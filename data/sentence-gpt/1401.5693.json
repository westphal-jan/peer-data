{"id": "1401.5693", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Sentence Compression as Tree Transduction", "abstract": "This paper presents a tree-to-tree transduction method for sentence compression. Our model is based on synchronous tree substitution grammar, a formalism that allows local distortion of the tree topology and can thus naturally capture structural mismatches. We describe an algorithm for decoding in this framework and show how the model can be trained discriminatively within a large margin framework. This model can be deployed in a highly parallel fashion. In addition, we show that it is necessary to be able to train parallel algorithms based on the structural mismatch, as the model does not have a hierarchical structure, which enables it to efficiently perform large tree-to-tree transformations.", "histories": [["v1", "Wed, 15 Jan 2014 05:19:15 GMT  (376kb)", "http://arxiv.org/abs/1401.5693v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["trevor anthony cohn", "mirella lapata"], "accepted": false, "id": "1401.5693"}, "pdf": {"name": "1401.5693.pdf", "metadata": {"source": "CRF", "title": "Sentence Compression as Tree Transduction", "authors": ["Trevor Cohn", "Mirella Lapata"], "emails": ["tcohn@inf.ed.ac.uk", "mlap@inf.ed.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Recent years have witnessed increasing interest in text-to-text generation methods for many natural language processing applications, ranging from text summarisation to question answering and machine translation. At the heart of these methods lies the ability to perform rewriting operations. For instance, text simplification identifies which phrases or sentences in a document will pose reading difficulty for a given user and substitutes them with simpler alternatives (Carroll, Minnen, Pearce, Canning, Devlin, & Tait, 1999; Chandrasekar & Srinivas, 1996). In question answering, questions are often paraphrased in order to achieve more flexible matching with potential answers (Lin & Pantel, 2001; Hermjakob, Echihabi, & Marcu, 2002). Another example concerns reformulating written language so as to render it more natural sounding for speech synthesis applications (Kaji, Okamoto, & Kurohashi, 2004).\nSentence compression is perhaps one of the most popular text-to-text rewriting methods. The aim is to produce a summary of a single sentence that retains the most important information while remaining grammatical (Jing, 2000). The appeal of sentence compression lies in its potential for summarization and more generally for document compression, e.g., for displaying text on small screens such as mobile phones or PDAs (Vandeghinste & Pan, 2004). Much of the current work in the literature focuses on a simplified formulation of the compression task which does not allow any rewriting operations other than word deletion. Given an input source sentence of words x = x1, x2, . . . , xn, a target compression y is formed by removing any subset of these words (Knight & Marcu, 2002).\nDespite being restricted to word deletion, the compression task remains challenging from a modeling perspective. Figure 1 illustrates a source sentence and its target compression taken from one of the compression corpora used in our experiments (see Section 5 for details). In this case, a hypothetical compression system must apply a series of rewrite rules in order\nc\u00a92009 AI Access Foundation. All rights reserved.\nto obtain the target, e.g., delete the leaf nodes exactly and and, delete the subtrees made it and which ones, and merge the subtrees corresponding to records and are involved. More concretely, the system must have access to rules like those shown in Figure 2. The rules are displayed as a pair of tree fragments where the left fragment corresponds to the source and the right to the target. For instance, rule (1) states that a wh-noun phrase (WHNP) consisting of an adverb (RB) and a wh-pronoun (WP) (e.g., exactly what) can be rewritten as just a wh-pronoun (without the adverb). There are two things to note here. First, syntactic information plays an important role, since deletion decisions are not limited to individual words but often span larger constituents. Secondly, there can be a large number of compression rules of varying granularity and complexity (see rule (5) in Figure 2).\nPrevious solutions to the compression problem have been cast mostly in a supervised learning setting (for unsupervised methods see Clarke & Lapata, 2008; Hori & Furui, 2004; Turner & Charniak, 2005). Sentence compression is often modeled in a generative framework\nwhere the aim is to estimate the joint probability P (x,y) of source sentence x having the target compression y (Knight & Marcu, 2002; Turner & Charniak, 2005; Galley & McKeown, 2007). These approaches essentially learn rewrite rules similar to those shown in Figure 4 from a parsed parallel corpus and subsequently use them to find the best compression from the set of all possible compressions for a given sentence. Other approaches model compression discriminatively as subtree deletion (Riezler, King, Crouch, & Zaenen, 2003; Nguyen, Horiguchi, Shimazu, & Ho, 2004; McDonald, 2006).\nDespite differences in formulation, existing models are specifically designed with sentence compression in mind and are not generally applicable to other tasks requiring more complex rewrite operations such as substitutions, insertions, or reordering. A common assumption underlying previous work is that the tree structures representing the source sentences and their target compressions are isomorphic, i.e., there exists an edge-preserving bijection between the nodes in the two trees. This assumption is valid for sentence compression but does not hold for other rewriting tasks. Consequently, sentence compression models are too restrictive; they cannot be readily adapted to other generation problems since they are not able to handle structural and lexical divergences. A related issue concerns the deletion operations themselves which often take place without considering the structure of the target compression (the goal is to generate a compressed string rather than the tree representing it). Without a syntax-based language model (Turner & Charniak, 2005) or an explicit generation mechanism that licenses tree transformations there is no guarantee that the compressions will have well-formed syntactic structures. And it will not be straightforward to process them for subsequent generation or analysis tasks.\nIn this paper we present a sentence compression model that is not deletion-specific but can account for ample rewrite operations and scales to other rewriting tasks. We formulate the compression problem as tree-to-tree rewriting using a synchronous grammar (with rules like those shown in Figure 2). Specifically, we adopt the synchronous tree substitution grammar (STSG) formalism (Eisner, 2003) which can model non-isomorphic tree structures while having efficient inference algorithms. We show how such a grammar can be induced from a parallel corpus and propose a discriminative model for the rewriting task which can be viewed as a weighted tree-to-tree transducer. Our learning framework makes use of the large margin algorithm put forward by Tsochantaridis, Joachims, Hofmann, and Altun (2005) which efficiently learns a prediction function to minimize a given loss function. We also develop an appropriate algorithm that can be used in both training (i.e., learning the model weights) and decoding (i.e., finding the most plausible compression under the model). Beyond sentence compression, we hope that some of the work described here might be of relevance to other tasks involving structural matching (see the discussion in Section 8).\nThe remainder of this paper is structured as follows. Section 2 provides an overview of related work. Section 3 presents the STSG framework and the compression model we employ in our experiments. Section 5 discusses our experimental set-up and Section 6 presents our results. Discussion of future work concludes the paper."}, {"heading": "2. Related Work", "text": "Synchronous context-free grammars (SCFGs, Aho & Ullman, 1969) are a generalization of the context-free grammar (CFG) formalism to simultaneously produce strings in two\nlanguages. They have been used extensively in syntax-based statistical MT. Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004).\nSentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression. Their model consists of two components: a language model P (y) whose role is to guarantee that the compression output is grammatical and a channel model P (x|y) capturing the probability that the source sentence x is an expansion of the target compression y. Their decoding algorithm searches for the compression y which maximizes P (y)P (x|y). The channel model is a stochastic SCFG, the rules of which are extracted from a parsed parallel corpus and their weights estimated using maximum likelihood. Galley and McKeown (2007) show how to obtain improved SCFG probability estimates through Markovization. Turner and Charniak (2005) note that SCFG rules are not expressive enough to model structurally complicated compressions as they are restricted to trees of depth 1. They remedy this by supplying their synchronous grammar with a set of more general \u201cspecial\u201d rules. For example, they allow rules of the form \u3008NP,NP\u3009 \u2192 \u3008[NP NP 1 CC NP 2 ],NP 1 \u3009 (boxed subscripts are added to distinguish between the two NPs).\nOur own work formulates sentence compression in the framework of synchronous treesubstitution grammar (STSG, Eisner, 2003). STSG allows to describe non-isomorphic tree pairs (the grammar rules can comprise trees of arbitrary depth) and is thus suited to textrewriting tasks which typically involve a number of local modifications to the input text. Especially if each modification can be described succinctly in terms of syntactic transformations, such as dropping an adjectival phrase or converting a passive verb phrase into active form. STSG is a restricted version of synchronous tree adjoining grammar (STAG, Shieber & Schabes, 1990) without an adjunction operation. STAG affords mild context sensitivity, however at increased cost of inference. SCFG and STSG are weakly equivalent, that is, their string languages are identical but they do not produce equivalent tree pairs. For example, in Figure 2, rules (1)\u2013(4) can be expressed as SCFG rules, but rule (5) cannot because both the source and target fragments are two level trees. In fact it would be impossible to describe the trees in Figure 1 using a SCFG. Our grammar rules are therefore more general than those obtained by Knight and Marcu (2002) and can account for more elaborate tree divergences. Moreover, by adopting a more expressive grammar formalism, we can naturally model syntactically complex compressions without having to specify additional rules (as in Turner & Charniak, 2005).\nA synchronous grammar will license a large number of compressions for a given source tree. Each grammar rule typically has a score from which the overall score of a compression y for sentence x can be derived. Previous work estimates these scores generatively as discussed above. We opt for a discriminative training procedure which allows for the incorporation of all manner of powerful features. We use the large margin technique proposed by Tsochantaridis et al. (2005). The framework is attractive in that it supports a configurable loss function, which describes the extent to which a predicted target tree differs from\nthe reference tree. By devising suitable loss functions the model can be straightforwardly adapted to text rewriting tasks besides sentence compression.\nMcDonald (2006) also presents a sentence compression model that uses a discriminative large margin algorithm. The model has a rich feature set defined over compression bigrams including parts of speech, parse trees, and dependency information, without however making explicit use of a synchronous grammar. Decoding in this model amounts to finding the combination of bigrams that maximize a scoring function defined over adjacent words in the compression and the intervening words which were dropped. Our model differs from McDonald\u2019s in two important respects. First, we can capture more complex tree transformations that go beyond bigram deletion. Being tree-based, our decoding algorithm is better able to preserve the grammaticality of the compressed output. Second, the treebased representation allows greater modeling flexibility, e.g., by defining a wide range of loss functions over the tree or its string yield. In contrast, McDonald can only define loss functions over the final compression.\nAlthough the bulk of research on sentence compression relies on parallel corpora for modeling purposes, a few approaches use no training data at all or a small amount. An example is in the work of Hori and Furui (2004), who propose a model for automatically transcribed spoken text. Their method scores candidate compressions using a language model combined with a significance score (indicating whether a word is topical or not), and a score representing the speech recognizer\u2019s confidence in transcribing a given word correctly. Despite being conceptually simple and knowledge lean, their model operates at the word level. Since it does not take syntax into account, it has no means of deleting constituents spanning several subtrees (e.g., relative clauses). Clarke and Lapata (2008) show that such unsupervised models can be greatly improved when linguistically motivated constraints are used during decoding."}, {"heading": "3. Problem Formulation", "text": "As mentioned earlier, we formulate sentence compression as a tree-to-tree rewriting problem using a weighted synchronous grammar coupled with a large margin training process. Our model learns from a parallel corpus of input (uncompressed) and output (compressed) pairs (x1,y1), . . . , (xn,yn) to predict a target labeled tree y from a source labeled tree x. We capture the dependency between x and y as a weighted STSG which we define in the following section. Section 3.2 discusses how we extract such a grammar from a parallel corpus. Each rule has a score, as does each ngram in the output tree, from which the overall score of a compression y for sentence x can be derived. We introduce our scoring function in Section 3.3 and explain our training algorithm in Section 3.5. In this framework decoding amounts to finding the best target tree licensed by the grammar given a source tree. We present a chart-based decoding algorithm in Section 3.4."}, {"heading": "3.1 Synchronous Grammar", "text": "A synchronous grammar defines a space of valid source and target tree pairs, much as a regular grammar defines a space of valid trees. Synchronous grammars can be treated as tree transducers by reasoning over the space of possible sister trees for a given tree, that is, all the trees which can be produced alongside the given tree. This is essentially a transducer\nAlgorithm 1 Generative process for creating a pair of trees. initialize source tree, x = RS initialize target tree, y = RT initialize stack of frontier nodes, F = [(RS , RT )] for all node pairs, (vS , vT ) \u2208 F do\nchoose a rule \u3008vS , vT \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009 rewrite node vS in x as \u03b1 rewrite node vT in y as \u03b3 for all variables, u \u2208 \u223c do\nfind aligned child nodes, (cS , cT ), under vS and vT corresponding to u push (cS , cT ) on to F\nend for end for x and y are now complete\nwhich takes a tree as input and produces a tree as output. The grammar rules specify the steps taken by the transducer in recursively mapping tree fragments of the input tree into fragments in the target tree. From the many families of synchronous grammars (see Section 2), we elect to use a synchronous tree-substitution grammar (STSG). This is one of the simpler formalisms, and consequently has efficient inference algorithms, while still being complex enough to model a rich suite of tree edit operations.\nA STSG is a 7-tuple, G = (NS ,NT ,\u2126S ,\u2126T , P,RS , RT ) where N are the non-terminals and \u2126 are the terminals, with the subscripts S and T indicating source and target respectively, P are the productions and RS \u2208 NS and RT \u2208 NT are the distinguished root symbols. Each production is a rewrite rule for two aligned non-terminals X \u2208 NS and Y \u2208 NT in the source and target:\n\u3008X,Y \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009 (1)\nwhere \u03b1 and \u03b3 are elementary trees rooted with the symbols X and Y respectively. Note that a synchronous context free grammar (SCFG) limits \u03b1 and \u03b3 to one level elementary trees, but is otherwise identical to a STSG, which imposes no such limits. Non-terminal leaves of the elementary trees are referred to as frontier nodes or variables. These are the points of recursion in the transductive process. A one-to-one alignment between the frontier nodes in \u03b1 and \u03b3 is specified by \u223c. The alignment can represent deletion (or insertion) by aligning a node with the special symbol, which indicates that the node is not present in the other tree. Only nodes in \u03b1 can be aligned to , which allows for subtrees to be deleted during transduction. We disallow the converse, -aligned nodes in \u03b3, as these would license unlimited insertion in the target tree, independently of the source tree. This capability would be of limited use for sentence compression, while also increasing the complexity of inference.\nThe grammar productions can be used in a generative setting to produce pairs of trees, or in a transductive setting to produce a target tree when given a source tree. Algorithms 1 and 2 present pseudo-code for both processes. The generative process (Algorithm 1) starts with the two root symbols and applies a production which rewrites the symbols as the production\u2019s elementary trees. These elementary trees might contain frontier nodes, in\nAlgorithm 2 The transduction of a source tree into a target tree. Require: complete source tree, x, with root node labeled RS\ninitialize target tree, y = RT initialize stack of frontier nodes, F = [(root(x), RT )] for all node pairs, (vS , vT ) \u2208 F do\nchoose a rule \u3008vS , vT \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009 where \u03b1 matches the sub-tree rooted at vS in x rewrite vT as \u03b3 in y for all variables, u \u2208 \u223c do\nfind aligned child nodes, (cS , cT ), under vS and vT corresponding to u push (cS , cT ) on to F\nend for end for y is now complete\nwhich case the aligned pairs of frontier nodes are pushed on to the stack, and later rewritten using another production. The process continues in a recursive fashion until the stack is empty \u2014 there are no frontier nodes remaining \u2014, at which point the two trees are complete. The sequence of rewrite rules are referred to as a derivation, from which the source and target tree can be recovered deterministically.\nOur model uses a STSG in a transductive setting, where the source tree is given and it is only the target tree that is generated. This necessitates a different rewriting process, as shown in Algorithm 2. We start with the source tree, and RT , the target root symbol, which is aligned to the root node of the source, denoted root(x). Then we choose a production to rewrite the pair of aligned non-terminals such that the production\u2019s source side, \u03b1, matches the source tree. The target symbol is then rewritten using \u03b3. For each variable in \u03b1 the matching node in the source and its corresponding leaf node in the target tree are pushed on to the stack for later processing.1 The process repeats until the stack is empty, and therefore the source tree has been covered. We now have a complete target tree. As before we use the term derivation to refer to this sequence of production applications. The target string is the yield of the target tree, given by reading the non-terminals from the tree in a left to right manner.\nLet us consider again the compression example from Figure 1. The tree editing rules from Figure 2 are encoded as STSG productions in Figure 3 (see rules (1)\u2013(5)). Production (1), reproduces tree pair (1) from Figure 2, production (2) tree pair (2), and so on. The notation in Figure 3 (primarily for space reasons) uses brackets ([]) to indicate constituent boundaries. Brackets surround a constituent\u2019s non-terminal and its child nodes, which can each be terminals, non-terminals or bracketed subtrees. The boxed indices are short-hand notation for the alignment, \u223c. For example, in rule (1) they specify that the two WP non-terminals are aligned and the RB node occurs only in the source tree (i.e., heads a deleted subtree). The grammar rules allow for differences in non-terminal category between the source and target, as seen in rules (2)\u2013(4). They also allow arbitrarily deep elementary trees,\n1. Special care must be taken for aligned variables. Nodes in \u03b1 which are -aligned signify that the source sub-tree below this point can be deleted without affecting the target tree. For this reason we can safely ignore source nodes deleted in this manner.\nas evidenced by rule (5) which is has trees of depth two. Rules (6)\u2013(12) complete the toy grammar which describes the tree pair from Figure 1. These rules copy parts of the source tree into the target, be they terminals (e.g., rule (6)) or internal nodes with children (e.g., rule (9)).\nFigure 4 shows how this grammar can be used to transduce the source tree into the target tree from Figure 1. The first few steps of the derivation are also shown graphically in Figure 5. We start with the source tree, and seek to transduce its root symbol into the target root symbol, denoted S/S. The first rule to be applied is rule (5) in Figure 3; its source side, \u03b1 = [S [S\u0304 WHNP S] [CC and] S\u0304], matches the root of source tree and it has the requisite target category, Y = S. The matching part of the source tree is rewritten using the rule\u2019s target elementary tree, \u03b3 = [S WHNP [S NP VP]]. The three three variables are now annotated to reflect the category transformations required for each node, WHNP/WHNP, S/NP and S\u0304/VP. The process now continues for the leftmost of these nodes, labeled WHNP/WHNP. Rule (1) (from Figure 3) is then applied, which deletes the node\u2019s left child, shown as RB/ , and retains its right child. The subsequent rule completes the transduction of the WHNP node by matching the string \u2018exactly \u2019. The algorithm continues to visit each variable node and finishes when there are no variable nodes remaining, resulting in the desired target tree."}, {"heading": "3.2 Grammar", "text": "The previous section outlined the STSG formalism we employ in our sentence compression model, save one important detail: the grammar itself. For example, we could obtain a\nsynchronous grammar by hand, automatically from a corpus, or by some combination. Our only requirement is that the grammar allows the source trees in the training set to be transduced into their corresponding target trees. For maximum generality, we devised an automatic method to extract a grammar from a parsed, word-aligned parallel compression corpus. The method maps the word alignment into a constituent level alignment between nodes in the source and target trees. Pairs of aligned subtrees are next generalized to create tree fragments (elementary trees) which form the rules of the grammar.\nThe first step of the algorithm is to find the constituent alignment, which we define as the set of source and target constituent pairs whose yields are aligned to one another under the word alignment. We base our approach on the alignment template method (Och & Ney, 2004), which uses word alignments to define alignments between ngrams (called phrases in the SMT literature). This method finds pairs of ngrams where at least one word in one of the ngrams is aligned to a word in the other, but no word in either ngram is aligned to a word outside the other ngram. In addition, we require that these ngrams are syntactic constituents. More formally, we define constituent alignment as:\nC = {(vS , vT ), (\u2203(s, t) \u2208 A \u2227 s \u2208 Y (vS) \u2227 t \u2208 Y (vT ))\u2227 (2) (@(s, t) \u2208 A \u2227 (s \u2208 Y (vS) Y t \u2208 Y (vT )))}\nwhere vS and vT are source and target tree nodes (subtrees), A = {(s, t)} is the set of word alignments (pairs of word-indices), Y (\u00b7) returns the yield span for a subtree (the minimum and maximum word index in its yield) and Y is the exclusive-or operator. Figure 6 shows\nthe word alignment and the constituent alignments that are licensed for the sentence pair from Figure 1.\nThe next step is to generalize the aligned subtree pairs by replacing aligned child subtrees with variable nodes. For example, in Figure 6 when we consider the pair of aligned subtrees [S\u0304 which ones are involved] and [VP are involved], we could extract the rule:\n\u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 [WHNP [WP which]] [S [NP [NNS ones] [VP [VBP are] [VP [VBN involved]]]]]], [VP [VBP are] [VP [VBN involved]]]\u3009 (3)\nHowever, this rule is very specific and consequently will not be very useful in a transduction model. In order for it to be applied, we must see the full S\u0304 subtree, which is highly unlikely to occur in another sentence. Ideally, we should generalize the rule so as to match many more source trees, and thereby allow transduction of previously unseen structures. In the example, the node pairs labeled (VP1, VP1), (VBP, VBP), (VP2, VP2) and (VBN, VBN) can all be generalized as these nodes are aligned constituents (subscripts added to distinguish\nbetween the two VP nodes). In addition, the nodes WHNP, WP, NP and NNS in the source are unaligned, and therefore can be generalized using -alignment to signify deletion. If we were to perform all possible generalizations for the above example,2 we would produce the rule:\n\u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 WHNP S 1 ], VP 1 \u3009 (4)\nThere are many other possible rules which can be extracted by applying different legal combinations of the generalizations (there are 45 in total for this example).\nAlgorithm 3 shows how the minimial (most general) rules are extracted.3 This results in the minimal set of synchronous rules which can describe each tree pair.4 These rules are minimal in the sense that they cannot be made smaller (e.g., by replacing a subtree with a variable) while still honoring the word-alignment. Figure 7 shows the resulting minimal set of synchronous rules for the example from Figure 6. As can be seen from the example, many of the rules extracted are overly general. Ideally, we would extract every rule with every legal combination of generalizations, however this leads to a massive number of rules \u2014 exponential in the size of the source tree. We address this problem by allowing a limited number of generalizations to be \u2018skipped\u2019 in the extraction process. This is equivalent to altering lines 4 and 7 in Algorithm 3 to first make a non-deterministic decision whether to match or ignore the match and continue descending the source tree. The recursion depth limits the number of matches that can be ignored in this way. For example, if we allow one\n2. Where some generalizations are mutually exclusive, we take the highest match in the trees. 3. The non-deterministic matching step in line 8 allows the matching of all options individually. This\nis implemented as a mutually recursive function which replicates the algorithm state to process each different match. 4. Algorithm 3 is an extension of Galley, Hopkins, Knight, and Marcu\u2019s (2004) technique for extracting a SCFG from a word-aligned corpus consisting of (tree, string) pairs.\nAlgorithm 3 extract(x,y, A): extracts minimal rules from constituent-aligned trees Require: source tree, x, target tree, y, and constituent-alignment, A\n1: initialize source and target sides of rule, \u03b1 = x, \u03b3 = y 2: initialize frontier alignment, \u223c= \u2205 3: for all nodes vS \u2208 \u03b1, top-down do 4: if vS is null-aligned then 5: \u223c\u2190\u223c \u222a(vS , ) 6: delete children of a 7: else if vS is aligned to some target node(s) then 8: choose target node, vT {non-deterministic choice} 9: call extract(vS , vT , A)\n10: \u223c\u2190\u223c \u222a(vS , vT ) 11: delete children of vS 12: delete children of vT 13: end if 14: end for 15: emit rule \u3008root(\u03b1), root(\u03b3)\u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009\nlevel of recursion when extracting rules from the (S\u0304, VP) pair from Figure 6, we get the additional rules:\n\u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 [WHNP WP ] S 1 ], VP 1 \u3009 \u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 WHNP [S NP VP 1 ]], VP 1 \u3009\nwhile at two levels of recursion, we also get:\n\u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 [WHNP [WP which]] S 1 ], VP 1 \u3009 \u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 [WHNP [WP which]] [S NP VP 1 ]], VP 1 \u3009 \u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 WHNP [S [NP NNS ] VP 1 ]], VP 1 \u3009 \u3008S\u0304,VP\u3009 \u2192 \u3008[S\u0304 WHNP [S NP [VP VBD 1 VP 2 ]]], [VBD 1 VBD 2 ]\u3009\nCompared to rule (4) we can see that the specialized rules above add useful structure and lexicalisation, but are still sufficiently abstract to generalize to new sentences, unlike rule (3). The number of rules is exponential in the recursion depth, but with fixed a depth it is polynomial in the size of the source tree fragment. We set the recursion depth to a small number (one or two) in our experiments.\nThere is no guarantee that the induced rules will have good coverage on unseen trees. Tree fragments containing previously unseen terminals or non-terminals, or even an unseen sequence of children for a parent non-terminal, cannot be matched by any grammar productions. In this case the transduction algorithm (Algorithm 2) will fail as it has no way of covering the source tree. However, the problem can be easily remedied by adding new rules to the grammar to allow the source tree to be fully covered.5 For each node in the\n5. There are alternative, equally valid, techniques for improving coverage which simplify the syntax trees. For example, this can be done explicitly by binarizing large productions (e.g., Petrov, Barrett, Thibaux, & Klein, 2006) or implicitly with a Markov grammar over grammar productions (e.g., Collins, 1999).\nsource tree, a rule is created to copy that node and its child nodes into the target tree. For example, if we see the fragment [NP DT JJ NN] in the source tree, we add the rule:\n\u3008NP,NP\u3009 \u2192 \u3008[NP DT 1 JJ 2 NN 3 ], [NP DT 1 JJ 2 NN 3 ]\u3009\nWith these rules, each source node is copied into the target tree, and therefore the transduction algorithm can trivially recreate the original tree. Of course, the other grammar rules can work in conjunction with the copying rules to produce other target trees.\nWhile the copy rules solve the coverage problem on unseen data, they do not solve the related problem of under-compression. This occurs when there are unseen CFG productions in the source tree and therefore the only applicable grammar rules are copy rules, which copy all child nodes into the target. None of the child subtrees can be deleted unless the parent node can itself deleted by a higher-level rule, in which case all the children are deleted. Clearly, it would add considerable modelling flexibility to be able to delete some, but not all, of the children. For this reason, we add explicit deletion rules for each source CFG production which allow subsets of the child nodes to be deleted in a linguistically plausible manner.\nThe deletion rules attempt to preserve the most important child nodes. We measure importance using the head-finding heuristic from Collins\u2019 parser (Appendix A, Collins, 1999). Collins\u2019 method finds the single head child of a CFG production using hand-coded tables for each non-terminal type. As we desire a set of child nodes, we run the algorithm to find all matches rather than stopping after the first match. The order in which each match is found is used as a ranking of the importance of each child. The ordered list of child nodes is then used to create synchronous rules which retain head 1, heads 1\u20132, . . . , all heads.\nFor the fragment [NP DT JJ NN], the heads are found in the following order (NN, DT, JJ). Therefore we create rules to retain children (NN); (DT, NN) and (DT, JJ, NN):\n\u3008NP,NP\u3009 \u2192 \u3008[NP DT JJ NN 1 ], [NP NN 1 ]\u3009 \u3008NP,NN\u3009 \u2192 \u3008[NP DT JJ NN 1 ], NN 1 \u3009 \u3008NP,NP\u3009 \u2192 \u3008[NP DT 1 JJ NN 2 ], [NP DT 1 NN 2 ]\u3009 \u3008NP,NP\u3009 \u2192 \u3008[NP DT 1 JJ 2 NN 3 ], [NP DT 1 JJ 2 NN 3 ]\u3009\nNote that when only one child remains, the rule is also produced without the parent node, as seen in the second rule above."}, {"heading": "3.3 Linear Model", "text": "While an STSG defines a transducer capable of mapping a source tree into many possible target trees, it is of little use without some kind of weighting towards grammatical trees which have been constructed using sensible STSG productions and which yield fluent compressed target sentences. Ideally the model would define a scoring function over target trees or strings, however we instead operate on derivations. In general, there may be many derivations which all produce the same target tree, a situation referred to as spurious ambiguity. To fully account for spurious ambiguity would require aggregating all derivations which produce the same target tree. This would break the polynomial-time dynamic program used for inference, rendering inference problem NP-complete (Knight, 1999). To this end, we define a scoring function over derivations:\nscore(d; w) = \u3008\u03a8(d),w\u3009 (5)\nwhere d is a derivation6 consisting of a sequence of rules, w are the model parameters, \u03a8 is a vector-valued feature function and the operator \u3008\u00b7, \u00b7\u3009 is the inner product. The parameters, w, are learned during training, described in Section 3.5.\nThe feature function, \u03a8, is defined as: \u03a8(d) = \u2211 r\u2208d \u03c6(r, source(d)) + \u2211 m\u2208ngrams(d) \u03c8(m, source(d)) (6)\nwhere r are the rules of a derivation, ngrams(d) are the ngrams in the yield of the target tree and \u03c6 is a feature function returning a vector of feature values for each rule. Note that the feature function has access to not only the rule, r, but also the source tree, source(d), as this is a conditional model and therefore doing so has no overhead in terms of modeling assumptions or the complexity of inference.\nIn the second summand in (6), m are the ngrams in the yield of the target tree and \u03c8 is a feature function over these ngrams. Traditional (weighted) synchronous grammars only allow features which decompose with the derivation (i.e., can be expressed using the first summand in (6)). However, this is a very limiting requirement, as the ngram features allow the modeling of local coherence and are commonly used in the sentence compression literature (Knight & Marcu, 2002; Turner & Charniak, 2005; Galley & McKeown, 2007;\n6. The derivation, d, fully specifies both the source, x = source(d), and the target tree, y = target(d).\nClarke & Lapata, 2008; Hori & Furui, 2004; McDonald, 2006). For instance, when deleting a sub-tree with left and right siblings, it is critical to know not only that the new siblings are in a grammatical configuration, but also that their yield still forms a coherent string. For this reason, we allow ngram features, specifically the conditional log-probability of an ngram language model. Unfortunately, this comes at a price as the ngram features significantly increase the complexity of inference used for training and decoding."}, {"heading": "3.4 Decoding", "text": "Decoding aims to find the best target tree licensed by the grammar given a source tree. As mentioned above, we deal with derivations in place of target trees. Decoding finds the maximizing derivation, d\u2217, of:\nd\u2217 = argmax d:source(d)=x score(d; w) (7)\nwhere x is the (given) source tree, source(d) extracts the source tree from the derivation d and score is defined in (5). The maximization is performed over the space of derivations for the given source tree, as defined by the transduction process shown in Algorithm 2.\nThe maximization problem in (7) is solved using the chart-based dynamic program shown in Algorithm 4. This extends earlier inference algorithms for weighted STSGs (Eisner, 2003) which assume that the scoring function must decompose with the derivation, i.e., features apply to rules but not to terminal ngrams. Relaxing this assumption leads to additional complications and increased time and space complexity. This is equivalent to using as our grammar the intersection between the original grammar and an ngram language model, as explained by Chiang (2007) in the context of string transduction with an SCFG.\nThe algorithm defines a chart, C, to record the best scoring (partial) target tree for each source node vS and with root non-terminal t. The back-pointers, B, record the maximizing rule and store pointers to the child chart cells filling each variable in the rule. The chart is also indexed by the n\u2212 1 terminals at the left and right edges of the target tree\u2019s yield to allow scoring of ngram features.7 The terminal ngrams provide sufficient context to evaluate ngram features overlapping the cell\u2019s boundary when the chart cell is combined in another rule application (this is the operation performed by the boundary-ngrams function on line 15). This is best illustrated with an example. Using trigram features, n = 3, if a node were rewritten as [NP the fast car] then we must store the ngram context (the fast, fast car) in its chart entry. Similarly [VP skidded to a halt] would have ngram context (skidded to, a halt). When applying a parent rule [S NP VP] which rewrites these two trees as adjacent siblings we need to find the ngrams on the boundary between the NP and VP. These can be easily retrieved from the two chart cells\u2019 contexts. We combine the right edge of the NP context, \u2018fast car\u2019, with the left edge of the VP context, \u2018skidded to\u2019, to get the two trigrams \u2018fast car skidded\u2019 and \u2018car skidded to\u2019. The other trigrams \u2014 \u2018the fast car\u2019, \u2018skidded to a\u2019 and \u2018to a halt\u2019 \u2014 will have already been evaluated in the child chart cells. The new combined S chart cell is now given the context (the fast, a halt) by taking the left and right\n7. Strictly speaking, only the terminals on the right edge are required for a compression model which would create the target string in a left-to-right manner. However, our algorithm is more general in that it allows reordering rules such as \u3008PP,PP\u3009 \u2192 \u3008[PP IN 1 NP 2 ], [PP NP 2 IN 1 ]\u3009. Such rules are required for most other text-rewriting tasks besides sentence compression.\nAlgorithm 4 Exact chart based decoding algorithm. Require: complete source tree, x, with root node labeled RS\n1: let C[v, t, l] \u2208 R be a chart representing the score of the best derivation transducing the tree rooted at v to a tree with root category t and ngram context l 2: let B[v, t, l] \u2208 (P,x \u00d7 NT \u00d7 L) be the corresponding back-pointers, each consisting of a production and the source node, target category and ngram context for each of the production\u2019s variables 3: initialize chart, C[\u2217, \u2217, \u2217] = \u2212\u221e 4: initialize back-pointers, B[\u2217, \u2217, \u2217] = none 5: for all source nodes, vS \u2208 x, bottom-up do 6: for all rules, r = \u3008vS , Y \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009 where \u03b1 matches the sub-tree rooted at vS do 7: let m be the target ngrams wholly contained in \u03b3 8: let features vector, \u03a8\u2190 \u03c6(r,x) + \u03c8(m,x) 9: let l be an empty ngram context 10: let score, q \u2190 0 11: for all variables, u \u2208 \u223c do 12: find source child node, cu, under vS corresponding to u 13: let tu be the non-terminal for target child node under \u03b3 corresponding to u 14: choose child chart entry, qu = C[cu, tu, lu] {non-deterministic choice of lu} 15: let m\u2190 boundary-ngrams(r, lu) 16: update features, \u03a8\u2190 \u03a8 + \u03c8(m,x) 17: update ngram context, l\u2190 merge-ngram-context(l, lu) 18: update score, q \u2190 q + qu 19: end for 20: update score, q \u2190 q + \u3008\u03a8,w\u3009 21: if q > C[vS , Y, l] then 22: update chart, C[vS , Y, l]\u2190 q 23: update back-pointers, B[vS , Y, l]\u2190 (r, {(cu, tu, lu)\u2200u}) 24: end if 25: end for 26: end for 27: find best root chart entry, l\u2217 \u2190 argmaxl C[root(x), RT , l] 28: create derivation, d, by traversing back-pointers from B[root(x), RT , l\u2217]\nedges of the two child cells. This merging process is performed by the merge-ngram-context function on line 17. Finally we add artificial root node to the target tree with n\u22121 artificial start terminals and one end terminal. This allows the ngram features to be applied over boundary ngrams at the beginning and end of the target string.\nThe decoding algorithm processes the source tree in a post-order traversal, finding the set of possible trees and their ngram contexts for each source node and inserting these into the chart. The rules which match the node are processed in lines 6\u201324. The feature vector, \u03a8, is calculated on the rule and the ngrams therein (line 8), and for ngrams bordering child cells filling the rule\u2019s variables (line 16). Note that the feature vector only includes those features specific to the rule and the boundary ngrams, but not those wholly contained in\nthe child cell. For this reason the score is the sum of the scores for each child cell (line 18) and the feature vector and the model weights (line 20). The new ngram context, l, is calculated by combining the rule\u2019s frontier and the ngram contexts of the child cells (line 17). Finally the chart entry for this node is updated if the score betters the previous value (lines 21\u201324).\nWhen choosing the child chart cell entry in line 14, there can be many different entries each with a different ngram context, lu. This affects the ngram features, \u03c8, and consequently the ngram context, l, and the score, q, for the rule. The non-determinism means that every combination of child chart entries are chosen for each variable, and these combinations are then evaluated and inserted into the chart. The number of combinations is the product of the number of child chart entries for each variable. This can be bounded by O(|TT |2(n\u22121)V ) where |TT | is the size of the target lexicon and V is the number of variables. Therefore the asymptotic time complexity of decoding is the O(SR|TT |2(n\u22121)V ) where S are the number of source nodes and R is the number of matching rules for each node. This high complexity clearly makes exact decoding infeasible, especially so when either n or V are large.\nWe adopt a popular approach in syntax-inspired machine translation to address this problem (Chiang, 2007). Firstly, we use a beam-search, which limits the number of different ngram contexts stored in each chart cell to a constant, W . This changes the base in the complexity term, leading to an improved O(SRW V ) but which is still exponential in the number of variables. In addition, we use Chiang\u2019s cube-pruning heuristic to further limit the number of combinations. Cube-pruning uses a heuristic scoring function which approximates the conditional log-probability from a ngram language model with the logprobability from a unigram model.8 This allows us to visit the combinations in best-first order under the heuristic scoring function until the beam is filled.The beam is then rescored using the correct scoring function. This can be done cheaply in O(WV ) time, leading to an overall time complexity of decoding to O(SRWV ). We refer the interested reader to the work of Chiang (2007) for further details."}, {"heading": "3.5 Training", "text": "We now turn to the problem of how derivations are scored in our model. For a given source tree, the space of sister target trees implied by the synchronous grammar is often very large, and the majority of these trees are ungrammatical or poor compressions. It is the job of the training algorithm to find weights such that the reference target trees have high scores and the many other target trees licensed by the grammar are given lower scores.\nAs explained in Section 3.3 we define a scoring function over derivations. This function was given in (5) and (7), and is reproduced below:\nf(d; w) = argmax d:source(d)=x \u3008w,\u03a8(d)\u3009 (8)\nEquation (8) finds the best scoring derivation, d, for a given source, x, under a linear model. Recall that y is a derivation which generates the source tree x and a target tree. The goal\n8. We use the conditional log-probability of an ngram language model as our only ngram feature. In order to use other ngram features, such as binary identity features for specific ngrams, it would first be advisable to construct an approximation which decomposes with the derivation for use in the cube-pruning heuristic.\nof the training procedure is to find a parameter vector w which satisfies the condition:\n\u2200i,\u2200d : source(d) = xi \u2227 d 6= di : \u3008w,\u03a8(di)\u2212\u03a8(d)\u3009 \u2265 0 (9)\nwhere xi,di are the ith training source tree and reference derivation. This condition states that for all training instances the reference derivation is at least as high scoring as any other derivations. Ideally, we would also like to know the extent to which a predicted target tree differs from the reference tree. For example, a compression that differs from the gold standard with respect to one or two words should be treated differently from a compression that bears no resemblance to it. Another important factor is the length of the compression. Compressions whose length is similar to the gold standard should be be preferable to longer or shorter output. A loss function \u2206(yi,y) quantifies the accuracy of prediction y with respect to the true output value yi.\nThere are a plethora of different discriminative training frameworks which can optimize a linear model. Possibilities include perceptron training (Collins, 2002), log-linear optimisation of the conditional log-likelihood (Berger, Pietra, & Pietra, 1996) and large margin methods. We base our training on Tsochantaridis et al.\u2019s (2005) framework for learning Support Vector Machines (SVMs) over structured output spaces, using the SVMstruct implementation.9 The framework supports a configurable loss function which is particularly appealing in the context of sentence compression and more generally text-to-text generation. It also has an efficient training algorithm and powerful regularization. The latter is is critical for discriminative models with large numbers of features, which would otherwise over-fit the training sample at the expense of generalization accuracy. We briefly summarize the approach below; for a more detailed description we refer the interested reader to the work of Tsochantaridis et al. (2005).\nTraditionally SVMs learn a linear classifier that separates two or more classes with the largest possible margin. Analogously, structured SVMs attempt to separate the correct structure from all other structures with a large margin. The learning objective for the structured SVM uses the soft-margin formulation which allows for errors in the training set via the slack variables, \u03bei:\nmin w,\u03be 1 2 ||w||2 + C n n\u2211 i=1 \u03bei, \u03bei \u2265 0 (10)\n\u2200i,\u2200d : source(d) = xi \u2227 y 6= di : \u3008w,\u03a8(di)\u2212\u03a8(d)\u3009 \u2265 \u2206(di,d)\u2212 \u03bei\nThe slack variables, \u03bei, are introduced here for each training example, xi and C is a constant that controls the trade-off between training error minimization and margin maximization. Note that slack variables are combined with the loss incurred in each of the linear constraints. This means that a high loss output must be separated by a larger margin than a low loss output, or have a much larger slack variable to satisfy the constraint. Alternatively, the loss function can be used to rescale the slack parameters, in which case the constraints in (10) are replaced with \u3008w,\u03a8(di) \u2212 \u03a8(d)\u3009 \u2265 1 \u2212 \u03bei\u2206(di,d) . Margin rescaling is theoretically less desirable as it is not scale invariant, and therefore requires the tuning of an additional hyperparameter compared to slack rescaling. However, empirical results show\n9. http://svmlight.joachims.org/svm_struct.html\nlittle difference between the two rescaling methods (Tsochantaridis et al., 2005). We use margin rescaling for the practical reason that it can be approximated more accurately than can slack rescaling by our chart based inference method.\nThe optimization problem in (10) is approximated using an algorithm proposed by Tsochantaridis et al. (2005). The algorithm finds a small set of constraints from the fullsized optimization problem that ensures a sufficiently accurate solution. Specifically, it constructs a nested sequence of successively tighter relaxation of the original problem using a (polynomial time) cutting plane algorithm. For each training instance, the algorithm keeps track of the selected constraints defining the current relaxation. Iterating through the training examples, it proceeds by finding the output that most radically violates a constraint. In our case, the optimization crucially relies on finding the derivation which is both high scoring and has high loss compared to the gold standard. This requires finding the maximizer of:\nH(d) = \u2206(d\u2217,d)\u2212 \u3008w,\u03a8(di)\u2212\u03a8(d)\u3009 (11)\nThe search for the maximizer of H(d) in (11) can be performed by the decoding algorithm presented in Section 3.4 with some extensions. Firstly, by expanding (11) to H(d) = \u2206(d\u2217,d)\u2212 \u3008\u03a8(di),w\u3009+ \u3008\u03a8(d),w\u3009 we can see that the second term is constant with respect to d, and thus does not influence the search. The decoding algorithm maximizes the last term, so all that remains is to include the loss function into the search process.\nLoss functions which decompose with the rules or target ngrams in the derivation, \u2206(d\u2217,d) = \u2211 r\u2208d \u2206R(d \u2217, r) + \u2211 n\u2208ngrams(d) \u2206N (d \u2217, n), can be easily integrated into the decoding algorithm. This is done by adding the partial loss, \u2206R(d\u2217, r) + \u2206N (d\u2217, n) to each rule\u2019s score in line 20 of Algorithm 4 (the ngrams are recovered from the ngram contexts in the same manner used to evaluate the ngram features).\nHowever, many of our loss functions do not decompose with the rules or the ngrams. In order to calculate these losses the chart must be stratified by the loss function\u2019s arguments (Joachims, 2005). For example, unigram precision measures the ratio of correctly predicted tokens to total predicted tokens and therefore its loss arguments are the pair of counts, (TP, FP ), for true and false positives. They are initialized to (0, 0) and are then updated for each rule used in a derivation. This equates to checking whether each target terminal is in the reference string and incrementing the relevant value. The chart is extended (stratified) to store the loss arguments in the same way that ngram contexts are stored for decoding. This means that a rule accessing a child chart cell can get multiple entries, each with different loss argument values as well as multiple ngram contexts (line 14 in Algorithm 4). The loss argument for a rule application is calculated from the rule itself and the loss arguments of its children. This is then stored in the chart and the back-pointer list (lines 22\u201323 in Algorithm 4). Although this loss can only be evaluated correctly for complete derivations, we also evaluate the loss on partial derivations as part of the cube-pruning heuristic. Losses with a large space of argument values will be more coarsely approximated by the beam search, which prunes the number of chart entries to a constant size. For this reason, we have focused mainly on simple loss functions which have a relatively small space of argument values, and also use a wide beam during the search (200 unique items or 500 items, whichever comes first).\nAlgorithm 5 Find the gold standard derivation for a pair of trees (i.e., alignment). Require: source tree, x, and target tree, y\n1: let C[vS , vT ] \u2208 R be a chart representing the maximum number of rules used to align nodes vS \u2208 x and vT \u2208 y 2: let B[vS , vT ] \u2208 (P,x\u00d7y) be the corresponding back-pointers, consisting of a production and a pair aligned nodes for each of the production\u2019s variables 3: initialize chart, C[\u2217, \u2217] = \u2212\u221e 4: initialize back-pointers, B[\u2217, \u2217] = none 5: for all source nodes, vS \u2208 x, bottom-up do 6: for all rules, r = \u3008vS , Y \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009 where \u03b1 matches the sub-tree rooted at vS do 7: for all target nodes, vT \u2208 y, matching \u03b3 do 8: let rule count, j \u2190 1 9: for all variables, u \u2208 \u223c do\n10: find aligned child nodes, (cS , cT ), under vS and vT corresponding to u 11: update rule count, j \u2190 j + C[cS , cT ] 12: end for 13: if n greater than previous value in chart then 14: update chart, C[vS , vT ]\u2190 j 15: update back-pointers, B[vS , vT ]\u2190 (r, {(cS , cT )\u2200u}) 16: end if 17: end for 18: end for 19: end for 20: if C[root(x), root(y)] 6= \u2212\u221e then 21: success; create derivation by traversing back-pointers from B[root(x), root(y)] 22: end if\nIn our discussion so far we have assumed that we are given a gold standard derivation, yi glossing over the issue of how to find it. Spurious ambiguity in the grammar means that there are often many derivations linking the source and target, none of which are clearly \u2018correct\u2019. We select the derivation using the maximum number of rules, each of which will be small, and therefore should provide maximum generality.10 This is found using Algorithm 5, a chart-based dynamic program similar to the alignment algorithm for inverse transduction grammars (Wu, 1997). The algorithm has time complexity O(S2R) where S is the size of the larger of the two trees and R is the number of rules which can match a node."}, {"heading": "3.6 Loss Functions", "text": "The training algorithm described above is highly modular and in theory can support a wide range of loss functions. There is no widely accepted evaluation metric for text compression. A zero-one loss would be straightforward to define but inappropriate for our problem,\n10. We also experimented with other heuristics, including choosing the derivation at random and selecting the derivation with the maximum or minimum score under the model (all using the same search algorithm but with a different objective). Of these, only the maximum scoring derivation was competitive with the maximum rules heuristic.\nas it would always penalize target derivations that differ even slightly from the reference derivation. Ideally, we would like a loss with a wider scoring range that can discriminate between derivations that differ from the reference. Some of these may be good compressions whereas others may be entirely ungrammatical. For this reason we have developed a range of loss functions which draw inspiration from various metrics used for evaluating text-to-text rewriting tasks such as summarization and machine translation.\nLoss functions are defined over derivations and can look at any item accessible including tokens, ngrams and CFG rules. Our first class of loss functions calculates the Hamming distance between unordered bags of items. It measures the number of predicted items that did not appear in the reference, along with a penalty for short output:\n\u2206hamming(d\u2217,d) = FP + max (l \u2212 (TP + FP ), 0) (12)\nwhere TP and FP are the number of true and false positives, respectively, when comparing the predicted target, dT , with the reference, d\u2217T , and l is the length of the reference. We include the second term to penalize overly short output as otherwise predicting very little or nothing would incur no penalty.\nWe have created three instantiations of the loss function in (12) over: 1) tokens, 2) ngrams (n \u2264 3), and 3) CFG productions. In each case, the loss argument space is quadratic in the size of the source tree. Our Hamming ngram loss is an attempt at defining a loss function similar to BLEU (Papineni, Roukos, Ward, & Zhu, 2002). The latter is defined over documents rather than individual sentences, and is thus not directly applicable to our problem. Now, since these losses all operate on unordered bags they may reward erroneous predictions, for example, a permutation of the reference tokens will have zero token-loss. This is less of a problem for the CFG and ngram losses whose items overlap, thereby encoding a partial order. Another problem with the loss functions just described is that they do not penalize multiply predicting an item that occurred only once in the reference. This could be a problem for function words which are common in most sentences.\nTherefore we developed two additional loss functions which take multiple predictions into account. The first measures the edit distance \u2014 the number of insertions and deletions \u2014 between the predicted and the reference compressions, both as bags-of-tokens. In contrast to the previous loss functions, it requires the true positive counts to be clipped to the number of occurrences of each type in the reference. The edit distance is given by:\n\u2206edit(d\u2217,d) = p+ r \u2212 2 \u2211 i min(pi, qi) (13)\nwhere p and q denote the number of target tokens in the predicted tree, target(d), and reference, y\u2217 = target(d\u2217), respectively, and pi and qi are the counts for type i. The loss arguments for the edit distance consist of a vector of counts for each item type in the reference, {pi,\u2200i}. The space of possible values is exponential in the size of the source tree, compared to quadratic for the Hamming losses. Consequently, we expect beam search to result in many more search errors when using the edit distance loss.\nOur last loss function is the F1 measure, a harmonic mean between precision and recall, measured over bags-of-tokens. As with the edit distance, its calculation requires the counts to be clipped to the number of occurrences of each terminal type in the reference. We\nRef: [S [WHNP [WP what]] [S [NP [NNS records]] [VP [VBP are] [VP [VBN involved]]]]] Pred: [S [WHNP [WP what]] [S [NP [NNS ones]] [VP [VBP are] [VBN involved]]]]\ntherefore use the same loss arguments for its calculation. The F1 loss is given by:\n\u2206F1(d \u2217,d) = 1\u2212 2\u00d7 precision\u00d7 recall\nprecision+ recall (14)\nwhere precision = P imin(pi,qi) p and recall = P imin(pi,qi)\nq . As F1 shares the same arguments with the edit distance loss, it also has the same exponential space of loss argument values and will consequently be subject to severe pruning during the beam search used in training.\nTo illustrate the above loss functions, we present an example in Table 1. Here, the prediction (Pred) and reference (Ref) have the same length (4 tokens), identical syntactic structure, but differ by one word (ones versus records). Correspondingly, there are three correct tokens and one incorrect, which forms the arguments for the token Hamming loss, resulting in a loss of 1/4. The ngram loss is measured for n \u2264 3 and the start and end of the string are padded with special symbols to allow evaluation of the boundary ngrams. The CFG loss records only one incorrect CFG production (the preterminal [NNS ones]) from the total of nine productions. The last two losses use the same arguments: a vector with values for the counts of each reference type. The first four cells correspond to what, records, are and involved, the last cell records all other types. For the example, the edit distance is two (one deletion and one insertion) while the F1 loss is 1/4 (precision and recall are both 3/4)."}, {"heading": "4. Features", "text": "Our feature space is defined over source trees, x, and target derivations, d. We devised two broad classes of features, applying to grammar rules and to ngrams of target terminals. We defined only a single ngram feature, the conditional log-probability of a trigram language model. This was trained on the BNC (100 million words) using the SRI Language Modeling toolkit (Stolcke, 2002), with modified Kneser-Ney smoothing.\nFor each rule \u3008X,Y \u3009 \u2192 \u3008\u03b1, \u03b3,\u223c\u3009, we extract features according to the templates detailed below. Our templates give rise to binary indicator features, except where explicitly stated. These features perform a boolean test, returning value 1 when the test succeeds and 0 otherwise. An example rule and its corresponding features are shown in Table 2.\nType: Whether the rule was extracted from the training set, created as a copy rule and/or created as a delete rule. This allows the model to learn a preference for each of the three sources of grammar rules (see row Type in Table 2)\nRoot: The root categories of the source, X, and target, Y , and their conjunction, X \u2227 Y (see rows Root in Table 2).\nIdentity: The source side, \u03b1, target side, \u03b3, and the full rule, (\u03b1, \u03b3,\u223c). This allows the model to learn weights on individual rules or those sharing an elementary tree. Another feature checks if the rule\u2019s source and target elementary trees are identical, \u03b1 = \u03b3 (see rows Identity in Table 2).\nUnlexicalised Identity: The identity feature templates above are replicated for unlexicalised elementary trees, i.e., with the terminals removed from their frontiers (see rows UnlexId in Table 2).\nRule count: This feature is always 1, allowing the model to count the number of rules used in a derivation (see row Rule count in Table 2).\nWord count: Counts the number of terminals in \u03b3, allowing a global preference for shorter or longer output. Additionally, we record the number of terminals in the source tree, which can be used with the target terminal count to find the number of deleted terminals (see rows Word count in Table 2).\nYield: These features compare the terminal yield of the source, Y (\u03b1), and target, Y (\u03b3). The first feature checks the identity of two sequences, Y (\u03b1) \u2227 Y (\u03b3). We use identity features for each terminal in both yields, and for each terminal only in the source (see rows Yield in Table 2). We also replicate these feature templates for the sequence of non-terminals on the frontier (pre-terminals or variable non-terminals).\nLength: Records the difference in the lengths of the frontiers of \u03b1 and \u03b3, and whether the target\u2019s frontier is shorter than that of the source (see rows Length in Table 2).\nThe features listed above are defined for all the rules in the grammar. This includes the copy and delete rules, as described in Section 3.2, which were added to address the problem of unseen words or productions in the source trees at test time. Many of these rules can not be applied to the training set, but will receive some weight because they share features with rules that can be used in training. However, in training the model learns to disprefer these coverage rules as they are unnecessary to model the training set, which can be described perfectly using the extracted transduction rules. Our dual use of the training set for grammar extraction and parameter estimation results in a bias against the coverage rules. The bias could be addressed by extracting the grammar from a separate corpus, in which case the coverage rules would then be useful in modeling both the training set and the testing sets. However, this solution has its own problems, namely that many of the target trees in the training may not longer be reachable. This bias and its possible solutions is an interesting research problem and deserves further work."}, {"heading": "5. Experimental Set-up", "text": "In this section we present our experimental set-up for assessing the performance of the sentence compression model described above. We give details of the corpora used, briefly introduce McDonald\u2019s (2006) model used for comparison with our approach, and explain how system output was evaluated."}, {"heading": "5.1 Corpora", "text": "We evaluated our system on three publicly available corpora. The first is the Ziff-Davis corpus, a popular choice in the sentence compression literature. The corpus originates from a collection of news articles on computer products. It was created automatically by matching sentences that occur in an article with sentences that occur in an abstract (Knight & Marcu, 2002). The other two corpora11 were created manually; annotators were asked to produce target compressions by deleting extraneous words from the source without changing the word order (Clarke & Lapata, 2008). One corpus was sampled from written sources,\n11. Available from http://homepages.inf.ed.ac.uk/s0460084/data/.\nthe British National Corpus (BNC) and the American News Text corpus, whereas the other was created from manually transcribed broadcast news stories. We will henceforth refer to these two corpora as CLwritten and CLspoken, respectively. The sizes of these three corpora are shown in Table 3.\nThese three corpora pose different challenges to a hypothetical sentence compression system. Firstly, they are representative of different domains and text genres. Secondly, they have different compression requirements. The Ziff-Davis corpus is more aggressively compressed in comparison to CLspoken and CLwritten (Clarke & Lapata, 2008). As CLspoken is a speech corpus, it often contains incomplete and ungrammatical utterances and speech artefacts such as disfluencies, false starts and hesitations. Its utterances have varying lengths, some are very wordy whereas others cannot be reduced any further. This means that a compression system should leave some sentences uncompressed. Finally, we should note the CLwritten has on average longer sentences than Ziff-Davis or CLspoken. Parsers are more likely to make mistakes on long sentences which could potentially be problematic for syntax-based systems like the one presented here.\nAlthough our model is capable of performing any editing operation, such as reordering or substitution, it will not learn to do so from the training corpora. These corpora contain only deletions, and therefore the model will not learn transduction rules encoding, e.g., reordering. Instead the rules encode only the deleting and inserting terminals and restructuring internal nodes of the syntax tree. However, the model is capable general text rewriting, and given the appropriate training set will learn to perform these additional edits. This is demonstrated by our recent results from adapting the model to abstractive compression (Cohn & Lapata, 2008), where any edit is permitted, not just deletion.\nOur experiments on CLspoken and CLwritten followed Clarke and Lapata\u2019s (2008) partition of training, test, and development sets. The partition sizes are shown in Table 3. In the case of the Ziff-Davis corpus, Knight and Marcu (2002) had not defined a development set. Therefore we randomly selected (and held-out) 32 sentence pairs from their training set to form our development set."}, {"heading": "5.2 Comparison with State-of-the-Art", "text": "We evaluated our results against McDonald\u2019s (2006) discriminative model. In this approach, sentence compression is formalized as a classification task: pairs of words from the source sentence are classified as being adjacent or not in the target compression. Let x = x1, . . . , xN denote a source sentence with a target compression y = y1, . . . , yM where each yi occurs in x. The function L(yi) \u2208 {1 . . . N} maps word yi the target to the index of the word in\nthe source (subject to the constraint that L(yi) < L(yi+1)). McDonald defines the score of a compression y for a sentence x as the dot product between a high dimensional feature representation, f , over bigrams and a corresponding weight vector, w,\nscore(x,y; w) = M\u2211 i=2 \u3008w, f(x, L(yj\u22121), L(yj))\u3009 (15)\nDecoding in this framework amounts to finding the combination of bigrams that maximize the scoring function in (15). The maximization is solved using a semi-Markov Viterbi algorithm (McDonald, 2006).\nThe model parameters are estimated using the Margin Infused Relaxed Algorithm (MIRA Crammer & Singer, 2003), a discriminative large-margin online learning technique. McDonald (2006) uses a similar loss function to our Hamming loss (see (12)) but without an explicit length penalty. This loss function counts the number of words falsely retained or dropped in the predicted target relative to the reference. McDonald employs a rich feature set defined over words, parts of speech, phrase structure trees, and dependencies. These are gathered over adjacent words in the compression and the words which were dropped.\nClarke and Lapata (2008) reformulate McDonald\u2019s (2006) model in the context of integer linear programming (ILP) and augment it with constraints ensuring that the compressed output is grammatically and semantically well formed. For example, if the target sentence has negation, this must be included in the compression; If the source verb has a subject, this must also be retained in the compression. They generate and solve an ILP for every source sentence using the branch-and-bound algorithm. Since they obtain performance improvements over McDonald\u2019s model on several corpora, we also use it for comparison against our model.\nTo summarize, we believe that McDonald\u2019s (2006) model is a good basis for comparison for several reasons. First, it is has good performance, and can be treated as a state-of-theart model. Secondly, it is similar to our model in many respects \u2013 its training algorithm and feature space \u2013 but differs in one very important respect: compression is performed on strings and not trees. McDonald\u2019s system does make use of syntax trees, but only peripherally via the feature set. In contrast, the syntax tree is an integral part of our model."}, {"heading": "5.3 Evaluation", "text": "In line with previous work we assessed our model\u2019s output by eliciting human judgments. Following Knight and Marcu (2002), we conducted two separate experiments. In the first experiment participants were presented with a source sentence and its target compression and asked to rate how well the compression preserved the most important information from the source sentence. In the second experiment, they were asked to rate the grammaticality of the compressed outputs. In both cases they used a five point rating scale where a high number indicates better performance. We randomly selected 20 sentences from the test portion of each corpus. These sentences were compressed automatically by our system and McDonald\u2019s (2006) system. We also included gold standard compressions. Our materials thus consisted of 180 (20 \u00d7 3 \u00d7 3) source-target sentences. A Latin square design ensured that subjects did not see two different compressions of the same sentence. We collected\nratings from 30 unpaid volunteers, all self reported native English speakers. Both studies were conducted over the Internet using WebExp,12 a software package for running Internetbased experiments.\nWe also report results using F1 computed over grammatical relations (Riezler et al., 2003). Although F1 conflates grammaticality and importance into a single score, it nevertheless has been shown to correlate reliably with human judgments (Clarke & Lapata, 2006). Furthermore, it can be usefully employed during development for feature engineering and parameter optimization experiments. We measured F1 over directed and labeled dependency relations. For all models the compressed output was parsed using the RASP dependency parser (Briscoe & Carroll, 2002). Note that we could extract dependencies directly from the output of our model since it generates trees in addition to strings. However, we refrained from doing this in order to compare all models on an equal footing."}, {"heading": "6. Results", "text": "The framework presented in Section 3 is quite flexible. Depending on the grammar extraction strategy, choice of features, and loss function, different classes of models can be derived. Before presenting our results on the test set we discuss the specific model employed in our experiments and explain how its parameters were instantiated."}, {"heading": "6.1 Model Selection", "text": "All our parameter tuning and model selection experiments were conducted on the development set of the CLspoken corpus. We obtained syntactic analyses for source and target sentences with Bikel\u2019s (2002) parser. The corpus was automatically aligned using an algorithm which finds the set of deletions which transform the source into the target. This is equivalent to the minimum edit distance script when only deletion operations are permitted.\nAs expected, the predicted parse trees contained a number of errors, although we did not have gold standard trees with which to quantify this error or its effect on prediction output. We did notice, however, that errors in the source trees in the test set did not always negatively affect the performance of the model. In many instances the model was able to recover from these errors and still produce good output compressions. Of these recoveries, most cases involved either deleting the erroneous structure or entirely preserving it. While this often resulted in a poor output tree, the string yield was acceptable in most cases. Less commonly, the model corrected the errors in the source using tree transformation rules. These rules were acquired from the training set where there were errors in the source tree but not in the test tree. For example, one transformation allows a prepositional phrase to be moved from a high VP attachment to an object NP attachment.\nWe obtained a synchronous tree substitution grammar from the CLspoken corpus using the method described in Section 3.2. We extracted all maximally general synchronous rules. These were complemented with specified rules allowing recursion up to one ancestor for any given node.13 Grammar rules were represented by the features described in Section 4. An important parameter in our modeling framework is the choice of loss function. We\n12. See http://www.webexp.info/. 13. Rules were pruned so as to have no more than 5 variables and 15 nodes.\nevaluated the loss functions presented in Section 3.6 as follows. We performed a grid search for the hyper-parameters (a regularization parameter and a feature scaling parameter, which balances the magnitude of the feature vectors with the scale of the loss function)14 which minimized the relevant loss on the development set, and used the corresponding system output. The gold standard derivation was selected using the maximum number of rules heuristic, as described in Section 3.5. The beam was limited to 100 unique items or 200 items in total. The grammar was filtered to allow no more than 50 target elementary trees for every source elementary tree.\nWe next asked two human judges to rate on a scale of 1 to 5 the system\u2019s compressions when optimized for the different loss functions. To get an idea of the quality of the output we also included human-authored reference compressions. Sentences given high numbers were both grammatical and preserved the most important information. The mean ratings are shown in Table 4. As can be seen the differences among the losses are not very large, and the standard deviation is high. The Hamming loss over tokens performed best with a mean rating of 3.38, closely followed by the edit distance (3.30). We chose the former over the latter as it is less coarsely approximated during search. All subsequent experiments report results using the token-based Hamming loss.\nWe also wanted to investigate how the synchronous grammar influences performance. The default system described above used general rules together with specialized rules where the recursion depth was limited to one. We also experimented with a grammar that uses specialised rules with a maximum recursion depth of two and a grammar that uses solely the maximally general rules. In Table 5 we report the average compression rate, relations-based F1 and the Hamming loss over tokens for these different grammars. We see that adding the specified rules allows for better F1 (and loss) despite the fact that the search space remains the same. We observe a slight degradation in performance moving to depth \u2264 2 rules. This is probably due to the increase in spurious ambiguity affecting search quality, and also allowing greater overfitting of the training data. The number of transduction rules in the grammar also grows substantially with the increased depth \u2013 from 20,764 for the maximally general extraction technique to 33,430 and 62,116 for specified rules with depth\n14. We found that setting the regularization parameter C = 0.01 and the scaling parameter to 1 generally yields good performance across loss functions.\n\u2264 1 and \u2264 2, respectively. The growth in grammar size is exponential in the specification depth and therefore only small values should be used.\nWe also inspected the rules obtained with the maximally general extraction technique to better assess how our rules differ from those obtained from a vanilla SCFG (see Knight & Marcu, 2002). Many of these rules (12%) have deeper structure and therefore would not be licensed by an SCFG. This is due to structural divergences between the source and target syntax trees in the training set. A further 13% of the rules describe a change of syntactic category (X 6= Y ), and therefore only the remaining 76% of the rules would be allowable in Knight and Marcu\u2019s transducer. The proportion of SCFG rules decreases substantially as the rule specification depth is increased.\nRecall from Section 3.3 that our scoring function is defined over derivations rather than target trees or strings, and that we treat the derivation using the maximum number of rules as the gold standard derivation. As a sanity check, we also experimented with selecting the derivation with the maximum score under the model. The results in Table 5 indicate that the latter strategy is not as effective as selecting the derivation with the maximum number of rules. Again we conjecture this is due to overfitting. As the training data is used to extract the grammar, the derivations with the maximum score may consist of rules with rare features which model the data well but do not generalize to unseen instances.\nFinally, we conducted a feature ablation study to assess which features are more useful to our task. We were particularly interested to see if the ngram features would bring any benefit, especially since they increase computational complexity during decoding and training. We experimented with a unigram, bigram, and trigram language model. Note that the unigram language model is not as computationally expensive as the other two models because there is no need to record ngram contexts in the chart. As shown in Table 5, the unigram language model is substantially worse than the bigram and trigram which deliver similar performances. We also examined the impact of the other features by grouping them into two broad classes, those defined over rules and those defined over tokens. Our aim was to see whether the underlying grammar (represented by rule-based features) contributes\nto better compression output. The results in Table 5 reveal that the two feature groups perform comparably. However, the model using only token-based features tends to compress less. These features are highly lexicalized, and the model is not able to generalize well on unseen data. In conclusion, the full feature set does better on all counts than the two ablation sets, with a better compression rate.\nThe results reported have all been measured over string output. This was done by first stripping the tree structure from the compression output, reparsing, extracting dependency relations and finally comparing to the dependency relations in the reference. However, we may wish to measure the quality of the trees themselves, not just their string yield. A simple way to measure this15 would be to extract dependency relations directly from the phrase-structure tree output.16 Compared to dependencies extracted from the predicted parses using Bikel\u2019s (2002) parser on the output string, we observe that the relation F1 score increases uniformly for all tasks, by between 2.50% and 4.15% absolute. Therefore the system\u2019s tree output better encodes the syntactic dependencies than the tree resulting from re-parsing the string output. If the system is part of a NLP pipeline, and its output is destined for down-stream processing, then having an accurate syntax tree is extremely important. This is also true for related tasks where the desired output is a tree, e.g., semantic parsing."}, {"heading": "7. Model Comparison", "text": "In this section we present our results on the test set using the best performing model from the previous section. This model uses a grammar with unlexicalized and lexicalized rules (recursion depth 1), a Hamming loss based on tokens, and all the features from Section 4. The model was trained separately on each corpus (training portion). We first discuss our results using relations F1 and then move on to the human study.\nTable 6 illustrates the performance of our model (Transducer1) on CLspoken, CLwritten, and Ziff Davis. We also report results on the same corpora using McDonald\u2019s (2006) model (McDonald) and the improved version (Clarke ILP) put forward by Clarke and Lapata (2008). We also present the compression rate for each system and the reference gold standard. In all cases our tree transducer model outperforms McDonald\u2019s original model and the improved ILP-based version.\nNevertheless, it may be argued that our model has an unfair advantage here since it tends to compress less than the other models, and is therefore less likely to make many mistakes. To ensure that this is not the case, we created a version of our model with a compression rate similar to McDonald. This can be done relatively straightforwardly by manipulating the length penalty of the Hamming loss. The smaller the penalty the more words the model will tend to drop. Therefore, we varied the length penalty (and hyper-parameters) on the development set in order to obtain a compression rate similar to\n15. We could alternatively measure other tree metrics, such as tree edit distance. However, the standard measures used in parser evaluation (e.g., EVALB) would not be suitable, as they assume that the parse yield is fixed. In our case the reference target string is often different to the system\u2019s output. 16. We extract dependency relations with the conversion tool from the CoNLL 2007 shared task, available at http://nlp.cs.lth.se/pennconverter/.\nMcDonald.17 This model was then applied to the test set and its performance is shown in Table 6 as Transducer2. We refrained from doing this on Ziff-Davis, since our original transducer obtained a compression rate comparable to McDonald (67.45 vs. 66.26). As can be seen, Transducer2 yields a better F1 on CLspoken and CLwritten. The differences in F1 are statistically significant using the the Wilcoxon test (p < 0.01). Transducer1 numerically outperforms McDonald on Ziff-Davis, however the difference is not significant (the Ziff-Davis test set consists solely of 32 sentences).\nWe next consider the results of our judgment elicitation study which assesses in more detail the quality of the generated compressions. Recall that our participants judge compressed output on two dimensions, grammaticality and importance. We compared the output of our system (Transducer2 on CLspoken and CLwritten and Transducer1 on Ziff-Davis) against the output of McDonald (2006) and the reference gold standard. Table 7 illustrates examples of the compressions our participants saw.\n17. We matched the compression rate of McDonald by scaling the length penalty by 0.50 and 0.25 for the CLwritten and CLspoken corpora, respectively. Another way to control the compression rate would be to modify our chart-based decoder in a fashion similar to McDonald (2006). However, we leave this to future work.\nTable 8 shows the mean ratings18 for each system (and the reference) on CLspoken, CLwritten, and Ziff-Davis. We carried out an Analysis of Variance (Anova) to examine the effect of system type (McDonald, Transducer, Reference) on the compression ratings. The Anova revealed a reliable effect on all three corpora. We used post-hoc Tukey tests to examine whether the mean ratings for each system differed significantly (p < 0.01). On the CLspoken corpus the Transducer is perceived as significantly better than McDonald, both in terms of grammaticality and importance. We obtain the same result for the CLwritten corpus. The two systems achieve similar performances on Ziff-Davis (the grammaticality and importance score do not differ significantly). Ziff-Davis seems to be a less challenging corpus than CLspoken or CLwritten and less likely to highlight differences among systems. For example, Turner and Charniak (2005) present several variants of the noisy-channel model, all of which achieve compressions of similar quality on Ziff-Davis (grammaticality ratings varied by only \u00b10.13 and informativeness ratings \u00b10.31 in their human evaluation). In most cases the Transducer and McDonald yield significantly\n18. All statistical tests reported subsequently were done using the mean ratings.\nworse performance than the Reference, save one exception. On the CLspoken corpus, there is no significant difference between the Transducer and the gold standard.\nThese results indicate that our highly expressive framework is a good model for sentence compression. Under several experimental conditions, across different domains, we obtain better performance than previous work. Importantly, the model described here is not compression-specific, it could be easily adapted to other tasks, corpora or languages (for which syntactic analysis tools are available). Being supervised, the model learns to fit the compression rate of the training data. In this sense, it is somewhat inflexible as it cannot easily adapt to a specific rate given by a user or imposed by an application (e.g., when displaying text on small screens). Nevertheless, compression rate can be indirectly manipulated by adopting loss functions that encourage or discourage compression or directly during decoding by stratifying the chart for length (McDonald, 2006)."}, {"heading": "8. Conclusions", "text": "In this paper we have formulated sentence compression as a tree-to-tree rewriting task.19 We developed a system that licenses the space of all possible rewrites using a tree substitution grammar. Each grammar rule is assigned a weight which is learned discriminatively within a large margin model (Tsochantaridis et al., 2005). A specialized algorithm is used to learn the model weights and find the best scoring compression under the model. We argue\n19. The source code is freely available from http://homepages.inf.ed.ac.uk/tcohn/t3.\nthat the proposed framework is appealing for several reasons. The synchronous grammar provides expressive power to capture rewrite operations that go beyond word deletion such as reordering, changes in non-terminal categories and lexical substitution. Since it is not deletion-specific, the model could be ported to other rewriting tasks (see Cohn & Lapata, 2008, for an example) without the overhead of devising new algorithms for decoding or training. Moreover, the discriminative nature of the learning algorithm allows for the incorporation of all manner of powerful features. The rich feature space in conjunction with the choice of an appropriate loss function afford greater flexibility in fitting the empirical data for different domains or tasks.\nWe evaluated our model on three compression corpora (CLspoken, CLwritten, and ZiffDavis) and showed that in most cases it yields results superior to state-of-the-art (McDonald, 2006). Our experiments were also designed to assess several aspects of the proposed framework such as the complexity of the synchronous grammar, the choice of loss function, the effect of various features, and the quality of the generated tree output. We observed performance improvements by allowing maximally general grammar rules to be specified once, producing larger and more lexicalized rules. This concurs with Galley and McKeown (2007) who also find that lexicalization yields better compression output. The choice of loss function appears to have less of an effect. We devised three classes of loss functions based on Hamming distance, Edit distance and F1 score. Overall, the simple token-based Hamming loss achieved the best results. We conjecture that this is due to its simplicity \u2013 it can be evaluated more precisely than many of the other loss functions and isn\u2019t affected by poor parser output. Our feature ablation study revealed that ngram features are beneficial, mirroring a similar finding in the machine translation literature (Chiang, 2007). Finally, we found that the trees created by our generation algorithm are more accurate compared to the output of a parser applied to the string output. This augurs well for use in a cascaded NLP pipeline, where other systems use the compression output as input for further processing, and can potentially make better use of the system output.\nFuture extensions are many and varied. An obvious extension concerns porting the framework to other rewriting applications such as document summarization (Daume\u0301 III & Marcu, 2002) or machine translation (Chiang, 2007). Initial work (Cohn & Lapata, 2008) shows that the tree-to-tree transduction model presented here can be easily adapted to a sentence abstraction task where compression takes place using rewrite operations that are not restricted to word deletion. Examples include substitution, reordering, and insertion. Other future directions involve more detailed feature engineering, including source conditioned features and ngram features besides the language model. More research is needed to establish suitable loss functions for compression and other rewriting tasks. In particular it should be interesting to experiment with loss functions that incorporate a wider range of linguistic features beyond parts of speech. Examples include losses based on parse trees and semantic similarity. Finally, the experiments presented in this work use a grammar acquired from the training corpus. However, there is nothing inherent in our formalization that restricts us to this particular grammar. We therefore plan to investigate the potential of our method with unsupervised or semi-supervised grammar induction techniques for other rewriting tasks including paraphrase generation and machine translation."}, {"heading": "Acknowledgments", "text": "We are grateful to Philip Blunsom for insightful comments and suggestions and to the anonymous referees whose feedback helped to substantially improve the present paper. Special thanks to James Clarke for sharing his implementations of Clarke and Lapata\u2019s (2008) and McDonald\u2019s (2006) models with us. We acknowledge the support of EPSRC (grants GR/T04540/01 and GR/T04557/01). This work has made use of the resources provided by the Edinburgh Compute and Data Facility (ECDF). The ECDF is partially supported by the eDIKT initiative. A preliminary version of this work was published in the proceedings of EMNLP/CoNLL 2007."}], "references": [{"title": "Syntax directed translations and the pushdown assembler", "author": ["A.V. Aho", "J.D. Ullman"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Aho and Ullman,? \\Q1969\\E", "shortCiteRegEx": "Aho and Ullman", "year": 1969}, {"title": "Learning dependency translation models as collections of finite state head transducers", "author": ["H. Alshawi", "S. Bangalore", "S. Douglas"], "venue": "Computational Linguistics,", "citeRegEx": "Alshawi et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Alshawi et al\\.", "year": 2000}, {"title": "A maximum entropy approach to natural language processing", "author": ["A.L. Berger", "S.A.D. Pietra", "V.J.D. Pietra"], "venue": "Computational Linguistics,", "citeRegEx": "Berger et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Berger et al\\.", "year": 1996}, {"title": "Design of a multi-lingual, parallel-processing statistical parsing engine", "author": ["D. Bikel"], "venue": "In Proceedings of the 2nd International Conference on Human Language Technology Research,", "citeRegEx": "Bikel,? \\Q2002\\E", "shortCiteRegEx": "Bikel", "year": 2002}, {"title": "Robust accurate statistical annotation of general text", "author": ["E.J. Briscoe", "J. Carroll"], "venue": "In Proceedings of the Third International Conference on Language Resources and Evaluation,", "citeRegEx": "Briscoe and Carroll,? \\Q2002\\E", "shortCiteRegEx": "Briscoe and Carroll", "year": 2002}, {"title": "Simplifying text for language impaired readers", "author": ["J. Carroll", "G. Minnen", "D. Pearce", "Y. Canning", "S. Devlin", "J. Tait"], "venue": "In Proceedings of the 9th Conference of the European Chapter of the Association for Computational Linguistics,", "citeRegEx": "Carroll et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Carroll et al\\.", "year": 1999}, {"title": "Motivations and methods for text simplification", "author": ["R. Chandrasekar", "C.D.B. Srinivas"], "venue": "In Proceedings of the 16th International Conference on Computational Linguistics,", "citeRegEx": "Chandrasekar and Srinivas,? \\Q1996\\E", "shortCiteRegEx": "Chandrasekar and Srinivas", "year": 1996}, {"title": "Hierarchical phrase-based translation", "author": ["D. Chiang"], "venue": "Computational Linguistics,", "citeRegEx": "Chiang,? \\Q2007\\E", "shortCiteRegEx": "Chiang", "year": 2007}, {"title": "Models for sentence compression: A comparison across domains, training requirements and evaluation measures", "author": ["J. Clarke", "M. Lapata"], "venue": "In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Clarke and Lapata,? \\Q2006\\E", "shortCiteRegEx": "Clarke and Lapata", "year": 2006}, {"title": "Global inference for sentence compression: An integer linear programming approach", "author": ["J. Clarke", "M. Lapata"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Clarke and Lapata,? \\Q2008\\E", "shortCiteRegEx": "Clarke and Lapata", "year": 2008}, {"title": "Sentence compression beyond word deletion", "author": ["T. Cohn", "M. Lapata"], "venue": "In Proceedings of the 22nd International Conference on Computational Linguistics,", "citeRegEx": "Cohn and Lapata,? \\Q2008\\E", "shortCiteRegEx": "Cohn and Lapata", "year": 2008}, {"title": "Discriminative training methods for hidden Markov models: theory and experiments with perceptron algorithms", "author": ["M. Collins"], "venue": "In Proceedings of the 2002 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Collins,? \\Q2002\\E", "shortCiteRegEx": "Collins", "year": 2002}, {"title": "Head-driven statistical models for natural language parsing", "author": ["M.J. Collins"], "venue": "Ph.D. thesis,", "citeRegEx": "Collins,? \\Q1999\\E", "shortCiteRegEx": "Collins", "year": 1999}, {"title": "Ultraconservative online algorithms for multiclass problems", "author": ["K. Crammer", "Y. Singer"], "venue": "Machine Learning,", "citeRegEx": "Crammer and Singer,? \\Q2003\\E", "shortCiteRegEx": "Crammer and Singer", "year": 2003}, {"title": "A noisy-channel model for document compression", "author": ["H. Daum\u00e9 III", "D. Marcu"], "venue": "In Proceedings of the 40th Annual Meeting of thev Association for Computational Linguistics,", "citeRegEx": "III and Marcu,? \\Q2002\\E", "shortCiteRegEx": "III and Marcu", "year": 2002}, {"title": "Learning non-isomorphic tree mappings for machine translation", "author": ["J. Eisner"], "venue": "In The Companion Volume to the Proceedings of 41st Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Eisner,? \\Q2003\\E", "shortCiteRegEx": "Eisner", "year": 2003}, {"title": "What\u2019s in a translation rule", "author": ["M. Galley", "M. Hopkins", "K. Knight", "D. Marcu"], "venue": "In Proceedings of the 2004 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Galley et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Galley et al\\.", "year": 2004}, {"title": "Lexicalized Markov grammars for sentence compression", "author": ["M. Galley", "K. McKeown"], "venue": "In Proceedings of Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Galley and McKeown,? \\Q2007\\E", "shortCiteRegEx": "Galley and McKeown", "year": 2007}, {"title": "Training tree transducers", "author": ["J. Grael", "K. Knight"], "venue": "In Proceedings of the 2004 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Grael and Knight,? \\Q2004\\E", "shortCiteRegEx": "Grael and Knight", "year": 2004}, {"title": "Natural language based reformulation resource and wide exploitation for question answering", "author": ["U. Hermjakob", "A. Echihabi", "D. Marcu"], "venue": "In Proceedings of 11th Text Retrieval Conference,", "citeRegEx": "Hermjakob et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Hermjakob et al\\.", "year": 2002}, {"title": "Speech summarization: an approach through word extraction and a method for evaluation", "author": ["C. Hori", "S. Furui"], "venue": "IEICE Transactions on Information and Systems,", "citeRegEx": "Hori and Furui,? \\Q2004\\E", "shortCiteRegEx": "Hori and Furui", "year": 2004}, {"title": "Sentence reduction for automatic text summarization", "author": ["H. Jing"], "venue": "In Proceedings of the 6th Applied Natural Language Processing Conference,", "citeRegEx": "Jing,? \\Q2000\\E", "shortCiteRegEx": "Jing", "year": 2000}, {"title": "A support vector method for multivariate performance measures", "author": ["T. Joachims"], "venue": "In Proceedings of the 22nd International Conference on Machine Learning,", "citeRegEx": "Joachims,? \\Q2005\\E", "shortCiteRegEx": "Joachims", "year": 2005}, {"title": "Paraphrasing predicates from written language to spoken language using the web", "author": ["N. Kaji", "M. Okamoto", "S. Kurohashi"], "venue": "In Proceedings of the 2004 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Kaji et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Kaji et al\\.", "year": 2004}, {"title": "Decoding complexity in word-replacement translation models", "author": ["K. Knight"], "venue": "Computational Linguistics,", "citeRegEx": "Knight,? \\Q1999\\E", "shortCiteRegEx": "Knight", "year": 1999}, {"title": "Summarization beyond sentence extraction: a probabilistic approach to sentence compression", "author": ["K. Knight", "D. Marcu"], "venue": "Artificial Intelligence,", "citeRegEx": "Knight and Marcu,? \\Q2002\\E", "shortCiteRegEx": "Knight and Marcu", "year": 2002}, {"title": "Discovery of inference rules for question answering", "author": ["D. Lin", "P. Pantel"], "venue": "Natural Language Engineering,", "citeRegEx": "Lin and Pantel,? \\Q2001\\E", "shortCiteRegEx": "Lin and Pantel", "year": 2001}, {"title": "Discriminative sentence compression with soft syntactic constraints", "author": ["R. McDonald"], "venue": "In Proceedings of the 11th Conference of the European Chapter of the Association for Computational Linguistics,", "citeRegEx": "McDonald,? \\Q2006\\E", "shortCiteRegEx": "McDonald", "year": 2006}, {"title": "Example-based sentence reduction using the hidden markov model", "author": ["M.L. Nguyen", "S. Horiguchi", "A. Shimazu", "B.T. Ho"], "venue": "ACM Transactions on Asian Language Information Processing,", "citeRegEx": "Nguyen et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Nguyen et al\\.", "year": 2004}, {"title": "The alignment template approach to statistical machine translation", "author": ["F.J. Och", "H. Ney"], "venue": "Computational Linguistics,", "citeRegEx": "Och and Ney,? \\Q2004\\E", "shortCiteRegEx": "Och and Ney", "year": 2004}, {"title": "BLEU: a method for automatic evaluation of machine translation", "author": ["K. Papineni", "S. Roukos", "T. Ward", "Zhu", "W.-J"], "venue": "In Proceedings of the 40th Annual Meeting of thev Association for Computational Linguistics,", "citeRegEx": "Papineni et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Papineni et al\\.", "year": 2002}, {"title": "Learning accurate, compact, and interpretable tree annotation", "author": ["S. Petrov", "L. Barrett", "R. Thibaux", "D. Klein"], "venue": "In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Petrov et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Petrov et al\\.", "year": 2006}, {"title": "Statistical sentence condensation using ambiguity packing and stochastic disambiguation methods for lexical-functional grammar", "author": ["S. Riezler", "T.H. King", "R. Crouch", "A. Zaenen"], "venue": "In Proceedings of the 2003 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Riezler et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Riezler et al\\.", "year": 2003}, {"title": "Synchronous tree-adjoining grammars", "author": ["S. Shieber", "Y. Schabes"], "venue": "In Proceedings of the 13th International Conference on Computational Linguistics,", "citeRegEx": "Shieber and Schabes,? \\Q1990\\E", "shortCiteRegEx": "Shieber and Schabes", "year": 1990}, {"title": "SRILM \u2013 an extensible language modeling toolkit", "author": ["A. Stolcke"], "venue": "In Proceedings of the International Conference on Spoken Language Processing,", "citeRegEx": "Stolcke,? \\Q2002\\E", "shortCiteRegEx": "Stolcke", "year": 2002}, {"title": "Large margin methods for structured and interdependent output variables", "author": ["I. Tsochantaridis", "T. Joachims", "T. Hofmann", "Y. Altun"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Tsochantaridis et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Tsochantaridis et al\\.", "year": 2005}, {"title": "Supervised and unsupervised learning for sentence compression", "author": ["J. Turner", "E. Charniak"], "venue": "In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Turner and Charniak,? \\Q2005\\E", "shortCiteRegEx": "Turner and Charniak", "year": 2005}, {"title": "Sentence compression for automated subtitling: A hybrid approach", "author": ["V. Vandeghinste", "Y. Pan"], "venue": "In Text Summarization Branches Out: Proceedings of the ACL-04 Workshop,", "citeRegEx": "Vandeghinste and Pan,? \\Q2004\\E", "shortCiteRegEx": "Vandeghinste and Pan", "year": 2004}, {"title": "Stochastic inversion transduction grammars and bilingual parsing of parallel corpora", "author": ["D. Wu"], "venue": "Computational Linguistics,", "citeRegEx": "Wu,? \\Q1997\\E", "shortCiteRegEx": "Wu", "year": 1997}, {"title": "A syntax-based statistical translation model", "author": ["K. Yamada", "K. Knight"], "venue": "In Proceedings of the 39th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Yamada and Knight,? \\Q2001\\E", "shortCiteRegEx": "Yamada and Knight", "year": 2001}], "referenceMentions": [{"referenceID": 21, "context": "The aim is to produce a summary of a single sentence that retains the most important information while remaining grammatical (Jing, 2000).", "startOffset": 125, "endOffset": 137}, {"referenceID": 27, "context": "Other approaches model compression discriminatively as subtree deletion (Riezler, King, Crouch, & Zaenen, 2003; Nguyen, Horiguchi, Shimazu, & Ho, 2004; McDonald, 2006).", "startOffset": 72, "endOffset": 167}, {"referenceID": 15, "context": "Specifically, we adopt the synchronous tree substitution grammar (STSG) formalism (Eisner, 2003) which can model non-isomorphic tree structures while having efficient inference algorithms.", "startOffset": 82, "endOffset": 96}, {"referenceID": 15, "context": "Specifically, we adopt the synchronous tree substitution grammar (STSG) formalism (Eisner, 2003) which can model non-isomorphic tree structures while having efficient inference algorithms. We show how such a grammar can be induced from a parallel corpus and propose a discriminative model for the rewriting task which can be viewed as a weighted tree-to-tree transducer. Our learning framework makes use of the large margin algorithm put forward by Tsochantaridis, Joachims, Hofmann, and Altun (2005) which efficiently learns a prediction function to minimize a given loss function.", "startOffset": 83, "endOffset": 501}, {"referenceID": 38, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004).", "startOffset": 48, "endOffset": 58}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004).", "startOffset": 154, "endOffset": 168}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004). Sentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression.", "startOffset": 155, "endOffset": 596}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004). Sentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression. Their model consists of two components: a language model P (y) whose role is to guarantee that the compression output is grammatical and a channel model P (x|y) capturing the probability that the source sentence x is an expansion of the target compression y. Their decoding algorithm searches for the compression y which maximizes P (y)P (x|y). The channel model is a stochastic SCFG, the rules of which are extracted from a parsed parallel corpus and their weights estimated using maximum likelihood. Galley and McKeown (2007) show how to obtain improved SCFG probability estimates through Markovization.", "startOffset": 155, "endOffset": 1185}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004). Sentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression. Their model consists of two components: a language model P (y) whose role is to guarantee that the compression output is grammatical and a channel model P (x|y) capturing the probability that the source sentence x is an expansion of the target compression y. Their decoding algorithm searches for the compression y which maximizes P (y)P (x|y). The channel model is a stochastic SCFG, the rules of which are extracted from a parsed parallel corpus and their weights estimated using maximum likelihood. Galley and McKeown (2007) show how to obtain improved SCFG probability estimates through Markovization. Turner and Charniak (2005) note that SCFG rules are not expressive enough to model structurally complicated compressions as they are restricted to trees of depth 1.", "startOffset": 155, "endOffset": 1290}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004). Sentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression. Their model consists of two components: a language model P (y) whose role is to guarantee that the compression output is grammatical and a channel model P (x|y) capturing the probability that the source sentence x is an expansion of the target compression y. Their decoding algorithm searches for the compression y which maximizes P (y)P (x|y). The channel model is a stochastic SCFG, the rules of which are extracted from a parsed parallel corpus and their weights estimated using maximum likelihood. Galley and McKeown (2007) show how to obtain improved SCFG probability estimates through Markovization. Turner and Charniak (2005) note that SCFG rules are not expressive enough to model structurally complicated compressions as they are restricted to trees of depth 1. They remedy this by supplying their synchronous grammar with a set of more general \u201cspecial\u201d rules. For example, they allow rules of the form \u3008NP,NP\u3009 \u2192 \u3008[NP NP 1 CC NP 2 ],NP 1 \u3009 (boxed subscripts are added to distinguish between the two NPs). Our own work formulates sentence compression in the framework of synchronous treesubstitution grammar (STSG, Eisner, 2003). STSG allows to describe non-isomorphic tree pairs (the grammar rules can comprise trees of arbitrary depth) and is thus suited to textrewriting tasks which typically involve a number of local modifications to the input text. Especially if each modification can be described succinctly in terms of syntactic transformations, such as dropping an adjectival phrase or converting a passive verb phrase into active form. STSG is a restricted version of synchronous tree adjoining grammar (STAG, Shieber & Schabes, 1990) without an adjunction operation. STAG affords mild context sensitivity, however at increased cost of inference. SCFG and STSG are weakly equivalent, that is, their string languages are identical but they do not produce equivalent tree pairs. For example, in Figure 2, rules (1)\u2013(4) can be expressed as SCFG rules, but rule (5) cannot because both the source and target fragments are two level trees. In fact it would be impossible to describe the trees in Figure 1 using a SCFG. Our grammar rules are therefore more general than those obtained by Knight and Marcu (2002) and can account for more elaborate tree divergences.", "startOffset": 155, "endOffset": 2882}, {"referenceID": 7, "context": "Examples include inversion transduction grammar (Wu, 1997), head transducers (Alshawi, Bangalore, & Douglas, 2000), hierarchical phrase-based translation (Chiang, 2007), and several variants of tree transducers (Yamada & Knight, 2001; Grael & Knight, 2004). Sentence compression bears some resemblance to machine translation. Instead of translating from one language into another, we are translating long sentences into shorter ones within the same language. It is therefore not surprising that previous work has also adopted SCFGs for the compression task. Specifically, Knight and Marcu (2002) proposed a noisychannel formulation of sentence compression. Their model consists of two components: a language model P (y) whose role is to guarantee that the compression output is grammatical and a channel model P (x|y) capturing the probability that the source sentence x is an expansion of the target compression y. Their decoding algorithm searches for the compression y which maximizes P (y)P (x|y). The channel model is a stochastic SCFG, the rules of which are extracted from a parsed parallel corpus and their weights estimated using maximum likelihood. Galley and McKeown (2007) show how to obtain improved SCFG probability estimates through Markovization. Turner and Charniak (2005) note that SCFG rules are not expressive enough to model structurally complicated compressions as they are restricted to trees of depth 1. They remedy this by supplying their synchronous grammar with a set of more general \u201cspecial\u201d rules. For example, they allow rules of the form \u3008NP,NP\u3009 \u2192 \u3008[NP NP 1 CC NP 2 ],NP 1 \u3009 (boxed subscripts are added to distinguish between the two NPs). Our own work formulates sentence compression in the framework of synchronous treesubstitution grammar (STSG, Eisner, 2003). STSG allows to describe non-isomorphic tree pairs (the grammar rules can comprise trees of arbitrary depth) and is thus suited to textrewriting tasks which typically involve a number of local modifications to the input text. Especially if each modification can be described succinctly in terms of syntactic transformations, such as dropping an adjectival phrase or converting a passive verb phrase into active form. STSG is a restricted version of synchronous tree adjoining grammar (STAG, Shieber & Schabes, 1990) without an adjunction operation. STAG affords mild context sensitivity, however at increased cost of inference. SCFG and STSG are weakly equivalent, that is, their string languages are identical but they do not produce equivalent tree pairs. For example, in Figure 2, rules (1)\u2013(4) can be expressed as SCFG rules, but rule (5) cannot because both the source and target fragments are two level trees. In fact it would be impossible to describe the trees in Figure 1 using a SCFG. Our grammar rules are therefore more general than those obtained by Knight and Marcu (2002) and can account for more elaborate tree divergences. Moreover, by adopting a more expressive grammar formalism, we can naturally model syntactically complex compressions without having to specify additional rules (as in Turner & Charniak, 2005). A synchronous grammar will license a large number of compressions for a given source tree. Each grammar rule typically has a score from which the overall score of a compression y for sentence x can be derived. Previous work estimates these scores generatively as discussed above. We opt for a discriminative training procedure which allows for the incorporation of all manner of powerful features. We use the large margin technique proposed by Tsochantaridis et al. (2005). The framework is attractive in that it supports a configurable loss function, which describes the extent to which a predicted target tree differs from", "startOffset": 155, "endOffset": 3601}, {"referenceID": 24, "context": "McDonald (2006) also presents a sentence compression model that uses a discriminative large margin algorithm.", "startOffset": 0, "endOffset": 16}, {"referenceID": 18, "context": "An example is in the work of Hori and Furui (2004), who propose a model for automatically transcribed spoken text.", "startOffset": 29, "endOffset": 51}, {"referenceID": 8, "context": "Clarke and Lapata (2008) show that such unsupervised models can be greatly improved when linguistically motivated constraints are used during decoding.", "startOffset": 0, "endOffset": 25}, {"referenceID": 24, "context": "Algorithm 3 is an extension of Galley, Hopkins, Knight, and Marcu\u2019s (2004) technique for extracting a", "startOffset": 48, "endOffset": 75}, {"referenceID": 24, "context": "This would break the polynomial-time dynamic program used for inference, rendering inference problem NP-complete (Knight, 1999).", "startOffset": 113, "endOffset": 127}, {"referenceID": 15, "context": "This extends earlier inference algorithms for weighted STSGs (Eisner, 2003) which assume that the scoring function must decompose with the derivation, i.", "startOffset": 61, "endOffset": 75}, {"referenceID": 7, "context": "This is equivalent to using as our grammar the intersection between the original grammar and an ngram language model, as explained by Chiang (2007) in the context of string transduction with an SCFG.", "startOffset": 134, "endOffset": 148}, {"referenceID": 7, "context": "We adopt a popular approach in syntax-inspired machine translation to address this problem (Chiang, 2007).", "startOffset": 91, "endOffset": 105}, {"referenceID": 7, "context": "We adopt a popular approach in syntax-inspired machine translation to address this problem (Chiang, 2007). Firstly, we use a beam-search, which limits the number of different ngram contexts stored in each chart cell to a constant, W . This changes the base in the complexity term, leading to an improved O(SRW V ) but which is still exponential in the number of variables. In addition, we use Chiang\u2019s cube-pruning heuristic to further limit the number of combinations. Cube-pruning uses a heuristic scoring function which approximates the conditional log-probability from a ngram language model with the logprobability from a unigram model.8 This allows us to visit the combinations in best-first order under the heuristic scoring function until the beam is filled.The beam is then rescored using the correct scoring function. This can be done cheaply in O(WV ) time, leading to an overall time complexity of decoding to O(SRWV ). We refer the interested reader to the work of Chiang (2007) for further details.", "startOffset": 92, "endOffset": 992}, {"referenceID": 11, "context": "Possibilities include perceptron training (Collins, 2002), log-linear optimisation of the conditional log-likelihood (Berger, Pietra, & Pietra, 1996) and large margin methods.", "startOffset": 42, "endOffset": 57}, {"referenceID": 11, "context": "Possibilities include perceptron training (Collins, 2002), log-linear optimisation of the conditional log-likelihood (Berger, Pietra, & Pietra, 1996) and large margin methods. We base our training on Tsochantaridis et al.\u2019s (2005) framework for learning Support Vector Machines (SVMs) over structured output spaces, using the SVMstruct implementation.", "startOffset": 43, "endOffset": 231}, {"referenceID": 11, "context": "Possibilities include perceptron training (Collins, 2002), log-linear optimisation of the conditional log-likelihood (Berger, Pietra, & Pietra, 1996) and large margin methods. We base our training on Tsochantaridis et al.\u2019s (2005) framework for learning Support Vector Machines (SVMs) over structured output spaces, using the SVMstruct implementation.9 The framework supports a configurable loss function which is particularly appealing in the context of sentence compression and more generally text-to-text generation. It also has an efficient training algorithm and powerful regularization. The latter is is critical for discriminative models with large numbers of features, which would otherwise over-fit the training sample at the expense of generalization accuracy. We briefly summarize the approach below; for a more detailed description we refer the interested reader to the work of Tsochantaridis et al. (2005). Traditionally SVMs learn a linear classifier that separates two or more classes with the largest possible margin.", "startOffset": 43, "endOffset": 919}, {"referenceID": 35, "context": "little difference between the two rescaling methods (Tsochantaridis et al., 2005).", "startOffset": 52, "endOffset": 81}, {"referenceID": 35, "context": "little difference between the two rescaling methods (Tsochantaridis et al., 2005). We use margin rescaling for the practical reason that it can be approximated more accurately than can slack rescaling by our chart based inference method. The optimization problem in (10) is approximated using an algorithm proposed by Tsochantaridis et al. (2005). The algorithm finds a small set of constraints from the fullsized optimization problem that ensures a sufficiently accurate solution.", "startOffset": 53, "endOffset": 347}, {"referenceID": 22, "context": "In order to calculate these losses the chart must be stratified by the loss function\u2019s arguments (Joachims, 2005).", "startOffset": 97, "endOffset": 113}, {"referenceID": 38, "context": "10 This is found using Algorithm 5, a chart-based dynamic program similar to the alignment algorithm for inverse transduction grammars (Wu, 1997).", "startOffset": 135, "endOffset": 145}, {"referenceID": 34, "context": "This was trained on the BNC (100 million words) using the SRI Language Modeling toolkit (Stolcke, 2002), with modified Kneser-Ney smoothing.", "startOffset": 88, "endOffset": 103}, {"referenceID": 27, "context": "We give details of the corpora used, briefly introduce McDonald\u2019s (2006) model used for comparison with our approach, and explain how system output was evaluated.", "startOffset": 55, "endOffset": 73}, {"referenceID": 8, "context": "Our experiments on CLspoken and CLwritten followed Clarke and Lapata\u2019s (2008) partition of training, test, and development sets.", "startOffset": 51, "endOffset": 78}, {"referenceID": 8, "context": "Our experiments on CLspoken and CLwritten followed Clarke and Lapata\u2019s (2008) partition of training, test, and development sets. The partition sizes are shown in Table 3. In the case of the Ziff-Davis corpus, Knight and Marcu (2002) had not defined a development set.", "startOffset": 51, "endOffset": 233}, {"referenceID": 27, "context": "We evaluated our results against McDonald\u2019s (2006) discriminative model.", "startOffset": 33, "endOffset": 51}, {"referenceID": 27, "context": "The maximization is solved using a semi-Markov Viterbi algorithm (McDonald, 2006).", "startOffset": 65, "endOffset": 81}, {"referenceID": 25, "context": "The maximization is solved using a semi-Markov Viterbi algorithm (McDonald, 2006). The model parameters are estimated using the Margin Infused Relaxed Algorithm (MIRA Crammer & Singer, 2003), a discriminative large-margin online learning technique. McDonald (2006) uses a similar loss function to our Hamming loss (see (12)) but without an explicit length penalty.", "startOffset": 66, "endOffset": 265}, {"referenceID": 8, "context": "Clarke and Lapata (2008) reformulate McDonald\u2019s (2006) model in the context of integer linear programming (ILP) and augment it with constraints ensuring that the compressed output is grammatically and semantically well formed.", "startOffset": 0, "endOffset": 25}, {"referenceID": 8, "context": "Clarke and Lapata (2008) reformulate McDonald\u2019s (2006) model in the context of integer linear programming (ILP) and augment it with constraints ensuring that the compressed output is grammatically and semantically well formed.", "startOffset": 0, "endOffset": 55}, {"referenceID": 8, "context": "Clarke and Lapata (2008) reformulate McDonald\u2019s (2006) model in the context of integer linear programming (ILP) and augment it with constraints ensuring that the compressed output is grammatically and semantically well formed. For example, if the target sentence has negation, this must be included in the compression; If the source verb has a subject, this must also be retained in the compression. They generate and solve an ILP for every source sentence using the branch-and-bound algorithm. Since they obtain performance improvements over McDonald\u2019s model on several corpora, we also use it for comparison against our model. To summarize, we believe that McDonald\u2019s (2006) model is a good basis for comparison for several reasons.", "startOffset": 0, "endOffset": 677}, {"referenceID": 24, "context": "Following Knight and Marcu (2002), we conducted two separate experiments.", "startOffset": 10, "endOffset": 34}, {"referenceID": 24, "context": "Following Knight and Marcu (2002), we conducted two separate experiments. In the first experiment participants were presented with a source sentence and its target compression and asked to rate how well the compression preserved the most important information from the source sentence. In the second experiment, they were asked to rate the grammaticality of the compressed outputs. In both cases they used a five point rating scale where a high number indicates better performance. We randomly selected 20 sentences from the test portion of each corpus. These sentences were compressed automatically by our system and McDonald\u2019s (2006) system.", "startOffset": 10, "endOffset": 636}, {"referenceID": 32, "context": "We also report results using F1 computed over grammatical relations (Riezler et al., 2003).", "startOffset": 68, "endOffset": 90}, {"referenceID": 3, "context": "We obtained syntactic analyses for source and target sentences with Bikel\u2019s (2002) parser.", "startOffset": 68, "endOffset": 83}, {"referenceID": 3, "context": "16 Compared to dependencies extracted from the predicted parses using Bikel\u2019s (2002) parser on the output string, we observe that the relation F1 score increases uniformly for all tasks, by between 2.", "startOffset": 70, "endOffset": 85}, {"referenceID": 25, "context": "We also report results on the same corpora using McDonald\u2019s (2006) model (McDonald) and the improved version (Clarke ILP) put forward by Clarke and Lapata (2008).", "startOffset": 49, "endOffset": 67}, {"referenceID": 8, "context": "We also report results on the same corpora using McDonald\u2019s (2006) model (McDonald) and the improved version (Clarke ILP) put forward by Clarke and Lapata (2008). We also present the compression rate for each system and the reference gold standard.", "startOffset": 137, "endOffset": 162}, {"referenceID": 27, "context": "to modify our chart-based decoder in a fashion similar to McDonald (2006). However, we leave this to", "startOffset": 58, "endOffset": 74}, {"referenceID": 27, "context": "We carried out an Analysis of Variance (Anova) to examine the effect of system type (McDonald, Transducer, Reference) on the compression ratings. The Anova revealed a reliable effect on all three corpora. We used post-hoc Tukey tests to examine whether the mean ratings for each system differed significantly (p < 0.01). On the CLspoken corpus the Transducer is perceived as significantly better than McDonald, both in terms of grammaticality and importance. We obtain the same result for the CLwritten corpus. The two systems achieve similar performances on Ziff-Davis (the grammaticality and importance score do not differ significantly). Ziff-Davis seems to be a less challenging corpus than CLspoken or CLwritten and less likely to highlight differences among systems. For example, Turner and Charniak (2005) present several variants of the noisy-channel model, all of which achieve compressions of similar quality on Ziff-Davis (grammaticality ratings varied by only \u00b10.", "startOffset": 85, "endOffset": 813}, {"referenceID": 27, "context": "Nevertheless, compression rate can be indirectly manipulated by adopting loss functions that encourage or discourage compression or directly during decoding by stratifying the chart for length (McDonald, 2006).", "startOffset": 193, "endOffset": 209}, {"referenceID": 35, "context": "Each grammar rule is assigned a weight which is learned discriminatively within a large margin model (Tsochantaridis et al., 2005).", "startOffset": 101, "endOffset": 130}, {"referenceID": 27, "context": "We evaluated our model on three compression corpora (CLspoken, CLwritten, and ZiffDavis) and showed that in most cases it yields results superior to state-of-the-art (McDonald, 2006).", "startOffset": 166, "endOffset": 182}, {"referenceID": 7, "context": "Our feature ablation study revealed that ngram features are beneficial, mirroring a similar finding in the machine translation literature (Chiang, 2007).", "startOffset": 138, "endOffset": 152}, {"referenceID": 16, "context": "This concurs with Galley and McKeown (2007) who also find that lexicalization yields better compression output.", "startOffset": 18, "endOffset": 44}, {"referenceID": 7, "context": "An obvious extension concerns porting the framework to other rewriting applications such as document summarization (Daum\u00e9 III & Marcu, 2002) or machine translation (Chiang, 2007).", "startOffset": 164, "endOffset": 178}, {"referenceID": 8, "context": "Special thanks to James Clarke for sharing his implementations of Clarke and Lapata\u2019s (2008) and McDonald\u2019s (2006) models with us.", "startOffset": 66, "endOffset": 93}, {"referenceID": 8, "context": "Special thanks to James Clarke for sharing his implementations of Clarke and Lapata\u2019s (2008) and McDonald\u2019s (2006) models with us.", "startOffset": 66, "endOffset": 115}], "year": 2009, "abstractText": "This paper presents a tree-to-tree transduction method for sentence compression. Our model is based on synchronous tree substitution grammar, a formalism that allows local distortion of the tree topology and can thus naturally capture structural mismatches. We describe an algorithm for decoding in this framework and show how the model can be trained discriminatively within a large margin framework. Experimental results on sentence compression bring significant improvements over a state-of-the-art model.", "creator": "TeX"}}}