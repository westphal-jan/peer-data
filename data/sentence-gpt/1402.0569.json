{"id": "1402.0569", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Description Logic Knowledge and Action Bases", "abstract": "Description logic Knowledge and Action Bases (KAB) are a mechanism for providing both a semantically rich representation of the information on the domain of interest in terms of a description logic knowledge base and actions to change such information over time, possibly introducing new objects. We resort to a variant of DL-Lite where the unique name assumption is not enforced and where equality between objects may be asserted and inferred. Actions are specified as sets of conditional effects, where conditions are based on epistemic queries over the knowledge base (TBox and ABox), and effects are expressed in terms of new ABoxes. In this setting, we address verification of temporal properties expressed in a variant of first-order mu-calculus with quantification across states. Notably, we show decidability of verification, under a suitable restriction inspired by the notion of weak acyclicity in data exchange. We also show evidence of the role of \u03bb of knowledge in the evaluation of experimental data. It is not clear if any mechanisms for quantification have been identified to improve reliability in generalizations in generalizations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Tue, 4 Feb 2014 01:36:58 GMT  (391kb)", "http://arxiv.org/abs/1402.0569v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["babak bagheri hariri", "diego calvanese", "marco montali", "giuseppe de giacomo", "riccardo de masellis", "paolo felli"], "accepted": false, "id": "1402.0569"}, "pdf": {"name": "1402.0569.pdf", "metadata": {"source": "CRF", "title": "Description Logic Knowledge and Action Bases", "authors": ["Babak Bagheri Hariri", "Diego Calvanese", "Marco Montali", "Giuseppe De Giacomo", "Riccardo De Masellis", "Paolo Felli"], "emails": ["BAGHERI@INF.UNIBZ.IT", "CALVANESE@INF.UNIBZ.IT", "MONTALI@INF.UNIBZ.IT", "DEGIACOMO@DIS.UNIROMA1.IT", "DEMASELLIS@DIS.UNIROMA1.IT", "FELLI@DIS.UNIROMA1.IT"], "sections": [{"heading": null, "text": "semantically rich representation of the information on the domain of interest in terms of a description logic knowledge base and actions to change such information over time, possibly introducing new objects. We resort to a variant of DL-Lite where the unique name assumption is not enforced and where equality between objects may be asserted and inferred. Actions are specified as sets of conditional effects, where conditions are based on epistemic queries over the knowledge base (TBox and ABox), and effects are expressed in terms of new ABoxes. In this setting, we address verification of temporal properties expressed in a variant of first-order \u00b5-calculus with quantification across states. Notably, we show decidability of verification, under a suitable restriction inspired by the notion of weak acyclicity in data exchange."}, {"heading": "1. Introduction", "text": "Recent work in business processes, services and databases is bringing forward the need of considering both data and processes as first-class citizens in process and service design (Nigam & Caswell, 2003; Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Vianu, 2009; Meyer, Smirnov, & Weske, 2011). In particular, the so-called artifact-centric approaches, which advocate a sort of middle ground between a conceptual formalization of dynamic systems and their actual implementation, are promising to be effective in practice (Cohn & Hull, 2009). The verification of temporal properties in the presence of data represents a significant research challenge (for a survey, see Calvanese, De Giacomo, & Montali, 2013), since taking into account how data evolve over time results in systems that have an infinite number of states. Neither finite-state model checking (Clarke, Grumberg, & Peled, 1999) nor most of the current techniques for infinitestate model checking, which mostly tackle recursion (Burkart, Caucal, Moller, & Steffen, 2001), apply to this case. Recently, there have been some advancements on this issue (Cangialosi, De Giacomo, De Masellis, & Rosati, 2010; Damaggio, Deutsch, & Vianu, 2011; Bagheri Hariri, Calvanese, De Giacomo, De Masellis, & Felli, 2011; Belardinelli, Lomuscio, & Patrizi, 2011), in the context of suitably constrained relational database settings.\nc\u00a92013 AI Access Foundation. All rights reserved.\nWhile most of this work is based on maintaining information in a relational database, for more sophisticated applications it is foreseen to enrich data-intensive business processes with a semantic level, where information can be maintained in a semantically rich knowledge base which allows for operating with incomplete information (Calvanese, De Giacomo, Lembo, Montali, & Santoso, 2012; Limonad, De Leenheer, Linehan, Hull, & Vaculin, 2012). This leads us to look into how to combine first-order data, ontologies, and processes, while maintaining basic inference tasks (specifically verification) decidable. In this setting, we capture the domain of interest in terms of semantically rich formalisms as those provided by ontological languages based on Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). Such languages natively deal with incomplete knowledge in the modeled domain. This additional flexibility comes with an added cost, however: differently from relational databases, to evaluate queries we need to resort to logical implication. Moreover, incomplete information combined with the ability of evolving the system through actions results in a notoriously fragile setting w.r.t. decidability (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay, Kurusz, Wolter, & Zakharyaschev, 2003). In particular, due to the nature of DL assertions (which in general are not definitions but constraints on models), we get one of the most difficult kinds of domain descriptions for reasoning about actions (Reiter, 2001), which amounts to dealing with complex forms of state constraints (Lin & Reiter, 1994).\nTo overcome this difficulty, virtually all solutions that aim at robustness are based on a so-called \u201cfunctional view of knowledge bases\u201d (Levesque, 1984): the KB provides the ability of querying based on logical implication (\u201cask\u201d), and the ability of progressing it to a \u201cnew\u201d KB through forms of updates (\u201ctell\u201d) (Baader, Ghilardi, & Lutz, 2012; Calvanese, De Giacomo, Lenzerini, & Rosati, 2011). Notice that this functional view is tightly related to an epistemic interpretation of the KB (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007a). Indeed our work is also related to that on Epistemic Dynamic Logic (van Ditmarsch, van der Hoek, & Kooi, 2007), and, though out of the scope of this paper, the decidability results presented here could find application in the context of that research as well.\nWe follow this functional view of KBs. However, a key point of our work is that at each execution step external information is incorporated into the system in form of new individuals (denoted by function terms), that is, our systems are not closed w.r.t. the available information. This makes our framework particularly interesting and challenging. In particular, the presence of these individuals requires a specific treatment of equality, since as the system progresses and new information is acquired, distinct function terms may be inferred to denote the same object.\nSpecifically, we introduce the so-called Knowledge and Action Bases (KABs). A KAB is equipped with an ontology or, more precisely, a TBox expressed, in our case, in a variant of DLLiteA (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007b), which extends the core of the Web Ontology Language OWL 2 QL (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2012) and is particularly well suited for data management. Such a TBox captures intensional information on the domain of interest, similarly to UML class diagrams or other conceptual data models, though as a software component to be used at run-time. The KAB includes also an ABox, which acts as a storage or state. The ABox maintains the data of interest, which are accessed by relying on query answering based on logical implication (certain answers). Notably, our variant of DL-LiteA is without the unique name assumption (UNA), and we allow for explicit equality assertions in the ABox. In this way we can suitably treat function terms to represent individuals acquired during the execution. Technically, the need of dealing with equality breaks the first-order rewritability of DL-LiteA query answering, and requires that, in addition to the rewriting process, inference on equality is performed\n(Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009). As a query language, we use unions of conjunctive queries, possibly composing their certain answers through full FOL constructs. This gives rise to an epistemic query language that asks about what is \u201cknown\u201d by the current KB (Calvanese et al., 2007a). Apart from the KB, the KAB contains actions, whose execution changes the state of the KB, i.e., its ABox. Such actions are specified as sets of conditional effects, where conditions are (epistemic) queries over the KB and effects are expressed in terms of new ABoxes. Actions have no static pre-conditions, whereas a process is used to specify which actions can be executed at each step. For simplicity, we model such processes as condition/action rules, where the condition is again expressed as a query over the KB.\nIn this setting, we address the verification of temporal/dynamic properties expressed in a firstorder variant of \u00b5-calculus (Park, 1976; Stirling, 2001), where atomic formulae are queries over the KB which can refer both to constants and to function terms, and where a controlled form of quantification across states is allowed. Notice that all previous decidability results on actions over DL KBs assumed that no information is coming from outside of the system, in the sense that no new individual terms are added while executing actions (Calvanese et al., 2011; Baader et al., 2012; Rosati & Franconi, 2012). In this paper, instead, we allow for arbitrary introduction of new terms. Unsurprisingly, we show that even for very simple KABs and temporal properties, verification is undecidable. However, we also show that for a rich class of KABs, verification is in fact decidable and reducible to finite-state model checking. To obtain this result, following Cangialosi et al. (2010), and Bagheri Hariri et al. (2011), we rely on recent results in data exchange on the finiteness of the chase of tuple-generating dependencies (Fagin, Kolaitis, Miller, & Popa, 2005), though, in our case, we need to extend the approach to deal with (i) incomplete information, (ii) inference on equality, and (iii) quantification across states in the verification language.\nThe paper is organized as follows. In Section 2 we give preliminaries about DL-LiteA without UNA, which is going to be our knowledge base formalism. Section 3 describes the KAB framework in detail, while Section 4 discusses its execution semantics. In Section 5 we introduce the verification formalism for KABs. In Section 6, we show that verification of KABs is in general undecidable, even considering very simple temporal properties and KABs. In Section 7, we give our main technical result: verification of weakly acyclic KABs is decidable in EXPTIME. In Section 8, we extensively survey related work. Section 9 concludes the paper."}, {"heading": "2. Knowledge Base Formalism", "text": "Description Logics (DLs) (Baader et al., 2003) are knowledge representation formalisms that are tailored for representing the domain of interest in terms of concepts (or classes), denoting sets of objects, and roles (or relations), denoting binary relations between objects. DL knowledge bases (KBs) are based on an alphabet of concept and role names, and an alphabet of individuals. A DL KB is formed by two distinct parts: a TBox, which represents the intensional level of the KB and contains a description of the domain of interest in terms of universal assertions over concepts and roles; and an ABox, which represents the instance level of the KB and contains extensional information on the participation of individuals to concepts and roles.\nFor expressing KBs we use DL-LiteNU, a variant of the DL-LiteA language (Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, & Rosati, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2013) in which we drop the unique name assumption (UNA) in line with the standard Web Ontology Language (OWL 2) (Bao et al., 2012). Essentially, DL-LiteNU extends the OWL 2 QL\nprofile of OWL 2, by including functionality assertions and the possibility to state equality between individuals.\nThe syntax of concept and role expressions in DL-LiteNU is as follows:\nB \u2212\u2192 N | \u2203R, C \u2212\u2192 B | \u00acB,\nR \u2212\u2192 P | P\u2212, V \u2212\u2192 R | \u00acR,\nwhere N denotes a concept name, P a role name, and P\u2212 an inverse role. Formally, in a DL-LiteNU KB (T,A), the TBox T is a finite set of TBox assertions of the form\nB v C, R v V, (funct R),\ncalled respectively concept inclusions, role inclusions, and functionality assertions. We follow the usual assumption in DL-Lite, according to which a TBox may contain neither (funct P ) nor (funct P\u2212) if it contains R v P or R v P\u2212, for some role R (Poggi et al., 2008; Calvanese et al., 2013). This condition expresses that roles in functionality assertions cannot be specialized.\nDL-LiteNU TBoxes are able to capture the essential features of conceptual modeling formalisms, such as UML Class Diagrams (or Entity-Relationship schemas), namely ISA between classes and associations (relationships), disjointness between classes and between associations, typing of associations, and association multiplicities (in particular, mandatory participation and functionality). The main missing feature is completeness of hierarchies, which would require the introduction of disjunction and would compromise the good computational properties of DL-Lite.\nThe ABox A in a DL-LiteNU KB (T,A) is a finite set of ABox assertions of the form\nN(t1), P (t1, t2), t1 = t2,\ncalled respectively, concept (membership) assertions, role (membership) assertions, and equality assertions, where t1, t2 are terms denoting individuals (see below). The presence of equality assertions in the ABox requires a specific treatment of equality that goes beyond the usual reasoning techniques for DL-Lite based on first-order rewritability, although reasoning remains polynomial (Artale et al., 2009). On the other hand, we do not allow for explicit disequality, though one can use membership in disjoint concepts to assert that two individuals are different.\nDL-LiteNU admits complex terms for denoting individuals. Such terms are inductively defined by starting from a finite set of constants, and applying a finite set of (uninterpreted) functions of various arity greater than 0. As a result, the set of individual terms is countably infinite. We call function terms those terms involving functions. Also, the structure of terms has an impact on inference over equality, which is a congruence relation on the structure of terms, i.e., if ti = t\u2032i, for i \u2208 {1, . . . , n}, and f is a function symbol of arity n, then f(t1, . . . , tn) = f(t\u20321, . . . , t\u2032n). Apart from this aspect related to equality, we can treat individuals denoted by terms simply as ordinary individual constants in DLs.\nWe adopt the standard semantics of DLs based on FOL interpretations I = (\u2206I , \u00b7I), where \u2206I is the interpretation domain and \u00b7I is the interpretation function such that tI \u2208 \u2206I , NI \u2286 \u2206I , and P I \u2286 \u2206I\u00d7\u2206I , for each term t,concept nameN , and role name P . Coherently with the congruence relation on terms, we have that (f(t1, . . . , tn))I = (f(t\u20321, . . . , t \u2032 n)) I , whenever tIi = t \u2032 i I , for i \u2208 {1, . . . , n}. Complex concepts and roles are interpreted as follows:\n(\u2203R)I = {o | \u2203o\u2032.(o, o\u2032) \u2208 RI}, (\u00acB)I = \u2206I \\BI ,\n(P\u2212)I = {(o1, o2) | (o2, o1) \u2208 P I}, (\u00acR)I = \u2206I \u00d7\u2206I \\RI .\nAn interpretation I satisfies an assertion of the form: \u2022 B v C, if BI \u2286 CI ; \u2022 R v V , if RI \u2286 V I ; \u2022 (funct R), if for all o, o1, o2 we have that, if {(o, o1), (o, o2)} \u2286 RI , then o1 = o2; \u2022 N(t1), if tI1 \u2208 NI ; \u2022 P (t1, t2), if (tI1 , tI2 ) \u2208 P I ; \u2022 t1 = t2, if tI1 = tI2 .\nI is a model of a KB (T,A) if it satisfies all assertions in T and A. KB (T,A) is satisfiable if it has a model. We also say that an ABox A is consistent w.r.t. a TBox T if the KB (T,A) is satisfiable. An assertion \u03b1 is logically implied by a KB (T,A), denoted (T,A) |= \u03b1, if every model of (T,A) satisfies \u03b1 as well.\nThe following characterization of satisfiability and logical implication in DL-LiteNU is an easy consequence of results by Artale et al. (2009).\nTheorem 1 Checking satisfiability and logical implication in DL-LiteNU are PTIME-complete.\nProof. The PTIME lower bound is an immediate consequence of the same lower bound established by Artale et al. (2009) for DL-LiteNU in which we do not allow the use of complex individual terms.\nFor the upper bound, Artale et al. (2009) provide a PTIME algorithm that is based on first using functionality assertions to exhaustively propagate equality, and then resorting to a PTIME algorithm (in combined complexity) for reasoning in DL-Lite in the absence of UNA. We can adapt that algorithm by changing the first step, so as to propagate, again in PTIME, equality over terms in the active domain not only due to functionalities, but also due to congruence.\nNext we introduce queries. As usual (cf. OWL 2), answers to queries are formed by constants/terms denoting individuals explicitly mentioned in the ABox. The (active) domain of an ABox A, denoted by ADOM(A), is the (finite) set of constants/terms appearing in concept, role, and equality assertions in A. The (predicate) alphabet of a KB (T,A), denoted ALPH((T,A)) is the set of concept and role names occurring in T \u222aA.\nA union of conjunctive queries (UCQ) q over a KB (T,A) is a FOL formula of the form \u2203~y1.conj 1(~x, ~y1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u2203~yn.conj n(~x, ~yn) with free variables ~x and existentially quantified variables ~y1, . . . , ~yn. Each conj i(~x, ~yi) in q is a conjunction of atoms of the form N(z), P (z, z\n\u2032) where N and P respectively denote a concept and a role name occurring in ALPH((T,A)), and z, z\u2032 are constants in ADOM(A) or variables in ~x or ~yi, for some i \u2208 {1, . . . , n}. The certain answers to q over (T,A) is the set ANS(q, T,A) of substitutions1 \u03c3 of the free variables of q with constants/terms in ADOM(A) such that q\u03c3 evaluates to true in every model of (T,A), i.e., q\u03c3 is logically implied by (T,A). Following the notation used for assertions, we denote this as (T,A) |= q\u03c3. If q has no free variables, then it is called boolean and its certain answers are either the empty substitution denoting true or nothing denoting false.\nAgain, as an easy consequence of the results by Artale et al. (2009), we obtain the following characterization of query answering in DL-LiteNU.\nTheorem 2 Computing ANS(q, T,A) of an UCQ q over a DL-LiteNU KB (T,A) is PTIME-complete in the size of T and A.\n1. As customary, we can view each substitution simply as a tuple of constants, assuming some ordering of the free variables of q.\nProof. As in the proof of Theorem 1, we can first propagate in PTIME equality over terms in the active domain by using functionality and congruence closure, and then resort to query answering in DL-Lite in the presence of UNA, which is in PTIME in the combined size of the TBox T and the ABox resulting from the above equality propagation (actually, in AC0 in the size of this ABox).\nWe also consider an extension of UCQs, called ECQs, which are queries of the query language EQL-Lite(UCQ) (Calvanese et al., 2007a), that is, the FOL query language whose atoms are UCQs evaluated according to the certain answer semantics above. An ECQ over a KB (T,A) is a possibly open formula of the form\nQ \u2212\u2192 [q] | [x = y] | \u00acQ | Q1 \u2227Q2 | \u2203x.Q,\nwhere [q] denotes the certain answers of a UCQ q over (T,A), [x = y] denotes the certain answers of x = y over (T,A), that is, the set {\u3008x, y\u3009 \u2208 ADOM(A) | (T,A) |= (x = y)}, logical operators have the usual meaning, and quantification ranges over elements of ADOM(A).\nFormally we define the relation Q holds in (T,A) under substitution \u03c3 of all free variables in Q, written T,A, \u03c3 |= Q, inductively as follows:\nT,A, \u03c3 |= [q] if (T,A) |= q\u03c3, T,A, \u03c3 |= [x = y] if (T,A) |= (x = y)\u03c3, T,A, \u03c3 |= \u00acQ if T,A, \u03c3 6|= Q, T,A, \u03c3 |= Q1 \u2227Q2 if T,A, \u03c3 |= Q1 and T,A, \u03c3 |= Q2, T, A, \u03c3 |= \u2203x.Q if exists t \u2208 ADOM(A) such that T,A, \u03c3[x/t] |= Q,\nwhere \u03c3[x/t] denotes the substitution obtained from \u03c3 by assigning to x the constant/term t (if x is already present in \u03c3 its value is replaced by t, if not, the pair x/t is added to the substitution).\nThe certain answer toQ over (T,A), denoted ANS(Q,T,A), is the set of substitutions \u03c3 for the free variables in Q such that Q holds in (T,A) under \u03c3, i.e.,\nANS(Q,T,A) = {\u03c3 | T,A, \u03c3 |= Q}.\nFollowing the line of the proof by Calvanese et al. (2007a), but considering Theorem 2 for the basic step of evaluating an UCQ, we get:\nTheorem 3 Computing ANS(Q,T,A) of an ECQ Q over a DL-LiteNU KB (T,A) is PTIMEcomplete in the size of T and A.\nWe recall that DL-Lite enjoys a rewritability property, which states that for every UCQ q and for every DL-Lite KB (T,A),\nANS(q, T,A) = ANS(rewT (q), \u2205, A),\nwhere rewT (q) is a UCQ computed by the reformulation algorithm of Calvanese et al. (2007b). Notice that, in this way, we have \u201ccompiled away\u201d the TBox. This result can be extended to ECQs as well, i.e., for every ECQ Q, ANS(Q,T,A) = ANS(rewT (Q), \u2205, A) where the query rewT (Q) is obtained from Q by substituting each atom [q] (where q is an UCQ) by [rewT (q)] (Calvanese et al., 2007a). In our setting, we can again exploit rewritability, but only after having pre-processed the ABox (in PTIME) by propagating equalities between individual terms in ADOM(A) according to functionality assertions and congruence of terms.\nWe say that two ABoxes A1 and A2 are equivalent w.r.t. TBox T and predicate alphabet \u039b, denoted by\nA1 \u2261T,\u039b A2,\nif for every ABox assertion \u03b12 \u2208 A2 which is either a concept assertion N(t) with N \u2208 \u039b, role assertion P (t1, t2) with P \u2208 \u039b, or equivalence assertion t1 = t2, we have (T,A1) |= \u03b12; and viceversa, for every ABox assertion \u03b11 \u2208 A1, which is either a concept assertion N(t) with N \u2208 \u039b, role assertion P (t1, t2) with P \u2208 \u039b, or equivalence assertion t1 = t2, we have (T,A2) |= \u03b11. Notice that if A1 \u2261T,\u039b A2, then for every ECQ Q whose concept and role names belong to \u039b we have that ANS(Q,T,A1) = ANS(Q,T,A2). Notice also that, by applying Theorem 3 to the boolean query [\u03b1] corresponding to the ABox assertion \u03b1, for each \u03b1 in A1 and A2, we obtain that ABox equivalence can be checked in PTIME."}, {"heading": "3. Knowledge and Action Bases", "text": "A Knowledge and Action Base (KAB) is a tuple K = (T,A0,\u0393,\u03a0) where T and A0 form the knowledge component (or knowledge base), and \u0393 and \u03a0 form the action component (or action base). In practice, K stores the information of interest into a KB, formed by a fixed TBox T and an initial ABox A0, which evolves by executing actions \u0393 according to the sequencing established by process \u03a0. During the evolution new individuals can be acquired by the KB. Such individuals are witnesses of new pieces of information inserted into the KAB from the environment the KAB runs in (i.e., the external world). We represent these new objects as function terms. As the KAB evolves, the identity of individuals should be intuitively preserved and this induces the necessity of remembering equalities between terms denoting individuals discovered in the past. We describe in detail the components of the KAB."}, {"heading": "3.1 TBox", "text": "T is a DL-LiteNU TBox, used to capture the intensional knowledge about the domain of interest. Such a TBox is fixed once and for all, and does not evolve during the execution of the KAB."}, {"heading": "3.2 ABox", "text": "A0 is a DL-LiteNU ABox, which stores the extensional information of interest. Notice that A0 is the ABox of the initial state of the KAB, and as the KAB evolves due to the effect of actions, the ABox, which is indeed the state of the system, evolves accordingly to store up-to-date information. Through actions we acquire new information from the external world by using calls to external services represented through functions. Given that we have no information about these services, except for their name and the parameters that are passed to them, the functions remain uninterpreted. We only assume that the result of such service calls depends only on the passed parameters. Hence, we represent the new individuals returned by service calls as function terms. The presence of function terms has an impact on the treatment of equality, since in principle we need to close equality w.r.t. congruence. While this closure generates an infinite number of logically implied equality assertions, we are going to keep such assertions implicit, computing them only when needed."}, {"heading": "3.3 Actions", "text": "\u0393 is a finite set of actions. An action \u03b3 \u2208 \u0393 modifies the current ABox A by adding or deleting assertions, thus generating a new ABox A\u2032. An action \u03b3 has the form\nact(~x) : {e1, . . . , en},\nwhere act(~x) is the signature of \u03b3 and {e1, . . . , en} is a (finite) set of effects forming the effect specification of \u03b3. The action signature is constituted by a name act and a list ~x of individual input parameters, which need to be instantiated with actual individuals at execution time.2 An effect ei has the form\n[q+i ] \u2227Q \u2212 i A \u2032 i, (1)\nwhere\n\u2022 q+i is an UCQ, i.e., a positive query, which extracts the bulk data to process (obtained as the certain answers of q+i ); the free variables of q + i include the action parameters;\n\u2022 Q\u2212i is an arbitrary ECQ, whose free variables occur all among the free variables of q + i , which\nrefines, by using negation and quantification, the result of q+i . The query [q + i ] \u2227 Q \u2212 i as a whole extracts individual terms to be used to form the new state of the KAB (notice that the UCQ-ECQ division is also a convenience to have readily available the positive part of the condition, which we will exploit later);\n\u2022 A\u2032i is a set of (non-ground) ABox assertions, which include as terms: constants in A0, free variables of q+i , and function terms f(~x) having as arguments ~x free variables of q + i . These\nterms, once grounded with the values extracted from [q+i ] \u2227 Q \u2212 i , give rise to (ground) ABox assertions, which contribute to form the next state of the KAB.\nMore precisely, given the current ABox A of K and a substitution \u03b8 for the input parameters of the action \u03b3, we denote by \u03b3\u03b8 the action instantiated with the actual parameters coming from \u03b8. By firing \u03b3\u03b8 on the state A, we get a new state A\u2032 which is computed by simultaneously applying all instantiated effects of \u03b3\u03b8 as follows:\n\u2022 Each effect ei in \u03b3 of form (1) extracts from A the set ANS(([q+i ] \u2227Q \u2212 i )\u03b8, T,A) of tuples of\nterms in ADOM(A) and, for each such tuple \u03c3, asserts a setA\u2032i\u03b8\u03c3 of ABox assertions obtained from A\u2032i\u03b8 by applying the substitution \u03c3 for the free variables of q + i . For each function term f(~x)\u03b8 appearing in A\u2032i\u03b8, a new ground term is introduced having the form f(~x)\u03b8\u03c3. These terms represent new \u201cconstants\u201d coming from the external environment the KAB is running in.\nWe denote by ei\u03b8(A) the overall set of ABox assertions, i.e.,\nei\u03b8(A) = \u22c3\n\u03c3\u2208ANS(([q+i ]\u2227Q \u2212 i )\u03b8,T,A)\nA\u2032i\u03b8\u03c3.\n2. We disregard a specific treatment of output parameters, and assume instead that the user can freely pose queries over the KB, extracting whatever information she/he is interested in.\n\u2022 Moreover, let EQ(T,A) = {t1 = t2 | \u3008t1, t2\u3009 \u2208 ANS([x1 = x2], T, A)}. Observe that, due to the semantics of queries, the terms in EQ(T,A) must appear explicitly in ADOM(A), that is, the possibly infinite number of equalities due to congruence do not appear in EQ(T,A), though they are logically implied. Hence, the equalities in EQ(T,A) are the equality assertions involving terms in ADOM(A) that either appear explicitly in A, or are obtained by closing these under functionality and congruence of terms.\nThe overall effect of the action \u03b3 with parameter substitution \u03b8 over A is the new ABox A\u2032 = DO(T,A, \u03b3\u03b8) where\nDO(T,A, \u03b3\u03b8) = EQ(T,A) \u222a \u22c3\n1\u2264i\u2264n ei\u03b8(A).\nNotice that the presence of function terms in action effects makes the domain of the ABoxes obtained by executing actions continuously changing and in general unbounded in size. Notice also that we do have a persistence assumption on equalities, i.e., we implicitly copy all equalities holding in the current state to the new one. This implies that, as the system evolves, we acquire new information on equalities between terms, but never lose information on equalities already acquired. Finally, we observe that in the above execution mechanism no persistence/frame assumption (except for equality) is made. In principle at every move we substitute the whole old state, i.e., ABox, with a new one. On the other hand, it should be clear that we can easily write effect specifications that copy big chunks of the old state into the new one. For example, [P (x, y)] P (x, y) copies the entire set of assertions involving the role P . In some sense, the execution mechanism adopted in this paper is very basic and does not address any of the elaboration tolerance issues typical of reasoning about actions, such as the frame problem, ramification problem or qualification problem (Reiter, 2001)3. This is not because we consider them irrelevant, on the contrary, they are relevant and further research on such issues is desirable. We adopt this basic mechanism simply because it is general enough to expose all difficulties we need to overcome in order to get decidability of verification in this setting."}, {"heading": "3.4 Process", "text": "The process component of a KAB is a possibly nondeterministic program that uses the KAB ABoxes to store its (intermediate and final) computation results, and the actions in \u0393 as atomic instructions. The ABoxes can be arbitrarily queried through the KAB TBox T , while they can be updated only through actions in \u0393. To specify such a process component we adopt a rule-based specification.\nSpecifically, a process is a finite set \u03a0 of condition/action rules. A condition/action rule \u03c0 \u2208 \u03a0 is an expression of the form\nQ 7\u2192 \u03b3,\nwhere \u03b3 is an action in \u0393 and Q is an ECQ, whose free variables are exactly the parameters of \u03b3. The rule expresses that, for each tuple \u03b8 for which condition Q holds, the action \u03b3 with actual parameters \u03b8 can be executed. Processes do not force the execution of actions but constrain them: the user of the process will be able to choose any action that the rules forming the process allow. Moreover, our processes inherit entirely their states from the KAB knowledge component (TBox and ABox) (see, e.g., Cohn & Hull, 2009).\n3. But see also the work by Kowalski and Sadri (2011).\nWe observe that we adopt a basic rule-based specification here because, in spite of its simplicity, it is able to expose all the difficulties of our setting. Other choices are also possible, in particular, the process could maintain its own state besides the one of the KAB. As long as such an additional state is finite, or embeddable into the KAB itself, the results here would easily extend to such a case.\nExample 1 Let us consider a KAB K = (T,A0,\u0393,\u03a0) describing a super-heroes comics world, where we have cities in which characters live. Figure 1 shows the TBox T and its rendering as a UML Class Diagram. For the relationship between UML Class Diagrams and Description Logics in general and DL-Lite in particular, we refer to the work by Berardi, Calvanese, and De Giacomo (2005) and by Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodr\u0131\u0301guez-Muro, and Rosati (2009). As for the dynamics of the domain, characters can be superheroes or (super)villains, who fight each other. As in the most classic plot, superheroes help the endeavors of law enforcement fighting villains threatening the city they live in. When a villain reveals himself for perpetrating his nefarious purposes against the city\u2019s peace, he consequently becomes a declared enemy of all superheroes living in that city. Each character lives in one city at the time. A common trait of superheroes is a secret identity: a superhero is said to be the alter ego of some character, which is his identity in common life. Hence, the ABox assertion alterEgo(s, p) means that the superhero s is the alter ego of character p. Villains always try to unmask superheroes, i.e., find their secret identity, in order to exploit such a knowledge to defeat them. Notice the subtle difference here: we use the alterEgo(s, p) assertion to model the fact that s is the alter ego of p, whereas only by asserting s = p we can capture the knowledge that s and p semantically denote the same individual. \u0393 may include actions like the following ones:\nBecomeSH(p, c) : { [Character(p) \u2227 livesIn(p, c) \u2227 \u2203v.Villain(v) \u2227 livesIn(v, c)] {Superhero(sh(p)), alterEgo(sh(p), p)},\nCopyAll }\nstates that if there exists at least one villain living in the city c, a new superhero sh(p) can be created, with the purpose of protecting c. Such a superhero has p as alter ego. CopyAll is a shortcut for explicitly copying all concept and role assertions to the new state (equality assertions are always\nimplicitly copied). Action\nUnmask(s, p) : { [alterEgo(s, p)] {s = p}, CopyAll }\nstates that superhero s, who is the alter ego of p, gets unmasked by asserting the equality between s and p (it is now known that s = p). Action\nFight(v, s) : { \u2203p.[Villain(v) \u2227 Character(p) \u2227 alterEgo(s, p)] \u2227 [s = p] {defeated(v, s)}, CopyAll }\nstates that when villain v fights superhero s, he defeats s if s has been unmasked, i.e., it is known that s is equal to his alter ego. Action\nChallenge(v, s) : { [Villain(v) \u2227 Superhero(s) \u2227 \u2203p.alterEgo(s, p) \u2227 livesIn(p, sc)] \u2227 \u00ac[defeated(v, s)] {livesIn(v, sc), enemy(v, s)},\nCopyAll }\nstates that when villain v challenges superhero s and has not defeated him, next he lives in the same city as s and is an enemy of s. Action\nThreatenCity(v, c) : { [Villain(v) \u2227 Superhero(s) \u2227 \u2203p.alterEgo(s, p) \u2227 livesIn(p, c)]\n{enemy(v, s) \u2227 livesIn(v, c)} CopyAll }\nstates that when villain v threatens city c, then he becomes an enemy of all and only superheroes that live in c.\nA process \u03a0 might include the following rules:\n[Character(p)] \u2227 \u00ac[\u2203s.Superhero(s) \u2227 livesIn(s, c)] 7\u2192 BecomeSH(p, c), [Superhero(s) \u2227 Character(c)] 7\u2192 Unmask(s, c),\n[enemy(v, s)] \u2227 \u00ac[\u2203v\u2032.defeated(v\u2032, s)] 7\u2192 Fight(v, s), [Villain(v) \u2227 Superhero(s)] 7\u2192 Challenge(v, s),\n[Villain(v) \u2227 City(c)] \u2227 \u00ac\u2203v\u2032([Villain(v\u2032) \u2227 livesIn(v\u2032, c)] \u2227 \u00ac[v = v\u2032]) 7\u2192 ThreatenCity(v, c).\nFor instance, the first rule states that a character can become a superhero if the city does not already have one, whereas the last one states that a villain can threaten a city, if the city does not have another villain that is (known to be) distinct from him/her.\nNotice that, during the execution, reasoning on the KB is performed. For instance, consider an initial ABox\nA0 = { Superhero(batman), Villain(joker), alterEgo(batman, bruce), livesIn(bruce, gotham), livesIn(batman, gotham), livesIn(joker, city1) }.\nIn this state, bruce and batman live in the same city, and batman is the alter-ego of bruce, but it is not known whether they denote the same individual. Executing Challenge(joker, batman) in A0, which is indeed allowed by the process \u03a0, generates a new ABox with added assertions enemy(joker, batman), livesIn(joker, gotham), and gotham = city1 is implied by the functionality on livesIn."}, {"heading": "4. KAB Transition System", "text": "The semantics of KABs is given in terms of possibly infinite transition systems that represent the possible evolutions of the KAB over time, as actions are executed according to the process. Notice that such transition systems must be equipped with semantically rich states, since a full KB is associated to them. Formally we define the kind of transition system we need as follows: A transition system \u03a5 is a tuple of the form (U, T,\u03a3, s0, abox ,\u21d2), where:\n\u2022 U is a countably infinite set of terms denoting individuals, called universe;\n\u2022 T is a TBox;\n\u2022 \u03a3 is a set of states;\n\u2022 s0 \u2208 \u03a3 is the initial state;\n\u2022 abox is a function that, given a state s \u2208 \u03a3 returns an ABox associated to s which has as individuals terms of U, and which conforms to T ;\n\u2022 \u21d2 \u2286 \u03a3\u00d7 \u03a3 is a transition relation between pairs of states.\nFor convenience, we introduce the active domain of the whole transition system, defined as ADOM(\u03a5) = \u22c3 s\u2208\u03a3 ADOM(abox (s)). Also we introduce the (predicate) alphabet ALPH(\u03a5) of \u03a5 as the set of concepts and roles occurring in T or in the co-domain of abox . The KAB generates a transition system of this form during its execution. Formally, given a KAB K = (T,A0,\u0393,\u03a0), we define its (generated) transition system \u03a5K = (U, T,\u03a3, s0, abox ,\u21d2) as follows:\n\u2022 U is formed by all constants and all function terms inductively formed starting from ADOM(A0) by applying the functions occurring in the actions in \u0393;\n\u2022 T is the TBox of the KAB;\n\u2022 abox is the identity function (i.e., each state is simply an ABox);\n\u2022 s0 = A0 is the initial state;\n\u2022 \u03a3 and\u21d2 are defined by mutual induction as the smallest sets satisfying the following property: if s \u2208 \u03a3, then for each rule Q 7\u2192 \u03b3, evaluate Q and, for each tuple \u03b8 returned, if DO(T, abox (s), \u03b3\u03b8) is consistent w.r.t. T , then s\u21d2 s\u2032 where s\u2032 = DO(T, abox (s), \u03b3\u03b8).\nNotice that the alphabet ALPH(\u03a5K) of \u03a5K is simply formed by the set ALPH(K) of concepts and roles that occur in K.\nThe KAB transition system \u03a5K is an infinite tree with infinitely many different ABoxes in its nodes, in general. In fact, to get a transition system that is infinite, it is enough to perform indefinitely a simple action that adds new terms at each step, e.g., an action of the form\n\u03b3() : { [C(x)] {C(f(x))}, CopyAll }.\nHence the classical results on model checking (Clarke et al., 1999), which are developed for finite transition systems, cannot be applied directly for verifying KABs."}, {"heading": "5. Verification Formalism", "text": "To specify dynamic properties over KABs, we use a first-order variant of \u00b5-calculus (Stirling, 2001; Park, 1976). \u00b5-calculus is virtually the most powerful temporal logic used for model checking of finite-state transition systems, and is able to express both linear time logics such as LTL and PSL, and branching time logics such as CTL and CTL* (Clarke et al., 1999). The main characteristic of \u00b5-calculus is its ability of expressing directly least and greatest fixpoints of (predicate-transformer) operators formed using formulae relating the current state to the next one. By using such fixpoint constructs one can easily express sophisticated properties defined by induction or co-induction. This is the reason why virtually all logics used in verification can be considered as fragments of \u00b5-calculus. Technically, \u00b5-calculus separates local properties, asserted on the current state or on states that are immediate successors of the current one, from properties talking about states that are arbitrarily far away from the current one (Stirling, 2001). The latter are expressed through the use of fixpoints.\nIn this work, we use a first-order variant of \u00b5-calculus, where we allow local properties to be expressed as ECQs, and at the same time we allow for arbitrary first-order quantification across states. Given the nature of ECQs used for formulating local properties, first-order quantification ranges over terms denoting individuals. Formally, we introduce the logic \u00b5LA defined as follows:\n\u03a6 \u2212\u2192 Q | \u00ac\u03a6 | \u03a61 \u2227 \u03a62 | \u2203x.\u03a6 | \u3008\u2212\u3009\u03a6 | Z | \u00b5Z.\u03a6,\nwhereQ is a possibly open ECQ andZ is a second order predicate variable (of arity 0). We make use of the following abbreviations: \u2200x.\u03a6 = \u00ac(\u2203x.\u00ac\u03a6), \u03a61 \u2228 \u03a62 = \u00ac(\u00ac\u03a61 \u2227 \u00ac\u03a62), [\u2212]\u03a6 = \u00ac\u3008\u2212\u3009\u00ac\u03a6, and \u03bdZ.\u03a6 = \u00ac\u00b5Z.\u00ac\u03a6[Z/\u00acZ]. The formulae \u00b5Z.\u03a6 and \u03bdZ.\u03a6 respectively denote the least and greatest fixpoint of the formula \u03a6 (seen as the predicate transformer \u03bbZ.\u03a6). As usual in \u00b5-calculus, formulae of the form \u00b5Z.\u03a6 (and \u03bdZ.\u03a6) must obey to the syntactic monotonicity of \u03a6 w.r.t. Z, which states that every occurrence of the variable Z in \u03a6 must be within the scope of an even number of negation symbols. This ensures that the least fixpoint \u00b5Z.\u03a6 (as well as the greatest fixpoint \u03bdZ.\u03a6) always exists.\nThe semantics of \u00b5LA formulae is defined over possibly infinite transition systems of the form \u3008U, T,\u03a3, s0, abox ,\u21d2\u3009 seen above. Since \u00b5LA also contains formulae with both individual and predicate free variables, given a transition system \u03a5, we introduce an individual variable valuation v, i.e., a mapping from individual variables x to U, and a predicate variable valuation V , i.e., a mapping from the predicate variables Z to subsets of \u03a3. With these three notions in place, we assign meaning to formulae by associating to \u03a5, v, and V an extension function (\u00b7)\u03a5v,V , which maps formulae to subsets of \u03a3. Formally, the extension function (\u00b7)\u03a5v,V is defined inductively as follows:\n(Q)\u03a5v,V = {s \u2208 \u03a3 | ANS(Qv, T, abox (s)) = true}, (\u00ac\u03a6)\u03a5v,V = \u03a3 \\ (\u03a6) \u03a5 v,V ,\n(\u03a61 \u2227 \u03a62)\u03a5v,V = (\u03a61) \u03a5 v,V \u2229 (\u03a62) \u03a5 v,V ,\n(\u2203x.\u03a6)\u03a5v,V = {s \u2208 \u03a3 | \u2203t.t \u2208 ADOM(abox (s)) and s \u2208 (\u03a6) \u03a5 v[x/t],V }, (\u3008\u2212\u3009\u03a6)\u03a5v,V = {s \u2208 \u03a3 | \u2203s\u2032.s\u21d2 s\u2032 and s\u2032 \u2208 (\u03a6) \u03a5 v,V },\n(Z)\u03a5v,V = V (Z), (\u00b5Z.\u03a6)\u03a5v,V = \u22c2 {E \u2286 \u03a3 | (\u03a6)\u03a5v,V [Z/E] \u2286 E}.\nHere Qv stands for the (boolean) ECQ obtained from Q by substituting its free variables according to v. Intuitively, (\u00b7)\u03a5v,V assigns to such constructs the following meaning:\n\u2022 The boolean connectives have the expected meaning. \u2022 The quantification of individuals is done over the terms of the \u201ccurrent\u201d ABox. Notice that\nsuch terms can be referred in later states where the associated ABox does not include such terms anymore.\n\u2022 The extension of \u3008\u2212\u3009\u03a6 consists of the states s such that, for some state s\u2032 with transition s\u21d2 s\u2032, the formula \u03a6 holds in s\u2032 under valuation v . \u2022 The extension of [\u2212]\u03a6 consists of the states s such that, for all states s\u2032 with transition s\u21d2 s\u2032,\nthe formula \u03a6 holds in s\u2032 under valuation v.\n\u2022 The extension of \u00b5Z.\u03a6 is the smallest subset E\u00b5 of \u03a3 such that, when assigning to Z the extension E\u00b5, the resulting extension of \u03a6 (under valuation v) is contained in E\u00b5. That is, the extension of \u00b5Z.\u03a6 is the least fixpoint of the operator (\u03a6)\u03a5v,V [Z/E], where V [Z/E ] denotes the predicate valuation obtained from V by forcing the valuation of Z to be E . \u2022 Similarly, the extension of \u03bdZ.\u03a6 is the greatest subset E\u03bd of \u03a3 such that, when assigning to Z the extension E\u03bd , the resulting extension of \u03a6 contains E\u03bd . That is, the extension of \u03bdZ.\u03a6 is the greatest fixpoint of the operator (\u03a6)\u03a5v,V [Z/E]. Formally, (\u03bdZ.\u03a6) \u03a5 v,V = \u22c3 {E \u2286 \u03a3 | E \u2286\n(\u03a6)\u03a5v,V [Z/E]}.\nWhen \u03a6 is a closed formula, (\u03a6)\u03a5v,V does not depend on v or V , and we denote the extension of \u03a6 simply by (\u03a6)\u03a5 . A closed formula \u03a6 holds in a state s \u2208 \u03a3 if s \u2208 (\u03a6)\u03a5 . In this case, we write \u03a5, s |= \u03a6. A closed formula \u03a6 holds in \u03a5, denoted by \u03a5 |= \u03a6, if \u03a5, s0 |= \u03a6. We call model checking the problem of verifying whether \u03a5 |= \u03a6 holds.\nThe next example shows some simple temporal properties that can be expressed in \u00b5LA.\nExample 2 Considering the KAB of Example 1, we can easily express temporal properties as the following ones.\n\u2022 From now on all current superheroes that live in Gotham will live in Gotham forever (a form of safety):\n\u2200x.[Superhero(x) \u2227 livesIn(x, gotham)] \u2283 \u03bdZ.([livesIn(x, gotham)] \u2227 [\u2212]Z).\n\u2022 Eventually all current superheroes will be unmasked (a form of liveness):\n\u2200x.[Superhero(x)] \u2283 \u00b5Z.([alterEgo(x, x)] \u2228 [\u2212]Z).\n\u2022 There exists a possible future situation where all current superheroes will be unmasked (another form of liveness):\n\u2200x.[Superhero(x)] \u2283 \u00b5Z.([alterEgo(x, x)] \u2228 \u3008\u2212\u3009Z).\n\u2022 Along every future, it is always true, for every superhero, that there exists an evolution that eventually leads to unmask him (a form of liveness that holds in every moment):\n\u03bdY.(\u2200x.[Superhero(x)] \u2283 \u00b5Z.([alterEgo(x, x)] \u2228 \u3008\u2212\u3009Z)) \u2227 [\u2212]Y.\nConsider two transition systems sharing the same universe and the same predicate alphabet. We say that they are behaviorally equivalent if they satisfy exactly the same \u00b5LA formulas. To formally capture such an equivalence, we make use of the notion of bisimulation (Milner, 1971), suitably extended to deal with query answering over KBs.\nGiven two transition systems \u03a51 = \u3008U, T,\u03a31, s01, abox 1,\u21d21\u3009 and \u03a52 = \u3008U, T,\u03a32, s02, abox 2,\u21d22\u3009 sharing the same universe U, the same TBox T , and such that ALPH(\u03a51) = ALPH(\u03a52) = \u039b, a bisimulation between \u03a51 and \u03a52 is a relation B \u2286 \u03a31 \u00d7 \u03a32 such that (s1, s2) \u2208 B implies that:\n1. abox (s1) \u2261T,\u039b abox (s2); 2. if s1 \u21d21 s\u20321, then there exists s\u20322 such that s2 \u21d22 s\u20322 and (s\u20321, s\u20322) \u2208 B; 3. if s2 \u21d22 s\u20322, then there exists s\u20321 such that s1 \u21d21 s\u20321 and (s\u20321, s\u20322) \u2208 B.\nWe say that two states s1 and s2 are bisimilar if there exists a bisimulation B such that (s1, s2) \u2208 B. Two transition systems \u03a51 with initial state s01 and \u03a52 with initial state s02 are bisimilar if (s01, s02) \u2208 B. The following theorem states that the formula evaluation in \u00b5LA is indeed invariant w.r.t. bisimulation, so we can equivalently check any bisimilar transition systems.\nTheorem 4 Let \u03a51 and \u03a52 be two transition systems that share the same universe, the same TBox, and the same predicate alphabet, and that are bisimilar. Then, for two states s1 of \u03a51 and s2 of \u03a52 (including the initial ones) that are bisimilar, and for all closed \u00b5LA formulas \u03a6, we have that\ns1 \u2208 (\u03a6)\u03a51 iff s2 \u2208 (\u03a6)\u03a52 .\nProof. The proof is analogous to the standard proof of bisimulation invariance of \u00b5-calculus (Stirling, 2001), though taking into account our bisimulation, which guarantees that ECQs are evaluated identically over bisimilar states. Notice that the assumption that the two transition systems share the same universe and the same predicate alphabet makes it easy to compare the answers to queries.\nMaking use of such a notion of bisimulation, we can, for example, redefine the transition system generated by a KAB K = (T,A0,\u0393,\u03a0) while maintaining bisimilarity, by modifying the definition of \u03a5K = \u3008U, T,\u03a3, s0, abox ,\u21d2\u3009 given in Section 4 as follows.\n(i) We modify DO() so that no function term t\u2032 is introduced in the generated ABox A\u2032 if in the current ABox4 A there is already a term t such that (T,A) |= t = t\u2032. (ii) If the ABox A\u2032 = DO(T, abox (s), \u03b3\u03b8) obtained from the current state s is logically equivalent to the ABox abox (s\u2032\u2032), for some already generate state s\u2032\u2032, we do not generate a new state, but simply add s\u21d2 s\u2032\u2032 to \u03a5K."}, {"heading": "6. Verification of KABs", "text": "It is immediate to see that verification of KABs is undecidable in general as it is easy to represent Turing machines using a KAB. Actually we can do so using only a fragment of the capabilities of KABs, as shown in the next lemma.\nLemma 5 Checking formulas of the form \u00b5Z.(N(a) \u2228 \u3008\u2212\u3009Z), where N is an atomic concept and a is an individual occurring in A0, is undecidable already for a KAB K = (T,A0,\u0393,\u03a0) where:\n4. Note that all terms that are present in the current ABox are preserved in the new ABox, together with equalities between terms.\n\u2022 T is the empty TBox, \u2022 the actions in \u0393 make no use of negation nor equality, \u2022 \u03a0 is the trivial process that poses no restriction on executability of actions.\nProof. Given a Turing machineM = \u3008Q,\u03a3, q0, \u03b4, qf , \u3009, we show how to construct a corresponding KAB KM = (\u2205, A0,\u0393,\u03a0) that mimics the behavior of M. Specifically, we encode the halting problem for M as a verification problem over KM. Roughly speaking, KM maintains the tape and state information in the (current) ABox, and encodes the transitions of M as actions. Our construction makes use of a tape that initially contains a unique cell, represented by the constant 0, and is extended on-the-fly as needed: cells to the right of 0 are represented by function terms of the form n(n(\u00b7 \u00b7 \u00b7 (0) \u00b7 \u00b7 \u00b7 )), while cells to the left of 0 are represented by function terms of the form p(p(\u00b7 \u00b7 \u00b7 (0) \u00b7 \u00b7 \u00b7 )). Then, we make use of one constant aq for each state q \u2208 Q, of one constant av for each tape symbol value v \u2208 \u03a3, of a special constant #, and of the following concepts and roles: \u2022 cell(c, h) models a cell of the tape, where c is a cell identifier, and h corresponds to the current\nstate ofM, if the head ofM currently points to c, or to # if the head does not currently point to c; \u2022 next(cl, cr) models the relative position of cells, stating that cr is the cell immediately fol-\nlowing cl; \u2022 value(c, v) models that cell c currently contains value v, with v \u2208 \u03a3; \u2022 First(c) and Last(c) respectively denote the current first cell and last cell of the portion of\ntape explored so far. \u2022 Stop(c) is used to detect whenM halts.\nThe initial state of KM contains a unique cell and is defined as\nA0 = { cell(0, aq0), value(0, a ), First(0), Last(0) }.\nAs for the action component, \u0393 contains an action with no parameters for each transition in \u03b4, while the process \u03a0 poses no restriction on executability of actions, i.e., it contains a rule true 7\u2192 \u03b3() for each such action \u03b3.\nWe now provide the specification of actions, detailing the case of a right shift transition \u03b4(q, v, q\u2032, v\u2032, R). The corresponding action specification consists of the set of effects shown in Figure 2. The first effect maintains the first position of the tape unaltered. The second and third\neffects deal with the cell values. They remain the same except for the current cell, that is updated according to the transition. The next three effects deal with the right shift and the Turing Machine state. If the current cell has a next cell and therefore is not the last one, then the head is moved to the next cell and the state change ofM is recorded there. In this case the last cell remains the same. If instead the current cell is the last one, before moving the head the tape must be properly extended. The function n/1 is used to create the identifier of this new successor cell, starting from the identifier of the current one. Furthermore, since the transition corresponds to a right shift of one cell, the first cell and all the cells immediately following a cell marked # will be marked # in the next state. Finally, the last effect is used to identify the case in whichM has reached a final state. This is marked by inserting into the new state the special assertion Stop(0).\nThe construction for a left shift transition is done symmetrically, using the function p/1 to create a new predecessor cell. By construction, KM satisfies the conditions of the theorem. Observe that, in the transition system \u03a5KM generated by KM, every action corresponding to every transition of M can be executed in each ABox/state s of \u03a5KM , and since T is empty, it will actually generate a successor state of s. However, in each state, only the (unique) action that corresponds to the actually executed transition ofM will generate a successor state containing an ABox assertion of the form cell(c, aq), for some state q ofM. Therefore, only those ABoxes/states properly corresponding to configurations ofM could eventually lead to an ABox/state in \u03a5KM where Stop(0) holds. And the latter will happen if and only ifM halts. More precisely, one can show by induction on the length respectively of a halting computation ofM and of the shortest path from the initial state of \u03a5KM to a state where Stop(0) holds, thatM halts if and only if KM |= \u00b5Z.([Stop(0)] \u2228 \u3008\u2212\u3009Z), which concludes the proof.\nFrom the previous lemma, which shows undecidability already in a special case, we immediately obtain the following result.\nTheorem 6 Verification of \u00b5LA formulae over KABs is undecidable.\nWe observe that Lemma 5 uses a KB that is constituted only by an ABox containing concept and role assertions, and makes use only of conjunctive queries in defining actions effects. Moreover, the formula that we check makes no use of quantification at all, and can simply be seen as a propositional CTL formula of the form EFp, expressing that proposition p eventually holds along one path."}, {"heading": "7. Verification of Weakly Acyclic KABs", "text": "In spite of Theorem 6, next we introduce a notable class of KABs for which verification of arbitrary \u00b5LA properties is decidable. To do so, we rely on a syntactic restriction that resembles the notion of weak acyclicity in data exchange (Fagin et al., 2005)5, and that guarantees boundedness of ABoxes generated by the execution of the KAB and, in turn, decidability of verification.\nNow we are ready to introduce the notion of weak acyclicity in our context. We introduce the edge-labeled directed dependency graph of a KAB K = (T,A0,\u0393,\u03a0), defined as follows. Nodes, called positions, are obtained from the TBox T: there is a node for every concept name N in T , and two nodes for every role name P in T , corresponding to the domain and to the range of P . Edges\n5. We use the original definition of weak acyclicity. However, our results can be applied also to other variants of weak acyclicity (see discussion in Section 9).\nare drawn by considering every effect specification [q+] \u2227 Q\u2212 A\u2032 of each action contained in \u0393, tracing how values are copied or contribute to generate new values as the system progresses. In particular, let p be a position corresponding to a concept/role component in the rewriting rewT (q+) of q+ with variable x. For every position p\u2032 in A\u2032 with the same variable x, we include a normal edge p \u2192 p\u2032. For every position p\u2032\u2032 in A\u2032 with a function term f(~t) such that x \u2208 ~t, we include a special edge p \u2217\u2212\u2192 p\u2032\u2032. We say that K is weakly-acyclic if its dependency graph has no cycle going through a special edge.\nExample 3 The KAB of Example 1 is weakly acyclic. Its dependency graph, shown in Figure 3, does not contain any cycle going through special edges. For readability, self-loops are not shown in the Figure (but are present for all nodes), and dashed edges are used to compactly represent the contributions given by the rewriting of the queries. E.g., the dashed edge form Villain to Character denotes that for every outgoing edge from Character, there exists an outgoing edge from Villain with the same type and target. Hence, w.r.t. weak acyclicity dashed edges can be simply replaced by normal edges.\nWe are now ready to state the main result of this work, which we are going to prove in the remainder of this section.\nTheorem 7 Verification of \u00b5LA properties for a weakly acyclic KAB is decidable in EXPTIME in the size of the KAB.\nWe observe that the restriction imposed by weak acyclicity (or variants) is not too severe, and in many real cases KABs are indeed weakly acyclic or can be transformed into weakly acyclic ones at cost of redesign. Indeed, weakly acyclic KABs cannot indefinitely generate new values from the old ones, which then depend on a chain of unboundedly many previous values. In other words, current values depend only on a bounded number of old values. While unbounded systems exist in theory, e.g., Turing machines, higher level processes, as those in business process management or service-oriented modeling, typically require such a boundedness in practice. How to systematically transform systems into weakly acyclic ones remains an open issue.\nIn the remainder of this section we present the proof of Theorem 7. We do so in several steps:\n1. Normalized KAB. First we introduce a normalized form K\u0302 of the KABK, which isolates the contribution of equalities and of the TBox in actions effects of the KAB. An important point is that normalizing the KAB preserves weak acyclicity.\n2. Normalized DO(). Then, we introduce a normalized version DONORM() of DO(), which avoids to consider equalities in generating the bulk set of tuples to be used in the effects to generate the next ABox. The transition system \u03a5K\u0302,NORM generated through this normalized version\nDONORM() of DO() by the normalized KAB K\u0302 is bisimilar to the transition system \u03a5K generated through DO() by K. Hence the two transition systems satisfy the same \u00b5LA formulae.\n3. Positive dominant. The next step is to introduce what we call the positive dominant K++ of the normalized KAB K\u0302. This is obtained from K\u0302 essentially by dropping equalities, negations, and TBox. However K++ contains enough information in the positive part so that, when we drop all of these features, the active domain of the transition system \u03a5K++ generated by K++ \u201coverestimates\u201d the active domain of the transition system \u03a5K\u0302,NORM generated by the normalized KAB K\u0302. Moreover, if the normalized (and hence the original) KAB is weakly acyclic, so is its positive dominant. Finally if the positive dominant is weakly acyclic then the size of the active domain of its transition system \u03a5K++ is polynomially bounded by the size of its initial ABox, and hence so is the size of the active domain of \u03a5K\u0302,NORM. This implies that the size of \u03a5K\u0302,NORM is finite and at most exponential in the size of its initial ABox.\n4. Putting it all together. Tying these results together, we get the claim.\nIn the following, we detail each of these steps."}, {"heading": "7.1 Normalized KAB", "text": "Given a KAB K = (T,A0,\u0393,\u03a0), we build a KAB K\u0302 = (T, A\u03020, \u0393\u0302,\u03a0), called the normalized form of K, by applying a sequence of transformations that preserve the semantics of K while producing a KAB of a format that is easier to study.\n1. We view each ABoxA as partitioned into a part collecting all concept and role assertions, and a part collecting all equality assertions. We denote with A 6EQ the former and with EQ(T,A) the latter, after having closed it w.r.t. (the functionality assertions in) the TBox T . Notice that such a closure can be computed in polynomial time in the size of A and T .\n2. In K\u0302 all individuals appearing in equality assertions in an ABox also occur in special concept assertions of the form Dummy(t), where the concept Dummy is unrelated to the other concepts and roles in the KAB. We do so by:\n\u2022 adding concept assertions Dummy(t) for each t in an equality assertion in A0 that does not appear elsewhere; \u2022 adding to the right-hand part of each action effect ei a concept assertion Dummy(t) for\neach t in an equality assertion in the right-hand part of ei; \u2022 adding to each action an effect specification of the form\n[Dummy(x)] {Dummy(x)}.\nNotice that, as the result of this transformation, we get ABoxes containing the additional concept Dummy , which however is never queried by actions effects and by the rules forming the process. The impact of the transformation is simply that now the ADOM(A) of the ABoxes\nA in the KAB transition system can be readily identified as the set of terms occurring in concept and role assertion only (without looking at equality assertions).\nGiven an ABoxA, we denote by A\u0302 the result of the two above transformations, which respectively add to A the closure of equalities and the extension of Dummy .\n3. We manipulate each resulting effect specification\n[q+] \u2227Q\u2212 A\u0302\u2032\nas follows:\n3.1. We replace [q+]\u2227Q\u2212 by [rewT (q+)]\u2227 rewT (Q\u2212) (Calvanese et al., 2007a), exploiting the results by Calvanese et al. (2007b) and by Artale et al. (2009), which guarantee that, for every ECQ Q and every ABox A where equalities are closed under functionality and congruence, we have that\nANS(Q,T,A) = ANS(rewT (Q), \u2205, A).\n3.2. We replace each effect specification [rewT (q+)] \u2227 rewT (Q\u2212) A\u0302\u2032, resulting from Step 3.1, by a set of effect specifications [q+i ]\u2227 rewT (Q\u2212) A\u0302\u2032, one for each CQ qi in the UCQ rewT (q+). 3.3. For each effect specification [q+i ] \u2227 rewT (Q\u2212) A\u0302\u2032, we re-express q + i so as to make\nequalities used to join terms explicit and so as to remove constants from q+i . Specifically, we replace the effect specification by\n[q++i ] \u2227 q = \u2227 rewT (Q\u2212) A\u0302\u2032,\nwhere:\n\u2022 q++i is the CQ without repeated variables obtained from q + i by (i) replacing for each\nvariable x occurring in q+i , the j-th occurrence of x except for the first one, by x [j];\nand (ii) replacing each constant c with a new variable xc; \u2022 q= = \u2227 [x = x[j]] \u2227 \u2227 [xc = c] where (i) the first conjunction contains one equality\n[x = x[j]] for each variable x in q+i and for each variable x [j] introduced in the step above, and (ii) the second conjunction contains one equality for each constant c in q+i .\nTo clarify the latter consider the following example:\nExample 4 Given a query\n[q+i ] . = [N(x) \u2227 P1(x, y) \u2227 P2(c, x)],\nStep 3.3 above replaces it by [q++i ] \u2227 q=, where\nq++i . = N(x) \u2227 P1(x[2], y) \u2227 P2(xc, x[3]), q= . = [x = x[2]] \u2227 [x = x[3]] \u2227 [xc = c].\nAs for the correctness of Step 3.3, it is immediate to notice that [q+i ] is equivalent to [q ++ i \u2227\u2227 (x = x[j])\u2227 \u2227\n(xc = c)]. The equivalence between the latter and [q++i ]\u2227q= is a consequence of the construction by Artale et al. (2009), which shows that query entailment in the presence of equalities can be reduced to query evaluation by saturating equalities w.r.t. transitivity, reflexivity, symmetry, and functionality.\nGiven an action \u03b3, we denote by \u03b3\u0302 the action normalized as above.\nSince all transformations preserve logical equivalence (as long as we do not query Dummy), we have\nLemma 8 DO(T,A, \u03b3\u03b8) \u2261T,ALPH(K) DO(T, A\u0302, \u03b3\u0302\u03b8).\nAlso the normalization of a KAB preserves weak acyclicity, which is a crucial consideration for later results.\nLemma 9 If K is weakly acyclic, then also K\u0302 is weakly acyclic.\nProof. Consider each effect specification [q+] \u2227 Q\u2212 A\u2032 belonging to an action in K. The contribution of this effect specification to the dependency graph G of K is limited to each CQ qi in the UCQ rewT (q+), and to the set of concept and role assertions of A\u2032. We observe that each such qi corresponds to a query q++i in K\u0302 in which each variable of qi occurs exactly once. For every free variable x of qi that also appears inA\u2032, and for every occurrence of x in qi itself, an edge is included in G. In the dependency graph G\u0302 of K\u0302, only one of such edges appears, corresponding to the single occurrence of the variable x in q++i .\nNotice that Dummy can be omitted from the dependency graph of G\u0302 since, by definition of K\u0302, Dummy does not occur in the left-hand side of effects except for the trivial effect [Dummy(x)] {Dummy(x)}. This is not true for K, where Dummy is needed. Therefore, G\u0302 is indeed a subgraph of G, and hence weak acyclicity of G implies weak acyclicity of G\u0302.\n7.2 Normalized DO()\nNext we give a simplified version of DO(), which we call DONORM(). We start by observing that we can reformulate the definition of DO() given in Section 3. For that, we first need to define a suitable notion of join of two queries. Let q1 and q2 be two ECQs, which may have free variables in common, and let A1 and A2 be two ABoxes. Then we define ANS(q1, \u2205, A1) ./ ANS(q2, \u2205, A2) as the set of substitutions \u03c3 over the free variables in q1 and q2 such that qi holds in \u2205, Ai under \u03c3, i.e., \u2205, Ai, \u03c3 |= qi, for i \u2208 {1, 2}. Then, given an action \u03b3\u0302 with parameters substitution \u03b8 and an ABox A\u0302, we have\nDO(T, A\u0302, \u03b3\u0302\u03b8) = \u22c3 e in \u03b3\u0302 APPLY(T, A\u0302, e, \u03b8),\nwhere for an effect specification e : [q++] \u2227 q= \u2227Q\u2212 A\u0302\u2032, we have\nAPPLY(T, A\u0302, e, \u03b8) = \u22c3 A\u0302\u2032\u03b8\u03c3\n\u03c3\u2208ANS(q++\u03b8,\u2205,A\u0302)./ANS((q=\u2227Q\u2212)\u03b8,\u2205,A\u0302)\n\u222a EQ(T, A\u0302).\nInstead, we define DONORM() as\nDONORM(T, A\u0302, \u03b3\u0302\u03b8) = \u22c3 e in \u03b3\u0302 APPLYNORM(T, A\u0302, e, \u03b8),\nwhere, for an effect specification e : [q++] \u2227 q= \u2227Q\u2212 A\u0302\u2032, we have\nAPPLYNORM(T, A\u0302, e, \u03b8) = \u22c3 A\u0302\u2032\u03b8\u03c3\n\u03c3\u2208ANS(q++\u03b8,\u2205,A\u0302 6EQ)./ANS((q=\u2227Q\u2212)\u03b8,\u2205,A\u0302)\n\u222a EQ(T, A\u0302).\nNotice that the only difference between DO() and DONORM() is that in the latter we use only A\u0302 6EQ instead of A\u0302 to compute the answers to the CQs q++\u03b8. The following lemma shows that the applications of DO() and of DONORM() give rise to logically equivalent ABoxes.\nLemma 10 DO(T, A\u0302, \u03b3\u0302\u03b8) \u2261T,ALPH(K) DONORM(T, A\u0302, \u03b3\u0302\u03b8).\nProof. In order to prove the claim, it is enough to show that for each concept/role assertion \u03b12 \u2208 DONORM(T, A\u0302, \u03b3\u0302\u03b8) whose concept/role name belongs to ALPH(K), we have that (T, DO(T, A\u0302, \u03b3\u0302\u03b8)) |= \u03b12, and for each concept/role assertion \u03b11 \u2208 DO(T, A\u0302, \u03b3\u0302\u03b8) whose concept/role name belongs to ALPH(K), we have that (T, DONORM(T, A\u0302, \u03b3\u0302\u03b8)) |= \u03b11. We actually prove a slightly stronger result:\n(1) For each ABox assertion \u03b12 \u2208 APPLYNORM(T, A\u0302, e, \u03b8), we have that (T, APPLY(T, A\u0302, e, \u03b8)) |= \u03b12.\n(2) For each ABox assertion \u03b11 \u2208 APPLY(T, A\u0302, e, \u03b8), we have that (T, APPLYNORM(T, A\u0302, e, \u03b8)) |= \u03b11.\nFor (1), by monotonicity of q++ and the fact that A\u0302 6EQ \u2286 A\u0302, we have that\u22c3 A\u0302\u2032\u03b8\u03c3\n\u03c3\u2208(ANS(q++\u03b8,\u2205,A\u0302 6EQ)./ANS((q=\u2227Q\u2212)\u03b8,\u2205,A\u0302))\nis contained in \u22c3 A\u0302\u2032\u03b8\u03c3,\n\u03c3\u2208(ANS(q++\u03b8,\u2205,A\u0302)./ANS((q=\u2227Q\u2212)\u03b8,\u2205,A\u0302))\nhence the claim follows. For (2), consider an ABox assertion \u03b1 \u2208 APPLY(T, A\u0302, e, \u03b8). By definition of APPLY(), we know that there exists an effect e : [q++] \u2227 q= \u2227 Q\u2212 A\u0302\u2032 and an assignment \u03c3 to the free variables of q++ (which include also the free variables of q= \u2227 Q\u2212) such that \u03c3 \u2208 (ANS(q++\u03b8, \u2205, A\u0302) ./ ANS((q= \u2227 Q\u2212)\u03b8, \u2205, A\u0302)) and \u03b1 \u2208 A\u0302\u2032\u03b8\u03c3. Let {x1, . . . , xn} be all free variables in q++\u03b8, and \u03c3 = {x1 \u2192 t1, . . . , xn \u2192 tn, }. For each variable xi, let N(xi) be the (unique) concept atom in q++\u03b8 in which xi occurs (similar considerations hold when xi occurs in a role atom). Then, either N(ti) \u2208 A\u0302 6EQ, or for some t\u2032i, N(t\u2032i) \u2208 A\u0302 6EQ and (ti = t\u2032i) \u2208 EQ(T, A\u0302). In the former case, let t\u2032\u2032i denote ti, while in the latter case let t \u2032\u2032 i denote t \u2032 i. Then, consider the substitution \u03c3\u2032 = {x1 \u2192 t\u2032\u20321, . . . , xn \u2192 t\u2032\u2032n, }. By construction, we have that \u03c3\u2032 \u2208 ANS(q++\u03b8, \u2205, A\u0302 6EQ), and since \u03c3 \u2208 ANS((q= \u2227Q\u2212)\u03b8, \u2205, A\u0302), and (t\u2032\u2032i = ti) \u2208 EQ(T, A\u0302) for each i \u2208 {1, . . . , n}, we also have that \u03c3\u2032 \u2208 ANS(q++\u03b8, \u2205, A\u0302 6EQ) ./ ANS((q= \u2227Q\u2212)\u03b8, \u2205, A\u0302). Since \u2022 \u03b1 \u2208 A\u0302\u2032\u03b8\u03c3,\n\u2022 \u03c3 and \u03c3\u2032 are identical modulo EQ(T, A\u0302) and \u2022 EQ(T, A\u0302) \u2286 APPLYNORM(T, A\u0302, e, \u03b8),\nwe can infer that (T, APPLYNORM(T, A\u0302, e, \u03b8)) |= \u03b1. Hence the claim holds. By combining Lemma 8 and Lemma 10, we get that DO() on K and DONORM() on K\u0302 behave equivalently, when starting from equivalent ABoxes.\nLemma 11 If A1 \u2261T,ALPH(K) A2 then DO(T,A1, \u03b3\u03b8) \u2261T,ALPH(K) DONORM(T,A2, \u03b3\u0302\u03b8).\nProof. The claim is a direct consequence of Lemma 8, Lemma 10, the equivalence between A1 and A2, and the observation that logical equivalence is transitive.\nGiven a KAB K and its normalized version K\u0302, we call the transition system generated in the same way as \u03a5K, but using DONORM() on K\u0302 instead of DO() on K, the normalized transition system generated by K\u0302, and denote it with \u03a5K\u0302,NORM.\nLemma 12 Given a KAB K, the transition systems \u03a5K and \u03a5K\u0302,NORM are bisimilar.\nProof. Let \u03a5K = (U, T,\u03a3, s0, abox ,\u21d2) and \u03a5K\u0302,NORM = (U, T,\u03a3NORM, s0, abox NORM,\u21d2NORM). We define the relation B \u2286 \u03a3 \u00d7 \u03a3NORM as follows: (s1, s2) \u2208 B iff abox (s1) \u2261T,ALPH(K) abox NORM(s2) and show that B is a bisimulation. To do so, we prove that B is closed under the definition of bisimulation itself. Indeed, if (s1, s2) \u2208 B, then: \u2022 abox (s1) \u2261T,ALPH(K) abox (s2) by definition. \u2022 If s1 \u21d2 s\u20321 then there exists an action \u03b3 and a substitution \u03b8 such that s\u20321 =\nDO(T, abox (s1), \u03b3\u03b8) (notice that abox (s1) = s1) and s\u20321 is consistent w.r.t. T . Now let us consider s\u20322 = DONORM(T, abox (s2), \u03b3\u0302\u03b8). Since abox (s1) \u2261T,ALPH(K) abox (s2), then by Lemma 11, we have s\u20321 \u2261T,ALPH(K) s\u20322. Therefore, s\u20322 is consistent w.r.t. T , and hence s2 \u21d2NORM s\u20322, and (s\u20321, s\u20322) \u2208 B. \u2022 Similarly, if s2 \u21d2NORM s\u20322 then there exists an action \u03b3\u0302 and a substitution \u03b8 such that s\u20322 = DONORM(T, abox (s2), \u03b3\u0302\u03b8) and s \u2032 2 is consistent w.r.t. T . Now let us consider s \u2032 1 =\nDO(T, abox (s1), \u03b3\u03b8). Since s2 \u2261T,ALPH(K) s1, then by by Lemma 11, we have s\u20322 \u2261T,ALPH(K) s\u20321 Therefore, s \u2032 1 is consistent w.r.t. T , and hence s1 \u21d2 s\u20321, and, considering that equivalence enjoys symmetry, we have (s\u20321, s \u2032 2) \u2208 B.\nThis proves the claim.\nThe direct consequence of the above lemma is that, by considering the Bismulation Invariance Theorem 4, we can faithfully check \u00b5LA formulas over \u03a5K\u0302,NORM instead of \u03a5K."}, {"heading": "7.3 Positive Dominant", "text": "Our next step is to show that for a weakly acyclic KABK, the normalized transition system \u03a5K\u0302,NORM is finite. We do so by considering another transition system, which is behaviorally unrelated to \u03a5K\u0302,NORM, and hence to \u03a5K, but whose active domain bounds the active domain of \u03a5K\u0302,NORM. We obtain such a transition system essentially by ignoring all negative information and equalities. This allows us to refer back to the literature on data exchange to show boundedness. We call such a transition system positive dominant.\nGiven a normalized KAB K\u0302 = (T, A\u03020, \u0393\u0302,\u03a0), we define the positive dominant of K as the KAB\nK+ = (\u2205, A\u03020 6EQ , {\u03b3+}, {true 7\u2192 \u03b3+}).\nThe only action \u03b3+ is without parameters and its effect specification is constituted by CopyAll and by one effect of the form\n[q++i ] A \u2032 i 6EQ\nfor each effect [q++i ] \u2227 q=i \u2227 Q \u2212 i A \u2032 i in every action of \u0393\u0302. Observe that the parameters of the actions in \u0393\u0302 become simply free variables in \u03b3+. Notice that \u03b3+ is applicable at every step because the process trivially always allows it. The resulting state is always consistent, since K+ has an empty TBox. Moreover, no equality assertion is ever generated. The transition system \u03a5K+ is constituted by a single run, which incrementally accumulates all the facts that can be derived by the iterated application of \u03b3+ over such increasing ABox. This behavior closely resembles the chase of tuple-generating dependencies (TGDs) in data exchange, where an application of \u03b3+ corresponds to a \u201cparallel\u201d chase step (Deutsch, Nash, & Remmel, 2008).\nFrom a technical point of view, notice that K+ is already in normalized form (i.e., K+ = K\u0302+), and that DO() and DONORM() are identical since neither equality nor negation are considered. Hence \u03a5K+ = \u03a5K\u0302+,NORM.\nThe next lemma shows that K+ preserves weak acyclicity of K\u0302.\nLemma 13 If K\u0302 is weakly acyclic then also its positive dominant K+ is weakly acyclic.\nProof. The claim follows from the fact that, by construction, the dependency graph G+ of K+ is equal to G\u0302. Indeed, both q++i and its connection with A\u0302i are preserved by K+. Hence, we get the claim.\nNext we show that if K+ is weakly acyclic the active domain of the ABoxes in its transition system \u03a5K+ are polynomially bounded by the active domain of the initial ABox.\nLemma 14 If K+ is weakly acyclic, then there exists a polynomial P(\u00b7) such that\n|ADOM(\u03a5K+)| < P(|ADOM(A\u03020 6EQ )|).\nProof. We observe that there exists a strict connection between the execution of K+ and the chase of a set of TGDs in data exchange. Therefore, the proof closely resembles the one by Fagin et al. (2005, Thm. 3.9), where it is shown that for weakly acyclic TGDs, every chase sequence is bounded.\nLet \u03a5K+ = (U, \u2205,\u03a3, A0 6EQ, abox ,\u21d2), let G+ = (V,E) be the dependency graph of K+, and let n = |ADOM(A0 6EQ)|. For every node p \u2208 V , we consider an incoming path to be any (finite or infinite) path ending in p. Let rank(p) be the maximum number of special edges on any such incoming path. SinceK+ is weakly acyclic by hypothesis, G+ does not contain cycles going through special edges, and therefore rank(p) is finite. Let r be the maximum among rank(pi) over all nodes. We observe that r \u2264 |V |; indeed no path can lead to the same node twice using special edges, otherwise G+ would contain a cycle going through special edges, thus breaking the weak acyclicity hypothesis. Next we observe that we can partition the nodes in V according to their rank, obtaining a set of sets {V0, V1, . . . , Vr}, where Vi is the set of all nodes with rank i.\nLet us now consider a state A obtained from A0 6EQ by applying the only action \u03b3+ contained in K+ an arbitrary number of times. We now prove, by induction on i, the following claim: for every i there exists a polynomial Pi such that the total number of distinct values c that occur in A at positions in Vi is at most Pi(n).\n(Base case) Consider p \u2208 V0. By definition, p has no incoming path containing special edges. Therefore, no new values are stored in p along the run A0 6EQ \u21d2 \u00b7 \u00b7 \u00b7 \u21d2 A. Indeed p can just store values that are part of the initial ABox A0 6EQ. This holds for all nodes in V0 and hence we can fix P0(n) = n.\n(Inductive step) Consider p \u2208 Vi, with i \u2208 {1, . . . , r}. The first kind of values that may be stored inside p are those values that were stored inside p itself in A0 6EQ. The number of such values is at most n. In addition, a value may be stored in p for two reasons: either it is copied from some other position p\u2032 \u2208 Vj with i 6= j, or it is generated as a possibly new function term, built when applying effects that contain a function in their head.\nWe first determine the number of fresh individuals that can be generated from function terms. The possibility of generating and storing a new value in p as a result of an action is reflected by the presence of special edges. By definition, any special edge entering p must start from a node p\u2032 \u2208 V0 \u222a \u00b7 \u00b7 \u00b7 \u222a Vi\u22121. By induction hypothesis, the number of distinct values that can exist in p\u2032 is bounded by H(n) = \u2211 j\u2208{0,...,i\u22121} Pj(n). Let ba be the maximum number of special edges that enter a position, over all positions in the TBox; ba bounds the arity taken by each function term contained in \u03b3. Then for every choice of ba values in V0 \u222a \u00b7 \u00b7 \u00b7 \u222aVi\u22121 (one for each special edge that can enter a position), the number of new values generated at position p is bounded by tf \u00b7 H(n)ba , where tf is the total number of facts contained in all effects of \u03b3+. Note that this number does not depend on the data in A0 6EQ. By considering all positions in Vi, the total number of values that can be generated is then bounded by F(n) = |Vi| \u00b7 tf \u00b7 H(n)ba . Clearly, F(\u00b7) is a polynomial, because tf and ba are determined by \u03b3+.\nWe count next the number of distinct values that can be copied to positions of Vi from positions of Vj , with j 6= i. A copy is represented in the graph as a normal edge going from a node in Vj to a node in Vi, with j 6= i. We observe first that such normal edges can start only from nodes in V0\u222a\u00b7 \u00b7 \u00b7\u222aVi\u22121, that is, they cannot start from nodes in Vj with j > i. We prove this by contradiction. Assume that there exists p\u2032 \u2192 p \u2208 E, such that p \u2208 Vi and p\u2032 \u2208 Vj with j > i. In this case, the rank of p would be j > i, which contradicts the fact that p \u2208 Vi. As a consequence, the number of distinct values that can be copied to positions in Vi is bounded by the total number of values in V0 \u222a \u00b7 \u00b7 \u00b7 \u222a Vi\u22121, which corresponds toH(n) from our previous consideration.\nPutting it all together, we define Pi(n) = n + F(n) +H(n). Since Pi(\u00b7) is a polynomial, the claim is proven.\nNotice that, in the above claim, i is bounded by r, which is a constant. Hence, there exists a fixed polynomial P(\u00b7) such that the number of distinct values that can exist in every state s \u2208 \u03a3 is bounded by P(n). K+ is inflationary, because when \u03b3+ is applied it copies all concept and role assertions from the current to the next state. Since \u03a5K+ contains only a single run, P(n) is a bound for ADOM(\u03a5K+) as well.\nThe following lemma shows the key feature of the positive dominant.\nLemma 15 ADOM(\u03a5K\u0302) \u2286 ADOM(\u03a5K+).\nProof. Let K\u0302 = (T, A\u03020, \u0393\u0302,\u03a0) and K+ = (\u2205, A\u03020 6EQ , {\u03b3+}, {true 7\u2192 \u03b3+}).\nWe first observe that, for every ABox A in \u03a5K\u0302, ADOM(A) = ADOM(A 6EQ) by definition of K\u0302\n(this is the role of the special concept Dummy).\nWe show by induction on the construction of \u03a5K\u0302(U, T,\u03a31, A\u03020, abox ,\u21d21) and \u03a5K+ = (U, \u2205,\u03a32, A\u03020 6EQ , abox ,\u21d22), that for each state A1 \u2208 \u03a31 we have that there exists a state A2 \u2208 \u03a32 such that A1 6EQ \u2286 A2. The base case holds for the initial states A\u03020 and A\u03020 6EQ of the two transition systems by definition. For the inductive case, we have to show that, given A1 \u2208 \u03a31 and A2 \u2208 \u03a32 with A1 6EQ \u2286 A2, for each A\u20321 \u2208 \u03a31 with A1 \u21d21 A\u20321, the unique state A\u20322 \u2208 \u03a32 with A2 \u21d22 A\u20322 is such that A\u20321 \u2286 A\u20322. To show this, note thatA1 \u21d21 A\u20321 if there exists an action \u03b3 of K\u0302 and a substitution \u03b8 for the parameters of \u03b3 such that A\u20321 = DONORM(T,A1, \u03b3\u03b8). Similarly, taking into account that \u03b3\n+ has no parameters and is always executable in \u03a5K+ , we have that A\u20322 = DO(T,A2, \u03b3 +) = DONORM(T,A2, \u03b3 +). By construction of K+, for each effect e1 \u2208 \u03b3 of the form\ne1 : [q ++] \u2227 q= \u2227Q\u2212 A\u2032e1 ,\nthere is an effect e2 \u2208 \u03b3+ of the form\ne2 : [q ++] A\u2032e1 6EQ ,\nwhere A\u2032e1 6EQ is obtained from A\u2032e1 by removing all equality assertions. By induction hypothesis, we have that A1 6EQ \u2286 A2. By observing that ANS([q++]\u03b8, \u2205, A1 6EQ) ./ ANS((q= \u2227 Q\u2212)\u03b8, \u2205, A1) \u2286 ANS([q++], \u2205, A2), we then obtain that A\u2032e1 6EQ \u2286 A\u2032e2 , where A \u2032 e1 = APPLYNORM(T,A1, e1, \u03b8) and A\u2032e2 = APPLY(\u2205, A2, e2, \u2205). Hence, we get the claim that A \u2032 1 6EQ \u2286 A\u20322.\nNow since for an ABox A of \u03a5K\u0302 the active domain ADOM(A) of A and ADOM(A 6EQ) are identical by construction, and since ADOM(\u03a5K\u0302) and ADOM(\u03a5K+) are simply the union of the active domains of all generated ABoxes, we get the claim."}, {"heading": "7.4 Putting it All Together", "text": "If a KAB K is weakly acyclic, then, by Lemma 9, its normalized form K\u0302 is weakly acyclic as well and, by Lemma 13, so is its positive dominant K+. Hence, by Lemma 14, the size of the active domain ADOM(\u03a5K+) of the transition system \u03a5K+ of K+ is polynomially related to the size of its initial ABox.\nNow, by Lemma15, this implies that also the size of the active domain ADOM(\u03a5K\u0302,NORM) of the transition system \u03a5K\u0302 of K\u0302 is polynomially related to the size of its initial ABox. Hence, the number of possible states of \u03a5K\u0302 is finite, and in fact at most exponential in the size of the initial ABox. It follows that checking \u00b5LA formulae over \u03a5K\u0302 can be done in EXPTIME w.r.t. the size of K.\nFinally, by Lemma 12, \u03a5K\u0302 and \u03a5K are bisimilar, and by the Bisimulation Invariance Theorem 4, \u03a5K\u0302 and \u03a5K satisfy exactly the same \u00b5LA formulae. Hence, to check a \u00b5LA formula on \u03a5K it is sufficient to check it over \u03a5K\u0302, which can be done in EXPTIME. This concludes the proof of Theorem 7."}, {"heading": "8. Related Work", "text": "We provide now a detailed review of work that is related to the framework and the results presented in the previous sections."}, {"heading": "8.1 Combining Description Logics and Temporal Logics", "text": "Our work is deeply related to the research that studies combinations of description logics and temporal logics. Indeed, actions progress knowledge over time and, although temporal logics do not mention actions, we can easily used them for describing progression mechanisms, including transition systems (see, e.g., Clarke et al., 1999; Calvanese, De Giacomo, & Vardi, 2002).\nSuch research has mostly explored the combination of standard description logics with standard temporal logics at the level of models, which is certainly the most natural form of combination from a logical point of view. Technically, this form of combination gives rise to a combined logic with a two-dimensional semantics, where one dimension is for time and the other for the DL domain (Schild, 1993; Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). Unfortunately, from a computational point of view, this form of combination suffers from a key undecidability result, which makes it too fragile for many practical purposes: the possibility of specifying that roles preserve their extension over time (the so called rigid roles) causes undecidability6. Referring to the domain of interest in Example 1, this would result, for example, in the undecidability of theories that specify that each instance of Character livesIn the same City forever. Moreover, this undecidability result already holds for concept satisfiability w.r.t. a fixed TBox (i.e., where the same TBox axioms must hold at all time points), without ABoxes, and with only a single rigid role (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). That is, it holds for a reasoning service that is much simpler than conjunctive query answering (Calvanese, De Giacomo, & Lenzerini, 2008), even with a fixed TBox and no data (no ABox assertions, hence no individual terms) and for one of the simplest kinds of temporal formulae, namely \u201cforever something is true\u201d (safety) (Clarke et al., 1999).\nDecidability can be regained by: (i) dropping TBoxes altogether, but the decision problem is still hard for non-elementary time (Gabbay et al., 2003); (ii) allowing temporal operators only on concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Gutie\u0301rrez-Basulto, Jung, & Lutz, 2012; Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev, 2008; Baader et al., 2012). In fact cases (ii) and (iii) can be mixed (Baader & Laux, 1995; Wolter & Zakharyaschev, 1998).\nAllowing for temporal operators over assertions only (case (iii) above), is tightly related to the functional approach adopted in this paper: the fact that we admit temporal operators only in front of assertions allows us to consider temporal models whose time points are actually sets of models of description logic assertions. Hence it keeps the temporal component distinct from the description logic one, exactly as we do here. In particular, the results by Baader et al. (2012) can be directly compared with ours. Apart from the obvious differences in the formalism used, one key point to get decidability there is that the individual terms mentioned in the ABox assertions are fixed a priori. It is possible that, by adapting the techniques presented here, those results could be extended to allow functions for denoting terms, hence allowing for adding fresh individual terms during the temporal evolution.\n6. To lose decidability, it suffices to be able to specify/verify the persistence of binary predicates/roles, which allows one to build an infinite grid and hence to encode any Turing-machine computation (Robinson, 1971; van Emde Boas, 1997)."}, {"heading": "8.2 Combining Description Logics and Actions", "text": "Somehow hampered by the undecidability results mentioned at the beginning of the section, also combinations of description logics and action theories have been studied in the years. In particular, Liu, Lutz, Milicic, and Wolter (2006b, 2006a) study combinations of description logics and action theories at the level of models, but only w.r.t. the two classical problems in reasoning about actions, namely projection and executability. Both of these problems require to explicitly give a sequence of actions and then check a property of the resulting final state (projection), or check the executability of the sequence of actions, each of which comes with a certain precondition (Reiter, 2001). More sophisticated temporal properties (in particular, \u201cforever something is true\u201d mentioned above) would lead to undecidability. By the way, notice that such undecidability result also deeply questions from the computational point of view the possibility of adding (sound and complete) automated reasoning capabilities to proposals such as OWL-S (Semantic Markup for Web Services) (Martin, Paolucci, McIlraith, Burstein, McDermott, McGuinness, Parsia, Payne, Sabou, Solanki, Srinivasan, & Sycara, 2004).\nPossibly the first proposal based implicitly on the functional view of the KB was the pioneering work by De Giacomo, Iocchi, Nardi, and Rosati (1999), which adopts an epistemic description logic (based on certain answers) combined with an action formalism to describe routines of a mobile robot. Again, one important point there is that individual terms are bounded and fixed a priori. The functional view approach was first spelled out by Calvanese, De Giacomo, Lenzerini, and Rosati (2007), and by Calvanese et al. (2011). In that work, only projection and executability are studied, however there is a distinction between the KB in the states and the actions (there specified as updates), so that the framework gives rise to a single transition system whose states are labeled by KBs (in fact the TBox is fixed while the ABox changes from state to state). However, again, the individual terms considered are fixed a priori and hence the resulting transition system is finite. So, although not studied in that work, sophisticated forms of temporal properties as those proposed here are readily verifiable in that setting. Interestingly, apart from the KBs and action, in that work also Golog-like programs are considered. These are programs whose atomic actions are defined by the action formalism, and are combined using (usual and less usual) programming constructs, such as sequence, while-loop, if-then-else, and nondeterministic pick of a value (Levesque, Reiter, Lesperance, Lin, & Scherl, 1997; De Giacomo, Lespe\u0301rance, & Levesque, 2000). An important characteristic of these programs is that they have a finite number of control states (notice that the memory storage of these programs is kept in the action theory, or the KB in our case). Although out of the scope of this paper, this finiteness allows for easily extending our results to such program as well.\nAn interesting alternative way to combine description logics and reasoning about actions is the one reported by Gu and Soutchanski (2010). There, a description logics KB7 is used as a special FOL theory describing the initial situation in a situation calculus basic action theory (Reiter, 2001). Notice that as a result, TBox assertions do not act as state constraints (Lin & Reiter, 1994), which would lead to undecidability as discussed above (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003), in fact they essentially do not persist in any way through actions.\n7. They actually mainly focus on concepts only but in a description logic that includes the universal role, which allows one to express TBox assertions as concepts (Baader et al., 2003)."}, {"heading": "8.3 Description Logics Update", "text": "Observe that effects of an action in our setting can be seen as a basic form of update of the previous state (Katsuno & Mendelzon, 1991). Although our mechanism sidesteps the semantic and computational difficulties of description logic KB update (Liu et al., 2006b; De Giacomo, Lenzerini, Poggi, & Rosati, 2009; Calvanese, Kharlamov, Nutt, & Zheleznyakov, 2010; Lenzerini & Savo, 2012) by simply rejecting the execution of actions that would lead to an inconsistent state. Adopting proper forms of update in our setting is an interesting issue for future research."}, {"heading": "8.4 Artifacts and Data-Aware Processes", "text": "Our work is also closely related to research in verification of artifact-centric business processes (Nigam & Caswell, 2003; Bhattacharya et al., 2007). Artifact-centric approaches model business processes by giving equal importance to the control-flow perspective and the data of interest. An artifact is typically represented as a tuple of a schema, which models the artifact type, together with a set of actions/services that specify how the information maintained in the artifact can be manipulated over time. Each action is usually represented in terms of pre- and post-conditions that are respectively used to determine when the action is eligible for execution, and to relate the current artifact state with the successor state obtained after the action execution. Pre- and postconditions are modeled as first-order formulae, and post-conditions employ existentially quantified variables to account for external inputs from the environment. Differently from KABs, most of the approaches targeting artifact-centric processes assume complete information about data, using a relational database to maintain the artifacts\u2019 information. As in this paper, the aim of such works is to verify whether a relational artifact-centric process meets some temporal/dynamic property, formalized using first-order variants of branching or linear temporal logics.\nIn the work by Deutsch et al. (2009), the infinite domain of the artifact\u2019s database is equipped with a dense linear order, which can be mentioned in pre-conditions, post-conditions, and properties. Runs can receive unbounded external input from an infinite domain. Decidability of verification is achieved by avoiding branching time properties, and by restricting the formulae used to specify pre-, post-conditions and properties. In particular, the approach refers to read-only and read-write database relations differently, querying the latter only by checking whether they contain a given tuple of constants. The authors show that this restriction is tight, and that integrity constraints cannot be added to the framework, since even a single functional dependency leads to undecidability of verification. Damaggio et al. (2011) extend this approach by disallowing read-write relations, but this allows the extension of the decidability result to integrity constraints expressed as embedded dependencies with terminating chase, and to any decidable arithmetic. This is a major difference with our approach, where all concepts of the KAB are considered as read-write relations, and can be arbitrarily queried to determine the progression of the system. Differently from these works, Belardinelli et al. (2011) consider a first-order variant of CTL with no quantification across states as verification formalism. The framework supports the incorporation of new values from the external environment as parameters of the actions; the corresponding execution semantics considers all the possible actual values, thus leading to an infinite-state transition systems. As for decidability of verification, the authors show that, under the assumption that each state of the system (constituted by the union of artifacts\u2019 relational instances) has a bounded active domain, it is possible to construct a faithful abstract transition system which, differently from the original one, has a finite number of states. Belardinelli, Lomuscio, and Patrizi (2012) improve the results by Belar-\ndinelli et al. (2011) by introducing a semantic property of \u201cuniformity\u201d which, roughly speaking, says that the transition system representing the execution of the process under study is not able to distinguish among states that have the same constants and the same patterns of data. Under the assumptions of uniformity and state boundedness, decidability of verification is achieved for a richer logic, namely CTL with quantification across states, interpreted under the active domain semantics. The notion of state boundedness has also been adopted by the independently developed framework of Bagheri Hariri, Calvanese, De Giacomo, Deutsch, and Montali (2012, 2013), where first-order variants of \u00b5-calculus, similar to the one considered here, are considered. There, beside differences in the way data and external information are modeled, sufficient syntactic conditions that guarantee state boundedness are proposed. All these works are developed within the relational database setting, and do not extend trivially to systems where actions change DL knowledge bases.\nThe connection between data-/artifact-centric business processes and data exchange that we exploit in this paper was first established by Cangialosi et al. (2010), and by De Giacomo, De Masellis, and Rosati (2012). There the transition relation itself is described in terms of TGDs, which map the current state, represented as a relational database instance, to the next one. Null values are used to model the incorporation of new, unknown data into the system. The process evolution is essentially a form of chase. Under suitable weak acyclicity conditions this chase terminates, guaranteeing, in turn, that the system is finite-state. Decidability is then shown for a first-order \u00b5-calculus without first-order quantification across states. This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information. KABs constitute a more general framework, which can be seamlessly customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri et al. (2011) is also constituted by the verification formalism. In particular, both works focus on a form of \u00b5-calculus where ECQs are used to query the states of the system, but Bagheri Hariri et al. (2011) do not support quantification across states, as done here.\nCalvanese et al. (2012) investigate a framework for data-centric processes that mixes the approach proposed by Bagheri Hariri et al. (2013) for relational artifacts with the notion of knowledge bases as used here. In particular, semantically-governed data-aware processes are introduced as a mechanism to model a dynamic system working over a relational database, providing at the same time a conceptual representation of the manipulated data in terms of a DL-Lite knowledge base. By relying on ontology-based data access (Calvanese et al., 2009), declarative mappings are used to\nconnect the knowledge base with the underlying relational database. Differently from KABs, the system evolves at the relational layer, and the knowledge base is used to understand and ultimately govern such an execution at a higher level of abstraction.\nWe observe that the results presented here fully subsume those by Bagheri Hariri et al. (2011), where the underlying description logic is OWL 2 QL. On the one hand, if we remove the possibility of asserting functionality of roles in the knowledge component, and of equating individuals as a result of an action in the action component, we precisely obtain the setting presented by Bagheri Hariri et al. (2011). On the other hand, for both frameworks the established complexity upper bounds are the same."}, {"heading": "9. Conclusions", "text": "In this paper we have studied verification of knowledge and action bases, which are dynamic systems constituted by a knowledge base, expressed in description logics, and by an action specification that changes the knowledge base over time. We have obtained an interesting decidability result by relying on the notion of weak acyclicity, based on a connection with the theory of chase of TGDs in relational databases.\nIn our work, we have used the original notion of weak acyclicity. However, it is easy to adopt more advanced forms of acyclicity, since our results depend only on the ability of finding a finite bound on the number of distinct function terms that are generated (when applying the chase). While the majority of approaches that adopt forms of weak-acyclicity focus on databases (Marnette & Geerts, 2010; Meier, Schmidt, Wei, & Lausen, 2010), Cuenca Grau, Horrocks, Kro\u0308tzsch, Kupke, Magka, Motik, and Wang (2012) investigate sophisticated forms of acyclicity in the context of knowledge bases without UNA. Their results can thus be seamlessly applied to KABs. Interestingly, to manage the impact of equalities in a setting without UNA, they resort to the singularization technique presented by Marnette (2009), which closely resembles the normalization of KABs introduced in Section 7.\nWeak acyclicity allows us to gain decidability by bounding the number of distinct function terms that occur in the transition system. An alternative approach to gain decidability is to bound the number of distinct terms occurring in the ABox assertions of a state. Variants of this notion of \u201cstate boundedness\u201d have been proposed recently in other contexts (Belardinelli et al., 2012; De Giacomo, Lesperance, & Patrizi, 2012; Bagheri Hariri et al., 2013). It is of great interest to explore such an approach in the setting presented here of actions acting on a description logic knowledge base.\nWe observe that our decidability result (as well as the ones commented here and in Section 8), comes with an algorithm for verification that is exponential in the size of the initial ABox. This precludes a direct application of these techniques to large-scale systems, without a careful analysis of how these can be modularized in small units to be verified (almost) separately. This is an important direction for further investigation."}, {"heading": "Acknowledgments", "text": "This research has been partially supported by the EU under the ICT Collaborative Project ACSI (Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, and under the large-scale integrating project (IP) Optique (Scalable End-user Access to Big Data), grant agreement n. FP7318338."}], "references": [{"title": "The DL-Lite family and relations", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Artale et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2009}, {"title": "A temporal description logic for reasoning about actions and plans", "author": ["A. Artale", "E. Franconi"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Artale and Franconi,? \\Q1998\\E", "shortCiteRegEx": "Artale and Franconi", "year": 1998}, {"title": "Temporal description logics", "author": ["A. Artale", "E. Franconi"], "venue": "Handbook of Temporal Reasoning in Artificial Intelligence, Foundations of Artificial Intelligence. Elsevier", "citeRegEx": "Artale and Franconi,? \\Q2005\\E", "shortCiteRegEx": "Artale and Franconi", "year": 2005}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2003}, {"title": "LTL over description logic axioms", "author": ["F. Baader", "S. Ghilardi", "C. Lutz"], "venue": "ACM Trans. on Computational Logic,", "citeRegEx": "Baader et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2012}, {"title": "Terminological logics with modal operators", "author": ["F. Baader", "A. Laux"], "venue": "In Proc. of the 14th Int. Joint Conf. on Artificial Intelligence", "citeRegEx": "Baader and Laux,? \\Q1995\\E", "shortCiteRegEx": "Baader and Laux", "year": 1995}, {"title": "Verification of conjunctive-query based semantic artifacts", "author": ["B. Bagheri Hariri", "D. Calvanese", "G. De Giacomo", "R. De Masellis"], "venue": "In Proc. of the 24th Int. Workshop on Description Logic (DL 2011),", "citeRegEx": "Hariri et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Hariri et al\\.", "year": 2011}, {"title": "Foundations of relational artifacts verification", "author": ["B. Bagheri Hariri", "D. Calvanese", "G. De Giacomo", "R. De Masellis", "P. Felli"], "venue": "In Proc. of the 9th Int. Conference on Business Process Management (BPM 2011),", "citeRegEx": "Hariri et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Hariri et al\\.", "year": 2011}, {"title": "Verification of relational data-centric dynamic systems with external services. Corr technical report arXiv:1203.0024, arXiv.org e-Print archive", "author": ["B. Bagheri Hariri", "D. Calvanese", "G. De Giacomo", "A. Deutsch", "M. Montali"], "venue": null, "citeRegEx": "Hariri et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hariri et al\\.", "year": 2012}, {"title": "Verification of relational data-centric dynamic systems with external services", "author": ["B. Bagheri Hariri", "D. Calvanese", "G. De Giacomo", "A. Deutsch", "M. Montali"], "venue": "In Proc. of the 32nd ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "Hariri et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hariri et al\\.", "year": 2013}, {"title": "OWL 2 Web Ontology Language document overview (second edition). W3C Recommendation, World Wide Web Consortium. Available at http://www.w3.org/ TR/owl2-overview", "author": ["J Bao"], "venue": null, "citeRegEx": "Bao,? \\Q2012\\E", "shortCiteRegEx": "Bao", "year": 2012}, {"title": "Verification of deployed artifact systems via data abstraction", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 9th Int. Joint Conf. on Service Oriented Computing (ICSOC 2011),", "citeRegEx": "Belardinelli et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2011}, {"title": "An abstraction technique for the verification of artifact-centric systems", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Belardinelli et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2012}, {"title": "Reasoning on UML class diagrams", "author": ["D. Berardi", "D. Calvanese", "G. De Giacomo"], "venue": "Artificial Intelligence,", "citeRegEx": "Berardi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Berardi et al\\.", "year": 2005}, {"title": "Towards formal analysis of artifactcentric business process models", "author": ["K. Bhattacharya", "C. Gerede", "R. Hull", "R. Liu", "J. Su"], "venue": "In Proc. of the 5th Int. Conference on Business Process Management (BPM 2007),", "citeRegEx": "Bhattacharya et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bhattacharya et al\\.", "year": 2007}, {"title": "Verification of infinite structures", "author": ["O. Burkart", "D. Caucal", "F. Moller", "B. Steffen"], "venue": "In Handbook of Process Algebra. Elsevier Science", "citeRegEx": "Burkart et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Burkart et al\\.", "year": 2001}, {"title": "Ontologies and databases: The DL-Lite approach", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodr\u0131\u0301guez-Muro", "R. Rosati"], "venue": "Reasoning Web. Semantic Technologies for Informations Systems \u2013 5th Int. Summer School Tutorial Lectures (RW 2009),", "citeRegEx": "Calvanese et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2009}, {"title": "EQL-Lite: Effective first-order query processing in description logics", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Data complexity of query answering in description logics", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Artificial Intelligence,", "citeRegEx": "Calvanese et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2013}, {"title": "Ontology-based governance of data-aware processes", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Montali", "A. Santoso"], "venue": "In Proc. of the 6th Int. Conf. on Web Reasoning and Rule Systems (RR 2012),", "citeRegEx": "Calvanese et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2012}, {"title": "Conjunctive query containment and answering under description logics constraints", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini"], "venue": "ACM Trans. on Computational Logic,", "citeRegEx": "Calvanese et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2008}, {"title": "Actions and programs over description logic ontologies", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "In Proc. of the 20th Int. Workshop on Description Logic (DL 2007),", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Actions and programs over description logic knowledge bases: A functional approach", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "Knowing, Reasoning, and Acting: Essays in Honour of Hector Levesque. College Publications", "citeRegEx": "Calvanese et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2011}, {"title": "Foundations of data aware process analysis: A database theory perspective", "author": ["D. Calvanese", "G. De Giacomo", "M. Montali"], "venue": "In Proc. of the 32nd ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "Calvanese et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2013}, {"title": "Reasoning about actions and planning in LTL action theories", "author": ["D. Calvanese", "G. De Giacomo", "M.Y. Vardi"], "venue": "In Proc. of the 8th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Calvanese et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2002}, {"title": "Updating ABoxes in DL-Lite", "author": ["D. Calvanese", "E. Kharlamov", "W. Nutt", "D. Zheleznyakov"], "venue": "In Proc. of the 4th Alberto Mendelzon Int. Workshop on Foundations of Data Management", "citeRegEx": "Calvanese et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2010}, {"title": "Conjunctive artifact-centric services", "author": ["P. Cangialosi", "G. De Giacomo", "R. De Masellis", "R. Rosati"], "venue": "In Proc. of the 8th Int. Joint Conf. on Service Oriented Computing (ICSOC 2010),", "citeRegEx": "Cangialosi et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Cangialosi et al\\.", "year": 2010}, {"title": "Business artifacts: A data-centric approach to modeling business operations and processes", "author": ["D. Cohn", "R. Hull"], "venue": "Bull. of the IEEE Computer Society Technical Committee on Data Engineering,", "citeRegEx": "Cohn and Hull,? \\Q2009\\E", "shortCiteRegEx": "Cohn and Hull", "year": 2009}, {"title": "Acyclicity conditions and their application to query answering in description logics", "author": ["B. Cuenca Grau", "I. Horrocks", "M. Kr\u00f6tzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang"], "venue": "In Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Grau et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2012}, {"title": "Artifact systems with data dependencies and arithmetic", "author": ["E. Damaggio", "A. Deutsch", "V. Vianu"], "venue": "In Proc. of the 14th Int. Conf. on Database Theory (ICDT", "citeRegEx": "Damaggio et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Damaggio et al\\.", "year": 2011}, {"title": "Verification of conjunctive artifact-centric services", "author": ["G. De Giacomo", "R. De Masellis", "R. Rosati"], "venue": "Int. J. of Cooperative Information Systems,", "citeRegEx": "Giacomo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 2012}, {"title": "A theory and implementation of cognitive mobile robots", "author": ["G. De Giacomo", "L. Iocchi", "D. Nardi", "R. Rosati"], "venue": "J. of Logic and Computation,", "citeRegEx": "Giacomo et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 1999}, {"title": "On instance-level update and erasure in description logic ontologies", "author": ["G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati"], "venue": "J. of Logic and Computation, Special Issue on Ontology Dynamics,", "citeRegEx": "Giacomo et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 2009}, {"title": "ConGolog, a concurrent programming language based on the situation calculus", "author": ["G. De Giacomo", "Y. Lesp\u00e9rance", "H.J. Levesque"], "venue": "Artificial Intelligence,", "citeRegEx": "Giacomo et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 2000}, {"title": "Bounded situation calculus action theories and decidable verification", "author": ["G. De Giacomo", "Y. Lesperance", "F. Patrizi"], "venue": "In Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Giacomo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 2012}, {"title": "Automatic verification of data-centric business processes", "author": ["A. Deutsch", "R. Hull", "F. Patrizi", "V. Vianu"], "venue": "In Proc. of the 12th Int. Conf. on Database Theory (ICDT", "citeRegEx": "Deutsch et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2009}, {"title": "The chase revisited", "author": ["A. Deutsch", "A. Nash", "J.B. Remmel"], "venue": "In Proc. of the 27th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "Deutsch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2008}, {"title": "Data exchange: Semantics and query answering", "author": ["R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa"], "venue": "Theoretical Computer Science,", "citeRegEx": "Fagin et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Fagin et al\\.", "year": 2005}, {"title": "Many-dimensional Modal Logics: Theory and Applications", "author": ["D. Gabbay", "A. Kurusz", "F. Wolter", "M. Zakharyaschev"], "venue": null, "citeRegEx": "Gabbay et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Gabbay et al\\.", "year": 2003}, {"title": "A description logic based situation calculus", "author": ["Y. Gu", "M. Soutchanski"], "venue": "Ann. of Mathematics and Artificial Intelligence,", "citeRegEx": "Gu and Soutchanski,? \\Q2010\\E", "shortCiteRegEx": "Gu and Soutchanski", "year": 2010}, {"title": "Complexity of branching temporal description logics", "author": ["V. Guti\u00e9rrez-Basulto", "J.C. Jung", "C. Lutz"], "venue": "In Proc. of the 20th Eur. Conf. on Artificial Intelligence (ECAI", "citeRegEx": "Guti\u00e9rrez.Basulto et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Guti\u00e9rrez.Basulto et al\\.", "year": 2012}, {"title": "Concepts, agents, and coalitions in alternating time", "author": ["W. Jamroga"], "venue": "In Proc. of the 20th Eur. Conf. on Artificial Intelligence (ECAI", "citeRegEx": "Jamroga,? \\Q2012\\E", "shortCiteRegEx": "Jamroga", "year": 2012}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. Katsuno", "A. Mendelzon"], "venue": "In Proc. of the 2nd Int. Conf. on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Katsuno and Mendelzon,? \\Q1991\\E", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1991}, {"title": "Abductive logic programming agents with destructive databases", "author": ["R.A. Kowalski", "F. Sadri"], "venue": "Ann. of Mathematics and Artificial Intelligence,", "citeRegEx": "Kowalski and Sadri,? \\Q2011\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2011}, {"title": "Updating inconsistent description logic knowledge bases", "author": ["M. Lenzerini", "D.F. Savo"], "venue": "In Proc. of the 20th Eur. Conf. on Artificial Intelligence (ECAI", "citeRegEx": "Lenzerini and Savo,? \\Q2012\\E", "shortCiteRegEx": "Lenzerini and Savo", "year": 2012}, {"title": "GOLOG: A logic programming language for dynamic domains", "author": ["H.J. Levesque", "R. Reiter", "Y. Lesperance", "F. Lin", "R. Scherl"], "venue": "J. of Logic Programming,", "citeRegEx": "Levesque et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Levesque et al\\.", "year": 1997}, {"title": "Foundations of a functional approach to knowledge representation", "author": ["H.J. Levesque"], "venue": "Artificial Intelligence,", "citeRegEx": "Levesque,? \\Q1984\\E", "shortCiteRegEx": "Levesque", "year": 1984}, {"title": "Ontology of dynamic entities", "author": ["L. Limonad", "P. De Leenheer", "M. Linehan", "R. Hull", "R. Vaculin"], "venue": "In Proc. of the 31st Int. Conf. on Conceptual Modeling (ER", "citeRegEx": "Limonad et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Limonad et al\\.", "year": 2012}, {"title": "State constraints revisited", "author": ["F. Lin", "R. Reiter"], "venue": "J. of Logic Programming,", "citeRegEx": "Lin and Reiter,? \\Q1994\\E", "shortCiteRegEx": "Lin and Reiter", "year": 1994}, {"title": "Reasoning about actions using description logics with general TBoxes", "author": ["H. Liu", "C. Lutz", "M. Milicic", "F. Wolter"], "venue": "In Proc. of the 10th Eur. Conference on Logics in Artificial Intelligence (JELIA 2006),", "citeRegEx": "Liu et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2006}, {"title": "Updating description logic ABoxes", "author": ["H. Liu", "C. Lutz", "M. Milicic", "F. Wolter"], "venue": "In Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Liu et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2006}, {"title": "Temporal description logics: A survey", "author": ["C. Lutz", "F. Wolter", "M. Zakharyaschev"], "venue": "In Proc. of the 15th Int. Symp. on Temporal Representation and Reasoning (TIME", "citeRegEx": "Lutz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2008}, {"title": "Generalized schema-mappings: from termination to tractability", "author": ["B. Marnette"], "venue": "In Proc. of the 28th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "Marnette,? \\Q2009\\E", "shortCiteRegEx": "Marnette", "year": 2009}, {"title": "Static analysis of schema-mappings ensuring oblivious termination", "author": ["B. Marnette", "F. Geerts"], "venue": "In Proc. of the 13th Int. Conf. on Database Theory (ICDT", "citeRegEx": "Marnette and Geerts,? \\Q2010\\E", "shortCiteRegEx": "Marnette and Geerts", "year": 2010}, {"title": "Bringing semantics to web services: The OWL-S approach", "author": ["D. Martin", "M. Paolucci", "S. McIlraith", "M. Burstein", "D. McDermott", "D. McGuinness", "B. Parsia", "T. Payne", "M. Sabou", "Solanki", "N. Srinivasan", "K. Sycara"], "venue": "In Proc. of the 1st Int. Workshop on Semantic Web Services and Web Process Composition (SWSWPC", "citeRegEx": "Martin et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Martin et al\\.", "year": 2004}, {"title": "Semantic query optimization in the presence of types", "author": ["M. Meier", "M. Schmidt", "F. Wei", "G. Lausen"], "venue": "Proc. of the 29th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "Meier et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Meier et al\\.", "year": 2010}, {"title": "Data in business processes", "author": ["A. Meyer", "S. Smirnov", "M. Weske"], "venue": "EMISA Forum,", "citeRegEx": "Meyer et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Meyer et al\\.", "year": 2011}, {"title": "An algebraic definition of simulation between programs", "author": ["R. Milner"], "venue": "In Proc. of the 2nd Int. Joint Conf. on Artificial Intelligence", "citeRegEx": "Milner,? \\Q1971\\E", "shortCiteRegEx": "Milner", "year": 1971}, {"title": "OWL 2 Web Ontology Language profiles (second edition)", "author": ["B. Motik", "B. Cuenca Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz"], "venue": null, "citeRegEx": "Motik et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2012}, {"title": "Business artifacts: An approach to operational specification", "author": ["A. Nigam", "N.S. Caswell"], "venue": "IBM Systems Journal,", "citeRegEx": "Nigam and Caswell,? \\Q2003\\E", "shortCiteRegEx": "Nigam and Caswell", "year": 2003}, {"title": "Finiteness is Mu-ineffable", "author": ["D.M.R. Park"], "venue": "Theoretical Computer Science,", "citeRegEx": "Park,? \\Q1976\\E", "shortCiteRegEx": "Park", "year": 1976}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. on Data Semantics,", "citeRegEx": "Poggi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Poggi et al\\.", "year": 2008}, {"title": "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems", "author": ["R. Reiter"], "venue": null, "citeRegEx": "Reiter,? \\Q2001\\E", "shortCiteRegEx": "Reiter", "year": 2001}, {"title": "Undecidability and nonperiodicity of tilings on the plane", "author": ["R. Robinson"], "venue": "Inventiones Math.,", "citeRegEx": "Robinson,? \\Q1971\\E", "shortCiteRegEx": "Robinson", "year": 1971}, {"title": "Generalized ontology-based production systems", "author": ["R. Rosati", "E. Franconi"], "venue": "In Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Rosati and Franconi,? \\Q2012\\E", "shortCiteRegEx": "Rosati and Franconi", "year": 2012}, {"title": "Combining terminological logics with tense logic", "author": ["K. Schild"], "venue": "In Proc. of the 6th Portuguese Conf. on Artificial Intelligence (EPIA\u201993),", "citeRegEx": "Schild,? \\Q1993\\E", "shortCiteRegEx": "Schild", "year": 1993}, {"title": "Modal and Temporal Properties of Processes", "author": ["C. Stirling"], "venue": null, "citeRegEx": "Stirling,? \\Q2001\\E", "shortCiteRegEx": "Stirling", "year": 2001}, {"title": "The convenience of tilings", "author": ["P. van Emde Boas"], "venue": "Theory, Vol. 187 of Lecture Notes in Pure and Applied Mathematics,", "citeRegEx": "Boas,? \\Q1997\\E", "shortCiteRegEx": "Boas", "year": 1997}, {"title": "Automatic verification of database-driven systems: a new frontier", "author": ["V. Vianu"], "venue": "In Proc. of the 12th Int. Conf. on Database Theory (ICDT", "citeRegEx": "Vianu,? \\Q2009\\E", "shortCiteRegEx": "Vianu", "year": 2009}, {"title": "Satisfiability problem in description logics with modal operators", "author": ["F. Wolter", "M. Zakharyaschev"], "venue": "In Proc. of the 6th Int. Conf. on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Wolter and Zakharyaschev,? \\Q1998\\E", "shortCiteRegEx": "Wolter and Zakharyaschev", "year": 1998}, {"title": "Modal description logics: Modalizing roles", "author": ["F. Wolter", "M. Zakharyaschev"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Wolter and Zakharyaschev,? \\Q1999\\E", "shortCiteRegEx": "Wolter and Zakharyaschev", "year": 1999}, {"title": "Temporalizing description logic", "author": ["F. Wolter", "M. Zakharyaschev"], "venue": "Frontiers of Combining Systems,", "citeRegEx": "Wolter and Zakharyaschev,? \\Q1999\\E", "shortCiteRegEx": "Wolter and Zakharyaschev", "year": 1999}], "referenceMentions": [{"referenceID": 69, "context": "Recent work in business processes, services and databases is bringing forward the need of considering both data and processes as first-class citizens in process and service design (Nigam & Caswell, 2003; Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Vianu, 2009; Meyer, Smirnov, & Weske, 2011).", "startOffset": 180, "endOffset": 331}, {"referenceID": 63, "context": "In particular, due to the nature of DL assertions (which in general are not definitions but constraints on models), we get one of the most difficult kinds of domain descriptions for reasoning about actions (Reiter, 2001), which amounts to dealing with complex forms of state constraints (Lin & Reiter, 1994).", "startOffset": 206, "endOffset": 220}, {"referenceID": 47, "context": "To overcome this difficulty, virtually all solutions that aim at robustness are based on a so-called \u201cfunctional view of knowledge bases\u201d (Levesque, 1984): the KB provides the ability of querying based on logical implication (\u201cask\u201d), and the ability of progressing it to a \u201cnew\u201d KB through forms of updates (\u201ctell\u201d) (Baader, Ghilardi, & Lutz, 2012; Calvanese, De Giacomo, Lenzerini, & Rosati, 2011).", "startOffset": 138, "endOffset": 154}, {"referenceID": 61, "context": "In this setting, we address the verification of temporal/dynamic properties expressed in a firstorder variant of \u03bc-calculus (Park, 1976; Stirling, 2001), where atomic formulae are queries over the KB which can refer both to constants and to function terms, and where a controlled form of quantification across states is allowed.", "startOffset": 124, "endOffset": 152}, {"referenceID": 67, "context": "In this setting, we address the verification of temporal/dynamic properties expressed in a firstorder variant of \u03bc-calculus (Park, 1976; Stirling, 2001), where atomic formulae are queries over the KB which can refer both to constants and to function terms, and where a controlled form of quantification across states is allowed.", "startOffset": 124, "endOffset": 152}, {"referenceID": 23, "context": "Notice that all previous decidability results on actions over DL KBs assumed that no information is coming from outside of the system, in the sense that no new individual terms are added while executing actions (Calvanese et al., 2011; Baader et al., 2012; Rosati & Franconi, 2012).", "startOffset": 211, "endOffset": 281}, {"referenceID": 4, "context": "Notice that all previous decidability results on actions over DL KBs assumed that no information is coming from outside of the system, in the sense that no new individual terms are added while executing actions (Calvanese et al., 2011; Baader et al., 2012; Rosati & Franconi, 2012).", "startOffset": 211, "endOffset": 281}, {"referenceID": 3, "context": ", 2011; Baader et al., 2012; Rosati & Franconi, 2012). In this paper, instead, we allow for arbitrary introduction of new terms. Unsurprisingly, we show that even for very simple KABs and temporal properties, verification is undecidable. However, we also show that for a rich class of KABs, verification is in fact decidable and reducible to finite-state model checking. To obtain this result, following Cangialosi et al. (2010), and Bagheri Hariri et al.", "startOffset": 8, "endOffset": 429}, {"referenceID": 3, "context": ", 2011; Baader et al., 2012; Rosati & Franconi, 2012). In this paper, instead, we allow for arbitrary introduction of new terms. Unsurprisingly, we show that even for very simple KABs and temporal properties, verification is undecidable. However, we also show that for a rich class of KABs, verification is in fact decidable and reducible to finite-state model checking. To obtain this result, following Cangialosi et al. (2010), and Bagheri Hariri et al. (2011), we rely on recent results in data exchange on the finiteness of the chase of tuple-generating dependencies (Fagin, Kolaitis, Miller, & Popa, 2005), though, in our case, we need to extend the approach to deal with (i) incomplete information, (ii) inference on equality, and (iii) quantification across states in the verification language.", "startOffset": 8, "endOffset": 463}, {"referenceID": 3, "context": "Description Logics (DLs) (Baader et al., 2003) are knowledge representation formalisms that are tailored for representing the domain of interest in terms of concepts (or classes), denoting sets of objects, and roles (or relations), denoting binary relations between objects.", "startOffset": 25, "endOffset": 46}, {"referenceID": 62, "context": "We follow the usual assumption in DL-Lite, according to which a TBox may contain neither (funct P ) nor (funct P\u2212) if it contains R v P or R v P\u2212, for some role R (Poggi et al., 2008; Calvanese et al., 2013).", "startOffset": 163, "endOffset": 207}, {"referenceID": 19, "context": "We follow the usual assumption in DL-Lite, according to which a TBox may contain neither (funct P ) nor (funct P\u2212) if it contains R v P or R v P\u2212, for some role R (Poggi et al., 2008; Calvanese et al., 2013).", "startOffset": 163, "endOffset": 207}, {"referenceID": 0, "context": "The presence of equality assertions in the ABox requires a specific treatment of equality that goes beyond the usual reasoning techniques for DL-Lite based on first-order rewritability, although reasoning remains polynomial (Artale et al., 2009).", "startOffset": 224, "endOffset": 245}, {"referenceID": 0, "context": "The following characterization of satisfiability and logical implication in DL-LiteNU is an easy consequence of results by Artale et al. (2009).", "startOffset": 123, "endOffset": 144}, {"referenceID": 0, "context": "The PTIME lower bound is an immediate consequence of the same lower bound established by Artale et al. (2009) for DL-LiteNU in which we do not allow the use of complex individual terms.", "startOffset": 89, "endOffset": 110}, {"referenceID": 0, "context": "The PTIME lower bound is an immediate consequence of the same lower bound established by Artale et al. (2009) for DL-LiteNU in which we do not allow the use of complex individual terms. For the upper bound, Artale et al. (2009) provide a PTIME algorithm that is based on first using functionality assertions to exhaustively propagate equality, and then resorting to a PTIME algorithm (in combined complexity) for reasoning in DL-Lite in the absence of UNA.", "startOffset": 89, "endOffset": 228}, {"referenceID": 0, "context": "The PTIME lower bound is an immediate consequence of the same lower bound established by Artale et al. (2009) for DL-LiteNU in which we do not allow the use of complex individual terms. For the upper bound, Artale et al. (2009) provide a PTIME algorithm that is based on first using functionality assertions to exhaustively propagate equality, and then resorting to a PTIME algorithm (in combined complexity) for reasoning in DL-Lite in the absence of UNA. We can adapt that algorithm by changing the first step, so as to propagate, again in PTIME, equality over terms in the active domain not only due to functionalities, but also due to congruence. Next we introduce queries. As usual (cf. OWL 2), answers to queries are formed by constants/terms denoting individuals explicitly mentioned in the ABox. The (active) domain of an ABox A, denoted by ADOM(A), is the (finite) set of constants/terms appearing in concept, role, and equality assertions in A. The (predicate) alphabet of a KB (T,A), denoted ALPH((T,A)) is the set of concept and role names occurring in T \u222aA. A union of conjunctive queries (UCQ) q over a KB (T,A) is a FOL formula of the form \u2203~y1.conj 1(~x, ~y1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u2203~yn.conj n(~x, ~yn) with free variables ~x and existentially quantified variables ~y1, . . . , ~yn. Each conj i(~x, ~ yi) in q is a conjunction of atoms of the form N(z), P (z, z \u2032) where N and P respectively denote a concept and a role name occurring in ALPH((T,A)), and z, z\u2032 are constants in ADOM(A) or variables in ~x or ~ yi, for some i \u2208 {1, . . . , n}. The certain answers to q over (T,A) is the set ANS(q, T,A) of substitutions1 \u03c3 of the free variables of q with constants/terms in ADOM(A) such that q\u03c3 evaluates to true in every model of (T,A), i.e., q\u03c3 is logically implied by (T,A). Following the notation used for assertions, we denote this as (T,A) |= q\u03c3. If q has no free variables, then it is called boolean and its certain answers are either the empty substitution denoting true or nothing denoting false. Again, as an easy consequence of the results by Artale et al. (2009), we obtain the following characterization of query answering in DL-LiteNU.", "startOffset": 89, "endOffset": 2078}, {"referenceID": 16, "context": "Following the line of the proof by Calvanese et al. (2007a), but considering Theorem 2 for the basic step of evaluating an UCQ, we get:", "startOffset": 35, "endOffset": 60}, {"referenceID": 16, "context": "where rewT (q) is a UCQ computed by the reformulation algorithm of Calvanese et al. (2007b). Notice that, in this way, we have \u201ccompiled away\u201d the TBox.", "startOffset": 67, "endOffset": 92}, {"referenceID": 63, "context": "In some sense, the execution mechanism adopted in this paper is very basic and does not address any of the elaboration tolerance issues typical of reasoning about actions, such as the frame problem, ramification problem or qualification problem (Reiter, 2001)3.", "startOffset": 245, "endOffset": 259}, {"referenceID": 44, "context": "But see also the work by Kowalski and Sadri (2011).", "startOffset": 25, "endOffset": 51}, {"referenceID": 67, "context": "To specify dynamic properties over KABs, we use a first-order variant of \u03bc-calculus (Stirling, 2001; Park, 1976).", "startOffset": 84, "endOffset": 112}, {"referenceID": 61, "context": "To specify dynamic properties over KABs, we use a first-order variant of \u03bc-calculus (Stirling, 2001; Park, 1976).", "startOffset": 84, "endOffset": 112}, {"referenceID": 67, "context": "Technically, \u03bc-calculus separates local properties, asserted on the current state or on states that are immediate successors of the current one, from properties talking about states that are arbitrarily far away from the current one (Stirling, 2001).", "startOffset": 233, "endOffset": 249}, {"referenceID": 58, "context": "To formally capture such an equivalence, we make use of the notion of bisimulation (Milner, 1971), suitably extended to deal with query answering over KBs.", "startOffset": 83, "endOffset": 97}, {"referenceID": 67, "context": "The proof is analogous to the standard proof of bisimulation invariance of \u03bc-calculus (Stirling, 2001), though taking into account our bisimulation, which guarantees that ECQs are evaluated identically over bisimilar states.", "startOffset": 86, "endOffset": 102}, {"referenceID": 38, "context": "To do so, we rely on a syntactic restriction that resembles the notion of weak acyclicity in data exchange (Fagin et al., 2005)5, and that guarantees boundedness of ABoxes generated by the execution of the KAB and, in turn, decidability of verification.", "startOffset": 107, "endOffset": 127}, {"referenceID": 15, "context": "We replace [q+]\u2227Q\u2212 by [rewT (q+)]\u2227 rewT (Q\u2212) (Calvanese et al., 2007a), exploiting the results by Calvanese et al. (2007b) and by Artale et al.", "startOffset": 46, "endOffset": 123}, {"referenceID": 0, "context": "(2007b) and by Artale et al. (2009), which guarantee that, for every ECQ Q and every ABox A where equalities are closed under functionality and congruence, we have that", "startOffset": 15, "endOffset": 36}, {"referenceID": 0, "context": "The equivalence between the latter and [q i ]\u2227q= is a consequence of the construction by Artale et al. (2009), which shows that query entailment in the presence of equalities can be reduced to query evaluation by saturating equalities w.", "startOffset": 89, "endOffset": 110}, {"referenceID": 66, "context": "Technically, this form of combination gives rise to a combined logic with a two-dimensional semantics, where one dimension is for time and the other for the DL domain (Schild, 1993; Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003).", "startOffset": 167, "endOffset": 240}, {"referenceID": 39, "context": "Technically, this form of combination gives rise to a combined logic with a two-dimensional semantics, where one dimension is for time and the other for the DL domain (Schild, 1993; Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003).", "startOffset": 167, "endOffset": 240}, {"referenceID": 39, "context": ", where the same TBox axioms must hold at all time points), without ABoxes, and with only a single rigid role (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003).", "startOffset": 110, "endOffset": 169}, {"referenceID": 39, "context": "Decidability can be regained by: (i) dropping TBoxes altogether, but the decision problem is still hard for non-elementary time (Gabbay et al., 2003); (ii) allowing temporal operators only on concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Guti\u00e9rrez-Basulto, Jung, & Lutz, 2012; Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev, 2008; Baader et al.", "startOffset": 128, "endOffset": 149}, {"referenceID": 66, "context": ", 2003); (ii) allowing temporal operators only on concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Guti\u00e9rrez-Basulto, Jung, & Lutz, 2012; Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev, 2008; Baader et al.", "startOffset": 59, "endOffset": 158}, {"referenceID": 42, "context": ", 2003); (ii) allowing temporal operators only on concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Guti\u00e9rrez-Basulto, Jung, & Lutz, 2012; Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev, 2008; Baader et al.", "startOffset": 59, "endOffset": 158}, {"referenceID": 4, "context": ", 2003); (ii) allowing temporal operators only on concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Guti\u00e9rrez-Basulto, Jung, & Lutz, 2012; Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev, 2008; Baader et al., 2012).", "startOffset": 303, "endOffset": 361}, {"referenceID": 3, "context": "In particular, the results by Baader et al. (2012) can be directly compared with ours.", "startOffset": 30, "endOffset": 51}, {"referenceID": 64, "context": "To lose decidability, it suffices to be able to specify/verify the persistence of binary predicates/roles, which allows one to build an infinite grid and hence to encode any Turing-machine computation (Robinson, 1971; van Emde Boas, 1997).", "startOffset": 201, "endOffset": 238}, {"referenceID": 63, "context": "Both of these problems require to explicitly give a sequence of actions and then check a property of the resulting final state (projection), or check the executability of the sequence of actions, each of which comes with a certain precondition (Reiter, 2001).", "startOffset": 244, "endOffset": 258}, {"referenceID": 16, "context": "The functional view approach was first spelled out by Calvanese, De Giacomo, Lenzerini, and Rosati (2007), and by Calvanese et al. (2011). In that work, only projection and executability are studied, however there is a distinction between the KB in the states and the actions (there specified as updates), so that the framework gives rise to a single transition system whose states are labeled by KBs (in fact the TBox is fixed while the ABox changes from state to state).", "startOffset": 114, "endOffset": 138}, {"referenceID": 63, "context": "There, a description logics KB7 is used as a special FOL theory describing the initial situation in a situation calculus basic action theory (Reiter, 2001).", "startOffset": 141, "endOffset": 155}, {"referenceID": 39, "context": "Notice that as a result, TBox assertions do not act as state constraints (Lin & Reiter, 1994), which would lead to undecidability as discussed above (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003), in fact they essentially do not persist in any way through actions.", "startOffset": 149, "endOffset": 208}, {"referenceID": 39, "context": "An interesting alternative way to combine description logics and reasoning about actions is the one reported by Gu and Soutchanski (2010). There, a description logics KB7 is used as a special FOL theory describing the initial situation in a situation calculus basic action theory (Reiter, 2001).", "startOffset": 112, "endOffset": 138}, {"referenceID": 3, "context": "They actually mainly focus on concepts only but in a description logic that includes the universal role, which allows one to express TBox assertions as concepts (Baader et al., 2003).", "startOffset": 161, "endOffset": 182}, {"referenceID": 14, "context": "Our work is also closely related to research in verification of artifact-centric business processes (Nigam & Caswell, 2003; Bhattacharya et al., 2007).", "startOffset": 100, "endOffset": 150}, {"referenceID": 12, "context": "Our work is also closely related to research in verification of artifact-centric business processes (Nigam & Caswell, 2003; Bhattacharya et al., 2007). Artifact-centric approaches model business processes by giving equal importance to the control-flow perspective and the data of interest. An artifact is typically represented as a tuple of a schema, which models the artifact type, together with a set of actions/services that specify how the information maintained in the artifact can be manipulated over time. Each action is usually represented in terms of pre- and post-conditions that are respectively used to determine when the action is eligible for execution, and to relate the current artifact state with the successor state obtained after the action execution. Pre- and postconditions are modeled as first-order formulae, and post-conditions employ existentially quantified variables to account for external inputs from the environment. Differently from KABs, most of the approaches targeting artifact-centric processes assume complete information about data, using a relational database to maintain the artifacts\u2019 information. As in this paper, the aim of such works is to verify whether a relational artifact-centric process meets some temporal/dynamic property, formalized using first-order variants of branching or linear temporal logics. In the work by Deutsch et al. (2009), the infinite domain of the artifact\u2019s database is equipped with a dense linear order, which can be mentioned in pre-conditions, post-conditions, and properties.", "startOffset": 124, "endOffset": 1390}, {"referenceID": 12, "context": "Our work is also closely related to research in verification of artifact-centric business processes (Nigam & Caswell, 2003; Bhattacharya et al., 2007). Artifact-centric approaches model business processes by giving equal importance to the control-flow perspective and the data of interest. An artifact is typically represented as a tuple of a schema, which models the artifact type, together with a set of actions/services that specify how the information maintained in the artifact can be manipulated over time. Each action is usually represented in terms of pre- and post-conditions that are respectively used to determine when the action is eligible for execution, and to relate the current artifact state with the successor state obtained after the action execution. Pre- and postconditions are modeled as first-order formulae, and post-conditions employ existentially quantified variables to account for external inputs from the environment. Differently from KABs, most of the approaches targeting artifact-centric processes assume complete information about data, using a relational database to maintain the artifacts\u2019 information. As in this paper, the aim of such works is to verify whether a relational artifact-centric process meets some temporal/dynamic property, formalized using first-order variants of branching or linear temporal logics. In the work by Deutsch et al. (2009), the infinite domain of the artifact\u2019s database is equipped with a dense linear order, which can be mentioned in pre-conditions, post-conditions, and properties. Runs can receive unbounded external input from an infinite domain. Decidability of verification is achieved by avoiding branching time properties, and by restricting the formulae used to specify pre-, post-conditions and properties. In particular, the approach refers to read-only and read-write database relations differently, querying the latter only by checking whether they contain a given tuple of constants. The authors show that this restriction is tight, and that integrity constraints cannot be added to the framework, since even a single functional dependency leads to undecidability of verification. Damaggio et al. (2011) extend this approach by disallowing read-write relations, but this allows the extension of the decidability result to integrity constraints expressed as embedded dependencies with terminating chase, and to any decidable arithmetic.", "startOffset": 124, "endOffset": 2186}, {"referenceID": 11, "context": "Differently from these works, Belardinelli et al. (2011) consider a first-order variant of CTL with no quantification across states as verification formalism.", "startOffset": 30, "endOffset": 57}, {"referenceID": 11, "context": "Differently from these works, Belardinelli et al. (2011) consider a first-order variant of CTL with no quantification across states as verification formalism. The framework supports the incorporation of new values from the external environment as parameters of the actions; the corresponding execution semantics considers all the possible actual values, thus leading to an infinite-state transition systems. As for decidability of verification, the authors show that, under the assumption that each state of the system (constituted by the union of artifacts\u2019 relational instances) has a bounded active domain, it is possible to construct a faithful abstract transition system which, differently from the original one, has a finite number of states. Belardinelli, Lomuscio, and Patrizi (2012) improve the results by Belar-", "startOffset": 30, "endOffset": 792}, {"referenceID": 16, "context": "By relying on ontology-based data access (Calvanese et al., 2009), declarative mappings are used to", "startOffset": 41, "endOffset": 65}, {"referenceID": 12, "context": "The connection between data-/artifact-centric business processes and data exchange that we exploit in this paper was first established by Cangialosi et al. (2010), and by De Giacomo, De Masellis, and Rosati (2012).", "startOffset": 138, "endOffset": 163}, {"referenceID": 12, "context": "The connection between data-/artifact-centric business processes and data exchange that we exploit in this paper was first established by Cangialosi et al. (2010), and by De Giacomo, De Masellis, and Rosati (2012). There the transition relation itself is described in terms of TGDs, which map the current state, represented as a relational database instance, to the next one.", "startOffset": 138, "endOffset": 214}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component.", "startOffset": 38, "endOffset": 59}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al.", "startOffset": 38, "endOffset": 377}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al.", "startOffset": 38, "endOffset": 410}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al.", "startOffset": 38, "endOffset": 446}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al.", "startOffset": 38, "endOffset": 472}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself.", "startOffset": 38, "endOffset": 502}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered.", "startOffset": 38, "endOffset": 1119}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information.", "startOffset": 38, "endOffset": 1293}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information. KABs constitute a more general framework, which can be seamlessly customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri et al. (2011) is also constituted by the verification formalism.", "startOffset": 38, "endOffset": 1729}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information. KABs constitute a more general framework, which can be seamlessly customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri et al. (2011) is also constituted by the verification formalism. In particular, both works focus on a form of \u03bc-calculus where ECQs are used to query the states of the system, but Bagheri Hariri et al. (2011) do not support quantification across states, as done here.", "startOffset": 38, "endOffset": 1924}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information. KABs constitute a more general framework, which can be seamlessly customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri et al. (2011) is also constituted by the verification formalism. In particular, both works focus on a form of \u03bc-calculus where ECQs are used to query the states of the system, but Bagheri Hariri et al. (2011) do not support quantification across states, as done here. Calvanese et al. (2012) investigate a framework for data-centric processes that mixes the approach proposed by Bagheri Hariri et al.", "startOffset": 38, "endOffset": 2007}, {"referenceID": 6, "context": "This approach was extended by Bagheri Hariri et al. (2011), where TGDs were replaced by actions and a rule-based process that follow the same structure of the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al. (2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term is considered only equal to itself. Differently from these works, here we allow for sophisticated schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment of equality, where individuals can be inferred to be equal due to the application of such schema constraints and/or the execution of some action. This treatment of equality differentiates this work also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating with incomplete information. KABs constitute a more general framework, which can be seamlessly customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri et al. (2011) is also constituted by the verification formalism. In particular, both works focus on a form of \u03bc-calculus where ECQs are used to query the states of the system, but Bagheri Hariri et al. (2011) do not support quantification across states, as done here. Calvanese et al. (2012) investigate a framework for data-centric processes that mixes the approach proposed by Bagheri Hariri et al. (2013) for relational artifacts with the notion of knowledge bases as used here.", "startOffset": 38, "endOffset": 2123}, {"referenceID": 6, "context": "We observe that the results presented here fully subsume those by Bagheri Hariri et al. (2011), where the underlying description logic is OWL 2 QL.", "startOffset": 74, "endOffset": 95}, {"referenceID": 6, "context": "We observe that the results presented here fully subsume those by Bagheri Hariri et al. (2011), where the underlying description logic is OWL 2 QL. On the one hand, if we remove the possibility of asserting functionality of roles in the knowledge component, and of equating individuals as a result of an action in the action component, we precisely obtain the setting presented by Bagheri Hariri et al. (2011). On the other hand, for both frameworks the established complexity upper bounds are the same.", "startOffset": 74, "endOffset": 410}, {"referenceID": 12, "context": "Variants of this notion of \u201cstate boundedness\u201d have been proposed recently in other contexts (Belardinelli et al., 2012; De Giacomo, Lesperance, & Patrizi, 2012; Bagheri Hariri et al., 2013).", "startOffset": 93, "endOffset": 190}, {"referenceID": 47, "context": "While the majority of approaches that adopt forms of weak-acyclicity focus on databases (Marnette & Geerts, 2010; Meier, Schmidt, Wei, & Lausen, 2010), Cuenca Grau, Horrocks, Kr\u00f6tzsch, Kupke, Magka, Motik, and Wang (2012) investigate sophisticated forms of acyclicity in the context of knowledge bases without UNA.", "startOffset": 89, "endOffset": 222}, {"referenceID": 47, "context": "While the majority of approaches that adopt forms of weak-acyclicity focus on databases (Marnette & Geerts, 2010; Meier, Schmidt, Wei, & Lausen, 2010), Cuenca Grau, Horrocks, Kr\u00f6tzsch, Kupke, Magka, Motik, and Wang (2012) investigate sophisticated forms of acyclicity in the context of knowledge bases without UNA. Their results can thus be seamlessly applied to KABs. Interestingly, to manage the impact of equalities in a setting without UNA, they resort to the singularization technique presented by Marnette (2009), which closely resembles the normalization of KABs introduced in Section 7.", "startOffset": 89, "endOffset": 519}], "year": 2013, "abstractText": "Description logic Knowledge and Action Bases (KAB) are a mechanism for providing both a semantically rich representation of the information on the domain of interest in terms of a description logic knowledge base and actions to change such information over time, possibly introducing new objects. We resort to a variant of DL-Lite where the unique name assumption is not enforced and where equality between objects may be asserted and inferred. Actions are specified as sets of conditional effects, where conditions are based on epistemic queries over the knowledge base (TBox and ABox), and effects are expressed in terms of new ABoxes. In this setting, we address verification of temporal properties expressed in a variant of first-order \u03bc-calculus with quantification across states. Notably, we show decidability of verification, under a suitable restriction inspired by the notion of weak acyclicity in data exchange.", "creator": "TeX"}}}