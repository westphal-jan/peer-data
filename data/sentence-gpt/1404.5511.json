{"id": "1404.5511", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Apr-2014", "title": "Coactive Learning for Locally Optimal Problem Solving", "abstract": "Coactive learning is an online problem solving setting where the solutions provided by a solver are interactively improved by a domain expert, which in turn drives learning. In this paper we extend the study of coactive learning to problems where obtaining a globally optimal or near-optimal solution may be intractable or where an expert can only be expected to make small, local improvements to a candidate solution. The goal of learning in this new setting is to minimize the cost as measured by the expert effort over time and assess the feasibility of using a solution.\n\n\n\n\n\nTo explore further, we propose the following techniques:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Fri, 18 Apr 2014 21:17:04 GMT  (238kb,D)", "http://arxiv.org/abs/1404.5511v1", "AAAI 2014 paper, including appendices"]], "COMMENTS": "AAAI 2014 paper, including appendices", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["robby goetschalckx", "alan fern", "prasad tadepalli"], "accepted": true, "id": "1404.5511"}, "pdf": {"name": "1404.5511.pdf", "metadata": {"source": "CRF", "title": "Coactive Learning for Locally Optimal Problem Solving", "authors": ["Robby Goetschalckx", "Alan Fern", "Prasad Tadepalli"], "emails": [], "sections": [{"heading": "Introduction", "text": "This work is motivated by situations where a domain expert must solve a sequence of related problems. One way to reduce the expert\u2019s effort is for an automated solver to produce initial solutions that can then be improved, if necessary, by the expert with less effort than solving the problem from scratch. This requires that the solver has a good estimate of the expert\u2019s utility function, which is often unknown and must be learned through experience. This general notion of online learning from the improved solutions of an in situ expert is captured by the framework of coactive learning (Shivaswamy and Joachims 2012), (Raman et al. 2013), (Raman, Shivaswamy, and Joachims 2012), (Raman and Joachims 2013).\nThe current state-of-the-art in coactive learning generally assumes that the solver can either find a globally optimal solution (according to its current estimate of the utility function) to the problem, or at least a solution which can be proven to be at least \u03b1-close to the optimal solution (for example, using a greedy algorithm for a sub-modular utility\nCopyright c\u00a9 2014, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nfunction (Raman, Shivaswamy, and Joachims 2012), (Raman and Joachims 2013)). It is also assumed that the expert can always improve the solution if there is a possible improvement.\nUnfortunately in many planning and combinatorial optimization problems, neither of these assumptions is realistic. The current paper relaxes these assumptions by extending coactive learning to the cases where the system can only guarantee locally optimal solutions and the expert is only assumed to make a sequence of local improvements, but not required to return a locally optimal solution.\nFor example, consider a Traveling Salesperson Problem, where each edge of the graph is described by a number of numerical features, and the edge costs are known to be a linear combination of these features with unknown weights. We have an approximate solver which, for a given estimate of the edge-cost function, will give a reasonably good (but perhaps not optimal) solution to the TSP problem. The solver presents a candidate solution to an expert (who knows the actual cost function). The expert can either accept the solution or spend some effort making improvements to it. The more accurate the learner\u2019s estimate of the cost function, the less effort the expert needs to spend to adapt the candidate solution into one which is acceptable.\nMore generally, we assume that we have a planning or a combinatorial optimization problem, where finding a globally optimal solution for the problem is intractable, and where it is hard for an expert to do anything more than a sequence of local improvements to a candidate solution. We assume that we have a black-box solver which, for a given problem and current estimate of the cost function, will output a locally optimal solution. Assuming that the expert and the system have the same notion of \u2018locality\u2019, changes made by the expert will be very likely due to the estimate of the distance function being different from the actual distance function. With these assumptions, the expert feedback will allow the learner to improve its estimate of the proper cost function, eventually removing the need for the expert.\nIt is important to note that the local optimality assumptions of our framework strictly generalize those of prior coactive learning work, where the learner and the expert were assumed to be within a factor of \u03b1 of the true optimal solution. Another important aspect our framework is that we allow the learner to observe the effort expended by the\nar X\niv :1\n40 4.\n55 11\nv1 [\ncs .L\nG ]\n1 8\nA pr\n2 01\n4\nexpert, or cost, when producing improvements. The learner can exploit this additional feedback to put more emphasis on mistakes that are more costly from the expert\u2019s perspective, ideally leading to a faster reduction of expert effort.\nPerhaps the closest related work to ours is on learning trajectory preferences for robot manipulation (Jain, Joachims, and Saxena 2013). In this work, the authors describe a coactive learning approach that learns a scoring function based on improvements made by experts to automatically generated trajectories of robot manipulation tasks. Our main contributions in relation to this work are to formalize coactive learning in the context of locally optimal planning and demonstrate better learning algorithms with tighter performance bounds by making them cost-sensitive.\nIn addition to introducing the generalized coactive learning framework, our other primary contribution is to propose and analyze the cumulative cost of simple online learning algorithms for linearly parameterized cost functions. In particular, we describe cost-insensitive and cost-sensitive variants of the Perceptron and Passive Aggressive (PA) learning algorithms. We empirically evaluate these algorithms on four different domains and show that, the cost-sensitive Perceptron tends to perform better than all others when there is noise in the data. Also, unlike in classification setting, here the perceptron algorithms perform better than the PA algorithms. One reason for this is that the PA algorithms aggressively correct for any new data, meaning that any amount of noise can degrade the performance significantly."}, {"heading": "Problem Setup", "text": "Let X be the set of all problems in the domain of interest, e.g. a class of TSP graphs, and Y be the set of all possible problem solutions, e.g. possible tours. The quality of solutions is judged by the expert\u2019s utility function U(\u3008x, y\u3009) \u2192 R which gives the relative merit of a given candidate solution for a given problem.\nFor the purposes of learning we assume that the utility function can be well approximated by a linear function U\u0302(\u3008x, y\u3009) = ~w\u1d40~\u03c6(\u3008x, y\u3009). Here ~\u03c6(\u3008x, y\u3009) is a real-valued feature function of problem-solution pairs and ~w is a realvalued weight vector. In this work, we assume a bounded feature vector length: \u2016~\u03c6(\u00b7)\u2016 \u2264 R.\nA critical part of our coactive learning framework is the improvement of solutions by the expert. For this purpose we consider a setO of operators which can be used by the expert to transform a candidate solution into a different candidate solution: Oi \u2208 O : \u3008x, y\u3009 \u2192 \u3008x, y\u2032\u3009. The specific operators are highly domain and user-interface dependent. For example, in a TSP application, the operators might allow for local modifications to a current tour.\nWe assume a black-box solver S : X \u2192 Y which can be parameterized by the utility function weight vector ~w in order to optimize solutions according to U\u0302 . For many planning problems, including TSP, exactly optimizing U\u0302 will be intractable. Thus, for the purposes of our analysis we make the more realistic assumption that S is locally optimal with respect to U\u0302 and the set of expert operators O.\nAlgorithm 1 CoactiveUpdate(problem xt, black-box solution yt, expert solution y\u2032 (see text), cost Ct)\nif Ct > 0 then ~\u2206t := ~\u03c6(xt, y\n\u2032)\u2212 ~\u03c6(xt, yt) ~wt+1 = ~wt + \u03bbt~\u2206t\nend if\nAssumption 1 (Locally Optimal Solver). @Oi \u2208 O : U\u0302(Oi(\u3008xt, S(xt)\u3009)) > U\u0302(\u3008xt, S(xt)\u3009)\nWe can now specify our coactive learning protocol. The learner is presented with an arbitrary sequence of problems x0, x1, x2, . . . from X . Upon receiving each xt, the learner uses S to present the expert with a candidate solution yt based on its current utility estimate U\u0302 . The expert will then perform a sequence of operators O(1) . . . O(l) to the solution as long as significant local improvements are possible according to the true utility function U . We formalize this as a second assumption:\nAssumption 2 (Local Expert Improvement). If we denote, z(0) = \u3008xt, yt\u3009, z(i) = O(i)(z(i\u22121)), there is a constant \u03ba > 0 such that U(z(i+1)) \u2265 U(z(i)) + \u03ba.\nThe constant \u03ba reflects the minimum utility improvement required for the expert to go through the effort of applying an operator. Thus, according to this assumption the expert will monotonically improve a candidate solution until they are satisfied with it or they have reached diminishing returns for local improvements. The expert cost Ct for example xt is then equal to the number of operator applications, which reflects the amount of expert effort spent improving the candidate solution. The average cumulative cost 1 T \u2211T t=0 Ct quantifies the average effort of the expert over T steps. The goal of learning is to quickly diminish this cost. We note that it is straightforward to generalize the framework to account for operator dependent costs."}, {"heading": "Learning Algorithms", "text": "We consider online Perceptron-style algorithms that maintain a weight vector wt that is initialized to w0 = 0 and potentially updated after each training experience. At iteration t the learner presents the expert with solution S(xt) and observes the corresponding improvement operator sequence with cost Ct. Whenever Ct > 0 our learning algorithms will adjust the weight vector in the direction of ~\u2206t = ~\u03c6(xt, y\n\u2032)\u2212 ~\u03c6(xt, S(xt)). Algorithm 1 gives the schema used by our learning algorithms for updating the weight vector after the interaction involving problem xt. In the tradition of the Perceptron, this update is passive in the sense that whenever Ct = 0, meaning that the expert is satisfied with the solution produced, the weight vector is not altered. Our four algorithms differ only in the choices they make for the learning rate \u03bbt, which controls the magnitude of the weight update. Below we specify each of our four variants that are analyzed and empirically evaluated in the following sections.\nPerceptron (PER) (\u03bbt = 1). This instance of the algorithm corresponds to the classic Perceptron algorithm, which uses a uniform, cost-insensitive learning rate. This socalled preference perceptron algorithm was previously proposed for coactive learning, although its analysis was for their more restrictive assumption of global optimality (Shivaswamy and Joachims 2012).\nCost-Sensitive Perceptron (CSPER) (\u03bbt = Ct). Notice that the above Perceptron algorithm completely ignores the observed cost Ct. Intuitively, one would like to put more emphasis on examples where the cost is high, to potentially decrease the cumulative cost more rapidly. The CostSensitive Perceptron (an online version of the perceptron introduced in (Geibel and Wysotzki 2003)) takes the cost into account by simply allowing the learning rate to scale with the cost, in this case being equal to the cost. This is an approximation of what would happen if the original Perceptron update was applied Ct times per instance. This is similar to a standard approach to obtain an example-dependent cost-sensitive learner (Zadrozny, Langford, and Abe 2003), where the probability of each example to be considered by the algorithm is proportional to the cost of misclassifying it. The algorithm presented here can be seen as a simplified online version of this.\nPassive Aggressive (PA) (\u03bbt = M\u2212~w\u1d40t ~\u2206t \u2016~\u2206t\u20162\n). The framework of PA algorithms has been well-studied in the context of more traditional online learning problems (Crammer et al. 2006) and has shown advantages compared to more traditional Perceptron updates. Here we consider whether the PA framework can show similar advantage in the context of coactive learning.\nThe PA update principle is to be passive, just as for the Perceptron algorithms. In addition, unlike the Perceptron, PA updates are aggressive in the sense that the weights are updated in a way that are guaranteed to correct the most recent mistake. In our coactive setting, this PA principle corresponds to minimizing the change to the weight vector while ensuring that the new vector assigns the improved solution y\u2032 a higher utility than yt. More formally:\nwt+1 = arg min ~w \u2016~w \u2212 ~wt\u20162, s.t. ~w\u1d40t+1~\u2206t = M\nwhere M is a user specified target value for the margin. As in prior work (Crammer et al. 2006) the solution to this problem is easily derived via Lagrangian methods resulting in an update with \u03bbt = M\u2212~w\u1d40t ~\u2206t \u2016~\u2206t\u20162\n. Note that either version of the Perceptron algorithm may either not correct the mistake, or update the weights much more than necessary to correct the mistake. In our experiments we set M = 1 throughout, noting that in the coactive learning setting the specific value of M only results in a different scaling of the weight vectors, without changing the behavior or the obtained costs.\nCost-Sensitive PA (CSPA) (\u03bbt = Ct\u2212~w\u1d40t ~\u2206t \u2016~\u2206t\u20162\n). Since the margin M indicates how strongly an example influences the weight vector, a natural way to include the cost into the PA algorithm is by making the margin for an update equal to the cost. This approach effectively instantiates the idea of\nmargin-scaling, e.g., as employed for structured prediction (Taskar et al. 2005), within the PA framework."}, {"heading": "Cost Bounds", "text": "In this section we will present upper bounds on the average cost over time for all four algorithms presented in the previous section, in the realizable learning setting where the actual utility function is a linear function of the feature vector, represented by the weight vector ~w\u2217. Since the cost is an integer, this effectively provides a bound on the number of examples where the expert is able to make any improvement on the solution.\nThe most similar prior analysis done for coactive learning focused on the Perceptron algorithm under the assumptions of global optimality. That analysis provided a bound on the average regret, rather than expert cost, where regret is the utility difference between the globally optimal solution and the learner\u2019s solution. Thus the novelty of our analysis is in directly bounding the expert cost, which is arguably more relevant, generalizing to the setting of local optimality, and analyzing a wider set of algorithms. The analysis in (Shivaswamy and Joachims 2012) also provides a lower bound on the average difference in utlity between the expert solution and initial solution of \u2126( 1\u221a\nT ). For one of our algorithms,\nthe upper bound on the cost we obtain is better than this, (O( 1T )), indicating the difference between utility and cost. In fact, working out the specific example given as proof of the bound in (Shivaswamy and Joachims 2012) does provide a worst-case example, where the average cost is equal to the upper bound.\nWe will make one extra assumption for our theoretical analysis in addition to Assumptions 1 and 2 regarding local optimality.\nAssumption 3. If Ct > 0, then U\u0302(\u3008x, y\u2032t\u3009) < U\u0302(\u3008x, yt\u3009). This assumption assures us that the learner will favor its own solution yt over the final locally optimal improvement provided by the expert. In practice, this can be guaranteed by observing the entire sequence of candidate solutions the expert goes through to obtain their final solution and taking the last candidate in the sequence where the learner disagrees with it being an improvement on the original candidate solution. There will be at least one such solution in the sequence because of the assumption of local optimality of the original candidate solution. Of course, this implies that the actual effort will potentially be larger than the effort until the presented solution was found. However, since any such case has a cost of at least 1, we still have an upper bound on the number of times where the expert is able to provide improvements on the solution by local changes.\nWe now state the main result providing cost bounds for our four algorithms. The proof can be found in appendix A. Theorem 1. Given a linear expert utility function with weights ~w\u2217, under Assumptions 1-3 we get the following average cost bounds:\nPER: 1 T \u2211T t=0 Ct \u2264 2R||~w\u2217|| \u03ba \u221a T\nCSPER: 1 T \u2211T t=0 Ct \u2264 1\nT T\u2211 t=0 C 2 t \u2264 4R2||~w\u2217||2 \u03ba2T\nPA: 1 T \u2211T t=0 Ct \u2264 4R2||~w\u2217||2\n\u03ba2 \u221a T\nCSPA: 1 T \u2211T t=0 Ct \u2264 1\nT T\u2211 t=0 C 2 t \u2264 4R2||~w\u2217||2 \u03ba2 \u221a T\nWe first observe that the cost-sensitive Perceptron bound decreases significantly faster than the other bounds, achieving a rate of O(1/T ) compared to O(1/ \u221a T ). This implies that there is a constant bound on the summed costs. At least when comparing PER and CSPER, this shows the potential benefit of introducing cost into the learning process. Rather, we do not see such a rate reduction for cost-sensitive PA versus PA, which both achieve the same bound. It is not clear whether or not this is due to a loose analysis or is inherent in the algorithms. We do not yet have lower bounds on the rates of these algorithms, which would shed light on this issue. We do see however, that the bounds for both cost-sensitive algorithms hold for the average squared cost, which are strictly better bounds in our setting. Thus, even in the PA case, these results suggest that there is a potential advantage to introducing cost into learning.\nSimilar error bounds for the PER and CSPER algorithms in the case where there is noise in the expert\u2019s assessment, i.e. the expert might mis-estimate the relative utilities of the original solution and a suggested improvement by a term \u03bet are presented in appendix B."}, {"heading": "Experiments", "text": "Experiments were performed in 4 different problem domains. All reported results are averages over 10 runs of the experiments. In the first 3 domains the utility function is a linear function of the features. In each domain, two different settings were tested. In one of the settings, there are 10 dimensions to the feature vectors. In the other, there are 11 features, but one of the features is only available to the expert, not to the solver. This adds noise to the experiment, and learning a weight vector which does not incur any cost is impossible. The coefficients of the expert weight vector were generated uniformly at random from [0, 1].\nIn the cases where even the optimal weight vector does not guarantee non-zero cost, this average cost will be shown in the results, labeled \u2018expert\u2019. All graphs shown have a logscale on the Y -axis, unless reported otherwise.\nPath Planning The first task is a simple path planning domain. The environment consists of a 7-dimensional hypercube, where the solver needs to find the optimal path of length 7 from one corner to the diagonally opposite corner. There are 7! such possible paths. Each edge is described by a feature vector, and the feature vector of a total path is the sum of the vectors describing the edges used in the path.\nThe solver uses a simple 2 step lookahead search. The expert can improve this trajectory by looking at three subsequent moves and reordering them, if any such reordering gives an improvement of at least \u03ba = 0.1, until no such improvement is possible. Both a noisy and noise-free setting were tested. Note that the expert uses a different set of optimizations from the solver. This means that even with perfect weight vector, a cost of more than 0 is unavoidable. Results here (as shown in figures 1(a) and 1(b)) show that CSPER performs best, and PA performs worst.\nTSP To show the feasibility of the approach for a more interesting problem, a Traveling salesperson problem was used. A random set of 20 points was generated, with their connecting edges described by 100 dimensional feature vectors (with or without an extra 10 hidden dimensions). The solver uses a fast approximate solver. It keeps a set of unvisited points, and starts with a path containing only 1 point. The solver determines which unvisited point can be added to the current path at the least extra cost, and adds the point, until all points are visited. It then performs an optimization by performing 2-opt updates. Each such an update removes two edges from the path and reconnects the path in the shortest possible way.\nThe expert also uses 2-opt updates to improve the solution, but only performs an update if it decreases the path cost by at least \u03ba. The cost is the number of such updates performed until a local optimum is reached. Features were generated according to a uniform [0, 1] distribution. The slack variable \u03ba has value 0.1. Results are shown in figures 1(c) and 1(d). As in the previous experiments, CSPER outperforms the other algorithms.\nMulti-TSP Multi-TSP (mTSP) is a generalization of TSP to multiple salespersons. Given a set of 40 points, and 4 salespersons each with their own start and end locations among the given points, the goal is to determine a tour for each of the salespersons such that the total tour cost is minimized, and each point is visited exactly once by at least one salesperson.\nFor this experiment, a random set of 40 points are generated with their connecting edges described by feature vectors. The solver is a generalization of the TSP solver introduced in the previous section. It finds the tours for each salesperson incrementally, by finding a point that can be added to the existing tours with least cost. It repeats this strategy until no more points are left. It then applies 2-OPT adaptations to find a locally optimal solution. Similar to the TSP experiment, the expert uses 2-OPT heuristic to improve tours.\nResults are shown in figures 1(e) and 1(f). For the noisy setting, CSPER clearly outperforms the other algorithms. For the settings without noise, it performs worst, however. One possible explanation is that it focuses too much on the first few data points (where costs are high), relative to later points. The regular perceptron does not have this behavior, and results for this algorithm are good in all the settings.\nLearning to Rank Dataset A final experiment was performed using the Yahoo! Learning to Rank dataset (Chapelle and Chang 2011), a real-world dataset consisting of webbased queries and lists of documents which were returned for those queries. Human experts labeled the documents with scores from 0 to 4 according to relevance to the query. All documents are described by a 700-dimensional feature vector. The learner sorts all documents according to decreasing estimated utility. The expert then iterates over this list, exchanging the order of two subsequent elements if the latter one is substantially better than the first (a score difference of 2 or more). The effort is the number of such exchanges until no such exchanges are possible. All reported results are averages over 10 random permutations of the original dataset.\nResults are shown in figure 1(g) (notice the linear scale on the Y-axis). The classic perceptron algorithm performs best, with CSPER second-best. The relatively poor performance of the PA-based algorithms can be easily explained by the noise in the dataset. Since the PA algorithms aggressively correct the last observed error, any amount of noise could have a potentially disastrous effect. Note that CSPER does not perform as well as in most of the other experiments. One possible reason for this is that, as in the noise-free multi-TSP setting, the effort for the first few examples was large, resulting in a large jump in the weight vector. Subsequent costs are much smaller, which means it takes longer to fine-tune the weight vector. To test this, the experiment was repeated us-\ning an upper bound on the effort the expert was willing to make. For each example, a random integer between 5 and 15 was generated as the maximum \u201cbudget\u201d for the expert. Results are shown in Figure 1(h) (notice the linear scale on the Y-axis). It is clear that this bound on the maximum cost greatly benefits the CSPER algorithm, which now only performs slightly worse than the perceptron."}, {"heading": "Conclusions", "text": "In this paper, a novel problem statement for coactive learning was introduced. The main difference with existing work on coactive learning is that the problems are assumed to be so hard that finding the globally optimal solution is in-\ntractable, and an expert can be expected to only make small, local changes to a solution. We assume that there exist locally optimal solvers that can provide high-quality solutions when having an accurate estimate of the expert\u2019s utility function.\nFour algorithms were presented for this task. Since the objective is to minimize the effort spent to improve the candidate solutions, two of the algorithms directly take this cost into account in their update functions. Theoretical bounds on the average cost for the four algorithms were shown, where the cost-sensitive perceptron algorithm was shown to have a much stronger bound. Empirically it was verified that in most settings, the cost-sensitive versions of the algorithms outperform their cost-insensitive versions. The costsensitive perceptron performs best in most datasets, specifically when noise was present. However, in some cases it was observed that cost sensitivity hurt performance in cases where early high-cost problems significantly alter the weight vector. Our empirical results suggest that bounding the maximum change in weight vector can help in these cases. This leaves an open question of how to most robustly and effectively take cost into account in the co-active learning setting.\nOur final empirical observation was that the Passive Aggressive algorithms perform the worst, which is in contrast to such algorithms in the context of online classification. The reason for this might be that the algorithms are too aggressive in their updates, effectively overfitting the last seen example. This leads to some possible directions for future work including investigation of (mini-)batch learning algorithms and versions of the PA algorithm which limit the aggressiveness (Crammer et al. 2006)."}, {"heading": "Appendix A: Proof of Theorem 1", "text": "Proof. Each bound is derived using a similar strategy in the tradition of Perceptron-style analysis. The proof ignores all steps where no update occurs since these have cost equal to 0 and would only reduce the average cost. First, we show an upper bound on ||~wT+1||2. Then, for each algorithm, we provide a lower bound on ~w\u1d40T+1 ~w\n\u2217 in terms of the sum of costs \u2211T t=0 Ct or sum of squared costs \u2211T t=0 C 2 t .\nUsing the general update ~wT+1 = ~wT + \u03bbT ~\u2206T , we get the following bound for ||wT+1||2: ||~wT+1||2 = ||~wT ||2 + 2\u03bbT ~w \u1d40 T ~\u2206T +\u03bb 2 T ~\u2206\u1d40T ~\u2206T \u2264 ||~wT ||2 +\u03bb2T ~\u2206 \u1d40 T ~\u2206T \u2264 ||~wT ||2 + \u03bb2T (2R) 2 \u2264 4R2 \u2211T t=0 \u03bb 2 T where the last step follows by induction. The second step follows from Assumption 3. Then, we use the Cauchy-Schwarz inequality ~w\u1d40T+1 ~w\n\u2217 \u2264 ||~wT+1||\u00b7||~w\u2217|| to obtain an upper bound on the sum of costs, which can be trivially turned into a bound on the average cost. Note that in the setting of the paper, where the costs are natural numbers, the sum of the squares of the costs is an upper bound on the sum of the costs: \u2211T t=0 Ct \u2264 \u2211T t=0 C 2 t Below we derive bounds for each algorithm in turn. Perceptron. We get the upper bound ||~wT+1||2 < 4R2T . For the lower bound on ~w\u1d40T+1 ~w \u2217 we get: ~w\u1d40T+1 ~w \u2217 = ~w\u1d40T ~w \u2217+ ~\u2206\u1d40T ~w \u2217 \u2265 ~w\u1d40T ~w\u2217+\u03baCT \u2265 \u03ba \u2211T t=0 Ct Here the first inequality follows from Assumptions 2 and 3. In particular by Assumption 2 we have that for any step where Ct > 0,\nU(xt, y \u2032)\u2212 U(xt, yt) \u2264 \u03ba \u00b7 Ct.\nApplying Cauchy-Schwarz we get: \u03ba \u2211T t=0 Ct \u2264 2R||~w\u2217|| \u221a T\nCost-Sensitive Perceptron. We have the upper bound ||~wT+1||2 \u2264 4R2 \u2211T t=0 C 2 t and a lower bound on ~w \u1d40 T+1 ~w \u2217 = ~w\u1d40T ~w \u2217 + CT ~\u2206 \u1d40 T ~w \u2217 \u2265 ~w\u1d40T ~w\u2217 + \u03baC2T \u2265 \u03ba \u2211T t=0 C 2 t\nApplying Cauchy-Schwarz we get: \u03ba \u2211T t=0 C 2 t \u2264 2R||~w\u2217|| \u221a\u2211T t=0 C\n2 t\u221a\u2211T\nt=0 C 2 t \u2264 2R||~w\u2217|| \u03ba \u21d2 \u2211T t=0 C 2 t \u2264 4R2||~w\u2217||2 \u03ba2\nPA. We will use the shorthand S = M\u2212~w \u1d40 T ~\u2206T\n~\u2206\u1d40T ~\u2206T\n. We be-\ngin with proving an upper bound on ~\u2206\u1d40T ~\u2206T . We know that ~\u2206\u1d40T ~w\n\u2217 \u2265 \u03baCT . From the Cauchy-Schwarz inequality we then have that \u03baCT \u2264 ||w\u2217|| \u00b7 ||~\u2206T ||. This implies that ~\u2206\u1d40T ~\u2206T = ||~\u2206T ||2 \u2265 \u03ba2C2T ||w\u2217||2 . Since we only consider those examples where the cost is non-zero, this means that ~\u2206\u1d40T ~\u2206T \u2265 \u03ba 2 ||w\u2217||2 .\nAn upper bound on ||~wT+1||2 = ||~wT ||2 + 2S ~w\u1d40T ~\u2206T + S2~\u2206 \u1d40 T ~\u2206T = ||~wT ||2+S(2~w\u1d40T ~\u2206T+(M\u2212 ~w \u1d40 T ~\u2206T )) = ||~wT ||2+S(M+ ~w\u1d40T ~\u2206T ) = ||~wT ||2 + M2\u2212(~w\u1d40T ~\u2206T ) 2\n~\u2206\u1d40T ~\u2206T\n\u2264 ||~wT ||2 + M 2\n~\u2206\u1d40T ~\u2206T \u2264\n||~w\u2217||2TM2 \u03ba2\nNow a lower bound on ~w\u1d40T+1 ~w \u2217\n= ~w\u1d40T ~w \u2217 + S~\u2206\u1d40T ~w \u2217\n\u2265 ~w\u1d40T ~w \u2217 + S\u03baCT = ~w \u1d40 T ~w \u2217 + M \u2212 ~w\u1d40T ~\u2206T ~\u2206\u1d40T ~\u2206T \u03baCT\n\u2265 ~w\u1d40T ~w \u2217 + M\u03baCT ~\u2206\u1d40T ~\u2206T \u2265 M\u03ba 4R2 T\u2211 t=0 Ct\nApplying Cauchy-Schwarz we get M\u03ba/(4R2) \u2211T t=0 Ct \u2264 ||~w\u2217||2M \u221a T/\u03ba\nCost-Sensitive PA. Here we will use the shorthand S\u2032 = (CT \u2212 ~w\u1d40T ~\u2206T )/(~\u2206 \u1d40 T ~\u2206T ), and the bound ~\u2206 \u1d40 T ~\u2206T \u2265 \u03ba 2C2T ||w\u2217||2 .\nAn upper bound on ||~wT+1||2 = ||~wT ||2 + 2S\u2032 ~w\u1d40T ~\u2206T + S\u20322~\u2206 \u1d40 T ~\u2206T = ||~wT ||2 + S\u2032(2~w\u1d40T ~\u2206T +(CT\u2212 ~w\u1d40T ~\u2206T )) = ||~wT ||2+S\u2032(CtT+ ~w \u1d40 T ~\u2206T ) = ||~wT ||2 + C2T\u2212(~w \u1d40 T ~\u2206T ) 2\n~\u2206\u1d40T ~\u2206T\n\u2264 ||~wT ||2 + C 2 T ~\u2206\u1d40T ~\u2206T \u2264 ||~w \u2217||2T \u03ba2\nNow a lower bound on ~w\u1d40T+1 ~w \u2217\n= ~w\u1d40T ~w \u2217 + S\u2032~\u2206\u1d40T ~w \u2217 \u2265 ~w\u1d40T ~w\u2217 + S\u2032\u03baCT = ~w \u1d40 T ~w \u2217 +\nCT\u2212~w\u1d40T ~\u2206T ~\u2206\u1d40T ~\u2206T \u03baCT\n\u2265 ~w\u1d40T ~w\u2217 + \u03baC2T ~\u2206\u1d40T ~\u2206T \u2265 ~w\u1d40T ~w\u2217 + \u03baC2T 4R2 \u2265 \u03ba 4R2\n\u2211T t=0 C 2 t\nUsing this and applying Cauchy-Schwarz we get: \u03ba 4R2 \u2211T t=0 C 2 t \u2264 ||~w\u2217||2 \u221a T \u03ba"}, {"heading": "Appendix B: Bounds for Noisy Data", "text": "In this appendix, we present the analysis of the average cost bounds for the PER and CSPER algorithms in the case where there is noise in the expert\u2019s assessment, i.e. the expert might mis-estimate the relative utilities of the original solution and a suggested improvement by a term \u03bet so that Assumption 3 is relaxed, and we only have the assumption that for each example xt, U(\u3008xt, y\u2032\u3009) \u2212 U(\u3008xt, y\u3009) \u2265 \u03baCt \u2212 \u03bet. In this case, for the simple perceptron algorithm we get the bound 1T \u2211T t=0 Ct \u2264 2R||~w\u2217|| \u03ba \u221a T + 1\u03baT \u2211T t=0 \u03bet, which is comparable to the bound presented in (Shivaswamy and Joachims 2012). For the CSPER algorithm, we obtain the bound 1T \u2211T t=0 Ct \u2264 1 T \u2211T t=0 C 2 t \u2264 4R 2||~w\u2217||2 \u03ba2T + 4R||~w\u2217|| \u03ba2T \u221a\u2211T t=0 \u03betCt + 1 \u03ba2T \u2211T t=0 \u03betCt.\nIt is not clear whether similar bounds hold for the PAbased algorithm, since they are susceptible to noise. Theorem 2. Given a linear expert utility function with weights ~w\u2217, under Assumptions 1-3 we get the following average cost bounds:\nPER: 1T \u2211T t=0 Ct \u2264 2R||~w\u2217|| \u03ba \u221a T + 1\u03baT \u2211T t=0 \u03bet\nCSPER 1T \u2211T t=0 Ct \u2264 1 T \u2211T t=0 C 2 t\n\u2264 4R 2||~w\u2217||2 \u03ba2T + 4R||~w\u2217|| \u03ba2T \u221a\u2211T t=0 \u03betCt + 1 \u03ba2T \u2211T t=0 \u03betCt\nProof. PER For the Perceptron algorithm, we have the following bound on ||~wT+1||2:\n||~wT+1||2 = ||~wT ||2 + 2~w\u1d40T ~\u2206T + ~\u2206 \u1d40 T ~\u2206T\n\u2264 ||~wT ||2 + ~\u2206\u1d40T ~\u2206T \u2264 ||~wT ||2 + (2R)2\n\u2264 4R2T For the lower bound on ~w\u1d40T+1 ~w \u2217 we get:\n~w\u1d40T+1 ~w \u2217 = ~w\u1d40T ~w \u2217 + ~\u2206\u1d40T ~w \u2217 \u2265 ~w\u1d40T ~w \u2217 + \u03baCT \u2212 \u03beT\n\u2265 \u03ba T\u2211 t=0 Ct \u2212 T\u2211 t=0 \u03bet\nCombining these and applying Cauchy-Schwarz we get:\n\u03ba T\u2211 t=0 Ct \u2264 2R||~w\u2217|| \u221a T + T\u2211 t=0 \u03bet\n1\nT T\u2211 t=0 Ct \u2264 2R||~w\u2217|| \u03ba \u221a T + 1 \u03baT T\u2211 t=0 \u03bet\nCSPER\nFor the CSPER algorithm, we have the following bound on ||~wT+1||2: ||~wT+1||2 = ||~wT ||2 + 2CT ~w\u1d40T ~\u2206T + C 2 T ~\u2206\u1d40T ~\u2206T\n\u2264 ||~wT ||2 + C2T ~\u2206 \u1d40 T ~\u2206T \u2264 ||~wT ||2 + (2R)2C2T\n\u2264 4R2 T\u2211 t=0 C2t\nand the following bound on ~w\u1d40T+1 ~w \u2217:\n~w\u1d40T+1 ~w \u2217 = ~w\u1d40T ~w \u2217 + CT ~\u2206 \u1d40 T ~w \u2217\n\u2265 ~w\u1d40T ~w \u2217 + \u03baC2T \u2212 \u03beTCT\n\u2265 \u03ba T\u2211 t=0 C2t \u2212 T\u2211 t=0 \u03betCt\nCombining these, using Cauchy-Schwarz, we get:\n\u03ba T\u2211 t=0 C2t \u2212 T\u2211 t=0 \u03betCt \u2264 2R||~w\u2217|| \u221a\u221a\u221a\u221a T\u2211 t=0 C2t\nUsing the shorthand notation \u03b8 = \u221a\u2211T\nt=0 C 2 t , we can\nrewrite this as:\n\u03ba\u03b82 \u2212 2R||~w\u2217||\u03b8 \u2212 T\u2211 t=0 \u03betCt \u2264 0\nThis is a quadratic inequality in terms of \u03b8. The upper bound for \u03b8 we get from this is:\n\u03b8 \u2264 R||~w\u2217||+\n\u221a R2||~w\u2217||2 + \u2211T t=0 \u03betCt\n\u03ba\nFor simplicity, we can safely rewrite this (using\u221a A2 +B2 \u2264 \u221a A2 + \u221a B2) as:\n\u03b8 \u2264 2R||~w\u2217||+\n\u221a\u2211T t=0 \u03betCt\n\u03ba\nSince \u2211T t=0 C 2 t = \u03b8 2, we get:\nT\u2211 t=0 C2t \u2264 4R2||~w\u2217||2 \u03ba2 + 4R||~w\u2217|| \u03ba2 \u221a\u221a\u221a\u221a T\u2211 t=0 \u03betCt+ 1 \u03ba2 T\u2211 t=0 \u03betCt"}, {"heading": "Acknowledgements", "text": "The authors acknowledge support of the ONR ATL program N00014-11-1-0105."}], "references": [{"title": "Yahoo! Learning to Rank Challenge Overview", "author": ["Chapelle", "O. Chang 2011] Chapelle", "Y. Chang"], "venue": "Journal of Machine Learning Research", "citeRegEx": "Chapelle et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chapelle et al\\.", "year": 2011}, {"title": "Online passiveaggressive algorithms. The Journal of Machine Learning Research 7:551\u2013585", "author": ["Crammer"], "venue": null, "citeRegEx": "Crammer,? \\Q2006\\E", "shortCiteRegEx": "Crammer", "year": 2006}, {"title": "Perceptron based learning with example dependent and noisy costs", "author": ["Geibel", "P. Wysotzki 2003] Geibel", "F. Wysotzki"], "venue": "In Proceedings of the 20th International Conference on Machine Learning", "citeRegEx": "Geibel et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Geibel et al\\.", "year": 2003}, {"title": "Learning trajectory preferences for manipulators via iterative improvement", "author": ["Joachims Jain", "A. Saxena 2013] Jain", "T. Joachims", "A. Saxena"], "venue": "In Proceedings of the 30th International Conference on Machine Learning (ICML-13)", "citeRegEx": "Jain et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Jain et al\\.", "year": 2013}, {"title": "Learning socially optimal information systems from egoistic users", "author": ["Raman", "K. Joachims 2013] Raman", "T. Joachims"], "venue": "In ECML/PKDD", "citeRegEx": "Raman et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Raman et al\\.", "year": 2013}, {"title": "Stable coactive learning via perturbation", "author": ["Raman"], "venue": "Proceedings of the 30th International Conference on Machine Learning (ICML-13),", "citeRegEx": "Raman,? \\Q2013\\E", "shortCiteRegEx": "Raman", "year": 2013}, {"title": "Online learning to diversify from implicit feedback", "author": ["Shivaswamy Raman", "K. Joachims 2012] Raman", "P. Shivaswamy", "T. Joachims"], "venue": null, "citeRegEx": "Raman et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Raman et al\\.", "year": 2012}, {"title": "Online structured prediction via coactive learning", "author": ["Shivaswamy", "P. Joachims 2012] Shivaswamy", "T. Joachims"], "venue": "CoRR abs/1205.4213", "citeRegEx": "Shivaswamy et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Shivaswamy et al\\.", "year": 2012}, {"title": "Learning structured prediction models: A large margin approach", "author": ["Taskar"], "venue": "In Proceedings of the 22nd international conference on Machine learning,", "citeRegEx": "Taskar,? \\Q2005\\E", "shortCiteRegEx": "Taskar", "year": 2005}, {"title": "Cost-sensitive learning by costproportionate example weighting", "author": ["Langford Zadrozny", "B. Abe 2003] Zadrozny", "J. Langford", "N. Abe"], "venue": "In Data Mining,", "citeRegEx": "Zadrozny et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Zadrozny et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 4, "context": "This general notion of online learning from the improved solutions of an in situ expert is captured by the framework of coactive learning (Shivaswamy and Joachims 2012), (Raman et al. 2013), (Raman, Shivaswamy, and Joachims 2012), (Raman and Joachims 2013).", "startOffset": 170, "endOffset": 189}], "year": 2014, "abstractText": "Coactive learning is an online problem solving setting where the solutions provided by a solver are interactively improved by a domain expert, which in turn drives learning. In this paper we extend the study of coactive learning to problems where obtaining a globally optimal or near-optimal solution may be intractable or where an expert can only be expected to make small, local improvements to a candidate solution. The goal of learning in this new setting is to minimize the cost as measured by the expert effort over time. We first establish theoretical bounds on the average cost of the existing coactive Perceptron algorithm. In addition, we consider new online algorithms that use cost-sensitive and Passive-Aggressive (PA) updates, showing similar or improved theoretical bounds. We provide an empirical evaluation of the learners in various domains, which show that the Perceptron based algorithms are quite effective and that unlike the case for online classification, the PA algorithms do not yield significant performance gains.", "creator": "LaTeX with hyperref package"}}}