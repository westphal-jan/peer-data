{"id": "1405.1071", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-May-2014", "title": "Revisiting Chase Termination for Existential Rules and their Extension to Nonmonotonic Negation", "abstract": "Existential rules have been proposed for representing ontological knowledge, specifically in the context of Ontology- Based Data Access. Entailment with existential rules is undecidable. We focus in this paper on conditions that ensure the termination of a breadth-first forward chaining algorithm known as the chase. Several variants of the chase have been proposed. In the first part of this paper, we propose a new tool that allows to extend existing acyclicity conditions ensuring chase termination, while keeping good complexity properties. In the second part, we study the extension to existential rules with nonmonotonic negation under stable model semantics, discuss the relevancy of the chase variants for these rules and further extend acyclicity results obtained in the positive case. We also study the implications for the emergence of an ontological approach to nonmonotonic semantics, in contrast to the other alternatives for an ontological approach to nonmonotonic semantics. As part of the paper, we describe an expanded framework for describing new expressions. In addition, we discuss the implications for the inclusion of an existential category of existential rules in an open-access publication.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Mon, 5 May 2014 20:58:01 GMT  (49kb)", "https://arxiv.org/abs/1405.1071v1", "This paper appears in the Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"], ["v2", "Fri, 25 Jul 2014 12:49:54 GMT  (328kb)", "http://arxiv.org/abs/1405.1071v2", "This paper appears in the Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"]], "COMMENTS": "This paper appears in the Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["jean-fran\\c{c}ois baget", "fabien garreau", "marie-laure mugnier", "swan rocher"], "accepted": false, "id": "1405.1071"}, "pdf": {"name": "1405.1071.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Jean-Fran\u00e7ois Baget", "Fabien Garreau", "Marie-Laure Mugnier", "Swan Rocher"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n10 71\nv2 [\ncs .A\nI] 2\n5 Ju\nl 2 01\n4"}, {"heading": "Introduction", "text": "Existential rules (also called Datalog+/-) have been proposed for representing ontological knowledge, specifically in the context of Ontology-Based Data Access, that aims to exploit ontological knowledge when accessing data (Cal\u0131\u0300, Gottlob, and Lukasiewicz 2009a; Baget et al. 2009). These rules allow to assert the existence of unknown individuals, a feature recognized as crucial for representing knowledge in an open domain perspective. Existential rules generalize lightweight description logics, such as DL-Lite and EL (Calvanese et al. 2007; Baader, Brandt, and Lutz 2005) and overcome some of their limitations by allowing any predicate arity as well as cyclic structures.\nEntailment with existential rules is known to be undecidable (Beeri and Vardi 1981; Chandra, Lewis, and Makowsky 1981). Many sufficient conditions for decidability, obtained by syntactic restrictions, have been exhibited in knowledge representation and database theory (see e.g., the overview in (Mugnier 2011)). We focus in this paper on conditions that ensure the termination of a breadth-first forward chaining algorithm, known as the chase in the database literature. Given a knowledge base composed of data and existential rules, the chase saturates the data by application of the rules. When it is ensured to terminate, inferences enabled by the rules can be materialized in the data, which can then be queried like a classical database, thus allowing to benefit from any database optimizations technique. Several variants of the chase have been proposed, which differ in the way\nthey deal with redundant information (Fagin et al. 2005; Deutsch, Nash, and Remmel 2008; Marnette 2009). It follows that they do not behave in the same way with respect to termination. In the following, when we write the chase, we mean one of these variants. Various acyclicity notions have been proposed to ensure the halting of some chase variants.\nNonmonotonic extensions to existential rules were recently considered in (Cal\u0131, Gottlob, and Lukasiewicz 2009b) with stratified negation, (Gottlob et al. 2012) with well-founded semantics and (Magka, Kro\u0308tzsch, and Horrocks 2013) with stable model semantics. This latter work studies skolemized existential rules and focuses on cases where a finite unique model exists.\nIn this paper, we tackle the following issues : Can we still extend known acyclicity notions ? Would any chase variant be applicable to existential rules provided with nonmonotonic negation, a useful feature for ontological modeling ?\n1. Extending acyclicity notions. Acyclicity conditions can be classified into two main families : the first one constrains the way existential variables are propagated during the chase (e.g. (Fagin et al. 2003; Fagin et al. 2005; Marnette 2009; Kro\u0308tzsch and Rudolph 2011)) and the second one encodes dependencies between rules, i.e., the fact that a rule may lead to trigger another rule (e.g. (Baget 2004; Deutsch, Nash, and Remmel 2008; Baget et al. 2011)). These conditions are based on different graphs, but all of them can be seen as can as forbidding \u201cdangerous\u201d cycles in the considered graph. We define a new family of graphs that allows to extend these acyclicity notions, while keeping good complexity properties.\n2. Processing rules with nonmonotonic negation. We define a notion of stable models on nonmonotonic existential rules and provide a derivation algorithm that instantiate rules \u201con the fly\u201d (Lefe\u0300vre and Nicolas 2009; Dao-Tran et al. 2012). This algorithm is parametrized by a chase variant. We point out that, differently to the positive case, not all variants of the chase lead to sound procedures in presence of nonmonotonic negation ; furthermore, skolemizing existential variables or not makes a semantic difference, even when both computations terminate. Finally, we further extend acyclicity results obtained on positive rules by exploiting negative information as well.\nA technical report with the proofs omit-\nted for space restriction reasons is available http://www2.lirmm.fr/\u02dcbaget/publications/nmr2014-long.pdf."}, {"heading": "Preliminaries", "text": "Atomsets We consider first-order vocabularies with constants but no other function symbols. An atom is of the form p(t1, . . . , tk) where p is a predicate of arity k and the ti are terms, i.e., variables or constants (in the paper we denote constants by a, b, c, ... and variables by x, y, z, ...). An atomset is a set of atoms. Unless indicated otherwise, we will always consider finite atomsets. If F is an atom or an atomset, we write terms(F) (resp. vars(F), resp. csts(F)) the set of terms (resp. variables, resp. constants) that occur in F. If F is an atomset, we write \u03c6(F) the formula obtained by the conjunction of all atoms in F, and \u03a6(F) the existential closure of \u03c6(F). We say that an atomset F entails an atomset Q (notation F |= Q) if \u03a6(F) |= \u03a6(Q). It is well-known that F |= Q iff there exists a homomorphism from Q to F, i.e., a substitution \u03c3 : vars(F) \u2192 terms(Q) such that \u03c3(Q) \u2286 F. Two atomsets F and F\u2032 are said to be equivalent if F |= F\u2032 and F\u2032 |= F. If there is a homomorphism \u03c3 from an atomset F to itself (i.e., an endomorphism of F) then F and \u03c3(F) are equivalent. An atomset F is a core if there is no homomorphism from F to one of its strict subsets. Among all atomsets equivalent to an atomset F, there exists a unique core (up to isomorphism). We call this atomset the core of F.\nExistential Rules An existential rule (and simply a rule hereafter) is of the form B \u2192 H, where B and H are atomsets, respectively called the body and the head of the rule. To an existential rule R : B \u2192 H we assign a formula \u03a6(R) = \u2200~x\u2200~y(\u03c6(B) \u2192 \u2203~z\u03c6(H)), where vars(B) = ~x \u222a ~y, and vars(H) = ~x \u222a ~z. Variables ~x, which appear in both B and H, are called frontier variables, while variables ~z, which appear only in H are called existential variables. E.g., \u03a6(b(x, y) \u2192 h(x, z)) = \u2200x\u2200y(b(x, y) \u2192 \u2203zh(x, z)). The presence of existential variables in rule heads is the distinguishing feature of existential rules.\nA knowledge base is a pair K = (F,R) where F is an atomset (the set of facts) and R is a finite set of existential rules. We say that K = (F, {R1, . . . ,Rk}) entails an atomset Q (notation K |= Q) if \u03a6(F),\u03a6(R1), . . . ,\u03a6(Rk) |= \u03a6(Q). The fundamental problem we consider, denoted by entailment, is the following : given a knowledge base K and an atomset Q, is it true that K |= Q ? When \u03a6(Q) is seen as a Boolean conjunctive query, this problem is exactly the problem of determining if K yields a positive answer to this query.\nA rule R : B \u2192 H is applicable to an atomset F if there is a homomorphism \u03c0 from B to F. Then the application of R to F according to \u03c0 produces an atomset \u03b1(F,R, \u03c0) = F \u222a \u03c0(safe(H)), where safe(H) is obtained from H by replacing existential variables with fresh ones. An R-derivation from F is a (possibly infinite) sequence F0 = \u03c30(F), . . . , \u03c3k(Fk), . . . of atomsets such that \u22000 \u2264 i, \u03c3i is an endomorphism of Fi (that will be used to remove redundancy in Fi) and \u22000 < i, there is a rule (R : B \u2192 H) \u2208 R and a homomorphism \u03c0i from B to \u03c3i(Fi\u22121) such that Fi = \u03b1(\u03c3i(Fi\u22121),R, \u03c0i).\nExample 1 Consider the existential rule R =\nhuman(x) \u2192 hasParent(x, y), human(y) ; and the atomset F = {human(a)}. The application of R to F produces an atomset F\u2032 = F \u222a {hasParent(x, y0), human(y0)} where y0 is a fresh variable denoting an unknown individual. Note that R could be applied again to F\u2032 (mapping x to y0), which would create another existential variable and so on.\nA finite R-derivation F0, . . . , Fk from F is said to be from F to Fk. Given a knowledge base K = (F,R), K |= Q iff there exists a finite R-derivation from F to F\u2032 such that F\u2032 |= Q (Baget et al. 2011).\nLet Ri and R j be rules, and F be an atomset such that Ri is applicable to F by a homomorphism \u03c0 ; a homomorphism \u03c0\u2032 from B j to F\u2032 = \u03b1(F,Ri, \u03c0) is said to be new if \u03c0\u2032(B j) * F. Given a rule R = B \u2192 H, a homomorphism \u03c0 from B to F is said to be useful if it cannot be extended to a homomorphism from B\u222a H to F ; if \u03c0 is not useful then \u03b1(F,R, \u03c0) is equivalent to F, but this is not a necessary condition for \u03b1(F,R, \u03c0) to be equivalent to F."}, {"heading": "Chase Termination", "text": "An algorithm that computes an R-derivation by exploring all possible rule applications in a breadth-first manner is called a chase. In the following, we will also call chase the derivation it computes. Different kinds of chase can be defined by using different properties to compute F\u2032i = \u03c3i(Fi) in the derivation (hereafter we write F\u2032i for \u03c3i(Fi) when there is no ambiguity). All these algorithms are sound and complete w.r.t. the entailment problem in the sense that (F,R) |= Q iff they provide in finite (but unbounded) time a finite Rderivation from F to Fk such that Fk |= Q.\nDifferent kinds of chase In the oblivious chase (also called naive chase), e.g., (Cal\u0131\u0300, Gottlob, and Kifer 2008), a rule R is applied according to a homomorphism \u03c0 only if it has not already been applied according to the same homomorphism. Let Fi = \u03b1(F\u2032i\u22121,R, \u03c0), then F \u2032 i = F \u2032 i\u22121 if R was previously applied according to \u03c0, otherwise F\u2032i = Fi. This can be slightly improved. Two applications \u03c0 and \u03c0\u2032 of the same rule add the same atoms if they map frontier variables identically (for any frontier variable x of R, \u03c0(x) = \u03c0\u2032(x)) ; we say that they are frontier-equal. In the frontier chase, let Fi = \u03b1(F\u2032i\u22121,R, \u03c0), we take F \u2032 i = F \u2032 i\u22121 if R was previously applied according to some \u03c0\u2032 frontier-equal to \u03c0, otherwise F\u2032i = Fi. The skolem chase (Marnette 2009) relies on a skolemisation of the rules : a rule R is transformed into a rule skolem(R) by replacing each occurrence of an existential variable y with a functional term f Ry (~x), where ~x are the frontier variables of R. Then the oblivious chase is run on skolemized rules. It can easily be checked that frontier chase and skolem chase yield isomorphic results, in the sense that they generate exactly the same atomsets, up to a bijective renaming of variables by skolem terms.\nThe restricted chase (also called standard chase) (Fagin et al. 2005) detects a kind of local redundancy. Let Fi = \u03b1(F\u2032i\u22121,R, \u03c0), then F \u2032 i = Fi if \u03c0 is useful, otherwise F \u2032 i = F\u2032i\u22121. The core chase (Deutsch, Nash, and Remmel 2008) considers the strongest possible form of redundancy : for any Fi, F\u2032i is the core of Fi.\nA chase is said to be local if \u2200i \u2264 j, F\u2032i \u2286 F \u2032 j. All chase variants presented above are local, except for the core chase. This property will be critical for nonmonotonic existential rules.\nChase termination Since entailment is undecidable, the chase may not halt. We call C-chase a chase relying on some criterion C to generate \u03c3(Fi) = F\u2032i . So C can be oblivious, skolem, restricted, core or any other criterion that ensures the equivalence between Fi and F\u2032i . A C-chase generates a possibly infinite R-derivation \u03c30(F), \u03c31(F1), . . . , \u03c3k(Fk), . . .\nWe say that this derivation produces the (possibly infinite) atomset (F,R)C = \u222a0\u2264i\u2264\u221e\u03c3i(Fi)\\\u222a0\u2264i\u2264\u221e(\u03c3i(Fi)), where (\u03c3i(Fi)) = Fi \\ \u03c3(Fi). Note that this produced atomset is usually defined as the infinite union of the \u03c3i(Fi). Both definitions are equivalent when the criterion C is local. But the usual definition would produce too big an atomset with a non-local chase such as the core chase : an atom generated at step i and removed at step j would still be present in the infinite union. We say that a (possibly infinite) derivation obtained by the C-chase is complete when any further rule application on that derivation would produce the same atomset. A complete derivation obtained by any C-chase produces a universal model (i.e., most general) of (F,R) : for any atomset Q, we have F,R |= Q iff (F,R)C |= Q.\nWe say that the C-chase halts on (F,R) when the C-chase generates a finite complete R-derivation from F to Fk. Then (F,R)C = \u03c3k(Fk) is a finite universal model. We say that R is universally C-terminating when the C-chase halts on (F,R) for any atomset F. We call C-finite the class of universally C-terminating sets of rules. It is well known that the chase variants do not behave in the same way w.r.t. termination. The following examples highlight these different behaviors.\nExample 2 (Oblivious / Skolem chase) Let R = p(x, y) \u2192 p(x, z) and F = {p(a, b)}. The oblivious chase does not halt : it adds p(a, z0), p(a, z1), etc. The skolem chase considers the rule p(x, y) \u2192 p(x, f Rz (x)) ; it adds p(a, f R y (a)) then halts.\nExample 3 (Skolem / Restricted chase) Let R : p(x) \u2192 r(x, y), r(y, y), p(y) and F = {p(a)}. The skolem chase does not halt : at Step 1, it maps x to a and adds r(a, f Ry (a)), r( f Ry (a), f R y (a)) and p( f R y (a)) ; at step 2, it maps x to f R y (a) and adds r( f Ry (a), f R y ( f R y (a))), etc. The restricted chase performs a single rule application, which adds r(a, y0), r(y0, y0) and p(y0) ; indeed, the rule application that maps x to y0 yields only redundant atoms w.r.t. r(y0, y0) and p(y0).\nExample 4 (Restricted / Core chase) Let F = s(a), R1 = s(x) \u2192 p(x, x1), p(x, x2), r(x2, x2), R2 = p(x, y) \u2192 q(y) and R3 = q(x) \u2192 r(x, y), q(y). Note that R1 creates redundancy and R3 could be applied indefinitely if it were the only rule. R1 is the first applied rule, which creates new variables, called x1 and x2 for simplicity. The restricted chase does not halt : R3 is not applied on x2 because it is already satisfied at this point, but it is applied on x1, which creates an infinite chain. The core chase applies R1, computes the core of the result, which removes p(a, x1), then halts.\nIt is natural to consider the oblivious chase as the weakest form of chase and necessary to consider the core chase as\nthe strongest form of chase (since the core is the minimal representative of its equivalence class). We say that a criterion C is stronger than C\u2032 and write C \u2265 C\u2032 when C\u2032-finite \u2286 C-finite. We say that C is strictly stronger than C\u2032 (and write C > C\u2032) when C \u2265 C\u2032 and C\u2032 C.\nIt is well-known that core > restricted > skolem > oblivious. An immediate remark is that core-finite corresponds to finite expansion sets (fes) defined in (Baget and Mugnier 2002). To sum up, the following inclusions hold between C-finite classes : oblivious-finite \u2282 skolem-finite= frontier-finite\u2282 restricted-finite\u2282 core-finite = fes."}, {"heading": "Known Acyclicity Notions", "text": "We can only give a brief overview of known acylicity notions, which should however allow to place our contribution within the existing landscape. A comprehensive taxonomy can be found in (Cuenca Grau et al. 2013).\nAcyclicity notions ensuring that some chase variant terminates can be divided into two main families, each of them relying on a different graph : a \u201cposition-based\u201d approach which basically relies on a graph encoding variable sharing between positions in predicates and a \u201crule dependency approach\u201d which relies on a graph encoding dependencies between rules, i.e., the fact that a rule may lead to trigger another rule (or itself).\nPosition-based approach In the position-based approach, cycles identified as dangerous are those passing through positions that may contain existential variables ; intuitively, such a cycle means that the creation of an existential variable in a given position may lead to create another existential variable in the same position, hence an infinite number of existential variables. Acyclicity is then defined by the absence of dangerous cycles. The simplest notion of acyclicity in this family is that of weak acyclicity (wa) (Fagin et al. 2003) (Fagin et al. 2005), which has been widely used in databases. It relies on a directed graph whose nodes are the positions in predicates (we denote by (p, i) the position i in predicate p). Then, for each rule R : B \u2192 H and each variable x in B occurring in position (p, i), edges with origin (p, i) are built as follows : if x is a frontier variable, there is an edge from (p, i) to each position of x in H ; furthermore, for each existential variable y in H occurring in position (q, j), there is a special edge from (p, i) to (q, j). A set of rules is weakly acyclic if its associated graph has no cycle passing through a special edge.\nExample 5 (Weak-acyclicity) Let R1 = h(x) \u2192 p(x, y), where y is an existential variable, and R2 = p(u, v), q(v) \u2192 h(v). The position graph of {R1,R2} contains a special edge from (h, 1) to (p, 2) due to R1 and an edge from (p, 2) to (h, 1) due to R2, thus {R1,R2} is not wa.\nWeak-acyclicity has been generalized, mainly by shifting the focus from positions to existential variables (jointacyclicity (ja)(Kro\u0308tzsch and Rudolph 2011)) or to positions in atoms instead of predicates (super-weak-acyclicity (swa) (Marnette 2009)). Other related notions can be imported from logic programming, e.g., finite domain\n(fd) (Calimeri et al. 2008) and argument-restricted (ar) (Lierler and Lifschitz 2009). See the first column in Figure 1, which shows the inclusions between the corresponding classes of rules (all these inclusions are known to be strict).\nRule Dependency In the second approach, the aim is to avoid cyclic triggering of rules (Baget 2004; Baget et al. 2009; Deutsch, Nash, and Remmel 2008; Cuenca Grau et al. 2012). We say that a rule R2 depends on a rule R1 if there exists an atomset F such that R1 is applicable to F according to a homomorphism \u03c0 and R2 is applicable to F\u2032 = \u03b1(F,R1, \u03c0) according to a new useful homomorphism. This abstract dependency relation can be effectively computed with a unification operation known as piece-unifier (Baget et al. 2009). Piece-unification takes existential variables into account, hence is more complex than the usual unification between atoms. A piece-unifier of a rule body B2 with a rule head H1 is a substitution \u00b5 of vars(B\u20322) \u222a vars(H \u2032 1), where B \u2032 2 \u2286 B2 and H \u2032 1 \u2286 H1, such that (1) \u00b5(B\u20322) = \u00b5(H \u2032 1) and (2) existential variables in H\u20321 are not unified with separating variables of B \u2032 2, i.e., variables that occur both in B\u20322 and in (B2 \\ B \u2032 2) ; in other words, if a variable x occuring in B\u20322 is unified with an existential variable y in H\u20321, then all atoms in which x occurs also belong to B\u20322. It holds that R2 depends on R1 iff there is a piece-unifier of B2 with H1 satisfying easy to check additional conditions (atom erasing (Baget et al. 2011) and usefulness (Cuenca Grau et al. 2013)).\nExample 6 (Rule dependency) Consider the rules from Example 5. There is no piece-unifier of B2 with H1. The substitution \u00b5 = {(u, x), (v, y)}, with B\u20322 = p(u, v) and H \u2032 1 = H1, is not a piece-unifier because v is unified with an existential variable, whereas it is a separating variable of B\u20322 (thus, q(v) should be included in B\u20322, which is impossible). Thus R2 does not depend on R1.\nThe graph of rule dependencies of a set of rules R, denoted by GRD(R), encodes the dependencies between rules in R. It is a directed graph with set of nodes R and an edge (Ri,R j) if R j depends on Ri (intuition : \u201cRi may lead to trigger R j in a new way\u201d). E.g., considering the rules in Example 6, the only edge is (R2,R1).\nWhen the GRD is acyclic (aGRD, (Baget 2004)), any derivation sequence is necessarily finite. This notion is incomparable with those based on positions.\nWe point out here that the oblivious chase may not stop on wa rules. Thus, the only acyclicity notion in Figure 1 that ensures the termination of the oblivious chase is aGRD since all other notions generalize wa.\nCombining both approches Both approaches have their weaknesses : there may be a dangerous cycle on positions but no cycle w.r.t. rule dependencies (see the preceeding examples), and there may be a cycle w.r.t. rule dependencies whereas rules contain no existential variables (e.g. p(x, y) \u2192 p(y, x), q(x)). Attempts to combine both notions only succeded to combine them in a \u201cmodular way\u201d : if the rules in each strongly connected component (s.c.c.) of the GRD belong to a fes class, then the set of rules is fes (Baget 2004; Deutsch, Nash, and Remmel 2008). More specifically, it is\neasy to check that if for a given C-chase, each s.c.c. is Cfinite, then the C-chase stops.\nIn this paper, we propose an \u201cintegrated\u201d way of combining both approaches, which relies on a single graph. This allows to unify preceding results and to generalize them without complexity increasing (the new acyclicity notions are those with a gray background in Figure 1).\nFinally, let us mention model-faithful acyclicity (mfa) (Cuenca Grau et al. 2012), which generalizes the previous acyclicity notions and cannot be captured by our approach. Briefly, mfa involves running the skolem chase until termination or a cyclic functional term is found. The price to pay for the generality of this property is high complexity : checking if a set of rules is universally mfa (i.e., for any set of facts) is 2EXPTIME-complete. Checking modelsummarizing acyclicity (msa), which approximates mfa, remains EXPTIME-complete. In contrast, checking positionbased properties is in PTIME and checking agrd is also coNP-complete. Sets of rules satisfying mfa are skolem-finite (Cuenca Grau et al. 2012), thus all properties studied in this paper ensure C-finiteness, when C \u2265 skolem."}, {"heading": "Extending Acyclicity Notions", "text": "In this section, we combine rule dependency and propagation of existential variables into a single graph. W.l.o.g. we assume that distinct rules do not share any variable. Gi-\nven an atom a = p(t1, . . . , tk), the ith position in a is denoted by <a, i>, with pred(<a, i>) = p and term(<a, i>) = ti. If A is an atomset such that a \u2208 A, we say that <a, i> is in A. If term(<a, i>) is an existential (resp. frontier) variable, <a, i> is called an existential (resp. frontier) position. In the following, we use \u201cposition graph\u201d as a generic name to denote a graph whose nodes are positions in atoms.\nWe first define the notion of a basic position graph, which takes each rule in isolation. Then, by adding edges to this graph, we define three position graphs with increasing expressivity, i.e., allowing to check termination for increasingly larger classes of rules.\nDefinition 1 ((Basic) Position Graph (PG)) The position graph of a rule R : B \u2192 H is the directed graph PG(R) defined as follows :\n\u2013 there is a node for each <a, i> in B or in H ; \u2013 for all frontier positions <b, i>\u2208 B and all <h, j>\u2208 H,\nthere is an edge from <b, i> to <h, j> if term(<b, i>) = term(<h, j>) or if <h, j> is existential.\nGiven a set of rules R, the basic position graph of R, denoted by PG(R), is the disjoint union of PG(Ri), for all Ri \u2208 R.\nAn existential position <a, i> is said to be infinite if there is an atomset F such that running the chase on F produces an unbounded number of instantiations of term(<a, i>). To detect infinite positions, we encode how variables may be \u201cpropagated\u201d among rules by adding edges to PG(R), called transition edges, which go from positions in rule heads to positions in rule bodies. The set of transition edges has to be correct : if an existential position <a, i> is infinite, there must be a cycle going through <a, i> in the graph.\nWe now define three position graphs by adding transition edges to PG(R), namely PGF (R), PGD(R) and PGU(R). All three graphs have correct sets of edges. Intuitively, PGF(R) corresponds to the case where all rules are supposed to depend on all rules ; its set of cycles is in bijection with the set of cycles in the predicate position graph defining weakacyclicity. PGD(R) encodes actual paths of rule dependencies. Finally, PGU(R) adds information about the pieceunifiers themselves. This provides an accurate encoding of variable propagation from an atom position to another.\nDefinition 2 (PGX) Let R be a set of rules. The three following position graphs are obtained from PG(R) by adding a (transition) edge from each kth position <h, k> in a rule head Hi to each kth position <b, k> in a rule body B j, with the same predicate, provided that some condition is satisfied :\n\u2013 full PG, denoted by PGF(R) : no additional condition ; \u2013 dependency PG, denoted by PGD(R) : if R j depends\ndirectly or indirectly on Ri, i.e., if there is a path from Ri to R j in GRD(R) ; \u2013 PG with unifiers, denoted by PGU(R) : if there is a piece-unifier \u00b5 of B j with the head of an agglomerated rule R ji such that \u00b5(term([b, k])) = \u00b5(term([h, k])), where R ji is formally defined below (Definition 3)\nAn agglomerated rule associated with (Ri,R j) gathers information about selected piece-unifiers along (some) paths from Ri to (some) predecessors of R j.\nDefinition 3 (Agglomerated Rule) Given Ri and R j rules from R, an agglomerated rule associated with (Ri,R j) has the following form :\nR ji = Bi \u222at\u2208T\u2286terms(Hi) fr(t) \u2192 Hi\nwhere fr is a new unary predicate that does not appear in R, and the atoms fr(t) are built as follows. Let P be a non-empty set of paths from Ri to direct predecessors of R j in GRD(R). Let P = (R1, . . . ,Rn) be a path in P. One can associate a rule RP with P by building a sequence R1 = R p 1 , . . . ,R p n = RP such that \u22001 \u2264 l < n, there is a pieceunifier \u00b5l of Bl+1 with the head of R p l , where the body of R p l+1 is Bpl \u222a{fr(t) | t is a term of H p l unified in \u00b5l}, and the head of Rpl+1 is H1. Note that for all l, H p l = H1, however, for l , 1, Rpl may have less existential variables than Rl due to the added atoms. The agglomerated rule R ji built from {R P|P \u2208 P} is R ji = \u22c3 P\u2208P R P.\nProposition 1 (Inclusions between PGX) Let R be a set of rules. PGU(R) \u2286 PGD(R) \u2286 PGF(R). Furthermore, PGD(R) = PGF(R) if the transitive closure of GRD(R) is a complete graph.\nExample 7 (PGF and PGD) Let R = {R1,R2} from Example 5. Figure 2 pictures PGF (R) and PGD(R). The dashed edges belong to PGF(R) but not to PGD(R). Indeed, R2 does not depend on R1. PGF (R) has a cycle while PGD(R) has not.\nExample 8 (PGD and PGU) Let R = {R1,R2}, with R1 = t(x, y) \u2192 p(z, y), q(y) and R2 = p(u, v), q(u) \u2192 t(v,w). In Figure 3, the dashed edges belong to PGD(R) but not to PGU(R). Indeed, the only piece-unifier of B2 with H1 unifies u and y. Hence, the cycle in PGD(R) disappears in PGU(R).\nWe now study how acyclicity properties can be expressed on position graphs. The idea is to associate, with an acyclicity property, a function that assigns to each position a subset of positions reachable from this position, according to some propagation constraints ; then, the property is fulfilled if no existential position can be reached from itself. More precisely, a marking function Y assigns to each node <a, i> in a position graph PGX , a subset of its (direct or indirect) successors, called its marking. A marked cycle for <a, i> (w.r.t.\nX and Y) is a cycle C in PGX such that <a, i>\u2208 C and for all <a\u2032, i\u2032>\u2208 C, <a\u2032, i\u2032> belongs to the marking of <a, i>. Obviously, the less situations there are in which the marking may \u201cpropagate\u201d in a position graph, the stronger the acyclicity property is.\nDefinition 4 (Acyclicity property) Let Y be a marking function and PGX be a position graph. The acyclicity property associated with Y in PGX , denoted by YX , is satisfied if there is no marked cycle for an existential position in PGX . If YX is satisfied, we also say that PGX(R) satisfies Y.\nFor instance, the marking function associated with weakacyclicity assigns to each node the set of its successors in PGF(R), without any additional constraint. The next proposition states that such marking functions can be defined for each class of rules between wa and swa (first column in Figure 1), in such a way that the associated acyclicity property in PGF characterizes this class.\nProposition 2 A set of rules R is wa (resp. f d, ar, ja, swa) iff PGF(R) satisfies the acyclicity property associated with wa- (resp. f d-, ar-, ja-, swa-) marking.\nAs already mentioned, all these classes can be safely extended by combining them with the GRD. To formalize this, we recall the notion Y< from (Cuenca Grau et al. 2013) : given an acyclicity property Y, a set of rules R is said to satisfy Y< if each s.c.c. of GRD(R) satisfies Y, except for those composed of a single rule with no loop. 1 Whether R satisfies Y< can be checked on PGD(R) :\nProposition 3 Let R be a set of rules, and Y be an acyclicity property. R satisfies Y< iff PGD(R) satisfies Y, i.e., Y< = YD.\nFor the sake of brevity, if Y1 and Y2 are two acyclicity properties, we write Y1 \u2286 Y2 if any set of rules satisfying Y1 also satisfies Y2. The following results are straightforward.\nProposition 4 Let Y1, Y2 be two acyclicity properties. If Y1 \u2286 Y2, then YD1 \u2286 Y D 2 .\nProposition 5 Let Y be an acyclicity property. If a-grd * Y then Y \u2282 YD.\nHence, any class of rules satisfying a property YD strictly includes both a-grd and the class characterized by Y ; (e.g.,\n1. This particular case is to cover aGRD, in which each s.c.c. is an isolated node.\nFigure 1, from Column 1 to Column 2). More generally, strict inclusion in the first column leads to strict inclusion in the second one :\nProposition 6 Let Y1, Y2 be two acyclicity properties such that Y1 \u2282 Y2, wa \u2286 Y1 and Y2 * YD1 . Then Y D 1 \u2282 Y D 2 .\nThe next theorem states that PGU is strictly more powerful than PGD ; moreover, the \u201cjump\u201d from YD to YU is at least as large as from Y to YD.\nTheorem 1 Let Y be an acyclicity property. If Y \u2282 YD then YD \u2282 YU . Furthermore, there is an injective mapping from the sets of rules satisfying YD but not Y, to the sets of rules satisfying YU but not YD.\nProof: Assume Y \u2282 YD and R satisfies YD but not Y. R can be rewritten into R\u2032 by applying the following steps. First, for each rule Ri = Bi[~X, ~Y] \u2192 Hi[~Y, ~Z] \u2208 R, let Ri,1 = Bi[~X, ~Y] \u2192 pi(~X, ~Y) where pi is a fresh predicate ; and Ri,2 = pi(~X, ~Y) \u2192 Hi[~Y, ~Z]. Then, for each rule Ri,1, let R\u2032i,1 be the rule (B\u2032i,1 \u2192 Hi,1) with B \u2032 i,1 = Bi,1 \u222a {p \u2032 j,i(x j,i) : \u2200R j \u2208 R}, where p\u2032j,i are fresh predicates and x j,i fresh variables. Now, for each rule Ri,2, let R\u2032i,2 be the rule (Bi,2 \u2192 H \u2032 i,2) with H \u2032 i,2 = Hi,2 \u222a {p\u2032i, j(zi, j) : \u2200R j \u2208 R}, where zi, j are fresh existential variables. Let R\u2032 = \u22c3\nRi\u2208R {R\u2032i,1,R \u2032 i,2}. This construction ensures\nthat each R\u2032i,2 depends on R \u2032 i,1, and each R \u2032 i,1 depends on each R\u2032j,2, thus, there is a transition edge from each R \u2032 i,1 to R \u2032 i,2 and from each R\u2032j,2 to each R \u2032 i,1. Hence, PG D(R\u2032) contains exactly one cycle for each cycle in PGF (R). Furthermore, PGD(R\u2032) contains at least one marked cycle w.r.t. Y, and then R\u2032 does not satisfy YD. Now, each cycle in PGU(R\u2032) is also a cycle in PGD(R), and, since PGD(R) satisfies Y, PGU(R\u2032) also does. Hence, R\u2032 does not belong to YD but to YU .\nWe also check that strict inclusions in the second column in Figure 1 lead to strict inclusions in the third column.\nTheorem 2 Let Y1 and Y2 be two acyclicity properties. If YD1 \u2282 Y D 2 then Y U 1 \u2282 Y U 2 .\nProof: Let R be a set of rules such that R satisfies YD2 but does not satisfy YD1 . We rewrite R into R\n\u2032 by applying the following steps. For each pair of rules Ri,R j \u2208 R such that there is a dependency path from Ri to R j,for each variable x in the frontier of R j and each variable y in the head of Ri, if x and y occur both in a given predicate position, we add to the body of R j a new atom pi, j,x,y(x) and to the head of Ri a new atom pi, j,x,y(y), where pi, j,x,y denotes a fresh predicate. This construction allows each term from the head of Ri to propagate to each term from the body of R j, if they share some predicate position in R. Thus, any cycle in PGD(R) is also in PGU(R\u2032), without any change in the behavior w.r.t. the acyclicity properties. Hence R\u2032 satisfies YU2 but does not satisfy YU1 .\nThe next result states that YU is a sufficient condition for chase termination :\nTheorem 3 Let Y be an acyclicity property ensuring the halting of some chase variant C. Then, the C-chase halts for any set of rules R that satisfies YU (hence YD).\nExample 9 Consider again the set of rules R from Example 8. Figure 3 pictures the associated position graphs PGD(R) and PGU(R). R is not aGRD, nor wa, nor waD since PGD(R) contains a (marked) cycle that goes through the existential position <t(v,w), 2>. However, R is obviously waU since PGU(R) is acyclic. Hence, the skolem chase and stronger chase variants halt for R and any set of facts.\nFinally, we remind that classes from wa to swa can be recognized in PTIME, and checking a-grd is coNP-complete. Hence, as stated by the next result, the expressiveness gain is without increasing worst-case complexity.\nTheorem 4 (Complexity) Let Y be an acyclicity property, and R be a set of rules. If checking that R satisfies Y is in coNP, then checking that R satisfies YD or YU is coNPcomplete."}, {"heading": "Further Refinements", "text": "Still without complexity increasing, we can further ex-\ntend YU into YU +\nby a finer analysis of marked cycles and unifiers. We define the notion of incompatible sequence of unifiers, which ensures that a given sequence of rule applications is impossible. Briefly, a marked cycle for which all sequences of unifiers are incompatible can be ignored. Beside the gain for positive rules, this refinement will allow one to take better advantage of negation.\nWe first point out that the notion of piece-unifier is not appropriate to our purpose. We have to relax it, as illustrated by the next example. We call unifier, of a rule body B2 with a rule head H1, a substitution \u00b5 of vars(B\u20322) \u222a vars(H \u2032 1), where B\u20322 \u2286 B2 and H \u2032 1 \u2286 H1, such that \u00b5(B \u2032 2) = \u00b5(H \u2032 1) (thus, it satisfies Condition (1) of a piece-unifier).\nExample 10 Let R = {R1,R2,R3,R4} with : R1 : p(x1, y1) \u2192 q(y1, z1) R2 : q(x2, y2) \u2192 r(x2, y2) R3 : r(x3, y3) \u2227 s(x3, y3) \u2192 p(x3, y3) R4 : q(x4, y4) \u2192 s(x4, y4) There is a dependency cycle (R1,R2,R3,R1) and a corresponding cycle in PGU . We want to know if such a sequence of rule applications is possible. We build the following new rule, which is a composition of R1 and R2 (formally defined later) : R1 \u22c4\u00b5 R2 : p(x1, y1) \u2192 q(y1, z1) \u2227 r(y1, z1) There is no piece-unifier of R3 with R1 \u22c4\u00b5 R2, since y3 would be a separating variable mapped to the existential variable z1. This actually means that R3 is not applicable right after R1 \u22c4\u00b5 R2. However, the atom needed to apply s(x3, y3) can be brought by a sequence of rule applications (R1,R4). We thus relax the notion of piece-unifier to take into account arbitrary long sequences of rule applications.\nDefinition 5 (Compatible unifier) Let R1 and R2 be rules. A unifier \u00b5 of B2 with H1 is compatible if, for each position <a, i> in B\u20322, such that \u00b5(term(<a, i>)) is an existential variable z in H\u20321, PG\nU(R) contains a path, from a position in which z occurs, to <a, i>, that does not go through another existential position. Otherwise, \u00b5 is incompatible.\nNote that a piece-unifier is necessarily compatible.\nProposition 7 Let R1 and R2 be rules, and let \u00b5 be a unifier of B2 with H1. If \u00b5 is incompatible, then no application of R2 can use an atom in \u00b5(H1).\nWe define the rule corresponding to the composition of R1 and R2 according to a compatible unifier, then use this notion to define a compatible sequence of unifiers.\nDefinition 6 (Unified rule, Compatible sequence of unifiers)\n\u2022 Let R1 and R2 be rules such that there is a compatible unifier \u00b5 of B2 with H1. The associated unified rule R\u00b5 = R1 \u22c4\u00b5 R2 is defined by H\u00b5 = \u00b5(H1) \u222a \u00b5(H2), and B\u00b5 = \u00b5(B1) \u222a (\u00b5(B2) \\ \u00b5(H1)). \u2022 Let (R1, . . . ,Rk+1) be a sequence of rules. A sequence s = (R1 \u00b51 R2 . . . \u00b5k Rk+1), where, for 1 \u2264 i \u2264 k, \u00b5i is a unifier of Bi+1 with Hi, is a compatible sequence of unifiers if : (1) \u00b51 is a compatible unifier of B2 with H1, and (2) if k > 0, the sequence obtained from s by replacing (R1 \u00b51 R2) with R1 \u22c4\u00b51 R2 is a compatible sequence of unifiers.\nE.g., in Example 10, the sequence (R1 \u00b51 R2 \u00b52 R3 \u00b53 R1), with the obvious \u00b5i, is compatible. We can now improve all previous acyclicity properties (see the fourth column in Figure 1).\nDefinition 7 (Compatible cycles) Let Y be an acyclicity property, and PGU be a position graph with unifiers. The compatible cycles for <a, i> in PGU are all marked cycles C for <a, i> wrt Y, such that there is a compatible sequence of unifiers induced by C. Property YU+ is satisfied if, for each existential position <a, i>, there is no compatible cycle for <a, i> in PGU .\nResults similar to Theorem 1 and Theorem 2 are obtained for YU +\nw.r.t. YU , namely : \u2013 For any acyclicity property Y, YU \u2282 YU+. \u2013 For any acyclicity properties Y1 and Y2, if YU1 \u2282 Y U 2 ,\nthen YU+1 \u2282 Y U+ 2 .\nMoreover, Theorem 3 can be extended to YU +\n: let Y be an acyclicity property ensuring the halting of some chase variant C ; then the C-chase halts for any set of rules R that satisfies YU +\n(hence YU). Finally, the complexity result from Theorem 4 still holds for this improvement."}, {"heading": "Handling Nonmonotonic Negation", "text": "We now add nonmonotonic negation, which we denote by not. A nonmonotonic existential rule (NME rule) R is of the form (B+, notB\u22121 , . . . , notB \u2212 k \u2192 H), where B\n+, B\u2212i and H are atomsets, respectively called the positive body, the negative bodies and the head of R. Note that we generalize the usual notion of negative body by allowing to negate conjunctions of atoms. Moreover, the rule head may contain several atoms. However, we impose a safeness condition : \u22001 \u2264 i \u2264 k, vars(B\u2212i ) \u2286 vars(B\n+). The formula assigned to R is \u03a6not(R) = \u2200~x\u2200~y(\u03c6(B+) \u2227 not\u03c6(B\u22121 ), . . . , not\u03c6(B \u2212 k ) \u2192 \u2203~z\u03c6(H). We write pos(R) the existential rule obtained from R by removing its negative bodies, and pos(R) the set of all pos(R) rules, for R \u2208 R.\nAbout our Stable Model Semantics Answer Set Programming (Gelfond 2007) introduced stable model semantics for propositional logic, and was naturally extended to grounded programs (i.e., sets of NME rules without variables). In this framework, the semantics can be provided through the Gelfond-Lifschitz reduct operator that allows to compute a saturation (i.e., a chase) using only grounded NME rules. This semantics can be easily extended to rules with no existential variable in the head, or to skolemized NME rules, as done, for instance, in (Magka, Kro\u0308tzsch, and Horrocks 2013). The choice of the chase/saturation mechanism is here irrelevant, since no such mechanism can produce any redundancy.\nThe problem comes when considering existential variables in the head of rules. Several semantics have been proposed in that case, for instance circumscription in (Ferraris, Lee, and Lifschitz 2011), or justified stable models in (You, Zhang, and Zhang 2013). We have chosen not to adopt circumscription since it translates NME rules to second-order expressions, and thus would not have allowed to build upon results obtained in the existential rule formalism. In the same way, we have not considered justified stable models, whose semantics does not correspond to stable models on grounded rules, as shown by the following example :\nExample 11 Let \u03a01 = {\u2205 \u2192 p(a); p(a), notq(a) \u2192 t(a).} be a set of ground NME rules. Then {p(a); q(a)} is a justified stable model, but not a stable model. Let \u03a02 = {\u2205 \u2192 p(a); p(a), notq(b) \u2192 t(a)} . Then {p(a); t(a)} is a stable model but not a justified stable model.\nLet us now recast the Gelfond-Lifschitz reduct-based semantics in terms of the skolem-chase. Essentially (we will be more precise in the next section), a stable model M is a possibly infinite atomset produced by a skolem-chase that respects some particular conditions :\n\u2013 all rule applications are sound, i.e., none of its negative bodies can be found in the stable model produced (the rule is not blocked) ; \u2013 the derivation is complete, i.e., any rule applicable and not blocked is applied in the derivation.\nIn the next subsection, we formally define the notion of a stable model, while replacing the skolem-chase with any Cchase. We thus obtain a family of semantics parameterized by the considered chase, and define different notions of Cstable models.\nOn the Chase and Stable Models We define a notion of stable model directly on nonmonotonic existential rules and provide a derivation algorithm inspired from the notion of computation in (Liu et al. 2010) and Answer Set Programming solvers that instantiate rules on the fly (Lefe\u0300vre and Nicolas 2009; Dao-Tran et al. 2012) instead of grounding rules before applying them. The difference with our framework is that they consider normal logic programs, which are a generalization of skolemized NME rules.\nA natural question is then to understand if the choice of a chase mechanism has an impact, not only on the termination, but also on the semantics. Thus, we consider the chase as a parameter. Intuitively, a C-stable set A is produced by a\nC-chase that, according to (Gelfond 2007), must satisfy the NME rules (we say that it is sound, i.e., that no negative body appearing in the chase is in A) and the rationality principle (the sound chase does not generate anything that cannot be believed, and it must be complete : any rule application not present in the chase would be unsound).\nTo define C-stable sets, we first need to introduce additional notions. A NME R-derivation from F is a pos(R)-derivation from R. This derivation D = (F0 = \u03c30(F), . . . , \u03c3k(Fk), . . .) produces a possibly infinite atomset A. Let R be a NME rule such that pos(R) was applied at some step i in D, i.e., Fi+1 = \u03b1(\u03c3i(Fi), pos(R), \u03c0i). We say that this application is blocked if one of the \u03c0i(B\u2212q ) (for any negative body B\u2212q in R) can be found in A. This can happen in two ways. Either \u03c0i(B\u2212q ) can already be found in \u03c3i(Fi) or it appears later in the derivation. In both cases, there is a \u03c3 j(F j) (with j \u2265 i) that contains the atomset \u03c0i(B\u2212q ), as transformed by the sequence of simplifications from Fi to F j, i.e., there exists F j with j \u2265 i s.t. the atomset \u03c3i\u2192 j(\u03c0i(B\u2212q )) = \u03c3 j(. . . (\u03c3i+1(\u03c0i(B \u2212 q ))) . . .) is included in \u03c3 j(F j). We say that a derivation D is sound when no rule application is blocked in A. A sound derivation is said to be complete when adding any other rule application to the derivation would either make it unsound, or would not change the produced atomset. The derivation is a C-chase when the \u03c3i used at each step is determined by the criterion C.\nDefinition 8 (C-stable sets) Let F be a finite atomset, and R be a set of NME rules. We say that a (possibly infinite) atomset A is C-stable for (F,R) if there is a complete sound nonmonotonic C-chase from F that produces A.\nProposition 8 If R is a set of existential rules, then there is a unique C-stable set, which is equivalent to the universal model (F,R)C . If {F} \u222a R is a set of skolemized NME rules (with F being seen as a rule with empty body), then its skolem-stable sets are in bijection with its stable models.\nSketch of proof : First part of the claim stems from the fact that existential rules generate a unique branch that corresponds to a derivation. When that branch is complete, it corresponds to a chase. Second part of the claim comes from the fact that our definitions mimic the behavior of the sound and complete algorithm implemented in (Lefe\u0300vre and Nicolas 2009).\nC-chase Tree The problem with the fixpoint Definition 8 is that it does not provide an effective algorithm : at each step of the derivation, we need to know the set produced by that derivation. The algorithm used in the solver ASPe\u0301RIX (Lefe\u0300vre and Nicolas 2009) is here generalized to a procedure that generates the (possibly infinite) C-derivation tree of (F,R). All nodes of that tree are labeled by three fields. The field in contains the atomset that was inferred in the current branch. The field out contains the set of forbidden atomsets, i.e., that must not be inferred. Finally, the field mbt (\u201cmust be true\u201d) contains the atomset that has yet to be proven. A node is called unsound when a forbidden atomset has been inferred, or has to be proven, i.e., when out \u2229 (in \u222a mbt) , \u2205. At the initial step, the root of the C-derivation tree is a positive node labeled (\u03c30(F), \u2205, \u2205).\nThen, let us chose a node N that is not unsound and has no child. Assume there is a rule R = B+, notB\u22121 , . . . , notB \u2212 k \u2192 H in R such that there is a homomorphism \u03c0 from B+ to in(N). Then we will (possibly) add k + 1 children under N, namely N+, N\u22121 , . . . , N \u2212 k . These children are added if the rule application is not blocked, and produces new atoms. Intuitively, the positive child N+ encodes the effective application of the rule, while the k negative children N\u2212i encode the k different possibilities of blocking the rule (with each of the negative bodies). Let us consider the sequence of positive nodes from the root of the tree to N+. It encodes a pos(R)-derivation from F. On that derivation, the C-chase generates a sequence \u03c30(F), . . . , \u03c3p(Fp), S = \u03c3(\u03b1(\u03c3p(Fp), pos(R), \u03c0)). S produces something new when S * \u03c3p(Fp). We now have to fill the fields of the obtained children : let (in, out, mbt) be the label of a node N. Then label(N+) = (S , out \u222a {\u03c0i(B\u22121 ), . . . , \u03c0i(B \u2212 k )},mbt) and label(N\u2212i ) = (in, out,mbt \u222a \u03c0i(B \u2212 i )).\nWe say that a (possibly infinite) branch in the C-derivation tree is unsound when it contains an unsound node. A sound branch is said to be complete when its associated derivation is complete. Finally, a sound and complete branch is stable when for every node N in the branch such that B\u2212 \u2208 mbt(N), there exists a descendant N\u2032 of N such that B\u2212 \u2208 in(N\u2032). We say that a branch is unprovable if there exists a node N in the branch and an atomset B\u2212 \u2208 mbt(N) such that no complete branch containing N is stable. We call a C-chase tree any C-derivation tree for which all branches are either unsound, unprovable or complete.\nProposition 9 An atomset A is a C-stable set for (F,R) iff a C-chase tree of (F,R) contains a stable branch whose associated derivation produces A.\nOn the applicability of the chase variants In the positive case, all chase variants produce equivalent universal models (up to skolemization). Moreover, running a chase on equivalent knowledge bases produce equivalent results. Do these semantic properties still hold with nonmonotonic existential rules ? The answer is no in general.\nThe next example shows that the chase variants presented in this paper, core chase excepted, may produce nonequivalent results from equivalent knowledge bases.\nExample 12 Let F = {p(a, y), t(y)} and F\u2032 = {p(a, y\u2032), p(a, y), t(y)} be two equivalent atomsets. Let R : p(u, v), not t(v) \u2192 r(u). For any C-chase other than core chase, there is a single C-stable set for (F, {R}) which is F (or sk(F)) and a single C-stable set for (F\u2032, {R}) which is F\u2032\u222a{r(a)} (or sk(F\u2032)\u222a{r(a)}). These sets are not equivalent.\nOf course, if we consider that the initial knowledge base is already skolemized (including F seen as a rule), this trouble does not occur with the skolem-chase since there are no redundancies in facts and no redundancy can be created by a rule application. This problem does not arise with core chase either. Thus the only two candidates for processing NME rules are the core chase and the skolem chase (if we assume a priori skolemisation, which is already a semantic shift).\nThe choice between both mechanisms is important since, as shown by the next example, they may produce different\nresults even when they both produce a unique C-stable set. It follows that skolemizing existential rules is not an innocuous transformation in presence of nonmontonic negation.\nExample 13 We consider F = i(a), R1 = i(x) \u2192 p(x, y), R2 = i(x) \u2192 q(x, y), R3 = q(x, y) \u2192 p(x, y), t(y) and R4 = p(u, v), not t(v) \u2192 r(u). The core chase produces at first step p(a, y0) and q(a, y1), then p(a, y1) and t(y1) and removes the redundant atom p(a, y0), hence R4 is not applicable. The unique core-stable set is {i(a), q(a, y1), p(a, y1), t(y1)}. With the skolem chase, the produced atoms are p(a, f R1(a)) and q(a, f R2(a)), then p(a, f R2(a)) and t( f R2 (a)). R4 is applied with p(u, v) mapped to p(a, f R1(a)), which produces r(a). These atoms yield a unique skolem-stable set. These stable sets are not equivalent."}, {"heading": "Termination of the Chase Tree", "text": "On the finiteness of C-chase trees We say that the Cchase-tree halts on (F,R) when there exists a finite C-chase tree of (F,R) (in that case, a breadth-first strategy for the rule applications will generate it). We can thus define C-stablefinite as the class of sets of nonmonotonic existential rules R for which the C-chase-tree halts on any (F,R). Our first intuition was to assert \u201cif pos(R) \u2208 C-finite, then R \u2208 Cstable-finite\u201d. However, this property is not true in general, as shown by the following example :\nExample 14 Let R = {R1,R2} where R1 = h(x) \u2192 p(x, y), h(y) and R2 = p(x, y), not h(x) \u2192 p(x, x). See that pos(R) \u2208 core-finite (as soon as R1 is applied, R2 is also applied and the loop p(x, x) makes any other rule application redundant) ; however the only core-stable set of ({h(a)},R) is infinite (because all applications of R2 are blocked).\nThe following property shows that the desired property is true for local chases.\nProposition 10 Let R be a set of NME rules and C be a local chase. If pos(R) \u2208 C-finite, then R \u2208 C-stable-finite.\nWe have previously argued that the only two interesting chase variants w.r.t. the desired semantic properties are skolem and core. However, the core-finiteness of the positive part of a set of NME rules does not ensure the corestable-finiteness of these rules. We should point out now that if C \u2265 C\u2032, then C\u2032-stable-finiteness implies C-stablefiniteness. We can thus ensure core-stable-finiteness when C-finiteness of the positive part of rules is ensured for a local C-chase.\nProposition 11 Let R be a set of NME rules and C be a local chase. If pos(R) \u2208 C-finite, then R \u2208 core-stable-finite.\nWe can rely upon all acyclicity results in this paper to ensure that the core-chase tree halts.\nImproving finiteness results with negative bodies We now explain how negation can be exploited to enhance preceding acyclicity notions. We first define the notion of self-blocking rule, which is a rule that will never be applied in any derivation. A rule B+, not B\u22121 , . . . , not B \u2212 k is selfblocking if there is a negative body B\u2212i such that B \u2212 i \u2286 (B+ \u222a H). Such a rule will never be applied in a sound way, so will never produce any atom. It follows that :\nProposition 12 Let R\u2032 be the non-self-blocking rules of R. If pos(R\u2032) \u2208 C-finite and C is local, then R \u2208 C-stable-finite.\nThis idea can be further extended. We have seen for existential rules that if R\u2032 depends on R, then there is a unifier \u00b5 of body(R\u2032) with head(R), and we can build a rule R\u2032\u2032 = R \u22c4\u00b5 R\u2032 that captures the sequence of applications encoded by the unifier. We extend Def. 6 to take into account negative bodies : if B\u2212 is a negative body of R or R\u2032, then \u00b5(B\u2212) is a negative body of R\u2032\u2032. We also extend the notion of dependency in a natural way, and say that a unifier \u00b5 of head(R) with body(R\u2032) is self-blocking when R \u22c4\u00b5 R\u2032 is selfblocking, and R\u2032 depends on R when there exists a unifier of head(R) with body(R\u2032) that is not self-blocking. This extended notion of dependency exactly corresponds to the positive reliance in (Magka, Kro\u0308tzsch, and Horrocks 2013).\nExample 15 Let R = q(x), not p(x) \u2192 r(x, y) and R\u2032 = r(x, y) \u2192 p(x), q(y). Their associated positive rules are not core-finite. There is a single unifier \u00b5 of R\u2032 with R, and R \u22c4\u00b5 R\u2032 : q(x), not p(x) \u2192 r(x, y), p(x), q(y) is self-blocking. Then the skolem-chase-tree halts on (F, {R,R\u2032}) for any F.\nResults obtained from positive rules can thus be generalized by considering this extended notion of dependency (for PGU we only encode non self-blocking unifiers). Note that it does not change the complexity of the acyclicity tests.\nWe can further generalize this and check if a unifier sequence is self-blocking, thus extend the YU+ classes to take into account negative bodies. Let us consider a compatible cycle C going through <a, i> that has not been proven safe. Let C\u00b5 be the set of all compatible unifier sequences induced by C. We say that a sequence \u00b51 . . . \u00b5k \u2208 C\u00b5 is self-blocking when the rule R1\u22c4\u00b51 R2 . . .Rk\u22c4\u00b5k Rk+1 obtained by combining these unifiers is self-blocking. When all sequences in C\u00b5 are self-blocking, we say that C is also self-blocking. This test comes again at no additional computational cost.\nExample 16 Let R1 = q(x1), notp(x1) \u2192 r(x1, y1), R2 = r(x2, y2) \u2192 s(x2, y2), R3 = s(x3, y3) \u2192 p(x3), q(y3). PGU+({R1,R2,R3}) has a unique cycle, with a unique induced compatible unifier sequence. The rule R1 \u22c4 R2 \u22c4 R3 = q(x1), notp(x1) \u2192 r(x1, y1), s(x1, y1), p(x1), q(y1) is selfblocking, hence R1 \u22c4 R2 \u22c4 R3 \u22c4 R1 also is. Thus, there is no \u201cdangerous\u201d cycle.\nProposition 13 If, for each existential position <a, i>, all compatible cycles for <a, i> in PGU are self-blocking, then the stable computation based on the skolem chase halts."}, {"heading": "Conclusion", "text": "We have revisited chase termination with several results. First, a new tool that allows to unify and extend most existing acyclicity conditions, while keeping good computational properties. Second, a chase-like mechanism for nonmonotonic existential rules under stable model semantics, as well the extension of acyclicity conditions to take negation into account. This latter contribution extends the notion of negative reliance of (Magka, Kro\u0308tzsch, and Horrocks 2013) ; and does not rely upon stratification (and thus does not enforce the existence of a single stable model).\nThis work will be pursued on the theoretical side by a complexity study of entailment for the new acyclic classes and by a deeper study of logical foundations for NME rules, since it remains to relate our core-stable sets to an existing first-order semantics for general NME rules.\nAcknowledgements We thank the reviewers for their comments. This work is part of the ASPIQ and Pagoda projects and was partly funded by the french Agence Nationale de la Recherche (ANR) grants ANR-12-BS02-0003 and ANR-12-JS02-0007."}], "references": [{"title": "Pushing the el envelope", "author": ["Brandt Baader", "F. Lutz 2005] Baader", "S. Brandt", "C. Lutz"], "venue": "In IJCAI\u201905,", "citeRegEx": "Baader et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2005}, {"title": "The Complexity of Rules and Constraints", "author": ["Baget", "Mugnier 2002] Baget", "J.-F", "Mugnier", "M.-L"], "venue": "J. Artif. Intell. Res. (JAIR)", "citeRegEx": "Baget et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Baget et al\\.", "year": 2002}, {"title": "Extending decidable cases for rules with existential variables", "author": ["Baget"], "venue": "In IJCAI\u201909,", "citeRegEx": "Baget,? \\Q2009\\E", "shortCiteRegEx": "Baget", "year": 2009}, {"title": "On rules with existential variables : Walking the decidability line", "author": ["Baget"], "venue": "Artificial Intelligence", "citeRegEx": "Baget,? \\Q2011\\E", "shortCiteRegEx": "Baget", "year": 2011}, {"title": "The implication problem for data dependencies", "author": ["Beeri", "C. Vardi 1981] Beeri", "M. Vardi"], "venue": "In ICALP\u201981,", "citeRegEx": "Beeri et al\\.,? \\Q1981\\E", "shortCiteRegEx": "Beeri et al\\.", "year": 1981}, {"title": "Taming the infinite chase : Query answering under expressive relational constraints", "author": ["Gottlob Cal\u0131", "A. Kifer 2008] Cal\u0131", "G. Gottlob", "M. Kifer"], "venue": "In KR\u201908,", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2008}, {"title": "A general datalog-based framework for tractable query answering over ontologies", "author": ["Gottlob Cal\u0131", "A. Lukasiewicz 2009a] Cal\u0131", "G. Gottlob", "T. Lukasiewicz"], "venue": "In PODS\u201909,", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2009}, {"title": "Tractable query answering over ontologies with datalog\u00b1", "author": ["Gottlob Cal\u0131", "A. Lukasiewicz 2009b] Cal\u0131", "G. Gottlob", "T. Lukasiewicz"], "venue": "In Proceedings of the DL Home 22nd International Workshop on Description Logics (DL", "citeRegEx": "Cal\u0131 et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Cal\u0131 et al\\.", "year": 2009}, {"title": "Computable functions in asp : Theory and implementation", "author": ["Calimeri"], "venue": "In Logic Programming", "citeRegEx": "Calimeri,? \\Q2008\\E", "shortCiteRegEx": "Calimeri", "year": 2008}, {"title": "Tractable reasoning and efficient query answering in description logics : The DL-Lite family", "author": ["Calvanese"], "venue": "J. Autom. Reasoning", "citeRegEx": "Calvanese,? \\Q2007\\E", "shortCiteRegEx": "Calvanese", "year": 2007}, {"title": "Embedded implicational dependencies and their inference problem", "author": ["Lewis Chandra", "A.K. Makowsky 1981] Chandra", "H.R. Lewis", "J.A. Makowsky"], "venue": null, "citeRegEx": "Chandra et al\\.,? \\Q1981\\E", "shortCiteRegEx": "Chandra et al\\.", "year": 1981}, {"title": "Acyclicity conditions and their application to query answering in description logics. In KR", "author": ["Cuenca Grau"], "venue": null, "citeRegEx": "Grau,? \\Q2012\\E", "shortCiteRegEx": "Grau", "year": 2012}, {"title": "Acyclicity notions for existential rules and their application to query answering in ontologies", "author": ["Cuenca Grau"], "venue": "Journal of Artificial Intelligence Research", "citeRegEx": "Grau,? \\Q2013\\E", "shortCiteRegEx": "Grau", "year": 2013}, {"title": "Omiga : an open minded grounding on-the-fly answer set solver", "author": ["Dao-Tran"], "venue": "In Logics in Artificial Intelligence", "citeRegEx": "Dao.Tran,? \\Q2012\\E", "shortCiteRegEx": "Dao.Tran", "year": 2012}, {"title": "The chase revisited", "author": ["Nash Deutsch", "A. Remmel 2008] Deutsch", "A. Nash", "J. Remmel"], "venue": "In PODS\u201908,", "citeRegEx": "Deutsch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2008}, {"title": "Data exchange : Semantics and query answering", "author": ["Fagin"], "venue": "In ICDT\u201903,", "citeRegEx": "Fagin,? \\Q2003\\E", "shortCiteRegEx": "Fagin", "year": 2003}, {"title": "Data exchange : semantics and query answering", "author": ["Fagin"], "venue": "Theor. Comput. Sci", "citeRegEx": "Fagin,? \\Q2005\\E", "shortCiteRegEx": "Fagin", "year": 2005}, {"title": "Stable models and circumscription", "author": ["Lee Ferraris", "P. Lifschitz 2011] Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artif. Intell", "citeRegEx": "Ferraris et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Equality-friendly well-founded semantics and applications to description logics", "author": ["Gottlob"], "venue": "In Description Logics", "citeRegEx": "Gottlob,? \\Q2012\\E", "shortCiteRegEx": "Gottlob", "year": 2012}, {"title": "Extending decidable existential rules by joining acyclicity and guardedness", "author": ["Kr\u00f6tzsch", "M. Rudolph 2011] Kr\u00f6tzsch", "S. Rudolph"], "venue": "In IJCAI\u201911,", "citeRegEx": "Kr\u00f6tzsch et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2011}, {"title": "A first order forward chaining approach for answer set computing", "author": ["Lef\u00e8vre", "C. Nicolas 2009] Lef\u00e8vre", "P. Nicolas"], "venue": "In Logic Programming and Nonmonotonic Reasoning", "citeRegEx": "Lef\u00e8vre et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lef\u00e8vre et al\\.", "year": 2009}, {"title": "One more decidable class of finitely ground programs", "author": ["Lierler", "Y. Lifschitz 2009] Lierler", "V. Lifschitz"], "venue": "In Logic Programming", "citeRegEx": "Lierler et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lierler et al\\.", "year": 2009}, {"title": "Logic programs with abstract constraint atoms : The role of computations", "author": ["Liu"], "venue": "Artificial Intelligence", "citeRegEx": "Liu,? \\Q2010\\E", "shortCiteRegEx": "Liu", "year": 2010}, {"title": "Computing stable models for nonmonotonic existential rules", "author": ["D.", "M. Kr\u00f6tzsch", "I. Horrocks"], "venue": "Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI 2013). AAAI Press.", "citeRegEx": "D. et al\\.,? 2013", "shortCiteRegEx": "D. et al\\.", "year": 2013}, {"title": "Disjunctive logic programs with existential quantification in rule heads", "author": ["Zhang You", "J.-H. Zhang 2013] You", "H. Zhang", "Y. Zhang"], "venue": "Theory and Practice of Logic Programming", "citeRegEx": "You et al\\.,? \\Q2013\\E", "shortCiteRegEx": "You et al\\.", "year": 2013}], "referenceMentions": [], "year": 2014, "abstractText": "Existential rules have been proposed for representing ontological knowledge, specifically in the context of OntologyBased Data Access. Entailment with existential rules is undecidable. We focus in this paper on conditions that ensure the termination of a breadth-first forward chaining algorithm known as the chase. Several variants of the chase have been proposed. In the first part of this paper, we propose a new tool that allows to extend existing acyclicity conditions ensuring chase termination, while keeping good complexity properties. In the second part, we study the extension to existential rules with nonmonotonic negation under stable model semantics, discuss the relevancy of the chase variants for these rules and further extend acyclicity results obtained in the positive case.", "creator": "LaTeX with hyperref package"}}}