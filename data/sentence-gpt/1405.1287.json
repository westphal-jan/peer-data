{"id": "1405.1287", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-May-2014", "title": "Semantics and Compilation of Answer Set Programming with Generalized Atoms", "abstract": "Answer Set Programming (ASP) is logic programming under the stable model or answer set semantics. During the last decade, this paradigm has seen several extensions by generalizing the notion of atom used in these programs. Among these, there are aggregate atoms, HEX atoms, generalized quantifiers, and abstract constraints that can be applied to any number of program language features. An implementation in this area is an implementation that combines algebraic data processing with a new system. As such, it can be used to provide an even better way of looking at different set types as well as the behavior and behavior of both of these extensions.\n\n\n\nIn a similar sense, this approach, while also making it easier to find a solution for complex systems, does not require you to solve all of these tasks in an environment with such a large amount of code. Rather, you can combine these abstract constraints to implement an application to a much more complicated system. There are many ways to overcome this challenge.\nFirst, let us break down what makes a program program a complete system. Let us consider some very useful problems such as the program we are using. Here's a quick overview of the various ways you can combine HEX atoms together to implement the following tasks.\n1) Create a simple program with basic data\nThe following steps allow you to create a simple program without having to change the program's behavior.\nTo create a simple program with HEX atoms, let's combine the two fundamental data types into one, for example, the time signature. It should be clear to anyone who is familiar with the definition of a program in programming languages, especially with HEX. For example, let's use the HEX atoms as example for our HEX atoms.\n1) Create a simple program with basic data\nTo create a simple program using HEX atoms, let's combine the two fundamental data types into one, for example, the time signature. It should be clear to anyone who is familiar with the definition of a program in programming languages, especially with HEX. For example, let's use the HEX atoms as example for our HEX atoms.\n2) Create a simple program with basic data\nWe can use the HEX atoms as example for the HEX atoms.\nIn this way, the program could be as simple as this, with the following definition:\n1) Create a simple program with basic data\nThe following steps allow you to create a simple program using HEX atoms as example for our HEX atoms.\n", "histories": [["v1", "Tue, 6 May 2014 14:44:40 GMT  (26kb)", "http://arxiv.org/abs/1405.1287v1", "The paper appears in the Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"]], "COMMENTS": "The paper appears in the Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["mario alviano", "wolfgang faber"], "accepted": false, "id": "1405.1287"}, "pdf": {"name": "1405.1287.pdf", "metadata": {"source": "CRF", "title": "Semantics and Compilation of Answer Set Programming with Generalized Atoms", "authors": ["Mario Alviano", "Wolfgang Faber"], "emails": ["mario@alviano.com", "wf@wfaber.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n12 87\nv1 [\ncs .A\nI] 6\nM ay\n2 01"}, {"heading": "Introduction", "text": "Answer Set Programming (ASP) is a widely used problemsolving framework based on logic programming under the stable model semantics. The basic language relies on Datalog with negation in rule bodies and possibly disjunction in rule heads. When actually using the language for representing practical knowledge, it became apparent that generalizations of the basic language are necessary for usability. Among the suggested extensions are aggregate atoms (similar to aggregations in database queries) (Niemela\u0308, Simons, and Soininen 1999; Niemela\u0308 and Simons 2000; Dell\u2019Armi et al. 2003; Faber et al. 2008) and atoms that rely on external truth valuations (Calimeri, Cozza, and Ianni 2007; Eiter et al. 2004; Eiter et al. 2005). These extensions are characterized by\nthe fact that deciding the truth values of the new kinds of atoms depends on the truth values of a set of traditional atoms rather than a single traditional atom. We will refer to such atoms as generalized atoms, which cover also several other extensions such as abstract constraints, generalized quantifiers, and HEX atoms.\nConcerning semantics for programs containing generalized atoms, there have been several different suggestions. All of these appear to coincide for programs that do not contain generalized atoms in recursive definitions. The two main semantics that emerged as standards are the PSP semantics defined in (Pelov 2004; Pelov, Denecker, and Bruynooghe 2007) and (Son and Pontelli 2007), and the FLP semantics defined in (Faber, Leone, and Pfeifer 2004; Faber, Leone, and Pfeifer 2011). In a recent paper (Alviano and Faber 2013) the relationship between these two semantics was analyzed in detail; among other, more intricate results, it was shown that the semantics coincide up to convex generalized atoms. It was already established earlier that each PSP answer set is also an FLP answer set, but not vice versa. So for programs containing non-convex generalized atoms, some FLP answer sets are not PSP answer sets. In particular, there are programs that have FLP answer sets but no PSP answer sets.\nIn this paper, we argue that the FLP semantics is still too restrictive, and some programs that do not have any FLP answer set should instead have answer sets. In order to illustrate the point, consider a coordination game that is remotely inspired by the prisoners\u2019 dilemma. There are two players, each of which has the option to confess or defect. Let us also assume that both players have a fixed strategy already, which however still depends on the choice of the other player as well. In particular, each player will confess exactly if both players choose the same option, that is, if both players confess or both defect. The resulting program is P1 in Example 2, where a means that the first player confesses and b means that the second player confesses. As will be explained later, the FLP semantics does not assign any answer set to this program, and therefore also the PSP semantics will not assign any answer sets to this program. However, this is peculiar, as the scenario in which both players confess seems like a reasonable one; indeed, even a simple inflationary operator would result in this solution.\nLooking at the reason why this is not an FLP answer set, we observe that it has two countermodels that prevent it from being an answer set: One in which only the first player confesses, and another one in which only the second player confesses. Both of these countermodels are models in the classical sense, but they are weak in the sense that they are not supported, meaning that there is no rule justifying their truth. This is a situation that does not occur for aggregate-free programs, which always have supported countermodels. We argue that one needs to look at supported countermodels, instead of looking at minimal countermodels. It turns out that doing this yields the same results not only for aggregate-free programs, but also for programs containing convex aggregates, which we believe is the reason why this issue has not been noticed earlier.\nIn this paper, we define a new semantics along these lines and call it supportedly stable or SFLP (supportedly FLP) semantics. It provides answer sets for more programs than FLP and PSP, but is shown to be equal on convex programs. Analyzing the computational complexity of the new semantics, we show that it is in the same classes as the FLP and PSP semantics when considering polynomial-time computable generalized atoms. It should also be mentioned that the new semantics has its peculiarities, for instance adding \u201ctautological\u201d rules like a \u2190 a can change the semantics of the program.\nThis complexity result directly leads us to the second contribution of this paper. While it has been known for quite some time that the complexity of programs with generalized atoms (even without disjunctions) is equal to the complexity of disjunctive programs, no compact transformation from programs with generalized atoms to disjunctive standard programs is known yet. We provide a contribution with this respect and show how to achieve such a compact compilation for both FLP and SFLP semantics when non-convex aggregates are in disjunctive normal form. It hinges on the use of disjunction and fresh symbols to capture satisfaction of a generalized atom.\nThe remainder of this paper is structured as follows. In the next section, we present the syntax and FLP semantics for programs with generalized atoms. After that, we analyze issues with the FLP semantics and define the SFLP semantics, followed by a section that proves several useful properties of the new semantics. The subsequent section then deals with compiling programs with generalized atoms into generalized-atom-free programs, followed by conclusions."}, {"heading": "Syntax and FLP Semantics", "text": "In this section we present the syntax used in this paper and present the FLP semantics (Faber, Leone, and Pfeifer 2004; Faber, Leone, and Pfeifer 2011). To ease the presentation, we will directly describe a propositional language here. This can be easily extended to the more usual ASP notations of programs involving variables, which stand for their ground versions (that are equivalent to a propositional program)."}, {"heading": "Syntax", "text": "Let B be a countable set of propositional atoms.\nDefinition 1. A generalized atom A on B is a mapping from 2B to Boolean truth values. Each generalized atom A has an associated, finite1 domain DA \u2286 B, indicating those propositional atoms that are relevant to the generalized atom.\nExample 1. A generalized atom A1 modeling a conjunction a1, . . . , an (n \u2265 0) of propositional atoms is such that DA1\n= {a1, . . . , an} and, for every I \u2286 B, A1 maps I to true if and only if DA1 \u2286 I .\nA generalized atom A2 modeling a conjunction a1, . . . , am,\u223cam+1, . . . ,\u223can (n \u2265 m \u2265 0) of literals, where a1, . . . , an are propositional atoms and \u223c denotes negation as failure, is such that DA2 = {a1, . . . , an} and, for every I \u2286 B, A2 maps I to true if and only if {a1, . . . , am} \u2286 I and {am+1, . . . , an} \u2229 I = \u2205.\nA generalized atom A3 modeling an aggregate COUNT({a1, . . . , an}) 6= k (n \u2265 k \u2265 0), where a1, . . . , an are propositional atoms, is such that DA3 = {a1, . . . , an} and, for every I \u2286 B, A3 maps I to true if and only if |DA3 \u2229 I| 6= k.\nIn the following, when convenient, we will represent generalized atoms as conjunctions of literals or aggregate atoms. Subsets of B mapped to true by such generalized atoms will be those satisfying the associated conjunction.\nDefinition 2. A general rule r is of the following form:\nH(r) \u2190 B(r) (1)\nwhere H(r) is a disjunction a1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 an (n \u2265 0) of propositional atoms in B referred to as the head of r, and B(r) is a generalized atom on B called the body of r. For convenience, H(r) is sometimes considered a set of propositional atoms.\nA general program P is a set of general rules.\nExample 2. Consider the following rules:\nr1 : a \u2190 COUNT ({a, b}) 6= 1\nr2 : b \u2190 COUNT ({a, b}) 6= 1\nThe following are general programs:\nP1 := {r1; r2}\nP2 := {r1; r2; a \u2190 b; b \u2190 a}\nP3 := {r1; r2;\u2190 \u223ca;\u2190 \u223cb}\nP4 := {r1; r2; a \u2228 b \u2190}\nP5 := {r1; r2; a \u2190 \u223cb}"}, {"heading": "FLP Semantics", "text": "An interpretation I is a subset of B. I is a model for a generalized atom A, denoted I |= A, if A maps I to true. Otherwise, if A maps I to false, I is not a model of A, denoted I 6|= A. I is a model of a rule r of the form (1), denoted I |= r, if H(r)\u2229I 6= \u2205 whenever I |= B(r). I is a model of a programP , denoted I |= P , if I |= r for every rule r \u2208 P .\nGeneralized atoms can be partitioned into two classes according to the following definition.\n1In principle, we could also consider infinite domains, but refrain to do so for simplicity.\nDefinition 3 (Convex Generalized Atoms). A generalized atom A is convex if for all triples I, J,K of interpretations such that I \u2282 J \u2282 K , I |= A and K |= A implies J |= A.\nNote that convex generalized atoms are closed under conjunction (but not under disjunction or negation). A convex program is a general program whose rules have convex bodies.\nWe now describe a reduct-based semantics, usually referred to as FLP, which has been introduced and analyzed in (Faber, Leone, and Pfeifer 2004; Faber, Leone, and Pfeifer 2011).\nDefinition 4 (FLP Reduct). The FLP reduct P I of a program P with respect to I is defined as the set {r \u2208 P | I |= B(r)}.\nDefinition 5 (FLP Answer Sets). I is an FLP answer set of P if I |= P and for each J \u2282 I it holds that J 6|= P I . Let FLP (P ) denote the set of FLP answer sets of P .\nExample 3. Consider the programs from Example 2. The models of P1 are {a}, {b} and {a, b}, none of which is an FLP answer set. Indeed,\nP {a} 1 = P {b} 1 = \u2205,\nwhich have the trivial model \u2205, which is of course a subset of {a} and {b}. On the other hand\nP {a,b}\n1 = P1,\nand so {a} |= P {a,b}\n1 ,\nwhere {a} \u2282 {a, b}. We will discuss in the next section why this is a questionable situation.\nConcerning P2, it has one model, namely {a, b}, which is also its unique FLP answer set. Indeed,\nP {a,b}\n2 = P2,\nand hence the only model of P {a,b}2 is {a, b}. Interpretation {a, b} is also the unique model of program P3, which however has no FLP answer set. Here,\nP {a,b}\n3 = P1,\nhence similar to P1,\n{a} |= P {a,b}\n3\nand {a} \u2282 {a, b}. P4 instead has two FLP answer sets, namely {a} and {b}, and a further model {a, b}. In this case,\nP {a}\n4 = {a \u2228 b \u2190},\nand no proper subset of {a} satisfies it. Also\nP {b}\n4 = {a \u2228 b \u2190},\nand no proper subset of {b} satisfies it. Instead, for {a, b}, we have\nP {a,b}\n4 = P4,\nand hence {a} |= P {a,b}\n4\nand {a} \u2282 {a, b}. Finally, P5 has tree models, {a}, {b} and {a, b}, but only one answer set, namely {a}. In fact, P {a}5 = {a \u2190 \u223cb} and \u2205 is not a model of the reduct. On the other hand, \u2205 is a model of P {b}5 = \u2205, and {a} is a model of P {a,b} 5 = P1."}, {"heading": "SFLP Semantics", "text": "As noted in the introduction, the fact that P1 has no FLP answer sets is striking. If we first assume that both a and b are false (interpretation \u2205), and then apply a generalization of the well-known one-step derivability operator, we obtain truth of both a and b (interpretation {a, b}). Applying this operator once more again yields the same interpretation, a fix-point. {a, b} is also a supported model, that is, for all true atoms there exists a rule in which this atom is the only true head atom, and in which the body is true.\nIt is instructive to examine why this seemingly robust model is not an FLP answer set. Its reduct is equal to the original program, P {a,b}1 = P1. There are therefore two models of P1, {a} and {b}, that are subsets of {a, b} and therefore inhibit {a, b} from being an FLP answer set. The problem is that, contrary to {a, b}, these two models are rather weak, in the sense that they are not supported. Indeed, when considering {a}, there is no rule in P1 such that a is the only true atom in the rule head and the body is true in {a}: The only available rule with a in the head has a false body. The situation for {b} is symmetric.\nIt is somewhat counter-intuitive that a model like {a, b} should be inhibited by two weak models like {a} and {b}. Indeed, this is a situation that normally does not occur in ASP. For programs that do not contain generalized atoms, whenever one finds a J \u2286 I such that J |= P I there is for sure also a K \u2286 I such that K |= P I and K is supported. Indeed, we will show in the following section that this is the case also for programs containing only convex generalized atoms. Our feeling is that since such a situation does not happen for a very wide set of programs, it has been overlooked so far.\nWe will now attempt to repair this kind of anomaly by stipulating that one should only consider supported models for finding inhibitors of answer sets. In other words, one does not need to worry about unsupported models of the reduct, even if they are subsets of the candidate. Let us first define supported models explicitly.\nDefinition 6 (Supportedness). A model I of a program P is supported if for each a \u2208 I there is a rule r \u2208 P such that I \u2229 H(r) = {a} and I |= B(r). In this case we will write I |=s P .\nExample 4. Continuing Example 3, programs P1, P2, and P3 have one supported model, namely {a, b}. The model {a} of P1 is not supported because the body of the the rule with a in the head has a false body with respect to {a}. For a symmetric argument, model {b} of P1 is not supported either. The supported models of P4, instead, are {a}, {b}, and\n{a, b}, so all models of the program are supported. Note that both models {a} and {b} have the disjunctive rule as the only supporting rule for the respective single true atom, while for {a, b}, the two rules with generalized atoms serve as supporting rules for a and b. Finally, the supported models of P5 are {a} and {a, b}.\nWe are now ready to formally introduce the new semantics. In this paper we will normally refer to it as SFLP answer sets or SFLP semantics, but also call it supportedly stable models occasionally.\nDefinition 7 (SFLP Answer Sets). I is a supportedly FLP answer set (or SFLP answer set, or supportedly stable model) of P if I |=s P and for each J \u2282 I it holds that J 6|=s P\nI . Let SFLP (P ) denote the set of SFLP answer sets of P .\nExample 5. Consider again the programs from Example 2. Recall that P1 has only one supported model, namely {a, b}, and\nP {a,b}\n1 = P1,\nbut \u2205 6|=s P {a,b}\n1 ,\n{a} 6|=s P {a,b}\n1 ,\n{b} 6|=s P {a,b}\n1 ,\ntherefore no proper subset of {a, b} is a supported model, hence it is an SFLP answer set.\nConcerning P2, it has one model, namely {a, b}, which is supported and also its unique SFLP answer set. Indeed, recall that\nP {a,b}\n2 = P2,\nand hence no proper subset of {a, b} can be a model (let alone a supported model) of P {a,b}2 . Interpretation {a, b} is the unique model of program P3, which is supported and also its SFLP answer set. In fact\nP {a,b}\n3 = P1.\nP4 has two SFLP answer sets, namely {a} and {b}. In this case, recall\nP {a}\n4 = {a \u2228 b \u2190},\nand no proper subset of {a} satisfies it. Also\nP {b}\n4 = {a \u2228 b \u2190},\nand no proper subset of {b} satisfies it. Instead, for {a, b}, we have\nP {a,b}\n4 = P4,\nhence since {a} |=s P {a,b}\n4 ,\n{b} |=s P {a,b}\n4 ,\nwe obtain that {a, b} is not an SFLP answer set. Finally, P5 has two SFLP answer sets, namely {a} and {a, b}. In fact, P {a}5 = {a \u2190 \u223cb} and P {a,b}\n5 = P1. The programs, models, FLP answer sets, supported mod-\nels, and SFLP answer sets are summarized in Table 1.\nAn alternative, useful characterization of SFLP answer sets can be given in terms of Clark\u2019s completion (Clark 1978). In fact, it is well-known that supported models of a program are precisely the models of its completion. We define this notion in a somewhat non-standard way, making use of the concept of generalized atom.\nNext, we first define the completion of a propositional atom a with respect to a general program P as a generalized atom encoding the supportedness condition for a.\nDefinition 8. The completion of a propositional atom a \u2208 B with respect to a general program P is a generalized atom comp(a, P ) mapping to true any interpretation I containing a and such that there is no rule r \u2208 P for which I |= B(r) and I \u2229H(r) = {a}.\nThese generalized atoms are then used to effectively define a program whose models are the supported model of P .\nDefinition 9. The completion of a general program P is a general program comp(P ) extending P with a rule\n\u2190 comp(a, P )\nfor each propositional atom a occurring in P .\nExample 6. Consider again programs from Example 2. Program comp(P1) extends P1 with the following rules:\n\u2190 a, COUNT ({a, b}) = 1\n\u2190 b, COUNT ({a, b}) = 1\nProgram comp(P2) extends P2 with the following rules:\n\u2190 a, COUNT ({a, b}) = 1, \u223cb\n\u2190 b, COUNT ({a, b}) = 1, \u223ca\nProgram comp(P3) is equal to comp(P1), and program comp(P4) extends P4 with the following rules:\n\u2190 a, COUNT ({a, b}) = 1, b\n\u2190 b, COUNT ({a, b}) = 1, a\nProgram comp(P5) instead extends P5 with the following rules:\n\u2190 a, COUNT ({a, b}) = 1, b\n\u2190 b, COUNT ({a, b}) = 1\nThe only model of comp(P1), comp(P2), and comp(P3) is {a, b}. The models of comp(P4) and comp(P5) instead are {a}, {b}, and {a, b}.\nProposition 1. Let P be a general program and I an interpretation. I |=s P iff I |= comp(P ).\nThis characterization (which follows directly from (Clark 1978)) provides us with a means for implementation that relies only on model checks, rather than supportedness checks.\nProposition 2. Let P be a general program and I an interpretation. I is a supportedly FLP answer set of P if I |= comp(P ) and for each J \u2282 I it holds that J 6|= comp(P I)."}, {"heading": "Properties", "text": "The new semantics has a number of interesting properties that we report in this section. First of all, it is an extension of the FLP semantics, in the sense that each FLP answer set is also an SFLP answer set.\nTheorem 1. Let P be a general program. FLP (P ) \u2286 SFLP (P ).\nProof. Let I be an FLP answer set of P . Hence, each J \u2282 I is such that J 6|= P I . Thus, we can conclude that J 6|=s P I for any J \u2282 I . Therefore, I is a SFLP answer set of P .\nThe inclusion is strict in general. In fact, P1 is a simple program for which the two semantics disagree (see Examples 2\u20135 and Table 1). On the other hand, the two semantics are equivalent for a large class of programs, as shown below.\nTheorem 2. If P is a convex program then FLP (P ) ="}, {"heading": "SFLP (P ).", "text": "Proof. FLP (P ) \u2286 SFLP (P ) holds by Theorem 1. For the other direction, consider an interpretation I not being an FLP answer set of P . Hence, there is J \u2282 I such that J |= P I . We also assume that J is a subset-minimal model of P I , that is, there is no K \u2282 J such that K |= P I . We shall show that J |=s P I . To this end, suppose by contradiction that there is a \u2208 J such that for each r \u2208 P I either J 6|= B(r) or J \u2229 H(r) 6= {a}. Consider J \\ {a} and a rule r \u2208 P I such that J \\ {a} |= B(r). Since r \u2208 P I , I |= B(r), and thus J |= B(r) because B(r) is convex. Therefore, J \u2229H(r) 6= {a}. Moreover, J \u2229H(r) 6= \u2205 because J |= P I by assumption. Hence, (J \\ {a})\u2229H(r) 6= \u2205, and therefore J \\ {a} |= P I . This contradicts the assumption that J is a subset-minimal model of P I .\nWe will now focus on computational complexity. We consider here the problem of determining whether an SFLP answer set exists. We note that the only difference to the FLP semantics is in the stability check. For FLP, subsets need to be checked for being a model, for SFLP, subsets need to be checked for being a supported model. Intuitively, one would not expect that this difference can account for a complexity jump, which is confirmed by the next result.\nTheorem 3. Let P be a general program whose generalized atoms are polynomial-time computable functions. Checking whether SFLP (P ) 6= \u2205 is in \u03a3P2 in general; it is \u03a3 P 2 -hard already in the disjunction-free case if at least one form of non-convex generalized atom is permitted. The problem is NP -complete if P is disjunction-free and convex.\nProof. For the membership in \u03a3P2 one can guess an interpretation I and check that there is no J \u2282 I such that J |=s P . The check can be performed by a coNP oracle.\nTo prove \u03a3P2 -hardness we note that extending a general program P by rules a \u2190 a for every propositional atom occurring in P is enough to guarantee that all models of any reduct of P are supported. We thus refer to the construction and proof by (Alviano and Faber 2013).\nIf P is disjunction-free and convex then SFLP (P ) = FLP (P ) by Theorem 2. Hence, NP -completeness follows from results in (Liu and Truszczyn\u0301ski 2006).\nWe would like to point out that the above proof also illustrates a peculiar feature of SFLP answer sets, which it shares with the supported model semantics: the semantics is sensitive to tautological rules like a \u2190 a, as their addition can turn non-SFLP answer sets into SFLP answer sets."}, {"heading": "Compilation", "text": "The introduction of generalized atoms in logic programs does not increase the computational complexity of checking FLP as well as SFLP answer set existence, as long as one is allowed to use disjunctive rule heads. However, so far no compilation method that compactly transforms general programs to logic programs without generalized atoms has been presented for the FLP semantics. In the following we provide such a compilation for non-convex aggregates in disjunctive normal form. The compilation is also extended for the new SFLP semantics. We point out that such compilations are not necessarily intended to provide efficient methods for computing answer sets of general programs. Their purpose is instead to provide insights that may lead to obtain such methods in the future.\nIn this section we only consider generalized atoms in disjunctive normal form, that is, a generalized atom A will be associated with an equivalent propositional formula of the following form:\nk\u2228\ni=1\nai1 \u2227 . . . \u2227 aim \u2227 \u223caim+1 \u2227 . . . \u2227 \u223cain (2)\nwhere k \u2265 1, in \u2265 im \u2265 0 and ai1 , . . . , ain are propositional atoms for i = 1, . . . , k. We will also assume that the programs to be transformed have atomic heads. To generalize our compilations to cover disjunctive general rules is a problem to be addressed in future work.\nLet P be a program. In our construction we will use the following fresh propositional atoms, i.e., propositional\natoms not occurring in P : AT for each generalized atom A; AFi for each generalized atom A and integer i \u2265 0. For a generalized atom A of the form (2) and integer i = 1, . . . , k, let tr(A, i) denote the following rule:\nAT \u2228 aim+1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 ain \u2190 ai1 , . . . , aim ,\u223cA F0 . (3)\nMoreover, let fls(A, i, j) denote\nAFi \u2190 \u223caij ,\u223cA T (4)\nfor j = i1, . . . , im, and\nAFi \u2190 aij ,\u223cA T (5)\nfor j = im+1, . . . , in. Abusing of notation, let fls(A) denote the following rule:\nAF0 \u2190 AF1 , . . . , AFk ,\u223cAT . (6)\nIntuitively, rule tr(A, i) forces truth of AT whenever the ith disjunct of A is true. Similarly, rule fls(A, i, j) forces truth of AFi whenever the i-th disjunct of A is false due to atom aij ; if all disjuncts of A are false, rule fls(A) forces truth of AF0 to model that A is actually false. Note that atoms occurring in negative literals of the i-th disjunct of A have been moved in the head of tr(A, i). In this way, the information encoded by tr(A, i) is preserved in the reduct with respect to an interpretation I whenever the i-th disjunct of A is true with respect to a subset of I , not necessarily I itself.\nThe rewriting of A, denoted rew(A), is the following set of rules:\n{tr(A, i) | i = 1, . . . , k} \u222a {fls(A)} \u222a\n{fls(A, i, j) | i = 1, . . . , k \u2227 j = 1, . . . , n} (7)\nThe rewriting of P , denoted rew(P ), is obtained from P by replacing each generalized atom A by AT . The FLPrewriting of P , denoted rewFLP (P ), is obtained from rew(P ) by adding rules in rew(A) for each generalized atom A occurring in P . The SFLP-rewriting of P , denoted rewSFLP (P ), is obtained from rewFLP (P ) by adding a rule supp(a) of the form\nAT1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 A T n \u2190 a (8)\nfor each propositional atom a occurring in P , where a \u2190 Ai (i = 1, . . . , n) are the rules of P having head a.\nExample 7. Let A be the generalized atom in Example 2. Its disjunctive normal form is \u223ca\u2227 \u223cb\u2228 a\u2227 b. Rules r1 and r2 are then a \u2190 A and b \u2190 A. Program rewFLP (P1) is\nrew({r1}) : a \u2190 AT rew({r2}) : b \u2190 AT\ntr(A, 1) : AT \u2228 a \u2228 b \u2190 \u223cAF0 tr(A, 2) : AT \u2190 a, b,\u223cAF0\nfls(A, 1, 1) : AF1 \u2190 a,\u223cAT fls(A, 1, 2) : AF1 \u2190 b,\u223cAT fls(A, 2, 1) : AF2 \u2190 \u223ca,\u223cAT fls(A, 2, 2) : AF2 \u2190 \u223cb,\u223cAT\nfls(A) : AF0 \u2190 AF1 , AF2 ,\u223cAT\nOne can check that rewFLP (P1) has no answer set. In particular, {a, b, AT} is not an answer set of rewFLP (P1). Its FLP reduct consists of the first four rules\na \u2190 AT b \u2190 AT\nAT \u2228 a \u2228 b \u2190 \u223cAF0\nAT \u2190 a, b,\u223cAF0\nand both {a} and {b} are minimal models of the reduct. On the other hand, neither {a} nor {b} are models of the original program, and so also not answer sets.\nProgram rewSFLP (P1) extends rew FLP (P1) with the\nfollowing rules:\nsupp(a) : AT \u2190 a supp(b) : AT \u2190 b\nThe program rewSFLP (P1) has one answer set:\n{a, b, AT }.\nIn contrast to rewFLP (P1) its FLP reduct now consists of the first four rules of rewFLP (P1) plus the two additional rules:\na \u2190 AT b \u2190 AT\nAT \u2228 a \u2228 b \u2190 \u223cAF0\nAT \u2190 a, b,\u223cAF0 AT \u2190 a AT \u2190 b\nThese two additional rules impede {a} and {b} to be models, and indeed only {a, b, AT} is a model of the reduct.\nProgram rewFLP (P2) is rew FLP (P1) \u222a {a \u2190 b; b \u2190 a}. (To simplify the presentation, bodies equivalent to atomic literals are not rewritten.)\nIn this case, {a, b, AT}\nis its only answer set. Different to rewFLP (P2), the additional rules will be present in the reduct for {a, b, AT }:\na \u2190 AT b \u2190 AT\nAT \u2228 a \u2228 b \u2190 \u223cAF0\nAT \u2190 a, b,\u223cAF0\na \u2190 b b \u2190 a\nThus the reduct models {a} and {b} are avoided. Program rewSFLP (P2) extends rew FLP (P2) with\nsupp(a)\u2032 : AT \u2228 b \u2190 a supp(b)\u2032 : AT \u2228 a \u2190 b\nIt is easy to see that these additional rules do not alter answer sets, so also rewSFLP (P2) has a single answer set {a, b, AT}.\nProgram rewFLP (P3) is rew FLP (P1)\u222a{\u2190 \u223ca;\u2190 \u223cb}. This program has no answer sets for the same reason as rewFLP (P1). Indeed, the two additional rules are not in the\nreduct for {a, b, AT }, and so {a} and {b} are again minimal models.\nProgram rewSFLP (P3) is rew SFLP (P1) \u222a {\u2190 \u223ca;\u2190 \u223cb}. For the same reason as for rewSFLP (P1), this program has exactly one answer set:\n{a, b, AT}.\nThe two new rules disappear in the reduct, but the rules present in rewSFLP (P1) but not in rew\nFLP (P1) do not allow models {a} and {b}.\nProgram P4 contains a disjunctive rule and is thus not in the domain of rewFLP and rewSFLP described here.\nIn the examples provided so far, it can be checked that answer sets are preserved by our transformations if auxiliary symbols are ignored. In the remainder of this section we will formalize this intuition.\nDefinition 10. The expansion of an interpretation I for a program P , denoted exp(I), is the following interpretation:\nI \u222a {AT | AT occurs in rew(P ), I |= A}\n\u222a {AFi | AFi occurs in rew(P ), I 6|= A}. (9)\nThe contraction of an interpretation I to the symbols of P , denoted I|P , is the following interpretation:\nI \u2229 {a \u2208 B | a occurs in P}. (10)\nBelow, we show that expansions and contractions define bijections between the answer sets of a program and those of the corresponding compilations. In the claim we consider only FLP answer sets of the rewritten program because it is convex, and thus its FLP and SFLP answer sets coincide by Theorem 2.\nTheorem 4. Let P be a program, andF \u2208 {FLP, SFLP}.\n1. If I \u2208 F(P ) then exp(I) \u2208 FLP (rewF (P )). 2. If I \u2208 FLP (rewF (P )) then I|P \u2208 F(P ).\nProof (item 1). Let I be an F answer set of P . Hence, I |=s P (see Definition 7 and Theorem 1). Since each generalized atom A occurring in P is replaced by AT in rew(P ), and AT \u2208 exp(I) if and only if I |= A, we have I |= rew(P ). Consider rules in rew(A) for some generalized atom A of the form (2) occurring in P , and note that either AT \u2208 exp(I) or AF0 , . . . , AFk \u2208 exp(I). In both cases, all rules in rew(A) are satisfied by exp(I). Hence, exp(I) |= rewFLP (P ). Consider a rule supp(a) of the form (8) such that a \u2208 I . Since I |=s P , there is i \u2208 {1, . . . , n} such that I |= Ai. Thus, ATi \u2208 exp(I), and therefore exp(I) |= supp(a). We can conclude exp(I) |= rewSFLP (P ).\nLet J \u2286 exp(I) be such that J |= rewF (P )exp(I). We first show that J |P = I . Consider a rule a \u2190 A in P I such that I |= A and J |P |= A, where A is of the form (2). Hence, there is i \u2208 {1, . . . , k} such that\nJ |P |= ai1 \u2227 . . . \u2227 aim \u2227 \u223caim+1 \u2227 . . . \u2227 \u223cain .\nTherefore, AT \u2208 J because tr(A, i) \u2208 rewF (P )exp(I), and consequently a \u2208 J because of rule a \u2190 AT in\nrewF (P )exp(I). We thus conclude J |P |= P I . For F = FLP , this already proves J |P = I . For F = SFLP , let X \u2286 J |P be the atoms without support, i.e., X is a subsetmaximal set such that a \u2208 X implies J |P \\X 6|= A for each rule a \u2190 A in P I . Hence, J |P \\X |=s P I . It follows that J |P \\X = I , i.e., X = \u2205 and J |P = I .\nWe can now show that J = exp(I). Let A be a generalized atom of the form (2). If J |P |= A there is i \u2208 {1, . . . , k} such that\nJ |P |= ai1 \u2227 . . . \u2227 aim \u2227 \u223caim+1 \u2227 . . . \u2227 \u223cain ,\nand thus AT \u2208 J because tr(A, i) \u2208 rewF (P )exp(I) and J |= rewF (P )exp(I). Otherwise, if J |P 6|= A then for all i \u2208 {1, . . . , k} there is either j \u2208 {1, . . . ,m} such that aij /\u2208 J |P , or j \u2208 {m + 1, . . . , n} such that aij \u2208 J |P . Hence, AFi \u2208 J because J |= fls(A, i, j), and thus AF0 \u2208 J because J |= fls(A).\nProof (item 2). Let I be an FLP answer set of rewF (P ). Let A be a generalized atom A of the form (2) occurring in P . We prove the following statements:\n|I \u2229 {AT , AFi}| \u2264 1 holds for i = 1, . . . , k (11)\nAT \u2208 I if and only if I|P |= A (12)\n|I \u2229 {AT , AFi}| = 1 holds for i = 1, . . . , k (13)\nTo prove (11), define set X as a maximal subset satisfying the following requirements: If {AT , AFi} \u2286 I (for some i \u2208 {1, . . . , k}) then {AT , AF0 , . . . , AFk} \u2286 X ; if an atom a is not supported by I \\X in rewFLP (P )I then a \u2208 X . We have I \\X |= rewF (P )I , from which we conclude X = \u2205.\nConsider (12). If AT \u2208 I then by (11) no AFi belongs to I . Recall that FLP answer sets are supported models, i.e., I |=s rewF (P ). Thus, for F = FLP , there is i \u2208 {1, . . . , k} such that I |= B(tr(A, i)) and I \u2229 H(tr(A, i)) = {AT }. Therefore, I|P |= A. For F = SFLP , we just note that if AT is supported only by a rule of the form (8), then atom a is only supported by a rule a \u2190 AT in rewF (P ). I \\ {a,AT } would be a model of rewF (P )I in this case, then contradicting I \u2208 FLP (rewF (P )). Now consider the right-to-left direction. If I|P |= A then there is i \u2208 {1, . . . , k} such that I|P |= ai1\u2227. . .\u2227aim\u2227\u223caim+1\u2227. . .\u2227\u223cain , and thus A\nFi /\u2208 I (see Equations 4\u20135). Hence, AF0 /\u2208 I (see Equation 6). From rule tr(A, i) (see Equation 3) we have AT \u2208 I .\nConcerning (13), because of (11) and (12), we have just to show that AF0 , . . . , AFk \u2208 I whenever I|P 6|= A. In fact, in this case AT /\u2208 I by (12), and for each i \u2208 {1, . . . , k} there is either j \u2208 {1, . . . ,m} such that aij /\u2208 I|P , or j \u2208 {m+ 1, . . . , n} such that aij \u2208 I|P . Hence, A\nFi \u2208 I because of rules fls(r, i, j) and fls(r).\nWe can now prove the main claim. We start by showing that I|P |= P . Indeed, for a rule a \u2190 A in P such that I|P |= A, rew(P ) contains a rule a \u2190 AT . Moreover, AT \u2208 I by (12), and thus a \u2208 I . If F = SFLP , then for each a \u2208 I we have I |= supp(a), where supp(a) is of the form (8). Hence, there is i \u2208 1, ..., n such that ATi \u2208 I . Therefore, (12) implies I|P |= Ai, that is, a is supported by I|P in P . We can thus conclude that IP |=s P .\nTo complete the proof, for F = FLP we consider X \u2286 I|P such that I|P \\ X |= P I|P , while for F = SFLP we consider X \u2286 I|P such that I|P \\X |=s P I|P . Let J be the interpretation obtained from I \\X by removing all atom AT such that I|P \\X 6|= A. We shall show that J |= rewF (P )I , from which we conclude X = \u2205. Consider a rule of the form a \u2190 AT in rewF (P )I such that AT \u2208 J . Hence, I|P \\X |= A by construction of J . Since a \u2190 A is a rule in P I|P , we conclude a \u2208 I|P \\X and thus a \u2208 J . Consider now a rule tr(A, i) in rewF (P )I such that J |= B(tr(A, i)) and AT /\u2208 J . Hence, I|P \\ X 6|= A by construction of J , which means that there is either j \u2208 {1, . . . ,m} such that aij /\u2208 I|P \\ X , or j \u2208 {m + 1, . . . , n} such that aij \u2208 I|P \\X . We conclude that J |= tr(A, i). Rules fls(A, i, j) and fls(A) are satisfied as well because no AFi has been removed. For F = SFLP , consider a rule supp(a) of the form (8) such that a \u2208 J . Since I|P \\ X |=s P I|P , there is rule a \u2190 A in P I|P such that I|P \\X |= A. Hence, by construction of J , AT \u2208 J and thus J |= supp(a)."}, {"heading": "Conclusion", "text": "In this paper, we have first defined a new semantics for programs with generalized atoms, called supportedly stable models, supportedly FLP, or SFLP semantics. We have motivated its definition by an anomaly that arises for the FLP semantics in connection with non-convex generalized atoms. In particular, only unsupported models may in particular cases inhibit the stability of candidate models. The new definition overcomes this anomaly and provides a robust semantics for programs with generalized atoms. We show several properties of this new semantics, for example it coincides with the FLP semantics (and thus also the PSP semantics) on convex programs, and thus also on standard programs. Furthermore, the complexity of reasoning tasks is equal to the respective tasks using the FLP semantics. We also provide a characterization of the new semantics by a Clark-inspired completion.\nWe observe that other interesting semantics, such as the one by (Ferraris 2005), are also affected by the anomaly on unsupported models. In particular, the semantics by (Ferraris 2005) is presented for programs consisting of arbitrary set of propositional formulas, and it is based on a reduct in which false subformulas are replaced by \u22a5. Answer sets are then defined as interpretations being subsetminimal models of their reducts. For the syntax considered in this paper, when rewriting generalized atoms to an equivalent formula, the semantics by (Ferraris 2005) coincides with FLP, which immediately shows the anomaly. In (Ferraris 2005) there is also a method for rewriting aggregates, however COUNT ({a, b}) 6= 1 is not explicitly supported, but should be rewritten to \u00ac(COUNT ({a, b}) = 1). Doing this, one can observe that for P1, P2, P3, and P5 the semantics of (Ferraris 2005) behaves like SFLP (cf. Table 1), while for P4 the semantics of (Ferraris 2005) additionally has the answer set {a, b}, which is not a supported minimal model of the FLP reduct. P4 therefore shows that the two semantics do not coincide, even if generalized atoms are interpreted as their negated complements, and the precise re-\nlationship is left for further study. However, we also believe that rewriting a generalized atom into its negated complement is not always natural, and we are also not convinced that there should be a semantic difference between a generalized atom and its negated complement.\nThe second part of the paper concerns the question of compactly compiling generalized atoms away, to arrive at a program that contains only traditional atoms whose answer sets are in a one-to-one correspondence with the original program. Previously existing complexity results indicated that such a translation can exist, but that it has to make use of disjunction in rule heads. However, no such method is currently known. We show that similar techniques can be used for both FLP and the new SFLP semantics when non-convex aggregates are represented in disjunctive normal form.\nConcerning future work, implementing a reasoner supporting the new semantics would be of interest. However, we believe that it would actually be more important to collect example programs that contain non-convex generalized atoms in recursive definitions. We have experimented with a few simple domains stemming from game theory (as outlined in the introduction), but we are not aware of many other attempts. Our intuition is that such programs would be written in several domains that describe features with feedback loops, which applies to many so-called complex systems. Also computing or checking properties of neural networks might be a possible application in this area. Another, quite different application area could be systems that loosely couple OWL ontologies with rule bases, for instance by means of HEX programs. HEX atoms interfacing to ontologies will in general not be convex, and therefore using them in recursive definitions falls into our framework, where the FLP and SFLP semantics differ.\nAnother area of future work arises from the fact that rules like a \u2190 a are not irrelevant for the SFLP semantics. To us, it is not completely clear whether this is a big drawback. However, we intend to study variants of the SFLP semantics that do not exhibit this peculiarity."}], "references": [{"title": "and Faber", "author": ["M. Alviano"], "venue": "W.", "citeRegEx": "Alviano and Faber 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "External sources of knowledge and value invention in logic programming", "author": ["Cozza Calimeri", "F. Ianni 2007] Calimeri", "S. Cozza", "G. Ianni"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "Calimeri et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2007}, {"title": "K", "author": ["Clark"], "venue": "L.", "citeRegEx": "Clark 1978", "shortCiteRegEx": null, "year": 1978}, {"title": "Aggregate Functions in Disjunctive Logic Programming: Semantics, Complexity, and Implementation in DLV", "author": ["Dell\u2019Armi"], "venue": null, "citeRegEx": "Dell.Armi,? \\Q2003\\E", "shortCiteRegEx": "Dell.Armi", "year": 2003}, {"title": "Combining Answer Set Programming with Description Logics for the Semantic Web", "author": ["Eiter"], "venue": "In Principles of Knowledge Representation and Reasoning: Proceedings of the Ninth International Conference", "citeRegEx": "Eiter,? \\Q2004\\E", "shortCiteRegEx": "Eiter", "year": 2004}, {"title": "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer Set Programming", "author": ["Eiter"], "venue": "In International Joint Conference on Artificial Intelligence (IJCAI)", "citeRegEx": "Eiter,? \\Q2005\\E", "shortCiteRegEx": "Eiter", "year": 2005}, {"title": "Design and implementation of aggregate functions in the dlv system. Theory and Practice of Logic Programming 8(5\u20136):545\u2013580", "author": ["Faber"], "venue": null, "citeRegEx": "Faber,? \\Q2008\\E", "shortCiteRegEx": "Faber", "year": 2008}, {"title": "Recursive aggregates in disjunctive logic programs: Semantics and complexity", "author": ["Leone Faber", "W. Pfeifer 2004] Faber", "N. Leone", "G. Pfeifer"], "venue": "Proceedings of the 9th European Conference on Artificial Intelligence (JELIA 2004),", "citeRegEx": "Faber et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2004}, {"title": "Semantics and complexity of recursive aggregates in answer set programming. Artificial Intelligence 175(1):278\u2013298", "author": ["Leone Faber", "W. Pfeifer 2011] Faber", "N. Leone", "G. Pfeifer"], "venue": "Special Issue: John McCarthy\u2019s Legacy", "citeRegEx": "Faber et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2011}, {"title": "Answer Sets for Propositional Theories", "author": ["P. Ferraris"], "venue": "Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference,", "citeRegEx": "Ferraris,? \\Q2005\\E", "shortCiteRegEx": "Ferraris", "year": 2005}, {"title": "and Truszczy\u0144ski", "author": ["L. Liu"], "venue": "M.", "citeRegEx": "Liu and Truszczy\u0144ski 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "and Simons", "author": ["I. Niemel\u00e4"], "venue": "P.", "citeRegEx": "Niemel\u00e4 and Simons 2000", "shortCiteRegEx": null, "year": 2000}, {"title": "Stable Model Semantics of Weight Constraint Rules", "author": ["Simons Niemel\u00e4", "I. Soininen 1999] Niemel\u00e4", "P. Simons", "T. Soininen"], "venue": "Proceedings of the 5th International Conference on Logic Programming and Nonmonotonic Rea-", "citeRegEx": "Niemel\u00e4 et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Niemel\u00e4 et al\\.", "year": 1999}, {"title": "Well-founded and Stable Semantics of Logic Programs with Aggregates", "author": ["Denecker Pelov", "N. Bruynooghe 2007] Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "Theory and Practice of Logic Programming", "citeRegEx": "Pelov et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Pelov et al\\.", "year": 2007}, {"title": "and Pontelli", "author": ["T.C. Son"], "venue": "E.", "citeRegEx": "Son and Pontelli 2007", "shortCiteRegEx": null, "year": 2007}], "referenceMentions": [], "year": 2014, "abstractText": "Answer Set Programming (ASP) is logic programming under the stable model or answer set semantics. During the last decade, this paradigm has seen several extensions by generalizing the notion of atom used in these programs. Among these, there are aggregate atoms, HEX atoms, generalized quantifiers, and abstract constraints. In this paper we refer to these constructs collectively as generalized atoms. The idea common to all of these constructs is that their satisfaction depends on the truth values of a set of (non-generalized) atoms, rather than the truth value of a single (non-generalized) atom. Motivated by several examples, we argue that for some of the more intricate generalized atoms, the previously suggested semantics provide unintuitive results and provide an alternative semantics, which we call supportedly stable or SFLP answer sets. We show that it is equivalent to the major previously proposed semantics for programs with convex generalized atoms, and that it in general admits more intended models than other semantics in the presence of non-convex generalized atoms. We show that the complexity of supportedly stable models is on the second level of the polynomial hierarchy, similar to previous proposals and to stable models of disjunctive logic programs. Given these complexity results, we provide a compilation method that compactly transforms programs with generalized atoms in disjunctive normal form to programs without generalized atoms. Variants are given for the new supportedly stable and the existing FLP semantics, for which a similar compilation technique has not been known so far.", "creator": "LaTeX with hyperref package"}}}