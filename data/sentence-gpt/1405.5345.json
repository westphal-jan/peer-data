{"id": "1405.5345", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-May-2014", "title": "HATP: An HTN Planner for Robotics", "abstract": "Hierarchical Task Network (HTN) planning is a popular approach that cuts down on the classical planning search space by relying on a given hierarchical library of domain control knowledge. This provides an intuitive methodology for specifying high-level instructions on how robots and agents should perform tasks, while also giving the planner enough flexibility to choose the lower-level steps and their ordering. In this paper we present the HATP (Hierarchical Agent-based Task Planner) planning framework which extends the traditional HTN planning domain representation and semantics by making them more suitable for roboticists, and treating agents as \"first class\" entities in the language of high-level knowledge. This will focus on the classification of agents as \"second class\" entities and how they could be assigned to them based on information provided by the HATP (Hierarchical Agent-based Task Planner) planner. We propose a single hierarchical system based on HATP (Hierarchical Agent-based Task Planner) that uses a hierarchy structure similar to the HTN planning framework: hierarchical data sets and hierarchies, including class names, and lists. The hierarchy structure should be in a hierarchical, hierarchical, and modular order, where it can be used to store the entire hierarchy and subgroups for the agent.\n\n\n\n\nThe HATP (Hierarchical Agent-based Task Planner) planning framework is an elegant, concise, and simple framework. We propose a hierarchical system based on HATP (Hierarchical Agent-based Task Planner) planner. This framework allows for the development of a hierarchical, hierarchical, and modular network with the understanding of the roles of each agent. Hierarchical, hierarchical, and modular networks in which they can be assigned to them by specific class names should be represented as the following.\nThe HATP (Hierarchical Agent-based Task Planner) planner. This framework provides information about the specific roles of each agent and the agent by their hierarchical roles. Hierarchical, hierarchical, and modular networks in which they can be assigned to them by specific class names should be represented as the following. Hierarchical, hierarchical, and modular networks in which they can be assigned to them by specific class names should be represented as the following.\nThe HATP (Hierarchical Agent-based Task Planner) planner. This framework allows for the development of a hierarchical, hierarchical, and modular network with the understanding of the roles of each", "histories": [["v1", "Wed, 21 May 2014 09:32:15 GMT  (170kb,D)", "https://arxiv.org/abs/1405.5345v1", "2nd ICAPS Workshop on Planning and Robotics, PlanRob 2014"], ["v2", "Thu, 12 Jun 2014 13:53:15 GMT  (170kb,D)", "http://arxiv.org/abs/1405.5345v2", "2nd ICAPS Workshop on Planning and Robotics, PlanRob 2014"]], "COMMENTS": "2nd ICAPS Workshop on Planning and Robotics, PlanRob 2014", "reviews": [], "SUBJECTS": "cs.RO cs.AI", "authors": ["rapha\\\"el lallement", "lavindra de silva", "rachid alami"], "accepted": false, "id": "1405.5345"}, "pdf": {"name": "1405.5345.pdf", "metadata": {"source": "CRF", "title": "HATP: An HTN Planner for Robotics", "authors": ["Rapha\u00ebl Lallement", "Lavindra de Silva", "Rachid Alami"], "emails": [], "sections": [{"heading": "Introduction", "text": "Real-world robotics domains and problems offer natural testbeds for HTN (Hierarchical Task Network) planning. The intuitive hierarchical representation used by such planners allows the often available expert knowledge about a domain to be included with relative ease to guide the search process. This guidance might be abstract steps detailing how a task, such as cleaning a table full of different types of objects, should be performed by the robot, with sufficient flexibility over the more detailed steps and states\u2014e.g. the final locations of objects on the shelf. In practice, the inclusion of such search control knowledge makes HTN planning faster than classical planning, which is particularly important when dealing with robots as they need to be responsive to environmental changes involving other robots, and more importantly, humans.\nIn this paper we describe the HATP (Hierarchical Agentbased Task Planner) HTN planner and show how it is partic-\n1This work has been conducted within the EU ARCAS project (http://www.arcas-project.eu/) funded by the E.C. Division FP7IST under Contract ICT 287617. We thank the anonymous reviewers for their feedback. The second author has now moved to The University of Nottingham, Nottingham, UK.\nularly suited for use in robotics. HATP is based on SHOP (Nau et al. 1999), but unlike this planner and other HTN planners such as Nonlin (Tate 1976), SHOP2 (Nau et al. 2003) and UMCP (Erol, Hendler, and Nau 1994), HATP offers a user-friendly domain representation language inspired by popular programming languages, making it easier for roboticists, and indeed computer scientists alike, to become quickly acquainted with the syntax and semantics. We give insights into a formal mapping from this HATP language into an equivalent classical representation, but leave the detailed treatment for a separate paper.\nAn important feature of HATP is that it treats agents as \u201cfirst-class entities\u201d in the domain representation language. It can therefore distinguish between the different agents in the domain as well as between agents and the other entities such as tables and chairs. This facilitates a post-processing step in HATP that splits the final solution (sequence of actions) into multiple synchronised solution streams, one per agent, so that the streams may be executed in parallel by the respective agents by synchronising when necessary.\nThe planning algorithm of HATP has also been extended in various ways. First, it incorporates a simple mechanism to take into account the (user-defined) cost of executing actions, so that instead of returning the first arbitrary solution found, it keeps searching until an optimal (least-cost) one is found.2 Second, HATP has been extended to be more suitable for Human-Robot Interaction (HRI); in particular, \u201csocial rules\u201d can be included by the user to define what the acceptable (and unacceptable) behaviours of the agents are. Two examples are: what sequences of steps should be avoided in final solutions, and a limit on the amount of time a person should spend waiting (and doing nothing). The rules are then used to filter out the primitive solutions found that do not meet the constraints.\nFinally, there is much ongoing work on interleaving HATP with geometric planning algorithms, so as to validate online the actions being pursued by HATP, by consulting its geometric counterpart. This results in motion planning being performed by the geometric planner to check if the HATP action being planned is actually feasible in\n2The notion of optimality here is \u201clocal\u201d: HATP finds an optimal solution only from the set of HATP solutions obtained using the given methods.\nar X\niv :1\n40 5.\n53 45\nv2 [\ncs .R\nO ]\n1 2\nJu n\n20 14\nPlanning and Robotics (PlanRob) ICAPS-Workshop, Portsmouth, USA, 2014 the real world, modelled in great detail via the Move3D (Sime\u0301on, Laumond, and Lamiraux 2001) simulation environment. This integration takes an important step towards interfacing HATP\u2019s AI planning algorithms and techniques with the planning algorithms and techniques more commonly used by roboticists. In this paper we summarise all of these extensions to HATP, and explicate how they make HATP particularly suited for the Robotics community."}, {"heading": "HTN Planning", "text": "While classical planners such as STRIPS focus on achieving some goal state, Hierarchical Task Network (HTN) planners focus on solving abstract tasks. We have found HTN planning to be particularly useful for robotics applications, as it allows\u2014the often available\u2014instructions from the domain expert to be included in the domain as an intuitive hierarchy. This helps guide the search, making it faster in general than classical planning approaches, and thereby also more practical for real robots that need to be responsive to environmental changes.\nThe Hierarchical Agent-based Task Planner (HATP) is based on the popular \u201ctotally-ordered\u201d HTN planning approach, which unlike \u201cpartially-ordered\u201d HTN planning allows calls to external functions\u2014a necessity in our work. This is also highlighted as a feature in the SHOP (Nau et al. 1999) planner, on which HATP is based. The rest of this section focusses on totally-ordered HTN planning.\nWe define an HTN planning problem as the 3-tuple \u3008d, s0,D\u3009, where d, the \u201cgoal\u201d to achieve, is a sequence of primitive or abstract tasks, s0 is the initial state, and D is an HTN planning domain. An operator is as in classical planning, and actions are ground instances of operators. We generally use the terms operator and action interchangeably in this paper. An HTN planning domain is the pair D = \u3008A,M\u3009 where A is a finite set of operators, and M is a finite set of HTN methods. A method is a 4-tuple consisting of: the name of the method, the abstract task that it needs to solve, a precondition specifying when the method is applicable, and a body realising the \u201cdecomposition\u201d of the task associated with the method into more specific subtasks. Specifically, the method-body is a sequence of primitive and/or abstract tasks.\nThe HTN planning process works by selecting applicable methods from M and applying them to abstract tasks in d in a depth-first manner. In each iteration, this will typically result in d becoming a \u201cmore primitive\u201d sequence of tasks. The process continues until d has only primitive tasks left, which map to action names. At any stage during planning if no applicable method can be found for an abstract task, the planner essentially \u201cbacktracks\u201d and tries an alternative method for an abstract task refined earlier.\nIn more detail, the main steps of the HTN planning process are the following: in each iteration all ground instances are found of the methods available to decompose a chosen task from task network d; one such method instance is chosen arbitrarily that is applicable (whose precondition holds) in the current state of the world; and the instance is applied to d by basically replacing the chosen task with the subtasks in the method\u2019s body. The planner backtracks to choose an\nalternative method instance to one that was previously applied to d only if that method instance did not eventually allow a complete (and successful) decomposition of the toplevel goal task(s)."}, {"heading": "Features of HATP", "text": "In this section we present our own encoding in HATP of the Dock-Worker Robots domain (Nau, Ghallab, and Traverso 2004). In this domain, there is a robot (R1) that can move and carry containers, and two crane-agents (K1 and K2) that can lift and put down containers. Furthermore, there are two locations (L1 and L2), each containing two piles (P11 and P12 at L1, and P21 and P22 at L2) that can hold containers. The goal is to place the two containers C1 and C2 on piles P21 and P22, respectively."}, {"heading": "World state representation", "text": "In addition to having the standard advantages of total-order HTN planning, HATP also provides an intuitive objectoriented-like syntax for representing and manipulating the world state. This allows roboticists and computer scientists alike to quickly get acquainted with the syntax and start developing HATP domains.\nThe HATP world specification is defined as a collection of entities, which represent the agent types and object types in the world. This distinction between agents and other objects is important. Agents are treated as first class entities in the language of HATP; moreover, different types of agents may be defined by simply instantiating the default Agent entity. This distinction also facilitates a post-processing step in HATP, which splits the final solution into separate subsolutions to be executed by the respective agents.\nAn entity has a set of attributes, where an attribute either represents a data value, or a relation between the entity and other entities. For example, a robot-agent may have an attribute carry of type Container indicating that the robot can carry objects of type Container. HATP supports some of the standard data types found in programming languages, such as integers and strings, and also allows defining sets of objects, which are manipulated using the standard set operations. An example of an HATP world specification is shown in listing 1.\nPlanning and Robotics (PlanRob) ICAPS-Workshop, Portsmouth, USA, 2014\ndefine entityType Crane, Location, Pile, Container;\ndefine entityAttributes Agent { //An agent can be of type Robot or Crane static atom string type;\n//For cranes static atom Location attached;\n//For robots dynamic atom Location at; dynamic atom Container carry; dynamic atom bool loading;\n}\ndefine entityAttributes Location { static set Location adjacent; dynamic atom bool occupied; }\ndefine entityAttributes Pile { static atom Location attached; dynamic set Container contains; dynamic atom Container top; }\ndefine entityAttributes Container { dynamic atom Location in; dynamic atom Container on; }\nListing 1: HATP entities for the Dock-Worker Robot domain in figure 1. There are five entity types: Agent (default entity), Crane, Location, Pile and Container. The initial value assigned to a static attribute cannot change during planning, whereas a dynamic attribute can be assigned different values over the course of planning. An attribute classified as an atom can only have one value, whereas one classified as a set can have a set of values. The type of an attribute can be any of the primitive types allowed as well as an entity.\nThe HATP initial world state is then an instantiation of the defined entities, along with value assignments to their attributes. An example of an HATP initial world state is shown in listing 2. Notice that attributes of entities generally map to predicate symbols in standard \u201cclassical\u201d initial states, and the entities and values to the parameters of the predicate. For example, K1.attached = L1 could map to predicate attached(K1,L1) in a classical initial state, R1.loading = false to \u00acloading(R1), and R1.carry = NULL could be represented in the classical initial state by not including any positive literal in it that has predicate symbol carry, with R1 as its first parameter.\nR1, K1, K2 = new Agent; L1, L2 = new Location; P11, P12, P21, P22 = new Pile; C1, C2 = new Container;\nR1.type = \u2018\u2018ROBOT\u2019\u2019; R1.at = L1; R1.carry = NULL; R1.loading = false;\nK1.type = \u2018\u2018CRANE\u2019\u2019; K1.attached = L1;\nK2.type = \u2018\u2018CRANE\u2019\u2019; K2.attached = L2;\nL1.adjacent <<= L2; L1.occupied = true; L2.adjacent <<= L1; L2.occupied = false;\nP11.attached = L1; P11.contains <<= C1; P11.top = C1; P12.attached = L1; P12.contains <<= C2; P12.top = C2; P21.attached = L2; P22.attached = L2;\nC1.in = L1; C1.on = NULL; C2.in = L1; C2.on = NULL;\nListing 2: An HATP initial state for the Dock-Worker Robot domain. After instantiating the entity types, their attributes are assigned initial values. Note that symbol \u201c<<=\u201d is used to add the element on its RHS to the set on its LHS."}, {"heading": "Domain representation", "text": "As in standard HTN planning, an HATP domain consists of a set of methods and a set of operators. These are written similarly to traditional HTN domains with the exception where the HATP language offers some user-friendly constructs for defining preconditions of methods and operators, bodies of methods and effects of operators. In particular, variables are defined in HATP methods, and their bindings controlled, via the following constructs; examples of their use can be found in listing 3.\n\u2022 SELECT binds the given variable in the usual way. In essence, the construct amounts to a \u201cbacktrack point\u201d that allows all values of the associated variable\u2014and thereby all ground instances of the method\u2014to be considered.\n\u2022 SELECTORDERED binds the variable in some given order, governed by a user-supplied ordering relation. Moreover, the variable can be bound in ascending or descending order with respect to the relation.\n\u2022 SELECTONCE binds the variable only once\u2014the remaining bindings are disregarded. This offers a reduction in the branching factor at the expense of completeness, as some of the ignored bindings may also yield HATP solutions.\nWhile the last construct may result in the loss of HATP solutions, this heuristic is useful in domains where if a solution pursued by taking one binding of the variable\u2014and applying the resulting ground instance of the HATP method\u2014turns out to not work, then no other binding for that variable will work either. For example, imagine a slightly different DockWorker Robot domain/problem that has multiple robots, and where taking the shortest path during navigation is not important. This means that if one robot cannot navigate from one location to another, then none of the others will be able\nPlanning and Robotics (PlanRob) ICAPS-Workshop, Portsmouth, USA, 2014 to either. Therefore, there is no need to consider all possible robot-agent bindings as done in listing 3: a single binding will be sufficient.\nmethod Transport(Container C, Pile Target) { // do nothing if container is in target pile empty{C.in == Target;}; {\npreconditions { // container not already in target location EXIST(Pile Source2, {C.in == Source2;}, {Source2.attached != Target.attached;}); }; subtasks {\nS = SELECT(Pile, {C.in == S;}); R = SELECTORDERED(Agent, {R.type == \u2018\u2018ROBOT\u2019\u2019;},\ndistance(R.at, S.attached), <); K1 = SELECT(Agent,\n{K1.type == \u2018\u2018CRANE\u2019\u2019; K1.at == S.attached;}); K2 = SELECT(Agent,\n{K2.type == \u2018\u2018CRANE\u2019\u2019; K2.at == Target.attached;}); 1: GetReady(R, C, S); 2: LoadRobot(K1, R, C)>1; 3: NavFromTo(R, S.attached, Target.attached)>2; 4: UnloadRobot(K2, R, C)>3; 5: Put(K2, C, Target)>4;\n}; ...\n}\nListing 3: Part of an HATP method to move a container from a source pile to a target pile in a different location. Note that distance is a user-supplied ordering relation; \u201c<\u201d means that the variable bindings should be in descending order; and \u201cN1 : T > N2;\u201d means that task T (labelled N1) must precede the task labelled N2.\nObserve from listing 3 that, as expected, the subtasks within the method\u2019s body are totally ordered. HATP, however, also allows partially ordering subtasks; this is achieved by not specifying ordering constraints between some (or all) of the tasks in the method\u2019s body. For example, removing constraint \u201c> 2\u201d from the method in listing 3 would then not require that the task with label 3 occur after the one with label 2. Note that such partial ordering of tasks is merely a convenience: it is an alternative to supplying multiple totally-ordered methods corresponding to every possible linearisation of the partially ordered subtasks. This is exactly what happens during planning: the set of partially ordered subtasks in a method\u2019s body is handled by taking all possible linearisations of the set, essentially creating additional HATP method options to consider for the parent task\u2019s decomposition. Since partially ordering subtasks results in an exponential increase in the number of method options, it should be used with appropriate care. Introducing \u201ctrue\u201d partially-ordered planning into HATP is left as future work: the algorithms are not obvious as we want to have the ability to use evaluable predicates in preconditions, for which maintaining the complete state of the world at each step of the planning process is the obvious solution (Nau et al. 1999).\nSome other useful constructs supported by HATP are EXIST, IF, and FORALL. As in other HTN planners such as SHOP, construct EXIST is used only in preconditions of methods and operators; IF only in the effects of operators;\nand FORALL in both preconditions of methods and operators, as well as in the effects of operators. Examples of how these constructs may be used are shown in listings 3 and 4.\naction Move( Agent R, Location From, Location To, Location FinalDest) { preconditions {\nR.type == \u2018\u2018ROBOT\u2019\u2019; To >> From.adjacent; R.at == From; To.occupied == false;\n}; effects {\nR.at = To; From.occupied = false; To.occupied = true; R.path <<= To; IF{From !>> R.path;}{R.path <<= From;} IF{To.isForbiddenBy == R;}{To.isForbiddenBy = NULL;} IF{To == FinalDest;}{\nFORALL(Location LocP, {LocP >> R.path;},{R.path =>> LocP;});\n} }; cost{costToMove(From, To)};\n}\nListing 4: An HATP operator. The expression \u201cA >> B.attr\u201d holds if element A is in the set B.attr, and the expression\u2019s negation is specified using \u201cA! >> B.attr\u201d. Expression \u201cB.attr <<= A\u201d adds element A to set B.attr, and \u201cB.attr =>> A\u201d removes A from B.attr."}, {"heading": "Plan production", "text": "HATP is able to find the least-cost primitive solution that solves the goal task(s) at hand, as done for example in (Nau et al. 2003). To this end, HATP keeps track of the leastcostly plan computed so far, as well as the total cost of the current partial plan being pursued, and then avoids adding any action to it that will definitely lead to a costlier partial plan. Indeed, in the worst case this requires looking through all HATP solutions for the given goal task(s). Moreover, since the HATP search space is governed by the methods supplied, there may be other low-cost solutions (corresponding to methods not supplied) that HATP does not take into account.\nThe cost of the partial plan is computed via \u201ccost functions\u201d. A cost function is a user-supplied C++ function that is linked to an HATP operator as shown at the bottom of listing 4. The function can perform any arbitrary calculation to estimate the cost of executing the action; however, for efficiency reasons the function should terminate quickly. An example of such a function is one that computes the cost of executing an action to send data from one robot to another. This might involve checking how much data needs to be sent and thereby how much time it would take to do the transfer.\nBy using cost functions associated with the sequence of primitive actions pursued so far, HATP determines the total cost of the sequence, and avoids pursuing it further if by adding the next action the total cost would exceed the cost of the lowest-cost solution found so far.\nOnce HATP finds a solution\u2014a sequence of primitive actions\u2014it then splits the solution into multiple \u201cstreams\u201d,\nPlanning and Robotics (PlanRob) ICAPS-Workshop, Portsmouth, USA, 2014 one per agent in the domain, and adds causal links between streams for synchronisation (Alami et al. 2011). To determine which actions in the final solution belong to which agents, the HATP language reserves the first variable of every operator\u2019s name: it must always bind to the name of the agent responsible for eventually executing the operator. The second and subsequent variables of an operator\u2019s name may also be used as placeholders for agent names if necessary. Such an operator would then be a \u201cjoint operator\u201d: one that needs to be executed in parallel by all the robots/agents that it refers to.\nOnce the different streams are separated, they may then be executed. The stream (if any) belonging to the agent that formulated the plan may be executed by the agent directly, whereas actions in other streams need to be delegated to their respective agents, and the environment monitored to determine if the actions were successfully executed. Figure 2 shows a plan produced for the Dock-Worker Robots problem depicted in figure 1 with different streams belonging to the different agents in the domain.\nNote that in the case of joint operators, all the agents involved need a \u201cstronger\u201d synchronisation than what causal links entail. For instance in a robot-robot synchronisation they may need to set some rendezvous points so as to exchange information just before starting. This may also involve visual servoing, both in robot-robot and human-robot joint operators."}, {"heading": "HATP in an HRI context", "text": "As highlighted by (Alili, Alami, and Montreuil 2009) one challenge in robotics is to develop socially interactive and cooperative robots. The meaning of socially interactive robots is defined in (Fong, Nourbakhsh, and Dautenhahn 2003) which states that they must \u201coperate as partners, peers or assistants, which means that they need to exhibit a certain degree of adaptability and flexibility to drive the interaction with a wide range of humans\u201d. (Klein et al. 2004) implemented that in what they called \u201cten challenges for human robot teamwork\u201d. We are convinced that task planners can take care of several of these challenges. In this case the robot should be able to (Klein et al. 2004): (1) signal in what tasks it can/wants to participate; (2) act in a predictable way to ensure human understanding of what it is doing; (3) publicise its status and its intentions; (4) negotiate on tasks with its human partner in order to determine roles and decide how to perform the tasks; and (5) deal with social conventions, as well as its human partner\u2019s abilities and preferences.\nTo address some of those challenges HATP includes mechanisms to filter plans so as to keep only those suitable for HRI. To this end, HATP allows the specification of the following filtering criteria.\nWasted time: Avoids plans where an agent(s) mentioned in a plan spends a lot of its time waiting.\nEffort balancing: Avoids plans where efforts are not fairly distributed among the agents mentioned in a plan.\nControl of intricacy: Avoids plans with too many interdependencies between the actions of agents mentioned in\nthe plan, as a problem with executing just one of those actions could invalidate the entire plan.\nUndesirable sequences: Avoids plans that violate specific user-defined sequences.\nCombining some of the above criteria could help yield the following interesting behaviours: (1) the human ends up doing a lot of the tasks, but yet the overall effort (Alili, Alami, and Montreuil 2009) taken to do them is significantly lower than what the robot puts to do a lower number of effort-intensive tasks; (2) avoiding, when possible, having the human wait for the robot several times, which essentially prevents the streams from having too many causal links between them. The filtering criteria are implemented by looking through all the plans produced and filtering out the ones that do not meet the requirements specified. In the future we intend to study algorithms that do such filtering online, rather than after primitive solutions are found.\nInterleaving with geometric reasoning While an HTN hierarchy allows one to intuitively reason about high-level tasks such as Transport in terms of more specific tasks, and eventually in terms of basic actions, these still \u201cabstract out\u201d the lowest possible level of detail by making certain assumptions about the world. For example, HATP operator Move in listing 4 assumes that as long as location To is adjacent to location From, and To is not occupied, that the robot at From will be able to navigate to location To. Clearly, this may not always work for various reasons, such as there being an obstacle in the path, or certain geometrical characteristics of the robot and the connecting path making the move physically impossible. Combining HATP\u2014and symbolic/task planning in general\u2014with the geometric planning algorithms used in robotics is therefore essential to be able to obtain primitive solutions that are viable in the real world.\nThe work in (de Silva, Pandey, and Alami 2013; de Silva et al. 2014; 2013) proposes an interface between HATP and a geometric planner. This interface is mainly provided via \u201cevaluable predicates\u201d\u2014predicates in HATP preconditions that are evaluated by calling associated external procedures. Such a predicate evaluating to true amounts to a geometric solution existing for the \u201cgeometric task\u201d that the predicate represents, and evaluating to false amounts to the nonexistence of such a solution. For example, the precondition of an HATP action that gives an object to a person might have an evaluable predicate that invokes the geometric planner to check the feasibility of the task of giving the object to the person, and to store the resulting geometric trajectory if any. This notion of a geometric task is something that is both important in order to have a meaningful link between the two planning approaches, and also specific to the type of geometric planner used. A geometric task essentially corresponds to one or more motion planning goal-configurations, computed (automatically) by the geometric planner by taking into account various criteria such as the visibility and reachability of objects from the perspectives of different robots and humans in the domain. Aptly called Geometric Task Planner (GTP) (Pandey et al. 2012), this planner liberates\nHATP from having to reason in terms of low-level details such as grasps and orientations. Using this particular planner for forming the link with HATP also makes the interface proposed different to other interfaces in the literature, such as (Dornhege et al. 2009b; 2009a; Karlsson et al. 2012; Lagriffoul et al. 2012).\nThe interface between HATP and the GTP is used to interleave their planning algorithms. In one approach, whenever the GTP is invoked by HATP while testing an evaluable predicate, the non-existence of a GTP solution for the associated geometric task (from the current geometric world state) does not lead to the predicate evaluating to false; instead, the GTP backtracks to try alternative solutions for the previously invoked geometric tasks in an effort to make a solution possible for the most recently invoked one. Since this may cause changes to intermediate geometric world states, this approach comes with mechanisms to ensure that such changes do not affect the symbolic world state in a way that invalidates the HATP plan being pursued. Such mechanisms are, however, not necessary in the second approach to interleaved planning that the authors present. Here, whenever the GTP cannot find a solution for a geometric task, it does not\u2014as before\u2014backtrack to find alternatives for previous geometric tasks, but instead immediately returns with \u201cfailure\u201d. If this leads to HATP backtracking, HATP then has the option to try, intuitively, a different \u201cinstance\u201d of the action that needs to be \u201cundone\u201d as a consequence of the backtrack (in addition to the standard option of trying different actions); this different \u201cinstance\u201d is basically the same HATP action that needs to be undone, but this time with a different geometric solution attached to it.\nAn interesting feature of the GTP is its ability to plan not just the robots\u2019 tasks/actions but also the humans\u2019, by taking into account their respective kinematic models. This makes way for the multiple robots/agents defined in an HATP domain to have a clear association with those defined in the GTP domain. For example, figure 3 shows a simplified library domain (de Silva et al. 2014) where a PR2 robot serves a human customer, consisting of both human and robot actions. While the PR2-actions will be planned by the GTP from the perspective of the PR2 (using its kinematic model), those of the human, which involve paying and taking a book, will be planned from the human\u2019s perspective."}, {"heading": "The planning and execution architecture", "text": "Both HATP and the GTP are part of the larger LAAS robotics architecture (Fleury, Herrb, and Chatila 1997; Alami et al. 2011). This architecture has many components. It uses the Move3D (Sime\u0301on, Laumond, and Lamiraux 2001) motion and manipulation planner for representing the robot\u2019s version of the real world in 3D and for doing geometric task planning. Through various sensors the robot can also update its 3D world state in real-time. To this end, a tagbased stereo vision system is used for object identification and localisation, and a Kinect (Microsoft) sensor for localising and tracking the human. The execution controller\u2014the Procedural Reasoning System (PRS)(Ingrand et al. 1996)\u2014 is responsible for invoking HATP when a task needs to be planned, and also executing the resulting primitive solution returned by HATP by invoking various actuators via the interface provided by Genom (Fleury, Herrb, and Chatila 1997) to the low-level controllers, which is also the framework used to wrap them into individual well-defined modules.\nIn the current architecture, PRS receives goals from the environment, which it validates by checking for things such as whether the goal has already been achieved. If the goal is valid, it is sent as a task to HATP. If HATP (possibly together with the GTP) successfully returns a solution, it is then executed by PRS, by directly executing the robot\u2019s actions and indicating in the right order to other agents, via a dialogue module, what actions they need to execute. To execute an action directly, PRS sends requests to the relevant Genom modules which may result in the robot or an arm moving, for example. Indeed, the Genom modules may actually execute the trajectories found and stored by the GTP if it was invoked by HATP during the planning process. PRS is also able to confirm whether the robot\u2019s actions and those of the other agents were successfully executed, by examining the current state of the (symbolic and geometric) world."}, {"heading": "Conclusion and future work", "text": "We have described in this paper the HATP HTN planner, which has been used extensively for practical robotics applications in the LAAS architecture (Alami et al. 1998) over many years (Alili, Alami, and Montreuil 2009; Guitton, Warnier, and Alami 2012; Warnier et al. 2012; de Silva, Pandey, and Alami 2013; de Silva et al. 2014). We have focussed on describing how HATP is suited for not just HTN planning but also planning in the context of Human-Robot\nInteraction, in a multi-agent setting consisting of multiple humans and robots. This was based on two main extensions to HATP: the ability to handle user-supplied \u201csocial rules\u201d that specify what is appropriate behaviour for the agents in the domain; and interleaving the HATP planning algorithm with geometric planning algorithms from the robotics community. We have also presented the advantages of the userfriendly syntax and semantics of HATP using our own encoding of the Dock Worker Robot domain described in (Nau, Ghallab, and Traverso 2004).\nThere has also been some initial efforts toward extending HATP to support separately modelling the beliefs of the different agents in the domain (Alami et al. 2011). This allows reasoning about what the different agents know, including finding conflicting beliefs, and synchronising beliefs by planning to notify agents when there are inconsistencies between their beliefs. Other interesting work on HATP that is currently underway is formalising its domain representation language to show its relation with more traditional representations such as that used by the SHOP planner (Nau et al. 1999). Indeed, this involves developing a mapping from the syntax and notions of HATP to PDDL-like syntax and notions.\nIn terms of the link between HATP and the GTP, it would be interesting to compare the two different combined backtracking strategies. As the authors in (de Silva et al. 2014) have stated, this would require completing the implementation of the system presented in (de Silva, Pandey, and Alami 2013) so that it may be compared empirically with the sys-\ntem in (de Silva et al. 2014). An analytical evaluation would also be useful to understand in what situations/domains one combined backtracking approach should be favoured over the other. Finally, modifying HATP to interleave planning with execution to make HATP more \u201cresponsive\u201d to changes in the environment would make it even more suitable for real-world robotics applications (de Silva et al. 2014)."}], "references": [{"title": "An architecture for autonomy", "author": ["R. Alami", "R. Chatila", "S. Fleury", "M. Ghallab", "F. Ingrand"], "venue": "Internatonal Journal of Robotics Research, Special Issue on Integrated Architectures for Robot Control and Programming, volume 17, 315\u2013337.", "citeRegEx": "Alami et al\\.,? 1998", "shortCiteRegEx": "Alami et al\\.", "year": 1998}, {"title": "When the robot considers the human.", "author": ["R. Alami", "M. Warnier", "J. Guitton", "S. Lemaignan", "E.A. Sisbot"], "venue": "In Proceedings of the 15th International Symposium on Robotics Research", "citeRegEx": "Alami et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Alami et al\\.", "year": 2011}, {"title": "A Task Planner for an Autonomous Social Robot", "author": ["S. Alili", "R. Alami", "V. Montreuil"], "venue": "Distributed Autonomous Robotic Systems 8, 335\u2013344. Springer Berlin Heidelberg.", "citeRegEx": "Alili et al\\.,? 2009", "shortCiteRegEx": "Alili et al\\.", "year": 2009}, {"title": "Towards combining HTN planning and geometric task planning", "author": ["L. de Silva", "A.K. Pandey", "M. Gharbi", "R. Alami"], "venue": "In RSS Workshop on Combined Robot Motion Planning and AI Planning for Practical Applications", "citeRegEx": "Silva et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Silva et al\\.", "year": 2013}, {"title": "A new approach to combined symbolic-geometric", "author": ["L. de Silva", "M. Gharbi", "A.K. Pandey", "R. Alami"], "venue": null, "citeRegEx": "Silva et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Silva et al\\.", "year": 2014}, {"title": "An interface for interleaved symbolic-geometric planning and backtracking", "author": ["L. de Silva", "A.K. Pandey", "R. Alami"], "venue": "In IROS,", "citeRegEx": "Silva et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Silva et al\\.", "year": 2013}, {"title": "Semantic Attachments for DomainIndependent Planning Systems", "author": ["C. Dornhege", "P. Eyerich", "T. Keller", "S. Tr\u00fcg", "M. Brenner", "B. Nebel"], "venue": "ICAPS, 114\u2013121.", "citeRegEx": "Dornhege et al\\.,? 2009a", "shortCiteRegEx": "Dornhege et al\\.", "year": 2009}, {"title": "Integrating Symbolic and Geometric Planning for Mobile Manipulation", "author": ["C. Dornhege", "M. Gissler", "M. Teschner", "B. Nebel"], "venue": "IEEE International Workshop on Safety, Security and Rescue Robotics, 1\u20136.", "citeRegEx": "Dornhege et al\\.,? 2009b", "shortCiteRegEx": "Dornhege et al\\.", "year": 2009}, {"title": "UMCP: A sound and complete procedure for hierarchical task-network planning", "author": ["K. Erol", "J. Hendler", "D. Nau"], "venue": "International Conf. on AI Planning Systems, 249\u2013 254.", "citeRegEx": "Erol et al\\.,? 1994", "shortCiteRegEx": "Erol et al\\.", "year": 1994}, {"title": "Genom: A Tool for the Specification and the Implementation of Operating Modules in a Distributed Robot Architecture", "author": ["S. Fleury", "M. Herrb", "R. Chatila"], "venue": "IROS-97, 842\u2013848.", "citeRegEx": "Fleury et al\\.,? 1997", "shortCiteRegEx": "Fleury et al\\.", "year": 1997}, {"title": "A survey of socially interactive robots", "author": ["T. Fong", "I.R. Nourbakhsh", "K. Dautenhahn"], "venue": "Robotics and Autonomous Systems 42(3-4):143\u2013166.", "citeRegEx": "Fong et al\\.,? 2003", "shortCiteRegEx": "Fong et al\\.", "year": 2003}, {"title": "Belief Management for HRI Planning", "author": ["J. Guitton", "M. Warnier", "R. Alami"], "venue": "Workshop on Belief change, Non-monotonic reasoning and Conflict resolution.", "citeRegEx": "Guitton et al\\.,? 2012", "shortCiteRegEx": "Guitton et al\\.", "year": 2012}, {"title": "PRS: A High Level Supervision and Control Language for Autonomous Mobile Robots", "author": ["F.F. Ingrand", "R. Chatila", "R. Alami", "F. Robert"], "venue": "ICRA, 43\u201349.", "citeRegEx": "Ingrand et al\\.,? 1996", "shortCiteRegEx": "Ingrand et al\\.", "year": 1996}, {"title": "Combining task and path planning for a humanoid two-arm robotic system", "author": ["L. Karlsson", "J. Bidot", "F. Lagriffoul", "A. Saffiotti", "U. Hillenbrand", "F. Schmidt"], "venue": "Workshop on Combining Task and Motion Planning for RealWorld Applications, 114\u2013122.", "citeRegEx": "Karlsson et al\\.,? 2012", "shortCiteRegEx": "Karlsson et al\\.", "year": 2012}, {"title": "Ten Challenges for Making Automation a \u201cTeam Player\u201d in Joint Human-Agent Activity", "author": ["G. Klein", "D.D. Woods", "J.M. Bradshaw", "R.R. Hoffman", "P.J. Feltovich"], "venue": "IEEE Intelligent Systems 19(6):91\u201395.", "citeRegEx": "Klein et al\\.,? 2004", "shortCiteRegEx": "Klein et al\\.", "year": 2004}, {"title": "Constraint propagation on interval bounds for dealing with geometric backtracking", "author": ["F. Lagriffoul", "D. Dimitrov", "A. Saffiotti", "L. Karlsson"], "venue": "IROS, 957\u2013964.", "citeRegEx": "Lagriffoul et al\\.,? 2012", "shortCiteRegEx": "Lagriffoul et al\\.", "year": 2012}, {"title": "SHOP: Simple hierarchical ordered planner", "author": ["D. Nau", "Y. Cao", "A. Lotem", "H. Mu\u00f1oz-Avila"], "venue": "IJCAI, 968\u2013 973.", "citeRegEx": "Nau et al\\.,? 1999", "shortCiteRegEx": "Nau et al\\.", "year": 1999}, {"title": "SHOP2: An HTN Planning System", "author": ["D. Nau", "T.-C. Au", "O. Ilghami", "U. Kuter", "W. Murdock", "D. Wu"], "venue": "JAIR, volume 20, 379\u2013404.", "citeRegEx": "Nau et al\\.,? 2003", "shortCiteRegEx": "Nau et al\\.", "year": 2003}, {"title": "Automated Planning: Theory & Practice", "author": ["D. Nau", "M. Ghallab", "P. Traverso"], "venue": "San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.", "citeRegEx": "Nau et al\\.,? 2004", "shortCiteRegEx": "Nau et al\\.", "year": 2004}, {"title": "Towards planning human-robot interactive manipulation tasks: Task dependent and human oriented autonomous selection of grasp and placement", "author": ["A.K. Pandey", "J.-P. Saut", "D. Sidobre", "R. Alami"], "venue": "IEEE RAS EMBS International Conference on Biomedical Robotics and Biomecha-", "citeRegEx": "Pandey et al\\.,? 2012", "shortCiteRegEx": "Pandey et al\\.", "year": 2012}, {"title": "Move3D: a generic platform for path planning", "author": ["T. Sim\u00e9on", "J.-P. Laumond", "F. Lamiraux"], "venue": "4th International Symposium on Assembly and Task Planning, 25\u2013", "citeRegEx": "Sim\u00e9on et al\\.,? 2001", "shortCiteRegEx": "Sim\u00e9on et al\\.", "year": 2001}, {"title": "Project Planning Using a Hierarchic Nonlinear Planner", "author": ["A. Tate"], "venue": "Department of AI Research Report No. 25, University of Edinburgh.", "citeRegEx": "Tate,? 1976", "shortCiteRegEx": "Tate", "year": 1976}, {"title": "When the robot puts itself in your shoes", "author": ["M. Warnier", "J. Guitton", "S. Lemaignan", "R. Alami"], "venue": "Managing and exploiting human and robot beliefs. In RO-MAN, 948\u2013 954.", "citeRegEx": "Warnier et al\\.,? 2012", "shortCiteRegEx": "Warnier et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 16, "context": "HATP is based on SHOP (Nau et al. 1999), but unlike this planner and other HTN planners such as Nonlin (Tate 1976), SHOP2 (Nau et al.", "startOffset": 22, "endOffset": 39}, {"referenceID": 21, "context": "1999), but unlike this planner and other HTN planners such as Nonlin (Tate 1976), SHOP2 (Nau et al.", "startOffset": 69, "endOffset": 80}, {"referenceID": 17, "context": "1999), but unlike this planner and other HTN planners such as Nonlin (Tate 1976), SHOP2 (Nau et al. 2003) and UMCP (Erol, Hendler, and Nau 1994), HATP offers a user-friendly domain representation language inspired by popular programming languages, making it easier for roboticists, and indeed computer scientists alike, to become quickly acquainted with the syntax and semantics.", "startOffset": 88, "endOffset": 105}, {"referenceID": 16, "context": "This is also highlighted as a feature in the SHOP (Nau et al. 1999) planner, on which HATP is based.", "startOffset": 50, "endOffset": 67}, {"referenceID": 16, "context": "Introducing \u201ctrue\u201d partially-ordered planning into HATP is left as future work: the algorithms are not obvious as we want to have the ability to use evaluable predicates in preconditions, for which maintaining the complete state of the world at each step of the planning process is the obvious solution (Nau et al. 1999).", "startOffset": 303, "endOffset": 320}, {"referenceID": 17, "context": "HATP is able to find the least-cost primitive solution that solves the goal task(s) at hand, as done for example in (Nau et al. 2003).", "startOffset": 116, "endOffset": 133}, {"referenceID": 1, "context": "one per agent in the domain, and adds causal links between streams for synchronisation (Alami et al. 2011).", "startOffset": 87, "endOffset": 106}, {"referenceID": 14, "context": "(Klein et al. 2004) implemented that in what they called \u201cten challenges for human robot teamwork\u201d.", "startOffset": 0, "endOffset": 19}, {"referenceID": 14, "context": "In this case the robot should be able to (Klein et al. 2004): (1) signal in what tasks it can/wants to participate; (2) act in a predictable way to ensure human understanding of what it is doing; (3) publicise its status and its intentions; (4) negotiate on tasks with its human partner in order to determine roles and decide how to perform the tasks; and (5) deal with social conventions, as well as its human partner\u2019s abilities and preferences.", "startOffset": 41, "endOffset": 60}, {"referenceID": 19, "context": "Aptly called Geometric Task Planner (GTP) (Pandey et al. 2012), this planner liberates", "startOffset": 42, "endOffset": 62}, {"referenceID": 7, "context": "Using this particular planner for forming the link with HATP also makes the interface proposed different to other interfaces in the literature, such as (Dornhege et al. 2009b; 2009a; Karlsson et al. 2012; Lagriffoul et al. 2012).", "startOffset": 152, "endOffset": 228}, {"referenceID": 13, "context": "Using this particular planner for forming the link with HATP also makes the interface proposed different to other interfaces in the literature, such as (Dornhege et al. 2009b; 2009a; Karlsson et al. 2012; Lagriffoul et al. 2012).", "startOffset": 152, "endOffset": 228}, {"referenceID": 15, "context": "Using this particular planner for forming the link with HATP also makes the interface proposed different to other interfaces in the literature, such as (Dornhege et al. 2009b; 2009a; Karlsson et al. 2012; Lagriffoul et al. 2012).", "startOffset": 152, "endOffset": 228}, {"referenceID": 1, "context": "Both HATP and the GTP are part of the larger LAAS robotics architecture (Fleury, Herrb, and Chatila 1997; Alami et al. 2011).", "startOffset": 72, "endOffset": 124}, {"referenceID": 12, "context": "The execution controller\u2014the Procedural Reasoning System (PRS)(Ingrand et al. 1996)\u2014 is responsible for invoking HATP when a task needs to be planned, and also executing the resulting primitive solution returned by HATP by invoking various actuators via the interface provided by Genom (Fleury, Herrb, and Chatila 1997) to the low-level controllers, which is also the framework used to wrap them into individual well-defined modules.", "startOffset": 62, "endOffset": 83}, {"referenceID": 0, "context": "We have described in this paper the HATP HTN planner, which has been used extensively for practical robotics applications in the LAAS architecture (Alami et al. 1998) over many years (Alili, Alami, and Montreuil 2009; Guitton, Warnier, and Alami 2012; Warnier et al.", "startOffset": 147, "endOffset": 166}, {"referenceID": 22, "context": "1998) over many years (Alili, Alami, and Montreuil 2009; Guitton, Warnier, and Alami 2012; Warnier et al. 2012; de Silva, Pandey, and Alami 2013; de Silva et al. 2014).", "startOffset": 22, "endOffset": 167}, {"referenceID": 1, "context": "There has also been some initial efforts toward extending HATP to support separately modelling the beliefs of the different agents in the domain (Alami et al. 2011).", "startOffset": 145, "endOffset": 164}, {"referenceID": 16, "context": "Other interesting work on HATP that is currently underway is formalising its domain representation language to show its relation with more traditional representations such as that used by the SHOP planner (Nau et al. 1999).", "startOffset": 205, "endOffset": 222}], "year": 2014, "abstractText": "Hierarchical Task Network (HTN) planning is a popular approach that cuts down on the classical planning search space by relying on a given hierarchical library of domain control knowledge. This provides an intuitive methodology for specifying high-level instructions on how robots and agents should perform tasks, while also giving the planner enough flexibility to choose the lower-level steps and their ordering. In this paper we present the HATP (Hierarchical Agentbased Task Planner) planning framework which extends the traditional HTN planning domain representation and semantics by making them more suitable for roboticists, and treating agents as \u201cfirst class\u201d entities in the language. The former is achieved by allowing \u201csocial rules\u201d to be defined which specify what behaviour is acceptable/unacceptable by the agents/robots in the domain, and interleaving planning with geometric reasoning in order to validate online\u2013with respect to a detailed geometric 3D world\u2013the human/robot actions currently being pursued by HATP.1", "creator": "TeX"}}}