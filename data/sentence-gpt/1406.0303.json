{"id": "1406.0303", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Jun-2014", "title": "A Superposition Calculus for Abductive Reasoning", "abstract": "We present a modification of the superposition calculus that is meant to generate consequences of sets of first-order axioms. This approach is proven to be sound and deductive-complete in the presence of redundancy elimination rules, provided the considered consequences are built on a given finite set of ground terms, represented by constant symbols. In contrast to other approaches, most existing results about the termination of the superposition calculus can be carried over to our procedure for the calculation of values for a set of first-order axioms. A general approach for this type of system has been developed and discussed in the last section of this series. A general approach for this type of system has been developed and discussed in the last section of this series. A general approach for this type of system has been developed and discussed in the last section of this series. A general approach for this type of system has been developed and discussed in the last section of this series.\n\n\n\n\nThe theory of superposition does not provide a proof of the existence of a sub-problem. To obtain evidence for this possibility, we need to use finite terms such as \\((a)\\) as $\\displaystyle \\array{X}{X}$ and \\(b}\\) and \\(e)$. This is the principle of the superposition calculus. There are only a few common ways of proving that a sub-problem has a sub-problem. First, there is no proof of the existence of a sub-problem. Second, there is no proof of the existence of a sub-problem. Third, there is no proof of the existence of a sub-problem.\n\nOne way to understand this problem is to take a look at the idea of a sub-problem:\nThe answer to this question is to take a look at the idea of a sub-problem. This is a good way to show that a sub-problem exists. For example, a number of ways of proving that a sub-problem exists are presented in the final proof. For example, a number of ways of proving that a sub-problem exists is presented in the final proof. For example, a number of ways of proving that a sub-problem exists is presented in the final proof. The concept of a sub-problem exists is a common way of proving that a sub-problem exists. For example, a number of ways of proving that a sub-problem exists is presented in the final proof. The idea of a sub-problem exists is a common way of proving that a sub", "histories": [["v1", "Mon, 2 Jun 2014 09:21:11 GMT  (61kb,D)", "https://arxiv.org/abs/1406.0303v1", null], ["v2", "Sun, 13 Jul 2014 16:44:15 GMT  (78kb,D)", "http://arxiv.org/abs/1406.0303v2", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["mnacho echenim", "nicolas peltier"], "accepted": false, "id": "1406.0303"}, "pdf": {"name": "1406.0303.pdf", "metadata": {"source": "CRF", "title": "A Superposition Calculus for Abductive Reasoning", "authors": ["M. Echenim"], "emails": [], "sections": [{"heading": null, "text": "to generate consequences of sets of first-order axioms. This approach is proven to be sound and deductive-complete in the presence of redundancy elimination rules, provided the considered consequences are built on a given finite set of ground terms, represented by constant symbols. In contrast to other approaches, most existing results about the termination of the Superposition calculus can be carried over to our procedure. This ensures in particular that the calculus is terminating for many theories of interest to the SMT community."}, {"heading": "1 Introduction", "text": "The verification of complex systems is generally based on proving the validity, or, dually, the satisfiability of a logical formula. A standard practice consists in translating the behavior of the system to be verified into a logical formula, and proving that the negation of the formula is unsatisfiable. These formul\u00e6 may be domain-specific, so that it is only necessary to test the satisfiability of the formula modulo some background theory, whence the name Satisfiability Modulo Theories problems, or SMT problems. If the formula is actually satisfiable, this means the system is not error-free, and any model can be viewed as a trace that generates an error. The models of a satisfiable formula can therefore help the designers of the system guess the origin of the errors and deduce how they can be corrected; this is the main reason for example why state-of-the-art SMT solvers feature automated model building tools (see for instance Caferra, Leitsch, and Peltier, 2004). However, this approach is not always satisfactory. First, there is the risk of an information overkill: indeed, the generated model may be very large and complex, and discovering the origin of the error may require a long and difficult analysis. Second, the model may be too specific, in the sense that it only corresponds to one particular execution of the system and that dismissing this single execution may not be sufficient to fix the system. Also, there are generally many interpretations on different domains that satisfy the formula. In order to understand where the error(s) may come from, it is generally necessary\nar X\niv :1\n40 6.\n03 03\nv2 [\ncs .L\nO ]\n1 3\nJu l 2\nto analyze all of these models and to identify common patterns. This leaves the user with the burden of having to infer the general property that can rule out all the undesired behaviors. A more useful and informative solution would be to directly infer the missing axioms, or hypotheses, that can be added in order to ensure the unsatisfiability of the input formula. These axioms can be viewed as sufficient conditions ensuring that the system is valid. Such conditions must be plausible and economical: for instance, explanations that contradict the axioms of the considered theories are obviously irrelevant.\nIn this paper, we present what is, to the best of our knowledge, a novel approach to this debugging problem: we argue that rather than studying one or several models of a formula, more valuable information can be extracted from the properties that hold in all the models of the formula. For example, consider the theory of arrays, which is axiomatized as follows (as introduced by McCarthy, 1962):\n\u2200x, z, v. select(store(x, z, v), z) ' v, (1) \u2200x, z, w, v. z ' w \u2228 select(store(x, z, v), w) ' select(x,w). (2)\nThese axioms state that if element v is inserted into array x at position z, then the resulting array contains v at position z, and the same elements as in x elsewhere. Assume that to verify that the order in which elements are inserted into a given array does not matter, the satisfiability of the following formula is tested (see also Figure 1):\nselect(store(store(a, i, b), j, c), k) 6' select(store(store(a, j, c), i, b), k).\nThis formula asserts that there is a position k that holds different values in the array obtained from a by first inserting element b at position i and then element c at position j, and in the array obtained from a by first inserting element c at position j and then element b at position i. It turns out that this formula is actually satisfiable, which in this case means that some hypotheses are missing. State-of-the-art SMT solvers such as Yices (Dutertre and de Moura, 2006) or Z3 (de Moura and Bj\u00f8rner, 2008) can help find out what hypotheses are missing by outputting a model of the formula. In this case, Yices outputs (= b 1) (= c 3) (= i 2) (= k 2) (= j 2), and for this simple example, such a model may be sufficient to quickly understand where the error comes from. However, a\nsimpler and more natural way to determine what hypotheses are missing would be to have a tool that, when fed the formula above, outputs i ' j \u2227 b 6' c, stating that the formula can only be true when elements b and c are distinct, and are inserted at the same position in array a. This information permits to know immediately what additional hypotheses must be made for the formula to be unsatisfiable. In this example, there are two possible hypotheses that can be added: i 6' j or b ' c.\nWe investigate what information should be provided to the user and how it can be obtained, by distinguishing a set of ground terms on which additional hypotheses are allowed to be made. These terms may be represented by a particular set of constant symbols, called abducible constants or simply abducibles, and the problem boils down to determining what ground clauses containing only abducible constants are logically entailed by the formula under consideration, since the negation of any of these clauses can be viewed as a set of additional hypotheses that make the formula unsatisfiable. Indeed, by duality, computing implicants (or explanations) of a formula \u03c6 is equivalent to computing implicates (i.e., logical consequences) of \u00ac\u03c6. In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.e., that can generate all the clauses built on abducible constants using finite set of predicate symbols including ' that are logical consequences of the input clause set (up to redundancy). Our procedure is defined by enriching the standard calculus with some new mechanisms allowing the assertion of relevant hypotheses during the proof search. These additional hypotheses are stored as constraints associated with the clauses and are propagated along the derivations. If the empty clause can be generated under a conjunction of hypotheses X , then the conjunction of the original formula and X is unsatisfiable. An essential feature of this approach is that the conditions are not asserted arbitrarily or eagerly, using a generate-and-test approach (which would be inefficient): instead they are discovered on a need basis, either by considering residual equations of unification failures (for positive hypotheses) or by negating some of the literals occurring in the clauses (for negative hypotheses).\nRelated Work The generation of implicants (or, by duality, of implicates) of logical formul\u00e6 has many applications in system verification and artificial intelligence, and this problem has been thoroughly investigated in the context of propositional logic. The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011). These methods mainly focus on the efficient representation of information, and develop compact ways of storing and manipulating huge sets of implicates.\nIn contrast, the approaches handling abductive reasoning in first-order or equational logic are very scarce. Implicates can be generated automatically\nfrom sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formul\u00e6 that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b.\nWhile the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formul\u00e6 interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)).\nWernhard (2013) proposes a method to derive abductive explanations from first-order logical programs, under several distinct non-classical semantics, using a reduction to second-order quantifier-elimination. Both the considered framework and the proposed techniques completely depart from our work.\nOrganization of the Paper The rest of the paper is structured as follows. In Section 2 we review basic definitions and adapt usual results to our framework. In Section 3 the new Superposition calculus SA\u227asel is presented, and it is shown in Section 4 that it is deductive-complete for ground clauses built on the set of abducible constants. In Section 5 some refinements of the calculus are presented, aiming at more efficiency. In Section 6, we show that most termination results holding for the usual Superposition calculus also apply to SA\u227asel. The present paper is a thoroughly expanded and revised version of (Echenim and Peltier, 2012). See Section 5.2 for more details on the relationship of SA\u227asel with the calculus in (Echenim and Peltier, 2012)."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Basic Definitions", "text": "The set of terms is built as usual on a set of function symbols F including a set of predicate symbols P, containing in particular a special constant >, and a set of variables V. Every symbol f \u2208 F is mapped to a unique arity ar(f) \u2208 N. The set Fn is the set of function symbols of arity n; an element of F0 is a constant. A term whose head is in P is boolean.\nAn atom (or equation) is an unordered pair of terms, written t ' s, where t and s are terms. A literal is either an atom or the negation of an atom (i.e., a disequation), written t 6' s. For every literal l, we denote by lc the complementary literal of l, which is defined as follows: (t ' s)c def= t 6' s and (t 6' s)c def= t ' s. We use the notation t ./ s to denote a literal of the form t ' s or t 6' s, and t 6./ s then denotes the complementary literal of t ./ s. As usual, a non-equational atom p(~t) where p \u2208 P is encoded as an equation p(~t) ' >. For readability, such an equation is sometimes written p(~t), and p(~t) 6' > can be written \u00acp(~t). A clause is a finite multiset of literals, sometimes written as a disjunction. The empty clause is denoted by 2. For technical reasons, we assume that the predicate symbols only occur in atoms of the form t ' >, where t 6= > (literals of the form > 6' > can be removed from the clauses and clauses containing a literal > ' > can be dismissed; equations of the form p(~t) = q(~s) with p, q \u2208 P \\ {>} are forbidden). For every clause C = {l1, . . . , ln}, Cc denotes the set of unit clauses {{lci} | i \u2208 [1, n]} and for every set of unit clauses S = {{li} | i \u2208 [1, n]}, Sc denotes the clause {lc1, . . . , lcn}. Throughout the paper, we assume that \u227a denotes some fixed reduction ordering on terms (see, e.g., Baader and Nipkow, 1998) such that > \u227a t, for all terms t 6= >, extended to atoms, literals and clauses as usual1.\nThe set of variables occurring in an expression (term, atom, literal, clause) E is denoted by var(E). If var(E) = \u2205 then E is ground. A substitution is a function mapping variables to terms. For every term t and for every substitution\n1The literals t ' s and t 6' s are ordered as {{t}, {s}} and {{t, s}}, respectively.\n\u03c3, we denote by t\u03c3 the term obtained from t by replacing every variable x by its image w.r.t. \u03c3. The domain of a substitution is the set of variables x such that x\u03c3 6= x. A substitution \u03c3 is ground if for every x in the domain of \u03c3, x\u03c3 is ground.\nA position is a finite sequence of positive integers. A position p occurs in a term t if either p = \u03b5 or if t = f(t1, . . . , tn), p = i.q with i \u2208 [1, n] and q is a position in ti. If p is a position in t, the terms t|p and t[s]p are defined as follows: t|\u03b5 def = t, t[s]\u03b5 def = s, f(t1, . . . , tn)|i.q def = (ti)|q and f(t1, . . . , tn)[s]i.q def = f(t1, . . . , ti\u22121, ti[s]q, ti+1, . . . , tn). Given a set of constants E, a literal t ./ s is E-flat if either t, s \u2208 V \u222a E or t = p(t1, . . . , tn), s = > and t1, . . . , tn \u2208 V \u222a E. A clause is E-flat if all its literals are E-flat. The set of E-flat clauses is denoted by Cflat(E). A clause is flat if it is F0-flat and elementary if it is A-flat and contains no symbol in P (in other words, every literal is of the form a ./ b with a, b \u2208 V \u222a A).\nAn interpretation is a congruence relation on ground terms. An interpretation I validates a clause C if for all ground substitutions \u03c3 of domain var(C) there exists l \u2208 C such that either l = (t ' s) and (l, s)\u03c3 \u2208 I, or l = (t 6' s) and (l, s)\u03c3 6\u2208 I.\n2.2 Abducible Constants and A-Sets In this section we introduce the notion of an A-set, that provides a convenient way of representing partial interpretations defined on a particular set of constant symbols. Let A \u2286 F0 be a set of constants, called the abducible constants. The set A is fixed by the user and contains all constants on which the abducible formul\u00e6 can be constructed. We assume that f(~t) a, for all a \u2208 A and f 6\u2208 A, and that q(t1, . . . , tn) p(a1, . . . , an) if a1, . . . , an \u2208 A, p, q are predicate symbols and \u2203i \u2208 [1, n] ti a1, . . . , an.\nDefinition 1 An A-set is a set of A-flat literals X satisfying the following properties.\n\u2022 If L \u2208 X and L is not ground then L is negative or of the form p(t1, . . . , tn) ' >.\n\u2022 If {L[a]p, a ' b} \u2286 X , where a, b 6= >, then L[b]p \u2208 X .\n\u2022 a ' a \u2208 X , for all a \u2208 A.\nAn A-set X is positive if it only contains positive literals, and complete if for every ground A-flat atom A, X contains either A or \u00acA.\nNote that all elementary positive literals in X must be ground whereas negative or non elementary literals possibly contain variables. . Informally, a satisfiable A-set can be viewed as a partial interpretation on the constant symbols in A. The positive elementary literals in X define an equivalence relation between elements on A and the negative elementary literals specify the equivalence classes that are known to be distinct. Literals of the form p(t1, . . . , tn) ./ >\nspecify the interpretation of predicate symbols on constants of A. Variables correspond to unknown (or unspecified) constant symbols in A. Complete Asets are total interpretations on A.\nThis definition of A-sets is given for theoretical purposes only: in practice, they can be more conveniently represented by a set of oriented equations of the form {ai ' bi | i \u2208 [1, n]}, where \u2200i \u2208 [1, n] ai, bi \u2208 A, ai bi and i 6= j \u21d2 ai 6= aj , together with a set of irreducible literals of the form c 6' d or p(c1, . . . , cn) ./ >, where \u2200i \u2208 [1, n], c, d, c1, . . . , cn 6= ai. When convenient, we may represent an A-set by a set X of equations and disequations, with the intended meaning that we are actually referring to the smallest A-set X that contains X.\nExample 2 Let A = {a, b, c, d} and x \u2208 V. Then the set\nX = {a ' a, b ' b, c ' c, d ' d, e ' e, a ' b, c 6' a, c 6' b, d 6' x}\nis an A-set. Assuming an ordering such that a b c d, it can be more concisely represented by {a ' b, c 6' b, d 6' x}. X defines a partial interpretation in which a, b are known to be equal and distinct from c, while d is distinct from some unspecified constant x (x can represent a, b, c or e \u2013 if x represents d then the set is unsatisfiable). The interpretation is only partial since it can be extended into a total interpretation that satisfies either a ' d or a 6' d.\nDefinition 3 For every A-set X and for every expression (term, atom, literal, clause or clause set) E, we denote by E\u2193X the expression obtained from E by replacing every constant a \u2208 A in E by the smallest (according to \u227a) constant b in A such that a ' b \u2208 X . We write t \u223cXA s iff t\u2193X = s\u2193X and t \u223cA s iff there exists an A-set X such that t \u223cXA s. This definition is extended to substitutions: we write \u03c3 = \u03b8\u2193X if x\u03c3 = (x\u03b8)\u2193X and \u03c3 \u223cXA \u03b8 if for all x \u2208 dom(\u03c3) \u222a dom(\u03b8), x\u03c3 \u223cXA x\u03b8.\nProposition 4 Let C be a clause, \u03c3 be a substitution and X be an A-set. If (C\u03c3)\u2193X is A-flat (resp. elementary), then so is C.\nProof. 1 The contrapositive is obvious: if C is not A-flat, then it contains a non-boolean term t that is not in A\u222aV. But then, neither t\u03c3 nor t\u03c3\u2193X can be in A \u222a V, and (C\u03c3)\u2193X cannot be A-flat. The reasoning is similar for elementary clauses.\n2.3 A-Unification A-unification is an extension of unification that, given two terms t and s, aims at computing a substitution \u03c3 such that t\u03c3 \u223cA s\u03c3, meaning that t\u03c3 and s\u03c3 are equal up to a renaming of constants in A. The set of necessary constant renamings is collected and stored in a positive A-set. This set corresponds exactly to residual (non-solvable) equations obtained when applying standard unification algorithms.\nExample 5 The terms f(a, b) and f(x, x) are not unifiable in the standard sense, but they are A-unifiable. The substitution \u03c3 : {x 7\u2192 a} is an A-unifier of these two terms, together with the A-set {a ' a, b ' b, a ' b}.\nDefinition 6 An A-substitution is a pair (\u03c3,X ) where \u03c3 is a substitution and X is an A-set containing only equations between elements of A. An A-substitution (\u03c3,X ) is an A-unifier of an equation t ' s iff t\u03c3 \u223cXA s\u03c3. Two terms admitting an A-unifier are A-unifiable.\nIntuitively, if (\u03c3,X ) is an A-unifier of an equation t ' s, then the equations in X can be used to reduce t and s to terms that are unifiable in the standard sense.\nDefinition 7 An A-substitution (\u03c3,X ) is more general than an A-substitution (\u03c3\u2032,X \u2032), written (\u03c3,X ) \u2265A (\u03c3\u2032,X \u2032), if there exists a (standard) substitution \u03b8 such that the two following conditions hold:\n\u2022 X \u2286 X \u2032.\n\u2022 For every x \u2208 V, x\u03c3\u2032 \u223cX \u2032A x\u03c3\u03b8.\nWe write (\u03c3,X ) \u223cA (\u03c3\u2032,X \u2032) if (\u03c3,X ) \u2265A (\u03c3\u2032,X \u2032) and (\u03c3\u2032,X \u2032) \u2265A (\u03c3,X ).\nExample 8 Let A = {a, b, c}, and consider the following substitutions and Asets:\n\u03c3 = {x 7\u2192 a, y 7\u2192 c, z 7\u2192 f(a, z\u2032)} and X = {a ' c} \u03c3\u2032 = {x 7\u2192 a, y 7\u2192 b, z 7\u2192 f(b, b), } and X \u2032 = {a ' b, b ' c} .\nBy letting \u03b8 = {z\u2032 7\u2192 b}, it is simple to verify that (\u03c3,X ) \u2265A (\u03c3\u2032,X \u2032).\nNote that most general A-unifiers are not unique modulo variable renamings. For example, the equation f(g(a), g(b)) ' f(g(x), g(y)) admits several most general unifiers, including ({x\u2192 a, y \u2192 b}, {a ' b}), ({x\u2192 b, y \u2192 a}, {a ' b}), . . . which are of course all \u223cA-equivalent. A-unifiers can be computed by a slight adaptation of the usual unification algorithm (see Appendix A for details)."}, {"heading": "3 A-Superposition Calculus", "text": "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set. The calculus handles constrained clauses, called A-clauses, the constraint part of an A-clause being an A-set containing all the equations and disequations needed to derive the corresponding non-constraint part from the original clause set. Unification is replaced by A-unification, and the A-set of the generated Aunifier is appended to the constraint of the conclusion of the rule. Furthermore, an additional inference rule, called the A-Assertion rule, is introduced in order to add disequations to the constraints.\nDefinition 9 An A-clause is a pair [C | X ] where C is a clause and X is an A-set. If X = \u2205, then we may write C instead of [C |\u2205].\nIn what follows, we first define the ordering and selection function the calculus is based upon before presenting the inference rules and redundancy criterion of the A-Superposition calculus. We conclude this section by showing that the calculus is sound."}, {"heading": "3.1 Ordering and Selection Function", "text": "We begin by introducing some additional notations and terminology.\nDefinition 10 For all terms t, s, we write t A s if for every A-set X and ground substitution \u03c3, we have t\u03c3\u2193X s\u03c3\u2193X . This ordering is extended to atoms, literals and clauses in a similar way to \u227a.\nIntuitively t A s means that t is always greater than s, regardless of the names of the constants in A.\nExample 11 If a, b, c \u2208 A and f(x) a b c, then we have f(b) A a, but f(a) 6 A f(b), since f(a)\u2193{a'c} = f(c) \u227a f(b) = f(b)\u2193{a'c}.\nDefinition 12 A substitution \u03c3 is X -pure if for all variables x \u2208 var(X ), x\u03c3 is either a variable or a constant in A.\nDefinition 13 A function sel is a selection function for an ordering > iff sel maps every clause C to a set of literals in C such that sel(C) either contains a negative literal or contains all literals that are >-maximal in C.\nWe consider a selection function sel for the ordering A, that satisfies the following assumptions.\nAssumption 14 The function sel is stable under A-substitutions, i.e., for every clause C, for every literal l \u2208 C and for every A-substitution (\u03b7,X ), if l\u03b7\u2193X \u2208 sel(C\u03b7\u2193X ), then l \u2208 sel(C).\nAssumption 15 For every A-clause C, if sel(C) contains a literal of the form p(~t) = > then sel(C) contains no negative literal of the form a 6' b with a, b \u2208 V \u222a A.\nAssumption 15 can always be fulfilled since negative literals can be selected arbitrarily."}, {"heading": "3.2 Inference Rules", "text": "The calculus SA\u227asel is defined by the rules below. The standard Superposition calculus (denoted by SP\u227asel) coincides with SA \u227a sel if A = \u2205.\nRemark 16 Following our convention, in all rules, if X , Y are two A-sets, then X \u222aY does not denote the mere union of X and Y, but rather the smallest A-set containing both X and Y (it is obtained by transitive closure from the union of X and Y). For example, if {a, b, c} \u2286 A with a b c, X = {a ' a, b ' b, c ' c, a ' b} and Y = {a ' a, b ' b, c ' c, a ' c}, then X \u222a Y denotes the A-set {a ' a, b ' b, c ' c, a ' b, a ' c, b ' c}. Similarly, if X is an A-set and \u03c3 is an X -pure substitution, then X\u03c3 denotes the smallest A-set containing X\u03c3. For instance, if X = {a ' a, b ' b, a ' b, x 6' y} and \u03c3 = {x 7\u2192 a}, then X\u03c3 = {a ' a, b ' b, a ' b, a 6' y, b 6' y}.\nA-Superposition\n[C \u2228 t ./ s |X ], [D \u2228 u ' v |Y] [C \u2228D \u2228 t[v]p ./ s |X \u222a Y \u222a E ]\u03c3\nIf ./\u2208 {', 6'}, (\u03c3, E) is an (X \u222a Y)-pure most general A-unifier of u and t|p, v\u03c3 6 A u\u03c3, s\u03c3 6 A t\u03c3, (t ./ s)\u03c3 \u2208 sel((C \u2228 t ./ s)\u03c3), (u ' v)\u03c3 \u2208 sel((D \u2228 u ' v)\u03c3) and if t|p is a variable then t|p occurs in X .\nWe shall refer to the left and right premises of the inference rule as the into and from premises, respectively. The main difference with the usual Superposition rule (besides the replacement of by A and of unifiers by A-unifiers) is that superposition into a variable is permitted, provided the considered variable occurs in the constraint part of the clause. The reason is that these do not actually represent variables in the usual sense, but rather placeholders for (unknown) constants (see also Example 41).\nBy definition of the calculus, variables can only occur in the constraints if the A-Assertion rule (see below) is applied on a non-ground literal. This is the case because, by definition of A-unification, the other rules add only ground equations into the constraints. Furthermore, by definition, a non-ground literal can be added to the constraints only if the considered clause is variable-eligible, i.e. contains a selected literal of the form x ' t, where x 6\u227a t. This cannot happen if the clause set is variable-inactive (Armando et al, 2009). However, there exist theories of interest that are not variable-inactive, for instance the theory of arrays with axioms for constant arrays (e.g., \u2200x, select(t, x) ' c).\nNote that the rule applies if t and u are of the form p(~t) ./ > and p(~s) ' > (with p = \u03b5), in which case t[v]p ./ s is of the form > ./ >. If ./ is ' then the A-clause is a tautology and can be deleted, and if ./ is 6' then the literal > 6' > is deleted from the clause as explained before. The rule is essentially equivalent to Ordered Resolution in this case (see for instance Leitsch, 1997).\nA-Reflection [C \u2228 t 6' s |X ] [C |X \u222a E ]\u03c3\nIf (\u03c3, E) is an X -pure most general A-unifier of t and s and (t 6' s)\u03c3 \u2208 sel((C \u2228 t 6' s)\u03c3).\nEquational A-Factorization\n[C \u2228 t ' s \u2228 u ' v |X ] [C \u2228 s 6' v \u2228 t ' s |X \u222a E ]\u03c3\nIf (\u03c3, E) is an X -pure most general A-unifier of t and u, s\u03c3 6 A t\u03c3, v\u03c3 6 A u\u03c3 and (t ' s)\u03c3 \u2208 sel((C \u2228 t ' s \u2228 u ' v)\u03c3).\nFor technical convenience, we assume that s 6' v is omitted in the conclusion if s\u03c3 = v\u03c3.\nA-Assertion [t ' s \u2228 C |X ]\n[C |X \u222a {t 6' s}]\nIf t, s \u2208 A \u222a V, t ' s \u2208 sel(t ' s \u2228 C) and A 6= \u2205.\n[p(t1, . . . , tn) ./ > \u2228 C |X ] [C |X \u222a {p(t1, . . . , tn) 6./ >}]\nIf t1, . . . , tn \u2208 A \u222a V, p(t1, . . . , tn) ./ > \u2208 sel(t ' s \u2228 C) and A 6= \u2205.\nA-Substitutivity Rule\n[t1 ' s1 \u2228 C1 |X1] . . . [tn ' sn \u2228 Cn |Xn] [p(t1, . . . , tn) ./ > \u2228 C1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Cn |{p(s1, . . . , sn) ./ >} \u222a \u22c3n i=1 Xi]\nThe rule can be applied also by replacing some of the premisses [ti ' si\u2228Ci |Xi] by variants of the Reflexivity axiom x ' x (note that if all premisses are of this form then the conclusion is a tautology)."}, {"heading": "3.3 Soundness", "text": "The interpretation of an A-clause is defined as a logical implication:\nDefinition 17 An interpretation I validates an A-clause [C | X ] iff for every X -pure ground substitution \u03c3 of domain var(C) \u222a var(X ), either I 6|= X\u03c3 or I |= C\u03c3.\nIf I |= [C |X ] for all interpretations I, then [C |X ] is a tautology. In particular, this property holds if X is unsatisfiable, if C\u2193X contains two complementary literals or a literal of the form t ' t, or if all the literals in C occurs in X .\nTheorem 18 Let S be a set of A-clauses. If C is generated from S by one of the rules of SA\u227asel then S |= C.\nProof. 2 It suffices to prove that all the rules are sound, i.e., that the conclusion of the rule is a logical consequence of the premises. This is due to the fact that if (\u03c3, E) is an A-unifier of t ' s, then the A-clause [t\u03c3 ' s\u03c3 | E ] is valid in all interpretations. Then the proof follows by a straightforward inspection of the rules, as in the usual case."}, {"heading": "3.4 Redundancy", "text": "We now adapt the standard redundancy criterion to A-clauses. An A-clause is quasi-positive if the only negative literals occurring in it are of the form p(~t) 6' >.\nDefinition 19 An A-clause [C | X ] is A-redundant in a set of A-clauses S if either [C | X ] is a tautology, or for every ground substitution \u03b8 of the variables in [C | X ] such that X \u03b8 is a satisfiable A-set, one of the following conditions hold.\n\u2022 There exists an A-clause [D |Y] and a substitution \u03c3 such that D\u03c3 \u2286 C\u03b8 and Y\u03c3 \u2286 X \u03b8.\n\u2022 If A = \u2205 or C\u03b8 is not both A-flat and quasi-positive, then there exist A-clauses [Di |Yi] and substitutions \u03c3i (1 \u2264 i \u2264 n), such that:\n\u2013 Yi\u03c3i \u2286 X \u03b8 for all i = 1, . . . , n, \u2013 X \u03b8,D1\u03c31, . . . , Dn\u03c3n |= C\u03b8, \u2013 C\u03b8 A D1\u03c31, . . . , Dn\u03c3n.\nWhen applied to standard clauses (with A = \u2205), this notion of redundancy coincides with the usual criterion (see for instance Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001).\nIt is easy to check that the standard redundancy detection rules such as subsumption, tautology deletion or equational simplification, are particular cases of this redundancy criterion. Note that the second item in Definition 19 is similar to the usual redundancy criterion of the Superposition calculus (see, e.g, Bachmair and Ganzinger, 1994), with the following differences: (i) the entire constraint part of the considered A-clause may be used to infer the clausal part, disregarding any ordering condition, (ii) the condition only applies to clauses that are not both A-flat and quasi-positive. For the clauses that are A-flat and quasi-positive, redundancy testing is limited to tautology deletion and subsumption (this is necessary to ensure completeness, see Remark 27).\nExample 20 Let A = {a, b, c}. The A-clause [a 6' c \u2228 b 6' c \u2228 f(x) ' d |a 6' b] is A-redundant in any set S, since for all ground substitutions \u03b8, a 6' b |= (a 6' c \u2228 b 6' c \u2228 f(x) ' d)\u03b8.\nThe A-clause [f(a, b) ' c \u2228 g(a) ' d | a 6' b] is A-redundant in {f(a, x) ' c\u2228a ' b}. Indeed, let \u03c3 = {x 7\u2192 b}, then a 6' b, f(a, x)\u03c3 ' c\u2228a ' b |= f(a, b) ' c \u2228 g(a) ' d and f(a, b) ' c \u2228 g(a) ' d A f(a, x)\u03c3 ' c \u2228 a ' b.\nThe following result is a straightforward consequence of Definition 19.\nProposition 21 If [C |X ] is redundant in a set S, then for any A-substitution (\u03c3,Y), [C\u03c3 |X \u222a Y] is also redundant in S.\nDefinition 22 A set S is SA\u227asel-saturated if every A-clause that can be derived from A-clauses in S by a rule in SA\u227asel is redundant in S.\nExamples\nWe provide simple application examples.\nExample 23 Let S = {g(f(x)) ' d, f(a) ' a, g(b) ' b, d ' c}. Assume that A = {a, b, c}. By applying the A-Superposition rule on the terms f(x) and f(a), we derive the clause g(a) ' d (note that this application of the rule is equivalent to the usual one). Then the A-Superposition rule can be applied again on the terms g(a) and g(b). The unification yields the constraints a ' b, hence the following A-clause is derived: [b ' d | a ' b]. The Assertion rule cannot be applied on b ' d, since this literal is not A-flat. Instead,the application of the A-Superposition rule on the term d (note that we must have d b, c since d 6\u2208 A and b, c \u2208 A) yields: [b ' c | a ' b]. Finally, the Assertion rule can be applied on b ' c since this literal is A-flat, thus generating [2 | b 6' c \u2227 a ' b]. This A-clause is equivalent to the clause b ' c\u2228a 6' b, and we have S |= b ' c\u2228a 6' b.\nThe second example involves predicate symbols.\nExample 24 We consider two functions f and g such that f and y 7\u2192 g(x, y) are increasing, together with abducible constants a, b, i and j. The aim is to determine under which conditions the property f(g(a, i)) \u2264 f(g(b, j)) holds. The problem is formalized as follows (where t \u2264 s stands for (t \u2264 s) ' > and <\u2208 P, x, y, u \u2208 V): S = {x 6\u2264 y \u2228 f(x) \u2264 f(y), x 6\u2264 y \u2228 g(u, x) \u2264 g(u, y), f(g(a, i)) 6\u2264 f(g(b, j))}. For conciseness, the axioms corresponding to \u2264 (e.g., transitivity) are omitted since they play no r\u00f4le in our context.\nThe Superposition rule applies on the first and last clauses, yielding g(a, i) 6\u2264 g(b, j). Then the rule applies again from the latter clause into the second one, and it generates: [i 6\u2264 j | {a ' b}]. Finally the A-Assertion rule yields the Aclause: [2 | {i \u2264 j, a ' b}], meaning that the desired property is fulfilled if i \u2264 j and a ' b hold.\nThe A-Assertion rule is necessary to guarantee deductive completeness, as shown in the example below.\nExample 25 Consider the (satisfiable) clause set: S def= {y ' x \u2228 f(x, x, y) ' a, f(a, b, c) 6' a}, where A def= {a, b, c} and x, y are variables. It is simple to verify that S |= a 6' b \u2228 c ' a, and the calculus is designed to generate from S a clause of the form [2 | X ], where \u00acX \u2261 a 6' b \u2228 c ' a. In order to generate such a clause, it is clear that one has to unify f(x, x, y) and f(a, b, c), since the unification of f(a, b, c) and a leads to an immediate failure, so that the Reflection rule is not applicable. This is feasible only if the condition a ' b is added to the constraints of the obtained clause, yielding a constrained clause of the form: [c ' a | a ' b]. The literal c ' a is deleted using the A-Assertion rule, by appending the disequation c 6' a to the constraints, thus obtaining the required A-clause: {[2 |a ' b, c 6' a]}.\nThe last example shows that the A-Substitutivity rule is also needed for completeness.\nExample 26 Consider the clause set: S def= {a ' b}. It is clear that S |= p(a) ' >\u2228p(b) 6' > for any predicate symbol p of arity 1, but [2 |{p(a) 6' >, p(b) ' >}] cannot be generated without the help of the A-Substitutivity rule. The above implicate is indeed obtained as follows: The A-Substitutivity rule generates the A-clause [p(x) ' > | p(x) ' >], then the A-Superposition rule applies from a ' b, yielding [p(a) ' > | p(b) ' >], and the desired result is obtained by applying the A-Assertion rule. Note that the equation p(a) ' p(b) does not need to be inferred in our context since predicate symbols are allowed only in atoms of the form t ' >. Considering implicates built on arbitrary function symbols (with nested applications) would lead to divergence since, e.g., an infinite number of clauses of the form fn(a) ' fn(b) (with n \u2208 N) could be derived from the above clause.\nRemark 27 The previous example also shows the importance of the restriction on the redundancy criterion. Indeed, if the criterion is relaxed by removing the condition \u201cC\u03b8 is not A-flat and quasi-positive\u201d in the second item of Definition 19, then the A-clause [p(a) ' > | p(b) ' >] is redundant in S (since a ' b \u227a p(a) ' > and a ' b, p(b) ' > |= p(a) ' >). Consequently no non redundant inferences apply on S and the implicate p(a) ' >\u2228p(b) 6' > cannot be generated."}, {"heading": "4 Deductive Completeness", "text": "We show in this section that SA\u227asel is deduction-complete for the clauses in Cflat(A). More precisely, we prove that for any SA\u227asel-saturated set S and clause C \u2208 Cflat(A), if S |= C then S contains an A-clause of the form [2 | Y] where Cc |= Y. The result is obtained in the following way. Given such a set S and clause C, we consider the smallest A-set X that contains Cc, and construct a set of standard ground clauses \u03a6(S,X ) such that:\n\u2022 \u03a6(S,X ) contains all ground instances of clauses in S, as well as a set of unit clauses equivalent to X \u2261 Cc.\n\u2022 \u03a6(S,X ) is saturated under a slightly adapted version of the Superposition calculus which is refutationally complete.\nSince S \u222a {Cc} is unsatisfiable and the considered calculus is refutationally complete, these two properties together will entail that \u03a6(S,X ) contains the empty clause. Finally, we show that this is possible only if S contains an Aclause of the required form.\nFirst, we formally define the notions of A-implicates and prime A-implicates.\nDefinition 28 Let S be a set of A-clauses. A clause C is an A-implicate of S if it satisfies the following conditions.\n\u2022 C is A-flat and ground.\n\u2022 C is not a tautology.\n\u2022 S |= C.\nC is a prime A-implicate of S if, moreover, C |= D holds for every A-implicate D of S such that D |= C. We denote by IA(S) the set of A-implicates of S.\nDefinition 29 We denote by CA(S) the set of clauses of the form (X\u03c3)c, where [2 |X ] \u2208 S and \u03c3 maps each variable x in X to some constant symbol a \u2208 A in such a way that X\u03c3 is satisfiable2. We write S v S\u2032 if for every clause C \u2032 \u2208 S\u2032, there exists C \u2208 S such that C |= C \u2032.\nOur goal is to prove that CA(S) v IA(S) when S is SA\u227asel-saturated, i.e., that every prime implicate of S occurs in CA(S) (up to equivalence)."}, {"heading": "4.1 Definition of \u03a6(S,X )", "text": "Let \u03b1 and \u03b2 be two arbitrarily chosen function symbols not occurring in S, where ar(\u03b1) = 1 and ar(\u03b2) = 0. We assume that \u2200a \u2208 A, \u03b2 \u03b1(a) and that \u2200g 6\u2208 A \u222a {\u03b1}, g(~t) \u03b2.\nFor every clause C and clause set S, sup(C, S) denotes the set inductively defined as follows.\n\u2022 C \u2208 sup(C, S).\n\u2022 If D \u2208 sup(C, S) and D\u2032 is obtained by applying the standard Superposition rule into D from a positive and elementary clause in S, then D\u2032 \u2208 sup(C, S).\nA clause set S is non-redundant iff for every clause C \u2208 S, C is not redundant in S \\ {C}. For every clause set S, it is easy to obtain a non-redundant subset of S that is equivalent to S by recursively removing from S every clause C that is redundant in S \\ {C}.\nWe define the set of standard ground clauses \u03a6(S,X ) as well as a selection function sel\u03a6 as follows.\n2In other words, \u03c3 is such that for every u 6' v \u2208 X , u\u03c3 6= v\u03c3.\nDefinition 30 Let S be a set of A-clauses and let X be an A-set. We denote by \u03a6(S,X ) the set\n\u03a6(S,X ) def= \u03a61(S,X ) ] \u03a62(S,X ) ] \u03a63(S,X ) ] \u03a64(S,X ) ] \u03a65(S,X )\nwhere for i = 1, . . . , 5, \u03a6i(S,X ) is defined as follows:\n1. \u03a61(S,X ) is the set of clauses of the form D\u03c3\u2193X\u2228C \u2032, where [D |Y] \u2208 S, \u03c3 is a ground substitution of domain var(D) such that Y\u03c3 \u2286 X and x\u03c3\u2193X = x\u03c3 for all x \u2208 var(D), and C \u2032 is defined as follows:\n\u2022 C \u2032 def= 2 if D\u03c3 is A-flat and quasi-positive;\n\u2022 C \u2032 def= (\u03b2 6' >) otherwise.\nThe selection function sel\u03a6 is defined on \u03a61(S,X ) as follows: sel\u03a6(D\u03c3\u2193X \u2228 C \u2032) contains all literals l\u2193X such that l \u2208 sel(D\u03c3) and one of the following holds:\n\u2022 l is negative, \u2022 sel(D\u03c3) is positive and l\u2193X is -maximal in D\u03c3\u2193X \u2228 C \u2032.\n2. \u03a62(S,X ) is the set of unit clauses of the form c ' c\u2193X , where c \u2208 A and c 6= c\u2193X . The selection function is defined on \u03a62(S,X ) by: sel\u03a6(c ' c\u2193X ) def = {c ' c\u2193X }.\n3. \u03a63(S,X ) is the set of non-redundant clauses in\u22c3 a6'b\u2208X sup(\u03b1(a\u2193X ) 6' \u03b1(b\u2193X ),\u03a61(S,X )),\nand for all C \u2208 \u03a63(S,X ), sel\u03a6(C) contains all negative literals in C.\n4. \u03a64(S,X ) is the set of non-redundant clauses in\u22c3 p(a1,...,an)./>\u2208X sup(p(a1\u2193X , . . . , an\u2193X ) ./ >,\u03a61(S,X )),\nand for all C \u2208 \u03a63(S,X ), sel\u03a6(C) contains all literals of the form t ./ > in C. Note that the symbol ./ occurring in the generated clause is the same as the one in the corresponding literal p(a1, . . . , an) ./ > of X .\n5. \u03a65(S,X ) = {\u03b2 ' >} \u222a {\u03b1(u) 6' \u03b1(v) \u2228 u ' v | u, v \u2208 A, u = u\u2193X , v = v\u2193X , u 6= v}. We let sel\u03a6(\u03b2 ' >) def = {\u03b2 ' >}, and sel\u03a6(\u03b1(u) 6' \u03b1(v) \u2228 u '\nv) def = {\u03b1(u) 6' \u03b1(v)}.\nIt is easy to verify that the sets \u03a6i(S,X ) with i = 1, . . . , 5 are disjoint. The type of a clause C \u2208 \u03a6(S,X ) is the number i such that C \u2208 \u03a6i(S,X ).\nExample 31 Let A = {a, b, c, d, e}, and X be the reflexive-transitive closure of {a ' b, c ' d, b 6' e}, where a b c d e. Consider the set of clauses\nS = {f(a) ' c\u2228a 6' b, b 6' c, c ' d, [g(x, y) ' f(d) |y 6' e], [f(x) ' x |a ' c]}.\nThen \u03a6(S,X ) is decomposed as follows:\n\u03a61(S,X ): This set consists of f(b) ' d \u2228 a 6' b \u2228 \u03b2 6' >, b 6' d \u2228 \u03b2 6' >, d ' d and g(t, b) ' f(d)\u2228\u03b2 6' >, where t ranges over the set of all ground terms. The constants a and c occurring in S are respectively replaced by b = a\u2193X and d = c\u2193X in \u03a6(S,X ). The A-clause [f(x) ' x | a ' c] generates no clauses in \u03a6(S,X ), since (a ' c) 6\u2208 X .\n\u03a62(S,X ): {a ' b, c ' d}.\n\u03a63(S,X ): {\u03b1(b) 6' \u03b1(e), \u03b1(d) 6' \u03b1(e)}. The first clause is constructed from (b 6' e) \u2208 X , the second one is generated by Superposition into \u03b1(b) 6' \u03b1(e) from the clause b ' d above.\n\u03a64(S,X ): \u2205. There is no predicate symbols other than '.\n\u03a65(S,X ): This set consists of the following clauses:\n{\u03b2 ' >, \u03b1(b) 6' \u03b1(d) \u2228 b ' d, \u03b1(b) 6' \u03b1(e) \u2228 b ' e, \u03b1(d) 6' \u03b1(e) \u2228 d ' e} .\nRemark 32 The addition of \u03b1 is irrelevant from a semantic point of view, since by construction, \u03b1(a) 6' \u03b1(b) if and only if a 6' b for all a, b \u2208 A; it is possible to replace all atoms of the form \u03b1(x) 6' \u03b1(y) by x 6' y. However, this technical trick ensures that all the clauses of type 3 are strictly greater than all elementary A-flat clauses in \u03a6(S,X ), which plays a crucial r\u00f4le in the proof of Lemma 37. Similarly, the addition of the literal \u03b2 6' > does not affect the semantics of the clause set (since by definition \u03b2 ' > occurs in this set), but ensures that all clauses of type 1 that are not quasi-positive are strictly greater than all clauses of type 2 or 3.\nProposition 33 For all sets of clauses S and A-sets X , sel\u03a6 is a selection function for the ordering .\nProof. 3 We must check that for every clause C \u2208 \u03a6(S,X ), sel\u03a6(C) contains either a negative literal in C or all -maximal literals in C (see Definition 30 for the notations). This is immediate for clauses of type 2 and 5, since sel\u03a6(C) = C. For clauses of type 3, we observe that C necessarily contains a negative literal, obtained from the literal \u03b1(a\u2193X ) 6' \u03b1(b\u2193X ) by Superposition. Similarly, all Aclauses of type 4 contains a (unique) literal of the form p(a1, . . . , an) ./ >, that is necessarily maximal. Now assume that C is a clause of type 1, i.e., that C = D\u03c3\u2193X \u2228D\u2032\u2032 for some [D | Y] in S and D\u2032\u2032 \u2286 {\u03b2 6' >}. If we suppose that sel\u03a6(C) contains no negative literal, then the same must hold for sel(D\u03c3), thus sel(D\u03c3) necessarily contains all A-maximal literals in D\u03c3, and by Assumption\n15, if D\u03c3 is A-flat then it must be quasi-positive, and in this case D\u2032\u2032 = 2. Furthermore, by definition of A, for all m \u2208 D\u03c3, if m\u2193X is -maximal in D\u03c3\u2193X , then m is A-maximal in D\u03c3, which entails that sel\u03a6(C) contains all -maximal literals in C (note that if D\u2032\u2032 6= 2 then D is not A-flat, hence D\u03c3 D\u2032\u2032).\nProposition 34 Let Sinit be a set of standard clauses and let S be a set of clauses generated from Sinit by SA\u227asel. Then \u03a6(S,X ) |= Sinit \u2261 S.\nProof. 4 Let S\u2032 = \u03a6(S,X ) and consider the set of standard clauses Scl occurring in S, i.e., Scl def = {C | [C |\u2205] \u2208 S}. Since SA\u227asel is sound, Sinit |= S. Furthermore, if a standard clause is A-redundant in a set of A-clauses, then it is also redundant w.r.t. the standard clauses in this set, by definition of the redundancy criterion. Thus Scl \u2261 S \u2261 Sinit.\nBy construction, S\u2032 contains all the clauses that can be obtained from ground instances of clauses in Scl, by replacing every constant a by a\u2193X and possibly adding literals of the form \u03b2 6' >. Since S\u2032 contains all atoms of the form a ' a\u2193X where a 6= a\u2193X as well as the atom \u03b2 ' >, we deduce that S\u2032 |= Scl, and that S\u2032 |= Sinit \u2261 S."}, {"heading": "4.2 Saturatedness of \u03a6(S,X )", "text": "The next lemma states that \u03a6(S,X ) is saturated w.r.t. a slight restriction of the usual Superposition calculus. We shall also use a refined version of the redundancy criterion.\nDefinition 35 A set of ground clauses S is weakly saturated w.r.t. an inference rule in SP\u227asel\u03a6 if every application of the rule on a set of premises {C1, . . . , Cn} \u2286 S (with n = 1, 2) yields a clause C such that there exists {D1, . . . , Dm} \u2286 S with \u2200i \u2208 [1,m], Di \u227a max\u227a({C1, . . . , Cn}) and {D1, . . . , Dm} |= C.\nLemma 36 Let S be a set of ground clauses that is weakly saturated w.r.t. all rules in SP\u227asel\u03a6 . The set S is satisfiable iff it does not contain 2.\nProof. 5 See (Bachmair and Ganzinger, 1994) or (Nieuwenhuis and Rubio, 2001, theorem 4.8).\nLemma 37 below is the main technical result that is used to prove the completeness of SA\u227asel.\nLemma 37 Let S be an SA\u227asel-saturated set of A-clauses and let X be a ground and satisfiable A-set. The set \u03a6(S,X ) is weakly saturated under all inference rules in SP\u227asel\u03a6 , except for Equational Factorization on positive A-flat clauses.\nProof. 6 The proof is given in Appendix B.\nRemark 38 The set \u03a6(S,X ) is not saturated under Equational Factorization, because the literal \u03b2 6' > is not added to the clauses that are positive and A-flat, and such clauses can have non-positive descendants. For example, {a ' b\u2228 a ' c, b 6' c} is SA\u227asel-saturated, but \u03a6(S, \u2205) = {a ' b\u2228 a ' c, b 6' c\u2228\u03b2 6' >, \u03b2 ' >} is not.\nCorollary 39 Let S be an SA\u227asel-saturated set of A-clauses and let X be a ground and satisfiable A-set. If \u03a6(S,X ) is unsatisfiable then it contains 2.\nProof. 7 The proof is not straightforward since \u03a6(S,X ) is not saturated w.r.t. Equational Factorization on A-flat A-clauses, as explained above. However it can be shown that the application of this rule on A-flat is useless in our context; this is due to the fact that the constants in A are not ordered (see Appendix C for details)."}, {"heading": "4.3 Deductive Completeness Theorem", "text": "The previous results lead to the following theorem, which states that the calculus SA\u227asel can be used to generate all ground implicates built on A.\nTheorem 40 Let Sinit be a set of standard clauses and let S be a set of Aclauses obtained from Sinit by SA\u227asel-saturation. Then CA(S) v IA(Sinit).\nProof. 8 Let C \u2208 IA(Sinit), let X be the smallest A-set containing Cc and let S\u2032 def = \u03a6(S,X ). Note that X is ground since C is ground. Since X is equivalent to Cc and C is not a tautology, this A-set is satisfiable. We first prove that S\u2032 is equivalent to S\u2032\u2032 def= S \u222a Cc \u222a {\u03b2 ' >, \u03b1(u) 6' \u03b1(v) \u2228 u ' v | u, v \u2208 A}, and therefore unsatisfiable. By Proposition 34 S\u2032 |= Sinit \u2261 S; since \u03a62(S,X ) \u222a \u03a63(S,X ) \u2286 S\u2032, we have S\u2032 |= Cc, and since \u03a65(S,X ) \u2286 S\u2032, we conclude that S\u2032 |= S\u2032\u2032. We now show that S\u2032\u2032 entails all clauses in S\u2032.\nClauses in \u03a65(S,X ). All the clauses in \u03a65(S,X ) are in S\u2032\u2032, and the result is obvious.\nClauses in \u03a62(S,X ). For all c \u2208 A, Cc |= c ' c\u2193X . Since Cc \u2286 S\u2032\u2032, we have the result.\nClauses in \u03a61(S,X ). Let [D | Y] \u2208 S, and consider a ground substitution \u03c3 such that Y\u03c3 \u2286 X and x\u03c3\u2193X = x\u03c3 for all x \u2208 var(D). Then S\u2032\u2032 |= D\u03c3, and since Y\u03c3 \u2286 X \u2261 Cc, S\u2032\u2032 |= (D\u03c3)\u2193X . But \u03b2 ' > \u2208 S\u2032\u2032, thus S\u2032\u2032 |= (D\u03c3)\u2193X \u2228 C \u2032, regardless of whether C \u2032 = 2 or C \u2032 = (\u03b2 6' >).\nClauses in \u03a64(S,X ). These clauses are all in Cc, hence the result is obvious.\nClauses in \u03a63(S,X ). Consider a literal a 6' b \u2208 X . Since the clause a ' b \u2228 \u03b1(a) 6' \u03b1(b) occurs in S\u2032\u2032, we have S\u2032\u2032 |= \u03b1(a) 6' \u03b1(b); therefore, S\u2032\u2032 |= sup(\u03b1(a\u2193X ) 6' \u03b1(b\u2193X ),\u03a61(S,X )).\nSince S\u2032\u2032 is unsatisfiable by construction, so is S\u2032 and by Corollary 39, S\u2032 contains the empty clause. This means that S must contain an A-clause of the form [2 |Y] where Y\u03b8 \u2286 Cc. By definition CA(S) contains the clause (Y\u03b8)c and since Y\u03b8 \u2286 Cc we have (Y\u03b8)c |= C.\nNote that Theorem 40 does not hold if S is not obtained by SA\u227asel-saturation from a set of standard clauses; this is due to the fact that no inference is performed on the literals occurring in the constraints. For example, the set: S = {[2 | a ' b], [2 | a 6' b]} is clearly unsatisfiable and SA\u227asel-saturated, however we have CA(S) = {a ' b, a 6' b} 6v IA(S), since 2 \u2208 IA(S). We also provide an example showing that the theorem does not hold if A-Superposition into the variables occurring in the constraints is not allowed.\nExample 41 Let S def= {x ' a \u2228 x ' c, x ' b \u2228 x ' d} and C def= e ' a \u2228 e ' b\u2228c ' d. It is straightforward to verify that S |= C. The only way of generating an A-clause [2 |X ] such that X\u03c3 |= Cc is to apply the Superposition rule on the literals x ' c and x ' d upon the term x, which is usually forbidden. This can be done by first applying the A-Assertion rule on the literals x ' a and x ' b, yielding [x ' c | {x 6' a}] and [x ' d | {x 6' b}]. Then it is possible to apply the Superposition on the term x since it occurs in the constraints. This yields [c ' d | {x 6' a, x 6' b}], and by applying the A-Assertion rule again, we obtain the A-clause [2 |{x 6' a, x 6' b, c 6' d}], which satisfies the required property."}, {"heading": "5 Refinements", "text": "Theorem 40 proves that SA\u227asel-saturation permits to obtain the prime Aimplicates of any set of clauses. This set may still be very large, it could thus require a lot of time to be generated and be difficult to handle. In this section we introduce some refinements of the calculus SA\u227asel, showing that at almost no cost, it is possible to generate only those prime A-implicates of a clause set S that satisfy properties that are closed under subsumption (see Definition 42), or to obtain a more concise representation of all the A-implicates of S."}, {"heading": "5.1 Imposing Additional Restriction on the Implicates", "text": "The first refinement is rather straightforward: it consists in investigating how the calculus can be adapted to generate implicates satisfying additional arbitrary restrictions (e.g., for generating implicates of some bounded cardinality, or purely positive implicates). We show that some restrictions can be imposed on the constraint part of all the A-clauses occurring in the search space without losing deductive completeness; in other words, inferences yielding to A-clauses whose constraints do not fulfill the considered restriction can be blocked. This is possible if these implicates belong to some class that is closed under some form of logical generalization. More formally:\nDefinition 42 A set of clauses P is closed under subsumption if for every C \u2208 P and for every clause D such that D\u03c3 \u2286 C for some substitution \u03c3, we have D \u2208 P. An A-clause [C |X ] is P-compatible if X c \u2208 P.\nProposition 43 Let P be a set of clauses that is closed under subsumption, and let [E | Z] be an A-clause generated by an SA\u227asel-rule, with [C | X ] as a premise. If [E |Z] is P-compatible, then so is [C |X ].\nProof. 9 We only consider the case where [E | Z] is generated by the ASuperposition rule applied to [C |X ] and [D |Y], the case for the unary inference rules is similar. Then by definition, Z = (X \u222a Y \u222a E)\u03c3, where (\u03c3, E) is an (X \u222a Y)-pure A-substitution, and we have\nX c\u03c3 \u2286 [(X \u222a Y \u222a E)\u03c3]c = Zc.\nSince P is closed under subsumption, we deduce that [C |X ] is P-compatible.\nSA\u227asel(P) denotes the calculus SA \u227a sel in which all inferences that generate non-P-compatible A-clause are blocked. The following theorem shows that the calculus SA\u227asel(P) is deductive complete for the clauses in Cflat(A) \u2229P.\nTheorem 44 Let Sinit be a set of standard clauses and let S be a set of Aclauses obtained from Sinit by SA\u227asel(P)-saturation. If P is closed under subsumption then CA(S) v IA(Sinit) \u2229P.\nProof. 10 A simple induction together with Proposition 43 proves that all the ancestors of P-compatible clauses generated by SA\u227asel are necessarily Pcompatible themselves. Since 2 \u2208 P for all sets P that are closed under subsumption, all the clauses in Sinit must be P-compatible, hence the result.\nExamples of classes of clauses that are closed under subsumption include the following sets that are of some practical interest:\n\u2022 The set of clauses C such that there exists a substitution \u03c3 such that C\u03c3 is equivalent to a clause of length at most k.\n\u2022 The set of positive (resp. negative) clauses.\n\u2022 The set of implicants of some formula \u03c6.\nNote also that the class of clause sets that are closed under subsumption is closed under union and intersection, which entails that these criteria can be combined easily."}, {"heading": "5.2 Discarding the Inferences on A-flat Clauses", "text": "In this section we impose a restriction on the calculus that consists in preventing inferences on A-literals. The obtained calculus is not complete since it does not generate all A-implicates in general, but it is complete in a restricted sense: every A-implicate is a logical consequence of the set of A-flat clauses generated by the calculus.\nDefinition 45 We denote by SAR\u227asel the calculus SA \u227a sel in which no inference upon A-literals is allowed, except for the A-Assertion and A-Reflection rules. We denote by \u03a8(S,X ) the set obtained from \u03a6(S,X ) by deleting, in every clause C \u2208 \u03a6(S,X ), each literal l such that the unit clause lc belongs to X \u222a {\u03b2 ' >}.\nExample 46 Consider the set of clauses and A-set from Example 31. The set \u03a8(S,X ) contains the following clauses:\n\u2022 f(b) ' d, b 6' d, d ' d and g(t, b) ' f(d), where t ranges over the set of all ground terms;\n\u2022 a ' b and c ' d;\n\u2022 \u03b1(b) 6' \u03b1(e) and \u03b1(d) 6' \u03b1(e);\n\u2022 \u03b2 ' >, \u03b1(b) 6' \u03b1(d) \u2228 b ' d, \u03b1(b) 6' \u03b1(e) and \u03b1(d) 6' \u03b1(e) \u2228 d ' e.\nProposition 47 For all sets of A-clauses S and A-sets X , \u03a6(S,X ) \u2261 \u03a8(S,X ).\nSAR\u227asel essentially simulates the calculus in (Echenim and Peltier, 2012), but there are some important differences: in particular our previous approach does not handle variable-active axioms and is complete only for implicates containing no predicate symbol other than '. This entails that for example, an implicate of the form p(c1, . . . , cn) ' d can only be generated if a new constant c is added to A, along with the axiom c \u21d4 p(c1, . . . , cn). It is clear that applying this operation on all ground atoms is costly from a practical point of view. This is avoided with the new calculus SAR\u227asel, thanks to the addition of new inference rules.\nLemma 48 Let S be an SAR\u227asel-saturated set of A-clauses and let X be a complete and satisfiable A-set. The set \u03a8(S,X ) is SP\u227asel\u03a6-saturated.\nProof. 11 We prove that every A-flat clause of type 1 in \u03a8(S,X ) is redundant in \u03a8(S,X ). Let C = a ./ b \u2228 C \u2032 be such a clause, by definition of \u03a6(S,X ), we have a = a\u2193X and b = b\u2193X . If a = b then either ./=', in which case a ./ b \u2228 C is a tautology, or ./= 6', in which case (a 6' a)c \u2208 X , and C cannot occur in \u03a8(S,X ). Thus a 6= b, and since X is complete, we deduce that a 6' b \u2208 X ad that \u03b1(a) 6' \u03b1(b) occurs in \u03a6(S,X ). This implies that ./ is 6', since otherwise the literal a ' b would have been deleted from the clause. Thus, C is of the form a 6' b \u2228 C \u2032; it is not positive, and by construction, it contains the literal \u03b2 6' >. We deduce that \u03b1(a) 6' \u03b1(b) |= C and that \u03b1(a) 6' \u03b1(b) \u227a C; C is therefore redundant. This implies that the only non-redundant inferences that can be applied on clauses in \u03a8(S,X ) are upon literals that are not A-flat. The restriction on the calculus SAR\u227asel does not affect such inferences, thus, as shown in the proof of Lemma 37, they can be simulated by inferences on the corresponding A-clauses in S.\nThe next theorem states a form of completeness for the restricted calculus SAR\u227asel, which is weaker than that of the calculus SA \u227a sel (compare with Theorem 40) and similar to that of (Echenim and Peltier, 2012). The proof is based on the following result.\nProposition 49 Let S be a set of A-clauses and let X be a complete A-set. Then \u03a8(S,X ) |= S.\nProof. 12 By Proposition 47 we have \u03a8(S,X ) \u2261 \u03a6(S,X ). Let [C | Y] be a clause in S and let \u03c3 be a ground Y-pure substitution. If Y\u03c3 6\u2286 X , then there exists l \u2208 Y\u03c3 such that l 6\u2208 X and since X is complete we deduce that lc \u2208 X , which entails that X |= Y\u03c3c, and thus \u03a6(S,X ) |= Y\u03c3c (since by Proposition 66 \u03a6(S,X ) |= X ). Otherwise, we must have C\u03c3\u2193X\u2228C \u2032 \u2208 \u03a6(S,X ), with C \u2032 \u2286 \u03b2 6' > and since \u03b2 ' > \u2208 \u03a6(S,X ) we deduce that \u03a6(S,X ) |= C\u03c3.\nTheorem 50 Let S be an SAR\u227asel-saturated set of A-clauses. Then CA(S) |= IA(S).\nProof. 13 We prove the contrapositive, i.e., that every counter-model of IA(S) is a counter-model of CA(S). Let M be a counter-model of IA(S) and let X be the corresponding A-set, i.e. the set containing all A-flat literals that are true in M. By definition, X is complete and satisfiable. By Proposition 49, \u03a8(S,X ) |= S |= IA(S). Since \u03a8(S,X ) |= X and X \u222a IA(S) is unsatisfiable, we deduce that \u03a8(S,X ) is unsatisfiable; but \u03a8(S,X ) is SP\u227asel\u03a6-saturated by Lemma 48, hence 2 \u2208 \u03a8(S,X ). We deduce that S contains an A-clause of the form [C | Y] and there exists a substitution \u03c3 such that Cc\u03c3\u2193X \u222a Y\u03c3 \u2286 X . Without loss of generality, we assume that C is the clause with the least number of literals satisfying this property. Assume that C is nonempty. Then sel\u03a6(C\u03c3\u2193X ) contains at least one literal (u ./ v)\u03c3\u2193X and C is of the form u ./ v \u2228 D. If ./ is ', then the A-Assertion rule can be applied to this literal, yielding the A-clause [D | Y \u222a {u 6' v}]. Since S is SAR\u227asel-saturated, this A-clause must be A-redundant and by Definition 19, S contains an A-clause [D\u2032 | Y \u2032], such that, for some substitution \u03b8, D\u2032\u03b8 \u2286 D\u03c3 and (Y \u2032 \u222a {u 6' v})\u03b8 \u2286 Y\u03c3 (note that D\u03c3 cannot be a tautology because Dc\u03c3 \u2286 X and X is satisfiable). This is impossible because then [D\u2032 | Y \u2032] would then satisfy the above restriction, thus contradicting the minimality of C. If ./ is 6' then (u ' v)\u03c3\u2193X must occur in X since Cc\u03c3\u2193X \u2286 X ; this implies that u\u03c3\u2193X = v\u03c3\u2193X , hence that u\u03c3 \u223cXA v\u03c3. Thus the A-Reflection rule applies, yielding [D |Y \u222aE ]\u03b7, where (\u03b7, E) is the most general unifier of u and v. There exists a substitution \u03c3\u2032 such that \u03c3 \u223cXA \u03b7\u03c3\u2032, and by the same reasoning as previously, since S is SAR\u227asel-saturated, it contains an A-clause [D\u2032 | Y \u2032] and there exists a substitution \u03b8\u2032 such that D\u2032\u03b8\u2032 \u2286 D\u03b7\u03c3\u2032 and Y \u2032\u03b8\u2032 \u2286 Y\u03b7\u03c3\u2032 \u222a E. But then (D\u2032\u03b8\u2032\u2193X )c \u2286 (D\u03b7\u03c3\u2032\u2193X )c = (D\u03c3\u2193X )c \u2286 X , and Y \u2032\u03b8\u2032\u2193X \u2286 (Y\u03b7\u03c3\u2032 \u222a E)\u2193X = (Y\u03c3 \u222a E)\u2193X \u2286 X . Again, this contradicts the minimality of C. Therefore, C is empty, and (Y\u03c3)c \u2208 CA(S). Now Y\u03c3 \u2286 X , thusM 6|= (Y\u03c3)c, which proves thatM is indeed a counter-model of CA(S), and the proof is completed.\nThe difference between the calculi SA\u227asel and SAR \u227a sel can be summarized as\nfollows.\n\u2022 The calculus SA\u227asel explicitly generates all prime implicates in IA(S), whereas SAR\u227asel only generates a finite representation of them, in the form of an A-flat implicant S\u2032 of IA(S). The formula S\u2032 can still contain redundancies and some additional post-processing step is required to generate explicitly the prime implicates of S\u2032 if needed. Any algorithm for generating prime implicates of propositional clause sets can be used for this purpose, since flat ground equational clause sets can be reduced into equivalent sets of propositional clauses by adding equality axioms. In (Echenim et al, 2013) a much more efficient algorithm has been proposed, in which equality axioms are directly taken into account in the inference engine and redundancy pruning mechanism. From a practical point of view, the set IA(S) can be very large, thus S\u2032 can also be viewed as a concise and suitable representation of such a set.\n\u2022 The calculus SAR\u227asel restricts inferences on A-flat literals to those that actually delete such literals, possibly by transferring them to the constraint part of the clauses (the A-Assertion and A-Reflection rules). From a practical point of view, this entails that these literals do not need to be considered anymore in the clausal part of the A-clause: they can be transferred systematically in the constraints. This can reduce the number of generated clauses by an exponential factor, since a given A-flat clause l1 \u2228 . . . \u2228 ln can be in principle represented by 2n distinct A-clauses depending on whether li is stored to the clausal or constraint part of the A-clause (for instance a ' b can be represented as [a ' b |\u2205] or [2 |a 6' b]). Furthermore, the number of applicable inferences is also drastically reduced, since the rules usually apply in many different ways on (selected) A-literals, due to the fact that two A-flat terms are always A-unifiable and that the ordering A is empty when applied on terms in A. For example the clauses a ' b and c ' d generate the A-clauses\n[d ' b |{a ' c}], [d ' a |{b ' c}], [c ' b |{a ' d}], [c ' a |{b ' d}],\nregardless of the ordering \u227a.\nThe following example illustrates the differences between SA\u227asel and SAR \u227a sel.\nExample 51 Let S = {f(a, b) 6' f(c, d), g(x) ' 0 \u2228 x ' c, g(a) 6' 0}, where x \u2208 V, g(x) a b c d and A = {a, b, c, d}. It is easy to check that SAR\u227asel generates the implicates [2 |{a ' c, b ' d}] (by A-Reflection on the first clause) and [2 |{a 6' c}] (by an application of the A-Superposition rule from the second clause into the third one, followed by an application of the A-Assertion rule). However, the implicate [2 | {b ' d}] that is a logical consequence of the above A-clauses is not generated. In contrast, it is possible to infer this implicate with SA\u227asel: First the A-Superposition rule generates as usual the clauses a ' c and then f(c, b) 6' f(c, d) (the constraints are empty at this point since all the\nconsidered A-unifiers are standard unifiers), and [2 | {b ' d}] is inferred by applying A-Reflection on the latter clause. Note that SA\u227asel has a larger search space than SAR\u227asel. Consider for instance a clause a ' b \u2228 c ' d. SAR \u227a sel simply reduces this clause into [2 | {a 6' b, c 6' d}] and no further inference is applicable on it, while SA\u227asel also generates the A-clauses [a ' b | {c 6' d}] and [c ' d |{a 6' b}], which in turn possibly enable other inferences.\nIt is possible to combine the two calculi SA\u227asel and SAR \u227a sel. This can be done as follows.\n\u2022 Starting from a set of clauses S, SAR\u227asel is first applied until saturation, yielding a new set S\u2032. By Theorem 50 we have CA(S\u2032) \u2261 IA(S).\n\u2022 Then SA\u227asel(P) is applied on CA(S\u2032) until saturation yielding a set S\u2032\u2032, where P denotes the set of clauses that logically entail at least one clause in CA(S\u2032). It is clear that this set of clauses is closed under subsumption, hence by Theorem 44, we eventually obtain a set of clauses CA(S\u2032\u2032) v IA(CA(S\u2032)) \u2229P. But IA(CA(S\u2032)) \u2229P v CA(S\u2032), hence CA(S\u2032\u2032) v CA(S\u2032), and CA(S\u2032\u2032) \u2261 IA(S). The set of clauses CA(S\u2032\u2032) can therefore be considered as a concise representation of IA(S). This approach is appealing since CA(S\u2032\u2032) is in generally much smaller than IA(S), and contrary to CA(S\u2032), this set is free of redundancies.\nAnother straightforward method to eliminate redundant literals from the clauses in CA(S\u2032) without having to explicitly compute the set IA(S\u2032) is to test, for every clause l\u2228C \u2208 CA(S\u2032), whether the relation CA(S\u2032) |= C, holds, in which case the literal l can be safely removed. The test can be performed by using any decision procedure for ground equational logic (see for instance Meir and Strichman, 2005; Dillig et al, 2010, for a similar approach). Note however that removing redundant literals is not sufficient to obtain prime implicates, as shown in the following example.\nExample 52 Consider the clause set: S def= {a 6' c\u2228 b 6' c\u2228 d ' e, a ' c\u2228 a ' f, b ' c \u2228 a ' f, f 6' b}. It is easy to check that a 6' b \u2228 d ' e is an implicate of S and that this clause is strictly more general than a 6' c \u2228 b 6' c \u2228 d ' e. The calculus SA\u227asel computes the A-clause [2 | {a ' b, d ' e}], yielding the set of prime implicates: S\u2032 def= {a 6' b \u2228 d ' e, a ' c \u2228 a ' f, b ' c \u2228 a ' f, f 6' b}. S\u2032 is equivalent to S and strictly smaller. In contrast, the approach devised by Dillig et al (2010) cannot simplify S since there is no useless literal."}, {"heading": "6 Termination", "text": "We relate the termination behavior of SA\u227asel to that of the usual Superposition calculus. We first introduce restricted ordering and redundancy criteria. For all expressions (terms, atoms, literals or clauses) t and s, we write t BA s if t\u2032 s\u2032 holds for all expressions t\u2032, s\u2032 such that t \u223cA t\u2032 and s \u223cA s\u2032. Note that the ordering BA is stronger than A (and also stronger than ) because the\nconstants in t and s can be rewritten independently of each other. Assume for instance that \u227a is such that f(a) \u227a g(a) \u227a f(b) \u227a g(b) with A = {a, b}. Then it is easy to check that g(a) A f(a) but g(a) 6BA f(a) since g(a) \u227a f(b) \u223cA f(a). Also, let selA be the selection function defined from the function sel as follows: for every clause l \u2228 C, l \u2208 selA(l \u2228 C) if there exists l\u2032, C \u2032 such that l\u2032 \u223cA l, C \u2032 \u223cA C and l\u2032 \u2208 sel(l\u2032 \u2228 C \u2032). We show that most termination results for the calculus SPCAselA also apply to SA \u227a sel. To this purpose, we consider a restricted form of redundancy testing.\nDefinition 53 A standard clause C is strongly redundant in a set of standard clauses S iff for every clause C \u2032 \u223cA C, C \u2032 is A-redundant in S.\nDefinition 54 For every set of A-clauses S and for every ground A-set Y, we denote by \u0393(S,Y) the set of standard clauses C\u03c3, where [C |X ] \u2208 S and \u03c3 is an X -pure substitution of domain var(X ) such that \u03c3\u2193Y = \u03c3 and X\u03c3 \u2286 Y.\nThe definition of \u0393(S,Y) is similar to that of \u03a6(S,Y) (see Section 4), except that: (i) only the variables occurring in X are instantiated; (ii) the clauses are not reduced with respect to the equations in the constraint part (but the constants replacing the variables in X are reduced).\nExample 55 Let S = {[f(x, y) ' a |{x 6' b}]} with A = {a, b, c} and a b c. We have \u0393(S, {a 6' b, a ' c}) = {f(c, y) ' a} and \u0393(S, {a 6' b, c 6' b}) = {f(a, y) ' a, f(c, y) ' a}.\nLemma 56 Let S be a set of A-clauses, E be an A-clause and U be a ground A-set.\n\u2022 If E can be deduced from S by SA\u227asel, then every clause in \u0393(E,U) can be deduced from \u0393(S,U) \u222a U by SPCAselA .\n\u2022 If S is a set of standard clauses and \u0393(E,U) contains a clause that is strongly redundant in \u0393(S,U) then E is A-redundant in S.\nProof. 14 See Appendix D.\nWe denote by UA the set of all unit clauses of the form p(a1, . . . , an) ./ > or a ./ b, with a1, . . . , an, a, b \u2208 A. For any set of clauses S, we denote by S? the set of clauses inductively defined as follows.\n\u2022 S \u2286 S?.\n\u2022 If C is not strongly redundant in S and is deducible from S? \u222a UA by applying the rules in SPCAselA (in one step), then C \u2208 S ?.\nLemma 56 immediately entails the following:\nCorollary 57 Let S be a set of clauses. If S? is finite then SA\u227asel terminates on S (up to redundancy).\nIn order to prove that SA\u227asel terminates on some class of clause sets S, it suffices to prove that S? is finite, for every S \u2208 S. The calculus SPCAsel is slightly less restrictive than the usual Superposition calculus SP\u227asel, since CA is a stronger relation than \u227a. However, most of the usual termination results for the Superposition calculus still hold for SPCAsel , because they are closed under the addition of equalities between constants and do not depend on the order of \u223cA-equivalent terms. Similarly, redundancy testing is usually restricted to subsumption and tautology detection. In particular, all the termination results described by Armando, Ranise, and Rusinowitch (2003) are preserved (it is easy to check that S? is finite for the considered sets of axioms).\nAn interesting continuation of the present work would be to devise formal (automated) proofs of the termination of SA\u227asel on the usual theories of interest in program verification, enriched by arbitrary ground clauses. This could be done by using existing schematic calculi (see, e.g., Lynch and Morawska, 2002; Lynch et al, 2011; Tushkanova et al, 2013) to compute a symbolic representation of the set of A-clauses S?."}, {"heading": "7 Conclusion and Discussion", "text": "Although the Superposition calculus is not deductive-complete in general, we have shown that it can be adapted in order to make it able to generate all implicates defined over a given finite set of ground terms denoted by constant symbols, using a finite set of predicate symbols including the equality predicate. Furthermore, this is done in such a way that the usual termination properties of the calculus are preserved. By duality, the procedure can be used to generate abductive explanations of first-order formul\u00e6.\nA major restriction of our approach is that it cannot handle built-in theories such as arithmetics which play an essential r\u00f4le in verification. Axiomatizing these theories in first-order logic is infeasible or inefficient. A natural follow-up of this work is therefore to make the procedure able to cooperate with external decision procedures. This can be done for instance by combining our approach with existing techniques for fusing the Superposition calculus and external reasoning tools (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013). These techniques, based on the use of constrained Superposition together with an abstraction of the terms of the considered theory, should be easy to combine with A-Superposition. Note that our calculus has many commun points with the above-mentioned constrained Superposition calculi, however in our case the constraint and clausal parts are not defined over disjoint signatures: in contrast the A-unification and Assertion rules allow one to transfer literals from the clausal part to the constraints. In other approaches (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013) the constraints are used to store formul\u00e6 that cannot be handled by the Superposition calculus, whereas in our case they are used to store properties that are asserted instead of being proved.\nAnother obvious drawback with the calculi SA\u227asel and SAR \u227a sel is that the\nuser has to explicitly declare the set of abducible terms (i.e., the constants in A). This set must be finite and must contain all built-in constants. Note that, thanks to the results in Section 5, unsatisfiable or irrelevant implicates (such as 0 ' 1) can be easily detected and discarded on the fly during proof search. Handling infinite (but recursive) sets of terms is possible from a theoretical point of view: it suffices to add an inference rule generating clauses of the form a ' t, where t is an abducible ground terms and a is a fresh abducible constant symbol. It is easy to see that completeness is preserved, but of course termination is lost. A way to recover termination is to develop additional techniques to restrict the application of this rule by selecting the terms t. This could be done either statically, from the initial set of clauses, or dynamically, from the information deduced during proof search.\nAnother possible extension would be to generate \u201cmixed\u201d implicates, containing both abducible and non-abducible terms, which would avoid having to declare built-in constants as abducible. An alternative approach consists in avoiding to have to explicitly declare abducible terms, by adding rules for generating them symbolically (as the A-Substitutivity rule does for predicate symbols). For termination, additional conditions should be added to ensure that the set of abducible terms is finite (using, e.g., sort constraints).\nAnother restriction is that our method does not handle non-ground abducible terms, hence cannot generate quantified formul\u00e6. We are now investigating these issues."}, {"heading": "B Proof of Lemma 37", "text": "The proof is based on the following intermediate results.\nDefinition 61 Let S be a set of A-clauses and X be an A-set. If u ./ v\u2228C\u2228D is a clause of type 1 in \u03a6(S,X ), where ./\u2208 {', 6'} and D \u2286 {\u03b2 6' >}, then there exist an A-clause [u\u2032 ./ v\u2032 \u2228 C \u2032 | Y] \u2208 S and a substitution \u03c3 such that3 (u\u2032\u03c3)\u2193X = u, (v \u2032\u03c3)\u2193X = v, (C \u2032\u03c3)\u2193X = C and Y\u03c3 \u2286 X . The term occurrence u is superposable in u ./ v \u2228 C if u\u2032 occurs in Y whenever it is a variable.\nProposition 62 Let S be a set of A-clauses and X be an A-set. Let C be a clause of type 1 in \u03a6(S,X ) and a, b be constants in A such that a\u2193X = a and b\u2193X = b. Let P be a set of non-superposable occurrences of a in C. Then there exists a set P \u2032 of occurrences of a in C that contains P , and a clause D in \u03a6(S,X ) such that D is obtained from C by replacing all occurrences of a in P \u2032 by b.\nProof. 17 By definition, there exists an A-clause [C \u2032 |Y] \u2208 S and a substitution \u03c3 such that C = C \u2032\u03c3\u2193X \u2228 C \u2032\u2032, C \u2032\u2032 \u2286 {\u03b2 6' >} and Y\u03c3 \u2286 X . Since P is a set of non-superposable occurrences in C, the subterms of D at the positions in P are variables x1, . . . , xn not occurring in Y.\nConsider the substitution \u03b8 coinciding with \u03c3, except that \u2200i \u2208 [1, n], xi\u03b8 def = b. Since the variables xi (1 \u2264 i \u2264 n) do not occur in Y, \u03b8 and \u03c3 coincide on Y, hence Y\u03b8 \u2286 X . This means that \u03a6(S,X ) must contain the clause of type 1 C \u2032\u03b8\u2193X \u2228 C \u2032\u2032 (note that C \u2032\u2032 is not affected because C \u2032\u03c3 is A-flat and positive exactly when C \u2032\u03b8 satisfies the same property). By definition, since a\u2193X = a and b\u2193X = b, C \u2032\u03b8\u2193X \u2228 C \u2032\u2032 is therefore obtained from C = C \u2032\u03c3\u2193X \u2228 C \u2032\u2032 by replacing some occurrences of a by b, and in particular, all the occurrences in P are replaced.\nNote that P \u2032 can be a strict superset of P : for example, if S = {x ' c\u2228x ' d}, then a ' c\u2228a ' d \u2208 \u03a6(S, \u2205), position 1.1 is not superposable in a ' c\u2228a ' d, and it is clear that b ' c \u2228 b ' d \u2208 \u03a6(S, \u2205) but b ' c \u2228 a ' c 6\u2208 \u03a6(S, \u2205).\nProposition 63 Let [C | X ] be an A-clause; assume that X is satisfiable and that C is A-flat and quasi-positive. Then [C |X ] is a tautology if and only if C\u2193X is either a tautology or contains a literal that also occurs in X . In particular, if C is elementary and positive then [C | X ] is a tautology exactly when C\u2193X is a tautology.\nProof. 18 Assume that C\u2193X is not a tautology and contains no literal in X . Let I be the interpretation such that \u2200a, b \u2208 A, I |= a ' b iff a\u2193X = b\u2193X and for all a1, . . . , an where ai\u2193X = ai, I |= p(a1, . . . , an) ' > iff p(a1, . . . , an) ' > \u2208 X or p(a1, . . . , an) 6' > \u2208 C\u2193X . Note that I is well-defined, since X and C\u2193X share no literals and neither of them contains complementary literals. By definition, I validates all positive literals in X . If a 6' b \u2208 X and I 6|= a 6' b, then a\u2193X = b\u2193X , hence X |= a ' b, which means that X is unsatisfiable, and this contradicts the hypothesis of the lemma. Similarly, if p(a1, . . . , an) 6' > \u2208 X\n3If several terms u\u2032 satisfying the above conditions exist then one of them is chosen arbitrarily.\nand I |= p(a1, . . . , an) ' > then since X is satisfiable, p(a1, . . . , an) 6' > must occur in C\u2193X , which contradicts the hypothesis that X and C\u2193X share no literals. Therefore, I |= X . Now consider a literal l \u2208 C. Since C is A-flat and quasipositive, l is of the form a ' b or p(a1, . . . , an) ./ >. If l is of the form a ' b and a\u2193X = b\u2193X then C\u2193X is a tautology, and this is impossible by hypothesis. Thus a\u2193X 6= b\u2193X and I 6|= a ' b. Now assume that l is of the form p(a1, . . . , an) ' > and that I |= l; the case where l is of the form p(a1, . . . , an) 6' > is similar. Let m = p(a1\u2193X , . . . , an\u2193X ) ' >. Since I |= l,X , it is clear that I |= m, thus by definition of I, either m \u2208 X or mc \u2208 C\u2193X . In the first case m occurs in both X and C\u2193X , and in the second case, both m and mc occur in C\u2193X which is a tautology; thus we get a contradiction in both cases. Therefore, I is a counter-model of [C |X ].\nThe converse is straightforward.\nNote that the previous property does not hold if C is not quasi-positive; for example, [a 6' b |a 6' b] is a tautology but the unit clause (a 6' b)\u2193{a6'b} = a 6' b is not.\nLemma 64 Let S be an SA\u227asel-saturated set of A-clauses and X be an A-set. For i = 1, 2, let ui ' vi \u2228 Ci be an A-flat clause of type 1 in \u03a6(S,X ), and assume that ui 6= vi. If the following conditions hold:\n\u2022 u1 = u2 6= >,\n\u2022 u1 is superposable in u1 ' v1 \u2228 C1,\n\u2022 for i = 1, 2, ui ' vi \u2208 sel\u03a6(ui ' vi \u2228 Ci),\n\u2022 v1 ' v2 \u2228 C1 \u2228 C2 is not a tautology,\nthen \u03a6(S,X ) contains a clause of type 1 contained in v1 ' v2 \u2228 C1 \u2228 C2.\nProof. 19 For i = 1, 2, since ui ' vi \u2228Ci is of type 1, there exists an A-clause [ti ' si \u2228Di | Yi] \u2208 S and a substitution \u03c3i such that Yi\u03c3i \u2286 X , Di\u03c3i\u2193X = Ci, ti\u03c3i\u2193X = ui and si\u03c3i\u2193X = vi.\nLet \u03c3 = \u03c31\u03c32. Since u1 = u2, we have t1\u03c3 = t1\u03c31 \u223cXA t2\u03c32 = t2\u03c3, hence (\u03c3,X ) is an A-unifier of t1 ' t2. Let (\u03b7,Z) be a most general A-unifier of t1 ' t2, then Z \u2286 X , and there exists a ground substitution \u03c3\u2032 such that \u2200x, x\u03b7\u03c3\u2032 \u223cXA x\u03c3. Now, [(ti ' si)\u03b7\u03c3\u2032]\u2193X = ui ' vi, which is selected in ui ' vi \u2228Ci, and since sel is stable under A-substitutions, (ti ' si)\u03b7 \u2208 sel((ti ' si \u2228Di)\u03b7).\nBy hypothesis v1, v2 \u2208 A \u222a V, hence s1, s2 \u2208 A \u222a V. By definition of A, this implies that si\u03b7 6 A ti\u03b7: indeed, s1, s2 can be replaced by the minimal constant >, either by instantiation or by rewriting of constants in A. Note also that si\u03b7 6= ti\u03b7 since otherwise we would have ui = vi, which contradicts the hypotheses of the lemma.\nSince u1 is superposable, either t1 is not a variable or t1 occurs in Y1, hence by definition of SA\u227asel, the A-Superposition from [t2 ' s2 \u2228 D2 | Y2] into [t1 ' s1 \u2228D1 | Y1] upon the terms t1 and t2 generates [(s1 ' s2 \u2228D1 \u2228D2)\u03b7 | Y1\u03b7 \u222a\nY2\u03b7 \u222a Z]. Now, the A-clause [(s1 ' s2 \u2228 D1 \u2228 D2)\u03b7\u03c3\u2032 | Y1\u03b7\u03c3\u2032 \u222a Y2\u03b7\u03c3\u2032 \u222a Z] must be A-redundant in S, because S is SA\u227asel-saturated. This clause cannot be a tautology; indeed, for i = 1, 2, since ui ' vi \u2208 sel\u03a6(ui ' vi \u2228 Ci) and ui ' vi\u2228Ci \u2208 Cflat(A), Ci must be positive by definition of the selection function sel\u03a6, and cannot contain a symbol in P (otherwise the literal containing this symbol would be strictly greater than ui ' vi). By hypothesis, v1 ' v2 \u2228C1 \u2228C2 is not a tautology and since C1, C2 are positive and elementary, we deduce by Proposition 63 that [(s1 ' s2 \u2228 D1 \u2228 D2)\u03b7\u03c3\u2032 | Y1\u03b7\u03c3\u2032 \u222a Y2\u03b7\u03c3\u2032 \u222a Z] is not a tautology either. Thus, by Definition 19, there exists an A-clause [E | Z \u2032] \u2208 S and a substitution \u03b8 such that E\u03b8 \u2286 (s1 ' s2 \u2228D1 \u2228D2)\u03b7\u03c3\u2032 and Z \u2032\u03b8 \u2286 Y1\u03b7\u03c3\u2032 \u222a Y2\u03b7\u03c3\u2032 \u222aZ \u2286 X . Therefore, \u03a6(S,X ) contains the clause E\u03b8\u2193X that is contained in [(s1 ' s2 \u2228D1 \u2228D2)\u03b7\u03c3\u2032]\u2193X = v1 ' v2 \u2228 C1 \u2228 C2.\nProposition 65 Let S be an SA\u227asel-saturated set of A-clauses and X be a ground A-set. If \u03a6(S,X ) contains a non-tautological clause D \u2286 C\u2228a ' b\u2228a ' b, where C \u2228 a ' b is positive and elementary then C \u2228 a ' b is redundant in \u03a6(S,X ).\nProof. 20 If D contains at most one occurrence of a ' b, then necessarily D \u2286 C \u2228 a ' b and the proof is immediate. Otherwise, since a ' b\u2228 a ' b \u2286 D, the latter cannot be of type 2; it is therefore of type 1, thus there exists an Aclause [D\u2032 | Y] \u2208 S and a substitution \u03c3 such that D\u2032\u03c3\u2193X = D and Y\u03c3 \u2286 X . D\u2032 is of the form C \u2032 \u2228 u ' v \u2228 u\u2032 ' v\u2032, where C \u2032\u03c3\u2193X \u2286 C, u\u03c3\u2193X = u\u2032\u03c3\u2193X = a and v\u03c3\u2193X = v\u2032\u03c3\u2193X = b. By Proposition 4, D\u2032 is A-flat; thus the literal u ' v is necessarily A-maximal in D\u2032, and the A-Factorization rule applied to [D\u2032 |Y] generates [(C \u2032 \u2228 u ' v \u2228 v 6' v\u2032)\u03b8 |Y\u03b8 \u222a Z], where (\u03b8,Z) is the m.g.u. of u and u\u2032, or simply [(C \u2032 \u2228 u ' v)\u03b8 | Y\u03b8 \u222a Z], if v\u03b8 = v\u2032\u03b8. We assume that v\u03b8 6= v\u2032\u03b8, the proof when they are equal is simpler. Since (\u03c3,X ) is an instance of (\u03b8,Z), by Proposition 21 the clause [(C \u2032 \u2228 u ' v \u2228 v 6' v\u2032)\u03c3 | X ] must be redundant in S, and since v\u03c3\u2193X = v\u2032\u03c3\u2193X = b, it is equivalent to [(C \u2032 \u2228 u ' v)\u03c3 |X ]. This Aclause cannot be a tautology; otherwise, by Proposition 63, (C \u2032 \u2228 u ' v)\u03c3\u2193X \u2261 D would also be a tautology. Therefore, by Definition 19, there exists an A-clause [E | U ] \u2208 S and a substitution \u03b7 such that E\u03b7 \u2286 (C \u2032 \u2228 u ' v \u2228 v 6' v\u2032)\u03c3 and U\u03b7 \u2286 X . By definition of \u03a6(S,X ), the clause E\u03b7\u2193X occurs in \u03a6(S,X ). If E\u03b7 \u2286 (C \u2032 \u2228 u ' v)\u03c3 then the proof is completed. Otherwise, E is of the form E\u2032 \u2228 w 6' w\u2032, where E\u2032\u03b7 \u2286 (C \u2032 \u2228 u ' v)\u03c3, w\u03b7 = v\u03c3 and w\u2032\u03b7 = v\u2032\u03c3. Note that w and w\u2032 cannot both be equal to >, since otherwise w 6' w\u2032 would have been removed from the A-clause, thus the literal w 6' w\u2032 is necessarily A-maximal in E\u2032 \u2228 w 6' w\u2032, and it must be selected; therefore, the A-Reflection rule can be applied on this clause. Since (\u03b7,X ) is a unifier of w and w\u2032, necessarily, the A-clause [E\u2032\u03b7 | X ] is redundant in S. By Definition 19, S contains a clause [E\u2032\u2032 | U \u2032] and there exists a substitution \u00b5 such that E\u2032\u2032\u00b5 \u2286 E\u2032\u03b7 and U \u2032\u00b5 \u2286 X . We conclude that E\u2032\u03b7\u2193X \u2286 C \u2228 a ' b must be redundant in \u03a6(S,X ).\nProposition 66 There exists a set of clauses U \u2286 \u03a62(S,X ) \u222a \u03a63(S,X ) \u222a \u03a64(S,X ) \u222a \u03a65(S,X ) such that U contains no occurrence of \u03b2, and U |= X\nProof. 21 Consider the following sets:\nX1 def = {a ' a\u2193X | a \u2208 X , a 6= a\u2193X } ,\nX2 def = { (a 6' b)\u2193X | a 6' b \u2208 X } ,\nX3 def = { (f(a1, . . . , an) ./ >)\u2193X | f(a1, . . . , an) ./ > \u2208 X } .\nIt is clear that X \u2261 X1 \u222a X2 \u222a X3 and that X1 \u2286 \u03a62(S,X ). By letting X \u20322 def =\u22c3\na6'b\u2208X2 {\u03b1(a) 6' \u03b1(b)}, we have X \u2032 2 |= X2, the set U def = X1 \u222aX \u20322 \u222aX3 entails X , it is a subset of \u03a62(S,X ) \u222a\u03a63(S,X ) \u222a\u03a64(S,X ) and contains no occurrence of \u03b2.\nWe now establish a result concerning the form of the clauses of type 3 or 4 in \u03a6(S,X ).\nLemma 67 Any clause C of type 3 (resp. 4) in \u03a6(S,X ) is of the form \u03b1(a1) 6' \u03b1(a2) \u2228 C \u2032 (resp. p(a1, . . . , an) ./ > \u2228 C \u2032) where:\n1. a1, a2 \u2208 A (resp. a1, . . . , an \u2208 A)\n2. C \u2032 is positive and elementary.\n3. X contains a clause of the form b1 6' b2 (resp. p(b1, . . . , bn)).\n4. For every i \u2208 [1, 2] (resp. i \u2208 [1, n]) either ai = bi or ai \u227a bi and \u03a6(S,X ) contains a clause of the form ai ' bi\u2228Ci with Ci \u2286 C \u2032 and Ci \u227a (ai ' bi).\nProof. 22 By definition of the clauses of type 3 and 4 in \u03a6(S,X ) (see Definition 30), C is obtained from a clause of the form \u03b1(b1) 6' \u03b1(b2) with b1 6' b2 \u2208 X (resp. from a clause p(b1, . . . , bn) \u2208 X ) by applying Superposition inferences from positive elementary clauses in \u03a6(S,X ). Furthermore, C cannot be redundant. We prove the result by induction on the number of Superposition inferences. The base case is immediate (with ai = bi, C \u2032 = 2). Assume that C is obtained by Superposition into a clause D. Without loss of generality we assume that the considered derivation is minimal (w.r.t. the number of steps). By the induction hypothesis, D is necessarily of the form \u03b1(a1) 6' \u03b1(a2) \u2228 C \u2032 (resp. p(a1, . . . , an) ./ >\u2228C \u2032), where a1, . . . , an and C \u2032 satisfy the above properties. By definition of the selection function sel\u03a6, only the literal \u03b1(a1) 6' \u03b1(a2) (resp. p(a1, . . . , an)) is selected, hence the replacement necessarily occurs in this literal. By symmetry, we may assume that it occurs upon the constant a1, from a clause of the form a1 ' a\u20321 \u2228 D\u2032 (with a1 a\u20321). The inference yields C = \u03b1(a\u20321) 6' \u03b1(a2)\u2228C \u2032\u2228D\u2032 (resp. p(a\u20321, a2, . . . , an) ./ >\u2228C \u2032\u2228D\u2032). If b1 = a1, then the proof is completed, since the clause a1 ' a\u20321 \u2228 D\u2032 fulfills the property of Item 4. Otherwise, by the induction hypothesis, \u03a6(S,X ) contains a clause of the form a1 ' b1 \u2228 C1 with C1 \u2286 C \u2032 Assume that a1 is not superposable in a1 ' b1 \u2228 C1. By Proposition 62, this entails that \u03a6(S,X ) contains a clause of type 1 of the form a\u20321 ' b1 \u2228 C \u20321, where C \u20321 is obtained from C1 by replacing\noccurrences of a1 by a\u20321 (b1 is not replaced, since b1 6= a1). By replacing the Superposition inference upon b1 in the derivation yielding C by a Superposition from a\u20321 ' b1 \u2228 C \u20321, we get a clause D\u2032\u2032 of the form a\u20321 6' a2 \u2228 C \u2032\u2032 (resp. p(a\u20321, a2, . . . , an) ./ >\u2228C \u2032\u2032 with C \u2032\u2032 \u2286 C \u2032\u2228C \u20321. Clause D\u2032\u2032 satisfies the following properties.\n\u2022 D\u2032\u2032 is a clause of type 3 or 4 in \u03a6(S,X ).\n\u2022 D\u2032\u2032 C, since a\u20321 \u227a a1.\n\u2022 a\u20321 ' a1\u2228D\u2032 \u227a C, since by definition of the ordering \u03b1(x) c and p(~x) c for every c \u2208 A.\n\u2022 D\u2032\u2032, a\u20321 ' a1 \u2228D\u2032 |= C.\nThe number of inferences in the derivation is strictly lower than that of C (since the sequence of Superposition inferences replacing b1 by a1 and then a1 by a\u20321 has been replaced by a single replacement of b1 by a\u20321), which by minimality of the derivation entails that D\u2032\u2032 6= C. Thus D\u2032\u2032 C and C is redundant, which contradicts the definition of the clauses of type 3 and 4. Consequently a1 is superposable in a1 ' b1 \u2228 C1. We now distinguish two cases.\n\u2022 The clause b1 ' a\u20321 \u2228 C1 \u2228D\u2032 is a tautology. Since this clause is positive, this entails that it contains a literal of the form t ' t (otherwise the interpretation mapping all constants to distinct elements would falsify the clause). Since b1 a1 and a1 a\u20321 we have b1 6= a\u20321 hence the literal t ' t occurs in C1 \u2228D\u2032. But then C would be redundant (since it contains C1 \u2228D\u2032), which contradicts the definition of the clauses of type 3 and 4.\n\u2022 The clause b1 ' a\u20321 \u2228 C1 \u2228D\u2032 is not a tautology. Since a1 is superposable in a1 ' b1 \u2228 C1, by Lemma 64, we deduce that there is a clause of type 1 in \u03a6(S,X ) that is contained in (a\u20321 ' b1) \u2228 C1 \u2228 D\u2032. If this clause is contained in C1\u2228D\u2032 then it is also contained in C which is redundant and the proof is completed; otherwise it is of the form (a\u20321 ' b1) \u2228 C \u20321, where C \u20321 \u2286 C1\u2228D\u2032 \u2286 C \u2032\u2228D\u2032, which proves that the above property holds for C.\nWe are now in a position to provide the proof of Lemma 37. We have to prove that every clause generated from \u03a6(S,X ) by an inference in SP\u227asel\u03a6 except for Equational Factorization on positive A-flat clauses is a logical consequence of some clauses in \u03a6(S,X ) that are strictly smaller than the maximal premise of the inference. Note that this condition necessarily holds if the conclusion is redundant in \u03a6(S,X ), since a clause cannot be greater than its maximal premise. We distinguish several cases, depending on the types of the clauses involved in the inference.\nClauses of type 2.\nBy definition, every such clause is of the form c ' c\u2193X , where c 6= c\u2193X and by construction, c c\u2193X . Constant c cannot occur in other clauses in \u03a6(S,X ), since\nall its occurrences are replaced by c\u2193X . Thus the clause c ' c\u2193X cannot interact with any other clause, because of the ordering restrictions of the Superposition calculus.\nClauses of type 5.\nBy construction, constant \u03b2 only occurs in literals of the form \u03b2 6' > and \u03b2 ' >. By definition of sel\u03a6, the literal \u03b2 6' > is never selected, thus the clause \u03b2 ' > cannot interact with other clauses in \u03a6(S,X ). Now, consider a clause of the form \u03b1(u) 6' \u03b1(v) \u2228 u ' v. By definition, u = u\u2193X , and u cannot be the maximal term of a selected literal in \u03a6(S,X ). Since \u03b1 occurs only in negative literals, no literal can interact with \u03b1(u) 6' \u03b1(v), and since u 6= v, the Reflection rule does not apply either.\nClauses of type 3.\nLet C be a clause of type 3. By definition, only negative literals are selected in C, thus the only inference rules that can be applied on C are the Reflection rule or the Superposition rule into C, where the \u201cfrom\u201d premise is necessarily a clause of type 1 in \u03a6(S,X ). By Case 3 of Definition 30, all the non-redundant clauses that can be generated by the Superposition inference rule are already in \u03a63(S,X ). Thus, we only consider the case where the Reflection inference rule applied on C generates a clause D.\nBy Lemma 67, C is of the form \u03b1(a1) 6' \u03b1(a2) \u2228 C \u2032, where X contains a clause of the form b1 6' b2 with for all i = 1, 2 either bi = ai or \u03a6(S,X ) contains a clause of type 1 of the form (bi ' ai) \u2228 Ci, where Ci \u2286 C \u2032. Furthermore, by definition of the Reflection rule, we must have a1 = a2.\nIf b1 = a1 or b2 = a2 or if ai is superposable in (bi ' ai) \u2228 Fi, then by Lemma 64, \u03a6(S,X ) contains a clause (b1 ' b2) \u2228C \u2032\u2032 with C \u2032\u2032 \u2286 C1 \u2228C2. Then S contains an A-clause of the form [u ' v \u2228 E |Y], where u\u03b8\u2193X = b, v\u03b8\u2193X = a, E\u03b8\u2193X = C\n\u2032\u2032 and Y\u03b8 \u2286 X . Then the A-Assertion rule can be applied to this A-clause, yielding [E | Y \u222a {u 6' v}]. Note that since b1 6= b2, Y\u03b8 \u222a {u 6' v} \u03b8 must be satisfiable. If [E | Y \u222a {u 6' v}]\u03b8 is a tautology, then so is E\u03b8\u2193X = C \u2032\u2032 by Proposition 63, hence D is also a tautology and is redundant in \u03a6(S,X ), thus the proof is completed. Otherwise, by Definition 19, since S is SA\u227aselsaturated, it contains an A-clause [E\u2032 | Y \u2032] and there exists a substitution \u03b8\u2032 such that E\u2032\u03b8\u2032 \u2286 E\u03b8 and Y \u2032\u03b8\u2032 \u2286 Y\u03b8 \u222a {u 6' v} \u03b8. Then \u03a6(S,X ) contains the clause E\u2032\u03b8\u2032\u03b8\u2193X \u2286 E\u03b8\u2193X = C \u2032\u2032 \u2286 C \u2032, and the latter is therefore redundant in \u03a6(S,X ).\nNow assume that b1 6= a1, b2 6= a2 and that neither a1 nor a2 is superposable. By Proposition 62, \u03a6(S,X ) contains a clause of the form b1 ' b2 \u2228 G1, where G1 is obtained from F1 by replacing occurrences of a1 by b2. Using the fact that S is saturated under A-Assertion, we deduce as in the previous case that \u03a6(S,X ) contains a clause G\u20321 \u2286 G1. Thus, since \u03b1(a1) 6' \u03b1(a2) \u2228 F1 \u2228 F2 \u2286 C and a1 = a2, we have:\nG\u20321, b2 ' a2 \u2228 F2 |= G1, b2 ' a2 \u2228 F2 |= G1 \u2228 F2 |= C.\nSince C contains an occurrence of \u03b1, it is strictly greater than G\u20321 and b2 ' a2 \u2228 F2, thus C is redundant, and cannot be a clause of type 3.\nClauses of type 4.\nBy Lemma 67, C is necessarily of the form p(a1, . . . , an) ./ > \u2228 C \u2032, where for every i \u2208 [1, n], one of the two following conditions hold:\n1. ai = bi.\n2. \u03a6(S,X ) contains a positive elementary clause of the form ai ' bi \u2228 Ci, with ai \u227a bi, (ai ' bi) Ci, Ci \u2286 C \u2032.\nThe only rule that can be applied on C (beside Superposition from elementary positive clauses for which the proof follows immediately from Case 4 of Definition 30) is the Superposition rule on the term p(a1, . . . , an), and in this case the other premisse must be of the form p(a1, . . . , an) 6./ > \u2228 F . The generated clause is C \u2032 \u2228 F , since literals of the form > 6' > are deleted.\nBy definition of \u03a6(S,X ), for each index i satisfying the second item, there exist an A-clause [a\u2032i ' b\u2032i\u2228C \u2032i |Yi] \u2208 S and a substitution \u03c3i such that a\u2032i\u03c3i\u2193X = ai, b\u2032i\u03c3i\u2193X = bi, C \u2032 i\u03c3i\u2193X = Ci, and Yi\u03c3 \u2286 X . Let E (resp. E\u2032) be the disjunction of the clauses Ci (resp. C \u2032i), for all indices such that ai 6= bi. Note that E \u2286 C \u2032, hence it is sufficient to prove that E \u2228 F is redundant in \u03a6(S,X ). The ASubstitutivity rule applied on the clauses [a\u2032i ' b\u2032i \u2228 C \u2032i | Yi] generates the Aclause: [p(a\u20321, . . . , a\u2032n) ./ > \u2228 E\u2032 | {p(b\u20321, . . . , b\u2032n) ./ >}], with bi = ai \u21d2 (b\u2032i = a\u2032i = xi) (where the xi\u2019s denote pairwise distinct fresh variables) and bi 6= ai \u21d2 (b\u2032i = bi \u2227 a\u2032i = ai). This A-clause must be redundant in S, in particular (taking xi = bi if bi = ai) either [p(a1, . . . , an) ./ > \u2228 E | {p(b1, . . . , bn) ./ >}] is a tautology (Case (i)) or there exist an A-clause [D |Y] and a substitution \u03b8 with D\u03b8\u2193X \u2286 p(a1, . . . , an) ./ > \u2228 E and Y\u03b8 \u2286 {p(b1, . . . , bn) ./ >} (Case (ii)).\nIf D\u03b8\u2193X \u2286 E then E \u2228 F is clearly redundant in \u03a6(S,X ), thus we assume that D is of the form p(~s) ./ >\u2228D\u2032, with ~s\u03b8\u2193X = (a1, . . . , an) and D\u2032\u03b8\u2193X \u2286 E. Note that by definition of the ordering p(~s\u03b8\u2193X ) ./ > is strictly greater than any literal in D\u2032\u03b8\u2193X .\nBy Proposition 63, we observe that [p(a1, . . . , an) ./ >\u2228E |{p(b1, . . . , bn) ./ >}] is a tautology only if (a1, . . . , an) = (b1, . . . , bn). We then distinguish two cases, according to the type of the other premisse p(a1, . . . , an) 6./ > \u2228 F .\n1. If p(a1, . . . , an) 6./ >\u2228 F is of type 1, then there exist an A-clause [p(~t) 6./ > \u2228 F \u2032 | Z] \u2208 S and a substitution \u03b8\u2032 such that ~t\u03b8\u2032\u2193X = (a1, . . . , an), F \u2032\u03b8\u2032\u2193X \u2228 F \u2032\u2032 = F and Z\u03b8\u2032 \u2286 X , where F \u2032\u2032 = \u03b2 6' > if F is quasi-positive and F \u2032\u2032 = 2 otherwise. Then:\n\u2022 In Case (i), we have (a1, . . . , an) = (b1, . . . , bn), by the above remark. Furthermore, the A-Assertion rule applies on [p(~t) 6./ > \u2228 F \u2032 | Z], yielding [F \u2032 | Z \u222a {p(~t) ./ >}]. Since S is saturated under the AAssertion rule, this A-clause is redundant in S. Since (p(~t\u03b8\u2032\u2193X ) ' >) = (p(a1, . . . , an) ' >) = (p(b1, . . . , bn) ' >) \u2208 X , this entails\nthat F \u2032\u03b8\u2032\u2193X \u2228 F \u2032\u2032 (hence also E \u2228 F since F = F \u2032\u03b8\u2032\u2193X \u2228 F \u2032\u2032) is redundant in \u03a6(S,X ).\n\u2022 In Case (ii), since ~t\u03b8\u2032\u2193X = (a1, . . . , an) = ~s\u03b8\u2193X , ~t and ~s have an Aunifier (\u00b5,U), that is more general than (\u03b8 \u222a \u03b8\u2032,X ). Furthermore, (p(~s) ./ >)\u00b5 and (p(~t) 6./)\u00b5 must be selected in D\u00b5 and (p(~t) 6./ >\u2228F \u2032)\u00b5, respectively, because the selection function is stable under A-substitution and p(~s\u03b8\u2193X ) ./ > and p(~t\u03b8\u2032\u2193X ) 6./ must be selected in D\u03b8\u2193X and (p(~s) 6./ > \u2228 F \u2032)\u03b8\u2032\u2193X respectively. Consequently, the Superposition rule applies on [p(~s) ./ >\u2228D\u2032 |Y] and [p(~t) 6./ >\u2228 F \u2032 | Z], yielding [(D\u2032 \u2228 F \u2032) |Y \u222a Z \u222a U ]\u00b5. The A-clause [D\u2032\u03b8 \u2228 F \u2032\u03b8\u2032 |X ] is thus redundant in S, hence E \u2228 F is redundant in \u03a6(S,X ).\n2. Otherwise, p(a1, . . . , an) 6./ > \u2228 F must be of type 4, F must be positive and elementary, and by the same reasoning as before we can prove that X contains a clause p(b\u20321, . . . , b\u2032n) 6./ >, such that either [p(a1, . . . , an) 6./ >\u2228F |{p(b\u20321, . . . , b\u2032n) 6./ >}] is a tautology (Case (iii)) or there exist an Aclause [p(~s\u2032) 6./ >\u2228D\u2032\u2032 |Y \u2032] and a substitution \u03b8\u2032 with ~s\u2032\u03b8\u2032\u2193X = (a1, . . . , an), D\u2032\u2032\u2193X \u03b8 \u2286 F and Y \u2032\u03b8 \u2286 {p(b\u20321, . . . , b\u2032n) ./ >} (Case (iv)). By Proposition 63, Case (iii) can only occur if (a1, . . . , an) = (b\u20321, . . . , b\u2032n) Also, we note that Cases (i) and (iii) cannot hold simultaneously (otherwise we would have (b1, . . . , bn) = (a1, . . . , an) = (b\u20321, . . . , b\u2032n) hence X would contain both p(a1, . . . , an) ./ > and p(a1, . . . , an) 6./ > and would be thus unsatisfiable). By symmetry, we may assume that (i) does not hold. Then:\n\u2022 In Case (iii), we can apply the A-Assertion rule on [p(~s) ./ >\u2228D\u2032 |Y], yielding [D\u2032 | Y \u222a {p(~s) 6./ >}]. Since (a1, . . . , an) = (b\u20321, . . . , b\u2032n), we have Y\u03b8 \u222a {(p(~s\u2193X ) 6./ >)\u03b8} \u2286 {p(b1, . . . , bn) ./ >, p(b\u20321, . . . , b\u2032n) 6./ >} \u2286 X and D\u2032\u03b8 \u2286 E is thus redundant in \u03a6(S,X ).\n\u2022 In Case (iv), it is easy to check that we can apply theA-Superposition rule on [p(~s) ./ > \u2228D\u2032 | Y] and [p(~s\u2032) 6./ > \u2228D\u2032\u2032 | Y \u2032], yielding an Aclause of the form [D\u2032\u2228D\u2032\u2032 |Y \u222aY \u2032\u222aU ]\u00b5, where (\u00b5,U) is more general than (\u03b8 \u222a \u03b8\u2032,X ). Then E \u2228 F is redundant in \u03a6(S,X ).\nClauses of type 1.\nAll inferences involving a clause of type 2, 3 or 4 have already been considered, we now focus on inferences involving only clauses of type 1. We assume the Superposition rule is applied; the proof for the unary inference rules is similar. Let C = u ' v \u2228 D and E = t ./ s \u2228 F be two clauses of type 1 in \u03a6(S,X ). Assume that the Superposition rule applies from C into E, upon the terms u and t|p, yielding t[v]p ./ s\u2228F \u2228D, where t|p = u, u v, t s, u ' v \u2208 sel\u03a6(C) and t ./ s \u2208 sel\u03a6(E). Note that this implies that u ' v is strictly maximal in C. We prove that the clause t[v]p ./ s \u2228 F \u2228D is redundant in \u03a6(S,X ). Note that by definition of sel\u03a6, t ./ s cannot be \u03b2 6' >. By definition, S contains\ntwo A-clauses C \u2032 = [u\u2032 ' v\u2032 \u2228D\u2032 |Y] and E\u2032 = [t\u2032 ./ s\u2032 \u2228 F \u2032 |Z] and there exist substitutions \u03c3 and \u03b8 such that:\n\u2022 u\u2032\u03c3\u2193X = u, v\u2032\u03c3\u2193X = v, D\u2032\u03c3\u2193X \u2228D\u2032\u2032 = D, Y\u03c3 \u2286 X and D\u2032\u2032 \u2286 {\u03b2 6' >},\n\u2022 t\u2032\u03b8\u2193X = t, s\u2032\u03b8\u2193X = s, F \u2032\u03b8\u2193X \u2228 F \u2032\u2032 = F , Z\u03b8 \u2286 X and F \u2032\u2032 \u2286 {\u03b2 6' >}.\nFirst assume that there is a strict prefix q of p such that t\u2032|q is a variable x. Then x cannot occur in Z, since otherwise x\u03b8 would be a constant in A (because Z\u03b8 \u2286 X ), and q would not be a strict prefix of p. Let \u03b8\u2032 be the substitution coinciding with \u03b8, except for the value of x, and such that x\u03b8\u2032 is obtained from x\u03b8 by replacing all occurrences of u by v. Since \u03b8 and \u03b8\u2032 coincide on all the variables in Z, necessarily Z\u03b8\u2032 \u2286 X . Furthermore, since (t\u2032 ./ s\u2032\u2228F \u2032)\u03b8\u2032 is A-flat and positive exactly when (t\u2032 ./ s\u2032 \u2228F \u2032)\u03b8 is A-flat and positive, we deduce that (t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2032\u2193X \u2228 F \u2032\u2032 \u2208 \u03a6(S,X ), and this clause is such that\n(t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2032\u2193X \u2228 F \u2032\u2032, u ' v \u2228D |= (t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2193X \u2228 F \u2032\u2032 \u2228D, u ' v \u2228D = t ./ s \u2228 F \u2228D,u ' v \u2228D |= t[v]p ./ s \u2228 F \u2228D.\nIf (t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2032\u2193X \u2228 F \u2032\u2032 = t[v]p ./ s \u2228 F \u2228 D then t[v]p ./ s \u2228 F \u2228 D occurs in \u03a6(S,X ) hence the proof is completed. Otherwise (t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2032\u2193X \u2228 F \u2032\u2032 \u227a t[u]p ./ s\u2228F . If p 6= \u03b5 or ./= 6', then necessarily u ' v \u227a t[u]p ./ s, since u v. Furthermore, D \u227a u ' v, hence (t\u2032 ./ s\u2032 \u2228 F \u2032)\u03b8\u2032\u2193X \u2228 F \u2032\u2032, u ' v \u2228 D \u227a t[u]p ./ s \u2228 F , and the clause t[v]p ./ s \u2228 F \u2228 D is therefore a logical consequence of clauses of \u03a6(S,X ) that are strictly smaller than one of its premises, the proof is thus completed.\nIf p = \u03b5 and ./=', then E = u ' s \u2228 F , and the generated clause is v ' s\u2228D\u2228F . If v = s then this clause is a tautology, and is trivially redundant in \u03a6(S,X ). Otherwise, assume w.l.o.g. that v \u227a s (since the same inference can be performed by considering E as the \u201cfrom\u201d premise, the two parent clauses play symmetric r\u00f4les), then u ' v \u227a u ' s, and as in the previous case, the clause v ' s\u2228F \u2228D is therefore a logical consequence of clauses that are strictly smaller than one of its premises.\nNow assume that there is no strict prefix q of p such that t\u2032|q is a variable x. Necessarily, pmust be a position in t\u2032. Since u = t|p, we have u\u2032\u03c3 \u223cXA t\u2032|p\u03b8, hence u\u2032 and t\u2032|p are A-unifiable. Let (\u03b7,X \u2032) be a most general A-unifier of u\u2032 and t\u2032|p. Since (\u03c3\u03b8,X ) is an A-unifier of u\u2032 and t\u2032|p we have X \u2032 \u2286 X and there exists a substitution \u03b7\u2032 such that \u03b7\u03b7\u2032 \u223cXA \u03c3\u03b8. Since u\u2032\u03c3\u2193X = u v = v\u2032\u03c3\u2193X , we have v\u2032\u03b7 6 A u\u2032\u03b7, and similarly, t\u2032\u03b7 6 A s\u2032\u03b7. Furthermore, since the selection function sel is stable by A-substitution, (t\u2032 ./ s\u2032)\u03b7 and (u\u2032 ' v\u2032)\u03b7 must be selected in C \u2032\u03b7 and E\u2032\u03b7 respectively. Thus the A-Superposition rule applied to C \u2032 and E\u2032, generates [(t\u2032[v\u2032]p ./ s\u2032\u2228D\u2032\u2228F \u2032)\u03b7 |(Y\u222aZ)\u03b7\u222aX \u2032]. Since S is SA\u227asel-saturated, this clause is A-redundant in S, and so is [(t\u2032[v\u2032]p ./ s\u2032\u2228D\u2032\u2228F \u2032)\u03b7\u03b7\u2032 |(Y\u222aZ)\u03b7\u03b7\u2032\u222aX \u2032].\nSuppose that (t\u2032[v\u2032]p ./ s\u2032 \u2228 D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032 is A-flat and quasi-positive. If [(t\u2032[v\u2032]p ./ s\n\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032 |(Y \u222aZ)\u03b7\u03b7\u2032 \u222aX \u2032] is a tautology, then by Proposition 63 (t\u2032[v\u2032]p ./ s\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X either is a tautology or contains a literal A ./\n> occurring in X . In both cases, (t\u2032[v\u2032]p ./ s\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X is redundant in \u03a6(S,X ) Otherwise, by Definition 19, S contains an A-clause [G | U ] and there exists a substitution \u00b5 such that G\u00b5 \u2286 (t\u2032[v\u2032]p ./ s\u2032 \u2228 D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032 and U\u00b5 \u2286 (Y \u222a Z)\u03b7\u03b7\u2032 \u222a X \u2032 \u2286 X . The clause G\u00b5 must be positive and A-flat, hence by Case 1 of Definition 30, \u03a6(S,X ) contains G\u00b5\u2193X \u22282 = G\u00b5, and G\u00b5 \u2286 (t\u2032[v\u2032]p ./ s\n\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X = t[v]p ./ s \u2228D \u2228 F . If (t\u2032[v\u2032]p ./ s\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032 is not A-flat or not quasi-positive, then there\nexist n A-clauses [C1 |X1], . . . , [Cn |Xn] and substitutions \u03b31, . . . , \u03b3n such that:\n\u2022 \u2200i \u2208 [1, n]Xi\u03b3i \u2286 (Y \u222a Z)\u03b7\u03b7\u2032 \u222a X \u2032,\n\u2022 X \u2032\u2032, C1\u03b31, . . . , Cn\u03b3n |= (t\u2032[v\u2032]p ./ s\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032,\n\u2022 (t\u2032[v\u2032]p ./ s\u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X A C1\u03b31, . . . , Cn\u03b3n.\nSince X \u2032\u2032 \u2286 X , we deduce that X , C1\u03b31, . . . , Cn\u03b3n |= (t\u2032[v\u2032]p ./ s\u2032 \u2228 D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032. Also, by definition of A, we have C1\u03b31\u2193X , . . . , Cn\u03b3n\u2193X (t\u2032[v\u2032]p ./ s \u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X . But since X1\u03b3, . . . ,Xn\u03b3 \u2286 (Y \u222a Z)\u03b7\u03b7 \u2032 \u222a X \u2032 \u2286 X , \u03a6(S,X ) contains clauses of the form Ci\u03b3i\u2193X \u2228 Gi (1 \u2264 i \u2264 n), where Gi \u2286 {\u03b2 6' >}. By Proposition 66, X is a logical consequence of a subset of \u03a62(S,X ) \u222a \u03a63(S,X ) \u222a \u03a64(S,X ) \u222a \u03a65(S,X ) that contains no occurrence of \u03b2. Since (t\u2032[v\u2032]p ./ s\u2032 \u2228 D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032 is either not A-flat or not positive, t[v]p ./ s \u2228 F \u2228 D contains \u03b2 6' >, and must be strictly greater than all clauses of type 2, 3, 4 or 5 that do not contain any occurrence of \u03b2. Thus (t\u2032[v\u2032]p ./ s \u2032 \u2228D\u2032 \u2228 F \u2032)\u03b7\u03b7\u2032\u2193X = t[v]p ./ s \u2228 F \u2228D is redundant in \u03a6(S,X )."}, {"heading": "C Proof of Corollary 39", "text": "Let S\u2032 be the smallest set of (standard ground) clauses such that S\u2032 contains all clauses C satisfying the following properties:\n\u2022 C is generated by one of the rules in SP\u227asel\u03a6 from \u03a6(S,X ) \u222a S \u2032.\n\u2022 C is not a logical consequence of the set of clauses in \u03a6(S,X ) \u222a S\u2032 that are strictly smaller than the maximal premise of C.\nLet S\u2032\u2032 = \u03a6(S,X ) \u222a S\u2032. Intuitively, S\u2032\u2032 is the SA\u227asel-closure of \u03a6(S,X ) modulo redundancy. By definition S\u2032\u2032 must be unsatisfiable and weakly SP\u227asel-saturated, hence S\u2032\u2032 contains the empty clause. For any term t, we denote by P+(t) the set of positive clauses in \u03a6(S,X ) that contain no term s t. We prove that the clauses in S\u2032 are A-flat and of the form c ' a\u2032 \u2228 a 6' b \u2228 C \u2032, where:\n1. C \u2032 is positive,\n2. c a\u2032, a\u2032 a and a\u2032 b,\n3. P+(c) |= C \u2032 \u2228 a ' a\u2032 \u2228 b ' a\u2032,\n4. \u03a6(S,X ) contains a positive A-flat clause C \u2032\u2032 \u2286 c ' a \u2228 c ' b \u2228D of type 1 such that {D} \u222a P+(c) |= C \u2032 and D C \u2032.\nThis immediately implies that 2 6\u2208 S\u2032, hence that 2 \u2208 \u03a6(S,X ). The proof is by structural induction on S\u2032. Let C \u2208 S\u2032. Note that C cannot be redundant in \u03a6(S,X ), by definition of S\u2032 since the conclusion of an inference rule cannot be greater than its maximal premise.\n\u2022 Assume that C is derived by the Reflection inference rule. Then, since \u03a6(S,X ) is weakly saturated under Reflection, the parent of C must occur in S\u2032, hence by the induction hypothesis, it must be of the form c ' a\u2032\u2228a 6' b \u2228C \u2032, where \u03a6(S,X ) contains a clause C \u2032\u2032 \u2286 c ' a \u2228 c ' b \u2228D such that {D} \u222aP+(c) |= C \u2032, P+(c) |= C \u2032 \u2228 a ' a\u2032 and D C \u2032. By definition of the Reflection rule we have a = b and by Proposition 65 the clause c ' a \u2228D is necessarily redundant in \u03a6(S,X ). But C = c ' a\u2032 \u2228 C \u2032 is redundant in {c ' a \u2228D} \u222a P+(c) by Condition 3 above, since a = b. Therefore, C is redundant in \u03a6(S,X ), which is impossible.\n\u2022 Assume that C is derived by Factorization. Then C is of the form c ' a \u2228 a 6' b \u2228 C \u2032, and its parent is c ' a \u2228 c ' b \u2228 C \u2032. Note that this parent clause must be positive, otherwise c ' a would not be selected, and that it is of type 1. Thus, it cannot occur in S\u2032, and c ' a\u2228 c ' b\u2228C \u2032 \u2208 \u03a6(S,X ). It is simple to verify that the induction hypothesis holds on C.\n\u2022 Assume that C is generated by a Superposition from C1 into C2. Then one of the premises is necessarily in S\u2032, and by the induction hypothesis, it contains a negative literal. Since a positive literal is selected in the first premise of the inference rule, we deduce that C1 = a ' d\u2228C \u20321, where a d, C2 = c ' a\u2032\u2228a 6' b\u2228C \u20322, and C = c ' a\u2032\u2228b 6' d\u2228C \u20321\u2228C \u20322. Note that C1 must be of type 1; furthermore, a 6= b, since otherwise the Reflection rule would apply upon C2, c ' a\u2032\u2228C \u20322 would be redundant in \u03a6(S,X ) and so would C. We prove that C verifies the induction hypothesis.\n1. Since C1 is a positive clause and C \u20322 is positive by the induction hypothesis, it is clear that C \u20321 \u2228 C \u20322 is positive. 2. Since a\u2032 a d, we have c a\u2032, a\u2032 b and a\u2032 d. 3. By the induction hypothesis, P+(c) |= C \u20322 \u2228 a ' a\u2032 \u2228 b ' a\u2032. Since c a\u2032 a d, we deduce that C1 \u2208 P+(c), and therefore P+(c) |= C \u20322 \u2228 C \u20321 \u2228 d ' a\u2032 \u2228 b ' a\u2032. 4. By the induction hypothesis, there is a positive clause C \u2032\u20322 \u2208 \u03a6(S,X ) of type 1 such that C \u2032\u20322 \u2286 c ' a\u2228c ' b\u2228D2, where {D2}\u222aP+(c) |= C \u20322 and D2 C \u20322. If C \u2032\u20322 does not contain literal c ' a, then the proof is immediate, by letting C \u2032\u2032 def= C \u2032\u20322 and D def = D2. Otherwise, C \u2032\u20322 is\nof the form c ' a \u2228 E, where E \u2286 c ' b \u2228 D2. If a is superposable in c ' a \u2228 E, then by Lemma 64, there is a clause in \u03a6(S,X ) that is contained in c ' d \u2228 C \u20321 \u2228 E \u2286 c ' b \u2228 c ' d \u2228 C \u20321 \u2228 D2, and the proof is completed. Otherwise, by Proposition 62, since C \u2032\u20322 is of type\n1, \u03a6(S,X ) contains a clause c ' d \u2228 E\u2032, where E\u2032 is obtained from E by replacing some occurrences of a by d. Since E \u2286 c ' b \u2228 D2 and a 6= b, c, we deduce that E\u2032 \u2286 c ' b \u2228 D\u20322, for a clause D\u20322 obtained from D2 by replacing some occurrences of a by d. Since a ' d\u2228C \u20321 \u2208 P+(c), we deduce that {D\u20322} \u222aP+(c) |= C \u20321 \u2228D2, hence {D\u20322}\u222aP+(c) |= C \u20321\u2228C \u20322. Now a d, so that D\u20322 D2 C \u20322, and the clause d ' c \u2228E\u2032 \u2286 d ' c \u2228 b ' c \u2228D\u20322 fulfills the required property."}, {"heading": "D Proof of Lemma 56", "text": "The proof is based on the following results:\nProposition 68 If (\u03c3, E) is a most general A-unifier of t ' s, then for all X such that E \u2286 X , t\u2193X and s\u2193X are unifiable, and \u03c3\u2193X is a most general unifier of t\u2193X ' s\u2193X .\nProof. 23 This is because if (S, \u03b8,X ) and (S\u2032, \u03b8\u2032,X \u2032) are A-unification problems such that (S, \u03b8,X )\u2192 (S\u2032, \u03b8\u2032,X \u2032), then for all A-sets Y such that X \u2032 \u2286 Y, we have S\u2193Y \u2192 S\u2032\u2193Y for the standard unification rules. The proof follows by a straightforward induction.\nSince terms that are \u223cA-equivalent cannot be distinguished by EA and selA, we have the following result.\nProposition 69 Let C = [t ./ s \u2228D |X ] be an A-clause, where t ./ s \u2208 sel(t ./ s \u2228 D) and t 6 A s. Let \u03c3 be a ground X -pure substitution of domain var(X ). If t\u03c3 \u223cA t\u2032, then t\u2032 6EA s\u03c3 and (t\u2032 ./ s\u03c3) \u2208 selA(t\u2032 ./ s\u03c3 \u2228D\u03c3).\nProposition 70 Let \u00b5 be an m.g.u. of t ' s.\n\u2022 If \u00b51, \u00b52 are such that dom(\u00b51) \u2229 dom(\u00b52) = \u2205 and \u00b5 = \u00b51\u00b52, then \u00b52 is an m.g.u. of t\u00b51 ' s\u00b51.\n\u2022 Let \u03c3 be a substitution such that dom(\u03c3) \u2286 var(t ' s) and dom(\u03c3) \u2229 dom(\u00b5) = \u2205. Then the restriction of \u00b5\u03c3 to dom(\u00b5) is an m.g.u. of t\u03c3 ' s\u03c3.\nProof. 24 Since t\u00b51\u00b52 = t\u00b5 = s\u00b5 = s\u00b51\u00b52, it is clear that t\u00b51 and s\u00b51 are unifiable. If \u03b4 is a unifier of of t\u00b51 ' s\u00b51, then t\u00b51\u03b4 = s\u00b51\u03b4, hence \u00b51\u03b4 is a unifier of t ' s, and is therefore an instance of \u00b5 = \u00b51\u00b52, thus \u03b4 is an instance of \u00b52. This proves that \u00b52 is an m.g.u. of t\u00b51 ' s\u00b51.\nThe second point is a consequence of the fact that for any unification problem, if S \u2192 S\u2032, then S\u03c3 \u2192 S\u2032\u03c3. The result is proved by induction on the transformation of the unification problem {t ' s}.\nWe prove that if the A-Superposition rule applied to C,D generates E, then for all E\u2032 \u2208 \u0393(E,U), there exists C \u2032 \u2208 \u0393(C,U) and D\u2032 \u2208 \u0393(D,U) such that E\u2032\ncan be derived from C \u2032, D\u2032,U by SA\u227asel. The proof for the other inference rules is similar. We let\nC = [u ' v \u2228 C1 |X ], D = [t ./ s \u2228D1 |Y], E = [(t[v]p ./ s \u2228 C1 \u2228D1)\u00b5 |Z],\nwhere (\u00b5, E) is an (X \u222aY)-pure most general A-unifier of u ' t|p and Z = (X \u222a Y\u222aE)\u00b5. Up to a renaming, we may assume that var(Z) \u2286 var(X\u222aY), so that for all x \u2208 dom(\u00b5)\u2229var(X \u222aY), x\u00b5 \u2208 A\u222avar(X \u222aY). Let E\u2032 \u2208 \u0393({[E |Z]} ,Z), and let \u03c3 be the Z-pure substitution of domain var(Z) such that \u03c3\u2193U = \u03c3, Z\u03c3 \u2286 U and E\u2032 = E\u03c3. We let C def= dom(\u00b5)\u2229 var(X \u222aY) and define \u00b51 as the restriction of \u00b5 to C and \u00b52 as the restriction of \u00b5 to dom(\u00b5) \\ C, so that \u00b5 = \u00b51 ] \u00b52. Consider the substitution \u03b4 def= \u00b51\u03c3. It is clear that \u03b4 is a ground (X \u222a Y)-pure substitution of domain var(X \u222a Y), and that X\u00b51,Y\u00b51 \u2286 Z\u03c3 \u2286 U , therefore, C \u2032 def = C\u03b4 \u2208 \u0393({[C |X ]} ,U) and D\u2032 def= D\u03b4 \u2208 \u0393({[D |Y]} ,U). The clause C \u2032 is of the form u1 ' v1 \u2228 C \u20321, and the clause D\u2032 of the form t1 ./ s1 \u2228D\u20321, where:\n\u2022 u1 = u\u03b4, v1 = v\u03b4 and C \u20321 = C1\u03b4,\n\u2022 t1 = t\u03b4, s1 = s\u03b4 and D\u20321 = D1\u03b4.\nLet t\u20321 def = t1\u2193U |p and u\u20321 def = u1\u2193U . By Proposition 69, t1 ./ s1 and u1 ' v1 are selected in C \u2032 and D\u2032 respectively, and we have t1 6CA s1, u1 6CA v1. Thus, there is an SA\u227asel-derivation from {C \u2032}\u222aU that generates the clause u\u20321 ' v1\u2228C \u20321, and an SA\u227asel-derivation from {D\u2032} \u222a U that generates t1[t\u20321]p ./ s1 \u2228D\u20321: it suffices to use repeated applications of the Superposition rule from equations in U to replace every constant a occurring in u1 or t1|p by a\u2193U . Note that u\u20321 ' v1 and t1[t \u2032 1]p ./ s1 are both selected and that u\u20321 6CA v1 and t1[t\u20321]p 6CA s1. We prove that t\u20321 and u\u20321 are unifiable. For i = 1, 2, let \u03b3i def = \u00b5i\u2193U , and let \u03b3 def = \u03b31]\u03b32. By Proposition 68, since (\u00b5, E) is a most general A-unifier of t|p ' s and E \u2286 U , \u03b3 is a most general unifier of (t|p)\u2193U ' u\u2193U . By Proposition 70, \u03b32 is an m.g.u. of (t|p)\u2193U\u03b31 ' u\u2193U\u03b31, and the restriction \u03bd of \u03b32\u03c3 to dom(\u03b32) is an m.g.u. of (t|p)\u2193U\u03b31\u03c3 ' u\u2193U\u03b31\u03c3. But we have\n(t|p)\u2193U\u03b31\u03c3 = (t\u00b51\u03c3)|p\u2193U = (t\u03b4)|p\u2193U = t \u2032 1,\nand similarly, u\u2193U\u03b31\u03c3 = u\u20321. Since t\u20321 and u\u20321 are unifiable with m.g.u. \u03bd, the Superposition rule applied to u\u20321 ' v1 \u2228 C \u20321 and t1[t\u20321]p ./ s1 \u2228D\u20321 generates the clause F def= (t1[v1]p ./ s1 \u2228 C \u20321 \u2228D\u20321)\u03bd, and:\nF = (t1[v1]p ./ s1 \u2228 C \u20321 \u2228D\u20321)\u03bd = (t[v]p\u03b4 ./ s\u03b4 \u2228 C \u2032\u03b4 \u2228D\u2032\u03b4)\u03bd = (t[v]p ./ s \u2228 C \u2032 \u2228D\u2032)\u00b51\u03c3\u03bd.\nWe now prove that for any variable x, we have x\u00b51\u03c3\u03bd = x\u00b5\u03c3. First assume that x /\u2208 dom(\u00b51). If x \u2208 var(X \u222a Y), then necessarily x \u2208 var(Z), and therefore,\nx\u00b5 = x and x \u2208 dom(\u03c3). Thus, x\u00b51\u03c3\u03bd = x\u03c3\u03bd = x\u03c3 = x\u00b5\u03c3. Otherwise, since dom(\u03c3) \u2286 var(X \u222a Y), necessarily x\u03c3 = x and x\u00b51\u03c3\u03bd = x\u03c3\u03bd = x\u03bd. If x \u2208 dom(\u03bd) then x\u03bd = x\u00b5\u03c3 by definition of \u03bd, otherwise, since x /\u2208 dom(\u00b51) ] dom(\u00b52) = dom(\u00b5), we deduce that x\u03bd = x = x\u00b5 = x\u00b5\u03c3. Now assume that x \u2208 dom(\u00b51). Then x\u00b51 = x\u00b5, and if x\u00b5 \u2208 A, then x\u00b51\u03c3\u03bd = x\u00b5 = x\u00b5\u03c3. Otherwise x\u00b5 \u2208 var(Z) = dom(\u03c3), hence x\u00b5\u03c3\u03b3 = x\u00b5\u03c3.\nFor the second part of the lemma, let E def= [E\u2032 |Z] and suppose that \u0393(E,U) contains a clause E\u2032\u03b3\u2032 (with \u03b3\u2032\u2193U = \u03b3\u2032) that is strongly redundant in \u0393(S,U). Let \u03c3 be a ground substitution of the variables in [E\u2032 |Z] such that Z\u03c3 \u2286 U . We show that [E\u2032 |Z]\u03c3 is A-redundant in S. We assume, w.l.o.g., that \u03c3 = \u03c3\u2193X . Let \u03b3 and \u03b8 be the restrictions of \u03c3 to var(X ) and dom(\u03b8) \\ var(X ) respectively. By definition we have dom(\u03b3) = var(X ) = dom(\u03b3\u2032), hence E\u2032\u03b3\u2032 \u223cA E\u03b3. Since E\u2032\u03b3\u2032 is strongly redundant in \u0393(S,U) we deduce that E\u2032\u03b3\u03b8 = E\u2032\u03c3 is A-redundant in S. Since S is a set of standard clauses, this entails that E\u03c3 is also A-redundant."}], "references": [{"title": "Superposition modulo linear arithmetic sup(la)", "author": ["E Althaus", "E Kruglov", "C Weidenbach"], "venue": "FroCoS 2009, Springer, LNCS,", "citeRegEx": "Althaus et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Althaus et al\\.", "year": 2009}, {"title": "A rewriting approach to satisfiability procedures. Information and Computation", "author": ["A Armando", "S Ranise", "M Rusinowitch"], "venue": null, "citeRegEx": "Armando et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Armando et al\\.", "year": 2003}, {"title": "New results on rewritebased satisfiability procedures", "author": ["A Armando", "MP Bonacina", "S Ranise", "S Schulz"], "venue": "ACM Transactions on Computational Logic", "citeRegEx": "Armando et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Armando et al\\.", "year": 2009}, {"title": "Term Rewriting and All That", "author": ["F Baader", "T Nipkow"], "venue": null, "citeRegEx": "Baader and Nipkow,? \\Q1998\\E", "shortCiteRegEx": "Baader and Nipkow", "year": 1998}, {"title": "Rewrite-based equational theorem proving with selection and simplification", "author": ["L Bachmair", "H Ganzinger"], "venue": "Journal of Logic and Computation", "citeRegEx": "Bachmair and Ganzinger,? \\Q1994\\E", "shortCiteRegEx": "Bachmair and Ganzinger", "year": 1994}, {"title": "Refutational theorem proving for hierarchic first-order theories. Applicable Algebra in Engineering, Communication and Computing", "author": ["L Bachmair", "H Ganzinger", "U Waldmann"], "venue": null, "citeRegEx": "Bachmair et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Bachmair et al\\.", "year": 1994}, {"title": "Hierarchic superposition with weak abstraction", "author": ["P Baumgartner", "U Waldmann"], "venue": null, "citeRegEx": "Baumgartner and Waldmann,? \\Q2013\\E", "shortCiteRegEx": "Baumgartner and Waldmann", "year": 2013}, {"title": "Automated Deduction - CADE-24 - 24th International Conference on Automated Deduction, Lake Placid", "author": ["MP Bonacina"], "venue": "NY, USA, June 9-14,", "citeRegEx": "Bonacina,? \\Q2013\\E", "shortCiteRegEx": "Bonacina", "year": 2013}, {"title": "Automated Model Building", "author": ["R Caferra", "A Leitsch", "N Peltier"], "venue": "Applied Logic Series,", "citeRegEx": "Caferra et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Caferra et al\\.", "year": 2004}, {"title": "An improved incremental algorithm for generating prime implicates", "author": ["J De Kleer"], "venue": "Proceedings of the National Conference on Artificial Intelligence,", "citeRegEx": "Kleer,? \\Q1992\\E", "shortCiteRegEx": "Kleer", "year": 1992}, {"title": "A (2010) Small formulas for large programs: On-line constraint simplification in scalable static analysis", "author": ["I Dillig", "T Dillig", "Aiken"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Dillig et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Dillig et al\\.", "year": 2010}, {"title": "Minimum satisfying assignments for smt", "author": ["I Dillig", "T Dillig", "KL McMillan", "A Aiken"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Dillig et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dillig et al\\.", "year": 2012}, {"title": "The YICES SMT-solver", "author": ["D Dutertre", "L de Moura"], "venue": "In SMT-COMP: Satisfiability Modulo Theories Competition. Available at http://yices.csl.sri.com", "citeRegEx": "Dutertre and Moura,? \\Q2006\\E", "shortCiteRegEx": "Dutertre and Moura", "year": 2006}, {"title": "A Calculus for Generating Ground Explanations", "author": ["M Echenim", "N Peltier"], "venue": "Proceedings of the International Joint Conference on Automated Reasoning (IJCAR\u201912), Springer LNCS,", "citeRegEx": "Echenim and Peltier,? \\Q2012\\E", "shortCiteRegEx": "Echenim and Peltier", "year": 2012}, {"title": "An approach to abductive reasoning in equational logic", "author": ["M Echenim", "N Peltier", "S Tourret"], "venue": "Proceedings of IJCAI\u201913 (International Conference on Artificial Intelligence),", "citeRegEx": "Echenim et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Echenim et al\\.", "year": 2013}, {"title": "The prime normal form of boolean formulas", "author": ["L Henocque"], "venue": "Technical report at http://wwwIsisorg/fichephp", "citeRegEx": "Henocque,? \\Q2002\\E", "shortCiteRegEx": "Henocque", "year": 2002}, {"title": "Computing prime implicants", "author": ["P Jackson", "J Pais"], "venue": "10th International Conference on Automated Deduction,", "citeRegEx": "Jackson and Pais,? \\Q1990\\E", "shortCiteRegEx": "Jackson and Pais", "year": 1990}, {"title": "An incremental method for generating prime implicants/implicates", "author": ["A Kean", "G Tsiknis"], "venue": "Journal of Symbolic Computation", "citeRegEx": "Kean and Tsiknis,? \\Q1990\\E", "shortCiteRegEx": "Kean and Tsiknis", "year": 1990}, {"title": "Equality and abductive residua for horn clauses", "author": ["E Knill", "P Cox", "T Pietrzykowski"], "venue": "Theoretical Computer Science", "citeRegEx": "Knill et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Knill et al\\.", "year": 1992}, {"title": "The resolution calculus", "author": ["A Leitsch"], "venue": "Springer. Texts in Theoretical Computer Science", "citeRegEx": "Leitsch,? \\Q1997\\E", "shortCiteRegEx": "Leitsch", "year": 1997}, {"title": "Automatic Decidability", "author": ["C Lynch", "B Morawska"], "venue": "Proc. of 17th IEEE Symposium on Logic in Computer Science (LICS\u20192002),", "citeRegEx": "Lynch and Morawska,? \\Q2002\\E", "shortCiteRegEx": "Lynch and Morawska", "year": 2002}, {"title": "Automatic decidability and combinability", "author": ["C Lynch", "S Ranise", "C Ringeissen", "DK Tran"], "venue": "Information and Computation", "citeRegEx": "Lynch et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Lynch et al\\.", "year": 2011}, {"title": "Extending abduction from propositional to first-order logic", "author": ["P Marquis"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Marquis,? \\Q1991\\E", "shortCiteRegEx": "Marquis", "year": 1991}, {"title": "Prime implicate tries. Automated Reasoning with Analytic Tableaux and Related Methods pp", "author": ["A Matusiewicz", "N Murray", "E Rosenthal"], "venue": null, "citeRegEx": "Matusiewicz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Matusiewicz et al\\.", "year": 2009}, {"title": "Tri-based set operations and selective computation of prime implicates", "author": ["A Matusiewicz", "N Murray", "E Rosenthal"], "venue": "Foundations of Intelligent Systems", "citeRegEx": "Matusiewicz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Matusiewicz et al\\.", "year": 2011}, {"title": "First order abduction via tableau and sequent calculi", "author": ["MC Mayer", "F Pirri"], "venue": "Logic Journal of the IGPL", "citeRegEx": "Mayer and Pirri,? \\Q1993\\E", "shortCiteRegEx": "Mayer and Pirri", "year": 1993}, {"title": "Computer programs for checking mathematical proofs", "author": ["J McCarthy"], "venue": "Recursive Function Theory, Proc. of Symposia in Pure Mathematics,", "citeRegEx": "McCarthy,? \\Q1962\\E", "shortCiteRegEx": "McCarthy", "year": 1962}, {"title": "Yet another decision procedure for equality logic", "author": ["O Meir", "O Strichman"], "venue": "Proceedings of the 17th International Conference on Computer Aided Verification,", "citeRegEx": "Meir and Strichman,? \\Q2005\\E", "shortCiteRegEx": "Meir and Strichman", "year": 2005}, {"title": "Paramodulation-based theorem proving", "author": ["R Nieuwenhuis", "A Rubio"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Nieuwenhuis and Rubio,? \\Q2001\\E", "shortCiteRegEx": "Nieuwenhuis and Rubio", "year": 2001}, {"title": "Efficient consequence finding", "author": ["L Simon", "A Del Val"], "venue": "Proceedings of the 17th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Simon and Val,? \\Q2001\\E", "shortCiteRegEx": "Simon and Val", "year": 2001}, {"title": "Hierarchical reasoning for the verification of parametric systems", "author": ["V Sofronie-Stokkermans"], "venue": "IJCAR, Springer, LNCS,", "citeRegEx": "Sofronie.Stokkermans,? \\Q2010\\E", "shortCiteRegEx": "Sofronie.Stokkermans", "year": 2010}, {"title": "Hierarchical reasoning and model generation for the verification of parametric hybrid systems", "author": ["V Sofronie-Stokkermans"], "venue": null, "citeRegEx": "Sofronie.Stokkermans,? \\Q2013\\E", "shortCiteRegEx": "Sofronie.Stokkermans", "year": 2013}, {"title": "Generalization of consensus theory and application to the minimization of boolean functions", "author": ["P Tison"], "venue": "Electronic Computers, IEEE Transactions on 4:446\u2013456", "citeRegEx": "Tison,? \\Q1967\\E", "shortCiteRegEx": "Tison", "year": 1967}, {"title": "Combination of convex the", "author": ["DK Tran", "C Ringeissen", "S Ranise", "H Kirchner"], "venue": null, "citeRegEx": "Tran et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Tran et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 4, "context": "In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.", "startOffset": 87, "endOffset": 146}, {"referenceID": 28, "context": "In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.", "startOffset": 87, "endOffset": 146}, {"referenceID": 32, "context": "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).", "startOffset": 64, "endOffset": 142}, {"referenceID": 17, "context": "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).", "startOffset": 64, "endOffset": 142}, {"referenceID": 16, "context": "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).", "startOffset": 226, "endOffset": 297}, {"referenceID": 15, "context": "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).", "startOffset": 226, "endOffset": 297}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991).", "startOffset": 62, "endOffset": 77}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic.", "startOffset": 63, "endOffset": 269}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning.", "startOffset": 63, "endOffset": 801}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formul\u00e6 that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories.", "startOffset": 63, "endOffset": 1495}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formul\u00e6 that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formul\u00e6 interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability).", "startOffset": 63, "endOffset": 2553}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formul\u00e6 that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formul\u00e6 interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)).", "startOffset": 63, "endOffset": 3125}, {"referenceID": 22, "context": "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formul\u00e6 that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formul\u00e6 interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)). Wernhard (2013) proposes a method to derive abductive explanations from first-order logical programs, under several distinct non-classical semantics, using a reduction to second-order quantifier-elimination.", "startOffset": 63, "endOffset": 3143}, {"referenceID": 13, "context": "The present paper is a thoroughly expanded and revised version of (Echenim and Peltier, 2012).", "startOffset": 66, "endOffset": 93}, {"referenceID": 13, "context": "2 for more details on the relationship of SAsel with the calculus in (Echenim and Peltier, 2012).", "startOffset": 69, "endOffset": 96}, {"referenceID": 4, "context": "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set.", "startOffset": 78, "endOffset": 137}, {"referenceID": 28, "context": "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set.", "startOffset": 78, "endOffset": 137}, {"referenceID": 28, "context": "When applied to standard clauses (with A = \u2205), this notion of redundancy coincides with the usual criterion (see for instance Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001).", "startOffset": 108, "endOffset": 184}, {"referenceID": 4, "context": "5 See (Bachmair and Ganzinger, 1994) or (Nieuwenhuis and Rubio, 2001, theorem 4.", "startOffset": 6, "endOffset": 36}, {"referenceID": 13, "context": "SARsel essentially simulates the calculus in (Echenim and Peltier, 2012), but there are some important differences: in particular our previous approach does not handle variable-active axioms and is complete only for implicates containing no predicate symbol other than '.", "startOffset": 45, "endOffset": 72}, {"referenceID": 13, "context": "The next theorem states a form of completeness for the restricted calculus SARsel, which is weaker than that of the calculus SA \u227a sel (compare with Theorem 40) and similar to that of (Echenim and Peltier, 2012).", "startOffset": 183, "endOffset": 210}, {"referenceID": 6, "context": "This can be done for instance by combining our approach with existing techniques for fusing the Superposition calculus and external reasoning tools (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013).", "startOffset": 148, "endOffset": 223}, {"referenceID": 6, "context": "In other approaches (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013) the constraints are used to store formul\u00e6 that cannot be handled by the Superposition calculus, whereas in our case they are used to store properties that are asserted instead of being proved.", "startOffset": 20, "endOffset": 95}], "year": 2014, "abstractText": "We present a modification of the Superposition calculus that is meant to generate consequences of sets of first-order axioms. This approach is proven to be sound and deductive-complete in the presence of redundancy elimination rules, provided the considered consequences are built on a given finite set of ground terms, represented by constant symbols. In contrast to other approaches, most existing results about the termination of the Superposition calculus can be carried over to our procedure. This ensures in particular that the calculus is terminating for many theories of interest to the SMT community.", "creator": "LaTeX with hyperref package"}}}