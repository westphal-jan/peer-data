{"id": "1406.2161", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jun-2014", "title": "Tableaux for Dynamic Logic of Propositional Assignments", "abstract": "The Dynamic Logic for Propositional Assignments (DL-PA) has recently been studied as an alternative to Propositional Dynamic Logic (PDL). In DL-PA, the abstract atomic programs of PDL are replaced by assignments of propositional variables to truth values. This makes DL-PA enjoy some interesting meta-logical properties that PDL does not, such as eliminability of the Kleene star, compactness and interpolation. We define and analytic tableaux calculus for DL-PA and show that it matches the known complexity results.\n\n\n\nThe problem of assigning the type of expression to the condition of a condition of truth (1) is not an empirical problem; rather, it is an empirical problem. In this article, we demonstrate that PDL is a useful concept to explain the derivation of function types. We show that PDL can be generalized by assigning the condition of truth in its simplest form to the condition of truth:\n1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\n1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 90 91 92 93 94 95 97 98 99 100\n2 3 4 5 6 7 8 9 10 11 12 13 15 16 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 47 48 49 50 51 52 53 55 56 57 58 59 61 63 64 65 66 67 68 69 70 71 72 73 75 76 78 79 80 81 82 83 84 85 86 88 89 90 92 93 94 95 96 97 98 99 100\n3 4 6 7 8 9 10 12 13 15 16 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34", "histories": [["v1", "Mon, 9 Jun 2014 12:54:41 GMT  (21kb)", "http://arxiv.org/abs/1406.2161v1", "20 pages"]], "COMMENTS": "20 pages", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["tiago de lima", "andreas herzig"], "accepted": false, "id": "1406.2161"}, "pdf": {"name": "1406.2161.pdf", "metadata": {"source": "CRF", "title": "Tableaux for Dynamic Logic of Propositional Assignments", "authors": ["Tiago de Lima", "Andreas Herzig"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 6.\n21 61\nv1 [\ncs .L\nO ]\n9 J\nun 2\nKeywords: Modal Logic; Propositional Dynamic Logic; Dynamic Logic of Propositional Assignments; analytic tableaux."}, {"heading": "1 Introduction", "text": "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7]. In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4]. While, in PDL, one can write formulas of the form [a]\u03d5, meaning \u201cafter every possible execution of the abstract atomic program a, formula \u03d5 is true\u201d, in DL-PA, one can write formulas of the form [+p]\u03d5, meaning \u201cafter assigning the truth value of p to true, formula \u03d5 is true\u201d. The atomic program +p is an assignment that maps the propositional variable p to true. In fact, the atomic programs of DL-PA are sets of such assignments, that are viewed as partial functions from the set of propositional variables to {\u22a4,\u22a5}. From these atomic programs, complex programs are built just as in PDL. For example, one can write in DL-PA the formula [\u00acp?;+p]p, which means \u201cif p is false then p is true after its truth value be assigned to true\u201d.\nWhile the models of PDL are transition systems, the models of DL-PA are much smaller: valuations of classical propositional logic, i.e., nothing but sets of propositional variables. Due to that, DL-PA enjoys some interesting meta-logical properties that PDL lacks, such as eliminability of the Kleene star, compactness and interpolation.\nThe complexity of the satisfiability problem in DL-PA is the same as in PDL: it is in EXPTIME for the full language and PSPACE complete for the star-free fragment. EXPTIME membership of the full language is proved by a polynomial embedding of DL-PA into PDL, and PSPACE membership of the star-free fragment of DL-PA is\nproved via NPSPACE membership of its model checking problem, exploiting the fact that NPSPACE = PSPACE. However, these reductions lead to suboptimal theorem proving methods. Our aim in this paper is to define tableaux theorem proving procedures for DL-PA that are both direct and more efficient.\nThe paper is organized as follows. We start by recalling DL-PA (Section 2). Then, we provide a tableaux method for its star-free fragment (Section 3) and show an algorithm implementing it that works in polynomial space (Section 4). After that, we extend the tableaux method to the full language of DL-PA (Section 5) and then show an algorithm implementing it and that works in time exponential (Section 6). Section 7 discusses some issues and concludes the paper.3"}, {"heading": "2 Dynamic Logic of Propositional Assignments", "text": ""}, {"heading": "2.1 Syntax", "text": "The vocabulary of DL-PA contains a countable set P of propositional variables. From this set, we build the setA of propositional assignments, which are the atomic programs of the language. Each propositional assignment is a non-empty finite partial function from P to {\u22a5,\u22a4}.4\nThe language L of DL-PA is the the set of formulas \u03d5 defined by the BNF:\n\u03d5F p | \u00ac\u03d5 | \u03d5 \u2227 \u03d5 | [\u03c0]\u03d5\n\u03c0F \u03b1 | \u03c0; \u03c0 | \u03c0 \u222a \u03c0 | \u03c0\u2217 | \u03d5?\nwhere p ranges over P and \u03b1 ranges over A. To ease notation and readability of programs, we write +p for (p,\u22a4) and \u2212p for (p,\u22a5). Moreover, we sometimes \u201cforget\u201d some parentheses and curly braces when writing propositional assignments. As a result, the formula [{(p,\u22a4), (q,\u22a5)}]\u03d5 is rather noted [+p,\u2212q]\u03d5. In some places, we use the expression \u00b1p to talk economically about +p and \u2212p at the same time.\nThe complex programs of DL-PA are constructed as in Dynamic Propositional Logic (PDL) [8]. As well as in PDL, formulas of the form [\u03c0]\u03d5 are read \u201cafter every possible execution of \u03c0, \u03d5 is true\u201d.\nWe also use the common abbreviations for the connectives \u22a4, \u22a5, \u2228, \u2192 and \u2194. The formula \u3008\u03c0\u3009\u03d5 abbreviates \u00ac[\u03c0]\u00ac\u03d5. The star-free fragment of L is the fragment without the Kleene star operator \u2217 and is noted L\u2212\u2217.\nThe length of a formula or a program, given by the function len, is the number of atoms and connectives in the formula or the program. Table 1 defines it formally.\nThe closure of \u03d5 is the set cl(\u03d5) defined in Table 2. This is almost the same as the Fisher-Ladner closure [5], which is used to show decidability and complexity results for PDL. But since the atomic programs of DL-PA are sets of assignments, there is a difference here in the definition of cl ([\u03b1]\u03d5). It takes into account the assignments by adding the domain of the atomic program \u03b1.\n3 Proofs of the important theorems are in the appendix. 4 We note that the original language in [2] is slightly more restrictive: \u03b1 only assigns a single\npropositional variable. But, as shown in this paper, it does not change the known decidability and complexity results.\nThe extended closure of \u03d5 is the set cl+(\u03d5) containing cl(\u03d5) and the negations of its formulas, i.e., cl+(\u03d5) = cl(\u03d5)\u222a {\u00ac\u03c8 : \u03c8 \u2208 cl(\u03d5)}. To ease notation, we sometimes use P\u03d5 to denote the set of propositional variables occurring in \u03d5, i.e. P\u03d5 = P \u2229 cl(\u03d5).\nThe lemma below can be proved with an easy induction on the length of formulas and programs.\nLemma 1.\n1. card(cl ([\u03c0]\u03d5)) \u2264 len([\u03c0]\u03d5) 2. card(cl(\u03d5)) \u2264 len(\u03d5). 3. card(cl+(\u03d5)) \u2264 2 len(\u03d5).\nIntuitively, the set of execution traces of \u03c0 is the set exe(\u03c0) of sequences of assignments that corresponds to all possible executions of program \u03c0. The set exe(\u03d5) corresponds to all possible executions of all programs in \u03d5. These are defined by a mutual recursion, as displayed in Table 3. We use the symbol \u2018()\u2019 to denote the empty sequence.\nThe length of execution traces, also given by the function len, is just the number of atomic programs in it. That is: len(()) = 0, len(\u03b1) = 1 and len(\u03c3\u03b1) = len(\u03c3) + len(\u03b1).\nThe lemma below can also be proved with an easy induction on the length of programs and formulas:\nLemma 2.\n1. If \u03c0 does not contain the Kleene star then len(\u03c3) \u2264 len(\u03c0), for all \u03c3 \u2208 exe(\u03c0). 2. If \u03d5 \u2208 L\u2212\u2217 then len(\u03c3) \u2264 len(\u03d5), for all \u03c3 \u2208 exe(\u03d5).\nNote, however, that each \u03c3 \u2208 exe(\u03c0\u2217) is infinite."}, {"heading": "2.2 Semantics", "text": "A DL-PA model is a set V \u2286 P of propositional variables. When p \u2208 V then p is true, and when p < V then p is false.\nThe interpretation of an assignment \u03b1 is in terms of a model update. The update of a model V by an assignment \u03b1 is the new model V\u03b1 such that:\nV\u03b1 = {p : V |= \u03b1(p)}\nwhere we suppose that when p is not in the domain of \u03b1 then \u03b1(p) equals p. In particular, for the assignment +p we have V+p = V \u222a {p}. Given a sequence of assignments \u03b11 . . . \u03b1n, for the sake of readability, we sometimes write V\u03b11 \u00b7\u00b7\u00b7\u03b1n instead of (\u00b7 \u00b7 \u00b7 (V\u03b11 ) \u00b7 \u00b7 \u00b7 )\u03b1n .\nFormulas \u03d5 are interpreted as sets of models ||\u03d5||, while programs \u03c0 are interpreted by means of a (unique) relation between valuations ||\u03c0||. Just as in PDL, the formal definition is by a mutual recursion. It is given in Table 4.\nAs usual, we also write V |= \u03d5 to mean that V \u2208 ||\u03d5||. Moreover, given a formula \u03d5, we say that \u03d5 is DL-PA valid (noted |= \u03d5) if and only if ||\u03d5|| = 2P, and we say that \u03d5 is DL-PA satisfiable if and only if ||\u03d5|| , \u2205.\nFor example, the formulas [+p]\u22a4, [+p]\u03d5\u2194 \u00ac[+p]\u00ac\u03d5, [\u03c0]\u22a4, [+p]p and [\u2212p]\u00acp are all DL-PA valid."}, {"heading": "2.3 Existing Proof Methods", "text": "We now recall the existing methods for both model checking and satisfiability checking in DL-PA. They either use a non-elementary reduction to propositional logic or a quadratic embedding into PDL. We then provide a linear reduction of satisfiability checking to model checking. This justifies our focus on a tableaux method for model checking in the rest of the paper. But first, let us recall some valid principles in DL-PA.\nProposition 1 ([10]). The following principles are valid in DL-PA:\n1. [\u03b1]p \u2194 \u03b1(p) 2. [\u03c8?]\u03d5\u2194 (\u03c8\u2192 \u03d5) 3. [\u03c0]\u00ac\u03d5\u2194 \u00ac[\u03c0]\u03d5 4. [\u03c0](\u03d5 \u2227 \u03c8) \u2194 ([\u03c0]\u03d5 \u2227 [\u03c0]\u03c8) 5. [\u03c01; \u03c02]\u03d5\u2194 [\u03c01][\u03c02]\u03d5 6. [\u03c01 \u222a \u03c02]\u03d5\u2194 ([\u03c01]\u03d5 \u2227 [\u03c02]\u03d5) 7. [\u03c0\u2217]\u03d5\u2194 (\u03d5 \u2227 [\u03c0][\u03c0\u2217]\u03d5) 8. From \u03c8\u2192 (\u03d5 \u2227 [\u03c0\u2217]\u03c8) infer \u03c8\u2192 [\u03c0\u2217]\u03d5\nIt follows from Proposition 1.1\u20131.6 plus the rule of substitution of valid equivalences that the star-free fragment of DL-PA is reducible to propositional logic. This however fails to provide an efficient theorem proving method because the reduced formula might be exponentially longer than the original formula. In [2], it is also shown that the Kleene star can be eliminated in DL-PA, i.e., there is an algorithm that translates every formula in L to an equivalent formula in L\u2212\u2217. Such translation, however, also leads to much longer formulas. In fact, this is a non-elementary reduction because it starts from the innermost Kleene star operator.\nSatisfiability checking in DL-PA is shown to be in EXPTIME in [2]. The proof is given via a translation to satisfiability checking in PDL. For every DL-PA formula \u03d5, the translation tr returns a PDL formula which is obtained by just replacing each assignment \u00b1p by an abstract PDL program a\u00b1p. To guarantee that the abstract programs behave the same way as the original assignment, the following set of formulas \u0393\u03d5 is also used:\n\u0393\u03d5 = {[a+p]p : p \u2208 P\u03d5} \u222a\n{[a\u2212p]\u00acp : p \u2208 P\u03d5} \u222a\n{\u3008a\u00b1p\u3009\u22a4 : \u00b1p \u2208 P\u03d5} \u222a\n{q \u2192 [a\u00b1p]q : p, q \u2208 P\u03d5, p , q} \u222a\n{\u00acq \u2192 [a\u00b1p]\u00acq : p, q \u2208 P\u03d5, p , q}\nProposition 2 ([2]). Let U\u03d5 be the PDL program ( \u22c3 p\u2208P\u03d5 (a+p\u222aa\u2212p)) \u2217. For every DL-PA formula \u03d5, \u03d5 is DL-PA satisfiable if and only if\ntr(\u03d5) \u2227 [U\u03d5] ( \u2227 \u0393\u03d5 )\nis PDL satisfiable.\nNote that, even though this reduction is polynomial, a quadratically longer formula is produced. Precisely, the size of \u0393\u03d5 is bounded by 5 len(\u03d5)2. Moreover, if we consider the star-free fragment of DL-PA, this transformation is sub-optimal, because of the Kleene star operator in U\u03d5.5\nIf follows from the next result that satisfiability checking in DL-PA can be linearly reduced to model checking in DL-PA.\nProposition 3. Let a formula \u03d5 \u2208 L be given. Let P\u03d5 = {p1, . . . , pn}. and let M\u03d5 be the DL-PA program (+p1 \u222a \u2212p1); . . . ; (+pn \u222a \u2212pn). Formula \u03d5 is satisfiable if and only if V |= \u3008M\u03d5\u3009\u03d5 for any model V.\nProof. It suffices to see that the interpretation of the program M\u03d5 relates all possible valuations in the vocabulary of \u03d5, while leaving the other variables unchanged. \u2293\u2294\nThe operation [M\u03d5] works as a master modality and thus \u3008M\u03d5\u3009 works as its dual. Because it does not contain the Kleene star operator, the length of \u3008M\u03d5\u3009\u03d5 is bounded by 3 len(\u03d5). Also note that, in particular, \u03d5 is satisfiable if and only if V = \u2205 satisfies \u3008M\u03d5\u3009\u03d5. This means that the input (V, \u3008M\u03d5\u3009\u03d5) for the model checking problem is also linear on the length of \u03d5. Therefore, in order to perform satisfiability checking in DL-PA, one could take advantage of an efficient algorithm for model checking in DL-PA. This motivates the tableaux methods presented in the next section.\nBefore concluding this section, let us recall that, in DL-PA, model checking has the same computational complexity as satisfiability checking. This follows from Proposition 3 above and Proposition 4 below.\nProposition 4 ([2]). For every valuation V and formula \u03d5, V \u2208 ||\u03d5|| if and only if the formula\n\u03d5 \u2227\n         \u2227\np\u2208P\u03d5\u2229V\np\n         \u2227          \u2227\np\u2208P\u03d5\\V\n\u00acp\n        \nis DL-PA satisfiable."}, {"heading": "3 A Tableaux Method for Star-Free DL-PA", "text": "In this section, we define a model checking procedure for the star-free fragment of DL-PA using analytic tableaux. We start with some useful definitions.\nA labeled formula is a pair \u03bb = \u3008\u03c3, \u03d5\u3009, where \u03c3 = \u03b11 . . . \u03b1n is a (possibly empty) sequence of propositional assignments and \u03d5 \u2208 L. A branch is a set of labelled formulas.\nDefinition 1 (Tableau). Let V \u2286 P and \u03d50 \u2208 L\u2212\u2217. The initial branch for (V, \u03d50) is the the set b0 = {\u3008(), p\u3009 : p \u2208 P\u03d50 \u2229 V} \u222a {\u3008(),\u00acp\u3009 : p \u2208 P\u03d50 \\ V} \u222a {\u3008(), \u03d50\u3009}. A tableau for (V, \u03d50) is a set of branches T that satisfies one of the following two conditions:\n1. T = {b0}, which is called the initial tableau for (V, \u03d50).\n5 For the star-free fragment, a transformation without the Kleene star operator is also possible. In this case, the program \u22c3\np\u2208P\u03d5(a+p \u222a a\u2212p) must be iterated up to len(\u03d5), but this leads to an even longer formula.\n2. T = (T \u2032 \\ {b}) \u222a B, where T \u2032 is a tableau for (V, \u03d50) containing the branch b and B is a set of k branches {b \u222a b1, . . . , b \u222a bk} generated by one of the following tableau rules below:6\n(R\u00ac) \u3008\u03c3,\u00ac\u00ac\u03d5\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3, \u03d5\u3009}. (R\u2227) \u3008\u03c3, \u03d5 \u2227 \u03c8\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3, \u03d5\u3009, \u3008\u03c3, \u03c8\u3009}. (R\u2228) \u3008\u03c3,\u00ac(\u03d5 \u2227 \u03c8)\u3009 \u2208 b implies k = 2, b1 = {\u3008\u03c3,\u00ac\u03d5\u3009} and b2 = {\u3008\u03c3,\u00ac\u03c8\u3009}. (R[\u03b1]) \u3008\u03c3, [\u03b1]\u03d5\u3009 \u2208 b implies k = 1 and\nb1 = {\u3008\u03c3\u03b1, \u03d5\u3009} \u222a {\u3008\u03c3\u03b1, p\u3009 : \u03b1(p) = \u22a4} \u222a {\u3008\u03c3\u03b1,\u00acp\u3009 : \u03b1(p) = \u22a5}. (R\u3008\u03b1\u3009) \u3008\u03c3,\u00ac[\u03b1]\u03d5\u3009 \u2208 b implies k = 1 and\nb1 = {\u3008\u03c3\u03b1,\u00ac\u03d5\u3009} \u222a {\u3008\u03c3\u03b1, p\u3009 : \u03b1(p) = \u22a4} \u222a {\u3008\u03c3\u03b1,\u00acp\u3009 : \u03b1(p) = \u22a5}. (R[?]) \u3008\u03c3, [\u03c8?]\u03d5\u3009 \u2208 b implies k = 2, b1 = {\u3008\u03c3,\u00ac\u03c8\u3009} and b2 = {\u3008\u03c3, \u03d5\u3009}. (R\u3008?\u3009) \u3008\u03c3,\u00ac[\u03c8?]\u03d5\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3, \u03c8\u3009, \u3008\u03c3,\u00ac\u03d5\u3009}. (R[;]) \u3008\u03c3, [\u03c01; \u03c02]\u03d5\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3, [\u03c01][\u03c02]\u03d5\u3009}. (R\u3008;\u3009) \u3008\u03c3,\u00ac[\u03c01; \u03c02]\u03d5\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3,\u00ac[\u03c01][\u03c02]\u03d5\u3009}. (R[\u222a]) \u3008\u03c3, [\u03c01 \u222a \u03c02]\u03d5\u3009 implies k = 1 and b1 = {\u3008\u03c3, [\u03c01]\u03d5\u3009, \u3008\u03c3, [\u03c02]\u03d5\u3009}. (R\u3008\u222a\u3009) \u3008\u03c3,\u00ac[\u03c01\u222a\u03c02]\u03d5\u3009 \u2208 b implies k = 2, b1 = {\u3008\u03c3,\u00ac[\u03c01]\u03d5\u3009} and b2 = {\u3008\u03c3,\u00ac[\u03c02]\u03d5\u3009}. (RP1) {\u3008\u03c3, p\u3009, \u3008\u03c3\u03b1, \u03c8\u3009} \u2286 b for some \u03c8 and p < dom(\u03b1) implies k = 1 and b1 = {\u3008\u03c3\u03b1, p\u3009}. (RP2) {\u3008\u03c3,\u00acp\u3009, \u3008\u03c3\u03b1, \u03c8\u3009} \u2286 b for some \u03c8 and p < dom(\u03b1) implies k = 1 and\nb1 = {\u3008\u03c3\u03b1,\u00acp\u3009}.\nThe initial tableau corresponds to the input of the problem in the tableau. Rules R\u00ac, R\u2227 and R\u2228 are the standard tableaux rules for Boolean connectives. RP1 and RP2 (propagation rules) propagate literals whose the truth value is not changed by assignments: if the model updated by \u03c3 satisfies p and \u03b1 does not change the truth value of p then the model updated by \u03c3\u03b1 also satisfies p. The other rules just reflect the semantic definition of the corresponding programs. For instance, for the rule R[\u03b1], if the model updated by the sequence of assignments \u03c3 satisfies [\u03b1]\u03d5 then the model updated by the sequence \u03c3\u03b1 satisfies \u03d5. Note that they also correspond to the validities 1\u20136 in Proposition 1.\nA branch b is blatantly inconsistent if and only if b contains both \u3008\u03c3, \u03d5\u3009 and \u3008\u03c3,\u00ac\u03d5\u3009, for some \u03c3 and \u03d5. A branch b is closed if and only if it is blatantly inconsistent. A tableau is closed if and only if all its branches are closed. A tableau is open if and only if it is not closed.\nThe idea is that, if there is a closed tableau for the input (V, \u03d50) then V 6|= \u03d50. On the other hand, if there is no closed tableau for (V, \u03d50) then V |= \u03d50.\nExample 1. Table 5 shows how the method can be used to prove that the model V = {p, q} does not satisfy the formula\u03d50 = \u00ac[+p\u222a\u2212p]q. In the table, lines 1\u20133 consist of the initial tableau for the input (V, \u03d50). Rule applications are indicated between parentheses on the left of each line. Line 4 is generated by the application of R[\u222a] to line 3. This generates two different branches. The rule applications continue until both branches are closed.\n6 Some of these rules are also presented in the more traditional numerator-denominator form in Table 10 of the Appendix.\nExample 2. Table 6 shows how the method can be used to prove that the model V = \u2205 satisfy the formula \u03d50 = [\u00acp?;+p]p. Note that RP2 is not applicable to the labelled formulas in lines 1 and 5 because p \u2208 dom(+p). Thus, the branch on the right remains open, which means that V |= \u03d50.\nIn the sequel, we show the soundness of the method. The idea is to show that, if V |= \u03d50, then successive rule applications can never close the tableau. But first, a useful definition and a lemma are presented.\nDefinition 2 (Consistent Branch). A branch b is consistent if and only if V\u03c3 |= \u03d5 for every \u3008\u03c3, \u03d5\u3009 \u2208 b.\nLemma 3 (Consistency Preservation). For each tableau rule \u03c1, if branch b is consistent, then the set of branches B generated by the application of \u03c1 to b contains a consistent branch.\nTheorem 1 (Soundness). If V |= \u03d50 then there is no closed tableau for (V, \u03d50).\nWe now address the completeness of the method. The idea is to show that, if the tableau remains open after all possible applications of the tableau rules, then V |= \u03d50. But first, some useful definitions are presented.\nDefinition 3 (Witness). A witness to rule \u03c1 in branch b is a labelled formula \u3008\u03c3, \u03d5\u3009 \u2208 b allowing the application of \u03c1.\nFor example, \u3008(),\u00ac\u00acp\u3009 is a witness to R\u00ac, and \u3008\u03b2,\u00ac[+p,\u2212q]p\u3009 is a witness to R\u3008\u03b1\u3009. Moreover, the formula \u3008\u03c3, p\u3009 is a witness to RP1 in b if there is a formula \u3008\u03c3\u03b1, \u03c8\u3009 \u2208 b and p < dom(\u03b1).\nDefinition 4 (Saturated Tableau). The label \u03c3 in the branch b is saturated under the tableau rule \u03c1 if and only if for each witness \u3008\u03c3, \u03d5\u3009 to \u03c1 in b, b contains some bi generated by the application of \u03c1 to b. The branch b is saturated under the tableau rule \u03c1 if and only if all its labels are saturated. A branch is saturated if and only if it is saturated under all tableau rules. A tableau is saturated if and only if all its branches are saturated.\nTheorem 2 (Completeness). If there is no closed tableau for (V, \u03d50) then V |= \u03d50."}, {"heading": "4 An Optimal Procedure for Star-Free DL-PA", "text": "In this section we define an algorithm to check whether V |= \u03d50, for \u03d50 \u2208 L\u2212\u2217. Such an algorithm is displayed in Table 7. It implements the tableaux method using the recursive function mcTableau. It takes as argument a tableau branch b and returns whether b is consistent. When called with the initial tableau for (V, \u03d50) it returns whether V |= \u03d50. The execution of mcTableau explores in a depth-first manner a tree whose nodes are tableau branches and each child is generated by the application of a tableau rule to its parent.\nThe rules are applied in a specific order and, after the application of a rule, the witness is marked \u2018non-applicable\u2019, thus avoiding an infinite loop. Lines 8\u201321 perform what is called \u2018local saturation\u2019. That is, only rules that do not create labelled formulas with different labels than that of the witness are applied. Its first part (lines 8\u201311) applies rules that do not create more than one branch in the tableau. Its second part (lines 12\u2013 21) apples rules that create more than one branch in the tableau. At the end of the local saturation, only witnesses to rules R[\u03b1], R\u3008\u03b1\u3009 remain. Note that no new label is created in the local saturation part, which means that there can be no witnesses to rules RP1 and RP2. Then, in lines 22\u201338 the algorithm performs what is called \u2018successor creation\u2019. First (line 22), it tests whether there is a successor to be created, i.e., if there is a witness \u03bb to R[\u03b1] or R\u3008\u03b1\u3009. It creates the successor (line 23) and then marks the witness as \u2018non-applicable\u2019 (line 24). After that (lines 25\u201334), it propagates the suitable formulas to the successor, as follows: assume that the witness is \u03bb = \u3008\u03c3, [\u03b1]\u03c8\u3009. Then, for every labelled formula \u3008\u03c3, [\u03b1]\u03c8\u2032\u3009 and \u3008\u03c3, \u3008\u03b1\u3009\u03c8\u2032\u3009 there must be a labelled formula \u3008\u03c3\u03b1, \u03c8\u2032\u3009 in the successor. This is done in lines 25\u201329. And also, every labelled formula \u3008\u03c3, p\u3009 (resp. \u3008\u03c3,\u00acp\u3009) must be propagated, i.e., there must be a labelled formula \u3008\u03c3\u03b1, p\u3009 (resp. \u3008\u03c3\u03b1,\u00acp\u3009) in the successor b1. This is done in lines 30\u201334. The last part (lines 35\u2013 37) makes a recursive call to mcTableau with the b1. The current branch is considered satisfiable if all recursive calls return true.\nThis algorithm has two important features. First, its successor creation part guarantees that each time mcTableau is called with branch b as argument, all the labelled formulas in b have the same label. Second, the first feature implies that the list of successors created during successive recursive calls of mcTableau corresponds to one execution trace from input formula \u03d50. These are the key arguments used in the proof of complexity result below.\nTheorem 3 (Termination). The algorithm in Table 7 halts for every input (V, \u03d50).\nTheorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is a polynomial function of the length of the input (V, \u03d50).\nTherefore, the algorithm in Table 7 works in space polynomial in the length of the input. This is an optimal algorithm, given that the satisfiability problem in star-free DL-PA is PSPACE-complete [10]."}, {"heading": "5 A Tableaux Method for Full DL-PA", "text": "In this section, we define an extension of the tableaux method that also takes into account the Kleene star operator.\nDefinition 5 (Tableau). Let (V, \u03d50) be the input under concern (thus, the initial tableau is the same as in Definition 1). The tableau rules for full DL-PA are those of Definition 1 plus the following ones:\n(R[\u2217]) \u3008\u03c3, [\u03c0\u2217]\u03d5\u3009 \u2208 b implies k = 1 and b1 = {\u3008\u03c3, \u03d5\u3009, \u3008\u03c3, [\u03c0][\u03c0\u2217]\u03d5\u3009}. (R\u3008\u2217\u3009) \u3008\u03c3,\u00ac[\u03c0\u2217]\u03d5\u3009 \u2208 b implies k = 2, b1 = {\u3008\u03c3,\u00ac\u03d5\u3009} and b2 = {\u3008\u03c3, \u03d5\u3009, \u3008\u03c3,\u00ac[\u03c0][\u03c0\u2217]\u03d5\u3009}.\nThe two rules above reflect the fix point property of Proposition 1.7. For instance, if the model V\u03c3 |= [\u03c0\u2217]\u03d5 then V\u03c3 |= \u03d5 and also V\u03c3 |= [\u03c0][\u03c0\u2217]\u03d5.\nDefinition 6 (Fulfillment). An eventuality \u3008\u03c3,\u00ac[\u03c0\u2217]\u03d5\u3009) is fulfilled in a tableau branch b if and only if there is a (possibly empty) execution trace \u03c3\u2032 \u2208 exe(\u03c0) such that \u3008\u03c3\u03c3\u2032,\u00ac\u03d5\u3009 \u2208 b.\nDefinition 7 (Closed Branch). A branch b is closed if and only if (1) b is blatantly inconsistent or (2) b is saturated and contains an unfulfilled eventuality.\nExample 3. Table 8 shows how the method can be used to prove that model V = {p, q} does not satisfy the formula \u03d50 = \u00ac[(+p\u222a\u2212p)\u2217]q. The leftmost branch is closed because it is blatantly inconsistent. In the branch of the middle, the same pattern will be repeated indefinitely. Thus, it is an infinite brunch, but it is saturated. Since the eventuality in line 3 is not fulfilled, it is also closed. The right-most branch is analogous to the one in the middle.\nIf the input formula contains a sub-formula of the form \u00ac[\u03c0\u2217]\u03d5, the method invariably creates tableaux with infinite branches that repeat the same pattern over and over again, as in Example 3. The repetition can be detected and it is possible to provide a terminating algorithm. This is presented in Section 6. Here, we show the correctness of the method presented so far.\nLemma 4 (Consistency Preservation). For each tableau rule \u03c1, if branch b is consistent, then the set of branches B generated by the application of \u03c1 to b contains a consistent branch.\nTheorem 5 (Soundness). If V |= \u03d50 then there is no closed tableau for (V, \u03d50).\nTheorem 6 (Completeness). If there is no closed tableau for (V, \u03d50) then V |= \u03d50."}, {"heading": "6 An EXPTIME Procedure for Full DL-PA", "text": "In this section, we define a procedure to model check formulas in L. As before, we define an algorithm. Here, it must detect the aforementioned repetitions of the applications of R\u3008\u2217\u3009 in the tableau. This is done by performing equality tests. A label \u03c31 is said to be equal to a label \u03c32 if and only if the set of formulas labelled by \u03c31 and \u03c32 are the same. More formally we have:\nDefinition 8 (Equality). Let \u03c31 and \u03c32 be two labels in the tableau T . Label \u03c31 is equal to label \u03c32 (noted \u03c31 = \u03c32) if and only if there are two branches b1, b2 \u2208 T such that {\u03d5 : \u3008\u03c31, \u03d5\u3009 \u2208 b1} = {\u03d5 : \u3008\u03c32, \u03d5\u3009 \u2208 b2}.\nAn equality test between labels can prevent the tableau to enter in an infinite loop. Then one can try to provide an algorithm that is similar to the one in Section 4, by first adding rules R[\u2217] and R\u3008\u2217\u3009 in their suitable places and the equality test just before the exploration of a new successor. Such an algorithm works, but is not optimal. For instance, the application of the method to the formula [(+p1\u222a\u2212p1\u222a\u00b7 \u00b7 \u00b7\u222a+pn\u222a\u2212pn)\u2217]p creates 2n different successors from a single tableau branch. Then such a method may explore a tree whose the number of nodes is bounded by 22\nlen(\u03d50) . However, satisfiability in DL-PA is proven to be in EXPTIME.\nA different technique than that in Section 4 must be employed in order to obtain a more efficient method for full DL-PA. Such a technique is implemented in the algorithm of Table 9. It is somewhat similar to the algorithm in Section 4, but there are some important differences. The most important ones are the addition of the equality test in lines 17\u201319 and the fact that this algorithm now maintains the entire tableau T in memory. It does not uses a recursive function anymore, for it now uses the tableau T as the search tree. Once the initial tableau for (V, \u03d50) is created in line 4, it enters a loop that finishes when T is closed or saturated (recall that a branch is also considered to be closed if it is saturated and contains an unfulfilled eventuality). As before, there is a \u2018local saturation\u2019 part (lines 9\u201316) and a \u2018successor creation\u2019 part (lines 20\u201333). In lines 36\u201340, the algorithm tests whether T is still open to return the right answer.\nTheorem 7 (Termination). The algorithm in Table 9 halts for every input (V, \u03d50).\nTheorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an exponential function of the length of the input (V, \u03d50).\nThus, the algorithm in Table 9 works in time exponential on len(\u03d50). This is as expected, given that the model checking problem in full DL-PA is in EXPTIME [10]."}, {"heading": "7 Discussion and Conclusion", "text": "In this paper, we have defined a linear reduction of satisfiability checking into model checking in DL-PA. We also define analytic tableaux methods for model checking formulas in the star-free fragment and in full DL-PA. The complexity of these methods match the complexity class of their respective problems. In the sequel, we compare such methods to similar approaches and discuss possible improvements and extensions.\nComparisons. The methods presented in this paper have been inspired by others already proposed in the literature. For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star. As already mentioned, the naive strategy would generate tableau branches with size exponential in the length of the input formula. The idea of keeping the tree in memory and perform equality tests comes from that work.\nAssignments of Propositional Variables to Formulas. DL-PA can be extended with assignments \u03b1 to formulas in L, instead of the simpler {\u22a4,\u22a5}. The corresponding tableau rule R[\u03b1] would be as follows:\n\u03c3 : [\u03b1]\u03d5 \u03c3 : \u03c81 \u03c3 : \u03c82 ... \u03c3 : \u03c8n \u03c3\u03b1 : p1 \u03c3\u03b1 : p2 ... \u03c3\u03b1 : pn \u03c3\u03b1 : \u03d5 \u03c3 : \u00ac\u03c81 \u03c3 : \u03c82 ... \u03c3\u03b1 : \u03c8n \u03c3\u03b1 : \u00acp1 \u03c3\u03b1 : p2 ... \u03c3\u03b1 : pn \u03c3\u03b1 : \u03d5 . . . \u03c3 : \u00ac\u03c81 \u03c3 : \u00ac\u03c82 ... \u03c3 : \u00ac\u03c8n \u03c3\u03b1 : \u00acp1 \u03c3\u03b1 : \u00acp2 ... \u03c3\u03b1 : \u00acpn \u03c3\u03b1 : \u03d5\nwhere we assume that the domain of \u03b1 is {p1, . . . , pn} and let \u03b1(pi) = \u03c8i. In spite of the apparent complexity of this tableau rule, we believe that the complexity of the method is not affected in the star-free fragment. For the full language, we have to include a cut rule that ranges over all sub-formulas of the input formula \u03d50. The reason is to permit the equality test to work also with all formulas \u03c8i that are included in the tableau when the new rule R[\u03b1] is applied. Again, we believe that the complexity remains the same.\nOther PDL Connectives. The integration of converse, complement, intersection and other PDL program connectives is also on our agenda. For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse. In this case though, it is not clear whether complexity (or even decidability) results remain the same. This is subject of future work."}, {"heading": "A Rules in Numerator-Denominator Form", "text": "For the comfort of the reader we present here the tableau rules in the more traditional numerator-denominator form."}, {"heading": "B Proofs", "text": "Lemma 3 (Consistency Preservation). For each tableau rule \u03c1, if branch b is consistent, then the set of branches B generated by the application of \u03c1 to b contains a consistent branch.\nProof. The proofs for the rules R\u00ac, R\u2227 and R\u2228 are easy and left to the reader. For rule R[\u03b1], note that, because b is consistent, we have V\u03c3 |= [\u03b1]\u03d5. Then V\u03c3\u03b1 |= \u03d5 by the truth condition for [\u03b1]. Moreover, by the definition of updates we have:\n\u2013 V\u03c3\u03b1 |= p for all p \u2208 dom(\u03b1) such that \u03b1(p) = \u22a4, and\n\u2013 V\u03c3\u03b1 |= \u00acp for all p \u2208 dom(\u03b1) such that \u03b1(p) = \u22a5.\nFor the remaining tableau rules, namely R\u3008\u03b1\u3009, R[;], R\u3008;\u3009, R[\u222a], and R\u3008\u222a\u3009, RP1 and RP2, the reasoning is similar and left to the reader. \u2293\u2294\nTheorem 1 (Soundness). If V |= \u03d50 then there is no closed tableau for (V, \u03d50).\nProof. Assume that V |= \u03d50. Then the initial tableau for (V, \u03d50) is consistent. It follows from Lemma 3 that all tableaux for \u03d50 have at least one consistent branch b. Now, towards a contradiction, assume that b is closed. Then b contains both \u3008\u03c3, \u03c8\u3009 and \u3008\u03c3,\u00ac\u03c8\u3009, for some \u03c3 and \u03c8. However, since b is consistent, V\u03c3 |= \u03c8 and V\u03c3 |= \u00ac\u03c8, which is a contradiction. Therefore, b is not closed neither is the tableau containing it. \u2293\u2294\nTheorem 2 (Completeness). If there is no closed tableau for (V, \u03d50) then V |= \u03d50.\nProof. Suppose there is no closed tableau for (V, \u03d50). Let b be an open and saturated branch of a tableau for (V, \u03d50). We prove that, for every pair \u3008\u03c3, \u03c8\u3009 \u2208 b, we have V\u03c3 |= \u03c8. The proof is done by induction on len(\u03c3) + len(\u03c8) and, in particular, establishes that V |= \u03d50, since \u3008(), \u03d50\u3009 \u2208 b.\nInduction base: We consider two cases:\n\u2013 Let \u03c3 = () and \u03c8 = p \u2208 P. Then V |= p, otherwise b would be closed since b0 \u2286 b. \u2013 Let \u03c3 = () and \u03c8 = \u00acp. Then V |= \u00acp, otherwise b would be closed since b0 \u2286 b.\nInduction Hypothesis: For every \u3008\u03c3, \u03c8\u3009 \u2208 b, if len(\u03c3) + len(\u03c8) \u2264 n, then V\u03c3 |= \u03c8.\nInduction step: Let len(\u03c3)+ len(\u03c8) = n+1. We only give some of all possible cases:\n\u2013 Let \u03c3 = \u03c31\u03b1 and \u03c8 = p \u2208 P. We consider two sub-cases: \u2022 Let p < dom(\u03b1). We have \u3008\u03c31,\u00acp\u3009 < b, otherwise b would be closed, because\nit is saturated under RP2. Then we have \u3008\u03c31, p\u3009 \u2208 b, because the branch is saturated under RP1 and b0 \u2286 b. By induction hypothesis, we have V\u03c31 |= p. Since p < dom(\u03b1), we also have V\u03c31\u03b1 |= p. \u2022 Let p \u2208 dom(\u03b1). We then must have \u03b1(p) = \u22a4: otherwise b would not only contain \u3008\u03c31\u03b1, p\u3009, but also \u3008\u03c31\u03b1,\u00acp\u3009 (by the application of rule R[\u03b1]) and b would therefore be closed. Hence, by the definition of updates p \u2208 V\u03c31\u03b1. The latter means that V\u03c31\u03b1 |= p. \u2013 Let \u03c3 = \u03c31\u03b1 and \u03c8 = \u00acp. Again, we consider two sub-cases: \u2022 Let p < dom(\u03b1). We have \u3008\u03c31, p\u3009 < b: otherwise, b would be closed, since\nit is saturated under RP1. Then we have \u3008\u03c31,\u00acp\u3009 \u2208 b, because the branch is saturated under RP2 and b0 \u2208 b. Then p < V\u03c31 (by the induction hypothesis) and thus p < V\u03c31\u03b1. Then V\u03c31\u03b1 |= \u00acp. \u2022 Let p \u2208 dom(\u03b1). Note that we have \u03b1(p) = \u22a5: otherwise b would be closed, because it would contain \u3008\u03c31\u03b1, p\u3009 and \u3008\u03c31\u03b1,\u00acp\u3009, since it is saturated under R[\u03b1]. Then p < V\u03c31\u03b1 (by its definition) Then V\u03c31\u03b1 |= \u00acp. \u2013 Let \u03c8 = \u00ac\u00ac\u03c81. If \u3008\u03c3,\u00ac\u00ac\u03c81\u3009 \u2208 b then \u3008\u03c3, \u03c81\u3009 \u2208 b (because b is saturated under R\u00ac). By Induction Hypothesis we have V\u03c3 |= \u03c81. Therefore V\u03c3 |= \u00ac\u00ac\u03c81 by the truth condition for negation.\n\u2013 Let \u03c8 = \u03c81 \u2227\u03c82. If \u3008\u03c3, \u03c81 \u2227\u03c82\u3009 \u2208 b then \u3008\u03c3, \u03c81\u3009, \u3008\u03c3, \u03c82\u3009 \u2208 b (because b is saturated under R\u2227). By Induction Hypothesis we have V\u03c3 |= \u03c81 and V\u03c3 |= \u03c82. Therefore V\u03c3 |= \u03c81 \u2227 \u03c82 by the truth condition for conjunction. \u2013 Let \u03c8 = \u00ac(\u03c81 \u2227 \u03c82). If \u3008\u03c3,\u00ac(\u03c81 \u2227 \u03c82)\u3009 \u2208 b then \u3008\u03c3,\u00ac\u03c81\u3009 \u2208 b or \u3008\u03c3,\u00ac\u03c82\u3009 \u2208 b (because b is saturated under R\u2228). By Induction Hypothesis we have V\u03c3 |= \u00ac\u03c81 or V\u03c3 |= \u00ac\u03c82. Therefore V\u03c3 |= \u00ac(\u03c81 \u2227 \u03c82) by the truth conditions for negation and conjunction. \u2013 Let \u03c8 = [\u03b1]\u03c81. If \u3008\u03c3, [\u03b1]\u03c81\u3009 \u2208 b then \u3008\u03c3\u03b1, \u03c81\u3009 \u2208 b (because b is saturated under R[\u03b1]). Then, V\u03c3\u03b1 |= \u03c81 (by Induction Hypothesis, because len(\u03c3) + len(\u03b1) + len(\u03c81) < len(\u03c3)+len([\u03b1]\u03c81) = len(\u03c3)+1+len(\u03b1)+len(\u03c81)). Therefore, V\u03c3 |= [\u03b1]\u03c81 (by definition). \u2013 Let \u03c8 = [\u03c81?]\u03c82. If \u3008\u03c3, [\u03c81?]\u03c82\u3009 \u2208 b then, because b is saturated under rule R[?], we consider two sub-cases. Either (1) \u3008\u03c3,\u00ac\u03c81\u3009 \u2208 b or (2) \u3008\u03c3, \u03c82\u3009 \u2208 b. In both subcases, we have V\u03c3 |= \u03c81 implies V\u03c3 |= \u03c82 (by Induction Hypothesis). Therefore, V\u03c3 |= [\u03c82?]\u03c82 (by definition). \u2013 Let \u03c8 = [\u03c01; \u03c02]\u03c81. If \u3008\u03c3, [\u03c01; \u03c02]\u03c81\u3009 \u2208 b then \u3008\u03c3, [\u03c01][\u03c02]\u03c82\u3009 \u2208 b (because b is saturated under rule R[;]). Then it is easy to see that \u3008\u03c3\u03c31, [\u03c02]\u03c81\u3009 \u2208 b, for all execution traces \u03c31 \u2208 exe(\u03c01) Then V\u03c3\u03c31 |= [\u03c02]\u03c81 (by Induction Hypothesis, since len(\u03c3) + len(\u03c31) + 1 + len(\u03c02) + len(\u03c81) = len(\u03c3\u03c31) + len([\u03c02]\u03c81) < len(\u03c3) + len([\u03c01; \u03c02]\u03c81) = len(\u03c3)+ 1+ len(\u03c01)+ 1+ len(\u03c02)+ len(\u03c81)). The latter means that V\u03c3 |= [\u03c01; \u03c02]\u03c81. \u2013 Let \u03c8 = [\u03c01\u222a\u03c02]\u03c81. If \u3008\u03c3, [\u03c01\u222a\u03c02]\u03c81\u3009 \u2208 b then \u3008\u03c3, [\u03c01]\u03c81\u3009, \u3008\u03c3, [\u03c02]\u03c81\u3009 \u2208 b (because b is saturated under rule R[\u222a]). Then, V\u03c3 |= [\u03c01]\u03c81 and V\u03c3 |= [\u03c02]\u03c81 (by Induction Hypothesis). Therefore, V\u03c3 |= [\u03c01 \u222a \u03c02]\u03c81 (by definition). \u2013 The cases where \u03c8 = \u00ac[\u03c0]\u03c81 are analogous to the last ones. \u2293\u2294\nTheorem 3 (Termination). The algorithm in Table 7 halts for every input (V, \u03d50).\nProof. It is enough to show that function mcTableau is eventually called with an argument b which is either a closed or a saturated branch. Assume that, during the execution, branch b is passed as argument to a call of function mcTableau. Assume that b contains a witness \u03bb to one of the tableau rules. Then the function will be called recursively with a new branch b1 wherein \u03bb is marked \u2018non-applicable\u2019, so it will never be a witness again. Moreover, b1 differs from b by some additional labelled formulas that are shorter than \u03bb. Therefore, by an easy induction on the length of labelled formulas, we show that function mcTableau will eventually generate a branch b1 which is either closed or saturated. The details are omitted. \u2293\u2294\nTheorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is a polynomial function of the length of the input (V, \u03d50).\nProof. Each call of function mcTableau generates a new tableau branch. This branch remains in memory during the recursive calls and is released once the present call of the function finishes its execution returning true or false. Therefore, to prove our claim, it is enough to show that the amount of memory used by each tableau branch is a polynomial function of len(\u03d50) and that the number of successive recursive calls to mcTableau is a polynomial function of len(\u03d50) as well.\nFirst, we observe that the initial branch b0 contains only formulas from cl+(\u03d50). Second, each time mcTableau is called with branch b as argument, all the labelled formulas in b have the same label. Since the amount of memory used by a branch is bounded by the number of different labelled formulas it contains, it then follows from Lemma 1 that the number of different labelled formulas in b is bounded by 2 len(\u03d50).\nThird, the number of successive recursive calls during the local saturation of the tableau is bounded by the number of different labelled formulas a successor may contain. This number is 2 len(\u03d50), again by Lemma 1. Now, recall that the list of successors created by the algorithm during successive recursive calls of mcTableau corresponds to one execution trace from input formula \u03d50. The length of each execution trace is bounded by len(\u03d50), by Lemma 2. Then the number of successive recursive calls that create new successors is bounded by len(\u03d50). Finally, the total number of successive recursive calls to mcTableau is bounded by 2 len(\u03d50)2.\nWe then conclude that the amount of memory used by the algorithm is proportional to 4 len(\u03d50)3. \u2293\u2294\nLemma 4 (Satisfiability Preservation). For each tableau rule \u03c1, if branch b is consistent, then the set of branches B generated by the application of \u03c1 to b contains a consistent branch.\nProof. For the rules that are already part of in the method for star-free DL-PA the proof is the same as in the proof of Lemma 3. For the other cases, we have:\n\u2013 Rule R[\u2217]: If V\u03c3 |= [\u03c0\u2217]\u03d5 then, by Proposition 1, V\u03c3 |= \u03d5 and V\u03c3 |= [\u03c0][\u03c0\u2217]\u03d5. \u2013 Rule R\u3008\u2217\u3009: If V\u03c3 |= \u00ac[\u03c0\u2217]\u03d5 then V\u03c3 6|= [\u03c0\u2217]\u03d5, and the latter is the case iff V\u03c3 |= \u00ac\u03d5\nor V\u03c3 |= \u00ac[\u03c0][\u03c0\u2217]\u03d5, again due to Proposition 1. \u2293\u2294\nTheorem 5 (Soundness). If V |= \u03d50 then there is no closed tableau for (V, \u03d50).\nProof. Assume that V |= \u03d50. Then, the initial tableau for (V, \u03d50) is consistent. It follows from Lemma 4 that all tableaux for (V, \u03d50) have at least one consistent branch b. Now, towards a contradiction, assume that b is closed. Then, either (1) b contains both \u3008\u03c3, \u03d5\u3009 and \u3008\u03c3,\u00ac\u03d5\u3009, for some \u03c3 and \u03d5; or (2) b is saturated and contains an unfulfilled eventuality \u3008\u03c3,\u00ac[\u03c0\u2217]\u03d5\u3009. In the first case, (because b is consistent) V\u03c3 |= \u03d5 and V\u03c3 |= \u00ac\u03d5, which is a contradiction. In the second case, (again because b is consistent) V\u03c3 |= \u00ac[\u03c0\u2217]\u03d5. Moreover, b contains \u3008\u03c3\u03c3\u2032, \u03d5\u3009, for all execution traces \u03c3\u2032 \u2208 exe(\u03c0\u2217), by the saturation of R\u3008\u2217\u3009 and because the eventuality is not fulfilled. Then, V\u03c3\u03c3 \u2032\n|= \u03d5, for all execution traces \u03c3\u2032 \u2208 exe(\u03c0\u2217) (because the branch is consistent). Then, V\u03c3 |= [\u03c0n]\u03d5, for all n \u2265 0. The latter implies V\u03c3 |= [\u03c0\u2217]\u03d5, which contradicts the hypothesis. So b is not closed, and therefore the tableau containing b cannot be closed. \u2293\u2294\nTheorem 6 (Completeness). If there is no closed tableau for (V, \u03d50) then V |= \u03d50.\nProof. The proof is essentially the same as for Theorem 2. We only add the induction step case for the Kleene star operator here:\n- Let \u03c8 = [\u03c0\u2217]\u03c81. If \u3008\u03c3, [\u03c0\u2217]\u03c81\u3009 \u2208 b then \u3008\u03c3\u03c3\u2032, \u03c81\u3009 \u2208 b, for all execution traces \u03c3\u2032 \u2208 exe(\u03c0\u2217) (because b is saturated, in particular, under rule R[\u2217]). Then, V\u03c3\u03c3 \u2032\n|= \u03c8, for all execution traces \u03c3\u2032 \u2208 exe(\u03c0\u2217) (by Induction Hypothesis), iff V\u03c3 |= [\u03c0n]\u03c8, for all n \u2208 N0, iff V\u03c3 |= [\u03c0\u2217]\u03c8.\nFor the case where \u03c8 = \u00ac[\u03c0\u2217]\u03c8 we use the fact that the branch b is not closed, which means that the eventuality is fulfilled in b, by definition. \u2293\u2294\nTheorem 7 (Termination). The algorithm in Table 9 halts for every input (V, \u03d50).\nProof. It is enough to show that the algorithm eventually generates a tableau such that all its branches are either closed or saturated. The algorithm has two parts: local saturation and successor creation.\nFirst, assume that the latest generated tableau T contains an open and unsaturated branch b with a witness \u03bb to one of the tableau rules of the local saturation part. Then the algorithm updates T by marking \u03bb as \u2018non-applicable\u2019, so it will never be a witness again. Moreover, the new branches of the updated tableau T differ from the old ones by somme additional labelled formulas that are either shorter than \u03bb or (in the case of rules R[\u2217] and R\u3008\u2217\u3009) that can no longer be witnesses to these rules any more. Therefore, by an easy induction on the length of labelled formulas, we show that the algorithm will eventually generate a tableau such that all its branches are either closed or saturated for these rules. The details are omitted.\nSecond, assume that the latest generated tableau T contains an open and unsaturated branch b with a witness \u03bb to one of the tableau rules R[\u03b1] and R\u3008\u03b1\u3009. Then it marks \u03bb as \u2018non-applicable\u2019 and the updated T contains new branches with somme additional labelled formulas \u3008\u03c3, \u03c8\u3009, where \u03c3 is a new label and \u03c8 \u2208 cl+(\u03d50). Since cl+(\u03d50) is finite, there cannot be an infinite number of different labelled formulas whose labels different from another label of the tableau. Thus, the equality test will eventually succeeds and new successors won\u2019t be created indefinitely. \u2293\u2294\nTheorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an exponential function of the length of the input (V, \u03d50).\nProof. The amount of time used by the algorithm in Table 9 is bounded by the number of rule applications during the execution and the time spent on the equality tests.\nFirst, for each successor, the local saturation part performs at most 2 len(\u03d50) rule applications, because it is the maximum size of cl+(\u03d50) (by Lemma 1). Second, there can be at most 22 len(\u03d50) different labels in the entire tableau T , because it is the maximum size of P(cl+(\u03d50)). Then the successor creation part can generate at most 22 len(\u03d50) different labels until the equality test succeeds. Moreover, the equality test itself takes time proportional to 22 len(\u03d50), by the same reasons.\nOverall, the amount of time used by the algorithm is bounded by 2 len(\u03d50)\u00d722 len(\u03d50)\u00d7 22 len(\u03d50) equals to 24 len(\u03d50)+1 len(\u03d50), which is an exponential function of the length of the input formula \u03d50. \u2293\u2294"}], "references": [{"title": "An on-the-fly tableau-based decision procedure for PDL-satisfiability", "author": ["Pietro Abate", "Rajeev Gor\u00e9", "Florian Widmann"], "venue": "Electr. Notes Theor. Comput. Sci.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Dynamic logic of propositional assignments: a well-behaved variant of PDL", "author": ["Philippe Balbiani", "Andreas Herzig", "Nicolas Troquard"], "venue": "In Orna Kupferman, editor, Logic in Computer Science (LICS),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Combining deduction and model checking into tableaux and algorithms for converse-PDL", "author": ["Giuseppe De Giacomo", "Fabio Massacci"], "venue": "Information and Computation,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2000}, {"title": "A dynamic logic framework for abstract argumentation", "author": ["Sylvie Doutre", "Andreas Herzig", "Laurent Perrussel"], "venue": "Proc. KR", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Propositional dynamic logic of regular programs", "author": ["Michael J. Fischer", "Richard E. Ladner"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1979}, {"title": "Optimal and cut-free tableaux for propositional dynamic logic with converse", "author": ["Rajeev Gor\u00e9", "Florian Widmann"], "venue": "In Automated Reasoning,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "Belief change operations: a short history of nearly everything, told in dynamic logic of propositional assignments", "author": ["Andreas Herzig"], "venue": "In Chitta Baral and Giuseppe De Giacomo,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "A dynamic logic of normative systems", "author": ["Andreas Herzig", "Emiliano Lorini", "Fr\u00e9d\u00e9ric Moisan", "Nicolas Troquard"], "venue": "editor, International Joint Conference on Artificial Intelligence (IJCAI), Barcelona,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Belief merging in Dynamic Logic of Propositional Assignments", "author": ["Andreas Herzig", "Pilar Pozos Parra", "Fran\u00e7ois Schwarzentruber"], "venue": "editors, International Symposium on Foundations of Information and Knowledge Systems (FoIKS) (FolKS), Bordeaux. Springer,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2014}, {"title": "A comparison of solvers for propositional dynamic logic", "author": ["Ullrich Hustadt", "Renate A. Schmidt"], "venue": "EPiC Series,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}], "referenceMentions": [{"referenceID": 7, "context": "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7].", "startOffset": 92, "endOffset": 98}, {"referenceID": 1, "context": "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7].", "startOffset": 92, "endOffset": 98}, {"referenceID": 7, "context": "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].", "startOffset": 135, "endOffset": 139}, {"referenceID": 8, "context": "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].", "startOffset": 158, "endOffset": 162}, {"referenceID": 6, "context": "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].", "startOffset": 194, "endOffset": 197}, {"referenceID": 3, "context": "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].", "startOffset": 244, "endOffset": 247}, {"referenceID": 4, "context": "This is almost the same as the Fisher-Ladner closure [5], which is used to show decidability and complexity results for PDL.", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "4 We note that the original language in [2] is slightly more restrictive: \u03b1 only assigns a single propositional variable.", "startOffset": 40, "endOffset": 43}, {"referenceID": 7, "context": "Proposition 1 ([10]).", "startOffset": 15, "endOffset": 19}, {"referenceID": 1, "context": "In [2], it is also shown that the Kleene star can be eliminated in DL-PA, i.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "Satisfiability checking in DL-PA is shown to be in EXPTIME in [2].", "startOffset": 62, "endOffset": 65}, {"referenceID": 1, "context": "Proposition 2 ([2]).", "startOffset": 15, "endOffset": 18}, {"referenceID": 1, "context": "Proposition 4 ([2]).", "startOffset": 15, "endOffset": 18}, {"referenceID": 7, "context": "This is an optimal algorithm, given that the satisfiability problem in star-free DL-PA is PSPACE-complete [10].", "startOffset": 106, "endOffset": 110}, {"referenceID": 7, "context": "This is as expected, given that the model checking problem in full DL-PA is in EXPTIME [10].", "startOffset": 87, "endOffset": 91}, {"referenceID": 2, "context": "For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star.", "startOffset": 38, "endOffset": 41}, {"referenceID": 9, "context": "For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star.", "startOffset": 52, "endOffset": 56}, {"referenceID": 5, "context": "For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse.", "startOffset": 77, "endOffset": 85}, {"referenceID": 0, "context": "For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse.", "startOffset": 77, "endOffset": 85}], "year": 2014, "abstractText": "The Dynamic Logic for Propositional Assignments (DL-PA) has recently been studied as an alternative to Propositional Dynamic Logic (PDL). In DL-PA, the abstract atomic programs of PDL are replaced by assignments of propositional variables to truth values. This makes DL-PA enjoy some interesting meta-logical properties that PDL does not, such as eliminability of the Kleene star, compactness and interpolation. We define and analytic tableaux calculus for DL-PA and show that it matches the known complexity results.", "creator": "LaTeX with hyperref package"}}}