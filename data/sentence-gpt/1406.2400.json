{"id": "1406.2400", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jun-2014", "title": "Controlled Natural Language Generation from a Multilingual FrameNet-based Grammar", "abstract": "This paper presents a currently bilingual but potentially multilingual FrameNet-based grammar library implemented in Grammatical Framework. The contribution of this paper is two-fold. First, it offers a methodological approach to automatically generate the grammar based on semantico-syntactic valence patterns extracted from FrameNet-annotated corpora. Secondly, it focuses on the use of a variety of linguistic tools in a language that differs from other languages. In order to demonstrate the utility of such a framework, we consider a particular subset of the lexical syntax used in a grammar parser to generate a lexical syntactic structure (i.e. lexical order for a grammar parser) and to construct and construct structures that allow the expression of a block of code (i.e. blocks of code, such as the argument \u202a) that is used to express the structure of the text. These constructors are known as the \u202a\u2013\u202a, and have various advantages over conventional grammar systems. In order to identify and support specific grammatical patterns, we describe a new, hierarchical structure based on the construction of a block of code to ensure that it meets the requirements of the grammar grammar language and also provides an additional set of criteria that determine the grammar grammar. In addition to the syntax and grammar structure of Grammatical Framework, we apply the new syntax to the language in which each element of the grammar is generated. By generating a lexical structure of this structure, we have been able to construct a grammar parser using the following language:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Tue, 10 Jun 2014 01:01:48 GMT  (28kb)", "http://arxiv.org/abs/1406.2400v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["dana dann\\'ells", "normunds gr\\=uz\\=itis"], "accepted": false, "id": "1406.2400"}, "pdf": {"name": "1406.2400.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["dana.dannells@svenska.gu.se,", "normunds.gruzitis@cse.gu.se"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 6.\n24 00\nv1 [\ncs .C\nL ]\n1 0\nJu n\nKeywords: Controlled Natural Language, FrameNet, Natural Language Generation, Multilinguality, Grammatical Framework"}, {"heading": "1 Introduction", "text": "Two years ago, at CNL 2012, a conception of a general-purpose semantic grammar based on FrameNet (FN) was proposed [1] to facilitate the development of multilingual controlled natural language (CNL) applications in Grammatical Framework (GF). GF [2], a type-theoretical grammar formalism and a toolkit, provides a wide-coverage resource grammar library (RGL) for nearly 30 languages that implement a shared syntactic API [3]. The idea behind the FN-based grammar is to provide a frame semantic abstraction layer, a shared semantic API, over the syntactic RGL.\nFollowing this proposal, a shared abstract syntax of wide-coverage English and Swedish semantic grammars has been recently extracted from FN-annotated corpora [4]. In this work, we take this approach one step further, and the contribution of this paper is two-fold. First, we offer a methodological approach to automatically generate concrete syntaxes based on the extracted abstract syntax. Second, we provide a proof of concept for two use cases illustrating how the acquired multilingual grammar can be exploited in different CNL applications in the domains of arts and tourism. Although we focus on English and Swedish, the same approach is intended to be applicable to other languages as well.\nThe future potential of our work is to provide a means for multilingual verbalization of FN-annotated databases that have been populated in information extraction processes by FN-based semantic parsers and that potentially can be mapped with the FN-based API automatically [5].\n2"}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 FrameNet (FN)", "text": "FrameNet is a lexico-semantic resource based on the theory of frame semantics [6]. According to this theory, a semantic frame representing a cognitive scenario is characterized in terms of frame elements (FE) and is evoked by target words called lexical units (LU). An LU entry carries semantic and syntactic valence information about the possible realizations of FEs. The syntactic and semantic valence patterns are derived from FN-annotated corpora. FEs are classified in core and non-core FEs. A set of core FEs uniquely characterize the frame and syntactically correspond to verb arguments, in contrast to non-core FEs (adjuncts) which can be instantiated in many other frames. In this paper, we consider only those frames for which there is at least one corpus example where the frame is evoked by a verb. The frame-based grammar currently covers only core FEs.\nThe FrameNet approach provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing [7], information extraction [8] and natural language generation [9]. There are available computationally oriented FNs for German, Japanese, Spanish [10] and Swedish [11]. More initiatives exist for other languages. In this paper, we consider two FNs: the original Berkeley FrameNet (BFN) [6] and the Swedish FrameNet (SweFN) [11].\nBFN version 1.5 defines more than 1,000 frames,1 of which 556 are evoked by around 3,200 verb LUs in more than 68,500 annotated sentences [4]. Although BFN has been developed for English, its inventory of frames and FEs is being reused for many other FNs [10]. Hence, the abstract semantic layer of BFN can be seen as an interlingua for linking different FNs.\nSweFN mostly uses the BFN frame inventory, however, around 50 additional frames have been introduced in SweFN, and around 15 BFN frames have been modified (in terms of FEs). The SweFN development version contains more than 900 frames of which 638 are evoked by around 2,300 verb LUs in more than 3,700 annotated sentences [4].2"}, {"heading": "2.2 Grammatical Framework (GF)", "text": "The presented grammar is implemented in GF, a categorial grammar formalism specialized for multilingual (parallel) grammars [2]. One of the key features of GF grammars is the separation between an abstract syntax and concrete syntaxes. The abstract syntax defines the language-independent structure, the semantics of a domain-specific application grammar or a general-purpose grammar library, while the concrete syntaxes define the language-specific syntactic and lexical realization of the abstract syntax.\n1 https://framenet.icsi.berkeley.edu/ 2 http://spraakbanken.gu.se/swefn/ (a snapshot taken in February 2014)\n3 Remarkably, GF is not only a grammar formalism or programming language. It also provides a general-purpose resource grammar library (RGL) for nearly 30 languages that implement the same abstract syntax, a shared syntactic API [3]. The use of the shared syntactic types and functions allows for rapid and rather flexible development of multilingual application grammars without the need of specifying low-level details like inflectional paradigms and syntactic agreement."}, {"heading": "3 FrameNet-based Grammar", "text": "The language-independent conceptual layer of FrameNet, i.e. frames and FEs, is defined in the abstract syntax of the multilingual FN-based grammar, while the language-specific lexical layers, i.e. the surface realization of frames and LUs, are defined in concrete syntaxes.3 The syntactic API of RGL is used for generalizing and unifying the syntactic types and constructions used in different FNs, which facilitates porting the implementation to other languages. The FN-based grammar, in turn, provides a frame semantic abstraction layer to RGL, so that the application grammar developer can primarily manipulate with plain semantic constructors in combination with some simple syntactic constructors instead of comparatively complex syntactic constructors for building verb phrases (VP). Moreover, the frame constructors can be typically specified for all languages at once in the shared concrete syntax (functor) of an application grammar."}, {"heading": "3.1 Abstract Syntax", "text": "Following a recently proposed approach [4], we have extracted a set of shared semantico-syntactic frame valence patterns from the annotated sentences in BFN and SweFN. For instance, the shared valence patterns for the frame Desiring are:\nDesiring/VAct Experiencer/NPSubj Focal participant/Adv Desiring/V2Act Experiencer/NPSubj Focal participant/NPDObj Desiring/VVAct Event/VP Experiencer/NPSubj\nwhich correspond, for instance, to these annotated examples in BFN:4\n[Dexter ]Experiencer/NP [YEARNED ]V [for a cigarette]Focal participant/Adv [she]Experiencer/NP [WANTS ]V2 [a protector ]Focal participant/NP [I ]Experiencer/NP would n\u2019t [WANT ]VV [to know ]Event/VP\nIn contrast to the previous experiment [4], where the focus was on the abstract grammar, here we generate the concrete syntaxes taking the syntactic roles for FEs of type NP into account: subject (Subj), direct object (DObj) and indirect object (IObj). Thus, we also consider the grammatical voice (Act/Pass) in the pattern comparison, as well as the target verb type deduced from the syntactic types and roles of involved FEs. Additionally, we handle FEs of common\n3 http://www.grammaticalframework.org/framenet/ 4 The actual BFN phrase types are generalized by RGL types.\n4 types of subclauses (generalized to S, embedded sentences), as well as finite and gerundive VPs, and PPs where the preposition governs a wh-clause or a gerundive VP, so that the fraction of skipped BFN examples is reduced form 14% to 4%, and no SweFN examples are skipped.\nThe extracted sets of valence patterns usually vary across languages depending on corpora. For multilingual applications we are primarily interested in valence patterns whose implementation can be generated for all considered languages. Thus, we focus on valence patterns that are shared between FNs. The multilingual criteria also help in reducing the number of incorrect patterns due to annotation errors introduced by the automatic POS tagging and syntactic parsing. However, patterns that are not verified across FNs could be separated into FN-specific extra modules of the grammar.\nTo find a representative yet condensed set of shared valence patterns, we compare the extracted patterns by subsumption instead of exact match [4]. Pattern A subsumes pattern B if A.frame = B.frame, A.verbType = B.verbType, A.voice = B.voice, and B.FEs \u2286 A.FEs (taking into account the syntactic types and roles). If a pattern of FN1 is subsumed by a pattern of FN2, it is added to the shared set (and vice versa). In the final set, patterns which are subsumed by other shared patterns are removed. To reduce the propagation of annotation errors even more, we filter out once used BFN valence patterns before performing the cross-FN pattern comparison.5\nIn the result, from around 66,800 annotated sentences in BFN and around 4,100 annotated sentences in SweFN, we have extracted a set of 717 shared semantico-syntactic valence patterns covering 423 frames.\nFrame valence patterns are declared in the grammar as functions (henceforth called frame functions) that take one or more core FEs and one verb as arguments. For each frame, the set of core FEs is often split into several alternative functions according to the corpus evidence.6 Different subsets of core FEs may require different types of target verbs. We also differentiate between functions that return clauses in the passive voice from functions that return active voice clauses because the subject and object FEs swap their syntactic roles and/or the order (which otherwise is not reflected in the abstract syntax). If the verb type and voice suffixes are not sufficient to make the function name unique, a discriminative number is added as well. For instance, consider the following abstract functions derived from the above given valence patterns:7\nfun Desiring V : Experiencer NP \u2192 Focal participant Adv \u2192 V \u2192 Clause fun Desiring V2 Act : Experiencer NP \u2192 Focal participant NP \u2192 V2 \u2192 Clause fun Desiring V2 Pass : Experiencer NP \u2192 Focal participant NP \u2192 V2 \u2192 Clause fun Desiring VV : Event VP \u2192 Experiencer NP \u2192 VV \u2192 Clause\n5 A similar pre-filtering is currently not reasonable for SweFN due to its small size. 6 It is often unlikely that all core FEs can be used in the same sentence. 7 Note that Desiring V2 Pass is not directly acquired from a shared pattern; missing passive voice patterns could be derived from the corresponding active voice patterns. Also note that the syntactic roles are not reflected in the abstract syntax; they are used to generate the implementation of frame functions in the concrete syntaxes.\n5 In GF, constituents and features of phrases are stored in objects of record types, and functions are applied to such objects to construct phrase trees. In the abstract syntax, both argument types and the value type of a function are separated by right associative arrows, i.e. all functions are curried. Arguments of a frame function are combined into an object of type Clause that differs form the RGL type Cl. A Clause whose linearization type is {np : NP; vp : VP} comprises two constituents of RGL types. It is a deconstructed Cl where the subject NP is separated from the rest of the clause. The motivation for this is to allow for nested frames (see Section 4.1) and for adding non-core FEs before combining the NP and VP parts into a clause (see Section 4.2).\nIn the FN-based grammar, FEs are declared as semantic categories (types) that are subcategorized by RGL types, and these discriminators are also encoded by suffixes in FE names to keep the names unique, for instance:\ncat Experiencer NP\nNote that the FE Focal participant is typically realized as a noun phrase (NP), but some intransitive verbs require it as a prepositional phrase (PP), hence this FE is subcategorized using the RGL types NP and Adv (adverbial modifier). In GF, the type Adv covers both adverbs and PPs, and there is no separate type for PPs. Also note that the word order is not specified in the abstract syntax (FEs in the function type signatures are given alphabetically), and all FE arguments are specified in concrete syntaxes as optional, i.e. any FE can be an empty phrase if it is not expressed in the sentence.\nThe frame-evoking target verb, either intransitive (V), transitive (V2) or ditransitive (V3), is always given as the last, mandatory argument. We additionally differentiate two special cases of transitive verbs: verb-phrase-complement verbs (VV) and sentence-complement verbs (VS), as well as a special case for each of them allowing also for an indirect object (V2V and V2S respectively).\nLUs are represented as functions that take no arguments. To distinguish between different senses and types of LUs, the verb type and the frame name is added to lexical function names, for instance:\n(Eng) fun want VV Desiring : VV (Swe) fun vilja VV Desiring : VV\nHowever, LUs between BFN and SweFN are not directly aligned, therefore an FN-specific lexicon is generated for each language containing more than 3,300 entries for English and more than 1,100 entries for Swedish. The domain-specific translation equivalents can be aligned in application grammars.\nWe assume that verbs of the same type evoking the same frame share a set of generalized syntactic valence patterns. Patterns requiring, for instance, a transitive verb cannot be evoked by an intransitive verb. Otherwise, the current approach does not limit the set of verbs that can evoke a frame, and the set of prepositions that can be used for an FE if it is realized as a PP. We expect that appropriate verbs and prepositions are specified by the application grammar that uses the FN-based grammar as an API. Hence, this approach allows to evoke a frame by a metaphor, i.e. an LU that normally evokes another frame.\n6"}, {"heading": "3.2 Concrete Syntaxes", "text": "The exact behaviour of the types and functions declared in the abstract syntax is defined in the concrete syntax for each language.\nThe mapping from the semantic FN types to the syntactic RGL types is straightforward and is shared for all languages in a functor, for instance:\nlincat Focal participant NP = Maybe NP lincat Focal participant Adv = Maybe Adv\nTo allow for optional FEs (verb arguments that might not be expressed in the sentence), all linearization types are of type Maybe whose behaviour is similar to the analogous type in Haskell: a value of type Maybe x either contains a value of type x (represented as Just x ), or it is empty (represented as Nothing).\nTo implement the frame functions, particularly to fill the VP part of Clause objects, RGL constructors are applied to the arguments depending on their RGL types and syntactic roles. The implementation of functions declared in the previous section is systematically generated for English and Swedish as follows:\nlin Desiring V experiencer focal participant v = { np = fromMaybe NP experiencer ; vp = mkVP (mkVP v) (fromMaybe Adv focal participant) }\nlin Desiring V2 Act experiencer focal participant v2 = { np = fromMaybe NP experiencer ; vp = mkVP v2 (fromMaybe NP focal participant) }\nlin Desiring V2 Pass experiencer focal participant v2 = { np = fromMaybe NP focal participant ; vp =mkVP (passiveVP v2) (mkAdv by8agent Prep (fromMaybe NP experiencer)) }\nlin Desiring VV event experiencer vv = { np = fromMaybe NP experiencer ; vp = mkVP (mkVV vv) (fromMaybe VP event) }\nApart from RGL constructors (mkVP, mkVV, passiveVP, mkAdv, etc.8), a helper function fromMaybe is used to handle the potentially optional FEs. This function takes a Maybe value and returns an empty phrase of the specified type if the Maybe value is empty (Nothing); otherwise it returns the Maybe value.\nThe RGL-based code templates used to implement the above functions can be reused for many other frame functions. Given the 717 extracted shared semantico-syntactic valence patterns, there are only 25 syntactic valence patterns that match all 717 patterns if we consider only the syntactic types and roles of FEs, and the grammatical voice the roles depend on. These patterns (except 5 once used) are listed in Table 1 that shows that the syntactic patterns underlying functions Desiring V, Desiring V2 Act, Desiring V2 Pass and Desiring VV already cover 55% of all shared patterns. For the same verb types, similar syntactic patterns (RGL-based code templates) cover another 39% of frame functions. The similar templates can be derived in several (incl. combined) ways:\n8 http://www.grammaticalframework.org/lib/doc/synopsis.html\n7 \u2013 more adverbial modifiers can be added by recursive calls of the respective mkVP constructor, or modifiers can be removed at all; \u2013 the NP part of the return values can be fixed to an empty NP if no FE is expected to fill the subject role (e.g. due to examples in the imperative mood; however, a missing subject FE could be often automatically added); \u2013 in the passive voice, the direct object can be possibly fixed to an empty NP.\nThe remaining 6% of the shared patterns represent the use of other verb types: V3, V2V, VS and V2S. Basic code templates that are reused to implement the corresponding frame functions (VP parts) are illustrated by these examples:\nmkVP v3 (fromMaybe NP recipient) (fromMaybe NP theme) -- Giving: [she]Donor/NP [handed ]V3 [him]Recipient/NP [the ring ]Theme/NP\nmkVP vs (fromMaybe S message) -- Hear: [we]Hearer/NP [heard ]VS [it was a good school ]Message/S\nmkVP v2v (fromMaybe NP addressee) (fromMaybe VP message) -- Request: [UK ]Speaker/NP [urges]V2V [Savimbi ]Addressee/NP [to keep the peace]Message/VP\nmkVP v2s (fromMaybe NP addressee) (fromMaybe S content) -- Suasion: [he]Speaker/NP [persuaded ]V2S [himself ]Addressee/NP [that they helped ]Content/S\nNote that the RGL type S, embedded declarative sentence, is used only if the subclause can be verbalized using the subjunction that ; otherwise such FEs are subcategorized as Adv, and the application grammar developer has to specify the subjunction by applying the RGL constructor mkAdv : Subj \u2192 S \u2192 Adv. Also note that FEs of type VP or S, or Adv encapsulating an S represent nested frames. We use the type S instead of Cl to allow for specifying sentence level parameters like tense, anteriority and polarity of the nested frames.\nThe implementation of frame functions, although currently kept separate for each language, mostly could be shared due to the syntactic abstraction provided by RGL. In general, however, the order of Adv FEs can differ across languages.\n8"}, {"heading": "4 Case Studies", "text": "We illustrate the use of the FrameNet-based API to GF RGL by re-engineering two existing multilingual GF application grammars: one for translating standard tourist phrases [12] and another for generating descriptions of paintings [13], both developed in the MOLTO project.9 In both cases, we preserve the original functionality, and we do not make any changes in the application abstract syntax. Changes affect only the concrete syntaxes of English and Swedish."}, {"heading": "4.1 Phrasebook", "text": "Although the Phrasebook grammar covers many idiomatic expressions that cannot be translated using the same frame or for which the FN-based approach would not be suitable at all, it includes around 20 complex clause-building functions that can be handled by the FN-based grammar. To illustrate the use of the semantic API, we re-implement the following Phrasebook functions:\nALive : Person -> Country -> Action -- e.g. \u2018we live in Sweden\u2019 AWant : Person -> Object -> Action -- e.g. \u2018I want a pizza\u2019 AWantGo : Person -> Place -> Action -- e.g. \u2018I want to go to a museum\u2019\nby applying the frame functions Desiring V2 Act and Desiring VV introduced in Section 3, and some additional functions:\nMotion_V_2 : Goal_Adv -> Source_Adv -> Theme_NP -> Clause Possession_V2 : Owner_NP -> Possession_NP -> Clause Residence_V : Location_Adv -> Resident_NP -> Clause\nBy using RGL constructors, ALive is implemented for English, Swedish and other languages in the same way, except that different verbs are used:\nALive p co = mkCl p.name (mkVP (mkVP (mkV \"live\")) (mkAdv in_Prep co)) ALive p co = mkCl p.name (mkVP (mkVP (mkV \"bo\")) (mkAdv in_Prep co))\nFirst, the language-specific verbs can be factored out by introducing a shared abstract verb in the domain lexicon (e.g. live V that links live V Residence and bo V Residence). Second, the implementation of ALive can be done in a shared functor by using the FN-based API:\nALive p co = let cl : Clause =\nResidence_V (Just Adv (mkAdv in_Prep co)) (Just NP p.name) live_V\nin mkCl cl.np cl.vp\nFor AWant, neither the RGL-based nor the current FN-based implementation can be done in the functor because, in Swedish, the verb vilja (\u2018to want\u2019) evoking Desiring V2 Act requires the auxiliary verb ha (\u2018to have\u2019). This can be seen as a nested auxiliary frame Possession:\n9 http://www.molto-project.eu/\n9 AWant p obj = mkCl p.name (mkV2 (mkV \"want\")) obj -- Eng Desiring_V2_Act (Just NP p.name) (Just NP obj) want_V2\nAWant p obj = mkCl p.name want_VV (mkVP L.have_V2 obj) -- Swe Desiring_VV\n(Just VP (Possession_V2 (Nothing NP) (Just NP obj) have_V2).vp) (Just NP p.name) want_VV\nAssuming that the auxiliary verb can be optionally used also with other Swedish verbs when applying this frame function, the nested frame could be hidden in the Swedish implementation of Desiring V2 Act. This, however, is not the case with AWantGo which in both languages requires a main nested frame and, thus, can be put in the functor:\nAWantGo p place = mkCl p.name want_VV (mkVP (mkVP go_V) place.to)\nDesiring_VV (Just VP\n(Motion_V_2 (Just Adv place.to) (Nothing Adv) (Nothing NP) go_V).vp) (Just NP p.name) want_VV\nAt first gleam, the new code might look more complex, but it does not specify how the VP is built, and the same uniform code template is used in all cases. The re-implemented version of Phrasebook accepts and generates the same set of sentences as before."}, {"heading": "4.2 Painting Grammar", "text": "The Painting grammar is a part of a large scale Natural Language Generation (NLG) grammar developed for the cultural heritage (CH) domain in order to verbalize data about museum objects stored in an RDF-based ontology [13]. A set of RDF triples (subject-predicate-object expressions) forms the input to the application. As an example, a simplified set of triples representing information about the artwork Le Ge\u0301ne\u0301ral Bonaparte is:\n<LeGeneralBonaparte> <createdBy> <JacquesLouisDavid> <LeGeneralBonaparte> <hasDimension> <LeGeneralBonaparteDimesion> <LeGeneralBonaparte> <hasCreationDate> <LeGeneralBonaparteCreationDate> <LeGeneralBonaparte> <hasCurrentLocation> <MuseeDuLouvre>\nThis information is combined by the grammar to generate a coherent text. The function in the abstract syntax that combines the triples is the following:\nDPainting : Painting -> Painter -> Year -> Size -> Museum -> Description\nEach argument of the function corresponds to a class in the ontology. Below we show how the arguments are linearized in the original concrete syntax for English and how this syntax has been adapted to generate from the FN-based grammar. To adapt the grammar, we first identified the frames that match the target verbs in the linearization rules. Then we matched the core FEs of the identified frames with the verb arguments.\n10\nThe original grammar: Using the FrameNet-based API: -------------------------------- ------------------------------------- DPainting painting painter DPainting painting painter\nyear size museum = year size museum =\nlet let\ns1 : Text = mkText (mkS cl1 : Clause =\npastTense (mkCl painting (mkVP Create_physical_artwork_V2_Pass\n(mkVP (passiveVP paint_V2) (Just NP painter.long)\n(mkAdv by8agent_Prep (Just NP painting)\npainter.long)) year.s))) ; paint_V2 ;\ns2 : Text = mkText cl2 : Clause = Dimension_V\n(mkCl it_NP (mkVP (mkVP (Just Adv size.s)\n(mkVPSlash measure_V2) (Just NP it_NP) (mkNP (mkN \"\"))) size.s) ; measure_V2 ;\ns3 : Text = mkText cl3 : Clause = Being_located_V\n(mkCl (mkNP this_Det painting) (Just Adv museum.s)\n(mkVP (passiveVP display_V2) (Just NP (mkNP this_Det painting))\nmuseum.s)) display_V2\nin mkText s1 (mkText s2 s3) ; in mkText (mkText (mkS pastTense\n(mkCl cl1.np (mkVP cl1.vp year.s))) (mkText (mkCl cl2.np cl2.vp)\n(mkText (mkCl cl1.np cl3.vp))) ;\nThe grammar exploits patterns of frames Create physical artwork, Dimension and Being located. Since the FN-based grammar currently does not cover noncore FEs, the adjunct Year is associated with no FE in Create physical artwork. Instead, it is attached to the corresponding clause in the final linearization rule (mkText) illustrating how non-core FEs can be incorporated.\nThe Swedish syntax was adapted in a similar way. The only difference in comparison to English and to the original Swedish syntax is the choice of verbs and pronouns. The descriptions generated by the new version of DPainting are semantically equivalent to the descriptions produced by the original grammar:\nEng: Le Ge\u0301ne\u0301ral Bonapart was painted by Jacques-Louis David in 1510. It measures 81 by 65 cm. This work is displayed at the Muse\u0301e du Louvre. Swe: Le Ge\u0301ne\u0301ral Bonapart m\u030aalades av Jacques-Louis David a\u030ar 1510. Den ma\u0308ter 81 g\u030aanger 65 cm. Det ha\u0308r verket ha\u0308nger p\u030aa Louvren."}, {"heading": "5 Evaluation", "text": "We have conducted a simple intrinsic and extrinsic evaluation of the acquired FN-based grammar. For an initial intrinsic evaluation, we count the number of examples in the source corpora that belong to the set of shared frames and that are covered by the set of shared semantico-syntactic valence patterns. Corpus examples are represented by sentence patterns disregarding non-core FEs, word\n11\norder and prepositions, but including syntactic roles and the grammatical voice. There are 55,837 examples in BFN that belong to the shared set of 423 frames, and 69.4% of them are covered by the shared valence patterns despite the modest size of SweFN. In SweFN, 2,434 examples belong to the shared set of frames, and 68.9% of them are covered by the shared patterns. Note that the original sentences are, in general, covered by paraphrasing.\nFor an initial extrinsic evaluation, we compare the original application grammars with their FN-based counterparts in terms of code complexity. Since we do not modify the abstract syntax of application grammars, the amount of linearization rules remains the same. Therefore we count the number of constructors used to linearize the functions. In the Painting grammar, the number of constructors is considerably reduced from 21 to 13. In the case of Phrasebook, the number is slightly reduced from 10 in English and 11 in Swedish to 8 in both languages."}, {"heading": "6 Related Work", "text": "The main difference between this work and the previous approaches to CNL grammars is that we present an effort to exploit a robust and well established semantic model in the grammar development. Our approach can be compared with the work on multilingual verbalisation of modular ontologies using GF and lemon, the Lexicon Model for Ontologies [14]. We use additional lexical information about syntactic arguments for building the concrete syntax.\nThe grounding of NLG using the frame semantics theory has been addressed in the work on text-to-scene generation [15] and in the work on text generation for navigational tasks [16]. In that research, the content of frames is utilized through alignment between the frame-semantic structure and the domainsemantic representation. Discourse is supported by applying aggregation and pronominalization techniques. In the CH use case, we also show how an application which utilizes the FN-based grammar can become more discourseoriented; something that is necessary in actual NLG applications and that has been demonstrated for the CH domain in GF before [17]. In our current approach, the semantic representation of the domain and the linguistic structures of the grammar are based on FN-annotated data.\nAs suggested before [18], a FN-like approach can be used to deal with polysemy in CNL texts. Although we consider lexicalisation alternatives and restrictions for LUs and FEs, we do not address the problem of selectional restrictions and word sense disambiguation in general."}, {"heading": "7 Conclusion", "text": "In this paper we demonstrated the advantages of utilizing a FrameNet-based grammar to facilitate the development of multilingual CNL applications. We presented an approach to generating semantic grammar library from two FNannotated corpora. We tested the feasibility of this grammar as a semantic API for developing application grammars in GF. The major advantage is that\n12\nlanguage-dependent clause-level specifications to a large extent are hidden by the API, making the application grammars more robust and flexible.\nAcknowledgements. This research has been supported by the Swedish Research Council under Grant No. 2012-5746 (Reliable Multilingual Digital Communication: Methods and Applications) and by the Centre for Language Technology in Gothenburg."}], "references": [{"title": "FrameNet resource grammar library for GF", "author": ["N. Gruzitis", "P. Paikens", "G. Barzdins"], "venue": "Proc. of the 3rd Workshop on CNL. Volume 7427 of LNCS.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Grammatical Framework, a type-theoretical grammar formalism", "author": ["A. Ranta"], "venue": "Journal of Functional Programming 14(2)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "The GF resource grammar library", "author": ["A. Ranta"], "venue": "LILT 2(2)", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "Extracting a bilingual semantic grammar from FrameNet-annotated corpora", "author": ["D. Dann\u00e9lls", "N. Gruzitis"], "venue": "Proceedings of the 9th International Language Resources and Evaluation Conference (LREC).", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "FrameNet CNL: A knowledge representation and information extraction language", "author": ["G. Barzdins"], "venue": "Proc. of the 4th Workshop on CNL.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2014}, {"title": "Background to Framenet", "author": ["C.J. Fillmore", "C.R. Johnson", "M.R.L. Petruck"], "venue": "International Journal of Lexicography 16(3)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Frame semantic parsing", "author": ["D. Das", "D. Chen", "A.F.T. Martins", "N. Schneider", "N.A. Smith"], "venue": "Computational Linguistics 40(1)", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Open domain information extraction via automatic semantic labeling", "author": ["A. Moschitti", "P. Morarescu", "S.M. Harabagiu"], "venue": "Proc. of the 16th IFLAIRS.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "A NLG-based application for walking directions", "author": ["M. Roth", "A. Frank"], "venue": "Proceedings of the 47th ACL and the 4th IJCNLP Conference.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Multilingual FrameNets in Computational Lexicography", "author": ["H.C. Boas"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "The past meets the present in Swedish FrameNet++", "author": ["L. Borin", "D. Dann\u00e9lls", "M. Forsberg", "M. Toporowska Gronostaj", "D. Kokkinakis"], "venue": "Proceedings of the 14th EURALEX International Congress.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "Controlled language for everyday use: The MOLTO Phrasebook", "author": ["A. Ranta", "R. Enache", "G. D\u00e9trez"], "venue": "Proceedings of the 2nd Workshop on Controlled Natural Language. Volume 7175 of LNCS.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Multilingual online generation from Semantic Web ontologies", "author": ["D. Dann\u00e9lls", "R. Enache", "M. Damova", "M. Chechev"], "venue": "Proceedings of the 21st International World Wide Web Conference, European Project Track.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Multilingual verbalisation of modular ontologies using GF and lemon", "author": ["B. Davis", "R. Enache", "J.V. Grondelle", "L. Pretorius"], "venue": "Controlled Natural Language.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "VigNet: Grounding Language in Graphics Using Frame Semantics", "author": ["B. Coyne", "D. Bauer", "O. Rambow"], "venue": "Proc. of RELMS, ACL", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "Computing EM-based Alignments of Routes and Route Directions as a Basis for Natural Language Generation", "author": ["M. Roth", "A. Frank"], "venue": "In Huang, C.R., Jurafsky, D., eds.: COLING, Tsinghua University Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2010}, {"title": "Discourse Generation from Formal Specifications Using the Grammatical Framework, GF", "author": ["D. Dann\u00e9lls"], "venue": "Special issue of the RCS, Springer", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2010}, {"title": "Polysemy in controlled natural language texts", "author": ["N. Gruzitis", "G. Barzdins"], "venue": "Revised papers of the Workshop on CNL. Volume 5972 of LNCS.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Two years ago, at CNL 2012, a conception of a general-purpose semantic grammar based on FrameNet (FN) was proposed [1] to facilitate the development of multilingual controlled natural language (CNL) applications in Grammatical Framework (GF).", "startOffset": 115, "endOffset": 118}, {"referenceID": 1, "context": "GF [2], a type-theoretical grammar formalism and a toolkit, provides a wide-coverage resource grammar library (RGL) for nearly 30 languages that implement a shared syntactic API [3].", "startOffset": 3, "endOffset": 6}, {"referenceID": 2, "context": "GF [2], a type-theoretical grammar formalism and a toolkit, provides a wide-coverage resource grammar library (RGL) for nearly 30 languages that implement a shared syntactic API [3].", "startOffset": 178, "endOffset": 181}, {"referenceID": 3, "context": "Following this proposal, a shared abstract syntax of wide-coverage English and Swedish semantic grammars has been recently extracted from FN-annotated corpora [4].", "startOffset": 159, "endOffset": 162}, {"referenceID": 4, "context": "The future potential of our work is to provide a means for multilingual verbalization of FN-annotated databases that have been populated in information extraction processes by FN-based semantic parsers and that potentially can be mapped with the FN-based API automatically [5].", "startOffset": 273, "endOffset": 276}, {"referenceID": 5, "context": "FrameNet is a lexico-semantic resource based on the theory of frame semantics [6].", "startOffset": 78, "endOffset": 81}, {"referenceID": 6, "context": "The FrameNet approach provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing [7], information extraction [8] and natural language generation [9].", "startOffset": 300, "endOffset": 303}, {"referenceID": 7, "context": "The FrameNet approach provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing [7], information extraction [8] and natural language generation [9].", "startOffset": 328, "endOffset": 331}, {"referenceID": 8, "context": "The FrameNet approach provides a benchmark for representing large amounts of word senses and word usage patterns through the linguistic annotation of corpus examples, therefore the exploitation of FN-like resources has been appealing for a range of advanced NLP applications such as semantic parsing [7], information extraction [8] and natural language generation [9].", "startOffset": 364, "endOffset": 367}, {"referenceID": 9, "context": "There are available computationally oriented FNs for German, Japanese, Spanish [10] and Swedish [11].", "startOffset": 79, "endOffset": 83}, {"referenceID": 10, "context": "There are available computationally oriented FNs for German, Japanese, Spanish [10] and Swedish [11].", "startOffset": 96, "endOffset": 100}, {"referenceID": 5, "context": "In this paper, we consider two FNs: the original Berkeley FrameNet (BFN) [6] and the Swedish FrameNet (SweFN) [11].", "startOffset": 73, "endOffset": 76}, {"referenceID": 10, "context": "In this paper, we consider two FNs: the original Berkeley FrameNet (BFN) [6] and the Swedish FrameNet (SweFN) [11].", "startOffset": 110, "endOffset": 114}, {"referenceID": 3, "context": "5 defines more than 1,000 frames, of which 556 are evoked by around 3,200 verb LUs in more than 68,500 annotated sentences [4].", "startOffset": 123, "endOffset": 126}, {"referenceID": 9, "context": "Although BFN has been developed for English, its inventory of frames and FEs is being reused for many other FNs [10].", "startOffset": 112, "endOffset": 116}, {"referenceID": 3, "context": "The SweFN development version contains more than 900 frames of which 638 are evoked by around 2,300 verb LUs in more than 3,700 annotated sentences [4].", "startOffset": 148, "endOffset": 151}, {"referenceID": 1, "context": "The presented grammar is implemented in GF, a categorial grammar formalism specialized for multilingual (parallel) grammars [2].", "startOffset": 124, "endOffset": 127}, {"referenceID": 2, "context": "It also provides a general-purpose resource grammar library (RGL) for nearly 30 languages that implement the same abstract syntax, a shared syntactic API [3].", "startOffset": 154, "endOffset": 157}, {"referenceID": 3, "context": "Following a recently proposed approach [4], we have extracted a set of shared semantico-syntactic frame valence patterns from the annotated sentences in BFN and SweFN.", "startOffset": 39, "endOffset": 42}, {"referenceID": 3, "context": "In contrast to the previous experiment [4], where the focus was on the abstract grammar, here we generate the concrete syntaxes taking the syntactic roles for FEs of type NP into account: subject (Subj), direct object (DObj) and indirect object (IObj).", "startOffset": 39, "endOffset": 42}, {"referenceID": 3, "context": "To find a representative yet condensed set of shared valence patterns, we compare the extracted patterns by subsumption instead of exact match [4].", "startOffset": 143, "endOffset": 146}, {"referenceID": 11, "context": "We illustrate the use of the FrameNet-based API to GF RGL by re-engineering two existing multilingual GF application grammars: one for translating standard tourist phrases [12] and another for generating descriptions of paintings [13], both developed in the MOLTO project.", "startOffset": 172, "endOffset": 176}, {"referenceID": 12, "context": "We illustrate the use of the FrameNet-based API to GF RGL by re-engineering two existing multilingual GF application grammars: one for translating standard tourist phrases [12] and another for generating descriptions of paintings [13], both developed in the MOLTO project.", "startOffset": 230, "endOffset": 234}, {"referenceID": 12, "context": "The Painting grammar is a part of a large scale Natural Language Generation (NLG) grammar developed for the cultural heritage (CH) domain in order to verbalize data about museum objects stored in an RDF-based ontology [13].", "startOffset": 218, "endOffset": 222}, {"referenceID": 13, "context": "Our approach can be compared with the work on multilingual verbalisation of modular ontologies using GF and lemon, the Lexicon Model for Ontologies [14].", "startOffset": 148, "endOffset": 152}, {"referenceID": 14, "context": "The grounding of NLG using the frame semantics theory has been addressed in the work on text-to-scene generation [15] and in the work on text generation for navigational tasks [16].", "startOffset": 113, "endOffset": 117}, {"referenceID": 15, "context": "The grounding of NLG using the frame semantics theory has been addressed in the work on text-to-scene generation [15] and in the work on text generation for navigational tasks [16].", "startOffset": 176, "endOffset": 180}, {"referenceID": 16, "context": "In the CH use case, we also show how an application which utilizes the FN-based grammar can become more discourseoriented; something that is necessary in actual NLG applications and that has been demonstrated for the CH domain in GF before [17].", "startOffset": 240, "endOffset": 244}, {"referenceID": 17, "context": "As suggested before [18], a FN-like approach can be used to deal with polysemy in CNL texts.", "startOffset": 20, "endOffset": 24}], "year": 2014, "abstractText": "This paper presents a currently bilingual but potentially multilingual FrameNet-based grammar library implemented in Grammatical Framework. The contribution of this paper is two-fold. First, it offers a methodological approach to automatically generate the grammar based on semantico-syntactic valence patterns extracted from FrameNetannotated corpora. Second, it provides a proof of concept for two use cases illustrating how the acquired multilingual grammar can be exploited in different CNL applications in the domains of arts and tourism.", "creator": "LaTeX with hyperref package"}}}