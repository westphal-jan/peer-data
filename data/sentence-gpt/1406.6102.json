{"id": "1406.6102", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jun-2014", "title": "Random Logic Programs: Linear Model", "abstract": "This paper proposes a model, the linear model, for randomly generating logic programs with low density of rules and investigates statistical properties of such random logic programs. It is mathematically shown that the average number of answer sets for a random program converges to a constant when the number of atoms approaches infinity. Several experimental results are also reported, which justify the suitability of the linear model, including the possibility that some of the features of the model are completely dependent upon the random generator.\n\n\n\n\nThe model was originally proposed as a model for random random selection, a form of general random generator for general random selection. However, in the future it will be a more complex and more expensive model. For example, it may be possible to derive random random number generators as random random number generators. The model may also be very efficient for the task of applying the random generation algorithm to randomly generated sets of random programs. The main challenge, which involves solving an exponentially large number of random algorithms, is to generate large numbers of random programs with low density of rules. This process requires a number of different types of random algorithms, and will require a number of different type-of random programs that are computationally nonrandom.\nThe model may also be highly efficient for the task of applying the random generation algorithm to random generated sets of random programs. A solution to this problem is to produce random numbers in one set (i.e., a set of randomly generated values) from a single random program.\nThe results of this paper show that the general random generator (i.e., a set of random random generators) is very simple, without any statistical properties.\nThe current state of the model and the general random generator have been proposed for the purpose of generating small numbers of random programs. It has already been demonstrated that the standard random generator (with its own random generators) would make a significant difference to solving a large number of random programs.\nThe paper is available on paper at arXiv.org.", "histories": [["v1", "Mon, 23 Jun 2014 22:23:11 GMT  (371kb,D)", "http://arxiv.org/abs/1406.6102v1", "33 pages. To appear in: Theory and Practice of Logic Programming"]], "COMMENTS": "33 pages. To appear in: Theory and Practice of Logic Programming", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["kewen wang", "lian wen", "kedian mu"], "accepted": false, "id": "1406.6102"}, "pdf": {"name": "1406.6102.pdf", "metadata": {"source": "CRF", "title": "Random Logic Programs: Linear Model", "authors": ["Kewen Wang", "Lian Wen", "Kedian Mu"], "emails": ["k.wang@griffith.edu.au)", "l.wen@griffith.edu.au)", "mukedian@math.pku.edu.cn)"], "sections": [{"heading": null, "text": "KEYWORDS: answer set programming, random logic programs."}, {"heading": "1 Introduction", "text": "As in the case of combinatorial structures, the study of randomly generated instances of NPcomplete problems in artificial intelligence has received significant attention in the last two decades. These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999). In turn, these results on properties of random SAT and random CSP significantly help researchers in better understanding SAT and CSP, and developing fast solvers for them.\nOn the other hand, it is well known that reasoning in propositional logic and in most constraint languages is monotonic in the sense that conclusions obtained before new information is added cannot be withdrawn. However, commonsense knowledge is nonmonotonic. In artificial intelligence, significant effort has been paid to develop fundamental problem solving paradigms that allow users to conveniently represent and reason about commonsense knowledge and solve problems in a declarative way. Answer set programming (ASP) is currently one of the most widely used nonmonotonic reasoning systems due to its simple syntax, precise semantics and importantly, the availability of ASP solvers, such as clasp (Gebser et al. 2009), dlv (Leone et al. 2006), and smodels (Syrja\u0308nen and Niemela\u0308 2001). However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).\n(Zhao and Lin 2003) first conducted an experimental study on the issue of phase transition for randomly generated ASP programs whose rules can have three or more literals. (Schlipf\nar X\niv :1\n40 6.\n61 02\nv1 [\ncs .A\nI] 2\net al. 2005) reported on their experimental work for determining the distribution of randomly generated normal logic programs at the Dagstuhl Seminar.\nTo study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs. Their method is to map some statistical properties of random graphs into simple random programs by transforming a random program into that of a random graph through a close connection between simple random programs and random graphs. As the authors have commented, those classes of random programs that correspond to some classes of random graphs are too restricted to be useful. Their effort further confirms that it is challenging to recast statistical properties of SAT/CSP to nonmonotonic formalisms such as ASP.\nIn fact, the monotonicity plays an important role in proofs of major results for random SAT/CSP. Specifically, major statistical properties for SAT/CSP are based on a simple but important property: An interpretation M is a model of a set of clauses/constraints if and only if M is a model of each clause/constraint. Due to the lack of monotonicity in ASP, this property fails to hold for ASP and other major nonmonotonic formalisms.\nFor this reason, it might make sense to first focus on some relatively simple but expressive classes of ASP programs (i.e., still NP-complete). We argue that the class of negative two-literal programs (i.e. normal logic programs in which a rule body has exactly one negative literal) is a good start for studying random logic programs under answer set semantics for several reasons1: (1) The problem of deciding if a negative two-literal program has an answer set is still NP-complete. In fact, the class of negative two-literal programs is used to show the NP-hardness of answer set semantics for normal logic programs in (Marek and Truszczynski 1991) (Theorem 6.4 and its proof, where a negative two-literal program corresponds to a simple K1-theory). (2) Many important NP-complete problems can be easily encoded as (negative) two-literal programs (Huang et al. 2002). (3) Negative two-literal programs allow us to conduct large scale experiments with existing ASP solvers, such as smodels, dlv and clasp.\nIn this paper we introduce a new model for generating and studying random negative twoliteral programs, called linear model. A random program generated under the linear model is of the size about c\u00d7n where c is a constant and n is the total number of atoms. We choose such a model of randomly generating negative two-literal programs for two reasons. First, if we use a natural way to randomly generate programs like what has been done in SAT and CSP, we would come up with two possible models in terms of program sizes (i.e. linear in n and quadratic in n), since only n2 negative two-literal rules in total can be generated from a set of n atoms. We study statistical properties of such random programs and have obtained both theoretical and experimental results for random programs generated under the linear model, especially, Theorem 1. These properties include the average number of answer sets, the size distribution of answer sets, and the distribution of consistent programs under the linear model. Second, such results can be used in practical applications. For instance, it is important to compute all answer sets of a program in applications, such as diagnoses and query answering, in P-log (Baral et al. 2009). In such cases, the number of answer sets for a program is certainly relevant. If we know the number of answer sets and the average size of the answer sets for a logic program, such information\n1 Our definition of negative two-literal programs here is slightly different from that used by some other authors. But these definitions are essentially equivalent if we notice that a fact rule a\u2190 can be expressed as a rule a\u2190 not a\u2032 where a\u2032 is a new atom. Details can be found in Section 2.\ncan be useful heuristics for finding all answer sets of a given program. Also, the linear model of random programs may be useful in application domains such as ontology engineering where most of large practical ontologies are sparse in the sense that the ratio of terminological axioms to concepts/roles is relatively small (Staab and Studer 2004).\nThe contributions of this work can be summarised as follows:\n1. A model for generating random logic programs, called the linear model, is established. Our model generates random logic programs in a similar way as SAT and CSP, but we distinguish the probabilities for picking up pure rules and contradiction rules. (Namasivayam and Truszczynski 2009) discusses some program classes of two-literal programs that may not be negative. However, as their major results are inherited from the corresponding ones in random graph theory, such results hold only for very special classes of two-literal programs. For instance, in regard to the result on negative two-literal programs without contradiction rules (Theorem 2, page 228), the authors pointed out that the theorem \u201cconcerns only a narrow class of dense programs, its applicability being limited by the specific number of rules programs are to have\u201d (0 < c < 1, x is a fixed number, the number of rules m = bcN + x \u221a c(c\u22121)Nc and N = n(n\u22121))2. 2. We mathematically show that the average number of answer sets for a random program converges to a constant when the number of atoms approaches infinity. We note that the proofs of statistical properties, such as phase transitions, for random SAT and random CSP are usually obtained through the independence of certain probabilistic events, which in turn is based on a form of the monotonicity of classical logics (specifically, given a set of formulas S = {\u03c61, . . . ,\u03c6t} with t \u2265 0, it holds that Mod(S) =Mod(\u03c61)\u2229 \u00b7\u00b7 \u00b7\u2229Mod(\u03c6t) when Mod(\u00b7) denotes the set of all models of a formula or a set of formulas). However, it is well known that ASP is nonmonotonic. In our view, this is why many proof techniques for random SAT cannot be immediately adapted to random ASP. In order to provide a formal proof for Theorem 1, we resort to some techniques from mathematical analysis such as Stirling\u2019s Approximation and Taylor series. As a result, our proof is both mathematically involved and technically novel. We look into the application of our main result in predicting the consistency of random programs (Proposition 5 and Section 4.3). 3. We have conducted significant experiments on statistical properties of random programs generated under the linear model. These properties include the average number of answer sets, the size distribution of answer sets, and the distribution of consistent programs under the linear model. For the average number of answer sets, our experimental results closely match the theoretical results obtained in Section 3. Also, the experimental results corroborate the conjecture that under the linear model, the size distribution of answer sets for random programs obeys a normal distribution when n is large. The experimental results show that our theories can be used to predict practical situations. As explained above, we need to find all answer sets in some applications. For large logic programs, it may be infeasible to find all answer sets but we could develop algorithms for finding most of the answer sets. If we know an average size of answer sets, we might need only to examine those sets of atoms whose sizes are around the average size.\nThe rest of the paper is arranged as follows. In Section 2, we briefly review answer set semantics of logic programs and some properties of two-literal programs that will be used in the\n2 There may be an error here as c\u22121 < 0.\nsubsequent sections. In Section 3, we first introduce the linear model for random logic programs (negative two-literal programs), study mathematical properties of random programs, and then present the main result in a theorem. In Section 4 we describe some of our experimental results and compare them with related theoretical results obtained in the paper. We conclude the work in Section 5. For the convenience of readers, some mathematical basics required for the proofs are included in the Appendix at the end of the paper."}, {"heading": "2 Answer Set Semantics and Two-Literal Programs", "text": "We briefly review some basic definitions and notation of answer set programming (ASP). We restrict our discussion to finite propositional logic programs on a finite set An of n atoms (n > 0).\nA normal logic program (simply, logic program) is a finite set of rules of the form\na\u2190 b1, . . . ,bs,not c1, . . . ,not ct , (1)\nwhere not is for the default negation, s, t \u2265 0, and a, bi and c j are atoms in An (i = 1, . . . ,s, j = 1, . . . , t).\nWe assume that all atoms appearing in the body of a rule are pairwise distinct. A literal is an atom a or its default negation not a. The latter is called a negative literal. An atom a and its default negation not a are said to be complementary. Given a rule R of form (1), its head is defined as head(R) = a and its body is body(R) = body+(R)\u222anot body\u2212(R) where body+(R) = {b1, . . . ,bs}, body\u2212(R) = {c1, . . . ,ct}, and not body\u2212(R) = {not q | q \u2208 body\u2212(R)}.\nA rule R of form (1) is positive, if t = 0; negative, if s = 0. A logic program P is called positive (resp. negative), if every rule in P is positive (resp. negative).\nAn interpretation for a logic program P is a set of atoms S \u2286 An. A rule R is satisfied by S, denoted S |= R, if S |= head(R) whenever body+(R) \u2286 S and body\u2212(R)\u2229S = /0. Furthermore, S is a model of P, denoted S |= P, if S |= R for every rule R \u2208 P. A model S of P is a minimal model of P if for any model S\u2032 of P, S\u2032 \u2286 S implies S\u2032 = S.\nThe semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows. Given an interpretation S, the reduct of P on S is defined as PS = {head(R)\u2190 body+(R) |R\u2208P,body\u2212(R)\u2229S= /0}. Note that PS is a positive logic program and every (normal) positive program has a unique least model. Then we say S is an answer set of P, if S is the least model of PS. By AS(P) we denote the collection of all answer sets of P. For an integer k \u2265 0, AS(P,k) denotes the set of answer sets of size k for P.\nA logic program P may have zero, one or multiple answer sets. P is said to be consistent, if it has at least one answer set. It is well-known that the answer sets of a logic program P are incomparable: for any S and S\u2032 in AS(P), S\u2286 S\u2032 implies S = S\u2032.\nTwo logic programs P and P\u2032 are equivalent under answer set semantics, denoted P \u2261 P\u2032, if AS(P) = AS(P\u2032), i.e., P and P\u2032 have the same answer sets. We can slightly generalise the equivalence of two programs as follows. Let P be a logic program on An and P\u2032 a logic program on An \u222aE, where E is a set of new (auxiliary) atoms. We say P and P\u2032 are equivalent if the following two conditions are satisfied:\n1. if S \u2208 AS(P), then there exists S\u2032 \u2208 AS(P\u2032) such that S\u2032 = S\u222aSe and Se \u2286 E. 2. if S\u2032 \u2208 AS(P\u2032), then S = S\u2032 \\E is in AS(P).\nFrom the next section and on, we will focus on a special class of logic programs, called negative two-literal programs.\nA negative two-literal rule is a rule of the form a\u2190 not b where a and b are atoms. These two atoms do not have to be distinct. If a 6= b, it is a pure rule; if a = b, it is a contradiction rule. A negative two-literal program is a finite set of negative two-literal rules.\nWe note that our definition is slightly different from some other authors, such as (Janhunen 2006; Lonc and Truszczynski 2002), in that fact rules are not allowed in our definition. This may not be an issue since a fact rule of the form a\u2190 can be expressed as a negative two-literal rule a\u2190 not c, where c is a new atom that does not appear in the program.\nIt is shown in (Marek and Truszczynski 1991) that the problem of deciding the existence of answer sets for a negative two-literal program is NP-complete. This result confirms that the class of negative two-literal programs is computationally powerful and it makes sense to study the randomness for such a class of logic programs.\nWe remark that, by allowing the contradiction rules, constraints of the form \u2190 b1, . . . ,bs,not c1, . . . ,not ct (s, t \u2265 0) can be expressed in the class of negative two-literal programs. A contradiction rule a\u2190 not a is strongly equivalent to the constraint \u2190 not a under answer set semantics: for any logic program P, P\u222a{\u2190 not a} is equivalent to P\u222a{a\u2190 not a} under answer set semantics. Notice also that a constraint of the form\u2190 not a,not b is strongly equivalent to the two constraints \u2190 not a and \u2190 not b, and a constraint of the form \u2190 a is strongly equivalent to two rules\u2190 not a\u2032 and a\u2032\u2190 not a where a\u2032 is a fresh atom.\nIn the rest of this section we present three properties of negative two-literal programs. While Proposition 1 is to demonstrate the expressive power of negative two-literal programs, Propositions 2 and 3 will be used to prove our main theorem in the next section. These properties are already known in the literature and we do not claim their originality here.\nFirst, each logic program can be equivalently transformed into a negative two-literal program under answer set semantics. This result is mentioned in (Blair et al. 1999) but no proof is provided there. For completeness, we provide a proof of this proposition in the appendix at the end of the paper.\nProposition 1 Each normal logic program P is equivalent to a negative two-literal program under answer set semantics.\nThe next result provides an alternative characterization for the answer sets of a negative twoliteral program, which is a special case of Theorem 6.81, Section 6.8 in (Marek and Truszczynski 1993).\nProposition 2 Let P be a negative two-literal program on An containing at least one rule. Then S is an answer set of P iff the following two conditions are satisfied:\n1. If b1,b2 \u2208 An \\S, then b1\u2190 not b2 is not a rule in P. 2. If a \u2208 S, then there exists b \u2208 An \\S such that a\u2190 not b is a rule in P.\nWe note that in condition 1 above, it can be the case that b1 = b2. We note that if the empty set is an answer set of a negative two-literal program, the program must be empty. Also, An is not an answer set for any negative two-literal program on An.\nProposition 3 Let P be a negative two-literal program on An containing at least one rule. If S is an answer set of P, then 0 < |S|< n. Here |S| is the number of elements in S."}, {"heading": "3 Random Programs and Their Properties", "text": "In this section we first introduce a model for randomly generating negative two-literal programs and then present some statistical properties of such random programs. The main result in this section (Theorem 1) shows that the expected number of answer sets for a random program on An generated under our model converges to a constant when the number n of atoms approaches infinity. As the proof of Theorem 1 is lengthy and mathematically involved, some technical details, as well as necessary basics of mathematical analysis, are included in the appendix at the end of the paper.\nIn this section, we assume that each negative two-literal program contains at least one rule.\nDefinition 1 (Linear Model L(N2,c1,c2)) Let c1 and c2 be two non-negative real numbers with c1 +c2 > 0. Given a set An of n atoms with n > max(c1,c2), a random program P on An is a negative two-literal program that is generated as follows:\n1. For any two different atoms a,b \u2208 An, the probability of the pure rule a\u2190 not b being in P is p = c1/n. 2. For any atom a \u2208 An, the probability of the constraint a\u2190 not a being in P is d = c2/n. 3. Each rule is selected randomly and independently based on the given probability.\nIn the above notation, \u2018N2\u2019 is for \u2018negative two-literal programs\u2019. For simplicity, we assume that a random program is non-empty. If c2 = 0, then a random program generated under L(N2,c1,c2) does not contain any contradiction rules.\nIn probability theory, the expected value (or mathematical expectation) of a random variable is the weighted average of all possible values that this random variable can take on. Suppose random variable X can take k possible values x1, . . . ,xm and each xk has the probability pk for k = 1, . . . ,m. Then the expected value of random variable X is defined as\nE[X ] = m\n\u2211 k=1 pkxk.\nAlso, if a random variable X is the sum of a finite number of other variables X1, . . . ,Xs (s > 0), i.e.,\nX = s\n\u2211 k=1 Xk,\nthen\nE[X ] = s\n\u2211 k=1 E[Xk].\nThe number |P| of rules in random program P (i.e., the size of P) is a random variable. As there are n(n\u2212 1) possible pure rules, each of which has probability p = c1/n, and n possible constraints, each of which has the probability d = c2/n. Thus, the expected value of |P|, also called the expected number of rules for random program P, is the sum of expected number of\npure rules and the expected number of constraints:\nE[|P|] = n(n\u22121)p+nd = c1(n\u22121)+ c2.\nThis means that the average size of random programs generated under the model L(N2,c1,c2) is a linear function of n. This is the reason why we refer to our model for random programs as the linear model of random programs under answer sets.\nFor S \u2286 An with |S| = k (0 < k < n), the probability of S being an answer set of random program P, denoted Pr(k), can be easily figured out as the next result shows. We remark that, by Proposition 3, for negative two-literal program P, neither the empty set /0 nor An can be an answer set of P. So we do not need to consider the case of k = 0 or k = n.\nProposition 4 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). Then\nPr(k) = (\n1\u2212 c1 n\n)(n\u2212k)(n\u2212k\u22121)( 1\u2212 (\n1\u2212 c1 n\n)n\u2212k)k( 1\u2212 c2\nn\n)n\u2212k . (2)\nRecall that p = c1/n and d = c2/n. If we denote q = 1\u2212 p, then Eq.(2) can be simplified into\nPr(k) = q(n\u2212k)(n\u2212k\u22121)(1\u2212qn\u2212k)k(1\u2212d)n\u2212k. (3)\nProof Let S be a subset of An with |S|= k and T =An\\S. We can split the first condition in Proposition 2 into two sub-conditions. S is an answer set of negative two-literal program P iff the following two conditions are satisfied:\n(1) (1.1) for each pair b1,b2 \u2208 T with b1 6= b2, the rule b1\u2190 not b2 is not in P. (1.2) for each a \u2208 T , the rule a\u2190 not a is not in P. (2) for each a \u2208 S, there exists an atom b \u2208 T such that a\u2190 not b is in P.\nLet us figure out the probabilities that the above conditions (1.1), (1.2) and (2) hold, respectively.\nWe say that an atom a is supported w. r. t. S in P (or just, supported) if there exists a rule of the form a\u2190 not b in P such that b \u2208 T . In this case, the rule a\u2190 not b is referred to as a supporting rule for a.\nFirst, since T contains n\u2212 k elements, there are (n\u2212 k)(n\u2212 k\u2212 1) possible pure rules of the form b1\u2190 not b2 with b1,b2 \u2208 T and b1 6= b2. By the definition of L(N2,c1,c2), the probability that a pure rule does not belong to P is 1\u2212 p = q. Thus, the probability that none of the pure rules with b1,b2 \u2208 T and b1 6= b2 belongs to P is q(n\u2212k)(n\u2212k\u22121). That is, the condition (1.1) will hold with the probability q(n\u2212k)(n\u2212k\u22121).\nNext, by the definition of L(N2,c1,c2), the probability that a constraint rule of the form a\u2190 not a does not belong to P is 1\u2212d. Since T contains n\u2212 k atoms, the probability that none of the constraint rules of the form a\u2190 not a with a \u2208 T is (1\u2212d)n\u2212k. That is, the condition (1.2) will hold with the probability (1\u2212d)n\u2212k.\nLast, we consider the condition (2). For each a \u2208 S, if a pure rule supports a, then it must be of the form a\u2190 not b for some b \u2208 T . There are n\u2212 k possible such pure rules. Also, a is not supported by such pure rules only if P does not contain such rules at all. Thus, the probability that a is not supported (by one of such pure rules) is qn\u2212k. That is, the probability that a is supported\nis 1\u2212qn\u2212k. As there are k atoms in S, the probability that every atom in S is supported by a pure rule in P is (1\u2212qn\u2212k)k.\nCombining the above three conditions, we know that the probability that S is an answer set of random program P is as follows.\nPr(k) = q(n\u2212k)(n\u2212k\u22121)(1\u2212qn\u2212k)k(1\u2212d)n\u2212k.\nNow we are ready to present the main result in this section, which shows that the average number of answer sets for random logic programs generated under the linear model converges to a constant when the number of atoms approaches infinity. This constant is determined by c1 and c2, e. g., when c1 = 5 and c2 = 0, the constant is around 1.6.\nTheorem 1 Let P denote a random program generated under the linear model L(N2,c1,c2) and E[|AS(P)|] be the expected number of answer sets for random program P. Then\nlim n\u2192\u221e\nE[|AS(P)|] = \u03b1e c1\u2212c2 \u03b1\n\u03b1 + c1 , (4)\nwhere \u03b1 > 1 is the unique solution of the equation ln\u03b1 = c1/\u03b1 .\nThis result gives an estimation for the average number of answer sets for a random program. Before we prove Theorem 1, let us look at its application in predicting the consistency of a random program.\nFor a random program P and a set of atoms S, by eS we denote the (probabilistic) event that a given set of atoms is an answer set for P. We introduce the following property for random programs: (ASI) Given a random program P, Pr(eS|eS\u2032) = Pr(eS) for any two sets S and S\u2032 of atoms.\nThe \u2018I\u2019 in (ASI) is for \u2018Independence\u2019. Informally, the above property says that for any two sets of atoms S and S\u2032, the events eS and eS\u2032 are independent of each other. We remark that this property does not hold in general. For example, suppose S1 \u2282 S2 \u2282 An. If S1 is an answer set of P, then S2 must not be an answer set of P. This implies that eS1 and eS2 are actually not independent. However, when the set of atoms An is sufficiently large, by Theorem 1, the average number of answer sets will be relatively small compared to the number of all subsets of An. As a result, there will be a relatively small number of pairs S \u2286 An and S\u2032 \u2286 An with S 6= S\u2032 such that eS and eS\u2032 are not independent. Thus, when n is sufficiently large, the impact of dependency for answer sets will be not radical. Under the (ASI) assumption, we are able to derive an estimation for the probability that a random program has an answer set.\nProposition 5 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If (ASI) holds and n is sufficiently large, then\nPr(E(|AS(P)|> 0))\u2248 1\u2212 e\u2212E(|AS(P)|). (5)\nAs explained, (ASI) does not hold in realistic situation. Our experiments indeed show that there is a shift between the estimated probability determined by Eq.(5) and the actual probability. However, The experimental results suggest that this shift can be remedied by applying a factor \u03b3 of around 0.5 to E(|AS(P)|) in Eq.(5), see Section 4 for details. So, combining Theorem 1 and Proposition 5, we will be able to estimate the probability for the consistency of random programs.\nProof Let eS,k be the event that S\u2282 An is an answer set of size k for random program P. We first observe that by Eq.(3), lim\nn\u2192\u221e Pr(eS,k) = 0. Recall that AS(P,k) is the set of answer sets of size k for logic\nprogram P. If n is sufficiently large, then\nPr(E(|AS(P)|)> 0) = 1\u2212Pr(E(|AS(P)|) = 0) = 1\u2212 \u220f\n0<k<n Pr(E(|AS(P,k)|) = 0)\n= 1\u2212 \u220f 0<k<n\n[1\u2212Pr(eS,k)]( n k)\n= 1\u2212 \u220f 0<k<n\n[1\u2212Pr(eS,k)] 1 Pr(eS,k) \u00b7Pr(eS,k)\u00b7(nk)\n\u2248 1\u2212 \u220f 0<k<n\ne\u2212Pr(eS,k)\u00d7( n k), because lim\nx\u21920 (1\u2212 x)\n1 x = e\u22121\n= 1\u2212 \u220f 0<k<n\ne\u2212E(|AS(P,k)|)\n= 1\u2212 e\u2212\u22110<k<n E(|AS(P,k)|)\n= 1\u2212 e\u2212E(|AS(P)|).\nIn the rest of this section, we will present a formal proof of Theorem 1. Let us first outline a sketch for the proof. In order to prove Eq.(4), our first goal will be to show that E[|AS(P)|] is the sum of E[Nk]\u2019s for 0 < k < n.\nFor an integer k with 0 < k < n, we use AS(P,k) to denote the collection of answer sets of size k for program P, i.e., AS(P,k) = {S | S \u2208 AS(P), |S|= k}. Then the number Nk = |AS(P,k)| is a random variable. It is easy to see that the expected number of answer sets of size k for random program P is\nE[Nk] = (\nn k\n) Pr(k). (6)\nSo the expected (total) number of answer sets for P, denoted E[|AS(P)|], can be expressed as\nE[|AS(P)|] = n\u22121\n\u2211 k=1 E[Nk]. (7)\nNote that by Proposition 3, a random program generated under the linear model has neither answer sets of size 0 nor n. So, we can ignore the cases of k = 0 and k = n.\nOur next goal is, based on Eq.(7), to show that\nlim n\u2192\u221e E[|AS(P)|] = lim n\u2192\u221e \u222b n 1 \u03c6(x)dx. (8)\nwhere the function \u03c6(x) is defined by\n\u03c6(x) = \u221a\nn 2\u03c0x(n\u2212 x)\n( n(1\u2212qn\u2212x)\nx\n)x(nrqn\u2212x n\u2212 x )n\u2212x . (9)\nAt the same time, we are going to show that\nlim n\u2192\u221e \u222b n 1 \u03c6(x)dx = lim n\u2192\u221e \u222b \u221e \u2212\u221e \u03c7(x)dx, (10)\nwhere the function \u03c7(x) defined below is a normal distribution function multiplied by a constant. Thus, it follows from Eq.(8) and Eq.(10) that\nlim n\u2192\u221e E[|AS(P)|] = lim n\u2192\u221e \u222b \u221e \u2212\u221e \u03c7(x)dx.\nAs the above integral of \u03c7(x) is \u03b1e c1\u2212c2\n\u03b1 /(\u03b1+c1), which can be figured out easily, the conclusion of Theorem 1 will be proven.\nHere \u03b1 > 1 is the unique solution of the equation \u03b1\u03b1 = ec1 and \u03c7(x) is the normal distribution function\nNx0,\u03c3 (x) = 1\u221a 2\u03c0\u03c3 e\u2212\n(x\u2212x0) 2\n2\u03c32\nmultiplied by a constant \u221a 2\u03c0\u03c3\u03c6(x0):\n\u03c7(x) = (\u221a 2\u03c0\u03c3\u03c6(x0) ) Nx0,\u03c3 (x) = \u03c6(x0)e \u2212 (x\u2212x0) 2 2\u03c32 . (11)\nwhile x0 and \u03c3 are defined, respectively, as follows.\nx0 = (\u03b1\u22121)n\n\u03b1 . (12)\n\u03c3 = \u221a (\u03b1\u22121)n \u03b1 + c1 . (13)\nSome remarks are in order. As c1 > 0, if \u03b1\u03b1 = ec1 for some \u03b1 , it must be the case that \u03b1 > 1. On the other hand, if \u03b1 > 1, the function \u03b1\u03b1 is monotonically increasing and thus the equation \u03b1\u03b1 = ec1 must have a unique solution.\nMoreover, we define\nc0 = max(\n\u221a 2(\u03b1 + c1)\u221a\n\u03b1\u22121 ,\n1 \u221a\nc1 ). (14)\n\u2206 = c0 \u221a n lnn. (15)\nBefore providing the proof of Theorem 1, we first prove some technical results. The following result shows that \u03c6(k), as defined in Eq.(9), is indeed a tight approximation to\nE[Nk].\nProposition 6 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). Let E[Nk] be the expected number of answer sets of size k for P (0 < k < n). Then ,\n4\u03c02\ne2 \u03c6(k)\u2264 E[Nk]\u2264 e 2\u03c0 \u03c6(k). (16)\nE[Nk] = \u03c6(k) ( 1+O (\n1 min(k,n\u2212 k)\n)) . (17)\nProof Note that\nE[Nk] = (\nn k\n) Pr(k) =\nn! k!(n\u2212 k)! Pr(k).\nBy Proposition 4,\nE[Nk] = n!\nk!(n\u2212 k)! q(n\u2212k)(n\u2212k\u22121)(1\u2212qn\u2212k)k(1\u2212d)n\u2212k.\nLet r = (1\u2212d)/(1\u2212 p) = (1\u2212d)/q. Then\nE[Nk] = n!\nk!(n\u2212 k)! (qn\u2212kr)n\u2212k(1\u2212qn\u2212k)k.\nApplying Stirling\u2019s approximation to n!, k! and (n\u2212 k)!, and based on the two properties of Stirling\u2019s approximation presented in Section 5.2, Eq.(16) and Eq.(17) are obtained.\nBy Proposition 6, we can show the following result.\nProposition 7 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If E[Nk] and \u03c6(k) are defined as in Eq.(6) and Eq.(9, then\nlim n\u2192\u221e\nn\u22121 \u2211 k=1 E[Nk] = limn\u2192\u221e n\u22121 \u2211 k=1 \u03c6(k). (18)\nProof Let \u2206 be defined as in Eq.(15). Then\nn\u22121 \u2211 k=1 E(Nk) = bx0\u2212\u2206c \u2211 k=1 E(Nk)+ bx0+\u2206c\u22121 \u2211 k=bx0\u2212\u2206c+1 E(Nk)+ n\u22121 \u2211 k=bx0+\u2206c E(Nk).\nBy inequality (16),\nbx0\u2212\u2206c\n\u2211 k=1\nE(Nk)+ n\u22121\n\u2211 k=bx0+\u2206c\nE(Nk)\u2264 e\n2\u03c0\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k)+ n\u22121\n\u2211 k=bx0+\u2206c \u03c6(k)\n) .\nBy Lemma 6 (in Section 5.3),\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k)+ n\u22121\n\u2211 k=bx0+\u2206c \u03c6(k)\n) = 0.\nBased on Eq.(17), and the fact that both \u03c6(k) and E(Nk) are non-negative,\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\nE(Nk)+ n\u22121\n\u2211 k=bx0+\u2206c E(Nk)\n) =\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k) ( 1+O (\n1 min(k,n\u2212 k)\n)) + n\u22121\n\u2211 k=bx0+\u2206c\n\u03c6(k) ( 1+O (\n1 min(k,n\u2212 k)\n)))\n\u2264 lim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k)+ n\u22121\n\u2211 k=bx0+\u2206c \u03c6(k)\n) (1+O(1)) = 0.\nAs E(Nk)\u2265 0 for k \u2265 1, we have that\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\nE(Nk)+ n\u22121\n\u2211 k=bx0+\u2206c E(Nk)\n) = 0.\nBy Eq.(17),\nbx0+\u2206c\u22121\n\u2211 k=bx0\u2212\u2206c+1\nE(Nk) = bx0+\u2206c\u22121\n\u2211 k=bx0\u2212\u2206c+1\n( \u03c6(k) ( 1+O ( 1\nmin(k,n\u2212 k)\n)))\n=\n( bx0+\u2206c\u22121\n\u2211 k=bx0\u2212\u2206c+1 \u03c6(k)\n)( 1+O ( 1\nmin(x0\u2212\u2206,n\u2212 x0\u2212\u2206)\n)) .\nBy Eq.(12) and Eq.(15), we have that\nlim n\u2192\u221e min(x0\u2212\u2206,n\u2212 x0\u2212\u2206) = \u221e.\nSo\nlim n\u2192\u221e\nbx0+\u2206c\u22121\n\u2211 k=bx0\u2212\u2206c+1 E(Nk) = limn\u2192\u221e\nbx0+\u2206c\u22121\n\u2211 k=bx0\u2212\u2206c+1 \u03c6(k).\nTherefore, the conclusion is proved.\nThe next result shows that the integral of \u03c6(x) can be obtained through the integral of \u03c7(x), which is useful as the integral of \u03c7(x) can be easily figured out.\nProposition 8 Let P be a random program on a set An of n atoms, generated under L(N2,c1,c2), with n > max(c1,c2). If the continuous functions \u03c6(x) and \u03c7(x) are defined as in Eq.(9) and Eq.(11), then\nlim n\u2192\u221e \u222b n 1 \u03c6(x)dx = lim n\u2192\u221e \u222b \u2212\u221e \u221e \u03c7(x)dx. (19)\nProof Let \u2206 = c0 \u221a n lnn be defined as in Eq.(15). By Lemma 6, it follows that\nlim n\u2192\u221e (\u222b x0\u2212\u2206 1 \u03c6(x)dx+ \u222b n x0+\u2206 \u03c6(x)dx ) = 0.\nBy Lemma 8 and Lemma 9, Eq.(19) holds.\nNow we are ready to present the proof of Theorem 1, a main result in this paper,\nProof of Theorem 1 Given a random program P, the expected total number of answer sets for P is\nE[|AS(P)|] = n\u22121\n\u2211 k=1 E[Nk].\nBy Proposition 7 and Proposition 8,\nlim n\u2192\u221e E[|AS(P)|] = lim n\u2192\u221e\nn\u22121 \u2211 k=1 E[Nk] = limn\u2192\u221e n\u22121 \u2211 k=1 \u03c6(k)\n= lim n\u2192\u221e \u222b n 1 \u03c6(x)dx = lim n\u2192\u221e \u222b \u221e \u2212\u221e \u03c7(x)dx.\nThen\nlim n\u2192\u221e \u222b \u221e \u2212\u221e \u03c7(x)dx = lim n\u2192\u221e \u221a 2\u03c0\u03c3\u03c6(x0) = \u03b1e c1\u2212c2 \u03b1 \u03b1 + c1 .\nTherefore,\nlim n\u2192\u221e\nE[|AS(P)|] = \u03b1e c1\u2212c2 \u03b1\n\u03b1 + c1 ."}, {"heading": "4 Experimental Results", "text": "In this section, we describe some experimental results about the average number of answer sets, the size distribution of answer sets, and the probability of consistency for random programs under the linear model. For the average number of answer sets, our experimental results closely match the theoretical results obtained in Section 3.\nTo conduct the experiments, we have developed a software tool to generate random logic programs, which is able to randomly generate logic programs based on the user-input parameters, such as the type of programs, the number of atoms, the number of literals in a rule, the number of rules in a program and the number of programs in a test set etc. After a set of random programs are generated, the tool invokes an ASP solver to compute the answer sets of the random programs, records the test results in a file, and analyses them. The experimental results in this section were based on the ASP solver clasp (Gebser et al. 2009), but same patterns were obtained for test cases on which dlv (Leone et al. 2006) and smodels (Syrja\u0308nen and Niemela\u0308 2001) were also used.\nWe have conducted a significant number of experiments to corroborate the theoretical results obtained in Section 3 including Theorem 1. In order to get a feel for how quickly the experimental distribution converges to the theoretical one, we tested the difference rate of these two values for varied numbers of atoms. The experimental results show that the theorem can be used to predict practical situations. Some other statistical properties of random programs generated under the linear model were also experimented, such as the size distribution of answer sets. Positive results are received for nearly all of our experiments. In this section, we report the results from two of our experiments. In the first experiment, we set c2 = 0, which means there are no contradiction rules in the programs. In the second experiment, we set c2 from 0 to 20 to test the impact of contradiction rules on the random programs."}, {"heading": "4.1 Experiment 1: Random Programs without contradiction rules", "text": "In this experiment, c1 = 5, c2 = 0, and n varies with values 50,100,150, ...,500, respectively. For each of these values of n, 5,000 logic programs were randomly and independently generated under the linear model.\nGiven that c1 = 5 and \u03b1 > 1 is determined by \u03b1\u03b1 = ec1 , we have that \u03b1 \u2248 3.7687. Thus, by Eq.(4), it follows that E(|AS(P)|)\u2248 1.6274.\nWe use NAvg to denote the average number of answer sets for the 5,000 programs in each test generated under the linear model. The (experimental) values for NAvg and their corresponding theoretical values (i.e., the expected number E[Nk] of answer sets for random programs determined by Eq.(4)) are listed in Table 1. The experimental and theoretical results are visualized in Figure 1. We can see that these two values are very close even if n is relatively small.\nAnother important result obtained from this experiment is about the size distribution of answer sets for random programs. Specifically, the experiment supports a conjecture that the distribution of the average size of answer sets for random programs obeys a normal distribution.\nThe experimental result can be easily seen by comparing the following three types of values for 0 \u2264 k \u2264 n, which are visualized as three curves in Figure 2 and Figure 3 with n = 50 and n = 400 respectively. Average number of answer sets for the 5,000 programs randomly generated in each test (referred to as \u2018Experiment Result\u2019 in Figure 2 and Figure 3): We took n = 50,100, ...,500, respectively, and for each of these values of n, we randomly generated 5,000 programs under the linear model. For each k (0 \u2264 k \u2264 n), we calculated the average number of answer sets of size k for these programs, i.e., the ratio of the total number of answer sets of size k for all these programs divided by 5,000. Expected number of answer sets for random programs under the linear model (referred to as \u2018The Model\u2019 in Figure 2 and Figure 3): In order to compare the experimental values with their theoretical counterparts, for each 0\u2264 k\u2264 n, we calculated the expected number E[Nk] of answer sets of size k for random programs under the linear model. Normal Distribution function: The above two types of values were also compared with the function \u03c7(x) defined by Eq.(11), which is actually the normal distribution function N (x0,\u03c3) multiplied by a constant.\nFigure 2 and Figure 3 show that even for relatively small values of n, the theoretical results are still very close to the experimental results. In order to see how quickly the experimental distribution converges to the theoretical one, we consider the rate variance function D: For two discrete functions f and g on the interval [1,n\u22121] with f (k)> 0 (1\u2264 k \u2264 n\u22121), we define\nD( f ,g) = \u2211n\u22121k=1( f (k)\u2212g(k)) 2\n\u2211n\u22121k=1 f (k)2 .\nClearly, the closer f and g, the smaller D( f ,g), and vice versa. The function D( f ,g) is often used in measuring the gap between two discrete functions f and g. If we take f as the normal distribution function and g as the experimental distribution function (i.e., the average size of answer sets\nbased on the 5,000 programs randomly generated in each test). The resulting rate variance function is depicted in Figure 4. This diagram shows that, as n increases, the rate variance gradually decreases. It also shows that the rate variance is very small even when n = 50. This experimental result further suggests the conjecture that the size distribution of answer sets obeys a normal distribution."}, {"heading": "4.2 Experiment 2: Random Programs with contradiction rules", "text": "In this experiment, we tested random programs that may contain contradiction rules and obtained similar experimental results as in the first experiment. We set c1 = 10, n = 200, and c2 = 0,1,2, ...,20, respectively. For each value of c2, 5,000 programs were independently generated under the linear model.\nGiven c1 = 10, it follows by Eq.(12) and Eq.(13) that \u03b1 \u2248 5.7289, x0 \u2248 165.0894, and \u03c3 \u2248 1.9552. The value \u03c6(x0), which depends on c2, decreases roughly from 0.4257 (when c2 = 0) to 0.01297 (when c2 = 20).\nOn the other hand, based on Eq.(4), we can figure out the expected number of answer sets for each c2.\nThese two types of values are visualized as two curves in Figure 5. It shows that these two curves are very close to each other, which means our theoretical result on size distribution of answer sets is corroborated by the experimental result.\nSimilar to the first experiment, the size distribution of answer sets was also investigated experimentally. In this case, we took c2 = 4 and three types of values were obtained (shown in Figure 6). There is a slight shift between the linear model and the normal distribution. We expect that when the number n is sufficiently large, this shift will become narrower. For example, when n increases from 200 to 400, the shift is significantly reduced."}, {"heading": "4.3 Experiment 3: Approximating the probability for consistency of random programs", "text": "In this subsection we present our experimental results on verifying the formula for predicting consistency of random programs (discussed in Section 3):\nPr(E(|AS(P)|> 0))\u2248 1\u2212 e\u2212\u03b3\u00b7E(|AS(P)|). (20)\nHere \u03b3 is a constant around 0.5 (i.e. independent of n). We tested various pairs of c1 and c2. For each such pair, we took n = 100,150,200, ...,1000. Then for each value of n, we computed the\nvalue determined by Eq.(20). For each value of n, we generated 5,000 programs randomly and computed the ratio of consistent programs to all 5,000 programs.\nOur experimental results corroborate the estimation in Eq.(20). So this formula can be used to predict the consistency of random programs generated under the linear model. The corresponding values for two cases we tested are depicted in Figures 7 and 8. In each figure, the upper curve is for the value determined by Eq.(5), the middle curve is for the ratio of consistent programs to all 5,000 programs randomly generated, and the lower curve is for the value determined by Eq.(20)."}, {"heading": "5 Conclusion", "text": "We have proposed a new model of randomly generating logic programs under answer set semantics, called linear model. The average size of a random program generated in this way is linear to the total number of atoms. We have proved some mathematical results and the main result shows that the expected number of answer sets of random programs under the linear model converges to a constant that is determined by the probabilities of both pure rules and constraints. The formal proof of this result is mathematically involving as we have seen. The main result is further corroborated by our experiments. Another important experimental result reveals that the (size) distribution of answer sets for random programs generated under the linear model obeys a normal distribution.\nThere are several issues for future work. First, it would be interesting to mathematically prove some results presented in Section 4. Second, it would be both interesting and useful to study phase transition phenomena for hardness. In this case, a new model for random programs may need to be designed based on an algorithm for ASP computation (for SAT and CSP, DPLL is often used for studying the hardness of random problems). Last, while the class of negative twoliteral programs is of importance, it would be interesting to study properties of random logic\nprograms that are more general than negative two-literal programs, such as the program classes discussed in (Janhunen 2006; Lonc and Truszczynski 2002). However, it is not straightforward to carry over our proofs to those program classes. For instance, Proposition 4 may not hold for arbitrary two-literal programs."}, {"heading": "Acknowledgement", "text": "The authors would like to thank the editor Michael Gelfond and three anonymous referees for their constructive comments, which helped significantly improve the quality of the paper. Thanks to Fangzhen Lin and Yi-Dong Shen for discussions on this topic. This work was supported by the Australian Research Council (ARC) under grants DP1093652 and DP130102302.\nAppendix"}, {"heading": "5.1 Proofs for Section 2", "text": "Proposition 1 Each normal logic program P is equivalent to a negative two-literal program under answer set semantics.\nProof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005). So, without loss of generality, we assume that P is a negative normal program.\nNext, we show that each negative normal program P can be transformed into a logic program that consists of only two-literal rules and fact rules. In fact, we can define the translation as follows.\nFor each rule R in P of the form a\u2190 not c1, . . . ,not cn (n\u2265 0), R is replaced with the following n+1 rules:\na\u2190 not eR. eR\u2190 c1. . . . . . . eR\u2190 cn. Here eR is a new atom introduced for the rule R. The resulting logic program, denoted simple(P), is exactly a logic program that consists of only two-literal rules and fact rules. We use EP to denote the set of new atoms eR introduced above, that is, EP = {eR | R \u2208 P}.\nNote that, by applying unfolding transformation, simple(P) can be easily transformed into a logic program that consists of only negative two-literal rules and fact rules. As explained in Section 2, each rule can be expressed as a negative two-literal rule by introducing a new atom. Thus, simple(P) is equivalent to a negative two-literal program under answer set semantics.\nSo, it is sufficient to show that simple(P) and P are indeed equivalent under answer set semantics. (1) Let S be an answer set of P. Take Se = {eR \u2208 EP | R \u2208 P,body\u2212(R)\u2229S 6= /0}. Then we show that S\u2032 = S\u222aSe is an answer set of P\u2032. It suffices to prove that S\u2032 is a minimal model of (P\u2032)S \u2032 .\nBy the definition of Se, S\u2032 is a model of (P\u2032)S \u2032 .\nWe need only to show that S\u2032 is minimal. Assume that there exists T \u2032 such that T \u2032 \u2286 S\u2032 and T \u2032 is also a model of (P\u2032)S \u2032 . Let T = T \u2032 \\EP. Then T is a model of PS. To see this, for each rule R of the form a\u2190 not c1, . . . ,not ct such that ci 6\u2208 S for i = 1, . . . , t, if a 6\u2208 T , then a 6\u2208 T \u2032. Thus eR \u2208 T \u2032 by T \u2032 |= R, which implies that ci \u2208 T \u2032 for some i (1\u2264 i\u2264 n). So we have ci \u2208 T , that is, T |= R. By the minimality of S, T = S.\nAlso, if eR \u2208 S\u2032, then ci \u2208 S for some i (1 \u2264 i \u2264 n). This means ci \u2208 T because S = T , which implies that eR \u2208 T \u2032. Therefore, T \u2032 = S\u2032. (2) If S\u2032 is an answer set of P\u2032, we want to show that S = S\u2032 \\EP is an answer set of P.\nS |= PS: for each rule R of the form a\u2190 not c1, . . . ,not cn, if R+ \u2208 PS, then {c1, . . . ,cn}\u2229S = /0, which implies that eR 6\u2208 S\u2032. Thus R+ = (a\u2190 not eR)+ \u2208 (P\u2032)S \u2032 . By the assumption, a \u2208 S\u2032, that is, a \u2208 S. Thus S |= R+. S is a minimal model of PS: Suppose that T \u2286 S and T |= PS. Take T \u2032 = T \u222a Se where Se = {eR \u2208 EP | body\u2212(R)\u2229S 6= /0}. We first show that T \u2032 |= (P\u2032)S \u2032 .\nLet R\u2032 \u2208 P\u2032 with (R\u2032)+ \u2208 (P\u2032)S\u2032 . Consider two possible cases: Case 1. R\u2032 is of the form a\u2190 not eR: Then eR 6\u2208 S\u2032. By T \u2032 \u2286 S\u2032, eR 6\u2208 T \u2032. Then {c1, . . . ,cn}\u2229S = /0. This means R+ \u2208 PS. Since T |= PS, we have a \u2208 T . Thus T \u2032 |= (R\u2032)+. Case 2. R\u2032 is of the form eR\u2190 ci where 1\u2264 i\u2264 n: If ci \u2208 T \u2032, then ci \u2208 S. By this rule, eR \u2208 S\u2032 or eR \u2208 Se. Thus eR \u2208 T \u2032. Again, we have T \u2032 |= (R\u2032)+.\nTherefore, T \u2032 |= (P\u2032)S\u2032 . By the minimality of S\u2032, T \u2032 = S\u2032, which implies T = S. Thus S is a minimal model of PS.\nSo, we conclude the proof.\nProposition 2 Let P be a negative two-literal program on An containing at least one rule. Then S is an answer set of P iff the following two conditions are satisfied:\n1. If b1,b2 \u2208 An \\S, then b1\u2190 not b2 is not a rule in P. 2. If a \u2208 S, then there exists b \u2208 An \\S such that a\u2190 not b is a rule in P.\nProof \u21d2: Let S be an answer set of P.\nTo prove condition 1, suppose that b1\u2190 not b2 is a rule in P and b2 \u2208An\\S. Then the rule b1\u2190 is in PS. This implies that b1 \u2208 S, which is in contradiction to b1 \u2208 An \\S. Therefore, b1\u2190 not b2 cannot be a rule in P if b1,b2 \u2208 An \\S.\nFor condition 2, if a \u2208 S, P contains at least one rule with the head a. On the contrary, suppose that there does not exist any b \u2208 An \\ S such that a\u2190 not b is in P. Then for every rule of the form a\u2190 not b in P, we would have b \u2208 S, which implies the reduct PS would contain no rules whose head is a. Therefore, a 6\u2208 S, a contradiction. Therefore, there must exist an atom b \u2208 An \\S such that a\u2190 not b is in P. \u21d0: Assume that S \u2286 An satisfies the above two conditions 1 and 2. We want show that S is an answer set.\nS |= PS: If R: a\u2190 not c is a rule of P such that R+ \u2208 PS, then c 6\u2208 S. By condition 1, a \u2208 S. This means that every rule of PS is satisfied by S. Thus, S |= PS.\nS is a minimal model of PS: By condition 2, for each a \u2208 S, there exists a rule a\u2190 not b such that b 6\u2208 S. Then the rule a\u2190 is in PS, which implies that every model of PS must contain a. This implies that every model of PS is a superset of S. Therefore, S is minimal (actually the least model of PS).\nProposition 3 Let P be a negative two-literal program on An containing at least one rule. If S is an answer set of P, then 0 < |S|< n. Here |S| is the number of elements in S.\nProof If |S| = 0, then S = /0. Since P contains at least one rule, we assume that a\u2190 not b is in P. By S = /0, a 6\u2208 S. Then it would be the case that b \u2208 S, which is a contradiction to S = /0. Therefore, |S|> 0.\nIf |S| 6= 0, i.e. S 6= /0, then there exists an element a \u2208 S. By the definition of answer sets, the rule a\u2190 not b must be in P for some b 6\u2208 S. This implies that S must be a proper subset of An."}, {"heading": "5.2 Basics of mathematical analysis", "text": "In this subsection, we briefly recall some basics of mathematical analysis and notation that are used in related proofs.\n1. Big O notation: let f (x), g(x), h(x) be three real functions. By f (x) = g(x)+O(h(x)), we mean that | f (x)\u2212g(x)|= O(h(x)). That is, there exists a positive real number c and a real number x0 such that for all x > x0.\n| f (x)\u2212g(x)| \u2264 c|h(x)|.\nThe same notation is also applicable to discrete functions. 2. Stirling\u2019s approximation: for all integer n > 0\n1\u2264 n! e\u2212nnn \u221a 2n\u03c0 \u2264 e\u221a 2\u03c0 , (21)\nn! = e\u2212nnn \u221a 2n\u03c0(1+O( 1 n )). (22)\n3. Taylor series: Let f (x) be an infinitely differentiable real function on R, x0 \u2208 R is a real number, then for all x \u2208 R,\nf (x) = \u221e\n\u2211 i=0 f (i)(x0) i! (x\u2212 x0)i. (23)\nHere f (i)(x0) denotes the i-th derivative of f at x0 (i\u2265 0). In particular, f (0)(x) = f (x). 4. Properties of the natural exponential function:\nlim x\u21920\n(1+ x) 1 x = e. (24)\n(1+ x)\u2264 ex , and the equatility holds iff x = 0. (25) For all n \u2208 N, (\n1+ 1 n\n)n = e+O ( 1 n ) . (26)\n5. Properties of the logarithmic function:\nlim x\u21920 ln(1+ x) x = 1 (27)\nif x > 0, ln(1+ x)< x.\n6. Concave functions: A real function f is said to be concave if, for any x,y \u2208 R and for any t in [0,1],\nf (tx+(1\u2212 t)y)\u2265 t f (x)+(1\u2212 t) f (y). Let f (x) be a continuously differentiable function.\n(a) If f \u2032\u2032(x) is negative for all x \u2208 R, then f (x) is a concave function. (b) For x0 \u2208 R, if f (x) is concave and f \u2032(x0) = 0, then f (x) reaches its apex at x0. (c) If f (x) is concave and reaches its apex at x0, then g(x) = e f (x) is strictly monotoni-\ncally increasing when x < x0 and strictly monotonically decreasing when x > x0.\n7. The complementary error function erfc(x) is defined by\nerfc(x) = 2\u221a \u03c0 \u222b \u221e x e\u2212t 2 dt, (28)\nwhich has the following property:\nlim x\u2192\u221e erfc(x) = 0. (29)"}, {"heading": "5.3 Lemmas", "text": "Recall that \u03c6(x), x0 and \u03c3 have been defined in Eq.(9), Eq.(12), and Eq.(13), respectively. We first define three real functions as follows.\n\u03c8(x) = ln(\u03c6(x))\u2212 ln(\u03c6(x0)). (30)\n\u03be (x) = ln(\u03c7(x))\u2212 ln(\u03c6(x0)) =\u2212 (x\u2212 x0)2\n2\u03c32 . (31)\n\u03ba(x) = 1\u2212qn\u2212x. (32)\nThen\n\u03c6(x) = \u03c6(x0)e\u03c8(x),\nand\n\u03c7(x) = \u03c6(x0)e\u03be (x).\nAccording to Taylor series:\nln(1+ x) = 0+ x\u2212 x 2\n2 +\nx3 3 \u2212 ...\nWe have\nlnq = ln(1\u2212 c1 n ) =\u2212c1 n \u2212 c 2 1 2n2 +O ( 1 n3 ) =\u2212c1 n +O ( 1 n2 ) = O ( 1 n ) . (33)\nLemma 1\nqn\u2212x0 = 1 \u03b1 \u2212 c 2 1 2\u03b12n +O ( 1 n2 ) . (34)\n\u03ba(x0) = \u03b1\u22121\n\u03b1 + c21 2\u03b12n\n+O (\n1 n2\n) . (35)\nProof By Eq.(12) and Eq.(33),\n(n\u2212 x0) lnq = n \u03b1\n[ \u2212c1\nn \u2212 c 2 1 2n2 +O ( 1 n3 )] =\u2212c1 \u03b1 \u2212 c 2 1 2n\u03b1 +O ( 1 n2 ) .\nThen\nqn\u2212x0 = e\u2212 c1 \u03b1 e\u2212 c21 2n\u03b1 eO\n( 1\nn2 ) .\nAs \u03b1 > 1 satisfies the equation \u03b1\u03b1 = ec1 , we can show that\ne\u2212 c1 \u03b1 = 1 \u03b1 .\nNote that\nex = 1+ x+ 1\n2x2 + ...\nthen,\nqn\u2212x0 = 1 \u03b1\n[ 1\u2212 c 2 1\n2n\u03b1 +O ( 1 n2 )][ 1+O ( 1 n2 )] =\n1 \u03b1 \u2212 c 2 1 2\u03b12n +O ( 1 n2 ) . Based on the definition of \u03ba(x) in Eq.(32),\n\u03ba(x0) = 1\u2212qn\u2212x0 = \u03b1\u22121\n\u03b1 + c21 2\u03b12n\n+O (\n1 n2\n) .\nRemark: lnq and \u03ba(x0) can be simplified into\nlnq =\u2212c1 n +O ( 1 n2 ) = O ( 1 n ) ,\nand\n\u03ba(x0) = \u03b1\u22121\n\u03b1 +O ( 1 n ) = O(1).\nLemma 2 When n is sufficiently large,\n\u03c8 \u2032(1)> 0. (36)\n\u03c8 \u2032(n\u22121)< 0. (37) \u03c8 \u2032(x0) = O (\n1 n\n) . (38)\nProof From the definitions of \u03c8(x) in Eq.(30) and \u03c6(x) in Eq.(9), it follows that\n\u03c8 \u2032(x) = 1 2 ( 1 n\u2212 x \u2212 1 x )+ ln n\u2212 x x\n\u2212 (2n\u22122x) lnq+ ln(1\u2212qn\u2212x) + x\n1\u2212qn\u2212x \u00d7qn\u2212x lnq\u2212 lnr.\n(39)\nTake x = 1 in Eq.(39), we can see that the second term is ln(n\u22121) and all the other terms are of the order O(1). So, when n is sufficiently large,\n\u03c8 \u2032(1) = ln(n\u22121)+O(1)> 0.\nTake x = n\u22121 in Eq.(39), the most significant term is the fifth one. By Eq.(33), the fifth term can be simplified as follows.\nn\u22121 1\u2212qn\u2212(n\u22121) \u00d7qn\u2212(n\u22121) lnq =\u2212 (n\u22121)(n\u2212 c1) n +O(1)\nand the other terms are of the order O(ln(n)) or less. So, when n is sufficient large,\n\u03c8 \u2032(n\u22121) =\u2212 (n\u22121)(n\u2212 c1) n +O(lnn)< 0.\nFinally, take x = x0 = (\u03b1\u22121)n \u03b1 in Eq.(39), the first term is of the order O ( 1 n ) . The other five terms can be simplified correspondingly into\nln n\u2212 x0\nx0 =\u2212 ln(\u03b1\u22121),\n\u2212(2n\u22122x0) lnq = 2c1 \u03b1\n+O (\n1 n\n) ,\nln(1\u2212qn\u2212x0) = ln\u03ba(x) = ln(\u03b1\u22121)\u2212 ln\u03b1 +O (\n1 n\n) ,\nx0 1\u2212qn\u2212x0 \u00d7qn\u2212x0 lnq =\u2212c1 \u03b1\n+O (\n1 n\n) ,\nRandom Logic Programs: Linear Model 25\n\u2212 ln(r) =\u2212 ln 1\u2212d 1\u2212 p =\u2212 ln n\u2212 c2 n\u2212 c1 =\u2212 ln(1+ c1\u2212 c2 n\u2212 c1\n) = O (\n1 n\n) .\nThen\n\u03c8 \u2032(x0) = c1 \u03b1 \u2212 ln\u03b1 +O ( 1 n ) .\nSince \u03b1 > 1 satisfies the equation \u03b1\u03b1 = ec1 , we have that c1 \u03b1 \u2212 ln\u03b1 = 0.\nThus,\n\u03c8 \u2032(x0) = O (\n1 n\n) .\nLemma 3 If 1\u2264 x\u2264 n\u22121, then\n\u03c8 \u2032\u2032(x)< 2lnq < 0, (40)\n\u03c8 \u2032\u2032(x0) =\u2212 1\n\u03c32 +O ( 1 n2 ) (41)\nwhere \u03c3 is defined in Eq.(13).\nProof By Eq.(39),\n\u03c8 \u2032\u2032(x) = 1 2x2 \u2212 1 x \u2212 1 n\u2212 x + 1 2(n\u2212 x)2\n+2lnq+ qn\u2212x lnq 1\u2212qn\u2212x + (1\u2212qn\u2212x)(qn\u2212x\u2212 xqn\u2212x lnq)\u2212 xq2(n\u2212x) lnq\n(1\u2212qn\u2212x)2 \u00d7 lnq.\nThen it can be further simplified to\n\u03c8 \u2032\u2032(x) = 1 2x2 \u2212 1 x \u2212 1 n\u2212 x + 1 2(n\u2212 x)2\n+ 2lnq \u03ba(x) +( 1 \u03ba(x) \u2212 1 \u03ba(x)2 )x ln2 q.\n(42)\nFrom 1\u2264 x\u2264 n\u22121, we have that 1\n2x2 \u2212 1 x \u2212 1 n\u2212 x + 1 2(n\u2212 x)2 < 0.\nAs \u03ba(x) = 1\u2212qn\u2212x, so 0 < \u03ba(x)< 1, then( 1\n\u03ba(x) \u2212 1 \u03ba(x)2\n) x ln2 q < 0.\nSo\n\u03c8 \u2032\u2032(x)< 2lnq \u03ba(x) < 2lnq < 0.\nTake x = x0 = (\u03b1\u22121)n\n\u03b1 in Eq.(42) and split the formula into three partsas follows. Then by Eq.(33) and Lemma 1,\n1 2x20 \u2212 1 x0 \u2212 1 n\u2212 x0 + 1 2(n\u2212 x0)2 =\u2212 \u03b1 2 (\u03b1\u22121)n +O ( 1 n2 ) ,\n2lnq \u03ba(x0) =\u2212 2\u03b1c1 (\u03b1\u22121)n\n+O (\n1 n2\n) ,\n( 1 \u03ba(x0) \u2212 1 \u03ba(x0)2 )x0 ln2 q =\u2212 c21 (\u03b1\u22121)n\n+O (\n1 n2\n) .\nCombining the three parts above together and by the definition of \u03c3 in Eq.(13),\n\u03c8 \u2032\u2032(x0) =\u2212 \u03b12 +2\u03b1c1 + c21\n(\u03b1\u22121)n +O ( 1 n2 ) =\u2212 1 \u03c32 +O ( 1 n2 ) .\nLemma 4 For all i > 2, the i-th derivative of \u03c8(x) at x0 satisfies\n\u03c8(i)(x0) = O (\n1 ni\u22121\n) . (43)\nProof By the definition of \u03ba(x) in Eq.(32), for i > 2, we have that\n\u03ba(i)(x) = (\u22121)(i+1)qn\u2212x(lnq)i.\nTake x = x0, by Eq.(33) and Lemma 1, the formula above can be simplified to \u03ba(i)(x0) = O (\n1 ni\n) . (44)\nDefine\n\u03c81(x) = 1 2x2 \u2212 1 x \u2212 1 n\u2212 x + 1 2(n\u2212 x)2 ,\n\u03c82(x) = 2lnq \u03ba(x) ,\n\u03c83(x) = (\n1 \u03ba(x) \u2212 1 \u03ba(x)2\n) x ln2 q.\nBy Eq.(42), \u03c8 \u2032\u2032(x) = \u03c81(x)+\u03c82(x)+\u03c83(x). Thus\n\u03c8(i)(x) = \u03c8(i\u22122)1 (x)+\u03c8 (i\u22122) 2 (x)+\u03c8 (i\u22122) 3 (x).\nAs x0 = O(n), we have that\n\u03c8(i\u22122)1 (x0) = O ( 1 ni\u22121 ) . (45)\nThen\n\u03c82(x) = 2lnq(\u03ba(x))\u22121 ,\n\u03c8 \u20322(x) = 2lnq ( \u2212\u03ba(x)\u22122\u03ba \u2032(x) ) ,\n\u03c8 \u2032\u20322 (x) = 2lnq ( 2\u03ba(x)\u22123\u03ba \u2032(x)2\u2212\u03ba(x)\u22122\u03ba \u2032\u2032(x) ) ,\n\u03c8 \u2032\u2032\u20322 (x) = 2lnq ( \u22126\u03ba(x)\u22124\u03ba \u2032(x)3 +6\u03ba(x)\u22123\u03ba \u2032(x)\u03ba \u2032\u2032(x).\u2212\u03ba(x)\u22122\u03ba \u2032\u2032\u2032(x) ) .\nIn general, for i > 2, it holds that\n\u03c8(i\u22122)2 (x) = 2lnq\u2211 j \u039bi, j(x)\nwhere\n\u039bi, j(x) = ci, j\u03ba(x)\u2212 j \u220f s (\u03ba(is)(x))ts ,\nci, j is a constant determined by i and j, and\n\u2211 s is\u00d7 ts = i\u22122.\nThen by Eq.(44), we know that\n\u039bi, j(x0) = O (\n1 ni\u22122\n) .\nSince lnq = O ( 1\nn\n) ,\n\u03c8(i\u22122)2 (x0) = O ( 1 ni\u22121 ) .\nSimilarly, we can show that\n\u03c8(i\u22122)3 (x0) = O ( 1 ni\u22121 ) .\nTherefore,\n\u03c8(i)(x0) = \u03c8 (i\u22122) 1 (x0)+\u03c8 (i\u22122) 2 (x0)+\u03c8 (i\u22122) 3 (x0) = O\n( 1\nni\u22121\n) .\nLemma 5\n\u03c6(x0) = \u03b1e c1\u2212c2 \u03b1\u221a\n2\u03c0(\u03b1\u22121)n +O(n\u2212 3 2 ). (46)\nProof By the definition of \u03c6(x) and x0 in Eq.(9) and Eq.(12),\n\u03c6(x0) = \u221a\nn 2\u03c0x0(n\u2212 x0)\n( n(1\u2212qn\u2212x0)\nx0\n)x0(nrqn\u2212x0 n\u2212 x0 )n\u2212x0 = \u221a \u03b12\n2\u03c0(\u03b1\u22121)n\n( \u03ba(x0)\n\u03b1\u22121 \u03b1\n) \u03b1\u22121 \u03b1 n (\nrqn\u2212x0 1 \u03b1\n) n \u03b1\n.\nBy Lemma 1,\n\u03c6(x0)=\n\u221a \u03b12\n2\u03c0(\u03b1\u22121)n\n( 1+\nc21 2\u03b1(\u03b1\u22121)n\n+O (\n1 n2\n)) \u03b1\u22121 \u03b1 n((\n1\u2212 c2\u2212 c1 n\u2212 c1\n)( 1\u2212 c 2 1\n2\u03b1n +O ( 1 n2 ))) n \u03b1 .\nThen Eq.(26), the above equation can be further simplified as follows:\n\u03c6(x0) =\n\u221a \u03b12\n2\u03c0(\u03b1\u22121)n\n( e c21 2\u03b12 +O ( 1 n ))( e\u2212 c21 2\u03b12 + c1\u2212c2 \u03b1 +O ( 1 n ))\n= \u03b1e c1\u2212c2 \u03b1\u221a\n2\u03c0(\u03b1\u22121)n +O(n\u2212 3 2 ).\nLemma 6 Let \u2206 = c0 \u221a n lnn as defined in Eq.(15), where c0 is defined in Eq.(14). Then\nlim n\u2192\u221e (\u222b x0\u2212\u2206 1 \u03c6(x)dx+ \u222b n\u22121 x0+\u2206 \u03c6(x)dx ) = 0,\nand\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k)+ n\u22121\n\u2211 k=bx0+\u2206c \u03c6(k)\n) = 0.\nProof By the definition of \u03c8(x), we have\n\u03c6(x) = \u03c6(x0)e\u03c8(x).\nBy Lemma 2 and Lemma 3, for all x \u2208 [1,n\u22121],\n\u03c8 \u2032\u2032(x)< 2lnq =\u22122c1 n +O( 1 n2 ).\nThen the Taylor series for \u03c8 at x \u2208 [1,n\u22121] is\n\u03c8(x)\u2264 \u03c8(x0)+(x\u2212 x0)\u03c8 \u2032(x0)+ 1 2 (x\u2212 x0)2 max(\u03c8 \u2032\u2032(x)).\nAs x < n, so\n\u03c8(x)\u2264\u2212c1 n (x\u2212 x0)2 +O(1).\nWe note that the function \u2212 c1n (x\u2212 x0) 2 is an upper bound for \u03c8(x), which is strictly increasing when x < x0 and strictly decreasing when x > x0. Thus,\u222b x0\u2212\u2206 1 \u03c6(x)dx+ \u222b n\u22121 x0+\u2206 \u03c6(x)dx\u2264 \u222b x0\u2212\u2206 1 \u03c6(x0\u2212\u2206)dx+ \u222b n\u22121 x0+\u2206 \u03c6(x0 +\u2206)dx\n\u2264 \u03c6(x0)ne\u2212 lnn+O(1) = O(\u03c6(x0)).\nBy Lemma 5,\n\u03c6(x0) = \u03b1e c1\u2212c2 \u03b1\u221a\n2\u03c0(\u03b1\u22121)n +O\n( n\u2212 3 2 ) = O ( 1\u221a n ) .\nSo,\nlim n\u2192\u221e (\u222b x0\u2212\u2206 1 \u03c6(x)dx+ \u222b n\u22121 x0+\u2206 \u03c6(x)dx ) \u2264 0.\nFrom \u03c6(x)\u2265 0, it follows that\nlim n\u2192\u221e (\u222b x0\u2212\u2206 1 \u03c6(x)dx+ \u222b n\u22121 x0+\u2206 \u03c6(x)dx ) = 0.\nThus,\nlim n\u2192\u221e\n( bx0\u2212\u2206c\n\u2211 k=1\n\u03c6(k)+ n\u22121\n\u2211 k=bx0+\u2206c \u03c6(k)\n) = 0.\nThe next lemma is a basic property of integral. We present it here for reader\u2019s reference.\nLemma 7 Let the function \u03c6 be defined as in Eq.(9). Then\nlim n\u2192\u221e\nn\u22121 \u2211 k=1 \u03c6(k) = lim n\u2192\u221e \u222b n 1 \u03c6(x)dx. (47)\nProof By Lemma 3, \u03c8 \u2032\u2032(x) < 0 when x \u2208 [1,n\u2212 1]. We know that \u03c8(x) is a concave function in the range. Also, by Lemma 2, \u03c8 \u2032(1) > 0 and \u03c8 \u2032(n\u2212 1) < 0, which mean there exists a unique x\u0302 \u2208 (1,n\u22121) such that \u03c8(x) reaches its apex at x\u0302. As \u03c6(x) = \u03c6(x0)e\u03c8(x) and it is a concave function, \u03c6(x) is strictly increasing for x \u2208 (1, x\u0302) and strictly decreasing for x \u2208 (x\u0302,n\u22121).\nTo compare the difference between the integral and the sum of the discrete values, we use Figure 9 as an example. The curve reaches its maximum at x\u0302 which is larger than 3 and smaller than 4. Clearly, from Figure 9(a), it is difficult to compare the integral and the sum of the discrete values. However, if we remove the tallest bar, which is \u03c6(3) and shift all the bars right of it leftward one step, then clearly (as shown in Figure 9(b)) the sum of the discrete values is smaller than the integral of the curve. If we insert the bar of \u03c6(x\u0302) at the left of the bar of the smallest number which is larger than x\u0302, (in this example it is 4), and shift all the bars left of it leftward one step (as shown in Figure 9(c)), then the total of the discrete values is larger than the integral of the curve. Therefore we have:\nn\u22121 \u2211 k=1\n\u03c6(k)+\u03c6(x\u0302)> \u222b n\n1 \u03c6(x)dx >\nn\u22121 \u2211 k=1 \u03c6(k)\u2212\u03c6(x\u0302).\nBy Lemma 5, we know that\n\u03c6(x0) = \u03b1e c1\u2212c2 \u03b1\u221a\n2\u03c0(\u03b1\u22121)n +O\n( n\u2212 3 2 ) = O ( 1\u221a n ) .\nAlso, from the proof of Lemma 6, we can see that, for x \u2208 [1,n\u2212 1], \u03c6(x) = \u03c6(x0)e\u03c8(x) and \u03c8(x)\u2264\u2212c1(x\u2212x0)2/n+O(1). So, \u03c6(x) =O(\u03c6(x0)), which implies \u03c6(x\u0302) =O(n\u2212 1 2 ). That means lim n\u2192\u221e \u03c6(x\u0302) = 0. Therefore,\nlim n\u2192\u221e\nn\u22121 \u2211 k=1 \u03c6(k) = lim n\u2192\u221e \u222b n 1 \u03c6(x)dx.\nLemma 8\nlim n\u2192\u221e (\u222b x0\u2212\u2206 \u2212\u221e \u03c7(x)dx+ \u222b \u221e x0+\u2206 \u03c7(x)dx ) = 0. (48)\nProof Note that \u222b x0\u2212\u2206\n\u2212\u221e \u03c7(x)dx+ \u222b \u221e x0+\u2206 \u03c7(x)dx = 2 \u222b \u221e x0+\u2206 \u03c7(x)dx\n= 2\u03c6(x0) \u222b \u221e\n\u2206 e\u2212\nx2\n2\u03c32 dx.\nLet x = \u221a\n2\u03c3t, then \u222b \u221e \u2206 e\u2212 x2 2\u03c32 dx = \u221a 2\u03c3 \u222b \u221e\n\u2206\u221a 2\u03c3\ne\u2212t 2 dt = \u221a 2\u03c0\u03c3 2 erfc( \u2206\u221a 2\u03c3 ),\nwhere erfc is the complementary error function. Then\nlim n\u2192\u221e (\u222b x0\u2212\u2206 \u2212\u221e \u03c7(x)dx+ \u222b \u221e x0+\u2206 \u03c7(x)dx ) = lim n\u2192\u221e \u221a 2\u03c0\u03c3\u03c6(x0)erfc( \u2206\u221a 2\u03c3 ).\nBy Eq.(13) and Lemma 5, we know that\n\u03c3\u03c6(x0) = O(1).\nAnd then by Eq.(15), we have \u2206\u221a 2\u03c3 = O (\u221a lnn ) \u2192 \u221e. From Eq.29 (the property of complementary error function), it follows that\nlim z\u2192\u221e erfc(z) = 0.\nThus,\nlim n\u2192\u221e (\u222b x0\u2212\u2206 \u2212\u221e \u03c7(x)dx+ \u222b \u221e x0+\u2206 \u03c7(x)dx ) = 0.\nLemma 9\nlim n\u2192\u221e \u222b x0+\u2206 x0\u2212\u2206 |\u03c6(x)\u2212\u03c7(x)|dx = 0. (49)\nProof From the definitions of \u03c6(x) and \u03c7(x) in Eq.(9) and Eq.(11),\u222b x0+\u2206\nx0\u2212\u2206 |\u03c6(x)\u2212\u03c7(x)|dx = \u03c6(x0) \u222b x0+\u2206 x0\u2212\u2206 |e\u03c8(x)\u2212 e\u03be (x)|dx\n= \u03c6(x0) \u222b x0+\u2206\nx0\u2212\u2206 e\u03be (x)|e\u03c8(x)\u2212\u03be (x)\u22121|dx,\nwhere\n\u03be (x) =\u2212 (x\u2212 x0) 2\n2\u03c32 .\nNote that e\u03be (x) \u2264 1 and when |\u03b4 | is small enough,\n|e\u03b4 \u22121| \u2264 2|\u03b4 |.\nIf we can show that \u03c8(x)\u2212\u03be (x)\u2192 0 when x \u2208 [x0\u2212\u2206,x0 +\u2206], then\u222b x0+\u2206 x0\u2212\u2206 |\u03c6(x)\u2212\u03c7(x)|dx\u2264 2\u03c6(x0) \u222b x0+\u2206 x0\u2212\u2206 |\u03c8(x)\u2212\u03be (x)|dx. (50)\nFrom the definition of \u03be (x), it follows that\n\u03be (x0) = \u03be \u2032(x0) = 0,\n\u03be \u2032\u2032(x0) =\u2212 1\n\u03c32 ,\nand \u03be (i)(x0) = 0, for i > 2. From the definition of \u03c8(x) in Eq.(30),\n\u03c8(x0) = 0.\nBy Lemma 2, Lemma 3 and Lemma 4, \u03c8 \u2032(x0) = O (\n1 n\n) ,\n\u03c8 \u2032\u2032(x0) =\u2212 1\n\u03c32 +O ( 1 n2 ) ,\n\u03c8(i)(x0) = O ( n\u2212(i\u22121) ) , for i > 2.\nBased on the Taylor series for the function \u03c8(x)\u2212\u03be (x),\n|\u03c8(x)\u2212\u03be (x)| \u2264 \u221e\n\u2211 i=0 \u2223\u2223\u2223\u2223\u2223\u03c8(i)(x0)\u2212\u03be (i)(x0)i! (x\u2212 x0)i \u2223\u2223\u2223\u2223\u2223 .\nAs x \u2208 [x0\u2212\u2206,x0 +\u2206],\n|x\u2212 x0| \u2264 O (\u221a n lnn ) .\nThus,\n|\u03c8(x)\u2212\u03be (x)| \u2264 O (\u221a lnn n ) \u2192 0,\nwhich indicates Eq(50) holds. By Eq(50), we have\u222b x0+\u2206 x0\u2212\u2206 |\u03c6(x)\u2212\u03c7(x)|dx\u2264 O(2\u03c6(x0)) \u222b x0+\u2206 x0\u2212\u2206 |\u03c8(x)\u2212\u03be (x)|dx\n\u2264 O (\n1\u221a n\n) \u00d7O (\u221a n lnn ) \u00d7O (\u221a lnn n )\n= O (\nlnn\u221a n\n) \u2192 0."}], "references": [{"title": "Random constraint satisfaction: A more accurate picture", "author": ["D. ACHLIOPTAS", "L. KIROUSIS", "E. KRANAKIS", "D. KRIZANC", "M. MOLLOY", "Y. STAMATIOU"], "venue": "Proceedings of the 3rd International Conference on Principles and Practice of Constraint Programming (CP-97). 107\u2013120.", "citeRegEx": "ACHLIOPTAS et al\\.,? 1997", "shortCiteRegEx": "ACHLIOPTAS et al\\.", "year": 1997}, {"title": "Rigorous location of phase transitions in hard optimization problems", "author": ["D. ACHLIOPTAS", "A. NAOR", "Y. PERES"], "venue": "Nature 435, 7043, 759764.", "citeRegEx": "ACHLIOPTAS et al\\.,? 2005", "shortCiteRegEx": "ACHLIOPTAS et al\\.", "year": 2005}, {"title": "Probabilistic reasoning with answer sets", "author": ["C. BARAL", "M. GELFOND", "N. RUSHTON"], "venue": "Theory and Practice of Logic Programming 9, 1, 57\u2013144.", "citeRegEx": "BARAL et al\\.,? 2009", "shortCiteRegEx": "BARAL et al\\.", "year": 2009}, {"title": "Continuous models of computation for logic programs: importing continuous mathematics into logic programming\u2019s algorithmic foundations", "author": ["H. BLAIR", "F. DUSHIN", "D. JAKEL", "D. RIVERA", "M. SEZGIN"], "venue": "The Logic Programming Paradigm. 231\u2013255.", "citeRegEx": "BLAIR et al\\.,? 1999", "shortCiteRegEx": "BLAIR et al\\.", "year": 1999}, {"title": "Semantics of disjunctive logic programs based on partial evaluation", "author": ["S. BRASS", "J. DIX"], "venue": "Journal of Logic Programming 38, 3, 167\u2013312.", "citeRegEx": "BRASS and DIX,? 1999", "shortCiteRegEx": "BRASS and DIX", "year": 1999}, {"title": "Where the really hard problems are", "author": ["P. CHEESEMAN", "B. KANEFSKY", "W.M. TAYLOR"], "venue": "Proceedings of the 12th International Joint Conference on Artificial Intelligence (IJCAI-91). 331\u2013340.", "citeRegEx": "CHEESEMAN et al\\.,? 1991", "shortCiteRegEx": "CHEESEMAN et al\\.", "year": 1991}, {"title": "The conflict-driven answer set solver clasp: Progress report", "author": ["M. GEBSER", "B. KAUFMANN", "T. SCHAUB"], "venue": "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-09). 509\u2013514.", "citeRegEx": "GEBSER et al\\.,? 2009", "shortCiteRegEx": "GEBSER et al\\.", "year": 2009}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proceedings of the 5th International Conference on Logic Programming (ICLP-88). 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1990", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1990}, {"title": "Logic programs with classical negation", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proceedings of the 7th International Conference on Logic Programming (ICLP-90). 579\u2013597.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "The sat phase transition", "author": ["I. GENT", "T. WALSH"], "venue": "Proceedings of the Eleventh European Conference on Artificial Intelligence (ECAI-94). 105\u2013109.", "citeRegEx": "GENT and WALSH,? 1994", "shortCiteRegEx": "GENT and WALSH", "year": 1994}, {"title": "Two-literal logic programs and satisfiability representation of stable models: A comparison", "author": ["HUANG G.", "JIA X.", "C.", "YOU", "J."], "venue": "Proceedings 15th Canadian Conference on Artificial Intelligence. 119\u2013131.", "citeRegEx": "G. et al\\.,? 2002", "shortCiteRegEx": "G. et al\\.", "year": 2002}, {"title": "Phase transitions in artificial intelligence systems", "author": ["B. HUBERMAN", "T. HOGG"], "venue": "Artificial Intelligence 33, 2, 155\u2013171.", "citeRegEx": "HUBERMAN and HOGG,? 1987", "shortCiteRegEx": "HUBERMAN and HOGG", "year": 1987}, {"title": "Some (in)translatability results for normal logic programs and propositional theories", "author": ["T. JANHUNEN"], "venue": "Journal of Applied Non-Classical Logics , 1-2, 35\u201386.", "citeRegEx": "JANHUNEN,? 2006", "shortCiteRegEx": "JANHUNEN", "year": 2006}, {"title": "The dlv system for knowledge representation and reasoning", "author": ["N. LEONE", "G. PFEIFER", "W. FABER", "T. EITER", "G. GOTTLOB", "S. PERRI", "F. SCARCELLO"], "venue": "ACM Transactions on Computational Logic 7, 3, 499\u2013562.", "citeRegEx": "LEONE et al\\.,? 2006", "shortCiteRegEx": "LEONE et al\\.", "year": 2006}, {"title": "Computing stable models: worst-Case performance estimates", "author": ["Z. LONC", "M. TRUSZCZYNSKI"], "venue": "Theory and Practice of Logic Programming 4, 1-2, 193\u2013231.", "citeRegEx": "LONC and TRUSZCZYNSKI,? 2004", "shortCiteRegEx": "LONC and TRUSZCZYNSKI", "year": 2004}, {"title": "Autoepistemic logic", "author": ["V. MAREK", "M. TRUSZCZYNSKI"], "venue": "Journal of the Association for Computing Machinery 38, 3, 588\u2013619.", "citeRegEx": "MAREK and TRUSZCZYNSKI,? 1991", "shortCiteRegEx": "MAREK and TRUSZCZYNSKI", "year": 1991}, {"title": "Nonmonotonic Logic: Context-Dependent Reasonong", "author": ["V. MAREK", "M. TRUSZCZYNSKI"], "venue": "Springer, 1993.", "citeRegEx": "MAREK and TRUSZCZYNSKI,? 1993", "shortCiteRegEx": "MAREK and TRUSZCZYNSKI", "year": 1993}, {"title": "Hard and easy distributions of sat problems", "author": ["D. MITCHELL", "B. SELMAN", "H. LEVESQUE"], "venue": "Proceedings of the 10th National Conference on Artificial Intelligence (AAAI-92). 459\u2013465.", "citeRegEx": "MITCHELL et al\\.,? 1992", "shortCiteRegEx": "MITCHELL et al\\.", "year": 1992}, {"title": "2+psat: Relation of typical-case complexity to the nature of the phase transition", "author": ["R. MONASSON", "R. ZECCHINA", "S. KIRKPATRICK", "B. SELMAN", "L. TROYANSKY"], "venue": "Random Structures and Algorithms 15, 3-4, 414\u2013435.", "citeRegEx": "MONASSON et al\\.,? 1999", "shortCiteRegEx": "MONASSON et al\\.", "year": 1999}, {"title": "Study of random logic programs", "author": ["G. NAMASIVAYAM"], "venue": "Proceedings of the 25th International Conference on Logic Programming (ICLP-09). 555\u2013556.", "citeRegEx": "NAMASIVAYAM,? 2009", "shortCiteRegEx": "NAMASIVAYAM", "year": 2009}, {"title": "Simple random logic programs", "author": ["G. NAMASIVAYAM", "M. TRUSZCZYNSKI"], "venue": "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-09). 223\u2013235.", "citeRegEx": "NAMASIVAYAM and TRUSZCZYNSKI,? 2009", "shortCiteRegEx": "NAMASIVAYAM and TRUSZCZYNSKI", "year": 2009}, {"title": "On the distribution of programs with stable models", "author": ["J. SCHLIPF", "M. TRUSZCZYNSKI", "D. WONG"], "venue": "05171 Abstracts Collection - Nonmonotonic Reasoning, Answer Set Prorgamming and Constraints.", "citeRegEx": "SCHLIPF et al\\.,? 2005", "shortCiteRegEx": "SCHLIPF et al\\.", "year": 2005}, {"title": "Handbook on Ontologies", "author": ["S. STAAB", "R. STUDER"], "venue": "Springer-Verlag, 2004.", "citeRegEx": "STAAB and STUDER,? 2004", "shortCiteRegEx": "STAAB and STUDER", "year": 2004}, {"title": "The smodels system", "author": ["T. SYRJ\u00c4NEN", "I. NIEMEL\u00c4"], "venue": "Proceedings of the 6th International ConferenceLogic Logic Programming and Nonmonotonic Reasoning (LPNMR-01). 434\u2013438.", "citeRegEx": "SYRJ\u00c4NEN and NIEMEL\u00c4,? 2001", "shortCiteRegEx": "SYRJ\u00c4NEN and NIEMEL\u00c4", "year": 2001}, {"title": "Comparisons and computation of well-founded semantics for disjunctive logic programs", "author": ["K. WANG", "L. ZHOU"], "venue": "ACM Transactions on Computational Logic 6, 2, 295\u2013327.", "citeRegEx": "WANG and ZHOU,? 2005", "shortCiteRegEx": "WANG and ZHOU", "year": 2005}, {"title": "Answer set programming phase transition: A study on randomly generated programs", "author": ["Y. ZHAO", "F. LIN"], "venue": "Proceedings of the 19th International Conference on Logic Programming (ICLP-03). 239\u2013 253.", "citeRegEx": "ZHAO and LIN,? 2003", "shortCiteRegEx": "ZHAO and LIN", "year": 2003}], "referenceMentions": [{"referenceID": 0, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 1, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 5, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 9, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 11, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 17, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 18, "context": "These problems include the satisfiability of boolean formulas (SAT) and the constraint satisfaction problems (CSP) (Achlioptas et al. 1997; Achlioptas et al. 2005; Cheeseman et al. 1991; Gent and Walsh 1994; Huberman and Hogg 1987; Mitchell et al. 1992; Monasson et al. 1999).", "startOffset": 115, "endOffset": 275}, {"referenceID": 6, "context": "Answer set programming (ASP) is currently one of the most widely used nonmonotonic reasoning systems due to its simple syntax, precise semantics and importantly, the availability of ASP solvers, such as clasp (Gebser et al. 2009), dlv (Leone et al.", "startOffset": 209, "endOffset": 229}, {"referenceID": 13, "context": "2009), dlv (Leone et al. 2006), and smodels (Syrj\u00e4nen and Niemel\u00e4 2001).", "startOffset": 11, "endOffset": 30}, {"referenceID": 20, "context": "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).", "startOffset": 79, "endOffset": 172}, {"referenceID": 19, "context": "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).", "startOffset": 79, "endOffset": 172}, {"referenceID": 21, "context": "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).", "startOffset": 79, "endOffset": 172}, {"referenceID": 25, "context": "However, the theoretical study of random ASP has not made much progress so far (Namasivayam and Truszczynski 2009; Namasivayam 2009; Schlipf et al. 2005; Zhao and Lin 2003).", "startOffset": 79, "endOffset": 172}, {"referenceID": 25, "context": "(Zhao and Lin 2003) first conducted an experimental study on the issue of phase transition for randomly generated ASP programs whose rules can have three or more literals.", "startOffset": 0, "endOffset": 19}, {"referenceID": 20, "context": "To study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs.", "startOffset": 53, "endOffset": 106}, {"referenceID": 19, "context": "To study statistical properties for random programs, (Namasivayam and Truszczynski 2009; Namasivayam 2009) considered the class of randomly generated ASP programs in which each rule has exactly two literals, called simple random programs.", "startOffset": 53, "endOffset": 106}, {"referenceID": 15, "context": "In fact, the class of negative two-literal programs is used to show the NP-hardness of answer set semantics for normal logic programs in (Marek and Truszczynski 1991) (Theorem 6.", "startOffset": 137, "endOffset": 166}, {"referenceID": 2, "context": "For instance, it is important to compute all answer sets of a program in applications, such as diagnoses and query answering, in P-log (Baral et al. 2009).", "startOffset": 135, "endOffset": 154}, {"referenceID": 22, "context": "Also, the linear model of random programs may be useful in application domains such as ontology engineering where most of large practical ontologies are sparse in the sense that the ratio of terminological axioms to concepts/roles is relatively small (Staab and Studer 2004).", "startOffset": 251, "endOffset": 274}, {"referenceID": 20, "context": "(Namasivayam and Truszczynski 2009) discusses some program classes of two-literal programs that may not be negative.", "startOffset": 0, "endOffset": 35}, {"referenceID": 8, "context": "The semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows.", "startOffset": 107, "endOffset": 163}, {"referenceID": 7, "context": "The semantics of a logic program P is defined in terms of its answer sets (or equivalently, stable models) (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1990) as follows.", "startOffset": 107, "endOffset": 163}, {"referenceID": 12, "context": "We note that our definition is slightly different from some other authors, such as (Janhunen 2006; Lonc and Truszczynski 2002), in that fact rules are not allowed in our definition.", "startOffset": 83, "endOffset": 126}, {"referenceID": 15, "context": "It is shown in (Marek and Truszczynski 1991) that the problem of deciding the existence of answer sets for a negative two-literal program is NP-complete.", "startOffset": 15, "endOffset": 44}, {"referenceID": 3, "context": "This result is mentioned in (Blair et al. 1999) but no proof is provided there.", "startOffset": 28, "endOffset": 47}, {"referenceID": 16, "context": "8 in (Marek and Truszczynski 1993).", "startOffset": 5, "endOffset": 34}, {"referenceID": 6, "context": "The experimental results in this section were based on the ASP solver clasp (Gebser et al. 2009), but same patterns were obtained for test cases on which dlv (Leone et al.", "startOffset": 76, "endOffset": 96}, {"referenceID": 13, "context": "2009), but same patterns were obtained for test cases on which dlv (Leone et al. 2006) and smodels (Syrj\u00e4nen and Niemel\u00e4 2001) were also used.", "startOffset": 67, "endOffset": 86}, {"referenceID": 12, "context": "programs that are more general than negative two-literal programs, such as the program classes discussed in (Janhunen 2006; Lonc and Truszczynski 2002).", "startOffset": 108, "endOffset": 151}, {"referenceID": 4, "context": "Proof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005).", "startOffset": 132, "endOffset": 172}, {"referenceID": 24, "context": "Proof First, it has been proven that each normal logic program is equivalent to a negative logic program under answer set semantics (Brass and Dix 1999; Wang and Zhou 2005).", "startOffset": 132, "endOffset": 172}], "year": 2014, "abstractText": "This paper proposes a model, the linear model, for randomly generating logic programs with low density of rules and investigates statistical properties of such random logic programs. It is mathematically shown that the average number of answer sets for a random program converges to a constant when the number of atoms approaches infinity. Several experimental results are also reported, which justify the suitability of the linear model. It is also experimentally shown that, under this model, the size distribution of answer sets for random programs tends to a normal distribution when the number of atoms is sufficiently large.", "creator": "LaTeX with hyperref package"}}}