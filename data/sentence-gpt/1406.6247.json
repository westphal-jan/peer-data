{"id": "1406.6247", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Jun-2014", "title": "Recurrent Models of Visual Attention", "abstract": "Applying convolutional neural networks to large images is computationally expensive because the amount of computation scales linearly with the number of image pixels. We present a novel recurrent neural network model that is capable of extracting information from an image or video by adaptively selecting a sequence of regions or locations and only processing the selected regions at high resolution. Like convolutional neural networks, the proposed model has a degree of translation invariance built-in, but the amount of computation it performs can be controlled independently of the input image size. The model also presents a model with the probability that a neuron can be created on a given network for each individual image or video. These models predict how many images a given image is to the target region of the network. We report the results of the model's classification, and the number of images a given image can be determined by using convolutional neural networks.\n\n\n\n\n\n\n\n\n\nThe model was developed in the 1990s in order to study the complexity of convolutional neural networks. In the course of its study, the researchers presented a model which shows how convolutional neural networks perform across multiple architectures of memory and spatial organization. In one example, the network consists of the following networks:\n\nThe network consists of four neurons: the left and the right.\nThe network consists of three neurons: the right and the right.\nThe network consists of six neurons: the left and the right.\nThe network consists of seven neurons: the right and the right.\nThe network consists of eight neurons: the left and the right.\nThe network consists of nine neurons: the right and the right.\nThe network consists of nine neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons: the right and the right.\nThe network consists of ten neurons", "histories": [["v1", "Tue, 24 Jun 2014 14:16:56 GMT  (982kb,D)", "http://arxiv.org/abs/1406.6247v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.CV stat.ML", "authors": ["volodymyr mnih", "nicolas heess", "alex graves", "koray kavukcuoglu"], "accepted": true, "id": "1406.6247"}, "pdf": {"name": "1406.6247.pdf", "metadata": {"source": "CRF", "title": "Recurrent Models of Visual Attention", "authors": ["Volodymyr Mnih", "Nicolas Heess", "Alex Graves", "Koray Kavukcuoglu"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Neural network-based architectures have recently had great success in significantly advancing the state of the art on challenging image classification and object detection datasets [8, 12, 19]. Their excellent recognition accuracy, however, comes at a high computational cost both at training and testing time. The large convolutional neural networks typically used currently take days to train on multiple GPUs even though the input images are downsampled to reduce computation [12]. In the case of object detection processing a single image at test time currently takes seconds when running on a single GPU [8, 19] as these approaches effectively follow the classical sliding window paradigm from the computer vision literature where a classifier, trained to detect an object in a tightly cropped bounding box, is applied independently to thousands of candidate windows from the test image at different positions and scales. Although some computations can be shared, the main computational expense for these models comes from convolving filter maps with the entire input image, therefore their computational complexity is at least linear in the number of pixels.\nOne important property of human perception is that one does not tend to process a whole scene in its entirety at once. Instead humans focus attention selectively on parts of the visual space to acquire information when and where it is needed, and combine information from different fixations over time to build up an internal representation of the scene [18], guiding future eye movements and decision making. Focusing the computational resources on parts of a scene saves \u201cbandwidth\u201d as fewer \u201cpixels\u201d need to be processed. But it also substantially reduces the task complexity as the object of interest can be placed in the center of the fixation and irrelevant features of the visual environment (\u201cclutter\u201d) outside the fixated region are naturally ignored.\nIn line with its fundamental role, the guidance of human eye movements has been extensively studied in neuroscience and cognitive science literature. While low-level scene properties and bottom up processes (e.g. in the form of saliency; [11]) play an important role, the locations on which humans fixate have also been shown to be strongly task specific (see [9] for a review and also e.g. [15, 22]). In this paper we take inspiration from these results and develop a novel framework for attention-based task-driven visual processing with neural networks. Our model considers attention-based processing\nar X\niv :1\n40 6.\n62 47\nv1 [\ncs .L\nG ]\n2 4\nJu n\n20 14\nof a visual scene as a control problem and is general enough to be applied to static images, videos, or as a perceptual module of an agent that interacts with a dynamic visual environment (e.g. robots, computer game playing agents).\nThe model is a recurrent neural network (RNN) which processes inputs sequentially, attending to different locations within the images (or video frames) one at a time, and incrementally combines information from these fixations to build up a dynamic internal representation of the scene or environment. Instead of processing an entire image or even bounding box at once, at each step, the model selects the next location to attend to based on past information and the demands of the task. Both the number of parameters in our model and the amount of computation it performs can be controlled independently of the size of the input image, which is in contrast to convolutional networks whose computational demands scale linearly with the number of image pixels. We describe an end-to-end optimization procedure that allows the model to be trained directly with respect to a given task and to maximize a performance measure which may depend on the entire sequence of decisions made by the model. This procedure uses backpropagation to train the neural-network components and policy gradient to address the non-differentiabilities due to the control problem.\nWe show that our model can learn effective task-specific strategies for where to look on several image classification tasks as well as a dynamic visual control problem. Our results also suggest that an attention-based model may be better than a convolutional neural network at both dealing with clutter and scaling up to large input images."}, {"heading": "2 Previous Work", "text": "Computational limitations have received much attention in the computer vision literature. For instance, for object detection, much work has been dedicated to reducing the cost of the widespread sliding window paradigm, focusing primarily on reducing the number of windows for which the full classifier is evaluated, e.g. via classifier cascades (e.g. [7, 24]), removing image regions from consideration via a branch and bound approach on the classifier output (e.g. [13]), or by proposing candidate windows that are likely to contain objects (e.g. [1, 23]). Even though substantial speedups may be obtained with such approaches, and some of these can be combined with or used as an add-on to CNN classifiers [8], they remain firmly rooted in the window classifier design for object detection and only exploit past information to inform future processing of the image in a very limited way.\nA second class of approaches that has a long history in computer vision and is strongly motivated by human perception are saliency detectors (e.g. [11]). These approaches prioritize the processing of potentially interesting (\u201csalient\u201d) image regions which are typically identified based on some measure of local low-level feature contrast. Saliency detectors indeed capture some of the properties of human eye movements, but they typically do not to integrate information across fixations, their saliency computations are mostly hardwired, and they are based on low-level image properties only, usually ignoring other factors such as semantic content of a scene and task demands (but see [22]).\nSome works in the computer vision literature and elsewhere e.g. [2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here. There, as in our work, information about the image is gathered sequentially and the decision where to attend next is based on previous fixations of the image. [4] employs the learned Bayesian observer model from [5] to the task of object detection. The learning framework of [5] is related to ours as they also employ a policy gradient formulation (cf. section 3) but their overall setup is considerably more restrictive than ours and only some parts of the system are learned.\nOur work is perhaps the most similar to the other attempts to implement attentional processing in a deep learning framework [6, 14, 17]. Our formulation which employs an RNN to integrate visual information over time and to decide how to act is, however, more general, and our learning procedure allows for end-to-end optimization of the sequential decision process instead of relying on greedy action selection. We further demonstrate how the same general architecture can be used for efficient object recognition in still images as well as to interact with a dynamic visual environment in a task-driven way."}, {"heading": "3 The Recurrent Attention Model (RAM)", "text": "In this paper we consider the attention problem as the sequential decision process of a goal-directed agent interacting with a visual environment. At each point in time, the agent observes the environment only via a bandwidth-limited sensor, i.e. it never senses the environment in full. It may extract\ninformation only in a local region or in a narrow frequency band. The agent can, however, actively control how to deploy its sensor resources (e.g. choose the sensor location). The agent can also affect the true state of the environment by executing actions. Since the environment is only partially observed the agent needs to integrate information over time in order to determine how to act and how to deploy its sensor most effectively. At each step, the agent receives a scalar reward (which depends on the actions the agent has executed and can be delayed), and the goal of the agent is to maximize the total sum of such rewards.\nThis formulation encompasses tasks as diverse as object detection in static images and control problems like playing a computer game from the image stream visible on the screen. For a game, the environment state would be the true state of the game engine and the agent\u2019s sensor would operate on the video frame shown on the screen. (Note that for most games, a single frame would not fully specify the game state). The environment actions here would correspond to joystick controls, and the reward would reflect points scored. For object detection in static images the state of the environment would be fixed and correspond to the true contents of the image. The environmental action would correspond to the classification decision (which may be executed only after a fixed number of fixations), and the reward would reflect if the decision is correct."}, {"heading": "3.1 Model", "text": "The agent is built around a recurrent neural network as shown in Fig. 1. At each time step, it processes the sensor data, integrates information over time, and chooses how to act and how to deploy its sensor at next time step:\nSensor: At each step t the agent receives a (partial) observation of the environment in the form of an image xt. The agent does not have full access to this image but rather can extract information from xt via its bandwidth limited sensor \u03c1, e.g. by focusing the sensor on some region or frequency band of interest.\nIn this paper we assume that the bandwidth-limited sensor extracts a retina-like representation \u03c1(xt, lt\u22121) around location lt\u22121 from image xt. It encodes the region around l at a high-resolution but uses a progressively lower resolution for pixels further from l, resulting in a vector of much\nlower dimensionality than the original image x. We will refer to this low-resolution representation as a glimpse [14]. The glimpse sensor is used inside what we call the glimpse network fg to produce the glimpse feature vector gt = fg(xt, lt\u22121; \u03b8g) where \u03b8g = {\u03b80g , \u03b81g , \u03b82g} (Fig. 1B). Internal state: The agent maintains an interal state which summarizes information extracted from the history of past observations; it encodes the agent\u2019s knowledge of the environment and is instrumental to deciding how to act and where to deploy the sensor. This internal state is formed by the hidden units ht of the recurrent neural network and updated over time by the core network: ht = fh(ht\u22121, gt; \u03b8h). The external input to the network is the glimpse feature vector gt.\nActions: At each step, the agent performs two actions: it decides how to deploy its sensor via the sensor control lt, and an environment action at which might affect the state of the environment. The nature of the environment action depends on the task. In this work, the location actions are chosen stochastically from a distribution parameterized by the location network fl(ht; \u03b8l) at time t: lt \u223c p(\u00b7|fl(ht; \u03b8l)). The environment action at is similarly drawn from a distribution conditioned on a second network output at \u223c p(\u00b7|fa(ht; \u03b8a)). For classification it is formulated using a softmax output and for dynamic environments, its exact formulation depends on the action set defined for that particular environment (e.g. joystick movements, motor control, ...).\nReward: After executing an action the agent receives a new visual observation of the environment xt+1 and a reward signal rt+1. The goal of the agent is to maximize the sum of the reward signal1\nwhich is usually very sparse and delayed: R = \u2211T t=1 rt. In the case of object recognition, for example, rT = 1 if the object is classified correctly after T steps and 0 otherwise.\nThe above setup is a special instance of what is known in the RL community as a Partially Observable Markov Decision Process (POMDP). The true state of the environment (which can be static or dynamic) is unobserved. In this view, the agent needs to learn a (stochastic) policy \u03c0((lt, at)|s1:t; \u03b8) with parameters \u03b8 that, at each step t, maps the history of past interactions with the environment s1:t = x1, l1, a1, . . . xt\u22121, lt\u22121, at\u22121, xt to a distribution over actions for the current time step, subject to the constraint of the sensor. In our case, the policy \u03c0 is defined by the RNN outlined above, and the history st is summarized in the state of the hidden units ht. We will describe the specific choices for the above components in Section 4."}, {"heading": "3.2 Training", "text": "The parameters of our agent are given by the parameters of the glimpse network, the core network (Fig. 1C), and the action network \u03b8 = {\u03b8g, \u03b8h, \u03b8a} and we learn these to maximize the total reward the agent can expect when interacting with the environment.\nMore formally, the policy of the agent, possibly in combination with the dynamics of the environment (e.g. for game-playing), induces a distribution over possible interaction sequences s1:N and we aim to maximize the reward under this distribution: J(\u03b8) = Ep(s1:T ;\u03b8) [\u2211T t=1 rt ] = Ep(s1:T ;\u03b8) [R],\nwhere p(s1:T ; \u03b8) depends on the policy\nMaximizing J exactly is non-trivial since it involves an expectation over the high-dimensional interaction sequences which may in turn involve unknown environment dynamics. Viewing the problem as a POMDP, however, allows us to bring techniques from the RL literature to bear: As shown by Williams [26] a sample approximation to the gradient is given by\n\u2207\u03b8J = T\u2211 t=1 Ep(s1:T ;\u03b8) [\u2207\u03b8 log \u03c0(ut|s1:t; \u03b8)R] \u2248 1 M M\u2211 i=1 T\u2211 t=1 \u2207\u03b8 log \u03c0(uit|si1:t; \u03b8)Ri, (1)\nwhere si\u2019s are interaction sequences obtained by running the current agent \u03c0\u03b8 for i = 1 . . .M episodes.\nThe learning rule (1) is also known as the REINFORCE rule, and it involves running the agent with its current policy to obtain samples of interaction sequences s1:T and then adjusting the parameters \u03b8 of our agent such that the log-probability of chosen actions that have led to high cumulative reward is increased, while that of actions having produced low reward is decreased.\n1 Depending on the scenario it may be more appropriate to consider a sum of discounted rewards, where rewards obtained in the distant future contribute less: R = \u2211T t=1 \u03b3 t\u22121rt. In this case we can have T \u2192 \u221e.\nEq. (1) requires us to compute \u2207\u03b8 log \u03c0(uit|si1:t; \u03b8). But this is just the gradient of the RNN that defines our agent evaluated at time step t and can be computed by standard backpropagation [25].\nVariance Reduction : Equation (1) provides us with an unbiased estimate of the gradient but it may have high variance. It is therefore common to consider a gradient estimate of the form\n1\nM M\u2211 i=1 T\u2211 t=1 \u2207\u03b8 log \u03c0(uit|si1:t; \u03b8) ( Rit \u2212 bt ) , (2)\nwhere Rit = \u2211T t\u2032=1 r i t\u2032 is the cumulative reward obtained following the execution of action u i t, and bt is a baseline that may depend on si1:t (e.g. via h i t) but not on the action u i t itself. This estimate is equal to (1) in expectation but may have lower variance. It is natural to select bt = E\u03c0 [Rt] [21], and this form of baseline known as the value function in the reinforcement learning literature. The resulting algorithm increases the log-probability of an action that was followed by a larger than expected cumulative reward, and decreases the probability if the obtained cumulative reward was smaller. We use this type of baseline and learn it by reducing the squared error between Rit\u2019s and bt.\nUsing a Hybrid Supervised Loss: The algorithm described above allows us to train the agent when the \u201cbest\u201d actions are unknown, and the learning signal is only provided via the reward. For instance, we may not know a priori which sequence of fixations provides most information about an unknown image, but the total reward at the end of an episode will give us an indication whether the tried sequence was good or bad.\nHowever, in some situations we do know the correct action to take: For instance, in an object detection task the agent has to output the label of the object as the final action. For the training images this label will be known and we can directly optimize the policy to output the correct label associated with a training image at the end of an observation sequence. This can be achieved, as is common in supervised learning, by maximizing the conditional probability of the true label given the observations from the image, i.e. by maximizing log \u03c0(a\u2217T |s1:T ; \u03b8), where a\u2217T corresponds to the ground-truth label(-action) associated with the image from which observations s1:T were obtained. We follow this approach for classification problems where we optimize the cross entropy loss to train the action network fa and backpropagate the gradients through the core and glimpse networks. The location network fl is always trained with REINFORCE."}, {"heading": "4 Experiments", "text": "We evaluated our approach on several image classification tasks as well as a simple game. We first describe the design choices that were common to all our experiments:\nRetina and location encodings: The retina encoding \u03c1(x, l) extracts k square patches centered at location l, with the first patch being gw \u00d7 gw pixels in size, and each successive patch having twice the width of the previous. The k patches are then all resized to gw \u00d7 gw and concatenated. Glimpse locations l were encoded as real-valued (x, y) coordinates2 with (0, 0) being the center of the image x and (\u22121,\u22121) being the top left corner of x. Glimpse network: The glimpse network fg(x, l) had two fully connected layers. LetLinear(x) denote a linear transformation of the vector x, i.e. Linear(x) =Wx+b for some weight matrixW and bias vector b, and letRect(x) = max(x, 0) be the rectifier nonlinearity. The output g of the glimpse network was defined as g = Rect(Linear(hg) + Linear(hl)) where hg = Rect(Linear(\u03c1(x, l))) and hl = Rect(Linear(l)). The dimensionality of hg and hl was 128 while the dimensionality of g was 256 for all attention models trained in this paper.\nLocation network: The policy for the locations l was defined by a two-component Gaussian with a fixed variance. The location network outputs the mean of the location policy at time t and is defined as fl(h) = Linear(h) where h is the state of the core network/RNN.\nCore network: For the classification experiments that follow the core fh was a network of rectifier units defined as ht = fh(ht\u22121) = Rect(Linear(ht\u22121) + Linear(gt)). The experiment done on a dynamic environment used a core of LSTM units [10].\n2We also experimented with using a discrete representation for the locations l but found that it was difficult to learn policies over more than 25 possible discrete locations."}, {"heading": "4.1 Image Classification", "text": "The attention network used in the following classification experiments made a classification decision only at the last timestep t = N . The action network fa was simply a linear softmax classifier defined as fa(h) = exp (Linear(h)) /Z, where Z is a normalizing constant. The RNN state vector h had dimensionality 256. All methods were trained using stochastic gradient descent with momentum of 0.9. Hyperparameters such as the learning rate and the variance of the location policy were selected using random search [3]. The reward at the last time step was 1 if the agent classified correctly and 0 otherwise. The rewards for all other timesteps were 0.\nCentered Digits: We first tested the ability of our training method to learn successful glimpse policies by using it to train RAM models with up to 7 glimpses on the MNIST digits dataset. The \u201cretina\u201d for this experiment was simply an 8\u00d78 patch, which is only big enough to capture a part of a digit, hence the experiment also tested the ability of RAM to combine information from multiple glimpses. Note that since the first glimpse is always random, the single glimpse model is effectively a classifier that gets a single random 8 \u00d7 8 patch as input. We also trained a standard feedforward neural network with two hidden layers of 256 rectified linear units as a baseline. The error rates achieved by the different models on the test set are shown in Table 1a. We see that each additional glimpse improves the performance of RAM until it reaches its minimum with 6 glimpses, where it matches the performance of the fully connected model training on the full 28 \u00d7 28 centered digits. This demonstrates the model can successfully learn to combine information from multiple glimpses.\nNon-Centered Digits: The second problem we considered was classifying non-centered digits. We created a new task called Translated MNIST, for which data was generated by placing an MNIST digit in a random location of a larger blank patch. Training cases were generated on the fly so the effective training set size was 50000 (the size of the MNIST training set) multiplied by the possible number of locations. Figure 2a contains a random sample of test cases for the 60 by 60 Translated MNIST task. Table 1b shows the results for several different models trained on the Translated MNIST task with 60 by 60 patches. In addition to RAM and two fully-connected networks we also trained a network with one convolutional layer of 16 10 \u00d7 10 filters with stride 5 followed by a rectifier nonlinearity and then a fully-connected layer of 256 rectifier units. The convolutional network, the RAM networks, and the smaller fully connected model all had roughly the same number of parameters. Since the convolutional network has some degree of translation invariance built in, it\nattains a significantly lower error rate of 2.3% than the fully connected networks. However, RAM with 4 glimpses gets roughly the same performance as the convolutional network and outperforms it for 6 and 8 glimpses, reaching roughly 1.9% error. This is possible because the attention model can focus its retina on the digit and hence learn a translation invariant policy. This experiment also shows that the attention model is able to successfully search for an object in a big image when the object is not centered.\nCluttered Non-Centered Digits: One of the most challenging aspects of classifying real-world images is the presence of a wide range clutter. Systems that operate on the entire image at full resolution are particularly susceptible to clutter and must learn to be invariant to it. One possible advantage of an attention mechanism is that it may make it easier to learn in the presence of clutter by focusing on the relevant part of the image and ignoring the irrelevant part. We test this hypothesis with several experiments on a new task we call Cluttered Translated MNIST. Data for this task was generated by first placing an MNIST digit in a random location of a larger blank image and then adding random 8 by 8 subpatches from other random MNIST digits to random locations of the image. The goal is to classify the complete digit present in the image. Figure 2b shows a random sample of test cases for the 60 by 60 Cluttered Translated MNIST task.\nTable 2a shows the classification results for the models we trained on 60 by 60 Cluttered Translated MNIST with 4 pieces of clutter. The presence of clutter makes the task much more difficult but the performance of the attention model is affected less than the performance of the other models. RAM with 4 glimpses reaches 7.1% error, which outperforms fully-connected models by a wide margin and the convolutional neural network by 0.7%, and RAM trained with 6 and 8 glimpses achieves even lower error. Since RAM achieves larger relative error improvements over a convolutional network in the presence of clutter these results suggest the attention-based models may be better at dealing with clutter than convolutional networks because they can simply ignore it by not looking at\nit. Two samples of learned policy is shown in Figure 6 and more are included in the supplementary materials. The first column shows the original data point with the glimpse path overlaid. The location of the first glimpse is marked with a filled circle and the location of the final glimpse is marked with an empty circle. The intermediate points on the path are traced with solid straight lines. Each consecutive image to the right shows a representation of the glimpse that the network sees. It can be seen that the learned policy can reliably find and explore around the object of interest while avoiding clutter at the same time.\nTo further test this hypothesis we also performed experiments on 100 by 100 Cluttered Translated MNIST with 8 pieces of clutter. The test errors achieved by the models we compared are shown in Table 2b. The results show similar improvements of RAM over a convolutional network. It has to be noted that the overall capacity and the amount of computation of our model does not change from 60 \u00d7 60 images to 100 \u00d7 100, whereas the hidden layer of the convolutional network that is connected to the linear layer grows linearly with the number of pixels in the input."}, {"heading": "4.2 Dynamic Environments", "text": "One appealing property of the recurrent attention model is that it can be applied to videos or interactive problems with a visual input just as easily as to static image tasks. We test the ability of our approach to learn a control policy in a dynamic visual environment while perceiving the environment through a bandwidth-limited retina by training it to play a simple game. The game is played on a 24 by 24 screen of binary pixels and involves two objects: a single pixel that represents a ball falling from the top of the screen while bouncing off the sides of the screen and a two-pixel paddle positioned at the bottom of the screen which the agent controls with the aim of catching the ball. When the falling pixel reaches the bottom of the screen the agent either gets a reward of 1 if the paddle overlaps with the ball and a reward of 0 otherwise. The game then restarts from the beginning.\nWe trained the recurrent attention model to play the game of \u201cCatch\u201d using only the final reward as input. The network had a 6 by 6 retina at three scales as its input, which means that the agent had to capture the ball in the 6 by 6 highest resolution region in order to know its precise position. In addition to the two location actions, the attention model had three game actions (left, right, and do nothing) and the action network fa used a linear softmax to model a distribution over the game actions. We used a core network of 256 LSTM units.\nWe performed random search to find suitable hyper-parameters and trained each agent for 20 million frames. A video of the best agent, which catches the ball roughly 85% of the time, can be downloaded from http://www.cs.toronto.edu/\u02dcvmnih/docs/attention.mov. The video shows that the recurrent attention model learned to play the game by tracking the ball near the bottom of the screen. Since the agent was not in any way told to track the ball and was only rewarded for catching it, this result demonstrates the ability of the model to learn effective task-specific attention policies."}, {"heading": "5 Discussion", "text": "This paper introduced a novel visual attention model that is formulated as a single recurrent neural network which takes a glimpse window as its input and uses the internal state of the network to select the next location to focus on as well as to generate control signals in a dynamic environment. Although the model is not differentiable, the proposed unified architecture is trained end-to-end from pixel inputs to actions using a policy gradient method. The model has several appealing properties. First, both the number of parameters and the amount of computation RAM performs can be controlled independently of the size of the input images. Second, the model is able to ignore clutter present in an image by centering its retina on the relevant regions. Our experiments show that RAM significantly outperforms a convolutional architecture with a comparable number of parameters on a cluttered object classification task. Additionally, the flexibility of our approach allows for a number of interesting extensions. For example, the network can be augmented with another action that allows it terminate at any time point and make a final classification decision. Our preliminary experiments show that this allows the network to learn to stop taking glimpses once it has enough information to make a confident classification. The network can also be allowed to control the scale at which the retina samples the image allowing it to fit objects of different size in the fixed size retina. In both cases, the extra actions can be simply added to the action network fa and trained using the policy gradient procedure we have described. Given the encouraging results achieved by RAM, applying the model to large scale object recognition and video classification is a natural direction for future work.\nSupplementary Material"}], "references": [{"title": "What is an object", "author": ["Bogdan Alexe", "Thomas Deselaers", "Vittorio Ferrari"], "venue": "In CVPR,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "Searching for objects driven by context", "author": ["Bogdan Alexe", "Nicolas Heess", "Yee Whye Teh", "Vittorio Ferrari"], "venue": "In NIPS,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Random search for hyper-parameter optimization", "author": ["James Bergstra", "Yoshua Bengio"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "Optimal scanning for faster object detection", "author": ["Nicholas J. Butko", "Javier R. Movellan"], "venue": "In CVPR,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "I-pomdp: An infomax model of eye movement", "author": ["N.J. Butko", "J.R. Movellan"], "venue": "In Proceedings of the 7th IEEE International Conference on Development and Learning,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Learning where to attend with deep architectures for image tracking", "author": ["Misha Denil", "Loris Bazzani", "Hugo Larochelle", "Nando de Freitas"], "venue": "Neural Computation,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Cascade object detection with deformable part models", "author": ["Pedro F. Felzenszwalb", "Ross B. Girshick", "David A. McAllester"], "venue": "In CVPR,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["Ross B. Girshick", "Jeff Donahue", "Trevor Darrell", "Jitendra Malik"], "venue": "CoRR, abs/1311.2524,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Eye movements in natural behavior", "author": ["Mary Hayhoe", "Dana Ballard"], "venue": "Trends in Cognitive Sciences,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2005}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural computation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1997}, {"title": "A model of saliency-based visual attention for rapid scene analysis", "author": ["L. Itti", "C. Koch", "E. Niebur"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1998}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["Alex Krizhevsky", "Ilya Sutskever", "Geoff Hinton"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Beyond sliding windows: Object localization by efficient subwindow search", "author": ["Christoph H. Lampert", "Matthew B. Blaschko", "Thomas Hofmann"], "venue": "In CVPR,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Learning to combine foveal glimpses with a third-order boltzmann machine", "author": ["Hugo Larochelle", "Geoffrey E. Hinton"], "venue": "In NIPS,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Action from still image dataset and inverse optimal control to learn task specific visual scanpaths", "author": ["Stefan Mathe", "Cristian Sminchisescu"], "venue": "In NIPS,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "Q-learning of sequential attention for visual object recognition from informative local descriptors", "author": ["Lucas Paletta", "Gerald Fritz", "Christin Seifert"], "venue": "In CVPR,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "On Learning Where To Look", "author": ["M. Ranzato"], "venue": "ArXiv e-prints,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2014}, {"title": "The dynamic representation of scenes", "author": ["Ronald A. Rensink"], "venue": "Visual Cognition,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2000}, {"title": "Overfeat: Integrated recognition, localization and detection using convolutional networks", "author": ["Pierre Sermanet", "David Eigen", "Xiang Zhang", "Micha\u00ebl Mathieu", "Rob Fergus", "Yann LeCun"], "venue": "CoRR, abs/1312.6229,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Evolving a roving eye for go", "author": ["Kenneth O. Stanley", "Risto Miikkulainen"], "venue": "In GECCO,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2004}, {"title": "Policy gradient methods for reinforcement learning with function approximation", "author": ["Richard S. Sutton", "David Mcallester", "Satinder Singh", "Yishay Mansour"], "venue": "In NIPS,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2000}, {"title": "Contextual guidance of eye movements and attention in real-world scenes: the role of global features in object search", "author": ["Antonio Torralba", "Aude Oliva", "Monica S Castelhano", "John M Henderson"], "venue": "Psychol Rev,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2006}, {"title": "Segmentation as Selective Search for Object Recognition", "author": ["K E A van de Sande", "J.R.R. Uijlings", "T Gevers", "A.W.M. Smeulders"], "venue": "In ICCV,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}, {"title": "Rapid object detection using a boosted cascade of simple features", "author": ["Paul A. Viola", "Michael J. Jones"], "venue": "In CVPR,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2001}, {"title": "Solving deep memory pomdps with recurrent policy gradients", "author": ["Daan Wierstra", "Alexander Foerster", "Jan Peters", "Juergen Schmidhuber"], "venue": "In ICANN", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2007}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Machine Learning,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1992}], "referenceMentions": [{"referenceID": 7, "context": "Neural network-based architectures have recently had great success in significantly advancing the state of the art on challenging image classification and object detection datasets [8, 12, 19].", "startOffset": 181, "endOffset": 192}, {"referenceID": 11, "context": "Neural network-based architectures have recently had great success in significantly advancing the state of the art on challenging image classification and object detection datasets [8, 12, 19].", "startOffset": 181, "endOffset": 192}, {"referenceID": 18, "context": "Neural network-based architectures have recently had great success in significantly advancing the state of the art on challenging image classification and object detection datasets [8, 12, 19].", "startOffset": 181, "endOffset": 192}, {"referenceID": 11, "context": "The large convolutional neural networks typically used currently take days to train on multiple GPUs even though the input images are downsampled to reduce computation [12].", "startOffset": 168, "endOffset": 172}, {"referenceID": 7, "context": "In the case of object detection processing a single image at test time currently takes seconds when running on a single GPU [8, 19] as these approaches effectively follow the classical sliding window paradigm from the computer vision literature where a classifier, trained to detect an object in a tightly cropped bounding box, is applied independently to thousands of candidate windows from the test image at different positions and scales.", "startOffset": 124, "endOffset": 131}, {"referenceID": 18, "context": "In the case of object detection processing a single image at test time currently takes seconds when running on a single GPU [8, 19] as these approaches effectively follow the classical sliding window paradigm from the computer vision literature where a classifier, trained to detect an object in a tightly cropped bounding box, is applied independently to thousands of candidate windows from the test image at different positions and scales.", "startOffset": 124, "endOffset": 131}, {"referenceID": 17, "context": "Instead humans focus attention selectively on parts of the visual space to acquire information when and where it is needed, and combine information from different fixations over time to build up an internal representation of the scene [18], guiding future eye movements and decision making.", "startOffset": 235, "endOffset": 239}, {"referenceID": 10, "context": "in the form of saliency; [11]) play an important role, the locations on which humans fixate have also been shown to be strongly task specific (see [9] for a review and also e.", "startOffset": 25, "endOffset": 29}, {"referenceID": 8, "context": "in the form of saliency; [11]) play an important role, the locations on which humans fixate have also been shown to be strongly task specific (see [9] for a review and also e.", "startOffset": 147, "endOffset": 150}, {"referenceID": 14, "context": "[15, 22]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 21, "context": "[15, 22]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 6, "context": "[7, 24]), removing image regions from consideration via a branch and bound approach on the classifier output (e.", "startOffset": 0, "endOffset": 7}, {"referenceID": 23, "context": "[7, 24]), removing image regions from consideration via a branch and bound approach on the classifier output (e.", "startOffset": 0, "endOffset": 7}, {"referenceID": 12, "context": "[13]), or by proposing candidate windows that are likely to contain objects (e.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "[1, 23]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 22, "context": "[1, 23]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 7, "context": "Even though substantial speedups may be obtained with such approaches, and some of these can be combined with or used as an add-on to CNN classifiers [8], they remain firmly rooted in the window classifier design for object detection and only exploit past information to inform future processing of the image in a very limited way.", "startOffset": 150, "endOffset": 153}, {"referenceID": 10, "context": "[11]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "Saliency detectors indeed capture some of the properties of human eye movements, but they typically do not to integrate information across fixations, their saliency computations are mostly hardwired, and they are based on low-level image properties only, usually ignoring other factors such as semantic content of a scene and task demands (but see [22]).", "startOffset": 348, "endOffset": 352}, {"referenceID": 1, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 3, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 5, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 13, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 15, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 16, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 19, "context": "[2, 4, 6, 14, 16, 17, 20] have embraced vision as a sequential decision task as we do here.", "startOffset": 0, "endOffset": 25}, {"referenceID": 3, "context": "[4] employs the learned Bayesian observer model from [5] to the task of object detection.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[4] employs the learned Bayesian observer model from [5] to the task of object detection.", "startOffset": 53, "endOffset": 56}, {"referenceID": 4, "context": "The learning framework of [5] is related to ours as they also employ a policy gradient formulation (cf.", "startOffset": 26, "endOffset": 29}, {"referenceID": 5, "context": "Our work is perhaps the most similar to the other attempts to implement attentional processing in a deep learning framework [6, 14, 17].", "startOffset": 124, "endOffset": 135}, {"referenceID": 13, "context": "Our work is perhaps the most similar to the other attempts to implement attentional processing in a deep learning framework [6, 14, 17].", "startOffset": 124, "endOffset": 135}, {"referenceID": 16, "context": "Our work is perhaps the most similar to the other attempts to implement attentional processing in a deep learning framework [6, 14, 17].", "startOffset": 124, "endOffset": 135}, {"referenceID": 13, "context": "We will refer to this low-resolution representation as a glimpse [14].", "startOffset": 65, "endOffset": 69}, {"referenceID": 25, "context": "Viewing the problem as a POMDP, however, allows us to bring techniques from the RL literature to bear: As shown by Williams [26] a sample approximation to the gradient is given by", "startOffset": 124, "endOffset": 128}, {"referenceID": 24, "context": "But this is just the gradient of the RNN that defines our agent evaluated at time step t and can be computed by standard backpropagation [25].", "startOffset": 137, "endOffset": 141}, {"referenceID": 20, "context": "It is natural to select bt = E\u03c0 [Rt] [21], and this form of baseline known as the value function in the reinforcement learning literature.", "startOffset": 37, "endOffset": 41}, {"referenceID": 9, "context": "The experiment done on a dynamic environment used a core of LSTM units [10].", "startOffset": 71, "endOffset": 75}, {"referenceID": 2, "context": "Hyperparameters such as the learning rate and the variance of the location policy were selected using random search [3].", "startOffset": 116, "endOffset": 119}], "year": 2014, "abstractText": "Applying convolutional neural networks to large images is computationally expensive because the amount of computation scales linearly with the number of image pixels. We present a novel recurrent neural network model that is capable of extracting information from an image or video by adaptively selecting a sequence of regions or locations and only processing the selected regions at high resolution. Like convolutional neural networks, the proposed model has a degree of translation invariance built-in, but the amount of computation it performs can be controlled independently of the input image size. While the model is non-differentiable, it can be trained using reinforcement learning methods to learn task-specific policies. We evaluate our model on several image classification tasks, where it significantly outperforms a convolutional neural network baseline on cluttered images, and on a dynamic visual control problem, where it learns to track a simple object without an explicit training signal for doing so.", "creator": "LaTeX with hyperref package"}}}