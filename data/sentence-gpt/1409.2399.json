{"id": "1409.2399", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Sep-2014", "title": "Prioritized Planning Algorithms for Trajectory Coordination of Multiple Mobile Robots", "abstract": "An important capability of autonomous multi-robot systems is to prevent collision among the individual robots. One approach to this problem is to plan conflict-free trajectories and let each of the robots follow its pre-planned trajectory. A widely used practical method for multi-robot trajectory planning is prioritized planning, which has been shown to be effective in practice, but is in general incomplete. Formal analysis of instances that are provably solvable by prioritized planning is still missing. Moreover, prioritized planning is a centralized algorithm, which may be in many situations undesirable. A variety of algorithms (such as a hierarchical algorithm) have a large amount of information to keep track of. It is possible to use a comprehensive set of algorithms to identify a single example. Such algorithms typically have no information about the behavior of the individual robots. In the most efficient, efficient way, the automated algorithm will ensure that the robots that are currently in a position to enter the same zone can never encounter the situation, as well as the interactions between them.\n\n\n\nThe main objective of automated multi-robot trajectory planning is to provide an overall picture of the direction a given robot is approaching. It is important to understand the relative magnitude of collision between a specific robot and the selected robot. It is important to consider a general equilibrium that is at an average location. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a particular robot and the selected robot. This is especially important for multi-robot trajectory planning. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a specific robot and the selected robot. This is especially important for multi-robot trajectory planning. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a particular robot and the selected robot. This is especially important for multi-robot trajectory planning. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a particular robot and the selected robot. This is especially important for multi-robot trajectory planning. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a particular robot and the selected robot. This is especially important for multi-robot trajectory planning. It is important to consider the relationship between autonomous robots and each other by considering the relative magnitude of collision between a particular robot and the selected robot. This is especially important for multi", "histories": [["v1", "Mon, 8 Sep 2014 15:38:31 GMT  (5955kb,D)", "http://arxiv.org/abs/1409.2399v1", null]], "reviews": [], "SUBJECTS": "cs.RO cs.AI cs.MA", "authors": ["michal \\v{c}\\'ap", "peter nov\\'ak", "alexander kleiner", "martin seleck\\'y"], "accepted": false, "id": "1409.2399"}, "pdf": {"name": "1409.2399.pdf", "metadata": {"source": "CRF", "title": "Prioritized Planning Algorithms for Trajectory Coordination of Multiple Mobile Robots", "authors": ["Michal \u010c\u00e1p", "Peter Nov\u00e1k", "Alexander Kleiner", "Martin Seleck\u00fd"], "emails": [], "sections": [{"heading": null, "text": "In this paper we a) propose a revised version of prioritized planning and characterize the class of instances that are provably solvable by the algorithm and b) propose an asynchronous decentralized variant of prioritized planning, which maintains the desirable properties of the centralized version and in the same time exploits the distributed computational power of the individual robots, which in most situations allows to find the joint trajectories faster.\nThe experimental evaluation performed on real-world indoor maps shows that a) the revised version of prioritized planning reliably solves a wide class of instances on which both classical prioritized planning and popular reactive technique ORCA fail and b) the asynchronous decentralized algorithm provides solution faster than the previously proposed synchronized decentralized algorithm.\nNote to Practitioners\u2014Consider a large warehouse in which the goods are stored and retrieved by autonomous transport robots. One option is to ignore interaction between the vehicles during the route planning for each robot and handle the conflicts only during the route execution. However, such approach is prone to deadlocks, i.e. to a situations during which some of the robots mutually block each other, cannot proceed and fail to complete their transportation task. An alternative approach would involve planning collision-free routes for each robot before the robots start executing them. However, the general methods for this problem that guarantee a solution are impractical due to their high computational complexity. In this paper, we show that a simple prioritized approach in which robots plan their routes one after another is guaranteed to find collision-free trajectories for a welldefined class of practical problems. In particular, if the systems resembles human-made transport infrastructures by requiring that the start and destination position of each vehicle must never obstruct other vehicles from moving, then the proposed approach is guaranteed to provide a solution. E.g., in such a warehouse application, the collision-free routes can efficiently computed by the prioritized approach. The paper contains formal condition that characterizes the problem instances for which is the method guaranteed to work.\nFurther, we propose a new decentralized adaptation of the prioritized algorithm that can be used in multi-robot systems without a central solver. This technique can be used to find coordinate trajectories just by running simple negotiation protocol between the individual robots. The paper contains analysis showing that the decentralized algorithm exhibits desirable theoretical properties and experimental comparison of performance of different variations of centralized and decentralized algorithms.\nIndex Terms\u2014multi-robot systems, trajectory planning, collision avoidance, decentralized algorithms\nI. INTRODUCTION When mobile robots autonomously operate in a shared space, one of the crucial issues is how to coordinate the trajectories of individual robots so as to prevent potential collisions. The two most commonly used classes of methods that deal with this problems are multi-robot planning and reactive collision avoidance.\nMulti-robot motion planners take into consideration the start and goal position of each robot and plan coordinated trajectories that are mutually conflict-free. If the robots execute the resulting joint plan precisely (or within some given tolerance), it is guaranteed that the robots will reach their goals without collision. However, it is known that even the simplest variants of multi-robot path planning problem are intractable. Deciding whether a coordinated collision-free paths exist for multiple discs moving amidst polygonal obstacles is known to be strongly NP-hard [13]; the same task involving rectangular objects in an empty room is known to be in PSPACE-hard [5].\nThe multi-robot planners are typically based either on the coupled heuristic search in the joint state space of all robots or on decoupled planning. The coupled approaches typically find optimal solutions [14], [15], [20], but do not scale well with the increasing number of conflicting robots.\nOn the other hand, decoupled approaches plan independently for each robot. They can be fast enough for real-time applications, but they typically suffer from incompleteness.\nA widely used decoupled scheme for the multi-robot motion planning that has been shown to be effective in practice is prioritized planning [4]. In prioritized planning, each robot is assigned a unique priority and the algorithm proceeds sequentially from the highest priority robot to the lowest priority one. At each iteration, one of the robots plans its trajectory such that it avoids the higher-priority robots. Such a greedy approach is clearly incomplete if we allow arbitrary maps and arbitrary start and goal locations for each robot, but in relatively sparse environments, the techniques tends to perform well.\nRecently, Velagapudi et al. presented a decentralized version of prioritized planning technique for teams of mobile robots [19], which is able to utilize the distributed computational resources to reduce the time needed to find a solution. Since the algorithm proceeds in globally-synchronized rounds, faster-computing robots have to wait at the end of each round for the longest-computing robot and thus the distributed computational power may not be used efficiently.\nar X\niv :1\n40 9.\n23 99\nv1 [\ncs .R\nO ]\n8 S\nep 2\n01 4\n2 The contribution of this paper is twofold: 1) We propose a revised version of the prioritized planning scheme and show that for this revised version it is possible to provide sufficient conditions under which is the algorithm guaranteed to provide a solution. 2) We propose an novel asynchronous decentralized variant of both classical and revised prioritized planning scheme that is guaranteed to terminate and inherits completeness properties from the respective centralized counterpart. We experimentally show that asynchronous decentralized algorithm exhibits better utilization of the distributed computational resources and thus provides faster convergence times compared to the previously presented synchronized approach. Finally, we demonstrate a practical applicability of the asynchronous approach in a cooperative multi-UAV scenario.\nPartial results of the presented work appeared in [3], [18], where the focus was on the design of asynchronous version of decentralized prioritized planning. Here, we extend our previous work by proposing the revised version of prioritized planning scheme, by theoretical analysis of the properties of all discussed algorithms, by performing experimental comparison on real-world indoor maps and by including reactive techniques into the comparison."}, {"heading": "II. PROBLEM DEFINITION", "text": "Consider n circular robots operating in a 2-d workspace W \u2286 R2. The subset of W occupied by the body of robot i when its center is on position x is denoted as Ri(x). The maximum speed the robot i can move at is denoted as vi. Each robot is assumed to be assigned a task that involves moving from its start position si to some goal position gi and stay there. We assume that the start and goal positions of all robots are mutually disjunct, i.e. the bodies of robots do not overlap when the robots are on their start positions and when they are on their goal positions.\nA path p : [0, 1]\u2192W of robot i in workspace W is called satisfying if it starts at the robot\u2019s start position si, ends at robot\u2019s goal position gi, and the body of robot whose center follows the path p always lies entirely in W . A trajectory \u03c0 : [0,\u221e) \u2192 W is a mapping from time points to positions in workspace and unlike a path it carries information about how it should be executed in time. Analogically, a trajectory of robot i is called satisfying if it starts at the robot\u2019s start position si, finally reaches and stays at the goal position gi, the body of robot i whose center follows the trajectory \u03c0 always lies entirely in W , and the robot never moves faster than its maximum speed vi.\nThe trajectories \u03c0i, \u03c0j of two robots i, j are said to be conflict-free if the bodies of the robots i, j never intersect when they follow the trajectories \u03c0i and \u03c0j .\nProblem 1 (Trajectory Coordination Problem). Given a workspace W and tasks \u3008s1, g1\u3009 , . . . , \u3008sn, gn\u3009 for robots 1, . . . , n, find trajectories \u03c01, . . . , \u03c0n such that each trajectory \u03c0i is satisfying for robot i and trajectories \u03c0i, \u03c0j of every two different robots i, j are mutually conflict-free."}, {"heading": "Notation", "text": "The following shorthand notations will be used to talk about regions occupied by a different subsets of robots at their start and goal positions:\nSi := Ri(si) G i := Ri(gi)\nS>i := \u222a j=i+1,...,n Rj(sj) G <i := \u222a j=1,...,i\u22121 Rj(gj)\nS := \u222a j=1,...,n Rj(sj) G := \u222a j=1,...,n Rj(gj)\nFurther, we will work with the concept of a space-time region: When a spatial object, such as the body of a robot, follows a given trajectory, then it can be thought of as occupying a certain region in space-time T :=W\u00d7 [0,\u221e). A dynamic obstacle \u2206 is then a region in such a space-time T . If (x, y, t) \u2208 \u2206, then we know that the spatial position (x, y) is occupied by dynamic obstacle \u2206 at time t. The function\nR\u2206i (\u03c0) := {(x, y, t) : t \u2208 [0,\u221e) \u2227 (x, y) \u2208 Ri(\u03c0(t))}\nmaps trajectories of a robot i to regions of space-time that the robot i occupies when its center point follows given trajectory \u03c0. As a special case, let R\u2206i (\u2205) := \u2205."}, {"heading": "Assumptions on Communication", "text": "We assume that each robot is equipped with an independent computation unit and a wireless device for communication with other robots. Wireless communication channels are typically implemented as broadcast channels, where each communicated message is broadcast, but ignored by the nodes that are not among the declared recipients of the message. In such a channel a single broadcast message uses the same channel capacity as a single point-to-point message and thus we will prefer to perform a single broadcast instead of sending several point-to-point messages. Further, in the following discussion we will assume that such a communication channel is reliable, i.e. each broadcast messages is eventually received by all robots in the system, and that the communication channel preserves the ordering of messages that were sent in."}, {"heading": "III. PRIORITIZED PLANNING", "text": "A straightforward approach to solve the trajectory coordination problem would be to see all robots in the system as one composite robot with many degrees of freedom and use some path planning algorithm to find a joint path for all the robots. However, the size of such a joint configuration space is exponential in the number of robots and thus this approach quickly becomes impractical if one wants to plan for more than a few robots. A pragmatic approach that is often useful even for large multi-robot teams is prioritized planning. The idea has been first articulated by Erdman and Lozano-P\u00ef\u00bf\u0153rez in [4]. Other works such as [16], [2] investigate techniques for choosing a good prioritization for the robots.\n3"}, {"heading": "Classical Prioritized Planning", "text": "In prioritized planning each robot is assigned a unique priority. The trajectories for individual robots are then planned sequentially from the highest priority robot to the lowest priority one. For each robot a trajectory is planned that avoids both the static obstacles in the environment and the higherpriority robots moving along the trajectories planned in the previous iterations. The pseudocode of classical prioritized planning is in Algorithm 1.\nAlgorithm 1: Classical Prioritized Planning 1 Algorithm PP 2 \u2206\u2190 \u2205; 3 for i\u2190 1 . . . n do 4 \u03c0i \u2190Best-traj(W,\u2206); 5 if \u03c0i = \u2205 then 6 report failure and terminate\n7 \u2206\u2190 \u2206 \u222aR\u2206i (\u03c0i);\n8 Function Best-traj(W \u2032,\u2206) 9 return optimal satisfying trajectory for robot i in W \u2032\nthat avoids regions \u2206 if it exists, otherwise return \u2205\nThe algorithm iterates over the robots, starting from the highest-priority robot 1 to the lowest-priority robot n. During i-th iteration the algorithm computes a trajectory for robot i that avoids the space-time regions occupied by robots 1, . . . , i\u2212 1.\nThe trajectory of robot i is computed in Best-traj(W \u2032,\u2206) function. The function returns a trajectory for robot i such that body of the robot always stays inside the static workspace W \u2032 and avoids dynamic regions \u2206 occupied by other robots. Such a function would be in practice implemented using some application-specific technique for motion planning with dynamic obstacles, e.g. [17] or [10]. As it will become clear later, it is desirable that this function is implemented using an algorithm that offers some form of completeness, since this property will be inherited also by the multi-robot algorithm.\nProperties: The algorithm terminates either with success or with failure in at most n iterations. The successful termination occurs in exactly n iterations if valid trajectories for all robots have been found. The termination with failure occurs if there exists a robot for whom no satisfying trajectory that avoids higher-priority robots have been found.\nWhen the algorithm terminates successfully, each robot is assigned a trajectory that is conflict-free with the trajectories of all other robots. This follows from the fact that the final trajectory of each robot i is conflict-free with the higherpriority robots, since robot i avoided collision with them and also with lower-priority robots since they avoided conflict with the trajectory of robot i themselves.\nPrioritized planning is in general incomplete, consider the counter-example [12] depicted in Figure 1:\nLet us now analyze when is prioritized planning bound to fail. The algorithm fails to find a trajectory for robot i if 1) no satisfying path exists for robot i, i.e. the robot cannot reach its destination even if there are no other robots in the workspace; 2) every satisfying trajectory of robot i is in conflict with some higher-priority robot. There are two types of conflicts that can occur between a satisfying trajectory \u03c0 of robot i and a higher-priority robot:\nType A: Occurs if trajectory \u03c0 is in conflict with a higherpriority robot who has reached and is \u201csitting\u201d at its destination, i.e. it is blocked by a static higher-priority robot. The following Figure shows a scenario where all satisfying trajectories of a robot are in Type A conflict:\nType B: Occurs if trajectory \u03c0 of robot i is in conflict with a higher-priority robot who is moving towards its destination, i.e. it is \u201crun over\u201d by a moving higher-priority robot. The following Figure shows a scenario where all satisfying trajectories of a robot are in Type B conflict:\n4\nA question that naturally arises is whether it would be possible to restrict the class of solvable instances or to alter the prioritized planning algorithm such that there will always be at least one trajectory without neither Type A nor Type B conflict for each robot.\nOne way to ensure that there will be a satisfying trajectory without Type A conflict for every robot is to only consider instances, where each robot has a path to its goal that avoids goal regions of all higher-priority robots. When each robot follows such a path, then they cannot be engaged in a Type A conflict, because a Type A conflict can only occur at the goal region of one of the higher-priority robots.\nUnfortunately, the existence of a trajectory without Type B conflict is difficult to guarantee in classical prioritized planning, since higher-priority robots completely ignore interactions with lower-priority robots when planning their trajectories. To ensure that each robot will have a satisfying trajectory without Type B conflict, all higher-priority robots would have to plan their trajectories so that the lower-priority robots are always left with some alternative trajectory that can be used to avoid the potential conflicts of this type.\nOne way to ensure that there will be a satisfying trajectory without Type B conflict for every robot is to consider only instances where each robot has a path to its goal that avoids start region of lower-priority robots and enforce that the trajectory of each robot will avoid start regions of all lowerpriority robots. When this is ensured, then any robot will always have a fall-back option to wait at its start position (since no higher-priority robot can run over its start region) until its desired path is clear of all higher-priority robots. Thus it can always avoid Type B conflicts.\nMoreover, if the robot continues by following a path that avoids goal regions of higher-priority robots, then the resulting trajectory is also guaranteed to avoid the Type A conflicts.\nTheorem 2. Let us have a trajectory coordination problem with workspace W and tasks \u3008s1, g1\u3009 , . . . , \u3008sn, gn\u3009 for robots 1, . . . , n. If for every robot i there exist a S>i-avoiding and G<i-avoiding satisfying path, then a sequential conflict-free solution can be constructed.\nProof: We will construct the solution inductively as follows:\nInduction assumption: Trajectories of robots 1, . . . , i \u2212 1 are satisfying and S>i\u22121-avoiding.\nBase step (robot 1): Robot 1 is the highest-priority robot. There are no higher-priority robots that the robot 1 needs to avoid. From our assumption there exists a path p that is satisfying for robot 1 and S>1-avoiding. A satisfying and S>1avoiding trajectory for robot 1 can be simply constructed by following the path p at an arbitrary positive speed. Such a trajectory can always be constructed, therefore the algorithm will not report failure when planning for robot 1.\nInduction step (robot i): From our assumption there exists a path p that is satisfying for robot i, S>i-avoiding and G<i-avoiding. Since all trajectories for robots 1, . . . , i \u2212 1 are satisfying (i.e. eventually reach the goal and stay there) then there must exists a time point t after which all robots 1, . . . , i \u2212 1 have reached and will stay at their goal. A satisfying and S>i-avoiding trajectory for robot i that is conflict-free with all robots 1, . . . i\u2212 1 can be constructed as follows: \u2022 In interval [0, t] stay at si. The trajectory cannot be in\nconflict with higher-priority robots during this interval, because all trajectories of robots 1, . . . , i \u2212 1 are S>i\u22121 and thus also Si-avoiding. \u2022 In interval [t,\u221e] follow path p until the goal position gi is reached. The path p avoids regions G<i and thus the trajectory cannot be in collision with any of the higher-priority robots 1, . . . , i \u2212 1 because they are at their goal positions during this time interval, which the path p avoids.\nSuch a trajectory can always be constructed. The trajectories of robots 1, . . . , i \u2212 1 are satisfying and S>i\u22121-avoiding, which implies that they are also S>iavoiding. The newly computed trajectory for robot i is satisfying and S>i-avoiding. By taking the union of the old set of trajectories and the new trajectory we have a set of trajectories for robots 1, . . . , i that are satisfying and S>i-avoiding.\nAs we can see from the constructive proof of Theorem 2, the instances that admit S>i-avoiding and G<i-avoiding paths for each robot can be solved by a simple sequential algorithm that navigates all robots one-after-another along their shortest S>i-avoiding and G<i-avoiding paths. Albeit simple, such an approach never lets two robots to move concurrently and thus it typically generates solutions of poor quality. The solution quality can be improved if we adopt the prioritized planning approach and find for each robot a best S>i-avoiding trajectory that avoids conflicts with higher-priority robots."}, {"heading": "Revised Prioritized Planning", "text": "We propose a Revised version of Prioritized Planning (RPP) that uses the insights from the preceding discussion and plans the trajectory of each robot so that both a) start position of all lower-priority robots are avoided and b) conflicts with higherpriority robots are avoided. The pseudocode of RPP is listed in Algorithm 2.\nProperties: The RPP algorithm inherits the termination and soundness properties from the PP algorithm. The algorithm terminates successfully in n iterations if a trajectory for each\n5 Algorithm 2: Revised Prioritized Planning 1 Algorithm RPP 2 \u2206\u2190 \u2205; 3 for i\u2190 1 . . . n do 4 S \u2190\n\u22c3 j>i Sj\n5 \u03c0i \u2190Best-traj(W \\ S,\u2206); 6 if \u03c0i = \u2205 then 7 report failure and terminate;\n8 \u2206\u2190 \u2206 \u222aR\u2206i (\u03c0i);\nrobot has been found. The algorithm terminates with failure at iteration i < n if there is a robot i for whom a satisfying trajectory in W \\ S has not been found.\nIn general, it is not guaranteed that a trajectory that avoids both start positions of lower-priority robots and regions occupied by higher-priority robots will exist for each robot and thus the algorithm may fail to provide a solution to a solvable problem instance. Consider e.g. the example in Figure 1 once again. However, for the instances characterized by the following condition, the solution is guaranteed exists and RPP will find it.\nCorollary 3. If there is a S>i-avoiding, G<i-avoiding satisfying path for every robot i and a complete algorithm is used for the single-robot trajectory planning in Best-traj function, then RPP is guaranteed to terminate with conflictfree solution.\nProof: Consider the inductive argument from the proof of Theorem 2. The argument states that at every iteration, there exists a S>i-avoiding satisfying trajectory for robot i that avoids all higher-priority robots. Since the single-robot planning algorithm is assumed to be complete, it cannot fail in finding such a trajectory.\nValid Infrastructures\nConsider a situation when one designs a closed multirobot systems such as a warehouse with a large number of autonomous vehicles. Then, we can exploit the Theorem 2 and Corollary 3 to design the environment and allowed tasks of the robots in such a way that S>i-avoiding and G<i-avoiding paths will always exists and RPP will be consequently guaranteed to provide a conflict-free solution to every trajectory coordination query. An important class of environments that satisfy the condition of having a S>i-avoiding and G<iavoiding paths for every possible task of every robot are valid infrastructures.\nLet D(x, r) be a closed disk centered at x with radius r and intr X be an r-interior of set X defined as\nintr X := {x : D(x, r) \u2286 X} .\nAny path that lies entirely in intr X will have r-clearance with respect to X , i.e. any point on the path will be at minimum distance r from the closest boundary of X .\n(a) Valid infrastructure: The workspace W and endpoints {e1, e2, e3, e4} for robot having radius r form a valid infrastructure. (b) Invalid infrastructure: The workspace W and endpoints {e1, e2, e3} do not form a valid infrastructure because there is no path from e1 to e2 with 2r-clearance to e3 for a robot having radius r.\nFigure 4: Valid and invalid infrastructure\nWe say that a workspaceW together with a set of endpoints E form a valid infrastructure for circular robots with maximum radius r if any two endpoints can be connected by a path\nin workspace intr ( W \\ \u222a\ne\u2208E D(e, r)\n) , i.e. there must exists a\npath between any two endpoints with at least r-clearance to the boundary of the workspace and at least 2r-clearance to any other endpoint. Figure 4 illustrates the concept of a valid infrastructure.\nThe notion of valid infrastructures follows the structure typically witnessed in man-made environments that are intuitively designed to allow efficient transit of multiple people or vehicles. In such environments, the endpoint locations where people or vehicle stop for long time are separated from the transit area that is reserved for travel between these locations.\nIn a road network, for example, the endpoints would be the parking places and the system of roads is built in such a way that any two parking places are reachable without crossing any other parking place. Similar structure can be witnessed in offices or factories. The endpoints would be all locations, where people may need to spend longer periods of time, e.g. surroundings of the work desks or machines. As we know from our every day experience, work desks and machines are typically given enough free room around them so that a person working at a desk or a machine does not obstruct people moving between other desks or machines. We can see that real-world environments are indeed often designed as valid infrastructures.\nSuppose that a particular workspace W and a set of endpoints E form a valid infrastructure for robots having radius r. An instance of multi-robot trajectory coordination problem in such an infrastructure would then involve a number of robots traveling from one endpoint to another so that each endpoint is used by at most one robot. From the valid infrastructure property, we know that for each robot there is a path p from its start endpoint to its goal endpoint that avoids all other endpoints in the infrastructure with 2r clearance. Since all other robots\u2019 start and goal positions lie at some endpoint, the path p is also avoiding start and goal position of every other robot. In other words, for every robot there is a path that is S\u2212i-avoiding and G\u2212i-avoiding, which implies that\n6 the path is also S>i-avoiding and G<i-avoiding. Therefore, all trajectory coordination queries between the endpoints of a valid infrastructure will be successfully solved by RPP algorithm, given that a complete algorithm is used for the single robot trajectory planning."}, {"heading": "Checking Solvability", "text": "Now consider an open multi-robot system in which new robot tasks can appear any time and we cannot guarantee that the robots will move only between pre-designed endpoints. Then we can use Theorem 2 to check whether adding a new robot task maintains sequential solvability of the trajectory coordination problem between the existing robots and the new robot. If it does not, then we can decide to reject or delay the adding of new robot task. Corollary 3 gives us sufficient condition that can be used to quickly determine whether a particular problem instance is solvable by RPP without actually running the algorithm. This is done by verifying that S>i-avoiding and G<i-avoiding satisfying path exists for each robot. Deciding whether such paths exist amounts to planning n spatial paths amidst static obstacles, which is in practice significantly faster than planning n spatio-temporal trajectories amidst dynamic obstacles which would have to be done if RPP is executed."}, {"heading": "Limitations", "text": "We have shown that there is a class of instances that RPP completely covers, but PP does not. However, outside this class we can find instances that PP solves, but RPP does not. Consider the following scenario:\nNone of the algorithm is therefore superior to the other in terms of instance coverage.\nFurther, since RPP avoid start regions preemptively, even when they can be safely passed through, the solutions generated by RPP tend to be be slightly longer than the ones generated by PP. This can be demonstrated in the following scenario:\nFigure 6: When RPP searches for a trajectory for robot 1 it has to avoid start position of robot 2, resulting in the curved trajectory as depicted in the picture. On the other hand, PP would generate a shorter straight-line trajectory connecting start and destination of robot 1.\nWe can see that despite the theoretical guarantees of RPP, there exist situations in which PP would be a more appropriate choice than RPP."}, {"heading": "IV. DECENTRALIZED ALGORITHMS", "text": "Imagine a multi-robot system consisting of a large number of heterogeneous autonomous robots. In such a scenario, a decentralized implementation of (revised) prioritized planning may be more desirable than a centralized one. In a decentralized implementation, each robot runs its own instance of the algorithm and exchanges messages with the other robots according to a prescribed communication protocol. If an inconsistency is detected by a robot, then it recomputes the best trajectory for itself using its own on-board computation resources. The process should eventually converge to a state where all robots hold mutually conflict-free trajectories.\nAn advantage of such an approach is that several robots often end up computing their trajectories in parallel and thus a conflict-free solution is usually computed faster. Another advantage for multi-robot systems with heterogeneous robots is that the kinematic and other potentially implicit constraints on the trajectory of a particular robot stay local to that robot and do not need to be formalized nor communicated, which simplifies the design of the communication protocol and allows each robot to use a custom robot-specific planner for planning its trajectory."}, {"heading": "Synchronized Decentralized Implementation", "text": "A decentralized implementation of classical prioritized planning scheme, where robots concurrently proceed in synchronize rounds, has been first presented by Velagapudi et al. in [19]. We will use their approach as a baseline decentralized implementation of (revised) prioritized planning and denote the resulting algorithm as synchronized decentralized implementation of (revised) prioritized planning, SD-(R)PP.\nThe algorithm proceeds in synchronized rounds. During every round, each robot ensures that its current trajectory is consistent with the trajectories of higher-priority robots from the previous round. If the current trajectory is consistent, then the robot keeps its current trajectory and remains silent. Otherwise, it finds a new consistent trajectory for itself and broadcasts the trajectory to all other robots. When a robot finishes its computation in the current round, then it waits for all\n7 other robots to finish the round and all robots simultaneously proceed to the next round. The algorithm successfully finishes if none of the robots changes its current trajectory during a single round. The SD-PP algorithm finishes with failure if there is a robot that fails to find a trajectory that avoids the higher-priority robots following their respective trajectories. The SD-RPP algorithm, on the other hand, finishes with failure if there is a robot that fails to find a satisfying trajectory that avoids the start positions of lower-priority robots. The pseudocode of SD-(R)PP is listed in Algorithm 3.\nAlgorithm 3: Synchronized Decentralized Implementation of (Revised) Prioritized Planning. Pseudocode for robot i\n1 Algorithm SD-(R)PP 2 \u03c0i \u2190 \u2205; 3 Hi \u2190 \u2205;\n4 S \u2190 \u2205 for SD-PP\u22c3 j>i Sj for SD-RPP ; 5 repeat 6 \u03c0\u2217 \u2190 Find-consistent(\u03c0i,W \\ S,\u2206(Hi)); 7 if \u03c0\u2217 = \u2205 then 8 report failure and terminate; 9 else if \u03c0\u2217 6= \u03c0i then\n10 \u03c0i \u2190 \u03c0\u2217; 11 broadcast INFORM(i, R\u2206i (\u03c0\u2217)); 12 wait for INFORM messages from all other\nrobots, wait for all other robots to finish processing INFORM messages ;\n13 until not global termination detected; 14 Handle-message INFORM(j,\u2206j) 15 if j < i then 16 Hi \u2190(\nHi \\ { (j,\u2206\u2032j) : (j,\u2206 \u2032 j) \u2208 Hi }) \u222a {(j,\u2206j)};\n17 Function Find-consistent(\u03c0,W,\u2206) 18 if \u03c0 = \u2205 \u2228 \u00acconsistenti(\u03c0,\u2206) then 19 \u03c0\u2217 \u2190Best-traji(W,\u2206); 20 return \u03c0\u2217; 21 else 22 return \u03c0;\nIn SD-(R)PP, each robot i maintains a database of spacetime regions occupied by higher-priority robots. We call such a database a trajectory store and model it as a set of pairs Hi = {(j,\u2206j)}, where \u2206j is the space-time region occupied by robot j.\nFunction \u2206(H) represents the region of the space-time occupied by all robots stored in a trajectory store H:\n\u2206(H) := \u222a (j,\u2206j)\u2208H \u2206j .\nFurther, we use a predicate consistenti(\u03c0,\u2206) to express that robot i following the trajectory \u03c0 is collision-free against\ndynamic obstacles \u2206, defined as:\nconsistenti(\u03c0,\u2206) := R \u2206 i (\u03c0) \u2229 \u2206 = \u2205.\nProperties: In order to facilitate and simplify exposition of the later introduced asynchronous algorithm, we developed an alternative proof of termination of the SD-(R)PP algorithm, which deviates from the original one devised by the authors of SD-PP in [19]. Further, in this section we show that SD(R)PP inherits the soundness and completeness properties from its respective centralized counterpart.\nThe SD-(R)PP algorithm is guaranteed to terminate. First we need to define what does termination mean for a decentralized algorithm. A decentralized algorithm \u2022 terminates when all robots stop computing, \u2022 terminates with failure if it terminates and there is at\nleast one robot that reported failure during the computation, \u2022 terminates successfully if it terminates and does not terminate with failure.\nTo show that SD-(R)PP terminates, we first show that robots running SD-(R)PP cannot exchange messages forever.\nProposition 4. All robots running SD-(R)PP algorithm eventually stop sending INFORM messages.\nProof: We will proceed by induction on the robot priority i. Inductive hypothesis: Robots 1, . . . , i \u2212 1 eventually stop sending messages. Base step (robot 1): Robot 1 is the highest-priority robot and as such it does not receive any message from a higher-priority robot. Therefore, its trajectory store will stay empty. During the initialization, the robot 1 either successfully finds its initial trajectory and broadcasts a single message or reports a failure and terminates. Since its trajectory store is empty, its initial trajectory will never become inconsistent, the robot will therefore never replan and send any further INFORM message. Induction step (robot i): From the inductive hypothesis we know that each of the robots 1, . . . , i\u2212 1 eventually stops broadcasting messages. After the last message from the robots 1, . . . , i \u2212 1 has been received by robot i, its trajectory store gets updated for the last time, since from our assumption there are no more messages from higher-priority robots. After trajectory store changes for the last time, the robot either a) keeps its current trajectory if it is consistent with the last trajectory store, b) finds a new consistent trajectory or c) terminates with failure. In cases a) and b), the current trajectory will never become inconsistent again because trajectory store does not change anymore and thus robot will never have to replan and communicate the new trajectory. In case c), the robot has terminated and thus it won\u2019t send any further messages. We see that after robots 1, . . . , i\u22121 stopped sending messages, also robot i eventually stops sending messages.\nCorollary 5. SD-(R)PP terminates.\nProof: We know that all robots in the system will eventually stop sending messages. Assume that the last message\n8 is broadcast during round k. In the round k + 1, no robot changes its trajectory since otherwise a message would have to be broadcast which is a contradiction. If no robot changes its trajectory during the round, the global termination condition is satisfied and the system terminates.\nUnless a failure is reported by one of the robots, the solution computed when SD-(R)PP terminates is sound:\nProposition 6. When SD-(R)PP successfully terminates, then all robots hold trajectories that are mutually conflict-free.\nProof: Let \u03c0i be the trajectory of robot i after the algorithm terminated. We need to show that\n\u2200i, j : i 6= j \u21d2 \u03c0i and \u03c0j are conflict-free.\nTake two arbitrary, but different robots i,j. Since the conflictfree relation is symmetrical, we can assume j < i w.l.o.g. If robot i stopped computing without failure, then it must have received the INFORM message from higher-priority robot j carrying its last trajectory \u03c0j at some point before its termination. Since there are no further INFORM messages broadcast by robot j, the trajectory store of robot i will contain \u03c0j from that point on. Every trajectory returned by Find-consistent function for robot i from that point on will be conflict-free with \u03c0j and thus also its last trajectory \u03c0i will be conflict-free with \u03c0j .\nThe synchronized decentralized implementation of PP and RPP inherit completeness properties from the respective centralized implementations. In general, both SD-PP and SD-RPP are incomplete. However if S>i-avoiding and G<i-avoiding satisfying path exists for each robot, then the SD-RPP is guaranteed to terminate successfully.\nProposition 7. If there is a S>i-avoiding, G<i-avoiding satisfying path for every robot i and a complete algorithm is used for the single-robot trajectory planning in Best-traj function, then SD-RPP is guaranteed to terminate with a conflict-free solution.\nProof: The argument used in the proof of Theorem 3, which shows that RPP will never fail during planning, can be extended to decentralized implementations of RPP: Take arbitrary replanning request for robot i. All trajectories of each higher-priority robot j < i have been generated to be S>javoiding and thus such trajectory will be also Si-avoiding. All trajectories in the trajectory store of robot i are therefore Si-avoiding. An S>i-avoiding satisfying trajectory consistent with trajectories of higher-priority robots can be constructed as follows. Wait at start position si until all higher-priority robots reach their goal position and then follow the S>iavoiding G<i-avoiding satisfying path from the assumption. Since such a trajectory is guaranteed to exist for robot i and a complete replanning algorithm is used, the replanning cannot report failure. The algorithm must terminate with success."}, {"heading": "Asynchronous Decentralized Implementation", "text": "Due to its synchronous nature, the SD-(R)PP algorithm does not fully exploit the computational resources distributed among individual robots. In every iteration, the robots that\nfinished their trajectory planning routine sooner, or did not have to re-plan at all, idle while waiting for the slower computing robots in that round, even though they could use the time to resolve some of the conflicts they have among themselves and speed up the overall process. An example of a situation, where the asynchronous algorithm would be beneficial is illustrated in Figure 7.\nTo deal with such an inefficiency, we propose an asynchronous decentralized implementation of the (revised) prioritized planning scheme, abbreviated as AD-(R)PP. The pseudocode code of AD-(R)PP is exposed in Algorithm 4. The asynchronous algorithm replaces the concept of globally synchronized rounds (while loop in Algorithm 3) by a reactive approach in which every robot reacts merely to incoming INFORM messages. Upon receiving an INFORM message (Handle-message INFORM(j,\u2206j) routine in Algorithm 4), the robot simply replaces the information about the trajectory of the sender robot in its trajectory store and checks whether its current trajectory is still consistent with the new contents of its trajectory store. If the current trajectory is inconsistent, the robot triggers replanning and inform other robots about its new trajectory, otherwise the robot keeps its current trajectory and remains silent.\nAlgorithm 4: Asynchronous Decentralized Implementation of (Revised) Prioritized Planning\n1 Algorithm AD-(R)PP 2 \u03c0i \u2190 \u2205; 3 Hi \u2190 \u2205;\n4 S \u2190 \u2205 for AD-PP\u22c3 j>i Sj for AD-RPP ; 5 \u03c0i \u2190Find-consistent(\u03c0i,W\\S,\u2206(Hi)); 6 if \u03c0i = \u2205 then 7 report failure and terminate; 8 else 9 broadcast INFORM(i, R\u2206i (\u03c0i));\n10 wait for global termination;\n11 Handle-message INFORM(j,\u2206j) 12 if j < i then 13 Hi \u2190(\nHi \\ { (j,\u2206\u2032j) : (j,\u2206 \u2032 j) \u2208 Hi }) \u222a {(j,\u2206j)};\n14 \u03c0\u2217 \u2190 Find-consistent(\u03c0i,W \\ S,\u2206(Hi)); 15 if \u03c0\u2217 = \u2205 then 16 report failure and terminate; 17 else if \u03c0\u2217 6= \u03c0i then 18 \u03c0i \u2190 \u03c0\u2217; 19 broadcast INFORM(i, R\u2206i (\u03c0\u2217));\nProperties: AD-(R)PP inherits all the desirable properties from its synchronized and centralized coutnerparts, i.e. it terminates and if it terminates with success than all the robots will hold conflict-free trajectories. Further, AD-RPP is guaranteed to solve instances that admit S>i-avoiding and G<i-avoiding path for each robot.\n9\nProposition 8. AD-(R)PP terminates.\nProof: Recall that the inductive argument demonstrating that robots running SD-(R)PP will eventually stop sending messages (Lemma 4) does not make use of the synchronization points in SD-(R)PP and thus it is also valid for AD-(R)PP. By this argument, we know that there is a finite number of messages being sent. We can observe that a robot running AD(R)PP performs computation only during initialization or when it processes an incoming message. When all robots process their last incoming messages, the system terminates.\nProposition 9. When AD-(R)PP successfully terminates, then all robots hold trajectories that are mutually conflict-free.\nProof: The proof of soundness of SD-(R)PP (Proposition 6) is directly applicable also to AD-(R)PP.\nProposition 10. If S>i-avoiding, G<i-avoiding satisfying path exists for every robot i and a complete algorithm is used for the single-robot trajectory planning in Best-traj function, then AD-RPP terminates.\nProof: The proof of Proposition 7, where this property is demonstrated to hold for SD-RPP, is directly applicable also for AD-RPP."}, {"heading": "V. EXPERIMENTAL ANALYSIS", "text": "We compare the performance of PP, RPP, SD-PP, SD-RPP, AD-PP, AD-RPP in terms of coverage, runtime, communication complexity and solution quality. The comparison was performed in three real-world environments (see Figure 8a, 9a and 10a). For each of the environments we generated two sets of problem instances: 1) In free-formed tasks instance set, each robot is assigned a task to move from a randomly selected start position to a randomly selected goal position. 2) In infrastructure tasks instance set, we generated a set of endpoints that together with a particular roadmap discretization of the environment form a valid infrastructure; each robot\nis then assigned a random endpoint as a start position and a randomly chosen endpoint as a destination position.\nFor the decentralized algorithms (SD-PP, SD-RPP, AD-PP and AD-RPP), we assume that each robot uses its own onboard CPU to compute its trajectory. To measure the runtime characteristics of the execution of decentralized algorithms, we emulate the concurrent execution of the algorithms using a discrete-event simulation. The simulation measures the execution time of each message handling and uses the information to simulate the concurrent execution of the decentralized algorithm as if it is executed on n independent CPUs, where n is the number of robots. The concurrent process execution simulator was implemented using Alite multi-agent simulation toolkit. The source code of the entire experimental setup can be downloaded at http://agents.cz/~cap/adpp/.\nAll compared algorithms use identical best trajectory planner. The best trajectory for each robots is obtained by searching a roadmap extended with a discretized time-dimension using A* algorithm, where the heuristic is the shortest path on the graph from the given node to the goal node when the dynamic obstacles are ignored.\nThe experiments have been performed on AMD Opteron 8356 2.3GHz, 8 GB RAM. For each algorithm we measure the following characteristics:\nCoverage: We waited before each algorithm returns either success or failure and counted the number of instances each of the algorithm successfully solved.\nThe following characteristics were measured only on instances that were solved by all compared algorithms:\nTime to solution: We measured the wall-clock runtime needed to compute a solution. For the centralized planner we recorded the time of termination of the centralized planner. For the decentralized algorithms we recorded the time when the last robot detected global termination of the computation.\nSpeed-up: In order to be able to easier judge the effect of asynchronous execution in AD-(R)PP algorithm we also compute the speed-up ratio for both decentralized algorithms over their centralized counterparts. The speed-up for algorithm\n10\nA on instance i is computed as\nruntime of centralized variant of alg. Aon instance i runtime of alg. A on instance i ,\nwhere the centralized variant of AD-PP and SD-PP is PP, and the centralized variant of AD-RPP and SD-RPP is RPP.\nReplannings/Communication: Every time a robot running a decentralized algorithm adopts a new trajectory (replans), the trajectory is broadcast to all other robots. Therefore the number of replannings directly corresponds to the number of INFORM message broadcast in the system.\nProlongation: The objective criterion we minimize is the sum of goal arrival times for each robot. We measure the duration of the trajectory for each robot and compute the prolongation coefficient for each instance as\nprolongation of alg. A on instance i = \u2211n i=1 t A i \u2212 t\u2032i\u2211n\ni=1 t \u2032 i\n, (1)\nwhere tAi is the time robot i needs to reach its goal position when it follows the trajectory computed by the algorithm A and t\u2032i is the time the robot i would have needed to reach its goal following the shortest path on the roadmap if the collisions with other robots were ignored.\nComparison with reactive planning: In order to evaluate the practical advantages of the proposed planning approaches, we also compare their coverage with the popular reactive technique ORCA in our environments. ORCA is a control approach that continuously observes positions and velocities of other robots in a defined neighborhood. Should any potential collision be detected, a linear program is used to compute a new collision averting velocity that the robot should follow. If there are no eminent collisions, the robot follows its preferred preferred velocity. In our implementation the preferred velocity points at the globally shortest path from the robots current position to the goal."}, {"heading": "Environments", "text": "Empty-hall environment: The empty-hall environment and the roadmap used for trajectory planning in the environment are depicted in Figure 8a. For both instance sets and each number of robots ranging from n = 1 to n = 50, we generated 25 random instances of the problem containing the given number of robots.\nOffice Corridor environment: The office corridor environment is based on the laser rangefinder log of Cartesium building at the University of Bremen. We thank Cyrill Stachniss for providing the data through the Robotics Data Set Repository [6]. The environment and the roadmap used for trajectory planning in the environment are depicted in Figure 9a. For both instance sets and each number of robots ranging from n = 1 to n = 30, we generated 25 random problem instances containing the given number of robots.\nWarehouse environment: The map of the warehouse environment and the roadmap used for trajectory planning are depicted in Figure 10a. For both instance sets and each number of robots ranging from n = 1 to n = 60, we generated 25 random problem instances containing the given number\nof robots. The infrastructure tasks instance set represents a scenario of an automated logistic center where robots move goods between the gates and the storage shelves."}, {"heading": "Results", "text": "The results of the comparison in the three test environments for free-formed and infrastructure tasks are plotted in Figure 11 and Figure 12 respectively.\nNote that in the corridor environment and warehouse environment with free-formed tasks, all tested algorithms exhibit low success-rate on instances with higher number of robots. Since the plots from these two instance sets are based only on the few instances that all the tested algorithms were able to solve, they are shown only for the sake of completeness and will not be used to draw statistically significant conclusions.\nCoverage: For free-formed tasks, all tested algorithms exhibit incomplete coverage of the instance space. Generally, RPP-based algorithms solved fewer instances than the PPbased algorithms. This phenomena can be explained as follows: The failure of PP-based algorithms is due to Type A (robot cannot avoid being run-over by a higher-priority robot)\n11\nor Type B (all paths to the goal of a robot are blocked by higher-priority robots at their goal position) conflicts. The failure of a RPP-based algorithms can be caused either by nonexistence of path that avoids start-positions of higher-priority robots or by Type-B conflict. It is more likely, however, that a start-avoiding path will not exists (since it is a static condition that holds at all times) than that a Type B conflict will occur, thus the lower success rate of RPP-based algorithms.\nFor infrastructure tasks, the RPP-based instances show fullinstance coverage in accordance with our theoretical analysis. Further, we can see (best in Figure 12a-1) that some of those\ninstances remain unsolved both by PP-based algorithms and ORCA.\nTime to solution/speed-up: The asynchronous decentralized implementation of both PP and RPP consistently achieves higher speed-up than the synchronized implementation in accordance with our prediction. The higher speed-up is exhibited on instances with higher number of robots, where it is more likely that several independent conflict clusters will occur. On such instances, it is often beneficial that the conflict clusters can develop at different pace and thus converge faster. The phenomena can be seen clearly in Figures 11a-3, 12a-3, 12b3, and 12a-3.\nReplannings/Communication: AD-(R)PP broadcast higher number of messages than SD-(R)PP. To see how this can be explained, suppose that at some point of the computation new conflicts arise between the trajectory of one particular robot and the trajectories of two other higher-priority robots. If the two conflicts occur in a single round, SD-(R)PP solves both conflicts during one replanning at the end of the round and therefore broadcasts only a single INFORM message. However, in such a situation AD-(R)PP may need to replan twice because it triggers replanning immediately after each of the conflicts is detected and thus it will broadcast two INFORM messages.\nProlongation: There are two phenomena influencing the quality of returned solutions. First, RPP-based algorithms generate slightly longer trajectories than PP-based algorithms. This is due to the fact that RPP preemptively avoids start positions of the lower-priority robots. Second, decentralized approaches generate slightly longer trajectories than the centralized approaches. The reason is the replanning condition used by the decentralized algorithms. The condition states that a robot should replan its trajectory only if the trajectory is inconsistent with the trajectories of other robots. Thus, the robot may receive an updated trajectory from a higher-priority robot that allows an improvement in its current trajectory, but since its current trajectory may be still consistent, the robot will not exploit such an opportunity for an improvement.\n12\n13\n14"}, {"heading": "VI. DEPLOYMENT", "text": "To verify the applicability of the proposed algorithm in realistic communication conditions, we deployed the algorithm as a conflict resolution mechanism in a multi-UAV system. The multi-UAV system we used as a testbed is being developed as a part of a long-running research effort in our center [11], which is concerned with development of high-level control algorithms for teams of cooperating UAVs to autonomously carry out tasks such as patrolling, target tracking or area surveillance in tactical missions."}, {"heading": "Multi-UAV Robotic Testbed", "text": "Our testbed consists of two hardware UAVs and an arbitrary number of simulated UAVs. The hardware UAVs are based on the Unicorn airframe equipped with the Kestrel Autopilot from Lockheed Martin (see Figure 13a). Further, the airborne system is equipped with the Gumstix Overo EarthStorm embedded computer for on-board computation and Xbee 2.4GHz RF module to enable direct UAV-to-UAV messaging. Our algorithms are primarily targeted to large UAV teams. Due to the limited number of physical UAVs we have at our disposal, a mixed-reality approach [7] is used to scale up.\nTo address the flying capabilities of the employed UAVs, especially a relatively high inaccuracy in the plan execution due to unstable wind, we model the UAV (for the purposes of the trajectory planning and conflict resolution) as a large cylindric zone around each UAV. Specifically, we set the radius of the cylinder to 100 m and the half-height of the cylinder to 10 m. The parameters were chosen empirically to reflect the autopilot\u2019s trajectory tracking precision in difficult wind conditions.\nAn individual UAVs can communicate using a radio link having the shared capacity 5 kBps in ideal conditions. To keep the latency low and to use the bandwidth efficiently, the data are transferred in a raw form and thus the data delivery is not guaranteed."}, {"heading": "Closed-Loop AD-PP", "text": "Four main issues have to be addressed to apply AD-PP as a conflict resolution algorithm in a real-world multi-UAV system. Firstly, the whole team or individual UAVs may be re-tasked by an operator and thus the goals of any of the UAVs may change at any time during the mission execution. Secondly, the trajectories generated by the ADPP are often executed imprecisely by the UAVs, especially under unstable wind conditions. Thirdly, the radio communication channel used in the system does not guarantee message delivery and messages loss may occur. Fourthly, during the mission execution, some UAVs may be abruptly removed from the robotic team, while some new ones can be added. To address these requirements, we adapted the original AD-PP to work in a closed-loop fashion.\nIn this specific application, a decentralized implementation of classical prioritized planning turned out to be a better fit than a decentralized implementation of revised prioritized planning. First, since UAVs can replan at any time from any\npoint in space, we are not able to guarantee that S>i-avoiding and G<i-avoiding satisfying path will always exists, thus neither of the algorithms can guarantee completeness. Second, in situations similar to the one depicted in Figure 6, which are not uncommon in our case, PP returns shorter solution than RPP. Therefore, we chose to use PP over RPP as an underlying planning scheme.\nFurther, we chose asynchronous decentralized implementation of PP over the synchronized implementation, because in SD-PP the robots would need to run some form of distributed termination detection algorithm (e.g. [9]) at the end of each round in order to detect that every other robot has finished computing in the given round. With unreliable communication channels, such synchronization is in general impossible to achieve, as was shown in the famous Two General\u2019s problem [1].\nThe pseudo code of the closed-loop version of the AD-PP (called CLAD-PP) is given in Algorithm 5. In CLAD-PP, an execution of the trajectories is continuously monitored and a replanning is invoked if necessary. The replanning is triggered: a) if the robot is assigned a new task (e.g. by an operator); or b) if the robot has diverted from its planned trajectory.\nObserve that each such forced replanning triggers a new trajectory coordination query for the lower-priority robots and thus it may cause a cascade of replannings for lower-priority UAVs. However, just as in the standard AD-PP, each of the robots will eventually adapt a conflict-free trajectory or reports a failure to find one. Because of the possible message loss, the UAVs broadcast their planned trajectory not only when it changes, but also periodically onwards. The possible dynamic team reconfiguration does not allow to wait for a global termination of the ADPP run, and therefore, a robot starts executing its collision-free trajectory immediately when it is planned (lines 5, 12, and 15). For the trajectory generation (BESTTRAJ routine) we use an any-time RRT*-based [8] spatio-temporal trajectory planner, which is restricted to provide a solution within one second.\nFrom a practical point of view, it should be noted that such an extension was possible due to the asynchronous nature of the AD-PP. Implementing such a dynamic mechanism with a centralized or a synchronized algorithm would be much less natural."}, {"heading": "Superconflict experiment", "text": "The behavior of the proposed technique within a complex mission is demonstrated in a so-called \u201csuperconflict\u201d scenario. We considered four UAVs with starting positions placed at the corners of a square and their goals being at the respective diagonal opposite corners. Hence, all the airplanes are initially in a conflict in the middle of the square, see Figure 13b. In order to show the behaviour of the CLAD-PP technique more clearly, the BESTTRAJ trajectory planners of the individual UAVs were constrained to use only a fixed flight altitude and a fixed flight velocity.\nIn this experimental setup, two real UAVs (Plane1 and Plane2) are attached to a hardware-in-the-loop simulator and two others (Plane3 and Plane4) are simulated. The control\n15\nAlgorithm 5: Asynchronous Decentralized Implementation of Prioritized Planning, Closed-Loop version\n1 Algorithm CLAD-PP 2 \u03c0i \u2190 \u2205; 3 Hi \u2190 \u2205; 4 \u03c0i \u2190Find-consistent(\u03c0i,W,\u2206(Hi)); 5 follow \u03c0i; 6 Handle-message INFORM(j, \u03b4j) 7 if j < i then 8 Hi \u2190 ( Hi \\ { (j, \u03b4\u2032j) : (j, \u03b4 \u2032 j) \u2208 Hi }) \u222a {(j, \u03b4j)};\n// plans from the robot\u2019s current position\n9 \u03c0i \u2190 Find-consistent(\u03c0i,W,\u2206(Hi)); 10 if \u03c0i = \u2205 then 11 report failure and terminate;\n12 follow \u03c0i; 13 When task changes or robot diverted from \u03c0i\n// plans from the robot\u2019s current position\n14 \u03c0i \u2190Find-consistent(\u03c0i,W,\u2206(Hi)); 15 follow \u03c0i; 16 Periodically 17 broadcast INFORM(i, R\u2206i (\u03c0));\nalgorithms are deployed and run on the Gumstix on-board computers. The hardware UAVs use the safe zone radius 110 m, while the simulated ones use 70 m. The virtual UAVs are controlled by the identical software as the hardware UAVs; however, they run in independent virtual machines on a desktop computer. Both real and simulated UAVs communicate via their XBee radio modules. The Kestrel autopilot of the hardware UAVs is connected to a high-fidelity flight simulator Aviones1 in the hardware-in-the-loop mode. When the mission is started the UAVs execute the CLAD-PP algorithm to coor-\n1http://aviones.sourceforge.net/\ndinate their motions. The resulting traces that were recorded during the experiment are shown in Figure 13c and can also be seen in the attached video. One can see the typical phenomena of prioritized planning \u2013 the highest-priority Plane 1 keeps its first straight-lane trajectory, while all other UAVs need to change their first trajectory to adapt."}, {"heading": "VII. CONCLUSION", "text": "Prioritized planning is a practical approach for multi-robot trajectory planning. In this paper, we have summarized properties and compared performance of six different algorithms employing the idea of prioritized planning. While PP and SDPP are existing algorithms that have previously appeared in the literature, the remaining four algorithms are our novel contributions.\nIn particular, we have proposed a revised version of prioritize planning (RPP) and proved that this algorithm is guaranteed to provide solution if there is a path for every robot that reaches its goal position, avoids start positions of lower-priority robots and avoids goal positions of higherpriority robots. We have shown that this condition is satisfied if the individual robots move between two endpoints of a valid infrastructure. The significance of this result lies in the fact that human-made environments are usually build as valid infrastructures and thus the RPP algorithm can be used to efficiently find coordinated trajectories for the robots operating in such environments. We have experimentally demonstrated that in valid infrastructures, RPP algorithm solves instances that would be otherwise unsolvable by state-of-the-art techniques such as the classical prioritized planning or ORCA.\nA decentralized algorithm for the multi-robot trajectory coordination problem is often more desirable because the trajectory planning may be performed locally by each robot and several robots may plan in parallel. We proposed a novel asynchronous decentralized implementation of (revised) prioritized planning scheme and proved that the algorithm\n16\nis guaranteed to terminate. Further, the asynchronous decentralized implementation of revised prioritized planning is guaranteed to provide a solution under the same conditions as its centralized counterpart and thus it can be used to reliably plan coordinated trajectories in valid infrastructures. Further we have shown that in our test environments the asynchronous approach converges faster than the previously known synchronized approach. Further, we have demonstrated that the proposed asynchronous approach is flexible enough to be used as an on-line mechanism for conflict resolution in a multi-UAV system.\nIn future, we plan to study extensions of the presented decentralized algorithms to open multi-robot systems with local communication."}, {"heading": "Acknowledgements", "text": "This research was supported by the Czech Science Foundation (grant No. 13-22125S) and by the Grant Agency of the Czech Technical University in Prague grant SGS14/143/OHK3/2T/13. Access to computing and storage facilities owned by parties and projects contributing to the National Grid Infrastructure MetaCentrum, provided under the program \"Projects of Large Infrastructure for Research, Development, and Innovations\" (LM2010005), is greatly appreciated."}], "references": [{"title": "Some constraints and tradeoffs in the design of network communications", "author": ["E.A. Akkoyunlu", "K. Ekanandham", "R.V. Huber"], "venue": "In SOSP,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1975}, {"title": "Finding and optimizing solvable priority schemes for decoupled path planning techniques for teams of mobile robots", "author": ["M. Bennewitz", "W. Burgard", "S. Thrun"], "venue": "Robotics and Autonomous Systems,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2002}, {"title": "Asynchronous decentralized algorithm for space-time cooperative pathfinding. In Spatio-Temporal Dynamics Workshop (STeDy), SFB/TR 8 Spatial Cognition Center", "author": ["Michal Cap", "Peter Novak", "Jiri Vokrinek", "Michal Pechoucek"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "On the complexity of motion planning for multiple independent objects; pspace- hardness of the \"warehouseman\u2019s problem", "author": ["J.E. Hopcroft", "J.T. Schwartz", "M. Sharir"], "venue": "The International Journal of Robotics Research,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1984}, {"title": "The robotics data set repository (radish)", "author": ["Andrew Howard", "Nicholas Roy"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Towards incremental development of human-agent-robot applications using mixed-reality testbeds", "author": ["Michal Jakob", "Michal P\u011bchou\u010dek", "Peter Nov\u00e1k", "Michal \u010c\u00e1p", "Ondra Van\u011bk"], "venue": "IEEE Intelligent Systems,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Sampling-based algorithms for optimal motion planning", "author": ["Karaman", "Frazzoli"], "venue": "International Journal of Robotics Research,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Algorithms for distributed termination detection", "author": ["Friedemann Mattern"], "venue": "Distributed computing,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1987}, {"title": "Anytime safe interval path planning for dynamic environments", "author": ["Venkatraman Narayanan", "Mike Phillips", "Maxim Likhachev"], "venue": "In Intelligent Robots and Systems (IROS),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "P\u011bchou\u010dek. Deployment of multi-agent algorithms for tactical operations on uav hardware (demonstration)", "author": ["Martin Seleck\u00fd", "Anton\u00edn Komenda", "Michal \u0160tolba", "Tom\u00e1\u0161 Meiser", "Michal \u010c\u00e1p", "Milan Rollo", "Ji\u0159\u00ed Vok\u0159\u00ednek", "Michal"], "venue": "In Proceedings of AAMAS 2013 (to appear),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "Cooperative pathfinding", "author": ["David Silver"], "venue": "In AIIDE, pages 117\u2013122,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2005}, {"title": "Strong np-hardness of moving many discs", "author": ["Paul G. Spirakis", "Chee-Keng Yap"], "venue": "Inf. Process. Lett.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1984}, {"title": "Finding optimal solutions to cooperative pathfinding problems", "author": ["Trevor Scott Standley"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Complete algorithms for cooperative pathfinding problems", "author": ["Trevor Scott Standley", "Richard E. Korf"], "venue": "In Toby Walsh, editor,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Prioritized motion planning for multiple robots", "author": ["Jur van den Berg", "Mark Overmars"], "venue": "In IROS,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "Kinodynamic motion planning on roadmaps in dynamic environments", "author": ["Jur van den Berg", "Mark Overmars"], "venue": "In IROS,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2007}, {"title": "Asynchronous decentralized prioritized planning for coordination in multi-robot system", "author": ["Michal \u010c\u00e1p", "Peter Nov\u00e1k", "Martin Seleck\u00fd", "Jan Faigl", "Ji\u0159\u00ed Vok\u0159\u00ednek"], "venue": "In Intelligent Robots and Systems (IROS),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2013}, {"title": "Decentralized prioritized planning in large multirobot teams", "author": ["Prasanna Velagapudi", "Katia P. Sycara", "Paul Scerri"], "venue": "In IROS,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2010}, {"title": "A complete multirobot path planning algorithm with performance bounds", "author": ["Glenn Wagner", "Howie Choset. M"], "venue": "In IROS,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2011}], "referenceMentions": [{"referenceID": 11, "context": "Deciding whether a coordinated collision-free paths exist for multiple discs moving amidst polygonal obstacles is known to be strongly NP-hard [13]; the same task involving rectangular objects in an empty room is known to be in PSPACE-hard [5].", "startOffset": 143, "endOffset": 147}, {"referenceID": 3, "context": "Deciding whether a coordinated collision-free paths exist for multiple discs moving amidst polygonal obstacles is known to be strongly NP-hard [13]; the same task involving rectangular objects in an empty room is known to be in PSPACE-hard [5].", "startOffset": 240, "endOffset": 243}, {"referenceID": 12, "context": "The coupled approaches typically find optimal solutions [14], [15], [20], but do not scale well with the increasing number of conflicting robots.", "startOffset": 56, "endOffset": 60}, {"referenceID": 13, "context": "The coupled approaches typically find optimal solutions [14], [15], [20], but do not scale well with the increasing number of conflicting robots.", "startOffset": 62, "endOffset": 66}, {"referenceID": 18, "context": "The coupled approaches typically find optimal solutions [14], [15], [20], but do not scale well with the increasing number of conflicting robots.", "startOffset": 68, "endOffset": 72}, {"referenceID": 17, "context": "presented a decentralized version of prioritized planning technique for teams of mobile robots [19], which is able to utilize the distributed computational resources to reduce the time needed to find a solution.", "startOffset": 95, "endOffset": 99}, {"referenceID": 2, "context": "Partial results of the presented work appeared in [3], [18], where the focus was on the design of asynchronous version of decentralized prioritized planning.", "startOffset": 50, "endOffset": 53}, {"referenceID": 16, "context": "Partial results of the presented work appeared in [3], [18], where the focus was on the design of asynchronous version of decentralized prioritized planning.", "startOffset": 55, "endOffset": 59}, {"referenceID": 0, "context": "A path p : [0, 1]\u2192W of robot i in workspace W is called satisfying if it starts at the robot\u2019s start position si, ends at robot\u2019s goal position gi, and the body of robot whose center follows the path p always lies entirely in W .", "startOffset": 11, "endOffset": 17}, {"referenceID": 14, "context": "Other works such as [16], [2] investigate techniques for choosing a good prioritization for the robots.", "startOffset": 20, "endOffset": 24}, {"referenceID": 1, "context": "Other works such as [16], [2] investigate techniques for choosing a good prioritization for the robots.", "startOffset": 26, "endOffset": 29}, {"referenceID": 15, "context": "[17] or [10].", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[17] or [10].", "startOffset": 8, "endOffset": 12}, {"referenceID": 10, "context": "Prioritized planning is in general incomplete, consider the counter-example [12] depicted in Figure 1: Figure 1: The picture shows two robots desiring to move from s1 to g1 (s2 to g2 resp.", "startOffset": 76, "endOffset": 80}, {"referenceID": 17, "context": "in [19].", "startOffset": 3, "endOffset": 7}, {"referenceID": 17, "context": "Properties: In order to facilitate and simplify exposition of the later introduced asynchronous algorithm, we developed an alternative proof of termination of the SD-(R)PP algorithm, which deviates from the original one devised by the authors of SD-PP in [19].", "startOffset": 255, "endOffset": 259}, {"referenceID": 4, "context": "We thank Cyrill Stachniss for providing the data through the Robotics Data Set Repository [6].", "startOffset": 90, "endOffset": 93}, {"referenceID": 9, "context": "The multi-UAV system we used as a testbed is being developed as a part of a long-running research effort in our center [11], which is concerned with development of high-level control algorithms for teams of cooperating UAVs to autonomously carry out tasks such as patrolling, target tracking or area surveillance in tactical missions.", "startOffset": 119, "endOffset": 123}, {"referenceID": 5, "context": "Due to the limited number of physical UAVs we have at our disposal, a mixed-reality approach [7] is used to scale up.", "startOffset": 93, "endOffset": 96}, {"referenceID": 7, "context": "[9]) at the end of each round in order to detect that every other robot has finished computing in the given round.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "With unreliable communication channels, such synchronization is in general impossible to achieve, as was shown in the famous Two General\u2019s problem [1].", "startOffset": 147, "endOffset": 150}, {"referenceID": 6, "context": "For the trajectory generation (BESTTRAJ routine) we use an any-time RRT*-based [8] spatio-temporal trajectory planner, which is restricted to provide a solution within one second.", "startOffset": 79, "endOffset": 82}], "year": 2014, "abstractText": "An important capability of autonomous multi-robot systems is to prevent collision among the individual robots. One approach to this problem is to plan conflict-free trajectories and let each of the robots follow its pre-planned trajectory. A widely used practical method for multi-robot trajectory planning is prioritized planning, which has been shown to be effective in practice, but is in general incomplete. Formal analysis of instances that are provably solvable by prioritized planning is still missing. Moreover, prioritized planning is a centralized algorithm, which may be in many situations undesirable. In this paper we a) propose a revised version of prioritized planning and characterize the class of instances that are provably solvable by the algorithm and b) propose an asynchronous decentralized variant of prioritized planning, which maintains the desirable properties of the centralized version and in the same time exploits the distributed computational power of the individual robots, which in most situations allows to find the joint trajectories faster. The experimental evaluation performed on real-world indoor maps shows that a) the revised version of prioritized planning reliably solves a wide class of instances on which both classical prioritized planning and popular reactive technique ORCA fail and b) the asynchronous decentralized algorithm provides solution faster than the previously proposed synchronized decentralized algorithm. Note to Practitioners\u2014Consider a large warehouse in which the goods are stored and retrieved by autonomous transport robots. One option is to ignore interaction between the vehicles during the route planning for each robot and handle the conflicts only during the route execution. However, such approach is prone to deadlocks, i.e. to a situations during which some of the robots mutually block each other, cannot proceed and fail to complete their transportation task. An alternative approach would involve planning collision-free routes for each robot before the robots start executing them. However, the general methods for this problem that guarantee a solution are impractical due to their high computational complexity. In this paper, we show that a simple prioritized approach in which robots plan their routes one after another is guaranteed to find collision-free trajectories for a welldefined class of practical problems. In particular, if the systems resembles human-made transport infrastructures by requiring that the start and destination position of each vehicle must never obstruct other vehicles from moving, then the proposed approach is guaranteed to provide a solution. E.g., in such a warehouse application, the collision-free routes can efficiently computed by the prioritized approach. The paper contains formal condition that characterizes the problem instances for which is the method guaranteed to work. Further, we propose a new decentralized adaptation of the prioritized algorithm that can be used in multi-robot systems without a central solver. This technique can be used to find coordinate trajectories just by running simple negotiation protocol between the individual robots. The paper contains analysis showing that the decentralized algorithm exhibits desirable theoretical properties and experimental comparison of performance of different variations of centralized and decentralized algorithms.", "creator": "TeX"}}}