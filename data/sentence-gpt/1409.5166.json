{"id": "1409.5166", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Sep-2014", "title": "A Tabu Search Algorithm for the Multi-period Inspector Scheduling Problem", "abstract": "This paper introduces a multi-period inspector scheduling problem (MPISP), which is a new variant of the multi-trip vehicle routing problem with time windows (VRPTW). In the MPISP, each inspector is scheduled to perform a route in a given multi-period planning horizon. At the end of each period, each inspector is not required to return to the depot but has to stay at one of the vertices for recuperation.\n\n\n\n\nMaintain the continuous routing problem with time windows in the MPISP (RFP), the primary point of reference for the time windows.\nIn this paper, we explain how the scheduling problem is solved in an efficient and reliable way, in a modern situation.\nHere is a simplified timeline of each time window, and how it will be executed using the multi-period planning scenario in this paper.\nWe are going to demonstrate the use of the multi-period planning strategy in a simplified way.\nStep 1. Start from the first step by setting the schedule (1) in the MPISP, the next step by setting the schedule (2) in the MPISP.\nStep 2. Set the schedule on the first time window. Then press the key key (X) at the top of the schedule and enter the time window.\nStep 3. Set the time window on the next time window. Then press the key (Y) at the top of the schedule and enter the time window.\nStep 4. Set the time window on the next time window. Then press the key (Z) at the top of the schedule and enter the time window.\nStep 5. Set the time window on the next time window. Then press the key (Z) at the top of the schedule and enter the time window.\nThe first step is the time window. Then press the key (Z) at the top of the schedule and enter the time window.\nStep 6. Set the time window on the next time window. Then press the key (X) at the top of the schedule and enter the time window.\nStep 7. Set the time window on the next time window. Then press the key (Z) at the top of the schedule and enter the time window.\nStep 8. Set the time window on the next time window. Then press the key (X) at the top of the schedule and enter the time window.\nStep 9. Set the time window on the next time window. Then press the key", "histories": [["v1", "Wed, 17 Sep 2014 23:29:46 GMT  (182kb,D)", "http://arxiv.org/abs/1409.5166v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DS", "authors": ["hu qin", "zizhen zhang", "yubin xie", "rew lim"], "accepted": false, "id": "1409.5166"}, "pdf": {"name": "1409.5166.pdf", "metadata": {"source": "CRF", "title": "A Tabu Search Algorithm for the Multi-period Inspector Scheduling Problem", "authors": ["Hu Qin", "Zizhen Zhang", "Yubin Xie", "Andrew Lim"], "emails": [], "sections": [{"heading": null, "text": "This paper introduces a multi-period inspector scheduling problem (MPISP), which is a\nnew variant of the multi-trip vehicle routing problem with time windows (VRPTW). In the\nMPISP, each inspector is scheduled to perform a route in a given multi-period planning\nhorizon. At the end of each period, each inspector is not required to return to the depot\nbut has to stay at one of the vertices for recuperation. If the remaining time of the current\nperiod is insufficient for an inspector to travel from his/her current vertex A to a certain\nvertex B, he/she can choose either waiting at vertex A until the start of the next period\nor traveling to a vertex C that is closer to vertex B. Therefore, the shortest transit time\nbetween any vertex pair is affected by the length of the period and the departure time.\nWe first describe an approach of computing the shortest transit time between any pair of\nvertices with an arbitrary departure time. To solve the MPISP, we then propose several local\nsearch operators adapted from classical operators for the VRPTW and integrate them into\na tabu search framework. In addition, we present a constrained knapsack model that is able\nto produce an upper bound for the problem. Finally, we evaluate the effectiveness of our\nalgorithm with extensive experiments based on a set of test instances. Our computational\nresults indicate that our approach generates high-quality solutions.\nKey words: tabu search; routing; meta-heuristics; inspector scheduling problem; hotel\n1\nar X\niv :1\n40 9.\n51 66\nv1 [\ncs .A\nI] 1\n7 Se\nselection"}, {"heading": "1. Introduction", "text": "This paper studies a new manpower routing and scheduling problem faced by a company\nthat procures products from over one thousand suppliers across Asia. The company places\norders with a large number of suppliers and must inspect the goods at the factories of the\nsuppliers before shipment. Therefore, the suppliers are required to make inspection requests\nwith the company when the ordered goods are ready for delivery. An inspection request is\ncharacterized by the workload, the inspection site and the time window within which the\ninspection can be started. In turn, the company dispatches a team of professional quality\ninspectors to perform all on-site inspections. In order to facilitate coordination between\ninspectors and suppliers, the inspections could only be carried out during working hours (e.g.,\n8:00 am to 6:00 pm). Usually, a weekly schedule is created to assign inspectors to requests\nfor the upcoming week. The company has a stable of in-house inspectors, each having\na specified weekly workload limit, and the unfulfilled inspection requests are outsourced to\nexternal agencies with additional costs. After receiving their weekly inspection schedules, the\ninspectors depart from the regional office and will not report back until they have performed\nall their assigned inspections for the week. More specifically, they leave the regional office\non Monday, visit a set of inspection sites and return to the regional office on Friday or\nsome earlier workday. In each workday, an inspector generally travels to diffident locations,\ncompletes several inspections and finds overnight accommodation (i.e., hotel) in the vicinity\nof his/her last/next inspection site at or before the end of the office hours. The objective of\nthe problem is to assign as many inspection workloads as possible to the stable of in-house\ninspectors while satisfying all the above-mentioned practical constraints.\n\u2217Corresponding author at: School of Mobile Information Engineering, Sun Yat-Sen University, Tang Jia Bay, Zhuhai, Guangdong, China. Tel.: +86 13826411848.\nEmail addresses: tigerqin@hust.edu.cn, tigerqin1980@gmail.com (Hu Qin), zhangzizhen@gmail.com (Zizhen Zhang), xyb.0606@gmail.com (Yubin Xie), lim.andrew@cityu.edu.hk (Andrew Lim)\nPreprint submitted to Computers & Operations Research September 19, 2014\nWe call this problem the multi-period inspector scheduling problem (MPISP), which\ncan be viewed as a variant of the multi-trip vehicle routing problem with time windows\n(VPRTW) (Azi et al., 2010; Macedo et al., 2011). There are four main features that distin-\nguish the MPISP from the multi-trip VRPTW. First, the scheduling subjects, e.g., vehicles\nor inspectors, are not required to return to the regional office every workday. Second, at the\nend of each workday, each scheduling subject must stay at one of the vertices for recupera-\ntion. Third, each vertex can be visited more than once. If the remaining time of the current\nperiod is insufficient for an inspector to travel from his/her current vertex A to a certain\nvertex B, he/she can choose either waiting at vertex A until the start of the next period or\ntraveling to a vertex C that is closer to vertex B. The vertex C is called a waypoint, which\nonly acts as the intermediate point in a route. Fourth, the objective is to maximize the total\ninspected workload rather than to minimize the number of inspectors used and/or the total\ndistance traveled.\nIn this study, we propose a tabu search algorithm to solve the MPISP. This algorithm\nemploys a tailored fitness function consisting of three lexicographically ordered components,\na local improvement procedure with tabu moves, an ejection pool improvement process and\na perturbation phase. The contributions of this study are fourfold. First, we introduce a\nnew and practical multi-period manpower routing and scheduling problem that considers\nmultiple working periods. Second, we provide an effective tabu search algorithm that uses\na set of problem-specific neighborhood search operators. Third, we construct a constrained\nknapsack model that can produce an upper bound for the MPISP. Fourth, the comprehen-\nsive experimental results on a large number of test instances show the effectiveness of our\napproach.\nThe remainder of this paper is organized as follows. We first provide an overview of\nrelated research in Section 2. In Section 3, we then give a formal definition of the MPISP.\nIn Section 4, we describe an approach of computing the shortest transit time for any pair\nof vertices with any departure time. Our proposed tabu search algorithm is detailed in\nSection 5 and the constrained knapsack model is presented in Section 6. Section 7 reports\nthe experiments results and Section 8 concludes this study with some closing remarks. 3"}, {"heading": "2. Related work", "text": "The MPISP is one type of manpower scheduling problems. Scheduling staff members is\na traditional research area; example problems include the nurse rostering problem (Cheang\net al., 2003), the technician planning problem (Ernst et al., 2004) and the airline crew\nrostering problem (Kohl and Karisch, 2004). As for the manpower scheduling problems that\ninvolve creating routes for staff members, we refer the reader to Li et al. (2005); Tang et al.\n(2007); Za\u0308pfel and Bo\u0308gl (2008); Cai et al. (2013); Zhang et al. (2013).\nSince each inspector has to perform inspections at different locations, the MPISP is\nessentially a variant of the vehicle routing problem (Toth and Vigo, 2002). One of the\ndefining characteristics is its objective of maximizing the total inspected workload. Two\npreviously studied problems with similar objective are the team orienteering problem with\ntime windows (TOPTW) (Vansteenwegen et al., 2009, 2011; Labadie et al., 2012; Hu and\nLim, 2014) and the vehicle routing problem with time windows and a limited number of\nvehicles (m-VRPTW) (Lau et al., 2003; Lim and Zhang, 2007). The m-VRPTW is an\nextension of the TOPTW with the consideration of vehicle capacity and customer demands.\nThese two problems both aim to determine a set of routes that maximizes the total reward\nof the vertices visited during a single period with a distance or duration limit. The multi-\nperiod planning horizon of the MPISP is related to the periodic vehicle routing problem\n(PVRP) (Gaudioso and Paletta, 1992; Hemmelmayr et al., 2009) and the multiple trip\nvehicle routing problem (MTVRP) (Battarra et al., 2009). However, the MPISP is quite\ndifferent from the PVRP and MTVRP. In the PVRP, each customer requires a certain\nnumber of visits within the planning horizon, and two types of decisions are involved in the\nplanning, namely determining the visit days for each customer and the routing plan for each\ntime period. The PVRP and MTVRP both require that each vehicle must return to the\ndepot at the end of each period.\nAnother defining characteristic of the MPISP is the consideration of multiple working\nperiods. Working hour regulations have recently received increasing attention from some re-\nsearchers studying vehicle routing problems. Savelsbergh and Sol (1998) proposed a dynamic\n4\nand general pickup and delivery problem in which lunch and night breaks must be taken\ninto account. Xu et al. (2003) applied column generation based solution approaches to solve\na pickup and delivery vehicle routing problem that involves a set of practical complications,\nsuch as heterogeneous vehicles, last-in-first-out loading and unloading operations, pickup\nand delivery time windows, and working hour restrictions by the United States Department\nof Transportation. Similarly, Goel (2009, 2010) and Kok et al. (2010) investigated combined\nvehicle routing and driver scheduling problems under the European Union regulations for\ndrivers.\nThe MPISP problem can be viewed as a natural extension of the orienteering problem\nwith hotel selection (OPHS) (Divsalar et al., 2013, 2014). In the OPHS, a scheduling subject\ncan visit a set of vertices each with a score and find accommodation at a given set of hotels.\nThe tour is divided into multiple trips, each with a limited duration and starting from and\nending at one of the hotels. The objective of the OPHS is to determine a tour that maximizes\nthe total collected score. The OPHS is a variant of the traveling salesperson problem with\nhotel selection (TSPHS) (Vansteenwegen et al., 2012; Castro et al., 2013), which aims to\nserve all vertices with the minimum number of connected trips and the minimum total travel\ndistance. The common characteristic of the above three problems is the involvement of hotel\nselection.\nTang et al. (2007) and Za\u0308pfel and Bo\u0308gl (2008) introduced two manpower routing and\nscheduling problems that involve maximization of profits, multiple periods and working hour\nrestrictions. However, their problems require that the trip in each period must start from\nand end at the depot. Most recently, Zhang et al. (2013) proposed an inspector scheduling\nproblem which is very similar to our problem. Their problem differs from our problem in\nthe following four assumptions: (1) each vertex can only be visited at most once; (2) if a\nvertex is visited by an inspector, its inspection request must be fulfilled by this inspector;\n(3) an inspector reaches a vertex and completes the corresponding inspection task in the\nsame period; and (4) each vehicle stays at the last served vertex at the end of each period\nand begins the trip of the next period from that vertex. By ignoring these four assumptions,\nthe MPISP is more difficult but practical. 5"}, {"heading": "3. Problem description", "text": "The MPISP is defined on a directed graph G = (V,E), where V = {0, 1, . . . , n} is the vertex set and E = {(i, j) : i, j \u2208 V, i 6= j} is the edge set. Vertex 0 represents the depot location and VC = {1, . . . , n} denotes the locations of n suppliers. Each supplier i is characterized by a location i \u2208 VC , a workload di, a required service time si and a time window [ei, li]. For notational convenience, we assign d0 = 0 and s0 = 0 for the depot. Each edge (i, j) \u2208 E requires a non-negative traveling time ti,j, where the matrix [ti,j] satisfies the triangle inequality.\nWe are given a set K of m homogeneous inspectors, each of which has a workload limit Q and can only work within a set P = {1, . . . , w} of w working periods (or called working time windows). For any period p \u2208 P , ap and bp (ap < bp) are its starting and closing working times, respectively, and bp \u2212 ap equals a positive constant T that is not less than si for any i \u2208 V . An inspector can arrive at vertex i \u2208 VC prior to ei and wait at no cost until the service of supplier i becomes possible. All inspectors must leave the depot\nafter e0 (e0 = a1 = 0) and return to the depot before l0 (l0 = bw), where [e0, l0] is called depot time window. At the end of each period, each inspector is not required to return to\nthe depot but has to stop traveling and stay at one of vertices. Moreover, service cannot\nbe interrupted, i.e., if the service of some supplier cannot be completed before the end of\na period, it must be restarted in the later periods. Each vertex can be visited more than\nonce while each supplier can be served by at most one inspector, so some supplier locations\ncan be used as waypoints. The objective of the MPISP is to construct m inspector routes\nto complete as many workloads as possible while respecting depot time window, workload\nlimit, supplier time windows and inspector working time windows. We provide a mixed\ninteger programming model for the MPISP in Appendix A.\nIn reality, ap should be larger than bp\u22121, and the duration between ap and bp\u22121 is the downtime for rest and recuperation. Without loss of generality, we can assume that the\nlength of the downtime is extremely small by setting bp\u22121 = ap and imposing a break at time bp\u22121. As illustrated in Figure 1, we can easily transform the non-zero downtime cases\n6\nto zero downtime ones. In Figure 1(a), T = 20 and the time windows of suppliers 1, 2,\nand 3 are [5, 90], [10, 50] and [85, 95], respectively. After transformation, their time windows\nbecome [5, 50], [10, 30] and [45, 55] (see Figure 1(b)).\nTo further describe the MPISP, we convert the graph G = (V,E) into a directed (not complete) graph G\u2032 = (V \u2032, E \u2032) by the following two steps: (1) split each vertex i \u2208 VC into two vertices i+ and i\u2212, and create an edge (i+, i\u2212), where vertex i+ represents the arrival of vertex i and vertex i\u2212 represents the completion of supplier i\u2019s service; (2) create edges (0, i+), (i+, 0), (i\u2212, 0), (i+, j+) and (i\u2212, j+), where i, j \u2208 VC and i 6= j; and (3) set ti+,i\u2212 = si, t0,i+ = t0,i, ti+,0 = ti\u2212,0 = ti,0 and ti+,j+ = ti\u2212,j+ = ti,j. An example to illustrate this conversion is shown in Figure 2, where Figure 2(b) is the resultant graph derived from\nFigure 2(a).\nWe can denote a feasible solution of the MPISP by S, consisting of m routes, namely S = {r1, r2, . . . , rm}. A route rk (1 \u2264 k \u2264 m) is divided into w sub-routes by periods and therefore can be expressed as rk = (r 1 k, r 2 k, . . . , r w k ), where r p k (1 \u2264 p \u2264 w) denotes the trip in period p. If an inspector returns to the depot before period w, he/she will stay at the depot for the remaining periods. The sub-route rpk is a sequence of vertices, where its starting and ending vertices are denoted by vs(r p k) and ve(r p k), respectively. If an inspector k stays at the depot during the whole period p, we set rpk = (0) and vs(r p k) = ve(r p k) = 0. According to the definition of our problem, an inspector must stay at vertex ve(r p k) for rest and will start\n7\nthe next trip from this vertex in period p + 1, i.e, ve(r p k) = vs(r p+1 k ) for all 1 \u2264 p \u2264 w \u2212 1. Obviously, the starting vertex of period 1 and the ending vertex of period w for each route\nmust be vertex 0. Figure 3 gives a feasible solution to an MPISP instance involving 10\nsuppliers, 4 inspectors and 3 periods.\nS et of unserved suppliers U={9, 10} working idle\nIn Figure 3, the solid and dash lines denote the working (i.e., traveling or providing service) and idle statuses of the inspectors, respectively. The set U = {9, 10} indicates that suppliers 9 and 10 are not served by any inspector. The route r1 = (r 1 1, r 2 1, r 3 1) comprises\n8\nthree trips, i.e., r11 = (0, 1+), r 2 1 = (1+, 1\u2212, 2+, 2\u2212) and r31 = (2\u2212, 3+, 3\u2212, 0). This route shows that inspector 1 arrives at vertex 1, but does not have sufficient time to complete\nthe service for supplier 1 in the first period. Thus, he/she has to wait until the start of the\nsecond period and then provides service to supplier 1. Subsequently, inspector 1 travels to\nvertex 2, completes the service of supplier 2 and stays at vertex 2 for recuperation. In the\nthird period, inspector 1 travels from vertex 2 to vertex 3, provides service for supplier 3, and\nfinally returns to the depot. Since each supplier i can be served by at most one inspector, edge (i+, i\u2212) can be included in at most one route. In route r2, after completing the service of supplier 4, inspector 2 travels to vertex 5 via a waypoint, namely vertex 3. Note that any\nwaypoint must be the ending vertex of a certain period (and also be the starting vertex of the\nfollowing period) due to the rule of triangle inequality. As shown in route r3, an inspector may use two or more waypoints between two consecutively served suppliers. In this route,\ninspector 3 visits but does not serve supplier 9, i.e., vertex 9 only acts as a waypoint. As no route traverses edge (9+, 9\u2212), supplier 9 is not served by any inspector in this solution.\nThe route r4 illustrates that an inspector may be idle during some periods; its three trips are represented by r14 = (0, 8+, 8\u2212, 0), r24 = (0) and r34 = (0)."}, {"heading": "4. Shortest transit time", "text": "In a complete graph that satisfies the triangle inequality, the shortest path from vertex\ni to vertex j must be edge (i, j). When working periods are imposed on the inspectors,\nedge (i, j) may be unusable in some situations and therefore the shortest transit time may\nbe greater than ti,j. The simplest such situation can be encountered when ti,j > T . To move from vertex i to vertex j, an inspector has to use some waypoints and the transit time\nmay cross several periods. We illustrate this situation in Figure 4, where an inspector has\ncompleted the service of supplier i and departs from vertex i at the beginning of a certain\nperiod.\nUnlike the classical VRP models, in the MPISP the shortest transit times from vertex\ni to other vertices are affected by the departure time (denoted by dti) of the inspector. Therefore, we define t\u0302i,j(dti) as the shortest transit time from vertex i to vertex j with 9\ndeparture time dti. If dti is the opening time of a certain period, i.e., dti = ap for some p \u2208 P , t\u0302i,j(dti) can be simplified to t\u0302i,j. Further, we define ceil(dti) as the closing time of the period within which dti lies, i.e., if ap < dti \u2264 bp, then ceil(dti) = bp. If ceil(dti)\u2212 dti \u2265 ti,j, an inspector can travel across edge (i, j) within the current period and thus t\u0302i,j(dti) = ti,j. Otherwise, the inspector has to either wait at vertex i until the start of the next period or\ntravel to some waypoint u. We illustrate these situations in Figure 5, where an inspector\nmay travel from vertex i to vertex j via some waypoint.\nAs previously mentioned, a waypoint u can only be positioned as the last or the first\nvertex in the trip of some period. More precisely, if an inspector travels to a waypoint u, he\n10\nmust stay at u for downtime (see Figure 5(b)). Taking N(dti) = {u \u2208 V |ti,u \u2264 ceil(dti)\u2212dti} to be the set of all vertices that can act as waypoints for vertex i, the value of t\u0302i,j(dti) can be calculated by:\nt\u0302i,j(dti) =  ti,j, if ceil(dti)\u2212 dti \u2265 ti,j;ceil(dti)\u2212 dti + minu\u2208N(dti)\u222a{i}{t\u0302u,j}, otherwise. (1) The above expression shows that computing any t\u0302i,j(dti) requires O(n) time given the values of all t\u0302i,j, which can be calculated prior to applying any algorithm to the problem. If the last waypoint between vertex i and vertex j is vertex u, the corresponding shortest transit time, denoted by t\u0302ui,j, can be obtained by:\nt\u0302ui,j =  t\u0302i,u + tu,j, if ceil(t\u0302i,u)\u2212 t\u0302i,u \u2265 tu,j; ceil(t\u0302i,u) + tu,j, if ceil(t\u0302i,u)\u2212 t\u0302i,u < tu,j \u2264 T ;\n+\u221e, otherwise.\n(2)\nObviously, we have:\nt\u0302i,j = min u\u2208V {t\u0302ui,j}\nTo compute all t\u0302i,j, we can apply an algorithm modified from the Dijkstra\u2019s algorithm (Ahuja et al., 1993), one of the most well-known label-setting algorithms for the classical shortest\npath problem. This modified Dijkstra\u2019s algorithm employs expression (2) as the extension function and has a time complexity of O(n2). Since we need to compute the shortest transit time between each vertex pair, the total time complexity for all t\u0302i,j is bounded by O(n 3).\nWe can accelerate the computation of t\u0302i,j(dti) by the following procedure. We first remove from the graph all edges whose lengths are greater than T and then sort all neighbors u\nof vertex i in ascending order of ti,u, generating a vertex sequence (i0, i1, . . . , ih). Note that we have i0 = i since ti,i = 0. For 0 \u2264 k \u2264 h, let t\u0302(k)i,j = min0\u2264k\u2032\u2264k{t\u0302ik\u2032 ,j} be the shortest transit time from one of the first k + 1 vertices in the sequence to vertex j. The values of all t\u0302 (k) i,j can be computed by Algorithm 1 in time complexity of O(n 3). Figure 6 pictorially shows the process of computing all t\u0302 (k) i,j . According to expression (1), t\u0302i,j(dti) = ceil(dti) \u2212 dti + minu\u2208N(dti)\u222a{i}{t\u0302u,j} if ceil(dti) \u2212 dti < ti,j. To achieve this t\u0302i,j(dti), we 11\nidentify the largest k satisfying ceil(dti)\u2212dti \u2265 ti,ik using binary search on ti,i0 , ti,i1 , . . . , ti,ih , and retrieve the value of t\u0302 (k) i,j , which is equal to minu\u2208N(dti)\u222a{i}{t\u0302u,j}. The above procedure shows that the time complexity of computing t\u0302i,j(dti) can be reduced to O(logn) given that all t\u0302 (k) i,j are available.\nThe computation of all t\u0302i,j and t\u0302 (k) i,j can be done in a preprocessing stage, which requires a time complexity of O(n3). The approach described in the following section needs to\nfrequently compute t\u0302i,j(dti). Thus, this preprocessing stage is particularly useful to save the overall computation time."}, {"heading": "5. Tabu search algorithm", "text": "Tabu search algorithm has been successfully applied to a wide variety of routing and\nscheduling problems, such as the classical VRP (Gendreau et al., 1994; Toth and Vigo,\n2003), the VRPTW (Chiang and Russell, 1997; Gordeau et al., 2001), the three-dimensional\nloading capacitated VRP (Zhu et al., 2012), the job-shop scheduling problem (Barnes and\n12\nAlgorithm 1 The algorithm for preprocessing all t\u0302 (k) i,j .\n1: INPUTS: all t\u0302i,j; 2: for i = 0 to n do\n3: Sort all neighbors u of vertex i in ascending order of ti,u to generate a vertex sequence\n(i = i0, i1, . . . , ih);\n4: for j = 0 to n do 5: t\u0302 (0) i,j = t\u0302i,j; 6: for k = 1 to h do 7: t\u0302 (k) i,j = min{t\u0302 (k\u22121) i,j , t\u0302ik,j}; 8: end for\n9: end for\n10: end for\nChambers, 1995) and the nurse rostering problem (Burke et al., 2003). Basically, tabu\nsearch algorithm starts from an initial solution and iteratively proceeds from the incumbent\nsolution to its best allowable neighbor. The neighborhood of a solution is a set of solutions\nthat can be reached from that solution by a certain operation. Each type of operation\ncorresponds to a neighborhood and the procedure of identifying the best allowable neighbor\nin the neighborhood is called an operator. The transition from the incumbent solution to\none of its neighbors is called a move.\nOur tabu search algorithm employs several operations adapted from classical operations for the VRPTW, namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange (Bra\u0308ysy and Gen-\ndreau, 2005), and an ejection pool (Lim and Zhang, 2007; Nagata and Bra\u0308ysy, 2009). The\nmost noteworthy characteristic that distinguishes these adapted operations from their clas-\nsical counterparts is the procedure of checking the feasibility of the modified solution. For\nexample, after performing an operation on a VRPTW solution, we can check the feasibility\nof the resultant solution in O(1) time (it is assumed that for each vertex the latest arrival\ntime that does not lead to the violation of the time windows of all successive vertices has\nbeen calculated in a preprocessing step). However, for a modified MPISP solution, we may\n13\nrequire up to O(nlogn) time to check its feasibility due to the re-computation of the shortest\ntransit times associated with the affected vertices, which will be elaborated in Section 5.4.1.\nThe pseudocode of our tabu search algorithm is presented in Algorithm 2, which is an\niterative approach that follows a four-phase framework: initialization, local search with\ntabu moves, ejection pool algorithm and perturbation. At the beginning of the algorithm,\nwe generate an initial solution S0 using the function best init (see Section 5.3) and then initialize both the best solution Sbest and the current solution S by S0. In each iteration, we first invoke the local search procedure with tabu moves (function local search, see Section 5.4) and set S \u2032 to be the best solution found by this procedure. Subsequently, we try to improve on S \u2032 by an ejection pool algorithm (function EPA, see Section 5.5) and then update\nSbest if possible. Finally, the search process is diversified by perturbing the best solution found in this iteration. The above process is repeated until the perturbation procedure\n(function perturb, see Section 5.6) is consecutively performed maxPerturbation times without\nimproving on Sbest."}, {"heading": "5.1. Solution representation", "text": "In Section 3, we have used the sequences of visited vertices to represent the problem\nsolution (see Figure 3). However, in our tabu search algorithm, we represent the route of\neach inspector by a sequence of served suppliers. For example, Figure 7 shows a solution\nthat is exactly the same as the one in Figure 3. The routes r1, r2, r3 and r4 include the served suppliers and the ejection pool U contains the leftover suppliers. All waypoints are\nnot displayed in this solution representation and there may exist waypoints and/or breaks\nbetween two consecutively served suppliers."}, {"heading": "5.2. Fitness function", "text": "The tabu search algorithm ranks solutions using a fitness function. It is natural to define\nthe fitness value of a solution S as the total completed workload, denoted by P (S). However,\nmany distinct solutions have the same value of P (S). To further differentiate solutions, we\nincorporate into the fitness function another two measures denoted by D(S) and F (S),\n14\nAlgorithm 2 Framework of the tabu search algorithm.\n1: S0 \u2190 best init(); 2: Sbest \u2190 S0 and S \u2190 S0; 3: i \u2190 0; 4: while i \u2264 maxPerturbation do 5: S \u2032 \u2190 the best solution found by local search(S); 6: S \u2032 \u2190 EPA(S \u2032) 7: if S \u2032 is better than Sbest then 8: Sbest \u2190 S \u2032 and i \u2190 0; 9: else\n10: i \u2190 i+ 1;\n11: end if 12: S \u2190 perturb (S \u2032);\n13: end while\n14: return Sbest.\nrespectively, which is inspired by Lim and Zhang (2007). As a result, the fitness function\nconsists of three lexicographically ordered components, namely P (S), D(S) and F (S).\nThe second component D(S) employs a function mv(u, S) that estimates the difficulty of inserting supplier u \u2208 U into the routes of solution S. Denoting any route in S by r = (v0, v1, . . . , v|r|, v|r|+1), where |r| is the number of served suppliers in route r and v0 =\n15\nv|r|+1 = 0, the definition of mv(u, S) is given by:\nmv(u, S) = min r\u2208S mv(u, r)\nwhere mv(u, r) = max { \u03b7 \u00d7mvl(u, r), mvt(u, r) } (3)\nmvl(u, r) =  0, if wl(r) + du \u2264 Q;(l0 \u2212 e0)\u00d7 (wl(r)+du\u2212Q)wl(r)+du , otherwise. (4) wl(r) =\n\u2211 v\u2208r dv\nmvt(u, r) = min 0\u2264i\u2264|r| c(u, vi, r) c(u, vi, r) = max { ea\u2032u \u2212 lu, 0 } + max { eu \u2212 la\u2032u, 0 } + max { ea\u2032vi+1 \u2212 lavi+1 , 0 } (5)\nThe cost of inserting supplier u into route r, denoted by mv(u, r), is computed based\non the extent of violating the workload limit and the time-window constraint. The amount\nof workload is translated into time unit by expression (4), where wl(r) is the cumulative\nworkload in route r. If the inspector has enough capability to serve supplier u, namely wl(r) + du \u2264 Q, then no workload penalty is incurred. Otherwise, the penalty, denoted by mvl(u, r), equals the length of the depot time window multiplied by the workload violation percentage.\nThe penalty for time-window violation, denoted by mvt(u, r), considers all possible insertions. For each vi \u2208 r, we can easily find its earliest arrival time eavi when (0, v1, . . . , vi) is feasible, and its latest arrival time lavi that does not affect the feasibility of (vi+1, vi+2, . . . , v|r|, 0). Inserting u into r at the position immediately after vi creates a new route r \u2032, which may be infeasible. Under the condition that (0, v1, . . . , vi) is feasible, we can find the earliest arrival times at u and vi+1 in r \u2032, denoted by ea\u2032u and ea \u2032 vi+1 , respectively. The partial route (0, v1, . . . , vi, u, vi+1) may be infeasible, i.e., ea \u2032 u > lu and/or ea \u2032 vi+1 > lvi+1 . Furthermore, we can also find the latest arrival time at u, denoted by la\u2032u, that makes (vi+1, vi+2, . . . , v|r|, 0) feasible. The penalty for time-window violation incurred by inserting u between vi and vi+1 is calculated by summing up the violations of lu, eu and lavi+1 (see expression (5)). As shown in 16\nexpression (3), the cost of inserting u into r takes into account both mvl(u, r) and mvt(u, r) whose relative weights are controlled by a parameter \u03b7. After sorting the mv(u, S) values of\nall unserved suppliers in ascending order, we can obtain a sequence (mv1, . . . ,mv|U |), where |U | is the cardinality of U . The value of D(S) is calculated by \u2211|U |\ni=1mvi/i. We believe that\nthe solution S with smaller D(S) has more chance to be improved by including the unserved\nsuppliers.\nThe third component F (S) is the summation of the maximal free times of all routes in S. The maximal free time of route r is defined as mft(r) = max0\u2264i\u2264|r|+1{lai \u2212 eai} and\naccordingly F (S) = \u2211\nr\u2208Smft(r)."}, {"heading": "5.3. Initialization", "text": "We obtain an initial feasible solution for the tabu search algorithm using Algorithm 3.\nThis algorithm first generates Ninit feasible solutions using the function init (see Algorithm 4) and then chooses the best one as the initial solution. In each iteration of init, we begin with computing the shortest transit time stri from the tail of each route r to each unserved supplier vi. If vi cannot be feasibly appended at the tail of r, we set st r i = +\u221e. Next, we calculate the ratio of stri to di and set \u03c1i to be the minimal ratio of vi over all routes (see Algorithm 4, line 11). If the value of \u03c1i is positive infinity, i.e., vi cannot be appended at the tail of any route, we remove vi from U . Finally, we sort all suppliers in U by increasing value of \u03c1i and relocate the k-th supplier vs from U to the tail of the route r who has \u03c1s = st r s/ds. The value of k is a random number generated by k = brandom(0, 1)\u03b11 \u00d7 |U |c, where the\ncontrolling parameter \u03b11 > 1. This process is repeated until U becomes empty."}, {"heading": "5.4. Local search with tabu moves", "text": "The pseudocode of the local search procedure with tabu moves is provided in Algorithm\n5. The following context of this subsection presents all main components of this procedure,\nincluding neighborhood structure, tabu list, aspiration and termination criteria.\n17\nAlgorithm 3 Function best init.\n1: Initialize S0 = \u2205; 2: while i \u2264 Ninit do 3: S = init();\n4: if S is better than S0 then 5: S0 \u2190 S; 6: end if\n7: i = i+ 1;\n8: end while\n9: return S0."}, {"heading": "5.4.1. Neighborhood structure", "text": "The neighborhood structure is one of the most important components that determine\nthe size of the search space and the quality of the final solution. Our tabu search algorithm\nemploys five neighborhood operations adapted from classical operations for the VRPTW (Bra\u0308ysy and Gendreau, 2005), namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange. We\ntreat the ejection pool as a dummy route that includes all unserved suppliers. Compared with\ntheir classical counterparts, these adapted operations require more computational efforts to\ncheck the feasibility of the resultant solution, and to update the earliest and latest arrival\ntimes at the affected suppliers.\nFigure 8 illustrates the 2-opt and Or-opt operations. Assume that we are given the\nearliest and latest arrival times (eai and lai) at each supplier i in route r. The earliest departure time (edi) of each supplier can be easily derived by:\nedi =  eai + si, if ceil(eai)\u2212 eai \u2265 si;ceil(eai) + si, otherwise. The 2-opt operation replaces edges (i, i+1) and (j, j+1) with edges (i, j) and (i+1, j+1), and then reverses the directions of all edges between i + 1 and j. The resultant route r\u2032 shown in Figure 8(b) must be feasible if its subroute (j, j\u22121, . . . , i+1, j+1, . . . , 0) is feasible. To check the feasibility of r\u2032, we need to re-calculate the earliest arrival time (ea\u2032k) at each 18\nAlgorithm 4 Function init.\n1: INPUT: the set U of unserved suppliers and m empty routes;\n2: while U is not empty do\n3: for each vi in U do 4: for r = 1, . . . ,m do\n5: if vi can be feasibly appended to the tail of r then 6: stri \u2190 the shortest transit time from the last supplier of r to vi; 7: else 8: stri \u2190 +\u221e; 9: end if\n10: end for 11: \u03c1i = min m r=1{stri/di}; 12: if \u03c1i = +\u221e then 13: Remove vi from U ; 14: end if\n15: end for\n16: Sort all suppliers in U by increasing value of \u03c1i; 17: vs \u2190 the k-th supplier in the sorted supplier list, where k = brandom(0, 1)\u03b11 \u00d7 |U |c\nand \u03b11 > 1;\n18: Append vs at the tail of r with st r s/ds = \u03c1s; 19: Remove vs from U ; 20: end while\nsupplier k in subroute (j, j \u2212 1, . . . , i + 1, j + 1). If ea\u2032k is less than ek or within [ek, lk] for each supplier, this subroute must be feasible. If ea\u2032j+1 in r \u2032 is less than or equal to laj+1 in r, subroute (j + 1, . . . , 0) must be feasible. All ea\u2032k can be obtained in O(nslogn) time using the procedure described in Section 4, where ns is the number of suppliers in subroute (j, j \u2212 1, . . . , i + 1, j + 1). Therefore, it requires O(nslogn) time to check the feasibility of route r\u2032. By contrast, when dealing with the VRPTW, a 2-opt operation only requires\n19\nAlgorithm 5 The local search procedure with tabu moves (local search).\n1: INPUT: the initial solution S; 2: The current best solution S \u2032 \u2190 S and Iter \u2190 0; 3: while Iter \u2264 maxLocalIter do 4: Apply the 2-opt, Or-opt, 2-opt\u2217, relocate and exchange operators on S ; 5: S \u2190 the best allowable solution found by the above operators; 6: if S is better than S \u2032 then 7: S \u2032 \u2190 S and Iter \u2190 0;\n8: else 9: Iter \u2190 Iter + 1;\n10: end if\n11: Update the tabu list;\n12: end while 13: return S \u2032.\nO(ns) time to accomplish the feasibility check. In addition, updating the values of ea \u2032 i and la\u2032i for all suppliers in r \u2032 requires O(|r|logn) time and computing the fitness of the resultant solution requires O(|r||U |logn) time.\nThe Or-opt operation replaces three edges (i\u2212 1), (i+ 1, i+ 2) and (j, j + 1) with edges\n20\n(i\u2212 1, i+ 2), (j, i) and (i+ 1, j + 1); the resultant route is illustrated in Figure 8(c). After\nan Or-opt operation, we can also derive the time complexity for checking the feasibility\nof the resultant route, updating the earliest and latest arrival times at each supplier, and\ncomputing the fitness of the resultant solution in a manner similar to that used for the 2-opt\noperation.\nFigure 9 illustrates the 2-opt\u2217 operation which exchanges the latter subroutes of r1 and r2 by replacing edges (i, i+1) and (j, j+1) with edges (i, j+1) and (j, i+1). The feasibility of the resultant routes can be checked by simply comparing ea\u2032j+1 (resp. ea \u2032 i+1) with laj+1 (resp. lai+1) in O(logn) time. After this operation, we need O((|r1| + |r2|)logn) time to update ea\u2032i and la \u2032 i in r \u2032 1 and r \u2032 2 and O((|r1|+ |r2|)|U |logn) time to update the fitness of the resultant solution.\nThe relocate operation can either relocate supplier j in route r1 to another position in the same route or to route r2, which is illustrated in Figure 10. In the former case, the feasibility of the resultant route shown in Figure 10(b) can be checked by calculating ea\u2032i for all suppliers in subroute (j, i + 1, . . . , j \u2212 1, j + 1). In the latter case, we only need to check the feasibility of r\u20322 shown in Figure 10(c), which can be done in O(logn) time. The relocation operation can also relocate a supplier in the ejection pool to a certain route or\nvice versa.\nThe exchange operation exchanges positions of two suppliers. Figure 11(b) shows the\n21\nresultant route after exchanging the positions of two suppliers in the same route. The feasibility of this route can be checked by calculating ea\u2032i for all suppliers in subroute (j, i+ 1, . . . , j \u2212 1, i, j + 1). The resultant routes created by exchanging two suppliers from two\ndifferent routes are shown in Figure 11(c). The feasibility check can be done in O(logn)\ntime. This operation can also exchange a supplier in some route with a supplier in the\nejection pool."}, {"heading": "5.4.2. Tabu list, aspiration and termination", "text": "Tabu search algorithm employs one or more tabu lists to prevent the search process from\nbeing trapped in local optima. In our implementation, the tabu list stores edges that have\nbeen created within the previous \u03be iterations. A move is considered as tabu if it attempts to\nremove the edges in the tabu list. The tabu restriction can be overridden if the aspiration\ncriterion is satisfied. Specifically, we allow the tabu moves to be performed if the solutions they result in are better than the current best solution S \u2032. The solutions that are created\nby non-tabu moves or by aspiration are called allowable neighbors. All allowable moves\nare stored in a candidate list and sorted according to the fitness values of their resultant\nsolutions. The best candidate is performed to generate the next incumbent solution. We 22\nterminate the local search procedure when maxLocalIter consecutive iterations are unable to improve on S \u2032."}, {"heading": "5.5. Ejection pool", "text": "Ejection pool has been previously used in the algorithms for reducing the number of\nroutes for some routing problems (see for example Lim and Zhang (2007); Nagata and\nBra\u0308ysy (2009); Cheang et al. (2012)). Our ejection pool algorithm (EPA) is presented in Algorithm 6. The initial solution S \u2032 of this algorithm is the best solution found by function local search. Since S \u2032 is a local optimum, no supplier in the ejection pool can be feasibly inserted into S \u2032. The EPA generates a candidate solution based on S \u2032 for each of the unserved suppliers by an insertion-ejection procedure. If the best candidate solution is superior to S \u2032, then S \u2032 is updated.\nFor each u \u2208 U , we evaluate its insertion positions using function c(i, u, j), namely the\ncost of inserting u between two consecutively served suppliers i and j, which is defined as: c(i, u, j) = \u03b21 \u00d7 du \u2212 \u03b22 \u00d7 ( max { 0, ea\u2032u \u2212 lu } + max { 0, ea\u2032j \u2212 lj }) ,\nwhere \u03b21 and \u03b22 are controlling parameters, and ea \u2032 u and ea \u2032 j are the earliest arrival times at suppliers u and j after inserting u between i and j. The position with the smallest value 23\nAlgorithm 6 The ejection pool algorithm (EPA).\n1: INPUT: the initial feasible solution S \u2032; 2: for each u \u2208 U do\n3: Evaluate all insertion positions using the function c(i, u, j); 4: Su \u2190 the resultant solution after inserting u into S \u2032 at the best position; 5: Eject suppliers one by one using the function c(i) until Su becomes feasible; 6: Improve Su by function local search with \u03be = 0; 7: end for 8: if the best candidate solution Su is better than S \u2032 then 9: S \u2032 \u2190 Su;\n10: end if 11: return S \u2032.\nof c(i, u, j) is selected for insertion.\nThe target route rt becomes infeasible after the insertion. Thus, some of its suppliers (except the newly inserted one) need to be ejected one by one until its feasibility is restored.\nThe supplier i to be ejected is determined based on the value of c(i), which is defined as:\nc(i) = \u03b23 \u00d7 di + \u03b24 \u00d7max { wl(r\u2032t)\u2212Q, 0 } + \u03b25 \u00d7 violationtw(r\u2032t),\nwhere \u03b23, \u03b24 and \u03b25 are controlling parameters, r \u2032 t is the resultant route after removing i from rt, and violationtw(r \u2032 t) is the total time-window violation of all suppliers in route r \u2032 t, defined as:\nviolationtw(r \u2032 t) = \u2211 j\u2208r\u2032t max { 0, ea\u2032j \u2212 lj } .\nThe supplier i with minimal c(i) is ejected from the route rt.\nAfter performing the insertion-ejection procedure on each u \u2208 U , we obtain |U | candidate\nsolutions, which are further improved by local search without tabu moves, namely \u03be = 0. The solution S \u2032 is updated by the best candidate solution if possible.\n24"}, {"heading": "5.6. Perturbation", "text": "The perturbation procedure is a diversification scheme that helps the search process es-\ncape from local optima. Our perturbation procedure (function perturb) randomly removes some suppliers from the solution S \u2032 following the rule that the suppliers with smaller workloads have more chances to be removed. Given a solution S \u2032, we sort the served suppliers in\nnon-decreasing order of workloads, generating a supplier list (v1, v2, . . . , vn\u2032). The probability of removing the k-th supplier is determined by:\npmin + (pmax \u2212 pmin)\u00d7 k\nn\u2032 , (6)\nwhere pmin and pmax are controlling parameters satisfying 0 \u2264 pmin \u2264 pmax \u2264 1. It implies that the supplier with larger workload has smaller probability to be kicked out.\nThe tabu search algorithm performs at least maxPerturbation iterations (see line 4 \u2013 13, Algorithm 2). We store the best solution S \u2032 found within each iteration in a solution list.\nThe solutions with equal values of P (S), D(S) and F (S) are regarded as the same. The number of times that the current solution S \u2032 appears in the solution list is represented by\nNrep. When Nrep grows large, we expect that the perturbed solution deviates far from the current solution S \u2032. To this end, we replace pmin and pmax in expression (6) by:\npmin \u2190 pmin + p\u2206 \u00d7min{Nrep, Nmax},\npmax \u2190 pmax + p\u2206 \u00d7min{Nrep, Nmax},\nwhere p\u2206 is a controlling parameter, and the parameter Nmax is used to set an upper bound for the probability. The introduction of Nmax can help avoid the overly large probability, which would cause the process to degenerate into an ineffective multi-start method."}, {"heading": "6. Upper bound", "text": "The solutions generated by our tabu search algorithm are lower bounds to the MPISP.\nIn this section, we construct a constrained knapsack model to produce an upper bound for\nthe MPISP; this model is motivated by Lau et al. (2003).\n25\nThe time windows of all suppliers can be adjusted based on the following straightforward\nobservations. For a supplier i, if the opening time of its time window lies within period p, i.e., ap \u2264 ei \u2264 bp, and it is impossible to complete its service during that period, i.e., bp\u2212ei < si, then the real earliest service starting time for supplier i should be the opening time ap+1 of the next period. Consequently, in this situation ei can be updated by ei = ap+1. Analogously, if ap \u2264 li \u2264 bp and bp \u2212 li < si, we can update li by li = bp \u2212 si. Let \u03bbi = ceil(li + si) + t\u0302i,0 denote the time of returning to the depot immediately after severing supplier i with the service starting time li. We construct a supplier set VG = {g1, g2, . . . , gm} \u2286 VC that contains m distinct suppliers satisfying \u03bbi \u2265 \u03bbj for all i \u2208 VG and j \u2208 VC\\VG.\nObviously, if ei > li, supplier i cannot be served by any inspector and vertex i can only be used as a waypoint. We define f1(i) = 0 if ei > li and f1(i) = 1 otherwise. Suppose ei and li lie within periods p1 and p2, respectively. We define f2(i, p) = 1 if p1 \u2264 p \u2264 p2 and f2(i, p) = 0 otherwise, where f2(i, p) = 1 indicates that supplier i could probably be served during period p. Furthermore, we use f3(i, j) = 1 to indicate that it is possible for an inspector to serve both suppliers i and j when supplier time windows, workload capacity\nand working periods are not considered. Thus, the definition of f3(i, j) is:\nf3(i, j) =  1, if ei + si + ti,j \u2264 lj or ej + sj + tj,i \u2264 li;0, otherwise. We denote by rpi the time required to directly travel from supplier i to its nearest neighbor who could probably be served by the same inspector during period p. Define set V pi = {j \u2208 V |j 6= i, f2(j, p) = 1, f3(i, j) = 1}. We set rpi = +\u221e if V p i is empty, and otherwise rpi = minj\u2208Vi{ti,j}. Let xi,k,p be a binary decision variable that equals 1 if supplier i is served by inspector k during period p, and 0 otherwise. The optimal solution value of the following\n26\ninteger programming model gives an upper bound to the MPISP:\nmax \u2211 i\u2208VC \u2211 k\u2208K \u2211 p\u2208P dixi,k,p (7)\ns.t. \u2211 k\u2208K \u2211 p\u2208P xi,k,p \u2264 f1(i), \u2200 i \u2208 VC (8)\n\u2211 k\u2208K xi,k,p \u2264 f2(i, p), \u2200 i \u2208 VC , p \u2208 P (9)\n\u2211 p\u2208P (xi,k,p + xj,k,p) \u2264 1 + f3(i, j), \u2200i, j \u2208 VC , i 6= j, k \u2208 K (10)\n\u2211 i\u2208VC \u2211 p\u2208P dixi,k,p \u2264 Q, \u2200 k \u2208 K (11)\n\u2211 i\u2208VC \u2211 p\u2208P ( si + min{rpi , r p+1 i , . . . , r w i } ) xi,k,p + r 1 0 \u2264 \u03bbgk , \u2200 k \u2208 K (12)\n\u2211 i\u2208VC xi,k,p(si + r p i )\u2212max i\u2208VC rpi \u2264 T, \u2200 k \u2208 K, p \u2208 P (13) xi,k,p \u2208 {0, 1}, \u2200 i \u2208 VC , k \u2208 K, p \u2208 P (14)\nThe objective (7) is to maximize the total completed workload. Constraints (8) state\nthat each supplier must be assigned to at most one inspector and be served in at most\none period. Constraints (9) guarantee that if supplier i cannot be served by any inspector\nduring period p, all relative variables must be set to zero. Constraints (10) ensure that if\nf3(i, j) = 0, suppliers i and j cannot be served by the same inspector. As the inspector workload capacity cannot be exceeded, Constraints (11) apply. When supplier i is served\nby some inspector, the time it consumes must be at least the sum of si and the traveling time to its nearest neighbor. Any feasible solution to the MPISP must have m routes, each\nof which has an earliest time of returning to the depot. It is easy to observe that the k-th\nlargest return time must be less than or equal to the k-th largest \u03bbgk . Obviously, the sum of si + min{rpi , r p+1 i , . . . , r w i } associated with all suppliers covered by a route should be less than or equal to the length of that route, which is capped by \u03bbgk . Therefore, Constraints (12) hold. After completing the service of supplier i, the inspector may stay at vertex i until the start of the next period. The difference between the total si + r p i of all suppliers served in each period and the largest rpi must be less than or equal to the period length, which is 27\nensured by Constraints (13).\nAny feasible solution to the MPISP must be also feasible to the constrained knapsack\nmodel (7) \u2013 (14). The knapsack problem and many of its variants have been well-studied\nand can be efficiently handled by several commercial mathematical programming solvers."}, {"heading": "7. Computational experiments", "text": "Our tabu search (TS) algorithm was coded in C++ and compiled using the gcc 4.6.1\ncompiler, and was tested on a Dell server with an Intel Xeon E5430 2.66GHz CPU, 8 GB\nRAM and running Linux-CentOS-5.0 64-bit operating system. The algorithm was config-\nured with determined parameter settings: \u03b7 = 1.0, Ninit = 100, \u03b11 = 5, maxPerturbation = 4, maxLocalIter = 200, \u03be = 100, \u03b21 = 0.6, \u03b22 = \u03b23 = \u03b24 = 0.4, \u03b25 = 0.2, pmin = 0.05, pmax = 0.30, p\u2206 = 0.1 and Nmax = 5. The MPISP reduces to the traditional TOPTW when w = 1 and Q = +\u221e. In our experiments, we first applied the TS algorithm to the\nTOPTW instances and compared the results with the recent results reported in Vansteen-\nwegen et al. (2009); Lin and Yu (2012); Labadie et al. (2012); Hu and Lim (2014). Next,\nwe conducted experiments on the MPISP instances generated from the Solomon\u2019s VRPTW\ninstances (Solomon, 1987). Since our TS algorithm is not deterministic, we solved each in-\nstance ten times. Finally, we achieved an upper bound for each MPISP instance by solving\nthe model (7) \u2013 (14) using ILOG CPLEX 12.1 with default settings. Computation times\nreported are in CPU seconds on this server. All instances and detailed results can be found\nonline at: http://www.computational-logistics.org/orlib/mpisp/."}, {"heading": "7.1. Test instances", "text": "We considered the TOPTW instances used in Vansteenwegen et al. (2009); Hu and\nLim (2014), which can be accessed at http://www.mech.kuleuven.be/en/cib/op. Hu and\nLim (2014) classified these instances into two categories, namely \u201cINST-M\u201d and \u201cOPT\u201d;\nthe instances in category INST-M have unknown optimal solution values while the optimal\nsolution values of the instances in category OPT are given.\n28\nThe TOPTW instances in category INST-M were constructed by Montemanni and Gam-\nbardella (2009) based on the OPTW instances by considering the number of vehicles taken from set {1, 2, 3, 4}. These OPTW instances were designed by Righini and Salani (2009)\nusing 56 Solomon\u2019s VRPTW instances (Solomon, 1987) and 20 Cordeau\u2019s multi-depot VRP\n(MDVRP) instances (Cordeau et al., 1997). The Solomon\u2019s VRPTW instances, each con-\ntaining 100 customers, are divided into six groups, namely C1 (c101 \u2013 c109), C2 (c201 \u2013\nc208), R1 (r101 \u2013 r112), R2 (r201 \u2013 r211), RC1 (rc101 \u2013 rc108) and RC2 (rc201 \u2013 rc208).\nThe numbers of customers in the MDVRP instances (pr01 \u2013 pr20) range from 48 to 288. The\nTOPTW instances were obtained from the VRPTW or MDVRP instances by the following\ntwo steps: (1) set the profit collected at each customer to be the demand of this customer,\nand (2) remove the vehicle capacity restriction. The instances in category OPT are the same\nas the instances in category INST-M except for the number of vehicles available. Vansteen-\nwegen et al. (2009) designed the instances in category OPT by setting the number of vehicles\nin each aforementioned TOPTW instance except for pr11 \u2013 pr20 to the number of vehicles\nappearing in the solution of the corresponding VRPTW instance. This implies that with\nsuch number of vehicles, all customers can be visited and the optimal objective value must be equal to the total profits of all customers. Therefore, we have 76 \u00d7 4 = 304 instances in\ncategory INST-M and 66 instances in category OPT, for a total of 370 TOPTW instances.\nWe generated 12 MPISP instances from each Solomon\u2019s VRPTW instance by taking the values of w and m from {1, 3, 5} and {7, 9, 11, 13}, respectively, for a total of 72\ninstance groups (each instance group is identified by the name of Solomon\u2019s instance group,\nw and m) and 672 instances. The workload of each supplier is set to be the demand of the corresponding vertex. The duration of each period is set to T = (l0 \u2212 e0)/w and the workload limit of each inspector is set to 200. The total profits in the MPISP instances\nrelated to the Solomon\u2019s instance groups C1, C2, R1, R2, RC1 and RC2 are 1810, 1810,\n1458, 1458, 1724 and 1724, respectively.\n29"}, {"heading": "7.2. Results for the TOPTW instances", "text": "To evaluate the performance of our algorithm based on the TOPTW instances, we con-\nsidered the following four state-of-the-art existing algorithms in our comparisons:\n\u2022 ILS: the iterated local search algorithm by Vansteenwegen et al. (2009).\n\u2022 SSA: the slow version of the simulated annealing algorithm by Lin and Yu (2012).\n\u2022 GVNS: the LP-based granular variable neighborhood search algorithm by Labadie\net al. (2012).\n\u2022 I3CH: the iterative three-component heuristic (I3CH) by Hu and Lim (2014).\nLin and Yu (2012) proposed two versions of simulated annealing algorithm for the TOPTW,\nnamely a fast version and a slow one. Compared with the fast version, the slow simulated\nannealing algorithm (SSA) is able to find better solutions at the expense of more computation\ntime. As we are more concerned with solution quality, we used the SSA rather than the\nfast version in the comparisons. For each TOPTW instance, the ILS, SSA and I3CH were\nexecuted only once while the GVNS was performed five times. Although these algorithms\nwere coded in different programming languages and executed on different computational\nenvironments (see Table 1), we believe that there is no dramatic difference between the\nspeeds of these algorithms and it is acceptable to directly compare their computation times.\ninstances. We first identified the best solution value (BSV) obtained by these five algorithms 30\nand then computed the ratio of the best solution value produced by each algorithm to\nthe BSV. The columns \u201cRatio (%)\u201d and \u201cTime (s)\u201d show the average ratios and average\ncomputation times of all instance groups. Since Labadie et al. (2012) did not report the\nbest solution value in their article, we filled the corresponding cells with \u201cN/A\u201d and ignored\nthese cells when calculating the overall average ratio. Beside the name of each algorithm,\nwe give the number of times it was run for each instance. The overall average values of\n\u201cRatio (%)\u201d and \u201cTime (s)\u201d are presented in the last row and the best ratios in each row\nare marked in bold. All of the detailed solutions can be found in Appendix B.\nThe numbers of the best solution values achieved by ILS, SSA, GVNS, I3CH and TS\nare 85, 191, 138, 247 and 272, respectively (see Appendix B). Although TS produced the\nlargest number of the best solution values and the largest overall average ratio (i.e., 0.9980),\nwe cannot conclude that this algorithm is superior to the rest since it was executed more\ntimes and consumed more computation time. We can only say that the results generated\nby our TS algorithm are comparable to those generated by the best existing approaches for\nthe TOPTW."}, {"heading": "7.3. Analysis of components", "text": "As our TS algorithm consists of three main components, namely local search with tabu\nmoves (LS), ejection pool (EP) algorithm and perturbation (PER) procedure, it is important\nto investigate the performance of these components. In the experiments, we considered the\ncombinations LS + EP, LS + PER, EP + PER and LS + EP + PER and 50 TOPTW\ninstances generated from pr01 \u2013 pr10. Table 3 shows the average performance of these four\ncombinations. For each test instance, we calculated a ratio that is equal to the average\nprofit over ten runs divided by the best solution value generated by these four combinations\n(for the detailed results, see Appendix C). The column \u201cAvg. Ratio (%)\u201d shows the average\nvalues of the ratios of the instances grouped by m. From this table, we can see that on\naverage, LS + EP + PER performed best while LS + PER generated the worst results.\nMoreover, EP + PER and LS + EP performed slightly worse than LS + EP + PER. These\nobservations imply that the ejection pool algorithm plays a critical role in improving the\n31\nsolution quality of our proposed approach."}, {"heading": "7.4. Results for the MPISP instances", "text": "The column \u201cUB\u201d shows the upper bound of each instance obtained from the constrained\nknapsack model (see Section 6). Each block corresponds to a value of w and includes the\nmaximum workload Max. Workload, the average workload Ave. Workload and the average\ncomputation time Ave. Time over the ten executions. Since the MPISP is a new problem,\nthere is no existing algorithm tailored for it. As a consequence, we cannot compare our\ntabu search algorithm with other approaches. The test instances and computational results\nreported in this article can serve as benchmarks for future researchers on this problem.\nTheoretically speaking, the optimal solution value of some instance with w = d must be\ngreater than or equal to that of the same instance with w = kd, where k is an integral number.\nThis is because we can always construct a feasible solution to an instance with w = d from\nany solution to this instance with w = kd. For example, the optimal solution value of an\ninstance with w = 1 must be greater than those of this instance with w = 3 and w = 5.\nSince our tabu search algorithm is a stochastic approach, it is possible that the maximum\nworkload of some instance with w = 3 or w = 5 is larger than that of this instance with\nw = 1. Fortunately, we did not encounter such phenomenon in our experiments. However, 33\nwhen w2/w1 is not an integer, an instance with w2 may have larger optimal solution value than this instance with w1. For example, the optimal solution value of an instance with w = 5 may be larger than this instance with w = 3. In these tables, we can find several instances\nwith w = 3 have larger maximum workload than their counterparts with w = 5. Since these\nmaximum workloads may not be optimal, we cannot judge whether these phenomena were\nresulted from the randomness of the tabu search algorithm or the nature of the instances.\nObviously, for each instance with a certain w, the maximum workload increases as the\nnumber of vehicles.\nFor each instance group, we calculated the average of all \u201cAve. Time\u201d and show the\nstatistical results in Table 8. From this table, we can observe that in most cases (those are\nnot marked in bold), the average computation times increase as the value of w.\n(b)"}, {"heading": "8. Conclusion", "text": "This paper introduces an inspector scheduling problem in which a set of inspectors are\ndispatched to complete a set of inspection requests at different locations in a multi-period\nplanning horizon. At the end of each period, each inspector is not required to return to the\ndepot but has to stay at one of the inspection locations for recuperation. We first studied\nthe way of computing the shortest transit time between any pair of locations when the\nworking time periods are considered. Next, we introduced several local search operators\nthat were adapted from classical VRPTW operators and integrated these adapted operators\nin a tabu search framework. Moreover, we presented a constrained knapsack model that is\nable to produce an upper bound for the MPISP. Finally, we evaluated the algorithm based\non 370 TOPTW instances and 672 MPISP instances. The experimental results reported in\nthis study show the effectiveness of our algorithm and can serve as benchmarks for future\nresearchers. Since the working time windows of the scheduling subjects and the use of\nwaypoint are very common considerations in practice, a possible research direction can\nfocus on studying the variants of other existing vehicle routing models that involves these\ntwo factors."}, {"heading": "Acknowledgments", "text": "This research was partially supported by the Fundamental Research Funds for the Central\nUniversities, HUST (Grant No. 2014QN206) and National Natural Science Foundation of\nChina (Grant No. 71201065)."}], "references": [{"title": "Network flows: theory, algorithms, and applications", "author": ["R.K. Ahuja", "T.L. Magnanti", "J.B. Orlin"], "venue": null, "citeRegEx": "Ahuja et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Ahuja et al\\.", "year": 1993}, {"title": "An exact algorithm for a vehicle routing problem with time", "author": ["N. Prentice hall. Azi", "M. Gendreau", "Potvin", "J.-Y"], "venue": null, "citeRegEx": "Azi et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Azi et al\\.", "year": 2010}, {"title": "An adaptive guidance approach for the heuristic solution of a minimum multiple trip vehicle routing problem", "author": ["M. Battarra", "M. Monaci", "D. Vigo"], "venue": "Computers & Operations Research", "citeRegEx": "Battarra et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Battarra et al\\.", "year": 2009}, {"title": "Vehicle routing problem with time windows, part I: Route construction and local search algorithms", "author": ["O. Br\u00e4ysy", "M. Gendreau"], "venue": "Transportation Science", "citeRegEx": "Br\u00e4ysy and Gendreau,? \\Q2005\\E", "shortCiteRegEx": "Br\u00e4ysy and Gendreau", "year": 2005}, {"title": "A tabu-search hyperheuristic for timetabling and rostering", "author": ["E.K. Burke", "G. Kendall", "E. Soubeiga"], "venue": "Journal of Heuristics", "citeRegEx": "Burke et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Burke et al\\.", "year": 2003}, {"title": "A tree-based tabu search algorithm for the manpower allocation problem with time windows and job-teaming constraints", "author": ["Y. Cai", "Z. Zhang", "S. Guo", "H. Qin", "A. Lim"], "venue": "Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence. pp", "citeRegEx": "Cai et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Cai et al\\.", "year": 2013}, {"title": "A memetic algorithm for the travelling salesperson problem with hotel selection", "author": ["M. Castro", "K. S\u00f6rensen", "P. Vansteenwegen", "P. Goos"], "venue": "Computers & Operations Research", "citeRegEx": "Castro et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Castro et al\\.", "year": 2013}, {"title": "Multiple pickup and delivery traveling salesman problem with last-in-first-out loading and distance constraints", "author": ["B. Cheang", "X. Gao", "A. Lim", "H. Qin", "W. Zhu"], "venue": "European Journal of Operational Research", "citeRegEx": "Cheang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Cheang et al\\.", "year": 2012}, {"title": "Nurse rostering problems \u2013 a bibliographic survey", "author": ["B. Cheang", "A. Lim", "B. Rodrigues"], "venue": "European Journal of Operational Research", "citeRegEx": "Cheang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Cheang et al\\.", "year": 2003}, {"title": "A reactive tabu search metaheuristic for the vehicle routing problem with time windows", "author": ["Chiang", "W.-C", "R.A. Russell"], "venue": "INFORMS Journal on Computing", "citeRegEx": "Chiang et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Chiang et al\\.", "year": 1997}, {"title": "A tabu search heuristic for periodic and multi-depot vehicle routing problems. Networks", "author": ["Cordeau", "J.-F", "M. Gendreau", "G. Laporte"], "venue": null, "citeRegEx": "Cordeau et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cordeau et al\\.", "year": 1997}, {"title": "A variable neighborhood search method for the orienteering problem with hotel selection", "author": ["A. Divsalar", "P. Vansteenwegen", "D. Cattryssea"], "venue": "International Journal of Production Economics", "citeRegEx": "Divsalar et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Divsalar et al\\.", "year": 2013}, {"title": "A memetic algorithm for the orienteering problem with hotel selection", "author": ["A. Divsalar", "P. Vansteenwegen", "D. Cattryssea"], "venue": "European Journal of Operational Research", "citeRegEx": "Divsalar et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Divsalar et al\\.", "year": 2014}, {"title": "Staff scheduling and rostering: A review of applications, methods and models", "author": ["A.T. Ernst", "H. Jiang", "M. Krishnamoorthy", "D. Sier"], "venue": "European Journal of Operational Research", "citeRegEx": "Ernst et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Ernst et al\\.", "year": 2004}, {"title": "A heuristic for the periodic vehicle routing problem", "author": ["M. Gaudioso", "G. Paletta"], "venue": "Transportation Science", "citeRegEx": "Gaudioso and Paletta,? \\Q1992\\E", "shortCiteRegEx": "Gaudioso and Paletta", "year": 1992}, {"title": "A tabu search heuristic for the vehicle routing problem", "author": ["M. Gendreau", "A. Hertz", "G. Laporte"], "venue": "Management Science", "citeRegEx": "Gendreau et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Gendreau et al\\.", "year": 1994}, {"title": "Vehicle scheduling and routing with drivers", "author": ["A. Goel"], "venue": "working hours. Transportation Science", "citeRegEx": "Goel,? \\Q2009\\E", "shortCiteRegEx": "Goel", "year": 2009}, {"title": "Truck driver scheduling in the European union", "author": ["A. Goel"], "venue": "Transportation Science", "citeRegEx": "Goel,? \\Q2010\\E", "shortCiteRegEx": "Goel", "year": 2010}, {"title": "A unified tabu search heuristic for vehicle routing problems with time windows", "author": ["Gordeau", "J.-F", "G. Laporte", "M. A"], "venue": "Journal of the Operational Research Society", "citeRegEx": "Gordeau et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Gordeau et al\\.", "year": 2001}, {"title": "A variable neighborhood search heuristic for periodic routing problems", "author": ["V.C. Hemmelmayr", "K.F. Doerner", "R.F. Hartl"], "venue": "European Journal of Operational Research", "citeRegEx": "Hemmelmayr et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hemmelmayr et al\\.", "year": 2009}, {"title": "An iterative three-component heuristic for the team orienteering problem with time windows", "author": ["Q. Hu", "A. Lim"], "venue": "European Journal of Operational Research", "citeRegEx": "Hu and Lim,? \\Q2014\\E", "shortCiteRegEx": "Hu and Lim", "year": 2014}, {"title": "Airline crew rostering: Problem types, modeling, and optimization", "author": ["N. Kohl", "S.E. Karisch"], "venue": "Annals of Operations Research", "citeRegEx": "Kohl and Karisch,? \\Q2004\\E", "shortCiteRegEx": "Kohl and Karisch", "year": 2004}, {"title": "A dynamic programming heuristic for the vehicle routing problem with time windows and European community social legislation", "author": ["A.L. Kok", "C.M. Meyer", "H. Kopfer", "J.M.J. Schutten"], "venue": "Transportation Science", "citeRegEx": "Kok et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kok et al\\.", "year": 2010}, {"title": "The team orienteering problem with time windows: An LP-based granular variable neighborhood search", "author": ["N. Labadie", "R. Mansini", "J. Melechovsk\u00fd", "R. Wolfler Calvo"], "venue": "European Journal of Operational Research", "citeRegEx": "Labadie et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Labadie et al\\.", "year": 2012}, {"title": "Vehicle routing problem with time windows and a limited number of vehicles", "author": ["H.C. Lau", "M. Sim", "K.M. Teo"], "venue": "European Journal of Operational Research", "citeRegEx": "Lau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lau et al\\.", "year": 2003}, {"title": "Manpower allocation with time windows and job-teaming constraints", "author": ["Y. Li", "A. Lim", "B. Rodrigues"], "venue": "Naval Research Logistics", "citeRegEx": "Li et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Li et al\\.", "year": 2005}, {"title": "A two-stage heuristic with ejection pools and generalized ejection chains for the vehicle routing problem with time windows", "author": ["A. Lim", "X. Zhang"], "venue": "INFORMS Journal on Computing", "citeRegEx": "Lim and Zhang,? \\Q2007\\E", "shortCiteRegEx": "Lim and Zhang", "year": 2007}, {"title": "A simulated annealing heuristic for the team orienteering problem with time windows", "author": ["Lin", "S.-W", "V.F. Yu"], "venue": "European Journal of Operational Research", "citeRegEx": "Lin et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Lin et al\\.", "year": 2012}, {"title": "Solving the vehicle routing problem with time windows and multiple routes exactly using a pseudo-polynomial model", "author": ["R. Macedo", "C. Alves", "J.M. Val\u00e9rio de Carvalho", "F. Clautiaux", "S. Hanafi"], "venue": "European Journal of Operational Research", "citeRegEx": "Macedo et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Macedo et al\\.", "year": 2011}, {"title": "An ant colony system for team orienteering problems with time windows", "author": ["R. Montemanni", "L.M. Gambardella"], "venue": "Foundations of Computing and Decision Sciences", "citeRegEx": "Montemanni and Gambardella,? \\Q2009\\E", "shortCiteRegEx": "Montemanni and Gambardella", "year": 2009}, {"title": "A powerful route minimization heuristic for the vehicle routing problem with time windows", "author": ["Y. Nagata", "O. Br\u00e4ysy"], "venue": "Operations Research Letters", "citeRegEx": "Nagata and Br\u00e4ysy,? \\Q2009\\E", "shortCiteRegEx": "Nagata and Br\u00e4ysy", "year": 2009}, {"title": "Decremental state space relaxation strategies and initialization heuristics for solving the orienteering problem with time windows with dynamic programming", "author": ["G. Righini", "M. Salani"], "venue": "Computers & Operations Research", "citeRegEx": "Righini and Salani,? \\Q2009\\E", "shortCiteRegEx": "Righini and Salani", "year": 2009}, {"title": "Drive: Dynamic routing of independent vehicles", "author": ["M. Savelsbergh", "M. Sol"], "venue": "Operations Research", "citeRegEx": "Savelsbergh and Sol,? \\Q1998\\E", "shortCiteRegEx": "Savelsbergh and Sol", "year": 1998}, {"title": "Algorithms for the vehicle routing and scheduling problems with time window constraints", "author": ["M.M. Solomon"], "venue": "Operations Research", "citeRegEx": "Solomon,? \\Q1987\\E", "shortCiteRegEx": "Solomon", "year": 1987}, {"title": "Scheduling technicians for planned maintenance of geographically distributed equipment", "author": ["H. Tang", "E. Miller-Hooks", "R. Tomastik"], "venue": "Transportation Research Part E: Logistics and Transportation Review", "citeRegEx": "Tang et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Tang et al\\.", "year": 2007}, {"title": "The vehicle routing problem", "author": ["P. Toth", "D. Vigo"], "venue": null, "citeRegEx": "Toth and Vigo,? \\Q2002\\E", "shortCiteRegEx": "Toth and Vigo", "year": 2002}, {"title": "The granular tabu search and its application to the vehicle-routing problem", "author": ["P. Toth", "D. Vigo"], "venue": "INFORMS Journal on Computing", "citeRegEx": "Toth and Vigo,? \\Q2003\\E", "shortCiteRegEx": "Toth and Vigo", "year": 2003}, {"title": "The orienteering problem: A survey", "author": ["P. Vansteenwegen", "W. Souffriau", "D.V. Oudheusden"], "venue": "European Journal of Operational Research", "citeRegEx": "Vansteenwegen et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Vansteenwegen et al\\.", "year": 2011}, {"title": "The travelling salesperson problem with hotel selection", "author": ["P. Vansteenwegen", "W. Souffriau", "K. S\u00f6rensen"], "venue": "Journal of the Operational Research Society", "citeRegEx": "Vansteenwegen et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Vansteenwegen et al\\.", "year": 2012}, {"title": "Iterated local search for the team orienteering problem with time windows", "author": ["P. Vansteenwegen", "W. Souffriau", "G. Vanden Berghe", "D. Van Oudheusden"], "venue": "Computers & Operations Research", "citeRegEx": "Vansteenwegen et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Vansteenwegen et al\\.", "year": 2009}, {"title": "Solving a practical pickup and delivery problem", "author": ["H. Xu", "Chen", "Z.-L", "S. Rajagopal", "S. Arunapuram"], "venue": "Transportation Science", "citeRegEx": "Xu et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Xu et al\\.", "year": 2003}, {"title": "Multi-period vehicle routing and crew scheduling with outsourcing options", "author": ["G. Z\u00e4pfel", "M. B\u00f6gl"], "venue": "International Journal of Production Economics", "citeRegEx": "Z\u00e4pfel and B\u00f6gl,? \\Q2008\\E", "shortCiteRegEx": "Z\u00e4pfel and B\u00f6gl", "year": 2008}, {"title": "A memetic algorithm for the multiperiod vehicle routing problem with profit", "author": ["Z. Zhang", "O. Che", "B. Cheang", "A. Lim", "H. Qin"], "venue": "European Journal of Operational Research", "citeRegEx": "Zhang et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2013}, {"title": "A two-stage tabu search algorithm with enhanced packing heuristics for the 3L-CVRP and M3L-CVRP", "author": ["W. Zhu", "H. Qin", "A. Lim", "L. Wang"], "venue": "Computers & Operations Research", "citeRegEx": "Zhu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhu et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 1, "context": "We call this problem the multi-period inspector scheduling problem (MPISP), which can be viewed as a variant of the multi-trip vehicle routing problem with time windows (VPRTW) (Azi et al., 2010; Macedo et al., 2011).", "startOffset": 177, "endOffset": 216}, {"referenceID": 28, "context": "We call this problem the multi-period inspector scheduling problem (MPISP), which can be viewed as a variant of the multi-trip vehicle routing problem with time windows (VPRTW) (Azi et al., 2010; Macedo et al., 2011).", "startOffset": 177, "endOffset": 216}, {"referenceID": 8, "context": "Scheduling staff members is a traditional research area; example problems include the nurse rostering problem (Cheang et al., 2003), the technician planning problem (Ernst et al.", "startOffset": 110, "endOffset": 131}, {"referenceID": 13, "context": ", 2003), the technician planning problem (Ernst et al., 2004) and the airline crew rostering problem (Kohl and Karisch, 2004).", "startOffset": 41, "endOffset": 61}, {"referenceID": 21, "context": ", 2004) and the airline crew rostering problem (Kohl and Karisch, 2004).", "startOffset": 47, "endOffset": 71}, {"referenceID": 35, "context": "Since each inspector has to perform inspections at different locations, the MPISP is essentially a variant of the vehicle routing problem (Toth and Vigo, 2002).", "startOffset": 138, "endOffset": 159}, {"referenceID": 23, "context": "Two previously studied problems with similar objective are the team orienteering problem with time windows (TOPTW) (Vansteenwegen et al., 2009, 2011; Labadie et al., 2012; Hu and Lim, 2014) and the vehicle routing problem with time windows and a limited number of vehicles (m-VRPTW) (Lau et al.", "startOffset": 115, "endOffset": 189}, {"referenceID": 20, "context": "Two previously studied problems with similar objective are the team orienteering problem with time windows (TOPTW) (Vansteenwegen et al., 2009, 2011; Labadie et al., 2012; Hu and Lim, 2014) and the vehicle routing problem with time windows and a limited number of vehicles (m-VRPTW) (Lau et al.", "startOffset": 115, "endOffset": 189}, {"referenceID": 24, "context": ", 2012; Hu and Lim, 2014) and the vehicle routing problem with time windows and a limited number of vehicles (m-VRPTW) (Lau et al., 2003; Lim and Zhang, 2007).", "startOffset": 119, "endOffset": 158}, {"referenceID": 26, "context": ", 2012; Hu and Lim, 2014) and the vehicle routing problem with time windows and a limited number of vehicles (m-VRPTW) (Lau et al., 2003; Lim and Zhang, 2007).", "startOffset": 119, "endOffset": 158}, {"referenceID": 14, "context": "The multiperiod planning horizon of the MPISP is related to the periodic vehicle routing problem (PVRP) (Gaudioso and Paletta, 1992; Hemmelmayr et al., 2009) and the multiple trip vehicle routing problem (MTVRP) (Battarra et al.", "startOffset": 104, "endOffset": 157}, {"referenceID": 19, "context": "The multiperiod planning horizon of the MPISP is related to the periodic vehicle routing problem (PVRP) (Gaudioso and Paletta, 1992; Hemmelmayr et al., 2009) and the multiple trip vehicle routing problem (MTVRP) (Battarra et al.", "startOffset": 104, "endOffset": 157}, {"referenceID": 2, "context": ", 2009) and the multiple trip vehicle routing problem (MTVRP) (Battarra et al., 2009).", "startOffset": 62, "endOffset": 85}, {"referenceID": 5, "context": "Scheduling staff members is a traditional research area; example problems include the nurse rostering problem (Cheang et al., 2003), the technician planning problem (Ernst et al., 2004) and the airline crew rostering problem (Kohl and Karisch, 2004). As for the manpower scheduling problems that involve creating routes for staff members, we refer the reader to Li et al. (2005); Tang et al.", "startOffset": 111, "endOffset": 379}, {"referenceID": 5, "context": "Scheduling staff members is a traditional research area; example problems include the nurse rostering problem (Cheang et al., 2003), the technician planning problem (Ernst et al., 2004) and the airline crew rostering problem (Kohl and Karisch, 2004). As for the manpower scheduling problems that involve creating routes for staff members, we refer the reader to Li et al. (2005); Tang et al. (2007); Z\u00e4pfel and B\u00f6gl (2008); Cai et al.", "startOffset": 111, "endOffset": 399}, {"referenceID": 5, "context": "Scheduling staff members is a traditional research area; example problems include the nurse rostering problem (Cheang et al., 2003), the technician planning problem (Ernst et al., 2004) and the airline crew rostering problem (Kohl and Karisch, 2004). As for the manpower scheduling problems that involve creating routes for staff members, we refer the reader to Li et al. (2005); Tang et al. (2007); Z\u00e4pfel and B\u00f6gl (2008); Cai et al.", "startOffset": 111, "endOffset": 423}, {"referenceID": 4, "context": "(2007); Z\u00e4pfel and B\u00f6gl (2008); Cai et al. (2013); Zhang et al.", "startOffset": 32, "endOffset": 50}, {"referenceID": 4, "context": "(2007); Z\u00e4pfel and B\u00f6gl (2008); Cai et al. (2013); Zhang et al. (2013). Since each inspector has to perform inspections at different locations, the MPISP is essentially a variant of the vehicle routing problem (Toth and Vigo, 2002).", "startOffset": 32, "endOffset": 71}, {"referenceID": 2, "context": ", 2009) and the multiple trip vehicle routing problem (MTVRP) (Battarra et al., 2009). However, the MPISP is quite different from the PVRP and MTVRP. In the PVRP, each customer requires a certain number of visits within the planning horizon, and two types of decisions are involved in the planning, namely determining the visit days for each customer and the routing plan for each time period. The PVRP and MTVRP both require that each vehicle must return to the depot at the end of each period. Another defining characteristic of the MPISP is the consideration of multiple working periods. Working hour regulations have recently received increasing attention from some researchers studying vehicle routing problems. Savelsbergh and Sol (1998) proposed a dynamic", "startOffset": 63, "endOffset": 744}, {"referenceID": 38, "context": "The OPHS is a variant of the traveling salesperson problem with hotel selection (TSPHS) (Vansteenwegen et al., 2012; Castro et al., 2013), which aims to serve all vertices with the minimum number of connected trips and the minimum total travel distance.", "startOffset": 88, "endOffset": 137}, {"referenceID": 6, "context": "The OPHS is a variant of the traveling salesperson problem with hotel selection (TSPHS) (Vansteenwegen et al., 2012; Castro et al., 2013), which aims to serve all vertices with the minimum number of connected trips and the minimum total travel distance.", "startOffset": 88, "endOffset": 137}, {"referenceID": 30, "context": "Xu et al. (2003) applied column generation based solution approaches to solve a pickup and delivery vehicle routing problem that involves a set of practical complications, such as heterogeneous vehicles, last-in-first-out loading and unloading operations, pickup and delivery time windows, and working hour restrictions by the United States Department of Transportation.", "startOffset": 0, "endOffset": 17}, {"referenceID": 13, "context": "Similarly, Goel (2009, 2010) and Kok et al. (2010) investigated combined vehicle routing and driver scheduling problems under the European Union regulations for drivers.", "startOffset": 11, "endOffset": 51}, {"referenceID": 6, "context": ", 2012; Castro et al., 2013), which aims to serve all vertices with the minimum number of connected trips and the minimum total travel distance. The common characteristic of the above three problems is the involvement of hotel selection. Tang et al. (2007) and Z\u00e4pfel and B\u00f6gl (2008) introduced two manpower routing and scheduling problems that involve maximization of profits, multiple periods and working hour restrictions.", "startOffset": 8, "endOffset": 257}, {"referenceID": 6, "context": ", 2012; Castro et al., 2013), which aims to serve all vertices with the minimum number of connected trips and the minimum total travel distance. The common characteristic of the above three problems is the involvement of hotel selection. Tang et al. (2007) and Z\u00e4pfel and B\u00f6gl (2008) introduced two manpower routing and scheduling problems that involve maximization of profits, multiple periods and working hour restrictions.", "startOffset": 8, "endOffset": 284}, {"referenceID": 6, "context": ", 2012; Castro et al., 2013), which aims to serve all vertices with the minimum number of connected trips and the minimum total travel distance. The common characteristic of the above three problems is the involvement of hotel selection. Tang et al. (2007) and Z\u00e4pfel and B\u00f6gl (2008) introduced two manpower routing and scheduling problems that involve maximization of profits, multiple periods and working hour restrictions. However, their problems require that the trip in each period must start from and end at the depot. Most recently, Zhang et al. (2013) proposed an inspector scheduling problem which is very similar to our problem.", "startOffset": 8, "endOffset": 560}, {"referenceID": 0, "context": "t\u0302i,j = min u\u2208V {t\u0302i,j} To compute all t\u0302i,j, we can apply an algorithm modified from the Dijkstra\u2019s algorithm (Ahuja et al., 1993), one of the most well-known label-setting algorithms for the classical shortest path problem.", "startOffset": 111, "endOffset": 131}, {"referenceID": 15, "context": "Tabu search algorithm has been successfully applied to a wide variety of routing and scheduling problems, such as the classical VRP (Gendreau et al., 1994; Toth and Vigo, 2003), the VRPTW (Chiang and Russell, 1997; Gordeau et al.", "startOffset": 132, "endOffset": 176}, {"referenceID": 36, "context": "Tabu search algorithm has been successfully applied to a wide variety of routing and scheduling problems, such as the classical VRP (Gendreau et al., 1994; Toth and Vigo, 2003), the VRPTW (Chiang and Russell, 1997; Gordeau et al.", "startOffset": 132, "endOffset": 176}, {"referenceID": 18, "context": ", 1994; Toth and Vigo, 2003), the VRPTW (Chiang and Russell, 1997; Gordeau et al., 2001), the three-dimensional loading capacitated VRP (Zhu et al.", "startOffset": 40, "endOffset": 88}, {"referenceID": 43, "context": ", 2001), the three-dimensional loading capacitated VRP (Zhu et al., 2012), the job-shop scheduling problem (Barnes and", "startOffset": 55, "endOffset": 73}, {"referenceID": 4, "context": "Chambers, 1995) and the nurse rostering problem (Burke et al., 2003).", "startOffset": 48, "endOffset": 68}, {"referenceID": 3, "context": "Our tabu search algorithm employs several operations adapted from classical operations for the VRPTW, namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange (Br\u00e4ysy and Gendreau, 2005), and an ejection pool (Lim and Zhang, 2007; Nagata and Br\u00e4ysy, 2009).", "startOffset": 154, "endOffset": 181}, {"referenceID": 26, "context": "Our tabu search algorithm employs several operations adapted from classical operations for the VRPTW, namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange (Br\u00e4ysy and Gendreau, 2005), and an ejection pool (Lim and Zhang, 2007; Nagata and Br\u00e4ysy, 2009).", "startOffset": 204, "endOffset": 250}, {"referenceID": 30, "context": "Our tabu search algorithm employs several operations adapted from classical operations for the VRPTW, namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange (Br\u00e4ysy and Gendreau, 2005), and an ejection pool (Lim and Zhang, 2007; Nagata and Br\u00e4ysy, 2009).", "startOffset": 204, "endOffset": 250}, {"referenceID": 26, "context": "respectively, which is inspired by Lim and Zhang (2007). As a result, the fitness function consists of three lexicographically ordered components, namely P (S), D(S) and F (S).", "startOffset": 35, "endOffset": 56}, {"referenceID": 3, "context": "Our tabu search algorithm employs five neighborhood operations adapted from classical operations for the VRPTW (Br\u00e4ysy and Gendreau, 2005), namely 2-opt, Or-opt, 2-opt\u2217, Relocate and Exchange.", "startOffset": 111, "endOffset": 138}, {"referenceID": 24, "context": "Ejection pool has been previously used in the algorithms for reducing the number of routes for some routing problems (see for example Lim and Zhang (2007); Nagata and Br\u00e4ysy (2009); Cheang et al.", "startOffset": 134, "endOffset": 155}, {"referenceID": 24, "context": "Ejection pool has been previously used in the algorithms for reducing the number of routes for some routing problems (see for example Lim and Zhang (2007); Nagata and Br\u00e4ysy (2009); Cheang et al.", "startOffset": 134, "endOffset": 181}, {"referenceID": 7, "context": "Ejection pool has been previously used in the algorithms for reducing the number of routes for some routing problems (see for example Lim and Zhang (2007); Nagata and Br\u00e4ysy (2009); Cheang et al. (2012)).", "startOffset": 182, "endOffset": 203}, {"referenceID": 24, "context": "In this section, we construct a constrained knapsack model to produce an upper bound for the MPISP; this model is motivated by Lau et al. (2003). 25", "startOffset": 127, "endOffset": 145}, {"referenceID": 33, "context": "Next, we conducted experiments on the MPISP instances generated from the Solomon\u2019s VRPTW instances (Solomon, 1987).", "startOffset": 99, "endOffset": 114}, {"referenceID": 34, "context": "In our experiments, we first applied the TS algorithm to the TOPTW instances and compared the results with the recent results reported in Vansteenwegen et al. (2009); Lin and Yu (2012); Labadie et al.", "startOffset": 138, "endOffset": 166}, {"referenceID": 34, "context": "In our experiments, we first applied the TS algorithm to the TOPTW instances and compared the results with the recent results reported in Vansteenwegen et al. (2009); Lin and Yu (2012); Labadie et al.", "startOffset": 138, "endOffset": 185}, {"referenceID": 22, "context": "(2009); Lin and Yu (2012); Labadie et al. (2012); Hu and Lim (2014).", "startOffset": 27, "endOffset": 49}, {"referenceID": 20, "context": "(2012); Hu and Lim (2014). Next, we conducted experiments on the MPISP instances generated from the Solomon\u2019s VRPTW instances (Solomon, 1987).", "startOffset": 8, "endOffset": 26}, {"referenceID": 36, "context": "We considered the TOPTW instances used in Vansteenwegen et al. (2009); Hu and Lim (2014), which can be accessed at http://www.", "startOffset": 42, "endOffset": 70}, {"referenceID": 20, "context": "(2009); Hu and Lim (2014), which can be accessed at http://www.", "startOffset": 8, "endOffset": 26}, {"referenceID": 20, "context": "(2009); Hu and Lim (2014), which can be accessed at http://www.mech.kuleuven.be/en/cib/op. Hu and Lim (2014) classified these instances into two categories, namely \u201cINST-M\u201d and \u201cOPT\u201d; the instances in category INST-M have unknown optimal solution values while the optimal solution values of the instances in category OPT are given.", "startOffset": 8, "endOffset": 109}, {"referenceID": 33, "context": "These OPTW instances were designed by Righini and Salani (2009) using 56 Solomon\u2019s VRPTW instances (Solomon, 1987) and 20 Cordeau\u2019s multi-depot VRP (MDVRP) instances (Cordeau et al.", "startOffset": 99, "endOffset": 114}, {"referenceID": 10, "context": "These OPTW instances were designed by Righini and Salani (2009) using 56 Solomon\u2019s VRPTW instances (Solomon, 1987) and 20 Cordeau\u2019s multi-depot VRP (MDVRP) instances (Cordeau et al., 1997).", "startOffset": 166, "endOffset": 188}, {"referenceID": 28, "context": "The TOPTW instances in category INST-M were constructed by Montemanni and Gambardella (2009) based on the OPTW instances by considering the number of vehicles taken from set {1, 2, 3, 4}.", "startOffset": 59, "endOffset": 93}, {"referenceID": 28, "context": "The TOPTW instances in category INST-M were constructed by Montemanni and Gambardella (2009) based on the OPTW instances by considering the number of vehicles taken from set {1, 2, 3, 4}. These OPTW instances were designed by Righini and Salani (2009) using 56 Solomon\u2019s VRPTW instances (Solomon, 1987) and 20 Cordeau\u2019s multi-depot VRP (MDVRP) instances (Cordeau et al.", "startOffset": 59, "endOffset": 252}, {"referenceID": 10, "context": "These OPTW instances were designed by Righini and Salani (2009) using 56 Solomon\u2019s VRPTW instances (Solomon, 1987) and 20 Cordeau\u2019s multi-depot VRP (MDVRP) instances (Cordeau et al., 1997). The Solomon\u2019s VRPTW instances, each containing 100 customers, are divided into six groups, namely C1 (c101 \u2013 c109), C2 (c201 \u2013 c208), R1 (r101 \u2013 r112), R2 (r201 \u2013 r211), RC1 (rc101 \u2013 rc108) and RC2 (rc201 \u2013 rc208). The numbers of customers in the MDVRP instances (pr01 \u2013 pr20) range from 48 to 288. The TOPTW instances were obtained from the VRPTW or MDVRP instances by the following two steps: (1) set the profit collected at each customer to be the demand of this customer, and (2) remove the vehicle capacity restriction. The instances in category OPT are the same as the instances in category INST-M except for the number of vehicles available. Vansteenwegen et al. (2009) designed the instances in category OPT by setting the number of vehicles in each aforementioned TOPTW instance except for pr11 \u2013 pr20 to the number of vehicles appearing in the solution of the corresponding VRPTW instance.", "startOffset": 167, "endOffset": 867}, {"referenceID": 37, "context": "\u2022 ILS: the iterated local search algorithm by Vansteenwegen et al. (2009).", "startOffset": 46, "endOffset": 74}, {"referenceID": 23, "context": "\u2022 GVNS: the LP-based granular variable neighborhood search algorithm by Labadie et al. (2012).", "startOffset": 72, "endOffset": 94}, {"referenceID": 20, "context": "\u2022 I3CH: the iterative three-component heuristic (I3CH) by Hu and Lim (2014).", "startOffset": 58, "endOffset": 76}, {"referenceID": 23, "context": "Since Labadie et al. (2012) did not report the best solution value in their article, we filled the corresponding cells with \u201cN/A\u201d and ignored these cells when calculating the overall average ratio.", "startOffset": 6, "endOffset": 28}], "year": 2014, "abstractText": "This paper introduces a multi-period inspector scheduling problem (MPISP), which is a new variant of the multi-trip vehicle routing problem with time windows (VRPTW). In the MPISP, each inspector is scheduled to perform a route in a given multi-period planning horizon. At the end of each period, each inspector is not required to return to the depot but has to stay at one of the vertices for recuperation. If the remaining time of the current period is insufficient for an inspector to travel from his/her current vertex A to a certain vertex B, he/she can choose either waiting at vertex A until the start of the next period or traveling to a vertex C that is closer to vertex B. Therefore, the shortest transit time between any vertex pair is affected by the length of the period and the departure time. We first describe an approach of computing the shortest transit time between any pair of vertices with an arbitrary departure time. To solve the MPISP, we then propose several local search operators adapted from classical operators for the VRPTW and integrate them into a tabu search framework. In addition, we present a constrained knapsack model that is able to produce an upper bound for the problem. Finally, we evaluate the effectiveness of our algorithm with extensive experiments based on a set of test instances. Our computational results indicate that our approach generates high-quality solutions.", "creator": "LaTeX with hyperref package"}}}