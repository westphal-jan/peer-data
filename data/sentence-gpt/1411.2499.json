{"id": "1411.2499", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2014", "title": "Comparative Study of View Update Algorithms in Rational Choice Theory", "abstract": "The dynamics of belief and knowledge is one of the major components of any autonomous system that should be able to incorporate new pieces of information. We show that knowledge base dynamics has interesting connection with kernel change via hitting set and abduction. The approach extends and integrates standard techniques for efficient query answering and integrity checking and analysis of knowledge-driven information. More detailed questions like this can be found in the \"Learning to Trust\" blog at The University of Wisconsin, and the IEEE Web.\n\n\n\nAbout IISP: IISP is the global community dedicated to the development of intelligent data processing systems that are used in the real world for the purpose of \"innovation and improvement of machine learning.\" It is dedicated to building open source data infrastructure that provides reliable and scalable and scalable information storage services.\nIISP is a nonprofit, enterprise and organization that focuses on innovative approaches to information-driven information technology, using open source platforms to help them to effectively manage data and learn more about the information they need.\nIn addition to providing the tools for managing data storage, IISP aims to build a collaborative ecosystem of community members that promotes the development of open source technology. IISP is a global research group, based in Barcelona.\nAbout IISP: IISP is a collaborative technology that helps researchers collaborate on new technology such as AI, machine learning, and artificial intelligence. It is based in Singapore, but is focused mainly on developing computer science and software that will enable them to use a variety of technologies. IISP is one of the key components of every project that is building and maintaining an organization that includes IISP is a collaborative technology that enables organizations to build and maintain an organization that provides reliable and scalable data storage services. It is funded by the Ministry of Health. It is a global partnership between IISP and the World Health Organization (WHO) and provides information-driven services for health professionals. It includes a dedicated database and database, which will provide a way for the organization to provide more accurate, accurate information. It provides an automated database of information about millions of people who are not involved in the data sharing. The IISP initiative is organized and has a number of programs built specifically for the use of IISP that can also help the organization to improve their data processing.\nAbout IISP: IISP was founded in June of 2005 by Erik C. Wolk, a prominent IISP veteran, and a graduate student in computer science and technology. He and his colleagues developed and developed", "histories": [["v1", "Mon, 10 Nov 2014 16:43:24 GMT  (41kb)", "http://arxiv.org/abs/1411.2499v1", "this http URLarXiv admin note: substantial text overlap witharXiv:1407.3512,arXiv:1301.5154"]], "COMMENTS": "this http URLarXiv admin note: substantial text overlap witharXiv:1407.3512,arXiv:1301.5154", "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.LO", "authors": ["radhakrishnan delhibabu"], "accepted": false, "id": "1411.2499"}, "pdf": {"name": "1411.2499.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Radhakrishnan Delhibabu"], "emails": ["delhibabu@kbsg.rwth-aachen.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 1.\n24 99\nv1 [\ncs .A\nI] 1\n0 N\nov 2\nKeyword: AGM, Belief Revision, Knowledge Base Dynamics, Kernel Change, Abduction, Hyber Tableaux, Magic Set, View update, Update Propagation."}, {"heading": "1 Introduction", "text": "Modeling intelligent agents\u2019 reasoning requires designing knowledge bases for the purpose of performing symbolic reasoning. Among the different types of knowledge representations in the domain of artificial intelligence, logical representations stem from classical logic. However, this is not suitable for representing or treating items of information containing vagueness, incompleteness or uncertainty, or knowledge base evolution that leads the agent to change his beliefs about the world.\nWhen a new item of information is added to a knowledge base, it may become inconsistent. In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework. Revision means modifying the knowledge base in order to maintain consistency [81], while keeping the new information and removing (contraction) or not removing the least possible previous information. In our case, update means revision and contraction, that is insertion and deletion in database perspective. Previous work [6,7] makes connections with contraction from knowledge base dynamics.\n\u22c6 This paper extends work from Delhibabu [34] and Mayol [83]\nOur knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]). Knowledge bases have a set of integrity constraints (see the definitions in later section). In the case of finite knowledge bases, it is sometimes hard to see how the update relations should be modified to accomplish certain knowledge base updates.\nExample 1. Consider a database with an (immutable) rule that a staff member is a person who is currently working in a research group under a chair. Additional (updatable) facts are that matthias and gerhard are group chairs, and delhibabu and aravindan are staff members in group info1. Our first integrity constraint (IC) is that each research group has only one chair ie. \u2200x, y, z (y=x)\u2190 group chair(x,y) \u2227 group chair(x,z). Second integrity constraint is that a person can be a chair for only one research group ie. \u2200x, y, z (y=z)\u2190 group chair(y,x) \u2227 group chair(z,x).\nImmutable part: staff chair(X,Y)\u2190 staff group(X,Z),group chair(Z,Y).\nUpdatable part: group chair(infor1,matthias)\u2190 group chair(infor2,gerhard)\u2190 staff group(delhibabu,infor1)\u2190 staff group(aravindan,infor1)\u2190\nSuppose we want to update this database with the information, staff chair(aravindan,gerhard); From the immutable part, we can deduce that this can be achieved by asserting staff group(aravindan,Z) \u2227 group chair(Z,gerhard)\nIf we are restricted to definite clauses, there are three plausible ways to do this: first case is, aravindan and gerhard belong to infor1, i.e, staff group(aravindan,info1) \u2227\ngroup chair(info1,gerhard). We need to delete both base facts group chair(infor1,matthias)\u2190 and group chair(infor2,gerhard)\u2190, because our first IC as well as second IC would be violated otherwise. In order to change the view, we need to insert group chair(infor1,gerhard)\u2190 as a base fact. Assume that we have an algorithm that deletes the base facts staff group(delhibabu,infor1)\u2190 from the database. But, no rational person will agree with such an algorithm, because the fact staff group(delhibabu,infor1)\u2190 is not \u201drelevant\u201d to the view atom.\nSecond case, aravindan and gerhard belong to infor2, that is staff group(aravindan,info2) \u2227\ngroup chair(info2,gerhard). Simply, insert the new fact staff group(aravindan,infor2)\u2190 to change the view. Suppose an algorithm deletes the base facts staff group(aravindan,infor1)\u2190 from the database, then it can not be \u201drational\u201d since these facts are not \u201drelevant\u201d to the view atom.\nThird case, aravindan and gerhard belong to infor3 (free assignment of the group value), that is staff group(aravindan,info3) \u2227\ngroup chair(info3,gerhard). Suppose, we insert new base fact group chair(info3,gerhard) \u2190, our second IC does not follow. Suppose an algorithm inserts the new base fact staff group(aravindan,infor2)\u2190 or staff group(aravindan,infor1)\u2190 is deleted, then it can not be \u201drational\u201d.\nThe above example highlights the need for some kind of \u201drelevance policy\u201d to be adopted when a view atom is to be inserted to a deductive database. How many such axioms and policies do we need to characterize a \u201dgood\u201d view update? When are we sure that our algorithm for view update is \u201drational\u201d? Clearly, there is a need for an axiomatic characterization of view updates. By axiomatic characterization, we mean explicitly listing all the rationality axioms that are to be satisfied by any algorithm for view update.\nWhen dealing with the revision of a knowledge base (both insertions and deletions), there are other ways to change a knowledge base and it has to be performed automatically also. Considering the information, change is precious and must be preserved as much as possible. The principle of minimal change [58,97] can provide a reasonable strategy. On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourro\u0301n, Peter Ga\u0308rdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?\nThe basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them. One specific feature of this diagnosis algorithm is the use of semantics (by transforming the system description and the observation using an initial model of the correctly working system) in guiding the search for a diagnosis. This semantical guidance by program transformation turns out to be useful for database updates as well. More specifically we use a (least) Herbrand model of the given database to transform it along with the update request into a disjunctive logic program in such a way that the models of this transformed program stand for possible updates. This paper aims at studying the view update algorithms in relational databases. First, we define a framework for highlighting the basic theory of minimal change. Thus, we present a generalized revision algorithm based on abductive explanation for knowledge base revision and main view update method.\nThe rest of paper is organized as follows: First we start with preliminaries in Section 2. In Section 3, we introduce knowledge base dynamics along with the concept of generalized revision, and revision operator for knowledge base. Section 4 studies the relationship between knowledge base dynamics and abduction. We discuss an important application of knowledge base dynamics in providing an axiomatic characterization for updating view literal to databases. We briefly discuss hyper tableaux calculus and magic set in Section 5. We present two variants of our rational and efficient algorithm for view update in Section 6. In Section 7, we discuses six basic dimensions in the process of view updating and comparative study of view update algorithms in rational approach is presented. In Section 7, we give brief overview. In Section 8 we draw conclusions with a summary of our contribution and indicate future directions of our investigation. All proofs can be found in the Appendix."}, {"heading": "2 Preliminaries", "text": "We consider a propositional language LP defined from a finite set of propositional variables P and the standard connectives. We use lower case Roman letters a, b, x, y, ... to range over elementary letters and Greek letters \u03d5, \u03c6, \u03c8, ... for propositional formulae. Sets of formulae are denoted by upper case Roman letters A,B, F,K, ..... A literal is an atom (positive literal), or a negation of an atom (negative literal).\nFor any formula \u03d5, we write E(\u03d5) to mean the set of the elementary letters that occur in \u03d5. The same notation also applies to a set of formulae. For any set F of formulae, L(F ) represents the sub-language generated by E(F ), i.e., the set of all formulae \u03d5 with E(\u03d5) \u2286 E(F ).\nHorn formulae are defined [37] as follows:\n1. Every a \u2208 \u03a6 where \u03a6 \u2208 LP \u222a {\u22a5} , a and \u00aca are Horn clauses. 2. a\u2190 a1 \u2227a2 \u2227 ...\u2227an is a Horn clause, where n \u2265 0 and a, ai \u2208 \u03a6 (1 \u2264 i \u2264 n). 3. Every Horn clause is a Horn formula, a is called head and ai is body of the\nHorn formula. 4. If \u03d5 and \u03c8 are Horn formulae, so is \u03d5 \u2227 \u03c8.\nA definite Horn clause is a finite set of literals (atoms) that contains exactly one positive literal which is called the head of the clause. The set of negative literals of this definite Horn clause is called the body of the clause. A Horn clause is non-recursive, if the head literal does not occur in its body. We usually denote a Horn clause as head\u2190body. Let LH be the set of all Horn formulae with respect to LP . A formula \u03c6 is a syntactic consequence within LP of a set \u0393 of formulas if there is a formal proof in LP of \u03c6 from the set \u0393 is \u0393 \u22a2LP \u03c6.\nA immutable part is a function-free clause of the form a\u2190 a1 \u2227 a2 \u2227 ...\u2227 an, with n \u2265 1 where a is an atom denoting the immutable part\u2019s head and a1 \u2227 a2 \u2227 ... \u2227 an are literals. i.e., positive or negative atoms, representing the body of the Horn clauses.\nFormally, a finite Horn knowledge baseKB is defined as a finite set of formulae from language LH, and divided into three parts: an immutable theory KBI is a Horn formula (head\u2190body), which is the fixed part of the knowledge; updatable theory KBU is a Horn clause (head\u2190); and integrity constraint KBIC representing a set of clauses (\u2190body).\nDefinition 1 (Horn Knowledge Base). A Horn knowledge base, KB is a finite set of Horn formulae from language LH, s.t KB = KBI \u222aKBU \u222aKBIC, KBI \u2229KBU = \u2205 and KBU \u2229KBIC = \u2205.\nIn the AGM framework, a belief set is represented by a deductively closed set of propositional formulae. While such sets are infinite, they can always be finitely representable. However, working with deductively closed, infinite belief sets is not very attractive from a computational point of view. The AGM approach to belief dynamics is very attractive in its capturing the rationality of change, but it is not always easy to implement either Horn formula based partial meet revision. In\nreal application from artificial intelligence and databases, what is required is to represent the knowledge using a finite Horn knowledge base. Further, a certain part of the knowledge is treated as immutable and should not be changed.\nKnowledge base change deals with situations in which an agent has to modify its beliefs about the world, usually due to new or previously unknown incoming information, also represented as formulae of the language. Common operations of interest in Horn knowledge base change are the expansion of an agent\u2019s current Horn knowledge base KB by a given Horn clause \u03d5 (usually denoted as KB+\u03d5), where the basic idea is to add regardless of the consequences, and the revision of its current beliefs by \u03d5 (denoted as KB * \u03d5), where the intuition is to incorporate \u03d5 into the current beliefs in some way while ensuring consistency of the resulting theory at the same time. Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [2]), which is intended to represent situations in which an agent has to give up \u03d5 from its current stock of beliefs (denoted as KB-\u03d5).\nDefinition 2 (AGM Contraction). Let KB be a Horn knowledge base, and \u03b1 a belief that is present in KB. Then contraction of KB by \u03b1, denoted as KB\u2212\u03b1, is a consistent belief set that excludes \u03b1\nDefinition 3 (Levi Identity). Let - be an AGM contraction operator for KB. A way to define a revision is by using Generalized Levi Identity:\nKB \u2217 \u03b1 = (KB \u2212 \u00ac\u03b1) \u222a \u03b1\nThen, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [45]. The aim of our work is not to define revision from contraction, but rather to construct and axiomatically characterize revision operators in a direct way."}, {"heading": "3 Knowledge base dynamics", "text": "AGM [2] proposed a formal framework in which revision(contraction) is interpreted as belief change. Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [7]) has to verify.\nIn the AGM approach, a belief is represented by a sentence over a suitable language LH, and a belief KB is represented by a set of sentence that are close wrt the logical closure operator Cn. It is assumed that LH, is closed under application of the boolean operators negation, conjunction, disjunction, and implication.\nDefinition 4. Let KB be a knowledge base with an immutable part KBI . Let \u03b1 and \u03b2 be any two clauses from LH. Then, \u03b1 and \u03b2 are said to be KB-equivalent iff the following condition is satisfied: \u2200 set of Horn clauses E \u2286 LH: KBI \u222aE \u22a2 \u03b1 iff KBI \u222a E \u22a2 \u03b2.\nThese postulates stem from three main principles: the new item of information has to appear in the revised knowledge base, the revised base has to be consistent and revision operation has to change the least possible beliefs. Now we consider the revision of a Horn clause \u03b1 wrt KB, written as KB \u2217 \u03b1. The rationality postulates for revising \u03b1 from KB can be formulated as follows:\nDefinition 5 (Rationality postulates for knowledge base revision).\n(KB*1) Closure: KB \u2217 \u03b1 is a knowledge base. (KB*2) Weak Success: if \u03b1 is consistent with KBI \u222aKBIC then \u03b1 \u2286 KB \u2217 \u03b1. (KB*3.1) Inclusion: KB \u2217 \u03b1 \u2286 Cn(KB \u222a \u03b1). (KB*3.2) Immutable-inclusion: KBI \u2286 Cn(KB \u2217 \u03b1). (KB*4.1) Vacuity 1: if \u03b1 is inconsistent with KBI \u222aKBIC then KB \u2217\u03b1 = KB. (KB*4.2) Vacuity 2: if KB \u222a \u03b1 0\u22a5 then KB \u2217 \u03b1 = KB \u222a \u03b1. (KB*5) Consistency: if \u03b1 is consistent with KBI \u222a KBIC then KB \u2217 \u03b1 is\nconsistent with KBI \u222aKBIC . (KB*6) Preservation: If \u03b1 and \u03b2 are KB-equivalent, then KB \u2217 \u03b1\u2194 KB \u2217 \u03b2. (KB*7.1) Strong relevance: KB \u2217 \u03b1 \u22a2 \u03b1 If KBI 0 \u00ac\u03b1 (KB*7.2) Relevance: If \u03b2 \u2208 KB\\KB \u2217 \u03b1, then there is a set KB\u2032 such that\nKB \u2217 \u03b1 \u2286 KB\u2032 \u2286 KB \u222a \u03b1, KB\u2032 is consistent KBI \u222a KBIC with \u03b1, but KB\u2032 \u222a {\u03b2} is inconsistent KBI \u222aKBIC with \u03b1. (KB*7.3) Weak relevance: If \u03b2 \u2208 KB\\KB \u2217\u03b1, then there is a set KB\u2032 such that KB\u2032 \u2286 KB \u222a \u03b1, KB\u2032 is consistent KBI \u222aKBIC with \u03b1, but KB\u2032 \u222a {\u03b2} is inconsistent KBI \u222aKBIC with \u03b1.\nTo revise \u03b1 from KB, only those information that are relevant to \u03b1 in some sense can be added (as the example from the introduction illustrates). (KB\u22177.1) is a very strong axiom allowing only minimum changes, and certain rational revisions can not be carried out. So, relaxing this condition (example with more details can be found in [7]) allows for weakening strong relevance to relevance only. The relevance policy (KB \u2217 7.2), however, still does not permit rational revisions, so we need to go one step further. With (KB \u2217 7.3) the relevance axiom is further weakened and the resulting conditions are referred to as \u201dcoreretainment\u201d."}, {"heading": "3.1 Relationship with Abductive Logic Grammars", "text": "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [4]). We show how abduction grammar could be used to realize revision with immutability condition. A special subset of literal (atoms) of language LH, abducibles Ab, are designated for abductive reasoning. Our work is based on atoms, so we combine Christiansen and Dahl [29] grammars method to our theory.\nDefinition 6 (Abductive grammar). An abductive grammar \u0393 is a 6-tuple \u3008N,T, IC,KB,R, S\u3009 where\n- N are nonterminal symbols in immutable part (KBI).\n- T is a set of terminal symbols in updatable part (KBU). - IC is the integrity constraint to Horn knowledge base (KBIC). - KB is the Horn knowledge base which consists of KB = KBI\u222aKBU\u222aKBIC. - R is a set of rules, R \u2286 KB. - S is the revision of literals (atoms), called the start symbol.\nDefinition 7 (Constraint system). A constraint system for a abduction is a pair \u3008KBAb,KBBG\u3009, where KBAb(\u2206) is a set of propositions (abducibles) and KBBG background Horn knowledge base.\nNotations: From grammar point, KBBG is set all Horn formulae from R and KBAb is set of abducibles from T.\nDefinition 8 (Minimal abductive explanation). Let KB be a Horn knowledge base and \u03b1 an observation to be explained. Then, for a set of abducibles (KBAb), \u2206 is said to be an abductive explanation wrt KBBG iff KBBG\u222a\u2206 \u22a2 \u03b1. \u2206 is said to be minimal wrt KBBG iff no proper subset of \u2206 is an abductive explanation for \u03b1, i.e. \u2204\u2206 \u2032 s.t. KBBG \u222a\u2206 \u2032 \u22a2 \u03b1.\nSince an incision function is adding and removing only updatable elements from each member of the kernel set, to compute a generalized revision of \u03b1 from KB, we need to compute only the abduction in every \u03b1-kernel of KB. So, it is now necessary to characterize precisely the abducibles present in every \u03b1-kernel of KB. The notion of minimal abductive explanation is not enough to capture this, and we introduce locally minimal and KB-closed abductive explanations.\nDefinition 9 (Local minimal abductive explanations). Let KBBG \u2032\nbe a smallest subset of KBBG, s.t \u2206 is a minimal abductive explanation of \u03b1 wrt KBBG \u2032 (for some \u2206). Then \u2206 is called local minimal for \u03b1 wrt KBBG.\nDefinition 10 (Constraint abduction system). A constrained abductive grammar is a pair \u3008\u0393,C\u3009, where \u0393 is an abductive grammar and C a constraint system for abduction, \u0393=\u3008N,T,R, S\u3009 and C=\u3008KBBG,KBAb, IC\u3009.\nGiven a constrained abductive grammar \u3008\u0393,C\u3009 as above, the constrained abductive recognition problem for \u03c4 \u2208 T \u2217 is the problem of finding an admissible and denial knowledge base from KBAb and such that \u03c4 \u2208 LP (\u0393KBAb) where LP (\u0393KBAb) is propositional language over abducibles in \u0393 , where \u0393KBAb = \u3008N,T,KBBG \u222aKBAb, R, S\u3009. In this case, KBAb is called a constrained (abductive) system of \u03c4 . Such that KBAb is minimal whenever no proper subset of it is an in \u03c4 given \u3008\u0393,C\u3009.\nLet KBAb \u2208 ({\u2206+, \u2206\u2212}). Here \u2206+ refers to admission Horn knowledge base (positive atoms) and \u2206\u2212 refers to denial Horn knowledge base(negative atoms) wrt given \u03b1. Then problem of abduction is to explain\u2206 with abducibles (KBAb), s.t. KBBG \u222a\u2206+ \u222a\u2206\u2212 \u22a2 \u03b1 and KBBG \u222a\u2206+ |= \u03b1\u222a\u2206\u2212 are both consistent with IC.\nTheorem 1. Consider a constrained abductive grammar AG = \u3008\u0393,C\u3009 with \u0393 = \u3008N,T,KB,R, S\u3009 and C = \u3008KBBG,KBAb, IC\u3009. Construct a abductive grammar \u2206(AG) =\u3008N,T,KBBG, R, S\u3009 by having, for any (\u2206+) (or(\u2206\u2212) from KBAb, the set of acceptable results for accommodate(\u03b1,KBBG \u2208 \u2206+) being of the form (KBAb\\\u2206+) where (\u2206+ \u2208 KBAb \u2032\n). \u2206+ is a locally minimal set of atoms (literals) KBBG \u222a \u2206+ and KBBG \u222a \u2206+ |= \u03b1 is consistent with IC; if no such (\u2206\u2212) exists (like denial (\u2206\u2212) being of the form (KBAb\\\u2206\u2212). \u2206\u2212 is a locally minimal set of atoms (literals) KBBG \u222a \u2206\u2212 and KBBG \u222a \u2206\u2212 |= \u03b1 is consistent with IC), otherwise accommodate (\u03b1,KBBG \u2208 \u2206\u2212) is not possible.\nNow, we need to connect the grammar system \u0393 to the Horn knowledge base KB, such that KBI \u222aKBU \u222a KBIC = KBBG \u222aKBAb \u222a IC holds. The connection between locally minimal abductive explanation for \u03b1 wrt KBI and \u03b1-kernel of KB, which is shown by the following lemma immediately follows from their respective definitions.\nLemma 1.\n1. Let KB be a Horn knowledge base and \u03b1 a Horn clause s.t. 0 \u00ac\u03b1. Let \u2206+ and \u2206\u2212 be a KB-closed locally minimal abductive explanation for \u03b1 wrt KBI. Then, there exists a \u03b1-kernel X of KB s.t. X \u2229KBU = \u2206+ \u222a\u2206\u2212. 2. Let KB be a Horn knowledge base and \u03b1 a Horn clause s.t. 0 \u00ac\u03b1. Let X be a \u03b1-kernel of KB and \u2206+ \u222a \u2206\u2212 = X \u2229 KBU . Then, \u2206+ and \u2206\u2212 are KB -locally minimal abductive explanations for \u03b1 wrt KBI.\nAn immediate consequence of the above lemma 4.1 is that it is enough to compute all the KB-locally minimal abductive explanations for \u03b1 wrt KBI in order to revise \u03b1 from KB. Thus, a well-known abductive procedure to compute an abductive explanation for \u03b1 wrt KBI could be used."}, {"heading": "3.2 Generalized revision algorithm", "text": "The problem of knowledge base revision is concerned with determining how a request to change can be appropriately translated into one or more atoms or literals. In this section we develop a new generalized revision algorithm. Note that it is enough to compute all the KB-locally minimal abduction explanations for \u03b1 wrt KBI \u222aKBU \u222aKBIC . If \u03b1 is consistent with KB then a well-known abductive procedure for compute an abductive explanation for \u03b1 wrt KBI could be used to compute kernel revision.\nTheorem 2. Let KB be a Horn knowledge base and \u03b1 is formula.\n1. If Algorithm 1 produced KB\u2019as a result of revising \u03b1 from KB, then KB\u2019 satisfies all the rationality postulates (KB*1) to (KB*6) and (KB*7.3). 2. Suppose KB\u2032\u2032 satisfies all these rationality postulates for revising \u03b1 from KB, then KB\u2032\u2032 can be produced by Algorithm 1.\nAlgorithm 1 Generalized revision algorithm Input : A Horn knowledge base KB = KBI \u222aKBU \u222aKBIC\nand a Horn clause \u03b1 to be revised. Output: A new Horn knowledge base KB\u2032 = KBI \u222aKB\u2217U \u222aKBIC ,\ns.t. KB\u2032is a generalized revision \u03b1 to KB. Procedure KB(KB,\u03b1)\nbegin 1. Let V:= {c \u2208 KBIC | KBI \u222aKBIC inconsistent with \u03b1 wrt c}\nP := N := \u2205 and KB\u2032 = KB 2. While (V , \u2205)\nselect a subset V \u2032 \u2286 V For each v \u2208 V \u2032, select a literal to be\nremove (add to N) or a literal to be added (add to P) wrt KB Let KB := KR(KB,P,N)\nLet V:= {c \u2208 KBIC | KBI inconsistent with \u03b1 wrt c} return\n3. Produce a new Horn knowledge base KB\u2032\nend.\nAlgorithm 2 Procedure KR(KB,\u2206+, \u2206\u2212)\nbegin 1. Let P := {e \u2208 \u2206+| KBI 6|= e} and N := {e \u2208 \u2206\n\u2212| KBI |= e} 2. While (P , \u2205) or (N , \u2205)\nselect a subset P \u2032 \u2286 P or N \u2032 \u2286 N Construct a set S1 = {X | X is a KB-closed locally minimal abductive explanation wrt P} Construct a set S2 = {X | X is a KB-closed locally\nminimal abductive explanation wrt N } Determine hitting set \u03c3(S1) and \u03c3(S2)\nIf ((N \u2032 = \u2205) and (P \u2032 , \u2205)) Produce KB\u2032 = KBI \u222a {(KBU \u222a \u03c3(S1)}\nelse Produce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2) \u222a \u03c3(S1)}\nend if If ((N \u2032 , \u2205) and (P \u2032 = \u2205))\nProduce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2)} else Produce KB\u2032 = KBI \u222a {(KBU\\\u03c3(S2) \u222a \u03c3(S1)} end if Let P := {e \u2208 \u2206+| KBI 6|= e} and N := {e \u2208 \u2206\u2212| KBI |= e}\n3. return KB\u2032\nend."}, {"heading": "4 Deductive database", "text": "A Deductive database DDB consists of three parts: an intensional database IDB (KBI), a set of definite program clauses, extensional database EDB (KBU ), a set of ground facts; and integrity constraints IC. The intuitive meaning of DDB is provided by the Least Herbrand model semantics and all the inferences are carried out through SLD-derivation. All the predicates that are defined in IDB are referred to as view predicates and those defined in EDB are referred to as base predicates. Extending this notion, an atom with a view predicate is said to be a view atom,and similarly an atom with base predicate is a base atom. Further we assume that IDB does not contain any unit clauses and no predicate defined in a given DDB is both view and base.\nTwo kinds of view updates can be carried out on a DDB: An atom, that does not currently follow from DDB, can be inserted, or an atom, that currently follows from DDB can be deleted. When an atom A is to be updated, the view update problem is to insert or delete only some relevant EDB facts, so that the modified EDB together with IDB will satisfy the updating of A to DDB.\nNote that a DDB can be considered as a knowledge base to be revised. The IDB is the immutable part of the knowledge base, while the EDB forms the updatable part. In general, it is assumed that the language underlying a DDB is fixed and the semantics of DDB is the least Herbrand model over this fixed language. We assume that there are no function symbols implying that the Herbrand Base is finite. Therefore, the IDB is practically a shorthand of its ground instantiation1 written as IDBG. In the sequel, technically we mean IDBG when we refer simply to IDB. Thus, a DDB represents a knowledge base where the immutable part is given by IDBG and updatable part is the EDB. Hence, the rationality postulates (KB*1)-(KB*6) and (KB*7.3) provide an axiomatic characterization for update (insert and delete) a view atom A from a definite database DDB.\nLogic provides a conceptual level for understanding the meaning of relational databases. Hence, the rationality postulates (KB*1)-(KB*6) and (KB*7.3) can provide an axiomatic characterization for view updates in relational databases too. A relational database together with its view definitions can be represented by a deductive database (EDB representing tuples in the database and IDB representing the view definitions), and so the same algorithm can be used to delete view extensions from relational deductive databases.\nAn update request U = B, where B is a set of base facts, is not true in KB. Then, we need to find a transaction T = Tins \u222a Tdel, where Tins(\u2206i) (resp. Tdel(\u2206j)) is the set of facts, such that U is true in DDB\n\u2032 = ((EDB \u2212 Tdel \u222a Tins)\u222a IDB \u222a IC). Since we consider stratifiable (definite) deductive databases, SLD-tree can be used to compute the required abductive explanations. The idea is to get all EDB facts used in a SLD-derivation of A wrt DDB, and construct that as an abductive explanation for A wrt IDBG.\n1 a ground instantiation of a definite program P is the set of clauses obtained by substituting terms in the Herbrand Universe for variables in P in all possible ways\nAll solutions translate [85] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request. Further, a stratifiable (definite) deductive database can be considered as a knowledge base, and thus rationality postulates and insertion algorithm of the previous section can be applied for view updates in database."}, {"heading": "5 View update method", "text": "View updating [11] aims at determining one or more base relation updates such that all given update requests with respect to derived relations are satisfied after the base updates have been successfully applied.\nDefinition 11 (View update). Let DDB = \u3008IDB,EDB, IC\u3009 be a stratifiable (definite) deductive database DDB(D). A VU request \u03bdD is a pair \u3008\u03bd + D, \u03bd \u2212\nD\u3009 where \u03bd+D and \u03bd \u2212\nD are sets of ground atoms representing the facts to be inserted into D or deleted from D, resp., such that pred(\u03bd+D \u222a \u03bd \u2212 D) \u2286 pred(IDB), \u03bd + D \u2229 \u03bd \u2212\nD = \u2205, \u03bd+D \u2229 PMD = \u2205 and \u03bd \u2212 D \u2286 PMD.\nNote that we consider again true view updates only, i.e., ground atoms which are presently not derivable for atoms to be inserted, or are derivable for atoms to be deleted, respectively. A method for view updating determines sets of alternative updates satisfying a given request. A set of updates leaving the given database consistent after its execution is called VU realization.\nDefinition 12 (Induced update). Let DDB = \u3008IDB,EDB, IC\u3009 be a stratifiable (definite) deductive database and DDB = \u03bdD a VU request. A VU realization is a base update uD which leads to an induced update uD\u2192D\u2032 from D to D\u2032 such that \u03bd+D \u2286 PMD\u2032 and \u03bd \u2212 D \u2229 PMD\u2032 = \u2205.\nThere may be infinitely many realizations and even realizations of infinite size which satisfy a given VU request. A breadth-first search (BFS) is employed for determining a set of minimal realizations \u03c4D = {u1D, . . . , u i D}. Any u i D is minimal in the sense that none of its updates can be removed without losing the property of being a realization for \u03bdD.\nIn [9,8] a variant of clausal normal form tableaux called \u201dhyper tableaux\u201d is introduced. Since the hyper tableaux calculus constitutes the basis for our view update algorithm, Clauses, i.e., multisets of literals, are usually written as the disjunction A1 \u2228A2 \u2228 \u00b7 \u00b7 \u00b7 \u2228Am \u2228 not B1 \u2228 not B2 \u00b7 \u00b7 \u00b7 \u2228 not Bn (M \u2265 0, n \u2265 0). The literals A1, A2, . . . Am (resp. B1, B2, . . . , Bn) are called the head (resp. body) of a clause. With L we denote the complement of a literal L. Two literals L and K are complementary if L = K\nFrom now onD always denotes a finite ground clause set, also called database, and \u03a3 denotes its signature, i.e., the set of all predicate symbols occurring in it. We consider finite ordered trees T where the nodes, except the root node, are labeled with literals. In the following we will represent a branch b in T by the sequence b = L1, L2, . . . , Ln (n \u2265 0) of its literal labels, where L1 labels an\nimmediate successor of the root node, and Ln labels the leaf of b. The branch b is called regular iff Li , Lj for 1 \u2264 i, j \u2264 n and i , j, otherwise it is called irregular. The tree T is regular iff every of its branches is regular, otherwise it is irregular. The set of branch literals of b is lit(b) = {L1, L2, . . . , Ln}. For brevity, we will write expressions like A \u2208 b instead of A \u2208 lit(b). In order to memorize the fact that a branch contains a contradiction, we allow to label a branch as either open or closed. A tableau is closed if each of its branches is closed, otherwise it is open.\nDefinition 13 (Hyper Tableau). A literal set is called inconsistent iff it contains a pair of complementary literals, otherwise it is called consistent. Hyper tableaux for D are inductively defined as follows:\nInitialization step: The empty tree, consisting of the root node only, is a hyper tableau for D. Its single branch is marked as \u201dopen\u201d.\nHyper extension step: If (1) T is an open hyper tableau for D with open branch b, and (2) C = A1\u2228A2\u2228\u00b7 \u00b7 \u00b7\u2228Am \u2190 B1\u2227B2 \u00b7 \u00b7 \u00b7\u2227Bn is a clause fromD (n \u2265 0,m \u2265 0), called extending clause in this context, and (3) {B1, B2, . . . , Bn} \u2286 b (equivalently, we say that C is applicable to b)then the tree T is a hyper tableau for D, where T is obtained from T by extension of b by C: replace b in T by the new branches\n(b, A1), (b, A2), . . . , (b, Am), (b,\u00acB1), (b,\u00acB2), . . . , (b,\u00acBn)\nand then mark every inconsistent new branch as \u201dclosed\u201d, and the other new branches as \u201dopen\u201d.\nThe applicability condition of an extension expresses that all body literals have to be satisfied by the branch to be extended. From now on, we consider only regular hyper tableaux. This restriction guarantees that for finite clause sets no branch can be extended infinitely often. Hence, in particular, no open finished branch can be extended any further. This fact will be made use of below occasionally. Notice as an immediate consequence of the above definition that open branches never contain negative literals."}, {"heading": "5.1 View update algorithm", "text": "The key idea of the algorithm presented in this paper is to transform the given database along with the view update request into a disjunctive logic program and apply known disjunctive techniques to solve the original view update problem. The intuition behind the transformation is to obtain a disjunctive logic program in such a way that each (minimal) model of this transformed program represent a way to update the given view atom. We present two variants of our algorithm. The one that is discussed in this section employs a trivial transformation procedure but has to look for minimal models; and another performs a costly transformation, but dispenses with the requirement of computing the minimal models."}, {"heading": "5.2 Minimality test", "text": "We start presenting an algorithm for stratifiable (definite) deductive databases by first defining precisely how the given database is transformed into a disjunctive logic program for the view deletion process [8] (successful branch - see in Algorithms 3 and 4 via Hyper Tableau).\nDefinition 14 (IDB Transformation). Given an IDB and a set of ground atoms S, the transformation of IDB wrt S is obtained by translating each clause C \u2208 IDB as follows: Every atom A in the body (resp. head) of C that is also in S is moved to the head (resp. body) as \u00acA.\nNote 1. If IDB is a stratifiable deductive database then the transformation introduced above is not necessary.\nDefinition 15 (IDB\u2217 Transformation). Let IDB\u222aEDB be a given database. Let S0 = EDB \u222a{A | A is a ground IDB atom}. Then, IDB\u2217 is defined as the transformation of IDB wrt S0.\nNote 2. Note that IDB\u2217 is in general a disjunctive logic program. The negative literals (\u00acA) appearing in the clauses are intuitively interpreted as deletion of the corresponding atom (A) from the database. Technically, a literal \u00acA is to be read as a positive atom, by taking the \u00ac-sign as part of the predicate symbol. To be more precise, we treat \u00acA as an atom wrt IDB\u2217, but as a negative literal wrt IDB.\nNote that there are no facts in IDB\u2217. So when we add a delete request such as \u00acA to this, the added request is the only fact and any bottom-up reasoning strategy is fully focused on the goal (here the delete request)\nDefinition 16 (Update Tableaux Hitting Set). An update tableau for a database IDB \u222a EDB and delete request \u00acA is a hyper tableau T for IDB\u2217 \u222a {\u00acA\u2190} such that every open branch is finished. For every open finished branch b in T we define the hitting set (of b in T ) as HS(b) = {A \u2208 EDB|\u00acA \u2208 b}.\nDefinition 17 (Minimality test). Let T be an update tableau for IDB\u222aEDB and delete request \u00acA. We say that open finished branch b in T satisfies the strong minimality test iff \u2200s \u2208 HS(b) : IDB \u222a EDB\\HS(b) \u222a {s} \u22a2 A.\nDefinition 18 (Update Tableau satisfying strong minimality). An update tableau for given IDB \u222a EDB and delete request \u00acA is transformed into an update tableau satisfying strong minimality by marking every open finished branch as closed which does not satisfy strong minimality.\nNext step is view insertion process [11] (For unsuccessful branches - see in Algorithms 3 and 4 via magic set).\nDefinition 19 (IDB\u2217\u2217 Transformation). Let IDB\u222aEDB be a given database. Let S1 = EDB \u222a {A | A is a ground IDB atom}. Then, IDB\n\u2217\u2217 is defined as the transformation of IDB wrt S1.\nNote 3. Note that IDB is in general a (stratifiable) disjunctive logic program. The positive literals (A) appearing in the clauses are intuitively interpreted as an insertion of the corresponding atom (A) from the database.\nDefinition 20 (Update magic Hitting Set). An update magic set rule for a database IDB \u222a EDB and insertion request A is a magic set rule M for IDB\u2217 \u222a {A\u2190} such that every close branch is finished. For every close finished branch b in M we define the magic set rule (of b in M) as HS(b) = {A \u2208 EDB|A \u2208 b}.\nDefinition 21 (Minimality test). Let M be an update magic set rule for IDB \u222a EDB and insert request A. We say that close finished branch b in M satisfies the strong minimality test iff \u2200s \u2208 HS(b) : IDB \u222aEDB\\HS(b)\u222a {s} \u22a2 \u00acA.\nDefinition 22 (Update magic set rule satisfying strong minimality). An update magic set rule for given IDB\u222aEDB and insert request A is transformed into an update magic set rule satisfying strong minimality by marking every close finished branch as open which does not satisfy strong minimality.\nThis means that every minimal model (minimal wrt the base atoms) of IDB\u2217 \u222a {\u00acA} provides a minimal hitting set for deleting the ground view atom A. Similarly, IDB\u2217\u222a{A} provides a minimal hitting set for inserting the ground view atom A. Now we are in a position to formally present our algorithm. Given a database and a view atom to be updated, we first transform the database into a definite disjunctive logic program and use hyper tableaux calculus to generate models of this transformed program for deletion of an atom. Second, magic set rule is used to generate models of this transformed program for insertion of an atom. Models that do not represent rational update are filtered out using the strong minimality test. This is formalized in Algorithm 3.\nTo show the rationality of this approach, we study how this is related to the previous approach presented in the last section, i.e. generating explanations and computing hitting sets of these explanations. To better understand the relationship it is imperative to study where the explanations are in the hyper tableau approach and magic set rule. We first define the notion of EDB -cut and then view update seeds.\nDefinition 23 (EDB-Cut). Let T be update tableau with open branches b1, b2, . . . , bn. A set S = {A1, A2, . . . , An} \u2286 EDB is said to be EDB-cut of T iff \u00acAi \u2208 bi (Ai \u2208 bi), for 1 \u2264 i \u2264 n.\nDefinition 24 (EDB seeds). Let M be an update seeds with close branches b1, b2, . . . , bn. A set S = {A1, A2, . . . , An} \u2286 EDB is said to be a EDB-seeds of M iff EDB seeds vu seeds(\u03bdD) with respect to \u03bdD is defined as follows:\nvu seeds(\u03bdD) := { \u2207\u03c0p (c1, . . . , cn)|p(c1, . . . , cn) \u2208 \u03bd \u03c0 D and \u03c0 \u2208 {+,\u2212} } .\nAlgorithm 3 View update algorithm based on minimality test Input : A stratifiable (definite) deductive database DDB = IDB \u222a EDB \u222a IC\nan literals A Output: A new stratifiable (definite) database IDB \u222a EDB\u2032 \u222a IC begin\n1. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c } While (V , \u2205) 2. Construct a complete SLD-tree for \u2190 A wrt DDB. 3. For every successful branch i:construct \u2206i = {D | D \u2208 EDB}\nand D is used as an input clause in branch i. Construct a branch i of an update tableau satisfying minimality\nfor IDB \u222a EDB and delete request \u00acA. Produce IDB \u222a EDB\\HS(i) as a result\n4. For every unsuccessful branch j:construct \u2206j = {D | D \u2208 EDB} and D is used as an input clause in branch j.\nConstruct a branch j of an update magic set rule satisfying minimality for IDB \u222a EDB and insert request A.\nProduce IDB \u222aEDB\\HS(j) as a result Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c }\nreturn 5. Produce DDB as the result.\nend.\nLemma 2. Let T be an update tableau for IDB \u222aEDB and update request A. Similarly, for M be an update magic set rule. Let S be the set of all EDBclosed minimal abductive explanations for A wrt. IDB. Let S\u2032 be the set of all EDB-cuts of T and EDB-seeds of M . Then the following hold\n\u2022 S \u2286 S\u2032.\n\u2022 \u2200\u2206\u2032 \u2208 S\u2032 : \u2203\u2206 \u2208 Ss.t.\u2206 \u2286 \u2206\u2032.\nThe above lemma precisely characterizes what explanations are generated by an update tableau. It is obvious then that a branch cuts through all the explanations and constitutes a hitting set for all the generated explanations. This is formalized below.\nLemma 3. Let S and S\u2032 be sets of sets s.t. S \u2286 S\u2032 and every member of S\u2032\\S contains an element of S. Then, a set H is a minimal hitting set for S iff it is a minimal hitting set for S\u2032.\nLemma 4. Let T be an update tableau for IDB \u222a EDB and update request A that satisfies the strong minimality test. Similarly, for M be an update magic set rule. Then, for every open (close) finished branch b in T , HS(b) (M , HS(b)) is a minimal hitting set of all the abductive explanations of A.\nSo, Algorithms 3 generate a minimal hitting set (in polynomial space) of all EDB-closed locally minimal abductive explanations of the view atom to be deleted. From the belief dynamics results recalled in section 3, it immediately follows that Algorithms 5 and 6 are rational, and satisfy the strong relevance postulate (KB-7.1).\nTheorem 3. Algorithms 3 is a rational, in the sense that they satisfy all the rationality postulates (KB*1)-(KB*6) and the strong relevance postulate (KB*7.1). Further, any update that satisfies these postulates can be computed by these algorithms."}, {"heading": "5.3 Materialized view", "text": "In many cases, the view to be updates is materialized, i.e., the least Herbrand Model is computed and kept, for efficient query answering. In such a situation, rational hitting sets can be computed without performing any minimality test. The idea is to transform the given IDB wrt the materialized view.\nDefinition 25 (IDB+ Transformation). Let IDB\u222aEDB be a given database. Let S be the Least Herbrand Model of this database. Then, IDB+ is defined as the transformation of IDB wrt S.\nNote 4. If IDB is a stratifiable deductive database then the transformation introduced above is not necessary.\nDefinition 26 (Update Tableau based on Materialized view). An update tableau based on materialized view for a database IDB\u222aEDB and delete request \u00acA is a hyper tableau T for IDB+ \u222a {\u00acA \u2190} such that every open branch is finished.\nDefinition 27 (IDB\u2212 Transformation). Let IDB\u222aEDB be a given database. Let S1 be the Least Herbrand Model of this database. Then, IDB\n\u2212 is defined as the transformation of IDB wrt S1.\nDefinition 28 (Update magic set rule based on Materialized view). An update magic set rule based on materialized view for a database IDB \u222a EDB and insert request A is a magic set M for IDB+ \u222a {A\u2190} such that every close branch is finished.\nNow the claim is that every model of IDB+ \u222a {\u00acA \u2190} (A \u2190) constitutes a rational hitting set for the deletion and insertion of the ground view atom A. So, the algorithm works as follows: Given a database and a view update request, we first transform the database wrt its Least Herbrand Model (computation of the Least Herbrand Model can be done as a offline preprocessing step. Note that it serves as materialized view for efficient query answering). Then the hyper tableaux calculus (magic set rule) is used to compute models of this transformed program. Each model represents a rational way of accomplishing the given view update request. This is formalized in Algorithms 4.\nThis approach for view update may not satisfy (KB*7.1) in general. But, as shown in the sequel, conformation to(KB*6.3) is guaranteed and thus this approach results in rational update.\nAlgorithm 4 View update algorithm based on Materialized view Input : A stratifiable (definite) deductive database DDB = IDB \u222a EDB \u222a IC\nan literals A Output: A new stratifiable (definite) database IDB \u222a EDB\u2032 \u222a IC begin\n1. Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c } While (V , \u2205) 2. Construct a complete SLD-tree for \u2190 A wrt DDB. 3. For every successful branch i:construct \u2206i = {D | D \u2208 EDB}\nand D is used as an input clause in branch i. Construct a branch i of an update tableau based on view\nfor IDB \u222a EDB and delete request \u00acA. Produce IDB \u222a EDB\\HS(i) as a result\n4. For every unsuccessful branch j:construct \u2206j = {D | D \u2208 EDB} and D is used as an input clause in branch j.\nConstruct a branch j of an update magic set rule based on view for IDB \u222a EDB and insert request A.\nProduce IDB \u222aEDB\\HS(j) as a result Let V := {c \u2208 IC | IDB \u222a IC inconsistent with A wrt c }\nreturn 5. Produce DDB as the result.\nend.\nLemma 5. Let T be an update tableau based on materialized view for IDB \u222a EDB and delete request \u00acA (A), Similarly, for M be an update magic set rule. Let S be the set of all EDB-closed locally minimal abductive explanations for A wrt IDB. Let S\u2032 be the set of all EDB-cuts of T and EDB-seeds of M . Then, the following hold:\n\u2022 S \u2286 S\u2032. \u2022 \u2200\u2206\u2032 \u2208 S\u2032 : \u2203\u2206 \u2208 S s.t. \u2206 \u2286 \u2206\u2032. \u2022 \u2200\u2206\u2032 \u2208 S\u2032 : \u2206\u2032 \u2286 \u22c3 S.\nLemma 6. Let S and S\u2032 be sets of sets s.t. S \u2208 S\u2032 and for every member X of S\u2032\\S: X contains a member of S and X is contained in \u22c3\nS. Then, a set H is a hitting set for S iff it is a hitting set for S\u2032.\nLemma 7. Let T and M be defined as in Lemma 5. Then HS(b) is a rational hitting set for A, for every open finished branch b in T (close finished branch b in M).\nTheorem 4. Algorithms 4 is a rational, in the sense that they satisfy all the rationality postulates (KB*1) to (KB*6) and (KB*7.3)."}, {"heading": "6 A Comparative Study of Integrity Constraints and View Update", "text": "During the process of updating a database, two interrelated problems could arise. On one hand, when an update is applied to the database, integrity constraints could become inconsistent with request, then stop the process. On the other hand, when an update request consist on updating some derived predicate, a view updating mechanism must be applied to translate the update request into correct updates on the underlying base facts. Our work is not focusing on the integrity constraint maintenance approach. In this section, we extend Mayol and Teniente\u2019s [83] survey for view updating and integrity constraint.\nThe main aspects that must be taken into account during the process of view updating and integrity constraint [48] enforcement are the following: the problem addressed, the considered database schema, the allowed update requests, the used technique, update change and the obtained solutions. These six aspects provide the basic dimensions to be taken into account. We explain each dimension in this section.\nProblem Addressed\n(Type) - What kind of program to be used (stratified(S), Horn clause(H), Disjunctive database(D), Normal Logic program(N) and Other (O)). (View Update) - Whether they are able to deal with view updating or not (indicated by Yes or No in the second column of Table 1). (integrity-constraint Enforcement) - Whether they incorporate an integrity constraint checking or an integrity constraint maintenance approach (indicated by check or maintain in the third column). (Run/Comp) - Whether the method follows a run-time(transaction) or a compiletime approach (indicated by Run or Compile in the fourth column).\nDatabase Schema Considered\n(Definition Language) - The language mostly used is logic, although some methods use a relational language and also uses an object-oriented. (The DB Schema Contains Views) - All methods that deal with view updating need views to be defined in the database schema. Some of other method allow to define views. (Restrictions Imposed on the Integrity Constraints) - Some proposals impose certain restrictions on the kind of integrity constraints that can be defined and, thus, handled by their methods. (Static vs Dynamic Integrity Constraints) - Integrity constraints may be either static, and impose restrictions involving only a certain state of the database, or dynamic.\nUpdate Request Allowed\n(Multiple Update Request) - An update request is multiple if it contains several updates to be applied together to the database.\n(Update Operators) - Traditionally, three different basic update operators are distinguished: insertion (\u03b9), deletion (\u03b4) and modification (\u03c7). Modification can always be simulated by a deletion followed by an insertion.\nUpdate Processing Mechanism\n(Applied Technique) - The techniques applied by these methods can be classified according to four different kinds of procedures, unfolding, SLD, active and predefined programs, respectively. (Taking Base Facts into Account - Base facts can either be taken into account or not during update processing. (User Participation) - User participation during update processing or not.\nUpdate Changing Mechanism\n(Type of modification) - Changing table by singleton like atom (S), sets of each types of modification(SS) and group of changes(G). (Changing Base Fact) - Base fact can be changed either using principle of minimal change or complete change (maximal change). (Changing View Definition) - Whether update process view definition is changed or not.\nObtained Solution\n(Our Axiom follow) - When update process done, we are comparing our axiomatized method and which relevance policy holds ((KB*1) to (KB*6),(KB*7.1),(KB*7.2) and (KB*7.3) is enumerated 1 to 9) (Soundness) - A method is correct if it only obtains solutions that satisfy the requested update. (Completeness) - A method is complete if it is able to obtain all solutions that satisfy a given update request.\nResults of each method according to these features are summarized in Appendix Table 1."}, {"heading": "7 Related Works", "text": "We begin by recalling previous work on view deletion. Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change. Similar to our approach, he focused on set of formulae or sentences in knowledge base revision for view update wrt. insertion and deletion and formulae are considered at the same level. Chandrabose proposed different ways to change knowledge base via only database deletion, devising particular postulate which is shown to be necessary and sufficient for such an update process.\nOur Horn knowledge base consists of two parts, immutable part and updatable part , but focus is on principle of minimal change. There are more related works on that topic. Eiter [42], Langlois[67], and Delgrande [37] are focusing\non Horn revision with different perspectives like prime implication, logical closure and belief level. Segerberg [98] defined new modeling for belief revision in terms of irrevocability on prioritized revision. Hansson [54], constructed five types of non-prioritized belief revision. Makinson [77] developed dialogue form of revision AGM. Papini[89] defined a new version of knowledge base revision. Here, we consider immutable part as a Horn clause and updatable part as an atom(literals).\nWe are bridging gap between philosophical work, paying little attention to computational aspects of database work. In such a case, Hansson\u2019s[54] kernel change is related with abductive method. Aliseda\u2019s [4] book on abductive reasoning is one of the motivation keys. Christiansen\u2019s [29] work on dynamics of abductive logic grammars exactly fits our minimal change (insertion and deletion). Wrobel\u2019s [102] definition of first order theory revision was helpful to frame our algorithm.\nOn other hand, we are dealing with view update problem. Keller\u2019s [62] thesis is motivation for view update problem. There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]). More similar to our work is paper presented by Bessant et al. [16] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications. Laurent et al.[68] parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.\nFurthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]). Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).\nThe significance of our work can be summarized in the following:\n- We have defined new way of insertion and deletion of an atom(literals) as per norm of principle of minimal change. - We have proposed new generalized revision algorithm for knowledge base dynamics, interesting connections with kernel change and abduction procedure. - We have written new view update algorithm for DDB, and we provided stratifiable (definite) deductive database, using our axiomatic method based on Hyper tableaux and magic sets. - Finally, we presented current Comparative Study of view update algorithms."}, {"heading": "8 Conclusion and remarks", "text": "The main contribution of this research is to provide a link between theory of belief dynamics and concrete applications such as view updates in databases. We argued for generalization of belief dynamics theory in two respects: to handle certain part of knowledge as immutable; and dropping the requirement that belief state be deductively closed. The intended generalization was achieved by\nintroducing the concept of knowledge base dynamics and generalized contraction for the same. Further, we also studied the relationship between knowledge base dynamics and abduction resulting in a generalized algorithm for revision based on abductive procedures. We also successfully demonstrated how knowledge base dynamics can provide an axiomatic characterization for updating an atom(literals) to a stratifiable (definite) deductive database.\nIn bridging the gap between belief dynamics and view updates, we have observed that a balance has to be achieved between computational efficiency and rationality. While rationally attractive notions of generalized revision prove to be computationally inefficient, the rationality behind efficient algorithms based on incomplete trees is not clear at all. From the belief dynamics point of view, we may have to sacrifice some postulates, vacuity for example, to gain computational efficiency. Further weakening of relevance has to be explored, to provide declarative semantics for algorithms based on incomplete trees.\nOn the other hand, from the database side, we should explore various ways of optimizing the algorithms that would comply with the proposed declarative semantics. We believe that partial deduction and loop detection techniques, will play an important role in optimizing algorithms of the previous section. Note that, loop detection could be carried out during partial deduction, and complete SLD-trees can be effectively constructed wrt a partial deduction (with loop check) of a database, rather than wrt database itself. Moreover, we would anyway need a partial deduction for optimization of query evaluation.\nWe have presented two variants of an algorithm for updating a view atom to a definite database. The key idea of this approach is to transform the given database into a disjunctive logic program in such a way that updates can be read off from the models of this transformed program. One variant based on materialized views is of polynomial time complexity. Moreover, we have also shown that this algorithm is rational in the sense that it satisfies the rationality postulates that are justified from philosophical angle.\nIn the second variant, where materialized view is used for the transformation, after generating a hitting set and removing corresponding EDB atoms, we easily move to the new materialized view. An obvious way is to recompute the view from scratch using the new EDB (i.e. compute the Least Herbrand Model of the new updated database from scratch) but it is certainly interesting to look for more efficient methods. In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].\nThough we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]). It would also be interesting to study how results using soft stratification [11] with belief dynamics, especially the relational approach, could be applied in real world problems. Still, a lot of developments are possible, for improving existing operators or for defining new classes of change operators. As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [47]. The revision and update are more challenging in logical view update prob-\nlem(database theory), so we can extend the theory to combine results similar to Konieczny\u2019s [64] and Nayak\u2019s [87].\nAppendix\nProof of Theorem 1. Sound and Completeness are trivially to shown from the definition.\nProof of Lemma 1.\n1. The fact that 0 \u00ac\u03b1 and there exists a KB - closed locally minimal abductive explanation for \u03b1 wrt KBI , it is clear that there exists at least one \u03b1kernel of KB. Suppose \u2206 (\u2206 \u2208 \u2206+ \u222a\u2206\u2212) is empty (i.e., KBI \u22a2 \u00ac\u03b1), then the required result follows immediately. If not, since \u2206 is a locally minimal abductive explanation, there exists a minimal subset KB\u2032I \u2286 KBI , s.t. \u2206 is minimal abductive explanation of \u03b1 wrt KB\u2032I . Since, \u2206 is KB-closed, it is not difficult to see that KB\u2032I \u222a\u2206\n+ \u222a\u2206\u2212 is a \u03b1 - kernel of KB. 2. Since X is a \u03b1 - kernel of KB and \u2206 is the set of all abducibles in X, it follows\nthat \u2206+ \u222a \u2206\u2212 is a minimal abductive explanation of \u2206 wrt X\\\u2206\u2212 \u222a \u2206+. It is obvious that \u2206+ \u222a\u2206\u2212 is KB- closed, and so \u2206 is a KB-closed locally minimal abductive explanation for \u03b1 wrt KBI .\nProof of Theorem 2. Sound and Completeness are trivially to shown from the Algorithm 1.\nProof of Lemma 2 and 5.\n1. Consider a \u2206(\u2206 \u2208 \u2206i \u222a\u2206j) \u2208 S. We need to show that \u2206 is generated by algorithm 3 at step 2. From lemma 1, it is clear that there exists a A-kernel X of DDBG s.t. X \u2229 EDB = \u2206j and X \u222a EDB = \u2206i. Since X \u22a2 A, there must exist a successful derivation for A using only the elements ofX as input clauses and similarly X 0 A. Consequently \u2206 must have been constructed at step 2. 2. Consider a \u2206\u2032((\u2206\u2032 \u2208 \u2206i \u222a\u2206j) \u2208 S\u2032. Let \u2206\u2032 be constructed from a successful(unsuccessful) branch i via \u2206i(\u2206j). Let X be the set of all input clauses used in the refutation i. Clearly X \u22a2 A(X 0 A). Further, there exists a minimal (wrt set-inclusion) subset Y of X that derives A (i.e. no proper subset of Y derives A). Let \u2206 = Y \u2229EDB (Y \u222aEDB). Since IDB does not(does) have any unit clauses, Y must contain some EDB facts, and so \u2206 is not empty (empty) and obviously \u2206 \u2286 \u2206\u2032. But, Y need not (need) be a A-kernel for IDBG since Y is not ground in general. But it stands for several A-kernels with the same (different) EDB facts \u2206 in them. Thus, from lemma 1, \u2206 is a DDB-closed locally minimal abductive explanation for A wrt IDBG and is contained in \u2206\u2032. 3. Since this proof easy to see materialized view update with minimal.\nProof of Lemma 3 and 6.\n1. (Only if part) Suppose H is a minimal hitting set for S. Since S \u2286 S\u2032 , it follows that H \u2286 \u22c3\nS\u2032 . Further, H hits every element of S\u2032 , which is evident from the fact that every element of S\u2032 contains an element of S. Hence H is a hitting set for S\u2032 . By the same arguments, it is not difficult to see that H is minimal for S\u2032 too.\n(If part) Given that H is a minimal hitting set for S\u2032 , we have to show that it is a minimal hitting set for S too. Assume that there is an element E \u2208 H that is not in \u22c3\nS. This means that E is selected from some Y \u2208 S\u2032\\S. But Y contains an element of S, say X . Since X is also a member of S\u2032 , one member of X must appear in H . This implies that two elements have been selected from Y and hence H is not minimal. This is a contradiction and hence H \u2286 \u22c3\nS. Since S \u2286 S\u2032 , it is clear that H hits every element in S, and so H is a hitting set for S. It remains to be shown that H is minimal. Assume the contrary, that a proper subset H \u2032 of H is a hitting set for S. Then from the proof of the only if part, it follows that H \u2032 is a hitting set for S\u2032 too, and contradicts the fact that H is a minimal hitting set for S\u2032 . Hence, H must be a minimal hitting set for S.\n2. (If part) Given that H is a hitting set for S\u2032 , we have to show that it is a hitting set for S too. First of all, observe that \u22c3 S = \u22c3\nS\u2032 , and so H \u2286 \u22c3\nS. Moreover, by definition, for every non-empty member X of S\u2032 , H\u2229X is not empty. Since S \u2286 S\u2032 , it follows that H is a hitting set for S too.\n(Only if part) Suppose H is a hitting set for S. As observed above, H \u2286 \u22c3\nS\u2032 . By definition, for every non-empty member X \u2208 S, X \u2229 H is not empty. Since every member of S\u2032 contains a member of S, it is clear that H hits every member of S\u2032 , and hence a hitting set for S\u2032 .\nProof of Lemma 4 and 7. Follows from the lemma 3,4 (minimal test) and 6,7 (materialized view) of [11]\nProof of Theorem 3. Follows from Lemma 3 and Theorem 2.\nProof of Theorem 4. Follows from Lemma 6 and Theorem 2."}, {"heading": "Acknowledgement", "text": "The author acknowledges the support of RWTH Aachen, where he is visiting scholar with an Erasmus Mundus External Cooperation Window India4EU by the European Commission when the paper was written. I would like to thanks Chandrabose Aravindan and Gerhard Lakemeyer both my Indian and Germany PhD supervisor, give encourage to write the paper.\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[50] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 SLDNF No No S Yes No 1-6,9 No Not proved\n[61] N Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF No No S Yes No \u2014 No No\n[65] S Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u2014 Yes No SS Yes Yes 1-6,7 Not Not proved proved [84] N No Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No 1-6,7 No No proved proved [51] S Yes Check Comp. Relation. No No Static Yes \u03b9 \u03b4 \u03c7 predef.\nYes No G Yes No \u2014 No No Maintain Run Logic Programs\n[39] N Yes Check Run Logic Yes No Static Yes \u03b9 \u03b4 predef\nYes No S Yes No 1-6,7 Not\nNo Programs Proved\n[101] S Yes Check\nRun Logic Yes Yes Static Yes \u03b9 \u03b4 \u03c7 SLDNF No No SS Yes No 1-6,7 Yes No Maintain\n[52] N Yes Maintain Run Logic Yes No Static Yes \u03b9 \u03b4 Unfold Yes No SS Yes No 1-6,9 Yes Yes\n[82] N Yes Maintain Comp. Logic Yes Yes Static\nYes \u03b9 \u03b4 \u03c7 SLDNF Yes No S Yes No 1-6,9 Not Not\nRun Dynamic proved proved\n[103] S Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 Unfold. No Yes S Yes No 1-6,7 Not\nNo proved\n[6] H Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes\n[22] N No Maintain Comp Relation\nYes Limited Static Yes \u03b9 \u03b4 \u03c7 Active Yes Yes S Yes No \u2014 No No Run Logic\n[49] N No Maintain Comp Relation No Flat Static\nYes \u03b9 \u03b4 \u03c7 Active Yes Yes S Yes No \u2014 No No Run Logic Limited Dynamic\n[25] H Yes Check Comp. O-O Class\nLimited Static Yes \u03b9 \u03b4 Active Yes No SS Yes No 1-6,9 No Yes Maintain Run Att.\n[32] N Yes Maintain Run Logic Yes Flat\nStatic Yes \u03b9 \u03b4 Unfold. Yes No S Yes No 1-6,9 Not\nYes Limited proved\n[74] N Yes Maintain Run Logic Yes Limited Static No \u03b9 \u03b4 Active Yes No SS Yes No 1-6,7 Yes Not proved [100] N Yes Maintain Comp Logic Yes Yes Static\nYes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes Run Dynamic\n[94] S Yes Maintain Comp Logic No Flat\nStatic Yes \u03b9 \u03b4 predef\n\u2014 Yes G No Yes \u2014 No Not\nLimited Programs proved\nTab. 1. Summary of view-update and integrity constraint with our axiomatic methodAppendix B\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[99] N No Maintain Comp Logic Yes Limited Static Yes \u03b9 \u03b4 \u03c7 Predef\nYes No S Yes No 1-6,7 Yes No Program\n[8] H Yes Check Run Logic Yes Limited Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes\n[33] N Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF No No S Yes No 1-6,7 No Not Proved [72] N Yes Maintain Run Logic Yes Flat Static Yes \u03b9 \u03b4 Unfold No Yes G Yes No 1-6,7 Not\nNo Limited proved\n[104] H No Maintain Comp. Relation Yes Limited Static\nYes \u03b9 \u03b4 \u03c7 Unfold Yes No S Yes No 1-6,7 Not Not\nRun Dynamic proved proved\n[76] N No Maintain Comp Logic No Flat Static\nYes \u03b9 \u03b4 Active Yes No G No No \u2014 No No Restore Run Limited Dynamic\n[95] N No Maintain Comp Relation No Flat\nStatic Yes \u03b9 \u03b4 Active Yes No S No No \u2014 No No Run Limited\n[75] N Yes Check Run Logic Yes Limited Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes\n[1] O No Maintain Run Logic Yes Limited Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No\n[96] N No Maintain Comp Relation No Limited Static Yes \u03b9 \u03b4 Predef\nNo No G No No \u2014 No No Program\n[53] N No Maintain Comp Logic Yes Limited Static Yes \u03b9 \u03b4 \u2014 No No S No No \u2014 No No\n[26] N No Maintain Comp. Relation Yes Limited Static\nYes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 Not Not\nRun Dynamic proved proved\n[40] H Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 Predef\nYes No S Yes No 1-6,7 Yes Not\nPrograms proved\n[55] O Yes Check Run Relation Yes Limited Static No \u03b9 \u03b4 Unfold Yes No S Yes No 1-6,9 Yes Yes\n[10] O Yes Check Run Relation Yes Limited Static No \u03b9 \u03b4 Unfold Yes No S Yes No 1-6,9 Yes Yes\n[43] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes\n[91] N No Maintain Run Logic Yes Limited Static Yes \u03b9 \u03b4 Predef Yes No S Yes No 1-6,7 Yes Not\nPrograms proved\n[59] O No Maintain Comp Relation Yes Limited Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[92] N Yes Check Run Logic No Limited Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes\n[44] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 SLDNF No No S Yes No 1-6,9 Not\nNo proved\n[80] N Yes Check\nRun Logic Yes Yes Static No \u03b9 \u03b4 \u03c7 SLD Yes No S Yes No \u2014 No No Maintain\n[17] N Yes Check Run\nLogic Yes Yes Static No \u03b9 \u03b4 \u03c7 SLD Yes No SS Yes No 1-6,7 Yes Not Maintain Comp proved\n[27] N Yes Check Run Logic Yes Yes Static\nYes \u03b9 \u03b4 \u03c7 Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program\n[21] N Yes Check Comp Logic Yes Yes Dynamic Yes \u03b9 \u03b4 Predef Yes No S Yes No \u2014 Not\nNo Programs Proved proved\n[28] N Yes Check Run Logic Yes Yes Static\nYes \u03b9 \u03b4 \u03c7 Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program\n[30] N No Maintain Comp Logic Yes No \u2014 Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No\n[106] N No Maintain Run Relation Yes No \u2014 Yes \u03b9 \u03b4 \u03c7 Unfold Yes No SS No No \u2014 Not Not proved proved [56] O No Maintain Comp. Logic Yes No \u2014 Yes \u03b9 \u03b4 \u2014- Yes No G No No \u2014 Yes Not\nRun proved\n[11] S Yes Check Run Logic Yes Flat\nStatic Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Not\nLimited proved\n[41] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No\n[23] O No Maintain Run Relation Yes No Static Yes \u03b9 \u03b4 SLD Yes Yes G No No \u2014 Not Not proved proved\n[12] O No Maintain Comp Relation Yes No Static Yes \u03b9 \u03b4 \u03c7 \u2014 Yes No SS Yes No \u2014 No No\n[3] O No Maintain Comp. Relation No Limited Static\nYes \u03b9 \u03b4 \u2014 Yes No G Yes No \u2014 No No Run Dynamic\n[78] N No Maintain Comp Relation No Yes Static Yes \u03b9 \u03b4 \u03c7 Unfold No Yes SS No No \u2014 No No\n[93] N No Check Comp Logic No Yes Static Yes \u03b9 \u03b4 Active Yes No G Yes No \u2014 No No\n[36] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes"}], "references": [{"title": "Automated selection of materialized views and indexes in SQL databases, Intl", "author": ["S Agrawal"], "venue": "Conference on Very Large Data Bases (VLDB),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourron"], "venue": "Journal of Symbolic Logic 50,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1985}, {"title": "Filtering XML content for publication and presentation on the web, ICDIM, 85-89", "author": ["L. Alexandre", "J. Coelho"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Abductive Resoning Logic Investigations into Discovery and Explanation", "author": ["A. Aliseda"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2006}, {"title": "A new approach for preference-based argumentation frameworks", "author": ["L. Amgoud", "S. Vesic"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Belief Dynamics, Abduction, and Database", "author": ["C. Aravindan", "Dung", "P.M"], "venue": "JELIA,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1994}, {"title": "Dynamics of Belief: Epistmology, Abduction and Database Update", "author": ["Aravindan C"], "venue": "Phd Thesis,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1995}, {"title": "A Rational and Efficient Algorithm for View Deletion in Databases", "author": ["C. Aravindan", "P. Baumgartner"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1997}, {"title": "Semantically Guided Theorem Proving for Diagnosis Applications", "author": ["P Baumgartner"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1997}, {"title": "On solving the view selection problem in distributed data warehouse architectures", "author": ["A. Bauer", "W. Lehne"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "A Transformation-Based Approach to View Updating in Stratifiable Deductive Databases", "author": ["A. Behrend", "R. Manthey"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "A cooperative approach to view selection and placement in P2P systems", "author": ["Z Bellahsene"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Agent-based communities of web services: an argumentation-driven approach", "author": ["J Bentahar"], "venue": "Service Oriented Computing and Applications,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Using argumentation to model and deploy agent-based B2B applications", "author": ["J Bentahar"], "venue": "Knowl.-Based Syst.,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "A taxonomy of argumentation models used for knowledge representation, Artif", "author": ["J Bentahar"], "venue": "Intell. Rev,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "Combining Nonmonotonic Reasoning and Belief Revision: A Practical Approach", "author": ["B. Bessant"], "venue": "AIMSA,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1998}, {"title": "Efficient Integrity Checking over XML Documents", "author": ["D Braga"], "venue": "EDBT Workshops,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "Inference-usability confinement by maintaining inference-proof views of an information system. IJCSE", "author": ["J. Biskup"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "The View-Update Problem for Indefinite Databases. JELIA", "author": ["L. Caroprese"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "View-based query answering in Description Logics Semantics and complexity", "author": ["D Calvanese"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2012}, {"title": "Automatic Generation of Production Rules for Integrity Maintenance", "author": ["S Ceri"], "venue": "ACM Transactions on Database Systems", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1994}, {"title": "Towards materialized view selection for distributed databases", "author": ["Chaves", "L.W.F"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2009}, {"title": "A Comparative Study of View Update Problem", "author": ["H. Chen", "H. Liao"], "venue": "DSDE,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2010}, {"title": "An Execution Model for Limited Ambiguity Rules and Its Application to Derived Data Update", "author": ["Chen", "I.A"], "venue": "ACM Transactions on Database Systems", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "The view-selection problem has an exponential-time lower bound for conjunctive queries and views", "author": ["R. Chirkova"], "venue": "ACM Symposium on Principles of Database Systems (PODS),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2002}, {"title": "On Simplification of Database Integrity Constraints", "author": ["H. Christiansen", "D. Martinenghi"], "venue": "Fundam. Inform", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2006}, {"title": "Integrity Checking and Maintenance with Active Rules in XML Databases", "author": ["H. Christiansen", "M. Rekouts"], "venue": "BNCOD Workshops,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2007}, {"title": "Type-Based Static and Dynamic Website Verification, ICIW", "author": ["J. Coelho", "M. Florido"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2007}, {"title": "On the Complexity of View Update Analysis and Its Application to Annotation Propagation", "author": ["G Cong"], "venue": "IEEE Trans. Knowl. Data", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2012}, {"title": "The Role of Abduction in Database View Updating", "author": ["L Console"], "venue": "Journal of Intelligent Information Systems", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1995}, {"title": "One Abductive Logic Programming Procedure for two kind of Updates", "author": ["H. Decker"], "venue": "Proc. Workshop DINAMICS\u201997 at Int. Logic Programming Symposium", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1997}, {"title": "A Rational and Efficient Algorithm for View Revision in Databases", "author": ["R. Delhibabu", "G. Lakemeyer"], "venue": "Applied Mathematics & Information Sciences", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2013}, {"title": "An Abductive Framework for Knowledge Base Dynamics", "author": ["R. Delhibabu"], "venue": "Applied Mathematics & Information Sciences (accepted)", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}, {"title": "A New Rational Algorithm for View Updating in Relational Databases", "author": ["R. Delhibabu", "A. Behrend"], "venue": "Applied Intelligence (accepted)", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2014}, {"title": "Materialized View Selection in Data Warehousing: A Survey", "author": ["C.A. Dhote", "M.S. Ali"], "venue": "Journal of Applied Sciences,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2009}, {"title": "Incremental evaluation of datalog queries", "author": ["G. Dong", "R.W. Topor"], "venue": "In Database Theory - ICDT,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 1992}, {"title": "Integrity Constraint Enforcement by Means of Trigger Templates", "author": ["E Dom\u0131\u0301nguez"], "venue": "ADVIS,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2002}, {"title": "Model-Driven, View-Based Evolution of Relational Databases, DEXA, 822-836", "author": ["E Dom\u0131\u0301nguez"], "venue": null, "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2008}, {"title": "On computing all abductive explanations from a propositional Horn theory", "author": ["T. Eiter", "K. Makino"], "venue": "J. ACM", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2007}, {"title": "Handling Existential Derived Predicates in View Updating", "author": ["C Farr\u00e9"], "venue": null, "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2003}, {"title": "A New Approach for Checking Schema Validation Properties", "author": ["C Farr\u00e9"], "venue": null, "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2004}, {"title": "Prioritized and Non-prioritized", "author": ["M.A. Falappa"], "venue": "Multiple Change on Belief Bases. J. Philosophical Logic", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2012}, {"title": "Stratified Belief Bases Revision with Argumentative Inference", "author": ["M Falappa"], "venue": "J. Philosophical Logic,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2013}, {"title": "AGM 25 Years - Twenty-Five Years of Research in Belief Change", "author": ["E.L. Ferme", "S.O. Hansson"], "venue": "J. Philosophical Logic", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2011}, {"title": "A Review of Repairing Techniques for Integrity Maintenance, RIDS", "author": ["P. Fraternali", "S. Paraboschi"], "venue": null, "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1993}, {"title": "Specifying Reactive Integrity Control for Active Databases, RIDE, 62-70", "author": ["M. Gertz"], "venue": null, "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1994}, {"title": "Updating Knowledge Bases, New Generation", "author": ["A. Guessoum", "J.W. Lloyd"], "venue": "Computing Vol,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1990}, {"title": "Counting solutions to the view maintenance problem", "author": ["A Gupta"], "venue": "In Workshop on Deductive Databases,", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 1992}, {"title": "Maintaining views incrementally", "author": ["A Gupta"], "venue": "ACM SIGMOD,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1993}, {"title": "Answering queries using views: A survey", "author": ["A.Y. Halevy"], "venue": null, "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2001}, {"title": "Textbook of Belief Dynamics", "author": ["S.O. Hansson"], "venue": null, "citeRegEx": "54", "shortCiteRegEx": "54", "year": 1997}, {"title": "Uniqueness of Update Strategies for Database Views", "author": ["S.J. Hegner"], "venue": "FoIKS,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2002}, {"title": "A Model of Database Components and their Interconnection Based upon Communicating Views", "author": ["S.J. Hegner"], "venue": "EJC,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2007}, {"title": "Research opportunities for argumentation in social networks", "author": ["S Heras"], "venue": "Artif. Intell. Rev.,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2013}, {"title": "Propositional Belief Base Update and Minimal Change", "author": ["A. Herzig", "O. Rifi"], "venue": "Artif. Intell", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 1999}, {"title": "Applying evolutionary algorithms to materialized view selection in a data warehouse", "author": ["Horng", "J. T"], "venue": "Soft Comput,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2003}, {"title": "Model Generation for Horn Logic with Stratified Negation. FORTE", "author": ["E.K. Jackson", "W. Schulte"], "venue": null, "citeRegEx": "60", "shortCiteRegEx": "60", "year": 2008}, {"title": "Database Updates Through Abduction", "author": ["A.C. Kakas", "P. Mancarella"], "venue": "VLDB Conference,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 1990}, {"title": "Relational Databases Through Views", "author": ["A. Keller"], "venue": "Phd Thesis", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 1985}, {"title": "Ontology-based data access systems", "author": ["M.R. Kogalovsky"], "venue": "Programming and Computer Software", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 2012}, {"title": "Dynamics of Beliefs", "author": ["S. Konieczny"], "venue": null, "citeRegEx": "64", "shortCiteRegEx": "64", "year": 2011}, {"title": "Horn Complements: Towards Horn-to-Horn Belief Revision", "author": ["M Langlois"], "venue": null, "citeRegEx": "67", "shortCiteRegEx": "67", "year": 2008}, {"title": "Updating Intensional Predicates in Deductive Databases", "author": ["D Laurent"], "venue": "Data Knowl. Eng", "citeRegEx": "68", "shortCiteRegEx": "68", "year": 1998}, {"title": "Speeding up materialized view selection in data warehouses using a randomized algorithm", "author": ["M. Lee", "J. Hammer"], "venue": "Int. J. Cooperative Inf. Syst.,", "citeRegEx": "69", "shortCiteRegEx": "69", "year": 2001}, {"title": "The Complexity of Belief Update (Extended in 2003)", "author": ["P. Liberatore"], "venue": "IJCAI vol", "citeRegEx": "70", "shortCiteRegEx": "70", "year": 1997}, {"title": "The Compactness of Belief Revision and Update Operators", "author": ["P. Liberatore", "M. Schaerf"], "venue": "Fundam. Inform", "citeRegEx": "71", "shortCiteRegEx": "71", "year": 2004}, {"title": "Minimal and Consistent Evolution of Knowledge Bases", "author": ["J. Lobo", "G. Trajcevski"], "venue": "Journal of Applied Non-Classical Logics", "citeRegEx": "72", "shortCiteRegEx": "72", "year": 1997}, {"title": "Materialized View Selection: A Survey, IGI book chapter, View Management Techniques and Their Application to Data Stream Management, DOI: 10.4018/978-1-60566-816-1.ch005", "author": ["X. Li"], "venue": null, "citeRegEx": "73", "shortCiteRegEx": "73", "year": 2010}, {"title": "Efficient maintenance of materialized mediated", "author": ["J Lu"], "venue": "views. ACM SIGMOD,", "citeRegEx": "74", "shortCiteRegEx": "74", "year": 1995}, {"title": "View Updates in Disjunctive Deductive Databases Based on SLDResolution", "author": ["W. Lu"], "venue": "KRDB,", "citeRegEx": "75", "shortCiteRegEx": "75", "year": 1999}, {"title": "Maintaining and Restoring Database Consistency with Update Rules, Workshop DYNAMICS, JICSLP", "author": ["S. Maabout"], "venue": null, "citeRegEx": "76", "shortCiteRegEx": "76", "year": 1998}, {"title": "Modeling view selection as a constraint satisfaction", "author": ["I Mami"], "venue": "problem. DEXA,", "citeRegEx": "78", "shortCiteRegEx": "78", "year": 2011}, {"title": "A survey of view selection methods", "author": ["I. Mami", "Bellahsene. Z"], "venue": "SIGMOD Record", "citeRegEx": "79", "shortCiteRegEx": "79", "year": 2012}, {"title": "Efficient Integrity Checking for Databases with", "author": ["D. Martinenghi", "H. Christiansen"], "venue": "Recursive Views. ADBIS,", "citeRegEx": "80", "shortCiteRegEx": "80", "year": 2005}, {"title": "A General Framework for Reasoning On Inconsistency", "author": ["M Martinez"], "venue": "Springer Briefs in Computer Science,", "citeRegEx": "81", "shortCiteRegEx": "81", "year": 2013}, {"title": "Incorporating Modification Requests in Updating Consistent Knowledge Bases", "author": ["E. Mayol", "E. Teniente"], "venue": "Fourth Int. Works. on the Deductive Approach to Information Systems and Databases,", "citeRegEx": "82", "shortCiteRegEx": "82", "year": 1993}, {"title": "A Survey of Current Methods for Integrity Constraint Maintenance and View Updating", "author": ["E. Mayol", "E. Teniente"], "venue": "ER (Workshops),", "citeRegEx": "83", "shortCiteRegEx": "83", "year": 1999}, {"title": "Reactive Consistency Control in Deductive Databases", "author": ["G. Moerkotte", "Lockemann", "P.C"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "84", "shortCiteRegEx": "84", "year": 1991}, {"title": "Transaction Trees for Knowledge Revision", "author": ["L Mota-Herranz"], "venue": "FQAS,", "citeRegEx": "85", "shortCiteRegEx": "85", "year": 2000}, {"title": "Forgetting and Knowledge Update", "author": ["A Nayak"], "venue": "Australian Conference on Artificial Intelligence,", "citeRegEx": "86", "shortCiteRegEx": "86", "year": 2006}, {"title": "Is Revision a Special Kind of Update", "author": ["A. Nayak"], "venue": "Australasian Conference on Artificial Intelligence,", "citeRegEx": "87", "shortCiteRegEx": "87", "year": 2011}, {"title": "How Hard is it to Revise a Belief Base", "author": ["B. Nebel"], "venue": "Handbook of Defeasible Reasoning and Uncertainty Management Systems,", "citeRegEx": "88", "shortCiteRegEx": "88", "year": 1998}, {"title": "Knowledge-base revision. The Knowledge Engineering", "author": ["Papini"], "venue": "Review 15(4),", "citeRegEx": "89", "shortCiteRegEx": "89", "year": 2000}, {"title": "A Survey of Revision Approaches in Description Logics. Description Logics", "author": ["G. Qi", "F. Yang"], "venue": null, "citeRegEx": "90", "shortCiteRegEx": "90", "year": 2008}, {"title": "Incremental Evaluation of Tabled Logic Programs", "author": ["D. Saha", "C.R. Ramakrishnan"], "venue": null, "citeRegEx": "91", "shortCiteRegEx": "91", "year": 2003}, {"title": "An abductive framework for computing knowledge base updates", "author": ["C. Sakama", "K. Inoue"], "venue": "TPLP", "citeRegEx": "92", "shortCiteRegEx": "92", "year": 2003}, {"title": "Database Integrity Mechanism between OLTP and Offline Data, ACIIDS", "author": ["M Salman"], "venue": null, "citeRegEx": "93", "shortCiteRegEx": "93", "year": 2012}, {"title": "Tailoring Consistent Specializations as a Natural Approach to Consistency Enforcement, 6th Int. Workshop on Foundations of Models and Languages for Data and Objects: Integrity in Databases", "author": ["K.D. Schewe"], "venue": null, "citeRegEx": "94", "shortCiteRegEx": "94", "year": 1996}, {"title": "Consistency Enforcement in Entity-Relationship and Object Oriented Models, Data & Knowledge Eng 28(1),121-140", "author": ["K.D. Schewe"], "venue": null, "citeRegEx": "95", "shortCiteRegEx": "95", "year": 1998}, {"title": "Minimal Belief Change and Pareto-Optimality", "author": ["O. Schulte"], "venue": "Australian Joint Conference on Artificial Intelligence,", "citeRegEx": "97", "shortCiteRegEx": "97", "year": 1999}, {"title": "Irrevocable Belief Revision in Dynamic Doxastic Logic", "author": ["K. Segerberg"], "venue": "Notre Dame Journal of Formal Logic", "citeRegEx": "98", "shortCiteRegEx": "98", "year": 1998}, {"title": "Incremental maintenance of externally materialized views", "author": ["M. Staudt", "Jarke. M"], "venue": "VLDB Journal,", "citeRegEx": "99", "shortCiteRegEx": "99", "year": 1996}, {"title": "Updating Knowledge Bases while Maintaining their Consistency", "author": ["E. Teniente", "A. Olive"], "venue": "The VLDB Journal,", "citeRegEx": "100", "shortCiteRegEx": "100", "year": 1995}, {"title": "A method for change computation in deductive databases. VLDB, 225\u00ef\u00a3\u00b71\u00ef\u00a3\u00b777", "author": ["Ur\u1e55\u0131", "A. Oliv\u00e9"], "venue": null, "citeRegEx": "101", "shortCiteRegEx": "101", "year": 1992}, {"title": "First order Theory Refinement", "author": ["S. Wrobel"], "venue": "IOS Frontier in AI and Application Series", "citeRegEx": "102", "shortCiteRegEx": "102", "year": 1995}, {"title": "On Updates and Inconsistency", "author": ["B. W\u00fcthrich"], "venue": "Repairing in Knowledge Bases,", "citeRegEx": "103", "shortCiteRegEx": "103", "year": 1993}, {"title": "Algorithms for materialized view design in data warehousing environment", "author": ["J Yang"], "venue": null, "citeRegEx": "104", "shortCiteRegEx": "104", "year": 1997}, {"title": "Genetic algorithm for materialized view selection in data warehouse", "author": ["C. Zhang", "Y. Yang"], "venue": "environments, DaWaK,", "citeRegEx": "105", "shortCiteRegEx": "105", "year": 1999}], "referenceMentions": [{"referenceID": 4, "context": "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.", "startOffset": 70, "endOffset": 82}, {"referenceID": 12, "context": "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.", "startOffset": 70, "endOffset": 82}, {"referenceID": 13, "context": "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.", "startOffset": 70, "endOffset": 82}, {"referenceID": 14, "context": "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.", "startOffset": 70, "endOffset": 82}, {"referenceID": 74, "context": "Revision means modifying the knowledge base in order to maintain consistency [81], while keeping the new information and removing (contraction) or not removing the least possible previous information.", "startOffset": 77, "endOffset": 81}, {"referenceID": 5, "context": "Previous work [6,7] makes connections with contraction from knowledge base dynamics.", "startOffset": 14, "endOffset": 19}, {"referenceID": 6, "context": "Previous work [6,7] makes connections with contraction from knowledge base dynamics.", "startOffset": 14, "endOffset": 19}, {"referenceID": 31, "context": "\u22c6 This paper extends work from Delhibabu [34] and Mayol [83]", "startOffset": 41, "endOffset": 45}, {"referenceID": 76, "context": "\u22c6 This paper extends work from Delhibabu [34] and Mayol [83]", "startOffset": 56, "endOffset": 60}, {"referenceID": 81, "context": "Our knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]).", "startOffset": 162, "endOffset": 166}, {"referenceID": 90, "context": "Our knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]).", "startOffset": 181, "endOffset": 185}, {"referenceID": 54, "context": "The principle of minimal change [58,97] can provide a reasonable strategy.", "startOffset": 32, "endOffset": 39}, {"referenceID": 89, "context": "The principle of minimal change [58,97] can provide a reasonable strategy.", "startOffset": 32, "endOffset": 39}, {"referenceID": 1, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourr\u00f3n, Peter G\u00e4rdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?", "startOffset": 252, "endOffset": 255}, {"referenceID": 66, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourr\u00f3n, Peter G\u00e4rdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?", "startOffset": 286, "endOffset": 296}, {"referenceID": 79, "context": "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourr\u00f3n, Peter G\u00e4rdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?", "startOffset": 286, "endOffset": 296}, {"referenceID": 10, "context": "The basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them.", "startOffset": 18, "endOffset": 24}, {"referenceID": 7, "context": "The basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them.", "startOffset": 18, "endOffset": 24}, {"referenceID": 1, "context": "Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [2]), which is intended to represent situations in which an agent has to give up \u03c6 from its current stock of beliefs (denoted as KB-\u03c6).", "startOffset": 112, "endOffset": 115}, {"referenceID": 41, "context": "Then, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [45].", "startOffset": 197, "endOffset": 201}, {"referenceID": 1, "context": "AGM [2] proposed a formal framework in which revision(contraction) is interpreted as belief change.", "startOffset": 4, "endOffset": 7}, {"referenceID": 6, "context": "Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [7]) has to verify.", "startOffset": 155, "endOffset": 158}, {"referenceID": 6, "context": "So, relaxing this condition (example with more details can be found in [7]) allows for weakening strong relevance to relevance only.", "startOffset": 71, "endOffset": 74}, {"referenceID": 3, "context": "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [4]).", "startOffset": 114, "endOffset": 117}, {"referenceID": 78, "context": "All solutions translate [85] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request.", "startOffset": 24, "endOffset": 28}, {"referenceID": 10, "context": "View updating [11] aims at determining one or more base relation updates such that all given update requests with respect to derived relations are satisfied after the base updates have been successfully applied.", "startOffset": 14, "endOffset": 18}, {"referenceID": 8, "context": "In [9,8] a variant of clausal normal form tableaux called \u201dhyper tableaux\u201d is introduced.", "startOffset": 3, "endOffset": 8}, {"referenceID": 7, "context": "In [9,8] a variant of clausal normal form tableaux called \u201dhyper tableaux\u201d is introduced.", "startOffset": 3, "endOffset": 8}, {"referenceID": 7, "context": "We start presenting an algorithm for stratifiable (definite) deductive databases by first defining precisely how the given database is transformed into a disjunctive logic program for the view deletion process [8] (successful branch - see in Algorithms 3 and 4 via Hyper Tableau).", "startOffset": 210, "endOffset": 213}, {"referenceID": 10, "context": "Next step is view insertion process [11] (For unsuccessful branches - see in Algorithms 3 and 4 via magic set).", "startOffset": 36, "endOffset": 40}, {"referenceID": 76, "context": "In this section, we extend Mayol and Teniente\u2019s [83] survey for view updating and integrity constraint.", "startOffset": 48, "endOffset": 52}, {"referenceID": 44, "context": "The main aspects that must be taken into account during the process of view updating and integrity constraint [48] enforcement are the following: the problem addressed, the considered database schema, the allowed update requests, the used technique, update change and the obtained solutions.", "startOffset": 110, "endOffset": 114}, {"referenceID": 5, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 12, "endOffset": 17}, {"referenceID": 6, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 12, "endOffset": 17}, {"referenceID": 31, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 32, "endOffset": 42}, {"referenceID": 32, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 32, "endOffset": 42}, {"referenceID": 33, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 32, "endOffset": 42}, {"referenceID": 50, "context": "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson\u2019s [54] belief change.", "startOffset": 168, "endOffset": 172}, {"referenceID": 38, "context": "Eiter [42], Langlois[67], and Delgrande [37] are focusing", "startOffset": 6, "endOffset": 10}, {"referenceID": 61, "context": "Eiter [42], Langlois[67], and Delgrande [37] are focusing", "startOffset": 20, "endOffset": 24}, {"referenceID": 90, "context": "Segerberg [98] defined new modeling for belief revision in terms of irrevocability on prioritized revision.", "startOffset": 10, "endOffset": 14}, {"referenceID": 50, "context": "Hansson [54], constructed five types of non-prioritized belief revision.", "startOffset": 8, "endOffset": 12}, {"referenceID": 82, "context": "Papini[89] defined a new version of knowledge base revision.", "startOffset": 6, "endOffset": 10}, {"referenceID": 50, "context": "In such a case, Hansson\u2019s[54] kernel change is related with abductive method.", "startOffset": 25, "endOffset": 29}, {"referenceID": 3, "context": "Aliseda\u2019s [4] book on abductive reasoning is one of the motivation keys.", "startOffset": 10, "endOffset": 13}, {"referenceID": 94, "context": "Wrobel\u2019s [102] definition of first order theory revision was helpful to frame our algorithm.", "startOffset": 9, "endOffset": 14}, {"referenceID": 58, "context": "Keller\u2019s [62] thesis is motivation for view update problem.", "startOffset": 9, "endOffset": 13}, {"referenceID": 22, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 113, "endOffset": 117}, {"referenceID": 76, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 172, "endOffset": 176}, {"referenceID": 34, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 49, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 67, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 63, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 72, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 97, "context": "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).", "startOffset": 221, "endOffset": 241}, {"referenceID": 15, "context": "[16] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications.", "startOffset": 0, "endOffset": 4}, {"referenceID": 62, "context": "[68] parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.", "startOffset": 0, "endOffset": 4}, {"referenceID": 83, "context": "Furthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]).", "startOffset": 140, "endOffset": 144}, {"referenceID": 59, "context": "Furthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]).", "startOffset": 161, "endOffset": 165}, {"referenceID": 64, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).", "startOffset": 146, "endOffset": 153}, {"referenceID": 65, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).", "startOffset": 146, "endOffset": 153}, {"referenceID": 18, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).", "startOffset": 165, "endOffset": 169}, {"referenceID": 19, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).", "startOffset": 183, "endOffset": 187}, {"referenceID": 28, "context": "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese\u2019s [20], and Cong [31]).", "startOffset": 198, "endOffset": 202}, {"referenceID": 56, "context": "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].", "startOffset": 82, "endOffset": 86}, {"referenceID": 42, "context": "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].", "startOffset": 115, "endOffset": 122}, {"referenceID": 53, "context": "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].", "startOffset": 115, "endOffset": 122}, {"referenceID": 18, "context": "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]).", "startOffset": 214, "endOffset": 218}, {"referenceID": 17, "context": "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]).", "startOffset": 223, "endOffset": 227}, {"referenceID": 10, "context": "It would also be interesting to study how results using soft stratification [11] with belief dynamics, especially the relational approach, could be applied in real world problems.", "startOffset": 76, "endOffset": 80}, {"referenceID": 43, "context": "As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [47].", "startOffset": 103, "endOffset": 107}, {"referenceID": 60, "context": "lem(database theory), so we can extend the theory to combine results similar to Konieczny\u2019s [64] and Nayak\u2019s [87].", "startOffset": 92, "endOffset": 96}, {"referenceID": 80, "context": "lem(database theory), so we can extend the theory to combine results similar to Konieczny\u2019s [64] and Nayak\u2019s [87].", "startOffset": 109, "endOffset": 113}, {"referenceID": 10, "context": "Follows from the lemma 3,4 (minimal test) and 6,7 (materialized view) of [11]", "startOffset": 73, "endOffset": 77}, {"referenceID": 46, "context": "[50] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 SLDNF No No S Yes No 1-6,9 No Not proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 57, "context": "[61] N Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF No No S Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 77, "context": "[84] N No Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No 1-6,7 No No proved proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 47, "context": "[51] S Yes Check Comp.", "startOffset": 0, "endOffset": 4}, {"referenceID": 35, "context": "[39] N Yes Check Run Logic Yes No Static Yes \u03b9 \u03b4 predef Yes No S Yes No 1-6,7 Not No Programs Proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 93, "context": "[101] S Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u03c7 SLDNF No No SS Yes No 1-6,7 Yes No Maintain", "startOffset": 0, "endOffset": 5}, {"referenceID": 48, "context": "[52] N Yes Maintain Run Logic Yes No Static Yes \u03b9 \u03b4 Unfold Yes No SS Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 75, "context": "[82] N Yes Maintain Comp.", "startOffset": 0, "endOffset": 4}, {"referenceID": 95, "context": "[103] S Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 Unfold.", "startOffset": 0, "endOffset": 5}, {"referenceID": 5, "context": "[6] H Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 3}, {"referenceID": 20, "context": "[22] N No Maintain Comp Relation Yes Limited Static Yes \u03b9 \u03b4 \u03c7 Active Yes Yes S Yes No \u2014 No No Run Logic", "startOffset": 0, "endOffset": 4}, {"referenceID": 45, "context": "[49] N No Maintain Comp Relation No Flat Static Yes \u03b9 \u03b4 \u03c7 Active Yes Yes S Yes No \u2014 No No Run Logic Limited Dynamic", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[25] H Yes Check Comp.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "[32] N Yes Maintain Run Logic Yes Flat Static Yes \u03b9 \u03b4 Unfold.", "startOffset": 0, "endOffset": 4}, {"referenceID": 68, "context": "[74] N Yes Maintain Run Logic Yes Limited Static No \u03b9 \u03b4 Active Yes No SS Yes No 1-6,7 Yes Not proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 92, "context": "[100] N Yes Maintain Comp Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes Run Dynamic", "startOffset": 0, "endOffset": 5}, {"referenceID": 87, "context": "[94] S Yes Maintain Comp Logic No Flat Static Yes \u03b9 \u03b4 predef \u2014 Yes G No Yes \u2014 No Not Limited Programs proved Tab.", "startOffset": 0, "endOffset": 4}, {"referenceID": 91, "context": "[99] N No Maintain Comp Logic Yes Limited Static Yes \u03b9 \u03b4 \u03c7 Predef Yes No S Yes No 1-6,7 Yes No Program", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "[8] H Yes Check Run Logic Yes Limited Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 3}, {"referenceID": 30, "context": "[33] N Yes Maintain Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF No No S Yes No 1-6,7 No Not Proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 66, "context": "[72] N Yes Maintain Run Logic Yes Flat Static Yes \u03b9 \u03b4 Unfold No Yes G Yes No 1-6,7 Not No Limited proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 96, "context": "[104] H No Maintain Comp.", "startOffset": 0, "endOffset": 5}, {"referenceID": 70, "context": "[76] N No Maintain Comp Logic No Flat Static Yes \u03b9 \u03b4 Active Yes No G No No \u2014 No No Restore Run Limited Dynamic", "startOffset": 0, "endOffset": 4}, {"referenceID": 88, "context": "[95] N No Maintain Comp Relation No Flat Static Yes \u03b9 \u03b4 Active Yes No S No No \u2014 No No Run Limited", "startOffset": 0, "endOffset": 4}, {"referenceID": 69, "context": "[75] N Yes Check Run Logic Yes Limited Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "[1] O No Maintain Run Logic Yes Limited Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No", "startOffset": 0, "endOffset": 3}, {"referenceID": 49, "context": "[53] N No Maintain Comp Logic Yes Limited Static Yes \u03b9 \u03b4 \u2014 No No S No No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[26] N No Maintain Comp.", "startOffset": 0, "endOffset": 4}, {"referenceID": 36, "context": "[40] H Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 Predef Yes No S Yes No 1-6,7 Yes Not Programs proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 51, "context": "[55] O Yes Check Run Relation Yes Limited Static No \u03b9 \u03b4 Unfold Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[10] O Yes Check Run Relation Yes Limited Static No \u03b9 \u03b4 Unfold Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 39, "context": "[43] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 84, "context": "[91] N No Maintain Run Logic Yes Limited Static Yes \u03b9 \u03b4 Predef Yes No S Yes No 1-6,7 Yes Not Programs proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 55, "context": "[59] O No Maintain Comp Relation Yes Limited Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 85, "context": "[92] N Yes Check Run Logic No Limited Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}, {"referenceID": 40, "context": "[44] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 SLDNF No No S Yes No 1-6,9 Not No proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 73, "context": "[80] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 \u03c7 SLD Yes No S Yes No \u2014 No No Maintain", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[17] N Yes Check Run Logic Yes Yes Static No \u03b9 \u03b4 \u03c7 SLD Yes No SS Yes No 1-6,7 Yes Not Maintain Comp proved", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[27] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u03c7 Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "[28] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u03c7 Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "[30] N No Maintain Comp Logic Yes No \u2014 Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 52, "context": "[56] O No Maintain Comp.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] S Yes Check Run Logic Yes Flat Static Yes \u03b9 \u03b4 SLDNF Yes No S Yes No 1-6,9 Yes Not", "startOffset": 0, "endOffset": 4}, {"referenceID": 37, "context": "[41] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 \u2014 Yes No S Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[23] O No Maintain Run Relation Yes No Static Yes \u03b9 \u03b4 SLD Yes Yes G No No \u2014 Not Not", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] O No Maintain Comp Relation Yes No Static Yes \u03b9 \u03b4 \u03c7 \u2014 Yes No SS Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "[3] O No Maintain Comp.", "startOffset": 0, "endOffset": 3}, {"referenceID": 71, "context": "[78] N No Maintain Comp Relation No Yes Static Yes \u03b9 \u03b4 \u03c7 Unfold No Yes SS No No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 86, "context": "[93] N No Check Comp Logic No Yes Static Yes \u03b9 \u03b4 Active Yes No G Yes No \u2014 No No", "startOffset": 0, "endOffset": 4}, {"referenceID": 33, "context": "[36] N Yes Check Run Logic Yes Yes Static Yes \u03b9 \u03b4 SLD Yes No S Yes No 1-6,9 Yes Yes", "startOffset": 0, "endOffset": 4}], "year": 2014, "abstractText": "The dynamics of belief and knowledge is one of the major components of any autonomous system that should be able to incorporate new pieces of information. We show that knowledge base dynamics has interesting connection with kernel change via hitting set and abduction. The approach extends and integrates standard techniques for efficient query answering and integrity checking. The generation of hitting set is carried out through a hyper tableaux calculus and magic set that is focused on the goal of minimality. Many different view update algorithms have been proposed in the literature to address this problem. The present paper provides a comparative study of view update algorithms in rational approach. Keyword: AGM, Belief Revision, Knowledge Base Dynamics, Kernel Change, Abduction, Hyber Tableaux, Magic Set, View update, Update Propagation.", "creator": "LaTeX with hyperref package"}}}