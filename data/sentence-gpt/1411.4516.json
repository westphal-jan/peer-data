{"id": "1411.4516", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Nov-2014", "title": "Verification of Relational Multiagent Systems with Data Types (Extended Version)", "abstract": "We study the extension of relational multiagent systems (RMASs), where agents manipulate full-fledged relational databases, with data types and facets equipped with domain-specific, rigid relations (such as total orders). Specifically, we focus on design-time verification of RMASs against rich first-order temporal properties expressed in a variant of first-order mu-calculus with quantification across states. We build on previous decidability results under the \"state-bounded\" assumption, i.e., in the first-order domains, only the second-order domains are expected to be in the second-order domains. We find that only two domains have been observed to be within the first-order domains (the \"first-order domain\"). In a separate study, we investigated the correlation between the number of domain-specific, rigid relational databases (HPSS) with their spatial dependencies (Fig. 2a) and their spatial dependencies (Fig. 2b). We show that HPSS also have a spatial component with their spatial dependencies (Fig. 2c). Thus, HPSS is related to the relative strength of R (1) and L (2). HPSS's spatial dependency is associated with spatial dependencies (Fig. 2d) and the size of the region in the second-order domain. When a group is not in the second-order domain, we find that HPSS is associated with a local dependence on spatial dependencies (Fig. 2e). This dependence is observed in the first-order domains (e.g., in the first-order domains, the \"first-order domain\") (Fig. 2f).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Mon, 17 Nov 2014 15:49:35 GMT  (62kb)", "http://arxiv.org/abs/1411.4516v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.MA", "authors": ["diego calvanese", "giorgio delzanno", "marco montali"], "accepted": false, "id": "1411.4516"}, "pdf": {"name": "1411.4516.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Marco Montali", "Giorgio Delzanno"], "emails": ["calvanese@inf.unibz.it", "montali@inf.unibz.it", "giorgio.delzanno@unige.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 1.\n45 16\nv1 [\ncs .A\nI] 1\n7 N\nov 2\n01 4"}, {"heading": "1 Introduction", "text": "We study relational multiagent systems (RMASs), taking inspiration from the recently defined framework of data-aware commitment-based multiagent systems (DACMASs) (Chopra and Singh 2013; Montali, Calvanese, and De Giacomo 2014). Broadly speaking, an RMAS is constituted by agents that maintain data in an internal full-fledged relational database, and apply proactive and reactive rules to update their own data, and exchange messages with other agents. Messages have an associated payload, which is used to move data from one agent to another. Notably, when updating their internal database, agents may also inject fresh data into the system, by invoking external services. This abstraction serves as a metaphor for any kind of interaction with the external world, such as invocation of web services, or interaction with humans.\nFrom the data perspective, previous research has mainly focused on a single, countably infinite data domain, whose elements can only be compared for equality and inequality. This assumption is highly restrictive, since data types used in applications are typically equipped with domain-specific,\nCopyright c\u00a9 2014, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nrigid relations (such as total orders), and might be specialized through the use of facets (ISO/IEC 11404:2007 2007; Savkovic and Calvanese 2012).\nThe focus of this work is on design-time verification of RMASs against rich first-order temporal properties, allowing for quantification across states. By considering only a countably infinite domain with equality, it has been shown in (Belardinelli, Lomuscio, and Patrizi 2012; Bagheri Hariri et al. 2013; Montali, Calvanese, and De Giacomo 2014) that decidability of verification holds for variants of firstorder temporal logics under the assumption that the system is \u201cstate-bounded\u201d, i.e., unboundedly many data objects can be encountered over time, provided that in each single state only a bounded number of them is stored in the agent databases (Bagheri Hariri et al. 2014). We recast this condition by considering different options for the data types. Specifically, by exploiting an encoding of two-counter machines, we show that decidability of verification even of propositional reachability properties is lost when one of the data types is equipped with the successor relation. Our main technical result is showing decidability for a variant of first-order \u00b5-calculus in presence of dense, linear orders, and facets defined on top of them. In this case, we provide an explicit technique to construct a finite-state, sound and complete abstraction of the original system, in which dense linear orders are reformulated as non-rigid relations working on the active domain of the system only. Notably, this allows us to model and verify state-bounded RMASs that include coordination mechanisms such as ticket-based mutual exclusion protocols."}, {"heading": "2 Relational Multiagent Systems", "text": "RMASs are data-aware multiagent systems constituted by agents that exchange and update data. Beside generic agents, an RMAS is equipped with a so-called institutional agent, which exists from the initial system state, and can be contacted by the other agents as a sort of \u201cwhite-page\u201d agent, i.e., to: (i) get information about the system as a whole; (ii) obtain names of other agents so as to establish an interaction with them; and (iii) create and remove agents.\nAt a surface level, RMASs and DACMASs share many aspects. There are however two key differences in the way they model data. On the one hand, while DACMASs consider only a single, abstract data domain equipped with equality\nonly, in RMASs data are typed and enriched with domainspecific relations. This deeply impacts the modeling power of the system (see Section 3). On the other hand, while agents in DACMASs operate with incomplete knowledge about the data, and use a description logic ontology as a semantic interface for queries, RMASs employ standard relational technology for storage and querying services. This is done to simplify the treatment and isolate the core issues that arise when incorporating data types and facets, but we believe our results can be transferred to DACMASs as well.\nAn RMAS X is a tuple \u3008T ,F ,\u22060,F ,S,M,G, I\u3009, where: (1) T is a finite set of data types; (2) F is a finite set of facets over T ; (3) \u22060,F is the initial data domain of X ; (4) S is a finite set of F -typed service calls; (5) M is a finite set of F -typed relations denoting messages with payload; (6) G is a finite set of F -typed agent specifications; and (7) I is the F -typed specification of the institutional agent."}, {"heading": "2.1 Data Types and Their Facets", "text": "Data types and facets provide the backbone for modeling real-world objects manipulated by the RMAS agents. A data type T is a pair \u3008\u2206T ,RT \u3009, where \u2206T is an infinite set1, and RT is a set of relation schemas. Each relation schema R/n \u2208 RT with name R and arity n is associated with an n-ary predicate RT \u2286 \u2206nT . Given a set T of data types, we denote by RT all domain-specific relations mentioned in T . Similarly, \u2206T groups all the (pairwise disjoint) data domains of the data types in T . The interaction between data types is orthogonal to our work and is left for the future.\nExample 2.1. We consider the following, well-known data domains, whose relations retain the usual meaning: \u2022 Dense total orders such as \u3008Q, {<,=}\u3009 and \u3008R, {<,=}\u3009. \u2022 Total orders with successor, like: \u3008Z, {<,=, succ}\u3009.\nWe assume that every RMAS has two special datatypes: (i) \u3008A, {=}\u3009 for agent names that, as in mobile calculi, behave as pure names (Needham 1989; Montanari and Pistore 2005) and can only be tested for (in)equality. (ii) \u3008B, {=}\u3009 for agent specification names (see Section 2.4).\nFacets are introduced to restrict data types. A facet F is a pair \u3008T, \u03d5(x)\u3009 where T = \u3008\u2206T ,RT \u3009 is a data type, and \u03d5(x) is a monadic facet formula built as:\n\u03d5(x) := true | P (~v) | \u00ac\u03d5(x) | \u03d51(x) \u2228 \u03d52(x)\nwhere P (~v) is a relation whose schema belongs to RT , and whose terms ~v are either variable x or data objects in \u2206T . We use the standard abbreviations false and \u03d51(x) \u2227 \u03d52(x). Given a set F of facets, we use RF and \u2206F as a shortcut for RT and \u2206T respectively, where T is the set of data types on which facets in F are defined.\nGiven a facet F = \u3008T, \u03d5(x)\u3009 with T = \u3008\u2206T ,RT \u3009, a data object d belongs to F if: (i) d \u2208 \u2206T ; (ii) \u03d5(x) holds in F under substitution [x/d], written F, [x/d] |= \u03d5(x). In\n1Being infinite does not lead to a loss of generality, thanks to the notion of facet defined below.\nturn, given substitution \u03c3 = [x/d], relation F, \u03c3 |= \u03d5(x) is inductively defined as follows: F, \u03c3 |= true F, \u03c3 |= R(~v)\u03c3 if R(~v)\u03c3 is true in T F, \u03c3 |= \u00ac\u03d5(x) if F, \u03c3 6|= \u03d5(x) F, \u03c3 |= \u03d51(x) \u2227 \u03d52(x) if F, \u03c3 |= \u03d51(x) and F, \u03c3 |= \u03d52(x)\nNotice that a base facet that simply ranges over all data objects of a data type can be encoded with true as its facet formula. In particular, we use AF = \u3008\u3008A, {=}\u3009, true\u3009 and BF = \u3008\u3008B, {=}\u3009, true\u3009 to refer to two base facets for agent and specification names respectively. Example 2.2. An Enumeration s1, . . . , sn over string values can be modeled as facet \u3008\u3008S, {=}\u3009, \u2228 i\u2208{1,...,n} x = si\u3009. This also accounts for the type of boolean, which can be captured by Bool = \u3008\u3008S, {=}\u3009, x = \u201ct\u201d \u2228 x = \u201cf\u201d\u3009. Example 2.3. \u3008\u3008R, {>,=}\u3009, (x > 0 \u2227 18 > x) \u2228 x > 65\u3009 denotes ages of junior or senior people.\nFacets are used as relation types. Given a set F of facets, an F -typed relation schema R is a pair \u3008R/n,FR\u3009, where R/n is a relation schema with name R and arity n, and FR is an n-tuple \u3008F1, . . . , Fn\u3009 of facets in F .\nAn F -typed database schema D is a finite set of F -typed relation schemas, such that no two typed relations in D share the same name.\nIn the following, we denote the i-th component of R as R[i], and write TYPED(R[i]) to indicate the type associated by D to R[i]. We also denote the tuple of types associated by D to all components of R as TYPED(R). To simplify readability, we also seldomly use notation R(F1, . . . , Fn) as a shortcut for R = \u3008R/n, \u3008F1, . . . , Fn\u3009\u3009.\nObviously, since relations are typed, it is important to define when their tuples agree with their facets. Let R = \u3008R/n,FR\u3009 be a relation schema. We say that a fact R(o1, . . . , on) conforms to R if for every i \u2208 {1, . . . , n}, we have that oi belongs to Fi. Let F be a set of facets, and D be an F -typed database schema. A database instance I conforms to D if every tuple R(o1, . . . , on) \u2208 I conforms to its corresponding relation schema R \u2208 D."}, {"heading": "2.2 Initial Data Domain", "text": "Giving a data type T = \u3008\u2206T ,RT \u3009, we isolate a finite subset \u22060,T \u2282 \u2206T of initial data objects for T . This subset explicitly enumerates those data objects that can be used in the initial states of the agent specifications (cf. Section 2.4), plus specific \u201ccontrol data objects\u201d that are explicitly mentioned in the agent specifications themselves, and consequently contribute to determine the possible executions.\nWe extend this notion to cover also those objects used in the definition of facets. Giving a facet F = \u3008T, \u03d5(x)\u3009 with T = \u3008\u2206T ,RT \u3009, the set of initial data objects for F is a finite subset of \u2206T that contains all data objects explicitly mentioned in \u03d5(x). The initial data domain of an RMAS with set F of facets, written \u22060,F , is then defined as the (disjoint) union of initial data objects for each facet in F ."}, {"heading": "2.3 Typed Service Calls", "text": "Typed service calls provide an abstract mechanism for agents to incorporate new data objects when updating their\nown databases. As argued in (Bagheri Hariri et al. 2013; Montali, Calvanese, and De Giacomo 2014; Bagheri Hariri et al. 2014), this is crucial to make the system \u201copen\u201d to the external world, and accounts for a variety of interaction modes, such as interaction with services or humans. We exploit this mechanism to model in particular the agent ability to inject new data according to internal decisions taken by the agent itself, but still external to its specification.\nGiven a set F of facets, an F -typed service f is a triple \u3008f/n,F in, F out\u3009, where (i) f/n is a function schema with name f and arity n; (ii) F in is an n-tuple \u3008F1, . . . , Fn\u3009 of facets in F representing the input types of the service call; (iii) F out is a facet in F representing the output facet of the service call. As for typed relations, in S there are no two typed services that share the same name. Intuitively, when invoked with a tuple of ground data objects belonging to their input facets, the service non-deterministically returns a data object that belongs to the output facet.\nExample 2.4. Service getPrice = \u3008getPrice/0, {SF}, PF \u3009 gets a string in SF = \u3008\u3008S, {= }\u3009, true\u3009 referring to a product, and returns a rational price PF = \u3008\u3008Q, {<,=}\u3009, x > 0\u3009 .\nExample 2.5. Given facet AF = \u3008\u3008A, {=}\u3009, true\u3009, service getN = \u3008getN/0, \u2205, AF \u3009 returns agent names."}, {"heading": "2.4 Agent Specifications", "text": "In RMASs, agent specifications consist of three main components. The first is the data component, whose intensional part is a typed database schema with constraints; every agent adopting the same specification starts with the same initial extensional data, but during the execution it autonomously evoles by interacting with other agents and services. The second is a proactive behavior, constituted by a set of condition-action communicative rules that determine which messages can be emitted by the agent, together with their actual payload and target agent. The third is a reactive behavior, constituted by ECA-like update rules that determine how the agent updates its own data when a certain message with payload is received from or sent to another agent.\nGiven a set F of facets with initial data domain \u22060,F , an F -typed agent specification is a tuple \u3008n,D,\u0393, D0, C,A,U\u3009, where: 1. n \u2208 B\u2229\u22060,F is the specification name, which is assumed\nto be also part of the initial data domain. 2. D is an F -typed database schema. We assume that the\nschema is always equipped with a special unary relation MyName , whose unique component is typed with AF , and that is used to keep track of the global name associated to the agent in the system. 3. \u0393 is a finite set of database constraints over D, i.e., of domain-independent first-order formulae over D and RF , using only constants from \u22060,F . 4. D0 is the initial agent state, i.e., a database instance that conforms to D, satisfies all constraints in \u0393, and uses only constants from D0. 5. C is a set of communicative rules, defined below.\n6. A and U are sets of update actions and update rules, defined below. When clear from the context, we use the name of a component with superscript the name of the specification to extract that component from the specification tuple. For example, Dn denotes the database schema above.\nCommunicative rules. These rules are used to determine which messages with payload are enabled to be sent by the agent to other agents, depending on the current configuration of the agent database. When multiple ground messages with payload are enabled, the agent nondeterministically chooses one of them, according to an internal, black-box policy.\nA communicative rule is a rule of the form\nQ(t, ~x) enables M(~x) to t\nwhere: (i) Q is a domain-independent FO query over D and RF , whose terms are variables t and ~x, as well as data objects in \u22060,F ; (ii) M(~x) is a message, i.e., a typed relation whose schema belongs to M.\nLet F be a set facets, D a F -typed database schema, D a database instance that conforms to D, and Q(x1, . . . , xn) a FO query over D and RF that uses only constants in \u22060,F . The answer ans (Q,D) to Q over D is the set of assignments \u03b8 from the free variables ~x of Q to data objects in \u22060,F , such that D |= Q\u03b8. We treat Q\u03b8 as a boolean query, and we say ans (Q\u03b8,D) \u2261 true if and only if D |= Q\u03b8.\nIn the following, we use the special query LIVET (x) as a shortcut for the query that returns all data objects in the current active domain that belong to data type T . Given schema D, such a query can be easily expressed as the union of conjunctive queries checking whether x belongs to a component of some relation in D, such that the component has type T . In this respect, notice that any query can be relativized to the active domain through LIVE atoms.\nWe also make use to the anonymous variable \u201c \u201d to signify an existentially quantified variable not used elsewhere.\nUpdate actions. These are parametric actions used to update the agent current database instance, possibly injecting new data objects by interacting with typed services.\nAn update action is a pair \u3008\u03b1, \u03b1spec\u3009, where: (i) \u03b1 is the action schema, i.e., a typed relation accounting for the action name and for the number of action parameters, together with their types; (ii) \u03b1spec is the action specification and has the form \u03b1(~p) : {e1, . . . , en}, where {e1, . . . , en} are update effects. Each update effects has the form\nQ(~p, ~x) add A, del D\nwhere (i) Q is a domain-independent FO query over D and RF , whose terms are parameters ~p, variables ~x, and data objects in \u22060,F ; (ii) A is a set of \u201cadd\u201d facts over D that include as terms: free variables ~x of Q, parameters ~p and terms f(~x,~p), with f in S; (iii) D is a set of \u201cdelete\u201d facts that include as terms free variables ~x and parameters ~p.\nAn update action is applied by grounding its parameters ~p with data objects ~o. This results in partially grounding each of its effects. The effects are then applied in parallel over the agent database, as follows. For each partially grounded effect Q(~o, ~x) add A, del D, Q(~o, ~x) is evaluated over the\ncurrent database and for each obtained answer \u03b8, the fully ground facts A\u03b8 (resp., D\u03b8) are obtained. All the ground facts in D\u03b8 are deleted from the agent database. Facts in A\u03b8, instead, could contain (ground) typed service calls. In this case, every service call is issued, obtaining back a (possibly fresh) data object belonging to the output facet of the service. The instantiated facts in A\u03b8 obtained by replacing the ground service calls with the corresponding results are then added to the current database, giving priority to additions.\nUpdate rules. These are conditional, ECA-like rules used by the agent to invoke an update action on its own data when a message with payload is exchanged with another agent.\nAn update rule is a rule of the form \u2022 (on-send) on M(~x) to t if Q(~y1) then \u03b1(~y2), with ~y1 \u222a ~y2 \u2286 ~x \u222a {t}, or \u2022 (on-receive) on M(~x) from s if Q(~y1) then \u03b1(~y2), with ~y1 \u222a ~y2 \u2286 ~x \u222a {s}, where: (i) M(~x) is a message, i.e., a typed relation whose schema belongs to M; (ii) Q is a FO query over D, whose terms are variables ~y1 and data objects in \u22060,F ; (iii) \u03b1 is an update action in A, whose parameters are bound to variables ~y2.\nInstitutional Agent Specification. In an RMAS, an institutional agent is dedicated to the management of the system as a whole. Differently from DACMASs (Montali, Calvanese, and De Giacomo 2014), we do not assume here that the institutional agent has full visibility of the messages exchanged by all agents acting into the system. It is simply an agent that is always active in the system and whose name, inst in the following, is known by every other agent. Still, we assume that the institutional agent has special duties, such as in particular handling the creation of agents and their removal from the system, and maintainance of agent-related information, like the set of names for active agents, together with their specifications.\nTechnically, the institutional agent specification I is a standard agent specification named ispec, partially grounded as follows. To keep track of agents and their specifications, Di contains three dedicated typed relations: (i) \u3008Agent/1, \u3008AF \u3009\u3009, to store agent names; (ii) \u3008Spec/1, \u3008BF \u3009\u3009, to store specification names; (iii) \u3008hasSpec/2, \u3008AF,BF \u3009\u3009, to store the relationship between agents and their specifications. Given these special relations, inst can also play the role of agent registry, supporting agents in finding names of other agents to communicate with. Additional system-level relations, such as agent roles, duties, commitments (Montali, Calvanese, and De Giacomo 2014), can be insterted into Dinst depending on the specific domain under study. To properly enforce that hasSpec/2 relates agent to specification names, foreign keys can be added to \u0393ispec. Futhermore, we properly initialize Dinst0 as follows: (i) Agent(inst) \u2208 Dispec0 ; (ii) Spec(si) \u2208 D ispec\n0 for every agent specification that is part of the RMAS, i.e., for specification name ispec and all specification names mentioned in G; (iii) hasSpec(inst, instSpec) \u2208 Dispec0 . Obviously, inst may have other initial data, and specific rules and actions. Of particular interest is the possibility for inst of dynamically\ncreating and removing other agents. This can be encoded by readapting (Montali, Calvanese, and De Giacomo 2014). Details are given in the online appendix.\nAgent creation/removal. Two actions are employed by the institutional agent to insert or remove an agent into/from the system. Their respective action schemas are NEWAG(BF ) and REMAG(AF ). As for creation, inst employs the service call introduced in Example 2.5 to introduce a name into the Agent relation, attaching to it the specification name passed as input. However, some additional modeling effort is needed so as to ensure that the introduced name is indeed new:\nNEWAG(s) :    OldAg(a) del {OldAg(a)} FreshAg(a) del {FreshAg(a)} true add { FreshAg(getN()), Agent(getN()), Spec(getN(), s) }\nAgent(a) add{OldAg(a)}\n  \nIntuitively, apart from adding the new agent and attaching the corresponding specification, the action updates the two accessory agent relations OldAd and FreshAg , which are assumed to be part of Dispec, ensuring that in the next state OldAd contains the set of agent names that were present in the immediately preceding state, and that FreshAg contains the newly injected name. Freshness can then be guaranteed by adding a dedicated constraint to \u0393ispec:\n\u2200a.OldAg(a) \u2227 FreshAg(a) \u2192 false\nRemoval of an agent is instead simply modelled as:\nREMAG(a) : { hasSpec(a, s) del { Agent(a), hasSpec(a, s) }}\nUpdate rules that employ these special actions obviously depend on the domain, by including specific on-send and onreceive rules in I ."}, {"heading": "2.5 Well-Formed Specifications", "text": "In an RMAS, every piece of information is typed. This immediately calls for a suitable notion of well-formedness that checks the compatibility of types in all agent specifications. Intuitively, an RMAS X is well-formed if: (1) every query appearing in X consistently use variables, that is, if a variable appears multiple components, they all have the same data type; (2) every proactive rule instantiates the message payload with compatible data objects, and the destination agent with an agent name; (3) every reactive rule correctly relates the data types of the message payload with those of the query and of the update action; (4) each action effect uses parameters in a compatible way with the action type; (5) each action effect instantiates the facts in the head in a compatible way with their types; (6) each service call correctly binds its inputs and output.\nWe now formalize this intuition. Let F be a set facets, and D be a F -typed database schema. Let Q be a FO query over D and RF that uses only constants in \u22060,F . We say that Q is D-compatible if: (i) whenever a data object from \u22060,F appears in componentR[i] inside Q, then it belongs to\nTYPED(R[i]); (ii) whenever the same variable x appears in two components R1[i1] and R2[i2], then TYPED(R1[i1]) = TYPED(R2[i2]).\nBy definition of compatibility, each free variable of a Dcompatible query is associated to a single facet/data type. This allows us to characterize the \u201coutput types\u201d of a query, that is, the types associated to its free variables (and hence also the types of its answer components). Given an F -typed database schema D and a well-formed FO query Q(~x) over D and RF that uses only constants in \u22060,F , the outputtype of xi \u2208 ~x according to Q, written OUT-TYPEQ(xi), is the unique data type in F to which xi is associated by Q, where T is the set of data types on which F is defined. We extend the notion of output-type to a tuple of variables ~x\u2032 = \u3008xi, . . . , xk\u3009 \u2286 ~x with 1 \u2264 i \u2264 k \u2264 n, writing OUT-TYPEQ(~x\u2032) as a shortcut for the tuple \u3008OUT-TYPEQ(xi), . . . , OUT-TYPEQ(xk)\u3009. We also write OUT-TYPE(Q), as a shortcut for OUT-TYPEQ(~x). Notice that, when applied to an atomic query, this notion corresponds exactly to the typing of the corresponding relation, according to its schema.\nGiven an RMAS X = \u3008T ,F ,\u22060,F ,S,M,G, I\u3009 and an agent specification N = \u3008n,D,\u0393, D0, C,A,U\u3009 in G \u222a {I}, we say that:\n\u2022 C is well-formed if each of its communicative rules Q(t, ~x) enables M(~x) to t is such that (i) OUT-TYPEQ(t) = A (i.e., Q binds t to an agent name), and (ii) OUT-TYPE(Q) = TYPEM(M) (i.e., the payload is instantiated by Q in a compatible way with the types of message M ). \u2022 A is well-formed if each of its actions is well-formed. We say in turn that action \u3008\u03b1, \u03b1spec\u3009 is well-formed if every effect Q(~p, ~x) add A, del D in \u03b1spec is such that: \u2013 Q is D-compatible. \u2013 Whenever a parameter p is mentioned in Q, the type\nto which p is assigned by OUT-TYPE(Q) is the same to which p is assigned by \u03b1. \u2013 For every n-ary typed relation R \u2208 D, every fact F of R appearing inD, and for each i \u2208 {1, . . . , n}: (i) if the i-th position of F contains a data object, then such data object belongs to the domain of TYPED(R[i]); (ii) if the i-th position of F contains a variable y \u2208 ~x, then OUT-TYPEQ(y) = TYPED(R[i]). \u2013 For every n-ary typed relation R \u2208 D, every fact F of R appearing in A, and for each i \u2208 {1, . . . , n}: (i) if the i-th position of F contains a data object, then such data object belongs to the domain of TYPED(R[i]); (ii) if the i-th position of F contains a variable y \u2208 ~x, then OUT-TYPEQ(y) = TYPED(R[i]); (iii) if the i-th position of F contains a k-ary service call f(~y) with ~y \u2286 ~x and \u3008f/k,F in, F out\u3009 \u2208 S, then OUT-TYPEQ(~y) = F in and F out = TYPED(R[i]). \u2022 U is well-formed if all its update rules are wellformed. We discuss the case of on-send rules - the definition of well-formedness is identical for onreceive rules. An on-send rule in U of the form on M(~x) to t if Q(~y1) then \u03b1(~y2), with ~y1\u222a~y2 \u2286 ~x\u222a{t}, is well-formed if the following conditions hold: (i) if\nt \u2208 ~y1, then OUT-TYPEQ(t) = A; (ii) if t appears in the i-th component of \u03b1, then \u03b1 assigns type A to its i-th parameter; (iii) for each variable x \u2208 ~x \u2229 ~y1, such that x appears in the i-th component of M , we have that TYPEM(M [i]) = OUT-TYPEQ(x); (iv) for each variable x \u2208 ~x \u2229 ~y2, such that x appears in the i-th component of M and in the j-th component of \u03b1, we have that \u03b1 assigns type TYPEM(M [i]) to its j-th parameter. \u2022 N itself is well-formed if C, A and U are all well-formed. Finally, we say that the entire RMAS X is well-formed if all agents specifications in G \u222a {I} are well-formed.\nIt is easy to see that checking whether an RMAS is wellformed requires linear time in the size of the specification.\nFrom now on, we always assume that RMASs are wellformed. It is important to notice that well-formedness does not guarantee that the restrictions imposed by facets are always satisfied, but only that the agent specification consistently use data types. Consistency with facets is managed at runtime, by dynamically handling facet violations (cf. Section 4)."}, {"heading": "3 Modeling with RMAS", "text": "We briefly show how RMASs can be easily accommodate complex data-aware interaction protocols, leveraging on data types. We take inspiration from ticket-based mutual exclusion protocols (Bultan, Gerber, and Pugh 1999; Baier and Katoen 2008). This can be used, in our setting, to guarantee the possibility for an agent to engage in a complex, critical interaction with the institutional agent.\nAnother interesting example, namely how to model a form of contract net protocol in RMASs, is provided in Section 3.2. The interested reader can also refer to (Montali, Calvanese, and De Giacomo 2014) for commitment-based interactions.\nFrom now on, we assume that interaction in RMAS is synchronous. This assumption is without loss of generality, since message queues for asynchronous communication can be modelled as special typed relations in the agent databases:\nTheorem 3.1. Asynchronous RMASs based on message queues can be simulated by synchronous RMASs.\nProof. We consider a form of reliable, asynchronous communication based on message buffers. In particular, the model works as follows: \u2022 Messages sent by an agent to itself are processed immedi-\nately (in fact, there is no effective communication in this case). \u2022 Whenever a sender agent emits a message with payload targeting another agent, the message is atomically inserted into a message buffer attached to the target agent. \u2022 The target agent asynchronously reacts to the message by extracting it from the buffer (this could happen much later). \u2022 We consider two variations of this general model: one in which the buffer is ordered (i.e., it is a queue), and one in which the buffer is just a set of messages. Both models are interesting, because they reflect different assumptions on the asynchronous communication model. In fact, the\nfirst guarantees that the order in which messages are processed by the target follows the order in which messages where emitted (possibly by different agents). We call this communication model asynchronous, ordered (AO for short), and use acronym AO-RMAS for an RMAS adopting the AO communication model. Contrariwise, the second model accommodates the situation in which the order in which messages are received (i.e., processed) by a target agent does not necessarily reflect the order in which such messages were emitted. We call this communication model asynchronous, disordered (AD for short), and use acronym AD-RMAS for an RMAS adopting the AD communication model. We prove that these asynchronous communication models can be both accommodated by a synchronous RMAS that employs accessory data structures in the agent schemas, specifically tailored to buffer messages and decouple the emission of a message from its processing by the target agent.\nGiven an AD-RMAS/AO-RMAS X = \u3008T ,F ,\u22060,F ,S,M,G, I\u3009, we convert it into a standard, synchronous RMAS Xs = \u3008T ,F ,\u22060,F ,Ss,Ms,Gs, Is\u3009, where Ms and Ss just extend M and S with an additional message/service as illustrated below, and where each agent specification N = \u3008n,D,\u0393, D0, C,A,U\u3009 in G \u222a {I} becomes a corresponding agent specification Ns = \u3008n,Ds,\u0393s, D0, Cs,As,Us\u3009 in Gs \u222a {Is}, according to the translation mechanism illustrated in the following (notice that we are interested here in the correctness of the encoding, not in its efficient implementation; effective ways of realizing the translation can be provided by using this encoding as a basis).\nLet us first focus on the database schema of the agent specification. We set Ds = D\u222a{MBuffer ,NewM ,OldM }, where MBuffer is a global buffer tracking incoming messages that have been received by the agent but still needs to be (asynchronously) processed, while NewM and OldM are unary accessory relations used to manage the generation of new identifiers for messages to be enqueued. The management of such identifiers closely resembles name management as discussed for the institutional agent.\nSpecifically, MBuffer contains a numeric primary key, and internalizes the payload schemas of all message relations in M, plus an additional component to track the sender agent, and a boolean component indicating whether the payload has a valid content. A tuple in MBuffer contains a message identifier and sets exactly one of such boolean components to true, leaving the others false. This indicates what is the type of the buffered message, and that the corresponding payload/sender components contain the actual message payload and sender agents, whereas all other payload/sender components contain meaningless values. For this latter aspect, we assume, without loss of generality, that all data types are equipped with an undefined data object.\nTechnically, we fix an ordering overM, that is, a bijection msg : {1, . . . , |M|} \u2212\u2192 M\nand fix the function index = msg\u22121. We set the arity of MBuffer to 1 + \u2211|M| i=1 (2 + ai), where ai is\nthe arity of relation msg(i). We make use of the following three specific types: (i) the Bool facet (cf. Example 2.2), (ii) the RF facet, defined as \u3008\u3008R, {=, < }\u3009, true\u3009, and (iii) the facet AF for agent names. Specifically, we type component MBuffer [1] (the relation primary key) with RF . For each i \u2208 {1, . . . , |M|}, we type component MBuffer [ 2 + \u2211i\u22121 j=1(2 + aj) ] with Bool, and component MBuffer [ 3 + \u2211i\u22121 j=1(2 + aj) ] with AF ,\nwhere ai is the arity of msg(i). Furthermore, for each i \u2208 {1, . . . , |M|} and for every k \u2208 {1, . . . , ai} (ai being the arity of msg(i)), we set the type of component MBuffer [ 3 + \u2211i\u22121 j=1(2 + aj) + k ] to be the same as the\ntype of component msg(i)[k]. Unary relations NewM and OldM are respectively used to store newly created or already existing message identifiers. Their unique component is consequently typed with RF .\nLet us now consider the database constraints. We set \u0393s = \u0393\u222a {\u03a6msgId}, where \u03a6msgId is a constraint ensuring that new message identifiers do not clash with already existing identifiers, and whose specific shape depend on whether the original RMAS is asynchronous ordered or unordered. In particular: \u2022 if X is an AD-RMAS, then \u03a6newMsg is\n\u2200idn, ido.NewM (idn) \u2227OldM (ido) \u2192 ido 6= idn\n(where ido 6= idn is an abbreviation for \u00ac(ido = idn)). \u2022 if X is an AO-RMAS, then \u03a6newMsg is\n\u2200idn, ido.NewM (idn) \u2227OldM (ido) \u2192 ido < idn\nIn fact, for an ordered RMAS, a newly created message must be enqueued after all pending messages that were enqueued before. We now focus on the behavior of Ns, that is, on how the rules of N are translated into corresponding rules in Ns so as to simulate the asynchronous communication model on top of a synchronous communication model. Since asynchronous communication requires to decouple the emission of a message from the reaction of the target agent, Us only maintains the on-send rules of U , replacing the on-receive rules with other on-receive rules. This new on-receive rules are organized in two groups. The first group of rules is just used to insert message received from other agents into the buffer. In particular, for each i \u2208 {1, . . . , |M|}, Us contains a rule of the form\non Mi(~x) from s if \u00acMyName(s) then BUFFERMi(~x, s)\nwhere Mi is the name of relation msg(i), and BUFFMi is a specific update action in As, dedicated to insert the payload and sender agent of a message Mi into the buffer. In particular, BUFFMi(~x, s) is defined as:   OldM (m) del{OldM (m)} NewM (m) del{NewM (m)} true add    NewM (getRN()), MBuffer (getRN(), . . . , \u201ct\u201d\ufe38\ufe37\ufe37\ufe38 i-th component , p,~x, . . .)   \nMBuffer (m, , . . . , ) add{OldM (m)}\n  \nwhere getRN is a service that returns a RF data object, and in the addition of the tuple MBuffer(getRN(), . . . , \u201ct\u201d, p,~x, . . .), attributes \u201ct\u201d, p,~x are inserted in those positions corresponding to the boolean component, sender agent component, and payload components dedicated to msg(i), while all the other boolean components are set to \u201cf\u201d, and all remaining components are set to undef.\nThe processing of a buffered message is triggered by a special communicative rule that is contained in Cs together with all the original rules in C. The purpose of the communicative rule is to extract a message from the buffer, triggering the agent to process it whenever the original specification contained on-receive rules dedicated to this. This is done by self-sending a message nextM Specifically: \u2022 If X is an AD-RMAS, the message extraction rule is:\nMyName(a) \u2227 MBuffer (m, , . . . , ) enables nextM(m) to a\nIndeed, for a disordered RMAS, the order in which messages are received is non-deterministic. This rule mimics such a nondeterminism, since the agent nondeterministically picks one of the buffered messages.\n\u2022 If X is an AO-RMAS, the message extraction rule is:\nMyName(a) \u2227MBuffer(m, , . . . , ) \u2227\u00ac(\u2203m2.MBuffer (m2, , . . . , ) \u2227m2 < m) enables nextM(m) to a\nIndeed, for an ordered RMAS, messages are deterministically received according to the order in which they have been sent. This rule mimics such a determinism by following a FIFO policy, picking the first message in the queue. Recall that, for AO-RMAS, whenever a new message is inserted into the queue, its primary key is greater than the primary keys of already enqueued messages. The last dimension to be covered is the agent reaction to a message to be processed. This is done by suitably reformulating the original on-receive rules present in U . Specifically, for each on-receive rule\non M(~x) from s if Q(~y1) then \u03b1(~y2)\nin U , with ~y1 \u222a ~y2 \u2286 ~x \u222a {s}, Us contains a corresponding on-receive rule (which, by construction of Xs, is triggered only by the agent itself)\non nextM (m) from a if MyName(a) \u2227 \u03a6M (m,~y1, ~y2) \u2227Q(~y1) then \u03b1(m,~y2)\nwhere \u03a6M (m, s, ~x) is a query that: (i) checks whether the identifier m points to a tuple in the buffer that actually refers to a message of type M (this can be done by checking whether the boolean component in position index (M) is set to \u201ct\u201d); (ii) if so, extracts the sender of message m, and its payload ~x. Technically, the query is simply formulated as:\n\u03a6M (m, s, ~x) = MBuffer (m, , . . . , \u201ct\u201d\ufe38\ufe37\ufe37\ufe38 index(M)-th component , s, ~x, . . .)\nA final, additional update rule that always triggers when a nextM message is received is needed to properly update the buffer, by removing the processed message:\non nextM (m) from a if MyName(a) then REMOVEM(m)\nwhere:\nREMOVEM(m) : {MBuffer(m, ~x) del{MBuffer(m, ~x)}}\nBy putting everything together, if we project away the accessory relations MBuffer , OldM and NewM , we obtain that the asynchronous execution semantics of X under both the ordered and disordered assumption exactly corresponds to that of Xs under the standard synchronous semantics, as precisely defined in Figure 1.\nThe proof of Theorem 3.1 already gives a glimpse about the modelling power of RMASs equipped with ordered types. We next discuss how these features can be exploited to easily capture mutual exclusion protocols based on tickets."}, {"heading": "3.1 Ticket-Based Mutual Exclusion Protocols", "text": "The idea behind ticket-based mutual exclusion protocols is that, when a process wants to access a critical section, it must get a ticket, and wait until its turn arrives. We model tickets using the base facet RF = \u3008\u3008R, {<,=}\u3009, true\u3009 for real numbers, and exploit the domain-specific relation < to compare agent tickets. In our formulation, the critical section consists of a (possibly complex) interaction with the inst, excluding the possibility for other agents to concurrently engage in the same kind of interaction with inst.\nWe focus on the realization of inst, in such a way that mutual exclusion is guaranteed no matter how the other agents behave. First of all, inst gives top priority to handle ticket requests by the agents. A ticket request is issued by another agent using a 0-ary message ASKTICKET. Agent inst reacts by invoking a ticket generation action, provided that the sender agent is not already owner of a ticket, and the Assigned relation is empty (see below):\non ASKTICKET() from a if \u00acHasTicket(a, ) \u2227 \u00acAssigned( , ) then GENTICKET(a)\nAction GENTICKET takes as input an agent name, and uses a typed service getTicket = \u3008getTicket/0, \u2205, RF \u3009 to get a numerical ticket. The result is stored in the temporary relation Assigned , tracing that the ticket has been assigned but the corresponding agent still needs to be informed.\nGENTICKET(a) : {true add{Assigned(a,getTicket())}}\nTo guarantee that every agent will have the possibility of engaging the critical interaction with inst, every time a ticket is assigned to an agent, inst must ensure that such agent will be served after those already possessing a ticket. This is enforced through the following database constraint, which leverages on the domain-specific relation > for tickets:\n\u2200tnew, t.Assigned( , tnew) \u2227 HasTicket( , t) \u2192 tnew > t\nAn assigned ticket must be sent to the requestor agent:\nAssigned(t, a) enables GIVETICKET(t) to a\nto which inst itself reacts by moving the tuple from the temporary relation Assigned to hasTicket :\non GIVETICKET(t) to a if true then BINDTICKET(a, t)\nBINDTICKET(a, t) : { true del {Assigned(a, t)} true add{hasTicket(a, t)} }\nNow, let CMSG be a critical message. To engage in the critical interaction with inst triggered by message CMSG, the agent provides the payload and the ticket. Agent inst positively react to the request provided that the ticket indeed corresponds to the agent, and that the ticket is now to be served (i.e., it is smaller than any other ticket):\non CMSG(~p, t) from a if hasTicket(a, t) \u2227 \u00ac(\u2203a\u2032, t\u2032.hasTicket(a\u2032, t\u2032) \u2227 t > t\u2032) then CACT(a, ~p)\nThis pattern can be replicated for any other critical interaction. Additional, state relations can be added to discipline the orderings among critical message exchanges."}, {"heading": "3.2 Contract Net", "text": "We show how the classical contract net protocol (Smith 1980) can be easily accommodated in our framework. This can be considered as an example of a \u201cprice-based\u201d protocol, and therefore indirectly shows how different kinds of auctions could be modelled as well, as, e.g., done in (Belardinelli 2014).\nAn RMAS that incorporates the contract net protocol contains two agent specifications (that can be obviously enriched and extended on a per-domain basis): the specification of an initiator agent, and the specification of a participant agent. The first specification is embodied by an agent that is interested in delegating the execution of a task to another agent, so as to achieve a desired goal. The second specification is embodied by agents that have the capabilities and the interest in executing the task, provided that they get back a reward.\nThe system employs the following FIPA-like messages: \u2022 cfp(SF ) (from the initiator to participants) \u2013 a call-for-\nproposal related to the execution of the provided task (for simplicity, we use strings to represent tasks, and we assume that the task name is used also as a conversation identifier); \u2022 propose(SF, PF ) (from a participant to the initiator), with PF as in Example 2.4 \u2013 a proposal to execute the task indicated in the first parameter, for the price indicated in the second parameter; \u2022 reject(SF ) (from the initiator to a participant) \u2013 rejection of all proposals for the specified task; \u2022 accept(SF, PF ) (from the initiator to a participant) \u2013 acceptance of a proposal;\n\u2022 inform(SF ) (from a participant to the initiator) \u2013 notification that the task has been executed. \u2022 failure(SF ) (from a participant to the initiator) \u2013 notification that the task execution failed. Let us focus on the realization of the protocol from the point of view of inst, which acts as the initiator. We first introduce the relations used by inst to run the protocol: \u2022 Agent(AF ) lists the (names of) agents known to the ini-\ntiator agent; if the initiator agent is inst, then it already holds all agents present in the system, otherwise the initiator agent can engage in a preliminary interaction with inst and/or other agents to collect such names.\n\u2022 Task (SF, StateF ) lists the task names that the initiator agent is interested to assign, i.e., those that can become\nthe subject of an instance of the contract net protocol. StateF = \u3008\u3008S, {=}\u3009, x = \u201ctodo\u201d \u2228 x = \u201cassigned\u201d \u2228 x = \u201cdone\u201d\u3009 is an enumerative facet used to track the state of each task \u2013 the three states are self-explanatory.\n\u2022 Contacted(AF, SF ) lists those agents that have been already contacted for a given task. \u2022 PropPrice(AF, SF, PF ) lists those agents that answered to a proposal with a certain price.\n\u2022 AssignedTo(AF, SF, PF ) lists those tasks that have been assigned to an agent for a given price. We have now all the ingredients to model the behavioral rules of the initiator agent. First of all, the initiator agent can issue a call-for-proposal for any task in the \u201ctodo\u201d state, directed towards an eligible agent. This is captured by the communicative rule:\nTask(t, \u201ctodo\u201d) \u2227Agent(a) \u2227 \u03a6sui(a, t) \u2227 \u00acContacted(a, t) enables cfp(t) to a\nwhere \u03a6sui(a, t) is a boolean query that checks whether a is a suitable agent for executing t, and that does so by possibly involving additional relations maintained by the initiator agent for this specific purpose. An agent is considered eligible if it is suitable and has not been already contacted for the selected task.\nThe initiator agent reacts to this message by indicating that agent a has been contacted for task t:\non cfp(t) to a if true then MARKCONTACTED(a, t)\nwhere MARKCONTACTED(a, t) : { true add{Contacted(a, t)} }\nWhen a proposer agent sends back a proposal, the initiator agent stores it into the PropPrice relation:\non propose(t, p) from s if true then SETPROPOSAL(s, t, p)\nwhere SETPROPOSAL(s, t, p) : { true add{PropPrice(s, t, p)} }\nNotice that this formalization seamlessly enables the same agent to make different proposals for the same task, but can be easily modified so as to account for the situation where only one proposal per agent can be accepted.\nThe presence of at least one registered proposal enables the initiator to assign the task to some agent, provided that such an agent made the best proposal, i.e., that with the lowest price. Notice that the initiator is free to choose when to accept, and can decide to contact further agents before actually selecting the best proposal.\nPropPrice(a, t, p) \u2227 \u00ac(\u2203p2.PropPrice( , t, p2) \u2227 p2 < p) enables accept(t, p) to a\nWhen the initiator decides to actually accept the best offer, it reacts by tracking to which agent the task has been assigned (and with wich price), taking also care of properly updating the task state, as well as to clean the PropPrice relation. This is done through two different rules. The task assignment is handled by rule\non accept(t, p) to a if true then MARKASSIGNED(a, t, p)\nwhere MARKASSIGNED(a, t, p) : { true add {AssignedTo(a, t, p)} PropPrice(a, t, pa) del {PropPrice(a, t, pa)} }\nThe task state update is instead managed by rule\non accept(t, p) to a if true then SETSTATE(t, \u201cassigned\u201d)\nwhere SETSTATE(t, state) is a generic state-update action formalized as follows:{\nTask(t, oldstate) del {Task(t, oldstate)} add {Task(t, state)}\n}\nThe acceptance of an offer enables the initiator to send a rejection to all the agents that made an offer but were not selected:\nPropPrice(a, t, ) \u2227 \u00ac(AssignedTo(a, t, )) enables reject(t) to a\nTo track that a rejection has been sent, the initiator reacts to the rejection message by removing all proposals registered for the corresponding agent and task:\non reject(t) to a if true then REMPROPS(a, t)\nwhere REMPROPS(a, t) : { PropPrice(a, t, p) del{PropPrice(a, t, p)} }\nFinally, an assigned task is marked as \u201cdone\u201d whenever the corresponding agent informs the initiator that the task has been executed, or brought back to the \u201ctodo\u201d state if the agent signals a failure. These two cases are respectively handled by the two on-receive rules\non inform(t) from a if AssignedTo(a, t, ) then SETSTATE(t, \u201cdone\u201d)\nand\non inform(t) from a if AssignedTo(a, t, ) then SETSTATE(t, \u201ctodo\u201d)\nwhich reuse the action SETSTATE as defined above. The case of a failure allows the initiator agent to restart a contract net protocol for the non-executed task."}, {"heading": "4 Verification", "text": "We now focus on the verification of RMASs against rich first-order temporal properties. The execution semantics of RMAS X = \u3008T ,F ,\u22060,F ,S,M,G, I\u3009 is captured by a relational transition system \u03a5X = \u3008\u2206T ,DX ,\u03a3, s0, db,\u2192\u3009, where: (i) DX is the union of typed schemas in the specifications of G and I; (ii) \u03a3 is a possibly infinite sets of states; (iii) s0 \u2208 \u03a3 is the initial state; (iv) db is a function that, given a state s \u2208 \u03a3 and the name n of an agent active in s, returns the database of n in state s, written s.db(n), which must be Dspecn -conformant, where specn is the name of nspecification adopted by n. (v) \u2192 \u2286 \u03a3 \u00d7 \u03a3 is a transition relation between states.\nThe full \u03a5X construction starting from the initial state is given in Figure 1. We report the main steps in the following. The initial state s0 is constructed by assigning s0.db(inst)\nto the initial database instance Dispec0 of I , and the initial database of each agent mentioned in Dispec0 taking from its specification. The construction then proceeds by mutual induction over \u03a3 and \u2192, repeating the following steps forever: (1) A state s is picked from \u03a3. (2) An active agent a is nondeterministically picked selecting its name from s.db(inst). (3) The communicative rules of a are evaluated, extracting all enabled messages with their ground payloads and destination agents. (4) An enabled messages is nondeterministically picked. (5) The on-send/on-receive rules of the two involved agents are triggered, fetching all actions to be applied. (6) The actions are applied over the respective databases. If there are service calls involved, they are nondeterminstically substituted with resulting data objects, consistently with the service output facets. (7) Each agent updates its own database provided that the database resulting from the parallel application of the actions is compatible with the schema and satisfies all constraints. Otherwise the old database is maintained, so as to model a sort of \u201ctransaction rollback\u201d. (8) If one of the involved agents is inst and the update leads to the introduction of a new agent into the system, it database is initialized in accordance to its specification. (9) The global state so obtained is declared to be successor of the state picked at step 1.\nInterestingly,\u03a5X is in general infinite-branching, because of the substitution of service calls with their results, and infinite runs, because of the storage of such data objects in time.\nThe \u00b5\u0141@p Verification Logic. To specify sophisticated properties over RMASs we employ the \u00b5\u0141@p logic. This logic combines the salient features of those introduced in (Bagheri Hariri et al. 2013) and (Montali, Calvanese, and De Giacomo 2014). \u00b5\u0141@p supports the full \u00b5-calculus to predicate over the system dynamics. Recall that the \u00b5-calculus is virtually the most expressive temporal logics: it subsumes LTL and CTL\u2217. To query possibly different agent databases, \u00b5\u0141@p adopts FO queries extended with location arguments (Montali, Calvanese, and De Giacomo 2014), which are dynamically bound to agents. Furthermore, to track the temporal evolution of data objects, \u00b5\u0141@p adopts a controlled form of FO quantification across time: quantification is limited to those objects that persist in the system:\n\u03a6 ::= Q\u2113 | \u00ac\u03a6 | \u03a61 \u2227 \u03a62 | \u2203x.LIVET (x) \u2227 \u03a6 | Z | \u00b5Z.\u03a6 |\u2227 i\u2208{1,...,n} LIVETi(~xi) \u2227 \u3008\u2212\u3009\u03a6 | \u2227 i\u2208{1,...,n} LIVETi(~xi) \u2227 [\u2212]\u03a6\nwhere Q\u2113 is a (possibly open) FO query with location arguments, in which the only constants that may appear are those in \u22060,F , and Z is a second order predicate variable (of arity 0). Furthermore, the following assumption holds: in the \u3008\u2212\u3009 and [\u2212] cases, the variables x1, . . . , xn are exactly the free variables of \u03a6, once we substitute to each bounded predicate variable Z in \u03a6 its bounding formula \u00b5Z.\u03a6\u2032. We adopt the usual abbreviations, including \u03bdZ.\u03a6 for greatest fixpoints. Notice that the usage of LIVE can be safely substituted by an atomic positive query.\nThe semantics of \u00b5\u0141@p is defined over a relational transition system similarly to the semantics of \u00b5\u0141p in (Bagheri Hariri et al. 2013). The most peculiar aspect is\nconstituted by Q\u2113, which allows one to dynamically inspect the databases maintained by active agents. In particular, Q\u2113 is a standard (typed) FO query, whose atoms have the form R(~x)@a, where R is a (typed) relation, and a denotes an agent name. The evaluation of the atomic query R(~x)@a over a relational transition system \u03a5 with substitution \u03b8 returns those states s of \u03a5 such that: \u2022 a\u03b8 is an active agent in s, that is, Agent(a\u03b8) \u2208 s.db(inst); \u2022 the atomic query R(~x)\u03b8 evaluates to true in the\ndatabase instance that agent a\u03b8 has in state s, i.e., ans (R(~x)\u03b8, s.db(a\u03b8)) \u2261 true.\nExample 4.1. Consider the protocol in Section 3, assuming that inst uses a unary typed relation inCritical to store the agent that is currently in the critical interaction. Given:\nFirst(a) = \u2203t.hasTicket@inst(a, t)\u2227 \u00ac\u2203a\u2032, t\u2032.hasTicket@inst(a\u2032, t\u2032) \u2227 a\u2032 6= a \u2227 t\u2032 < t,\n\u03bdZ.(\u2200a.Agent@inst(a) \u2227 First(a) \u2192 \u00b5Y.(inCritical@inst(a) \u2228 (Agent@inst(a) \u2227 \u3008\u2212\u3009Y )) \u2227 [\u2212]Z\nmodels that when an agent is \u201cfirst\u201d, there will be a run in which it persists into the system until it enters the critical interaction."}, {"heading": "5 Decidability of Verification", "text": "We now study different aspects of the following verification problem: given a closed \u00b5\u0141@p property \u03a6 and an RMAS X , check whether \u03a6 holds over the relational transition system \u03a5X , written \u03a5X |= \u03a6. Unsurprisingly, this problem in general is undecidable. In a recent series of works, verification of data-aware dynamic systems has been studied under the notion of state-boundedness (Bagheri Hariri et al. 2014), which, in the context of RMASs, can be phrased as follows. An RMAS X is state-bounded if, for every state s of\u03a5X , the number of data objects stored in each agent database does not exceed a pre-defined bound.\nAs shown in previous work, state-boundedness still allows one to model systems that encounter infinitely many different data objects (and, possibly, even agents) along their runs, provided that they do not accumulate in the same state. In our setting, this means that infinitely many different agents can interact, provided that at each time point only a bounded number of them is active (Montali, Calvanese, and De Giacomo 2014). Similarly, from Theorem 3.1 we obtain that when an RMAS is state-bounded, asynchronous communication can be modelled only by putting a threshold on the size of each message queue.\n(Montali, Calvanese, and De Giacomo 2014) have shown that verification of state-bounded DACMASs is decidable. We study now how data types impact on this. Compilation of Facets. Facets can be eliminated, getting a shallow-typed RMAS, i.e., one using base facets only.\nTheorem 5.1. For every RMAS X , there exists a corresponding shallow-typed RMAS X\u0302 such that, for every \u00b5\u0141@p property \u03a6, we have \u03a5X |= \u03a6 if and only if \u03a5X\u0302 |= \u03a6.\nProof. Let X = \u3008T ,F ,\u22060,F ,S,M,G, I\u3009. We construct X\u0302 = \u3008T , T\u0302 ,\u22060,F , S\u0302,M\u0302, G\u0302, I\u0302\u3009 as follows:\n\u2022 T\u0302 is the set of base facets constructed starting from the types in T .\n\u2022 S\u0302 and M\u0302, are obtained from S and M by substituting the facet attached to each component with the corresponding base facet: whenever a component is originally typed with facet \u3008T, \u03d5(x)\u3009 \u2208 F , the corresponding component is typed with the base facet \u3008T, true\u3009 \u2208 T\u0302 .\n\u2022 S\u0302 and M\u0302, are obtained from S and M by substituting the facet attached to each component with the corresponding base facet: whenever a component is originally typed with facet \u3008T, \u03d5(x)\u3009 \u2208 F , the corresponding component is typed with the base facet \u3008T, true\u3009 \u2208 T\u0302 . \u2022 Each agent specification N = \u3008n,D,\u0393, D0, C,A,U\u3009 in G\u222a{I} becomes a corresponding agent specification N\u0302 = \u3008n, D\u0302, \u0393\u0302, D0, C\u0302, A\u0302, U\u0302\u3009 in G\u0302 \u222a{I\u0302}. The database schema D\u0302 transforms D similarly to how S\u0302 and M\u0302 transform S and M: for every n-ary typed relation R \u2208 D, a corresponding n-ary relation R is included in D\u0302, such that, for every i \u2208 {1, . . . , n}, TYPED\u0302(R\n\u2032[i]) = \u3008T, true\u3009 if and only if TYPED(R[i]) = \u3008T, \u03d5(x)\u3009. In addition, for every typed service call f(\u3008T1, \u03d51(x)\u3009, . . . , \u3008Tn, \u03d5n(x)\u3009) in S, D\u0302 contains a relation Inputf (\u3008T1, \u03d51(x)\u3009, . . . , \u3008Tn, \u03d5n(x)\u3009), whose use is explained below. The other elements of N\u0302 ensure that the type checks of N are properly recreated in the form of special queries and constraints. In particular: \u2013 For every communicative rule \u201cQ(t, ~x) enables M(~x)\nto t\u201d in C, with |~x| = n, C\u0302 contains the corresponding rule\nQ(t, ~x) \u2227 \u2227\ni\u2208{1,...,n},\u3008Ti,\u03d5i(x)\u3009=TYPEM(M [i])\n\u03d5(xi) enables M(~x)\nThis guarantees that the filter criterion applied on lines 45-47 of Figure 1 is properly reconstructed, so that X and X\u0302 produce the same sets of enabled messages. \u2013 A similar approach is applied to the update rules in U , incorporating into each condition the facet expressions of the facets attached to the corresponding action components, in such a way that the filter criterion applied on lines 15 and 17 of Figure 1 is properly reconstructed. This ensures that X and X\u0302 produce the same sets of instantiated actions. \u2013 Actions A need to be translated by ensuring that the types of relations in D and those of the service call input/outputs in S are properly checked. The typing of relation components is guaranteed by augmenting the set \u0393 of constraints. Specifically, beside all the original constraints in \u0393, for each n-ary typed relation R in D and every i \u2208 {1, . . . , n}, we insert into \u0393\u0302 a dedicated constraint\n\u2200xi.R( , . . . , xi, . . . , ) \u2192 \u03d5i(xi)\nwhere \u03d5i is the facet formula of TYPED(R[i]). This technique guarantees that X and X\u0302 equivalently evaluate the conditions on lines 24 and 26 of Figure 1 (X\u0302\nalways satisfies the conformance test, and lifts the original conformance test of X as a test on the satisfaction of database constraints, expressed in the second conjunct of lines 24 and 26). Finally, the tests expressed on lines 21 and 22 of Figure 1, which respectively check whether the service calls involved in an action application have inputs and outpus conforming to their respective facets, is reformulated using the technique illustrated in the following. For every action \u03b1 \u2208 A, A\u0302 contains an action \u03b1\u2032, constructed by properly manipulating the set of facts in the add-set. Specifically, for each effect \u201cQ(~p, ~x) add A, del D\u201d in the specification of \u03b1, \u03b1\u2032 contains a corresponding effect \u201cQ(~p, ~x) add A\u2032, del D\u201d, where:\nA\u2032 = A\u222a{Inputf (~x)|F \u2208 A and f(~x) appears in F} {Outputf (f(~x))|F \u2208 A and f(~x) appears in F}\nIntuitively, A\u2032 adds a fact for relation Inputf/n and a fact for relation Outputf/1 for every n-ary service call f appearing in A, in such a way that the contect of these two facts respectively correspond to the input and output of f . Since it is not important that such facts are persisted in the agent database, but it is only important that they are present after the action is applied, the specification of each action in A\u0302 also contains the following effects:\n{ Inputfi(~x) del{Inputfi(~x)} \u2223\u2223 fi \u2208 S }\nThe conformance with the service input facets can then be reformulated similarly to the case of relations in D, that is, by further augmenting the set \u0393\u0302 of constraints. Specifically, for each n-ary service call f = \u3008f/n,F in, F out\u3009 in S, we insert two dedicated constraints in \u0393\u0302: 1. by denoting with \u03d5i the facet formula of the i-th\ncomponent of F in, \u2200x1, . . . , xn.Inputf (x1, . . . , xn) \u2192 \u2227\ni\u2208{1,...,n}\n\u03d5i(xi)\n2. by denotwing with \u03c8 the facet formula of F out,\n\u2200x.Outputf (x) \u2192 \u03c8(x)\nThis mechanism lifts the checks applied for X on lines 21 and 22 of Figure 1 (which is trivially true for X\u0302 ) as additional constraint checks on lines 24 and 26, where the satisfaction of database constraints is tested.\nThe translation mechanism ensures that the execution semantics of X\u0302 suitably reconstructs that of X , i.e., if we project away the accessory relations used for the service call inputs, we have that \u03a5X\u0302 is equivalent to \u03a5X .\nAs a consequence of Theorem 5.1, we have that, for shallow-typed RMASs, the transition system construction can be simplified as shown in the BUILD-TS-SHALLOW procedure of Figure 2."}, {"heading": "5.1 RMASs with the Successor Relation", "text": "We now show that including at least one data type with the successor relation compromises decidability:\nTheorem 5.2. Verification of a propositional reachability property over state-bounded, shallow-typed RMASs that use a single data type equipped with the successor relation is undecidable, even when the RMAS contains a single agent that uses unary relations only.\nProof. The proof is by reduction from the halting problem of two-counter machines. A counter is a memory register that stores a (non-negative) integer. Notice that the proof works in the same way even if we substitute Z with Q or R, provided that they are equipped with the successor relation.\nGiven two positive integers n,m \u2208 N+, an m-counter machineC with counters c1, . . . , cm is a program constituted by a (numbered) sequence of n instructions:\n1 : CMD1; 2 : CMD2; . . . n : HALT;\nwhere the n-th instruction indicates that C halts, while for every k \u2208 {1, . . . , n\u2212 1}, instruction k : CMDk has one of the two following forms: \u2022 (increment command for counter i) CMDk = INC(i, k\u2032),\nwith i \u2208 {1, . . . ,m} and k\u2032 \u2208 {1, . . . , n}, which increases the counter ci of one unit, and then jumps to instruction number k\u2032:\nk : ci := ci + 1; GOTO k \u2032;\n\u2022 (conditional decrement command for counter i)CMDk = CDEC(i, k\u2032, k\u2032\u2032), with i \u2208 {1, . . . ,m} and k\u2032, k\u2032\u2032 \u2208 {1, . . . , n}, which tests whether the value of counter i is zero. If so, it jumps to instruction k\u2032; otherwise, it decreases counter i of one unit, and then jumps to instruction k\u2032\u2032:\nk : if ci == 0 then GOTO k\u2032; else {ci := ci \u2212 1; GOTO k\u2032\u2032; }\nAn input for an m-counter machine is an m-tuple of values \u3008d1, . . . , dm\u3009 (such that di \u2208 N), used to initialize its counters. Given an m-counter machine C and an input I of size m, we say that C halts on input I if the execution of C with counter initial values set by I eventually reaches the last, HALT command.\nIt is well-known that checking whether a 2-counter machine halts on a given input is undecidable (Minsky 1967), and that undecidability still holds when checking whether the 2-counter machine halts on input \u30080, 0\u3009.\nWe show how to encode a 2-counter machine into a state-bounded, shallow-typed RMAS containing a single agent specification that work over unary relations only. Specifically, given a 2-counter machine C with n instructions, we construct RMAS XC = \u3008{AT,ZT }, {AF,ZF}, {0, . . . , k}, {input}, {go}, \u2205, IC\u3009, where k = max{2, n}, and: \u2022 AT = \u3008A, {=}\u3009 is the agent type (just used to keep track\nof the inst name), ZT = \u3008Z, {<,=, succ}\u3009 is the integer type (but, as specified above, Z can be seamlessly substituted by Q or R).\n\u2022 AF and ZF are the base facets defined starting from AT and ZT respectively.\n\u2022 input = \u3008input/0, \u3008\u3009, ZF \u3009 is a 0-ary service that returns integer values. \u2022 go is a message sent by inst to itself so as to trigger the processing of the next instruction. \u2022 IC is a specification for the institutional agent that mimics the program of C. Specifically, IC = \u3008instspec,DC,\u0393C, Dinst0 , CC,AC,UC\u3009, where:\n\u2022 DC =    C1(ZF ), C p 1 (ZF ), C2(ZF ), C p 2 (ZF ),\nPC (ZF ),Op(ZF ),Target(ZF ),Halted() Agent(AF ),MyName(AF )\n  \nwhere: \u2013 C1 and C2 store the current values of the two counters, \u2013 Cp1 and C p 2 store their previous values,\n\u2013 PC stores the program counter (i.e., the number of the instruction to be processed), \u2013 Op indicates the nature of the operator to be applied (0 means increment, while 1 means decrement), \u2013 Target indicates the target counter, that is, the counter to which the operation must be applied (1 means the first counter, 2 the second), \u2013 Halted is a proposition indicating that the agent finished the execution (i.e., reached the last instruction of C). \u2022 \u0393C contains constraints that encode the semantics of operations. In particular: \u2013 In the case of increment, the target counter must have a\ncurrent value that is successor of the previous value:\nOp(0) \u2227 Target(1) \u2192 (\u2200xp, x.C1(x) \u2227 C p 1 (xp) \u2192 succ(x, xp)) Op(0) \u2227 Target(2) \u2192 (\u2200xp, x.C2(x) \u2227 C p 2 (xp) \u2192 succ(x, xp))\n\u2013 In the case of decrement, the opposite holds, i.e., the target counter must have a current value that is precedessor of the previous value:\nOp(1) \u2227 Target(1) \u2192 (\u2200xp, x.C1(x) \u2227 C p 1 (xp) \u2192 succ(xp, x)) Op(1) \u2227 Target(2) \u2192 (\u2200xp, x.C2(x) \u2227 C p 2 (xp) \u2192 succ(xp, x))\n\u2022 The initial database of inst initializes the two counters to 0, and the program counter to the first instruction:\nDinst0 = {Agent(inst),MyName(inst), C1(0), C2(0), PC(1)}\n\u2022 CC contains just a single rule, which enables inst to send a go message to itself if it is not halted:\nMyName(a) \u2227 \u00acHalted enables go() to a\n\u2022 AC contains the following actions: \u2013 SET-PC(ZF ) updates the program counter to the value\npassed as parameter:\nSET-PC(next) :\n{ PC (x) del {PC (x)},\ntrue add{PC (next)}\n}\n\u2013 SET-OP(ZF,ZF ) sets the operation, i.e., the operation type and the target counter, to the passed parameters:\nSET-OP(o, t) :    Op(x) del {Op(x)}, Target(x) del {Target(x)},\ntrue add{Op(o)} true add{Target(t)}\n  \n\u2013 U-C(ZF ) updates the value of the counter whose index is passed as parameter, and at the same time remembers the current value moving it to the \u201cprevious\u201d counter relation:\nU-C(c) :    c = 1 \u2227Cp1 (x) del {C p 1 (x)} c = 1 \u2227C1(x) del {C1(x)}, add{C p 1 (x)} c = 1 add{C1(input())} c = 2 \u2227Cp2 (x) del {C p 2 (x)} c = 2 \u2227C2(x) del {C2(x)}, add{C p 2 (x)}\nc = 2 add{C2(input())}\n  \nIt is worth noting that the action nondeterministically updates the content of the first or second counter, depending on the value of the parameter. However, by considering the constraints modelled in \u0393C, only the successor state that has picked exactly the successor or precedessor value of the current one will be selected, depending on what the current operation is. \u2013 STOP() is an action without parameters that just sets the Halted flag to true:\nSTOP() : {true add{Halted}}\n\u2022 UC constains a set of rules that mirror the instructions of C, according from the following translation schema: \u2013 For instruction k : INC(i, k\u2032) (with i \u2208 {1, 2}), we get:\non go if PC (k) then SET-PC(k\u2032) on go if PC (k) then SET-OP(0, i) on go if PC (k) then U-C(i)\nThe first rule handles the update of the program counter. The second rule indicates that counter i must be subject to operation with code 0. The third rule indicates that the instruction require to update the content of counter i. \u2013 For instruction k : CDEC(i, k\u2032, k\u2032\u2032) (with i \u2208 {1, 2}), we get:\non go if PC (k) \u2227 Ci(0) then SET-PC(k\u2032) on go if PC (k) \u2227 \u00acCi(0) then SET-PC(k\u2032\u2032) on go if PC (k) \u2227 \u00acCi(0) then SET-OP(1, i) on go if PC (k) \u2227 \u00acCi(0) then U-C(i)\nThe formalization is specular to the case of increment, with the proviso that the manipuation of the counter is triggered only if the counter is not 0.\n\u2013 For instruction n : HALT, we simply get:\non go if PC (n) then HALT()\nIt is now apparent that C halts on input \u30080, 0\u3009 if and only if \u03a5XC |= \u00b5Z.(Halted) \u2228 \u3008\u2212\u3009Z"}, {"heading": "5.2 Densely-Ordered RMASs", "text": "Given the previous undecidability result, we focus on dense orders. A densely-ordered RMAS only relies on data types equipped with domain-specific equality = and, possibly, total dense orders, as well as corresponding facets. For this class of RMASs, we have:\nTheorem 5.3. Verification of closed \u00b5\u0141@p properties over state-bounded, densely-ordered RMASs is decidable, and reducible to conventional, finite-state model checking.\nLet X = \u3008T ,F ,\u22060,F ,S,M,G, I\u3009 be an RMAS, and \u03a6 be a closed \u00b5\u0141@p property. Notice that, by hypothesis, T is constituted by a set Tu of data types equipped with domainspecific equality only, and a set To of data types equipped also with a dense total order: T = Tu \u228e To.\nThe proof is quite involved, so we separate it into several steps and intermediate lemmas.\nThe first step consists in reformulating the input RMAS X into the equivalent, shallow-typed version X\u0302 = \u3008T , T\u0302 ,\u22060,F , S\u0302,M\u0302\u3009, as defined in the proof of Theorem 5.1. By Theorem 5.1, we have that \u03a5X |= \u03a6 if and only if \u03a5X\u0302 |= \u03a6.\nAs a second step, we consider the infinite-state transition system \u03a5X\u0302 , and seek a faithful (sound and complete) finite-state abstraction of it, suitably extending the technique in (Bagheri Hariri et al. 2013) so as to consider types, and dense orders in particular. Since X is state-bounded, two sources of infinity are possibly present in \u03a5X and \u03a5X\u0302 :\n1. infinite branching, that is, presence of a state with infinitely many successors due to the injection of data through service calls; 2. infinite runs, that is, runs that visit infinitely many different agent databases. We can get rid of the infinite-branching in \u03a5X\u0302 by suitably pruning it:\nLemma 5.4. For every shallow-typed RMAS X\u0302 , there exists a transition system \u039bX\u0302 that obeys the following properties:\n(i) \u039bX\u0302 is finite-branching; (ii) for every closed \u00b5\u0141@p property \u03a6, \u03a5X\u0302 |= \u03a6 if and only\nif \u039bX\u0302 |= \u03a6.\nTo produce \u039bX\u0302 , we extend the notion of equality commitment exploited in (Bagheri Hariri et al. 2012; Bagheri Hariri et al. 2013). Equality commitments are used to abstractly describe how the result of a service call relates through (in)equality to the values present in the active\ndomain of the system, and to those returned by other service calls issued in the same moment, without considering their actual, specific results. Technically, we adapt the definition of equality commitment in (Bagheri Hariri et al. 2012) to the case of RMASs, taking into account that: (i) differently from DCDSs, data objects are typed, and (ii) some data objects could be compared not only with equality, but also with a domain-specific total, dense relation.\nConsider a data type Tu \u2208 Tu, and a set S made up of data objects in \u2206Tu and of ground service calls built by applying a service call f \u2208 S to input data objects, such that the return type of f is compatible with Tu. A Tu-equality commitment P on S is a partition of S, that is, a set of disjoint subsets of S, called cells, such that the union of the cells in P is exactly S. Each cell contains at most one data object (but arbitrarily many ground service calls). For any e \u2208 P , [e]P denotes the cell to which e belongs.\nThe intention of H is to abstractly characterize how the elements in S are related to each other via the domainspecific relation =Tu of Tu. In particular, P is used to capture equality and non-equality commitments on the members of S in the following sense: for every e1, e2 \u2208 S, we have e1 =Tu e2 if and only if [e1]H =Tu [e2]H.\nConsider now a data type To \u2208 To, and a set S as before. A To-densely ordered commitment H on S is a pair \u3008P , pos\u3009, where:\n\u2022 P is a To-equality commitment over S; \u2022 pos is an ordering over P that is compatible with S, i.e., pos is a bijection {1, . . . , |P|} \u2212\u2192 P that obeys to the following property: for every P1, P2 \u2208 P , whenever P1 contains a data object d1 \u2208 T and P2 contains a data object d2 in \u2206T , we have pos(P1) <N pos(P2) if and only if d1 <To d2, where <N denotes the total order relation on natural numbers.\nThe intention ofH is to abstractly characterize how the elements in S are related to each other via the domain-specific relations =To and <To of T . Specifically, P covers equality, while pos accounts for <, and orders the members of S in the following sense: for every e1, e2 \u2208 S, we have e1 <To e2 if and only if pos([e1]P) <N pos([e2]P ).\nWe now exploit commitments to change the BUILD-TS algorithm, shown in Figure 1 and used to construct \u03a5X\u0302 . In particular, we start from the TS-BUILD-SHALLOW procedure, and modify the function that nondeterministically selects the results returned by service calls. First of all, we assume the existence of a pre-defined function ASSIGN-RES, parameterized by a tuple of commitments, which substitutes a service call with a corresponding result that is in accordance with the cell to which the service call belongs. In particular, let Tu = {T 1u , . . . , T n u } and To = {T 1 o , . . . , T m o }. Let \u3008S1u, . . . , S n u , S 1 o , . . . , S m o \u3009 be a tuple of sets, each containing data objects from the corresponding type, and possibly also service calls whose return type matches with that type. Let H = \u3008P1, . . . ,Pn,H1, . . . ,Hm\u3009 be a tuple of commitments, where each Pi is a T iu-equality commitment built over Siu, and where each Hj is a T j o -densely ordered commitment built over Sjo .\nSpecifically, given a data domain \u2206, we define\nASSIGN-RES\u2206H : \u03a3\u00d7 CALLS( \u22c3\ni\u2208{1,...,n}\nSiu \u222a \u22c3\nj\u2208{1,...,m}\nSjo) \u2212\u2192 \u2206\nwhere, by fixing a state s \u2208 \u03a3, ASSIGN-RES\u2206H obeys to the following properties: \u2022 For i \u2208 {1, . . . , n}, for every service call f(~o) \u2208 Siu and for\nevery data object d \u2208 Siu: ASSIGN-RES \u2206 H (s, f(~o)) =T iu d iff\n[f(~o)]Pi =T iu [d]Pi . \u2022 For i \u2208 {1, . . . , n} and for every two service calls\nf1(~o1), f2(~o2) \u2208 S i u: ASSIGN-RES \u2206 H (s, f1(~o1)) =T iu\nASSIGN-RES\u2206H (s, f2(~o2)) iff [f1(~o1)]Pi =T iu [f2(~o2)]Pi . \u2022 For j \u2208 {1, . . . ,m} with Hj = \u3008P \u2032j , posj\u3009, for every ser-\nvice call f(~o) \u2208 Sjo and for every data object d \u2208 S j o: ASSIGN-RES\u2206H (s, f(~o)) =T iu d iff [f(~o)]P\u2032j\u2206 =T iu [d]P\u2032j . \u2022 For Hj = \u3008P \u2032j , posj\u3009 ( j \u2208 {1, . . . ,m}), and for every two service calls f1(~o1), f2(~o2) \u2208 Sjo: ASSIGN-RES\n\u2206 H (s, f1(~o1)) =T jo\nASSIGN-RES\u2206H (s, f2(~o2)) iff [f1(~o1)]P\u2032 j = T j o [f2(~o2)]P\u2032 j .\n\u2022 For Hj = \u3008P \u2032j , posj\u3009 ( j \u2208 {1, . . . ,m}), and for every two service calls f1(~o1), f2(~o2) \u2208 Sjo : \u2013 ASSIGN-RES\u2206H (s, f1(~o1)) =T jo ASSIGN-RES \u2206 H (s, f2(~o2)) iff\n[f1(~o1)]P\u2032 j = T j o [f2(~o2)]P\u2032 j ;\n\u2013 ASSIGN-RES\u2206H (s, f1(~o1)) <T jo ASSIGN-RES \u2206 H (s, f2(~o2)) iff\npos([f1(~o1)]P\u2032 j ) <N pos([f2(~o2)]P\u2032 j ).\nIntuitively, this function is used to select a single, representative combination of service call results that obey to the constraints imposed by a given commitment.\nFigure 3 shows the revised version of the algorithm in Figure 2. Instead of picking any combination of service call results, the BUILD-FB-TS-SHALLOW algorithm picks an equality/densely-ordered commitment for each type of the input RMAS, constructed over the current active domain for that type, where the current active domain for type T is obtained by considering: \u2022 the initial data objects for T ; \u2022 the current data objects for T ; \u2022 the service calls that must be issued now, and whose re-\nturn facet is defined over type T . The combination of service call results for each type is then obtained by applying the pre-defined ASSIGN-RES function.\nLet \u039bX\u0302 be the transition system obtained by the application of the BUILD-FB-TS-SHALLOW procedure over the shallow-typed RMAS X\u0302 . We first argue that \u039bX\u0302 is finitebranching, differently from \u03a5X\u0302 , for which the function GET-CALL-RES may return infinitely many combinations of service call results. In fact, given the current active domain ADoms(T ) of a type T , there are only finitely many commitments that can be constructed over that set. More specifically, when T is an unordered type their number is bounded by the Bell number of |ADoms(T )|, wherease when T is an ordered type their number is bounded by the Bell number of |ADoms(T )|, multiplied by the factorial of |ADoms(T )| (so as to account for the permutation of data objects). Since the ASSIGN-RES function assigns a single combination of results for each commitment, there are only finitely many combination of service call results, and consequently only\nfinitely many successor states of a given state can be present in \u039bX\u0302 .\nTo show that \u03a5X\u0302 and \u039bX\u0302 satisfy the same set of \u00b5\u0141@p formulae, one needs to follow step-by-step the proof of (Bagheri Hariri et al. 2012; Bagheri Hariri et al. 2013), noticing that the notion of densely-ordered commitment covers the case of formulae of the form x < y, which is the only one not already tackled by (Bagheri Hariri et al. 2012; Bagheri Hariri et al. 2013). This concludes the proof of Lemma 5.4.\nWe now observe that \u039bX\u0302 may still contain runs visiting infinitely many different states. The third phase of our proof consequently consists of showing that it is possible to produce a \u201cfolded\u201d folded transition system \u0398X\u0302 that is finite-state, and such that for every closed \u00b5\u0141@p property \u03a6, \u039bX\u0302 |= \u03a6 if and only if \u0398X\u0302 |= \u03a6.\nBefore showing how this can be done, we define a variant of BUILD-FB-TS-SHALLOW that, instead of employing the domain-specific (rigid) ordering relations, relies on additional \u201ccomparison tables\u201d that are suitably manipulated state by state. The algorithm is shown in Figure 4. The construction algorithm exploits a specific database (indexed in the state by symbol <) to store the projection of the ordering relations of types in To, where only actively persisting data objects are considered. Such database employs a relation lessThanTo for each densely-ordered data type To \u2208 To. In order to make the input RMAS insisting on such relations instead of the domain-specific ones, we introduce the FLATTEN operator, which takes an RMAS or one of its components, and substitutes every occurrence of a query of the form x <To y with the corresponding atomic query lessThanTo(x, y).\nSuch a database is initialized by computing, for each data type T io \u2208 To, the transitive closure of the <T io relation on the initial data domain for T io , and by inserting all extracted pairs into the dedicated lessThanT io binary relation. It is then used whenever a query is issued over an agent database, so as to complement it with the explicit listing of all lessThan relations. Finally, it is updated state-by-state: \u2022 on the one hand by considering the issued service calls,\nin accordance with the pos relation of the established densely-ordered commitments (cf. line 36 in Figure 4); \u2022 on the other hand by filtering away those tuples that involve a data object that is not persisting when performing a transition from the current to the next state (cf. line 53 in Figure 4). Let \u039bflat\nX\u0302 be the transition system produced by\nBUILD-FB-TS-SHALLOW-FLAT(X\u0302 ). We have that:\nLemma 5.5. For every shallow-typed RMAS X\u0302 and every closed \u00b5\u0141@p property \u03a6:\n\u039bX\u0302 |= \u03a6 if and only if \u039b flat X\u0302 |= FLATTEN(\u03a6)\nThe lemma can be proven by induction on the construction of the two transition systems, recalling that: \u2022 Every execution step of an RMAS is triggered by issuing\ndomain-independent queries over the current database of\none of its agents, and therefore comparisons can only be applied to data objects actively present in that databse. \u2022 \u00b5\u0141@p queries can only compare data objects that are present in the current active domain of the system, or that were present in the immediately previous state. This is suitably handled, for FLATTEN(\u03a6), in line 53 of Figure 4, where all comparisons between data objects present in the previous or current states are explicitly maintained. It is also important to observe that \u039bflat X\u0302\ndoes not alter the state-boundedness of \u039bX\u0302 , because it only adds relations on data objects that are present in the current or previous active domains, while comparisons between old data objects are filtered away.\nHowever, the crucial property of the construction of \u039bflat X\u0302\n, is that apart from data objects present in the initial data domain, the comparison database is not based on the domain-specific ordering relations, but is constructed starting from the picked densely-ordered commitments, as shown in line 36 of Figure 4. We combine this crucial property with the inability of \u00b5\u0141@p , due to its persistent nature, of comparing currently active data objects with objects that were encountered in the past, but are not active anymore. In particular, we can directly apply the data recycling technique in (Bagheri Hariri et al. 2012; Bagheri Hariri et al. 2013), reusing old, forgotten data objects in place of fresh ones.\nFigure 5 shows the construction algorithm with recycling of data objects. Let \u0398X\u0302 be the transition system produced by such an algorithm. Due to the fact, argued before, that during the system construction comparisons are stored by analyzing densely-ordered commitments, and not domain-specific ordering relations, correctness is obtained by adapting the proof in (Bagheri Hariri et al. 2012; Bagheri Hariri et al. 2013). In particular, we obtain that, when the original RMAS is state-bounded, then only a bounded number of new data objects must be inserted before recycling makes it not necessary anymore to consider fresh values, that is, before the set Passive is guaranteed to contain sufficiently many used but non-active data objects. This implies that the construction algorithm of Figure 5 terminates, and in turn that \u0398X\u0302 is finite-state, and represents at the same time a sound and complete abstraction of the original system.\nBy putting everything together, we obtain in fact that, for every state-bounded, densely-ordered RMAS X , and for every \u00b5\u0141@p property \u03a6: 1. \u0398X\u0302 can be effectively constructed using the procedure\nBUILD-TS-ABSTRACT of Figure 5; 2. \u0398X\u0302 has a finite number of states; 3. \u03a5X |= \u03a6 if and only if \u0398X\u0302 |= FLATTEN(\u03a6). This concludes the proof."}, {"heading": "6 Conclusion", "text": "RMASs constitute a very rich modeling framework for dataaware multiagent systems. The presence of concrete data types and their facets greatly empowers its modeling capabilities, making it, e.g., apt to capture mutual exclusion\nprotocols, asynchronous interactions with bounded queues, and price-based protocols. Our key result, namely that densely-order, state-bounded RMASs are verifiable with standard model checking techniques, paves the way towards concrete verification algorithms for this class of systems (Lomuscio, Qu, and Raimondi 2009; Cavada et al. 2014). In this respect, a major obstacle is the exponentiality in the data slots that can be changed over time, a source of complexity that is inherent in all data-aware dynamic systems (Deutsch, Sui, and Vianu 2007). We intend to attack this by proposing data modularization techniques to decompose the system into smaller components.\nFrom a foundational perspective, our work presents connections to (Belardinelli 2014), which extends the framework in (Belardinelli, Lomuscio, and Patrizi 2012) with types so as to model and verify auctions. The two settings are incomparable w.r.t. both the framework and the verification logic, and it would be interesting to study cross-transfer of results between the two settings."}], "references": [{"title": "Verification of relational data-centric dynamic systems with external services", "author": ["Bagheri Hariri"], "venue": "CoRR Technical Report arXiv:1203.0024,", "citeRegEx": "Hariri,? \\Q2012\\E", "shortCiteRegEx": "Hariri", "year": 2012}, {"title": "Verification of relational data-centric dynamic systems with external services", "author": ["Bagheri Hariri"], "venue": "In Proc. of the 32nd ACM SIGACT SIGMOD SIGAI Symp. on Principles of Database Systems", "citeRegEx": "Hariri,? \\Q2013\\E", "shortCiteRegEx": "Hariri", "year": 2013}, {"title": "State-boundedness in data-aware dynamic systems", "author": ["Bagheri Hariri"], "venue": "In Proc. of the 14th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR)", "citeRegEx": "Hariri,? \\Q2014\\E", "shortCiteRegEx": "Hariri", "year": 2014}, {"title": "and Katoen", "author": ["C. Baier"], "venue": "J.-P.", "citeRegEx": "Baier and Katoen 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "An abstraction technique for the verification of artifact-centric systems", "author": ["Lomuscio Belardinelli", "F. Patrizi 2012] Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Belardinelli et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2012}, {"title": "Model-checking concurrent systems with unbounded integer variables: Symbolic representations, approximations, and experimental results", "author": ["Gerber Bultan", "T. Pugh 1999] Bultan", "R. Gerber", "W. Pugh"], "venue": "ACM Transactions on Programming Languages and Systems", "citeRegEx": "Bultan et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Bultan et al\\.", "year": 1999}, {"title": "The nuXmv symbolic model checker", "author": ["Cavada"], "venue": "In Proc. of the 26th Int. Conf. on Computer Aided", "citeRegEx": "Cavada,? \\Q2014\\E", "shortCiteRegEx": "Cavada", "year": 2014}, {"title": "M", "author": ["A.K. Chopra", "Singh"], "venue": "P.", "citeRegEx": "Chopra and Singh 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Specification and verification of datadriven web applications", "author": ["Sui Deutsch", "A. Vianu 2007] Deutsch", "L. Sui", "V. Vianu"], "venue": "J. of Computer and System Sciences", "citeRegEx": "Deutsch et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2007}, {"title": "MCMAS: A model checker for the verification of multi-agent systems", "author": ["Qu Lomuscio", "A. Raimondi 2009] Lomuscio", "H. Qu", "F. Raimondi"], "venue": "In Proc. of the 21st Int. Conf. on Computer Aided Verification (CAV),", "citeRegEx": "Lomuscio et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lomuscio et al\\.", "year": 2009}, {"title": "M", "author": ["Minsky"], "venue": "L.", "citeRegEx": "Minsky 1967", "shortCiteRegEx": null, "year": 1967}, {"title": "Verification of data-aware commitment-based multiagent systems", "author": ["Calvanese Montali", "M. De Giacomo 2014] Montali", "D. Calvanese", "G. De Giacomo"], "venue": "In Proc. of the 13th Int. Conf. on Autonomous Agents and Multiagent Systems (AAMAS),", "citeRegEx": "Montali et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Montali et al\\.", "year": 2014}, {"title": "and Pistore", "author": ["U. Montanari"], "venue": "M.", "citeRegEx": "Montanari and Pistore 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "and Calvanese", "author": ["O. Savkovic"], "venue": "D.", "citeRegEx": "Savkovic and Calvanese 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "1980", "author": ["Smith", "R. G"], "venue": "The contract net protocol: High-level communication and control in a distributed problem solver. IEEE Transactions on Computers 29(12):1104\u2013", "citeRegEx": "Smith 1980", "shortCiteRegEx": null, "year": 1113}], "referenceMentions": [], "year": 2014, "abstractText": "We study the extension of relational multiagent systems (RMASs), where agents manipulate full-fledged relational databases, with data types and facets equipped with domainspecific, rigid relations (such as total orders). Specifically, we focus on design-time verification of RMASs against rich firstorder temporal properties expressed in a variant of first-order \u03bc-calculus with quantification across states. We build on previous decidability results under the \u201cstate-bounded\u201d assumption, i.e., in each single state only a bounded number of data objects is stored in the agent databases, while unboundedly many can be encountered over time. We recast this condition, showing decidability in presence of dense, linear orders, and facets defined on top of them. Our approach is based on the construction of a finite-state, sound and complete abstraction of the original system, in which dense linear orders are reformulated as non-rigid relations working on the active domain of the system only. We also show undecidability when including a data type equipped with the successor relation.", "creator": "LaTeX with hyperref package"}}}