{"id": "1412.1042", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Dec-2014", "title": "A CSP implementation of the bigraph embedding problem", "abstract": "A crucial problem for many results and tools about bigraphs and bigraphical reactive systems is bigraph embedding. An embedding is more informative than a bigraph matching, since it keeps track of the correspondence between the various components of the redex (guest) within the agent (host). In this paper, we present an algorithm for computing embeddings based on a reduction to a constraint satisfaction problem (LAP).\n\n\n\nThe first part of this paper presents the main concepts of embedding, and then introduces them to the application of the bigraph. We summarize how we are able to embedding systems in the Bigraphs (see the previous part of this paper).", "histories": [["v1", "Mon, 1 Dec 2014 08:52:16 GMT  (97kb,D)", "http://arxiv.org/abs/1412.1042v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["marino miculan", "marco peressotti"], "accepted": false, "id": "1412.1042"}, "pdf": {"name": "1412.1042.pdf", "metadata": {"source": "META", "title": "A CSP implementation of the bigraph embedding problem", "authors": ["Marino Miculan", "Marco Peressotti"], "emails": ["marino.miculan@uniud.it", "marco.peressotti@uniud.it"], "sections": [{"heading": "1 Introduction", "text": "Bigraphical Reactive Systems (BRSs) [14, 19] are a flexible and expressive meta-model for ubiquitous computation. System states are represented by bigraphs, which are compositional data structures describing at once both the locations and the logical connections of (possibly nested) components of a system. Like graph rewriting [24], the dynamic behaviour of a system is defined by a set of (parametric) reaction rules, which can modify a bigraph by replacing a redex with a reactum, possibly changing agents\u2019 positions and connections.\nBRSs have been successfully applied to the formalization of a broad variety of domain-specific calculi and models, from traditional programming languages to process calculi for concurrency and mobility, from context-aware systems to web-service orchestration languages, from business processes to systems biology; a non exhaustive list is [2,4,5,8,16,18]. Very recently bigraphs have been used in structure-aware agent-based computing for modelling the structure of the (physical) world where the agents operates (e.g., drones, robots, etc.) [20].\nBeside their normative and expressive power, BRSs are appealing because they provide a range of interesting general results and tools, which can be readily instantiated with the specific model under scrutiny: simulation tools, systematic construction of compositional bisimulations [14], graphical editors [9], general model checkers [23], modular composition [22], stochastic extensions [15], etc.\nIn this paper, we give an implementation for a crucial problem that virtually all these tools have to deal with, i.e., the matching a bigraph inside an agent. Roughly, this can be stated as follows: given R and A, we have to find (all, or some) C,D such that A = C \u25e6 R \u25e6D. Clearly this is required by any simulation tool (in order to apply a reaction rule, we have to match the redex inside the agent, and then replace it with the reactum), but also in other tools, e.g., for implementing \u201cfind&replace\u201d in graphical editors, for occurrence checks in sortings [1] and model checkers, for refinements in architectural design tools, etc.\nar X\niv :1\n41 2.\n10 42\nv1 [\ncs .L\nO ]\n1 D\nec 2\n01 4\nLike the similar and well-known subgraph isomorphism problem, bigraph matching is NPcomplete (see [3]). However, using the theory of Fixed Parameter Tractability it can be shown that the exponential explosion depends only on the size (more precisely, the width) of the redex to be found, and not on the size of the agent. In most practical cases, this width is constant and small (e.g. \u2264 3), hence the problem becomes feasible.\nA (rather ad-hoc) implementation of bigraph matching has been given in the BPLTool [7]; this was based on a term-based representation of agents and rules, in the spirit of term rewriting systems. More recently, a more graphical-oriented approach has been preferred. H\u00f8jsgaard have introduced the notion of bigraph embedding [11], which is a function from nodes and edges of the redex to nodes and edges of the agent, describing how the former is embedded in the latter. Although embeddings and matchings are basically equivalent, embeddings turn out to be more useful especially in connection with Gillespie-like algorithms for stochastic simulations [11], because they allow for a simpler calculation of interference between redexes. In fact, embeddings are at the core of the Bigraphic Abstract Machine [21], a general abstract machine for implementing various kinds of BRSs, with several possible execution strategies.\nFor these reasons, in this paper we focus on the bigraph embedding problem. More precisely, we translate the embedding problem to a constraint satisfaction problem (CSP), whose solutions correspond to bigraph embeddings. Instead of defining directly a CSP for the bigraph embedding problem we take advantage of bigraphs being the \u201cmerge\u201d of two graphical structures (called link graphs and place graphs respectively): initially we define the encoding for embeddings of these two orthogonal structures separately and then combine them by means of some consistency constraints reflecting the interplay between link and place structures. This split mimics the peculiar structure of bigraphs and allows us to factor the exposition of the problem, its encoding and the accompanying adequacy results. An implementation based on the CHOCO solver is available in LibBig (available at http://mads.dimi.uniud.it/), an extensible library for manipulating bigraphical reactive systems. However, this is an implementation choice mainly due to the use of Java, but the results of this paper can be implemented in any solver capable of handling the integer solutions of a linear equation system.\nWe do not provide an exhaustive discussion of experimental results because the encoding proposed is \u201csolver-independent\u201d and moreover, because there is no widely-acknowledged benchmark suit for this problem. In fact, finding a reasonably representative set of instances still is an open question.\nSynopsis In Section 2 we briefly recall the notion of bigraphs and bigraphical reactive systems and in Section 3 present the bigraph embedding problem, its complexity and how it can be divided in two sub-problems, by taking advantage of the components of bigraphs. The implementation of the bigraph embedding problem as a constraint satisfaction problem and the adequacy results are presented in Sections 4. Conclusions, with some experimental evaluations, and some directions for future work are in Section 5."}, {"heading": "2 Bigraphical reactive systems", "text": "In this section we briefly recall the notion of Bigraphical Reactive Systems (BRS) referring the interested reader to [19].\nThe key point of BRSs is that \u201cthe model should consist in some sort of reconfigurable space\u201d. Agents may interact in this space, even if they are spatially separated. This means that two agents may be adjacent in two ways: they may be at the same place, or they may be connected by a link. This leads to the definition of bigraphs as a data structure for representing the state of the\nsystem. A bigraph can be seen as enriched hyper-graph combining two independent graphical structures over the same set of nodes: a hierarchy of places, and a hyper-graph of links.\nDefinition 1 (Bigraph [19, Def. 2.3]). A bigraph graph G over a given signature \u03a3 (i.e. a set of types, called controls, denoting a finite arity) is a an object\n(VG, EG, ctrlG, prntG, linkG) : \u3008nG, XG\u3009 \u2192 \u3008mG, YG\u3009\ncomposed by two substructures (Figure 1): a place graph GP = (VG, ctrlG, prntG) : nG \u2192 mG and a link graph GL = (VG, EG, ctrlG, linkG) : XG \u2192 YG. The set VG is a finite set of nodes and to each of them is assigned a control in \u03a3 by the control map ctrlG : VG \u2192 \u03a3. The set EG is a finite set of names called edges.\nThese structures presents an inner interface (composed by nG and XG) and an outer one (mG, YG) along which can be composed with other of their kind as long as they do not share any node or edge. In particular, XG and YG are finite sets of names and nG and mG are finite ordinals that index sites and roots respectively.\nOn the side of GP , nodes, sites and roots are organized in a forest described by the parent map prntG : VG \u228e nG \u2192 VG \u228emG such that sites are leaves and roots are exactly mG.\nOn the side of GL, nodes, edges and names of the inner and outer interface forms a hypergraph described by the link map linkG : PG \u228eXG \u2192 EG \u228e YG which is a function from XG and ports PG (i.e. elements of the finite ordinal associated to each node by its control) to edges EG and names in YG.\nThe dynamic behaviour of a system is described in terms of reactions of the form a _ a\u2032 where a, a\u2032 are agents, i.e. bigraphs with inner interface \u30080, \u2205\u3009. Reactions are defined by means of graph rewrite rules, which are pairs of bigraphs (RL, RR) equipped with a function \u03b7 from the sites of RR to those of RL called instantiation rule. A bigraphical encoding for the open reaction rule of the Ambient Calculus is shown in Figure 2 where redex and reactum are the bigraph on the left and the one on the right respectively and the instantiation rule is drawn in red. A rule fires when its redex can be embedded into the agent; then, the matched part is replaced by the reactum and the parameters (i.e. the substructures determined by the sites of the redex) are instantiated accordingly with \u03b7."}, {"heading": "3 Bigraph embeddings", "text": "In this Section we briefly recall the notion of bigraph embedding. The following definitions are taken from [11], with minor modification to simplify the presentation of the equivalent CSP\n] ]\n] ]\n0 open\n1\namb\nx\n0 1\nx\nopenx. 0 \u2016 ambx. 1 _ 0 \u2016 1\nFigure 2: Open reaction rule of the Ambient Calculus.\nformulation (cf. Section 4). As usual, we shall exploit the orthogonality of the link and place graphs, by defining link and place graph embeddings separately and then combine them to extend the notion to bigraph.\nLink graph Intuitively an embedding of link graphs is a structure preserving map from one link graph (the guest) to another (the host). As one would expect from a graph embedding, this map contains a pair of injections: one for the nodes and one for the edges (i.e., a support translation). The remaining of the embedding map specifies how names of the inner and outer interfaces should be mapped into the host link graph. Outer names can be mapped to any link; here injectivity is not required since a context can alias outer names. Dually, inner names can mapped to hyper-edges linking sets of points in the host link graph and such that every point is contained in at most one of these sets.\nDefinition 2 (Link graph embedding [11, Def 7.5.1]). Let G : XG \u2192 YG and H : XH \u2192 YH be two concrete link graphs. A link graph embedding \u03c6 : G \u2192\u0592 H is a map \u03c6 , \u03c6v \u228e \u03c6e \u228e \u03c6i \u228e \u03c6o (assigning nodes, edges, inner and outer names respectively) subject to the following conditions:\n(LGE-1) \u03c6v : VG  VH and \u03c6e : EG  EH are injective;\n(LGE-2) \u03c6i : XG  \u2118(XH \u228e PH) is fully injective: \u2200x 6= x\u2032 : \u03c6i(x) \u2229 \u03c6i(x\u2032) = \u2205;\n(LGE-3) \u03c6o : YG \u2192 EH \u228e YH in an arbitrary partial map; (LGE-4) img(\u03c6e) \u2229 img(\u03c6o) = \u2205 and img(\u03c6port) \u2229\u22c3 img(\u03c6i) = \u2205; (LGE-5) \u03c6p \u25e6 link\u22121G \u2223\u2223 EG = link\u22121H \u25e6 \u03c6e;\n(LGE-6) ctrlG = ctrlH \u25e6 \u03c6v;\n(LGE-7) \u2200p \u2208 XG \u228e PG : \u2200p\u2032 \u2208 (\u03c6p)(p) : (\u03c6h \u25e6 linkG)(p) = linkh(p\u2032)\nwhere \u03c6p , \u03c6i \u228e \u03c6port, \u03c6h , \u03c6e \u228e \u03c6o and \u03c6port : PG  PH is \u03c6port(v, i) , (\u03c6v(v), i)).\nThe first three conditions are on the single sub-maps of the embedding. Condition (LGE-4) ensures that no components (except for outer names) are identified; condition (LGE-5) imposes that points connected by the image of an edge are all covered. Finally, conditions (LGE-6) and (LGE-7) ensure that the guest structure is preserved i.e. node controls and point linkings are preserved.\nFigure 2: pen reaction rule of the bient alculus.\nfor ulation (cf. Section 4). s usual, e shall exploit the orthogonality of the link and place graphs, by defining link and place graph e beddings separately and then co bine the to extend the notion to bigraph.\nLink graph Intuitively an e bedding of link graphs is a structure preserving ap fro one link graph (the guest) to another (the host). s one would expect fro a graph e bedding, this ap contains a pair of injections: one for the nodes and one for the edges (i.e., a support translation). The re aining of the e bedding ap specifies how na es of the inner and outer interfaces should be apped into the host link graph. uter na es can be apped to any link; here injectivity is not required since a context can alias outer na es. ually, inner na es can\napped to hyper-edges linking sets of points in the host link graph and such that every point is contained in at ost one of these sets.\nefinition 2 (Link graph e bedding [11, ef 7.5.1]). Let : G YG and : H YH be two concrete link graphs. A link graph e bedding \u03c6 : \u21aa is a ap \u03c6 \u03c6v ] \u03c6e ] \u03c6i ] \u03c6o (assigning nodes, edges, inner and outer na es respectively) subject to the following conditions:\n(L -1) \u03c6v : VG VH and \u03c6e : EG EH are injective;\n(L -2) \u03c6i : G \u2118( H ] PH) is fully injective: \u2200x 6 x\u2032 : \u03c6i(x) \u2229 \u03c6i(x\u2032) \u2205;\n(L -3) \u03c6o : YG EH ] YH in an arbitrary partial ap;\n(L E-4) i g(\u03c6e) \u2229 i g(\u03c6o) \u2205 and i g(\u03c6port) \u2229 i g(\u03c6i) \u2205; (L E-5) \u03c6p \u25e6 link\u22121G \u2223\u2223 EG link\u22121H \u25e6 \u03c6e;\n(L E-6) ctrlG ctrlH \u25e6 \u03c6v;\n(L E-7) \u2200p \u2208 G ] PG : \u2200p\u2032 \u2208 (\u03c6p)(p) : (\u03c6h \u25e6 linkG)(p) linkh(p\u2032)\nwhere \u03c6p \u03c6i ] \u03c6port, \u03c6h \u03c6e ] \u03c6o and \u03c6port : PG PH is \u03c6port(v, i) (\u03c6v(v), i)).\nThe first three conditions are on the single sub- aps of the e bedding. Condition (L E-4) ensures that no co ponents (except for outer na es) are identified; condition (L E-5) i poses that points connected by the i age of an edge are all covered. Finally, conditions (L E-6) and (L E-7) ensure that the guest structure is preserved i.e. node controls and point linkings are preserved.\nPlace graph Like link graph embeddings, place graph embeddings are just a structure preserving injective map from nodes along with suitable maps for the inner and outer interfaces. In particular, a site is mapped to the set of sites and nodes that are \u201cput under it\u201d and a root is mapped to the host root or node that is \u201cput over it\u201d splitting the host place graphs in three parts: the guest image, the context and the parameter (which are above and below the guest image).\nDefinition 3 (Place graph embedding [11, Def 7.5.4]). Let G : nG \u2192 mG and H : nH \u2192 mH be two concrete place graphs. A place graph embedding \u03c6 : G \u21aa\u2192 H is a map \u03c6 , \u03c6v ] \u03c6s ] \u03c6r (assigning nodes, sites and regions respectively) subject to the following conditions:\n(PGE-1) \u03c6v : VG VH is injective;\n(PGE-2) \u03c6s : nG \u2118(nH ] VH) is fully injective;\n(PGE-3) \u03c6r : mG \u2192 VH ]mH in an arbitrary map; (PGE-4) img(\u03c6v) \u2229 img(\u03c6r) = \u2205 and img(\u03c6v) \u2229\u22c3 img(\u03c6s) = \u2205;\n(PGE-5) \u2200r \u2208 mG : \u2200s \u2208 nG : prnt\u2217H \u25e6 \u03c6r(r) \u2229 \u03c6s(s) = \u2205; (PGE-6) \u03c6c \u25e6 prnt\u22121G \u2223\u2223 VG = prnt\u22121H \u25e6 \u03c6v;\n(PGE-7) ctrlG = ctrlH \u25e6 \u03c6v;\n(PGE-8) \u2200c \u2208 nG ] VG : \u2200c\u2032 \u2208 \u03c6c(c) : (\u03c6f \u25e6 prntG)(c) = prntH(c\u2032); where prnt\u2217H(c) = \u22c3 i<\u03c9 prnt i(c), \u03c6f , \u03c6v ] \u03c6r, and \u03c6c , \u03c6v ] \u03c6s.\nConditions in the above definition follows the structure of Definition 2, the main notable difference is (PGE-5) which states that the image of a root can not be the descendant of the image of another. Conditions (PGE-1), (PGE-2) and (PGE-3) are on the three sub-maps composing the embedding; conditions (PGE-4) and (PGE-5) ensure that no components are identified; (PGE-6) imposes surjectivity on children and the last two conditions require the guest structure to be preserved by the embedding map.\nBigraph Finally, bigraph embeddings can now be defined as maps being composed by an embedding for the link graph with one for the place graph consistently with the interplay of these two substructures. In particular, the interplay is captured by a single additional condition ensuring that points in the image of an inner names reside in the parameter defined by the place graph embedding (i.e. are inner names or ports of some node under a site image).\nDefinition 4 (Bigraph embedding [11, Def 7.5.14]). Let G : \u3008nG, XG\u3009 \u2192 \u3008mG, YG\u3009 and H : \u3008nH , XH\u3009 \u2192 \u3008mH , YH\u3009 be two concrete bigraphs. A bigraph embedding \u03c6 : G \u21aa\u2192 H is a map given by a place graph embedding \u03c6P : GP \u21aa\u2192 HP and a link graph embedding \u03c6L : GL \u21aa\u2192 HL subject to the consistency condition:\n(BGE-1) img(\u03c6i) \u2286 XH ] {(v, i) \u2208 PH | \u2203s \u2208 nG : k \u2208 N : prntkH(v) \u2208 \u03c6s(s)}.\nNP-completeness Despite their apparent complexity, the conditions maps have to satisfy to be considered bigraph embeddings may give some information and guidance in the construction of these maps. However the problem remains NP-complete as demonstrated in [3]. We recall their results to make this paper self contained. The authors focus on labelled forest embedding which covers the case of place graphs embeddings but not link graphs. In Section 4.1 we prove that the link graph embedding problem corresponds to an admissibility problem for a specific flow network. Therefore, the result presented in [3] will suffice to justify our approach.\nTo prove that the labelled forest pattern is NP-complete, in [3, \u00a73] a reduction from 3-Sat is provided. The proposed reduction uses the RainbowAntichain problem as a middle step (introduced in loc. cit.). An instance of this problem is a tree T (V, E) with nodes V and edges E , and a finite set of colours P, said palette. Some of the nodes in T have been coloured with one or more colours taken from P. The problem asks to decide whatever exists a colourful subset of nodes R \u2282 V where each colour c of P has exactly one representative node coloured with c and for no pair of u, v \u2208 R of distinct nodes u is an ancestor of v.\nTheorem 1 ([3, Th. 8]). The RainbowAntichain problem is NP-complete.\nIt is the straightforward to see that an instance T , P = (c0, . . . , cn\u22121) of RainbowAntichain can be reduced to a forest pattern matching, namely, one that embeds the forest (c0[0], . . . , cn\u22121[n \u2212 1]) \u2013 every tree has only a node, labelled with a colour of the palette, and a hole/site \u2013 into T . This states that the forest pattern matching problem is NP-complete. Formally,\nTheorem 2 ([3, Th. 9]). The labelled forest embedding problem is NP-complete.\nThis proves that deciding the existence of a place graph embedding (which can be seen as labelled forest pattern matching) of a given guest into a given host is NP-complete. Moreover, we are interested in listing all of them thus making CSP a viable approach."}, {"heading": "4 Implementing the embedding problem in CSP", "text": "In this Section we present the main contribution of the paper i.e. a constraint satisfaction problem that models bigraph embedding problem. The encoding is based solely on integer linear constraints and is proven to be sound and complete.\nInitially, we present the encoding for the link graph embedding problem and for the place graph embedding problem. Then we combine them providing some additional \u201cgluing constraints\u201d to ensure the consistency of the two sub-problems. The resulting encodings contains 34 constraint families (reflecting the size of the problem definition, cf. in Section 3) and hence taking advantage of the orthogonality of link and place structures is mandatory for the sake of both exposition and adequacy proofs. We shall remark that, despite the constraint families are quite numerous, the overall number of variables and constraints produced by the encoding is polynomially bounded with respect to the support cardinality of the involved bigraphs."}, {"heading": "4.1 Link Graphs", "text": "Let us fix the guest and host concrete bigraphs: G : XG \u2192 YG and H : XH \u2192 YH . We characterize the embeddings of G into H as the solutions of a suitable multi-flux problem which we denote as LGE[G,H]. The main idea is to see the host points (i.e. ports and inner names) and handles (i.e. edges and outer names) as sources and sinks respectively: each point outputs a flux unit and each handle inputs one unit for each point it links. Units flows towards each point\nhandle following H hyper-edges and optionally taking a \u201cdetour\u201d along the linking structure of the guest G (provided that some conditions regarding structure preservation are met). Figure 3 and Figure 4 contain a sketch of the flux problem and its formal definition respectively.\nThe flux network reflects the linking structure and contains an edge connecting each point to its handle; these edges have an integer capacity limited to 1 and are represented by the variables defined in (2). The remaining edges of the network are organised in two complete biparted graphs: one between guest and host handles and one between guest and host points. Edges of the first sub-network are described by the variables in (1) and their capacity is bounded by the number of points linked by the host handle since this is the maximum acceptable flux and corresponds to the case where each point passes through the same hyper-edge of the guest link graph. Edges of the second sub-network are described by the variables in (3) and, like the first group of links, have their capacity limited to 1; to be precise, some of these variables will never assume a value different from 0 because host points can receive flux from anything but the host ports (as expressed by constraint (9)). Edges for the link structure of the guest are presented implicitly in the flux preservation constraints (see constraint (7)). In order to fulfil the injectivity conditions of link embeddings, some additional flux variables (whereas the previous are network variables) are defined by (4). These are used to keep track and separate each flux on the bases of the points handle1.\nThe constraint families (5) and (6) define the outgoing and ingoing flux of host points and handles respectively. The firsts have to send exactly one unit considering every edge they are involved into and the seconds receive one unit for each of their point regardless if this unit comes from the point directly or from a handle of the guest.\nThe linking structure of the guest graph is encoded by the constraint family (7) which states that flux is preserved while passing through the guest i.e. the output of each handle has to match the overall input of the points it connects.\nConstraints (8), (9), (18), (19) and (20) shape the flux in the sub-network linking guest and host points. Specifically, (8) requires that each point from the guest receives exactly one unit or, the other way round, that guest points are assigned with disjoint sets of points from the host.\n1The problem can be presented without the additional flux variables, but we found this approach more readable.\nConstraints (9), (18) and (19) disable edges between guest ports and host inner names, between mismatching ports of matching nodes and between ports of mismatching nodes. Finally, the flux of ports belonging to the same node has to act compactly i.e. if there is flux between the i-th ports of two nodes, then, there should be flux between every other matching ports as expressed by (20).\nConstraints (10), (11) and (12) relates flux and network variables ensuring that the formers assume a true value if, and only, if there is actual flux between the corresponding guest and host handles. In particular, (11) propagates the information about the absence of flux between handles disabling the sub-network linking handles points and, vice versa, (12) propagates the information in the other way disabling flux between handles if there is no flux between their points.\nThe remaining constraints prevent fluxes from mixing. Constraint (13) requires guest handles to send their output to exactly one destination thus renders the sub-network between handles a function assigning guest handles to host handles. This mapping is subject to some additional conditions when edges are involved: (16) and (17) ensure that the edges are injectively mapped to edges only, (15) forbids host outer names to receive flux from an edge and an outer name at the same time. Finally, constraint (14) states that the output of host points cannot bypass the guest if there is flux between its handle and an edge from the guest.\nAdequacy Let ~N be a solution of LGE[G,H]. The corresponding link graph embedding \u03c6 : G \u21aa\u2192 H is defined as follows:\n\u03c6v(v) , v\u2032 \u2208 VH : \u2203i : N(v,i),(v\u2032,i) = 1 \u03c6e(e) , e\u2032 \u2208 EH : Fe,e\u2032 = 1 \u03c6o(y) , y\u2032 \u2208 YH : Fy,y\u2032 = 1 \u03c6i(x) , {x\u2032 \u2208 XH ] PH | Nx\u2032,x = 1}\nThe components of \u03c6 just defined are well-given and compliant with Definition 2. On the other way round, let \u03c6 : G \u21aa\u2192 H be a link graph embedding. The corresponding solution ~N of LGE[G,H] is defined as follows:\nNp,p\u2032 ,    1 if p\u2032 \u2208 XG \u2227 p \u2208 \u03c6i(p\u2032) 1 if p\u2032 = (v, i) \u2227 p = (\u03c6v(v), i) 0 otherwise Np,h\u2032 , {\n1 if h\u2032 = linkHp \u2227 @p\u2032 : Np,p\u2032 = 1 0 otherwise\nNh,h\u2032 ,    1 if h \u2208 EH \u2227 h\u2032 \u2208 EG \u2227 h = \u03c6e(h\u2032) 1 if h \u2208 YH \u2227 h\u2032 \u2227 h = \u03c6o(h\u2032) 0 otherwise\nClearly Fh,h\u2032 = 1 4\u21d0\u21d2 Nh,h\u2032 6= 0. Then it is easy to check that every constraint of LGE[G,H] is satisfied by the solution just defined. The constraint satisfaction problem in Figure 4 is sound and complete with respect to the link graph embedding problem given in Definition 2.\nProposition 3 (Adequacy of LGE). For any two concrete link graphs G and H, there is a bijective correspondence between the link graph embeddings of G into H and the solutions of LGE[G,H]."}, {"heading": "4.2 Place Graphs", "text": "Let us fix the guest and host place graphs: G : nG \u2192 mG and H : nH \u2192 mH . We characterize the embeddings of G into H as the solutions of the constraint satisfaction problem in Figure 5.\nThe problem is a direct encoding of Definition 3 as a matching problem presented, as usual, as a biparted graph. Sites, nodes and roots of the two place graphs are represented as nodes and parted into the guest and the host ones. For convenience of exposition, graph is complete.\nEdges are modelled by the boolean variables defined in (21); these are the only variables used by the problem. So far a solution is nothing more than a relation between the components of guest and host containing only those pairs connected by an edge assigned a non-zero value. To capture exactly those assignments that are actual place graph embeddings some conditions have to be imposed.\nConstraints (22) and (23) prevent roots and sites from the host to be matched with nodes or sites and nodes or roots respectively. (24) disables matching between nodes decorated with different controls. Constraint (25) prevents any matching for host nodes under a passive context (i.e. have an ancestor labelled with a passive control). (26) propagates the matching along the parent map from children to parents. Constraints (27) and (28) ensure that the matching is a function when restricted to guest nodes and roots (the codomain restriction follows by (22) and\n(23)). (29) says that if a node from the host cannot be matched with a root or a node/site from the guest at the same time; moreover, if the host node is matched with a node then it cannot be matched to anything else.\nThe remaining constraints are the counterpart of (26) and propagate matchings from parents to children. (30) applies on matchings between nodes and says that if parents are matched, then children from the host node are covered by children from the guest node. In particular, the matching is a perfect assignment when restricted to guest children that are nodes (because of (29)) and is a surjection on those that are sites. (31) imposes a similar condition on matchings between guest roots and host nodes. Specifically, it says that the matching have to cover child nodes from the guest (moreover, it is injective on them) leaving child sites to match whatever remains ranging from nothing to all unmatched children. Finally, (32) prevent matching from happening inside a parameter.\nAdequacy Let ~M be a solution of PGE[G,H]. The corresponding place graph embedding \u03c6 : G \u21aa\u2192 H is defined as follows:\n\u03c6v(g) , h \u2208 VH : \u2203i : Mh,g = 1 \u03c6s(g) , {h \u2208 nh ] VH |Mh,g = 1} \u03c6r(g) , h \u2208 mH ] VH : Mh,g = 1\nThe components of \u03c6 just defined are well-given and compliant with Definition 3. On the opposite direction, let \u03c6 : G \u21aa\u2192 H be a place graph embedding. The corresponding solution ~M of PGE[G,H] is defined as follows:\nMh,g ,    1 if g \u2208 VG \u2227 h = \u03c6v(g) 1 if g \u2208 mG \u2227 h = \u03c6r(g) 1 if g \u2208 nG \u2227 h \u2208 \u03c6s(g) 0 otherwise\nIt is easy to check that every constraint of PGE[G,H] is satisfied by the solution just defined. The constraint satisfaction problem in Figure 5 is sound and complete with respect to the place graph embedding problem given in Definition 3.\nProposition 4 (Adequacy of PGE). For any two concrete place graphs G and H, there is a bijective correspondence between the place graph embeddings of G into H and the solutions of PGE[G,H]."}, {"heading": "4.3 Bigraphs", "text": "Let G : \u3008nG, XG\u3009 \u2192 \u3008mG, YG\u3009 and H : \u3008nH , XH\u3009 \u2192 \u3008mH , YH\u3009 be two concrete bigraphs. By taking advantage of the orthogonality of the link and place structure we can define the constraint satisfaction problem capturing bigraph embeddings by simply composing the constraints given above for the link and place graph embeddings and by adding just two consistency constraints to relate the solutions of the two problems.\nThese additional constraint families are reported in Figure 6. The family (33) ensures that solutions for LGE[G,H] and PGE[G,H] agree on nodes since the map \u03c6v has to be shared by the corresponding link and place embeddings. The family (34) ensures that ports are in the image of inner names (i.e. send their flux unit to them) only if their node is part of the parameter i.e. only if it is matched to a site from the guest or it descends from a node that is so.\nIt is easy to check that (34) corresponds exactly to condition (BGE-1). Therefore, from Proposition 3 and Proposition 4, the constraint satisfaction problem defined by Figures 4, Figure 5 and Figure 6 is sound and complete with respect to the bigraph embedding problem given in Definition 4 as stated by below.\nProposition 5 (Adequacy of BGE). For any two concrete bigraphs G and H, there is a bijective correspondence between the bigraph embeddings of G into H and the solutions of BGE[G,H]."}, {"heading": "5 Conclusions and future works", "text": "In this paper, we have presented a sound and complete algorithm for solving the bigraph embedding problem, based on a constraint satisfaction problem. The resulting model is compact and composed by a number of variables and linear constraints, polynomially bounded by the size of the guest and host bigraphs. Remarkably, this algorithm does not require hosts to be ground.\nThe CSP approach offers a great flexibility, e.g. allowing to move execution strategies upstream into CSP calculation. An example can be found in this paper: in practice, the notion of active/passive contexts defines an execution strategy.\nThis approach naturally suggests several interesting extensions of the bigraphic model itself. We can think of weighted bigraphs, where nodes and edges can be given \u201cweights\u201d, and firing a rule has a cost related to the nodes involved. This extension would lead us to consider \u201capproximated embeddings\u201d: a guest can be embedded up-to some distance based on costs (e.g. missing controls, or quantitative differences between controls,. . . ). In both cases, our implementation can be straightforwardly adapted just by adding a cost function, in order to give the optimal matchings; this would be far more efficient and easier to implement than dealing with these issues at the level of strategies (if possible at all).\nThe proposed approach can be easily applied also to extensions of the bigraphs, e.g. directed bigraphs [10], bigraphs with sharing [6] or local bigraphs. An interesting direction would be to extend the algorithm also to stochastic and probabilistic bigraphs [15] which will offer useful modelling and verification tools for quantitative aspects, e.g. for biological problems [2, 8].\nThe algorithm has been successfully integrated into LibBig, an extensible library for manipulating bigraphical reactive systems. This library can be used for implementing a wide range of tools and it can be adapted to support several extensions of bigraphs. Approximated and weighted embeddings are supported too but are still an experimental feature. In fact, the theoretical foundations and implications of these extensions have not been fully investigated yet suggesting another line of research.\nThe empirical evaluation of the implementation available in LibBig looks promising. It cannot be considered a rigorous experimental validation mainly because performance depends on the solver, and the model is not optimized for any particular solver. Moreover, up to now there are no \u201cofficial\u201d (or \u201cwidely recognized\u201d) benchmarks for the bigraph embedding problem. An algorithm for the bigraph matching problem is proposed in [7], based on a translation into a term\nmatching problem; this algorithm is at the core of BPLTool. In [25] Sevegnani et. al. presented a SAT based algorithm for deciding the matching problem in bigraphs with sharing. To the best of the authors knowledge, the approach of [25] is the nearest to the solution presented in this paper. However, an accurate and fair comparison of algorithms for computing bigraph embeddings/matchings is difficult because of the aforementioned reasons and because of the different bigraph variants these algorithms deal with (e.g., the matching algorithm of the model checker BigMC does not support inner names).\nA decentralized algorithm for computing bigraphical embeddings has been proposed in [17] and is at the core of the distributed bigraphical machine.\nAcknowledgements We thank Alessio Mansutti and the participants to MeMo\u201914 for fruitful discussions on preliminary version of this paper. This work is partially supported by MIUR PRIN project 2010LHT4KM, CINA."}, {"heading": "A NP-completeness of the bigraph embedding problem", "text": "In [3] the authors proved that the labelled forest embedding problem is NP-Complete. This result covers the case of place graphs embeddings but not link graphs. However, the latter correspond to an admissibility problem for a specific flow network and hence their results will suffice to justify our approach.\nTo prove that the labelled forest pattern is NP-complete, in [3, \u00a73] a reduction from 3-Sat is provided. The proposed reduction uses the RainbowAntichain problem as a middle step. An instance of this problem (introduced in [3]) is a tree T (V, E) with nodes V and edges E , and a finite set of colours P, said palette. Some of the nodes in T have been coloured with one or more colours taken from P. The problem asks to decide whatever exists a colourful subset of nodes R \u2282 V where each colour c of P has exactly one representative node coloured with c and for no pair of u, v \u2208 R of distinct nodes u is an ancestor of v.\nTheorem 6 ([3, Th. 8]). The RainbowAntichain problem is NP-complete.\nProof. RainbowAntichain is in NP, since, given a set of nodes R, checking whatever R us a rainbow anti-chain for T can be easily done in polynomial time by breadth-first visit of T , and for each v \u2208 R found, firsti increase the node counter nc, then the colour counter p[i] (with 1 \u2264 i \u2264 |P|) if v has a colour ci \u2208 P. The check fails whether nc > |P| or p[j] = 0 for some j, otherwise R is a rainbow anti-chain for T .\nLet C = {c1, . . . cm} be an instance of 3-Sat on variables {x1, . . . , xn}. From C we define a coloured tree T as follows. Let r be the root node which is left uncoloured. For each variable xi let xi and x\u0304i be child nodes of r, and color them with fresh colour cxi , distinct for each variable. For each clause cj \u2208 C. let c1j , c2j and c3j be children nodes of li in T if cj contains li as negated, and assign to each of them a fresh colour ccj , distinct for each clause. An example of construction for c1 = (x\u03041 \u2228 x2 \u2228 x\u03043), c2 = (x1 \u2228 x2 \u2228 x3) is shown below.\nr\nx1\nc11\nx\u03041\nc12\nx2 x\u03042\nc21 c 2 2\nx3\nc31\nx\u03043\nc32\nLet \u03d5 be a truth assignment satisfying the formula C. By construction, selecting only literal nodes li which are satisfied by \u03d5, we obtain a rainbow anti-chain R\u2032 in T for the palette {cxi | 1 \u2264 i \u2264 n}. Now, we extend R\u2032 to R adding all clause nodes which are not children of an element in R\u2032. Such R is clearly an anti-chain for T , but we must ensure that is colourful and no more than one representative per colour is taken. To do this, it suffices to prove that R is colourful, indeed if a colour occurs more than one in R we remove the others. By hypothesis, each clause cJ is satisfied by \u03d5, hencecJ has at least one literal li such that \u03d5(li) is true. By construction of T , there exist a node ckj , with 1 \u2264 k \u2264 3, child of l\u0304i, hence already in R. This holds for all clauses cj , hence R is colourful.\nControversy, letR be a rainbow anti-chain for T . Let the boolean function \u03d5 over {x1, . . . , xn} be defined by \u03d5(xi) = T if xi is a node in R and \u03d5(xi) = F otherwise. Since R has exactly one representative per colour, no opposite literals are in R, hence \u03d5 is a truth assignment for C. By colourfulness of R, for all colours ccJ (1 \u2264 j \u2264 m) there exists a node ckj \u2208 R (1 \u2264 k \u2264 3) such that ckj has a colour ccj . By construction on T , each cKj \u2208 R is a children of a literal node li /\u2208 R,\nand moreover the clause cj contains l\u0304j . Since lj /\u2208 R, by definition \u03d5(l\u0304i) = T, hence \u03d5(cj) = T. This holds for all 1 \u2264 j \u2264 m, hence \u03d5 satisfies C.\nIn [3] labelled trees are described by terms of a language inspired to the ambient calculus and quotiented by the usual structural congruence. Then ambients corresponds to labelled subtrees; the null process to the empty tree; variables are leaves; parallel processes to siblings (with the additional requirement for disjoint variables to ensure a tree structure). This allows to represent grafting as (simultaneous) substitution. An embedding of a labelled forest (with variables #\u00bb\nZ) #\u00bb S ( #\u00bb\nZ) into a tree T (denoted as T #\u00bbS ) can be described by a tree C( #\u00bbX), said context, and a forest #\u00bb\nD, whose trees are called parameters, such that T \u2261 (C{ #\u00bbS/ #\u00bbX}){ #\u00bbD/ #\u00bbZ}. It is the straightforward to see that an instance T , P = (c0, . . . , cn\u22121) of RainbowAntichain can be reduced to a forest pattern matching, namely, one that embeds the forest (c0[0], . . . , cn\u22121[n \u2212 1]) \u2013 every tree has only a node, labelled with a colour of the palette, and a hole/site \u2013 into T . This states that the forest pattern matching problem is NP-complete. Formally,\nTheorem 7 ([3, Th. 9]). The labelled forest embedding problem is NP-complete.\nProof. Given a solution (C, #\u00bb D) for T #\u00bbS , checking that T \u2261 (C{ #\u00bbS/ #\u00bbX}){ #\u00bbD/ #\u00bbZ} corresponds to a tree isomorphism test, which is in P for [12, 13]. Let a coloured tree T and a palette P = {c1, . . . , cn} be and instance of the RainbowAntichain problem. Let us transform T into a tree term T as follows. If T is a single node v (a leaf) T is the empty tree labelled with m (m[nil]) where m = c if v has color c, otherwise m = \u2217, a fresh name not in P denoting an uncoloured node. If T has root r and T1, . . . , Tk are the (children) subtrees of r, T is m[T1| . . . |Tk], where m is as above for r, and T1, . . . , Tk are transformed trees of T1, . . . , Tk. Suppose (C, #\u00bb D) be a solution for T #\u00bbS = (c1[x1], . . . , ck[xn]). In C, each ci[xi] is grafted into a variable zi \u2208 vars(C). Since variables can appear in terms only as leaves, in the transformation T of T , we have found a rainbow anti-chain for P, since the matching forest #\u00bbS has all the colors in P exactly once.\nAssume that T has a rainbow anti-chain R. In order to recover context C and parameters #\u00bbD, which are a solution for T (c1[x1], . . . , ck[xn]), it suffices to apply the construction explained above with some adjustments: we obtain C applying the transformation from the root of T , but if a node in R is reached it is transformed by a fresh variable zi (1 \u2264 i \u2264 n) one for each element in R; Dj \u2019s are recovered applying the original transformation starting from the subtrees rooted at the children of nodes in R. It is straightforward to prove that T \u2261 (C{c1[x1]/z1, . . . , ck[xn]/ zn}){ #\u00bb D/ #\u00bb X}, for X = {x1, . . . , xn}.\nThis proves that deciding the existence of a place graph embedding (which can be seen as labelled forest pattern matching) of a given redex into an agent is NP-complete. Moreover, we are interested in listing all of them thus making CSP a viable approach."}], "references": [], "referenceMentions": [], "year": 2014, "abstractText": "<lb>A crucial problem for many results and tools about bigraphs and bigraphical reactive<lb>systems is bigraph embedding. An embedding is more informative than a bigraph matching,<lb>since it keeps track of the correspondence between the various components of the redex<lb>(guest) within the agent (host). In this paper, we present an algorithm for computing<lb>embeddings based on a reduction to a constraint satisfaction problem. This algorithm, that<lb>we prove to be sound and complete, has been successfully implemented in LibBig, a library<lb>for manipulating bigraphical reactive systems. This library can be used for implementing a<lb>wide range of tools, and it can be adapted to various extensions of bigraphs.", "creator": "LaTeX with hyperref package"}}}