{"id": "1412.5567", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Dec-2014", "title": "Deep Speech: Scaling up end-to-end speech recognition", "abstract": "We present a state-of-the-art speech recognition system developed using end-to-end deep learning. Our architecture is significantly simpler than traditional speech systems, which rely on laboriously engineered processing pipelines; these traditional systems also tend to perform poorly when used in noisy environments. In contrast, our system does not need hand-designed components to model background noise, reverberation, or speaker variation, but instead directly learns a function that is robust to such effects.\n\n\n\n\n\n\n\n\nThe authors declare that they have not yet achieved a final product that incorporates algorithms to recognize and respond to high-frequency, low-frequency, high-frequency, high-frequency, low-frequency, low-frequency, low-frequency, low-frequency, high-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-frequency, low-", "histories": [["v1", "Wed, 17 Dec 2014 20:39:45 GMT  (333kb,D)", "http://arxiv.org/abs/1412.5567v1", null], ["v2", "Fri, 19 Dec 2014 21:36:13 GMT  (333kb,D)", "http://arxiv.org/abs/1412.5567v2", null]], "reviews": [], "SUBJECTS": "cs.CL cs.LG cs.NE", "authors": ["awni hannun", "carl case", "jared casper", "bryan catanzaro", "greg diamos", "erich elsen", "ryan prenger", "sanjeev satheesh", "shubho sengupta", "adam coates", "andrew y ng"], "accepted": false, "id": "1412.5567"}, "pdf": {"name": "1412.5567.pdf", "metadata": {"source": "CRF", "title": "DeepSpeech: Scaling up end-to-end speech recognition", "authors": ["Awni Hannun", "Carl Case", "Jared Casper", "Bryan Catanzaro", "Greg Diamos", "Erich Elsen", "Ryan Prenger", "Sanjeev Satheesh", "Shubho Sengupta", "Adam Coates", "Andrew Y. Ng"], "emails": ["awnihannun@baidu.com"], "sections": [{"heading": "1 Introduction", "text": "Top speech recognition systems rely on sophisticated pipelines composed of multiple algorithms and hand-engineered processing stages. In this paper, we describe an end-to-end speech system, called \u201cDeepSpeech\u201d, where deep learning supersedes these processing stages. Combined with a language model, this approach achieves higher performance than traditional methods on hard speech recognition tasks while also being much simpler. These results are made possible by training a large recurrent neural network (RNN) using multiple GPUs and thousands of hours of data. Because this system learns directly from data, we do not require specialized components for speaker adaptation or noise filtering. In fact, in settings where robustness to speaker variation and noise are critical, our system excels: DeepSpeech outperforms previously published methods on the Switchboard Hub5\u201900 corpus, achieving 16.5% error, and performs better than commercial systems in noisy speech recognition tests.\nTraditional speech systems use many heavily engineered processing stages, including specialized input features, acoustic models, and Hidden Markov Models (HMMs). To improve these pipelines, domain experts must invest a great deal of effort tuning their features and models. The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models. While this improvement has been significant, deep learning still plays only a limited role in traditional speech pipelines. As a result, to improve performance on a task such as recognizing speech in a noisy environment, one must laboriously engineer the rest of the system for robustness. In contrast, our system applies deep learning end-to-end using recurrent neural networks. We take advantage of the capacity provided by deep learning systems to learn from large datasets to improve our overall performance. Our model is trained end-to-end to produce\n\u2217Contact author: awnihannun@baidu.com\nar X\niv :1\n41 2.\n55 67\nv1 [\ncs .C\nL ]\n1 7\nD ec\n2 01\ntranscriptions and thus, with sufficient data and computing power, can learn robustness to noise or speaker variation on its own.\nTapping the benefits of end-to-end deep learning, however, poses several challenges: (i) we must find innovative ways to build large, labeled training sets and (ii) we must be able to train networks that are large enough to effectively utilize all of this data. One challenge for handling labeled data in speech systems is finding the alignment of text transcripts with input speech. This problem has been addressed by Graves, Ferna\u0301ndez, Gomez and Schmidhuber [13], thus enabling neural networks to easily consume unaligned, transcribed audio during training. Meanwhile, rapid training of large neural networks has been tackled by Coates et al. [7], demonstrating the speed advantages of multi-GPU computation. We aim to leverage these insights to fulfill the vision of a generic learning system, based on large speech datasets and scalable RNN training, that can surpass more complicated traditional methods. This vision is inspired partly by the work of Lee et. al. [27] who applied early unsupervised feature learning techniques to replace hand-built speech features.\nWe have chosen our RNN model specifically to map well to GPUs and we use a novel model partition scheme to improve parallelization. Additionally, we propose a process for assembling large quantities of labeled speech data exhibiting the distortions that our system should learn to handle. Using a combination of collected and synthesized data, our system learns robustness to realistic noise and speaker variation (including Lombard Effect [20]). Taken together, these ideas suffice to build an end-to-end speech system that is at once simpler than traditional pipelines yet also performs better on difficult speech tasks. DeepSpeech achieves an error rate of 16.5% on the full Switchboard Hub5\u201900 test set\u2014the best published result. Further, on a new noisy speech recognition dataset of our own construction, our system achieves a word error rate of 19.1% where the best commercial systems achieve 30.5% error.\nIn the remainder of this paper, we will introduce the key ideas behind our speech recognition system. We begin by describing the basic recurrent neural network model and training framework that we use in Section 2, followed by a discussion of GPU optimizations (Section 3), and our data capture and synthesis strategy (Section 4). We conclude with our experimental results demonstrating the state-of-the-art performance of DeepSpeech (Section 5), followed by a discussion of related work and our conclusions."}, {"heading": "2 RNN Training Setup", "text": "The core of our system is a recurrent neural network (RNN) trained to ingest speech spectrograms and generate English text transcriptions. Let a single utterance x and label y be sampled from a training set X = {(x(1), y(1)), (x(2), y(2)), . . .}. Each utterance, x(i), is a time-series of length T (i) where every time-slice is a vector of audio features, x(i)t , t = 1, . . . , T (i). We use spectrograms as our features, so x(i)t,p denotes the power of the p\u2019th frequency bin in the audio frame at time t. The goal of our RNN is to convert an input sequence x into a sequence of character probabilities for the transcription y, with y\u0302t = P(ct|x), where ct \u2208 {a,b,c, . . . , z, space, apostrophe, blank}. Our RNN model is composed of 5 layers of hidden units. For an input x, the hidden units at layer l are denoted h(l) with the convention that h(0) is the input. The first three layers are not recurrent. For the first layer, at each time t, the output depends on the spectrogram frame xt along with a context of C frames on each side.1 The remaining non-recurrent layers operate on independent data for each time step. Thus, for each time t, the first 3 layers are computed by:\nh (l) t = g(W (l)h (l\u22121) t + b (l))\nwhere g(z) = min{max{0, z}, 20} is the clipped rectified-linear (ReLu) activation function and W (l), b(l) are the weight matrix and bias parameters for layer l.2 The fourth layer is a bi-directional recurrent layer [38]. This layer includes two sets of hidden units: a set with forward recurrence,\n1We typically use C \u2208 {5, 7, 9} for our experiments. 2The ReLu units are clipped in order to keep the activations in the recurrent layer from exploding; in practice\nthe units rarely saturate at the upper bound.\nh(f), and a set with backward recurrence h(b):\nh (f) t = g(W (4)h (3) t +W (f) r h (f) t\u22121 + b (4))\nh (b) t = g(W (4)h (3) t +W (b) r h (b) t+1 + b (4))\nNote that h(f) must be computed sequentially from t = 1 to t = T (i) for the i\u2019th utterance, while the units h(b) must be computed sequentially in reverse from t = T (i) to t = 1.\nThe fifth (non-recurrent) layer takes both the forward and backward units as inputs h(5)t = g(W (5)h\n(4) t + b (5)) where h(4)t = h (f) t + h (b) t . The output layer is a standard softmax function\nthat yields the predicted character probabilities for each time slice t and character k in the alphabet:\nh (6) t,k = y\u0302t,k \u2261 P(ct = k|x) =\nexp(W (6) k h (5) t + b (6) k )\u2211\nj exp(W (6) j h (5) t + b (6) j )\n.\nHere W (6)k and b (6) k denote the k\u2019th column of the weight matrix and k\u2019th bias, respectively.\nOnce we have computed a prediction for P(ct|x), we compute the CTC loss [13] L(y\u0302, y) to measure the error in prediction. During training, we can evaluate the gradient \u2207y\u0302L(y\u0302, y) with respect to the network outputs given the ground-truth character sequence y. From this point, computing the gradient with respect to all of the model parameters may be done via back-propagation through the rest of the network. We use Nesterov\u2019s Accelerated gradient method for training [40].3\nThe complete RNN model is illustrated in Figure 1. Note that its structure is considerably simpler than related models from the literature [14]\u2014we have limited ourselves to a single recurrent layer (which is the hardest to parallelize) and we do not use Long-Short-Term-Memory (LSTM) circuits. One disadvantage of LSTM cells is that they require computing and storing multiple gating neuron responses at each step. Since the forward and backward recurrences are sequential, this small additional cost can become a computational bottleneck. By using a homogeneous model we have made the computation of the recurrent activations as efficient as possible: computing the ReLu outputs involves only a few highly optimized BLAS operations on the GPU and a single point-wise nonlinearity.\n3We use momentum of 0.99 and anneal the learning rate by a constant factor, chosen to yield the fastest convergence, after each epoch through the data."}, {"heading": "2.1 Regularization", "text": "While we have gone to significant lengths to expand our datasets (c.f. Section 4), the recurrent networks we use are still adept at fitting the training data. In order to reduce variance further, we use several techniques.\nDuring training we apply a dropout [19] rate between 5% - 10%. We apply dropout in the feedforward layers but not to the recurrent hidden activations.\nA commonly employed technique in computer vision during network evaluation is to randomly jitter inputs by translations or reflections, feed each jittered version through the network, and vote or average the results [23]. Such jittering is not common in ASR, however we found it beneficial to translate the raw audio files by 5ms (half the filter bank step size) to the left and right, then forward propagate the recomputed features and average the output probabilities. At test time we also use an ensemble of several RNNs, averaging their outputs in the same way."}, {"heading": "2.2 Language Model", "text": "When trained from large quantities of labeled speech data, the RNN model can learn to produce readable character-level transcriptions. Indeed for many of the transcriptions, the most likely character sequence predicted by the RNN is exactly correct without external language constraints. The errors made by the RNN in this case tend to be phonetically plausible renderings of English words\u2014 Table 1 shows some examples. Many of the errors occur on words that rarely or never appear in our training set. In practice, this is hard to avoid: training from enough speech data to hear all of the words or language constructions we might need to know is impractical. Therefore, we integrate our system with an N-gram language model since these models are easily trained from huge unlabeled text corpora. For comparison, while our speech datasets typically include up to 3 million utterances, the N-gram language model used for the experiments in Section 5.2 is trained from a corpus of 220 million phrases, supporting a vocabulary of 495,000 words.4\nGiven the output P(c|x) of our RNN we perform a search to find the sequence of characters c1, c2, . . . that is most probable according to both the RNN output and the language model (where the language model interprets the string of characters as words). Specifically, we aim to find a sequence c that maximizes the combined objective:\nQ(c) = log(P(c|x)) + \u03b1 log(Plm(c)) + \u03b2 word count(c)\nwhere \u03b1 and \u03b2 are tunable parameters (set by cross-validation) that control the trade-off between the RNN, the language model constraint and the length of the sentence. The term Plm denotes the probability of the sequence c according to the N-gram model. We maximize this objective using a highly optimized beam search algorithm, with a typical beam size in the range 1000-8000\u2014similar to the approach described by Hannun et al. [16]."}, {"heading": "3 Optimizations", "text": "As noted above, we have made several design decisions to make our networks amenable to highspeed execution (and thus fast training). For example, we have opted for homogeneous rectifiedlinear networks that are simple to implement and depend on just a few highly-optimized BLAS calls. When fully unrolled, our networks include almost 5 billion connections for a typical utterance\n4We use the KenLM toolkit [17] to train the N-gram language models in our experiments.\nand thus efficient computation is critical to make our experiments feasible. We use multi-GPU training [7, 23] to accelerate our experiments, but doing this effectively requires some additional work, as we explain."}, {"heading": "3.1 Data parallelism", "text": "In order to process data efficiently, we use two levels of data parallelism. First, each GPU processes many examples in parallel. This is done in the usual way by concatenating many examples into a single matrix. For instance, rather than performing a single matrix-vector multiplicationWrht in the recurrent layer, we prefer to do many in parallel by computing WrHt where Ht = [h (i) t , h (i+1) t , . . .] (where h(i)t corresponds to the i\u2019th example x (i) at time t). The GPU is most efficient when Ht is relatively wide (e.g., 1000 examples or more) and thus we prefer to process as many examples on one GPU as possible (up to the limit of GPU memory).\nWhen we wish to use larger minibatches than a single GPU can support on its own we use data parallelism across multiple GPUs, with each GPU processing a separate minibatch of examples and then combining its computed gradient with its peers during each iteration. We typically use 2\u00d7 or 4\u00d7 data parallelism across GPUs. Data parallelism is not easily implemented, however, when utterances have different lengths since they cannot be combined into a single matrix multiplication. We resolve the problem by sorting our training examples by length and combining only similarly-sized utterances into minibatches, padding with silence when necessary so that all utterances in a batch have the same length. This solution is inspired by the ITPACK/ELLPACK sparse matrix format [21]; a similar solution was used by the Sutskever et al. [41] to accelerate RNNs for text."}, {"heading": "3.2 Model parallelism", "text": "Data parallelism yields training speedups for modest multiples of the minibatch size (e.g., 2 to 4), but faces diminishing returns as batching more examples into a single gradient update fails to improve the training convergence rate. That is, processing 2\u00d7 as many examples on 2\u00d7 as many GPUs fails to yield a 2\u00d7 speedup in training. It is also inefficient to fix the total minibatch size but spread out the examples to 2\u00d7 as many GPUs: as the minibatch within each GPU shrinks, most operations become memory-bandwidth limited. To scale further, we parallelize by partitioning the model (\u201cmodel parallelism\u201d [7, 10]).\nOur model is challenging to parallelize due to the sequential nature of the recurrent layers. Since the bidirectional layer is comprised of a forward computation and a backward computation that are independent, we can perform the two computations in parallel. Unfortunately, naively splitting the RNN to place h(f) and h(b) on separate GPUs commits us to significant data transfers when we go to compute h(5) (which depends on both h(f) and h(b)). Thus, we have chosen a different partitioning of work that requires less communication for our models: we divide the model in half along the time dimension.\nAll layers except the recurrent layer can be trivially decomposed along the time dimension, with the first half of the time-series, from t = 1 to t = T (i)/2, assigned to one GPU and the second half to another GPU. When computing the recurrent layer activations, the first GPU begins computing the forward activations h(f), while the second begins computing the backward activations h(b). At the mid-point (t = T (i)/2), the two GPUs exchange the intermediate activations, h(f)T/2 and h (b) T/2 and swap roles. The first GPU then finishes the backward computation of h(b) and the second GPU finishes the forward computation of h(f)."}, {"heading": "3.3 Striding", "text": "We have worked to minimize the running time of the recurrent layers of our RNN, since these are the hardest to parallelize. As a final optimization, we shorten the recurrent layers by taking \u201csteps\u201d (or strides) of size 2 in the original input so that the unrolled RNN has half as many steps. This is similar to a convolutional network [25] with a step-size of 2 in the first layer. We use the cuDNN library [2] to implement this first layer of convolution efficiently."}, {"heading": "4 Training Data", "text": "Large-scale deep learning systems require an abundance of labeled data. For our system we need many recorded utterances and corresponding English transcriptions, but there are few public datasets of sufficient scale. To train our largest models we have thus collected an extensive dataset consisting of 5000 hours of read speech from 9600 speakers. For comparison, we have summarized the labeled datasets available to us in Table 2."}, {"heading": "4.1 Synthesis by superposition", "text": "To expand our potential training data even further we use data synthesis, which has been successfully applied in other contexts to amplify the effective number of training samples [37, 26, 6]. In our work, the goal is primarily to improve performance in noisy environments where existing systems break down. Capturing labeled data (e.g., read speech) from noisy environments is not practical, however, and thus we must find other ways to generate such data.\nTo a first order, audio signals are generated through a process of superposition of source signals. We can use this fact to synthesize noisy training data. For example, if we have a speech audio track x(i) and a \u201cnoise\u201d audio track \u03be(i), then we can form the \u201cnoisy speech\u201d track x\u0302(i) = x(i) + \u03be(i) to simulate audio captured in a noisy environment. If necessary, we can add reverberations, echoes or other forms of damping to the power spectrum of \u03be(i) or x(i) and then simply add them together to make fairly realistic audio scenes.\nThere are, however, some risks in this approach. For example, in order to take 1000 hours of clean speech and create 1000 hours of noisy speech, we will need unique noise tracks spanning roughly 1000 hours. We cannot settle for, say, 10 hours of repeating noise, since it may become possible for the recurrent network to memorize the noise track and \u201csubtract\u201d it out of the synthesized data. Thus, instead of using a single noise source \u03be(i) with a length of 1000 hours, we use a large number of shorter clips (which are easier to collect from public video sources) and treat them as separate sources of noise before superimposing all of them: x\u0302(i) = x(i) + \u03be(i)1 + \u03be (i) 2 + . . ..\nWhen superimposing many signals collected from video clips, we can end up with \u201cnoise\u201d sounds that are different from the kinds of noise recorded in real environments. To ensure a good match between our synthetic data and real data, we rejected any candidate noise clips where the average power in each frequency band differed significantly from the average power observed in real noisy recordings."}, {"heading": "4.2 Capturing Lombard Effect", "text": "One challenging effect encountered by speech recognition systems in noisy environments is the \u201cLombard Effect\u201d [20]: speakers actively change the pitch or inflections of their voice to overcome noise around them. This (involuntary) effect does not show up in recorded speech datasets since they are collected in quiet environments. To ensure that the effect is represented in our training data we induce the Lombard effect intentionally during data collection by playing loud background noise\nthrough headphones worn by a person as they record an utterance. The noise induces them to inflect their voice, thus allowing us to capture the Lombard effect in our training data.5"}, {"heading": "5 Experiments", "text": "We performed two sets of experiments to evaluate our system. In both cases we use the model described in Section 2 trained from a selection of the datasets in Table 2 to predict character-level transcriptions. The predicted probability vectors and language model are then fed into our decoder to yield a word-level transcription, which is compared with the ground truth transcription to yield the word error rate (WER)."}, {"heading": "5.1 Conversational speech: Switchboard Hub5\u201900 (full)", "text": "To compare our system to prior research we use an accepted but highly challenging test set, Hub5\u201900 (LDC2002S23). Some researchers split this set into \u201ceasy\u201d (Switchboard) and \u201chard\u201d (CallHome) instances, often reporting new results on the easier portion alone. We use the full set, which is the most challenging case and report the overall word error rate.\nWe evaluate our system trained on only the 300 hour Switchboard conversational telephone speech dataset and trained on both Switchboard (SWB) and Fisher (FSH) [3], a 2000 hour corpus collected in a similar manner as Switchboard. Many researchers evaluate models trained only with 300 hours from Switchboard conversational telephone speech when testing on Hub5\u201900. In part this is because training on the full 2000 hour Fisher corpus is computationally difficult. Using the techniques mentioned in Section 3 our system is able perform a full pass over the 2300 hours of data in just a few hours.\nSince the Switchboard and Fisher corpora are distributed at a sample rate of 8kHz, we compute spectrograms of 80 linearly spaced log filter banks and an energy term. The filter banks are computed over windows of 20ms strided by 10ms. We did not evaluate more sophisticated features such as the mel-scale log filter banks or the mel-frequency cepstral coefficients.\nSpeaker adaptation is critical to the success of current ASR systems [43, 36], particularly when trained on 300 hour Switchboard. For the models we test on Hub5\u201900, we apply a simple form of speaker adaptation by normalizing the spectral features on a per speaker basis. Other than this, we do not modify the input features in any way.\nFor decoding, we use a 4-gram language model with a 30,000 word vocabulary trained on the Fisher and Switchboard transcriptions. Again, hyperparameters for the decoding objective are chosen via cross-validation on a held-out development set.\nThe DeepSpeech SWB model is a network of 5 hidden layers each with 2048 neurons trained on only 300 hour switchboard. The DeepSpeech SWB + FSH model is an ensemble of 5 RNNs each with 5 hidden layers of 2304 neurons trained on the full 2300 hour combined corpus. All networks are trained on inputs of +/- 9 frames of context.\nWe report results in Table 3. The model from Vesely et al. (DNN-GMM sMBR) [43] uses a sequence based loss function on top of a DNN after using a typical hybrid DNN-HMM system to realign the training set. The performance of this model on the combined Hub5\u201900 test set is the best previously published result. When trained on the combined 2300 hours of data the DeepSpeech system improves upon this baseline by 1.9% absolute WER and 10.3% relative. The model from Maas et al. (DNN-HMM FSH) [28] achieves 19.9% WER when trained on the Fisher 2000 hour corpus. That system was built using Kaldi [32], state-of-the-art open source speech recognition software. We include this result to demonstrate that DeepSpeech, when trained on a comparable amount of data is competitive with the best existing ASR systems.\n5We have experimented with noise played through headphones as well as through computer speakers. Using headphones has the advantage that we obtain \u201cclean\u201d recordings without the background noise included and can add our own synthetic noise afterward."}, {"heading": "5.2 Noisy speech", "text": "Few standards exist for testing noisy speech performance, so we constructed our own evaluation set of 100 noisy and 100 noise-free utterances from 10 speakers. The noise environments included a background radio or TV; washing dishes in a sink; a crowded cafeteria; a restaurant; and inside a car driving in the rain. The utterance text came primarily from web search queries and text messages, as well as news clippings, phone conversations, Internet comments, public speeches, and movie scripts. We did not have precise control over the signal-to-noise ratio (SNR) of the noisy samples, but we aimed for an SNR between 2 and 6 dB.\nFor the following experiments, we train our RNNs on all the datasets (more than 7000 hours) listed in Table 2. Since we train for 15 to 20 epochs with newly synthesized noise in each pass, our model learns from over 100,000 hours of novel data. We use an ensemble of 6 networks each with 5 hidden layers of 2560 neurons. No form of speaker adaptation is applied to the training or evaluation sets. We normalize training examples on a per utterance basis in order to make the total power of each example consistent. The features are 160 linearly spaced log filter banks computed over windows of 20ms strided by 10ms and an energy term. Audio files are resampled to 16kHz prior to the featurization. Finally, from each frequency bin we remove the global mean over the training set and divide by the global standard deviation, primarily so the inputs are well scaled during the early stages of training.\nAs described in Section 2.2, we use a 5-gram language model for the decoding. We train the language model on 220 million phrases of the Common Crawl6, selected such that at least 95% of the characters of each phrase are in the alphabet. Only the most common 495,000 words are kept, the rest remapped to an UNKNOWN token.\nWe compared the DeepSpeech system to several commercial speech systems: (1) wit.ai, (2) Google Speech API, (3) Bing Speech and (4) Apple Dictation.7\nOur test is designed to benchmark performance in noisy environments. This situation creates challenges for evaluating the web speech APIs: these systems will give no result at all when the SNR is too low or in some cases when the utterance is too long. Therefore we restrict our comparison to the subset of utterances for which all systems returned a non-empty result.8 The results of evaluating each system on our test files appear in Table 4.\nTo evaluate the efficacy of the noise synthesis techniques described in Section 4.1, we trained two RNNs, one on 5000 hours of raw data and the other trained on the same 5000 hours plus noise. On the 100 clean utterances both models perform about the same, 9.2% WER and 9.0% WER for the clean trained model and the noise trained model respectively. However, on the 100 noisy utterances\n6commoncrawl.org 7wit.ai and Google Speech each have HTTP-based APIs. To test Apple Dictation and Bing Speech, we used a kernel extension to loop audio output back to audio input in conjunction with the OS X Dictation service and the Windows 8 Bing speech recognition API.\n8This leads to much higher accuracies than would be reported if we attributed 100% error in cases where an API failed to respond.\nthe noisy model achieves 22.6% WER over the clean model\u2019s 28.7% WER, a 6.1% absolute and 21.3% relative improvement."}, {"heading": "6 Related Work", "text": "Several parts of our work are inspired by previous results. Neural network acoustic models and other connectionist approaches were first introduced to speech pipelines in the early 1990s [1, 34, 11]. These systems, similar to DNN acoustic models [30, 18, 9], replace only one stage of the speech recognition pipeline. Mechanically, our system is similar to other efforts to build end-to-end speech systems from deep learning algorithms. For example, Graves et al. [13] have previously introduced the \u201cConnectionist Temporal Classification\u201d (CTC) loss function for scoring transcriptions produced by RNNs and, with LSTM networks, have previously applied this approach to speech [14]. We similarly adopt the CTC loss for part of our training procedure but use much simpler recurrent networks with rectified-linear activations [12, 29, 31]. Our recurrent network is similar to the bidirectional RNN used by Hannun et al. [16], but with multiple changes to enhance its scalability. By focusing on scalability, we have shown that these simpler networks can be effective even without the more complex LSTM machinery.\nOur work is certainly not the first to exploit scalability to improve performance of DL algorithms. The value of scalability in deep learning is well-studied [8, 24] and the use of parallel processors (including GPUs) has been instrumental to recent large-scale DL results [42, 24]. Early ports of DL algorithms to GPUs revealed significant speed gains [33]. Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available. Indeed, using high-performance computing infrastructure, it is possible today to train neural networks with more than 10 billion connections [7] using clusters of GPUs. These results inspired us to focus first on making scalable design choices to efficiently utilize many GPUs before trying to engineer the algorithms and models themselves.\nWith the potential to train large models, there is a need for large training sets as well. In other fields, such as computer vision, large labeled training sets have enabled significant leaps in performance as they are used to feed larger and larger DL systems [42, 23]. In speech recognition, however, such large training sets are less common, with typical benchmarks having training sets ranging from tens of hours (e.g. the Wall Street Journal corpus with 80 hours) to several hundreds of hours (e.g. Switchboard and Broadcast News). Larger benchmark datasets, such as the Fisher corpus [3] with 2000 hours of transcribed speech, are rare and only recently being studied. To fully utilize the expressive power of the recurrent networks available to us, we rely not only on large sets of labeled utterances, but also on synthesis techniques to generate novel examples. This approach is well known in computer vision [37, 26, 6] but we have found this especially convenient and effective for speech when done properly."}, {"heading": "7 Conclusion", "text": "We have presented an end-to-end deep learning-based speech system capable of outperforming existing state-of-the-art recognition pipelines in two challenging scenarios: clear, conversational speech and speech in noisy environments. Our approach is enabled particularly by multi-GPU training and\nby data collection and synthesis strategies to build large training sets exhibiting the distortions our system must handle (such as background noise and Lombard effect). Combined, these solutions enable us to build a data-driven speech system that is at once better performing than existing methods while no longer relying on the complex processing stages that had stymied further progress. We believe this approach will continue to improve as we capitalize on increased computing power and dataset sizes in the future."}, {"heading": "Acknowledgments", "text": "We are grateful to Jia Lei, whose work on DL for speech at Baidu has spurred us forward, for his advice and support throughout this project. We also thank Ian Lane, Dan Povey, Dan Jurafsky, Dario Amodei, Andrew Maas, Calisa Cole and Li Wei for helpful conversations."}], "references": [{"title": "Connectionist Speech Recognition: A Hybrid Approach", "author": ["H. Bourlard", "N. Morgan"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "The Fisher corpus: a resource for the next generations of speech-to-text", "author": ["C. Cieri", "D. Miller", "K. Walker"], "venue": "In LREC,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2004}, {"title": "Flexible, high performance convolutional neural networks for image classification", "author": ["D.C. Ciresan", "U. Meier", "J. Masci", "L.M. Gambardella", "J. Schmidhuber"], "venue": "In International Joint Conference on Artificial Intelligence,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2011}, {"title": "Multi-column deep neural networks for image classification", "author": ["D.C. Ciresan", "U. Meier", "J. Schmidhuber"], "venue": "In Computer Vision and Pattern Recognition,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Text detection and character recognition in scene images with unsupervised feature learning", "author": ["A. Coates", "B. Carpenter", "C. Case", "S. Satheesh", "B. Suresh", "T. Wang", "D.J. Wu", "A.Y. Ng"], "venue": "In International Conference on Document Analysis and Recognition,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Deep learning with COTS HPC", "author": ["A. Coates", "B. Huval", "T. Wang", "D.J. Wu", "A.Y. Ng", "B. Catanzaro"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "An analysis of single-layer networks in unsupervised feature learning", "author": ["A. Coates", "H. Lee", "A.Y. Ng"], "venue": "In 14th International Conference on AI and Statistics,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Context-dependent pre-trained deep neural networks for large vocabulary speech recognition", "author": ["G. Dahl", "D. Yu", "L. Deng", "A. Acero"], "venue": "IEEE Transactions on Audio, Speech, and Language Processing,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Large scale distributed deep networks", "author": ["J. Dean", "G.S. Corrado", "R. Monga", "K. Chen", "M. Devin", "Q.V. Le", "M.Z. Mao", "M. Ranzato", "A. Senior", "P. Tucker", "K. Yang", "A.Y. Ng"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Size matters: An empirical study of neural network training for large vocabulary continuous speech recognition", "author": ["D. Ellis", "N. Morgan"], "venue": "In ICASSP,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "Deep sparse rectifier neural networks", "author": ["X. Glorot", "A. Bordes", "Y. Bengio"], "venue": "In 14th International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Connectionist temporal classification: Labelling unsegmented sequence data with recurrent neural networks", "author": ["A. Graves", "S. Fern\u00e1ndez", "F. Gomez", "J. Schmidhuber"], "venue": "In ICML,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "Towards end-to-end speech recognition with recurrent neural networks", "author": ["A. Graves", "N. Jaitly"], "venue": "In ICML,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "Shift-invariance sparse coding for audio classification", "author": ["R. Grosse", "R. Raina", "H. Kwong", "A.Y. Ng"], "venue": "arXiv preprint arXiv:1206.5241,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "First-pass large vocabulary continuous speech recognition using bi-directional recurrent DNNs", "author": ["A.Y. Hannun", "A.L. Maas", "D. Jurafsky", "A.Y. Ng"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2014}, {"title": "Scalable modified Kneser-Ney language model estimation", "author": ["K. Heafield", "I. Pouzyrevsky", "J.H. Clark", "P. Koehn"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, Sofia, Bulgaria,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2013}, {"title": "Deep neural networks for acoustic modeling in speech recognition", "author": ["G. Hinton", "L. Deng", "D. Yu", "G. Dahl", "A. Mohamed", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T. Sainath", "B. Kingsbury"], "venue": "IEEE Signal Processing Magazine,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["G. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2014}, {"title": "The Lombard reflex and its role on human listeners and automatic speech recognizers", "author": ["J.-C. Junqua"], "venue": "Journal of the Acoustical Society of America,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1993}, {"title": "Scalable minimum Bayes risk training of deep neural network acoustic models using distributed hessian-free optimization", "author": ["B. Kingsbury", "T. Sainath", "H. Soltau"], "venue": "In Interspeech,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G. Hinton"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2012}, {"title": "Building high-level features using large scale unsupervised learning", "author": ["Q. Le", "M. Ranzato", "R. Monga", "M. Devin", "K. Chen", "G. Corrado", "J. Dean", "A. Ng"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Backpropagation applied to handwritten zip code recognition", "author": ["Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel"], "venue": "Neural Computation,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1989}, {"title": "Learning methods for generic object recognition with invariance to pose and lighting", "author": ["Y. LeCun", "F.J. Huang", "L. Bottou"], "venue": "In Computer Vision and Pattern Recognition,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2004}, {"title": "Unsupervised feature learning for audio classification using convolutional deep belief networks", "author": ["H. Lee", "P. Pham", "Y. Largman", "A.Y. Ng"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "Increasing deep neural network acoustic model size for large vocabulary continuous speech recognition", "author": ["A.L. Maas", "A.Y. Hannun", "C.T. Lengerich", "P. Qi", "D. Jurafsky", "A.Y. Ng"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2014}, {"title": "Rectifier nonlinearities improve neural network acoustic models", "author": ["A.L. Maas", "A.Y. Hannun", "A.Y. Ng"], "venue": "In ICML Workshop on Deep Learning for Audio, Speech, and Language Processing,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2013}, {"title": "Acoustic modeling using deep belief networks", "author": ["A. Mohamed", "G. Dahl", "G. Hinton"], "venue": "IEEE Transactions on Audio, Speech, and Language Processing,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2011}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["V. Nair", "G.E. Hinton"], "venue": "In 27th International Conference on Machine Learning,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "The Kaldi speech recognition toolkit", "author": ["D. Povey", "A. Ghoshal", "G. Boulianne", "L. Burget", "O. Glembek", "K. Vesel\u00fd", "N. Goel", "M. Hannemann", "P. Motlicek", "Y. Qian", "P. Schwarz", "J. Silovsky", "G. Stemmer"], "venue": "ASRU,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2011}, {"title": "Large-scale deep unsupervised learning using graphics processors", "author": ["R. Raina", "A. Madhavan", "A. Ng"], "venue": "In 26th International Conference on Machine Learning,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2009}, {"title": "Connectionist probability estimators in HMM speech recognition", "author": ["S. Renals", "N. Morgan", "H. Bourlard", "M. Cohen", "H. Franco"], "venue": "IEEE Transactions on Speech and Audio Processing,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1994}, {"title": "Improvements to deep convolutional neural networks for LVCSR", "author": ["T. Sainath", "B. Kingsbury", "A. Mohamed", "G. Dahl", "G. Saon", "H. Soltau", "T. Beran", "A. Aravkin", "B. Ramabhadran"], "venue": "In ASRU,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2013}, {"title": "Deep convolutional neural networks for LVCSR", "author": ["T.N. Sainath", "A. rahman Mohamed", "B. Kingsbury", "B. Ramabhadran"], "venue": "In ICASSP,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2013}, {"title": "A fast data collection and augmentation procedure for object recognition", "author": ["B. Sapp", "A. Saxena", "A.Y. Ng"], "venue": "In AAAI Twenty-Third Conference on Artificial Intelligence,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2008}, {"title": "Bidirectional recurrent neural networks", "author": ["M. Schuster", "K.K. Paliwal"], "venue": "IEEE Transactions on Signal Processing,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 1997}, {"title": "Feature engineering in context-dependent deep neural networks for conversational speech transcription", "author": ["F. Seide", "G. Li", "X. Chen", "D. Yu"], "venue": "In ASRU,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2011}, {"title": "On the importance of momentum and initialization in deep learning", "author": ["I. Sutskever", "J. Martens", "G. Dahl", "G. Hinton"], "venue": "In 30th International Conference on Machine Learning,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2013}, {"title": "Sequence to sequence learning with neural networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V. Le"], "venue": null, "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2014}, {"title": "Sequence-discriminative training of deep neural networks", "author": ["K. Vesely", "A. Ghoshal", "L. Burget", "D. Povey"], "venue": "In Interspeech,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2013}], "referenceMentions": [{"referenceID": 24, "context": "The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models.", "startOffset": 45, "endOffset": 64}, {"referenceID": 27, "context": "The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models.", "startOffset": 45, "endOffset": 64}, {"referenceID": 13, "context": "The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models.", "startOffset": 45, "endOffset": 64}, {"referenceID": 16, "context": "The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models.", "startOffset": 45, "endOffset": 64}, {"referenceID": 7, "context": "The introduction of deep learning algorithms [27, 30, 15, 18, 9] has improved speech system performance, usually by improving acoustic models.", "startOffset": 45, "endOffset": 64}, {"referenceID": 11, "context": "This problem has been addressed by Graves, Fern\u00e1ndez, Gomez and Schmidhuber [13], thus enabling neural networks to easily consume unaligned, transcribed audio during training.", "startOffset": 76, "endOffset": 80}, {"referenceID": 5, "context": "[7], demonstrating the speed advantages of multi-GPU computation.", "startOffset": 0, "endOffset": 3}, {"referenceID": 24, "context": "[27] who applied early unsupervised feature learning techniques to replace hand-built speech features.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "Using a combination of collected and synthesized data, our system learns robustness to realistic noise and speaker variation (including Lombard Effect [20]).", "startOffset": 151, "endOffset": 155}, {"referenceID": 35, "context": "2 The fourth layer is a bi-directional recurrent layer [38].", "startOffset": 55, "endOffset": 59}, {"referenceID": 11, "context": "Once we have computed a prediction for P(ct|x), we compute the CTC loss [13] L(\u0177, y) to measure the error in prediction.", "startOffset": 72, "endOffset": 76}, {"referenceID": 37, "context": "We use Nesterov\u2019s Accelerated gradient method for training [40].", "startOffset": 59, "endOffset": 63}, {"referenceID": 12, "context": "Note that its structure is considerably simpler than related models from the literature [14]\u2014we have limited ourselves to a single recurrent layer (which is the hardest to parallelize) and we do not use Long-Short-Term-Memory (LSTM) circuits.", "startOffset": 88, "endOffset": 92}, {"referenceID": 17, "context": "During training we apply a dropout [19] rate between 5% - 10%.", "startOffset": 35, "endOffset": 39}, {"referenceID": 20, "context": "A commonly employed technique in computer vision during network evaluation is to randomly jitter inputs by translations or reflections, feed each jittered version through the network, and vote or average the results [23].", "startOffset": 216, "endOffset": 220}, {"referenceID": 14, "context": "[16].", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "We use the KenLM toolkit [17] to train the N-gram language models in our experiments.", "startOffset": 25, "endOffset": 29}, {"referenceID": 5, "context": "We use multi-GPU training [7, 23] to accelerate our experiments, but doing this effectively requires some additional work, as we explain.", "startOffset": 26, "endOffset": 33}, {"referenceID": 20, "context": "We use multi-GPU training [7, 23] to accelerate our experiments, but doing this effectively requires some additional work, as we explain.", "startOffset": 26, "endOffset": 33}, {"referenceID": 38, "context": "[41] to accelerate RNNs for text.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "To scale further, we parallelize by partitioning the model (\u201cmodel parallelism\u201d [7, 10]).", "startOffset": 80, "endOffset": 87}, {"referenceID": 8, "context": "To scale further, we parallelize by partitioning the model (\u201cmodel parallelism\u201d [7, 10]).", "startOffset": 80, "endOffset": 87}, {"referenceID": 22, "context": "This is similar to a convolutional network [25] with a step-size of 2 in the first layer.", "startOffset": 43, "endOffset": 47}, {"referenceID": 1, "context": "The Wall Street Journal, Switchboard and Fisher [3] corpora are all published by the Linguistic Data Consortium.", "startOffset": 48, "endOffset": 51}, {"referenceID": 34, "context": "To expand our potential training data even further we use data synthesis, which has been successfully applied in other contexts to amplify the effective number of training samples [37, 26, 6].", "startOffset": 180, "endOffset": 191}, {"referenceID": 23, "context": "To expand our potential training data even further we use data synthesis, which has been successfully applied in other contexts to amplify the effective number of training samples [37, 26, 6].", "startOffset": 180, "endOffset": 191}, {"referenceID": 4, "context": "To expand our potential training data even further we use data synthesis, which has been successfully applied in other contexts to amplify the effective number of training samples [37, 26, 6].", "startOffset": 180, "endOffset": 191}, {"referenceID": 18, "context": "One challenging effect encountered by speech recognition systems in noisy environments is the \u201cLombard Effect\u201d [20]: speakers actively change the pitch or inflections of their voice to overcome noise around them.", "startOffset": 111, "endOffset": 115}, {"referenceID": 1, "context": "We evaluate our system trained on only the 300 hour Switchboard conversational telephone speech dataset and trained on both Switchboard (SWB) and Fisher (FSH) [3], a 2000 hour corpus collected in a similar manner as Switchboard.", "startOffset": 159, "endOffset": 162}, {"referenceID": 39, "context": "Speaker adaptation is critical to the success of current ASR systems [43, 36], particularly when trained on 300 hour Switchboard.", "startOffset": 69, "endOffset": 77}, {"referenceID": 33, "context": "Speaker adaptation is critical to the success of current ASR systems [43, 36], particularly when trained on 300 hour Switchboard.", "startOffset": 69, "endOffset": 77}, {"referenceID": 39, "context": "(DNN-GMM sMBR) [43] uses a sequence based loss function on top of a DNN after using a typical hybrid DNN-HMM system to realign the training set.", "startOffset": 15, "endOffset": 19}, {"referenceID": 25, "context": "(DNN-HMM FSH) [28] achieves 19.", "startOffset": 14, "endOffset": 18}, {"referenceID": 29, "context": "That system was built using Kaldi [32], state-of-the-art open source speech recognition software.", "startOffset": 34, "endOffset": 38}, {"referenceID": 39, "context": "(GMM-HMM BMMI) [43] 18.", "startOffset": 15, "endOffset": 19}, {"referenceID": 39, "context": "(DNN-HMM sMBR) [43] 12.", "startOffset": 15, "endOffset": 19}, {"referenceID": 25, "context": "(DNN-HMM SWB) [28] 14.", "startOffset": 14, "endOffset": 18}, {"referenceID": 25, "context": "(DNN-HMM FSH) [28] 16.", "startOffset": 14, "endOffset": 18}, {"referenceID": 36, "context": "(CD-DNN) [39] 16.", "startOffset": 9, "endOffset": 13}, {"referenceID": 19, "context": "(DNN-HMM sMBR HF) [22] 13.", "startOffset": 18, "endOffset": 22}, {"referenceID": 33, "context": "(CNN-HMM) [36] 11.", "startOffset": 10, "endOffset": 14}, {"referenceID": 0, "context": "Neural network acoustic models and other connectionist approaches were first introduced to speech pipelines in the early 1990s [1, 34, 11].", "startOffset": 127, "endOffset": 138}, {"referenceID": 31, "context": "Neural network acoustic models and other connectionist approaches were first introduced to speech pipelines in the early 1990s [1, 34, 11].", "startOffset": 127, "endOffset": 138}, {"referenceID": 9, "context": "Neural network acoustic models and other connectionist approaches were first introduced to speech pipelines in the early 1990s [1, 34, 11].", "startOffset": 127, "endOffset": 138}, {"referenceID": 27, "context": "These systems, similar to DNN acoustic models [30, 18, 9], replace only one stage of the speech recognition pipeline.", "startOffset": 46, "endOffset": 57}, {"referenceID": 16, "context": "These systems, similar to DNN acoustic models [30, 18, 9], replace only one stage of the speech recognition pipeline.", "startOffset": 46, "endOffset": 57}, {"referenceID": 7, "context": "These systems, similar to DNN acoustic models [30, 18, 9], replace only one stage of the speech recognition pipeline.", "startOffset": 46, "endOffset": 57}, {"referenceID": 11, "context": "[13] have previously introduced the \u201cConnectionist Temporal Classification\u201d (CTC) loss function for scoring transcriptions produced by RNNs and, with LSTM networks, have previously applied this approach to speech [14].", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13] have previously introduced the \u201cConnectionist Temporal Classification\u201d (CTC) loss function for scoring transcriptions produced by RNNs and, with LSTM networks, have previously applied this approach to speech [14].", "startOffset": 213, "endOffset": 217}, {"referenceID": 10, "context": "We similarly adopt the CTC loss for part of our training procedure but use much simpler recurrent networks with rectified-linear activations [12, 29, 31].", "startOffset": 141, "endOffset": 153}, {"referenceID": 26, "context": "We similarly adopt the CTC loss for part of our training procedure but use much simpler recurrent networks with rectified-linear activations [12, 29, 31].", "startOffset": 141, "endOffset": 153}, {"referenceID": 28, "context": "We similarly adopt the CTC loss for part of our training procedure but use much simpler recurrent networks with rectified-linear activations [12, 29, 31].", "startOffset": 141, "endOffset": 153}, {"referenceID": 14, "context": "[16], but with multiple changes to enhance its scalability.", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "The value of scalability in deep learning is well-studied [8, 24] and the use of parallel processors (including GPUs) has been instrumental to recent large-scale DL results [42, 24].", "startOffset": 58, "endOffset": 65}, {"referenceID": 21, "context": "The value of scalability in deep learning is well-studied [8, 24] and the use of parallel processors (including GPUs) has been instrumental to recent large-scale DL results [42, 24].", "startOffset": 58, "endOffset": 65}, {"referenceID": 21, "context": "The value of scalability in deep learning is well-studied [8, 24] and the use of parallel processors (including GPUs) has been instrumental to recent large-scale DL results [42, 24].", "startOffset": 173, "endOffset": 181}, {"referenceID": 30, "context": "Early ports of DL algorithms to GPUs revealed significant speed gains [33].", "startOffset": 70, "endOffset": 74}, {"referenceID": 20, "context": "Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available.", "startOffset": 129, "endOffset": 140}, {"referenceID": 2, "context": "Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available.", "startOffset": 129, "endOffset": 140}, {"referenceID": 32, "context": "Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available.", "startOffset": 129, "endOffset": 140}, {"referenceID": 5, "context": "Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available.", "startOffset": 163, "endOffset": 169}, {"referenceID": 3, "context": "Researchers have also begun choosing designs that map well to GPU hardware to gain even more efficiency, including convolutional [23, 4, 35] and locally connected [7, 5] networks, especially when optimized libraries like cuDNN [2] and BLAS are available.", "startOffset": 163, "endOffset": 169}, {"referenceID": 5, "context": "Indeed, using high-performance computing infrastructure, it is possible today to train neural networks with more than 10 billion connections [7] using clusters of GPUs.", "startOffset": 141, "endOffset": 144}, {"referenceID": 20, "context": "In other fields, such as computer vision, large labeled training sets have enabled significant leaps in performance as they are used to feed larger and larger DL systems [42, 23].", "startOffset": 170, "endOffset": 178}, {"referenceID": 1, "context": "Larger benchmark datasets, such as the Fisher corpus [3] with 2000 hours of transcribed speech, are rare and only recently being studied.", "startOffset": 53, "endOffset": 56}, {"referenceID": 34, "context": "This approach is well known in computer vision [37, 26, 6] but we have found this especially convenient and effective for speech when done properly.", "startOffset": 47, "endOffset": 58}, {"referenceID": 23, "context": "This approach is well known in computer vision [37, 26, 6] but we have found this especially convenient and effective for speech when done properly.", "startOffset": 47, "endOffset": 58}, {"referenceID": 4, "context": "This approach is well known in computer vision [37, 26, 6] but we have found this especially convenient and effective for speech when done properly.", "startOffset": 47, "endOffset": 58}], "year": 2014, "abstractText": "We present a state-of-the-art speech recognition system developed using end-toend deep learning. Our architecture is significantly simpler than traditional speech systems, which rely on laboriously engineered processing pipelines; these traditional systems also tend to perform poorly when used in noisy environments. In contrast, our system does not need hand-designed components to model background noise, reverberation, or speaker variation, but instead directly learns a function that is robust to such effects. We do not need a phoneme dictionary, nor even the concept of a \u201cphoneme.\u201d Key to our approach is a well-optimized RNN training system that uses multiple GPUs, as well as a set of novel data synthesis techniques that allow us to efficiently obtain a large amount of varied data for training. Our system, called DeepSpeech, outperforms previously published results on the widely studied Switchboard Hub5\u201900, achieving 16.5% error on the full test set. DeepSpeech also handles challenging noisy environments better than widely used, state-of-the-art commercial speech systems.", "creator": "LaTeX with hyperref package"}}}