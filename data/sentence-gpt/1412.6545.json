{"id": "1412.6545", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Dec-2014", "title": "KF metamodel formalization", "abstract": "The KF metamodel is a comprehensive unifying metamodel covering the static structural entities and constraints of UML Class Diagrams (v2.4.1), ER, EER, ORM, and ORM2, and intended to boost interoperability of common conceptual data modelling languages. It was originally designed in UML with textual constraints, and in this report we present its formalisations in FOL and OWL, which accompanies the paper that describes, discusses, and analyses the KF metamodel in detail. These new formalizations contribute to give a precise meaning to the metamodel, to understand its complexity properties and to provide a basis for future implementations. The authors recommend the publication of this paper in the Journal of Applied Physics, and the KF metamodel on the basis of both theoretical and practical applications in a range of areas of data modeling and data modeling.\n\n\n\nThe first of the three new formalizations of the KF metamodel is available in the Springer-Verlag International Journal of Applied Physics, an online library of theoretical, computer-science, and mathematics. The second is called the KF metamodel, which is distributed across all public and private systems. It is also known as the KF metamodel, where the metamodel has been described as a \u2010\u2013\u2013 system and consists of two main components: the GDF and KF. The KF metamodel is the most extensively used class of KF classes that can be accessed in a variety of applications.\nThe KF metamodel has been described as a \u2010\u2013\u2013 system and consists of two main components: the GDF and KF. The KF metamodel is the most extensively used class of KF classes that can be accessed in a variety of applications. The KF metamodel is the most widely used class of KF classes that can be accessed in a variety of applications. The KF metamodel is the most widely used class of KF classes that can be accessed in a variety of applications. The KF metamodel is the most widely used class of KF classes that can be accessed in a variety of applications. The KF metamodel is the most widely used class of KF classes that can be accessed in a variety of applications. The KF metamodel is the most widely used class of KF classes that can", "histories": [["v1", "Fri, 19 Dec 2014 21:56:59 GMT  (599kb,D)", "http://arxiv.org/abs/1412.6545v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.LO", "authors": ["pablo r fillottrani", "c maria keet"], "accepted": false, "id": "1412.6545"}, "pdf": {"name": "1412.6545.pdf", "metadata": {"source": "CRF", "title": "KF metamodel formalization", "authors": ["Pablo Rub\u00e9n Fillottrani", "Maria Keet"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Interoperability of conceptual data modelling languages has become a necessity with ever complex software systems, be this through integration of \u2018legacy\u2019 systems or de novo development. In such cases, typically, one would use various conceptual models, such as ORM for usability with domain experts and interaction between requirements and data analysis, perhaps an EER model for the back-end database, and UML for any application layer software, which requires the system analyst to link entities across models represented in different conceptual modelling languages. To aid this endeavour, we have developed an ontology-driven unifying metamodel of UML v2.4.1, ER, EER, ORM and ORM2, whose static, structural entities have been presented in [Keet and Fillottrani, 2013], and an extended version also covering constraint in [Keet and Fillottrani, 2014]. More specifically, this concerned UML Class diagrams as specified in the UML Superstructure specification v2.4.1 [Object Management Group, 2012], typical ORM as described in [Committee Members, 2012, Halpin and Morgan, 2008], and both the original ash the encyclopaedic entries for ER and EER [Chen, 1976, Song and Chen, 2009, Thalheim, 2009].\nThis was modelled in UML Class Diagram notation with textual constraints for purpose of facilitating communication. Here we present the FOL formalisation of that metamodel to ensure precision of meaning and as a first step toward its computational use, including its necessity for designing efficient algorithms to computationally verify an inter-model assertion is correct (see also [Fillottrani and Keet, 2014]). Secondly, we have formalised it also in OWL 2 [Motik et al., 2009], for there are many tools that can process OWL files, hence opening up other avenues of the use of the metamodel, such as for categorising entities in extant models.\nThe remainder of this technical report presents first the FOL formalisation in Section 2 and subsequently discusses the modelling decisions for the OWL 2 DL version in Section 3. We close in Section 4.\nar X\niv :1\n41 2.\n65 45\nv1 [\ncs .A\nI] 1\n9 D\nec 2\n01 4"}, {"heading": "2 FOL Formalization", "text": "The FOL formalization is organised along the subfigures of the metamodel, where we first present a brief overview (Section 2.1), and subsequently the relationships and attributes and the constraints among those entities. From Section 2.4 onwards, the model constraints are presented, starting with simple mandatory up to ORM\u2019s join constraints. Each subfigure of the metamodel is introduced first, which is followed by a brief description of the element in the figure and its formalisation. We use function-free FOL with equality, with a model-theoretic semantics; for a good overview of the language, see, e.g., [Hedman, 2004]. For notational convenience, we also use counting quantifiers \u2203\u2264c, \u2203\u2265c, and \u2203=c for all c > 0 which do not add expressive power to FOL but facilitates the interpretation of formula. See [Baader et al., 2008] for their translation into traditional FOL."}, {"heading": "2.1 Overview of the Static Entities", "text": "Figures 1 and 2 present the static entities of the metamodel, noting that it has been extended cf. [Keet and Fillottrani, 2013] with, notably, UML\u2019s qualifier, qualified association, and qualified identification. As before, we also use these two figures to communicate the overlap among the selected conceptual modelling languages, where a dark colour indicates all three families have that entity, classes filled with crossed lines are entities that appear in two of the three, a single line in only one, and an non-filled (white) class icon denotes an entity that appears in neither, but is used only in the metamodel to unify the other entities.\nFormalization of Static Entities The formalization is described based on each UML class diagram element in the corresponding figure, from top to bottom and left to right, and after that the textual constraints. For example, in figure 1 we have 10 isa relations and one textual constraint.\n\u2022 isa (disjoint and complete)\n\u2200(x)(Relationship(x) \u2192 Entity(x)) \u2200(x)(Role(x) \u2192 Entity(x)) \u2200(x)(EntityType(x) \u2192 Entity(x)) \u2200(x)(Constraint(x) \u2192 Entity(x)) \u2200(x)(\u00ac(Relationship(x) \u2227 Role(x))) \u2200(x)(\u00ac(Relationship(x) \u2227 EntityType(x))) \u2200(x)(\u00ac(Relationship(x) \u2227 Constraint(x))) \u2200(x)(\u00ac(Role(x) \u2227 EntityType(x))) \u2200(x)(\u00ac(Role(x) \u2227 Constraint(x))) \u2200(x)(\u00ac(EntityType(x) \u2227 Constraint(x))) \u2200(x)(Entity(x) \u2192 (Relationship(x) \u2228 Role(x) \u2228 EntityType(x) \u2228 Constraint(x)))\n\u2022 isa \u2200(x)(QualifiedRelationship(x) \u2192 Relationship(x))\n\u2022 isa (disjoint) \u2200(x)(PartWhole(x) \u2192 Relationship(x)) \u2200(x)(AttributiveProperty(x) \u2192 Relationship(x)) \u2200(x)(Subsumption(x) \u2192 Relationship(x)) \u2200(x)(\u00ac(PartWhole(x) \u2227 AttributiveProperty(x))) \u2200(x)(\u00ac(PartWhole(x) \u2227 Subsumption(x))) \u2200(x)(\u00ac(AttributiveProperty(x) \u2227 Subsumption(x)))\n\u2022 isa \u2200(x)(SharedAggregate(x) \u2192 PartWhole(x))\n\u2022 isa \u2200(x)(CompositeAggregate(x) \u2192 SharedAggregate(x))\n\u2022 isa (disjoint, complete) \u2200(x)(Attribute(x) \u2192 AttributiveProperty(x)) \u2200(x)(CompositeAttribute(x) \u2192 AttributiveProperty(x)) \u2200(x)(DimensionalAttribute(x) \u2192 AttributiveProperty(x)) \u2200(x)(\u00ac(Attribute(x) \u2227 CompositeAttribute(x))) \u2200(x)(\u00ac(Attribute(x) \u2227 DimensionalAttribute(x))) \u2200(x)(\u00ac(CompositeAttribute(x) \u2227 DimensionalAttribute(x))) \u2200(x)(AttributiveProperty(x) \u2192 (Attribute(x) \u2228 CompositeAttribute(x)\u2228\nDimensionalAttribute(x)))\n\u2022 isa (disjoint) \u2200(x)(MultivaluedAttribute(x) \u2192 Attribute(x)) \u2200(x)(MappedTo(x) \u2192 Attribute(x)) \u2200(x)(\u00ac(MultivaluedAttribute(x) \u2227 MappedTo(x)))\n\u2022 isa (disjoint, complete)\n\u2200(x)(ValueProperty(x) \u2192 EntityType(x)) \u2200(x)(DataType(x) \u2192 EntityType(x)) \u2200(x)(ObjectType(x) \u2192 EntityType(x)) \u2200(x)(Qualifier(x) \u2192 EntityType(x)) \u2200(x)(\u00ac(ValueProperty(x) \u2227 DataType(x))) \u2200(x)(\u00ac(ValueProperty(x) \u2227 ObjectType(x))) \u2200(x)(\u00ac(ValueProperty(x) \u2227 Qualifier(x))) \u2200(x)(\u00ac(DataType(x) \u2227 ObjectType(x))) \u2200(x)(\u00ac(DataType(x) \u2227 Qualifier(x))) \u2200(x)(\u00ac(ObjectType(x) \u2227 Qualifier(x))) \u2200(x)(EntityType(x) \u2192 (ValueProperty(x)\u2228DataType(x)\u2228ObjectType(x)\u2228Qualifier(x)))\n\u2022 isa (disjoint,complete) \u2200(x)(ValueType(x) \u2192 ValueProperty(x)) \u2200(x)(DimensionalValueType(x) \u2192 ValueProperty(x)) \u2200(x)(\u00ac(ValueType(x) \u2227 DimensionalValueType(x))) \u2200(x)(ValueProperty(x) \u2192 (ValueType(x) \u2228 DimensionalValueType(x)))\n\u2022 isa \u2200(x)(WeakObjectType(x) \u2192 ObjectType(x)) \u2200(x)(NestedObjectType(x) \u2192 ObjectType(x)) \u2200(x)(AssociativeObjectType(x) \u2192 ObjectType(x))\n\u2022 disjointness (first textual constraint) \u2200(x)(\u00ac(QualifiedRelationship(x) \u2227 AttributiveProperty(x))) \u2200(x)(\u00ac(QualifiedRelationship(x) \u2227 Subsumption(x))) \u2200(x)(\u00ac(AttributiveProperty(x) \u2227 Subsumption(x)))"}, {"heading": "2.2 Overview of the Constraints", "text": "There are several types of constraints in modelling languages, and this is reflected in the number of nodes in the graph in figure 2. The main is relation in the figue does not show all the siblings at the same level due to space limitations. In this section we only show the different types of constraints. In later sections, each constraint type is analyzed in detail together with related static entities.\nFormalization of Constraint types\n\u2022 isa \u2200(x)(CardinalityConstraint(x) \u2192 Constraint(x)) \u2200(x)(SubsetConstraint(x) \u2192 Constraint(x)) \u2200(x)(JoinConstraint(x) \u2192 Constraint(x)) \u2200(x)(UniquenessConstraint(x) \u2192 Constraint(x)) \u2200(x)(RelationshipConstraint(x) \u2192 Constraint(x)) \u2200(x)(DisjointnessConstraint(x) \u2192 Constraint(x)) \u2200(x)(EqualityConstraint(x) \u2192 Constraint(x)) \u2200(x)(ValueConstraint(x) \u2192 Constraint(x)) \u2200(x)(CompletenessConstraint(x) \u2192 Constraint(x)) \u2200(x)(ValueComparisonConstraint(x) \u2192 Constraint(x)) \u2200(x)(IdentificationConstraint(x) \u2192 Constraint(x)) \u2200(x)(MandatoryConstraint(x) \u2192 Constraint(x))\n\u2022 isa (disjoint, complete) \u2200(x)(CompoundCardinalityConstraint(x) \u2192 CardinalityConstraint(x)) \u2200(x)(AttributivePropertyCardinality(x) \u2192 CardinalityConstraint(x)) \u2200(x)(ObjectTypeCardinality(x) \u2192 CardinalityConstraint(x)) \u2200(x)(\u00ac(CompoundCardinalityConstraint(x) \u2227 AttributivePropertyCardinality(x))) \u2200(x)(\u00ac(CompoundCardinalityConstraint(x) \u2227 ObjectTypeCardinality(x))) \u2200(x)(\u00ac(AttributivePropertyCardinality(x) \u2227 ObjectTypeCardinality(x))) \u2200(x)(CardinalityConstraint(x) \u2192 (CompoundCardinalityConstraint(x)\u2228\nAttributivePropertyCardinality(x) \u2228 ObjectTypeCardinality(x)))\n\u2022 isa (disjoint) \u2200(x)(JoinSubsetConstraint(x) \u2192 JoinConstraint(x)) \u2200(x)(JoinEqualityConstraint(x) \u2192 JoinConstraint(x)) \u2200(x)(JoinDisjointnessConstraint(x) \u2192 JoinConstraint(x)) \u2200(x)(\u00ac(JoinSubsetConstraint(x) \u2227 JoinEqualityConstraint(x))) \u2200(x)(\u00ac(JoinSubsetConstraint(x) \u2227 JoinDisjointnessConstraint(x))) \u2200(x)(\u00ac(JoinEqualityConstraint(x) \u2227 JoinDisjointnessConstraint(x)))\n\u2022 isa (disjoint, complete)\n\u2200(x)(InternalUniquenessConstraint(x) \u2192 UniquenessConstraint(x)) \u2200(x)(ExternalUniquenessConstraint(x) \u2192 UniquenessConstraint(x)) \u2200(x)(\u00ac(InternalUniquenessConstraint(x) \u2227 ExternalUniquenessConstraint(x))) \u2200(x)(UniquenessConstraint(x) \u2192 (InternalUniquenessConstraint(x)\u2228\nExternalUniquenessConstraint(x)))\n\u2022 isa (complete) \u2200(x)(Transitivity(x) \u2192 RelationshipConstraint(x)) \u2200(x)(Antisymmetry(x) \u2192 RelationshipConstraint(x)) \u2200(x)(Irreflexivity(x) \u2192 RelationshipConstraint(x)) \u2200(x)(LocalReflexivity(x) \u2192 RelationshipConstraint(x)) \u2200(x)(Symmetry(x) \u2192 RelationshipConstraint(x)) \u2200(x)(RelationshipConstraint(x) \u2192 (Transitivity(x) \u2228 Antisymmetry(x)\u2228\nIrreflexivity(x) \u2228 LocalReflexivity \u2228 Symmetry(x)))\n\u2022 isa \u2200(x)(Asymmetry(x) \u2192 Antisymmetry(x))\n\u2022 isa \u2200(x)(Asymmetry(x) \u2192 Irreflexivity(x))\n\u2022 isa \u2200(x)(Acyclicity(x) \u2192 Asymmetry(x))\n\u2022 isa \u2200(x)(Intransitivity(x) \u2192 Irreflexivity(x))\n\u2022 isa \u2200(x)(StronglyIntransitivity(x) \u2192 Intransitivity(x))\n\u2022 isa \u2200(x)(GlobalReflexivity(x) \u2192 LocalReflexivity(x))\n\u2022 isa \u2200(x)(PurelyReflexivity(x) \u2192 LocalReflexivity(x))\n\u2022 isa (disjoint, complete) \u2200(x)(DisjointRoles(x) \u2192 DisjointnessConstraint(x)) \u2200(x)(DisjointRelationships(x) \u2192 DisjointnessConstraint(x)) \u2200(x)(DisjointObjectTypes(x) \u2192 DisjointnessConstraint(x)) \u2200(x)(\u00ac(DisjointRoles(x) \u2227 DisjointObjectTypes(x))) \u2200(x)(\u00ac(DisjointRoles(x) \u2227 DisjointRelationships(x))) \u2200(x)(\u00ac(DisjointRelationships(x) \u2227 DisjointObjectTypes(x))) \u2200(x)(DisjointnessConstraint(x) \u2192 (DisjointRoles(x)\u2228\nDisjointObjectTypes(x) \u2228 DisjointRelationships(x)))\n\u2022 isa \u2200(x)(JoinDisjointnessConstraint(x) \u2192 DisjointRoles(x))\n\u2022 isa (disjoint, complete) \u2200(x)(RoleEquality(x) \u2192 EqualityConstraint(x)) \u2200(x)(RelationshipEquality(x) \u2192 EqualityConstraint(x)) \u2200(x)(\u00ac(RoleEquality(x) \u2227 RelationshipEquality(x))) \u2200(x)(EqualityConstraint(x) \u2192 (RoleEquality(x) \u2228 RelationshipEquality(x)))\n\u2022 isa \u2200(x)(JoinEqualityConstraint(x) \u2192 RoleEquality(x))\n\u2022 isa (disjoint, complete) \u2200(x)(ValueTypeConstraint(x) \u2192 ValueConstraint(x)) \u2200(x)(RoleValueConstraint(x) \u2192 ValueConstraint(x)) \u2200(x)(AttributeValueConstraint(x) \u2192 ValueConstraint(x)) \u2200(x)(\u00ac(ValueTypeConstraint(x) \u2227 RoleValueConstraint(x))) \u2200(x)(\u00ac(ValueTypeConstraint(x) \u2227 AttributeValueConstraint(x))) \u2200(x)(\u00ac(RoleValueConstraint(x) \u2227 AttributeValueConstraint(x))) \u2200(x)(ValueConstraint(x) \u2192 (ValueTypeConstraint(x)\u2228\nRoleValueConstraint(x) \u2228 AttributeValueConstraint(x)))\n\u2022 isa (disjoint, complete) \u2200(x)(ExternalIdentification(x) \u2192 IdentificationConstraint(x)) \u2200(x)(InternalIdentification(x) \u2192 IdentificationConstraint(x)) \u2200(x)(\u00ac(ExternalIdentification(x) \u2227 InternalIdentification(x))) \u2200(x)(IdentificationConstraint(x) \u2192 (ExternalIdentification(x)\u2228\nInternalIdentification(x)))\n\u2022 isa (disjoint) \u2200(x)(QualifiedIdentification(x) \u2192 ExternalIdentification(x)) \u2200(x)(WeakIdentification(x) \u2192 ExternalIdentification(x)) \u2200(x)(\u00ac(QualifiedIdentification(x) \u2227 WeakIdentification(x)))\n\u2022 isa \u2200(x)(SingleIdentification(x) \u2192 InternalIdentification(x))\n\u2022 isa (disjoint) \u2200(x)(Mandatory(x) \u2192 MandatoryConstraint(x)) \u2200(x)(DisjunctiveMandatory(x) \u2192 MandatoryConstraint(x)) \u2200(x)(\u00ac(MandatoryConstraint(x) \u2227 DisjunctiveMandatory(x)))\n\u2022 isa \u2200(x)(InclusiveMandatory(x) \u2192 DisjunctiveMandatory(x))"}, {"heading": "2.3 Relationships between Relationship, Role and Entity type", "text": "This section goes into detail on relationships and roles in general, and subsequently subsumption and aggregation, and attributes and value types. The main entities and constraints pertaining to relationships are depicted in Figure 3.\nFormalization of Relationship, Role, EntityType and related constraints\n\u2022 composition (1, 2..\u2217) \u2200(x, y)(Contains(x, y) \u2192 Relationship(x) \u2227 Role(y)) \u2200(x)\u2203\u22652y(Contains(x, y)) \u2200(x)(Role(x) \u2192 \u2203=1(y)(Contains(y, x)))\nWe do not need to add asymmetric and irreflexive axioms to the formalization because they are both implicit after the disjointness between Relationship and Role. Also, transitivity is not included since we are dealing with a \u201cdirect parthood\u201d relationship.\nRoleRelationship Entity typerole playing 0..* playslinked to 1..*\n0..*of\n2..*1 contains\nObject type\nNested object type\n1\n0..1 reified as\nobjectifies\nCardinality constraint MinimumCardinality:Integer MaximumCardinality:Integer"}, {"heading": "2.3.1 Subsumption and Aggregation", "text": "The metamodel fragment dealing with subsumption and aggregation is depicted in Figure 4 and has the following logic-based reconstruction."}, {"heading": "Formalization of Subsumption and Aggregation", "text": "\u2022 relation (0..\u2217, 2), subset and union constraints\n\u2200(x, y)(Participant(x, y) \u2192 ((Relationship(x) \u2227 Entity(y))\u2228 (ValueComparisonConstraint(x) \u2227 Role(y))\u2228 (RelationshipConstraint(x) \u2227 Role(y)))) \u2200(x)(Relationship(x) \u2192 \u2203=2(y)(Participant(x, y))) \u2200(x, y)((Participant(x, y) \u2227 Relationship(x)) \u2194 (Sub(x, y)\u2228\nSuper(x, y) \u2228 Part(x, y) \u2228 Whole(x, y)))\n\u2022 relation (1, 0..\u2217), third textual constraint \u2200(x, y)(Sub(x, y) \u2192 (Subsumption(x) \u2227 Entity(y)\u2227\n\u00acQualifiedRelationship(y) \u2227 \u00acAttributiveProperty(y)\u2227 \u00acSubsumption(y) \u2227 \u00acQualifier(y) \u2227 \u00acConstraint(y)))\n\u2200(x)(Subsumption(x) \u2192 \u2203=1(y)(Sub(x, y)))\n\u2022 relation (1, 0..\u2217), third textual constraint \u2200(x, y)(Super(x, y) \u2192 (Subsumption(x) \u2227 Entity(y)\u2227\n\u00acQualifiedRelationship(y) \u2227 \u00acAttributiveProperty(y)\u2227 \u00acSubsumption(y) \u2227 \u00acQualifier(y) \u2227 \u00acConstraint(y)))\n\u2200(x)(Subsumption(x) \u2192 \u2203=1(y)(Super(x, y)))\n\u2022 disjunctive exclusion (not in figure) \u2200(x, y)((Subsumption(x) \u2227 Sub(x, y) \u2227 \u03a6(y)) \u2192 \u2203(z)(\u03a6(z) \u2227 Super(x, z)))\u2217\n\u2200(x, y)((Subsumption(x) \u2227 Super(x, y) \u2227 \u03a6(y)) \u2192 \u2203(z)(\u03a6(z) \u2227 Sub(x, z)))\u2217\nFor all \u03a6 \u2208 {SharedAggregate, CompositeAggregate, Role, DataType, Relationship \u2227 \u00acPartWhole, ObjectType}.\n\u2022 isa \u2200(x, y)(Part(x) \u2192 PartWhole(x))\n\u2022 relation (0..\u2217, 1)\n\u2200(x, y)(Part(x, y) \u2192 ((Part(x) \u2227 AttributiveProperty(y))\u2228 (SharedAggregate(x) \u2227 DataType(y))\u2228 (SharedAggregate(x) \u2227 ObjectType(y)))) \u2200(x)(Part(x) \u2192 \u2203=1(y)(Part(x, y) \u2227 AttributiveProperty(y)))\n\u2022 relation (2..\u2217, 1) \u2200(x, y)(Whole(x, y) \u2192 ((Part(x) \u2227 CompositeAttribute(y))\u2228\n(SharedAggregate(x) \u2227 DataType(y))\u2228 (SharedAggregate(x) \u2227 ObjectType(y))))\n\u2200(x)(Part(x) \u2192 \u2203=1(y)(Whole(x, y) \u2227 CompositeAttribute(y))) \u2200(x)(CompositeAttribute(x) \u2192 \u2203\u22652(y)(Part(y) \u2227 Whole(y, x)))\n\u2022 relation (0..\u2217, 0..1), xor, second textual constraint \u2200(x)(SharedAggregate(x) \u2192 \u2203\u22641(y)((DataType(y) \u2228 ObjectType(y)) \u2227 Part(x, y))) \u2200(x)(SharedAggregate(x) \u2192 (\u2203\u22651(y)(Part(x, y)) \u2227 \u2203\u22651(y)(Whole(x, y))))\n\u2022 relation (0..\u2217, 0..1), xor \u2200(x)(SharedAggregate(x) \u2192 \u2203\u22641(y)((DataType(y) \u2228 ObjectType(y)) \u2227 Whole(x, y)))\nThe last two set of formula only show the disjunction of the xor. The exclusion between DataType and ObjectType is inherited from the disjoint isa in figure 1.\n\u2022 and relationships \u2200(x, y)((SharedAggregate(x) \u2227 DataType(y) \u2227 Part(x, y)) \u2192\n\u2203(z)(DataType(z) \u2227 Whole(x, z)))\u2217\n\u2200(x, y)((SharedAggregate(x) \u2227 DataType(y) \u2227 Whole(x, y)) \u2192 \u2203(z)(DataType(z) \u2227 Part(x, z)))\u2217 \u2200(x, y)((SharedAggregate(x) \u2227 ObjectType(y) \u2227 Part(x, y)) \u2192 \u2203(z)(ObjectType(z) \u2227 Whole(x, z)))\u2217 \u2200(x, y)((SharedAggregate(x) \u2227 ObjectType(y) \u2227 Whole(x, y)) \u2192 \u2203(z)(ObjectType(z) \u2227 Part(x, z)))\u2217\n\u2022 irreflexivity, asymmetry (not in figure) \u2200(x, y, z)((PartWhole(x) \u2227 Part(x, y) \u2227 Whole(x, z)) \u2192 \u00ac(y = z))\u2217\n\u2200(x, y, z)((PartWhole(x) \u2227 Part(x, y) \u2227 Whole(x, z)) \u2192 \u00ac\u2203(v)(PartWhole(v) \u2227 Part(v, z) \u2227 Whole(v, y)))\u2217\n\u2022 relation (0..1, 1) \u2200(x, y)((Part(x, y) \u2227 CompositeAggregate(x)) \u2192 ObjectType(y)) \u2200(x)(CompositeAggregate(x) \u2192 \u2203=1(y)(Part(x, y))) \u2200(x)(CompositeAggregate(x) \u2192 \u2203\u22641(y)(Part(y, x)))\n\u2022 relation (0..\u2217, 1) \u2200(x, y)((CompositeAggregate(x) \u2227 Whole(x, y)) \u2192 ObjectType(y)) \u2200(x)(CompositeAggregate(x) \u2192 \u2203=1(y)(Whole(x, y)))\n\u2022 first textual constraint\n\u2200(x, y)(Compatible(x, y) \u2192 ((ValueProperty(x) \u2227 ValueProperty(y))\u2228 (DataType(x) \u2227 DataType(y))\u2228 (ObjectType(x) \u2227 ObjectType(y))\u2228 (Role(x) \u2227 Role(y))\u2228 (Relationship(x) \u2227 Relationship(y)))) \u2200(x, y)((Compatible(x, y) \u2227 Role(x)) \u2192 \u2203(v, w, s, t)(RolePlaying(x, v, w)\u2227 RolePlaying(y, s, t) \u2227 Compatible(w, t)))\u2217 \u2200(x, y)((Compatible(x, y) \u2227 Relationship(x)) \u2192 ((\u2203=n(z)(Contains(x, z)) \u2194 \u2203=n(z)(Contains(y, z)))\u2227 (\u2203(z, v)(Contains(x, z) \u2227 Contains(y, w) \u2227 Compatible(z, w)))))\u2217 \u2200(x, y, z)((Subsumption(x) \u2227 Sub(x, y) \u2227 Super(x, z)) \u2192 Compatible(y, z))\u2217\nHere n is any natural number from 2 up to the maximum arity of a relationship in the model. Therefore the formula is not second order."}, {"heading": "2.3.2 Attributes and Value Types", "text": "The metamodel fragment concerning attributes and ORM\u2019s counterpart, value types, is shown Figure 5 and has the following logic-based reconstruction."}, {"heading": "Formalization of Attributes and Value Types", "text": "\u2022 relation (0..1, 1), relation (1..2, 1), xor\n\u2200(x, y)(DeclaredOn(x, y) \u2192 ((Qualifier(x) \u2227 Role(y))\u2228 (Qualifier(x) \u2227 QualifiedRelationship(y))\u2228 (MandatoryConstraint(x) \u2227 Role(y))\u2228 (InternalUniquenessConstraint(x) \u2227 Role(y))\u2228 (ExternalIdentification(x) \u2227 Relationship(y))\u2228 (IdentificationConstraint(x) \u2227 ValueProperty(y))\u2228 (IdentificationConstraint(x) \u2227 AttributiveProperty(y))\u2228 (RelationshipEquality(x) \u2227 Relationship(y))\u2228 (DisjointRelationships(x) \u2227 Relationship(y))\u2228 (RoleEquality(x) \u2227 Role(y))\u2228 (DisjointRoles(x) \u2227 Role(y))\u2228 (DisjointEntities(x) \u2227 Subsumption(y))\u2228 (ObjectTypeEquality(x) \u2227 ObjectType(y))\u2228 (CompletenessConstraint(x) \u2227 Subsumption(y)))) \u2200(x)(Qualifier(x) \u2192 \u2203=1(y)(DeclaredOn(x, y) \u2227 (Role(y) \u2228 QualifiedRelationship(y)))) \u2200(x)(Role(x) \u2192 \u2203\u22641(y)(Qualifier(y) \u2227 DeclaredOn(y, x))) \u2200(x)(QualifiedRelationship(x) \u2192 (\u2203\u22651(y)(Qualifier(y) \u2227 DeclaredOn(y, x))\u2227 \u2203\u22642(y)(Qualifier(y) \u2227 DeclaredOn(y, x)))) \u2200(x, y, z)((DeclaredOn(x, y) \u2227 DeclaredOn(x, z) \u2227 Qualifier(x) \u2227 Role(y)) \u2192 Role(z)))\u2217 \u2200(x, y, z)((DeclaredOn(x, y) \u2227 DeclaredOn(x, z) \u2227 Qualifier(x)\u2227 QualifiedRelationship(y)) \u2192 QualifiedRelationship(z)))\u2217\n\u2022 composition (0..\u2217, 1..\u2217), or \u2200(x, y)(HasComponent(x, y) \u2192 (Qualifier(x)\u2227(DimensionalAttribute(y)\u2228Attribute(y)))) \u2200(x)(Qualifier(x) \u2192 \u2203\u22651(y)(HasComponent(x, y)))\n\u2022 relation (0..\u2217, 0..\u2217) \u2200(x, y)(Domain(x, y) \u2192 ((AttributiveProperty(x) \u2227 Relationship(y))\u2228\n(AttributiveProperty(x) \u2227 ObjectType(y)) \u2228 (MappedTo(x) \u2227 ValueType(y))\u2228 (ValueProperty(x) \u2227 ObjectType(y))))\n\u2022 relation (0..\u2217, 1) \u2200(x, y)(Range(x, y) \u2192 ((AttributiveProperty(x) \u2227 DataType(y))\u2228\n(MappedTo(x) \u2227 DataType(y)))) \u2200(x)(AttributiveProperty(x) \u2192 \u2203=1(y)(DataType(y) \u2227 Range(x, y)))\n\u2022 relation (0..\u2217, 1..\u2217) \u2200(x)(ValueProperty(x) \u2192 \u2203\u22651(y)(Domain(x, y) \u2227 ObjectType(y)))\n\u2022 relation (0..\u2217, 1) \u2200(x)(MappedTo(x) \u2192 \u2203=1(y)(DataType(y) \u2227 Range(x, y)))\n\u2022 ternary relation (0..\u2217, 0..\u2217, 0..\u2217), or \u2200(x, y, z)(DimensionalAttribution(x, y, z) \u2192 (Dimension(x) \u2227 DataType(y)\u2227\n(ObjectType(z) \u2228 Relationship(z))))\nAlthough this formula has three variables, it can be replaced by an equivalent set of several formula in two variables, thus it is not starred. This translation is similar to the process of reification described in Section 3, and it is applied to all ternary relations.\n\u2022 ternary relation (0..\u2217, 0..\u2217, 1) \u2200(x, y, z)(DimensionalValueTyping(x, y, z) \u2192 (Dimension(x)\u2227\nDataType(y) \u2227 DimensionalValueType(z))) \u2200(x)(DimensionalValueType(x) \u2192 \u2203=1(y, z)(DimensionalValueTyping(y, z, x)))"}, {"heading": "2.4 Mandatory Constraints", "text": "Form this section onwards, we turn our focus to constraints that can be represented on the selected conceptual modelling languages. The first one is about the different mandatory constraints, as shown in Figure 6."}, {"heading": "Formalization of Mandatory Constraints", "text": "\u2022 relation (0..\u2217, 1..\u2217) \u2200(x)(MandatoryConstraint(x) \u2192 \u2203\u22651(y)(Role(y) \u2227 DeclaredOn(x, y)))\n\u2022 relation (0..\u2217, 2..\u2217) \u2200(x)(DisjunctiveMandatory(x) \u2192 \u2203\u22652(y)(Role(y) \u2227 DeclaredOn(x, y)))\n\u2022 relation (0..1, 1) \u2200(x)(Mandatory(x) \u2192 \u2203=1(y)(Role(y) \u2227 DeclaredOn(x, y))) \u2200(x)(Role(x) \u2192 \u2203\u22641(y)(DeclaredOn(y, x) \u2227 Mandatory(y)))\n\u2022 constraint on relationships containing roles with the same mandatory constraint, not in diagram\n\u2200(x, y, z, v, w)((DeclaredOn(x, y) \u2227 DeclaredOn(x, z) \u2227 MandatoryConstraint(x)\u2227 Role(y) \u2227 Role(z) \u2227 Contains(w, y) \u2227 Contains(v, z)\u2227 Relationship(v) \u2227 Relationship(w)) \u2192 \u00ac(w = v))\u2217"}, {"heading": "2.5 Uniqueness Constraints", "text": "The second core constraints in the languages is uniqueness, as shown in Figure 7, which is formalised as follows."}, {"heading": "Formalization of Uniqueness Constraints", "text": "\u2022 relation (0..\u2217, 1..\u2217) \u2200(x)(InternalUniquenessConstraint(x) \u2192 \u2203\u22651(y)(Role(y) \u2227 DeclaredOn(x, y)))\n\u2022 ternary relation (1, 0; 2..\u2217, 0; 2..\u2217), third textual constraint \u2200(x, y, z)(ExtUnique(x, y, z) \u2192 (ExternalUniquenessConstraint(x)\u2227\nRole(y) \u2227 Relationship(z) \u2227 Contains(z, y)))\u2217\n\u2200(x)(ExternalUniquenessConstraint(x) \u2192 \u2203=1(y, z)(ExtUnique(x, y, z))) \u2200(x)(Role(x) \u2192 (\u2203=0(y, z)(ExternalUnique(y, x, z))\u2228 \u2203\u22652(y, z)(ExternalUnique(y, x, z)))) \u2200(x)(Relationship(x) \u2192 (\u2203=0(y, z)(ExternalUnique(y, z, x))\u2228\n\u2203\u22652(y, z)(ExternalUnique(y, z, x))))\n\u2022 first textual constraint \u2200(x, y, z)((InternalUniquenessConstraint(x) \u2227 Role(y) \u2227 DeclaredOn(x, y)\u2227\nRelationship(z) \u2227 Contains(z, y)) \u2192 (\u2203=n(w)(Contains(z, w)) \u2194 \u2203\u2264n(v)(DeclaredOn(x, v))))\u2217\nThis is necessary first order since n is any natural number up to the maximum arity of any relationships in the model.\n\u2022 second textual constraint \u2200(x)(ExternalUniquenessConstraint(x) \u2192 (\u2203=n(y)\u2203(z)(ExternalUnique(x, y, z)\n\u2194 \u2203=n(z)\u2203(y)ExternalUnique(x, y, z))))\u2217\nThis is necessary first order since n is any natural number up to the maximum arity of a relationships in the model."}, {"heading": "2.6 Identification Constraints", "text": "The metamodel fragment concerning identifiers (Figure 8), while comprehensive in its treatment, does not deal with definitions of identity (see [Keet, 2011] for a brief discussion on this topic). How identification is dealt with in the languages is formalised as follows."}, {"heading": "Formalization of Identification Constraints", "text": "\u2022 relation (0..\u2217, 1) \u2200(x, y)(PartiallyIdentifies(x, y) \u2192\n(QualifiedIdentification(x) \u2227 QualifiedRelationship(y))) \u2200(x)(QualifiedIdentification(x) \u2192 \u2203=1(y)(PartiallyIdentifies(x, y)))\n\u2022 relation (0..\u2217, 1..\u2217) \u2200(x)(ExternalIdentification(x) \u2192 \u2203\u22651(y)(DeclaredOn(x, y))\n\u2022 relation (1..\u2217, 1) \u2200(x, y)(Identifies(x, y) \u2192 (IdentificationConstraint(x) \u2227 ObjectType(y))) \u2200(x)(IdentificationConstraint(x) \u2192 \u2203=1(y)(Identifies(x, y))) \u2200(x)(ObjectType(x) \u2192 \u2203\u22651(y)(Identifies(y, x)))\n\u2022 relation (0..\u2217, 0..\u2217), xor, mandatory (not in diagram)\n\u2200(x, y, z)((DeclaredOn(x, y) \u2227 DeclaredOn(x, z)\u2227 IdentificationConstraint(x) \u2227 ValueProperty(y)) \u2192 ValueProperty(z))\u2217 \u2200(x, y, z)((DeclaredOn(x, y) \u2227 DeclaredOn(x, z)\u2227 IdentificationConstraint(x) \u2227 AttributiveProperty(y)) \u2192 AttributiveProperty(z))\u2217 \u2200(x)(IdentificationConstraint(x) \u2192 \u2203(y)(DeclaredOn(x, y)))\n\u2022 relation (0..1, 1) \u2200(x, y)((DeclaredOn(x, y) \u2227 SingleIdentification(x)) \u2192 (Attribute(y) \u2228 ValueType(y))) \u2200(x)(SingleIdentification(x) \u2192 \u2203=1(y)(DeclaredOn(x, y)) \u2200(x)((Attribute(x) \u2228 ValueType(x)) \u2192 \u2203\u22641(y)(DeclaredOn(y, x)\u2227\nSingleIdentification(y)))\nXor is inherited from previous set of formula.\n\u2022 relation (1..\u2217, 1) \u2200(x, y)((Identifies(x, y) \u2227 WeakIdentification(x)) \u2192 WeakObjectType(y)) \u2200(x)(WeakIdentification(x) \u2192 \u2203=1(y)(Identifies(x, y))) \u2200(x)(WeakObjectType(x) \u2192 \u2203\u22651(y)(WeakIdentification(y)\u2227\nIdentifies(y, x)))\n\u2022 relation (0..\u2217, 1) \u2200(x, y)(HasStrong(x, y) \u2192 (WeakObjectType(x) \u2227 ObjectType(y))) \u2200(x)(WeakObjectType(x) \u2192 \u2203=1(y)(HasStrong(x, y)))\n\u2022 first textual constraint\n\u2200(x, y, z)((WeakIdentification(x) \u2227 Identifies(x, y) \u2227 DeclaredOn(x, z)) \u2192 ((AttributiveProperty(z) \u2227 Domain(z, y))\u2228 \u2203=1(v, w, s)(IdentificationConstraint(v) \u2227 Identifies(v, w)\u2227 Relationship(s)\u2227DeclaredOn(v, z)\u2227Participant(s, w)\u2227Participant(s, y))))\u2217 \u2200(x, y, z, v, w, s, t)((WeakIdentification(x) \u2227 Identifies(x, y) \u2227 DeclaredOn(x, s)\u2227 IdentificationConstraint(v, w) \u2227 Identifies(v, t)\u2227 DeclaredOn(v, s)) \u2192 \u00ac(y = t))\u2217\n\u2022 second textual constraint \u2200(x, y, z)((SingleIdentification(x) \u2227 Identifies(x, y) \u2227 DeclaredOn(x, z)) \u2192\n\u2203(v)(CardO(z, y, v) \u2227 MinimumCardinality(v, 1) \u2227 MaximumCardinality(v, 1)))\u2217\n\u2022 third textual constraint \u2200(x, y)((QualifiedIdentification(x) \u2227 DeclaredOn(x, y)) \u2192 AttributiveProperty(y)) \u2200(x, y)((ExternalIdentification(x) \u2227 DeclaredOn(x, y)) \u2192 AttributiveProperty(y))\n\u2022 fourth textual constraint \u2200(x, y)(PartiallyIdentifies(x, y) \u2192 \u2203(z, v, w)(RolePlaying(z, v, w)\u2227\nContains(y, z) \u2227 MinimumCardinality(v, 1) \u2227 MaximumCardinality(v, 1)))\u2217"}, {"heading": "2.7 Cardinality Constraints", "text": "The fourth important constraint of the languages are the cardinality constraints; see Figure 9, which is formalised below."}, {"heading": "Formalization of Cardinality Constraints", "text": "\u2022 ternary relationship (0..\u2217, 0..\u2217, 0..\u2217) \u2200(x, y, z)(CardR(x, y, z) \u2192 (AttributiveProperty(x) \u2227 Relationship(y)\u2227\nCardinalityConstraint(z)))\n\u2022 ternay relation (0..\u2217, 0..\u2217, 0..\u2217) \u2200(x, y, z)(CardO(x, y, z) \u2192 (AttributiveProperty(x) \u2227 ObjectType(y)\u2227\nCardinalityConstraint(z)))\n\u2022 ternary relation (0..\u2217, 0; 2..\u2217, 1) \u2200(x, y, z)(Frequency(x, y, z) \u2192 (Relationship(x) \u2227 Role(y)\u2227\nCompoundCardinalityConstraint(z)))\n\u2200(x)(CompoundCardinalityConstraint(x) \u2192 \u2203=1(y, z)(Frequency(y, z, x)) \u2200(x)(Role(x) \u2192 (\u2203=0(y, z)(Frequency(y, x, z))\u2228\n\u2203\u22652(y, z)(Frequency(y, x, z))))\n\u2022 first and second textual constraint \u2200(x)(CardinalityConstraint(x) \u2192 \u2203(y)(MaximumCardinality(x, y)\u2228\nMinimumCardinality(x, y)))\nThe other part of these constraints are implicit from the formalization of attributes. The second constraint is implicit from the inheritance.\n\u2022 isa, third textual constraint \u2200(x)(CompoundCardinalityConstraint(x) \u2192 CardinalityConstraint(x)) \u2200(x, y, z, v, w)((Frequency(x, y, z) \u2227 Frequency(v, w, z)) \u2192\n((x = v) \u2227 Contains(x, y) \u2227 Contains(v, w) \u2227 \u00ac(y = w)))\u2217"}, {"heading": "2.8 Value type, Role and Attribute Value constraints", "text": "The formalisation of value types and role and attribute constraints is rather elegant compared to the difficulty of drawing that metamodel fragment (Figure 10), for there are repeating components to it that can be more easily captured in FOL."}, {"heading": "Formalization of Value type, Role and Attribute Value Constraints", "text": "\u2022 ternary relations (1, 0..\u2217, 0..\u2217), xor\n\u2200(x,w, z)(ConstrainingValues(x, y, z) \u2192 (((ValueTypeConstraint(x)\u2227 ValueProperty(y)) \u2228 (RoleValueConstraint(x) \u2227 Role(y))\u2228 (AttributeValueConstraint(x) \u2227 Attribute(y)))\u2227 (ValueEnumeration(z) \u2228 ValueRange(z)))) \u2200(x)(ValueTypeConstraint(x) \u2192 \u2203=1(y, z)(ConstrainingValues(x, y, z))) \u2200(x)(RoleValueConstraint(x) \u2192 \u2203=1(y, z)(ConstrainingValues(x, y, z))) \u2200(x)(AttributeValueConstraint(x) \u2192 \u2203=1(y, z)(ConstrainingValues(x, y, z))) \u2200(x)(ValueEnumeration(x) \u2192 \u00acValueRange(x)) \u2200(x)(ValueRange(x) \u2192 \u00acValueEnumeration(x))\n\u2022 relation (0..\u2217, 1) \u2200(x, y)(HasType(x, y) \u2192 (ValueRange(x) \u2227 DataType(y))) \u2200(x)(ValueRange(x) \u2192 \u2203=1(y)(HasType(x, y)))\n\u2022 attributes \u2200(x, y)((ValueRange(x) \u2227 MinimumValue(x, y)) \u2192 Literal(y)) \u2200(x, y)((ValueRange(x) \u2227 MaximumValue(x, y)) \u2192 Literal(y)) \u2200(x)(ValueRange(x) \u2192 \u2203=1(y)(MinimumValue(x, y))) \u2200(x)(ValueRange(x) \u2192 \u2203=1(y)(MaximumValue(x, y)))\nIn this figure we assign cardinalities [1..1] to both attributes. The type Literal is a data type covering all textual representations of values from simple data types in the model."}, {"heading": "2.9 Value comparison constraints", "text": "The metamodel fragment for value comparison constraints is depicted in Figure 11. Note that in the formalisation below, a textual representation is chosen for the comparison operators.\n\u2022 relation (0..\u2217, 2) role subset, first textual constraint\n\u2200(x)(ValueComparisonConstraint(x) \u2192 \u2203=2(y)(Participant(x, y))) \u2200(x, y)(First(x, y) \u2192 ((ValueComparisonConstraint(x) \u2227 Role(y))\u2228 (RelationshipConstraint(x) \u2227 Role(y)))) \u2200(x, y)(Second(x, y) \u2192 ((ValueComparisonConstraint(x) \u2227 Role(y))\u2228 (RelationshipConstraint(x) \u2227 Role(y)))) \u2200(x, y)(First(x, y) \u2192 Participant(x, y)) \u2200(x, y)(Second(x, y) \u2192 Participant(x, y)) \u2200(x, y)((Participant(x, y) \u2227 ValueComparisonConstraint(x)) \u2192 (First(x, y) \u2228 Second(x, y))) \u2200(x, y)(\u00ac(First(x, y) \u2227 Second(x, y) \u2227 ValueComparisonConstraint(x))) \u2200(x)(ValueComparisonConstraint(x) \u2192 \u2203=1(y)(First(x, y))) \u2200(x)(ValueComparisonConstraint(x) \u2192 \u2203=1(y)(Second(x, y)))\n\u2022 nominals \u2200(x, y)(ComparisonOperatorOf(x, y) \u2192 (ValueComparisonConstraint(x) \u2227 Operator(y))) \u2200(x)(ValueComparisonConstraint(x) \u2192 \u2203=1(y)(ComparisonOperatorOf(x, y))) \u2200(x)(Operator(x) \u2192 ((x = Less) \u2228 (x = Leq) \u2228 (x = Eq)\u2228\n(x = Neq) \u2228 (x = Geq) \u2228 (x = Greater))) \u2200(x)((x = Less) \u2192 (Operator(x) \u2227 \u00ac(x = Leq) \u2227 \u00ac(x = Eq)\u2227 \u00ac(x = Neq) \u2227 \u00ac(x = Geq) \u2227 \u00ac(x = Greater))) \u2200(x)((x = Leq) \u2192 (Operator(x) \u2227 \u00ac(x = Less) \u2227 \u00ac(x = Eq)\u2227 \u00ac(x = Neq) \u2227 \u00ac(x = Geq) \u2227 \u00ac(x = Greater))) \u2200(x)((x = Eq) \u2192 (Operator(x) \u2227 \u00ac(x = Less) \u2227 \u00ac(x = Leq)\u2227 \u00ac(x = Neq) \u2227 \u00ac(x = Geq) \u2227 \u00ac(x = Greater))) \u2200(x)((x = Neq) \u2192 (Operator(x) \u2227 \u00ac(x = Less) \u2227 \u00ac(x = Leq)\u2227 \u00ac(x = Eq) \u2227 \u00ac(x = Geq) \u2227 \u00ac(x = Greater))) \u2200(x)((x = Geq) \u2192 (Operator(x) \u2227 \u00ac(x = Less) \u2227 \u00ac(x = Leq)\u2227 \u00ac(x = Eq) \u2227 \u00ac(x = Neq) \u2227 \u00ac(x = Greater))) \u2200(x)((x = Greater) \u2192 (Operator(x) \u2227 \u00ac(x = Less) \u2227 \u00ac(x = Leq)\u2227\n\u00ac(x = Eq) \u2227 \u00ac(x = Neq) \u2227 \u00ac(x = Geq)))\nOperator is the name assigned to the concept associated with the nominals in Figure 11. These nominals are the only operators allowed, and they are all different.\n\u2022 relation (1, 0..\u2217) \u2200(x, y)(OnValueOfType(x, y) \u2192 (ValueComparisonConstraint(x) \u2227 DataType(y))) \u2200(x)(ValueComparisonConstraint(x) \u2192 \u2203=1(y)(OnValueOfType(x, y)))\n\u2022 second textual constraint \u2200(x, y, z)((ValueComparisonConstraint(x) \u2227 First(x, y) \u2227 Second(x, z)) \u2192\n\u2203(u, v, w)(RolePlaying(y, u, v) \u2227 RolePlaying(z, w, v) \u2227 DataType(v)))\u2217"}, {"heading": "2.10 Role and Relationship constraints", "text": "Constraints among roles and relationship are shown in Figure 12, and it, with its repetitive list of similar textual constraints are formalised afterward in this section. The Relationship constraints (reflexivity etc.) are presented afterward in Figure 13 and its formalisation. This section closes with the metamodel fragment for ORM\u2019s join constraints, depicted in Figure 14 and formalised at the end of this section, therewith completing the metamodel and its FOL formalisation.\nFormalization of Equality and Disjointness Constraints\n\u2022 four relations DeclaredOn (0..\u2217, 2..\u2217) \u2200(x)(RelationshipEquality(x) \u2192 \u2203\u22652(y)(DeclaredOn(x, y))) \u2200(x)(DisjointRelationships(x) \u2192 \u2203\u22652(y)(DeclaredOn(x, y))) \u2200(x)(RoleEquality(x) \u2192 \u2203\u22652(y)(DeclaredOn(x, y))) \u2200(x)(DisjointRoles(x) \u2192 \u2203\u22652(y)(DeclaredOn(x, y)))\n\u2022 two relations DeclaredOn (0..\u2217, 1) \u2200(x)(CompletenessConstraint(x) \u2192 \u2203=1(y)(DeclaredOn(x, y))) \u2200(x)(DisjointEntities(x) \u2192 \u2203=1(y)(DeclaredOn(x, y)))\n\u2022 two relations hasParticipant (0..\u2217, 2..\u2217) \u2200(x, y)(HasParticipant(x, y) \u2192 ((CompletenessConstraint(x) \u2228 DisjointEntities(x))\u2227\nEntity(y) \u2227 \u00acQualifiedRelationship(y) \u2227 \u00acSubsumption(y)\u2227 \u00acAttributiveProperty(y) \u2227 \u00acQualifier(y) \u2227 \u00acConstraint(y)))\n\u2200(x)(CompletenessConstraint(x) \u2192 \u2203\u22652(y)(HasParticipant(x, y))) \u2200(x)(DisjointEntities(x) \u2192 \u2203\u22652(y)(HasParticipant(x, y)))\n\u2022 textual constraints\n\u2200(x, y)((DisjointEntities(x) \u2227 HasParticipant(x, y)) \u2192 \u2203(z)(DeclaredOn(x, z) \u2227 Subsumption(z) \u2227 Sub(z, y)))\u2217 \u2200(x, y, z)((DisjointEntities(x) \u2227 DeclaredOn(x, y) \u2227 Sub(y, z)) \u2192 HasParticipant(x, z))\u2217 \u2200(x, y)((CompletenessConstraint(x) \u2227 HasParticipant(x, y)) \u2192 \u2203(z)(DeclaredOn(x, z) \u2227 Subsumption(z) \u2227 Sub(z, y)))\u2217 \u2200(x, y, z)((CompletenessConstraint(x) \u2227 DeclaredOn(x, y) \u2227 Sub(y, z)) \u2192 HasParticipant(x, z))\u2217 \u2200(x, y)(Compatible(x, y) \u2192 ((ValueProperty(x) \u2227 ValueProperty(y))\u2228 (DataType(x) \u2227 DataType(y))\u2228 (ObjectType(x) \u2227 ObjectType(y))\u2228 (Role(x) \u2227 Role(y))\u2228 (Relationship(x) \u2227 Relationship(y)))) \u2200(x, y)((Compatible(x, y) \u2227 Role(x)) \u2192 \u2203(v, w, s, t)(RolePlaying(x, v, w) \u2227 RolePlaying(y, s, t) \u2227 Compatible(w, t)))\u2217 \u2200(x, y)((Compatible(x, y) \u2227 Relationship(x)) \u2192 ((\u2203=n(z)(Contains(x, z)) \u2194 \u2203=n(z)(Contains(y, z)))\u2227 (\u2203(z, v)(Contains(x, z) \u2227 Contains(y, w) \u2227 Compatible(z, w)))))\u2217 \u2200(x, y, z)((DisjointRelationships(x) \u2227 DeclaredOn(x, y) \u2227 DeclaredOn(x, z)) \u2192 Compatible(y, z))\u2217 \u2200(x, y, z)((DisjointRoles(x) \u2227 DeclaredOn(x, y) \u2227 DeclaredOn(x, z)) \u2192 (Compatible(y, z)\u2227 \u2200(v, w)((Contains(v, y) \u2227 Contains(w, z)) \u2192 \u00ac(y = z))))\u2217 \u2200(x, y, z)((RoleEquality(x) \u2227 DeclaredOn(x, y) \u2227 DeclaredOn(x, z)) \u2192 (Compatible(y, z)\u2227 \u2200(v, w)((Contains(v, y) \u2227 Contains(w, z)) \u2192 \u00ac(y = z))))\u2217 \u2200(x, y, z)((RelationshipEquality(x) \u2227 DeclaredOn(x, y) \u2227 DeclaredOn(x, z)) \u2192 Compatible(y, z))\u2217\nThis is necessary first order since n is any natural number up to the maximum arity of a relationships in the model."}, {"heading": "Formalization of Relationship Constraints", "text": "\u2022 relation (0..4, 2) \u2200(x)(RelationshipConstraint(x) \u2192 \u2203=2(y)(Participant(x, y))) \u2200(x)(Role(x) \u2192 \u2203\u22644(y)(Participant(y, x)))\n\u2022 two relations (0..\u2217, 1), subset, union \u2200(x, y)((Participant(x, y) \u2227 RelationshipConstraint(x)) \u2192 (First(x, y) \u2228 Second(x, y))) \u2200(x, y)(\u00ac(First(x, y) \u2227 Second(x, y) \u2227 RelationshipConstraint(x))) \u2200(x)(RelationshipConstraint(x) \u2192 \u2203=1(y)(First(x, y))) \u2200(x)(RelationshipConstraint(x) \u2192 \u2203=1(y)(Second(x, y)))\n\u2022 textual constraint \u2200(x, y, z)((RelationshipConstraint(x, y) \u2227 RelationshipConstraint(x, z)\u2227\nFirst(x, y) \u2227 Second(x, z)) \u2192 (Compatible(y, z)\u2227 \u2203(w)(Contains(w, y) \u2227 Contains(w, z))))\u2217"}, {"heading": "Formalization of Join Constraints", "text": "\u2022 ternary relation (0..\u2217, 1, 0..\u2217) \u2200(x, y, z)(Joining(x, y, z) \u2192 (Relationship(x) \u2227 Role(z) \u2227 JoinConstraint(y))) \u2200(x)(JoinConstraint(x) \u2192 \u2203=1(y, z)(Joining(y, x, z)))\n\u2022 relation (3..4, 0..\u2217) and relation (4, 0..\u2217) \u2200(x, y)(ParticipatesIn(x, y) \u2192 (JoinConstraint(y) \u2227 (Relationship(x) \u2228 Role(x)))) \u2200(x)(JoinConstraint(x) \u2192 (\u2203=3(y)(Relationship(y) \u2227 ParticipatesIn(y, x))\u2228\n\u2203=4(y)(Relationship(y) \u2227 ParticipatesIn(x, y)))) \u2200(x)(JoinConstraint(x) \u2192 \u2203=4(y)(Role(y) \u2227 ParticipatesIn(y, x)))\n\u2022 first textual constraint \u2200(x, y)((JoinConstraint(x) \u2227 Role(y) \u2227 ParticipatesIn(y, x)) \u2192\n\u2203(z)(Relationship(z) \u2227 Contains(z, y) \u2227 ParticipatesIn(z, x)))\u2217"}, {"heading": "2.11 On the complexity of the FOL formalization", "text": "The complete FOL formalization of the metamodel is probably undecidable. We have complex formula in five variables, counting quantifiers, and ternary predicates. Even if we reify ternary relations, the complexity of deciding if a given formula follows from some instantiated metamodel is similar to that of the general satisfiability problem. Problematic formula belong though to textual constraints of the figures; they are not originated from the graphical language of UML class diagrams. So if we remove from the metamodel all formula labeled with a \u201c\u2217\u201d, then we obtain a lighter formalization described in C2, the fragment of function-free FOL with only two variables and counting quantifiers. This fragment is not only decidable, but also in NEXPTIME, as shown in [Pratt-Hartmann, 2005]. Most description logics are also subsets of C2.\nThis lighter version of the metamodel is the basis for the OWL 2 version described in next section."}, {"heading": "3 OWL 2 version of the metamodel", "text": "Considering that the complete formalisation of the metamodel requires full FOL, hence, using an undecidable language, we also look at representing a subset in a decidable language to facilitate the metamodel\u2019s use in various applications. A relevant and popular logic language in this\ncontext is OWL, so that, thanks to the tools that can process it, we also can have some form of verification that our model is consistent (at least for what is representable in OWL 2 DL). This OWL version of the metamodel (v1.2) is available at http://www.meteck.org/files/ ontologies/metamodelCDML.owl.\nThe OWL version is larger than the number of entities in the diagrams of the preceding section, and has 99 classes, 61 object properties, 2 data properties, and overall 657 axioms, and the language used is SHIQ(D) (data from Prote\u0301ge\u0301 v4.3\u2019s \u201contology metrics\u201d page), i.e., using features of OWL 2 DL [Motik et al., 2009] and in particular the qualified cardinality. Because the diagrams were made in Omnigraffle1, no UML-in-Omnigraffle to OWL tool exists, there are textual constraints in our metamodel that can be captured formally, and other UML-to-OWL tools are partial, we formalised the metamodel manually. Further, due to the limitations of OWL on the one hand, and the greater expressiveness regarding other features, there is no exact match between the metamodel and the OWL file. We describe the main changes and design decisions in the remainder of this section.\nMissing information. The first thing to note is that the ternary and quaternary associations of the metamodel could not be represented in OWL, and thus had to be approximated. We used the following procedure for this, which is similar to procedures mentioned elsewhere (e.g., the ontology design pattern in [Presutti et al., 2008]):\n1. Add new class ReifiedNAry, 2. If the n-ary was not reified already then add it as subclass of ReifiedNAry and append it\nwith an R, if present already then add a subsumption to ReifiedNAry. 3. Add n binaries between said class and the others, where the binaries have a naming scheme\nof the name of the n-ary appended with a number (1, 2 etc.) to distinguish them from real object properties, and add domain and range classes. 4. These numbered object properties are not to be used as real object properties elsewhere in the OWL file. 5. Add an exactly 1 (or other cardinality constraint, depending on the constraint in the model) from the ReifiedNAryR to the participating class. Note that several ternary relations in the metamodel are already reified, since one of their participant has cardinality constraint 1..1. For these relations, the above procedure can be simplified.\nOther information missing from the OWL file are the textual constraints whose formula are marked with \u201c\u2217\u201d in the FOL formalisations, because these constraints cannot be expressed in OWL. Also, a few other complex constraints, such as the \u201cThe Single identification has a Mandatory constraint on the participating Role and the Relationship that Role is contained in has a 1:1 Cardinality constraint declared on it.\u201d (see second textual constraint in Figure 8), are not included due to OWL\u2019s expressiveness limitations.\nOther modelling artefacts. Some other representation choices had to be made. We note them here for information and documentation; their rationale is outside the scope of this technical report.\nThere are several entities that were not subsumed by anything in particular, such as MaximumCardinality, MinimumCardinality, Dimension, and ValueRange, which have now been made an OWL subclass of Abstract. This also meant that the four attributes in the metamodel have been \u2018flattened\u2019 on the OWL file, i.e., instead of one binary from class to data type with OWL\u2019s data property, it uses a separate part relation and then a hasCValue and hasValue, respectively, to the values.\nThe participation of IdentificationConstraint is twice 0..* in the figure, but that is translated into OWL as \u201csome (ValueProperty or AttributiveProperty)\u201d, because the constraint has to be\n1https://www.omnigroup.com/omnigraffle; last accessed 5-12-2014.\ndeclared on something. The comparison operators of Figure 11 are written out in text and represented as subclasses of Comparison and is made the disjoint union of its subclasses, and the ValueComparisonConstraint is given exactly 1 Comparison.\nIt has been shown that using OWL 2\u2019s new feature of inverse object properties results in better reasoner performance [Keet et al., 2014]. Therefore, we chose not to use object properties \u2018in both directions\u2019, but use that instead. For instance constrainedWith has not been used in the OWL file, but instead, in Prote\u0301ge\u0301 notation, inverse(declaredOn).\nWe have added partOf, properPartOf, and hasPart.\nSatisfiability and consistency checking. We checked the OWL-ized metamodel with the automated reasoner HerMiT v1.3.8 that is shipped with Prote\u0301ge\u0301 v4.3. The sole useful inference was the detection of an inconsistency of Asymmetry in the hierarchy of constraints in an earlier version of the metamodel: the {disjoint, complete} on the object subtypes of Relationship constraint in [Keet and Fillottrani, 2013] had to be changed into {complete} in Figure 2 due to the multiple inheritance of Asymmetry that was overlooked. This has been corrected in this version of the metamodel.\nNon-logician readability/rendering. One may expect a reader who made it this far to be familiar with at least logic or UML notation and thus have a general understanding of the contents of the metamodel and its formalisation. However, as can be observed from the previous paragraphs about the OWL version of it, there are some finer details of that logic reconstruction. Also, the FOL version of the metamodel is rather light on annotations. To facilitate readability, we have generated an online controlled natural language version (verbalization) of the OWL file, which was made with SWAT Natural Language tools [Third et al., 2011]. This easily navigable HTML document is available online at www.meteck.org/files/ontologies/ metamodelNL.html and a section of it is shown in Figure 15."}, {"heading": "4 Final remarks", "text": "We have presented the FOL formalisation of the KF metamodel that serves as a unifying metamodel for the static structural entities of UML Class Diagrams (v2.4.1), ER, EER, ORM, and ORM2. It has to be noted that this indeed requires FOL. Notwithstanding, and with an eye on implementations, we also have created an OWL 2 DL version of it, noting some modelling decisions, such as a pattern for representing n-aries.\nInitial use of the formalisation has been demonstrated in [Fillottrani and Keet, 2014], where the constraints represented among the entities induce validation checking of inter-model assertions and model transformations."}, {"heading": "Acknowledgments", "text": "This work is based upon research supported by the National Research Foundation of South Africa (Project UID90041) and the Argentinean Ministry of Science and Technology. Any opinion, findings and conclusions or recommendations expressed in this material are those of the author and therefore the NRF does not accept any liability in regard thereto."}], "references": [{"title": "Reasoning over extended ER models", "author": ["Artale et al", "A. 2007] Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev"], "venue": "Proceedings of the 26th International Conference on Conceptual Modeling (ER\u201907),", "citeRegEx": "al. et al\\.,? \\Q2007\\E", "shortCiteRegEx": "al. et al\\.", "year": 2007}, {"title": "The Description Logics Handbook \u2013 Theory and Applications", "author": ["Baader et al", "F. 2008] Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. PatelSchneider"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2008\\E", "shortCiteRegEx": "al. et al\\.", "year": 2008}, {"title": "The entity-relationship model\u2014toward a unified view of data", "author": ["Chen", "P.P. 1976] Chen"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "Chen and Chen,? \\Q1976\\E", "shortCiteRegEx": "Chen and Chen", "year": 1976}, {"title": "Conceptual model interoperability: a metamodel-driven approach", "author": ["Fillottrani", "Keet", "P. 2014] Fillottrani", "C. Keet"], "venue": "Proceedings of the 8th International Web Rule Symposium (RuleML\u201914),", "citeRegEx": "Fillottrani et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Fillottrani et al\\.", "year": 2014}, {"title": "Information modeling and relational databases", "author": ["Halpin", "Morgan", "T. 2008] Halpin", "T. Morgan"], "venue": null, "citeRegEx": "Halpin et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Halpin et al\\.", "year": 2008}, {"title": "Exploring reasoning with the DMOP ontology", "author": ["Keet et al", "C. 2014] Keet", "C. d\u2019Amato", "Z. Khan", "A. Lawrynowicz"], "venue": "Workshop on Ontology Reasoner Evaluation (ORE\u201914),", "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "Enhancing identification mechanisms in UML class diagrams with meaningful keys", "author": ["C.M. Keet"], "venue": "[Keet,", "citeRegEx": "Keet,? \\Q2011\\E", "shortCiteRegEx": "Keet", "year": 2011}, {"title": "Toward an ontologydriven unifying metamodel for UML class diagrams, EER, and ORM2", "author": ["Keet", "Fillottrani", "C.M. 2013] Keet", "P.R. Fillottrani"], "venue": "32nd International Conference on Conceptual Modeling (ER\u201913),", "citeRegEx": "Keet et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Keet et al\\.", "year": 2013}, {"title": "An ontology-driven unifying metamodel of UML Class Diagrams, EER, and ORM2", "author": ["Keet", "Fillottrani", "C.M. 2014] Keet", "P.R. Fillottrani"], "venue": "Data & Knowledge Engineering,", "citeRegEx": "Keet et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Keet et al\\.", "year": 2014}, {"title": "OWL 2 web ontology language structural specification and functional-style syntax", "author": ["Motik et al", "B. 2009] Motik", "P.F. Patel-Schneider", "B. Parsia"], "venue": "W3c recommendation,", "citeRegEx": "al. et al\\.,? \\Q2009\\E", "shortCiteRegEx": "al. et al\\.", "year": 2009}, {"title": "A library of ontology design patterns: reusable solutions for collaborative design of networked ontologies. NeOn deliverable D2.5.1", "author": ["Presutti et al", "V. 2008] Presutti", "A. Gangemi", "S. David", "G.A. de Cea", "M.C. Surez-Figueroa", "E. Montiel-Ponsoda", "M. Poveda"], "venue": "NeOn Project,", "citeRegEx": "al. et al\\.,? \\Q2008\\E", "shortCiteRegEx": "al. et al\\.", "year": 2008}, {"title": "Entity relationship model", "author": ["Song", "Chen", "2009] Song", "I.-Y", "P.P. Chen"], "venue": "Encyclopedia of Database Systems,", "citeRegEx": "Song et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Song et al\\.", "year": 2009}, {"title": "OWL to English: a tool for generating organised easily-navigated hypertexts from ontologies", "author": ["Third et al", "A. 2011] Third", "S. Williams", "R. Power"], "venue": "poster/demo paper, Open Unversity UK. 10th International Semantic Web Conference", "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 6, "context": "The metamodel fragment concerning identifiers (Figure 8), while comprehensive in its treatment, does not deal with definitions of identity (see [Keet, 2011] for a brief discussion on this topic).", "startOffset": 144, "endOffset": 156}, {"referenceID": 8, "context": "It has been shown that using OWL 2\u2019s new feature of inverse object properties results in better reasoner performance [Keet et al., 2014].", "startOffset": 117, "endOffset": 136}], "year": 2014, "abstractText": "The KF metamodel [Keet and Fillottrani, 2013, Keet and Fillottrani, 2014] is a comprehensive unifying metamodel covering the static structural entities and constraints of UML Class Diagrams (v2.4.1), ER, EER, ORM, and ORM2, and intended to boost interoperability of common conceptual data modelling languages. It was originally designed in UML with textual constraints, and in this report we present its formalisations in FOL and OWL, which accompanies the paper that describes, discusses, and analyses the KF metamodel in detail. These new formalizations contribute to give a precise meaning to the metamodel, to understand its complexity properties and to provide a basis for future implementations.", "creator": "LaTeX with hyperref package"}}}