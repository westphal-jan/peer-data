{"id": "1502.02551", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2015", "title": "Deep Learning with Limited Numerical Precision", "abstract": "Training of large-scale deep neural networks is often constrained by the available computational resources. We study the effect of limited precision data representation and computation on neural network training. Within the context of low-precision fixed-point computations, we observe the rounding scheme to play a crucial role in determining the network's behavior during training. The technique allows training the network to produce a much more accurate model for each training task. By studying the training, we have learned that the task performance is highly correlated with the training outcome for the training task. When training at a specific location, training may be a more efficient training option than training in the next training phase. By examining the training, we have better predictors of network performance and training effectiveness, as well as a more accurate model for neural networks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Mon, 9 Feb 2015 16:37:29 GMT  (400kb,D)", "http://arxiv.org/abs/1502.02551v1", "10 pages, 6 figures, 1 table"]], "COMMENTS": "10 pages, 6 figures, 1 table", "reviews": [], "SUBJECTS": "cs.LG cs.NE stat.ML", "authors": ["suyog gupta", "ankur agrawal", "kailash gopalakrishnan", "pritish narayanan"], "accepted": true, "id": "1502.02551"}, "pdf": {"name": "1502.02551.pdf", "metadata": {"source": "META", "title": "Deep Learning with Limited Numerical Precision", "authors": ["Suyog Gupta", "Kailash Gopalakrishnan"], "emails": ["suyog@us.ibm.com", "ankuragr@us.ibm.com", "kailash@us.ibm.com", "pnaraya@us.ibm.com"], "sections": [{"heading": "1. Introduction", "text": "To a large extent, the success of deep learning techniques is contingent upon the underlying hardware platform\u2019s ability to perform fast, supervised training of complex networks using large quantities of labeled data. Such a capability enables rapid evaluation of different network architectures and a thorough search over the space of model hyperparameters. It should therefore come as no surprise that recent years have seen a resurgence of interest in deploying largescale computing infrastructure designed specifically for training deep neural networks. Some notable efforts in this direction include distributed computing infrastructure using thousands of CPU cores (Dean et al., 2012; Chilimbi et al., 2014), or high-end graphics processors (GPUs) (Krizhevsky & Hinton, 2009), or a combination of CPUs and GPUs scaled-up to multiple nodes (Coates et al., 2013; Wu et al., 2015).\nAt the same time, the natural error resiliency of neural network architectures and learning algorithms is well-documented, setting them apart from more traditional workloads that typically require precise computations and number representations with high dynamic range. It is well appreciated that in the presence of statistical approximation and estimation errors, high-precision computation in the context of learning is rather unnecessary (Bottou & Bousquet, 2007). Moreover, the addition of noise during training has been shown to improve the neural network\u2019s performance (Murray & Edwards, 1994; Bishop, 1995; Audhkhasi et al., 2013). With the exception of employing the asynchronous version of the stochastic gradient descent algorithm (Recht et al., 2011) to reduce network traffic, the state-of-the-art large-scale deep learning systems fail to adequately capitalize on the error-resiliency of their workloads. These systems are built by assembling general-purpose computing hardware designed to cater to the needs of more traditional workloads, incurring high and often unnecessary overhead in the required computational resources.\nThe work presented in this paper owes its inception to the thinking that it may be possible to leverage algorithm-level noise-tolerance to relax certain constraints on the underlying hardware, leading to a hardware-software co-optimized system that achieves significant improvement in computational performance and energy efficiency. Allowing the low-level hardware components to perform approximate, possibly non-deterministic computations and exposing these hardware-generated errors up to the algorithm level of the computing stack forms a key ingredient in developing such systems. Additionally, the low-level hardware changes need to be introduced in a manner that preserves the programming model so that the benefits can be readily absorbed at the application-level without incurring significant software redevelopment costs. ar X\niv :1\n50 2.\n02 55\n1v 1\n[ cs\n.L G\n] 9\nF eb\n2 01\nAs a first step towards achieving this cross-layer codesign, we explore the use of low-precision fixed-point arithmetic for deep neural network training with a special focus on the rounding mode adopted while performing operations on fixed-point numbers. The motivation to move to fixed-point arithmetic (from the conventional floating-point computations) is twofold. Firstly, fixed-point compute units are typically faster and consume far less hardware resources and power than floating-point engines. The smaller logic footprint of the fixed-point arithmetic circuits would allow for the instantiation of many more such units for a given area and power budget. Secondly, low-precision data representation reduces the memory footprint, enabling larger models to fit within the given memory capacity. Cumulatively, this could provide dramatically improved data-level parallelism.\nThe key finding of our exploration is that deep neural networks can be trained using low-precision fixedpoint arithmetic, provided that the stochastic rounding scheme is applied while operating on fixed-point numbers. We test the validity of the proposed approach by training deep neural networks for the MNIST and CIFAR10 image classification tasks. Deep networks trained using 16-bit wide fixed-point and stochastic rounding achieve nearly the same performance as that obtained when trained using 32-bit floating-point computations. Furthermore, we present a hardware accelerator design, prototyped on an FPGA, that achieves high throughput and low power using a large number of fixed-point arithmetic units, a dataflow architecture, and compact stochastic rounding modules."}, {"heading": "2. Related Work", "text": "Determining the precision of the data representation and the compute units is a critical design choice in the hardware (analog or digital) implementation of artificial neural networks. Not surprisingly, a rich body of literature exists that aims to quantify the effect of this choice on the network\u2019s performance. However, a disproportionately large majority of these studies are focused primarily on implementing just the feed-forward (inference) stage, assuming that the network is trained offline using high precision computations. Some recent studies that embrace this approach have relied on the processor\u2019s vector instructions to perform multiple 8 bit operations in parallel (Vanhoucke et al., 2011), or employ reconfigurable hardware (FPGAs) for highthroughput, energy-efficient inference (Farabet et al., 2011; Gokhale et al., 2014), or take the route of custom hardware implementations (Kim et al., 2014; Merolla et al., 2014).\nPrevious studies have also investigated neural network training using different number representations. Iwata et al. (Iwata et al., 1989) implements the backpropagation algorithm using 24-bit floating-point processing units. Hammerstrom (Hammerstrom, 1990) presents a framework for on-chip learning using 8 to 16 bit fixed-point arithmetic. In (Holt & Hwang, 1993), the authors perform theoretical analysis to understand a neural network\u2019s ability to learn when trained in a limited precision setting. Results from empirical evaluation of simple networks indicate that in most cases, 8-16 bits of precision is sufficient for back-propagation learning. In (Ho\u0308hfeld & Fahlman, 1992), probabilistic rounding of weight updates is used to further reduce (< 8 bits) the precision requirements in gradient-based learning techniques. While these studies provide valuable insights into the behavior of the limited precision training of neural networks, the networks considered are often limited to variants of the classical multilayer perceptron containing a single hidden layer and only a few hidden units. Extrapolating these results to the state-of-the-art deep neural networks that can easily contain millions of trainable parameters is nontrivial. Consequently, there is a need to reassess the impact of limited precision computations within the context of more contemporary deep neural network architectures, datasets, and training procedures.\nA recent work (Chen et al., 2014) presents a hardware accelerator for deep neural network training that employs fixed-point computation units, but finds it necessary to use 32-bit fixed-point representation to achieve convergence while training a convolutional neural network on the MNIST dataset. In contrast, our results show that it is possible to train these networks using only 16-bit fixed-point numbers, so long as stochastic rounding is used during fixed-point computations. To our knowledge, this work represents the first study of application of stochastic rounding while training deep neural networks using low-precision fixed-point arithmetic."}, {"heading": "3. Limited Precision Arithmetic", "text": "Standard implementations of deep neural network training via the back-propagation algorithm typically use 32-bit floating-point (float) representation of real numbers for data storage and manipulation. Instead, consider the generalized fixed-point number representation: [QI.QF], where QI and QF correspond to the integer and the fractional part of the number, respectively. The number of integer bits (IL) plus the number of fractional bits (FL) yields the total number of bits used to represent the number. The\nsum IL + FL is referred to as the word length WL. In this paper, we use the notation \u3008IL, FL\u3009 to denote a fixed-point representation in which IL (FL) correspond to the length of the integer (fractional) part of the number. We also employ to denote the smallest positive number that may be represented in the given fixed-point format. Therefore, the \u3008IL, FL\u3009 fixed-point format limits the precision to FL bits, sets the range to [ \u22122IL\u22121, 2IL\u22121 \u2212 2\u2212FL ] , and defines to be equal to 2\u2212FL."}, {"heading": "3.1. Rounding Modes", "text": "As will be evident in the sections to follow, the rounding mode adopted while converting a number (presumably represented using the float or a higher precision1 fixed-point format) into a lower precision fixed-point representation turns out to be a matter of important consideration while performing computations on fixed-point numbers. Given a number x and the target fixed-point representation \u3008IL, FL\u3009, we define bxc as the largest integer multiple of (= 2\u2212FL) less than or equal to x and consider the following rounding schemes:\n\u2022 Round-to-nearest Round(x, \u3008IL, FL\u3009) =bxc if bxc \u2264 x \u2264 bxc+ 2\nbxc+ if bxc+ 2 < x \u2264 bxc+\n\u2022 Stochastic rounding: The probability of rounding x to bxc is proportional to the proximity of x to bxc:\nRound (x, \u3008IL, FL\u3009) =  bxc w.p. 1\u2212 x\u2212 bxc\nbxc+ w.p. x\u2212 bxc\nStochastic rounding is an unbiased rounding scheme and possesses the desirable property that the expected rounding error is zero, i.e. E (Round (x, \u3008IL, FL\u3009)) = x\nIrrespective of the rounding mode used, if x lies outside the range of \u3008IL, FL\u3009, we saturate the result to either the lower or the upper limit of \u3008IL, FL\u3009:\nConvert (x, \u3008IL, FL\u3009) = \u22122IL\u22121 if x \u2264 \u22122IL\u22121 2IL\u22121 \u2212 2\u2212FL if x \u2265 2IL\u22121 \u2212 2\u2212FL\nRound(x, \u3008IL, FL\u3009) otherwise\n(1)\n1We call \u3008IL1, FL1\u3009 to be a higher precision representation than \u3008IL2, FL2\u3009 iff FL1 > FL2\n3.2. Multiply and accumulate (MACC) operation\nConsider two d-dimensional vectors a and b such that each component is represented in the fixed-point format \u3008IL, FL\u3009, and define c0 = a.b as the inner product of a and b. c0 is also represented in some fixed-point format \u3008 ~IL, ~IF\u3009. We split the computation of c0 into the following two steps:\n1. Compute z = \u2211d i=1 aibi\nThe product of ai and bi produces a fixed-point number in the \u30082 \u2217 IL, 2 \u2217 FL\u3009 format. z can be thought of as a temporary fixed-point register with enough width (number of bits) to prevent saturation/overflow and avoid any loss of precision while accumulating the sum over all products aibi. The requirement on the width of z is log2d+ 2WL in the worst case. Note that the worst case is extremely rare and occurs when all ai and bi are saturated to either the lower or the upper limit of \u3008IL, FL\u3009.\n2. Convert: c0 = Convert(z, \u3008 ~IL, ~IF\u3009)\nThis step invokes the Convert() function defined previously in eq. 1, resulting in either clipping the value in z to the limits set by \u3008 ~IL, ~IF\u3009 or rounding to ~FL bits of fractional precision using the specified rounding mode.\nAdopting this two-step approach has several advantages. Firstly, it closely mimics the behavior of the hardware implementation of vector inner product using the the hardware DSP2 units in FPGAs. These DSP units accept 18-bit inputs and accumulate the results of the MACC operation in a 48-bit wide register. Secondly, by invoking the rounding mode only after the accumulation of all the sums, we significantly reduce the hardware overhead in implementing the stochastic rounding scheme. Lastly, the adoption of this approach allows us to efficiently simulate fixedpoint computations using CPUs/GPUs and vendorsupplied BLAS3 libraries. For instance, matrix multiplication of two fixed-point matrices A and B can be simulated by first converting them into float matrices, calling the hardware-optimized SGEMM routine and applying the Convert() function to each element of the resulting float matrix.\n2Digital Signal Processing units are hardware units in the FPGA fabric that implement fixed-point multiplication and addition\n3Basic Linear Algebra Subprograms"}, {"heading": "4. Training Deep Networks", "text": "In this section, we present the results of our investigation into the effect of employing limited precision data representation during the training of deep neural networks. We consider both fully connected deep neural networks (DNN) as well as convolutional neural networks (CNN) and present results for the MNIST(Lecun & Cortes) and the CIFAR10(Krizhevsky & Hinton, 2009) datasets. As a baseline for comparison, we first evaluate the network performance (in terms of the rate of reduction of both the training error and the error on the test set) using the conventional 32-bit floating-point arithmetic. Subsequently, we constrain the neural network parameters (weights W l, biases Bl), as well as the other intermediate variables generated during the back-propagation algorithm (layer outputs Y l, back-propagated error \u03b4l, weight updates \u2206W l, bias updates \u2206Bl) to be represented in the fixed-point format and train the network again starting from random initialization of the parameters. While training using fixed-point, the different model hyperparameters such as weight initialization, regularization parameters, learning rates etc. are kept unchanged from the ones used during the\nbaseline evaluation. The word length WL for the fixedpoint format is set to 16 bits i.e. the number of bits allocated to represent the integer and the fractional parts add up to 16.\nThis fairly restrictive choice of number representation has some important implications. From the perspective of neural network training, an aggressive reduction of the precision with which the parameter updates are computed and stored may result in the loss of the gradient information if the updates are significantly smaller than the for the given fixed-point format. As a consequence, this may impede the progress of the gradient descent algorithm, or worse, introduce instabilities during the training procedure. Note that in the round-to-nearest scheme, any parameter update in the range ( \u2212 2 , 2 ) is always rounded to zero, as opposed to the stochastic rounding scheme which maintains a nonzero probability of small parameter updates to round to \u00b1 . Secondly, since the fixed-point format offers only a limited range, outputs of the ReLU activation function may get clipped to the upper limit set by \u3008IL, FL\u3009. From a hardware perspective, the use of 16- bits for data storage (instead of float) corresponds to a factor 2 reduction in the amount of memory needed\nfor training a given network. Moreover, the use of the same word length for all network variables carries with it the added advantage of simplifying the hardware implementation."}, {"heading": "4.1. MNIST", "text": ""}, {"heading": "4.1.1. Fully connected DNN", "text": "In the first set of experiments, we construct a fully connected neural network with 2 hidden layers, each containing 1000 units with ReLU activation function and train this network to recognize the handwritten digits from the MNIST dataset. This dataset comprises of 60, 000 training images and 10, 000 test images \u2013 each image is 28 x 28 pixels containing a digit from 0 to 9. The pixel values are normalized to lie in the [0, 1] range. No other form of data pre-processing or augmentation is performed. The weights in each layer are initialized by sampling random values from N (0, 0.01) while the bias vectors are initialized to 0. The network is trained using minibatch stochastic gradient descent (SGD) with a minibatch size of 100 to minimize the cross entropy objective function. The float baseline achieves a test error of 1.4%.\nNext, we retrain the network using fixed-point computations and set WL to 16 bits. Figure 1 shows the results for the two rounding modes: Round-to-nearest and Stochastic rounding. In both cases, allocating 14 bits to the fractional part4 produces no noticeable\n4Using up 14 bits for the fractional part leaves only 2 bits (including the sign bit) for representing the integer portion of the number. This does not seem to adversely affect the network performance.\ndegradation in either the convergence rate or the classification accuracy. A reduction in the precision below 14 bits begins to negatively impact the network\u2019s ability to learn when the round-to-nearest scheme is adopted. This is primarily because at reduced fractional precision, most of the parameter updates are rounded down to zero. In contrast, the stochastic rounding preserves the gradient information, atleast statistically, and the network is able to learn with as few as 8 bits of precision without any significant loss in performance. Note, however, at a precision lower than 8 bits, even the stochastic rounding scheme is unable to fully prevent the loss of gradient information."}, {"heading": "4.1.2. CNN", "text": "Using the MNIST dataset, we also evaluate a CNN with an architecture similar to LeNet-5 (LeCun et al., 1998). It comprises of 2 convolutional layers with 5x5 filters and ReLU activation function. The first layer has 8 feature maps while the second convolutional layer produces 16 feature maps. Each convolutional layer is followed by a pooling/subsampling layer. The pooling layers implement the max pooling function over non-overlapping pooling windows of size 2x2. The output of the second pooling layer feeds into a fully connected layer consisting of 128 ReLU neurons, which is then connected into a 10-way softmax output layer.\nFor training this network, we adopt an exponentially decreasing learning rate \u2013 scaling it by a factor of 0.95 after every epoch of training. The learning rate for the first epoch is set to 0.1. Momentum (p = 0.9) is used to speed up SGD convergence. The weight decay parameter is set to 0.0005 for all layers. When\ntrained using float, the network achieves a test error of 0.77%. As was done previously for DNNs, we retrain the network using fixed-point computations with WL set to 16 bits. However, in this case, saturating the output of the convolutional layers to a low integer value created some difficulty in jump-starting the training procedure. As a result, we increase the number of bits allocated for the integer part at the expense of reducing the precision and choose the \u30086, 10\u3009 format for representing the layer outputs. Figure 2 compiles the results obtained using the two different rounding modes. Unlike in the case of DNNs, when the round-tonearest scheme is adopted during fixed-point computations, the training procedure fails to converge. When stochastic rounding is used, we achieve a test error of 0.83% and 0.90% for 14-bit and 12-bit precision, respectively \u2013 corresponding to only a slight degradation from the float baseline."}, {"heading": "4.2. CIFAR10", "text": "To further test the validity of the stochastic rounding approach, we consider another commonly used image classification benchmark: CIFAR10. The training set consists of 50, 000 RGB images of size 32x32 pixels. The images are divided into 10 classes, each containing 5, 000 images. The test set has 10, 000 images. We scale the image RGB values to [0,1] range and do not perform any other form of data pre-processing or augmentation. For this dataset, we construct a CNN with 3 convolutional layers each followed by a subsampling/pooling layer. The convolutional layers consist of 64 5x5 filters and the subsampling layers implement the max pooling function over a window of size 3x3 using a stride of 2. The 3rd pooling layer connects to\na 10-way softmax output layer. This architecture is similar to the one introduced in (Hinton et al., 2012) with the exception that it does not implement local response normalization or dropout layers.\nThe network training starts off with a learning rate of 0.01 and reduced by a factor of 2 after 50, 75, and 100 epochs. Using 32-bit floating point numbers for training, this network configuration misclassifies approximately 24.6% of the images in the test set. This serves as the baseline for comparing the results obtained while training the network using fixed-point computations. Similar to earlier experiments, we set the WL for fixed-point number to 16 and test the different rounding modes and fractional precision. The layer outputs are represented in the \u30084, 12\u3009 format. As observed previously and as shown in Figure 3, training using fixed-point with round-to-nearest scheme begins to collapse after only a few epochs. On the contrary, the stochastic rounding scheme appears to bestow upon the training procedure a significantly higher degree of stability. For 14 bits of fractional precision and the stochastic rounding scheme, the network\u2019s behavior is quite similar to that observed during the baseline evaluation and achieves a test error of 25.4%.\nIf the precision is reduced further (to 12 bits) the convergence rate degrades as the learning proceeds and after a point, SGD stops making progress. This is expected since at reduced precision, the parameter updates tend to become sparser (despite stochastic rounding) due to the perilous combination of smaller gradients and diminished learning rates. The network\u2019s performance suffers as a result and the minimum achievable test error saturates at 28.8%. Fortunately, this damage is reversible as shown in Figure 3. After\ntraining for 100 epochs using the \u30084, 12\u3009 format, we relax the constraint on WL slightly and increase WL by 4 bits to 20 bits. This increases the fractional precision to 16 bits (\u30084, 16\u3009 format) and subsequent training results in a rapid improvement in the network\u2019s performance. After an additional 15-20 epochs of training using the higher precision representation, the test error approaches that obtained using float.\nThis result reveals a promising (and possibly more robust) strategy for deep neural network training in which the network is first trained using low-precision fixed-point arithmetic and stochastic rounding. At the point where learning shows stagnation, the network can be \u201cfine-tuned\u201d using only a few epochs of higherprecision fixed-point computations. Such a concept of employing mixed-precision computations has been explored previously in the context of floating point arithmetic (Baboulin et al., 2009), motivated largely by the fact that most modern processors achieve a factor 2 to 4 higher computational throughput for single-precision (32-bit) floating-point as compared with double-precision (64-bit) floating-point. Similar concepts, in conjunction with stochastic rounding, can be extended to perform mixed-precision fixed-point arithmetic.5"}, {"heading": "5. Hardware Prototyping", "text": "The execution time of the mini-batch stochastic gradient descent algorithm is dominated by a series of GEMM operations in the feed-forward, error back-propagation and weight update calculation steps6. As a result, an improvement in the computational throughput of the GEMM operation translates into an improvement in the training time. GPUs offering a large number of parallel vector processors and high memory bandwidth have therefore been very effective in accelerating these workloads.\nIn this section we describe a FPGA-based hardware accelerator for matrix-matrix multiplication. Our choice of using FPGAs as the hardware substrate is motivated by two factors. Firstly, FPGAs enable fast hardware development times and significantly lower costs when compared to ASICs7. Secondly, modern\n5While preparing this paper, we became aware of a very recent work (Courbariaux et al., 2014) that shares our motivations but adopts an orthogonal approach. The authors propose the use of dynamic fixed-point (a hybrid of the fixed-point and the conventional floating-point arithmetic) for training deep neural networks. However, hardware implications of this approach are not immediately obvious.\n6Convolution may also be rewritten as a GEMM operation 7Application Specific Integrated Circuits\nFPGAs have a large number of hard-wired fixed-point DSP units that are well-suited to implementing the fixed-point arithmetic described in the earlier sections, and can potentially yield gains in performance and power efficiency. However, limited memory bandwidth must still be carefully managed through various design choices.\nOur prototype is implemented on an off-the-shelf FPGA card featuring a Xilinx Kintex325T FPGA and 8 GB DDR3 memory, and communicating with the host PC over a PCIe bus. This FPGA has 840 DSP multiply-accumulate units and almost 2 MB of on-chip block RAM. The data bandwidth between the off-chip DDR3 memory and the FPGA is 6.4 GB/s. The typical dimensions of the input matrices preclude storing entire matrices in on-chip RAM. Thus, these matrices are stored in the DDR3 memory and parts of the matrices are brought into the FPGA for performing the computations. The off-chip communication bandwidth limitation necessitates that we reuse the on-chip data to the highest extent possible to make the achievable throughput, measured in giga-operations/second (Gops/s), compute-bound."}, {"heading": "5.1. System Description", "text": "Figure 4 presents a block diagram of the our fixedpoint matrix multiplier. The DSP units within the FPGA are organized as a massively parallel 2- dimensional systolic array (SA) (Kung, 1982) of size n such that n2 < 840. This forms the core of the multiplier and will be described in greater detail in the next subsection. Most of the block RAM on the FPGA is designated as the L2 cache where a fraction of the input matrices are stored. The READ logic sends data requests to the DDR3 memory and organizes the incoming data into the L2 cache. The WRITE logic sends back computed results to the external memory. The L2-to-SA circuit moves relevant rows and columns from the L2 cache to the array. The TOP\ncontroller coordinates the entire process. The FPGA also contains Xilinx-supplied IP blocks that interface to the DDR3 memory.\nThe operation sequence of the multiplier is as follows. Assume the first input matrix A has dimensions l x k and the second input matrix B has dimensions k x m. Initially n columns of matrix B and pn rows of matrix A, where p is the largest integer we can choose based on on-chip memory capacity constraints, are brought into the FPGA to compute pn2 elements of the result matrix. The next n columns of matrix B are then brought it and processed. This continues until all m columns of matrix B have been multiplied with the first pn rows of matrix A. This entire sequence is repeated l/pn times to process all rows of matrix A. Double buffering is employed to hide the latency of bringing in new subsets of the matrices in to the chip. This sequence of operation ensures that elements of matrix A are reused m times once brought into the FPGA while those of matrix B are reused pn times. This reuse allows efficient use of the bandwidth between the FPGA and the DDR3 memory."}, {"heading": "5.2. Systolic Array Architecture", "text": "Figure 5 shows the logical organization of the systolic array. Each node of the systolic array (DSP MACC) has a DSP unit that implements two operations (multiply and accumulate) in every clock cycle. Elements of input matrices A and B brought in from L2-cache are staged in local block RAM units configured as FIFO (First In First Out) queues. Each FIFO contains elements from either a row of A or a column of B. In each clock cycle, one element is read out from the\nFIFO. Elements from earlier cycles are cascaded right (for A) or down (for B) and the corresponding partial products are accumulated at the DSP units. After accumulation of all partial products, output data is cascaded out to stochastic rounding units (DSP ROUND) that are also implemented with DSP units. Rounded results are stored in output FIFOs (one per column) before final readout to external memory. Throughput of the array depends on the number of DSPs available and the maximum operating frequency at which the system can be operated without timing errors. This is an example of a wavefront-type systolic array where all connections are local, i.e. only between neighboring DSPs and edge FIFOs, which limits interconnect delays and improves maximum operating frequency.\nIn a wavefront array, as depicted in Figure 6, at the end of k cycles, where k corresponds to the inner dimension of the matrix multiplication, MACC unit \u201c11\u201d has accumulated all of its partial products. At this point, the accumulated result is transferred to a local register and the DSP is reset. This frees it up to receive data from the next matrix multiplication operation, even before other elements have completed. This achieves high throughput for the systolic array so long as the pipeline is fed with new incoming data. At the end of (k+ 2n\u2212 2) cycles, the matrix multiplication is complete, and data from the last DSP unit can be read out. Output paths from local registers to the edge of the array are also cascaded.\nWord length of the result elements after MACC operations are much larger (typically 48 bits if using 7- series DSPs) than word length of the inputs (typically 18 bits or less). Before transferring to output FIFOs, result elements must be trimmed through the stochastic rounding of least signficant bits (LSB) and truncation of excess MSB bits (after detection of\noverflow/underflow). Both operations can be efficiently achieved using a single DSP unit per output. At each column, linear feedback shift register (LFSR) is used to generate a random number whose width is equal to the number of LSB bits being rounded off. The DSP unit adds the random number to the incoming result and drops rounded off LSB bits. Pattern-detect capabilities built into the DSP are used to determine if excess MSB bits are identical (all \u201c0s\u201d or all \u201c1s\u201d). If not, an overflow/underflow condition is detected, and result values are saturated to the max/min 2\u2019s complement values8. The result is then transferred to output column FIFOs awaiting writeback to external memory. The overhead of stochastic rounding is thus the logic occupied by DSP ROUND units, which in our case is 28 DSP units \u2013 corresponding to less than 4% overhead in hardware resources."}, {"heading": "5.3. Results", "text": "For a 28x28 systolic array implemented on the KintexK325T FPGA, Xilinx\u2019s Vivado synthesis and place-and-route tool estimated a maximum circuit operation frequency of 166 MHz and a power consumption of 7 W. This translates to a throughput of 260 Gops/s at a power efficiency of 37 G-ops/s/W. This compares very favorably against the Intel i7-3720QM CPU, the NVIDIA GT650m and the GTX780 GPUs, all of which achieve power efficiency in the range of 1-5 G-ops/s/W (Gokhale et al., 2014). Table 1 presents a summary of the utilization of various resources in the FPGA. Throughput numbers can benefit from migration to newer Xilinx FPGAs, such as the Ultrascale series, that have much higher number of DSP units and can potentially operate at higher frequencies.\n8A more direct stochastic rounding approach is multibit magnitude comparison of result LSB vs. a random number, followed by a conditional addition and examining excess MSBs. The approach in this section achieves the same result but removes the first full multi-bit comparison, enabling compact implementation on a single DSP unit."}, {"heading": "6. Conclusion", "text": "In this paper, we embrace a top-down approach exploiting the noise-tolerance of deep neural networks and their training algorithms to influence the design of low-level compute units. Specifically, the substitution of floating-point units with fixed-point arithmetic circuits comes with significant gains in the energy efficiency and computational throughput, while potentially risking the neural network\u2019s performance. For low-precision fixed-point computations, where conventional rounding schemes fail, adopting stochastic rounding during deep neural network training delivers results nearly identical as 32-bit floating-point computations. Additionally, we implement a highthroughput, energy-efficient architecture for matrix multiplication that incorporates stochastic rounding with very little overhead. Extrapolating, we envision the emergence of hardware-software co-designed systems for large-scale machine learning based on relaxed, inexact models of computing running on nondeterministic components all across the stack, right down to low-level hardware circuitry."}], "references": [{"title": "Deep learning with cots hpc systems", "author": ["Coates", "Adam", "Huval", "Brody", "Wang", "Tao", "Wu", "David", "Catanzaro", "Bryan", "Andrew", "Ng"], "venue": "In Proceedings of The 30th International Conference on Machine Learning,", "citeRegEx": "Coates et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Coates et al\\.", "year": 2013}, {"title": "Low precision arithmetic for deep learning", "author": ["Courbariaux", "Matthieu", "Bengio", "Yoshua", "David", "Jean-Pierre"], "venue": "arXiv preprint arXiv:1412.7024,", "citeRegEx": "Courbariaux et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Courbariaux et al\\.", "year": 2014}, {"title": "Neuflow: A runtime reconfigurable dataflow processor for vision", "author": ["Farabet", "Cl\u00e9ment", "Martini", "Berin", "Corda", "Benoit", "Akselrod", "Polina", "Culurciello", "Eugenio", "LeCun", "Yann"], "venue": "In Computer Vision and Pattern Recognition Workshops (CVPRW),", "citeRegEx": "Farabet et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Farabet et al\\.", "year": 2011}, {"title": "A 240 gops/s mobile coprocessor for deep neural networks", "author": ["Gokhale", "Vinayak", "Jin", "Jonghoon", "Dundar", "Aysegul", "Martini", "Berin", "Culurciello", "Eugenio"], "venue": "In Computer Vision and Pattern Recognition Workshops (CVPRW),", "citeRegEx": "Gokhale et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Gokhale et al\\.", "year": 2014}, {"title": "A vlsi architecture for highperformance, low-cost, on-chip learning", "author": ["Hammerstrom", "Dan"], "venue": "In Neural Networks,", "citeRegEx": "Hammerstrom and Dan.,? \\Q1990\\E", "shortCiteRegEx": "Hammerstrom and Dan.", "year": 1990}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["Hinton", "Geoffrey E", "Srivastava", "Nitish", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan R"], "venue": "arXiv preprint arXiv:1207.0580,", "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "Probabilistic rounding in neural network learning with limited", "author": ["H\u00f6hfeld", "Markus", "Fahlman", "Scott E"], "venue": "precision. Neurocomputing,", "citeRegEx": "H\u00f6hfeld et al\\.,? \\Q1992\\E", "shortCiteRegEx": "H\u00f6hfeld et al\\.", "year": 1992}, {"title": "Finite precision error analysis of neural network hardware implementations", "author": ["JL Holt", "Hwang", "Jenq-Neng"], "venue": "Computers, IEEE Transactions on,", "citeRegEx": "Holt et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Holt et al\\.", "year": 1993}, {"title": "An artificial neural network accelerator using general purpose 24 bit floating point digital signal processors", "author": ["Iwata", "Akira", "Yoshida", "Yukio", "Matsuda", "Satoshi", "Sato", "Yukimasa", "Suzumura", "Nobuo"], "venue": "In Neural Networks,", "citeRegEx": "Iwata et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Iwata et al\\.", "year": 1989}, {"title": "X1000 real-time phoneme recognition vlsi using feed-forward deep neural networks", "author": ["Kim", "Jonghong", "Hwang", "Kyuyeon", "Sung", "Wonyong"], "venue": "In Acoustics, Speech and Signal Processing (ICASSP),", "citeRegEx": "Kim et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2014}, {"title": "Learning multiple layers of features from tiny images", "author": ["Krizhevsky", "Alex", "Hinton", "Geoffrey"], "venue": "Computer Science Department,", "citeRegEx": "Krizhevsky et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2009}, {"title": "Why systolic architectures", "author": ["H.T. Kung"], "venue": "Jan 1982. doi: 10.1109/MC.1982", "citeRegEx": "Kung,? \\Q1982\\E", "shortCiteRegEx": "Kung", "year": 1982}, {"title": "Gradient-based learning applied to document recognition", "author": ["LeCun", "Yann", "Bottou", "L\u00e9on", "Bengio", "Yoshua", "Haffner", "Patrick"], "venue": "Proceedings of the IEEE,", "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Enhanced mlp performance and fault tolerance resulting from synaptic weight noise during training", "author": ["Murray", "Alan F", "Edwards", "Peter J"], "venue": "Neural Networks, IEEE Transactions on,", "citeRegEx": "Murray et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Murray et al\\.", "year": 1994}, {"title": "Hogwild: A lock-free approach to parallelizing stochastic gradient descent", "author": ["Recht", "Benjamin", "Re", "Christopher", "Wright", "Stephen", "Niu", "Feng"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Recht et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Recht et al\\.", "year": 2011}, {"title": "Improving the speed of neural networks on cpus", "author": ["Vanhoucke", "Vincent", "Senior", "Andrew", "Mao", "Mark Z"], "venue": "In Proc. Deep Learning and Unsupervised Feature Learning NIPS Workshop,", "citeRegEx": "Vanhoucke et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Vanhoucke et al\\.", "year": 2011}, {"title": "Deep image: Scaling up image recognition", "author": ["Wu", "Ren", "Yan", "Shengen", "Shan", "Yi", "Dang", "Qingqing", "Sun", "Gang"], "venue": "arXiv preprint arXiv:1501.02876,", "citeRegEx": "Wu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": ", 2014), or high-end graphics processors (GPUs) (Krizhevsky & Hinton, 2009), or a combination of CPUs and GPUs scaled-up to multiple nodes (Coates et al., 2013; Wu et al., 2015).", "startOffset": 139, "endOffset": 177}, {"referenceID": 16, "context": ", 2014), or high-end graphics processors (GPUs) (Krizhevsky & Hinton, 2009), or a combination of CPUs and GPUs scaled-up to multiple nodes (Coates et al., 2013; Wu et al., 2015).", "startOffset": 139, "endOffset": 177}, {"referenceID": 14, "context": "With the exception of employing the asynchronous version of the stochastic gradient descent algorithm (Recht et al., 2011) to reduce network traffic, the state-of-the-art large-scale deep learning systems fail to adequately capitalize on the error-resiliency of their workloads.", "startOffset": 102, "endOffset": 122}, {"referenceID": 15, "context": "Some recent studies that embrace this approach have relied on the processor\u2019s vector instructions to perform multiple 8 bit operations in parallel (Vanhoucke et al., 2011), or employ reconfigurable hardware (FPGAs) for highthroughput, energy-efficient inference (Farabet et al.", "startOffset": 147, "endOffset": 171}, {"referenceID": 2, "context": ", 2011), or employ reconfigurable hardware (FPGAs) for highthroughput, energy-efficient inference (Farabet et al., 2011; Gokhale et al., 2014), or take the route of custom hardware implementations (Kim et al.", "startOffset": 98, "endOffset": 142}, {"referenceID": 3, "context": ", 2011), or employ reconfigurable hardware (FPGAs) for highthroughput, energy-efficient inference (Farabet et al., 2011; Gokhale et al., 2014), or take the route of custom hardware implementations (Kim et al.", "startOffset": 98, "endOffset": 142}, {"referenceID": 9, "context": ", 2014), or take the route of custom hardware implementations (Kim et al., 2014; Merolla et al., 2014).", "startOffset": 62, "endOffset": 102}, {"referenceID": 8, "context": "(Iwata et al., 1989) implements the backpropagation algorithm using 24-bit floating-point processing units.", "startOffset": 0, "endOffset": 20}, {"referenceID": 12, "context": "with an architecture similar to LeNet-5 (LeCun et al., 1998).", "startOffset": 40, "endOffset": 60}, {"referenceID": 5, "context": "This architecture is similar to the one introduced in (Hinton et al., 2012) with the exception that it does not implement local response normalization or dropout layers.", "startOffset": 54, "endOffset": 75}, {"referenceID": 1, "context": "While preparing this paper, we became aware of a very recent work (Courbariaux et al., 2014) that shares our motivations but adopts an orthogonal approach.", "startOffset": 66, "endOffset": 92}, {"referenceID": 11, "context": "The DSP units within the FPGA are organized as a massively parallel 2dimensional systolic array (SA) (Kung, 1982) of size n such that n < 840.", "startOffset": 101, "endOffset": 113}, {"referenceID": 3, "context": "This compares very favorably against the Intel i7-3720QM CPU, the NVIDIA GT650m and the GTX780 GPUs, all of which achieve power efficiency in the range of 1-5 G-ops/s/W (Gokhale et al., 2014).", "startOffset": 169, "endOffset": 191}], "year": 2015, "abstractText": "Training of large-scale deep neural networks is often constrained by the available computational resources. We study the effect of limited precision data representation and computation on neural network training. Within the context of low-precision fixed-point computations, we observe the rounding scheme to play a crucial role in determining the network\u2019s behavior during training. Our results show that deep networks can be trained using only 16-bit wide fixed-point number representation when using stochastic rounding, and incur little to no degradation in the classification accuracy. We also demonstrate an energy-efficient hardware accelerator that implements low-precision fixed-point arithmetic with stochastic rounding.", "creator": "LaTeX with hyperref package"}}}