{"id": "1502.02799", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Feb-2015", "title": "On Forgetting in Tractable Propositional Fragments", "abstract": "Distilling from a knowledge base only the part that is relevant to a subset of alphabet, which is recognized as forgetting, has attracted extensive interests in AI community. In standard propositional logic, a general algorithm of forgetting and its computation-oriented investigation in various fragments whose satisfiability are tractable are still lacking. The paper aims at filling the gap between a given field and a set of general types, where knowledge is important in determining the probability that a given field is correct and not in the wrong spot. The basic principle of the general rule is to have a general principle, which is based on the principle of a general system. In practice, this principle can be applied to an individual or group, the group representing each individual.\n\n\n\nThe first of the two major examples of how this principle can be applied to a particular field is the one in which the prediction of a given field is accurate. In practice, this principle can be applied to the predictions of a particular field and in practice, a combination of the two principle can be applied to a particular field with the expectation that a given field has a good quality in its prediction. The first example in this field is the prediction of a random variable (e.g. the random variable) in which the predicted variable is positive (e.g. random variable) with the expectation that it is positive for an event that might occur. For example, the probability that random variables in a random variable are positive can be used to predict if an event in a random variable is not positive. However, the probability that random variables in a random variable are positive does not be guaranteed (e.g., the probability of an event in a random variable that is positive in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable in any type of random variable", "histories": [["v1", "Tue, 10 Feb 2015 07:05:56 GMT  (26kb)", "http://arxiv.org/abs/1502.02799v1", "27 pages"]], "COMMENTS": "27 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yisong wang"], "accepted": false, "id": "1502.02799"}, "pdf": {"name": "1502.02799.pdf", "metadata": {"source": "CRF", "title": "On Forgetting in Tractable Propositional Fragments", "authors": ["Yisong Wang"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n50 2.\n02 79\n9v 1\n[ cs\n.A I]\n1 0\nKeywords: Forgetting; CNF; Horn theories; Algorithms; Complexity"}, {"heading": "1 Introduction", "text": "Motivated from Lin and Reiter\u2019s seminal work in first-order logic [1], the notion of forgetting \u2013 distilling from a knowledge base only the part that is relevant to a subset of the alphabet \u2013 has attracted extensive interests [2, 3]. A dual notion of forgetting in mathematical logic is called uniform interpolation [4]. In artificial intelligence, it has been studied under many different names including variable eliminating, irrelevance, independence, irredundancy, novelty, or separability [5].\nIn recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15]. It is commonly recognized that forgetting has both theoretical and practical interest as it can be\nused for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.\nThough forgetting has been extensively investigated from various aspects of different logical systems, in standard propositional logic, a general algorithm of forgetting and its computation-oriented investigation in various fragments whose satisfiability are tractable are still lacking.\nFirstly, the syntactic forgetting operator, which is defined as Forget(\u03a3, p) = \u03a3[p/\u22a4] \u2228 \u03a3[p\u22a5] where \u03d5[p/\u22a4] (resp. \u03d5[p/\u22a5]) is obtained from \u03d5 be replacing p with \u22a4 (resp. \u22a5), results in a disjunctive formula. Thus, it violates categoricity for non-disjunctive formulas, e.g., if \u03a3 is a conjunctive normal form (CNF) formula then Forget(\u03a3, p) is not a CNF formula any longer. Though one can transform a CNF formula into an equivalent disjunctive normal form (DNF) formula, the translation will bring about exponential explosion if no fresh atoms are allowed.\nSecondly, from the perspective of computation, Lang et al. have showed that deciding if a formula is independent of a set of atoms (called VAR-INDEPENDENCE) is co-NP-complete, and deciding if two formulas are equivalent on a common signature (called VAR-EQUIVALENCE) is \u03a0P2 -complete [2]. To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.\nIn the paper we mainly focus on CNF fragments of propositional logic, for which a resolution-based algorithm of forgetting is presented at first. Accordingly, we show that forgetting is categorical in the Horn, ren-Horn, q-Horn, double Horn [22] and Krom [23] (or 2-CNF) fragments. Namely, the result of forgetting from a Horn (resp. ren-Horn, q-Horn, double Horn and Krom [23] (or 2-CNF)) theory is Horn (resp. ren-Horn, q-Horn, double Horn and Krom) expressible.\nMore importantly, from the perspective of knowledge bases evolving, we are also interested in the following reasoning problems about forgetting, besides the VAR-INDEPENDENCE and VAR-EQUIVALENCE in [2], where Forget(\u03d5, V ) stands for a result of forgetting V from formula \u03d5,\n(1) [VAR-INDEPENDENCE] If a knowledge base \u03a0 is independent of a set V of atoms, i.e. Forget(\u03a0, V ) \u2261 \u03a0.\n(2) After a knowledge base \u03a3 has evolved from a knowledge base \u03a0 by incorporating some knowledge additionally on a set V of new propositions,\n[VAR-WEAK] if the restriction of \u03a3 on the signature of \u03a0 is at most as strong as \u03a0, i.e. \u03a0 |= Forget(\u03a3, V ).\n[VAR-STRONG] if the restriction of \u03a3 on the signature of \u03a0 is at least as strong as \u03a0, i.e. Forget(\u03a3, V ) |= \u03a0.\nWe answer these problems for CNF, DNF, Horn, ren-Horn, q-Horn, and Krom fragments of propositional logic. The main complexity results are summarized in Table 1, from which one can see that for Krom (resp. DNF) fragments, all of the six problems are tractable (resp. co-NP-complete). While comparing Horn and its variants with CNF fragments, the corresponding complexity of the former is one level below the latter in the complexity hierarchy.\nThe rest of the paper are organized as follows. The basic notations of propositional logics and its fragments are briefly introduced in Section 2. Forgetting and its basic properties, algorithms and complexity are presented in Section 3. Related work and concluding remarks are discussed in Section 4 and 5 respectively."}, {"heading": "2 Preliminaries", "text": "We assume a underlying propositional language LA with a finite set A of atoms, called the signature of LA. A literal is either an atom p (called positive literal) or its negation \u00acp (called negative literal). The complement of a literal l is \u00acl. The formulas (of LA) are defined as usual using connectives \u2227,\u2228,\u2283,\u2194 and \u00ac.\nWe assume two propositional constants \u22a4 and \u22a5 for tautology and contradiction respectively. A theory is a finite set of formulas. For a theory \u03a3, we use the following denotations:\n\u2022 \u00ac\u03a3 = {\u00ac\u03d5|\u03d5 \u2208 \u03a3},\n\u2022 \u2227 \u03a3 = \u2227\n\u03d5\u2208\u03a3 \u03d5,\n\u2022 \u2228 \u03a3 = \u2228\n\u03d5\u2208\u03a3 \u03d5, and\n\u2022 Var(\u03a3) stands for the set of all atoms occurring in \u03a3.\nAn interpretation is a set of atoms, which assigns true to the atoms in the set and false to the others. The notion of satisfaction between an interpretation I and a formula \u03d5, written I |= \u03d5, is inductively defined in the standard manner. In this case I is a called model of \u03d5. By Mod(\u03d5) we denote the set of models of \u03d5.\nA formula \u03c8 is a logical consequence of a formula \u03d5, denoted by \u03d5 |= \u03c8, if Mod(\u03d5) \u2286 Mod(\u03c8). Two formulas \u03d5 and \u03c8 are equivalent, written \u03d5 \u2261 \u03c8, if \u03d5 |= \u03c8 and \u03c8 |= \u03d5. A formula \u03c8 is irrelevant to a set V of atoms, denoted by IR(\u03c8, V ), if there is a formula \u03d5 such that \u03c8 \u2261 \u03d5 and Var(\u03d5)\u2229V = \u2205. Otherwise, \u03c8 is relevant to V ."}, {"heading": "2.1 Clauses and terms", "text": "In the following we assume that \u00ac\u00ac\u03d5 is shortten to \u03d5 where \u03d5 is a formula, unless explicitly stated otherwise. A clause is an expression of the form l1\u2228\u00b7 \u00b7 \u00b7\u2228 ln (n \u2265 0) where li (1 \u2264 i \u2264 n) are literals such that li 6= \u00aclj for every i, j (1 \u2264 i < j \u2264 n). It is an empty clause in the case n = 0, which means false. Dually, a term is an expression of the form l1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ln (n \u2265 0) where li (1 \u2264 i \u2264 n) are literals such that li 6= \u00aclj for every i, j (1 \u2264 i < j \u2264 n). By abusing the notation, we identify a clause l1\u2228\u00b7 \u00b7 \u00b7\u2228 ln and a term l1\u2227\u00b7 \u00b7 \u00b7\u2227 ln with the set {l1, . . . , ln} when it is clear from its context.\nA conjunctive normal form (CNF) formula is a conjunction of clauses, and a disjunctive normal form (DNF) formula is a disjunction of terms. A k-CNF (resp. k-DNF) formula is a CNF (resp. DNF) formula whose each clause (resp. term) contains no more than k literals. In particular, 2-CNF formulas are called Krom formulas [23].\nA prime implicate of a formula \u03d5 is a clause c such that \u03d5 |= c and \u03d5 6|= c\u2032 for every proper subclause c\u2032 \u2282 c. Dually, a prime implicant of \u03d5 is a term t such that t |= \u03d5 and t\u2032 6|= \u03d5 for each proper subterm t\u2032 \u2282 t. A CNF (resp. DNF) formula\nThe definition of relevant is equivalent with, but slightly different from, that of [24], in which \u03c8 is relevant to V if there is a prime implicate of \u03c8 which mentions some atom from V .\nis prime, if it contains only prime implicates (resp. implicants). By PI(\u03c8) (resp. IP(\u03c8)) we denote the set of prime implicates (resp. implicants) of formula \u03c8.\nIn the following we shall identify a theory \u03a3 with the formula \u2227\n\u03a3 when there is no confusion. The following lemma is well-known [25].\nLemma 1 Let \u03a3 be a theory and \u03d5 be a term. Then\n(1) \u2227 PI(\u03a3) \u2261 \u2228 IP(\u03a3) \u2261 \u03a3.\n(2) \u03d5 is a prime implicant of \u03a3 iff \u00ac\u03d5 is a prime implicate of \u00ac\u03a3.\n(3) If \u03a0 \u2261 \u03a3 then PI(\u03a3) = PI(\u03a0) and IP(\u03a3) = IP(\u03a0).\nTwo clauses c, c\u2032 are resolvable, if there is an atom p such that p,\u00acp \u2208 c \u222a c\u2032 and c\u2217 = (c\u222ac\u2032)\\{p,\u00acp} is a legal clause, viz, c\u2217 contains no pair of complement literals. In this case we denote the clause c \u222a c\u2032 \\ {p,\u00acp} by res(c, c\u2032), which is called their resolvent; otherwise, res(c, c\u2032) is undefined. It is well-known that all prime implicates of a CNF formula \u03d5 can be generated by resolution."}, {"heading": "2.2 Horn formulas and its variants", "text": "In the following, by Pos(c) (resp. Neg(c)) we denote the set of atoms occurring positively (resp. negatively) in the clause or term c. In this sense a clause c can be written as Pos(c) \u222a \u00acNeg(c).\nA clause c is Horn [19] if |Pos(c)| \u2264 1. Here |D| denotes the number of elements in the set D. A Horn formula is a conjunction of Horn clauses. A formula \u03d5 is Horn expressible if there is a Horn formula \u03c8 such that \u03c8 \u2261 \u03d5. A Horn formula \u03d5 is double Horn [22] if there is a Horn formula \u03c8 such that \u03c8 \u2261 \u00ac\u03d5, i.e., the negation of \u03d5 is also Horn expressible.\nGiven a formula \u03d5 and V \u2286 A, we denote ren(\u03d5, V ) the result of replacing every occurrence of atom p \u2208 V in \u03d5 by \u00acp and \u00ac\u00acp is shortened to p. For instance ren(p1 \u2228 \u00acp2 \u2228 \u00acp3, {p1, p2}) is the formula \u00acp1 \u2228 p2 \u2228 \u00acp3. A CNF formula \u03d5 is Horn renamable [20] iff there exists a Horn renaming for it, i.e., ren(\u03d5, V ) is a Horn formula for some V \u2286 A.\nDefinition 1 ([21, 18]) A CNF theory \u03a3 has a QH-partition iff there exists a partition {Q,H} of Var(\u03a3) s.t for every clause \u03b4 of \u03a3, the following conditions hold:\n(i) |Var(\u03b4) \u2229Q| \u2264 2.\n(ii) |Pos(\u03b4) \u2229H| \u2264 1.\n(iii) If |Pos(\u03b4) \u2229H| = 1 then Var(\u03b4) \u2229Q = \u2205.\nA CNF theory \u03a3 is q-Horn iff there exists a q-Horn renaming for it [21], i.e., there is a set V \u2286 A such that replacing in \u03a3 every occurrence of p \u2208 V by \u00acp leads to a CNF theory having a QH-partition {Q,H}. Here \u00ac\u00acp is shorten to p. It is not difficult to see that, every Horn theory is Horn renamable, every Horn renamable theory is q-Horn (Q = \u2205), and every 2-CNF theory is also q-Horn (H = \u2205). A CNF formula \u03d5 is Krom (resp. ren-Horn and q-Horn) expressible if there is Krom (resp. ren-Horn and q-Horn) formula \u03c8 such that \u03d5 \u2261 \u03c8.\nIn terms of Lemma 1, the following lemma are well-known.\nLemma 2 Let \u03a3 be a CNF theory. The following conditions are equivalent.\n(i) \u03a3 is Horn expressible.\n(ii) PI(\u03a3) is a Horn theory.\n(iii) M1 |= \u03a3 and M2 |= \u03a3 imply M1 \u2229M2 |= \u03a3, i.e. Mod(\u03a3) is closed under intersection.\nIt is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.\nProposition 1 Let \u03a3 be a CNF theory, V \u2286 A and c1, c2 two resolvable clauses of \u03a3. We have the following.\n(i) res(ren(c1, V ), ren(c2, V )) = ren(res(c1, c2), V ).\n(ii) If two subsets Q,H of A with Q \u2229H = \u2205 and Var(c1 \u222a c2) \u2286 Q \u222aH satisfy the conditions (i), (ii) and (iii) of Definition 1 for both c1 and c2, then Q and H satisfy the same conditions for res(c1, c2) as well.\nProof: Without loss of generality, suppose c1 = {p} \u222a c\u20321 and c2 = {\u00acp} \u222a c \u2032 2.\n(i) Note that res(c1, c2) = c\u20321 \u222a c \u2032 2, ren(c1, V ) = ren(p, V ) \u222a ren(c \u2032 1, V ) and ren(c2, V ) = ren(\u00acp, V )\u222aren(c\u20322, V ). Due to the fact that ren(c1, v) and ren(c2, V ) are resolvable and res(ren(c1, V ), ren(c2, V )) = ren(c\u20321, V )\u222aren(c \u2032 2, V ), it follows that res(ren(c1, V ), ren(c2, V )) = ren(res(c1, c2), V ). (ii) We consider the following two cases: (a) p \u2208 Q. We have the following:\n\u2022 Note that p \u2208 Var(c1) \u2229 Var(c2) and |Var(ci) \u2229 Q| \u2264 2 for i = 1, 2 by the condition (i) in Definition 1. It shows that |Var(c\u20321 \u222a c \u2032 2) \u2229Q| \u2264 2;\n\u2022 By Var(ci) \u2229Q 6= \u2205 for i = 1, 2 we have that |Pos(ci) \u2229H| = 0 due to the fact |Pos(ci) \u2229 H| \u2264 1 and |Pos(ci) \u2229 H| 6= 1 according to the conditions (ii) and (iii) of Definition 1. It follows |Pos(c\u20321 \u222a c \u2032 2) \u2229H| = 0.\n(b) p /\u2208 Q i.e. p \u2208 H . Now we have the following:\n\u2022 Since p \u2208 Pos(c1) \u2229H we have Var(c1) \u2229Q = \u2205 by conditions (ii) and (iii) of Definition 1. It implies that |Var(c1 \u222a c2) \u2229 Q| = |V ar(c2) \u2229 Q| \u2264 2 by condition (i) of Definition 1. Thus |Var(c\u20321 \u222a c \u2032 2) \u2229Q| \u2264 2.\n\u2022 Note that |Pos(c1) \u2229 H| \u2264 1 by condition (ii) of Definition 1 and p \u2208 Pos(c1) \u2229 H . It shows that |Pos(c1) \u2229 H| = 1 and Pos(c\u20321) \u2229 H = \u2205, thus |Pos(c\u20321 \u222a c \u2032 2) \u2229 H| \u2264 1 due to |Pos(c2) \u2229 H| \u2264 1 by condition (ii) of\nDefinition 1.\n\u2022 In the case |Pos(c\u20321 \u222a c \u2032 2) \u2229H| = 1 we have that |Pos(c \u2032 2) \u2229 H| = 1 due to\nPos(c\u20321) \u2229H = \u2205, which shows that |Pos(c2) \u2229H| = 1 by condition (ii) of Definition 1, and then Var(c2)\u2229Q = \u2205. Recall that Var(c1)\u2229Q = \u2205 (see the proof in the first item). Thus Var(c1\u222ac2)\u2229Q = \u2205, then Var(c\u20321\u222ac \u2032 2)\u2229Q = \u2205.\nIt completes the proof.\nLet \u03a3 be a CNF theory. We define\nres0\u03a3 = \u03a3, resn+1\u03a3 = res n \u03a3 \u222a {res(c, c \u2032)|c, c\u2032 \u2208 resn\u03a3 and c, c \u2032 are resolvable}.\nTheorem 1 Let V \u2286 A and \u03a3 a CNF theory.\n(i) If ren(\u03a3, V ) is a Horn theory then ren(resn\u03a3, V ) is a Horn theory for n \u2265 0.\n(ii) If the partition {Q,H} of Var(ren(\u03a3, V )) satisfies the conditions (i), (ii) and (iii) of Definition 1 for every clause of \u03a3, then {Q,H} satisfies the same conditions for every clauses in resnren(\u03a3,V ) for n \u2265 0.\nProof: We prove the theorem by induction on n. (i) Base: it trivially holds for n = 0 due to res0\u03a3 = \u03a3.\nStep: Suppose that ren(resn\u03a3, V ) is a Horn formula. For any c \u2208 res n+1 \u03a3 \\ res n \u03a3, c = res(c1, c2) for some clauses c1, c2 of resn\u03a3. According to (i) of Proposition 1 we have ren(c, V ) = ren(res(c1, c2), V ) = res(ren(c1, V ), ren(c2, V )). It follows that ren(c, V ) is a Horn clauses since the resolvent of two Horn clauses is a Horn clause.\n(ii) Base: it trivially holds for n = 0 due to res0ren(\u03a3,V ) = ren(\u03a3, V ). Step: Suppose that Q and H satisfy the same conditions for every clauses in\nresnren(\u03a3,V ). For every clause c \u2208 res n+1 ren(\u03a3,V ) \\ res n ren(\u03a3,V ), there are two resolvable clauses c1, c2 \u2208 resnren(\u03a3,V ) such that c = res(c1, c2). In terms of (ii) of Proposition 1,Q andH satisfy the conditions (i), (ii) and (iii) of Definition 1 for the clause\nc. Thus {Q,H} satisfies the same conditions for every clauses in resn+1ren(\u03a3,V ).\nTogether with Lemma 2 and the fact that |res(c1, c2)| \u2264 2 if |ci| \u2264 2 (1 \u2264 i \u2264 2), the theorem above implies:\nCorollary 2 Let V \u2286 A and \u03a3 a CNF theory. If \u03a3 is a Horn (resp. ren-Horn and q-Horn) theory then PI(\u03a3) is a Horn (resp. ren-Horn and q-Horn) theory.\nAs illustrated by the following example, the reverse of the above corollary do not generally hold even if \u03a3 is Horn expressible.\nExample 1 Let \u03a3 = (p \u2228 q) \u2227 (\u00acp \u2228 \u00acq) \u2227 (p \u2228 \u00acq). Since Mod(\u03a3) = {{p}} (over the signature {p, q}), \u03a3 is Horn expressible but it is not a Horn formula. In fact, PI(\u03a3) = {p,\u00acq}, which is a Horn theory. However \u03a3 is not Horn renamable as we have that ren(\u03a3, V ) is not a Horn formula for any V \u2286 {p, q}.\nLet \u03a0 = (p\u2228q\u2228r)\u2227 (p\u2228q\u2228\u00acr)\u2227 (\u00acp\u2228\u00acq\u2228r)\u2227 (\u00acp\u2228\u00acq\u2228\u00acr)\u2227 (p\u2228\u00acq). We have that PI(\u03a0) = {p,\u00acq}. It is evident that PI(\u03a0) is a 2-CNF formula, thus a q-Horn formula. However, one can verify that \u03a0 is not a q-Horn formula.\nLet M,X be two sets of atoms. We denote M \u00f7X the symmetric difference (M \\X)\u222a (X \\M). For a collection M of interpretations, we denote M\u00f7X = {M \u00f7X|M \u2208 M}.\nProposition 2 Let \u03a3 be a formula and V \u2286 A. Then Mod(\u03a3)\u00f7V = Mod(ren(\u03a3, V )).\nProof: (\u21d2) Let M \u2208 Mod(\u03a3) \u00f7 V . There exists M \u2032 |= \u03a3 such that M = (M \u2032 \\ V ) \u222a (V \\M \u2032). Suppose M 6|= ren(\u03a3, V ). It follows that M 6|= ren(c, V ) for some clause c \u2208 \u03a3. By M \u2032 |= c we have that M \u2032 |= l for some literal l in c. Evidently, if Var(l) /\u2208 V then l is also a literal of ren(c, V ) and M |= l, thus M |= ren(c, V ). In the case Var(l) \u2208 V , we consider the two cases, where p is an atom:\n\u2022 l = p. It shows that p \u2208 M \u2032 and then p /\u2208 M . Thus M |= ren(c, V ) due to M |= \u00acp.\n\u2022 l = \u00acp. It shows p /\u2208 M \u2032 and then p \u2208 M . Thus M |= ren(c, V ) due to M |= p.\nEither of the above two cases result in a confliction. (\u21d0) Let M \u2208 Mod(ren(\u03a3, V )). We have that (M \\ V ) \u222a (V \\ M) |= ren(ren(\u03a3, V ), V ), which implies (M \\ V ) \u222a (V \\M) |= \u03a3, i.e. M \u2208 Mod(\u03a3).\nThe following corollary easily follows from the proposition above.\nCorollary 3 Let \u03a3 be a CNF theory. Then \u03a3 is Horn renamable iff there exists V \u2286 A such that Mod(\u03a3)\u00f7 V is closed under intersection."}, {"heading": "3 Forgetting", "text": "Starting with the basic notations and properties of forgetting, we will consider a general algorithm for computing forgetting results of CNF theories, and computational complexity on various reasoning problems relating to forgetting.\nLet \u03a3 be a propositional formula, we denote \u03a3[p/\u22a4] (resp. \u03a3[p/\u22a5]) the formula obtained from \u03a3 by substituting all occurrences of p with \u22a4 (true) (resp. \u22a5 (false)). For instance, if \u03a3 = {p \u2283 q, (q \u2227 r) \u2283 s}, then \u03a3[q/\u22a4] \u2261 {r \u2283 s} and \u03a3[q/\u22a5] \u2261 {\u00acp}."}, {"heading": "3.1 Basic properties", "text": "Let M,N be two interpretations and V \u2286 A. M and N are V -bisimilar, written M \u223cV N , if and only if M \\ V = N \\ V .\nDefinition 2 ([1]) Let \u03d5 be a formula and V \u2286 A. A formula \u03c8 is a result of forgetting V from \u03d5 iff, for every model M of \u03c8, \u03d5 has a model M \u2032 such that M \u223cV M \u2032.\nThe syntactic counterpart of forgetting is a binary operator, written Forget(., .), which is defined recursively as:\nForget(\u03d5, \u2205) = \u03d5,\nForget(\u03d5, {p}) = \u03d5[p/\u22a4] \u2228 \u03d5[p/\u22a5],\nForget(\u03d5, V \u222a {p}) = Forget(Forget(\u03d5, {p}), V )\nwhere \u03d5 is a formula and V \u2286 A. Due to the fact that if \u03d5\u2032 and \u03c8\u2032 is a result of forgetting V from \u03d5 and \u03c8 respectively, then \u03d5\u2032 \u2261 \u03c8\u2032, by abusing the notation, we will denote Forget(\u03d5, V ) the result of forgetting V from \u03d5 when there is no ambiguity.\nThe following proposition easily follows from the definition of forgetting, cf, Propositions 17 and 21 of [2].\nProposition 3 Let \u03c8, \u03c6 be two formulas and V \u2286 A. Then we have\n(i) Forget(\u03c8 \u2228 \u03c6, V ) \u2261 Forget(\u03c8, V ) \u2228 Forget(\u03c6, V ).\n(ii) Forget(\u03c8 \u2227 \u03c6, V ) \u2261 Forget(\u03c8, V ) \u2227 \u03c6 if IR(\u03c6, V ).\nTo establish a semantic characterization of forgetting, we introduce the notion of extension. Let M be an interpretation and V \u2286 A. The extension of M over V , written M\u2020V , is the collection {X \u2286 A|X \u223cV M}. The extension of a collection M of interpretations is \u22c3\nM\u2208MM\u2020V . The following lemma establishes the\nsemantic characterization of the syntactic forgetting, which says that \u03d5 is a result of forgetting V from \u03c8 if and only if the models of \u03d5 consist of the V -extensions of models of \u03c8.\nThe following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].\nProposition 4 Let \u03d5, \u03c8 be two formulas and X \u2286 A. Then \u03d5 \u2261 Forget(\u03c8, V ) if and only if Mod(\u03d5) = Mod(\u03c8)\u2020V .\nProof: (\u21d2) On the one hand, for every M \u2208 Mod(\u03d5), there exists M \u2032 \u2208 Mod(\u03c8) such that M \u223cV M \u2032 by Definition 2, i.e. M \u2208 Mod(\u03c8)\u2020V . On the other hand, if M \u2208 Mod(\u03c8)\u2020V then there exists M \u2032 \u2208 Mod(\u03c8) such that M \u223cV M \u2032, which shows that M |= \u03d5 by Definition 2 again. Thus Mod(\u03d5) = Mod(\u03c8)\u2020V .\n(\u21d0) Note that Mod(\u03d5) = Mod(\u03c8)\u2020V implies, for every M |= \u03d5, there exists a mode M \u2032 |= \u03c8 such that M \u223cV M \u2032. Thus \u03d5 is a result of forgetting V from \u03c8 by Definition 2, i.e. \u03d5 \u2261 Forget(\u03c8, V ).\nThe following theorem shows that the forgetting is closely connected with prime implicates and implicants.\nTheorem 4 Let \u03a0,\u03a3 be two theories and V a set of atoms. The following conditions are equivalent to each other.\n(i) \u03a3 \u2261 Forget(\u03a0, V ).\n(ii) \u03a3 \u2261 {\u03c8|\u03a0 |= \u03c8 and IR(\u03c8, V )}.\n(iii) \u03a3 \u2261 \u2228 {t|t \u2208 IP(\u03a0) and Var(t) \u2229 V = \u2205}.\n(iv) \u03a3 \u2261 {c|c \u2208 PI(\u03a0) and Var(c) \u2229 V = \u2205}.\nProof: (i) \u21d4 (ii). It is trivial if \u03a0 \u2261 \u22a5. Suppose \u03a0 is not falsity. Let \u03a0\u2032 = {\u03c8|\u03a0 |= \u03c8 and IR(\u03c8, V )}. It is sufficient to prove Forget(\u03a0, V ) \u2261 \u03a0\u2032. On the one side, M |= Forget(\u03a0, V ) implies \u2203M \u2032 |= \u03a0 such that M \u223cV M \u2032. It follows that M \u2032 |= \u03a0\u2032. On the other side, M \u2032 |= \u03a0\u2032 implies M \u2032 can be modified to a model M of \u03a0 where M \u223cV M \u2032. It shows that M \u2032 \u2208 Mod(\u03a0)\u2020V .\n(i) \u21d4 (iii). Forget(\u03a3, V ) \u2261 Forget( \u2228 IP(\u03a3), V ) as \u03a3 \u2261 \u2228\nIP(\u03a3) \u2261 \u2228\nt\u2208IP(\u03a3) Forget(t, V ) by (i) of Proposition 3 \u2261 \u2228\n{t|t \u2208 IP(\u03a0) and Var(t) \u2229 V = \u2205} by (ii) of Proposition 3. (i) \u21d4 (iv). It is proved by Theorem 37 of [24], and can follows from Proposi-\ntions 19 and 20 of [2]. .\nActually, (i)\u21d4(iv) is mentioned as a fact in [17], which states that Forget(\u03a3, V ) is equivalent to the conjunction of prime implicates of \u03a3 that do not mention any propositions from V . In terms of Corollary 2 and the theorem above, we have the following corollary.\nCorollary 5 Let \u03a3 be a CNF theory and V \u2286 A. If \u03a3 is a Horn (resp. Krom, renHorn and q-Horn) expressible then Forget(\u03a3, V ) is a Horn (resp. Krom, ren-Horn and q-Horn) expressible."}, {"heading": "3.2 A resolution-based algorithm", "text": "Given a set \u03a0 of clauses and an atom p, the unfolding of \u03a0 w.r.t. p, written unfold(\u03a0, p), is the set of clauses obtained from \u03a0 by replacing every clause c \u2208 \u03a0 such that p \u2208 Pos(c) with the clauses\nres(c, ci) (1 \u2264 i \u2264 k)\nwhere c1, . . . , ck are all the clauses of \u03a0 such that p \u2208 Neg(ci) and, the two clauses c and ci are resolvable for every i (1 \u2264 i \u2264 k). In particular, if k = 0 then unfold(\u03a0, p) is obtained from \u03a0 by simply removing all the clauses that contain the positive literal p.\nThe strong unfolding of \u03a0 w.r.t. an atom p, denoted sunfold(\u03a0, p), is obtained from unfold(\u03a0, p) by removing all clauses containing \u00acp.\nExample 2 Let us consider the below two CNF theories.\n\u03a0 = {p \u2228 q \u2228 \u00aca, p \u2228 \u00acq, b \u2228 \u00acp, c \u2228 \u00acp}.\n\u03a3 = {p \u2228 \u00aca, p \u2228 \u00acq \u2228 \u00acb, q \u2228 \u00acp, c \u2228 \u00acp}.\nWe have that\nsunfold(\u03a0, p) = {b \u2228 q \u2228 \u00aca, c \u2228 q \u2228 \u00aca, b \u2228 \u00acq, c \u2228 \u00acq},\nsunfold(\u03a0, q) = {p \u2228 \u00aca, b \u2228 \u00acp, c \u2228 \u00acp},\nsunfold(sunfold(\u03a0, p), q) = {b \u2228 \u00aca, c \u2228 \u00aca, b \u2228 c \u2228 \u00aca},\nsunfold(sunfold(\u03a0, q), p) = {b \u2228 \u00aca, c \u2228 \u00aca},\nsunfold(\u03a3, p) = {q \u2228 \u00aca, c \u2228 \u00aca, c \u2228 \u00acq \u2227 b},\nsunfold(\u03a3, q) = {p \u2228 \u00aca, c \u2228 \u00acp},\nsunfold(sunfold(\u03a3, p), q) = {c \u2228 \u00aca, c \u2228 \u00aca \u2228 \u00acb},\nsunfold(sunfold(\u03a3, q), p) = {c \u2228 \u00aca}.\nThough sunfold(sunfold(\u03a0, p), q) 6= sunfold(sunfold(\u03a0, q), p), we will see that the two theories are equivalent, i.e., having same models.\nAs demonstrated by Theorem 4, forgetting results always exist, as every formula can be translated into an equivalent CNF theory. The below proposition shows that forgetting in CNF theories can be achieved by unfolding.\nTheorem 6 Let \u03a0 be a CNF theory and p \u2208 A. Then Forget(\u03a0, p) \u2261 sunfold(\u03a0, p).\nProof: Without loss of generality, we assume that \u03a0 contains no tautology. Note that if the clause c : A \u222a \u00acB in \u03a0 satisfies p /\u2208 A \u222a B then c \u2208 sunfold(\u03a0, p) and Forget(\u03a0, p) |= c by (ii) of Proposition 3. Thus we can assume p \u2208 A \u222a B for every clause A \u222a \u00acB of \u03a0.\nLet ci (1 \u2264 i \u2264 n) be all the clauses of \u03a0 such that p \u2208 ci, and c\u2032j (1 \u2264 j \u2264 m) be all the clauses of \u03a0 such that \u00acp \u2208 c\u2032j .\nThe direction from left to right is clear by (ii) of Theorem 4, i.e., Forget(\u03a0, p) |= sunfold(\u03a0, p), since \u03a0 |= res(ci, c\u2032j) for every i, j (1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m) whenever ci, c\u2032j are resolvable.\nTo prove the other direction, it is sufficient to show that for every model M of sunfold(\u03a0, P ), there exists a model M \u2032 of \u03a0 such that M \u2032 \u223cp M . We prove this by contradiction. Without loss of generality, let M |= sunfold(\u03a0, p), p /\u2208 M , M \u2032 = M \u222a {p}, M 6|= \u03a0 and M \u2032 6|= \u03a0. It follows that M 6|= ci for some i (1 \u2264 i \u2264 n) and M \u2032 6|= c\u2032j for some j (1 \u2264 j \u2264 m). Let us consider the following two cases:\n(1) ci and c\u2032j are not resolvable. It shows that there is an atom q different from p such that q,\u00acq \u2208 ci \u222a c\u2032j . Recall that ci, c \u2032 j are not tautology. In the case q \u2208 M we have that q \u2208 c\u2032j and \u00acq \u2208 ci as M 6|= ci. It shows that M |= c \u2032 j , thus M\n\u2032 |= c\u2032j , a contradiction. In the case q /\u2208M we have that q \u2208 ci and \u00acq \u2208 c\u2032j as M 6|= ci. It follows that M |= c\u2032j , thus M\n\u2032 |= c\u2032j , a contradiction. (2) ci and c\u2032j are resolvable. It shows that the resolvent res(ci, c \u2032 j) = (ci\\{p})\u222a (c\u2032j \\ {\u00acp}) belongs to sunfold(\u03a0, p). Note that M 6|= ci implies M 6|= ci \\ {p}. It follows that M |= c\u2032j \\ {\u00acp} since M |= res(ci, c \u2032 j), thus M\n\u2032 |= c\u2032j \\ {\u00acp} and M \u2032 |= c\u2032j by c \u2032 j \\ {\u00acp} |= c \u2032 j , a contradiction.\nProposition 5 Let \u03a0 be a CNF theory, p, q two atoms. Then we have that\nsunfold(sunfold(\u03a0, p), q) \u2261 sunfold(sunfold(\u03a0, q), p).\nProof: By Theorem 6, we have that sunfold(sunfold(\u03a0, p), q) \u2261 sunfold(Forget(\u03a0, p), q) \u2261 Forget(Forget(\u03a0, p), q) \u2261 Forget(\u03a0, {p, q}) \u2261 Forget(Forget(\u03a0, q), p)\n\u2261 Forget(sunfold(\u03a0, q), p) \u2261 Forget(Forget(\u03a0, q), p) \u2261 sunfold(sunfold(\u03a0, p), q).\nIn terms of the above proposition, the unfolding is independent of the ordering of atoms to be strongly unfolded. We define unfolding a set of atoms as following,\nsunfold(\u03a0, \u2205) = \u03a0,\nsunfold(\u03a0, V \u222a {p}) = sunfold(sunfold(\u03a0, p), V )\nwhere \u03a0 is a CNF theory and V \u2286 A. It follows that, by Theorem 6 and Proposition 5,\nCorollary 7 Let \u03a0 be a CNF theory and V \u2286 A. Forget(\u03a0, V ) \u2261 sunfold(\u03a0, V ).\nIn terms of Corollaries 2 and 7, we have\nCorollary 8 Let \u03a3 be a CNF theory and V \u2286 A. If \u03a3 is a Horn (resp. Krom, renHorn and q-Horn) theory then sunfold(\u03a3, V ) is a Horn (resp. Krom, ren-Horn and q-Horn) theory.\nThe strong unfolding provides alternative approach of evaluating forgetting. In particular, strong unfolding results of CNF theories are in CNF as well. If \u03a0 is a Horn theory then Forget(\u03a0, V ) is also Horn which can be achieved by strong unfolding. It distinguishes from the syntactic approach Forget(\u03a0, p) = \u03a0[p/\u22a5] \u2228 \u03a0[p/\u22a4], which is not in CNF, though it can be transformed into CNF (with possibly much more expense).\nBased on the notion of strong unfolding, we present the algorithm for computing forgetting results of CNF theories in Algorithm 1. The following proposition asserts the correctness.\nProposition 6 Let \u03a0, V,\u03a3 be as in Algorithm 1. Then \u03a3 \u2261 Forget(\u03a0, V ).\nProof: It follows from that the lines 3-9 of Algorithm 1 compute Forget(\u03a0, p).\nThe algorithm remains the potentiality of heuristics. For example, one can forget the atoms one by one in a specific order, and similarly choose two specific clauses to do resolution sequentially. In addition, to save space, one can add the condition \u03a3 6|= res(c, c\u2032) at line 7 of the algorithm. While checking the condition is intractable generally, however, it is tractable for some special CNF theories, including Horn, ren-Horn, q-Horn and Krom ones.\nBefore end of the section, we formally analyze the computational costs.\nAlgorithm 1: An Algorithm for Forget(\u03a0, V ) input : A set \u03a0 of clauses and a set V of atoms output: The result of forgetting V in \u03a0 1 begin 2 S \u2190 {c|c \u2208 \u03a0 and V \u2229 Var(c) = \u2205}; 3 \u03a0 \u2190 \u03a0 \\ S; 4 foreach (p \u2208 V ) do 5 \u03a0\u2032 \u2190 {c|c \u2208 \u03a0 and p \u2208 Var(c)}; 6 \u03a3 \u2190 \u03a0 \\ \u03a0\u2032; 7 foreach (c \u2208 \u03a0\u2032 s.t p \u2208 Pos(c)) do 8 foreach (c\u2032 \u2208 \u03a0\u2032 s.t p \u2208 Neg(c\u2032) and c, c\u2032 are resolvable) do 9 \u03a3 \u2190 \u03a3 \u222a res(c, c\u2032);\n10 end 11 end 12 \u03a0 \u2190 \u03a3; 13 end 14 return \u03a3 \u222a S 15 end\nProposition 7 Let \u03a0 be a CNF theory and V \u2286 A where |\u03a0| = n and |V | = k. The time and space complexity of Algorithm 1 are O(n2 k ).\nProof: It follows from that the lines 5-9 of the algorithm, which is to compute sunfold(\u03a0, p), is bounded by O(|\u03a0|2), and the size of sunfold(\u03a0, p) is bounded by O(|\u03a0|2) as well.\nOne can evidently note that, if k is given as a fixed parameter then sunfold(\u03a0, V ) can be computed in polynomial time in the size of \u03a0. The following example shows that an exponential explosion of Forget(\u03a0, V ) is inescapable even if \u03a0 is a Horn theory.\nExample 3 Let \u03a0 be the Horn theory consisting of\np \u2228 \u00acq1 \u2228 . . . \u2228 \u00acqn, q1 \u2228 \u00acr1, q1 \u2228 \u00acr \u2032 1, . . . , qn \u2228 \u00acrn, qn \u2228 \u00acr \u2032 n.\nIt is not difficult to see that, for each subset I of N = {1, . . . , n},\n\u03a0 |=\n(\n\u2228\ni\u2208I\n\u00acri\n)\n\u2228\n\n\n\u2228\nj\u2208(N\\I)\n\u00acr\u2032j\n\n \u2228 p.\nThus Forget(\u03a0, {q1, . . . , qn}) is in exponential size of \u03a0 since there are 2n number of subsets of N . And as a matter of fact, there is no Horn theory that is in polynomial size of \u03a0 and is equivalent to Forget(\u03a0, {q1, . . . , qn}) since ( \u2228 i\u2208I \u00acri ) \u2228 (\n\u2228\nj\u2208(N\\I) \u00acr \u2032 j\n)\n\u2228 p is a prime implicate of \u03a0.\nNote that, in the case \u03a0 is a Krom theory, there are at most O(m2) number clauses where m = |Var(\u03a0)|. Thus |\u03a3| in the line 7 of Algorithm 1 is bounded by O(n2) where n = |\u03a0|. Then the overall time and space complexity is O(kn2) whenever \u03a0 is a Krom theory where k = |V |."}, {"heading": "3.3 Complexities", "text": "In the following we consider the complexities of reasoning problems on forgetting for various fragments of propositional logic."}, {"heading": "3.3.1 DNF, CNF and arbitrary theories", "text": "Proposition 8 Let \u03a0,\u03a3 be two (CNF) theories, and V \u2286 A. We have that\n(i) deciding if \u03a0 |= Forget(\u03a3, V ) is \u03a0P2 -complete,\n(ii) deciding if Forget(\u03a0, V ) |= \u03a3 is co-NP-complete,\n(iii) deciding if Forget(\u03a0, V ) |= Forget(\u03a3, V ) is \u03a0P2 -complete.\nProof: (i) Membership. In the case \u03a0 6|= Forget(\u03a3, V ), there exists a model M of \u03a0 such that M 6|= Forget(\u03a3, V ), i.e. for every model M \u2032 of \u03a3 such that M \u223cV M\n\u2032, M \u2032 6|= \u03a3, which can be done in polynomial time in the size of \u03a3 and V by calling a nondeterministic Turing machine.\nHardness. It follows from the fact that \u22a4 |= Forget(\u03a3, V ) iff Forget(\u03a3, V ) is valid, i.e. \u2200V \u2032\u2203V \u03a3 is valid, where V \u2032 = Var(\u03a3) \\ V . The latter is \u03a0P2 -complete even if \u03a3 is a CNF theory, as every formula can be translated into a CNF theory with auxiliary variables that preserves the satisfiability, informally \u2200V \u2032\u2203V \u03a3 can be translated polynomially into \u2200V \u2032\u2203V \u2203V \u2217\u03a3\u2032 such that (a) \u03a3\u2032 is a CNF theory, and (b) \u2200V \u2032\u2203V \u03a3 is valid iff \u2200V \u2032\u2203V \u2203V \u2217\u03a3\u2032 is valid, where V \u2217 is the introduced auxiliary variables [28].\n(ii) Membership. If Forget(\u03a0, V ) 6|= \u03a3 then there exists two sets M and M \u2032 such that M |= \u03a0,M \u2032 6|= \u03a3 and M \u223cV M \u2032. It is in polynomial time to guess such M,M \u2032 and check the conditions M |= \u03a0,M \u2032 6|= \u03a3 and M \u223cV M \u2032. Hence the problem is in co-NP.\nHardness. Forget(\u03a0, V ) |= \u22a5 if and only if \u03a0 |= \u22a5, i.e. \u03a0 has no model, which is co-NP-hard. Thus the problem is co-NP-complete.\n(iii) Membership. If Forget(\u03a0, V ) 6|= Forget(\u03a3, V ) then there exist an interpretation M such that M |= Forget(\u03a0, V ) but M 6|= Forget(\u03a3, V ), i.e., there is M \u2032 \u223cV M withM \u2032 |= \u03a0 butM \u2032\u2032 6|= \u03a3 for everyM \u2032\u2032 withM \u2032\u2032 \u223cV M . It is evident that guessing such M,M \u2032 with M \u223cV M \u2032 and checking M \u2032 |= \u03a0 are feasible, while checking M \u2032\u2032 6|= \u03a3 for every M \u2032\u2032 \u223cV M can be done in polynomial time in the size of V and \u03a3 by call a nondeterministic Turing machine. Thus the problem is in \u03a0P2 .\nHardness. It follows from (i) due to the fact that Forget(\u03a0, V ) |= Forget(\u03a3, V ) iff \u03a0 |= Forget(\u03a3, V ).\nThe proposition implies:\nCorollary 9 Let \u03a0,\u03a3 be two (CNF) theories, and V \u2286 A. Then\n(i) deciding if \u03a0 \u2261 Forget(\u03a3, V ) is \u03a0P2 -complete,\n(ii) deciding if Forget(\u03a0, V ) \u2261 Forget(\u03a3, V ) is \u03a0P2 -complete, and\n(iii) deciding if Forget(\u03a0, V ) \u2261 \u03a0 is co-NP-complete.\nIn the case \u03a0 is an arbitrary propositional formula, (ii) and (iii) of the corollary corresponds to VAR-EQUIVALENCE and VAR-INDEPENDENCE in [2], in which it is proved to be the same complexity as that of CNF theory case, respectively. Note that the inverse of item (iii) is the relevance problem, i.e., if a formula \u03a0 is relevant to V , which is NP-hard (cf. Theorem 50 of [24]).\nRecall that Forget(\u03d5, p) = \u03d5[p/\u22a4]\u2228\u03d5[p/\u22a5] for a given formula \u03d5 and an atom p. According to (i) of Proposition 4, when \u03d5 is a term l1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ln, Forget(\u03d5, V ) is the term obtained from \u03d5 by replacing li (1 \u2264 i \u2264 n) with \u22a4 if Var(li) \u2286 V . E.g. Forget(p \u2227 \u00acq, {p}) \u2261 \u00acq and Forget(p \u2227 \u00acq, {q}) \u2261 q. It implies that if \u03a0 is a DNF theory then Forget(\u03a0, V ) can be computed in linear time in the size of \u03a0 by (i) of Proposition 3.\nProposition 9 Let \u03a0,\u03a3 be two DNF theories, and V \u2286 A. The following problems are co-NP-complete:\n(i) deciding if \u03a0 |= Forget(\u03a3, V ),\n(ii) deciding if Forget(\u03a0, V ) |= \u03a3,\n(iii) deciding if Forget(\u03a0, V ) |= Forget(\u03a3, V ).\nProof: (i) Membership. It is obvious that if \u03a0 6|= Forget(\u03a3, V ) then there exists a set M of atoms such that M |= \u03a0 and M 6|= Forget(\u03a3, V ). As Forget(\u03a3, V ) is\ncomputable in polynomial time, the checking M |= \u03a0 and M 6|= Forget(\u03a3, V ) is feasible in polynomial time as well. Hence the problem is in co-NP.\nHardness. Let \u03a0 \u2261 \u22a4. Note that \u22a4 |= Forget(\u03a3, V ) iff Forget(\u03a3, V ) is valid. As Forget(\u03a3, V ) is still a DNF theory whose validness is co-NP-hard, it shows that the problem is co-NP-hard as well.\n(ii) and (iii) can be similarly proved as that of (i).\nThe proposition above implies\nCorollary 10 Let \u03a0,\u03a3 be two DNF theories, and V \u2286 A. The following problems are co-NP-complete.\n(i) deciding if \u03a0 \u2261 Forget(\u03a3, V ),\n(ii) deciding if Forget(\u03a0, V ) \u2261 Forget(\u03a3, V ),\n(iii) deciding if Forget(\u03a0, V ) \u2261 \u03a0."}, {"heading": "3.3.2 Horn theories and its variants", "text": "For a Horn formula \u03a3, its dependency graph is the directed graph G(\u03a3) = (V,E), where V = A and (ai, aj) \u2208 E iff there is a Horn clause c \u2208 \u03a3 such that \u00acai \u2208 c and aj \u2208 c. A Horn formula \u03a3 is acyclic if G(\u03a3) has no directed cycle.\nTheorem 11 Let \u03a0,\u03a3 be Horn (resp. ren-Horn and q-Horn) theories and V \u2286 A.\n(i) The problem of deciding if \u03a0 |= Forget(\u03a3, V ) is co-NP-complete, even if \u03a0 and \u03a3 are acyclic.\n(ii) The problem of deciding if Forget(\u03a0, V ) |= \u03a3 is tractable.\n(iii) The problem of deciding if Forget(\u03a0, V ) |= Forget(\u03a3, V ) is co-NP-complete, even if \u03a0 and \u03a3 are acyclic.\nProof: (i) Membership. Note that \u03a0 6|= Forget(\u03a3, V ) iff there is a prime implicate c of \u03a3 such that Var(c)\u2229V = \u2205 and \u03a0 6|= c, the latter holds iff \u03a0\u222a\u00acc has a model, where \u00acc = {\u00acl|l is a disjunct of c}. In the case \u03a0 is q-Horn, \u03a0 \u222a \u00acc is q-Horn and its satiability checking is tractable [21]. One can guess such a prime implicate c and check if \u03a0 6|= c in polynomial time in the size of \u03a0 and \u03a3. Thus the problem is in co-NP even if \u03a0,\u03a3 are q-Horn theories.\nHardness. Let \u03b3 = c1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 cm be a 3CNF formula over atoms x1, . . . , xn, where ci = li,1 \u2228 li,2 \u2228 li,3. The below construction is quite similar to the one used in the proof of Theorem 4.1 [29]. We introduce for each clause ci a new atom yi, for each atom xj a new atom x\u2032j (which intuitively corresponds to \u00acxj), and a\nspecial atom z. The Horn theory \u03a0 = {\u00acxi \u2228 \u00acx\u2032i|1 \u2264 i \u2264 n} and \u03a3 contains \u03a0 and additional the below clauses:\n\u00acz \u2228 y1, \u00acyi \u2228 \u00acl \u2217 i,j \u2228 yi+1 for all i = 1, . . . , m\u2212 1, and j = 1, 2, 3, \u00acym \u2228 \u00acl \u2217 m,j for j = 1, 2, 3\nwhere l\u2217 = x if l is a positive literal x, and l\u2217 = x\u2032 if l is a negative literal \u00acx. It is clear that both \u03a0 and \u03a3 are acyclic Horn formulas, thus Horn renamable and q-Horn formulas. We claim that \u03b3 is satisfiable iff \u03a0 6|= Forget(\u03a3, V ) where V = {y1, . . . , ym}. It is easy to see that \u03a3 has a prime implicate c such that Var(c) \u2229 V = \u2205 and c /\u2208 \u03a0 iff \u03a0 6|= Forget(\u03a3, V ).\nOn the one hand, let \u03c3 be a satisfying assignment of \u03b3. Then we arbitrarily choose from each ci a literal li,ji satisfied by \u03c3. It follows that c = \u00acz \u2228 ( \u2228\n1\u2264i\u2264m \u00acl \u2217 i,ji ) is an implicate of \u03a3 where ji \u2208 {1, 2, 3}, and c contains at most one literal in {\u00acxi,\u00acx\u2032i} for every i (1 \u2264 i \u2264 n). As Var(c)\u2229V = \u2205, and \u2228 i \u00acl \u2217 i,ji is not an implicate of \u03a0 since there is no subclauses of it is generated by the resolution procedure for \u03a0, we have that c is a prime implicate of \u03a3 and \u03a0 6|= c. Thus \u03a0 6|= Forget(\u03a3, V ).\nOn the other hand, there exists a prime implicate c of \u03a3 such that both \u03a0 6|= c and Var(c)\u2229V = \u2205 due to \u03a0 6|= Forget(\u03a3, V ). This prime implicate c can only be generated from the Horn clauses in \u03a3 \\ \u03a0 and has the form \u00acz \u2228 ( \u2228\n1\u2264i\u2264m \u00acl \u2217 i,ji ) where ji \u2208 {1, 2, 3}. As \u00acxi \u2228 \u00acx\u2032i \u2208 \u03a0, we have \u00acxi \u2228 \u00acx \u2032 i 6|= c for every i (1 \u2264 i \u2264 n) due to \u03a0 6|= c. It shows that c mentions at most one atom in {xi, x\u2032i} for every i. Therefore c corresponds to a satisfying assignment for \u03b3.\n(ii) In the case that \u03a3 is unsatisfiable, i.e. \u03a3 \u2261 \u22a5, Forget(\u03a0, V ) \u2261 \u22a5 iff \u03a0 \u2261 \u22a5. In this case the problem is tractable. Suppose \u03a3 is satisfiable. We have Forget(\u03a0, V ) |= \u03a3 iff Forget(\u03a0, V ) |= c for every clause c of \u03a3. In the case Var(c) \u2229 V 6= \u2205, we have Forget(\u03a0, V ) 6|= c. in the case Var(c) \u2229 V = \u2205, Forget(\u03a0, V ) |= c iff \u03a0 |= c iff \u03a0 \u222a \u00acc is unsatisfiable, which is tractable even if \u03a0 is a q-Horn theory [21].\n(iii) Membership. If Forget(\u03a0, V ) 6|= Forget(\u03a3, V ) then there exists a prime implicate c of \u03a3 such that \u03a0 6|= c and Var(c) \u2229 V = \u2205. Thus it is in co-NP.\nHardness. It follows from (i) since Forget(\u03a0, V ) |= Forget(\u03a3, V ) iff \u03a0 |= Forget(\u03a3, V ).\nAccordingly, we have the following corollary.\nCorollary 12 Let \u03a0,\u03a3 be two Horn (resp. ren-Horn and q-Horn) theories and V \u2286 A.\n(i) The problem of deciding if \u03a0 \u2261 Forget(\u03a3, V ) is co-NP-complete.\n(ii) The problem of deciding if Forget(\u03a0, V ) \u2261 Forget(\u03a3, V ) is co-NP-complete.\n(iii) The problem of deciding if Forget(\u03a0, V ) \u2261 \u03a0 is tractable.\nProof: (i) As \u03a0 6\u2261 Forget(\u03a3, V ) iff \u03a0 6|= Forget(\u03a3, V ) or Forget(\u03a3, V ) 6|= \u03a0, the latter is tractable by (ii) of Theorem 11 while the former is in co-NP. Hardness follows from (i) of Theorem 11. Thus the problem is co-NP-complete.\n(ii) Membership is easy. Hardness follows from (iii) of Theorem 11. (iii) It follows from the facts that Forget(\u03a0, V ) \u2261 \u03a0 iff Forget(\u03a0, V ) |= \u03a0,\nand (ii) of Theorem 11.\nThe item (iii) in the above corollary shows that the problem of deciding whether \u03a0 is relevant to V is tractable if \u03a0 is a q-Horn theory. Thus it generalizes Theorem 51 of [24] for Horn theories."}, {"heading": "3.3.3 Krom theories", "text": "Note that, for every Krom theory \u03a3 and V \u2286 A. It is evident that\nForget(\u03a3, V ) \u2261 {l1 \u2228 l2|Var({l1, l2}) \u2286 Var(\u03a3) \\ V and \u03a3 |= l1 \u2228 l2}.\nIt implies that Forget(\u03a3, V ) can be computed in polynomial time in the size of \u03a3 and V since \u03a3 |= l1 \u2228 l2 is tractable [23] and there are at most O(|Var(\u03a3) \\ V |2) number of such clauses. The following corollary follows.\nCorollary 13 Let \u03a0,\u03a3 be two Krom theories and V \u2286 A. All of the following problems are tractable:\n(i) deciding if \u03a0 |= Forget(\u03a3, V ),\n(ii) deciding if Forget(\u03a0, V ) |= \u03a3,\n(iii) deciding if Forget(\u03a0, V ) |= Forget(\u03a3, V ),\n(iv) deciding if \u03a0 \u2261 Forget(\u03a3, V ),\n(v) deciding if Forget(\u03a0, V ) \u2261 Forget(\u03a3, V ),\n(vi) deciding if Forget(\u03a0, V ) \u2261 \u03a0."}, {"heading": "4 Related Work", "text": "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18]."}, {"heading": "4.1 Uniform interpolation", "text": "Let \u03b1, \u03b2 be two formulas. If \u03b1 |= \u03b2, an interpolant for (\u03b1, \u03b2) is a formula \u03b3 s.t\n\u03b1 |= \u03b3 and \u03b3 |= \u03b2 (1)\nwhere Var(\u03b3) \u2286 Var(\u03b1) \u2229 Var(\u03b2). A logic L with inference |=L is said to have the interpolantion property if an interpolant exists for every pair of formulas (\u03b1, \u03b2) such that \u03b1 |=L \u03b2. A logic L has uniform interpolation property iff for any formula \u03b1 and V a set of atoms, there exists a formula \u03b3 such that Var(\u03b3) \u2286 Var(\u03b1) \\ V , and for any formula \u03b2 with Var(\u03b2) \u2229 V = \u2205,\n\u03b1 |=L \u03b2 iff \u03b3 |=L \u03b2. (2)\nIt is easy to see that uniform interpolation is a strengthening of interpolation. A well-known result is that propositional logic has uniform interpolation property, while first-order logic does not [30].\nProposition 10 If \u03a3 is a double Horn theory and V \u2286 A then Forget(\u03a3, V ) is a double Horn theory.\nProof: Firstly Forget(\u03a3, V ) is Horn expressible by Corollary 5. We show that \u00acForget(\u03a3, V ) is Horn expressible by contradiction in the following. Suppose that there exist two interpretations X, Y such that\nX 6|= Forget(\u03a3, V ), Y 6|= Forget(\u03a3, V ), X \u2229 Y |= Forget(\u03a3, V ).\nNote that Forget(\u03a3, V ) is irrelevant to V . Thus I |= Forget(\u03a3, V ) if and only if I \\ V |= Forget(\u03a3, V ). For this reason, we assume X \u2229 V = \u2205 and Y \u2229 V = \u2205. The following three conditions hold:\n(a) X \u2032 6|= \u03a3 for any X \u2286 X \u2032 \u2286 X \u222a V .\n(b) Y \u2032 6|= \u03a3 for any Y \u2286 Y \u2032 \u2286 Y \u222a V .\n(c) There exists Z |= \u03a3 for some X \u2229 Y \u2286 Z \u2286 X \u2229 Y \u222a V .\nThe conditions (a) and (b) imply X \u2032 \u2229 Y \u2032 6|= \u03a3 since \u03a3 is a double Horn formula. It is evident that X \u2229 Y \u2286 X \u2032 \u2229 Y \u2032 \u2286 (X \u222a V ) \u2229 (Y \u222a V ) = X \u2229 Y \u222a V . This contradicts with condition (c).\nTogether with Corollary 8, the proposition above implies:\nCorollary 14 The Horn, Krom, double Horn, ren-Horn and q-Horn fragments of propositional logic have uniform interpolation property."}, {"heading": "4.2 Strongest necessary and weakest sufficient conditions", "text": "Let T be a theory, V \u2286 Var(T ) and q \u2208 Var(T ) \\ V . A formula \u03d5 of V is a necessary condition of q on V under T if T |= q \u2283 \u03d5. It is a strongest necessary condition (SNC) if it is a necessary condition and for any other necessary condition \u03d5\u2032, T |= \u03d5 \u2283 \u03d5\u2032. A formula \u03c8 of V is a sufficient condition of q on V under T if T |= \u03c8 \u2283 q. It is a weakest sufficient condition (WSC) if it is a sufficient condition and, for any other sufficient condition \u03c8\u2032, T |= \u03c8\u2032 \u2283 \u03c8 [17].\nTheorem 15 (Theorem 2 of [17]) Let T be a theory, V \u2286 Var(T ), q \u2208 Var(T ) \\ V , and V \u2032 = Var(T ) \\ (V \u222a {q}).\n\u2022 The strongest necessary condition of q on V under T is Forget(T [q/\u22a4], V \u2032).\n\u2022 The weakest sufficient condition of q on V under T is \u00acForget(T [q/\u22a5], V \u2032).\nNote that T [q/\u22a4] is a Horn (resp. Krom, ren-Horn and q-Horn) theory if T is a Horn (resp. Krom, ren-Horn and q-Horn) theory. In terms of Corollary 14, the SNC of q under T is Horn (resp. Krom, ren-Horn and q-Horn) expressible if T is a Horn (resp. Krom, ren-Horn and q-Horn) theory.\nThe following example shows that the weakest sufficient condition on Horn (resp. Krom) formulas may be not Horn (resp. Krom) expressible.\nExample 4 Let\u2019s consider the following two theories. (1) Let \u03a3 = (\u00acp \u2228 \u00acr) \u2227 (\u00acq \u2228 r) \u2227 (\u00acs \u2228 r) \u2227 \u00act, which is a Horn formula. We have that Forget(\u03a3[t/\u22a5], r) \u2261 (\u00acp\u2228\u00acq)\u2227 (\u00acp\u2228\u00acs). Thus \u00acForget(\u03a3, r) \u2261 p\u2227 (q\u2228 s), which is evidently not Horn expressible. That is the weakest sufficient condition of t on {p, q, s} under \u03a3 is not Horn expressible.\n(2) Let \u03a0 = (p1 \u2228 p2) \u2227 (\u00acp1 \u2228 p3) \u2227 (\u00acp2 \u2228 \u00acp3) \u2227 \u00acq, which is a Krom formula. Note that Forget(\u03a0[q/\u22a5], \u2205) \u2261 (p1 \u2228 p2) \u2227 (\u00acp1 \u2228 p3) \u2227 (\u00acp2 \u2228 \u00acp3). Thus \u00acForget(\u03a0[q/\u22a5], \u2205) \u2261 (\u00acp1 \u2228 p2 \u2228 \u00acp3) \u2227 (p1 \u2228 \u00acp2 \u2228 p3) \u2227 (\u00acp2 \u2228 \u00acp3). It is not a Krom formula. Actually, the clause \u00acp1 \u2228 p2 \u2228\u00acp3 is a prime implicate of \u00acForget(\u03a0[q/\u22a5], \u2205).\nTheorem 16 Let T, \u03d5 be two formulas, V \u2286 Var(T ), q \u2208 Var(T ) \\ V .\n(i) Deciding if \u03d5 is a necessary (sufficient) condition of q under T is co-NPcomplete.\n(ii) Deciding if \u03d5 is a necessary (sufficient) condition of q under T is tractable if T and \u03d5 are Horn (resp. ren-Horn and q-Horn) formulas.\n(iii) Deciding if \u03d5 is a strongest necessary (weakest sufficient) condition of q under T is \u03a0P2 -complete.\n(iv) Deciding if \u03d5 is a strongest necessary (weakest sufficient) condition of q under T is co-NP-complete if T and \u03d5 are Horn (resp. ren-Horn and qHorn) formulas.\nProof: (i) T |= q \u2283 \u03d5 iff T \u2227 q\u2227\u00ac\u03d5 is unsatisfiable. This is in co-NP and co-NPhard, i.e. deciding if \u03d5 is a necessary condition of q under T is co-NP-complete. The case of sufficient condition is similar.\n(ii) T |= q \u2283 \u03d5 iff T \u2227 q \u2227 \u00acc is unsatisfiable for every clause c of \u03d5, which is tractable even T and \u03d5 are q-Horn formulas. Thus deciding if \u03d5 is a necessary condition of q under T is tractable. Similarly T |= \u03d5 \u2283 q iff T \u2227 \u03d5 \u2227 \u00acq is unsatisfiable even if T and \u03d5 are q-Horn formulas.\n(iii) In terms of Theorem 15, \u03d5 is a strongest necessary condition of q under T iff \u03d5 \u2261 Forget(T [q/\u22a4], V \u2032) where V \u2032 = Var(T ) \\ (V \u222a {q}). It is in \u03a0P2 and \u03a0P2 -hard by (i) of Corollary 9.\n(iv) Recall that \u03d5 is a strong necessary condition of q under T if and only if \u03d5 \u2261 Forget(T [q/\u22a4], V \u2032) by (i) of Theorem 15 where V \u2032 = Var(T ) \\ (V \u222a {q}). Thus it is in co-NP when \u03d5 and T are q-Horn formulas and is co-NP-hard when \u03d5 and T are Horn formulas by (i) of Corollary 12.\nProposition 11 Let T and \u03d5 be two Krom formulas, V \u2286 Var(T ), q \u2208 Var(T )\\V .\n(i) Deciding if \u03d5 is a strongest necessary condition of q under T is tractable.\n(ii) Deciding if \u03d5 is a weakest sufficient condition of q under T is tractable.\nProof: Firstly, according to Theorem 4, one can compute Forget(T [q/\u22a4], V \u2032) in polynomial time in the size of T and V where V \u2032 = Var(T ) \\ (V \u222a {q}). It is evident that \u03a3 = sunfold(Forget[q/\u22a4], V \u2032) and \u03a3\u2032 = Forget(T [q/\u22a5], V \u2032) are Krom theories.\n(i) It follows from the facts that checking equivalence for Krom theories is tractable and \u03d5 is a strongest condition of q under T iff \u03d5 \u2261 \u03a3 by (i) of Theorem 15.\n(ii) \u03d5 is a weakest sufficient condition of q under T iff \u03d5 \u2261 \u00ac\u03a3\u2032 iff \u03d5 |= \u00ac\u03a3\u2032 and \u00ac\u03a3\u2032 |= \u03d5 iff \u03d5 \u2227 \u03a3\u2032 is unsatisfiable and \u00ac\u03a3\u2032 |= l1 \u2228 l2 for every conjunct l1 \u2228 l2 of \u03d5.\nIt is evident that checking satisfiability of \u03d5 \u2227 \u03a3\u2032 is tractable since \u03d5 \u2227 \u03a3\u2032 is a Krom formula. Note further that \u00ac\u03a3\u2032 |= l1 \u2228 l2 iff \u00ac\u03a3\u2032 \u2227 \u00acl1 \u2227 \u00acl2 is unsatisfiable iff \u03a3\u2032\u2032 = \u00ac(\u03a3\u2032[\u00acl1/\u22a4][\u00acl2/\u22a4]) is unsatisfiable iff s1 \u2227 s2 is unsatisfiable for every disjunct s1 \u2227 s2 of \u03a3\u2032\u2032, which is a 2-DNF formula."}, {"heading": "4.3 Strongest and weakest definitions", "text": "Definability is acknowledged as an important logical concept when reasoning about knowledge represented in propositional logic. Informally speaking, an atom p can be \u201cdefined\u201d in a given formula \u03a3 in terms of a set X of atoms whenever the knowledge of the truth values of X enables concluding about the truth value of p, under the condition of \u03a3 [18].\nDefinition 3 ([18]) Let \u03a3 be a formula, p \u2208 A, X \u2286 A and Y \u2286 A.\n\u2022 \u03a3 defines p in terms of X , denoted by X \u2291\u03a3 p, iff there exists a formula \u03a8 over X such that \u03a3 |= \u03a8 \u2194 p.\n\u2022 \u03a3 defines Y in terms of X , denoted by X \u2291\u03a3 Y , iff there exists a formula \u03a8 over X such that \u03a3 |= \u03a8 \u2194 p for every p \u2208 Y .\nIt is known that if both \u03d5 and \u03c8 (over a same signature X) are definitions of p in \u03a3 then \u03a3 |= \u03d5 \u2194 \u03c8, and additionally both \u03d5 \u2227 \u03c8 and \u03d5 \u2228 \u03c8 are definitions of p in \u03a3. In this situation, the strongest (resp. weakest) definition of p in \u03a3 exist, they are denoted by DefX,l\u03a3 (p) and Def X,u \u03a3 (p) respectively. In terms of Corollary 9 of [3] and Theorem 10 of [18], if \u03a3 defines p in terms of X then DefX,l\u03a3 (p) (resp. DefX,u\u03a3 (p)) is equivalent to the strongest necessary (resp. weakest sufficient) condition of p under \u03a3. Thus according to Theorem 16 and Proposition 11 we have the following:\nCorollary 17 Let \u03a3, \u03d5 be two formulas, X \u2286 A, p \u2208 A and Var(\u03d5) \u2286 X .\n(i) The problem of deciding if \u03d5 is a strongest (resp. weakest) definition of p (in terms of X) in \u03a3 is \u03a0P2 -complete.\n(ii) The problem of deciding if \u03d5 is a strongest (resp. weakest) definition of p (in terms of X) in \u03a3 is co-NP-complete if both \u03a3 and \u03d5 are Horn (resp. ren-Horn and q-Horn) formulas.\n(iii) deciding if \u03d5 is a strongest (resp. weakest) definition of p (in terms of X) in \u03a3 is tractable if both \u03a3 and \u03d5 are Krom formulas."}, {"heading": "5 Concluding Remarks", "text": "As mentioned in the introduction, forgetting is closely connected with many other logical concepts. Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33]. The main concerned Horn,\nKrom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].\nIn the paper we have firstly presented a resolution-based algorithm for computing forgetting results of CNF fragments of propositional logic. Though the algorithm is generally expensive even for Horn fragment as it is theoretically intractable, it opens a heuristic potentiality, e.g. choosing different orders of atoms to forget, and choosing different orders of resolvable clauses to do resolution. To investigate the effectiveness of the algorithm, heuristics and extensive experiments are worthy of studying.\nWhat\u2019s more, when concerning the dynamics of knowledge base, we considered various reasoning problems about forgetting in the fragments of propositional logic whose satisfiability are tractable. In particular, we concentrated on Horn, renamable Horn, q-Horn and Krom theories. The considered reasoning problems include VAR-EQUIVALENCE, VAR-INDEPENDENCE, VAR-WEAK, VAR-STRONG, VAR-MATCH and VAR-ENTAILMENT. Although some of the problems have been partially solved, e.g., VAR-EQUIVALENCE and VAR-INDEPENDENCE for propositional logic are proved in [2], this is the first comprehensive study on these problems for CNF, Horn, ren-Horn, q-Horn, Krom and DNF fragments, to our knowledge. It motivates us to consider these reasoning problems for forgetting in non-classical logical systems, such as model logic S5 in particular.\nIt deserves our further effort to investigate the knowledge simplification or compilation [16] in other logical formalisms, logic programming under stable model semantics, particularly.\nAcknowledgement This work was supported by the National Natural Science Foundation of China under grants 60963009,61370161 and Stadholder Foundation of Guizhou Province under grant (2012)62."}], "references": [{"title": "Propositional independence: Formula-variable independence and forgetting", "author": ["J\u00e9r\u00f4me Lang", "Paolo Liberatore", "Pierre Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2003}, {"title": "Reasoning under inconsistency: A forgetting-based approach", "author": ["J\u00e9r\u00f4me Lang", "Pierre Marquis"], "venue": "Artificial Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "Uniform interpolation and layered bisimulation", "author": ["Albert Visser"], "venue": "In Go\u0308del\u201996,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1996}, {"title": "Solving logic program conflict through strong and weak forgettings", "author": ["Yan Zhang", "Norman Y. Foo"], "venue": "Artificial Intelligence,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2006}, {"title": "Semantic forgetting in answer set programming", "author": ["Thomas Eiter", "Kewen Wang"], "venue": "Artificial Intelligence,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}, {"title": "Forgetting in Logic Programs", "author": ["Ka-Shu Wong"], "venue": "PhD thesis, The University of New South Wales,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2009}, {"title": "Forgetting in logic programs under strong equivalence", "author": ["Yisong Wang", "Yan Zhang", "Yi Zhou", "Mingyi Zhang"], "venue": "In Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Forgetting for answer set programs revisited", "author": ["Yisong Wang", "Kewen Wang", "Mingyi Zhang"], "venue": "IJCAI", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2013}, {"title": "Forgetting for knowledge bases in dl-lite", "author": ["Zhe Wang", "Kewen Wang", "Rodney W. Topor", "Jeff Z. Pan"], "venue": "Annuals of Mathematics and Artificial Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Foundations for uniform interpolation and forgetting in expressive description logics", "author": ["Carsten Lutz", "Frank Wolter"], "venue": "IJCAI", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Knowledge forgetting: Properties and applications", "author": ["Yan Zhang", "Yi Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "Variable forgetting in reasoning about knowledge", "author": ["Kaile Su", "Abdul Sattar", "Guanfeng Lv", "Yan Zhang"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "On the progression of knowledge in the situation calculus", "author": ["Yongmei Liu", "Ximing Wen"], "venue": "IJCAI", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Knowledge compilation in the modal logic s5", "author": ["Meghyn Bienvenu", "H\u00e9l\u00e8ne Fargier", "Pierre Marquis"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "On strongest necessary and weakest sufficient conditions", "author": ["Fangzhen Lin"], "venue": "Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2001}, {"title": "On propositional definability", "author": ["J\u00e9r\u00f4me Lang", "Pierre Marquis"], "venue": "Artif. Intell.,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "On sentences which are true of direct unions of algebras", "author": ["Alfred Horn"], "venue": "The Journal of Symbolic Logic,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1951}, {"title": "Renaming a set of clauses as a horn set", "author": ["Harry R. Lewis"], "venue": "J. ACM,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1978}, {"title": "Polynomial-time inference of all valid implications for horn and related formulae", "author": ["Endre Boros", "Yves Crama", "Peter L. Hammer"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1990}, {"title": "The decision problem for formulas in prenex conjunctive normal form with binary disjunctions", "author": ["M.R. Krom"], "venue": "The Journal of Symbolic Logic,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1970}, {"title": "Relevance from an epistemic perspective", "author": ["Gerhard Lakemeyer"], "venue": "Artif. Intell.,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1997}, {"title": "Handbook of Defeasible Reasoning and Uncertainty Management Systems: Algorithms for Defeasible and Uncertain Reasoning, volume 5, chapter Consequence finding algorithms, pages 41\u2013145", "author": ["Pierre Marquis"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1999}, {"title": "On renamable horn and generalized horn functions", "author": ["V. Chandru", "Collette R. Coullard", "Peter L. Hammer", "M. Montanuz", "Xiaorong Sun"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1990}, {"title": "Recognition of q-horn formulae in linear time", "author": ["Endre Boros"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1994}, {"title": "Handbook of Satisfiability, chapter 23 Theory of Quantified Boolean Formulas, pages 735\u2013760", "author": ["Hans Kleine B\u00fcning", "Uwe Bubeck"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "On computing all abductive explanations from a propositional horn theory", "author": ["Thomas Eiter", "Kazuhisa Makino"], "venue": "J. ACM,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}, {"title": "Interpolation in non-classical", "author": ["Giovanna D\u2019Agostino"], "venue": "logics. Synthese,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2008}, {"title": "Quantitatively evaluating formula-variable relevance by forgetting", "author": ["Xin Liang", "Zuoquan Lin", "Jan Van den Bussche"], "venue": "In Canadian Conference on AI,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2013}, {"title": "Lost in translation: Language independence in propositional logic \u2013 application to belief change", "author": ["Pierre Marquis", "Nicolas Schwind"], "venue": "Artificial Intelligence,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2014}, {"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["Carlos E. Alchourr\u00f6n", "Peter G\u00e4rdenfors", "David Makinson"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1985}, {"title": "Quantifier rewriting and equivalence models for quantified horn formulas", "author": ["Uwe Bubeck", "Hans Kleine B\u00fcing", "Xishun Zhao"], "venue": "editors, Theory and Applications of Satisfiability Testing,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2005}, {"title": "Redundancy in logic II: 2CNF and horn propositional formulae", "author": ["Paolo Liberatore"], "venue": "Artificial Intelligence,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2008}, {"title": "Language splitting and relevance-based belief change in horn logic", "author": ["Maonian Wu", "Dongmo Zhang", "Mingyi Zhang"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2011}, {"title": "Horn clause contraction functions", "author": ["James P. Delgrande", "Renata Wassermann"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2013}, {"title": "Belief revision in horn theories", "author": ["James P. Delgrande", "Pavlos Peppas"], "venue": "Artificial Intelligence,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "Motivated from Lin and Reiter\u2019s seminal work in first-order logic [1], the notion of forgetting \u2013 distilling from a knowledge base only the part that is relevant to a subset of the alphabet \u2013 has attracted extensive interests [2, 3].", "startOffset": 226, "endOffset": 232}, {"referenceID": 1, "context": "Motivated from Lin and Reiter\u2019s seminal work in first-order logic [1], the notion of forgetting \u2013 distilling from a knowledge base only the part that is relevant to a subset of the alphabet \u2013 has attracted extensive interests [2, 3].", "startOffset": 226, "endOffset": 232}, {"referenceID": 2, "context": "A dual notion of forgetting in mathematical logic is called uniform interpolation [4].", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 191, "endOffset": 207}, {"referenceID": 4, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 191, "endOffset": 207}, {"referenceID": 5, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 191, "endOffset": 207}, {"referenceID": 6, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 191, "endOffset": 207}, {"referenceID": 7, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 191, "endOffset": 207}, {"referenceID": 8, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 241, "endOffset": 249}, {"referenceID": 9, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 241, "endOffset": 249}, {"referenceID": 10, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 291, "endOffset": 303}, {"referenceID": 11, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 291, "endOffset": 303}, {"referenceID": 12, "context": "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].", "startOffset": 291, "endOffset": 303}, {"referenceID": 3, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 26, "endOffset": 32}, {"referenceID": 1, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 26, "endOffset": 32}, {"referenceID": 10, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 59, "endOffset": 67}, {"referenceID": 13, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 59, "endOffset": 67}, {"referenceID": 14, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 190, "endOffset": 194}, {"referenceID": 15, "context": "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.", "startOffset": 230, "endOffset": 234}, {"referenceID": 0, "context": "have showed that deciding if a formula is independent of a set of atoms (called VAR-INDEPENDENCE) is co-NP-complete, and deciding if two formulas are equivalent on a common signature (called VAR-EQUIVALENCE) is \u03a02 -complete [2].", "startOffset": 224, "endOffset": 227}, {"referenceID": 16, "context": "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.", "startOffset": 134, "endOffset": 138}, {"referenceID": 17, "context": "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.", "startOffset": 155, "endOffset": 159}, {"referenceID": 18, "context": "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.", "startOffset": 197, "endOffset": 205}, {"referenceID": 15, "context": "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.", "startOffset": 197, "endOffset": 205}, {"referenceID": 19, "context": "Accordingly, we show that forgetting is categorical in the Horn, ren-Horn, q-Horn, double Horn [22] and Krom [23] (or 2-CNF) fragments.", "startOffset": 109, "endOffset": 113}, {"referenceID": 19, "context": "ren-Horn, q-Horn, double Horn and Krom [23] (or 2-CNF)) theory is Horn (resp.", "startOffset": 39, "endOffset": 43}, {"referenceID": 0, "context": "More importantly, from the perspective of knowledge bases evolving, we are also interested in the following reasoning problems about forgetting, besides the VAR-INDEPENDENCE and VAR-EQUIVALENCE in [2], where Forget(\u03c6, V ) stands for a result of forgetting V from formula \u03c6, (1) [VAR-INDEPENDENCE] If a knowledge base \u03a0 is independent of a set V of atoms, i.", "startOffset": 197, "endOffset": 200}, {"referenceID": 19, "context": "In particular, 2-CNF formulas are called Krom formulas [23].", "startOffset": 55, "endOffset": 59}, {"referenceID": 20, "context": "The definition of relevant is equivalent with, but slightly different from, that of [24], in which \u03c8 is relevant to V if there is a prime implicate of \u03c8 which mentions some atom from V .", "startOffset": 84, "endOffset": 88}, {"referenceID": 21, "context": "The following lemma is well-known [25].", "startOffset": 34, "endOffset": 38}, {"referenceID": 16, "context": "A clause c is Horn [19] if |Pos(c)| \u2264 1.", "startOffset": 19, "endOffset": 23}, {"referenceID": 17, "context": "A CNF formula \u03c6 is Horn renamable [20] iff there exists a Horn renaming for it, i.", "startOffset": 34, "endOffset": 38}, {"referenceID": 18, "context": "Definition 1 ([21, 18]) A CNF theory \u03a3 has a QH-partition iff there exists a partition {Q,H} of Var(\u03a3) s.", "startOffset": 14, "endOffset": 22}, {"referenceID": 15, "context": "Definition 1 ([21, 18]) A CNF theory \u03a3 has a QH-partition iff there exists a partition {Q,H} of Var(\u03a3) s.", "startOffset": 14, "endOffset": 22}, {"referenceID": 18, "context": "A CNF theory \u03a3 is q-Horn iff there exists a q-Horn renaming for it [21], i.", "startOffset": 67, "endOffset": 71}, {"referenceID": 17, "context": "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.", "startOffset": 74, "endOffset": 82}, {"referenceID": 22, "context": "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.", "startOffset": 74, "endOffset": 82}, {"referenceID": 23, "context": "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.", "startOffset": 91, "endOffset": 95}, {"referenceID": 0, "context": "The following proposition easily follows from the definition of forgetting, cf, Propositions 17 and 21 of [2].", "startOffset": 106, "endOffset": 109}, {"referenceID": 0, "context": "The following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].", "startOffset": 57, "endOffset": 60}, {"referenceID": 0, "context": "The following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].", "startOffset": 96, "endOffset": 99}, {"referenceID": 20, "context": "It is proved by Theorem 37 of [24], and can follows from Propositions 19 and 20 of [2].", "startOffset": 30, "endOffset": 34}, {"referenceID": 0, "context": "It is proved by Theorem 37 of [24], and can follows from Propositions 19 and 20 of [2].", "startOffset": 83, "endOffset": 86}, {"referenceID": 14, "context": "Actually, (i)\u21d4(iv) is mentioned as a fact in [17], which states that Forget(\u03a3, V ) is equivalent to the conjunction of prime implicates of \u03a3 that do not mention any propositions from V .", "startOffset": 45, "endOffset": 49}, {"referenceID": 24, "context": "The latter is \u03a02 -complete even if \u03a3 is a CNF theory, as every formula can be translated into a CNF theory with auxiliary variables that preserves the satisfiability, informally \u2200V \u2203V \u03a3 can be translated polynomially into \u2200V \u2203V \u2203V \u03a3 such that (a) \u03a3 is a CNF theory, and (b) \u2200V \u2203V \u03a3 is valid iff \u2200V \u2203V \u2203V \u03a3 is valid, where V \u2217 is the introduced auxiliary variables [28].", "startOffset": 364, "endOffset": 368}, {"referenceID": 0, "context": "In the case \u03a0 is an arbitrary propositional formula, (ii) and (iii) of the corollary corresponds to VAR-EQUIVALENCE and VAR-INDEPENDENCE in [2], in which it is proved to be the same complexity as that of CNF theory case, respectively.", "startOffset": 140, "endOffset": 143}, {"referenceID": 20, "context": "Theorem 50 of [24]).", "startOffset": 14, "endOffset": 18}, {"referenceID": 18, "context": "In the case \u03a0 is q-Horn, \u03a0 \u222a \u00acc is q-Horn and its satiability checking is tractable [21].", "startOffset": 84, "endOffset": 88}, {"referenceID": 25, "context": "1 [29].", "startOffset": 2, "endOffset": 6}, {"referenceID": 18, "context": "in the case Var(c) \u2229 V = \u2205, Forget(\u03a0, V ) |= c iff \u03a0 |= c iff \u03a0 \u222a \u00acc is unsatisfiable, which is tractable even if \u03a0 is a q-Horn theory [21].", "startOffset": 135, "endOffset": 139}, {"referenceID": 20, "context": "Thus it generalizes Theorem 51 of [24] for Horn theories.", "startOffset": 34, "endOffset": 38}, {"referenceID": 19, "context": "It implies that Forget(\u03a3, V ) can be computed in polynomial time in the size of \u03a3 and V since \u03a3 |= l1 \u2228 l2 is tractable [23] and there are at most O(|Var(\u03a3) \\ V |) number of such clauses.", "startOffset": 120, "endOffset": 124}, {"referenceID": 26, "context": "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].", "startOffset": 91, "endOffset": 95}, {"referenceID": 14, "context": "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].", "startOffset": 151, "endOffset": 155}, {"referenceID": 15, "context": "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].", "startOffset": 195, "endOffset": 199}, {"referenceID": 26, "context": "A well-known result is that propositional logic has uniform interpolation property, while first-order logic does not [30].", "startOffset": 117, "endOffset": 121}, {"referenceID": 14, "context": "It is a weakest sufficient condition (WSC) if it is a sufficient condition and, for any other sufficient condition \u03c8, T |= \u03c8 \u2283 \u03c8 [17].", "startOffset": 129, "endOffset": 133}, {"referenceID": 14, "context": "Theorem 15 (Theorem 2 of [17]) Let T be a theory, V \u2286 Var(T ), q \u2208 Var(T ) \\ V , and V \u2032 = Var(T ) \\ (V \u222a {q}).", "startOffset": 25, "endOffset": 29}, {"referenceID": 15, "context": "Informally speaking, an atom p can be \u201cdefined\u201d in a given formula \u03a3 in terms of a set X of atoms whenever the knowledge of the truth values of X enables concluding about the truth value of p, under the condition of \u03a3 [18].", "startOffset": 218, "endOffset": 222}, {"referenceID": 15, "context": "Definition 3 ([18]) Let \u03a3 be a formula, p \u2208 A, X \u2286 A and Y \u2286 A.", "startOffset": 14, "endOffset": 18}, {"referenceID": 1, "context": "In terms of Corollary 9 of [3] and Theorem 10 of [18], if \u03a3 defines p in terms of X then Def \u03a3 (p) (resp.", "startOffset": 27, "endOffset": 30}, {"referenceID": 15, "context": "In terms of Corollary 9 of [3] and Theorem 10 of [18], if \u03a3 defines p in terms of X then Def \u03a3 (p) (resp.", "startOffset": 49, "endOffset": 53}, {"referenceID": 27, "context": "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].", "startOffset": 68, "endOffset": 72}, {"referenceID": 28, "context": "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].", "startOffset": 134, "endOffset": 138}, {"referenceID": 29, "context": "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].", "startOffset": 186, "endOffset": 190}, {"referenceID": 30, "context": "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].", "startOffset": 74, "endOffset": 94}, {"referenceID": 31, "context": "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].", "startOffset": 74, "endOffset": 94}, {"referenceID": 32, "context": "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].", "startOffset": 74, "endOffset": 94}, {"referenceID": 33, "context": "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].", "startOffset": 74, "endOffset": 94}, {"referenceID": 34, "context": "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].", "startOffset": 74, "endOffset": 94}, {"referenceID": 0, "context": ", VAR-EQUIVALENCE and VAR-INDEPENDENCE for propositional logic are proved in [2], this is the first comprehensive study on these problems for CNF, Horn, ren-Horn, q-Horn, Krom and DNF fragments, to our knowledge.", "startOffset": 77, "endOffset": 80}, {"referenceID": 13, "context": "It deserves our further effort to investigate the knowledge simplification or compilation [16] in other logical formalisms, logic programming under stable model semantics, particularly.", "startOffset": 90, "endOffset": 94}], "year": 2015, "abstractText": "Distilling from a knowledge base only the part that is relevant to a subset of alphabet, which is recognized as forgetting, has attracted extensive interests in AI community. In standard propositional logic, a general algorithm of forgetting and its computation-oriented investigation in various fragments whose satisfiability are tractable are still lacking. The paper aims at filling the gap. After exploring some basic properties of forgetting in propositional logic, we present a resolution-based algorithm of forgetting for CNF fragment, and some complexity results about forgetting in Horn, renamable Horn, q-Horn, Krom, DNF and CNF fragments of propositional logic.", "creator": "LaTeX with hyperref package"}}}