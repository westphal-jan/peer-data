{"id": "1502.03796", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Feb-2015", "title": "Variable and value elimination in binary constraint satisfaction via forbidden patterns", "abstract": "Variable or value elimination in a constraint satisfaction problem (CSP) can be used in preprocessing or during search to reduce search space size. A variable elimination rule (value elimination rule) allows the polynomial-time identification of certain variables (domain elements) whose elimination, without the introduction of extra compensatory constraints, does not affect the satisfiability of an instance. We show that there are essentially just four variable elimination rules and three value elimination rules defined by forbidding generic sub-instances, known as irreducible existential patterns, in arc-consistent CSP instances.\n\n\nThe standard definition of irreducible existential patterns is commonly used in CSP in the following three cases:\n1) An invalid and non-consistent CSP example (see below) and a non-consistent CSP example (see below). In the following examples, we define a fixed conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example.\n1) An invalid and non-consistent CSP example (see below). In the following examples, we define a conditional condition in the CSP example. We use a conditional condition in the CSP example.\n2) An invalid and non-consistent CSP example (see below). In the following examples, we define a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example.\n3) An invalid and non-consistent CSP example (see below). In the following examples, we define a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example. We use a conditional condition in the CSP example.\n4) An invalid and non-consistent CSP example (see below). In the following examples, we define a", "histories": [["v1", "Thu, 12 Feb 2015 20:22:44 GMT  (28kb)", "http://arxiv.org/abs/1502.03796v1", "A full version of an IJCAI'13 paper to appear in Journal of Computer and System Sciences (JCSS)"]], "COMMENTS": "A full version of an IJCAI'13 paper to appear in Journal of Computer and System Sciences (JCSS)", "reviews": [], "SUBJECTS": "cs.CC cs.AI cs.DM", "authors": ["david a cohen", "martin c cooper", "guillaume escamocher", "stanislav zivny"], "accepted": false, "id": "1502.03796"}, "pdf": {"name": "1502.03796.pdf", "metadata": {"source": "CRF", "title": "Variable and Value Elimination in Binary Constraint Satisfaction via Forbidden Patterns", "authors": ["David A. Cohen"], "emails": ["dave@cs.rhul.ac.uk", "cooper@irit.fr", "guillaume.escamocher@insight-centre.org", "standa@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 2.\n03 79\n6v 1\n[ cs"}, {"heading": "1 Introduction", "text": "Constraint satisfaction has proved to be a useful modelling tool in a variety of contexts, such as scheduling, timetabling, planning, bio-informatics and computer vision [17, 24, 29]. Dedicated solvers for constraint satisfaction are at the heart of the programming paradigm known as constraint programming. Theoretical advances on CSPs can thus potentially lead to the improvement of generic combinatorial problem solvers.\nIn the CSP model we have a number of variables, each of which can take values from its particular finite domain. Certain sets of the variables are constrained in that their simultaneous assignments of values is limited. The generic problem in which these sets of variables, known as the constraint scopes, are all of cardinality at most two, is known as binary constraint satisfaction. We are required to assign values to all variables so that every constraint is satisfied. Complete solution algorithms\n\u2217A preliminary version of part of this work appeared in Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI), 2013. Martin Cooper and Guillaume Escamocher were supported by ANR Project ANR-10-BLAN-0210. Stanislav Z\u030civny\u0301 was supported by a Royal Society University Research Fellowship. David Cohen, Martin Cooper and Stanislav Z\u030civny\u0301 were supported by EPSRC grant EP/L021226/1.\nfor constraint satisfaction are not polynomial time unless P=NP, since the graph colouring problem, which is NP-complete, can be reduced to binary constraint satisfaction [17]. Hence we need to find ways to reduce the search space.\nSearch algorithms for constraint problems usually proceed by transforming the instance into a set of subproblems, for example, by selecting a variable and assigning to it successively each value from its domain. This naive backtracking approach is recursive and explores the search tree of partial assignments in a depth first manner. Even though the backtracking algorithm can take exponential time it is often effective in practice thanks to intelligent pruning techniques.\nThere are many ways to improve naive backtracking by pruning the search space in ways that cannot remove solutions. This is done by avoiding searching exhaustively in all generated subproblems when certain kinds of discovered obstruction to solution exists. Such techniques include Back-marking, Back-jumping, Conflict-Directed Back-jumping [6,28]. As well as these lookback techniques it is also possible to look ahead by propagating the consequences of early decisions or of the discovered structure. Of these look-ahead techniques the most common is to maintain the local consistency property called generalised arc-consistency (GAC) [5]. This technique identifies certain values for variables that cannot possibly form part of a solution.\nOf course, savings can also be made if we are able to eliminate variables from a sub-problem. Since backtracking is of exponential time complexity, the elimination of variables and values (domain elements) to reduce instance size can in the best case reduce search time by an exponential factor. To maintain the soundness of search we require that such eliminations do not change the satisfiability of the instance. Invariance of satisfiability, which we study in the present paper, is a weaker property than the invariance of the set of solutions guaranteed by consistency techniques such as GAC. However, detection of non-satisfiability is the essential role of look-ahead techniques, since this allows pruning during search. Thus satisfiability-preserving reduction techniques (which do not necessarily preserve solutions) may prove useful even when the aim is to discover one or all solutions. In fact, we show that all the techniques presented in this paper, although they do not preserve solutions, allow a solution to the original instance to be reconstructed very efficiently."}, {"heading": "1.1 Simplification by variable and value elimination", "text": "We consider an instance I of the CSP viewed as a decision problem. Suppose that x is a variable of I and that, whenever there is some valid assignment to all variables except x, there is a solution to the whole instance; in this case, we can safely remove variable x from I. One of the questions we address in this paper is how to identify such variables?\nVariable elimination has been considered before in the literature. It is well known that in an arc-consistent binary CSP instance, a variable x which is constrained by only one other variable y can be eliminated; by the definition of arc consistency, each assignment to y is compatible with some assignment to x. It has been observed that a more general property, called the (local) Broken Triangle Property (lBTP) [13], if it holds at some variable, allows us to eliminate that variable. One way of stating the lBTP is that there is no pair of compatible assignments to two other variables y, z which have opposite compatibilities with two assignments to x. The closure of a binary CSP instance under the elimination of all variables that satisfy the lBTP is unique and can be found in O(ncd3) time, where n is the number of variables, c the number of constraints and d the maximum domain size, which may well prove effective when compared to the exponential cost of backtracking. The more general local min-of-max extendable property (lMME) allows us to eliminate more variables than the lBTP, but requires the identification of a particular domain order. Unfortunately, this domain order is NP-hard to discover [13] for unbounded domain size, and so the lMME is less likely to be effective in practice.\nAn alternative to simple variable elimination is used in Bucket Elimination [23]. In this algorithm a variable v is not simply eliminated. Instead it is replaced by a constraint on its neighbourhood (the set of variables constrained by v). This new constraint precisely captures those combinations of assignments to the neighbourhood of v which can be extended to a consistent assignment to v. Such an approach may generate high-order constraints, which are exponentially hard to process and to store. The arity can be bounded by the induced treewidth of the instance, but this still limits the applicability of Bucket Elimination. In the present paper we restrict our attention to the identification of variable elimination strategies which do not require the addition of compensatory constraints.\nThe elimination of domain elements is an essential component of constraint solvers via generalised arc consistency (GAC) operations. GAC eliminates domain elements that cannot be part of any solution, thus conserving all solutions. An alternative approach is the family of elimination rules based on substitution: if all solutions in which variable v is assigned value b remain solutions when the value of variable v is changed to another value a, then the value b can be eliminated from the domain of variable v while conserving at least one solution (if the instance is satisfiable). The most well-known polynomial-time detectable substitution operation is neighbourhood substitution [18]. The value elimination rules described in this paper go beyond the paradigms of consistency and substitution; we only require that the instance obtained after elimination of a value from a domain has the same satisfiability as the original instance.\nWe study rules for simplifying binary CSP instances based on properties of the instance at the microstructure level. The term microstructure was first given a formal definition by Je\u0301gou [22]: if I is a binary CSP instance, then its microstructure is a graph \u3008A,E\u3009 where A is the set of possible variable-value assignments and E is the set of pairs of compatible variable-value assignments. Solutions to I are in one-to-one correspondence with the n-cliques of the microstructure of I and with the size-n independent sets of the microstructure complement of I. The chromatic number of a graph is the smallest number of colours required to colour its vertices so that no two adjacent vertices have the same colour. A graph G is perfect if for every induced subgraph H of G, the chromatic number of H is equal to the size of the largest clique contained in H. Since a maximum clique in a perfect graph can be found in polynomial time [21], the class of binary CSP instances with a perfect microstructure is tractable [30]. Perfect graphs can also be recognized in polynomial time [16]. An instance of the minimum-cost homomorphism problem (MinHom) is a CSP instance in which weights are associated with each variable-value assignment and the aim is to find a solution which minimises the sum of the weights. Takhanov [31] gave a dichotomy for tractable conservative constraint languages for MinHom which uses the fact that an instance of binary MinHom can be solved in polynomial time if its microstructure is perfect. El Mouelhi et al. [26] make the observation that if the microstructure has a bounded number of maximal cliques then the instance will be solved in polynomial time by classical algorithms such as Forward Checking or Really Full Lookahead and hence by CSP solvers.\nSimple rules for variable or value elimination based on properties of the microstructure are used by Beigel and Eppstein [4] in their algorithms with low worst-case time bounds for such NP-complete problems as 3-COLOURING and 3SAT. Such simplification operations are an essential first step before the use of decompositions into subproblems with smaller domains. A similar approach allows Angelsmark and Thapper [3] to reduce the problem of finding a minimum weighted independent set in the microstructure complement to the problem of counting the number of solutions to a 2SAT instance. Thus, the variable and value elimination rules we present in this paper may find not only practical applications in solvers but also theoretical applications."}, {"heading": "1.2 Our contribution", "text": "In this paper we characterise those local conditions under which we can eliminate variables or values in binary CSPs while preserving satisfiability of the instance, without the need to add compensating constraints. By local conditions we mean configurations of variables, values and constraints which do not occur. That is, we will identify (local) obstructions to variable or value elimination. We will call such constructions variable elimination or value elimination patterns.\nSurprisingly we find that there are precisely four (three) essentially different local patterns whose absence permits variable (value) elimination. Searching for these local patterns takes polynomial time and need only be done during the pre-processing stage, before search. Any discovered obstructions to elimination can be effectively monitored during subsequent search using techniques analogous to watched literals [20]. Whenever a variable (value) no longer participates in any obstruction patterns it can safely be eliminated.\nWe show that after a sequence of variable and value eliminations it is always possible to reconstruct a solution to the original instance from a solution to the reduced instance in low-order polynomial time."}, {"heading": "2 Definitions", "text": "When certain kinds of local obstructions are not present in a binary CSP instance, variable or value elimination is possible. Such obstructions are called quantified patterns. A pattern can be seen as a generalisation of the concept of a constraint satisfaction instance that leaves the consistency of some assignments to pairs of variables undefined.\nDefinition 1. A pattern is a four-tuple \u3008X,D,A, cpt\u3009 where:\n\u2022 X is a finite set of variables;\n\u2022 D is a finite set of values;\n\u2022 A \u2286 X \u00d7 D is the set of possible assignments; The domain of v \u2208 X is its non-empty set D(v) of possible values: D(v) = {a \u2208 D | \u3008v, a\u3009 \u2208 A}; and\n\u2022 cpt is a partial compatibility function from the set of unordered pairs of assignments {{\u3008v, a\u3009, \u3008w, b\u3009} | v 6= w} to {TRUE, FALSE}; if cpt(\u3008v, a\u3009, \u3008w, b\u3009) = TRUE (resp., FALSE) we say that \u3008v, a\u3009 and \u3008w, b\u3009 are compatible (resp., incompatible).\nA quantified pattern is a pattern P with a distinguished variable, v(P ) and a subset of existential values e(P ) \u2286 D(v(P )).\nA flat quantified pattern is a quantified pattern for which e(P ) is empty. An existential pattern is a quantified pattern P for which e(P ) is non-empty. An existential pattern P may also have a distinguished value val(P ) \u2208 e(P ).\nWhen the context variable v is clear we use the value a to denote the assignment \u3008v, a\u3009 to v. We will often simplify notation by writing cpt(p, q) for cpt({p, q}). We will also use the terminology of graph theory, since a pattern can be viewed as a labelled graph: if cpt(p, q) = TRUE (resp., FALSE), then we say that there is a compatibility (resp., incompatibility) edge between p and q.\nWe will use a simple figurative drawing for patterns. Each variable will be drawn as an oval containing dots for each of its possible assignments. Pairs in the domain of the function cpt will be represented by lines between values: solid lines for compatibility and dashed lines for incompatibility.\nThe distinguished variable (v(P )) and any existential values in e(P ) will be indicated by an \u2203 symbol. Examples of patterns are shown in Figure 1 and Figure 2.\nWe are never interested in the names of variables nor the names of the domain values in patterns. So we define the following equivalence.\nDefinition 2. Two patterns P and Q are equivalent if they are isomorphic, i.e. if they are identical except for possible injective renamings of variables and assignments which preserve D, cpt, v, e and val.\nA pattern can be viewed as a CSP instance in which not all compatibilities are defined. We can thus refine patterns to give a definition of a (binary) CSP instance.\nDefinition 3. A binary CSP instance P is a pattern \u3008X,D,A, cpt\u3009 where cpt is a total function, i.e. the domain of cpt is precisely {{\u3008v, a\u3009, \u3008w, b\u3009} | v 6= w, a \u2208 D(v), b \u2208 D(w)}.\n\u2022 The relation Rv,w \u2286 D(v)\u00d7D(w) on \u3008v,w\u3009 is {\u3008a, b\u3009 | cpt(\u3008v, a\u3009, \u3008w, b\u3009) = TRUE}.\n\u2022 A partial solution to P on Y \u2286 X is a mapping s : Y \u2192 D where, for all v 6= w \u2208 Y we have \u3008s(v), s(w)\u3009 \u2208 Rv,w.\n\u2022 A solution to P is a partial solution on X.\nFor notational simplicity we have assumed that there is exactly one binary constraint between each pair of variables. In particular, this means that the absence of a constraint between variables v,w is modelled by a complete relation Rv,w = D(v) \u00d7 D(w) allowing every possible pair of assignments to v and w. We say that there is a non-trivial constraint on variables v,w if Rv,w 6= D(v)\u00d7D(w).\nIn practice, when solving CSP instances we prune the domains of variables in such a way as to maintain all solutions.\nDefinition 4. Let P = \u3008X,D,A, cpt\u3009 be a CSP instance. An assignment \u3008v, a\u3009 \u2208 A to variable v is called arc consistent if, for all variables w 6= v in X there is some assignment \u3008w, b\u3009 \u2208 A compatible with \u3008v, a\u3009.\nThe CSP instance \u3008X,D,A, cpt\u3009 is called arc consistent if every assignment in A is arc consistent.\nAssignments that are not arc-consistent cannot be part of a solution so can safely be removed. There are optimal O(cd2) algorithms for establishing arc consistency which repeatedly remove such values [5], where c is the number of non-trivial constraints and d the maximum domain size. Hence, for the remainder of this paper we will assume that all CSP instances are arc-consistent.\nIn this paper we are concerned with variable elimination characterised by forbidden patterns. We now define what this means.\nDefinition 5. We say that a variable x can be eliminated in the CSP instance \u3008X,D,A, cpt\u3009 if, whenever there is a partial solution on X \\ {x} there is a solution.\nIn order to use (the absence of) patterns for variable elimination we need to define what we mean when we say that a quantified pattern occurs at variable x of a CSP instance. We define occurrence in terms of reductions on patterns. The definitions of occurrence and reduction between quantified patterns extend definitions previously given for non-quantified patterns [12].\nDefinition 6. Let P = \u3008X,D,A, cpt\u3009 be any pattern.\n\u2022 We say that a pattern P \u2032 = \u3008X \u2032,D\u2032, A\u2032, cpt\u2032\u3009 is a sub-pattern of P if X \u2032 \u2286 X,A\u2032 \u2286 A and \u2200p, q \u2208 A\u2032, either cpt\u2032(p, q) = cpt(p, q) or cpt\u2032(p, q) is undefined.\nIf, furthermore, P \u2032 is quantified then we require that P is quantified and that v(P \u2032) = v(P ) and e(P \u2032) \u2286 e(P ). If P \u2032 has a distinguished value then we require that P also has a distinguished value and that val(P \u2032) = val(P ).\n\u2022 Values a, b \u2208 D(v) are mergeable in a pattern if there is no assignment p \u2208 A for which cpt(\u3008v, a\u3009, p), cpt(\u3008v, b\u3009, p) are both defined and cpt(\u3008v, a\u3009, p) 6= cpt(\u3008v, b\u3009, p). In a quantified pattern, for a to be merged into b, we also require that a \u2208 e(P ) only if b \u2208 e(P ).\nWhen a, b \u2208 D(v) are mergeable we define the merge reduction \u3008X,D,A \\ {\u3008v, a\u3009}, cpt\u2032\u3009, in which a is merged into b, by the following compatibility function:\ncpt\u2032(p, q) =\n{\ncpt(\u3008v, a\u3009, q) if p = \u3008v, b\u3009 and cpt(p, q) undefined,\ncpt(p, q) otherwise.\n\u2022 A dangling assignment p of P is any assignment for which there is at most one assignment q for which cpt(p, q) is defined, and furthermore (if defined) cpt(p, q) = TRUE. If P is quantified, then we also require that p /\u2208 v(P ) \u00d7 e(P ). For any dangling assignment p, we define the dangling reduction \u3008X,D,A\u2032, cpt \u21beA\u2032\u00d7A\u2032\u3009 where A \u2032 = A \\ {p}.\n\u2022 A reduction of a pattern P is a pattern obtained from P by a sequence of merge and dangling reductions. An irreducible pattern is one on which no merge or dangling reductions can be performed.\nTo illustrate the notions introduced in Definition 6, consider the patterns in Figure 1. Pattern P1 is a sub-pattern of P2 which is itself a sub-pattern of P3. In pattern P2, the values a, b \u2208 D(x) are mergeable: merging a into b produces the pattern P4. In the pattern P3, the values a, b \u2208 D(x) are not mergeable since cpt(\u3008x, a\u3009, \u3008z, d\u3009) and cpt(\u3008x, b\u3009, \u3008z, d\u3009) are both defined but are not equal. In pattern P2, \u3008x, a\u3009 is a dangling assignment: applying the dangling reduction to this assignment in P2 produces P1. Let P \u2032 2 be identical to P2 except that P \u2032 2 is a quantified pattern with v(P \u2032 2) = {x} and e(P \u20322) = {a}. Then P2 is a sub-pattern of P \u2032 2, but P \u2032 2 is not a sub-pattern of P2. In the domain of x in P \u20322, b can be merged into a but a cannot be merged into b since a \u2208 e(P \u2032 2) but b /\u2208 e(P \u2032 2). Furthermore, the assignment \u3008x, a\u3009 is not a dangling assignment in P \u20322 since a is an existential value for v(P \u20322) = x.\nNow we want to define when a quantified pattern occurs at a variable in a CSP instance, in order to characterise those patterns whose non-occurrence allows this particular variable to be eliminated. We define the slightly more general notion of occurrence of a pattern in another pattern. Recall that a CSP instance corresponds to the special case of a pattern whose compatibility function is total. Essentially we want to say that pattern P occurs in pattern Q if P is homomorphic to a sub-pattern of Q via an injective renaming of variables and a (possibly non-injective) renaming of assignments [7]. However, we find it simpler to define occurrence using the notions of sub-pattern, reduction and equivalence. We first make the observation that dangling assignments in a pattern provide no useful information since we assume that all CSP instances are arc consistent, which explains why dangling assignments can be eliminated from patterns.\nWe can then define occurrence in terms of reduced patterns.\nDefinition 7. We say that a pattern P occurs in a pattern Q (and that Q contains P ) if some reduction of P is equivalent to a sub-pattern of Q.\n\u270e \u270d \u261e \u270c \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\nxy\nz\nP1\nbc\nd\n\u270e\n\u270d\n\u261e\n\u270c \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\n\u270e\n\u270d\n\u261e \u270c\u2022 \u2022\n\u271a \u271a \u271a\n\u271a x y\nz\nP2\na\nb c\nd\nIf Q is a CSP instance, then the quantified pattern P occurs at variable x of Q if some reduction of P is equivalent to a sub-pattern of Q and x is the variable of the sub-pattern of Q corresponding to v(P ).\nWe say that the quantified pattern P occurs at variable x of Q with value mapping m : e(P ) \u2192 D(x) if the values of variable x corresponding to each a \u2208 e(P ) are given by the mapping m.\nA variable elimination pattern is defined in terms of occurrence of a pattern in a CSP instance.\nDefinition 8. A quantified pattern is a variable elimination pattern (var-elim pattern) if, whenever the pattern does not occur at a variable x in an arc-consistent CSP instance I for at least one injective value mapping, x can be eliminated in I (in the sense of Definition 5).\nA non-quantified pattern (i.e. a pattern without a distinguished variable) is a var-elim pattern if, whenever the pattern does not occur in an arc-consistent CSP instance, any variable can be eliminated in I.\nThe notion of non-quantified var-elim patterns is necessary for some of our proofs, but for practical applications we are interested in finding quantified (and, in particular, existential) varelim patterns. Existential patterns may allow more variables to be eliminated than flat quantified patterns. For example, as we will show later, the patterns snake and \u2203snake shown in Figure 2 are both var-elim patterns, but the latter allows more variables to be eliminated since we only require that it does not occur on a single value in the domain of the variable to be eliminated.\nExample 1. Suppose that we can assign value 0 to a subset S of the variables of an instance, without restricting the assignments to any other variables. Furthermore suppose that, within S, 0 is only compatible with 0. The var-elim pattern \u2203invsubBTP, shown in Figure 2, allows us to eliminate all variables in S, without having to explicitly search for S. This is because the pattern does not occur for the mapping a 7\u2192 0. The flat variant (invsubBTP) would not allow these eliminations.\nWe conclude this section with the simple observation that var-elim patterns define tractable classes. It takes polynomial time to establish arc consistency and to detect (by exhaustive search)\nthe non-occurrence of a var-elim pattern. Hence it takes polynomial time to identify arc-consistent CSP instances for which all variables can be eliminated one by one by a var-elim pattern P . Such instances are solvable in a greedy fashion.\nHence we are able to significantly extend the list of known tractable classes defined by forbidden patterns since among known tractable patterns, namely BTP [13], 2-constraint patterns [12], pivots [7] and JWP [15], only BTP (and its sub-patterns) allow variable elimination.\nIndeed, a general hybrid tractable class can be defined: the set of binary CSP instances which fall in some known tractable class after we have performed all variable (and value) eliminations defined by the rules given in this paper."}, {"heading": "3 Variable elimination by forbidden patterns", "text": "In this paper we characterise irreducible var-elim patterns. There are essentially just four (together with their irreducible sub-patterns): the patterns BTP, \u2203subBTP, \u2203invsubBTP and \u2203snake, shown in Figure 2. We begin by showing that each of these four patterns allows variable elimination. Forbidding BTP is equivalent to the already-known local Broken Triangle Property (lBTP) [13] mentioned in Section 1.1.\nTheorem 1. The patterns BTP, \u2203subBTP, \u2203invsubBTP and \u2203snake are var-elim patterns.\nProof. Since it is known that BTP is a var-elim pattern [13], we only need to prove the result for the three existential patterns: \u2203subBTP, \u2203invsubBTP and \u2203snake.\nEvery two-variable arc-consistent CSP instance allows either variable to be eliminated. So we only have to prove that these patterns allow variable elimination in CSP instances with at least three variables.\nWe first set up some general machinery which will be used in each of the three cases. Consider an arc-consistent CSP instance I = \u3008X,D,A, cpt\u3009 and let s be a partial solution on X \\ {x}.\nFix some assignment \u3008x, d\u3009, and let:\nY = {y \u2208 X \\ {x} | cpt(\u3008y, s(y)\u3009, \u3008x, d\u3009) = TRUE} ,\nY = {z \u2208 X \\ {x} | cpt(\u3008z, s(z)\u3009, \u3008x, d\u3009) = FALSE} .\nFor all y, z \u2208 X \\ {x}, since s is a partial solution, cpt(\u3008y, s(y)\u3009, \u3008z, s(z)\u3009) = TRUE. Thus, if X = Y \u222a{x} then we can extend s to a solution to I by choosing value d for variable x. So, in this case x could be eliminated. So we assume from now on that Y 6= \u2205.\nBy arc consistency, for all z \u2208 Y , there is some \u3008z, t(z)\u3009 \u2208 A such that cpt(\u3008z, t(z)\u3009, \u3008x, d\u3009) = TRUE.\nWe now prove the result for each pattern in turn. Suppose that \u2203subBTP does not occur at x in I for the mapping a 7\u2192 d. Consider any y \u2208 Y . By arc consistency, \u2203b \u2208 D(x) such that cpt(\u3008y, s(y)\u3009, \u3008x, b\u3009) = TRUE. Since the pattern \u2203subBTP does not occur, and in particular on the set of assignments {\u3008y, s(y)\u3009, \u3008z, s(z)\u3009, \u3008x, d\u3009, \u3008x, b\u3009}, we can deduce that, for every variable z \u2208 X different from both x and y, cpt(\u3008z, s(z)\u3009, \u3008x, b\u3009) = TRUE. Hence, we can extend s to a solution to I by choosing s(x) = b. So, in any case x can be eliminated and \u2203subBTP is indeed a var-elim pattern.\nNow instead, suppose \u2203invsubBTP does not occur at x in I for the mapping a 7\u2192 d. Since the pattern \u2203invsubBTP does not occur, if both y and z belong to Y then cpt(\u3008y, t(y)\u3009, \u3008z, t(z)\u3009) = TRUE, otherwise the pattern would occur on the assignments {\u3008y, s(y)\u3009, \u3008y, t(y)\u3009, \u3008z, t(z)\u3009, \u3008x, d\u3009}. Also, if y \u2208 Y , z \u2208 Y , then cpt(\u3008y, s(y)\u3009, \u3008z, t(z)\u3009) = TRUE, otherwise the pattern would occur on {\u3008z, s(z)\u3009, \u3008z, t(z)\u3009, \u3008y, s(y)\u3009, \u3008x, d\u3009}.\nSo, in this case we have a solution s\u2032 to I, where\ns\u2032(v) =\n\n \n \nd if v = x,\ns(v) if v \u2208 Y ,\nt(v) otherwise.\nSo \u2203invsubBTP is indeed a var-elim pattern. For the final pattern, suppose that \u2203snake does not occur at x in I for the mapping a 7\u2192 d. If y \u2208 Y , z \u2208 Y , since the pattern \u2203snake does not occur, we can deduce that cpt(\u3008y, s(y)\u3009, \u3008z, t(z)\u3009) = TRUE, otherwise the pattern would occur on the assignments {\u3008z, s(z)\u3009, \u3008z, t(z)\u3009, \u3008y, s(y)\u3009, \u3008x, d\u3009}. If both y and z both belong to Y , then we can deduce first that cpt(\u3008y, s(y)\u3009, \u3008z, t(z)\u3009) = TRUE (as in the previous case) and then, as a consequence, that cpt(\u3008y, t(y)\u3009, \u3008z, t(z)\u3009) = TRUE (otherwise the pattern would occur on {\u3008y, s(y)\u3009, \u3008y, t(y)\u3009, \u3008z, t(z)\u3009, \u3008x, d\u3009}).\nSo, again in this case we have a solution s\u2032 to I, where s\u2032 is defined as above. So \u2203snake is also a var-elim pattern."}, {"heading": "4 Characterisation of quantified var-elim patterns", "text": "Our aim is to precisely characterise all irreducible patterns which allow variable elimination in an arc-consistent binary CSP instance. We begin by identifying many patterns, including all those shown in Figure 3, which are not variable elimination patterns.\nLemma 1. None of the following patterns allow variable elimination in arc-consistent binary CSP instances: any pattern on strictly more than three variables, any pattern with three nonmergeable values for the same variable, any pattern with two non-mergeable incompatibility edges in the same constraint, Diamond, Z, XL, V(+\u2212), Triangle(asym), Triangle, Kite(sym), Kite(asym), rotsubBTP, Pivot(asym), Pivot(sym), Cycle(3).\nProof. For each pattern we exhibit a binary arc-consistent CSP instance that:\n\u2022 has a partial solution on the set of all the variables except a specified variable x;\n\u2022 has no solution;\n\u2022 does not contain the given pattern P at variable x (if P is a quantified pattern) or does not contain P at any variable (if P is a non-quantified pattern).\nBy definition, any such instance is enough to prove that a pattern is not a var-elim pattern.\n\u2022 For any pattern P which is either Diamond, Z, XL, or Triangle, or has at least four variables, or has three non-mergeable values for the same variable.\nLet I2COL3 be the CSP instance (corresponding to 2-colouring on 3 variables) with three Boolean variables, where the constraint between any two variables forces them to take different values.\nThis instance has partial solutions on any two variables, but has no solution, and does not contain P .\n\u2022 For V(+\u2212) and Triangle(asym).\nLet I\u22034 be the instance on four variables x1, x2, x3 and x, where the domains of x1, x2 and x3 are all {0, 1, 2} and the domain of x is {0, 1, 2, 3}. Each pair of variables in {x1, x2, x3} must take values in {\u30080, 0\u3009, \u30081, 2\u3009, \u30082, 1\u3009}. There are three further constraints: for i = 1, 2, 3, we have that (xi > 0) \u2228 (x = i).\nI\u22034 has a partial solution on {x1, x2, x3} but has no solution. I \u2203 4 contains neither V(+\u2212) nor Triangle(asym) at variable x for the value mapping m(a) = 0.\n\u2022 For Kite(sym).\nLet I4 be the CSP instance on four variables x1, x2, x3, x where x1, x2 and x3 are Boolean and D(x) = {1, 2, 3}, with the following constraints: x1 \u2228 x2, x1 \u2228 x3, x2 \u2228 x3, xi \u21d4 (x = i) (i = 1, 2, 3).\nI4 has a partial solution on {x1, x2, x3}, has no solution, and does not contain Kite(sym) at variable x.\n\u2022 For Kite(asym).\nLet IZOA4 be the CSP instance on the four variables x1, x2, x3, x each with domain {1, 2, 3}, with the following constraints: x1 = x2, x1 = x3, x2 = x3, (x1 = 1)\u2228 (x = 1), (x2 = 2)\u2228 (x = 2), (x3 = 3) \u2228 (x = 3).\n\u2022 For rotsubBTP.\nDefine the three binary relations:\nR = {\u30080, 0\u3009, \u30081, 2\u3009, \u30082, 1\u3009},\nR0 = {\u30080, 0\u3009, \u30081, 1\u3009, \u30082, 1\u3009},\nR1 = {\u30080, 1\u3009, \u30081, 0\u3009, \u30082, 0\u3009}.\nLet I7 be the CSP instance on the seven variables x1, . . . , x6, x where D(xi) = {0, 1, 2}, for i = 1, . . . , 6, and D(x) = {0, 1}, with the following constraints:\n\u270e \u270d \u261e \u270c \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\nI1\na a\u2032\nv0 v1\n\u270e\n\u270d\n\u261e \u270c\u2022 \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\n\u270e\n\u270d\n\u261e\n\u270c \u2022\nI2\na b c\ne\nv0 v1\nv2\nThe following lemma is then key to proving that we have identified all possible irreducible quantified var-elim patterns.\nLemma 2. The only flat quantified irreducible patterns that do not contain any of the patterns listed in Lemma 1 are contained in BTP, invsubBTP or snake (shown in Figure 2).\nProof. Consider a flat quantified irreducible pattern P = \u3008X,D,A, cpt\u3009 that does not contain any of the patterns listed in Lemma 1. Thus P has at most three variables, each with domain size at most two.\nWe consider first the case of a 2-variable pattern P . By Lemma 1, P does not have two nonmergeable incompatibility edges and does not contain Z. Since P is irreducible and hence does not have any dangling assignment, we can deduce by exhausting over all possibilities that P does not have any compatibility edge and a single incompatibility edge. Hence P is contained in BTP. We can therefore assume that P has exactly three variables.\nNow consider the negative sub-pattern P\u2212 = \u3008X,D,A,neg\u3009 where the compatibility function neg is cpt with its domain reduced to the incompatible pairs of assignments of P .\nAny irreducible pattern on three variables that does not contain an incompatible pair of assignments must contain Triangle. Moreover, if any assignment is incompatible with two other assignments then P must contain either Pivot(sym) or Pivot(asym), or have two non-mergeable incompatible edges in the same constraint. Now, since P does not contain Cycle(3), it follows that P\u2212 is I1 or I2, as shown in Figure 4.\nWe first consider the latter case. Without loss of generality, we assume that b is compatible with c, to avoid a and b being mergeable.\nSince the domains have at most two elements, we begin by assuming that D(v1) = {c, d} and D(v2) = {e, f}. In this case a and d must be compatible to avoid d and c being mergeable. Also b and f must be compatible to stop e and f being mergeable. Now d and b cannot be compatible since otherwise Z occurs in P . Moreover, d and e cannot be compatible since otherwise XL occurs in P . Furthermore, d and f cannot be compatible since, whichever variable is chosen for v(P ), either Kite(sym) or Kyte(asym) occurs in P . It follows that d can be removed as it is a dangling assignment.\nNow we begin again. As before, to avoid e and f being mergeable or Diamond occurring in P , we have that f is compatible with b and not compatible with a. To avoid Triangle occurring in P , f cannot be compatible with c, which means that f can be removed since it is a dangling assignment.\nSo, we have D(v1) = {c} and D(v2) = {e}. Suppose that there is a compatibility edge between c and e. If the distinguished variable v(P ) is v0 then, whether or not there is a compatibility edge between a and e, the pattern is contained in BTP. If v(P ) = v1 and there is no compatibility edge between a and e, then the pattern is contained in invsubBTP. If v(P ) = v1 and there is a compatibility edge between a and e, then the pattern contains rotsubBTP. If v(P ) = v2, then the pattern contains rotsubBTP. Since we have covered all cases in which there is a compatibility edge between c and e, we assume that there is no edge between c and e.\nWhether or not there is an incompatibility edge between a and e, the pattern is contained in BTP if v(P ) = v0, and the pattern is contained in snake if v(P ) is either v1 or v2.\nThe final case to consider is when P is a 3-variable pattern with P\u2212 = I1. Any two assignments for the third variable v2 could be merged, so we can assume its domain is a singleton which we denote by {a\u2032\u2032}. Since P is irreducible, does not contain Diamond, Z, Triangle, Kite(sym) or Kite(asym), we can deduce that the only compatible pairs of assignments include a\u2032\u2032. In fact, both {a, a\u2032\u2032} and {a\u2032, a\u2032\u2032} must be compatible since P is irreducible. But then P is contained in BTP if v(P ) is either v0 or v1, and is contained in invsubBTP if v(P ) = v2.\nWe need the following technical lemma which shortens several proofs.\nLemma 3. If a pattern P occurs in a var-elim pattern Q with |e(Q)| \u2264 1, then P is also a var-elim pattern.\nProof. Suppose that P occurs in the var-elim pattern Q and that |e(Q)| \u2264 1. By transitivity of the occurrence relation, if Q occurs in a binary CSP instance I (at variable x), then so does P . It follows that if (there is an injective mapping m : e(P ) \u2192 D(x) for which) P does not occur (at variable x) in an arc consistent binary CSP instance I, then (there is an injective mapping m\u2032 : e(Q) \u2192 D(x) for which) Q does not occur (at variable x) and hence variable elimination is possible.\nThe condition |e(Q)| \u2264 1 is required in the statement of Lemma 3, since for an instance in which D(x) is a singleton, if |e(P )| \u2264 1 and |e(Q)| > 1 there may be an injective mappingm : e(P ) \u2192 D(x) for which P does not occur at x but there can clearly be no injective mapping m\u2032 : e(Q) \u2192 D(x).\nAccording to Definition 7, a flat quantified pattern P is a sub-pattern of any existential version Q of P (and hence P occurs in Q). We state this special case of Lemma 3 as a corollary.\nCorollary 1. Let Q be an existential var-elim pattern with |e(Q)| = 1. If P is the flattened version of pattern Q, corresponding to e(P ) = \u2205, then P is also a var-elim pattern.\nThe following lemma deals with the case of existential patterns P with |e(P )| > 1.\nLemma 4. No irreducible existential pattern P with |e(P )| > 1 is a var-elim pattern.\nProof. Let a1, a2 be two distinct assignments in e(P ). Since P is irreducible, a1 and a2 are not mergeable; so there is an assignment b such that \u3008b, a1\u3009 is a compatibility edge and \u3008b, a2\u3009 is an incompatibility edge (or vice versa) in P .\nConsider the instance Ik4 (where k = |e(P )| + 3) on four variables x1, x2, x3, x with domains D(x1) = D(x2) = D(x3) = {0, 1, 2}, D(x) = {1, . . . , k} and the following constraints: x1 = 2 \u2212 x2, x1 = 2 \u2212 x3, x2 = 2 \u2212 x3, (xi 6= 1) \u2228 (x = i) (i = 1, 2, 3). I k 4 has a partial solution (1,1,1) on variables x1, x2, x3 but has no solution. Furthermore, for any (arbitrary choice of) injective mapping m : e(P ) \u2192 D(x) which maps e(P ) to a subset of {4, . . . , k}, P does not occur on x since the values m(a1),m(a2) \u2208 {4, . . . , k} have the same compatibilities with all assignments to other variables in Ik4 .\nTherefore there are no irreducible var-elim patterns P with |e(P )| > 1.\nThe following theorem is a direct consequence of Theorem 1 and Corollary 1 together with Lemma 1, Lemma 2 and Lemma 3.\nTheorem 2. The irreducible flat quantified patterns allowing variable elimination in arc-consistent binary CSP instances are BTP, invsubBTP or snake (and their irreducible sub-patterns).\nWe are now able to provide the characterisation for existential patterns after a little extra work.\nTheorem 3. The only irreducible existential patterns which allow variable elimination in arcconsistent binary CSP instances are \u2203subBTP, \u2203invsubBTP, \u2203snake (and their irreducible subpatterns).\nProof. By Lemma 4 we only need to consider patterns P with |e(P )| = 1. We know from Theorem 1 that \u2203subBTP, \u2203invsubBTP, \u2203snake are var-elim patterns. Theorem 2 and Corollary 1 show that when we flatten an existential var-elim pattern then the resulting flat quantified pattern is contained in BTP, invsubBTP or snake. In the case of invsubBTP and snake, the existential versions of these patterns are var-elim patterns and so there is nothing left to prove. So we only need to consider quantified patterns which flatten into sub-patterns of BTP.\nLet \u2203BTP denote the existential version Q of BTP such that |e(Q)| = 1. By symmetry, \u2203BTP is unique. The only remaining case is when P is an irreducible sub-pattern of \u2203BTP with |e(P )| = 1. By a straightforward exhaustive case analysis, we find that, in this case, either P contains V(+\u2212) or Triangle(asym) or P is a sub-pattern of \u2203subBTP. The result then follows by Lemma 1 and Lemma 3.\nCombining Theorem 2 and Theorem 3, we obtain the characterisation of irreducible quantified var-elim patterns.\nTheorem 4. The only irreducible quantified patterns which allow variable elimination in arcconsistent binary CSP instances are BTP , \u2203subBTP, \u2203invsubBTP, \u2203snake (and their irreducible sub-patterns).\nIt is easy to see that variable elimination cannot destroy arc consistency. Hence there is no need to re-establish arc consistency after variable eliminations. Furthermore, the result of applying our var-elim rules until convergence is unique; variable eliminations may lead to new variable eliminations but cannot introduce patterns and hence cannot invalidate applications of our varelim rules."}, {"heading": "5 Value elimination patterns", "text": "We now consider when forbidding a pattern can allow the elimination of values from domains rather than the elimination of variables. Value-elimination is at the heart of the simplification operations employed by constraint solvers during preprocessing or during search. In current solvers such eliminations are based almost exclusively on consistency operations: a value is eliminated from the domain of a variable if this assignment can be shown to be inconsistent (in the sense that it cannot be part of any solution). Another value-elimination operation which can be applied is neighbourhood substitutability which allows the elimination of certain assignments which are unnecessary for determining the satisfiability of the instance. Neighbourhood substitutability can be described by means of the pattern shown in Figure 5. If in a binary CSP instance I, there are two assignments a, b for the same variable x such that this pattern does not occur (meaning that a is consistent with all assignments with which b is consistent), then the assignment b can be eliminated. This is because in any solution containing b, simply replacing b by a produces another solution.\nIt is worth noting that even when all solutions are required, neighbourhood substitutability can still be applied since all solutions to the original instance can be recovered from the set of solutions to the reduced instance in time which is linear in the total number of solutions and polynomial in the size of the instance [9].\nDefinition 9. We say that a value b \u2208 D(x) can be eliminated from an instance I if the instance I \u2032 in which the assignment b has been deleted from D(x) is satisfiable if and only if I is satisfiable.\nDefinition 10. An existential pattern P with a distinguished value val(P ) is a value elimination pattern (val-elim pattern) if in all arc-consistent instances I, whenever the pattern does not occur at a variable x in I for at least one injective value mapping m, the value m(val(P )) can be eliminated from D(x) in I.\nAn obvious question is which patterns allow value elimination while preserving satisfiability? The following theorem gives three existential patterns which provide strict generalisations of neighbourhood substitutability since in each case the pattern of Figure 5 is a sub-pattern. In each of the patterns P in Figure 5 and Figure 6, the value that can be eliminated val(P ) is the value b surrounded by a small box.\nTheorem 5. The existential patterns shown in Figure 6, namely \u22032snake, \u22032invsubBTP and \u22032triangle, are each val-elim patterns.\nProof. We first show that the result holds for instances I with at most two variables. Let x be a variable of I. For |D(x)| > 1, there is clearly an injective mapping m : e(P ) \u2192 D(x) for which none of the patterns P shown in Figure 6 occur since they all have three variables. But, we can always eliminate all but one value in D(x) without destroying satisfiability, since by arc consistency the\nremaining value is necessarily part of a solution. For |D(x)| \u2264 1, there can be no injective mapping m : e(P ) \u2192 D(x) since |e(P ) = 2| and hence there is nothing to prove. In the rest of the proof we therefore only need to consider instances I = \u3008X,D,A, cpt\u3009 with at least three variables. We will prove the result for each of the three patterns one by one.\nWe consider first \u22032snake. Suppose that for a variable x and values a, b \u2208 D(x), the pattern \u22032snake does not occur. Let I \u2032 be identical to I except that value b has been eliminated from D(x). Suppose that s is a solution to I with s(x) = b. It suffices to show that I \u2032 has a solution. Let Y (Y ) be the set of variables z \u2208 X \\ {x} such that cpt(\u3008z, s(z)\u3009, \u3008x, a\u3009) = TRUE (FALSE). By arc consistency, there are assignments \u3008z, t(z)\u3009 for all z \u2208 Y which are compatible with \u3008x, a\u3009. Let z \u2208 Y and y \u2208 X \\ {x, z}. Since s is a solution with s(x) = b, cpt(\u3008y, s(y)\u3009, \u3008z, s(z)\u3009) = cpt(\u3008x, b\u3009, \u3008z, s(z)\u3009) = TRUE. Since \u22032snake does not occur on {\u3008x, a\u3009, \u3008x, b\u3009, \u3008z, s(z)\u3009, \u3008z, t(z)\u3009, \u3008y, s(y)\u3009}, we can deduce that cpt(\u3008z, t(z)\u3009, \u3008y, s(y)\u3009) = TRUE. In particular, we have cpt(\u3008y, s(y)\u3009, \u3008z, t(z)\u3009) = TRUE for all y 6= z \u2208 Y . Then, since \u22032snake does not occur on the assignments {\u3008x, a\u3009, \u3008x, b\u3009, \u3008y, s(y)\u3009, \u3008y, t(y)\u3009, \u3008z, t(z)\u3009}, we can deduce cpt(\u3008z, t(z)\u3009, \u3008y, t(y)\u3009) = TRUE. Hence the assignments \u3008z, t(z)\u3009 (z \u2208 Y ) are compatible between themselves, are all compatible with all \u3008y, s(y)\u3009 (y \u2208 Y ) and with \u3008x, a\u3009. Thus, s\u2032 is a solution to I \u2032, where\ns\u2032(v) =\n\n \n \na if v = x,\ns(v) if v \u2208 Y ,\nt(v) otherwise.\nWe now consider \u22032invsubBTP. Suppose that for a variable x and values a, b \u2208 D(x) in an instance I, the pattern \u22032invsubBTP does not occur. Let I \u2032 be identical to I except that value b has been eliminated from D(x). Suppose that s is a solution to I with s(x) = b and again let Y (Y ) be the set of variables z \u2208 X \\ {x} such that cpt(\u3008z, s(z)\u3009, \u3008x, a\u3009) = TRUE (FALSE). By arc consistency, for each z \u2208 Y , there is an assignment \u3008z, t(z)\u3009 which is compatible with \u3008x, a\u3009. Let s\u2032 be defined as above. Consider v \u2208 X \\ {x}. We know that cpt(\u3008x, a\u3009, \u3008v, s\u2032(v)\u3009) = TRUE. Let z \u2208 Y . Since the pattern \u22032invsubBTP does not occur on {\u3008x, a\u3009, \u3008x, b\u3009, \u3008z, s(z)\u3009, \u3008z, t(z)\u3009, \u3008v, s\u2032(v)\u3009}, we can deduce that cpt(\u3008z, t(z)\u3009, \u3008v, s\u2032(v)\u3009) = TRUE. It follows that s\u2032 is a solution to I \u2032.\nFinally, we consider \u22032triangle. Suppose that in an instance I, for values a, b \u2208 D(x), the pattern \u22032triangle does not occur. Let I \u2032 be identical to I except that value b has been eliminated from D(x). Suppose that s is a solution to I with s(x) = b. Then \u3008x, a\u3009 must be compatible with all assignments \u3008y, s(y)\u3009 (y \u2208 X \\ {x}), otherwise the pattern \u22032triangle would occur on {\u3008x, a\u3009, \u3008x, b\u3009, \u3008y, s(y)\u3009, \u3008z, s(z)\u3009} for all z \u2208 X \\ {x, y}. It follows that s\u2032\u2032 is a solution to I \u2032, where\ns\u2032\u2032(v) =\n{\na if v = x,\ns(v) otherwise.\nExample 2. Consider a CSP instance corresponding to a problem of colouring a complete graph on four vertices. The colours assigned to the four vertices are represented by variables x1, x2, x3, x4 whose domains are, respectively, {0, 1, 2, 3}, {0, 1}, {0, 2}, {0, 3}. Notice that the instance is arc consistent and no eliminations are possible by neighbourhood substitution. However, the value 1 can be eliminated from the domain of x1 since for the mapping a 7\u2192 0, b 7\u2192 1, the pattern \u22032snake does not occur on x1. The values 2 and 3 can also be eliminated from the domain of x1 for the same reason. After applying arc consistency to the resulting instance, all domains are singletons.\nExample 3. Consider the arc-consistent instance on three Boolean variables x, y, z and with the constraints z \u2228 \u00acx, z \u2228 y, \u00acy \u2228 \u00acx. In this instance we can eliminate the assignment \u3008x, 0\u3009 since \u22032invsubBTP does not occur on variable x for the mapping a 7\u2192 1, b 7\u2192 0. The assignments \u3008y, 1\u3009 and \u3008z, 0\u3009 then have no support at x and hence can be eliminated by arc consistency, leaving an instance in which all domains are singletons.\nExample 4. Consider the arc-consistent CSP instance corresponding to a graph colouring problem on a complete graph on three vertices in which the domains of variables x1, x2, x3 are each {0, 1}. Again, no eliminations are possible by neighbourhood substitution. However, the value 1 can be eliminated from the domain of x1 since for the mapping a 7\u2192 0, b 7\u2192 1, the pattern \u22032triangle does not occur on x1. Applying arc consistency then leads to an empty domain from which we can deduce that the original instance was unsatisfiable.\nNeighbourhood substitution cannot destroy arc consistency [9], but eliminating a value by a val-elim pattern can provoke new eliminations by arc consistency, as we have seen in the above examples.\nThe result of applying a sequence of neighbourhood substitution eliminations until convergence is unique modulo isomorphism [9]. This is not true for the result of eliminating domain elements by val-elim patterns, as the following example demonstrates.\nExample 5. Consider the CSP instance on three variables x1, x2, x3, each with domain {0, 1, 2}, and with the following constraints: (x1 6= 2) \u2228 (x2 6= 2), (x1, x3) \u2208 R, (x2, x3) \u2208 R, where R is the relation {(0, 0), (0, 2), (1, 1), (2, 1), (2, 2)}. We can eliminate the assignment \u3008x3, 0\u3009 since \u22032snake does not occur on x3 with the value a mapping to 2 and b to 0. But then in the resulting arcconsistent instance, no more eliminations are possible by any of the val-elim patterns shown in Figure 6. However, in the original instance we could have eliminated the assignment \u3008x3, 1\u3009 since \u22032snake does not occur on x3 with the value a mapping to 0 and b to 1. Then we can successively eliminate \u3008x1, 1\u3009, \u3008x2, 1\u3009 by arc consistency and then \u3008x1, 2\u3009, \u3008x2, 2\u3009, \u3008x3, 0\u3009 by \u22032snake. In the resulting instance all domains are singletons. Thus, for this instance there are two convergent sequences of value eliminations which produce non-isomorphic instances.\nIt is clear that variable elimination by our var-elim rules can provoke new value eliminations by our val-elim rules. Value elimination may provoke new variable eliminations, but may also invalidate a variable elimination if the value eliminated (or one of the values eliminated by subsequent arc consistency operations) is the only value on which an existential var-elim pattern does not occur. Thus, to maximize reductions, variable eliminations should always be performed before value eliminations."}, {"heading": "6 Characterisation of value elimination patterns", "text": "As with existential variable-elimination patterns, we can give a dichotomy for irreducible existential val-elim patterns. We first require the following lemma which shows that many patterns, including\nthose illustrated in Figure 7 (along with the patterns Z and Diamond shown in Figure 3), cannot be contained in val-elim patterns. In Figure 7, each of the patterns I(\u2212), L(+\u2212), triangle1, triangle2, \u2203Kite, \u2203Kite(asym) and \u2203Kite1 has a distinguished value b = val(P ) which is highlighted in the figure by placing the value in a small box.\nLemma 5. None of the following existential patterns P (with a distinguished value val(P )) allow value elimination in arc-consistent binary CSP instances: any pattern on strictly more than three variables, any pattern with three non-mergeable values for the same variable v 6= v(P ), any pattern with two non-mergeable incompatibility edges in the same constraint, any pattern containing any of Z, Diamond, I(\u2212), L(\u2212), L(+\u2212), triangle1, triangle2, \u2203Kite, \u2203Kite(asym) or \u2203Kite1.\nProof. For each pattern we exhibit a binary arc-consistent CSP instance I and a value b for a variable x in I such that\n\u2022 I has a solution which includes the assignment \u3008x, b\u3009;\n\u2022 I has no solution if the value b is deleted from D(x);\n\u2022 I does not contain the given pattern P on x with val(P ) mapping to b.\nBy definition, any such instance is sufficient to prove that the pattern P is not a val-elim pattern. Since in existential patterns P , the set e(P ) may be of arbitrary size, we have to give generic instances in which the size of the domain of x is arbitrarily large.\n\u2022 For any pattern P which either contains I(\u2212) or has strictly more than three variables or with three non-mergeable values for the same variable v 6= v(P ).\nLet ISAT3 be the arc-consistent instance on three variables x1, x2, x with domains D(x1) = D(x2) = {0, 1}, D(x) = {0, . . . , k} and with the following constraints: x1 \u2228 x2, x1 \u2228 (x = 0), x2\u2228(x = 0). I SAT 3 has a solution \u30080, 0, 0\u3009 which includes the assignment \u3008x, 0\u3009, has no solution if this assignment is eliminated, and does not contain P on x with val(P ) mapping to 0.\n\u2022 For any pattern P which has two non-mergeable incompatibility edges in the same constraint.\nLet ISAT 2k+1 be the arc-consistent instance on 2k + 1 variables x1, . . . , x2k, x with domains D(x1) = . . . = D(x2k) = {0, 1}, D(x) = {0, . . . , k} and with the following constraints for each i = 1, . . . , k: x2i\u22121 \u2228 x2i, x2i\u22121 \u2228 (x 6= i), x2i \u2228 (x 6= i). I SAT 2k+1 has a solution \u30080, . . . , 0\u3009 which includes the assignment \u3008x, 0\u3009, has no solution if this assignment is eliminated, and does not contain P on x with val(P ) mapping to 0.\n\u2022 For any pattern P which contains L(+\u2212), triangle2 or \u2203Kite1.\nLet I3 be the arc-consistent instance on three variables x1, x2, x with domains D(x1) = D(x2) = D(x) = {0, . . . , k} and with the following constraints: (x1 = 0) \u2228 (x2 = 0), x1 = x, x2 = x. I3 has a solution \u30080, 0, 0\u3009 which includes the assignment \u3008x, 0\u3009, has no solution if this assignment is eliminated, and does not contain P on x with val(P ) mapping to 0.\n\u2022 For any pattern P which contains L(\u2212).\nLet I3+ be the arc-consistent instance on four variables x1, x2, x3, x with domains D(x1) = D(x2) = D(x3) = D(x) = {0, . . . , k} and with the following constraints: (x1 = 0) \u2228 (x2 = 0), x1 = x3, x2 = x3, x3 = x. I3+ has a solution \u30080, 0, 0, 0\u3009 which includes the assignment \u3008x, 0\u3009, has no solution if this assignment is eliminated, and does not contain P on x.\n\u2022 For any pattern P which contains triangle1, \u2203Kite, \u2203Kite(asym), Diamond or Z.\nLet I2k3 be the arc-consistent instance on three variables x1, x2, x each with domain {0, . . . , 2k} and with the following constraints: x1 = 2k \u2212 x2, x1 = x, x2 = x. I 2k 3 has a solution \u3008k, k, k\u3009 which includes the assignment \u3008x, k\u3009, has no solution if this assignment is eliminated, and does not contain P on x with val(P ) mapping to k.\nWe can now characterise those irreducible existential patterns which allow value elimination and hence generalise neighbourhood substitution.\nTheorem 6. The only irreducible existential patterns which allow value elimination in arc-consistent binary CSP instances are \u22032snake, \u22032invsubBTP and \u22032triangle (and their irreducible sub-patterns).\nProof. Let P be an irreducible existential pattern which allows value elimination in arc-consistent binary CSP instances. Since val(P ) is necessarily defined in a val-elim pattern and belongs to e(P ), we need to consider three different cases:\n1. |e(P )| = 1, and hence e(P ) = {val(P )},\n2. |e(P )| = 2,\n3. |e(P )| > 2.\nCase |e(P )| = 1: Consider the CSP instance I2 consisting of only two variables x1, x2, each with a singleton domain {0} together with the constraint x1 = x2. Trivially, the value 0 cannot be eliminated from the domain of x1 without changing the satisfiability of the instance. Any existential pattern P with |e(P )| = 1 containing more than two variables or at least one incompatibility edge does not occur in I2 on x1 with val(P ) mapping to 0, and hence cannot be a val-elim pattern. There is no 2-variable irreducible existential pattern which contains only compatibility edges. Therefore, the only irreducible val-elim pattern P with |e(P )| = 1 is the trivial pattern with no edges (which is a sub-pattern of \u22032snake, for example).\nCase |e(P )| = 2: Let e(P ) = {a, b} where b = val(P ). We know from Lemma 5 that I(\u2212) cannot be contained in a val-elim pattern. We can therefore deduce that the assignment \u3008v(P ), b\u3009 can only belong to compatibility edges in P . Since P is irreducible, we can deduce that P must contain the neighbourhood substitution pattern shown in Figure 5, otherwise a and b could be merged. By Lemma 5, P does not contain more than three variables, does not contain L(\u2212) or L(+\u2212) and does not contain more than one incompatibility edge per constraint. It follows that P contains at most two incompatibility edges. The only extension of the neighbourhood substitution pattern (shown in Figure 5) containing only one incompatibility edge and containing none of I(\u2212), Z, Diamond, triangle1, triangle2 or \u2203Kite(asym) is the val-elim pattern \u22032triangle. The only extensions of the neighbourhood substitution pattern containing exactly two incompatibility edges and containing none of I(\u2212), L(\u2212), L(+\u2212), Z, Diamond, triangle1, \u2203Kite or \u2203Kite1 are the val-elim patterns \u22032snake and \u22032invsubBTP. Hence, the only irreducible val-elim patterns P with |e(P )| = 2 are \u22032snake, \u22032invsubBTP and \u22032triangle (and their irreducible sub-patterns).\nCase |e(P )| > 2: Let a1, a2, a3 be three distinct values in e(P ) and, for i = 1, 2, 3, let qi denote the assignment \u3008v(P ), ai\u3009 . Since P is irreducible, for all i, j such that 1 \u2264 i < j \u2264 3, ai and aj are not mergeable; so there is an assignment pij such that \u3008pij , qi\u3009 is a compatibility edge and \u3008pij , qj\u3009 is an incompatibility edge (or vice versa) in P . By Lemma 5, P has at most three variables, including v(P ). So two of p12, p13, p23 are assignments to the same variable. Without loss of generality, suppose that p12, p13 are assignments to the same variable y 6= v(P ). By Lemma 5, P has at most one incompatibility edge in each constraint. It follows that p12 = p13, with \u3008p12, q1\u3009 an incompatibility edge and \u3008p12, q2\u3009, \u3008p12, q3\u3009 compatibility edges. It also follows that p23 must be an assignment to a distinct variable z /\u2208 {y, v(P )}. But then P contains Diamond on p12, q2, q3, p23 and so, by Lemma 5, cannot be a val-elim pattern. Therefore there are no irreducible val-elim patterns P with |e(P )| > 2."}, {"heading": "7 Recovering one or all solutions after eliminations", "text": "The binary CSP has diverse applications. In some applications it is only the satisfiability of the instance which is of interest. For example, in optimal planning, to determine whether an action a among a set of available actions A is indispensable (i.e. that it is present in all solution-plans) we need to determine the satisfiability of a binary CSP representing the same planning problem using the set of actions A \\ {a} [11]. The variable and value elimination rules presented in this paper are directly applicable to such problems.\nNonetheless, in most applications, the final aim is to find one or all solutions. In many planning, scheduling and configuration problems, the aim is often to find just one solution which satisfies all the constraints. In other application areas, such as fault-diagnosis [32] or the interpretation of ambiguous pictures [8], it is important to find all solutions or a representation of all solutions from\nwhich it is possible to extract in polynomial time a solution satisfying certain criteria. For example, the on-line configuration of a product (such as a car) by a user can be rendered tractable by the off-line compilation of all solutions into some appropriate compact form [1, 2]. We will therefore study in this section whether it is possible to efficiently recover one or all solutions to a binary CSP instance after elimination of variables and/or values by our rules. We will show that the efficient recovery of one solution is always possible, but that only some of our rules allow the efficient recovery of all solutions.\nThe elimination of a variable cannot destroy arc consistency, but the elimination of a value may do so. Throughout this section we assume that the elimination of an assignment by applying a value-elimination rule is necessarily immediately followed by the re-establishment of arc consistency.\nProposition 7. Let I be an arc-consistent binary CSP instance and let s be a solution to the instance obtained after applying a sequence \u03c3 of variable and value elimination operations (defined by irreducible quantified var-elim or val-elim patterns in the sense of Definition 8 and Definition 10). Then a solution to I can be found from (s, \u03c3) in O(cd) time, where c is the number of non-trivial constraints and d the maximum domain size in I.\nProof. Since value elimination does not modify constraints, any solution for an instance obtained from I by value eliminations is also a solution to I. We therefore only need to consider the case of var-elim rules. We identified the irreducible quantified var-elim patterns in Theorem 4 as (irreducible sub-patterns of) BTP , \u2203subBTP, \u2203invsubBTP or \u2203snake. We only need to prove the proposition for these four patterns since absence of any sub-pattern implies absence of the pattern itself.\nConsider a single variable elimination operation consisting in eliminating variable x. Let cx denote the number of constraints whose scope includes x. If x has been eliminated due to the absence of BTP, then it is known that any solution s of the reduced instance can be extended to a solution of I [13]. The proof of Theorem 1 showed that this is also true in the case that x has been eliminated due to the absence of \u2203subBTP. In order to extend s to a solution of I, it suffices to test each of the elements of D(x) in turn against each of the cx constraints. This can be achieved in O(cxd) time.\nFor the two other patterns (\u2203invsubBTP and \u2203snake), the proof of Theorem 1 actually provides an algorithm to recover a solution s\u2032 of I from the solution s of the reduced instance, via the calculation of the variable set Y and the assignments t(z) (z \u2208 Y ). Again this can be achieved in O(cxd) time.\nSumming the O(cxd) complexity of recovering a solution to the instance in which a variable x is reinstated, over all eliminated variables x, gives a total complexity of O(cd), as claimed.\nProposition 8. Let I be an arc-consistent binary CSP instance and let S be the set of all solutions to the instance obtained after applying a sequence \u03c3 of operations given by the var-elim patterns BTP, \u2203subBTP and the val-elim pattern \u22032triangle. Then the set of all solutions to I can be found from (S, \u03c3) in O(|SI |cd+ 1) time, where SI is the set of solutions to I.\nProof. In the trivial case in which |SI | = 0, we necessarily have as input S = \u2205 which can clearly be tested for in O(1) time. In another simple case, in which I has at most two variables, the result follows from arc consistency. We therefore only need to consider satisfiable instances with at least three variables.\nWe now consider the elimination of a single variable x from an instance I due to absence of one of the var-elim patterns BTP or \u2203subBTP. As observed in the proof of Proposition 7, each solution of the reduced instance can be extended to a solution of I. This implies that the number of solutions\ncannot decrease when we reinstate the variable x. Clearly each solution of I is an extension of a solution of the reduced instance. So the algorithm given in the proof of Proposition 7, applied in turn to each solution of the reduced instance will find all solutions of I in time O(|SI |cxd).\nNow consider the elimination of a value b from the domain of a variable x by absence of \u22032triangle on values a, b \u2208 D(x) in an instance I. As observed in the proof of Theorem 5, s is a solution to I with s(x) = b implies that s\u2032\u2032 defined by s\u2032\u2032(x) = a, s\u2032\u2032(v) = s(v) for v 6= x is a solution to the reduced instance. To determine all solutions of I from the set of all solutions of the reduced instance thus requires only O(|SI |cx) time.\nSumming over all variables x (and, in the case of value-eliminations, over all assignments to x), we obtain a total time complexity of O(|SI |cd+ 1), as claimed.\nAn essential element of the proof of Proposition 8 in the case of var-elim patterns is that the number of solutions does not decrease when a variable x is reinstated. Unfortunately, in the case of the var-elim patterns \u2203invsubBTP and \u2203snake, it is easy to construct an example in which this is not true. Indeed, consider a binary CSP instance I corresponding to the 2-colouring of a star graph (a graph composed of one central node with edges to n \u2212 1 other nodes). Let x be the variable corresponding to the central node of the graph. Since neither \u2203invsubBTP nor \u2203snake occur on x, both rules allow us to eliminate x, leaving an instance on n \u2212 1 variables and no constraints. Whereas I has only two solutions (corresponding to the two possible 2-colourings of a star graph), the reduced instance has 2n\u22121 solutions. In this example, reinstating a single variable decreased the number of solutions by an exponential factor.\nThe elimination of values can, on the other hand, dramatically simplify an instance to the extent that finding all solutions to the original instance remains intractable, as illustrated by the following proposition.\nProposition 9. Let I be an arc-consistent binary CSP instance and suppose that we are given the set of all solutions to the instance obtained after applying a single value-elimination operation due to the absence of one of the patterns \u22032snake or \u22032invsubBTP. Determining whether I has more than one solution is NP-complete.\nProof. The problem is clearly in NP. It therefore suffices to give a polynomial reduction from the known NP-complete problem binary CSP. Let J = \u3008X,D,A, cpt\u3009 be an arbitrary instance of binary CSP. We will build an instance IJ such that, after elimination of one variable x from IJ by either \u22032invsubBTP or \u22032snake and re-establishing arc consistency, we obtain a trivially-solvable instance with exactly one solution, but determining the existence of a second solution to IJ is equivalent to solving the instance J .\nThe variable-set of instance IJ is X \u222a {x} (where x is a variable not in X). For each variable y \u2208 X, the domain of y in IJ is D(y)\u222a{0}, where without loss of generality we assume that 0 does not belong to the domain D(y) of variable y in J . The domain of variable x in IJ is {0, 1}. The compatibility function of IJ is an extension of the compatibility function of J : for each y \u2208 X, the assignment \u3008x, 0\u3009 is compatible only with the assignment \u3008y, 0\u3009, whereas the assignment \u3008x, 1\u3009 is compatible with all the assignments \u3008y, a\u3009 for a 6= 0; furthermore for each y, z \u2208 X, the assignment \u3008y, 0\u3009 is compatible with all assignments to z.\nNeither \u22032invsubBTP nor \u22032snake occur on variable x in IJ with a, b mapping respectively to 0, 1. We can therefore eliminate the value 1 from the domain of x. After establishing arc consistency, all domains are reduced to the singleton {0}. Hence the reduced instance has exactly one solution. In the instance IJ , the assignment \u3008x, 0\u3009 only belongs to the solution assigning 0 to each variable, whereas the assignment \u3008x, 1\u3009 is compatible with exactly the set of solutions to the instance J .\nTherefore, determining the existence of a second solution to IJ is equivalent to determining the satisfiability of J ."}, {"heading": "8 Conclusion", "text": "This paper has introduced the notion of variable and value elimination rules in binary CSPs based on the absence of quantified patterns. We have identified all irreducible quantified patterns whose absence allows variable or value elimination. As a consequence, we have also identified novel tractable classes of binary CSPs. From a practical point of view, our rules can be incorporated into generic constraint solvers to prune the search tree.\nThere are several interesting directions for further research. Can we generalise the variable or value elimination patterns described in this paper to arbitrary-arity CSP instances (perhaps using one of the possible definitions of microstructure for constraints of arbitrary arity [25])? A partial positive answer to this question has recently been provided by arbitrary-arity versions of BTP [14]. Do the variable and value elimination patterns introduced in this paper generalise to other versions of constraint satisfaction, such as the QCSP (as is the case for the tractable class defined by BTP [19]) or the Weighted CSP (as is the case for tractable class defined by the socalled joint-winner pattern [15])? The research reported in the present paper has recently led to the discovery of sound variable and value elimination rules defined by local properties which strictly generalise the absence of patterns [10]. The characterisation of all such generalised variable or value elimination rules is a challenging open problem."}], "references": [{"title": "Consistency restoration and explanations in dynamic CSPs application to configuration", "author": ["J\u00e9r\u00f4me Amilhastre", "H\u00e9l\u00e8ne Fargier", "Pierre Marquis"], "venue": "Artif. Intell.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2002}, {"title": "Compiling CSPs: A complexity map of (non-deterministic) multivalued decision diagrams", "author": ["J\u00e9r\u00f4me Amilhastre", "H\u00e9l\u00e8ne Fargier", "Alexandre Niveau", "C\u00e9dric Pralet"], "venue": "In ICTAI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "A microstructure based approach to constraint satisfaction optimisation problems", "author": ["Ola Angelsmark", "Johan Thapper"], "venue": "Proceedings of the Eighteenth International Florida Artificial Intelligence Research Society Conference,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "3-coloring in time o(1.3446n): A no-MIS algorithm", "author": ["Richard Beigel", "David Eppstein"], "venue": "Annual Symposium on Foundations of Computer Science, Milwaukee, Wisconsin,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1995}, {"title": "An optimal coarse-grained arc consistency algorithm", "author": ["Christian Bessi\u00e8re", "Jean-Charles R\u00e9gin", "Roland H.C. Yap", "Yuanlin Zhang"], "venue": "Artificial Intelligence,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2005}, {"title": "Conflict-directed backjumping revisited", "author": ["Xinguang Chen", "Peter van Beek"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "The tractability of CSP classes defined by forbidden patterns", "author": ["David A. Cohen", "Martin C. Cooper", "P\u00e1id\u0301\u0131 Creed", "D\u00e1niel Marx", "Andr\u00e1s Z. Salamon"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Efficient systematic analysis of occlusion", "author": ["Martin C. Cooper"], "venue": "Pattern Recognition Letters,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1988}, {"title": "Fundamental properties of neighbourhood substitution in constraint satisfaction problems", "author": ["Martin C. Cooper"], "venue": "Artif. Intell.,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1997}, {"title": "A weighted CSP approach to cost-optimal planning", "author": ["Martin C. Cooper", "Marie de Roquemaurel", "Pierre R\u00e9gnier"], "venue": "Artificial Intelligence Communications,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2001}, {"title": "A dichotomy for 2-constraint forbidden CSP patterns", "author": ["Martin C. Cooper", "Guillaume Escamocher"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Generalizing constraint satisfaction on trees: Hybrid tractability and variable elimination", "author": ["Martin C. Cooper", "Peter G. Jeavons", "Andr\u00e1s Z. Salamon"], "venue": "Artif. Intell.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "\u017divn\u00fd. Tractable triangles and cross-free convexity in discrete optimisation", "author": ["Martin C. Cooper", "Stanislav"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "A polynomial algorithm for recognizing perfect graphs. In FOCS, pages 20\u201327", "author": ["G\u00e9rard Cornu\u00e9jols", "Xinming Liu", "Kristina Vuskovic"], "venue": "IEEE Computer Society,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2003}, {"title": "Eliminating interchangeable values in constraint satisfaction problems", "author": ["Eugene C. Freuder"], "venue": "In Proceedings of AAAI-91,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1991}, {"title": "Hybrid tractable classes of binary quantified constraint satisfaction problems", "author": ["Jian Gao", "Minghao Yin", "Junping Zhou"], "venue": "In AAAI,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}, {"title": "Watched literals for constraint propagation in minion", "author": ["Ian P. Gent", "Christopher Jefferson", "Ian Miguel"], "venue": "editor, CP,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "The ellipsoid method and its consequences in combinatorial optimization", "author": ["M. Gr\u00f6tschel", "L. Lovasz", "A. Schrijver"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1981}, {"title": "Decomposition of domains based on the micro-structure of finite constraintsatisfaction problems", "author": ["P. Jegou"], "venue": "In Proceedings of the 11th National Conference on Artificial Intelligence,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1993}, {"title": "Boosting search with variable elimination in constraint optimization and constraint satisfaction problems", "author": ["Javier Larrosa", "Rina Dechter"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "Constraint Networks: Techniques and Algorithms", "author": ["Christophe Lecoutre"], "venue": "ISTE/Wiley,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2009}, {"title": "Microstructures for CSPs with constraints of arbitrary arity", "author": ["Achref El Mouelhi", "Philippe J\u00e9gou", "Cyril Terrioux"], "venue": "Proceedings of the Tenth Symposium on Abstraction,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2013}, {"title": "Some new tractable classes of CSPs and their relations with backtracking algorithms", "author": ["Achref El Mouelhi", "Philippe J\u00e9gou", "Cyril Terrioux", "Bruno Zanuttini"], "venue": "CPAIOR", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2013}, {"title": "Principles and Practice of Constraint Programming - 20th International Conference, CP", "author": ["Barry O\u2019Sullivan", "editor"], "venue": "Proceedings, volume 8656 of Lecture Notes in Computer Science. Springer,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2014}, {"title": "Hybrid algorithms for the constraint satisfaction problem", "author": ["Patrick Prosser"], "venue": "Computational Intelligence,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1993}, {"title": "Perfect constraints are tractable", "author": ["Andr\u00e1s Z. Salamon", "Peter G. Jeavons"], "venue": "In Proceedings of the 14th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2008}, {"title": "A dichotomy theorem for the general minimum cost homomorphism problem", "author": ["Rustem Takhanov"], "venue": "Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "Conflict-directed A* and its role in model-based embedded systems", "author": ["Brian C. Williams", "Robert J. Ragno"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2007}], "referenceMentions": [{"referenceID": 20, "context": "Constraint satisfaction has proved to be a useful modelling tool in a variety of contexts, such as scheduling, timetabling, planning, bio-informatics and computer vision [17, 24, 29].", "startOffset": 170, "endOffset": 182}, {"referenceID": 5, "context": "Such techniques include Back-marking, Back-jumping, Conflict-Directed Back-jumping [6,28].", "startOffset": 83, "endOffset": 89}, {"referenceID": 24, "context": "Such techniques include Back-marking, Back-jumping, Conflict-Directed Back-jumping [6,28].", "startOffset": 83, "endOffset": 89}, {"referenceID": 4, "context": "Of these look-ahead techniques the most common is to maintain the local consistency property called generalised arc-consistency (GAC) [5].", "startOffset": 134, "endOffset": 137}, {"referenceID": 11, "context": "It has been observed that a more general property, called the (local) Broken Triangle Property (lBTP) [13], if it holds at some variable, allows us to eliminate that variable.", "startOffset": 102, "endOffset": 106}, {"referenceID": 11, "context": "Unfortunately, this domain order is NP-hard to discover [13] for unbounded domain size, and so the lMME is less likely to be effective in practice.", "startOffset": 56, "endOffset": 60}, {"referenceID": 19, "context": "An alternative to simple variable elimination is used in Bucket Elimination [23].", "startOffset": 76, "endOffset": 80}, {"referenceID": 14, "context": "The most well-known polynomial-time detectable substitution operation is neighbourhood substitution [18].", "startOffset": 100, "endOffset": 104}, {"referenceID": 18, "context": "The term microstructure was first given a formal definition by J\u00e9gou [22]: if I is a binary CSP instance, then its microstructure is a graph \u3008A,E\u3009 where A is the set of possible variable-value assignments and E is the set of pairs of compatible variable-value assignments.", "startOffset": 69, "endOffset": 73}, {"referenceID": 17, "context": "Since a maximum clique in a perfect graph can be found in polynomial time [21], the class of binary CSP instances with a perfect microstructure is tractable [30].", "startOffset": 74, "endOffset": 78}, {"referenceID": 25, "context": "Since a maximum clique in a perfect graph can be found in polynomial time [21], the class of binary CSP instances with a perfect microstructure is tractable [30].", "startOffset": 157, "endOffset": 161}, {"referenceID": 13, "context": "Perfect graphs can also be recognized in polynomial time [16].", "startOffset": 57, "endOffset": 61}, {"referenceID": 26, "context": "Takhanov [31] gave a dichotomy for tractable conservative constraint languages for MinHom which uses the fact that an instance of binary MinHom can be solved in polynomial time if its microstructure is perfect.", "startOffset": 9, "endOffset": 13}, {"referenceID": 22, "context": "[26] make the observation that if the microstructure has a bounded number of maximal cliques then the instance will be solved in polynomial time by classical algorithms such as Forward Checking or Really Full Lookahead and hence by CSP solvers.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "Simple rules for variable or value elimination based on properties of the microstructure are used by Beigel and Eppstein [4] in their algorithms with low worst-case time bounds for such NP-complete problems as 3-COLOURING and 3SAT.", "startOffset": 121, "endOffset": 124}, {"referenceID": 2, "context": "A similar approach allows Angelsmark and Thapper [3] to reduce the problem of finding a minimum weighted independent set in the microstructure complement to the problem of counting the number of solutions to a 2SAT instance.", "startOffset": 49, "endOffset": 52}, {"referenceID": 16, "context": "Any discovered obstructions to elimination can be effectively monitored during subsequent search using techniques analogous to watched literals [20].", "startOffset": 144, "endOffset": 148}, {"referenceID": 4, "context": "There are optimal O(cd) algorithms for establishing arc consistency which repeatedly remove such values [5], where c is the number of non-trivial constraints and d the maximum domain size.", "startOffset": 104, "endOffset": 107}, {"referenceID": 10, "context": "The definitions of occurrence and reduction between quantified patterns extend definitions previously given for non-quantified patterns [12].", "startOffset": 136, "endOffset": 140}, {"referenceID": 6, "context": "Essentially we want to say that pattern P occurs in pattern Q if P is homomorphic to a sub-pattern of Q via an injective renaming of variables and a (possibly non-injective) renaming of assignments [7].", "startOffset": 198, "endOffset": 201}, {"referenceID": 11, "context": "Hence we are able to significantly extend the list of known tractable classes defined by forbidden patterns since among known tractable patterns, namely BTP [13], 2-constraint patterns [12], pivots [7] and JWP [15], only BTP (and its sub-patterns) allow variable elimination.", "startOffset": 157, "endOffset": 161}, {"referenceID": 10, "context": "Hence we are able to significantly extend the list of known tractable classes defined by forbidden patterns since among known tractable patterns, namely BTP [13], 2-constraint patterns [12], pivots [7] and JWP [15], only BTP (and its sub-patterns) allow variable elimination.", "startOffset": 185, "endOffset": 189}, {"referenceID": 6, "context": "Hence we are able to significantly extend the list of known tractable classes defined by forbidden patterns since among known tractable patterns, namely BTP [13], 2-constraint patterns [12], pivots [7] and JWP [15], only BTP (and its sub-patterns) allow variable elimination.", "startOffset": 198, "endOffset": 201}, {"referenceID": 12, "context": "Hence we are able to significantly extend the list of known tractable classes defined by forbidden patterns since among known tractable patterns, namely BTP [13], 2-constraint patterns [12], pivots [7] and JWP [15], only BTP (and its sub-patterns) allow variable elimination.", "startOffset": 210, "endOffset": 214}, {"referenceID": 11, "context": "Forbidding BTP is equivalent to the already-known local Broken Triangle Property (lBTP) [13] mentioned in Section 1.", "startOffset": 88, "endOffset": 92}, {"referenceID": 11, "context": "Since it is known that BTP is a var-elim pattern [13], we only need to prove the result for the three existential patterns: \u2203subBTP, \u2203invsubBTP and \u2203snake.", "startOffset": 49, "endOffset": 53}, {"referenceID": 8, "context": "It is worth noting that even when all solutions are required, neighbourhood substitutability can still be applied since all solutions to the original instance can be recovered from the set of solutions to the reduced instance in time which is linear in the total number of solutions and polynomial in the size of the instance [9].", "startOffset": 326, "endOffset": 329}, {"referenceID": 8, "context": "Neighbourhood substitution cannot destroy arc consistency [9], but eliminating a value by a val-elim pattern can provoke new eliminations by arc consistency, as we have seen in the above examples.", "startOffset": 58, "endOffset": 61}, {"referenceID": 8, "context": "The result of applying a sequence of neighbourhood substitution eliminations until convergence is unique modulo isomorphism [9].", "startOffset": 124, "endOffset": 127}, {"referenceID": 9, "context": "that it is present in all solution-plans) we need to determine the satisfiability of a binary CSP representing the same planning problem using the set of actions A \\ {a} [11].", "startOffset": 170, "endOffset": 174}, {"referenceID": 27, "context": "In other application areas, such as fault-diagnosis [32] or the interpretation of ambiguous pictures [8], it is important to find all solutions or a representation of all solutions from", "startOffset": 52, "endOffset": 56}, {"referenceID": 7, "context": "In other application areas, such as fault-diagnosis [32] or the interpretation of ambiguous pictures [8], it is important to find all solutions or a representation of all solutions from", "startOffset": 101, "endOffset": 104}, {"referenceID": 0, "context": "For example, the on-line configuration of a product (such as a car) by a user can be rendered tractable by the off-line compilation of all solutions into some appropriate compact form [1, 2].", "startOffset": 184, "endOffset": 190}, {"referenceID": 1, "context": "For example, the on-line configuration of a product (such as a car) by a user can be rendered tractable by the off-line compilation of all solutions into some appropriate compact form [1, 2].", "startOffset": 184, "endOffset": 190}, {"referenceID": 11, "context": "If x has been eliminated due to the absence of BTP, then it is known that any solution s of the reduced instance can be extended to a solution of I [13].", "startOffset": 148, "endOffset": 152}, {"referenceID": 21, "context": "Can we generalise the variable or value elimination patterns described in this paper to arbitrary-arity CSP instances (perhaps using one of the possible definitions of microstructure for constraints of arbitrary arity [25])? A partial positive answer to this question has recently been provided by arbitrary-arity versions of BTP [14].", "startOffset": 218, "endOffset": 222}, {"referenceID": 15, "context": "Do the variable and value elimination patterns introduced in this paper generalise to other versions of constraint satisfaction, such as the QCSP (as is the case for the tractable class defined by BTP [19]) or the Weighted CSP (as is the case for tractable class defined by the socalled joint-winner pattern [15])? The research reported in the present paper has recently led to the discovery of sound variable and value elimination rules defined by local properties which strictly generalise the absence of patterns [10].", "startOffset": 201, "endOffset": 205}, {"referenceID": 12, "context": "Do the variable and value elimination patterns introduced in this paper generalise to other versions of constraint satisfaction, such as the QCSP (as is the case for the tractable class defined by BTP [19]) or the Weighted CSP (as is the case for tractable class defined by the socalled joint-winner pattern [15])? The research reported in the present paper has recently led to the discovery of sound variable and value elimination rules defined by local properties which strictly generalise the absence of patterns [10].", "startOffset": 308, "endOffset": 312}], "year": 2015, "abstractText": "Variable or value elimination in a constraint satisfaction problem (CSP) can be used in preprocessing or during search to reduce search space size. A variable elimination rule (value elimination rule) allows the polynomial-time identification of certain variables (domain elements) whose elimination, without the introduction of extra compensatory constraints, does not affect the satisfiability of an instance. We show that there are essentially just four variable elimination rules and three value elimination rules defined by forbidding generic sub-instances, known as irreducible existential patterns, in arc-consistent CSP instances. One of the variable elimination rules is the already-known Broken Triangle Property, whereas the other three are novel. The three value elimination rules can all be seen as strict generalisations of neighbourhood substitution.", "creator": "LaTeX with hyperref package"}}}