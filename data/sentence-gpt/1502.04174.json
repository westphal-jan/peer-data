{"id": "1502.04174", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2015", "title": "Probabilistic Models for High-Order Projective Dependency Parsing", "abstract": "This paper presents generalized probabilistic models for high-order projective dependency parsing and an algorithmic framework for learning these statistical models involving dependency trees. Partition functions and marginals for high-order dependency trees can be computed efficiently, by adapting our algorithms which extend the inside-outside algorithm to higher-order cases. To show the effectiveness of our algorithms, we perform experiments on three languages---English, Chinese and Czech, using maximum conditional likelihood estimation for model training and L-BFGS for parameter estimation. The algorithm is able to efficiently use the maximum conditional probability estimation to predict the best probability of low-order models. Our algorithms have not been verified and therefore have not been tested and thus have not yet been used for validation in this paper.", "histories": [["v1", "Sat, 14 Feb 2015 06:47:34 GMT  (2100kb)", "http://arxiv.org/abs/1502.04174v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["xuezhe ma", "hai zhao"], "accepted": false, "id": "1502.04174"}, "pdf": {"name": "1502.04174.pdf", "metadata": {"source": "CRF", "title": "Probabilistic Models for High-Order Projective Dependency Parsing", "authors": ["Xuezhe Ma", "Hai Zhao"], "emails": ["xuezhe.ma@gmail.com,", "zhaohai@cs.sjtu.edu.cn"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 2.\n04 17\n4v 1\n[ cs\n.C L\n] 1\n4 Fe\nb 20\n15\nProbabilistic Models for High-Order Projective Dependency Parsing\nXuezhe Ma\u2217\nShanghai Jiao Tong University\nHai Zhao Shanghai Jiao Tong University\nThis paper presents generalized probabilistic models for high-order projective dependency parsing and an algorithmic framework for learning these statistical models involving dependency trees. Partition functions and marginals for high-order dependency trees can be computed efficiently, by adapting our algorithms which extend the inside-outside algorithm to higher-order cases. To show the effectiveness of our algorithms, we perform experiments on three languages\u2014 English, Chinese and Czech, using maximum conditional likelihood estimation for model training and L-BFGS for parameter estimation. Our methods achieve competitive performance for English, and outperform all previously reported dependency parsers for Chinese and Czech."}, {"heading": "1. Introduction", "text": "Dependency parsing is an approach to syntactic analysis inspired by dependency grammar. In recent years, several domains of Natural Language Processing have benefited from dependency representations, such as synonym generation (Shinyama, Sekine, and Sudo 2002), relation extraction (Nguyen, Moschitti, and Riccardi 2009) and machine translation (Katz-Brown et al. 2011; Xie, Mi, and Liu 2011). A primary reason for using dependency structures instead of more informative constituent structures is that they are usually easier to be understood and is more amenable to annotators who have good knowledge of the target domain but lack of deep linguistic knowledge (Yamada and Matsumoto 2003) while still containing much useful information needed in application.\nDependency structure represents a parsing tree as a directed graph with different labels on each edge, and some methods based on graph models have been applied to it and achieved high performance. Based on the report of the CoNLL-X shared task on dependency parsing (Buchholz and Marsi 2006; Nivre et al. 2007), there are currently two dominant approaches for data-driven dependency parsing: local-and-greedy transitionbased algorithms (Yamada and Matsumoto 2003; Nivre and Scholz 2004; Attardi 2006; McDonald and Nivre 2007), and globally optimized graph-based algorithms (Eisner 1996; McDonald, Crammer, and Pereira 2005; McDonald et al. 2005; McDonald and Pereira 2006; Carreras 2007; Koo and Collins 2010), and graph-based parsing models have achieved state-ofthe-art accuracy for a wide range of languages.\n\u2217 1Center for Brain-Like Computing and Machine Intelligence Department of Computer Science and Engineering. 2MOE-Microsoft Key Laboratory for Intelligent Computing and Intelligent Systems. Shanghai Jiao Tong University, 800 Dong Chuan Rd., Shanghai 200240, China. E-mail: xuezhe.ma@gmail.com, zhaohai@cs.sjtu.edu.cn\n\u00a9 2012 Center for Brain-Like Computing and Machine Intelligence\nThere have been several existing graph-based dependency parsers, most of which employed online learning algorithms such as the averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002) or Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) for learning parameters. However, One shortcoming of these parsers is that learning parameters of these models usually takes a long time (several hours for an iteration). The primary reason is that the training step cannot be performed in parallel, since for online learning algorithms, the updating for a new training instance depends on parameters updated with the previous instance.\nPaskin (2001) proposed a variant of the inside-outside algorithm (Baker 1979), which were applied to the grammatical bigram model (Eisner 1996). Using this algorithm, the grammatical bigram model can be learning by off-line learning algorithms. However, the grammatical bigram model is based on a strong independence assumption that all the dependency edges of a tree are independent of one another. This assumption restricts the model to first-order factorization (single edge), losing much of the contextual information in dependency tree. Chen et.al (2010) illustrated that a wide range of decision history can lead to significant improvements in accuracy for graph-based dependency parsing models. Meanwhile, several previous works (Carreras 2007; Koo and Collins 2010) have shown that grandchild interactions provide important information for dependency parsing. Therefore, relaxing the independence assumption for higher-order parts to capture much richer contextual information within the dependency tree is a reasonable improvement of the bigram model.\nIn this paper, we present a generalized probabilistic model that can be applied to any types of factored models for projective dependency parsing, and an algorithmic framework for learning these statistical models. We use the grammatical bigram model as the backbone, but relax the independence assumption and extend the inside-outside algorithms to efficiently compute the partition functions and marginals (see Section 2.4) for three higherorder models. Using the proposed framework, parallel computation technique can be employed, significantly reducing the time taken to train the parsing models. To achieve empirical evaluations of our parsers, these algorithms are implemented and evaluated on three treebanks\u2014Penn WSJ Treebank (Marcus, Santorini, and Marcinkiewicz 1993) for English, Penn Chinese Treebank (Xue et al. 2005) for Chinese and Prague Dependency Treebank (Hajic\u030c 1998; Hajic\u030c et al. 2001) for Czech, and we expect to achieve an improvement in parsing performance. We also give an error analysis on structural properties for the parsers trained by our framework and those trained by online learning algorithms. A free distribution of our implementation has been put on the Internet.1.\nThe remainder of this paper is structured as follows: Section 2 describes the probabilistic models and the algorithm framework for training the models. Related work is presented in Section 3. Section 4 presents the algorithms of different parsing models for computing partition functions and marginals. The details of experiments are reported in Section 5, and conclusions are in Section 6."}, {"heading": "2. Dependency Parsing", "text": ""}, {"heading": "2.1 Background of Dependency Parsing", "text": "Dependency trees represent syntactic relationships through labeled directed edges of words and their syntactic modifiers. For example, Figure 1 shows a dependency tree for the sentence, Economic news had little effect on financial markets, with the sentence\u2019s root-symbol as its root.\n1 http://sourceforge.net/projects/maxparser/\nRoot\nhad\nnews\nEconomic\neffect\nlittle on\nmarkets\nfinancial\nroot\nsbj obj\nnmod\nnmod\nnmod\nnmod\npc Economic news had little effect on financial marketsRoot\n(a) (b)\nFigure 1 An example dependency tree.\nBy considering the item of crossing dependencies, dependency trees fall into two categories\u2014projective and non-projective dependency trees. An equivalent and more convenient formulation of the projectivity constrain is that if a dependency tree can be written with all words in a predefined linear order and all edges drawn on the plane without crossing edges (see Figure 1(b)). The example in Figure 1 belongs to the class of projective dependency trees where crossing dependencies are not allowed.\nDependency trees are often typed with labels for each edge to represent additional syntactic information (see Figure 1(a)), such as sbj and obj for verb-subject and verb-object head-modifier interactions, respectively. Sometimes, however, the dependency labels are omitted. Dependency trees are defined as labeled or unlabeled according to whether the dependency labels are included or dropped. In the remainder of this paper, we will focus on unlabeled dependency parsing for both theoretical and practical reasons. From theoretical respect, unlabeled parsers are easier to describe and understand, and algorithms for unlabeled parsing can usually be extended easily to the labeled case. From practical respect, algorithms of labeled parsing generally have higher computational complexity than them of unlabeled version, and are more difficult to implement and verify. Finally, the dependency labels can be accurately tagged by a two-stage labeling method (McDonald 2006), utilizing the unlabeled output parse."}, {"heading": "2.2 Probabilistic Model", "text": "The symbols we used in this paper are denoted in what follows, x represents a generic input sentence, and y represents a generic dependency tree. T(x) is used to denote the set of possible dependency trees for sentence x. The probabilistic model for dependency parsing defines a family of conditional probability Pr(y|x) over all y given sentence x, with a log-linear form:\nPr(y|x) = 1\nZ(x) exp\n{\n\u2211\nj\n\u03bbjFj(y,x)\n}\n,\nwhere Fj are feature functions, \u03bb = (\u03bb1, \u03bb2, . . .) are parameters of the model, and Z(x) is a normalization factor, which is commonly referred to as the partition function:\nZ(x) = \u2211\ny\u2208T(x)\nexp\n{\n\u2211\nj\n\u03bbjFj(y,x)\n}\n."}, {"heading": "2.3 Maximum Likelihood Parameter Inference", "text": "Maximum conditional likelihood estimation is used for model training (like a CRF). For a set of training data {(xk,yk)}, the logarithm of the likelihood, knows as the log-likelihood, is given by:\nL(\u03bb) = log \u220f\nk\nPr(yk|xk)\n= \u2211\nk\nlog Pr(yk|xk)\n= \u2211\nk\n[\n\u2211\nj\n\u03bbjFj(yk,xk)\u2212 logZ(xk)\n]\n.\nMaximum likelihood training chooses parameters such that the log-likelihood L(\u03bb) is maximized. This optimization problem is typically solved using quasi-Newton numerical methods such as L-BFGS (Nash and Nocedal 1991), which requires the gradient of the objective function:\n\u2202L(\u03bb)\n\u2202\u03bbj =\n\u2211\nk\n\u2202 log Pr(yk|xk) \u2202\u03bbj\n= \u2211\nk\n[\nFj(yk,xk)\u2212 \u2202 log z(xk)\n\u2202\u03bbj\n]\n(1)\n= \u2211\nk\n[\nFj(yk,xk)\u2212 \u2211\ny\u2208T(xk)\nPr(y|xk)Fj(y,xk)\n]\n.\nThe computation of Z(x) and the second item in summation of Equation (1) are the difficult parts in model training. In the following, we will show how these can be computed efficiently using the proposed algorithms."}, {"heading": "2.4 Problems of Training and Decoding", "text": "In order to train and decode dependency parsers, we have to solve three inference problems which are central to the algorithms proposed in this paper.\nThe first problem is the decoding problem of finding the best parse for a sentence when all the parameters of the probabilistic model have been given. According to decision theory, a reasonable solution for classification is the Bayes classifier which classify to the most probable class, using the conditional distribution. Dependency parsing could be regarded as a classification problem, so decoding a dependency parser is equivalent to finding the dependency tree y\u2217 which\nhas the maximum conditional probability:\ny \u2217 = argmax\ny\u2208T(x)\nPr(y|x)\n= argmax y\u2208T(x) log Pr(y|x)\n= argmax y\u2208T(x)\n{\n\u2211\nj\n\u03bbjFj(y,x)\n}\n. (2)\nThe second and third problems are the computation of the partition function Z(x) and the gradient of the log-likelihood (see Equation (1)).\nFrom the definition above, we can see that all three problems require an exhaustive search over T(x) to accomplish a maximization or summation. It is obvious that the cardinality of T(x) grows exponentially with the length of x, thus it is impractical to perform the search directly. A common strategy is to factor dependency trees into sets of small parts that have limited interactions:\nFj(y,x) = \u2211\np\u2208y\nfj(p,x). (3)\nThat is, dependency tree y is treated as a set of parts p and each feature function Fj(y,x) is equal to the sum of all the features fj(p,x).\nWe denote the weight of each part p as follows:\nw(p,x) = exp\n{\n\u2211\nj\n\u03bbjfj(p,x)\n}\n.\nBased on Equation (3) and the definition of weight for each part, conditional probability Pr(y|x) has the the following form:\nPr(y|x) = 1\nZ(x) exp\n{\n\u2211\nj\n\u03bbj \u2211\np\u2208y\nfj(p,x)\n}\n= 1\nZ(x) exp\n{\n\u2211\np\u2208y\n\u2211\nj\n\u03bbjfj(p,x)\n}\n= 1\nZ(x)\n\u220f\np\u2208y\nw(p,x)\nFurthermore, Equation (2) can be rewritten as:\ny \u2217 = argmax\ny\u2208T(x)\n\u2211\np\u2208y\nlogw(p,x),\nand the partition function Z(x) and the second item in the summation of Equation (1) are\nZ(x) = \u2211\ny\u2208T(x)\n[\n\u220f\np\u2208y\nw(p,x)\n]\n,\nand\n\u2211\ny\u2208T(xk)\nPr(y|xk)Fj(y,xk)\n= \u2211\ny\u2208T(xk)\n\u2211\np\u2208y\nPr(y|xk)fj(p,xk)\n= \u2211\np\u2208P(xk)\n\u2211\ny\u2208T(p,xk)\nfj(p,xk)Pr(y|xk)\n= \u2211\np\u2208P(xk)\nfj(p,xk) \u2211\ny\u2208T(p,xk)\nPr(y|xk),\nwhere T(p,x) = {y \u2208 T(x)|p \u2208 y} and P(x) is the set of all possible part p for sentence x. Note that the remaining problem for the computation of the gradient in Equation (1) is to compute the marginal probability m(p) for each part p:\nm(p) = \u2211\ny\u2208T(p,x)\nPr(y|x).\nThen the three inference problems are as follows:\nProblem 1: Decoding\ny \u2217 = argmax\ny\u2208T(x)\n\u2211\np\u2208y\nlogw(p,x).\nProblem 2: Computing the Partition Function\nZ(x) = \u2211\ny\u2208T(x)\n[\n\u220f\np\u2208y\nw(p,x)\n]\n.\nProblem 3: Computing the Marginals\nm(p) = \u2211\ny\u2208T(p,x)\nPr(y|x), for all p."}, {"heading": "2.5 Discussion", "text": "It should be noted that for the parsers trained by online learning algorithms such as AP or MIRA, only the algorithm for solving the decoding problem is required. However, for the motivation of training parsers using off-line parameter estimation methods such as maximum likelihood described above, we have to carefully design algorithms for the inference problem 2 and 3.\nThe proposed probabilistic model is capable of generalization to any types of parts p, and can be learned by using the framework which solves the three inference problems. For different types of factored models, the algorithms to solve the three inference problems are different. Following Koo and Collins (2010), the order of a part is defined as the number of dependencies it contains, and the order of a factorization or parsing algorithm is the maximum of the order\nof the parts it uses. In this paper, we focus on three factorizations: sibling and grandchild, two different second-order parts, and grand-sibling, a third-order part:\nsibling grandchild grand-sibling\ns tr s tr s s t t r r g\ng\nIn this paper, we consider only projective trees, where crossing dependencies are not allowed, excluding non-projective trees, where dependencies are allowed to cross. For projective parsing, efficient algorithms exist to solve the three problems, for certain factorizations with special structures. Non-projective parsing with high-order factorizations is known to be NPhard in computation (McDonald and Pereira 2006; McDonald and Satta 2007). In addition, our models capture multi-root trees, whose root-symbols have one or more children. A multi-root parser is more robust to sentences that contain disconnected but coherent fragments, since it is allowed to split up its analysis into multiple pieces."}, {"heading": "2.6 Labeled Parsing", "text": "Our probabilistic model are easily extended to include dependency labels. We denote L as the set of all valid dependency labels. We change the feature functions to include label function:\nFj(y,x) = \u2211\n(p,l)\u2208y\nfj(p, l,x).\nwhere l is the vector of dependency labels of edges belonging to part p. We define the order of l as the number of labels l contains, and denote it as o(l). It should be noted that the order of l is not necessarily equal to the order of p, since l may contain labels of parts of edges in p. For example, for the second-order sibling model and the part (s, r, t), l can be defined to contain only the label of edge from word xs to word xt.\nThe weight function of each part is changed to:\nw(p, l,x) = exp\n{\n\u2211\nj\n\u03bbjfj(p, l,x)\n}\n. (4)\nBased on Equation 4, Problem 2 and 3 are rewritten as follows:\nZ(x) = \u2211\ny\u2208T(x)\n[\n\u220f\n(p,l)\u2208y\nw(p, l,x)\n]\n.\nand\nm(p, l) = \u2211\ny\u2208T(p,l,x)\nPr(y|x), for all (p, l).\nThis extension increases the computational complexity of time by factor of O(|L|o(l)), where |L| is the size of L.\n= + s t s r r+1 t\n= + s t s r r t\nfirst-order parser\n= + s t s r r+1 t\n= + s t s r r t\ng\ng\ng s\ng s\nsecond-order grandchild parser\n=\n+\ns t\ns r r+1 t\n= + s t s r r t\n= s t\ns r + r t\n=\n+\ns t\ns r r+1 t\n= + s t s r r t\n= s t\ns r + r t\ng\ng\ng\ng\ng\ng s\ng\ns\nsecond-order sibling parser third-order grand-sibling parser\nFigure 2 The dynamic-programming structures and derivation of four graph-based dependency parsers with different types of factorization. Symmetric right-headed versions are elided for brevity."}, {"heading": "3. Related Work", "text": ""}, {"heading": "3.1 Grammatical Bigram Probability Model", "text": "The probabilistic model described in Section 2.2 is a generalized formulation of the grammatical bigram probabilistic model proposed in Eisner (1996), which is used by several works (Paskin 2001; Koo et al. 2007; Smith and Smith 2007). In fact, the grammatical bigram probabilistic model is a special case of our probabilistic model, by specifying the parts p as individual edges. The grammatical bigram model is based on a strong independence assumption: that all the dependency edges of a tree are independent of one another, given the sentence x.\nFor the first-order model (part p is an individual edge), a variant of the inside-outside algorithm, which was proposed by Baker (1979) for probabilistic context-free grammars, can be applied for the computation of partition function and marginals for projective dependency structures. This inside-outside algorithm is built on the semiring parsing framework (Goodman 1999). For non-projective cases, Problems 2 and 3 can be solved by an adaptation of Kirchhoff\u2019s MatrixTree Theorem (Koo et al. 2007; Smith and Smith 2007)."}, {"heading": "3.2 Algorithms of Decoding Problem for Different Factored Models", "text": "It should be noted that if the score of parts is defined as the logarithm of their weight:\nscore(p,x) = logw(p,x) = \u2211\nj\n\u03bbjfj(p,x),\nthen the decoding problem is equivalent to the form of graph-based dependency parsing with global linear model (GLM), and several parsing algorithms for different factorizations have\nbeen proposed in previous work. Figure 2 provides graphical specifications of these parsing algorithms.\nMcDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges. A widely-used dynamic programming algorithm (Eisner 2000) was used for decoding. This algorithm introduces two interrelated types of dynamic programming structures: complete spans, and incomplete spans (McDonald, Crammer, and Pereira 2005). Larger spans are created from two smaller, adjacent spans by recursive combination in a bottom-up procedure.\nThe second-order sibling parser (McDonald and Pereira 2006) breaks up a dependency tree into sibling parts\u2014pairs of adjacent edges with shared head. Koo and Collins (2010) proposed a parser that factors each dependency tree into a set of grandchild parts. Formally, a grandchild part is a triple of indices (g, s, t) where g is the head of s and s is the head of t. In order to parse this factorization, it is necessary to augment both complete and incomplete spans with grandparent indices. Following Koo and Collins (2010), we refer to these augmented structures as g-spans.\nThe second-order parser proposed in Carreras (2007) is capable to score both sibling and grandchild parts with complexities of O(n4) time and O(n3) space. However, the parser suffers an crucial limitation that it can only evaluate events of grandchild parts for outermost grandchildren.\nThe third-order grand-sibling parser, which encloses grandchild and sibling parts into a grand-sibling part, was described in Koo and Collins (2010). This factorization defines all grandchild and sibling parts and still requires O(n4) time and O(n3) space."}, {"heading": "3.3 Transition-based Parsing", "text": "Another category of dependency parsing systems is \u201ctransition-based\u201d parsing (Nivre and Scholz 2004; Attardi 2006; McDonald and Nivre 2007) which parameterizes models over transitions from one state to another in an abstract state-machine. In these models, dependency trees are constructed by taking highest scoring transition at each state until a state for the termination is entered. Parameters in these models are typically learned using standard classification techniques to predict one transition from a set of possible transitions given a state history.\nRecently, several approaches have been proposed to improve transition-based dependency parsers. In the aspect of decoding, beam search (Johansson and Nugues 2007; Huang, Jiang, and Liu 2009) and partial dynamic programming (Huang and Sagae 2010) have been applied to improve one-best search. In the aspect of training, global structural learning has been applied to replace local learning on each decision (Zhang and Clark 2008; Huang, Jiang, and Liu 2009)."}, {"heading": "4. Algorithms for High-order Models", "text": "In this section, we describe our algorithms for problem 2 and 3 of three high-order factored models: grandchild and sibling, two second-order models; and grand-sibling, which is thirdorder. Our algorithms are built on the idea from the inside-outside algorithm (Paskin 2001) for the first-order projective parsing model. Following this, we define the inside probabilities \u03b2 and outside probabilities \u03b1 over spans \u03c6:\n\u03b2(\u03c6) = \u2211\nt\u2208\u03c6\n\u220f p\u2208t w(p,x)\n\u03b1(\u03c6) = \u2211\ny\u2208T(\u03c6)\n\u220f\np6\u2208y(\u03c6)\nw(p,x),\nAlgorithm 1 Compute inside probability \u03b2 for second-order Grandchild Model\nRequire: \u03b2(Cgs,s) = 1.0 \u2200g, s"}, {"heading": "1: for k = 1 to n", "text": ""}, {"heading": "2: for s = 0 to n\u2212 k", "text": "3: t = s+ k\n4: for g < s or g > t\n5: \u03b2(Igs,t) = \u2211 s\u2264r<t \u03b2(Cgs,r) \u00b7 \u03b2(C s t,r+1) \u00b7 w g s,t \u03b2(I g t,s) = \u2211 s\u2264r<t \u03b2(Cts,r) \u00b7 \u03b2(C g t,r+1) \u00b7 w g t,s\n6: \u03b2(Cgs,t) = \u2211 s<r\u2264t \u03b2(Igs,r) \u00b7 \u03b2(C s r,t) \u03b2(C g t,s) = \u2211 s\u2264r<t \u03b2(Igt,r) \u00b7 \u03b2(C t r,s)"}, {"heading": "7: end for", "text": ""}, {"heading": "8: end for", "text": "Require: \u03b2(Cs,s) = 1.0 \u2200s"}, {"heading": "9: for k = 1 to n", "text": "10: s = n\u2212 k, t = k\n11: \u03b2(I0,t) = \u2211\n0\u2264r<t \u03b2(C0,r) \u00b7 \u03b2(C\n0 t,r+1) \u00b7 w 0 0,t \u03b2(In,s) =\n\u2211\ns\u2264r<n \u03b2(Cns,r) \u00b7 \u03b2(Cn,r+1) \u00b7 w n n,s\n12: \u03b2(C0,t) = \u2211\n0<r\u2264t \u03b2(I0,r) \u00b7 \u03b2(C\n0 r,t) \u03b2(Cn,s) =\n\u2211\ns\u2264r<n \u03b2(In,r) \u00b7 \u03b2(C n r,s)"}, {"heading": "13: end for", "text": "where t is a sub-structure of a tree and y(\u03c6) is the sub-structure of tree y that belongs to span \u03c6."}, {"heading": "4.1 Model of Grandchild Factorization", "text": "In the second-order grandchild model, each dependency tree is factored into a set of grandchild parts\u2014 pairs of dependencies connected head-to-tail. Formally, a grandchild part is a triple of indices (g, s, t) where both (g, s) and (s, t) are dependencies.\nIn order to compute the partition function Z(x) and marginals m(g, s, t) for this factorization, we augment both incomplete and complete spans with grandparent indices. This is similar to Koo and Collins (2010) for the decoding algorithm of this grandchild factorization. Following Koo and Collins (2010), we refer to these augmented structures as g-spans, and denote an incomplete g-span as Igs,t, where Is,t is a normal complete span and g is the index of a grandparent lying outside the range [s, t], with the implication that (g, s) is a dependency. Complete g-spans are defined analogously and denoted as Cgs,t. In addition, we denote the weight of a grandchild part (g, s, t) as wgs,t for brevity.\nThe algorithm for the computation of inside probabilities \u03b2 is shown as Algorithm 1. The dynamic programming derivations resemble those of the decoding algorithm of this factorization, the only difference is to replace the maximization with summation. The reason is obvious, since\nAlgorithm 2 Compute outside probability \u03b1 for second-order Grandchild Model\nRequire: \u03b1(I0,n) = 1.0, \u03b1(In,0) = 1.0"}, {"heading": "1: for k = n to 1", "text": "2: s = n\u2212 k, t = k 3: \u03b1(C0,t) = \u2211\nt<r\u2264n\n\u03b2(C0r,t+1) \u00b7 \u03b1(I0,r) \u00b7w 0 0,r \u03b1(Cn,s) =\n\u2211\n0\u2264r<s\n\u03b2(Cnr,s\u22121) \u00b7 \u03b1(In,r) \u00b7w n n,r\n4: \u03b1(I0,t) = \u2211\nt\u2264r\u2264n\n\u03b2(C0t,r) \u00b7 \u03b1(C0,r) \u03b1(In,s) = \u2211\n0\u2264r\u2264s\n\u03b2(Cns,r) \u00b7 \u03b1(Cn,r)"}, {"heading": "5: end for", "text": "Require: \u03b1(I00,n) = 1.0, \u03b1(I n n,0) = 1.0"}, {"heading": "6: for k = n to 1", "text": ""}, {"heading": "7: for s = 0 to n\u2212 k", "text": "8: t = s+ k\n9: for g < s 10: \u03b1(Cgs,t) = \u2211\nt<r\u2264n\n\u03b2(Csr,t+1) \u00b7 \u03b1(I g s,r) \u00b7w g s,r +\n\u2211\nr<g\u2228r>t\n\u03b2(Irg,s) \u00b7 \u03b1(C r g,t)\n11: \u03b1(Cgt,s) = \u2211\ng<r<s\n\u03b2(Ctr,s\u22121) \u00b7 \u03b1(I g t,r) \u00b7 w g t,r +\n\u2211\nr<g\u2228r>t\n\u03b2(Crg,s\u22121) \u00b7 \u03b1(Ig,tr) \u00b7 w r g,t\n12: if g = 0\n13: \u03b1(Cgs,t) + = \u03b2(I0,s) \u00b7 \u03b1(C0,t) \u03b1(C g t,s) + = \u03b2(C0,s\u22121) \u00b7 \u03b1(I0,t) \u00b7w 0 0,t\n14: end if 15: \u03b1(Igs,t) = \u2211\nt\u2264r\u2264n\n\u03b2(Cst,r) \u00b7 \u03b1(C g s,r) \u03b1(I g t,s) =\n\u2211\ng<r\u2264s\n\u03b2(Cts,r \u00b7 \u03b1(C g t,r)"}, {"heading": "16: end for", "text": "17: for g > t 18: \u03b1(Cgs,t) = \u2211\nt<r<g\n\u03b2(Csr,t+1) \u00b7 \u03b1(I g s,r) \u00b7w g s,r +\n\u2211\nr<s\u2228r>g\n\u03b2(Crg,t+1) \u00b7 \u03b1(I r g,s) \u00b7 w r g,s\n19: \u03b1(Cgt,s) = \u2211\n0leqr<s\n\u03b2(Ctr,s\u22121) \u00b7 \u03b1(I g t,r) \u00b7 w g t,r +\n\u2211\nr<s\u2228r>g\n\u03b2(Irg,t) \u00b7 \u03b1(Ig,sr)\n20: if g = n\n21: \u03b1(Cgs,t) + = \u03b2(In,t+1) \u00b7 \u03b1(Cn,s) \u00b7w n n,s \u03b1(C g t,s) + = \u03b2(In,t) \u00b7 \u03b1(In,s)\n22: end if 23: \u03b1(Igs,t) = \u2211\nt\u2264r<g\n\u03b2(Cst,r) \u00b7 \u03b1(C g s,r) \u03b1(I g t,s) =\n\u2211\n0\u2264r\u2264s\n\u03b2(Cts,r) \u00b7 \u03b1(C g t,r)"}, {"heading": "24: end for", "text": ""}, {"heading": "25: end for", "text": "26: end for\nthe spans defined for the two algorithms are the same. Note that since our algorithm considers multi-root dependency trees, we should perform another recursive step to compute the inside probability \u03b2 for the complete span C0,t, after the computation of \u03b2 for all g-spans.\nAlgorithm 2 illustrates the algorithm for computing outside probabilities \u03b1. This is a topdown dynamic programming algorithm, and the key of this algorithm is to determine all the contributions to the final Z(x) for each g-span; fortunately, this can be done deterministically for all cases. For example, the complete g-span Cgs,t with g < s < t has two different contributions: combined with a g-span Csr,t+1, of which r > t, in the right side to build up a larger g-span I g s,r; or combined with a g-span Irg,s, of which r > t or r < g, in the left side to form a larger g-span Crg,t. So \u03b1(C g s,t) is the sum of two items, each of which corresponds to one of the two cases (See Algorithm 2). It should be noted that complete g-spans Cgs,t with g = 0 or g = n are two special cases.\nAfter the computation of \u03b2 and \u03b1 for all spans, we can get marginals using following equation:\nm(g, s, t) = \u03b2(Igs,t) \u00b7 \u03b1(I g s,t)/z(x).\nSince the complexity of the both Algorithm 1 and Algorithm 2 is O(n4) time and O(n3) space, the complexity overall for training this model is O(n4) time and O(n3) space, which is the same as the decoding algorithm of this factorization."}, {"heading": "4.2 Model of Sibling Factorization", "text": "In order to parse the sibling factorization, a new type of span: sibling spans, is defined (McDonald 2006). We denote a sibling span as Ss,t where s and t are successive modifiers with a shared head. Formally, a sibling span Ss,t represents the region between successive modifiers s and t of some head. The graphical specification of the second-order sibling model for dynamic-programming, which is in the original work of Eisner (Eisner 1996), is shown in Figure 2. The key insight is that an incomplete span is constructed by combining a smaller incomplete span with a sibling span that covers the region between the two successive modifiers. The new way allows for the collection of pairs of sibling dependents in a single state. It is no surprise that the dynamic-programming structures and derivations of the algorithm for computing \u03b2 is the same as that of the decoding algorithm, and we omit the pseudo-code of this algorithm.\nThe algorithm for computing \u03b1 can be designed with the new dynamic programming structures. The pseudo-code of this algorithm is illustrated in Algorithm 3. We use ws,r,t to denote the weight of a sibling part (s, r, t). The computation of marginals of sibling parts is quite different from that of the first-order dependency or second-order grandchild model. For the introduction of sibling spans, two different cases should be considered: the modifiers are at the left/right side of the head. In addition, the part (s,\u2212, t), which represents that t is the inner-most modifier of s, is a special case and should be treated specifically. We can get marginals for all sibling parts with s < r < t as following:\nm(s, r, t) = \u03b2(Is,r) \u00b7 \u03b2(Sr,t) \u00b7 \u03b1(Is,t) \u00b7 ws,r,t/z(x) m(t, r, s) = \u03b2(Ss,r) \u00b7 \u03b2(It,r) \u00b7 \u03b1(It,s) \u00b7 wt,r,s/z(x) m(s,\u2212, t) = \u03b2(Ct,s+1) \u00b7 \u03b1(Is,t) \u00b7 ws,\u2212,t/z(x) m(t,\u2212, s) = \u03b2(Cs,t\u22121) \u00b7 \u03b1(It,s) \u00b7 wt,\u2212,s/z(x),\nSince each derivation is defined by a span and a split point, the complexity for training and decoding of the second-order sibling model is O(n3) time and O(n2) space.\nAlgorithm 3 Compute outside probability \u03b1 for second-order Sibling Model\nRequire: \u03b1(C0,n) = 1.0 \u03b1(Cn,0) = 1.0"}, {"heading": "1: for k = n to 1", "text": ""}, {"heading": "2: for s = 0 to n\u2212 k", "text": "3: t = s+ k\n4: \u03b1(Ss,t) = \u2211\n0\u2264r<s \u03b2(Ir,s) \u00b7 \u03b1(Ir,t) \u00b7 wr,s,t +\n\u2211\nt<r\u2264n \u03b2(Ir,t) \u00b7 \u03b1(Ir,s) \u00b7 wr,t,s\n5: \u03b1(Cs,t) = \u2211\nt<r\u2264n \u03b2(Cr,t+1) \u00b7 \u03b1(Ss,r) +\n\u2211\n0\u2264r<s \u03b2(Ir,s) \u00b7 \u03b1(Cr,t)\n: + \u03b2(Ct+1,t+1) \u00b7 \u03b1(It+1,s) \u00b7 wt+1,\u2212,s\n6: \u03b1(Ct,s) = \u2211\n0\u2264r<s \u03b2(Cr,s\u22121) \u00b7 \u03b1(Sr,t) +\n\u2211\nt<r\u2264n \u03b2(Ir,t) \u00b7 \u03b1(Cr,s)\n: + \u03b2(Cs\u22121,s\u22121) \u00b7 \u03b1(Is\u22121,t) \u00b7 ws\u22121,\u2212,t\n7: \u03b1(Is,t) = \u2211\nt<r\u2264n \u03b2(St,r) \u00b7 \u03b1(Is,r) \u00b7 ws,t,r +\n\u2211\nt\u2264r\u2264n \u03b2(Cr,t) \u00b7 \u03b1(Cs,r)\n8: \u03b1(It,s) = \u2211 0\u2264r<s \u03b2(Sr,s) \u00b7 \u03b1(It,r) \u00b7 wt,s,r + \u2211 0\u2264r\u2264s \u03b2(Cs,r) \u00b7 \u03b1(Ct,r)"}, {"heading": "9: end for", "text": ""}, {"heading": "10: end for", "text": ""}, {"heading": "4.3 Model of Grand-Sibling Factorization", "text": "We now describe the algorithms of the third-order grand-sibling model. In this model, each tree is decomposed into grand-sibling parts, which enclose grandchild and sibling parts. Formally, a grand-sibling is a 4-tuple of indices (g, s, r, t) where (s, r, t) is a sibling part and (g, s, t) is a grandchild part. The algorithm of this factorization can be designed based on the algorithms for grandchild and sibling models.\nLike the extension of the second-order sibling model to the first-order dependency model, we define the sibling g-spans Sgs,t, where Ss,t is a normal sibling span and g is the index of the head of s and t, which lies outside the region [s, t] with the implication that (g, s, t) forms a valid sibling part. This model can also be treated as an extension of the sibling model by augmenting it with a grandparent index for each span, like the behavior of the grandchild model for the firstorder dependency model. Figure 2 provides the graphical specification of this factorization for dynamic-programming, too. The overall structures and derivations is similar to the second-order sibling model, with the addition of grandparent indices. The same to the second-order grandchild model, the grandparent indices can be set deterministically in all cases.\nThe pseudo-code of the algorithm for the computation of the outside probability \u03b1 is illustrated in Algorithm 4. It should be noted that in this model there are two types of special cases\u2014one is the sibling-g-span Sgs,t with g = 0 or g = n, as the complete g-span C g s,t with g = 0 or g = n in the second-order grandchild model; another is the inner-most modifier case as the second-order sibling model. We use wgs,r,t to denote the weight of a grand-sibling part\nAlgorithm 4 Compute outside probability \u03b1 for third-order Grand-sibling Model\nRequire: \u03b1(I0,n) = 1.0, \u03b1(In,0) = 1.0, \u03b1(C0,n) = 1.0, \u03b1(Cn,0) = 1.0\n1: for k = n to 1\n2: s = n\u2212 k, t = k 3: \u03b1(I0,t) = \u03b2(C0t,n) \u00b7 \u03b1(C0,n) + \u2211\nt<r\u2264n \u03b2(S0r,t) \u00b7 \u03b1(I0,r) \u00b7w 0 0,t,r\n4: \u03b1(In,s) = \u03b2(Cn0,s) \u00b7 \u03b1(Cn,0) + \u2211\n0\u2264r<s \u03b2(Snr,s) \u00b7 \u03b1(In,r) \u00b7w n n,s,r\n5: end for\nRequire: \u03b1(I00,n) = 1.0, \u03b1(I n n,0) = 1.0\n6: for k = n to 1\n7: for s = 0 to n\u2212 k\n8: t = s+ k\n9: for g < s\n10: \u03b1(Sgs,t) = \u2211\nr<g\u2228r>t \u03b2(Irg,s) \u00b7 \u03b1(I r g,t) \u00b7w r g,s,t if g = 0 \u03b1(S g s,t) + = \u03b2(I0,s) \u00b7 \u03b1(I0,t) \u00b7 w 0 0,s,t\n11: \u03b1(Cgs,t) = \u2211\nt<r\u2264n \u03b2(Cgr,t+1) \u00b7 \u03b1(S g s,r) +\n\u2211\nr<g\u2228r>t \u03b2(Irg,s) \u00b7 \u03b1(C r g,t)\n12: \u03b1(Cgt,s) = \u2211\ng<r<s\n\u03b2(Cgr,s\u22121) \u00b7 \u03b1(S g r,t) if g = s\u2212 1 \u03b1(C g t,s) + =\n\u2211\nr<g\u2228r>t \u03b2(Cgs,s) \u00b7 \u03b1(I r g,t) \u00b7w r g,\u2212,t\n13: \u03b1(Igs,t) = \u2211\nt<r\u2264n \u03b2(Sst,r) \u00b7 \u03b1(I g s,r) \u00b7w g s,t,r +\n\u2211\nt\u2264r\u2264n \u03b2(Cst,r) \u00b7 \u03b1(C g s,r)\n14: \u03b1(Igt,s) = \u2211\ng<r<s\n\u03b2(Str,s) \u00b7 \u03b1(I g t,r) \u00b7w g t,s,r +\n\u2211\ng<r\u2264s \u03b2(Cts,r) \u00b7 \u03b1(C g t,r)\n15: end for\n16: for g > t\n17: \u03b1(Sgs,t) = \u2211\nr<s\u2228r>g \u03b2(Irg,t) \u00b7 \u03b1(I r g,s) \u00b7w r g,t,s if g = n \u03b1(S g s,t) + = \u03b2(In,t) \u00b7 \u03b1(In,s) \u00b7w n n,t,s\n18: \u03b1(Cgs,t) = \u2211\nt<r<g\n\u03b2(Cgr,t+1) \u00b7 \u03b1(S g s,r) if g = t+ 1 \u03b1(C g s,t) + =\n\u2211\nr<s\u2228r>g \u03b2(Cgt,t) \u00b7 \u03b1(I r s,g) \u00b7 w r g,\u2212,s\n19: \u03b1(Cgt,s) = \u2211\n0\u2264r<s \u03b2(Cgr,s\u22121) \u00b7 \u03b1(S g r,t) +\n\u2211\nr<s\u2228r>g \u03b2(Irg,t) \u00b7 \u03b1(C r g,s)\n20: \u03b1(Igs,t) = \u2211\nt<r<g\n\u03b2(Sst,r) \u00b7 \u03b1(I g s,r) \u00b7w g s,t,r +\n\u2211\nt\u2264r<g \u03b2(Cst,r) \u00b7 \u03b1(C g s,r)\n21: \u03b1(Igt,s) = \u2211\n0\u2264r<s \u03b2(Str,s) \u00b7 \u03b1(I g t,r) \u00b7w g t,s,r +\n\u2211\n0\u2264r\u2264s \u03b2(Cts,r) \u00b7 \u03b1(C g t,r)\n22: end for\n23: end for\n24: end for\n(g, s, r, t) and the marginals for all grand-sibling parts with s < r < t can be computed as follows:\nm(g, s, r, t) = \u03b2(Igs,r) \u00b7 \u03b2(S s r,t) \u00b7 \u03b1(I g s,t) \u00b7 w g s,r,t/z(x) m(g, t, r, s) = \u03b2(Sts,r) \u00b7 \u03b2(I g t,r) \u00b7 \u03b1(I g t,s) \u00b7 w g t,r,s/z(x) m(g, s,\u2212, t) = \u03b2(Cst,s+1) \u00b7 \u03b1(I g s,t) \u00b7 w g s,\u2212,t/z(x) m(g, t,\u2212, s) = \u03b2(Cts,t\u22121) \u00b7 \u03b1(I g t,s) \u00b7 w g t,\u2212,s/z(x),\nDespite the extension to third-order parts, each derivation is still defined by a g-span and a split point as in second-order grandchild model, so training and decoding of the grand-sibling model still requires O(n4) time and O(n3) space."}, {"heading": "5. Experiments for Dependency Parsing", "text": ""}, {"heading": "5.1 Data Sets", "text": "We implement and evaluate the proposed algorithms of the three factored models (sibling, grandchild and grand-sibling) on the Penn English Treebank (PTB version 3.0) (Marcus, Santorini, and Marcinkiewicz 1993), the Penn Chinese Treebank (CTB version 5.0) (Xue et al. 2005) and Prague Dependency Treebank (PDT) (Hajic\u030c 1998; Hajic\u030c et al. 2001).\nFor English, the PTB data is prepared by using the standard split: sections 2-21 are used for training, section 22 is for development, and section 23 for test. Dependencies are extracted by using Penn2Malt2 tool with standard head rules (Yamada and Matsumoto 2003). For Chinese, we adopt the data split from Zhang and Clark (2009), and we also used the Penn2Malt tool to convert the data into dependency structures. Since the dependency trees for English and Chinese are extracted from phrase structures in Penn Treebanks, they contain no crossing edges by construction. For Czech, the PDT has a predefined training, developing and testing split. we \"projectivized\" the training data by finding best-match projective trees3.\n2 http://w3.msi.vxu.se/\u02dcnivre/research/Penn2Malt.html 3 Projective trees for training sentences are obtained by running the first-order projective parser with an oracle model\nthat assigns a score of +1 to correct edges and -1 otherwise.\nAll experiments were running using every single sentence in each set of data regardless of length. Parsing accuracy is measured with unlabeled attachment score (UAS): the percentage of words with the correct head, root accuracy (RA): the percentage of correctly identified root words, and the percentage of complete matches (CM). Following the standard of previous work, we did not include punctuation4 in the calculation of accuracies for English and Chinese. The detailed information of each treebank is showed in Table 1."}, {"heading": "5.2 Feature Space", "text": "Following previous work for high-order dependency parsing (McDonald and Pereira 2006; Carreras 2007; Koo and Collins 2010), higher-order factored models captures not only features associated with corresponding higher order parts, but also the features of relevant lower order parts that are enclosed in its factorization. For example, third-order grand-sibling model evaluates parts for dependencies, siblings, grandchildren and grand-siblings, so that the feature function of a dependency parse is given by:\nF (y,x) = \u2211\n(s,t)\u2208y\nfdep(s, t,x)\n+ \u2211\n(s,r,t)\u2208y\nfsib(s, r, t,x)\n+ \u2211\n(g,s,t)\u2208y\nfgch(g, s, t,x)\n+ \u2211\n(g,s,r,t)\u2208y\nfgsib(g, s, r, t,x)\nwhere fdep, fsib, fgch, and fgsib are the feature functions of dependency, sibling, grandchild, and grand-sibling parts.\nFirst-order dependency features fdep, second-order sibling features fsib and second-order grandchild features fgch are based on feature sets from previous work (McDonald, Crammer, and Pereira 2005; McDonald and Pereira 2006; Carreras 2007), to which we added lexicalized versions of several features. For instance, our first-order feature set contains lexicalized \u201cin-between\u201d features that recognize word types that occur between the head and modifier words in an attachment decision, while previous work has defined in-between features only for POS tags. As another example, the second-order features fsib and fgch contains lexical trigram features, which also excluded in the feature sets of previous work. The third-order grand-sibling features are based on Koo and Collins (Koo and Collins 2010). All feature templates for used in our parsers are outlined in Table 2.\nAccording to Table 2, several features in our parser depend on part-of-speech (POS) tags of input sentences. For English, POS tags are automatically assigned by the SVMTool tagger (Gimenez and Marquez 2004); For Chinese, we used gold-standard POS tags in CTB. Following Koo and Collins (2010), two versions of POS tags are used for any features involve POS: one using is normal POS tags and another is a coarsened version of the POS tags.5\n4 English evaluation ignores any token whose gold-standard POS is one of {\u201d \u201c : , .}; Chinese evaluation ignores any token whose tag is \u201cPU\u201d 5 For English, we used the first two characters, except PRP and PRP$; for Czech, we used the first character of the tag; for Chinese, we dropped the last character, except PU and CD."}, {"heading": "5.3 Model Training", "text": "Since the log-likelihood L(\u03bb) is a convex function, gradient descent methods can be used to search for the global minimum. The method of parameter estimation for our models is the limited memory BFGS algorithm (L-BFGS) (Nash and Nocedal 1991), with L2 regularization. L-BFGS algorithm is widely used for large-scale optimization, as it combines fast training time with low memory requirement which is especially important for large-scale optimization problems.\nMeanwhile, L-BFGS can achieve highly competitive performance. Development sets are used for tuning the hyper-parameter C which dictates the level of the regularization in the model.\nFor the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010). Each parser is trained for 10 iterations and selects parameters from the iteration that achieves the highest parsing performance on the development set.\nThe feature sets were fixed for all three languages. For practical reason, we exclude the sentences containing more than 100 words in all the training data sets of Czech, English and Chinese in all experiments."}, {"heading": "5.4 Results and Analysis", "text": "Table 3 shows the results of three different factored parsing models trained by three different learning algorithms on the three treebanks of PTB, CTB and PDT. Our parsing models trained by L-BFGS method achieve significant improvement on parsing performance of the parsing models trained by AP for all the three treebanks, and obtain parsing performance competitive with the parsing models trained by MIRA. For example, for the third-order grand-sibling model, the parsers trained by L-BFGS method improve the UAS of 0.6% for PTB, 2.1% for CTB and 1.1% for PDT, compared with the parsers trained by AP. For the parsers trained by MIRA, our parsers achieve the same UAS for PTB, and higher parsing accuracies (about 0.2% better) for both CTB\nand PDT. Moreover, it should be noticed that our algorithms achieve significant improvement of RA and CM on all three treebanks for the parsers trained by MIRA, although the parsers trained by L-BFGS and MIRA exhibit no statistically significant different in the parsing performance of UAS.\nAs mentioned above, parallel computation techniques could be applied to our models to speed up parser training. Table 4 lists the average training time for our three models with different number of cores. According to this table, the training time of our parsers trained by off-line LBFGS method with more than 10 cores is much less than the cost of the parsers trained by online learning methods MIRA. We omit the training time of online learning method AP, since the training times for MIRA and AP are nearly the same according to our experiences. The reason is that the time for updating parameters, which is the only difference between MIRA and AP, makes up a very small proportion (less than 10% ) of the total training time."}, {"heading": "5.5 Comparison with Previous Works", "text": "Table 5 illustrates the UAS and CM of related work on PTB, CTB and PDT for comparison. Our experimental results show an improvement in performance of English and Chinese over the results in Zhang and Clark (2008), which combining graph-based and transition-based dependency parsing into a single parser using the framework of beam-search, and Zhang and Nivre (2011), which are based on a transition-based dependency parser with rich non-local features. For English and Czech, our results are better than the results of the two third-order\nTable 5 Accuracy comparisons of different dependency parsers on PTB, CTB and PDT.\nEng Chn Cze UAS CM UAS CM UAS CM\nMcDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.5 42.1 82.5 32.6 85.2 35.9 Zhang and Clark (2008) 92.1 45.4 85.7 34.4 - - Zhang and Nivre (2011) 92.9 48.0 86.0 36.9 - - Koo and Collins (2010), model2 92.9 - - - 87.4 - Koo and Collins (2010), model1 93.0 - - - 87.4 - this paper 93.0 48.8 87.2 37.0 87.5 39.3 Koo et al. (2008)\u2217 93.2 - - - 87.1 - Suzuki et al. (2009)\u2217 93.8 - - - 88.1 - Zhang and Clark (2009)\u2217 - - 86.6 36.1 - -\ngraph-based dependency parsers in Koo and Collins (2010). The models marked * cannot be compared with our work directly, as they exploit large amount of additional information that is not used in our models, whiling our parses obtain results competitive with these works. For example, Koo et al. (2008) and Suzuki et al. (2009) make use of unlabeled data, and the parsing model of Zhang and Clark (2009) utilizes phrase structure annotations."}, {"heading": "6. Conclusion", "text": "In this article, we have described probabilistic models for high-order projective dependency parsing, obtained by relaxing the independent assumption of the previous grammatical bigram model, and have presented algorithms for computing partition functions and marginals for three factored parsing models\u2014second-order sibling and grandchild, and third-order grandsibling. Our methods achieve competitive or state-of-the-art performance on three treebanks for languages of English, Chinese and Czech. By analyzing errors on structural properties of length factors, we have shown that the parsers trained by online and off-line learning methods have distinctive error distributions despite having very similar parsing performance of UAS overall. We have also demonstrated that by exploiting parallel computation techniques, our parsing models can be trained much faster than those parsers using online training methods."}], "references": [{"title": "Experiments with a multilanguage non-projective dependency parser", "author": ["Attardi2006]Attardi", "Giuseppe"], "venue": "In Proceedings of the Tenth Conference on Natural Language Learning", "citeRegEx": "Attardi2006.Attardi and Giuseppe.,? \\Q2006\\E", "shortCiteRegEx": "Attardi2006.Attardi and Giuseppe.", "year": 2006}, {"title": "Trainable grammars for speech recognition", "author": ["K. James"], "venue": "In Proceedings of 97th meeting of the Acoustical Society of America,", "citeRegEx": "James,? \\Q1979\\E", "shortCiteRegEx": "James", "year": 1979}, {"title": "CoNLL-X shared task on multilingual dependency parsing", "author": ["Buchholz", "Marsi2006]Buchholz", "Sabine", "Erwin Marsi"], "venue": "In Proceeding of the 10th Conference on Computational Natural Language Learning", "citeRegEx": "Buchholz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Buchholz et al\\.", "year": 2006}, {"title": "Experiments with a higher-order projective dependency parser", "author": ["Carreras2007]Carreras", "Xavier"], "venue": "In Proceedings of the CoNLL Shared Task Session of EMNLP-CONLL,", "citeRegEx": "Carreras2007.Carreras and Xavier.,? \\Q2007\\E", "shortCiteRegEx": "Carreras2007.Carreras and Xavier.", "year": 2007}, {"title": "Improving graph-based dependency parsing with decision history", "author": ["Chen et al.2010]Chen", "Wenliang", "Jun\u2019ichi Kazama", "Yoshimasa Tsuruoka", "Kentaro Torisawa"], "venue": "In Proceeding of the 23rd International Conference on Computional Linguistics", "citeRegEx": "al.2010.Chen et al\\.,? \\Q2010\\E", "shortCiteRegEx": "al.2010.Chen et al\\.", "year": 2010}, {"title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms", "author": ["Collins2002]Collins", "Michael"], "venue": "In Proceedings of the 2002 Conference on Empirical Methods in Natural Language Processing (EMNLP", "citeRegEx": "Collins2002.Collins and Michael.,? \\Q2002\\E", "shortCiteRegEx": "Collins2002.Collins and Michael.", "year": 2002}, {"title": "Online passive-aggressive algorithms", "author": ["Crammer et al.2006]Crammer", "Koby", "Ofer Dekel", "Joseph Keshet", "Shai Shalev-Shwartz", "Yoram Singer"], "venue": "Jornal of Machine Learning Research,", "citeRegEx": "al.2006.Crammer et al\\.,? \\Q2006\\E", "shortCiteRegEx": "al.2006.Crammer et al\\.", "year": 2006}, {"title": "Ultraconservative online algorithms for multiclass problems", "author": ["Crammer", "Singer2003]Crammer", "Koby", "Yoram Singer"], "venue": "Journal of Machine Learining Research,", "citeRegEx": "Crammer et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Crammer et al\\.", "year": 2003}, {"title": "Three new probabilistic models for dependency parsing: An exploration", "author": ["Eisner1996]Eisner", "Jason"], "venue": "In Proceedings of the 9th International Conference on Computational Linguistics", "citeRegEx": "Eisner1996.Eisner and Jason.,? \\Q1996\\E", "shortCiteRegEx": "Eisner1996.Eisner and Jason.", "year": 1996}, {"title": "Bilexical grammars and their cubic-time parsing algorithms", "author": ["Eisner2000]Eisner", "Jason"], "venue": "Advances in Probabilistic and Other Parsing Technologies. Kluwer Academic Publishers,", "citeRegEx": "Eisner2000.Eisner and Jason.,? \\Q2000\\E", "shortCiteRegEx": "Eisner2000.Eisner and Jason.", "year": 2000}, {"title": "Large margin classification using the perceptron algorithm", "author": ["Freund", "Schapire1999]Freund", "Yoav", "Robert E. Schapire"], "venue": null, "citeRegEx": "Freund et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Freund et al\\.", "year": 1999}, {"title": "Svmtool: A general pos tagger generator based on support vector machines", "author": ["Gimenez", "Marquez2004]Gimenez", "Marquez"], "venue": "In Proceedings of the 4th International Conference of Language Resources and Evaluation", "citeRegEx": "Gimenez et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Gimenez et al\\.", "year": 2004}, {"title": "Building a syntactically annotated corpus: The Prague Dependency Treebank", "author": ["Haji\u010d1998]Haji\u010d", "Jan"], "venue": "Issues of Valency and Meaning Studies in Honor of Jarmila Panevov,", "citeRegEx": "Haji\u010d1998.Haji\u010d and Jan.,? \\Q1998\\E", "shortCiteRegEx": "Haji\u010d1998.Haji\u010d and Jan.", "year": 1998}, {"title": "The Prague Dependency Treebank 1.0 CD-ROM", "author": ["Haji\u010d et al.2001]Haji\u010d", "Jan", "Eva Haji\u010dov\u00e1", "Petr Pajas", "Jarmila Panevov\u00e1", "Petr Sgall"], "venue": "Linguistic Data Consortium, Cat. No. LDC2001T10", "citeRegEx": "al.2001.Haji\u010d et al\\.,? \\Q2001\\E", "shortCiteRegEx": "al.2001.Haji\u010d et al\\.", "year": 2001}, {"title": "Bilingually-constrained (monolingual) shift-reduce parsing", "author": ["Huang", "Jiang", "Liu2009]Huang", "Liang", "Wenbin Jiang", "Qun Liu"], "venue": "In Proceeding of EMNLP", "citeRegEx": "Huang et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2009}, {"title": "Dynamic programming for linear-time incremental parsing", "author": ["Huang", "Sagae2010]Huang", "Liang", "Kenji Sagae"], "venue": "In Proceeding of ACL 2010, page 1077l\u0301C1086,", "citeRegEx": "Huang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2010}, {"title": "Incremental dependency parsing using online learning", "author": ["Johansson", "Nugues2007]Johansson", "Richard", "Pierre Nugues"], "venue": "In Proceedings of CoNLL/EMNLP", "citeRegEx": "Johansson et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Johansson et al\\.", "year": 2007}, {"title": "Training a parser for machine translation reordering", "author": ["Katz-Brown et al.2011]Katz-Brown", "Jason", "Slav Petrov", "Ryan McDonald", "Franz Och", "David Talbot", "Hiroshi Ichikawa", "Masakazu Seno", "Hideto Kazawa"], "venue": "In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "al.2011.Katz.Brown et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al.2011.Katz.Brown et al\\.", "year": 2011}, {"title": "Simple semi-supervised dependency parsing", "author": ["Koo", "Carreras", "Collins2008]Koo", "Terry", "Xavier Carreras", "Michael Collins"], "venue": "In Proceedings of ACL-08: HLT,", "citeRegEx": "Koo et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Koo et al\\.", "year": 2008}, {"title": "Efficient third-order dependency parsers", "author": ["Koo", "Collins2010]Koo", "Terry", "Michael Collins"], "venue": "In Proceedings of 48th Meeting of the Association for Computional Linguistics", "citeRegEx": "Koo et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Koo et al\\.", "year": 2010}, {"title": "Structured predicition models via the matrix-tree theorem", "author": ["Koo et al.2007]Koo", "Terry", "Amir Globerson", "Xavier Carreras", "Michael Collins"], "venue": "In Proceedings of EMNLP-CONLL", "citeRegEx": "al.2007.Koo et al\\.,? \\Q2007\\E", "shortCiteRegEx": "al.2007.Koo et al\\.", "year": 2007}, {"title": "Building a large annotated corpus of English: the Penn Treebank", "author": ["Marcus", "Santorini", "Marcinkiewicz1993]Marcus", "Mitchell", "Beatrice Santorini", "Mary Ann Marcinkiewicz"], "venue": null, "citeRegEx": "Marcus et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Marcus et al\\.", "year": 1993}, {"title": "Online large-margin training of dependency parsers", "author": ["McDonald", "Crammer", "Pereira2005]McDonald", "Ryan", "Koby Crammer", "Fernando Pereira"], "venue": "In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics", "citeRegEx": "McDonald et al\\.,? \\Q2005\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2005}, {"title": "Characterizing the errors of data-driven dependency parsing models", "author": ["McDonald", "Nivre2007]McDonald", "Ryan", "Joakim Nivre"], "venue": "In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL", "citeRegEx": "McDonald et al\\.,? \\Q2007\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2007}, {"title": "Online learning of approximate dependency parsing algorithms", "author": ["McDonald", "Pereira2006]McDonald", "Ryan", "Fernando Pereira"], "venue": "In European Association for Computational Linguistics", "citeRegEx": "McDonald et al\\.,? \\Q2006\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2006}, {"title": "Non-projective dependency parsing using spanning tree algorithms", "author": ["McDonald et al.2005]McDonald", "Ryan", "Fernando Pereira", "Kiril Ribarov", "Jan Hajic"], "venue": "In Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language (HLT/EMNLP", "citeRegEx": "al.2005.McDonald et al\\.,? \\Q2005\\E", "shortCiteRegEx": "al.2005.McDonald et al\\.", "year": 2005}, {"title": "On the complexity of non-projective data-driven dependency parsing", "author": ["McDonald", "Satta2007]McDonald", "Ryan", "Giorgio Satta"], "venue": "In Proceedings of the 10th International Conference on Parsing Technologies,", "citeRegEx": "McDonald et al\\.,? \\Q2007\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2007}, {"title": "A numerical study of the limited memory bfgs method and truncated-newton method for large scale optimization", "author": ["Nash", "Nocedal1991]Nash", "Stephen G", "Jorge Nocedal"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "Nash et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Nash et al\\.", "year": 1991}, {"title": "Convolution kernels on constituent, dependency and sequential structures for relation extraction", "author": ["Nguyen", "Moschitti", "Riccardi2009]Nguyen", "Truc-Vien T", "Alessandro Moschitti", "Giuseppe Riccardi"], "venue": "In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Nguyen et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Nguyen et al\\.", "year": 2009}, {"title": "Deterministic dependency parsing of english text", "author": ["Nivre", "Scholz2004]Nivre", "Joakim", "Mario Scholz"], "venue": "In Proceedings of the 20th international conference on Computational Linguistics", "citeRegEx": "Nivre et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Nivre et al\\.", "year": 2004}, {"title": "Cubic-time parsing and learning algorithms for grammatical bigram models", "author": ["A. Mark"], "venue": "Technical Report,", "citeRegEx": "Mark,? \\Q2001\\E", "shortCiteRegEx": "Mark", "year": 2001}, {"title": "Automatic paraphrase acquisition from news articles", "author": ["Shinyama", "Sekine", "Sudo2002]Shinyama", "Yusuke", "Satoshi Sekine", "Kiyoshi Sudo"], "venue": "In Proceeding of the 2nd International Conference on Human Language Technology Research", "citeRegEx": "Shinyama et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Shinyama et al\\.", "year": 2002}, {"title": "Probabilistic models of nonporjective dependency trees", "author": ["Smith", "Smith2007]Smith", "David A", "Noah A. Smith"], "venue": "In Proceedings of EMNLP-CONLL", "citeRegEx": "Smith et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Smith et al\\.", "year": 2007}, {"title": "An empirial study of semi-supervised structured conditional models for dependency parsing", "author": ["Suzuki et al.2009]Suzuki", "Jun", "Hideki Isozaki", "Xavier Carreras", "Micheal Collins"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "al.2009.Suzuki et al\\.,? \\Q2009\\E", "shortCiteRegEx": "al.2009.Suzuki et al\\.", "year": 2009}, {"title": "A novel dependency-to-string model for statistical machine translation", "author": ["Xie", "Mi", "Liu2011]Xie", "Jun", "Haitao Mi", "Qun Liu"], "venue": "In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Xie et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Xie et al\\.", "year": 2011}, {"title": "The Penn Chinese TreeBank: Phrase structure annotation of a large corpus", "author": ["Xue et al.2005]Xue", "Naiwen", "Fei Xia", "Fu-Dong Chiou", "Marta Palmer"], "venue": "Natural Language Engineering,", "citeRegEx": "al.2005.Xue et al\\.,? \\Q2005\\E", "shortCiteRegEx": "al.2005.Xue et al\\.", "year": 2005}, {"title": "Statistical dependency analysis with support vector machines", "author": ["Yamada", "Matsumoto2003]Yamada", "Hiroyasu", "Yuji Matsumoto"], "venue": "In Proceedings of the 8th International Workshop on Parsing Technologies", "citeRegEx": "Yamada et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Yamada et al\\.", "year": 2003}, {"title": "A tale of two parsers: investigating and combining graph-based and transition-based dependency parsing using beam search", "author": ["Zhang", "Clark2008]Zhang", "Yue", "Stephen Clark"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "Zhang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2008}, {"title": "Transition-based parsing of Chinese treebank using a global discriminative model", "author": ["Zhang", "Clark2009]Zhang", "Yue", "Stephen Clark"], "venue": "In Proceedings of the 11th International Conference on Parsing Technologies", "citeRegEx": "Zhang et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2009}, {"title": "Transition-based dependency parsing with rich non-local features", "author": ["Zhang", "Nivre2011]Zhang", "Yue", "Joakim Nivre"], "venue": "In Proceeding of ACL", "citeRegEx": "Zhang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 22, "context": "2007), there are currently two dominant approaches for data-driven dependency parsing: local-and-greedy transitionbased algorithms (Yamada and Matsumoto 2003; Nivre and Scholz 2004; Attardi 2006; McDonald and Nivre 2007), and globally optimized graph-based algorithms (Eisner 1996; McDonald, Crammer, and Pereira 2005; McDonald et al. 2005; McDonald and Pereira 2006; Carreras 2007; Koo and Collins 2010), and graph-based parsing models have achieved state-ofthe-art accuracy for a wide range of languages.", "startOffset": 268, "endOffset": 404}, {"referenceID": 7, "context": "There have been several existing graph-based dependency parsers, most of which employed online learning algorithms such as the averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002) or Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) for learning parameters. However, One shortcoming of these parsers is that learning parameters of these models usually takes a long time (several hours for an iteration). The primary reason is that the training step cannot be performed in parallel, since for online learning algorithms, the updating for a new training instance depends on parameters updated with the previous instance. Paskin (2001) proposed a variant of the inside-outside algorithm (Baker 1979), which were applied to the grammatical bigram model (Eisner 1996).", "startOffset": 273, "endOffset": 709}, {"referenceID": 7, "context": "There have been several existing graph-based dependency parsers, most of which employed online learning algorithms such as the averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002) or Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) for learning parameters. However, One shortcoming of these parsers is that learning parameters of these models usually takes a long time (several hours for an iteration). The primary reason is that the training step cannot be performed in parallel, since for online learning algorithms, the updating for a new training instance depends on parameters updated with the previous instance. Paskin (2001) proposed a variant of the inside-outside algorithm (Baker 1979), which were applied to the grammatical bigram model (Eisner 1996). Using this algorithm, the grammatical bigram model can be learning by off-line learning algorithms. However, the grammatical bigram model is based on a strong independence assumption that all the dependency edges of a tree are independent of one another. This assumption restricts the model to first-order factorization (single edge), losing much of the contextual information in dependency tree. Chen et.al (2010) illustrated that a wide range of decision history can lead to significant improvements in accuracy for graph-based dependency parsing models.", "startOffset": 273, "endOffset": 1255}, {"referenceID": 18, "context": "2 is a generalized formulation of the grammatical bigram probabilistic model proposed in Eisner (1996), which is used by several works (Paskin 2001; Koo et al. 2007; Smith and Smith 2007). In fact, the grammatical bigram probabilistic model is a special case of our probabilistic model, by specifying the parts p as individual edges. The grammatical bigram model is based on a strong independence assumption: that all the dependency edges of a tree are independent of one another, given the sentence x. For the first-order model (part p is an individual edge), a variant of the inside-outside algorithm, which was proposed by Baker (1979) for probabilistic context-free grammars, can be applied for the computation of partition function and marginals for projective dependency structures.", "startOffset": 149, "endOffset": 639}, {"referenceID": 22, "context": "McDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges.", "startOffset": 0, "endOffset": 23}, {"referenceID": 22, "context": "McDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges. A widely-used dynamic programming algorithm (Eisner 2000) was used for decoding. This algorithm introduces two interrelated types of dynamic programming structures: complete spans, and incomplete spans (McDonald, Crammer, and Pereira 2005). Larger spans are created from two smaller, adjacent spans by recursive combination in a bottom-up procedure. The second-order sibling parser (McDonald and Pereira 2006) breaks up a dependency tree into sibling parts\u2014pairs of adjacent edges with shared head. Koo and Collins (2010) proposed a parser that factors each dependency tree into a set of grandchild parts.", "startOffset": 0, "endOffset": 657}, {"referenceID": 22, "context": "McDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges. A widely-used dynamic programming algorithm (Eisner 2000) was used for decoding. This algorithm introduces two interrelated types of dynamic programming structures: complete spans, and incomplete spans (McDonald, Crammer, and Pereira 2005). Larger spans are created from two smaller, adjacent spans by recursive combination in a bottom-up procedure. The second-order sibling parser (McDonald and Pereira 2006) breaks up a dependency tree into sibling parts\u2014pairs of adjacent edges with shared head. Koo and Collins (2010) proposed a parser that factors each dependency tree into a set of grandchild parts. Formally, a grandchild part is a triple of indices (g, s, t) where g is the head of s and s is the head of t. In order to parse this factorization, it is necessary to augment both complete and incomplete spans with grandparent indices. Following Koo and Collins (2010), we refer to these augmented structures as g-spans.", "startOffset": 0, "endOffset": 1010}, {"referenceID": 22, "context": "McDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges. A widely-used dynamic programming algorithm (Eisner 2000) was used for decoding. This algorithm introduces two interrelated types of dynamic programming structures: complete spans, and incomplete spans (McDonald, Crammer, and Pereira 2005). Larger spans are created from two smaller, adjacent spans by recursive combination in a bottom-up procedure. The second-order sibling parser (McDonald and Pereira 2006) breaks up a dependency tree into sibling parts\u2014pairs of adjacent edges with shared head. Koo and Collins (2010) proposed a parser that factors each dependency tree into a set of grandchild parts. Formally, a grandchild part is a triple of indices (g, s, t) where g is the head of s and s is the head of t. In order to parse this factorization, it is necessary to augment both complete and incomplete spans with grandparent indices. Following Koo and Collins (2010), we refer to these augmented structures as g-spans. The second-order parser proposed in Carreras (2007) is capable to score both sibling and grandchild parts with complexities of O(n) time and O(n) space.", "startOffset": 0, "endOffset": 1114}, {"referenceID": 22, "context": "McDonald et al. (2005) presented the first-order dependency parser, which decomposes a dependency tree into a set of individual edges. A widely-used dynamic programming algorithm (Eisner 2000) was used for decoding. This algorithm introduces two interrelated types of dynamic programming structures: complete spans, and incomplete spans (McDonald, Crammer, and Pereira 2005). Larger spans are created from two smaller, adjacent spans by recursive combination in a bottom-up procedure. The second-order sibling parser (McDonald and Pereira 2006) breaks up a dependency tree into sibling parts\u2014pairs of adjacent edges with shared head. Koo and Collins (2010) proposed a parser that factors each dependency tree into a set of grandchild parts. Formally, a grandchild part is a triple of indices (g, s, t) where g is the head of s and s is the head of t. In order to parse this factorization, it is necessary to augment both complete and incomplete spans with grandparent indices. Following Koo and Collins (2010), we refer to these augmented structures as g-spans. The second-order parser proposed in Carreras (2007) is capable to score both sibling and grandchild parts with complexities of O(n) time and O(n) space. However, the parser suffers an crucial limitation that it can only evaluate events of grandchild parts for outermost grandchildren. The third-order grand-sibling parser, which encloses grandchild and sibling parts into a grand-sibling part, was described in Koo and Collins (2010). This factorization defines all grandchild and sibling parts and still requires O(n) time and O(n) space.", "startOffset": 0, "endOffset": 1496}, {"referenceID": 7, "context": "For the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010).", "startOffset": 258, "endOffset": 586}, {"referenceID": 7, "context": "For the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010).", "startOffset": 258, "endOffset": 615}, {"referenceID": 7, "context": "For the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010).", "startOffset": 258, "endOffset": 646}, {"referenceID": 7, "context": "For the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010).", "startOffset": 258, "endOffset": 681}, {"referenceID": 7, "context": "For the purpose of comparison, we also run experiments on graph-based dependency parsers of the three different factorizations, employing two online learning methods: The kbest version of the Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer 2003; Crammer et al. 2006; McDonald 2006) with k = 10, and averaged structured perceptron (AP) (Freund and Schapire 1999; Collins 2002). Both the two learning methods are used in previous work for training graph-based dependency parsers and achieved highly competitive parsing accuracies\u2014k-best MIRA is used in McDonald et al. (2005), McDonald and Pereira (2006), and McDonald and Nivre (2007), and AP is used in Carreras (2007) and Koo and Collins (2010). Each parser is trained for 10 iterations and selects parameters from the iteration that achieves the highest parsing performance on the development set.", "startOffset": 258, "endOffset": 708}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.", "startOffset": 33, "endOffset": 56}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.", "startOffset": 33, "endOffset": 114}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.5 42.1 82.5 32.6 85.2 35.9 Zhang and Clark (2008) 92.", "startOffset": 33, "endOffset": 167}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.5 42.1 82.5 32.6 85.2 35.9 Zhang and Clark (2008) 92.1 45.4 85.7 34.4 - Zhang and Nivre (2011) 92.", "startOffset": 33, "endOffset": 212}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.5 42.1 82.5 32.6 85.2 35.9 Zhang and Clark (2008) 92.1 45.4 85.7 34.4 - Zhang and Nivre (2011) 92.9 48.0 86.0 36.9 - Koo and Collins (2010), model2 92.", "startOffset": 33, "endOffset": 257}, {"referenceID": 20, "context": "Eng Chn Cze UAS CM UAS CM UAS CM McDonald et al. (2005) 90.9 36.7 79.7 27.2 84.4 32.2 McDonald and Pereira (2006) 91.5 42.1 82.5 32.6 85.2 35.9 Zhang and Clark (2008) 92.1 45.4 85.7 34.4 - Zhang and Nivre (2011) 92.9 48.0 86.0 36.9 - Koo and Collins (2010), model2 92.9 - - - 87.4 Koo and Collins (2010), model1 93.", "startOffset": 33, "endOffset": 304}, {"referenceID": 18, "context": "3 Koo et al. (2008) 93.", "startOffset": 2, "endOffset": 20}, {"referenceID": 18, "context": "3 Koo et al. (2008) 93.2 - - - 87.1 Suzuki et al. (2009) 93.", "startOffset": 2, "endOffset": 57}, {"referenceID": 18, "context": "3 Koo et al. (2008) 93.2 - - - 87.1 Suzuki et al. (2009) 93.8 - - - 88.1 Zhang and Clark (2009) - - 86.", "startOffset": 2, "endOffset": 96}], "year": 2015, "abstractText": "This paper presents generalized probabilistic models for high-order projective dependency parsing and an algorithmic framework for learning these statistical models involving dependency trees. Partition functions and marginals for high-order dependency trees can be computed efficiently, by adapting our algorithms which extend the inside-outside algorithm to higher-order cases. To show the effectiveness of our algorithms, we perform experiments on three languages\u2014 English, Chinese and Czech, using maximum conditional likelihood estimation for model training and L-BFGS for parameter estimation. Our methods achieve competitive performance for English, and outperform all previously reported dependency parsers for Chinese and Czech.", "creator": "LaTeX with hyperref package"}}}