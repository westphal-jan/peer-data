{"id": "1503.05530", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Mar-2015", "title": "Exploration of the scalability of LocFaults", "abstract": "A model checker can produce a trace of counterexample, for an erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program.\n\n\n\nA model checker can produce a trace of counterexample, for an incorrect program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. The Loop 2, which is a complete rewrite of code, has an extremely limited number of instructions and is a slow implementation. This means that if an error is not present within the loop, it is still possible to detect an error by the loop's constructor.\nThis means that if an error is not present within the loop, it is still possible to detect an error by the loop's constructor. An example of this is the following:\nThe Loop 3.3 is not fully complete.\nThe loop is not fully complete.\nThe loop is not fully complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete.\nThe loop is not complete", "histories": [["v1", "Wed, 18 Mar 2015 18:40:55 GMT  (25kb)", "http://arxiv.org/abs/1503.05530v1", "in French"]], "COMMENTS": "in French", "reviews": [], "SUBJECTS": "cs.AI cs.SE", "authors": ["mohammed bekkouche"], "accepted": false, "id": "1503.05530"}, "pdf": {"name": "1503.05530.pdf", "metadata": {"source": "CRF", "title": "Exploration de la scalabilite\u0301 de LocFaults", "authors": ["Mohammed Bekkouche"], "emails": ["Mohammed.Bekkouche@unice.fr"], "sections": [{"heading": null, "text": "A model checker can produce a trace of counterexample, for a erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each MCD found. We present the times of our approach on programs with While-loops unfolded b times, and a number of diverted conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraintbased and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire\nLes erreurs dans un programme sont ine\u0301vitables, elles peuvent nuire a\u0300 son bon fonctionnement et avoir des conse\u0301quences financie\u0300res extre\u0302mement graves et pre\u0301senter une menace pour le bien-e\u0302tre humain [8]. Le lien suivant [7] cite des histoires re\u0301centes de bugs logiciels. Conse\u0301quemment, le processus de de\u0301bogage (la de\u0301tection, la localisation et la correction d\u2019erreurs) est essentiel. La localisation d\u2019erreurs est l\u2019e\u0301tape qui cou\u0302te le plus. Elle consiste a\u0300 identifier l\u2019emplacement exact des instructions suspectes [6] afin d\u2019aider l\u2019utilisateur a\u0300 comprendre pourquoi le programme a e\u0301choue\u0301, ce qui lui facilite la ta\u0302che de la correction des erreurs. En effet, quand un programme P est non conforme vis-a\u0300-vis de sa spe\u0301cification (P contient des erreurs), un ve\u0301rificateur de mode\u0300le peut produire une trace d\u2019un contre-exemple, qui est souvent longue et difficile a\u0300 comprendre me\u0302me pour les programmeurs expe\u0301rimente\u0301s. Pour re\u0301soudre ce proble\u0300me, nous avons propose\u0301 une approche [4] (nomme\u0301e LocFaults) a\u0300 base de contraintes qui explore les chemins du CFG(Control Flow Graph) du programme a\u0300 partir du contre-exemple, pour calculer les sous-ensembles minimaux permettant de restaurer la conformite\u0301 du programme vis-a\u0300-vis de sa postcondition. Assurer que notre me\u0301thode soit hautement scalable pour faire face a\u0300 l\u2019e\u0301norme complexite\u0301 des syste\u0300mes logiciels est un crite\u0300re important pour sa qualite\u0301 [1].\nDans ce papier, nous explorons le passage a\u0300 l\u2019e\u0301chelle de LocFaults sur des programmes avec boucles While de\u0301plie\u0301es b fois, et un nombre de conditions de\u0301vie\u0301es allant de 0 a\u0300 3.\nL\u2019ide\u0301e de notre approche est de re\u0301duire le proble\u0300me\nde la localisation d\u2019erreurs vers celui qui consiste a\u0300 calculer un ensemble minimal qui explique pourquoi un CSP (Constraint Satisfaction Problem) est infaisable. Le CSP repre\u0301sente l\u2019union des contraintes du contre-exemple, du programme et de l\u2019assertion viole\u0301e. L\u2019ensemble calcule\u0301 peut e\u0302tre un MCS (Minimal Correction Subset) ou MUS (Minimal Unsatisfiable Subset). En ge\u0301ne\u0301ral, tester la faisabilite\u0301 d\u2019un CSP sur un domaine fini est un proble\u0300me NP-Complet (intraitable) 1, la classe des proble\u0300mes les plus difficiles de la classe NP. Cela veut dire, expliquer l\u2019infaisabilite\u0301 dans un CSP est aussi dur, voire plus (on peut classer le proble\u0300me comme NP-Difficile). BugAssist [9] [10] est une me\u0301thode de localisation d\u2019erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Boole\u0301enne du programme en entier avec le contre-exemple. Elle devient inefficace pour les programmes de grande taille. LocFaults travaille aussi a\u0300 partir d\u2019un contre-exemple pour calculer les MCSs. La contribution de notre approche par rapport a\u0300 BugAssist peut se re\u0301sumer dans les points suivants : * Nous ne transformons pas la totalite\u0301 du programme en un syste\u0300me de contraintes, mais nous utilisons le CFG du programme pour collecter les contraintes du chemin du contre-exemple et des chemins de\u0301rive\u0301s de ce dernier, en supposant qu\u2019au plus k instructions conditionnelles sont susceptibles de contenir les erreurs. Nous calculons les MCSs uniquement sur le chemin du contre-exemple et les chemins qui corrigent le programme ;\n* Nous ne traduisons pas les instructions du programme en une formule SAT, mais pluto\u0302t en contraintes nume\u0301riques qui vont e\u0302tre manipule\u0301es par des solveurs de contraintes ; * Nous n\u2019utilisons pas des solveurs MaxSAT comme bo\u0302\u0131tes noires, mais pluto\u0302t un algorithme ge\u0301ne\u0301rique pour calculer les MCSs par l\u2019usage d\u2019un solveur de contraintes ; * Nous bornons la taille des MCSs ge\u0301ne\u0301re\u0301s et le nombre de conditions de\u0301vie\u0301es ; * Nous pouvons faire collaborer plusieurs solveurs durant le processus de localisation et prendre celui le plus performant selon la cate\u0301gorie du CSP construit. Exemple, si le CSP du chemin de\u0301tecte\u0301 est du type line\u0301aire sur les entiers, nous faisons appel a\u0300 un solveur MIP (Mixed Integer Programming) ; s\u2019il est non line\u0301aire, nous utilisons un solveur CP (Constraint Programming) ou aussi MINLP (Mixed Integer Nonlinear Programming).\nNotre expe\u0301rience pratique a montre\u0301 que toutes ces restrictions et distinctions ont permis a\u0300 LocFaults\n1. Si ce proble\u0300me pouvait e\u0302tre re\u0301solu en temps polynomial, alors tous les proble\u0300mes NP-Complet le seraient aussi.\nd\u2019e\u0302tre plus rapide et plus expressif.\nLe papier est organise\u0301 comme suit. La section 2 introduit la de\u0301finition d\u2019un MUS et MCS. Dans la section 3, nous de\u0301finirons le proble\u0300me \u2264 k-DCM. Nous expliquons une contribution du papier pour le traitement des boucles errone\u0301es, notamment le bug Off-by-one, dans la section 4. Une bre\u0300ve description de notre algorithme LocFaults est fournie dans la section 5. L\u2019e\u0301valuation expe\u0301rimentale est pre\u0301sente\u0301e dans la section 6. La section 7 parle de la conclusion et de nos travaux futurs.\n2 De\u0301finitions\nDans cette section, nous introduirons la de\u0301finition d\u2019un IIS/MUS et MCS.\nCSP Un CSP (Constraint Satisfaction Problem) P est un triplet < X,D,C > tel que : * X un ensemble de n variables x1, x2, ..., xn. * D le n-uplet < Dx1 , Dx2 , ..., Dxn >. L\u2019ensemble Dxi contient les valeurs de la variable xi.\n* C={c1, c2, ..., cn} est l\u2019ensemble des contraintes. Une solution pour P est une instanciation des variables I \u2208 D qui satisfait toutes les contraintes dans C. P est infaisable s\u2019il ne dispose pas de solutions. Un sous-ensemble de contraintes C\u2032 dans C est dit aussi infaisable pour la me\u0302me raison sauf qu\u2019ici on se limite a\u0300 l\u2019ensemble des contraintes dans C\u2032. On note par : \u2013 Sol(< X,C\u2032, D >) = \u2205, pour spe\u0301cifier que C\u2032 n\u2019a pas de solutions, et donc il est infaisable.\n\u2013 Sol(< X,C\u2032, D >) 6= \u2205, pour spe\u0301cifier que C\u2032 dispose d\u2019au moins une solution, et donc il est faisable.\nOn dit que P est en forme line\u0301aire et on note LP(Linear Program) ssi toutes les contraintes dans C sont des e\u0301quations/ine\u0301galite\u0301s line\u0301aires, il est continu si le domaine de toutes les variables est celui des re\u0301els. Si au moins une des variables dans X est du type entier ou binaire (cas spe\u0301cial d\u2019un entier), et les contraintes sont line\u0301aires, P est dit un programme line\u0301aire mixte MIP(Mixed-integer linear program). Si les contraintes sont non-line\u0301aires, on dit que P est un programme non line\u0301aire NLP(NonLinear Program).\nSoit P =< X,D,C > un CSP infaisable, on de\u0301finit pour P :\nIS Un IS(Inconsistent Set) est un sous-ensemble de contraintes infaisable dans l\u2019ensemble de contraintes infaisable C. C\u2032 est un IS ssi : * C\u2032 \u2286 C.\n* Sol(< X,C\u2032, D >) = \u2205.\nIIS ou MUS Un IIS(Irreducible Inconsistent Set) ou MUS (Minimal Unsatisfiable Subset) est un sousensemble de contraintes infaisable de C, et tous ses sous-ensembles stricts sont faisables. C\u2032 est un IIS ssi : * C\u2032 est un IS. * \u2200 C\u2032\u2032 \u2282 C\u2032.Sol(< X,C\u2032\u2032, D >) 6= \u2205, (chacune de ses parties contribue a\u0300 l\u2019infaisabilite\u0301), C\u2032 est dit irre\u0301ductible.\nMCS C\u2032 est un MCS(Minimal Correction Set) ssi : * C\u2032 \u2286 C. * Sol(< X,C\\C\u2032, D >) 6= \u2205. * \u2204 C\u2032\u2032 \u2282 C\u2032 tel que Sol(< X,C\\C\u2032\u2032, D >) 6= \u2205.\n3 Le proble\u0300me \u2264 k-DCM\nE\u0301tant donne\u0301 un programme errone\u0301 mode\u0301lise\u0301 en un CFG 2 G = (C,A,E) : C est l\u2019ensemble des n\u0153uds conditionnels ; A est l\u2019ensemble des blocs d\u2019affectation ; E est l\u2019ensemble des arcs, et un contre-exemple. Une DCM (De\u0301viation de Correction Minimale) est un ensemble D \u2286 C telle que la propagation du contreexemple sur l\u2019ensemble des instructions de G a\u0300 partir de la racine, tout en ayant nie\u0301 chaque condition 3 dans D, permet en sortie de satisfaire la postcondition. Elle est dite minimale (ou irre\u0301ductible) dans le sens ou\u0300 aucun e\u0301le\u0301ment ne peut e\u0302tre retire\u0301 de D sans que celle-ci ne perde cette proprie\u0301te\u0301. En d\u2019autres termes,D est une correction minimale du programme dans l\u2019ensemble des conditions. La taille d\u2019une de\u0301viation minimale est son cardinal. Le proble\u0300me \u2264 k-DCM consiste a\u0300 trouver toutes les DCMs de taille infe\u0301rieure ou e\u0301gale a\u0300 k.\nExemple, le CFG du programme AbsMinus (voir fig. 2) posse\u0300de une de\u0301viation minimale de taille 1 pour le contre-exemple {i = 0, j = 1}. Certes, la de\u0301viation {i0 \u2264 j0,k1 = 1 \u2227 i0 6= j0} permet de corriger le programme, mais elle n\u2019est pas minimale ; la seule de\u0301viation minimale pour ce programme est {k1 = 1 \u2227 i0 6= j0}.\nLe tableau ci-dessous re\u0301capitule le de\u0301roulement de LocFaults pour le programme AbsMinus, avec au plus 2 conditions de\u0301vie\u0301es a\u0300 partir du contre-exemple suivant {i = 0, j = 1}.\n2. Nous utilisons la transformation en forme DSA [5] qui assure que chaque variable est affecte\u0301e une seule fois sur chaque chemin du CFG.\n3. On nie la condition afin de prendre la branche oppose\u0301e a\u0300 celle ou\u0300 on devait aller.\n1 c l a s s AbsMinus { 2 /\u2217@ ensure s 3 @ (( i<j )==>(\\ r e s u l t==j\u2212 i ) )&& 4 @ (( i>=j )==>(\\ r e s u l t==i \u2212j ) ) ; \u2217/ 5 i n t AbsMinus ( in t i , i n t j ){ 6 i n t r e s u l t ; 7 i n t k = 0 ; 8 i f ( i <= j ) { 9 k = k+2;// e r r o r :\nshould be k=k+1 10 } 11 i f (k == 1 && i != j ) { 12 r e su l t = j\u2212i ; 13 } 14 e l s e { 15 r e su l t = i\u2212j ; 16 } 17 } 18 }\nFigure 1 \u2013 Le programme AbsMinus\nk0 = 0\ni0 \u2264 j0\nk1 = k0 + 2 Error k1 = k0\nk1 = 1 \u2227 i0! = j0\nr1 = j0 \u2212 i0 r1 = i0 \u2212 j0\nPOST :{r1 == |i \u2212 j|}\nIf Else\nIf Else\nFigure 2 \u2013 Le CFG DSA de AbsMinus\n{(i0 == 0) \u2227 (j0 == 1)}\nk0 = 0\ni0 \u2264 j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 \u2227 i0! = j0\nr1 = j0 \u2212 i0 r1 = i0 \u2212 j0\n{r1 == |i \u2212 j|}\nIf Else\nIf Else\nFigure 3 \u2013 Le chemin du contre-exemple\n{(i0 == 0) \u2227 (j0 == 1)}\nk0 = 0\ni0 \u2264 j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 \u2227 i0! = j0\nr1 = j0 \u2212 i0 r1 = i0 \u2212 j0\n{r1 == |i \u2212 j|} is UNSAT\nIf Else\nIf Else\nFigure 4 \u2013 Le chemin obtenu en de\u0301viant la condition i0 \u2264 j0\nConditions de\u0301vie\u0301es DCM MCS Figure\n\u2205 / {r1 = i0 \u2212 j0 : 15} fig. 3 {i0 \u2264 j0 : 8} Non / fig. 4 {k1 = 1 \u2227 i0! = j0 : 11} Oui {k0 = 0 : 7}, fig. 5\n{k1 = k0 + 2 : 9}\n{i0 \u2264 j0 : 8, Non / fig. 6 k1 = 1 \u2227 i0! = j0 : 11}\nNous avons affiche\u0301 les conditions de\u0301vie\u0301es, si elles constituent une de\u0301viation minimale ou non, les MCSs calcule\u0301s a\u0300 partir du syste\u0300me construit : voir respectivement les colonnes 1, 2 et 3. La colonne 4 indique la figure qui illustre le chemin explore\u0301 pour chaque de\u0301viation. Sur la premie\u0300re et la troisie\u0300me colonne, nous avons affiche\u0301 en plus de l\u2019instruction sa\nligne dans le programme. Exemple, la premie\u0300re ligne dans le tableau montre qu\u2019il y a un seul MCS trouve\u0301 ({r1 = i0 \u2212 j0 : 15}) sur le chemin du contre-exemple.\n4 Traitement des boucles\nDans le cadre du Bounded Model Checking (BMC) pour les programmes, le de\u0301pliage peut e\u0302tre applique\u0301 au programme en entier comme il peut e\u0302tre applique\u0301 aux boucles se\u0301pare\u0301ment [1]. Notre approche de localisation d\u2019erreurs, LocFaults [3] [4], se place dans la deuxie\u0300me de\u0301marche ; c\u2019est-a\u0300-dire, nous utilisons une borne b pour de\u0301plier les boucles en les remplac\u0327ant par des imbrications de conditionnelles de profondeur b. Conside\u0301rons le programme Minimum (voir fig. 7) contenant une seule boucle, qui calcule le minimum dans un tableau d\u2019entiers. L\u2019effet sur le graphe de flot de contro\u0302le du programme Minimum avant et apre\u0300s le de\u0301pliage est illustre\u0301 sur les figures respectivement 7 et 8 : la boucle While est de\u0301plie\u0301e 3 fois, tel que 3 est le nombre d\u2019ite\u0301rations ne\u0301cessaires a\u0300 la boucle pour calculer la valeur minimum dans un tableau de taille 4 dans le pire des cas.\nLocFaults prend en entre\u0301e le CFG du programme errone\u0301, CE un contre-exemple, bdcm : une borne sur le nombre de conditions de\u0301vie\u0301es, bmcs : une borne sur la taille des MCSs calcule\u0301s. Il permet d\u2019explorer le CFG en profondeur en de\u0301viant au plus bdcm conditions par rapport au comportement du contre-exemple : * Il propage le contre-exemple jusqu\u2019a\u0300 la postcondition. Ensuite, il calcule les MCSs sur le CSP du chemin ge\u0301ne\u0301re\u0301 pour localiser les erreurs sur le chemin du contre-exemple.\n* Il cherche a\u0300 e\u0301nume\u0301rer les ensembles \u2264 bdcm-DCM. Pour chaque DCM trouve\u0301e, il calcule les MCSs dans le chemin qui arrive a\u0300 la dernie\u0300re condition de\u0301vie\u0301e et qui permet de prendre le chemin de la de\u0301viation.\nParmi les erreurs les plus courantes associe\u0301es aux boucles selon [2], le bug Off-by-one, c\u2019est-a\u0300-dire, des boucles qui s\u2019ite\u0300rent une fois de trop ou de moins. Cela peut e\u0302tre du\u0302 a\u0300 une mauvaise initialisation des variables de contro\u0302le de la boucle, ou a\u0300 une condition incorrecte de la boucle. Le programme Minimum pre\u0301sente un cas de ce type d\u2019erreur. Il est errone\u0301 a\u0300 cause de sa boucle While, l\u2019instruction falsifie\u0301e se situe sur la condition de la boucle (ligne 9) : la condition correcte doit e\u0302tre (i < tab.length) (tab.length est le nombre d\u2019e\u0301le\u0301ments\ndu tableau tab). A\u0300 partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustre\u0301 sur la figure 8 le chemin fautif initial (voir le chemin colore\u0301 en rouge), ainsi que la de\u0301viation pour laquelle la postcondition est satisfaisable (la de\u0301-\nviation ainsi que le chemin au-dessus de la condition de\u0301vie\u0301e sont illustre\u0301s en vert).\nNous affichons dans le tableau ci-dessous les chemins errone\u0301s ge\u0301ne\u0301re\u0301s (la colonne PATH) ainsi que les MCSs calcule\u0301s (la colonne MCSs) pour au plus 1 condition de\u0301vie\u0301e par rapport au comportement du contreexemple. La premie\u0300re ligne correspond au chemin du contre-exemple ; la deuxie\u0300me correspond au chemin obtenu en de\u0301viant la condition {i2 \u2264 tab0.length\u2212 1}.\nPATH MCSs\n{CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1\n{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1,\nmin1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2,\nPOST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]}\n{CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1},\u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1},min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1}i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.length \u2212 1)]\nLocFaults a permis d\u2019identifier un seul MCS sur le chemin du contre-exemple qui contient la contrainte min2 = tab0[i1], l\u2019instruction de la ligne 11 dans la deuxie\u0300me ite\u0301ration de la boucle de\u0301plie\u0301e. Avec une condition de\u0301vie\u0301e, l\u2019algorithme suspecte la troisie\u0300me condition de la boucle de\u0301plie\u0301e, i2 < tab0.length \u2212 1 ; en d\u2019autres termes, il faut une nouvelle ite\u0301ration pour satisfaire la postcondition.\nCet exemple montre un cas d\u2019un programme avec une boucle errone\u0301e : l\u2019erreur est sur le crite\u0300re d\u2019arre\u0302t, elle ne permet pas en effet au programme d\u2019ite\u0301rer jusqu\u2019au dernier e\u0301le\u0301ment du tableau en entre\u0301e. LocFaults avec son me\u0301canisme de de\u0301viation arrive a\u0300 supporter ce type d\u2019erreur avec pre\u0301cision. Il fournit a\u0300 l\u2019utilisateur non seulement les instructions suspectes dans la boucle non de\u0301plie\u0301e du programme original, mais aussi des informations sur les ite\u0301rations ou\u0300 elles se situent\nconcre\u0300tement en de\u0301pliant la boucle. Ces informations pourraient e\u0302tre tre\u0300s utiles pour le programmeur pour mieux comprendre les erreurs dans la boucle.\n5 Algorithme ame\u0301liore\u0301\nNotre but consiste a\u0300 trouver les DCMs de taille infe\u0301rieure a\u0300 une borne k ; en d\u2019autres termes, on cherche a\u0300 donner une solution au proble\u0300me pose\u0301 ci-dessus (\u2264 k-DCM). Pour cela, notre algorithme (nomme\u0301 LocFaults) parcourt en profondeur le CFG et ge\u0301ne\u0300re les chemins ou\u0300 au plus k conditions sont de\u0301vie\u0301es par rapport au comportement du contre-exemple.\nPour ame\u0301liorer l\u2019efficacite\u0301, notre solution heuristique proce\u0300de de fac\u0327on incre\u0301mentale. Elle de\u0301vie successivement de 0 a\u0300 k conditions et elle recherche les MCSs pour les chemins correspondants. Toutefois, si a\u0300 l\u2019e\u0301tape k LocFaults a de\u0301vie\u0301 une condition ci et que cela a cor-\nrige\u0301 le programme, elle n\u2019explorera pas a\u0300 l\u2019e\u0301tape k\u2032 avec k\u2032 > k les chemins qui impliquent une de\u0301viation de la condition ci. Pour cela, nous ajoutons la cardinalite\u0301 de la de\u0301viation minimale trouve\u0301e (k) comme information sur le n\u0153ud de ci.\nNous allons sur un exemple illustrer le de\u0301roulement de notre approche, voir le graphe sur la figure 9. Chaque cercle dans le graphe repre\u0301sente un n\u0153ud conditionnel visite\u0301 par l\u2019algorithme. L\u2019exemple ne montre pas les blocs d\u2019affectations, car nous voulons illustrer uniquement comment nous trouverons les de\u0301viations de correction minimales d\u2019une taille borne\u0301e de la manie\u0300re cite\u0301e ci-dessus. Un arc reliant une condition c1 a\u0300 une autre c2 illustre que c2 est atteinte par l\u2019algorithme. Il y a deux fac\u0327ons, par rapport au comportement du contre-exemple, par lesquelles LocFaults arrive a\u0300 la condition c2 :\n1. en suivant la branche normale induite par la condition c1 ;\n2. en suivant la branche oppose\u0301e.\nLa valeur de l\u2019e\u0301tiquette des arcs pour le cas (1) (resp. (2)) est \u201dnext\u201d (resp. \u201ddevie\u201d).\n\u2013 A\u0300 l\u2019e\u0301tape k = 5, notre algorithme a identifie\u0301 deux de\u0301viations minimales de taille e\u0301gale a\u0300 5 :\n1. D1 = {1, 2, 3, 4, 7}, le n\u0153ud \u201d7\u201d est marque\u0301 par la valeur 5 ;\n2. D2 = {8, 9, 11, 12, 7}, elle a e\u0301te\u0301 autorise\u0301e, car la valeur de la marque du n\u0153ud \u201d7\u201d est e\u0301gale a\u0300 la cardinalite\u0301 de D2.\n\u2013 A\u0300 l\u2019e\u0301tape k = 6, l\u2019algorithme a suspendu la de\u0301viation suivante D3 = {8, 13, 14, 15, 16, 7}, car la cardinalite\u0301 de D3 est supe\u0301rieure strictement a\u0300 la valeur de l\u2019e\u0301tiquette du n\u0153ud \u201d7\u201d.\n6 Expe\u0301rience pratique\nPour e\u0301valuer la scalabilite\u0301 de notre me\u0301thode, nous avons compare\u0301 ses performances avec celles de BugAssist 4 sur deux ensembles de benchmarks 5. * Le premier benchmark est illustratif, il contient un ensemble de programmes sans boucles ;\n* Le deuxie\u0300me benchmark inclut 19, 49 et 91 variations pour respectivement les programmes BubbleSort, Sum et SquareRoot. Ces programmes contiennent des boucles pour e\u0301tudier le passage a\u0300 l\u2019e\u0301chelle de notre approche par rapport a\u0300 BugAssist. Pour augmenter la complexite\u0301 d\u2019un programme, nous augmentons le nombre d\u2019ite\u0301rations dans les boucles a\u0300 l\u2019exe\u0301cution de chaque outil ; nous utilisons la me\u0302me borne de de\u0301pliage des boucles pour LocFaults et BugAssist.\nPour ge\u0301ne\u0301rer le CFG et le contre-exemple, nous utilisons l\u2019outil CPBPV [11] (Constraint-Programming Framework for Bounded Program Verification). LocFaults et BugAssist travaillent respectivement sur des programmes Java et C. Pour que la comparaison soit juste, nous avons construit pour chaque programme deux versions e\u0301quivalentes : * une version en Java annote\u0301e par une spe\u0301cification JML ;\n* une version en ANSI-C annote\u0301e par la me\u0302me spe\u0301cification mais en ACSL. Les deux versions ont les me\u0302mes nume\u0301ros de lignes d\u2019instructions, notamment des erreurs. La pre\u0301condition spe\u0301cifie le contre-exemple employe\u0301 pour le programme.\nPour calculer les MCSs, nous avons utilise\u0301 les solveurs IBM ILOG MIP 6 et CP 7 de CPLEX. Nous\n4. L\u2019outil BugAssist est disponible a\u0300 l\u2019adresse : http:// bugassist.mpi-sws.org/\n5. Le code source de l\u2019ensemble de programmes est disponible a\u0300 l\u2019adresse : http://www.i3s.unice.fr/~bekkouch/ Benchs_Mohammed.html\n6. Disponible a\u0300 l\u2019adresse http ://www01.ibm.com/software/commerce/optimization/cplexoptimizer/\n7. Disponible a\u0300 l\u2019adresse http ://www01.ibm.com/software/commerce/optimization/cplex-cp-\navons adapte\u0301 et imple\u0301mente\u0301 l\u2019algorithme de Liffiton et Sakallah [12], voir alg. 1. Cette imple\u0301mentation prend en entre\u0301e l\u2019ensemble de contraintes infaisable qui correspond au chemin identifie\u0301 (C), et bmcs : la borne sur la taille des MCSs calcule\u0301s. Chaque contrainte ci dans le syste\u0300me construit C est augmente\u0301e par un indicateur yi pour donner yi \u2192 ci dans le nouveau syste\u0300me de contraintes C\u2032. Affecter a\u0300 yi la valeur V rai implique la contrainte ci ; en revanche, affecter a\u0300 yi la valeur Faux implique la suppression de la contrainte ci. Un MCS est obtenu en cherchant une affectation qui satisfait le syste\u0300me de contraintes avec un ensemble minimal d\u2019indicateurs de contraintes affecte\u0301s avec Faux. Pour limiter le nombre de variables indicateurs de contraintes qui peuvent e\u0302tre assigne\u0301es a\u0300 Faux, on utilise la contrainte AtMost(\u00acy1,\u00acy2, ...,\u00acyn, k) (voir la ligne 5), le syste\u0300me cre\u0301e\u0301 est note\u0301 dans l\u2019algorithme C\u2032k (ligne 5). Chaque ite\u0301ration de la boucle While (lignes 6 \u2212 19) permet de trouver tous les MCSs de taille k, k est incre\u0301mente\u0301 de 1 apre\u0300s chaque ite\u0301ration. Apre\u0300s chaque MCS trouve\u0301 (lignes 8\u2212 13), une contrainte de blocage est ajoute\u0301e a\u0300 C\u2032k et C\n\u2032 pour empe\u0302cher de trouver ce nouveau MCS dans les prochaines ite\u0301rations (lignes 15 \u2212 16). La premie\u0300re boucle (lignes 4 \u2212 19) s\u2019ite\u0300re jusqu\u2019a\u0300 ce que tous les MCSs de C soient ge\u0301ne\u0301re\u0301s (C\u2032 devient infaisable) ; elle peut s\u2019arre\u0302ter aussi si les MCSs de taille infe\u0301rieure ou e\u0301gale bmcs sont obtenus (k > bmcs).\n1 Fonction MCS(C,bmcs ) Entre\u0301es: C : Ensemble de contraintes infaisable, bmcs : Entier Sorties: MCS : Liste de MCSs de C de cardinalite\u0301 infe\u0301rieure a\u0300 bmcs 2 de\u0301but 3 C\u2032 \u2190 AddYVars(C) ; MCS \u2190 \u2205 ; k \u2190 1 ; 4 tant que SAT(C\u2032) \u2227 k \u2264 bmcs faire 5 C\u2032 k \u2190 C\u2032 \u2227 AtMost({\u00acy1,\u00acy2, ...,\u00acyn},k) 6 tant que SAT(C\u2032 k ) faire 7 newMCS \u2190 \u2205 8 pour chaque indicateur yi faire 9 % yi est l\u2019indicateur de la contrainte ci \u2208 C, et val(yi) la\nvaleur de yi dans la solution calcule\u0301e de C \u2032 k .\n10 si val(yi) = 0 alors 11 newMCS \u2190 newMCS \u222a {ci}. 12 fin 13 fin 14 MCS.add(newMCS). 15 C\u2032 k \u2190 C\u2032 k \u2227 BlockingClause(newMCS) 16 C\u2032 \u2190 C\u2032 \u2227 BlockingClause(newMCS) 17 fin 18 k \u2190 k + 1 19 fin 20 retourner MCS 21 fin\nAlgorithm 1: Algorithme de Liffiton et Sakallah\nBugAssist utilise l\u2019outil CBMC [13] pour ge\u0301ne\u0301rer la trace errone\u0301e et les donne\u0301es d\u2019entre\u0301e. Pour le solveur Max-SAT, nous avons utilise\u0301 MSUnCore2 [14].\nLes expe\u0301rimentations ont e\u0301te\u0301 effectue\u0301es avec un processeur Intel Core i7-3720QM 2.60 GHz avec 8 GO de RAM.\noptimizer/\n6.1 Le benchmark sans boucles\nCette partie sert a\u0300 illustrer l\u2019ame\u0301lioration apporte\u0301e a\u0300 LocFaults pour re\u0301duire le nombre d\u2019ensembles suspects fournis a\u0300 l\u2019utilisateur : a\u0300 une e\u0301tape donne\u0301e de l\u2019algorithme, le n\u0153ud dans le CFG du programme qui permet de de\u0301tecter une DCM sera marque\u0301 par le cardinal de cette dernie\u0300re ; ainsi aux prochaines e\u0301tapes, l\u2019algorithme n\u2019autorisera pas le balayage d\u2019une liste d\u2019adjacence de ce n\u0153ud.\nNos re\u0301sultats 8 montrent que LocFaults rate les erreurs uniquement pour TritypeKO6. Or, BugAssist rate l\u2019erreur pour AbsMinusKO2, AbsMinusKO3, AbsMinusV2KO2, TritypeKO, TriPerimetreKO, TriMultPerimetreKO et une des deux erreurs dans TritypeKO5. Les temps 9 de notre outil sont meilleurs par rapport a\u0300 BugAssist pour les programmes avec calcul nume\u0301rique ; ils sont proches pour le reste des programmes.\nPrenons trois exemples parmi ces programmes au hasard. Et conside\u0301rons l\u2019imple\u0301mentation de deux versions de notre algorithme, sans et avec marquage des n\u0153uds nomme\u0301es respectivement LocFaultsV1 et LocFaultsV2.\n\u2013 Les tables 1 et 2 montrent respectivement les ensembles suspects et les temps de LocFaultsV1 ; \u2013 Les tables 3 et 4 montrent respectivement les ensembles suspects et les temps de LocFaultsV2.\nDans les tables 1 et 3, nous avons affiche\u0301 la liste des MCSs et DCMs calcule\u0301s. Le nume\u0301ro de la ligne correspondant a\u0300 la condition est souligne\u0301. Les tables 2 et 4 donnent les temps de calcul : P est le temps de pre\u0301traitement qui inclut la traduction du programme Java en un arbre syntaxique abstrait avec l\u2019outil JDT (Eclipse Java devlopment tools), ainsi que la construction du CFG ; L est le temps de l\u2019exploration du CFG et de calcul des MCSs.\nLocFaultsV2 a permis de re\u0301duire conside\u0301rablement les de\u0301viations ge\u0301ne\u0301re\u0301es ainsi que les temps sommant l\u2019exploration du CFG et le calcul des MCSs de LocFaultsV1, et cela sans perdre l\u2019erreur ; les localisations fournies par LocFaultsV2 sont plus pertinentes. Les lignes e\u0301limine\u0301es de la table 3 sont colore\u0301es en bleu dans la table 1. Les temps ame\u0301liore\u0301s sont affiche\u0301s en gras dans la table 4. Par exemple, pour le programme TritypeKO2, a\u0300 l\u2019e\u0301tape 1 de l\u2019algorithme,\n8. Le tableau qui donne les MCSs calcule\u0301s par LocFaults pour les programmes sans boucles est disponible a\u0300 l\u2019adresse http://www.i3s.unice.fr/~bekkouch/Bench_ Mohammed.html#rsb\n9. Les tableaux qui donnent les temps de LocFaults et BugAssist pour les programmes sans boucles sont disponibles a\u0300 l\u2019adresse http://www.i3s.unice.fr/~bekkouch/Bench_ Mohammed.html#rsba\nLocFaultsV2marque le n\u0153ud de la condition 26, 35 et 53 (a\u0300 partir du contre-exemple, le programme devient correct en de\u0301viant chacune de ces trois conditions). Cela permet, a\u0300 l\u2019e\u0301tape 2, d\u2019annuler les de\u0301viations suivantes : {26, 29}, {26, 35}, {29, 35}, {32, 35}. Toujours a\u0300 l\u2019e\u0301tape 2, LocFaultsV2 de\u0301tecte deux de\u0301viations minimales en plus : {29, 57}, {32, 44}, les n\u0153uds 57 et 44 vont donc e\u0302tre marque\u0301s (la valeur de la marque est\n2). A\u0300 l\u2019e\u0301tape 3, aucune de\u0301viation n\u2019est se\u0301lectionne\u0301e ; a\u0300 titre d\u2019exemple, {29, 32, 44} n\u2019est pas conside\u0301re\u0301e parce que son cardinal est supe\u0301rieur strictement a\u0300 la valeur de la marque du n\u0153ud 44.\n6.2 Les benchmarks avec boucles\nCes benchmarks servent a\u0300 mesurer l\u2019extensibilite\u0301 de LocFaults par rapport a\u0300 BugAssist pour des programmes avec boucles, en fonction de l\u2019augmentation du nombre de de\u0301pliage b. Nous avons pris trois programmes avec boucles : BubbleSort, Sum et SquareRoot. Nous avons provoque\u0301 le bug Off-by-one dans chacun. Le benchmark, pour chaque programme, est cre\u0301e\u0301 en faisant augmenter le nombre de de\u0301pliage b. b est e\u0301gal au nombre d\u2019ite\u0301rations effectue\u0301es par la boucle dans le pire des cas. Nous faisons aussi varier le nombre de conditions de\u0301vie\u0301es pour LocFaults de 0 a\u0300 3.\nNous avons utilise\u0301 le solveur MIP de CPLEX pour BubbleSort. Pour Sum et SquareRoot, nous avons fait collaborer les deux solveurs de CPLEX (CP et MIP) lors du processus de la localisation. En effet, lors de la collecte des contraintes, nous utilisons une variable pour garder l\u2019information sur le type du CSP construit. Quand LocFaults de\u0301tecte un chemin errone\u0301 10 et avant de proce\u0301der au calcul des MCSs, il prend le bon solveur selon le type du CSP qui correspond a\u0300 ce chemin : s\u2019il est non line\u0301aire, il utilise le\n10. Un chemin errone\u0301 est celui sur lequel nous identifions les MCSs.\nsolveur CP OPTIMIZER; sinon, il utilise le solveur MIP.\nPour chaque benchmark, nous avons pre\u0301sente\u0301 un extrait de la table contenant les temps de calcul (les colonnes P et L affichent respectivement les temps de pre\u0301traitement et de calcul des MCSs), ainsi que le graphe qui correspond au temps de calcul des MCSs.\n6.2.1 Le benchmark BubbleSort\nBubbleSort est une imple\u0301mentation de l\u2019algorithme de tri a\u0300 bulles. Ce programme contient deux boucles imbrique\u0301es ; sa complexite\u0301 en moyenne est d\u2019ordre n2, ou\u0300 n est la taille du tableau : le tri a\u0300 bulles est conside\u0301re\u0301 parmi les mauvais algorithmes de tri. L\u2019instruction errone\u0301e dans ce programme entra\u0302\u0131ne le programme a\u0300 trier le tableau en entre\u0301e en conside\u0301rant seulement ses n \u2212 1 premiers e\u0301le\u0301ments. Le mauvais fonctionnement du BubbleSort est du\u0302 au nombre d\u2019ite\u0301rations insuffisant effectue\u0301 par la boucle. Cela est du\u0302 a\u0300 l\u2019initialisation fautive de la variable i : i = tab.length - 1 ; l\u2019instruction devait e\u0302tre i = tab.length.\nLes temps de LocFaults et BugAssist pour le benchmark BubbleSort sont pre\u0301sente\u0301s dans la table 5. Le graphe qui illustre l\u2019augmentation des temps des diffe\u0301rentes versions de LocFaults et de BugAssist en fonction du nombre de de\u0301pliages est donne\u0301 dans la figure 10.\nLa dure\u0301e d\u2019exe\u0301cution de LocFaults et de BugAssist cro\u0302\u0131t exponentiellement avec le nombre de de\u0301pliages ; les temps de BugAssist sont toujours les plus grands. On peut conside\u0301rer que BugAssist est inefficace pour ce benchmark. Les diffe\u0301rentes versions de LocFaults (avec au plus 3, 2, 1 et 0 conditions de\u0301vie\u0301es) restent utilisables jusqu\u2019a\u0300 un certain de\u0301pliage. Le nombre de de\u0301pliage au-dela\u0300 de lequel la croissance des temps de BugAssist devient re\u0301dhibitoire est infe\u0301rieur a\u0300 celui de LocFaults, celui de LocFaults avec au plus 3 conditions de\u0301vie\u0301es est infe\u0301rieur a\u0300 celui de LocFaults avec au plus 2 conditions de\u0301vie\u0301es qui est infe\u0301rieur lui aussi a\u0300\ncelui de LocFaults avec au plus 1 conditions de\u0301vie\u0301es. Les temps de LocFaults avec au plus 1 et 0 condition de\u0301vie\u0301e sont presque les me\u0302mes.\n6.2.2 Les benchmarks SquareRoot et Sum\nLe programme SquareRoot (voir fig. 11) permet de trouver la partie entie\u0300re de la racine carre\u0301e du nombre entier 50. Une erreur est injecte\u0301e a\u0300 la ligne 13, qui entra\u0302\u0131ne de retourner la valeur 8 ; or le programme doit retourner 7. Ce programme a e\u0301te\u0301 utilise\u0301 dans le papier de\u0301crivant l\u2019approche BugAssist, il contient un calcul nume\u0301rique line\u0301aire dans sa boucle et non line\u0301aire dans sa postcondition.\n1 c l a s s SquareRoot{ 2 /\u2217@ ensu res ( ( r e s \u2217 res<=val ) && ( re s +1)\u2217( r e s+1)>val ) ; \u2217/ 3 i n t SquareRoot ( ) 4 { 5 in t va l = 50 ; 6 in t i = 1; 7 in t v = 0; 8 in t r e s = 0 ; 9 whi l e (v < val ){\n10 v = v + 2\u2217 i + 1 ; 11 i= i + 1 ; 12 } 13 re s = i ; /\u2217 e r ro r : the i n s t r u c t i o n should be r e s = i \u2212 1\u2217/ 14 return re s ; 15 } 16 }\nFigure 11 \u2013 Le programme SquareRoot\nAvec un de\u0301pliage e\u0301gal a\u0300 50, BugAssist calcule pour ce programme les instructions suspectes suivantes : {9, 10, 11, 13}. Le temps de la localisation est 36, 16s et le temps de pre\u0301traitement est 0, 12s.\nLocFaults pre\u0301sente une instruction suspecte en indiquant a\u0300 la fois son emplacement dans le programme (la ligne d\u2019instruction), ainsi que la ligne de la condition et l\u2019ite\u0301ration de chaque boucle menant a\u0300 cette instruction. Par exemple, 9 : 2.11 correspond a\u0300 l\u2019instruction qui se trouve a\u0300 la ligne 11 dans le programme, cette dernie\u0300re est dans une boucle dont la ligne de la condition d\u2019arre\u0302t est 9 et le nume\u0301ro d\u2019ite\u0301ration est 2. Les ensembles suspecte\u0301s par LocFaults sont fournis dans le tableau suivant. DCMs MCSs\n\u2205 {5},{6},{9 : 1.11}, {9 : 2.11},{9 : 3.11}, {9 : 4.11},{9 : 5.11},{9 : 6.11},{9 : 7.11},{13}\n{9 : 7} {5},{6},{7},{9 : 1.10},{9 : 2.10},{9 : 3.10}, {9 : 4.10},{9 : 5.10}, {9 : 6.10},{9 : 1.11},\n{9 : 2.11},{9 : 3.11},{9 : 4.11},{9 : 5.11}, {9 : 6.11}\nLe temps de pre\u0301traitement est 0, 769s. Le temps e\u0301coule\u0301 lors de l\u2019exploration du CFG et le calcul des MCS est 1, 299s. Nous avons e\u0301tudie\u0301 le temps de LocFaults et BugAssist des valeurs de val allant de 10 a\u0300 100 (le nombre de de\u0301pliage b employe\u0301 est e\u0301gal a\u0300 val), pour e\u0301tudier le comportement combinatoire de chaque outil pour ce programme.\nLe programme Sum prend un entier positif n de l\u2019utilisateur, et il permet de calculer la valeur de\u2211n\ni=1 i. La postcondition spe\u0301cifie cette somme. L\u2019erreur dans Sum est dans la condition de sa boucle. Elle cause de calculer la somme \u2211n\u22121 i=1 i au lieu de \u2211n i=1 i. Ce programme contient des instructions nume\u0301riques line\u0301aires dans le c\u0153ur de la boucle, et une postcondition non line\u0301aire.\nLes re\u0301sultats en temps pour les benchmarks SquareRoot et Sum sont pre\u0301sente\u0301s dans les tables respectivement 6 et 7. Nous avons dessine\u0301 aussi le graphe qui correspond au re\u0301sultat de chaque benchmark, voir respectivement le graphe de la figure 12 et 13. Le temps d\u2019exe\u0301cution de BugAssist cro\u0302\u0131t rapidement ; les temps\nde LocFaults sont presque constants. Les temps de LocFaults avec au plus 0, 1 et 2 conditions de\u0301vie\u0301es sont proches de ceux de LocFaults avec au plus 3 conditions de\u0301vie\u0301es.\n7 Conclusion\nLa me\u0301thode LocFaults de\u0301tecte les sous-ensembles suspects en analysant les chemins du CFG pour trouver les DCMs et les MCSs a\u0300 partir de chaque DCM ; elle utilise des solveurs de contraintes. La me\u0301thode BugAssit calcule la fusion des MCSs du programme en transformant le programme complet en une formule boole\u0301enne ; elle utilise des solveurs Max-SAT. Les deux\nme\u0301thodes travaillent en partant d\u2019un contre-exemple. Dans ce papier, nous avons pre\u0301sente\u0301 une exploration de la scalabilite\u0301 de LocFaults, particulie\u0300rement sur le traitement des boucles avec le bug Off-by-one. Les premiers re\u0301sultats montrent que LocFaults est plus efficace que BugAssist sur des programmes avec boucles. Les temps de BugAssist croissent rapidement en fonction du nombre de de\u0301pliages.\nDans le cadre de nos travaux futurs, nous envisageons de confirmer nos re\u0301sultats sur des programmes avec boucles plus complexes. Nous de\u0301veloppons une version interactive de notre outil qui fournit les sousensembles suspects l\u2019un apre\u0300s l\u2019autre : nous voulons tirer profit des connaissances de l\u2019utilisateur pour se\u0301lectionner les conditions qui doivent e\u0302tre de\u0301vie\u0301es. Nous re\u0301fle\u0301chissons e\u0301galement sur comment e\u0301tendre notre me\u0301thode pour supporter les instructions nume\u0301riques avec calcul sur les flottants.\nRemerciements. Nous remercions Bertrand Neveu pour sa lecture attentive et ses commentaires utiles sur ce papier. Merci e\u0301galement a\u0300 Michel Rueher et He\u0301le\u0300ne Collavizza pour leurs remarques inte\u0301ressantes.\nRe\u0301fe\u0301rences\n[1] D\u2019silva, Vijay, Daniel Kroening, and Georg Weissenbacher. \u201dA survey of automated techniques for formal software verification.\u201d Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 27.7 (2008) : 1165-1178.\n[2] Kok-Ming Leung. \u201dDebugging Loops.\u201d In http://cis. poly.edu/~mleung/CS1114/s08/ch02/debug.htm\n[3] Bekkouche, Mohammed, He\u0301le\u0300ne Collavizza, and Michel Rueher. \u201dUne approche CSP pour l\u2019aide a\u0300 la localisation d\u2019erreurs.\u201d arXiv preprint arXiv :1404.6567 (2014).\n[4] Bekkouche, Mohammed, He\u0301le\u0300ne Collavizza, and Michel Rueher. \u201dLocFaults : A new flow-driven and constraint-based error localization approach*.\u201d ACM. SAC\u201915, SVT track, Apr 2015, Salamanca, Spain. <10.1145/2695664.2695822>. <hal-01094227>\n[5] Barnett, Mike, and K. Rustan M. Leino. \u201dWeakestprecondition of unstructured programs.\u201d ACM SIGSOFT Software Engineering Notes. Vol. 31. No. 1. ACM, 2005.\n[6] Wong, W. Eric, and Vidroha Debroy. \u201dA survey of software fault localization.\u201d Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45-09 (2009).\n[7] Bekkouche, Mohammed. \u201dBug stories.\u201d In http://www. i3s.unice.fr/~bekkouch/Bug_stories.html\n[8] Wikipedia. \u201dList of software bugs \u2014 Wikipedia, The Free Encyclopedia.\u201d In http: //en.wikipedia.org/w/index.php?title=List_\nof_software_bugs&oldid=648559652\n[9] Jose, Manu, and Rupak Majumdar. \u201dCause clue clauses : error localization using maximum satisfiability.\u201d ACM SIGPLAN Notices 46.6 (2011) : 437-446.\n[10] Jose, Manu, and Rupak Majumdar. \u201dBug-Assist : assisting fault localization in ANSI-C programs.\u201d Computer Aided Verification. Springer Berlin Heidelberg, 2011.\n[11] Collavizza, He\u0301le\u0300ne, Michel Rueher, and Pascal Van Hentenryck. \u201dCPBPV : a constraint-programming framework for bounded program verification.\u201dConstraints 15.2 (2010) : 238-264.\n[12] Liffiton, Mark H., and Karem A. Sakallah. \u201dAlgorithms for computing minimal unsatisfiable subsets of constraints.\u201d Journal of Automated Reasoning 40.1 (2008) : 1-33.\n[13] Clarke, Edmund, Daniel Kroening, and Flavio Lerda. \u201dA tool for checking ANSI-C programs.\u201d Tools and Algorithms for the Construction and Analysis of Systems. Springer Berlin Heidelberg, 2004. 168-176.\n[14] Marques-Silva, Joao. \u201dThe msuncore maxsat solver.\u201d SAT 2009 competitive events booklet : preliminary version (2009) : 151."}], "references": [{"title": "A survey of automated techniques for formal software verification.", "author": ["D\u2019silva", "Vijay", "Daniel Kroening", "Georg Weissenbacher"], "venue": "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 27.7", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Une approche CSP pour l\u2019aide \u00e0 la localisation d\u2019erreurs.", "author": ["Bekkouche", "Mohammed", "H\u00e9l\u00e8ne Collavizza", "Michel Rueher"], "venue": "arXiv preprint arXiv", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "LocFaults : A new flow-driven and constraint-based error localization approach*.", "author": ["Bekkouche", "Mohammed", "H\u00e9l\u00e8ne Collavizza", "Michel Rueher"], "venue": "ACM. SAC\u201915, SVT track,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Weakestprecondition of unstructured programs.", "author": ["Barnett", "Mike", "K. Rustan M. Leino"], "venue": "ACM SIG- SOFT Software Engineering Notes", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2005}, {"title": "A survey of software fault localization.", "author": ["Wong", "W. Eric", "Vidroha Debroy"], "venue": "Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45-09", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2009}, {"title": "Cause clue clauses : error localization using maximum satisfiability.", "author": ["Jose", "Manu", "Rupak Majumdar"], "venue": "ACM SIGPLAN Notices", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Bug-Assist : assisting fault localization in ANSI-C programs.", "author": ["Jose", "Manu", "Rupak Majumdar"], "venue": "Computer Aided Verification", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "CPBPV : a constraint-programming framework for bounded program verification.\u201dConstraints", "author": ["Collavizza", "H\u00e9l\u00e8ne", "Michel Rueher", "Pascal Van Hentenryck"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Algorithms for computing minimal unsatisfiable subsets of constraints.", "author": ["Liffiton", "Mark H", "Karem A. Sakallah"], "venue": "Journal of Automated Reasoning", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "A tool for checking ANSI-C programs.\u201d Tools and Algorithms for the Construction and Analysis of Systems", "author": ["Clarke", "Edmund", "Daniel Kroening", "Flavio Lerda"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2004}, {"title": "The msuncore maxsat solver.", "author": ["Marques-Silva", "Joao"], "venue": "SAT 2009 competitive events booklet : preliminary version", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}], "referenceMentions": [{"referenceID": 4, "context": "Elle consiste \u00e0 identifier l\u2019emplacement exact des instructions suspectes [6] afin d\u2019aider l\u2019utilisateur \u00e0 comprendre pourquoi le programme a \u00e9chou\u00e9, ce qui lui facilite la t\u00e2che de la correction des erreurs.", "startOffset": 74, "endOffset": 77}, {"referenceID": 2, "context": "Pour r\u00e9soudre ce probl\u00e8me, nous avons propos\u00e9 une approche [4] (nomm\u00e9e LocFaults) \u00e0 base de contraintes qui explore les chemins du CFG(Control Flow Graph) du programme \u00e0 partir du contre-exemple, pour calculer les sous-ensembles minimaux permettant de restaurer la conformit\u00e9 du programme vis-\u00e0-vis de sa postcondition.", "startOffset": 59, "endOffset": 62}, {"referenceID": 0, "context": "Assurer que notre m\u00e9thode soit hautement scalable pour faire face \u00e0 l\u2019\u00e9norme complexit\u00e9 des syst\u00e8mes logiciels est un crit\u00e8re important pour sa qualit\u00e9 [1].", "startOffset": 152, "endOffset": 155}, {"referenceID": 5, "context": "BugAssist [9] [10] est une m\u00e9thode de localisation d\u2019erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Bool\u00e9enne du programme en entier avec le contre-exemple.", "startOffset": 10, "endOffset": 13}, {"referenceID": 6, "context": "BugAssist [9] [10] est une m\u00e9thode de localisation d\u2019erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Bool\u00e9enne du programme en entier avec le contre-exemple.", "startOffset": 14, "endOffset": 18}, {"referenceID": 3, "context": "Nous utilisons la transformation en forme DSA [5] qui assure que chaque variable est affect\u00e9e une seule fois sur chaque chemin du CFG.", "startOffset": 46, "endOffset": 49}, {"referenceID": 0, "context": "Dans le cadre du Bounded Model Checking (BMC) pour les programmes, le d\u00e9pliage peut \u00eatre appliqu\u00e9 au programme en entier comme il peut \u00eatre appliqu\u00e9 aux boucles s\u00e9par\u00e9ment [1].", "startOffset": 172, "endOffset": 175}, {"referenceID": 1, "context": "Notre approche de localisation d\u2019erreurs, LocFaults [3] [4], se place dans la deuxi\u00e8me d\u00e9marche ; c\u2019est-\u00e0-dire, nous utilisons une borne b pour d\u00e9plier les boucles en les rempla\u00e7ant par des imbrications de conditionnelles de profondeur b.", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "Notre approche de localisation d\u2019erreurs, LocFaults [3] [4], se place dans la deuxi\u00e8me d\u00e9marche ; c\u2019est-\u00e0-dire, nous utilisons une borne b pour d\u00e9plier les boucles en les rempla\u00e7ant par des imbrications de conditionnelles de profondeur b.", "startOffset": 56, "endOffset": 59}, {"referenceID": 0, "context": "\u00c0 partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustr\u00e9 sur la figure 8 le chemin fautif initial (voir le chemin color\u00e9 en rouge), ainsi que la d\u00e9viation pour laquelle la postcondition est satisfaisable (la d\u00e9viation ainsi que le chemin au-dessus de la condition d\u00e9vi\u00e9e sont illustr\u00e9s en vert).", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "\u00c0 partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustr\u00e9 sur la figure 8 le chemin fautif initial (voir le chemin color\u00e9 en rouge), ainsi que la d\u00e9viation pour laquelle la postcondition est satisfaisable (la d\u00e9viation ainsi que le chemin au-dessus de la condition d\u00e9vi\u00e9e sont illustr\u00e9s en vert).", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 35, "endOffset": 38}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 80, "endOffset": 83}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 224, "endOffset": 227}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 259, "endOffset": 262}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 298, "endOffset": 301}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 335, "endOffset": 338}, {"referenceID": 0, "context": "CE :{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 24, "endOffset": 27}, {"referenceID": 1, "context": "CE :{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 54, "endOffset": 57}, {"referenceID": 7, "context": "Pour g\u00e9n\u00e9rer le CFG et le contre-exemple, nous utilisons l\u2019outil CPBPV [11] (Constraint-Programming Framework for Bounded Program Verification).", "startOffset": 71, "endOffset": 75}, {"referenceID": 8, "context": "com/software/commerce/optimization/cplex-cpavons adapt\u00e9 et impl\u00e9ment\u00e9 l\u2019algorithme de Liffiton et Sakallah [12], voir alg.", "startOffset": 107, "endOffset": 111}, {"referenceID": 9, "context": "BugAssist utilise l\u2019outil CBMC [13] pour g\u00e9n\u00e9rer la trace erron\u00e9e et les donn\u00e9es d\u2019entr\u00e9e.", "startOffset": 31, "endOffset": 35}, {"referenceID": 10, "context": "Pour le solveur Max-SAT, nous avons utilis\u00e9 MSUnCore2 [14].", "startOffset": 54, "endOffset": 58}, {"referenceID": 0, "context": "[1] D\u2019silva, Vijay, Daniel Kroening, and Georg Weissenbacher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[3] Bekkouche, Mohammed, H\u00e9l\u00e8ne Collavizza, and Michel Rueher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[4] Bekkouche, Mohammed, H\u00e9l\u00e8ne Collavizza, and Michel Rueher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[5] Barnett, Mike, and K.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[6] Wong, W.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[9] Jose, Manu, and Rupak Majumdar.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[10] Jose, Manu, and Rupak Majumdar.", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "[11] Collavizza, H\u00e9l\u00e8ne, Michel Rueher, and Pascal Van Hentenryck.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[12] Liffiton, Mark H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[13] Clarke, Edmund, Daniel Kroening, and Flavio Lerda.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[14] Marques-Silva, Joao.", "startOffset": 0, "endOffset": 4}], "year": 2015, "abstractText": "A model checker can produce a trace of counterexample, for a erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each MCD found. We present the times of our approach on programs with While-loops unfolded b times, and a number of diverted conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraintbased and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, although the information provided by LocFaults is more expressive for the user.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}