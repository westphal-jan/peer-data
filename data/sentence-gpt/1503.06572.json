{"id": "1503.06572", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2015", "title": "A Machine Learning Approach to Predicting the Smoothed Complexity of Sorting Algorithms", "abstract": "Smoothed analysis is a framework for analyzing the complexity of an algorithm, acting as a bridge between average and worst-case behaviour. For example, Quicksort and the Simplex algorithm are widely used in practical applications, despite their heavy worst-case complexity. Smoothed complexity aims to better characterize such algorithms in their tests, and to be more consistent with high performance models.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Mon, 23 Mar 2015 09:37:33 GMT  (1333kb,D)", "http://arxiv.org/abs/1503.06572v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI cs.CC", "authors": ["bichen shi", "michel schellekens", "georgiana ifrim"], "accepted": false, "id": "1503.06572"}, "pdf": {"name": "1503.06572.pdf", "metadata": {"source": "CRF", "title": "A Machine Learning Approach to Predicting the Smoothed Complexity of Sorting Algorithms", "authors": ["Bichen Shi", "Georgiana Ifrim"], "emails": ["bichen.shi@insight-centre.org", "m.schellekens@cs.ucc.ie", "georgiana.ifrim@insight-centre.org"], "sections": [{"heading": null, "text": "Keywords Smoothed Complexity \u00b7 Sorting Algorithms \u00b7Machine Learning \u00b7 Regression Models"}, {"heading": "1 Introduction", "text": "Smoothed Complexity (SC) was first introduced in (Spielman and Teng, 2001), aiming to provide a more realistic view of the practical performance of algorithms compared to worst-case or average-case analysis. Motivated by the observation that, in practice, input parameters are often subject to a small degree of random noise, SC measures the expected performance of algorithms under slight random perturbations of the worst-case inputs (Spielman and Teng, 2006). When worst-case is extremely rare in practice, a worst-case view can be problematic, especially for algorithms that have poor worst-case, but good average-case complexity. Average-case analysis is an important\nBichen Shi Insight Centre for Data Analytics, University College Dublin, Belfield, Dublin 4, Ireland E-mail: bichen.shi@insight-centre.org\nMichel Schellekens Centre for Efficiency Oriented Languages(CEOL), University College Cork, Western Road, Cork, Ireland E-mail: m.schellekens@cs.ucc.ie\nGeorgiana Ifrim Insight Centre for Data Analytics, University College Dublin, Belfield, Dublin 4, Ireland E-mail: georgiana.ifrim@insight-centre.org\nar X\niv :1\n50 3.\n06 57\n2v 1\n[ cs\n.L G\n] 2\n3 M\ncomplement to worst-case analysis, providing a more comprehensive view of the problem. Nevertheless, SC, a hybrid of worst-case and average-case, provides an alternative measurement for a given algorithm (Spielman and Teng, 2002). In practice, it is useful to understand how quickly the SC switches from worst to average case. By analyzing the worst-case inputs under perturbations, the SC intuitively indicates the probability of an algorithm encountering worst-case in practice. If the SC of an algorithm is low, then it is unlikely the algorithm will take a long time to solve practical instances, even if it has a poor worst-case complexity.\nAlthough very useful, SC is not easy to estimate, neither theoretically nor empirically. The SC bounds of many algorithms have been given, including the Simplex Algorithm, that has exponential worst-case complexity but polynomial SC (Spielman and Teng, 2001; Deshpande and Spielman, 2005), Quasi-Concave Minimization, an NP-hard problem, but with polynomial SC under certain conditions (Spielman and Teng, 2009), and Quicksort, with worst-case complexity O(N2), but SC of O(Np lnN), where p \u2208 [0,1] (Banderier et al., 2003). However, theoretical approaches to bound the SC generally require very complex proofs, and the resulting bounds are often weak. For sorting algorithms, (Schellekens et al., 2014) has shown that the gap between the exact (empirical) value of Quicksort\u2019s SC and its known bound is significant.\nRecently, modular smoothed analysis (Schellekens, 2008) has been introduced to better estimate the value of SC for discrete cases. In (Schellekens, 2008) it was shown that for an algorithm that satisfies random bag preservation, its SC value can be calculated through a recurrence equation. Although more accurate than the theoretical bounds, modular smoothed analysis currently works only for Quicksort and its median-of-three variant (M3Quicksort) (Schellekens et al., 2014; Hennessy and Schellekens, 2014). Furthermore, because of its recurrence structure, the maximum input size for which it is feasible to compute the SC of Quicksort is 3000, and for M3Quicksort it is 130.\nAn alternative to the above approaches, is to try to compute the SC directly, using its original definition. For discrete cases, the SC under partial permutation perturbations is the maximum average runtime over all perturbed inputs (Spielman and Teng, 2006; Schellekens et al., 2014). However, the perturbation step leads to a very heavy computing process. As shown in Figure 1, to calculate the SC of an input list with length N, under partial permutations given perturbation parameter K (the degree of perturbation), we need to generate a perturbed group for each input list, take the average runtime over each perturbed group, and take the maximum of these. The complexity for empirically computing the SC of Quicksort is then\nO( (N!)2N log(N)\n(N\u2212K)! ) (1)\nquickly becoming infeasible even for very small inputs (i.e., size N of list to be sorted). Our Contribution. In this paper, we show how using machine learning techniques to predict the value of SC for sorting algorithms overcomes the difficulties raised by either a theoretical or an empirical approach. This is a new point of view, since apart from theoretical bounds and some empirical results for small input sizes, there is very little information on how the SC of sorting algorithms behaves exactly. We formulate the SC prediction as a regression problem, and present two successful predictive models. Model TLR-SC (Transformed Linear Regression for SC) turns the non-linear relationship of our selected features into a linear one, and delivers good prediction by simply using linear regression. Model NLR-SC (Non-linear Regression for SC) turns a surface fitting problem into multiple curve fitting problems, and by predicting the smoothed complexity curve by curve, gradually predicts the entire surface. Because NLR-SC takes advantage of the theory of smoothed analysis, it delivers good results with very few training examples. The initial learning models are built for Quicksort, but easily adapted to other sorting algorithms, e.g., M3Quicksort, optimized Bubblesort and Mergesort. Previously, there were no known results on the SC of the latter three sorting algorithms, for large input sizes. We believe the results in this work are useful for characterizing the behavior of sorting algorithms in practice, and general enough so that they could also be adapted for other interesting algorithms.\nMany machine learning algorithms have been analyzed by smoothed analysis, such as k-means clustering (Arthur et al., 2009) and Support Vector Machines (Blum and Dunagan, 2002; Spielman and Teng, 2009), however,\nGiven Input List Length N\nto the best of our knowledge, there is no previous research on using machine learning algorithms to predict the SC of sorting algorithms. Due to recent modular smoothed analysis results, we can compute the SC of Quicksort exactly, for medium size inputs (e.g., N \u2264 3000). For other sorting algorithms, currently the SC can only be computed using its original definition, and thus, due to computational requirements, only for small input sizes (e.g., N \u2264 100), limiting our understanding of the general SC behaviour. This also means that we are faced with a lack of ground truth data to train machine learning algorithms for predicting the SC. To this end, in this work, we use a combination of modular smoothed analysis and empirical approaches to generate ground truth data. We formulate predicting the numeric value of SC of sorting algorithms as a regression problem. The techniques to handle regression, curve fitting and surface fitting problems in the machine learning area are quite mature (Hastie et al., 2013). The gist of this work is how to gather ground truth data, identify good features and build appropriate learning models, so that by training on behaviour data of sorting algorithms on small inputs (where it is relatively easy to gather ground truth data), we can accurately predict the SC of the sorting algorithm for large inputs."}, {"heading": "2 Discrete Smoothed Complexity", "text": "While worst-case complexity refers to the maximum running time of an algorithm acting on every input, the SC is a smoothed version of worst-case complexity, that considers the maximum average running time of an algorithm acting on the perturbations of every input. The degree of perturbation is measured by a parameter \u03c3 . SC can be explained as a function of \u03c3 which interpolates between the worst-case and average-case running times. When \u03c3 goes to 0, then the SC is equal to the worst-case complexity; whereas, if \u03c3 goes to 1, then the SC becomes the average-case complexity, and in practice, it is useful to understand how quickly the SC switches from worst to average case. The quicker the SC switches, the more unlikely the worst-case appeares in practice.\nSC was originally defined for continuous cases using Gaussian perturbations (Spielman and Teng, 2001). The discrete version of SC was introduced in (Banderier et al., 2003) and extended in (Schellekens et al., 2014). In this work, we use the partial permutation perturbation definition of (Schellekens et al., 2014), where \u03c3 = KN (0\u2264 K \u2264 N), N is the length of the input list:\nDefinition 1 A \u03c3 -partial permutation of S is a random sequence S\u2032=(S\u20321,S \u2032 2, . . .S \u2032 N) obtained from S=(S1,S2, . . .SN) in two steps.\n1. K elements of S are selected at random. 2. Choose one of the K! permutations of these elements (uniformly at random) and rearrange them in that order,\nleaving the positions of all the other elements fixed.\nTable 1 shows the partial permutations for N = 3 on the set of permutations of {1,2,3}. When K = 0, the list is not perturbed. When K = 1, the perturbed group contains the list itself, repeated N times. When K = N, the perturbed group is the set of permutations of size N, \u2211N .\nDefinition 2 (Schellekens et al., 2014) Given a problem P with input sequence domain \u2211N , let A be an algorithm for solving P. Let T A(I ) be the average running time T of an algorithm A on an input collection I \u2282 \u2211N . The SC, T SA (N,K), of the algorithm A is defined by:\nT SA (N,K) = maxS\u2208\u2211N (T A(PertK,N(S))) (2)\nwhere PertK,N(S) is the perturbed group of S under partial permutations, the degree of which is defined by K.\nIn this work, the algorithms are comparison-based, therefore TA(x) is measured as the number of comparisons A performs when computing the output on input x.\n2.1 Modular Smoothed Analysis\nModular smoothed analysis was recently introduced in (Schellekens et al., 2014; Hennessy and Schellekens, 2014). It is a simplification of traditional SC analysis by smoothing out the perturbations over the computation. For algorithms that are random bag preserving (Schellekens, 2008), the number of comparisons of the algorithm running on an input can be captured and calculated through a recurrence equation. The two equations for the modular SC of Quicksort and M3Quicksort are shown below (Equations 3,4). Using these two formulas we collect ground truth data for Quicksort and its median-of-three variant for training and evaluating our supervised learning method. The modular recurrence equation for the SC of Quicksort, f (N,K), is (Schellekens et al., 2014):\nf (N,K) = (N\u22121)+ N\n\u2211 j=1\n\u03b2 NN+1\u2212 j f ( j\u22121,K)+ N\n\u2211 j=1 \u03b2 Nj f ( j\u22121,K), (3)\nwhere \u03b2 NN =\nN\u2212K +1 N ,\nand\n\u03b2 Nj [ j 6= N] = (K\u22121)\nN(N\u22121) .\nThe recurrence equation for the SC of M3Quicksort is (Hennessy and Schellekens, 2014):\nf (N,K) = (N\u22121)+1+ N\u22121\n\u2211 j=2\n\u03b2 N\u22121N+1\u2212 j f ( j\u22121,K)+ N\u22121\n\u2211 j=2 \u03b2 N\u22121j f ( j\u22121,K) (4)\nwhere\n\u03b2 N\u22121j = 2!( j\u22121) K(N\u22122) (N\nK\n)(2(N\u22124 K\u22122 ) +2 (K +1) (K\u22121) ( N\u22124 K\u22123 ) + 3(N\u2212 j) (K\u22121) ( N\u22124 K\u22124 )) , 2\u2264 j \u2264 N\u22122,\nand\n\u03b2 N\u22121N\u22121 =\n{ K! (\nN\u22123 K\n) +(K\u22121)! ( N\u22123 K\u22121 ) (2+K)+2!(K\u22122)! ( N\u22123 K\u22122 ) (2K\u22121)\n+3!(K\u22122)! (\nN\u22123 K\u22123\n)} (N\u2212K)!\nN!\nModular SC values are closer to the traditional SC ones, as compared to the existing mathematical bounds (Schellekens et al., 2014)."}, {"heading": "3 Sorting Algorithms", "text": "This paper focuses on analysing and predicting the SC of four sorting algorithms: Quicksort, M3Quicksort, optimized Bubblesort and Mergesort. Their worst-case, average-case and smoothed complexity are listed in Table 2.\nM3Quicksort is a variation of Quicksort. The classical version of Quicksort selects the first element of the list as a pivot, while M3Quicksort first compares the first, the median and the last element, and selects as pivot the element whose value is the median of the three. By doing so, M3Quicksort is 30% - 50% faster than the original algorithm.\nBubblesort is simple to implement, and it is also easy to track its comparisons. The normal Bubblesort has a constant runtime for all inputs, and it is not desirable as a testing algorithm for the SC, which analyzes the transition between the worst-case and the average-case complexity. Therefore, we focus here on optimized Bubblesort\n(Knuth, 1973). A tracker is added in Bubblesort to show whether or not elements were swapped, so the algorithm can stop running earlier if the list has been sorted. As a result, optimized Bubblesort works faster on part of the inputs and its average-case runtime will be smaller than its worst-case runtime, although its two complexities are on the same scale.\nMergesort is the standard version. Note that although its worst-case and average-case complexities are on the same scale, its worst-case and average-case runtimes do not have the same value."}, {"heading": "4 Data Collection", "text": "In this section we describe our process of collecting ground truth data for learning prediction models. All our data and code is available upon request for research purposes.\n4.1 Empirical Approach\nAlthough (Banderier et al., 2003) has proven that the SC of Quicksort is O(Np ln(N)), this bound is not accurate enough (see (Schellekens et al., 2014) for details) to allow us training a supervised machine learning approach. To obtain better ground truth data for the SC, we first use an experimental approach to compute the SC exactly, by following definitions in (Schellekens et al., 2014). The steps for calculating the SC of a sorting algorithm A for given input lists length N are (Figure 1): Step1. Generate a perturbed group for each input list, under the partial permutation perturbation. Given the perturbation parameter K, and following Definition 1, the size of each perturbed group is(\nN K\n) K! =\nN! K!(N\u2212K)! K! = N! (N\u2212K)! (5)\nThe total number of permutations in all perturbed groups is equal to the number of the input lists, which is N!, multiplied with the size of each perturbed group:\n(N!)2\n(N\u2212K)! (6)\nStep2. For all permutations in every perturbed groups, compute their runtimes1 under sorting algorithm A. Denote the average-case complexity of A as A(N), then the complexity of this process is\nO( (N!)2 \u00b7A(N) (N\u2212K)! ) (7)\nStep3. Calculate the average runtime for each perturbed group, then select the maximum average runtime among all perturbed groups, i.e., the SC. Compared to Equation 7, the complexity of calculating the average and the maximum is too low to be considered. Therefore the complexity of computing SC of A is the same as Equation 7.\nWe can see how computationally heavy this process is. Even though we can store the runtime of the N! permutations into memory to avoid repetitive computation, the complexity of computing the SC is still\nO(N! \u00b7A(N)) (8)\n1 Runtime is the number of comparisons in our case, as we only consider sorting algorithms in this work.\nFor Quicksort, the complexity of computing the SC is O(N!N log(N)), while for Bubblesort, the complexity is O(N!N2). However, since empirical data is essential as a ground truth for a machine learning approach, we generate some of our data with this approach. We compute the SC of Quicksort, M3Quicksort, optimized Bubblesort, and Mergesort. Our code uses hill climbing and Quicksort-specific worst-case permutation results (Shi, 2013), to push the input size for which we can empirically obtain SC values. Plots of the results of the four algorithms are shown in Figure 2, for list length N = 10, 2\u2264 K \u2264 N.\nLimitations of the Empirical Approach: Through the experimental approach, we can obtain the SC of sorting algorithms for very limited N and K, due to the computational burden. For K = 2, we can compute the SC for Quicksort only up to N = 200, and for K = N, only up to N = 10. For algorithms that are less efficient than Quicksort, the data we can collect this way is much less. Such a dataset alone is too small to be useful for training and testing our learning system. Therefore, in the next section, we show how to use modular analysis to gather more data.\n4.2 Modular Smoothed Analysis\nModular smoothed analysis (Schellekens et al., 2014) provides another way to calculate the SC for Quicksort and its median-of-three variant. More precisely, it gives recursive formulas, that are parameterized by the list length N and perturbation parameter K. Using the same amount of time as the empirical approach, we can collect a thousand times more data through the modular approach. For Quicksort, the maximum list length N for which the SC can be computed is 3000. For M3Quicksort, we can collect the SC for N up to 130.Unfortunately, when N > 130, the factorial calculation within the formula makes the computation unmanageable. In addition, the formula only works when K \u2265 4, and the SC of K = 2,K = 3 cannot be obtained through the modular approach.\nLimitations of the Modular Approach: Due to the recursive structure of modular analysis equations, this aproach also quickly becomes infeasible with increasing input N. Additionally, for now, modular smoothed analysis results are known only for Quicksort and M3Quicksort, while we require ground truth data to validate learning models for more sorting algorithms, e.g., Bubblesort and Mergesort."}, {"heading": "5 Data Analysis", "text": "Section 4 discussed the collection of the ground truth data for building SC prediction algorithms, i.e., given an input list of length N, and a perturbation parameter K, we have computed the value of SC, for four sorting algorithms. For Quicksort and M3Quicksort, we used the modular approach, and for Bubblesort and Mergesort, the empirical approach. Table 3 shows sample ground truth data for Quicksort. Figure 2a shows the relationships between N, K and the SC of Quicksort. If the value of N increases, no matter what value K is, the SC increases as well. This is reasonable, since the execution time will be longer in general for sorting algorithms, when the input list length is greater. If the value of K increases, no matter what value N is, the SC decreases. Because the SC is the hybrid of worst-case and average-case analysis, if K increases, SC will tend from the worst-case towards the average-case behavior (Spielman and Teng, 2001). From Figures 2b, 2c, 2d we can see similar patterns also exist for the SC of M3Quicksort, Bubblesort and Mergesort.\n5.1 Fixed N\nBy fixing the value of N, we consider the relationship between the SC and K only. Figure 3 shows how the SC of Quicksort decreases while K increases, for N = 10,100,500,1500, 2 \u2264 K \u2264 N. When K = 2, the value of the SC is very close to the worst-case complexity, and when K = N, the value is equal to the average-case complexity (Spielman and Teng, 2001). Note that, the larger the value of N, the quicker the SC decreases while K increases.\nBy looking at the Figure 3 where N = 500, we can clearly see the tipping point where SC steadily turns to average-case complexity. Such point indicates how likely the algorithm encounters a worst-case in practice, and the quicker the tipping point appears, the better the SC of the algorithm. The data shape of the SC depends on the sorting algorithm, as shown in Figure 4. The relationships between the SC and K of Quicksort, optimized Bubblesort and Mergesort are completely different. While K increases, the SC of Quicksort decreases quickest, the second is Mergesort, and the last is Bubblesort. This explains why QuickSort performs very well in practice although its worst-case complexity is O(N2), and also shows how the SC encodes this behaviour.\n5.2 Fixed K\nWith K fixed, we analyze the relationship between the SC and N. Figure 5 shows how the SC of Quicksort increases when K = 2, and when K = N. The range of N is from 5 to 100. The value of the SC given K = 2, links to the worst-case behavior of the algorithm, which is O(N2) for Quicksort, and similarly, given K = N, it links to the average-case behavior, which is O(N logN).\n5.3 Feature Selection\nDue to the definition of SC, when selecting features for designing our learning models, N and K are the first choice. N is the input list length and K is the perturbation parameter varying from 2 to N. In our experiments, we also found Runtime-based features to be helpful for predicting the SC. Runtime is the comparison time of an input list in a sorting algorithm, and MaxRuntime is the maximum Runtime among all input lists, given N. The average time complexity for computing Runtime of Quicksort over all inputs is O(N logN). We define AvgRuntime as the value of average Runtime of an input\u2019s perturbed group in a sorting algorithm. Note that the SC is the maximum AvgRuntime (MaxAvgRuntime) that can be found among all inputs. We have found that Runtime and AvgRuntime do not improve prediction, but the MaxRuntime does. For each N, there is only one MaxRuntime value. MaxRuntime is fairly easy to compute compared to the SC, and it can act as a scaling factor to indicate an appropriate SC value for the model. For Quicksort we compute MaxRuntime using the worst-case permutation. For the other 3 algorithms, we use hill climbing. Table 4 shows the definition of important terms for this section."}, {"heading": "6 Prediction Models for the SC", "text": "In this section we present our evaluation methodology and our two approaches for predicting the SC of sorting algorithms.\n6.1 Evaluation Metrics\nWe use three classical measures to evaluate the prediction quality of the models tested. Assume the size of the test set is n; the actual target attribute values in the test set are a1,a2, . . . ,an; the predicted values on the test instances are p1, p2, . . . , pn. The Mean Absolute Error (MAE) is (Witten et al., 2011):\nMAE = |p1\u2212a1|+ \u00b7 \u00b7 \u00b7+ |pn\u2212an|\nn (9)\nWhen the relative rather than the absolute error values are more important, we use Mean Absolute Percentage Error (MAPE).\nMAPE = | p1\u2212a1a1 |+ | p2\u2212a2 a2 |+ \u00b7 \u00b7 \u00b7+ | pn\u2212anan |\nn \u00d7100% (10)\nWe also show the Root Mean Squared Error (RMSE), which is more sensitive to outliers (Witten et al., 2011):\nRMSE =\n\u221a (p1\u2212a1)2 + \u00b7 \u00b7 \u00b7+(pn\u2212an)2\nn (11)\n5 10 15 20 25 30\n0 5\n0 1\n5 0\n2 5\n0\nK\nK ^(\n\u2212 0\n.5 )*\nM a\nx R\nu n\nti m e N=10 N=15 N=20 N=25 N=30\nFig. 6: The value of feature 2 \u221a\n1 K \u00d7MaxRuntime in TLR-SC, when 2\u2264 K \u2264 N, N = 10,15,20,25,30\nWe use the R language environment for analysing our data and building predictive models, since it offers more flexibility in manipulating/visualising data. All our data and R code are available upon request for research purposes.\n6.2 Model TLR-SC\nIn order to predict the SC we have first tested several feature combinations (e.g., N, K, Runtime, MaxRuntime) and several built-in regression algorithms of the open source machine learning software Weka (Witten et al., 2011). Nevertheless, straightforward application of WEKA algorithms did not work well for predicting the SC, in particular, for the scenario we are interested in: training on small input sizes and predicting/testing on large input sizes. Most WEKA algorithms delivered MAPE around 20%, when trained on data with N \u2264 20 and tested on data with N \u2265 40.\nIn this section, we discuss several modelling approaches, and propose a first model for accurately predicting the SC, named TLR-SC (Transformed Linear Regression for Smoothed Complexity). The idea behind TLR-SC is to build new features that better capture the nature of the relationship between the SC and input data characteristics. For example, as shown in Figure 2a, for Quicksort, the SC has a nonlinear relationship with K and N. In order to capture this relationship, we create a new feature that directly couples K and MaxRuntime (which is also\ninfluenced by N). We empirically found that 2 \u221a\n1 K \u00d7MaxRuntime captures best this non-linear relationship. Using\nthe new feature and linear regresison (the lm R package), MAPE reduces from 20% to 4.58%. Figure 6 shows the value of feature 2 \u221a\n1 K \u00d7MaxRuntime, given 2\u2264 K \u2264 N,N = 10,15,20,25,30.\nNote that this feature is customized for Quicksort. As we showed earlier (Figure 4), different algorithms have different shapes of SC, thus feature 2 \u221a\n1 K \u00d7MaxRuntime is not suitable for other algorithms. Therefore, in order\nto build models for predicting the SC of other algorithms, we require a more general approach for capturing the relationship between SC and the features."}, {"heading": "6.2.1 Optimization of the Proposed Feature", "text": "The new feature, expressed as (K\u22120.5)\u00d7MaxRuntime, generally captures the shape of how SC decreases, while K increases. We can optimize this result by parameterizing it. Using two parameters a and b, with initial value a = 0,b =\u22120.5, the new feature becomes\n((K +a)b)\u00d7MaxRuntime (12)\nWe vary the value of parameters a and b to find the best combination. We have found that for lm (with features ((K + 2.2)\u22120.7)\u00d7MaxRuntime, N and K) trained on data with 10 \u2264 N \u2264 20,2 \u2264 K \u2264 N and tested on data of N = 40,2\u2264 K \u2264 N, the best combination is a = 2.2,b =\u22120.68, with Mean Absolute Error (MAE) of 7.04.\nAdding more parameters can improve the accuracy of our model, but may result in overfitting. Overfitting refers to fitting the training set very well, while failing to generalize to new test data. To check against this, we test the parameter combination on more test sets, where N = 40,60,80,2\u2264 K \u2264 N, while the training set remains 10 \u2264 N \u2264 20,2 \u2264 K \u2264 N. The overall results show that the following parameter combination works well on all test sets a = 2.2,b =\u22120.7 and the final feature used in lm is\n((K +2.2)\u22120.7)\u00d7MaxRuntime (13)"}, {"heading": "6.2.2 Results", "text": "We work with two ground truth datasets for training and testing models for Quicksort. The first set contains data of 10 \u2264 N \u2264 100,2 \u2264 K \u2264 N and N increases by 5. The second set contains data of 100 \u2264 N \u2264 500,2 \u2264 K \u2264 N and N increases by 100. Table 5 shows some sample data from the first dataset. We denote by traina\u2212b a training\nset with a\u2264 N \u2264 b,2\u2264 K \u2264 N, testa\u2212b a test set with a\u2264 N \u2264 b,2\u2264 K \u2264 N, and lma\u2212b, an lm model trained on traina\u2212b. These notations are listed in Table 6. Figure 7 shows the predicted results of lm10\u221220 on test40\u221240, the values of data in train10\u221220, and the true value of the SC of Quicksort in test40\u221240.\nTable 7 shows the MAE and MAPE of lm trained on different training sets and tested on various test sets. Generally speaking, the larger the training set, the better the test results, and the greater the N values in test set, the worse the prediction accuracy. For test set with small N values (e.g., N \u2264 100), MAPE is around 3%. However, when tested on greater N values (e.g., N \u2265 200), MAPE \u2265 10%."}, {"heading": "6.2.3 Discussion", "text": "The main idea behind TLR-SC is to transfer a nonlinear regression problem into a linear one, by manipulating data and features. The advantage is that we can use a simple algorithm - linear regression, to handle a complex data shape in one step, and therefore the TLR-SC model is really simple. This model shows the importance of analyzing the data and understanding the relationship between features and prediction target. No matter how powerful the learning algorithm (e.g., WEKA algorithms), it cannot automatically solve the problem without human knowledge.\nAlthough the TLR-SC results are very encouraging, the accuracy drops quickly when the N value of the test set is large. One reason might be that the training is not enough, so the model cannot show its full ability in learning and predicting. It is difficult to expect it performing well on test sets with N \u2265 300, when we only train it on data of N \u2264 20. Besides, transforming the data and features to create a linear relationship may cause the prediction error of linear regression to be distorted (Motulsky, 2004). Another reason is that possibly other functions may work better than our choice Kb. Most importantly, as discussed in Section 5, the relationship between SC and K is changing, given different values of N. The greater N is, the quicker SC decreases when K increases. Unfortunately, our customized feature does not capture this well. Although the value of feature ((K+a)b)\u00d7MaxRuntime changes with N, the parameters a and b do not. However, parameter b is the most important one in fitting the curve, and if we can make b change based on N, the performance of TLR-SC should improve. In the next section, we present a new model that implements this observation.\nAnother disadvantage of TLR-SC is that it is hard to transfer to other algorithms. The feature ((K+2.2)\u22120.7)\u00d7 MaxRuntime is created to fit the data shape of Quicksort. Other algorithms may have a totally different shape, therefore the model may not be applicable to other algorithms by solely changing the value of parameters. The biggest problem with the transition is that for other algorithms, we lack the necessary amount of data to analyze the data shape, so it is difficult to find the right function shape.\n6.3 Model NLR-SC\nIn this section, we propose a new model for predicting the SC, NLR-SC (Non-linear Regression for Smoothed Complexity). This is an updated model, aimed at solving the problems of TLR-SC. We previously showed that by carefully capturing the nonlinear data shape, TLR-SC can dramatically increase the accuracy of prediction. Nevertheless, the relationship between SC and the perturbation parameter K is changing, for different values of N, and the fixed parameters a and b limit the ability of TLR-SC to capture this changing shape, as well as to be transferred to other sorting algorithms.\nTo solve these problems, NLR-SC breaks down the surface-fitting problem into multiple curve-fitting problems. By predicting the SC curve by curve, NLR-SC gradually predicts the whole surface. We deal with three type of curves in NLR-SC, first one, the curve of SC and K, for fixed N, is shown in blue in Figure 8. Because the shape between the SC and K changes for different N, we divide the surface into curves by N values, and predict these curves one by one. For instance, to predict the SC of 40 \u2264 N \u2264 50,2 \u2264 K \u2264 N, we first predict the SC of N = 40,2 \u2264 K \u2264 N, then N = 41,2 \u2264 K \u2264 N, then N = 42,2 \u2264 K \u2264 N, . . . , until N = 50,2 \u2264 K \u2264 N. For each N, we re-calculate the parameters in the fitting function, so that we capture the data shape of the SC. For this, we employ nls, an R model fitting library, which automatically determines the nonlinear least-squares estimates of the parameters. nls works well when the function shape is decided, but the parameters of the function are uncertain. We refer to nls predicting the first type of curve as sub model NLR-SC-N.\nBy fixing K to 2 or N, we can get two more curves of the SC and N, shown in red and green in Figure 8. When we try to use data of small N and K, to predict the SC of large N and K, these two curves are bridges between training data and the predicted target, and they define the starting point and the ending point of curve one. The reason for fixing K to 2 and N is that, according to the theory of smoothed analysis, we know that when K = 2, the curve of the SC and N follows the worst-case behaviour, while when K = N, the curve follows the average-case\nbehaviour. Therefore, we can use two lm models to capture these two curves well, and supply NLR-SC-N with their prediction as a training set. We refer to this part as submodel NLR-SC-K.\nNLR-SC is the combination of NLR-SC-N and NLR-SC-K, shown in Figure 9. By fixing either N or K, we simplify the data shape and make the hidden patterns explicit."}, {"heading": "6.3.1 NLR-SC: Fixed N", "text": "We predict the SC of data of fixed N, using nls. The function we fit with nls is\na( K N + c)b +d (14)\nwhere a, b, c, d are parameters to be fitted. Equation 14 is inspired by the feature used in TLR-SC:\n((K +2.2)\u22120.7)\u00d7MaxRuntime (15)\nCompared to Equation 15, in Equation 14, we replace the MaxRuntime by a to increase the flexibility. In addition, we chose KN instead of K in Equation 14, because the maximum value of K depends on the value of N, and we need the nls model to work on all N values, therefore it is better to use the proportion of K to N, rather than the absolute value of K. We ran an experiment to examine the minimum training data that nls needs, to deliver good results. Figure 10 shows how nls performs when trained on data of N = 100,2\u2264 K \u2264 16 and N = 100,2\u2264 K \u2264 6 separately. Green spots in Figure 10 are training data, red spots are test data, and the blue line is the predicted result.\nWe see from Figure 10 that the performance of nls is already very good with only 5 training examples. This is likely due to the fact that Equation 14 fits the data well. The main reason why the accuracy decreases when we\nTraining Set Size 15\nTraining Set Size 5\nreduce the the training set is that the algorithm does not get enough information about where the SC will decrease to, in other words, what is the value of the SC when N = 100,K = N. By adding the data entry of N = 100,K = N into the training set, the prediction accuracy is greatly improved. Shown in Figure 11, with one extra data entry in the training set, nls easily finds the perfect fit to the curve.\nAs shown in Figure 12, examining data with N = 20,100,200,500, as long as the training data contains entries whose K = 2, and K = N, nls can find the perfect fit using only 5 training cases. Note that the size of the training\nset must be larger than the number of parameters in nls, and more parameters generally means higher prediction accuracy.\nAlthough both submodel NLR-SC-N of NLR-SC, and model TLR-SC, deal with the same nonlinear relationship, they take two different approaches. TLR-SC solves a surface fitting problem, using training data of small N and K, predicting the SC for large N and K, while NLR-SC-N solves a curve fitting problem, using training data of a specific N and some K values, predicting the SC of same N and other K values. The NLR-SC-N can be used to solve the same surface fitting problem as TLR-SC does, by dividing the surface into multiple curves by N, and solving them one by one. Because, for each N value, a new curve is constructed by nls, NLR-SC-N can capture the changing shape between the SC and K more accurately than TLR-SC, without causing overfitting.\nThe only problem now is how to generate training data for NLR-SC-N. To predict the SC of a specific N value, nls needs at least 5 training examples of same N value, K = 2, K = N and other K values. If N is large, we cannot collect such training data through an experimental approach. Therefore, we use submodel NLR-SC-K to predict the required training data for NLR-SC-N."}, {"heading": "6.3.2 NLR-SC: Fixed K", "text": "Submodel NLR-SC-K is created to generate the training data for nls in NLR-SC-N. As explained in the previous section, nls needs two important training data points, whith K = 2 and K = N, to determine the starting point and the ending point of the curve. As shown in Figure 13, when K = 2, the SC of Quicksort increases while N increases, following the worst-case behavior O(N2). Similarly, when K = N, the SC follows the average-case behavior O(N logN). Both experimental and theoretical results support this finding.\nThese two patterns are so clear that we can use two lm models to fit the curves. One model focuses on K = 2: we use N2 and N as features in lm, train it on data with small N, and test it on data with big N. Similarly, we fit another lm model for K = N: we use N\u00d7 log(N) and N as features. Results are shown in Figure 14 and Figure 15.\nN=20\nN=100\nBesides K = 2 and K = N, the SC of K values close to 2 or N can also be predicted. For example, the lm model which is applicable for K = 2, is also applicable for K = 3,K = 4, and K = 5. Similarly, the lm model which is applicable for K = N, is also applicable for K = N\u22121,K = N\u22122, and K = N\u22123. However, the accuracy of such predicted results might be compromised a little, and it is better to keep the value of K close to 2 and N. By using these two lm models, we can generate the necessary training cases for NLR-SC-N.\n6.4 Combining the NLR-SC-N and NLR-SC-K\nNLR-SC is the combination of NLR-SC-N and NLR-SC-K. NLR-SC-N is used to predict the SC of fixed large N, using nls, and NLR-SC-K is used to produce training data for NLR-SC-N, using lm.\nIn NLR-SC-N, for each N value we want to predict the SC for, we create a standalone nls model. Figure 16 shows 3 nls models for predicting the SC of N = 40,45,50, 6 \u2264 K \u2264 N \u2212 1. Each nls is trained on 5 training examples, marked as green stars, and these 3 nls models work one by one to predict the target surface of 40\u2264N \u2264 50, 6\u2264 K \u2264 N\u22121. In NLR-SC-K, for each K value we want to predict the SC for, we also create a standalone lm model. Figure 17 shows 5 lm models for predicting the SC of 40 \u2264 N \u2264 50, K = 2,3,4,5,N. Each lm is trained on 3 training examples of N = 10,15,20 and same K value as the prediction target, marked as green stars. These 5 lm models also work one by one to predict the SC of 40\u2264 N \u2264 50, K = 2,3,4,5,N. The most important point of the combination is that the training examples of NLR-SC-N are the predicted results of NLR-SC-K. In Figure 17, the red stars representing the predicted result of NLR-SC-K, change to green in Figure 17, indicating they are the training examples of NLR-SC-N. In other words, NLR-SC-N is built on the predicted results of NLR-SC-K.\nFigure 18 shows the final combination: NLR-SC. When we consider NLR-SC-N and NLR-SC-K together, the training set of the whole model is data of 10 \u2264 N \u2264 20, K = 2,3,4,5,N, and the prediction target is data of 40 \u2264 N \u2264 50, 2 \u2264 K \u2264 N, marked as green and red stars in Figure 18. This demonstrates the ability of NLR-SC to use training data of small N and K to predict the data of big N and K (as we will show, NLR-SC also works well for N = 3000). We give the detailed predicting process to explain the combination. As shown in Figure 18, suppose the training data is the SC of Quicksort for N = 10,15,20, 2 \u2264 K \u2264 N, and the test data is the SC of Quicksort for N = 40,45,50, 2 \u2264 K \u2264 N. First, we filter the training data into a smaller dataset TrainK=2, by K = 2, N = 10,15,20 and also filter the test data to a smaller dataset TestK=2, by K = 2, N = 40,45,50. Table 8 shows the data in TrainK=2 and TestK=2. Next, we train lm in NLR-SC-K on TrainK=2, using features N2 and N,\nNLR\u2212SC\u2212N\nTraining Data of NLR\u2212SC\u2212N Test Data of NLR\u2212SC\u2212N\nNLR\u2212SC\u2212K\nTraining Data of NLR\u2212SC\u2212K Test Data of NLR\u2212SC\u2212K\nNLR\u2212SC\nTraining Data of NLR\u2212SC Test Data of NLR\u2212SC\nand test it on TestK=2. We calculate the prediction error, and prepare the predicted results into different training sets for NLR-SC-N: TrainN=40, TrainN=45, and TrainN=50, by N value. We repeat this process for K = 3,4,5 and K = N. Note that for K = N, we change the features in lm to N\u00d7 log(N) and N.\nNow we have 3 training sets, TrainN=40, TrainN=45, and TrainN=50. Each training set contains 5 training examples, and we divide the test data into 3 test sets by N, and refer to them as TestN=40, TestN=45, and TestN=50. Table 9 shows the data in TrainN=40 and TestN=40. We train NLR-SC-N on TrainN=40 and test it on TestN=40. We repeat this process for the other 2 training and test sets. Prediction errors are calculated for each step and in total, as shown in Table 10. This example demonstrates how the two sub-models are combined, as well as the ability of NLR-SC to predict the SC for large N, using very little training data. MAPE is less than 1%, which is much less than any model or algorithms that we have studied before. One of the reasons why this model performs very well is that it takes advantage of the theory of smoothed analysis. Because NLR-SC-K relies on the data patterns\nthat relate to the worst-case and the average-case behaviour, it leads to very good prediction quality. Therefore NLR-SC-N, that is trained on the results of NLR-SC-K, also delivers good prediction results.\n6.5 Other Sorting Algorithms\nThe biggest advantage of NLR-SC is that it can be applied to algorithms other than Quicksort. In this work we also present experiments with NLR-SC for M3Quicksort, optimized Bubblesort and Mergesort.\nWe can explain NLR-SC in three steps. First, it predicts the worst-case runtime of a given list length N. Then it predicts the average-case runtime of the same N. Finally, it predicts how the SC turns from worst-case runtime to the average-case runtime. Therefore, as long as we know the worst-case and average-case complexity of an algorithm and have some small amount of ground truth data, technically, the algorithm\u2019s SC can be predicted by NLR-SC. Although the data shape of the SC of other algorithms is different to Quicksort\u2019s, NLR-SC can easily adjust to this difference. All we need to do for the transition is to select the correct lm model to predict the worstcase and average-case complexity, which is dictated by the theory. For instance, unlike Quicksort, Mergesort\u2019s worst-case and average-case complexity are both O(Nlog(N)). Therefore, in NLR-SC-K, we simply replace the features of the lm models to N\u00d7 log(N) and N, then the NLR-SC for predicting the SC of Mergesort can be used as is.\n7 Detailed Results of NLR-SC\n7.1 QuickSort\nWe first train and test NLR-SC on Quicksort. We work with three sets of data. The first set contains data of 10 \u2264 N \u2264 100,2 \u2264 K \u2264 N and N increases by 5. The second set contains data of 100 \u2264 N \u2264 500,2 \u2264 K \u2264 N and N increases by 100. The last set contains data of 600 \u2264 N \u2264 3000,2 \u2264 K \u2264 N and N increases by 300. We define traina\u2212b as a training set of a \u2264 N \u2264 b, testa\u2212b as a test set of a \u2264 N \u2264 b, and nls&lma\u2212b as a NLR-SC trained on traina\u2212b. In addition, we define nls&lmta\u2212b as the NLR-SC with t number of lm models in NLR-SC-K, which means, the nls in NLR-SC-N is trained on t number of training examples. For all NLR-SC examples we\ndiscussed in previous sections, their t value is 5, i.e., they have 5 lm models in NLR-SC-K for K = 2,3,4,5,N. In our experiments we found that the higher the t values, the more accurate the prediction. These terms are also listed in Table 11.\nTable 12 shows the MAE and MAPE of NLR-SC trained on different training sets, tested on various test sets. The first model nls&lm510\u221220 is trained on data of N = 10,15,20, with 5 lm models in NLR-SC-K. The second model nls&lm510\u221280 is similar to the first one, but trained on bigger dataset of 10 \u2264 N \u2264 80, and so on. The nls&lm610\u221220 model, on the other hand, has the same training set as the first model, but has 6 lm models in NLRSC-K. Based on the test results, we can see that simply increasing the size of the training data for NLR-SC, does not improve the accuracy, but increasing the number of lm models in NLR-SC-K, which also means increasing the training examples of NLR-SC-N, improves the accuracy.\nComparing to Table 7, Table 12 shows that NLR-SC has a much better prediction accuracy than TLR-SC. The average MAPE of NLR-SC on any test set is around 0.5% to 3%. Unlike TLR-SC, the error does not increase quickly when the size of the test set increases. Due to the computational requirements of modular smoothed analysis, the maximum test data we can collect through the modular approach is N = 3000, and NLR-SC performs well on it, with around 4% MAPE. Based on current test results, we expect NLR-SC to perform well on even larger N, but we currently lack the ground truth data to showcase this.\nThe most encouraging point of the test results is that we only use very few training examples to achieve such accurate prediction results. For model nls&lm510\u221220, the number of training examples it trained on is only 15. It means that if we apply NLR-SC to other algorithms, and only use the data collected through an experimental ap-\nproach, we can still predict the SC of N greater than 1,000. To our best knowledge, for now, only modular smoothed analysis can achieve that, and only for a restricted class of sorting algorithms (Quicksort and M3Quicksort) so far.\n7.2 M3Quicksort\nWe also applied NLR-SC to other algorithms. Table 13 shows MAE and MAPE of the prediction for M3Quicksort, for which we collected data through the modular approach. Note that the recurrence equation of modular smoothed analysis for M3Quicksort only works for K\u2265 4, therefore, we do not have the SC of K = 2, and K = 3. And because of the factorial calculation in the formula, the maximum data we can collect is N \u2264 130, 4 \u2264 K \u2264 N. Prediction on higher N values cannot be validated due to the lack of ground truth data.\nNLR-SC relies on the data of K = 2 and K = 3 to ensure the accuracy of NLR-SC-K, as well as the whole model, but the modular approach formula of M3Quicksort cannot supply them. We have to make NLR-SC work on data of K = 4,5,6,7 instead, and use Train15\u221225 instead of Train10\u221220, because when N = 10,K = 7, the SC is not at all the worst-case behavior, while when N = 15,K = 7, the SC is comparably closer to the worst-case behavior. This is why nls&lm540\u221250 gives a better result than nls&lm 5 15\u221225: for N = 40,K = 7, the SC is closer to the worst-case behaviour than for N = 15,K = 7. Besides, similar to the Quicksort results, adding in more lm models in NLR-SC-K (i.e. more training examples in NLR-SC-N) can improve the accuracy.\n7.3 Optimized Bubblesort\nWe also test NLR-SC on optimized Bubblesort, for which we collected data through the experimental approach. The size of the dataset is 50, with 3\u2264 N \u2264 15 and 2\u2264 K \u2264 N. Due to the limited computation power, the higher the N value, the less data we can collect, e.g., for N = 15 we can only collect ground truth data up to K = 4.\nThe original Bubblesort\u2019s worst-case runtime is equal to its average-case runtime. The optimized Bubblesort that we used in this paper has better performance on part of the input lists, but its average-case complexity remains O(N2), which is different from Quicksort. The good news is that NLR-SC can easily adjust to such difference. By simply replacing the feature N\u00d7 log(N) in lm models to N2, NLR-SC is able to capture the SC of algorithms whose average-case and worst-case complexity are both O(N2). Considering the limited amount of the ground truth data, we reduce the number of lm models as well as the number of parameters in nls to 4. Thus, NLR-SC only uses 12 training examples, that follow either worst-case or average-case behavior.\nExperimental Data Predicted Result\nExperimental Data Predicted Result\nTable 14 shows the error of the predicted results. Due to the shortage of ground truth data, we only test NLRSC on a test set of N = 9 and N = 10. The predicted results are fairly good, with MAE of 0.05 and MAPE of 0.16%.\nFigure 19a shows the plot of the predicted results. The green spots are the experimentally collected data, while red stars are predicted results of NLR-SC, where the real values of these data are unknown and cannot be collected through an experimental approach. We observe from the plot that the predicted results seem to agree with the trend of the experimental data, but have no ground truth data to numerically validate them.\n7.4 Mergesort\nSimilar to Bubblesort, the data of Mergesort is collected through the experimental approach. The total number of examples is 50, with data of 3 \u2264 N \u2264 15 and 2 \u2264 K \u2264 N. Both the worst-case complexity and the average-case\ncomplexity of Mergesort is O(Nlog(N)), therefore, we change all N2 features in lm models to N\u00d7 log(N). Similar to Bubblesort, because of the limited ground truth data, we reduce the number of lm models as well as the number of parameters in nls to 4. Tested on N = 9 and N = 10, the error of the predicted results of NLR-SC for Mergesort are shown in Table 14. Figure 19b shows the plot of the predicted results. Although the data shape of Mergesort is different to Bubblesort, the SC prediction accuracy is still high. Figure 20 shows the predicted SC of Quicksort,\nM3Quicksort, optimized Bubblesort and Mergesort given by NLR-SC, for N \u2264 60, 2\u2264 K \u2264 N."}, {"heading": "8 Conclusion", "text": "In this work, we present two regression models for predicting the Smoothed Complexity (denoted as SC) of sorting algorithms. The first model, TLR-SC, uses linear regression to predict the complex data surface of the SC. It transfers a nonlinear relationship into a linear one, by transforming the original features. TLR-SC has a simple structure and is very efficient, although it is aimed at Quicksort and is not easily transferable to other sorting algorithms. The second model, NLR-SC, takes an iterative approach. It divides the surface fitting problem into multiple curve fitting problems and by predicting curves one by one, it gradually predicts the entire surface. NLR-SC takes advantage of the theory of the smoothed analysis, which leads to its very good performance. With 15 training examples, NLR-SC can predict the SC of Quicksort for N \u2265 3000, with around 3% Mean Absolute Percentage Error. The rules NLR-SC relies on are general and grounded on the theory of SC: when the list perturbation parameter K approaches 1, the SC of any sorting algorithm follows the worst-case behavior, and when K approaches N, the SC follows the average-case behavior. Therefore, technically, as long as we know the worst-case and average-case complexity of a sorting algorithm, and have a small amount of training examples, we can use NLR-SC to predict the SC of the algorithm.\nIn this work we study the SC of four sorting algorithms and show that our prediction models deliver high quality results. A large part of our study focuses on data collection and analysis, since to start with, there is very limited availability of ground truth data, to test our prediction models. By getting a good understanding of the data shape and the relationship between features and the SC, we construct two predictive models that work very well with limited training data, and show that the shortage of data can be made up by the adequate background knowledge, in our case provided by the theory of SC. Our work fills the gap between known theoretical and empirical results on the behaviour of the Smoothed Complexity of sorting algorithms. By taking a machine learning approach, we build predictive models that are scalable for large input sizes, therefore advancing currently existing techniques. In the future, we plan to further analyze the potential of our prediction models, by studying other (than sorting) type of algorithms working on discrete data."}, {"heading": "9 Acknowledgements", "text": "This work was supported by Science Foundation Ireland under grant 07/CE/I1147 and 07/IN.1/I977."}], "references": [{"title": "k-means has polynomial smoothed complexity", "author": ["D. Arthur", "B. Manthey", "H. Roglin"], "venue": null, "citeRegEx": "Arthur et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Arthur et al\\.", "year": 2009}, {"title": "Smoothed analysis of three combinatorial problems", "author": ["C. Banderier", "R. Beier", "K. Mehlhorn"], "venue": "In Mathematical Foundations of Computer Science", "citeRegEx": "Banderier et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Banderier et al\\.", "year": 2003}, {"title": "Smoothed analysis of the perceptron algorithm for linear programming", "author": ["A. Blum", "J. Dunagan"], "venue": "In Proceedings of the thirteenth annual ACM-SIAM symposium on Discrete algorithms,", "citeRegEx": "Blum and Dunagan,? \\Q2002\\E", "shortCiteRegEx": "Blum and Dunagan", "year": 2002}, {"title": "Improved smoothed analysis of the shadow vertex simplex method", "author": ["A. Deshpande", "D.A. Spielman"], "venue": "In Foundations of Computer Science,", "citeRegEx": "Deshpande and Spielman,? \\Q2005\\E", "shortCiteRegEx": "Deshpande and Spielman", "year": 2005}, {"title": "The Elements of Statistical Learning", "author": ["T. Hastie", "R. Tibshirani", "J. Friedman"], "venue": null, "citeRegEx": "Hastie et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hastie et al\\.", "year": 2013}, {"title": "Modular smoothed analysis of median-of-three quicksort", "author": ["A. Hennessy", "M. Schellekens"], "venue": "Technical Report,", "citeRegEx": "Hennessy and Schellekens,? \\Q2014\\E", "shortCiteRegEx": "Hennessy and Schellekens", "year": 2014}, {"title": "The Art of Computer Programming, Volume III: Sorting and Searching", "author": ["D.E. Knuth"], "venue": null, "citeRegEx": "Knuth,? \\Q1973\\E", "shortCiteRegEx": "Knuth", "year": 1973}, {"title": "Fitting models to biological data using linear and nonlinear regression: a practical guide to curve fitting", "author": ["H. Motulsky"], "venue": "OUP USA", "citeRegEx": "Motulsky,? \\Q2004\\E", "shortCiteRegEx": "Motulsky", "year": 2004}, {"title": "A Modular Calculus for the Average Cost of Data Structuring: Efficiency-Oriented Programming in MOQA", "author": ["M. Schellekens"], "venue": null, "citeRegEx": "Schellekens,? \\Q2008\\E", "shortCiteRegEx": "Schellekens", "year": 2008}, {"title": "Modular smoothed analysis", "author": ["M. Schellekens", "A. Hennessy", "B. Shi"], "venue": "Technical Report,", "citeRegEx": "Schellekens et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Schellekens et al\\.", "year": 2014}, {"title": "A Machine Learning Approach For Estimating The Smoothed Complexity Of Sorting Algorithms", "author": ["B. Shi"], "venue": null, "citeRegEx": "Shi,? \\Q2013\\E", "shortCiteRegEx": "Shi", "year": 2013}, {"title": "Smoothed analysis of algorithms: Why the simplex algorithm usually takes polynomial time", "author": ["D. Spielman", "Teng", "S.-H"], "venue": "In Proceedings of the thirty-third annual ACM symposium on Theory of computing,", "citeRegEx": "Spielman et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Spielman et al\\.", "year": 2001}, {"title": "Smoothed analysis of algorithms and heuristics", "author": ["D.A. Spielman", "S. Teng"], "venue": "LONDON MATHEMATICAL SOCIETY LECTURE NOTE SERIES,", "citeRegEx": "Spielman and Teng,? \\Q2006\\E", "shortCiteRegEx": "Spielman and Teng", "year": 2006}, {"title": "Smoothed analysis of algorithms. ArXiv Mathematics e-prints", "author": ["D.A. Spielman", "Teng", "S.-H"], "venue": null, "citeRegEx": "Spielman et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Spielman et al\\.", "year": 2002}, {"title": "Smoothed analysis: an attempt to explain the behavior of algorithms in practice", "author": ["D.A. Spielman", "Teng", "S.-H"], "venue": "Communications of the ACM,", "citeRegEx": "Spielman et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Spielman et al\\.", "year": 2009}, {"title": "Data Mining: Practical Machine Learning Tools and Techniques", "author": ["I.H. Witten", "E. Frank", "M.A. Hall"], "venue": null, "citeRegEx": "Witten et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Witten et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 12, "context": "Motivated by the observation that, in practice, input parameters are often subject to a small degree of random noise, SC measures the expected performance of algorithms under slight random perturbations of the worst-case inputs (Spielman and Teng, 2006).", "startOffset": 228, "endOffset": 253}, {"referenceID": 3, "context": "The SC bounds of many algorithms have been given, including the Simplex Algorithm, that has exponential worst-case complexity but polynomial SC (Spielman and Teng, 2001; Deshpande and Spielman, 2005), Quasi-Concave Minimization, an NP-hard problem, but with polynomial SC under certain conditions (Spielman and Teng, 2009), and Quicksort, with worst-case complexity O(N2), but SC of O(p lnN), where p \u2208 [0,1] (Banderier et al.", "startOffset": 144, "endOffset": 199}, {"referenceID": 1, "context": "The SC bounds of many algorithms have been given, including the Simplex Algorithm, that has exponential worst-case complexity but polynomial SC (Spielman and Teng, 2001; Deshpande and Spielman, 2005), Quasi-Concave Minimization, an NP-hard problem, but with polynomial SC under certain conditions (Spielman and Teng, 2009), and Quicksort, with worst-case complexity O(N2), but SC of O(p lnN), where p \u2208 [0,1] (Banderier et al., 2003).", "startOffset": 409, "endOffset": 433}, {"referenceID": 9, "context": "For sorting algorithms, (Schellekens et al., 2014) has shown that the gap between the exact (empirical) value of Quicksort\u2019s SC and its known bound is significant.", "startOffset": 24, "endOffset": 50}, {"referenceID": 8, "context": "Recently, modular smoothed analysis (Schellekens, 2008) has been introduced to better estimate the value of SC for discrete cases.", "startOffset": 36, "endOffset": 55}, {"referenceID": 8, "context": "In (Schellekens, 2008) it was shown that for an algorithm that satisfies random bag preservation, its SC value can be calculated through a recurrence equation.", "startOffset": 3, "endOffset": 22}, {"referenceID": 9, "context": "Although more accurate than the theoretical bounds, modular smoothed analysis currently works only for Quicksort and its median-of-three variant (M3Quicksort) (Schellekens et al., 2014; Hennessy and Schellekens, 2014).", "startOffset": 159, "endOffset": 217}, {"referenceID": 5, "context": "Although more accurate than the theoretical bounds, modular smoothed analysis currently works only for Quicksort and its median-of-three variant (M3Quicksort) (Schellekens et al., 2014; Hennessy and Schellekens, 2014).", "startOffset": 159, "endOffset": 217}, {"referenceID": 12, "context": "For discrete cases, the SC under partial permutation perturbations is the maximum average runtime over all perturbed inputs (Spielman and Teng, 2006; Schellekens et al., 2014).", "startOffset": 124, "endOffset": 175}, {"referenceID": 9, "context": "For discrete cases, the SC under partial permutation perturbations is the maximum average runtime over all perturbed inputs (Spielman and Teng, 2006; Schellekens et al., 2014).", "startOffset": 124, "endOffset": 175}, {"referenceID": 0, "context": "Many machine learning algorithms have been analyzed by smoothed analysis, such as k-means clustering (Arthur et al., 2009) and Support Vector Machines (Blum and Dunagan, 2002; Spielman and Teng, 2009), however,", "startOffset": 101, "endOffset": 122}, {"referenceID": 2, "context": ", 2009) and Support Vector Machines (Blum and Dunagan, 2002; Spielman and Teng, 2009), however,", "startOffset": 36, "endOffset": 85}, {"referenceID": 4, "context": "The techniques to handle regression, curve fitting and surface fitting problems in the machine learning area are quite mature (Hastie et al., 2013).", "startOffset": 126, "endOffset": 147}, {"referenceID": 1, "context": "The discrete version of SC was introduced in (Banderier et al., 2003) and extended in (Schellekens et al.", "startOffset": 45, "endOffset": 69}, {"referenceID": 9, "context": ", 2003) and extended in (Schellekens et al., 2014).", "startOffset": 24, "endOffset": 50}, {"referenceID": 9, "context": "In this work, we use the partial permutation perturbation definition of (Schellekens et al., 2014), where \u03c3 = K N (0\u2264 K \u2264 N), N is the length of the input list:", "startOffset": 72, "endOffset": 98}, {"referenceID": 9, "context": "Definition 2 (Schellekens et al., 2014) Given a problem P with input sequence domain \u2211N , let A be an algorithm for solving P.", "startOffset": 13, "endOffset": 39}, {"referenceID": 9, "context": "1 Modular Smoothed Analysis Modular smoothed analysis was recently introduced in (Schellekens et al., 2014; Hennessy and Schellekens, 2014).", "startOffset": 81, "endOffset": 139}, {"referenceID": 5, "context": "1 Modular Smoothed Analysis Modular smoothed analysis was recently introduced in (Schellekens et al., 2014; Hennessy and Schellekens, 2014).", "startOffset": 81, "endOffset": 139}, {"referenceID": 8, "context": "For algorithms that are random bag preserving (Schellekens, 2008), the number of comparisons of the algorithm running on an input can be captured and calculated through a recurrence equation.", "startOffset": 46, "endOffset": 65}, {"referenceID": 9, "context": "The modular recurrence equation for the SC of Quicksort, f (N,K), is (Schellekens et al., 2014):", "startOffset": 69, "endOffset": 95}, {"referenceID": 5, "context": "The recurrence equation for the SC of M3Quicksort is (Hennessy and Schellekens, 2014):", "startOffset": 53, "endOffset": 85}, {"referenceID": 9, "context": "+3!(K\u22122)! ( N\u22123 K\u22123 )} (N\u2212K)! N! Modular SC values are closer to the traditional SC ones, as compared to the existing mathematical bounds (Schellekens et al., 2014).", "startOffset": 138, "endOffset": 164}, {"referenceID": 6, "context": "(Knuth, 1973).", "startOffset": 0, "endOffset": 13}, {"referenceID": 1, "context": "1 Empirical Approach Although (Banderier et al., 2003) has proven that the SC of Quicksort is O(p ln(N)), this bound is not accurate enough (see (Schellekens et al.", "startOffset": 30, "endOffset": 54}, {"referenceID": 9, "context": ", 2003) has proven that the SC of Quicksort is O(p ln(N)), this bound is not accurate enough (see (Schellekens et al., 2014) for details) to allow us training a supervised machine learning approach.", "startOffset": 98, "endOffset": 124}, {"referenceID": 9, "context": "To obtain better ground truth data for the SC, we first use an experimental approach to compute the SC exactly, by following definitions in (Schellekens et al., 2014).", "startOffset": 140, "endOffset": 166}, {"referenceID": 10, "context": "Our code uses hill climbing and Quicksort-specific worst-case permutation results (Shi, 2013), to push the input size for which we can empirically obtain SC values.", "startOffset": 82, "endOffset": 93}, {"referenceID": 9, "context": "2 Modular Smoothed Analysis Modular smoothed analysis (Schellekens et al., 2014) provides another way to calculate the SC for Quicksort and its median-of-three variant.", "startOffset": 54, "endOffset": 80}, {"referenceID": 15, "context": "The Mean Absolute Error (MAE) is (Witten et al., 2011): MAE = |p1\u2212a1|+ \u00b7 \u00b7 \u00b7+ |pn\u2212an| n (9) When the relative rather than the absolute error values are more important, we use Mean Absolute Percentage Error (MAPE).", "startOffset": 33, "endOffset": 54}, {"referenceID": 15, "context": "MAPE = | p1\u2212a1 a1 |+ | p2\u2212a2 a2 |+ \u00b7 \u00b7 \u00b7+ | pn\u2212an an | n \u00d7100% (10) We also show the Root Mean Squared Error (RMSE), which is more sensitive to outliers (Witten et al., 2011):", "startOffset": 153, "endOffset": 174}, {"referenceID": 15, "context": ", N, K, Runtime, MaxRuntime) and several built-in regression algorithms of the open source machine learning software Weka (Witten et al., 2011).", "startOffset": 122, "endOffset": 143}, {"referenceID": 7, "context": "Besides, transforming the data and features to create a linear relationship may cause the prediction error of linear regression to be distorted (Motulsky, 2004).", "startOffset": 144, "endOffset": 160}], "year": 2015, "abstractText": "Smoothed analysis is a framework for analyzing the complexity of an algorithm, acting as a bridge between average and worst-case behaviour. For example, Quicksort and the Simplex algorithm are widely used in practical applications, despite their heavy worst-case complexity. Smoothed complexity aims to better characterize such algorithms. Existing theoretical bounds for the smoothed complexity of sorting algorithms are still quite weak. Furthermore, empirically computing the smoothed complexity via its original definition is computationally infeasible, even for modest input sizes. In this paper, we focus on accurately predicting the smoothed complexity of sorting algorithms, using machine learning techniques. We propose two regression models that take into account various properties of sorting algorithms and some of the known theoretical results in smoothed analysis to improve prediction quality. We show experimental results for predicting the smoothed complexity of Quicksort, Mergesort, and optimized Bubblesort for large input sizes, therefore filling the gap between known theoretical and empirical results.", "creator": "LaTeX with hyperref package"}}}