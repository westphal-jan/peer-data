{"id": "1505.06813", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-May-2015", "title": "Surrogate Functions for Maximizing Precision at the Top", "abstract": "The problem of maximizing precision at the top of a ranked list, often dubbed Precision@k (prec@k), finds relevance in myriad learning applications such as ranking, multi-label classification, and learning with severe label imbalance. However, despite its popularity, there exist significant gaps in our understanding of this problem and its associated performance measure. While many of these areas have been underrepresented in any ranking system, there are some important areas of concern: it is common for students to be classified in this category, but it can take a very long time for students to get used to this information.\n\n\nThe above list is a sampling of the areas that we do not have in mind:", "histories": [["v1", "Tue, 26 May 2015 06:01:24 GMT  (95kb,D)", "http://arxiv.org/abs/1505.06813v1", "To appear in the the proceedings of the 32nd International Conference on Machine Learning (ICML 2015)"]], "COMMENTS": "To appear in the the proceedings of the 32nd International Conference on Machine Learning (ICML 2015)", "reviews": [], "SUBJECTS": "stat.ML cs.LG", "authors": ["purushottam kar", "harikrishna narasimhan", "prateek jain 0002"], "accepted": true, "id": "1505.06813"}, "pdf": {"name": "1505.06813.pdf", "metadata": {"source": "CRF", "title": "Surrogate Functions for Maximizing Precision at the Top", "authors": ["Purushottam Kar", "Harikrishna Narasimhan", "Prateek Jain"], "emails": ["t-purkar@microsoft.com", "harikrishna@csa.iisc.ernet.in", "prajain@microsoft.com", "Precision@k", "(prec@k),", "prec@k.", "prec@k.", "prec@k", "prec@k", "prec@k", "prec@k.", "Precision@k,", "Precision@k", "(prec@k)", "prec@k", "prec@k", "prec@k,", "prec@k"], "sections": [{"heading": null, "text": "The most notable of these is the lack of a convex upper bounding surrogate for prec@k. We also lack scalable perceptron and stochastic gradient descent algorithms for optimizing this performance measure. In this paper we make key contributions in these directions. At the heart of our results is a family of truly upper bounding surrogates for prec@k. These surrogates are motivated in a principled manner and enjoy attractive properties such as consistency to prec@k under various natural margin/noise conditions.\nThese surrogates are then used to design a class of novel perceptron algorithms for optimizing prec@k with provable mistake bounds. We also devise scalable stochastic gradient descent style methods for this problem with provable convergence bounds. Our proofs rely on novel uniform convergence bounds which require an in-depth analysis of the structural properties of prec@k and its surrogates. We conclude with experimental results comparing our algorithms with state-of-the-art cutting plane and stochastic gradient algorithms for maximizing prec@k."}, {"heading": "1 Introduction", "text": "Ranking a given set of points or labels according to their relevance forms the core of several real-life learning systems. For instance, in classification problems with a rare-class as is the case in spam/anomaly detection, the goal is to rank the given emails/events according to their likelihood of being from the rare-class (spam/anomaly). Similarly, in multilabel classification problems, the goal is to rank the labels according to their likelihood of being relevant to a data point Tsoumakas and Katakis [2007].\nThe ranking of items at the top is of utmost importance in these applications and several performance measures, such as Precision@k, Average Precision and NDCG have been designed to promote accuracy at top of ranked lists. Of these, the Precision@k (prec@k) measure is especially popular in a variety of domains. Informally, prec@k counts the number of relevant items in the top-k positions of a ranked list and is widely used in domains such as binary classification Joachims [2005], multi-label classification Prabhu and Varma [2014] and ranking Le and Smola [2007].\nGiven its popularity, prec@k has received attention from algorithmic, as well as learning theoretic perspectives. However, there remain specific deficiencies in our understanding of this performance measure. In fact, to the best of our knowledge, there is only one known convex surrogate function for prec@k, namely, the struct-SVM surrogate due to Joachims [2005] which, as we reveal in this work, is not an upper bound on prec@k in general, and need not recover an optimal ranking even in strictly separable settings.\nOur aim in this paper is to develop efficient algorithms for optimizing prec@k for ranking problems with binary relevance levels. Since the intractability of binary classification in the agnostic setting Guruswami and Raghavendra [2009] extends to prec@k, our goal would be to exploit natural notions of benign-ness usually observed in natural distributions to overcome such intractability results. \u2217 Work done while H.N. was an intern at Microsoft Research India, Bangalore.\nar X\niv :1\n50 5.\n06 81\n3v 1\n[ st\nat .M\nL ]\n2 6\nM ay\n2 01"}, {"heading": "1.1 Our Contributions", "text": "We make several contributions in this paper that both, give deeper insight into the prec@k performance measure, as well as provide scalable techniques for optimizing it.\nPrecision@k margin: motivated by the success of margin-based frameworks in classification settings, we develop a family of margin conditions appropriate for the prec@k problem. Recall that the prec@k performance measure counts the number of relevant items at the top k positions of a ranked list. The simplest of our margin notions, that we call the weak (k, \u03b3)-margin, is said to be present if a privileged set of k relevant items can be separated from all irrelevant items by a margin of \u03b3. This is the least restrictive margin condition that allows for a perfect ranking w.r.t prec@k. Notably, it is much less restrictive than the binary classification notion of margin which requires all relevant items to be separable from all irrelevant items by a certain margin. We also propose two other notions of margin suited to our perceptron algorithms.\nSurrogate functions for prec@k: we design a family of three novel surrogates for the prec@k performance measure. Our surrogates satisfy two key properties. Firstly they always upper bound the prec@k performance measure so that optimizing them promotes better performance w.r.t prec@k. Secondly, these surrogates satisfy conditional consistency in that they are consistent w.r.t. prec@k under some noise condition. We show that there exists a one-one relationship between the three prec@k margin conditions mentioned earlier and these three surrogates so that each surrogate is consistent w.r.t. prec@k under one of the margin conditions. Moreover, our discussion reveals that the three surrogates, as well as the three margin conditions, lie in a concise hierarchy.\nPerceptron and SGD algorithms: using insights gained from the previous analyses, we design two perceptronstyle algorithms for optimizing prec@k. Our algorithms can be shown to be a natural extension of the classical perceptron algorithm for binary classification Rosenblatt [1958]. Indeed, akin to the classical perceptron, both our algorithms enjoy mistake bounds that reduce to crisp convergence bounds under the margin conditions mentioned earlier. We also design a mini-batch-style stochastic gradient descent algorithm for optimizing prec@k.\nLearning theory: in order to prove convergence bounds for the SGD algorithm, and online-to-batch conversion bounds for our perceptron algorithms, we further study prec@k and its surrogates and prove uniform convergence bounds for the same. These are novel results and require an in-depth analysis into the involved structure of the prec@k performance measure and its surrogates. However, with these results in hand, we are able to establish crisp convergence bounds for the SGD algorithm, as well as generalization bounds for our perceptron algorithms.\nPaper Organization: Section 2 presents the problem formulation and sets up the notation. Section 3 introduces three novel surrogates and margin conditions for prec@k and reveals the interplay between these with respect to consistency to prec@k. Section 4 presents two perceptron algorithms for prec@k and their mistake bounds, as well as a mini-batch SGD-based algorithm. Section 5 discusses uniform convergence bounds for our surrogates and their application to convergence and online-to-batch conversion bounds for our the perceptron and SGD-style algorithms. We conclude with empirical results in Section 6."}, {"heading": "1.2 Related Work", "text": "There has been much work in the last decade in designing algorithms for bipartite ranking problems. While the earlier methods for this problem, such as RankSVM, focused on optimizing pair-wise ranking accuracy Herbrich et al. [2000], Joachims [2002], Freund et al. [2003], Burges et al. [2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cle\u0301menc\u0327on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014].\nIn this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k.\nIt is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al. [2007], Yue et al. [2007], Le and Smola [2007], Chakrabarti et al. [2008],\nYun et al. [2014]. There has also been some recent work on perceptron style ranking methods for list-wise ranking problems Chaudhuri and Tewari [2014], but these methods are tailored to optimize the NDCG and MAP measures, which are different from the prec@k measure that we consider here. Other less related works include online ranking algorithms for optimizing ranking measures in an adversarial setting with limited feedback Chaudhuri and Tewari [2015]."}, {"heading": "2 Problem Formulation and Notation", "text": "We will be presented with a set of labeled points (xi, yi), . . . , (xn, yn), where xi \u2208 X and yi \u2208 {0, 1}. We shall use X to denote the entire dataset, X+ and X\u2212 to denote the set of positive and negatively (null) labeled points, and y \u2208 {0, 1}n to denote the label vector. z = (x, y) shall denote a labeled data point. Our results readily extend to multi-label and ranking settings but for sake of simplicity, we focus only on bipartite ranking problems, where the goal is to rank (a subset of) positive examples above the negative ones.\nGiven n labeled data points z1, . . . , zn and a scoring function s : X \u2192 R, let \u03c3s \u2208 Sn be the permutation that sorts points according to the scores given by s i.e. s(x\u03c3s(i)) \u2265 s(x\u03c3s(j)) for i \u2264 j. The Precision@k measure for this scoring function can then be expressed as:\nprec@k(s; z1, . . . , zn) = k\u2211 i=1 (1\u2212 y\u03c3s(i)). (1)\nNote that the above is a \u201closs\u201d version of the performance measure which penalizes any top-k ranked data points that have a null label. For simplicity, we will use the abbreviated notation prec@k(s) := prec@k(s; z1, . . . , zn). We will also use the shorthand si = s(xi). For any label vectors y\u2032,y\u2032\u2032 \u2208 {0, 1}n, we define\n\u2206(y\u2032,y\u2032\u2032) = n\u2211 i=1 (1\u2212 y\u2032i)y\u2032\u2032i ,\nK(y\u2032,y\u2032\u2032) = n\u2211 i=1 y\u2032iy \u2032\u2032 i .\n(2)\nLet n+(y\u2032) = K(y\u2032,y\u2032) = \u2016y\u2032\u20161 denote the number of positives in the label vector y\u2032 and n+ = n+(y) denote the number of actual positives. Let y(s,k) be the label vector that assigns the label 1 only to the top k ranked items according to the scoring function s. That is, y(s,k)i = 1 if if \u03c3 \u22121 s (i) \u2264 k and 0 otherwise. It is easy to verify that for any scoring function s, \u2206(y,y(s,k)) = prec@k(s)."}, {"heading": "3 A Family of Novel Surrogates for prec@k", "text": "As prec@k is a non-convex loss function that is hard to optimize directly, it is natural to seek surrogate functions that act as a good proxy for prec@k. There will be two properties that we shall desire of such a surrogate:\n1. Upper Bounding Property: the surrogate should upper bound the prec@k loss function, so that minimizing the surrogate promotes small prec@k loss.\n2. Conditional Consistency: under some regularity assumptions, optimizing the surrogate should yield an optimal solution for prec@k as well.\nMotivated by the above requirements, we develop a family of surrogates which upper bound the prec@k loss function and are consistent to it under certain margin/noise conditions. We note that the results of Calauze\u0300nes et al. [2012] that negate the possibility of consistent convex surrogates for ranking performance measures do not apply to our results since they are neither stated for prec@k, nor do they negate the possibility of conditional consistency.\nIt is notable that the seminal work of Joachims [2005] did propose a convex surrogate for prec@k, that we refer to as `structprec@k(\u00b7). However, as the discussion below shows, this surrogate is not even an upper bound on prec@k let alone be consistent to it. Understanding the reasons for the failure of this surrogate would be crucial in designing our own."}, {"heading": "3.1 The Curious Case of `structprec@k(\u00b7)", "text": "The `structprec@k(\u00b7) surrogate is a part of a broad class of surrogates called struct-SVM surrogates that are designed for structured output prediction problems that can have exponentially large output spaces Joachims [2005]. Given a set of n labeled data points, `structprec@k(\u00b7) is defined as\nmax y\u0302\u2208{0,1}n \u2016y\u0302\u20161=k\n{ \u2206(y, y\u0302) +\nn\u2211 i=1 (y\u0302i \u2212 yi) si\n} . (3)\nThe above surrogate penalizes a scoring function if there exists a set of k points with large scores (i.e. the second term is large) which are actually negatives (i.e. the first term is large). However, since the candidate labeling y\u0302 is restricted to labeling just k points as positive whereas the true label vector y has n+ positives, in cases where n+ > k, a non-optimal candidate labeling y\u0302 can exploit the remaining n+ \u2212 k labels to hide the high scoring negative points, thus confusing the surrogate function. This indicates that this surrogate may not be an upper bound to prec@k. We refer the reader to Appendix A for an explicit example where, not only does this surrogate not upper bound prec@k, but more importantly, minimizing `structprec@k(\u00b7) does not produce a model that is optimal for prec@k, even in separable settings where all positives points are separated from negatives by a margin.\nIn the sequel, we shall propose three surrogates, all of which are consistent with prec@k under various noise/margin conditions. The surrogates, as well as the noise conditions, will be shown to form a hierarchy."}, {"heading": "3.2 The Ramp Surrogate `rampprec@k(\u00b7)", "text": "The key to maximizing prec@k in a bipartite ranking setting is to select a subset of k relevant items and rank them at the top k positions. This can happen iff the top ranked k relevant items are not outranked by any irrelevant item. Thus, a surrogate must penalize a scoring function that assigns scores to irrelevant items that are higher than those of the top ranked relevant items. Our ramp surrogate `rampprec@k(s) implicitly encodes this strategy:\nmax \u2016y\u0302\u20161=k\n{ \u2206(y, y\u0302) +\nn\u2211 i=1 y\u0302isi } \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n\ufe38 \ufe37\ufe37 \ufe38 (P )\n. (4)\nThe term (P ) contains the sum of scores of the k highest scoring positives. Note that `rampprec@k(\u00b7) is similar to the \u201cramp\u201d losses for binary classification Do et al. [2008]. We now show that `rampprec@k(\u00b7) is indeed an upper bounding surrogate for prec@k.\nClaim 1. For any k \u2264 n+ and scoring function s, we have `rampprec@k(s) \u2265 prec@k(s). Moreover, if ` ramp prec@k(s) \u2264 \u03be for a given scoring function s, then there necessarily exists a set S \u2282 [n] of size at most k such that for all \u2016y\u0302\u20161 = k, we have \u2211 i\u2208S si \u2265 \u2211n i=1 y\u0302isi + \u2206(y, y\u0302)\u2212 \u03be.\nProofs for this section are deferred to Appendix B. We can show that this surrogate is conditionally consistent as well. To do so, we introduce the notion of weak (k, \u03b3)-margin.\nDefinition 2 (Weak (k, \u03b3)-margin). A set of n labeled data points satisfies the weak (k, \u03b3)-margin condition if for some scoring function s and set S+ \u2286 X+ of size k,\nmin i\u2208S+ si \u2212 max j:yj=0 sj \u2265 \u03b3.\nMoreover, we say that the function s realizes this margin. We abbreviate the weak (k, 1)-margin condition as simply the weak k-margin condition.\nClearly, a dataset has a weak (k, \u03b3)-margin iff there exist some k positive points that substantially outrank all negatives. Note that this notion of margin is strictly weaker than the standard notion of margin for binary classification as it allows all but those k positives to be completely mingled with the negatives. Moreover, this seems to be one of the most natural notions of margin for prec@k. The following lemma establishes that `rampprec@k(\u00b7) is indeed consistent w.r.t. prec@k under the weak k-margin condition.\nClaim 3. For any scoring function s that realizes the weak k-margin over a dataset, `rampprec@k(s) = prec@k(s) = 0.\nThis suggests that `rampprec@k(\u00b7) is not only a tight surrogate, but tight at the optimal scoring function, i.e. prec@k(s) = 0; this along with upper bounding property implies consistency. However, it is also a non-convex function due to the term (P ). To obtain convex surrogates, we perform relaxations on this term by first rewriting it as follows:\n(P ) = n\u2211 i=1 yisi \u2212 min y\u0303 y\n\u2016y\u0303\u20161=n+\u2212k\nn\u2211 i=1 y\u0303isi\n\ufe38 \ufe37\ufe37 \ufe38 (Q)\n, (5)\nwhere y\u0303 y implies that yi = 0 \u21d2 y\u0303i = 0. Thus, to convexify the surrogate `rampprec@k(\u00b7), we need to design a convex upper bound on (Q). Notice that the term (Q) contains the sum of the scores of the n+ \u2212 k lowest ranked positive data points. This can be readily upper bounded in several ways which give us different surrogate functions."}, {"heading": "3.3 The Max Surrogate `maxprec@k(\u00b7)", "text": "An immediate convex upper bound on (Q) is obtained by replacing the sum of scores of the n+ \u2212 k lowest ranked positives with those of the highest ranked ones as follows: (Q) \u2264 max y\u0303 (1\u2212y\u0302)\u00b7y\n\u2016y\u0303\u20161=n+\u2212k\n\u2211n i=1 y\u0303isi, which gives us the\n`maxprec@k(s) surrogate defined below:\nmax \u2016y\u0302\u20161=k \u2206(y, y\u0302) + n\u2211 i=1\n(y\u0302i \u2212 yi)si + max y\u0303 (1\u2212y\u0302)\u00b7y \u2016y\u0303\u20161=n+\u2212k\nn\u2211 i=1 y\u0303isi  . (6) The above surrogate, being a point-wise maximum over convex functions, is convex, as well as an upper bound on prec@k(s) since it upper bounds `rampprec@k(s). This surrogate can also be shown to be consistent w.r.t. prec@k under the strong \u03b3-margin condition defined below for \u03b3 = 1.\nDefinition 4 (Strong \u03b3-margin). A set of n labeled data points satisfies the \u03b3-strong margin condition if for some scoring function s, mini:yi=1 si \u2212maxj:yj=0 sj \u2265 \u03b3.\nWe notice that the strong margin condition is actually the standard notion of binary classification margin and hence much stronger than the weak (k, \u03b3)-margin condition. It also does not incorporate any elements of the prec@k problem. This leads us to look for tighter convex relaxations to the term (Q) that we do below."}, {"heading": "3.4 The Avg Surrogate `avgprec@k(\u00b7)", "text": "A tighter upper bound on (Q) can be obtained by replacing (Q) by the average score of the false negatives. Define C(y\u0302) = n+\u2212K(y,y\u0302)n+\u2212k and consider the relaxation (Q) \u2264 1 C(y\u0302) \u2211n i=1(1 \u2212 y\u0302i)yisi. Combining this with (4), we get a new convex surrogate `avgprec@k(s) defined as: max \u2016y\u0302\u20161=k { \u2206(y, y\u0302) + n\u2211 i=1 si(y\u0302i \u2212 yi) + 1 C(y\u0302) n\u2211 i=1 (1\u2212 y\u0302i)yisi } . (7) We refer the reader to Appendix B.4 for a proof that `avgprec@k(\u00b7) is an upper bounding surrogate. It is notable that for k = n+ (i.e. for the PRBEP measure), the surrogate ` avg prec@k(\u00b7) recovers Joachims\u2019 original surrogate `structprec@k(\u00b7). To establish conditional consistency of this surrogate, consider the following notion of margin:\nDefinition 5 ((k, \u03b3)-margin). A set of n labeled data points satisfies the (k, \u03b3)-margin condition if for some scoring function s, we have, for all sets S+ \u2286 X+ of size n+ \u2212 k + 1,\n1 n+ \u2212 k + 1 \u2211 i\u2208S+ si \u2212 max j:yj=0 sj \u2265 \u03b3.\nMoreover, we say that the function s realizes this margin. We abbreviate the (k, 1)-margin condition as simply the k-margin condition.\nWe can now establish the consistency of `avgprec@k(\u00b7) under the k-margin condition. See Appendix B.5 for a proof.\nClaim 6. For any scoring function s that realizes the k-margin over a dataset, `avgprec@k(s) = prec@k(s) = 0.\nWe note that the (k, \u03b3)-margin condition is strictly weaker than the strong \u03b3-margin condition (Definition 4) since it still allows a non negligible fraction of the positive points to be assigned a lower score than those assigned to negatives. On the other hand, the (k, \u03b3)-margin condition is strictly stronger than the weak (k, \u03b3)-margin condition (Definition 2). The weak k-margin condition only requires one set of k-positives to be separated from the negatives, whereas the above margin condition at least requires the average of all positives to be separated from the negatives.\nAs Figure 1 demonstrates, the three surrogates presented above, as well as their corresponding margin conditions, fall in a neat hierarchy. We will now use these surrogates to formulate two perceptron algorithms with mistake bounds with respect to these margin conditions."}, {"heading": "4 Perceptron & SGD Algorithms for prec@k", "text": "We now present perceptron-style algorithms for maximizing the prec@k performance measure in bipartite ranking settings. Our algorithms work with a stream of binary labeled points and process them in mini-batches of a predetermined size b. Mini-batch methods have recently gained popularity and have been used to optimize ranking loss functions such as `structprec@k(\u00b7) as well Kar et al. [2014]. It is useful to note that the requirement for mini-batches goes away in ranking and multi-label classification settings, for our algorithms can be applied to individual data points in those settings (e.g. individual queries in ranking settings).\nAt every time instant t, our algorithms receive a batch of b points Xt = [ x1t , . . . ,x b t ] and rank these points using the existing model. Let \u2206t denote the prec@k loss (equation 1) at time t. If \u2206t = 0 i.e. all top k ranks are occupied by positive points, then the model is not updated. Otherwise, the model is updated using the false positives and negatives. For sake of simplicity, we will only look at linear models in this paper. Depending on the kind of updates we make, we get two variants of the perceptron rule for prec@k.\nOur first algorithm, PERCEPTRON@K-AVG, updates the model using a combination of all the false positives and negatives (see Algorithm 1). The effect of the update is a very natural one \u2013 it explicitly boosts the scores of the positive points that failed to reach the top ranks, and attenuates the scores of the negative points that got very high scores. It is interesting to note that in the limiting case of k = 1 and unit batch length (i.e. b = 1), the PERCEPTRON@K-AVG update reduces to that of the standard perceptron algorithm Rosenblatt [1958], Minsky and Papert [1988] for the choice y\u0302t = sign(st). Thus, our algorithm can be seen as a natural extension of the classical perceptron algorithm.\nAlgorithm 1 PERCEPTRON@K-AVG Input: Batch length b\n1: w0 \u2190 0, t\u2190 0 2: while stream not exhausted do 3: t\u2190 t+ 1 4: Receive b data points Xt = [ x1t , . . . ,x b t ] , yt \u2208 {0, 1}b 5: Calculate st = wt\u22121Xt and let y\u0302t = y(st,k) 6: \u2206t \u2190 \u2206(yt, y\u0302t) 7: if \u2206t = 0 then 8: wt \u2190 wt\u22121 9: else\n10: Dt \u2190 \u2206t\u2016yt\u20161\u2212K(yt,y\u0302t) 11: wt \u2190 wt\u22121 \u2212 \u2211 i\u2208[b](1\u2212 yi)y\u0302i \u00b7 x i t {false positives}\n12: wt \u2190 wt +Dt \u00b7 \u2211 i\u2208[b](1\u2212 y\u0302i)yi \u00b7 x i t {false negatives} 13: end if 14: end while 15: return wt\nAlgorithm 2 PERCEPTRON@K-MAX 10: St \u2190 FN(s,\u2206t) 11: wt \u2190 wt\u22121 \u2212 \u2211 i\u2208[b](1\u2212 yi)y\u0302i \u00b7 x i t {false positives}\n12: wt \u2190 wt + \u2211 i\u2208St x i t {top ranked false negatives}\nThe next lemma establishes that, similar to the classical perceptron Novikoff [1962], PERCEPTRON@K-AVG also enjoys a mistake bound. Our mistake bound is stated in the most general agnostic setting with the hinge loss function replaced with our surrogate `avgprec@k(s). All proofs in this section are deferred to Appendix C.\nTheorem 7. Suppose \u2225\u2225xit\u2225\u2225 \u2264 R for all t, i. Let \u2206CT = \u2211Tt=1 \u2206t be the cumulative mistake value observed when\nAlgorithm 1 is executed for T batches. Also, for any w, let L\u0302avgT (w) = \u2211T t=1 ` avg prec@k(w;Xt,yt). Then we have\n\u2206CT \u2264 min w\n( \u2016w\u2016 \u00b7R \u00b7 \u221a 4k + \u221a L\u0302avgT (w) )2 .\nSimilar to the classical perceptron mistake bound Novikoff [1962], the above bound can also be reduced to a simpler convergence bound in separable settings.\nCorollary 8. Suppose a unit norm w\u2217 exists such that the scoring function s : x 7\u2192 x>w\u2217 realizes the (k, \u03b3)-margin condition for all the batches, then Algorithm 1 guarantees the mistake bound: \u2206CT \u2264 4kR 2 \u03b32 .\nThe above result assures that, as datasets become \u201ceasier\u201d in the sense that their (k, \u03b3)-margin becomes larger, PERCEPTRON@K-AVG will converge to an optimal hyperplane at a faster rate. It is important to note there that the (k, \u03b3)-margin condition is strictly weaker than the standard classification margin condition. Hence for several datasets, PERCEPTRON@K-AVG might be able to find a perfect ranking while at the same time, it might be impossible for standard binary classification techniques to find any reasonable classifier in poly-time Guruswami and Raghavendra [2009].\nWe note that PERCEPTRON@K-AVG performs updates with all the false negatives in the mini-batches. This raises the question as to whether sparser updates are possible as such updates would be slightly faster as well as, in high dimensional settings, ensure that the model is sparser. To this end we design the PERCEPTRON@K-MAX algorithm (Algorithm 2). PERCEPTRON@K-MAX differs from PERCEPTRON@K-AVG in that it performs updates using only a few of the top ranked false negatives. More specifically, for any scoring function s and m > 0, define:\nFN(s,m) = arg max S\u2282X+t ,|S|=m \u2211 i\u2208S ( 1\u2212 y(s,k)i ) yisi\nAlgorithm 3 SGD@K-AVG Input: Batch length b, step lengths \u03b7t, feasible setW Output: A model w\u0304 \u2208 W\n1: w0 \u2190 0, t\u2190 0 2: while stream not exhausted do 3: t\u2190 t+ 1 4: Receive b data points Xt = [ x1t , . . . ,x b t ] , yt \u2208 {0, 1}b 5: Set gt \u2208 \u2202w`avgprec@k(wt\u22121;Xt,yt) {See Algorithm 4} 6: wt \u2190 \u03a0W [wt\u22121 \u2212 \u03b7t \u00b7 gt] {project onto setW} 7: end while 8: return w\u0304 = 1\nt \u2211t \u03c4=1 w\u03c4\nAlgorithm 4 Subgradient calculation for `avgprec@k(\u00b7) Input: A model win, n data points X,y, parameter k Output: A subgradient g \u2208 \u2202w`avgprec@k(win;X,y)\n1: Sort pos. and neg. points separately in dec. order of scores assigned by win i.e. s+1 \u2265 . . . \u2265 s+n+ and s \u2212 1 \u2265 . . . \u2265 s\u2212n\u2212 2: for k\u2032 = 0\u2192 k do 3: Dk\u2032 \u2190 k\u2212k \u2032\nn+\u2212k\u2032 4: \u2206k\u2032 \u2190 k \u2212 k\u2032 \u2212Dk\u2032 \u2211n+ i=k\u2032+1 s + i + \u2211k\u2212k\u2032 i=1 s \u2212 i\n5: gk\u2032 \u2190 \u2211k\u2212k\u2032 i=1 x \u2212 i \u2212Dk\u2032 \u2211n+ i=k\u2032+1 x + i 6: end for 7: k\u2217 \u2190 arg maxk\u2032 \u2206k\u2032 8: return gk\u2217\nas the set of the m top ranked false negatives. PERCEPTRON@K-MAX makes updates only for false positives in the set FN(s,\u2206t). Note that \u2206t can significantly smaller than the total number of false negatives if k n+. PERCEPTRON@K-MAX also enjoys a mistake bound but with respect to the `maxprec@k(\u00b7) surrogate.\nTheorem 9. Suppose \u2225\u2225xit\u2225\u2225 \u2264 R for all t, i. Let \u2206CT = \u2211Tt=1 \u2206t be the cumulative observed mistake value when\nAlgorithm 2 is executed for T batches. Also, for any w, let L\u0302maxT (w) = \u2211T t=1 ` max prec@k(w;Xt,yt). Then we have\n\u2206CT \u2264 min w\n( \u2016w\u2016 \u00b7R \u00b7 \u221a 4k + \u221a L\u0302maxT (w) )2 .\nSimilar to PERCEPTRON@K-AVG, we can give a simplified mistake bound in situations where the separability condition specified by Definition 4 is satisfied.\nCorollary 10. Suppose a unit norm w\u2217 exists such that the scoring function s : x 7\u2192 x>w\u2217 realizes the strong \u03b3-margin condition for all the batches, then Algorithm 2 guarantees the mistake bound: \u2206CT \u2264 4kR 2 \u03b32 .\nAs the strong \u03b3-margin condition is exactly the same as the standard notion of margin for binary classification, the above bound is no stronger than the one for the classical perceptron. However, in practice, we observe that PERCEPTRON@K-MAX at times outperforms even PERCEPTRON@K-AVG, even though the latter has a tighter mistake bound. This suggests that our analysis of PERCEPTRON@K-MAX might not be optimal and fails to exploit latent structures that might be present in the data.\nStochastic Gradient Descent for Optimizing prec@k. We now extend our algorithmic repertoire to include a stochastic gradient descent (SGD) algorithm for the prec@k performance measure. SGD methods are known to be very successful at optimizing large-scale empirical risk minimization (ERM) problems as they require only a few passes over the data to achieve optimal statistical accuracy.\nHowever, SGD methods typically require access to cheap gradient estimates which are difficult to obtain for nonadditive performance measures such as prec@k. This has been noticed before by several previous works Kar et al.\n[2014], Narasimhan et al. [2015] who propose to use mini-batch methods to overcome this problem Kar et al. [2014]. By combining the `avgprec@k(\u00b7) surrogate with mini-batch-style processing, we design SGD@K-AVG (Algorithm 3), a scalable SGD algorithm for optimizing prec@k. The algorithm uses mini-batches to update the current model using gradient descent steps. The subgradient calculation for this surrogate turns out to be non-trivial and is detailed in Algorithm 4.\nThe task of analyzing this algorithm is made non-trivial by the fact that the gradient estimates available to SGD@K-AVG via Algorithm 4 are far from being unbiased. The luxury of having unbiased gradient estimates is crucially exploited by standard SGD analyses but unfortunately, unavailable to us. To overcome this hurdle, we propose a uniform convergence based proof that, in some sense, bounds the bias in the gradient estimates.\nIn the following section, we present this, and many other generalization and online-to-batch conversion bounds with applications to our perceptron and SGD algorithms."}, {"heading": "5 Generalization Bounds", "text": "In this section, we discuss novel uniform convergence (UC) bounds for our proposed surrogates. We will use these UC bounds along with the mistake bounds in Theorems 7 and 9 to prove two key results \u2013 1) online-to-batch conversion bounds for the PERCEPTRON@K-AVG and PERCEPTRON@K-MAX algorithms and, 2) a convergence guarantee for the SGD@K-AVG algorithm.\nTo better present our generalization and convergence bounds, we use normalized versions of prec@k and the surrogates. To do so we write k = \u03ba \u00b7 n+ for some \u03ba \u2208 (0, 1] and define, for any scoring function s, its prec@\u03ba loss as:\nprec@\u03ba(s; z1, . . . , zn) = 1\n\u03ban+ \u2206(y,y(s,\u03ban+)).\nWe will also normalize the surrogate functions `rampprec@\u03ba(\u00b7), `maxprec@\u03ba(\u00b7), and ` avg prec@\u03ba(\u00b7) by dividing by k = \u03ba \u00b7 n+.\nDefinition 11 (Uniform Convergence). A performance measure \u03a8 : W \u00d7 (X \u00d7 {0, 1})n 7\u2192 R+ exhibits uniform convergence with respect to a set of predictorsW if for some \u03b1(b, \u03b4) = poly ( 1 b , log 1 \u03b4 ) , for a sample z\u03021, . . . , z\u0302b of size b chosen i.i.d. (or uniformly without replacement) from an arbitrary population z1, . . . , zn, we have w.p. 1\u2212 \u03b4,\nsup w\u2208W\n|\u03a8(w; z1, . . . , zn)\u2212\u03a8(w; z\u03021, . . . , z\u0302b)| \u2264 \u03b1(b, \u03b4)\nWe now state our UC bounds for prec@\u03ba and its surrogates. We refer the reader to Appendix D for proofs.\nTheorem 12. The loss function prec@\u03ba(\u00b7), as well as the surrogates `rampprec@\u03ba(\u00b7), ` avg prec@\u03ba(\u00b7) and `maxprec@\u03ba(\u00b7), all exhibit uniform convergence at the rate \u03b1(b, \u03b4) = O (\u221a\n1 b log 1 \u03b4\n) .\nRecently, Kar et al. [2014] also established a similar result for the `structprec@k(\u00b7) surrogate. However, a very different proof technique is required to establish similar results for `maxprec@\u03ba(\u00b7) and ` avg prec@\u03ba(\u00b7), partly necessitated by the terms in these surrogates which depend, in a complicated manner, on the positives predicted by the candidate labeling y\u0302. Nevertheless, the above results allow us to establish strong online-to-batch conversion bounds for PERCEPTRON@KAVG and PERCEPTRON@K-MAX, as well as convergence rates for the SGD@K-AVG method. In the following we shall assume that our data streams are composed of points chosen i.i.d. (or u.w.r.) from some fixed population Z .\nTheorem 13. Suppose an algorithm, when fed a random stream of data points, in T batches of length b each, generates an ensemble of models w1, . . . ,wT which together suffer a cumulative mistake value of \u2206CT . Then, with probability at least 1\u2212 \u03b4, we have\n1\nT T\u2211 t=1 prec@\u03ba(wt;Z) \u2264 \u2206 C T bT +O\n(\u221a 1\nb log\nT\n\u03b4\n) .\nThe proof of this theorem follows from Theorem 12 which guarantees that w.p. 1\u2212 \u03b4, prec@\u03ba(wt;Z) \u2264 \u2206t/b+ O (\u221a\n1 b log 1 \u03b4\n) for all t. Combining this with the mistake bound from Theorem 7 ensures the following generalization\nguarantee for the ensemble generated by Algorithm 1.\nCorollary 14. Let w1, . . . ,wT be the ensemble of classifiers returned by the PERCEPTRON@K-AVG algorithm on a random stream of data points and batch length b. Then, with probability at least 1\u2212 \u03b4, for any w\u2217 we have\n1\nT T\u2211 t=1 prec@\u03ba(wt;Z) \u2264 (\u221a `avgprec@\u03ba(w \u2217;Z) + C )2 ,\nwhere C = O ( \u2016w\u2217\u2016R \u221a 1 T + 4 \u221a 1 b log T \u03b4 ) .\nA similar statement holds for the PERCEPTRON@K-MAX algorithm with respect to the `maxprec@\u03ba(\u00b7) surrogate as well. Using the results from Theorem 12, we can also establish the convergence rate of the SGD@K-AVG algorithm.\nTheorem 15. Let w\u0304 be the model returned by Algorithm 3 when executed on a stream with T batches of length b. Then with probability at least 1\u2212 \u03b4, for any w\u2217 \u2208 W , we have\n`avgprec@\u03ba(w\u0304;Z) \u2264 ` avg prec@\u03ba(w \u2217;Z) +O\n(\u221a 1\nb log\nT\n\u03b4\n) +O (\u221a 1\nT\n)\nThe proof of this Theorem can be found in Appendix E."}, {"heading": "6 Experiments", "text": "We shall now evaluate our methods on several benchmark datasets for binary classification problems with a rare-class.\nDatasets: We evaluated our methods on 7 publicly available benchmark datasets: a) PPI, b) KDD Cup 2008, c) Letter, d) Adult, e) IJCNN, f) Covertype, and g) Cod-RNA. All datasets exhibit moderate to severe label imbalance with the KDD Cup dataset having just 0.61% positives.\nMethods: We compared both perceptron algorithms, SGD@K-AVG, as well as an SGD solver for the `maxprec@k(\u00b7) surrogate, with the cutting plane-based SVMPerf solver of Joachims [2005]. We also compare against stochastic\n1PMB solver of Kar et al. [2014]. The perceptron and SGD methods were given a maximum of 25 passes over the data with a batch length of 500. All methods were implemented in C. We used 70% of the data for training and the rest for testing. All results are averaged over 5 random train-test splits.\nOur experiments reveal three interesting insights into the problem of prec@k maximization \u2013 1) using tighter surrogates for optimization routines is indeed beneficial, 2) the presence of a stochastic solver cannot always compensate for the use of a suboptimal surrogate, and 3) mini-batch techniques, applied with perceptron or SGD-style methods, can offer rapid convergence to accurate models.\nWe first timed all the methods on prec@\u03ba maximization tasks for \u03ba = 0.25 on various datasets (see Figure 2). Of all the methods, the cutting plane method (SVMPerf) was found to be the most expensive computationally. On the other hand, the perceptron and stochastic gradient methods, which make frequent but cheap updates, were much faster at identifying accurate solutions.\nWe also observed that PERCEPTRON@K-AVG and SGD@K-AVG, which are based on the tight `avgprec@k(\u00b7) surrogate, were the most consistent at converging to accurate solutions whereas PERCEPTRON@K-MAX and SGD@K-MAX, which are based on the loose `maxprec@k(\u00b7) surrogate, showed large deviations in performance across tasks. Also, 1PMB and SVMPerf, which are based on the non upper-bounding `structprec@k(\u00b7) surrogate, were frequently found to converge to suboptimal solutions.\nThe effect of working with a tight surrogate is also clear from Figure 3 (a), (b) where the algorithms working with our novel surrogates were found to consistently outperform the SVMPerf method which works with the `structprec@k(\u00b7) surrogate. For these experiments, SVMPerf was allowed a runtime of up to 50\u00d7 of what was given to our methods after which it was terminated.\nFinally, to establish the stability of our algorithms, we ran, both the perceptron, as well as the SGD algorithms with varying batch lengths (see Figure 3 (c)-(e)). We found the algorithms to be relatively stable to the setting of the batch length. To put things in perspective, all methods registered a relative variation of less than 5% in accuracies across batch lengths spanning an order of magnitude or more. We present additional experimental results in Appendix F."}, {"heading": "Acknowledgments", "text": "HN thanks support from a Google India PhD Fellowship."}, {"heading": "A Structural SVM Surrogate for prec@k", "text": "The structural SVM surrogate for prec@k for a set of n points {(x1, y1), . . . , (xn, yn)} \u2208 (Rd \u00d7 {0, 1})n and model w \u2208 Rd can be written as `structprec@k(w):\nmax y\u0302\u2208{0,1}n \u2016y\u0302\u20161=k\n{ 1 + n\u2211 i=1 y\u0302i ( 1 n w>xi \u2212 1 k yi ) \u2212 1 n n\u2211 i=1 yiw >xi } .\nWe shall now give a simple setting where this surrogate produces a suboptimal model. Consider a set of 6 points in R \u00d7 {0, 1}: {(\u22121, 1), (\u22121, 1), (\u22122, 1), (\u22123, 0), (\u22123, 0), (\u22123, 0)}, and suppose we are interested in Prec@1. Note that the optimum model that maximizes prec@1 on these points has a positive sign. We will now show that the model w\u2217 \u2208 R that maximizes the above structural SVM surrogate on these points has a negative sign. On the contrary, let us assume that w\u2217 has a positive sign, and arrive at a contradiction; we shall consider the following two cases:\n(i) w\u2217 > 32 . It can be verified that\n`structprec@k(w \u2217) = 1 +\n( 1\n6 (\u2212w\u2217)\u2212 1\n) \u2212 1\n6 (\u2212w\u2217 +\u2212w\u2217 +\u22122w\u2217)\n= 1\n2 w\u2217\nOn the other hand, for the model w\u2032 = \u2212w\u2217, we have\n`structprec@k(w \u2032) = 1 +\n( 1\n6 (\u22123w\u2032)\u2212 0\n) \u2212 1\n6 (\u2212w\u2032 +\u2212w\u2032 +\u22122w\u2032)\n= 1 +\n( 1\n6 (3w\u2217)\u2212 0\n) \u2212 1\n6 (w\u2217 + w\u2217 + 2w\u2217)\n= 1\u2212 1 6 w\u2217 < `structprec@k(w \u2217),\nwhere the last step follows from w\u2217 > 32 ; clearly, w \u2217 is not optimal for the structural SVM surrogate, and hence a contradiction. (i) w\u2217 \u2264 32 . Here we have\n`structprec@k(w \u2217) = 1 +\n( 1\n6 (\u22123w\u2217)\u2212 0\n) \u2212 1\n6 (\u2212w\u2217 +\u2212w\u2217 +\u22122w\u2217)\n= 1 + 1\n6 w\u2217.\nFor w\u2032 = \u2212w\u2217,\n`structprec@k(w \u2032) = 1 +\n( 1\n6 (\u22123w\u2032)\u2212 0\n) \u2212 1\n6 (\u2212w\u2032 +\u2212w\u2032 +\u22122w\u2032)\n= 1 +\n( 1\n6 (3w\u2217)\u2212 0\n) \u2212 1\n6 (w\u2217 + w\u2217 + 2w\u2217)\n= 1\u2212 1 6 w\u2217 < `structprec@k(w \u2217).\nHere again, we have a contradiction. Notice that this surrogate can take negative values (when w < \u22126 for example) whereas prec@k is a positive valued function. This clearly indicates that this surrogate cannot upper bound prec@k. More specifically, notice that for w < 0, we have prec@k(w) = 1, however, the above analysis demonstrates cases when `structprec@k(w) < 1 which gives an explicit example that this surrogate is not even an upper bounding surrogate."}, {"heading": "B Proofs of Claims from Section 3", "text": ""}, {"heading": "B.1 Proof of Claim 1", "text": "Claim 1. For any k \u2264 n+ and scoring function s, we have\n`rampprec@k(s) \u2265 prec@k(s).\nMoreover, if for some scoring function s, we have `rampprec@k(s) \u2264 \u03be, then there necessarily exists a set S \u2282 [n] of size at most k such that for all \u2016y\u0302\u2016 = k, we have\n\u2211 i\u2208S si \u2265 n\u2211 i=1 y\u0302isi + \u2206(y, y\u0302)\u2212 \u03be.\nProof. Let y\u0302 = y(s,k) so that we have \u2206(y, y\u0302) = prec@k(s). Then we have\n`rampprec@k(s) = max\u2016y\u0302\u20161=k\n{ \u2206(y, y\u0302) +\nn\u2211 i=1 y\u0302isi } \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n\u2265 \u2206(y, y\u0302) + n\u2211 i=1 y\u0302isi \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n= \u2206(y, y\u0302) + max \u2016y\u0303\u20161=k n\u2211 i=1 y\u0303isi \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n\u2265 \u2206(y, y\u0302),\nwhere the third step follows from the definition of y\u0302. This proves the first claim. For the second claim, suppose for some scoring function s, we have `rampprec@k(s) \u2264 \u03be. Then if we consider S\u2217 to be the set of k-highest ranked positive points, then we have\n\u2211 i\u2208S\u2217 si = max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi \u2265 max \u2016y\u0302\u20161=k\n{ \u2206(y, y\u0302) +\nn\u2211 i=1 y\u0302isi\n} \u2212 \u03be \u2265\nn\u2211 i=1 y\u0302isi + \u2206(y, y\u0302)\u2212 \u03be,\nwhich proves the claim."}, {"heading": "B.2 Proof of Claim 3", "text": "Claim 3. For any scoring function s that realizes the weak k-margin over a dataset we have,\n`rampprec@k(s) = prec@k(s) = 0.\nProof. Consider a scoring function s that satisfies the weak k-margin condition and any y\u0302 such that \u2016y\u0302\u20161 = k. Based on the prec@k accuracy of y\u0302, we have the following two cases\nCase 1 (K(y, y\u0302) = k): In this case we have\n\u2206(y, y\u0302) + n\u2211 i=1 y\u0302isi \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi = 0 + n\u2211 i=1 y\u0302isi \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi \u2264 0,\nwhere the first step follows since K(y, y\u0302) = k and the second step follows since \u2016y\u0302\u20161 = k, as well as K(y, y\u0302) = k.\nCase 2 (K(y, y\u0302) = k\u2032 < k): In this case let S\u2217 be the set of k top ranked positive points according to the scoring function s. Also let S\u22171 be the set of k \u2032(= K(y, y\u0302)) top ranked positives and let S\u22172 = S \u2217\\S\u22171 . Then we have\n\u2206(y, y\u0302) + n\u2211 i=1 y\u0302isi \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi = \u2206(y, y\u0302) + n\u2211 i=1\ny\u0302iyisi\ufe38 \ufe37\ufe37 \ufe38 (A) +\nn\u2211 i=1 y\u0302i(1\u2212 yi)si \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n\u2264 \u2206(y, y\u0302) + \u2211 i\u2208S\u22171 si + n\u2211 i=1\ny\u0302i(1\u2212 yi)si\ufe38 \ufe37\ufe37 \ufe38 (B) \u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k\nn\u2211 i=1 y\u0303isi\n\u2264 \u2206(y, y\u0302) + \u2211 i\u2208S\u22171 si + \u2211 i\u2208S\u22172 si \u2212 (k \u2212 k\u2032)\u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n= k \u2212 k\u2032 + \u2211 i\u2208S\u2217 si \u2212 (k \u2212 k\u2032)\u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k n\u2211 i=1 y\u0303isi\n= 0,\nwhere the second step follows since the term (A) consists of k\u2032 true positives the third step follows since the term (B) contains k \u2212 k\u2032 false positives i.e. negatives and the k-margin condition, the fourth step follows since \u2206(y, y\u0302) = k \u2212K(y, y\u0302) and the fifth step follows since by the definition of the set S\u2217, we have\u2211\ni\u2208S\u2217 si = max\n\u2016y\u0303\u20161=k K(y,y\u0303)=k\nn\u2211 i=1 y\u0303isi.\nIn both cases, we have shown the surrogate to be non-positive. Since the performance measure prec@k cannot take negative values, this, along with the upper bounding property implies that prec@k(s) = 0 as well. This finishes the proof."}, {"heading": "B.3 A Useful Supplementary Lemma", "text": "Lemma 16. Given a set of n real numbers x1 . . . xn and any two integers k \u2264 k\u2032 \u2264 n, we have\nmin |S|=k\n1\nk \u2211 i\u2208S xi \u2264 min |S\u2032|=k\u2032 1 k\u2032 \u2211 j\u2208S\u2032 xj\nProof. The above is obviously true if k = k\u2032 so we assume that k\u2032 > k. Without loss of generality assume that the set is ordered in ascending order i.e. x1 \u2264 x2 \u2264 . . . \u2264 xn. Thus, the above statement is equivalent to showing that\n1\nk k\u2211 i=1 xi \u2264 1 k\u2032 k\u2032\u2211 j=1 xj \u21d4 ( 1 k \u2212 1 k\u2032 ) k\u2211 i=1 xi \u2264 1 k\u2032 k\u2032\u2211 j=k+1 xj \u21d4 1 k k\u2211 i=1 xi \u2264 1 k\u2032 \u2212 k k\u2032\u2211 j=k+1 xj ,\nwhere the last inequality is true since k\u2212 k\u2032 > 0 and the left hand side is the average of numbers which are all smaller than the numbers whose average forms the right hand side. This proves the lemma."}, {"heading": "B.4 Proof of the Upper-bounding Property for the `avgprec@k(\u00b7) Surrogate", "text": "Claim 17. For any k \u2264 n+ and scoring function s, we have\n`avgprec@k(s) \u2265 prec@k(s).\nMoreover, for linear scoring functions i.e. s(xi) = w>xi for w \u2208 W , the surrogate `avgprec@k(w) is convex in w.\nProof. We use the fact observed before that for any scoring function, we have \u2206(y,y(s,k)) = prec@k(s). We start off by showing the second part of the claim. Recall the definition of the surrogate `avgprec@k(s)\n`avgprec@k(w) = max\u2016y\u0302\u20161=k\n{ \u2206(y, y\u0302) +\nn\u2211 i=1 (y\u0302i \u2212 yi) \u00b7w>xi + 1 C(y\u0302) n\u2211 i=1 (1\u2212 y\u0302i)yi \u00b7w>xi\n}\nFor sake of simplicity, for any y\u0302 \u2208 {0, 1}n, define\n\u2206(s, y\u0302) = \u2206(y, y\u0302) + n\u2211 i=1 si(y\u0302i \u2212 yi) + 1 C(y\u0302) n\u2211 i=1 (1\u2212 y\u0302i)yisi.\nThe convexity of `avgprec@k(w) follows from the observation that the inner term in the maximization is linear (hence convex) in w and the max function is convex and increasing. We now move on to prove the first part. For sake of convenience y\u0303 = y(s,k). Note that \u2016y\u0303\u20161 = k by definition. This gives us\n`avgprec@k(s) = max\u2016y\u0302\u20161=k \u2206(s, y\u0302) \u2265 \u2206(s, y\u0303)\n= \u2206(y, y\u0303) + n\u2211 i=1 si(y\u0303i \u2212 yi) + 1 C(y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yisi\n= \u2206(y, y\u0303) + n\u2211 i=1 si(y\u0303i(1\u2212 yi)\u2212 yi(1\u2212 y\u0303i)) + n+ \u2212 k n+ \u2212K(y, y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yisi\n= \u2206(y, y\u0303) + n\u2211 i=1\ny\u0303i(1\u2212 yi)si\ufe38 \ufe37\ufe37 \ufe38 (A)\n\u2212 k \u2212K(y, y\u0303) n+ \u2212K(y, y\u0303) n\u2211 i=1\n(1\u2212 y\u0303i)yisi\ufe38 \ufe37\ufe37 \ufe38 (B) .\nNow define m = miny\u0303i=1 yi=0 si and M = maxy\u0303i=0 yi=1 si. This gives us\n(A) = n\u2211 i=1 y\u0303i(1\u2212 yi)si \u2265 m n\u2211 i=1 y\u0303i(1\u2212 yi) = \u2206(y, y\u0303) \u00b7m,\nand\n(B) = k \u2212K(y, y\u0303) n+ \u2212K(y, y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yisi \u2264 k \u2212K(y, y\u0303) n+ \u2212K(y, y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yiM = (k \u2212K(y, y\u0303)) \u00b7M = \u2206(y, y\u0303) \u00b7M.\nHowever, by definition of y\u0303 = y(s,k), we have\nm \u2265 min y\u0303=1 si \u2265 max y\u0303=0 si \u2265M.\nThus we have\n`avgprec@k(s) \u2265 \u2206(y, y\u0303) + (A)\u2212 (B) \u2265 \u2206(y, y\u0303)(1 +m\u2212M) \u2265 \u2206(y, y\u0303) = prec@k(s)"}, {"heading": "B.5 Proof of Claim 6", "text": "Claim 6. For any scoring function s that realizes the k-margin over a dataset we have,\n`avgprec@k(s) = prec@k(s) = 0.\nProof. We shall prove that for any y\u0302 such that \u2016y\u0302\u20161 = k, under the k-margin condition, we have \u2206(s, y\u0302) = 0. This will show us that `avgprec@k(s) = max\u2016y\u0302\u20161=k \u2206(s, y\u0302) = 0. Using Claim 17 and the fact that prec@k(s) \u2265 0 will then prove the claimed result. We will analyze two cases in order to do this\nCase 1 (K(y, y\u0302) = k): In this case the labeling y\u0302 is able to identify k relevant points correctly and thus we have C(y\u0302) = 1 and we have\n\u2206(s, y\u0302) = \u2206(y, y\u0302) + n\u2211 i=1 si(y\u0302i \u2212 yi) + n\u2211 i=1 (1\u2212 y\u0302i)yisi\nNow, since K(y, y\u0302) = k, we have \u2206(y, y\u0302) = 0 which means for all i such that y\u0302i = 1, we also have yi = 1. Thus, we have y\u0302i = y\u0302iyi. Thus,\n\u2206(s, y\u0302) = 0 + n\u2211 i=1 si(y\u0302i \u2212 yi) + n\u2211 i=1 (yi \u2212 y\u0302iyi)si = n\u2211 i=1 si(y\u0302i \u2212 yi) + n\u2211 i=1 (yi \u2212 y\u0302i)si = 0\nCase 2 (K(y, y\u0302) = k\u2032 < k): In this case, y\u0302 contains false positives. Thus we have\n\u2206(s, y\u0302) = \u2206(y, y\u0302) + n\u2211 i=1 si(y\u0302i \u2212 yi) + n+ \u2212 k n+ \u2212 k\u2032 n\u2211 i=1 (1\u2212 y\u0302i)yisi\n= \u2206(y, y\u0302) + n\u2211 i=1 y\u0302i(1\u2212 yi)si \u2212 k \u2212 k\u2032 n+ \u2212 k\u2032 n\u2211 i=1 yi(1\u2212 y\u0302i)si\n= (k \u2212 k\u2032)  1k \u2212 k\u2032\u2206(y, y\u0302)\ufe38 \ufe37\ufe37 \ufe38 (A) + 1 k \u2212 k\u2032 n\u2211 i=1 y\u0302i(1\u2212 yi)si\ufe38 \ufe37\ufe37 \ufe38 (B) \u2212 1 n+ \u2212 k\u2032 n\u2211 i=1 yi(1\u2212 y\u0302i)si\ufe38 \ufe37\ufe37 \ufe38 (C)  Now we have, by definition, (A) = 1. We also have\n(B) = 1 k \u2212 k\u2032 n\u2211 i=1 y\u0302i(1\u2212 yi)si \u2264 max j:yj=0 sj ,\nas well as\n(C) = 1 n+ \u2212 k\u2032 n\u2211 i=1 yi(1\u2212 y\u0302i)si\n\u2265 min S+\u2286X+\n|S+|=n+\u2212k\u2032\n1 n+ \u2212 k\u2032 \u2211 i\u2208S+ yi(1\u2212 y\u0302i)si\n\u2265 min S+\u2286X+\n|S+|=n+\u2212k+1\n1 n+ \u2212 k + 1 \u2211 i\u2208S+ yi(1\u2212 y\u0302i)si,\nwhere the last step follows from Lemma 16 and the fact that k\u2032 \u2264 k \u2212 1 in this case analysis. Then we have\n\u2206(s, y\u0302) = (k\u2212k\u2032)((A)+(B)\u2212(C)) \u2264 (k\u2212k\u2032) 1 + max j:yj=0 sj \u2212 min S+\u2286X+\n|S+|=n+\u2212k+1\n1 n+ \u2212 k + 1 \u2211 i\u2208S+ yi(1\u2212 y\u0302i)si  \u2264 0 where the last step follows because s realizes the k-margin. Having exhausted all cases, we establish the claim."}, {"heading": "C Proofs from Section 4", "text": ""}, {"heading": "C.1 Proof of Theorem 7", "text": "Theorem 7. Suppose \u2225\u2225xit\u2225\u2225 \u2264 R for all t, i. Let \u2206CT = \u2211Tt=1 \u2206t be the cumulative observed mistake values when Algorithm 1 is run. Also, for any predictor w, let L\u0302T (w) = \u2211T t=1 ` avg prec@k(w;Xt,yt). Then we have\n\u2206CT \u2264 min w\n( \u2016w\u2016 \u00b7R \u00b7 \u221a 4k + \u221a L\u0302T (w) )2 .\nProof. We will prove the theorem using two lemmata that we state below.\nLemma 18. For any time step t, we have\n\u2016wt\u20162 \u2264 \u2016wt\u22121\u20162 + 4kR2\u2206t\nLemma 19. For any fixed w \u2208 W , define Pt := \u3008wt,w\u3009. Then we have\nPt \u2265 Pt\u22121 + \u2206t \u2212 `avgprec@k(w;Xt,yt).\nUsing Lemmata 18 and 19, we can establish the mistake bound as follows. A repeated application of Lemma 19 tells us that\nPT \u2265 T\u2211 t=1 \u2206t \u2212 T\u2211 t=1 `avgprec@k(w;Xt,yt) = \u2206 C t \u2212 L\u0302T (w).\nIn case the right hand side is negative, we already have the result with us. In case it is positive, we can now analyze further using the Cauchy-Schwartz inequality, and a repeated application of Lemma 18. Starting from the above we have\n\u2206CT \u2264 PT + L\u0302T (w) = \u3008wT ,w\u3009+ L\u0302T (w) \u2264 \u2016wT \u2016 \u2016w\u2016+ L\u0302T (w)\n\u2264 \u2016w\u2016 \u221a\n4kR2 \u00b7\u2206CT + L\u0302T (w),\nwhich gives us the desired result upon solving the quadratic inequality. We now prove the lemmata below. Note that in the following discussion, we have, for sake of brevity, used the notation y\u0302 = y\u0302t = y(wt\u22121,k).\nProof of Lemma 18. For time steps where \u2206t = 0, the result obviously holds since wt = wt\u22121. For analyzing other time steps, let vt = Dt \u00b7 \u2211 i\u2208[b](1\u2212 y\u0302i)yi \u00b7 xit \u2212 \u2211 i\u2208[b](1\u2212 yi)y\u0302i \u00b7 xit so that wt = wt\u22121 + vt. This gives us\n\u2016wt\u20162 = \u2016wt\u22121\u20162 + 2 \u3008wt\u22121,vt\u3009+ \u2016vt\u20162 .\nLet si = w>t\u22121x i t. Then we have\n\u3008wt\u22121,vt\u3009 = Dt \u00b7 \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi \u2212 \u2211 i\u2208[b] (1\u2212 yi)y\u0302isi\n= \u2206t  1 \u2016yt\u20161 \u2212K(yt, y\u0302t) \u2211 i\u2208[b]\n(1\u2212 y\u0302i)yisi\ufe38 \ufe37\ufe37 \ufe38 (A)\n\u2212 1 \u2206t \u2211 i\u2208[b]\n(1\u2212 yi)y\u0302isi\ufe38 \ufe37\ufe37 \ufe38 (B)  More specifically, we use the fact that the inequality (x\u2212 l)2 \u2264 cx has a solution x \u2264 ( \u221a l + \u221a c)2 whenever x, l, c \u2265 0 and x \u2265 l.\n\u2264 0,\nwhere the last step follows since (A) is the average of scores given to the false negatives and (B) is the average of scores given to the false positives and by the definition of y\u0302t, since false negatives are assigned scores less than false positives, we have (A) \u2264 (B). We also have\n\u2016vt\u20162 = \u22062t \u2225\u2225\u2225\u2225\u2225\u2225 1\u2016yt\u20161 \u2212K(yt, y\u0302t) \u00b7 \u2211 i\u2208[b] (1\u2212 y\u0302i)yi \u00b7 xit \u2212 1 \u2206t \u2211 i\u2208[b] (1\u2212 yi)y\u0302i \u00b7 xit \u2225\u2225\u2225\u2225\u2225\u2225 2\n\u2264 4\u22062tR2 \u2264 4kR2\u2206t,\nsince \u2206t \u2264 k. Combining the two gives us the desired result.\nProof of Lemma 19. We prove the result using two cases. For sake of convenience, we will refer to yt and y\u0302t as y and y\u0302 respectively.\nCase 1 (\u2206t = 0): In this case Pt = Pt\u22121 since the model is not updated. However, since `avgprec@k(w) \u2265 prec@k(w) \u2265 0 for all w \u2208 W (by Claim 17), we still get\nPt \u2265 Pt\u22121 \u2212 `avgprec@k(w;Xt,yt),\nas required. Case 2 (\u2206t > 0): In this case we use the update to wt\u22121 to evaluate the update to Pt\u22121. For sake of convenience, let us use the notation si = w>xit. Also note that in Algorithm 1, Dt = 1\u2212 1C(y\u0302) .\nPt = Pt\u22121 \u2212 \u2211 i\u2208[b] (1\u2212 yi)y\u0302isi +Dt \u00b7 \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi\n= Pt\u22121 \u2212 \u2211 i\u2208[b] (1\u2212 yi)y\u0302isi + ( 1\u2212 1 C(y\u0302) )\u2211 i\u2208[b] (1\u2212 y\u0302i)yisi\n= Pt\u22121 \u2212 \u2211 i\u2208[b] (y\u0302i \u2212 yi)si + 1 C(y\u0302) \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi  \ufe38 \ufe37\ufe37 \ufe38\n(Q)\n\u2265 Pt\u22121 + \u2206t \u2212 `avgprec@k(w;Xt,yt),\nwhere the last step follows from the definition of `avgprec@k(\u00b7) which gives us\n\u2206t + (Q) = \u2206(y, y\u0302) + \u2211 i\u2208[b] (y\u0302i \u2212 yi)si + 1 C(y\u0302) \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi\n\u2264 max \u2016y\u0302\u20161=k \u2206(y, y\u0302) + \u2211 i\u2208[b] si(y\u0302i \u2212 yi) + 1 C(y\u0302) \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi  = `avgprec@k(s) = ` avg prec@k(w;Xt,yt)\nThis concludes the proof of the mistake bound."}, {"heading": "C.2 Proof of Theorem 9", "text": "Theorem 9. Suppose \u2225\u2225xit\u2225\u2225 \u2264 R for all t, i. Let \u2206CT = \u2211Tt=1 \u2206t be the cumulative observed mistake values when Algorithm 2 is run. Also, for any predictor w, let L\u0302maxT (w) = \u2211T t=1 ` max prec@k(w;Xt,yt). Then we have\n\u2206CT \u2264 min w\n( \u2016w\u2016 \u00b7R \u00b7 \u221a 4k + \u221a L\u0302maxT (w) )2 .\nProof. As before, we will prove this theorem in two parts. Lemma 18 will continue to hold in this case as well. However, we will need a modified form of Lemma 19 that we prove below. As before, we will use the notation y\u0302 = y\u0302t = y (wt\u22121,k).\nLemma 20. For any fixed w \u2208 W , define Pt := \u3008wt,w\u3009. Then we have\nPt \u2265 Pt\u22121 + \u2206t \u2212 `maxprec@k(w;Xt,yt).\nUsing Lemmata 18 and 20, the theorem follows as before. All that remains now is to prove Lemma 20.\nProof of Lemma 20. We prove the result using two cases as before. For sake of convenience, we will refer to yt and y\u0302t as y and y\u0302 respectively.\nCase 1 (\u2206t = 0): In this case Pt = Pt\u22121 since the model is not updated. However, since `maxprec@k(w) \u2265 prec@k(w) \u2265 0 for all w \u2208 W (by Claim 1), we still get\nPt \u2265 Pt\u22121 \u2212 `maxprec@k(w;Xt,yt),\nas required. Case 2 (\u2206t > 0): In this case we use the update to wt\u22121 to evaluate the update to Pt\u22121. For sake of convenience, let us use the notation si = w>xit. Also note that the set St := FN(w t\u22121,\u2206t) contains the false negatives in the top \u2206t positions as ranked by wt\u22121.\nPt = Pt\u22121 \u2212 \u2211 i\u2208[b] (1\u2212 yi)y\u0302isi + \u2211 i\u2208St (1\u2212 y\u0302i)yisi\n= Pt\u22121 \u2212 \u2211 i\u2208[b] (1\u2212 yi)y\u0302isi \u2212 \u2211 i\u2208[b] yiy\u0302isi + \u2211 i\u2208[b] yiy\u0302isi + \u2211 i\u2208St (1\u2212 y\u0302i)yisi\n= Pt\u22121 \u2212 \u2211 i\u2208[b] y\u0302isi + \u2211 i\u2208[b] yiy\u0302isi + \u2211 i\u2208St (1\u2212 y\u0302i)yisi\n= Pt\u22121 \u2212 \u2211 i\u2208[b] (y\u0302i \u2212 yi)si + \u2211 i\u2208[b] (1\u2212 y\u0302i)yisi \u2212 \u2211 i\u2208St (1\u2212 y\u0302i)yisi  \u2265 Pt\u22121 \u2212\n\u2211 i\u2208[b] (y\u0302i \u2212 yi)si + max y\u0303 (1\u2212y\u0302)\u00b7y \u2016y\u0303\u20161=n+\u2212k n\u2211 i=1 y\u0303isi  \ufe38 \ufe37\ufe37 \ufe38\n(Q)\n\u2265 Pt\u22121 + \u2206t \u2212 `maxprec@k(w;Xt,yt),\nwhere the last step follows from the definition of `avgprec@k(\u00b7) which gives us\n\u2206t + (Q) = \u2206t + \u2211 i\u2208[b] (y\u0302i \u2212 yi)si + max y\u0303 (1\u2212y\u0302)\u00b7y \u2016y\u0303\u20161=n+\u2212k n\u2211 i=1 y\u0303isi\n\u2264 max \u2016y\u0302\u20161=k \u2206t + \u2211 i\u2208[b] (y\u0302i \u2212 yi)si + max y\u0303 (1\u2212y\u0302)\u00b7y \u2016y\u0303\u20161=n+\u2212k n\u2211 i=1 y\u0303isi  = `maxprec@k(s) = ` max prec@k(w;Xt,yt)\nThis concludes the proof of the theorem."}, {"heading": "D Proof of Theorem 12", "text": "Our proof of Theorem 12 crucially utilizes the following two lemmas that helps in exploiting the structure in our surrogate functions. The first basic lemma states that the pointwise supremum of a set of Lipschitz functions is also Lipschitz.\nLemma 21. Let f1, . . . , fm be m real valued functions fi : Rn \u2192 R such that every fi is 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm. Then the function\ng(v) = max i\u2208[m] fi(v)\nis 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm too.\nThe second lemma establishes the convergence of additive estimates over the top of ranked lists. The abstract nature of the result would allow us to apply it to a wide variety of situations and would be crucial to our analyses.\nLemma 22. Let V be a universe with a total order established on it and let v1, . . . ,vn be a population of n items arranged in decreasing order. Let v\u03021, . . . , v\u0302b be a sample chosen i.i.d. (or without replacement) from the population and arranged in decreasing order as well. Then for any fixed h : V \u2192 [\u22121, 1] and \u03ba \u2208 (0, 1], we have, with probability at least 1\u2212 \u03b4 over the choice of the samples,\u2223\u2223\u2223\u2223\u2223\u2223 1d\u03bane d\u03bane\u2211 i=1 h(vi)\u2212 1 d\u03babe d\u03babe\u2211 i=1 h(v\u0302i) \u2223\u2223\u2223\u2223\u2223\u2223 \u2264 4 \u221a log 2\u03b4 \u03bab\nTheorem 12. The performance measure prec@\u03ba(\u00b7), as well as the surrogates `rampprec@\u03ba(\u00b7), ` avg prec@\u03ba(\u00b7) and `maxprec@\u03ba(\u00b7), all exhibit uniform convergence at the rate \u03b1(b, \u03b4) = O (\u221a\n1 b log 1 \u03b4\n) .\nWe will prove the four parts of the theorem in three separate subsections below. We shall consider a population z1, . . . , zn and a sample of size b z\u03021, . . . , z\u0302b chosen uniformly at random with (i.e. i.i.d.) or without replacement. We shall let p and p\u0302 denote the fraction of positives in the population and the sample respectively. In the following, we shall reserve the notation y\u0302 for the label vector in the sample and shall use the notation y\u0303 to denote candidate labellings in the definition of the surrogate."}, {"heading": "D.1 A Uniform Convergence Bound for the prec@\u03ba(\u00b7) Performance Measure", "text": "We note that a point-wise convergence result for prec@\u03ba(\u00b7) follows simply from Lemma 22. To see this, given a population z1, . . . , z)n and a fixed model w \u2208 W , construct a parallel population using the transformation vi \u2190 (w>xi,yi) \u2208 R2. We order these tuples according to their first component, i.e. along the scores and use h(vi) = 1\u2212 yi. Let the population be arranged such that v1 v2 . . .. Then this gives us\nk\u2211 i=1 h(vi) = k\u2211 i=1 (1\u2212 yi) = prec@k(y,y(w,k)) = prec@k(w).\nThus, the application of Lemma 22 gives us the following result\nLemma 23. For any fixed model w \u2208 W , with probability at least 1\u2212 \u03b4 over the choice of b samples, we have\n|prec@\u03ba(w; z1, . . . , zn)\u2212 prec@\u03ba(w; z\u03021, . . . , z\u0302b)| \u2264 O\n(\u221a 1\nb log\n1\n\u03b4\n) .\nTo prove the uniform convergence result, we will, in some sense, require a uniform version of Lemma 22. To do so we fix some notation. For any fixed \u03ba > 0, and for any w \u2208 W , we will define vw as the largest real number v such that\nn\u2211 i=1 I [ w>xi \u2265 v ] = \u03bapn\nSimilarly, we will define v\u0302w as the largest real number v such that\nb\u2211 i=1 I [ w>x\u0302i \u2265 v ] = \u03bap\u0302b\nUsing this notation we can redefine prec@\u03ba(\u00b7) on the population, as well as the sample, as\nprec@\u03ba(w; z1, . . . , zn) := 1\n\u03bapn n\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [yi = 0]\nprec@\u03ba(w; z\u03021, . . . , z\u0302b) := 1\n\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 v\u0302w ] \u00b7 I [y\u0302i = 0]\nWe can now write\nsup w\u2208W\n|prec@\u03ba(w; z1, . . . , zn)\u2212 prec@\u03ba(w; z\u03021, . . . , z\u0302b)|\n= sup w\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bapn n\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [yi = 0]\u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 v\u0302w ] \u00b7 I [y\u0302i = 0] \u2223\u2223\u2223\u2223\u2223 \u2264 sup\nw\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bapn n\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [yi = 0]\u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [y\u0302i = 0] \u2223\u2223\u2223\u2223\u2223 + sup\nw\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [y\u0302i = 0]\u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 v\u0302w ] \u00b7 I [y\u0302i = 0] \u2223\u2223\u2223\u2223\u2223 \u2264 sup\nw\u2208W,t\u2208R \u2223\u2223\u2223\u2223\u2223 1\u03bapn n\u2211 i=1 I [ w>x \u2265 t ] \u00b7 I [yi = 0]\u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 t ] \u00b7 I [y\u0302i = 0] \u2223\u2223\u2223\u2223\u2223\ufe38 \ufe37\ufe37 \ufe38 (A)\n+ sup w\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u00b7 I [y\u0302i = 0]\u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 v\u0302w ] \u00b7 I [y\u0302i = 0] \u2223\u2223\u2223\u2223\u2223\ufe38 \ufe37\ufe37 \ufe38 (B)\nNow, using a standard VC-dimension based uniform convergence argument over the class of thresholded classifiers, we get the following result: with probability at least 1\u2212 \u03b4\n(A) \u2264 O\n(\u221a 1\nb\n( log 1\n\u03b4 + dVC(W) \u00b7 log b\n)) = O\u0303 (\u221a 1\nb log\n1\n\u03b4\n) ,\nwhere dVC(W) is the VC-dimension of the set of classifiersW . Moving on to bound the second term, we can use an argument similar to the one used to prove Lemma 22 to show that\n(B) \u2264 sup w\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u2212 1 \u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 v\u0302w ]\u2223\u2223\u2223\u2223\u2223 \u2264 sup\nw\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u2212 \u03ba \u2223\u2223\u2223\u2223\u2223 \u2264 sup\nw\u2208W \u2223\u2223\u2223\u2223\u2223 1\u03bap\u0302b b\u2211 i=1 I [ w>x \u2265 vw ] \u2212 1 \u03bapn n\u2211 i=1 I [ w>x \u2265 vw ]\u2223\u2223\u2223\u2223\u2223\n\u2264 O\u0303\n(\u221a 1\nb log\n1\n\u03b4\n) ,\nwhere the last step follows from a standard VC-dimension based uniform convergence argument as before. This establishes the following uniform convergence result for the prec@k(\u00b7) performance measure\nTheorem 24. We have, with probability at least 1\u2212 \u03b4 over the choice of b samples,\nsup w\u2208W\n|prec@\u03ba(w; z1, . . . , zn)\u2212 prec@\u03ba(w; z\u03021, . . . , z\u0302b)| \u2264 O\u0303\n(\u221a 1\nb log\n1\n\u03b4\n) ."}, {"heading": "D.2 A Uniform Convergence Bound for the `rampprec@\u03ba(\u00b7) Surrogate", "text": "We first recall the form of the (normalized) surrogate below - note that this is a non-convex surrogate. Also recall that k = \u03ba \u00b7 n+(y).\n`rampprec@\u03ba(w; z1, . . . , zn) = max\u2016y\u0303\u20161=k\n{ \u2206(y, y\u0303)\nk +\n1\nk n\u2211 i=1 y\u0303iw >xi } \ufe38 \ufe37\ufe37 \ufe38\n\u03a81(w; z1,...,zn)\n\u2212 max \u2016y\u0303\u20161=k K(y,y\u0303)=k\n1\nk n\u2211 i=1 y\u0303iw >xi\n\ufe38 \ufe37\ufe37 \ufe38 \u03a82(w; z1,...,zn)\nWe will now show that both the functions \u03a81(\u00b7), as well as \u03a82(\u00b7), exhibit uniform convergence. This shall suffice to prove that `rampprec@\u03ba(\u00b7) exhibits uniform convergence. To do so we shall show that the two functions exhibit pointwise convergence and that they are Lipschitz. This will allow a standard L\u221e covering number argument Zhang [2002] to give us the required uniform convergence results."}, {"heading": "D.2.1 A Uniform Convergence Result for \u03a81(\u00b7)", "text": "We have\n\u03a81(w; z1, . . . , zn) = max \u2016y\u0303\u20161=\u03bapn\n{ 1\n\u03bapn n\u2211 i=1 y\u0303i(w >xi \u2212 yi)\n} + 1\n\u03a81(w; z\u03021, . . . , z\u0302b) = max \u2016y\u0303\u20161=\u03bap\u0302b\n{ 1\n\u03bap\u0302b b\u2211 i=1 y\u0303i(w >x\u0302i \u2212 y\u0302i)\n} + 1\nAn application of Corollary 29 indicates that \u03a81(\u00b7) is Lipschitz i.e.\n|\u03a81(w; z1, . . . , zn)\u2212\u03a81(w\u2032; z1, . . . , zn)| \u2264 O (\u2016w \u2212w\u2032\u20162) .\nThus, all that remains is to prove pointwise convergence. We decompose the error as follows\n|\u03a81(w; z1, . . . , zn)\u2212\u03a81(w; z\u03021, . . . , z\u0302b)| \u2264 \u2223\u2223\u2223\u2223\u2223\u03a81(w; z1, . . . , zn)\u2212 max\u2016y\u0303\u20161=\u03bapb { 1 \u03bapb b\u2211 i=1 y\u0303i(w >x\u0302i \u2212 y\u0302i) } + 1 \u2223\u2223\u2223\u2223\u2223\ufe38 \ufe37\ufe37 \ufe38 (A)\n+ \u2223\u2223\u2223\u2223\u2223 max\u2016y\u0303\u20161=\u03bapb { 1 \u03bapb b\u2211 i=1 y\u0303i(w >x\u0302i \u2212 y\u0302i) } + 1\u2212\u03a81(w; z\u03021, . . . , z\u0302b) \u2223\u2223\u2223\u2223\u2223\ufe38 \ufe37\ufe37 \ufe38 (B)\nAn application of Lemma 22 using vi = w>x\u0302i \u2212 y\u0302i and h(\u00b7) as the identity function shows us that\n(A) \u2264 O\n( 1\n\u03bap\n\u221a 1\nb log\n1\n\u03b4\n) .\nTo bound the residual term (B), notice that an application of the Hoeffding\u2019s inequality tells us that with probability at least 1\u2212 \u03b4 |p\u2212 p\u0302| \u2264 \u221a 1\n2b log\n2 \u03b4 ,\nwhich lets us bound the residual as follows. Assume, for sake of simplicity, that the sample data points have been ordered in decreasing order of the quantity w>x\u0302i \u2212 yi as well as that \u2223\u2223w>x\u2223\u2223 \u2264 1 for all x. (B) =\n\u2223\u2223\u2223\u2223\u2223 max\u2016y\u0303\u20161=\u03bapb { 1 \u03bapb b\u2211 i=1 y\u0303i(w >x\u0302i \u2212 y\u0302i) } \u2212 max \u2016y\u0303\u20161=\u03bap\u0302b { 1 \u03bap\u0302b b\u2211 i=1 y\u0303i(w >x\u0302i \u2212 y\u0302i) }\u2223\u2223\u2223\u2223\u2223 =\n\u2223\u2223\u2223\u2223\u2223 1\u03bapb \u03bapb\u2211 i=1 (w>x\u0302i \u2212 y\u0302i)\u2212 1 \u03bap\u0302b \u03bap\u0302b\u2211 i=1 (w>x\u0302i \u2212 y\u0302i) \u2223\u2223\u2223\u2223\u2223 \u2264 \u2223\u2223\u2223\u2223\u2223\u2223 \u03bamin{p,p\u0302}b\u2211\ni=1\n( 1\n\u03bapb \u2212 1 \u03bap\u0302b\n) (w>x\u0302i \u2212 y\u0302i) \u2223\u2223\u2223\u2223\u2223\u2223+ \u2223\u2223\u2223\u2223\u2223\u2223 1\u03bamax {p, p\u0302} b \u03bamax{p,p\u0302}b\u2211 i=\u03bamin{p,p\u0302}b+1 (w>x\u0302i \u2212 y\u0302i) \u2223\u2223\u2223\u2223\u2223\u2223 \u2264 2 \u03bab \u2223\u2223\u2223\u2223p\u2212 p\u0302pp\u0302 \u2223\u2223\u2223\u2223 \u00b7 \u03bamin {p, p\u0302} b+ 2\u03bamax {p, p\u0302} b \u00b7 \u03ba |p\u2212 p\u0302| b\n= 2 |p\u2212 p\u0302| \u00b7 (\nmin {p, p\u0302} pp\u0302 + 1 max {p, p\u0302} ) \u2264 \u221a 1\n2b log\n2 \u03b4 \u00b7 2 max {p, p\u0302} \u2264 2 p\n\u221a 1\n2b log\n2\n\u03b4\nThis establishes that for any fixed w \u2208 W , with probability at least 1\u2212 \u03b4, we have\n|\u03a81(w; z1, . . . , zn)\u2212\u03a81(w; z\u03021, . . . , z\u0302b)| \u2264 O\n(\u221a 1\nb log\n1\n\u03b4\n)\nwhich concludes the uniform convergence proof."}, {"heading": "D.2.2 A Uniform Convergence Result for \u03a82(\u00b7)", "text": "The proof follows similarly here with a direct application of Corollary 29 showing us that \u03a82(\u00b7) is Lipschitz and an application of Lemma 22 along with the observation that |p\u2212 p\u0302| \u2264 \u221a 1 2b log 2 \u03b4 similar to the discussion used above concluding the point-wise convergence proof. The above two part argument establishes the following uniform convergence result for the `rampprec@\u03ba(\u00b7) performance measure\nTheorem 25. We have, with probability at least 1\u2212 \u03b4 over the choice of b samples,\nsup w\u2208W\n\u2223\u2223\u2223`rampprec@\u03ba(w; z1, . . . , zn)\u2212 `rampprec@\u03ba(w; z\u03021, . . . , z\u0302b)\u2223\u2223\u2223 \u2264 O (\u221a 1\nb log\n1\n\u03b4\n) ."}, {"heading": "D.3 A Uniform Convergence Bound for the `avgprec@\u03ba(\u00b7) Surrogate", "text": "This will be the most involved of the four bounds, given the intricate nature of the surrogate. We will prove this result using a series of partial results which we state below. As before, for any w \u2208 W and any y\u0303, we define\n\u2206(w, y\u0303) := 1\n\u03bapn\n( \u2206(y, y\u0303) +\nn\u2211 i=1 (y\u0303i \u2212 yi)w>xi + 1 C(y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yiw>xi\n)\n\u2206\u0302(w, y\u0303) := 1\n\u03bap\u0302b\n( \u2206(y\u0302, y\u0303) +\nn\u2211 i=1 (y\u0303i \u2212 y\u0302i)w>x\u0302i + 1 C(y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)y\u0302iw>x\u0302i\n)\nRecall that we are using y\u0302 to denote the true labels of the sample points and y\u0303 to denote the candidate labellings while defining the surrogates. We also define, for any \u03b2 \u2208 [0, 1], the following quantities\n\u2206(w, \u03b2) := max \u2016y\u0303\u20161=\u03bapn K(y,y\u0303)=\u03b2pn\n{\u2206(w, y\u0303)}\n\u2206\u0302(w, \u03b2) := max \u2016y\u0303\u20161=\u03bap\u0302b K(y\u0302,y\u0303)=\u03b2p\u0302b\n{ \u2206\u0302(w, y\u0303) } Note that \u03b2 denotes a target true positive rate and consequently, can only take values between 0 and \u03ba. Given the above, we claim the following lemmata\nLemma 26. For every w and any \u03b2, \u03b2\u2032 \u2208 [0, \u03ba], we have\n|\u2206(w, \u03b2)\u2212\u2206(w, \u03b2\u2032)| \u2264 O (|\u03b2 \u2212 \u03b2\u2032|) .\nLemma 27. For any fixed \u03b2, we have, with probability at least 1\u2212 \u03b4 over the choice of the sample\nsup w\u2208W \u2223\u2223\u2223\u2206(w, \u03b2)\u2212 \u2206\u0302(w, \u03b2)\u2223\u2223\u2223 \u2264 O(\u221a1 b log 1 \u03b4 ) .\nUsing the above two lemmata as given, we can now prove the desired uniform convergence result for the `avgprec@\u03ba(\u00b7) surrogate:\nTheorem 28. With probability at least 1\u2212 \u03b4 over the choice of the samples, we have\nsup w\u2208W\n\u2223\u2223\u2223`avgprec@\u03ba(w; z1, . . . , zn)\u2212 `avgprec@\u03ba(w; z\u03021, . . . , z\u0302b)\u2223\u2223\u2223 \u2264 O\u0303 (\u221a 1\nb log\n1\n\u03b4\n) .\nProof. We note that given the definitions of \u2206(w, \u03b2) and \u2206\u0302(w, \u03b2), we can redefine the performance measure as follows\n`avgprec@\u03ba(w; z1, . . . , zn) = max \u03b2\u2208[0,\u03ba] \u2206(w, \u03b2)\nWe now note that for the population, the set of achievable values of true positive rates i.e. \u03b2 is\nB = { 0, 1\n\u03bapn ,\n2\n\u03bapn , . . . , \u03bapn\u2212 1 \u03bapn , 1\n} ,\nwhich correspond, respectively, to classifiers for which the number of true positives equals {0, 1, 2 . . . \u03bapn\u2212 1, \u03bapn}. Similarly, the set of achievable values of true positive rates i.e. \u03b2 for the sample is\nB\u0302 = { 0, 1\n\u03bap\u0302b ,\n2\n\u03bap\u0302b , . . . , \u03bap\u0302b\u2212 1 \u03bap\u0302b , 1\n} .\nClearly, for any \u03b2 \u2208 B, there exists a \u03c0B\u0302(\u03b2) \u2208 B\u0302 such that\u2223\u2223\u03c0B\u0302(\u03b2)\u2212 \u03b2\u2223\u2223 \u2264 1\u03bap\u0302b . Given this, let us define\n\u03b2\u2217(w) = arg max \u03b2\u2208[0,\u03ba] \u2206(w, \u03b2)\n\u03b2\u0302\u2217(w) = arg max \u03b2\u0302\u2208[0,\u03ba] \u2206\u0302(w, \u03b2\u0302)\nWe shall assume, for the sake of simplicity, that s|n so that B\u0302 \u2282 B. This gives us the following set of inequalities for any w \u2208 W:\n\u2206(w, \u03b2\u2217(w)) \u2264 \u2206(w, \u03c0B\u0302(\u03b2 \u2217(w))) + \u2223\u2223\u03b2\u2217(w)\u2212 \u03c0B\u0302(\u03b2\u2217(w))\u2223\u2223 \u2264 \u2206\u0302(w, \u03c0B\u0302(\u03b2\n\u2217(w))) + sup w\u2208W \u2223\u2223\u2223\u2206(w, \u03c0B\u0302(\u03b2\u2217(w)))\u2212 \u2206\u0302(w, \u03c0B\u0302(\u03b2\u2217(w)))\u2223\u2223\u2223+ 1\u03bap\u0302b \u2264 \u2206\u0302(w, \u03c0B\u0302(\u03b2\n\u2217(w))) + sup w\u2208W,\u03b2\u0302\u2208B\u0302 \u2223\u2223\u2223\u2206(w, \u03b2\u0302)\u2212 \u2206\u0302(w, \u03b2\u0302)\u2223\u2223\u2223+ 1 \u03bap\u0302b\n\u2264 \u2206\u0302(w, \u03c0B\u0302(\u03b2 \u2217(w))) +O\n(\u221a 1\nb log\nb\n\u03b4\n) + 1\n\u03bap\u0302b\n\u2264 \u2206\u0302(w, \u03b2\u0302\u2217(w)) +O\n(\u221a 1\nb log\nb\n\u03b4\n) + 1\n\u03bap\u0302b ,\nwhere the first step follows from Lemma 26, the third step follows since \u03c0B\u0302(\u03b2 \u2217(w)) \u2208 B\u0302, the fourth step follows from an application of the union bound with Lemma 27 over the set of elements in B\u0302 and noting \u2223\u2223\u2223B\u0302\u2223\u2223\u2223 \u2264 O (b), and the last\nstep follows from the optimality of \u03b2\u0302\u2217(w). Similarly we can write, for any w \u2208 W ,\n\u2206\u0302(w, \u03b2\u0302\u2217(w)) \u2264 \u2206(w, \u03b2\u0302\u2217(w)) +O\n(\u221a 1\nb log\nb\n\u03b4\n)\n\u2264 \u2206(w, \u03b2\u2217(w)) +O\n(\u221a 1\nb log\nb\n\u03b4\n) ,\nwhere the first step uses Lemma 27 with a union bound over elements in B\u0302 and the fact that \u03b2\u0302\u2217(w) \u2208 B\u0302 \u2282 B (note that this assumption is not crucial to the argument \u2013 indeed, even if \u03b2\u0302\u2217(w) /\u2208 B, we would only incur an extra O ( 1 n ) error by an application of Lemma 26 since given the granularity of B, we would always be able to find a value in B that is no more than O ( 1 n ) far from \u03b2\u0302\u2217(w)), and the last step uses the optimality of \u03b2\u2217(w). Thus, we can write\nsup w\u2208W \u2223\u2223\u2223`avgprec@\u03ba(w; z1, . . . , zn)\u2212 `avgprec@\u03ba(w; z\u03021, . . . , z\u0302b)\u2223\u2223\u2223 = sup w\u2208W \u2223\u2223\u2223\u2206(w, \u03b2\u2217(w))\u2212 \u2206\u0302(w, \u03b2\u0302\u2217(w))\u2223\u2223\u2223 \u2264 O (\u221a 1\nb log\nb\n\u03b4\n) + 1\n\u03bap\u0302b\n\u2264 O\u0303\n(\u221a 1\nb log\n1\n\u03b4\n) ,\nsince p\u0302 \u2265 \u2126 (1) with probability at least 1 \u2212 \u03b4. Thus, all we are left is to prove Lemmata 26 and 27 which we do below. To proceed with the proofs, we first write the form of \u2206(w, \u03b2) for a fixed w and \u03b2 and simplify the expression for ease of further analysis. We shall assume, for sake of simplicity, that \u03b2pn, \u03bapn, \u03b2p\u0302b, and \u03bap\u0302b are all integers.\n\u2206(w, \u03b2) = max \u2016y\u0303\u20161=\u03bapn K(y,y\u0303)=\u03b2pn\n{ 1\n\u03bapn\n( \u2206(y, y\u0303) +\nn\u2211 i=1 (y\u0303i \u2212 yi)w>xi + 1 C(y\u0303) n\u2211 i=1 (1\u2212 y\u0303i)yiw>xi\n)}\n= 1\u2212 \u03b2 \u03ba \u2212 1 \u03bapn ( \u03ba\u2212 \u03b2 1\u2212 \u03b2 ) n\u2211 i=1\nyiw >xi\ufe38 \ufe37\ufe37 \ufe38\nA(w,\u03b2)\n+ max \u2016y\u0303\u20161=\u03bapn K(y,y\u0303)=\u03b2pn\n{ 1\n\u03bapn n\u2211 i=1 y\u0303i ( 1\u2212 1\u2212 \u03ba 1\u2212 \u03b2 \u00b7 yi ) w>xi } \ufe38 \ufe37\ufe37 \ufe38\nB(w,\u03b2)\nWe can similarly define A\u0302(w, \u03b2) and B\u0302(w, \u03b2) for the samples.\nProof of Lemma 26. We have, by the above simplification,\n|\u2206(w, \u03b2)\u2212\u2206(w, \u03b2\u2032)| = 1 \u03ba |\u03b2 \u2212 \u03b2\u2032|+ |A(w, \u03b2)\u2212A(w, \u03b2\u2032)|+ |B(w, \u03b2)\u2212B(w, \u03b2\u2032)| ,\nas well as, assuming without loss of generality, that \u2223\u2223w>x\u2223\u2223 \u2264 1 for all w and x,\n|A(w, \u03b2)\u2212A(w, \u03b2\u2032)| \u2264 \u2223\u2223\u2223\u2223\u03ba\u2212 \u03b21\u2212 \u03b2 \u2212 \u03ba\u2212 \u03b2\u20321\u2212 \u03b2\u2032 \u2223\u2223\u2223\u2223 \u00b7 \u2223\u2223\u2223\u2223\u2223 1\u03bapn n\u2211 i=1 yiw >xi \u2223\u2223\u2223\u2223\u2223 \u2264 (1\u2212 \u03ba) |\u03b2 \u2212 \u03b2\n\u2032| \u03ba(1\u2212 \u03b2)(1\u2212 \u03b2\u2032) \u2264 1 \u03ba(1\u2212 \u03ba) |\u03b2 \u2212 \u03b2\u2032| ,\nwhere the last step follows since \u03b2, \u03b2\u2032 \u2264 \u03ba. To analyze the third term i.e. |B(w, \u03b2)\u2212B(w, \u03b2\u2032)|, we analyze the nature of the assignment y\u0303 which defines B(w, \u03b2). Clearly y\u0303 must assign \u03b2pn positives and (\u03ba \u2212 \u03b2)pn negatives a label of 1 and the rest, a label of 0. Since it is supposed to maximize the scores thus obtained, it clearly assigns the top ranked (\u03ba \u2212 \u03b2)pn negatives a label of 1. As far as positives are concerned, \u03b2 < \u03ba, we have ( 1\u2212 1\u2212\u03ba1\u2212\u03b2 ) \u2265 0 which means that the \u03b2pn top ranked positives will get assigned a label of 1. To formalize this, let us set some notation. Let s+1 \u2265 s + 2 \u2265 . . . \u2265 s+pn denote the scores of the positive points arranged in descending order. Similarly, let s\u22121 \u2265 s \u2212 2 \u2265 . . . \u2265 s \u2212 (1\u2212p)n denote the scores of the negative points arranged in descending order. Given this notation, we can rewrite B(w, \u03b2) as follows:\nB(w, \u03b2) = 1\n\u03bapn (\u03ba\u2212 \u03b2 1\u2212 \u03b2 ) \u03b2pn\u2211 i=1 s+i + (\u03ba\u2212\u03b2)pn\u2211 i=1 s\u2212i  . Thus, assuming without loss of generality that\n\u2223\u2223s+i \u2223\u2223 , \u2223\u2223s\u2212i \u2223\u2223 \u2264 1, we have, |B(w, \u03b2)\u2212B(w, \u03b2\u2032)| = 1\n\u03bapn \u2223\u2223\u2223\u2223\u2223\u2223 ( \u03ba\u2212 \u03b2 1\u2212 \u03b2 ) \u03b2pn\u2211 i=1 s+i + (\u03ba\u2212\u03b2)pn\u2211 i=1 s\u2212i \u2212 ( \u03ba\u2212 \u03b2\u2032 1\u2212 \u03b2\u2032 ) \u03b2\u2032pn\u2211 i=1 s+i \u2212 (\u03ba\u2212\u03b2\u2032)pn\u2211 i=1 s\u2212i \u2223\u2223\u2223\u2223\u2223\u2223 \u2264 1 \u03bapn \u2223\u2223\u2223\u2223\u2223\u2223 ( \u03ba\u2212 \u03b2 1\u2212 \u03b2 ) \u03b2pn\u2211 i=1 s+i \u2212 ( \u03ba\u2212 \u03b2\u2032 1\u2212 \u03b2\u2032 ) \u03b2\u2032pn\u2211 i=1 s+i \u2223\u2223\u2223\u2223\u2223\u2223+ 1\u03bapn \u2223\u2223\u2223\u2223\u2223\u2223 (\u03ba\u2212\u03b2)pn\u2211 i=1 s\u2212i \u2212 (\u03ba\u2212\u03b2\u2032)pn\u2211 i=1 s\u2212i\n\u2223\u2223\u2223\u2223\u2223\u2223 \u2264 \u2223\u2223\u2223\u2223\u03ba\u2212 \u03b21\u2212 \u03b2 \u2212 \u03ba\u2212 \u03b2\u20321\u2212 \u03b2\u2032 \u2223\u2223\u2223\u2223 \u00b7 \u2223\u2223\u2223\u2223\u2223\u2223\u2223 1 \u03bapn min{\u03b2,\u03b2\u2032}pn\u2211 i=1 s+i \u2223\u2223\u2223\u2223\u2223\u2223\u2223+ 1 \u03bapn \u03ba\u2212max {\u03b2, \u03b2\u2032} 1\u2212max {\u03b2, \u03b2\u2032} |\u03b2 \u2212 \u03b2\u2032| pn+ |\u03b2 \u2212 \u03b2 \u2032| pn \u03bapn\n\u2264 1 \u03ba(1\u2212 \u03ba)\n|\u03b2 \u2212 \u03b2\u2032| min {\u03b2, \u03b2 \u2032} pn\n\u03bapn +\n1\n\u03ba \u03ba\u2212max {\u03b2, \u03b2\u2032} 1\u2212max {\u03b2, \u03b2\u2032} |\u03b2 \u2212 \u03b2\u2032|+ |\u03b2 \u2212 \u03b2 \u2032| \u03ba\n\u2264 2 \u03ba(1\u2212 \u03ba) |\u03b2 \u2212 \u03b2\u2032| ,\nwhere the last step uses the fact that 0 \u2264 \u03b2, \u03b2\u2032 \u2264 \u03ba. This tells us that\n|\u2206(w, \u03b2)\u2212\u2206(w, \u03b2\u2032)| \u2264 4\u2212 \u03ba \u03ba(1\u2212 \u03ba) |\u03b2 \u2212 \u03b2\u2032| ,\nwhich finishes the proof.\nProof of Lemma 27. We will prove the theorem by showing that the terms A(w, \u03b2) and B(w, \u03b2) exhibit uniform convergence.\nIt is easy to see that A(w, \u03b2) exhibits uniform convergence since it is a simple average of population scores. The only thing to be taken care of is that A(w, \u03b2) contains p in the normalization whereas A\u0302(w, \u03b2) contains p\u0302. However, since p and p\u0302 are very close with high probability, an argument similar to the one used in the proof of Theorem 25 can be used to conclude that with probability at least 1\u2212 \u03b4, we have\nsup w\u2208W \u2223\u2223\u2223A(w, \u03b2)\u2212 A\u0302(w, \u03b2)\u2223\u2223\u2223 \u2264 O(\u221a1 b log 1 \u03b4 ) .\nTo prove uniform convergence for B(w, \u03b2) we will use our earlier method of showing that this function exhibits pointwise convergence and that this function is Lipschitz with respect to w. The Lipschitz property of B(w, \u03b2) is evident from an application of Corollary 29. To analyze its pointwise convergence property\nThus the function B(w, \u03b2), as analyzed in the proof of Lemma 26, is composed by sorting the positives and negatives separately and taking the top few positions in each list and adding the scores present therein. This allows an application of Lemma 22, as used in the proof of Theorem 25, separately to the positive and negative lists, to conclude the pointwise convergence bound for B(w, \u03b2).\nThis concludes the proof of the uniform convergence bound for `avgprec@\u03ba(\u00b7)."}, {"heading": "D.4 Proof of Lemma 21", "text": "Lemma 21. Let f1, . . . , fm be m real valued functions fi : Rn \u2192 R such that every fi is 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm. Then the function\ng(v) = max i\u2208[m] fi(v)\nis 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm too.\nProof. Fix v,v\u2032 \u2208 Rn. The premise guarantees us that for any i \u2208 [m], we have\n|fi(v)\u2212 fi(v\u2032)| \u2264 \u2016v \u2212 v\u2032\u2016\u221e .\nNow let g(v) = fi(v) and g(v\u2032) = fj(v\u2032). Then we have\ng(v)\u2212 g(v\u2032) = fi(v)\u2212 fj(v\u2032) \u2264 fi(v)\u2212 fi(v\u2032) \u2264 \u2016v \u2212 v\u2032\u2016\u221e ,\nsince fj(v\u2032) \u2265 fi(v\u2032). Similarly we have g(v\u2032)\u2212 g(v) \u2264 \u2016v \u2212 v\u2032\u2016\u221e. This completes the proof.\nThe following corollary would be most useful in our subsequent analyses.\nCorollary 29. Let \u03a8 :W \u2192 R be a function defined as follows\n\u03a8(w) = max y\u0302\u2208{0,1}n \u2016y\u0302\u20161=k\n1\nk\n\u2211 y\u0302i(w >xi \u2212 ci),\nwhere ci are constants independent of w and we assume without loss of generality that \u2016xi\u20162 \u2264 1 for all i. Then \u03a8(\u00b7) is 1- Lipschitz with respect to the L2 norm i.e. for all w,w\u2032 \u2208 W\n|\u03a8(w)\u2212\u03a8(w\u2032)| \u2264 \u2016w \u2212w\u2032\u20162 .\nProof. Note that for any y\u0302 such that \u2016y\u0302\u20161 = k, the function fy\u0302(v) = 1 k \u2211 y\u0302i(vi \u2212 ci) is 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm. Thus if we define \u03a6(v) = max\n\u2016y\u0302\u20161=k fy\u0302(v),\nthen an application of Lemma 21 tells us that \u03a6(\u00b7) is 1-Lipschitz with respect to the \u2016\u00b7\u2016\u221e norm as well. Also note that if we define\nv(w) = ( w>x1 \u2212 c1, . . . ,w>xn \u2212 cn ) ,\nthen we have \u03a8(w) = \u03a6(v(w))\nWe now note that by an application of Cauchy-Schwartz inequality, and the fact that \u2016xi\u20162 \u2264 1 for all i, we have\n\u2016v(w)\u2212 v(w\u2032)\u2016\u221e \u2264 \u2016w \u2212w \u2032\u20162\nThus we have\n|\u03a8(w)\u2212\u03a8(w\u2032)| = |\u03a6(v(w))\u2212 \u03a6(v(w\u2032))| \u2264 \u2016v(w)\u2212 v(w\u2032)\u2016\u221e \u2264 \u2016w \u2212w \u2032\u20162\nwhich gives us the desired result."}, {"heading": "D.5 Proof of Lemma 22", "text": "Lemma 22. Let V be a universe with a total order established on it and let v1, . . . ,vn be a population of n items arranged in decreasing order. Let v\u03021, . . . , v\u0302b be a sample chosen i.i.d. (or without replacement) from the population and arranged in decreasing order as well. Then for any fixed h : V \u2192 [\u22121, 1] and \u03ba \u2208 (0, 1], we have, with probability at least 1\u2212 \u03b4 over the choice of the samples,\u2223\u2223\u2223\u2223\u2223\u2223 1d\u03bane d\u03bane\u2211 i=1 h(vi)\u2212 1 d\u03babe d\u03babe\u2211 i=1 h(v\u0302i) \u2223\u2223\u2223\u2223\u2223\u2223 \u2264 4 \u221a log 2\u03b4 \u03bab\nProof. We will assume, for sake of simplicity, that \u03ban and \u03bab are both integers so that there are no rounding off issues. Let v\u2217n := v\u03ban and v \u2217 b := v\u0302\u03bab denote the elements at the bottom of the \u03ba-th fraction of the top in the sorted population and sample lists (recall that the population and the sample lists are sorted in descending order). Also let T(v) := I [v v\u2217n] and T\u0302(v) := I [v v\u2217b ] (note that I [E] is the indicator variable for the event E) so that we have\u2223\u2223\u2223\u2223\u2223 1\u03ban \u03ban\u2211 i=1 h(vi)\u2212 1 \u03bab \u03bab\u2211 i=1 h(v\u0302i) \u2223\u2223\u2223\u2223\u2223 = \u2223\u2223\u2223\u2223\u2223 1\u03ban n\u2211 i=1 T(vi) \u00b7 h(vi)\u2212 1 \u03bab b\u2211 i=1 T\u0302(v\u0302i) \u00b7 h(v\u0302i)\n\u2223\u2223\u2223\u2223\u2223 \u2264\n\u2223\u2223\u2223\u2223\u2223 1\u03ban n\u2211 i=1 T(vi) \u00b7 h(vi)\u2212 1 \u03bab b\u2211 i=1 T(v\u0302i) \u00b7 h(v\u0302i) \u2223\u2223\u2223\u2223\u2223+ \u2223\u2223\u2223\u2223\u2223 1\u03bab b\u2211 i=1 ( T(v\u0302i)\u2212 T\u0302(v\u0302i) ) \u00b7 h(v\u0302i) \u2223\u2223\u2223\u2223\u2223 \u2264 2 \u221a log 2\u03b4 \u03bab + \u2223\u2223\u2223\u2223\u2223 1\u03bab b\u2211 i=1 ( T(v\u0302i)\u2212 T\u0302(v\u0302i) ) \u00b7 h(v\u0302i)\n\u2223\u2223\u2223\u2223\u2223\ufe38 \ufe37\ufe37 \ufe38 (A) ,\nwhere the third step follows from Bernstein\u2019s inequality (which holds in situations with sampling without replacement as well Boucheron et al. [2004]) since |T(v) \u00b7 h(v)| \u2264 1 for all v and we have assumed b \u2265 1\u03ba log 2 \u03b4 . Now if v \u2217 n v\u2217b , then we have T\u0302(v) \u2265 T(v) for all v. On the other hand if v\u2217b v\u2217n, then we have T\u0302(v) \u2264 T(v) for all v. This means that since |h(v)| \u2264 1 for all v, we have\n(A) \u2264 \u2223\u2223\u2223\u2223\u2223 1\u03bab b\u2211 i=1 ( T(v\u0302i)\u2212 T\u0302(v\u0302i) )\u2223\u2223\u2223\u2223\u2223 = \u2223\u2223\u2223\u2223\u2223 1\u03bab b\u2211 i=1 T(v\u0302i)\u2212 1 \u2223\u2223\u2223\u2223\u2223 \u2264 2 \u221a log 2\u03b4 \u03bab ,\nwhere the second step follows since 1\u03bab \u2211b i=1 T\u0302(v\u0302i) = 1 by definition and the last step follows from another application of Bernstein\u2019s inequality. This completes the proof."}, {"heading": "D.6 A Uniform Convergence Bound for the `maxprec@\u03ba(\u00b7) Surrogate", "text": "Having proved a generalization bound for the `avgprec@\u03ba(\u00b7) surrogate, we note that similar techniques, that involve partitioning the candidate label space into labels that have a fixed true positive rate \u03b2, and arguing uniform convergence for each partition, can be used to prove a generalization bound for the `maxprec@\u03ba(\u00b7) surrogate as well. We postpone the details of the argument to a later version of the paper."}, {"heading": "E Proof of Theorem 15", "text": "Theorem 15. Let w\u0304 be the model returned by Algorithm 3 when executed on a stream with T batches of length b. Then with probability at least 1\u2212 \u03b4, for any w\u2217 \u2208 W , we have\n`avgprec@\u03ba(w\u0304;Z) \u2264 ` avg prec@\u03ba(w \u2217;Z) +O\n(\u221a 1\nb log\nT\n\u03b4\n) +O (\u221a 1\nT\n)\nProof. The proof of this theorem closely follows that of Theorems 7 and 8 in Kar et al. [2014]. More specifically, Theorem 6 from Kar et al. [2014] ensures that any convex loss function demonstrating uniform convergence would ensure a result of the kind we are trying to prove. Since Theorem 12 confirms that `avgprec@\u03ba(\u00b7) exhibits uniform convergence, the proof follows.\nF Additional Empirical Results"}], "references": [{"title": "The Infinite Push: A new support vector ranking algorithm that directly optimizes accuracy at the absolute top of the list", "author": ["S. Agarwal"], "venue": "In 11th SIAM International Conference on Data Mining (SDM),", "citeRegEx": "Agarwal.,? \\Q2011\\E", "shortCiteRegEx": "Agarwal.", "year": 2011}, {"title": "Concentration inequalities", "author": ["Stphane Boucheron", "Gbor Lugosi", "Olivier Bousquet"], "venue": "In Advanced Lectures in Machine Learning,", "citeRegEx": "Boucheron et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Boucheron et al\\.", "year": 2004}, {"title": "Accuracy at the top", "author": ["Stephen Boyd", "Corinna Cortes", "Mehryar Mohri", "Ana Radovanovic"], "venue": "In 26th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Boyd et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Boyd et al\\.", "year": 2012}, {"title": "Learning to rank using gradient descent", "author": ["C. Burges", "T. Shaked", "E. Renshaw", "A. Lazier", "M. Deeds", "N. Hamilton", "G. Hullender"], "venue": "In 22nd International Conference on Machine Learning (ICML),", "citeRegEx": "Burges et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Burges et al\\.", "year": 2005}, {"title": "On the (Non-)existence of Convex, Calibrated Surrogate Losses for Ranking", "author": ["Cl\u00e9ment Calauz\u00e8nes", "Nicolas Usunier", "Patrick Gallinari"], "venue": "In 26th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Calauz\u00e8nes et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Calauz\u00e8nes et al\\.", "year": 2012}, {"title": "Learning to rank: from pairwise approach to listwise approach", "author": ["Zhe Cao", "Tao Qin", "Tie-Yan Liu", "Ming-Feng Tsai", "Hang Li"], "venue": "In 24th International Conference on Machine learning (ICML),", "citeRegEx": "Cao et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Cao et al\\.", "year": 2007}, {"title": "Structured Learning for Non-Smooth Ranking Losses", "author": ["Soumen Chakrabarti", "Rajiv Khanna", "Uma Sawant", "Chiru Bhattacharyya"], "venue": "In 14th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD),", "citeRegEx": "Chakrabarti et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Chakrabarti et al\\.", "year": 2008}, {"title": "Perceptron-like algorithms and generalization bounds for learning to rank", "author": ["Sougata Chaudhuri", "Ambuj Tewari"], "venue": "CoRR, abs/1405.0591,", "citeRegEx": "Chaudhuri and Tewari.,? \\Q2014\\E", "shortCiteRegEx": "Chaudhuri and Tewari.", "year": 2014}, {"title": "Online ranking with top-1 feedback", "author": ["Sougata Chaudhuri", "Ambuj Tewari"], "venue": "In 18th International Conference on Artificial Intelligence and Statistics (AISTATS),", "citeRegEx": "Chaudhuri and Tewari.,? \\Q2015\\E", "shortCiteRegEx": "Chaudhuri and Tewari.", "year": 2015}, {"title": "Ranking the best instances", "author": ["St\u00e9phan Cl\u00e9men\u00e7on", "Nicolas Vayatis"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Cl\u00e9men\u00e7on and Vayatis.,? \\Q2007\\E", "shortCiteRegEx": "Cl\u00e9men\u00e7on and Vayatis.", "year": 2007}, {"title": "Tighter Bounds for Structured Estimation", "author": ["Chuong B. Do", "Quoc Le", "Choon Hui Teo", "Olivier Chapelle", "Alex Smola"], "venue": "In 22nd Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Do et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Do et al\\.", "year": 2008}, {"title": "An efficient boosting algorithm for combining preferences", "author": ["Y. Freund", "R. Iyer", "R.E. Schapire", "Y. Singer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Freund et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Freund et al\\.", "year": 2003}, {"title": "Hardness of learning halfspaces with noise", "author": ["Venkatesan Guruswami", "Prasad Raghavendra"], "venue": "SIAM J. Comput.,", "citeRegEx": "Guruswami and Raghavendra.,? \\Q2009\\E", "shortCiteRegEx": "Guruswami and Raghavendra.", "year": 2009}, {"title": "Large margin rank boundaries for ordinal regression", "author": ["R. Herbrich", "T. Graepel", "K. Obermayer"], "venue": "Advances in Large Margin Classifiers,", "citeRegEx": "Herbrich et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Herbrich et al\\.", "year": 2000}, {"title": "Optimizing search engines using clickthrough data", "author": ["T. Joachims"], "venue": "In 8th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD),", "citeRegEx": "Joachims.,? \\Q2002\\E", "shortCiteRegEx": "Joachims.", "year": 2002}, {"title": "A Support Vector Method for Multivariate Performance Measures", "author": ["Thorsten Joachims"], "venue": "In 22nd International Conference on Machine Learning (ICML),", "citeRegEx": "Joachims.,? \\Q2005\\E", "shortCiteRegEx": "Joachims.", "year": 2005}, {"title": "Online and stochastic gradient methods for nondecomposable loss functions", "author": ["Purushottam Kar", "Harikrishna Narasimhan", "Prateek Jain"], "venue": "In 28th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Kar et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kar et al\\.", "year": 2014}, {"title": "Direct optimization of ranking measures", "author": ["Quoc V. Le", "Alexander J. Smola"], "venue": "arXiv preprint arXiv:0704.3359,", "citeRegEx": "Le and Smola.,? \\Q2007\\E", "shortCiteRegEx": "Le and Smola.", "year": 2007}, {"title": "Top rank optimization in linear time", "author": ["Nan Li", "Rong Jin", "Zhi-Hua Zhou"], "venue": "In 28th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Li et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "Perceptrons: An Introduction to Computational Geometry", "author": ["Marvin Lee Minsky", "Seymour Papert"], "venue": null, "citeRegEx": "Minsky and Papert.,? \\Q1988\\E", "shortCiteRegEx": "Minsky and Papert.", "year": 1988}, {"title": "A Structural SVM Based Approach for Optimizing Partial AUC", "author": ["Harikrishna Narasimhan", "Shivani Agarwal"], "venue": "In 30th International Conference on Machine Learning (ICML),", "citeRegEx": "Narasimhan and Agarwal.,? \\Q2013\\E", "shortCiteRegEx": "Narasimhan and Agarwal.", "year": 2013}, {"title": "Optimizing Non-decomposable Performance Measures: A Tale of Two Classes", "author": ["Harikrishna Narasimhan", "Purushottam Kar", "Prateek Jain"], "venue": "In 32nd International Conference on Machine Learning (ICML),", "citeRegEx": "Narasimhan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Narasimhan et al\\.", "year": 2015}, {"title": "On convergence proofs on perceptrons", "author": ["A.B.J. Novikoff"], "venue": "In Proceedings of the Symposium on the Mathematical Theory of Automata,", "citeRegEx": "Novikoff.,? \\Q1962\\E", "shortCiteRegEx": "Novikoff.", "year": 1962}, {"title": "Fastxml: a fast, accurate and stable tree-classifier for extreme multi-label learning", "author": ["Yashoteja Prabhu", "Manik Varma"], "venue": "In 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Prabhu and Varma.,? \\Q2014\\E", "shortCiteRegEx": "Prabhu and Varma.", "year": 2014}, {"title": "The perceptron: A probabilistic model for information storage and organization in the brain", "author": ["Frank Rosenblatt"], "venue": "Psychological Review,", "citeRegEx": "Rosenblatt.,? \\Q1958\\E", "shortCiteRegEx": "Rosenblatt.", "year": 1958}, {"title": "The p-norm push: A simple convex ranking algorithm that concentrates at the top of the list", "author": ["C. Rudin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Rudin.,? \\Q2009\\E", "shortCiteRegEx": "Rudin.", "year": 2009}, {"title": "Multi-Label Classification: An Overview", "author": ["Grigorios Tsoumakas", "Ioannis Katakis"], "venue": "International Journal of Data Warehousing and Mining,", "citeRegEx": "Tsoumakas and Katakis.,? \\Q2007\\E", "shortCiteRegEx": "Tsoumakas and Katakis.", "year": 2007}, {"title": "Learning to rank by optimizing NDCG measure", "author": ["Hamed Valizadegan", "Rong Jin", "Ruofei Zhang", "Jianchang Mao"], "venue": "In 26th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Valizadegan et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Valizadegan et al\\.", "year": 2009}, {"title": "A support vector method for optimizing average precision", "author": ["Y. Yue", "T. Finley", "F. Radlinski", "T. Joachims"], "venue": "In 30th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR),", "citeRegEx": "Yue et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Yue et al\\.", "year": 2007}, {"title": "Ranking via robust binary classification", "author": ["Hyokun Yun", "Parameswaran Raman", "S Vishwanathan"], "venue": "In 28th Annual Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "Yun et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Yun et al\\.", "year": 2014}, {"title": "Covering Number Bounds of Certain Regularized Linear Function Classes", "author": ["Tong Zhang"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Zhang.,? \\Q2002\\E", "shortCiteRegEx": "Zhang.", "year": 2002}], "referenceMentions": [{"referenceID": 21, "context": "Similarly, in multilabel classification problems, the goal is to rank the labels according to their likelihood of being relevant to a data point Tsoumakas and Katakis [2007]. The ranking of items at the top is of utmost importance in these applications and several performance measures, such as Precision@k, Average Precision and NDCG have been designed to promote accuracy at top of ranked lists.", "startOffset": 145, "endOffset": 174}, {"referenceID": 13, "context": "Informally, prec@k counts the number of relevant items in the top-k positions of a ranked list and is widely used in domains such as binary classification Joachims [2005], multi-label classification Prabhu and Varma [2014] and ranking Le and Smola [2007].", "startOffset": 155, "endOffset": 171}, {"referenceID": 13, "context": "Informally, prec@k counts the number of relevant items in the top-k positions of a ranked list and is widely used in domains such as binary classification Joachims [2005], multi-label classification Prabhu and Varma [2014] and ranking Le and Smola [2007].", "startOffset": 155, "endOffset": 223}, {"referenceID": 13, "context": "Informally, prec@k counts the number of relevant items in the top-k positions of a ranked list and is widely used in domains such as binary classification Joachims [2005], multi-label classification Prabhu and Varma [2014] and ranking Le and Smola [2007]. Given its popularity, prec@k has received attention from algorithmic, as well as learning theoretic perspectives.", "startOffset": 155, "endOffset": 255}, {"referenceID": 13, "context": "Informally, prec@k counts the number of relevant items in the top-k positions of a ranked list and is widely used in domains such as binary classification Joachims [2005], multi-label classification Prabhu and Varma [2014] and ranking Le and Smola [2007]. Given its popularity, prec@k has received attention from algorithmic, as well as learning theoretic perspectives. However, there remain specific deficiencies in our understanding of this performance measure. In fact, to the best of our knowledge, there is only one known convex surrogate function for prec@k, namely, the struct-SVM surrogate due to Joachims [2005] which, as we reveal in this work, is not an upper bound on prec@k in general, and need not recover an optimal ranking even in strictly separable settings.", "startOffset": 155, "endOffset": 621}, {"referenceID": 12, "context": "Since the intractability of binary classification in the agnostic setting Guruswami and Raghavendra [2009] extends to prec@k, our goal would be to exploit natural notions of benign-ness usually observed in natural distributions to overcome such intractability results.", "startOffset": 74, "endOffset": 107}, {"referenceID": 10, "context": "Our algorithms can be shown to be a natural extension of the classical perceptron algorithm for binary classification Rosenblatt [1958]. Indeed, akin to the classical perceptron, both our algorithms enjoy mistake bounds that reduce to crisp convergence bounds under the margin conditions mentioned earlier.", "startOffset": 118, "endOffset": 136}, {"referenceID": 6, "context": "While the earlier methods for this problem, such as RankSVM, focused on optimizing pair-wise ranking accuracy Herbrich et al. [2000], Joachims [2002], Freund et al.", "startOffset": 110, "endOffset": 133}, {"referenceID": 6, "context": "While the earlier methods for this problem, such as RankSVM, focused on optimizing pair-wise ranking accuracy Herbrich et al. [2000], Joachims [2002], Freund et al.", "startOffset": 110, "endOffset": 150}, {"referenceID": 5, "context": "[2000], Joachims [2002], Freund et al. [2003], Burges et al.", "startOffset": 25, "endOffset": 46}, {"referenceID": 1, "context": "[2003], Burges et al. [2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al.", "startOffset": 8, "endOffset": 29}, {"referenceID": 1, "context": "[2003], Burges et al. [2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al.", "startOffset": 8, "endOffset": 263}, {"referenceID": 1, "context": "[2003], Burges et al. [2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al.", "startOffset": 8, "endOffset": 277}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al.", "startOffset": 256, "endOffset": 271}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al.", "startOffset": 256, "endOffset": 291}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice.", "startOffset": 256, "endOffset": 343}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al.", "startOffset": 256, "endOffset": 613}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k.", "startOffset": 256, "endOffset": 694}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k. It is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al.", "startOffset": 256, "endOffset": 1192}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k. It is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al. [2007], Yue et al.", "startOffset": 256, "endOffset": 1211}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k. It is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al. [2007], Yue et al. [2007], Le and Smola [2007], Chakrabarti et al.", "startOffset": 256, "endOffset": 1230}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k. It is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al. [2007], Yue et al. [2007], Le and Smola [2007], Chakrabarti et al.", "startOffset": 256, "endOffset": 1251}, {"referenceID": 0, "context": "[2005], of late, there has been enormous interest in performance measures that promote good ranking performance at the top portion of the ranked list, and in ranking methods that directly optimize these measures Cl\u00e9men\u00e7on and Vayatis [2007], Rudin [2009], Agarwal [2011], Boyd et al. [2012], Narasimhan and Agarwal [2013a,b], Li et al. [2014]. In this work, we focus on one such evaluation measure \u2013 Precision@k, which is widely used in practice. The only prior algorithms that we are aware of that directly optimize this performance measure are a structural SVM based cutting plane method due to Joachims [2005], and an efficient stochastic implementation of the same due to Kar et al. [2014]. However, as pointed out earlier, the convex surrogate used in these methods is not well-suited for prec@k. It is also important to note that the bipartite ranking setting considered in this work is different from other popular forms of ranking such as subset or list-wise ranking settings, which arise in several information retrieval applications, where again there has been much work in optimizing performance measures that emphasize on accuracy at the top (e.g. NDCG) Valizadegan et al. [2009], Cao et al. [2007], Yue et al. [2007], Le and Smola [2007], Chakrabarti et al. [2008],", "startOffset": 256, "endOffset": 1278}, {"referenceID": 7, "context": "There has also been some recent work on perceptron style ranking methods for list-wise ranking problems Chaudhuri and Tewari [2014], but these methods are tailored to optimize the NDCG and MAP measures, which are different from the prec@k measure that we consider here.", "startOffset": 104, "endOffset": 132}, {"referenceID": 7, "context": "There has also been some recent work on perceptron style ranking methods for list-wise ranking problems Chaudhuri and Tewari [2014], but these methods are tailored to optimize the NDCG and MAP measures, which are different from the prec@k measure that we consider here. Other less related works include online ranking algorithms for optimizing ranking measures in an adversarial setting with limited feedback Chaudhuri and Tewari [2015].", "startOffset": 104, "endOffset": 437}, {"referenceID": 4, "context": "We note that the results of Calauz\u00e8nes et al. [2012] that negate the possibility of consistent convex surrogates for ranking performance measures do not apply to our results since they are neither stated for prec@k, nor do they negate the possibility of conditional consistency.", "startOffset": 28, "endOffset": 53}, {"referenceID": 4, "context": "We note that the results of Calauz\u00e8nes et al. [2012] that negate the possibility of consistent convex surrogates for ranking performance measures do not apply to our results since they are neither stated for prec@k, nor do they negate the possibility of conditional consistency. It is notable that the seminal work of Joachims [2005] did propose a convex surrogate for prec@k, that we refer to as `struct prec@k(\u00b7).", "startOffset": 28, "endOffset": 334}, {"referenceID": 14, "context": "1 The Curious Case of `struct prec@k(\u00b7) The `struct prec@k(\u00b7) surrogate is a part of a broad class of surrogates called struct-SVM surrogates that are designed for structured output prediction problems that can have exponentially large output spaces Joachims [2005]. Given a set of n labeled data points, `struct prec@k(\u00b7) is defined as", "startOffset": 250, "endOffset": 266}, {"referenceID": 10, "context": "Note that ` prec@k(\u00b7) is similar to the \u201cramp\u201d losses for binary classification Do et al. [2008]. We now show that ` prec@k(\u00b7) is indeed an upper bounding surrogate for prec@k.", "startOffset": 80, "endOffset": 97}, {"referenceID": 16, "context": "Mini-batch methods have recently gained popularity and have been used to optimize ranking loss functions such as `struct prec@k(\u00b7) as well Kar et al. [2014]. It is useful to note that the requirement for mini-batches goes away in ranking and multi-label classification settings, for our algorithms can be applied to individual data points in those settings (e.", "startOffset": 139, "endOffset": 157}, {"referenceID": 16, "context": "Mini-batch methods have recently gained popularity and have been used to optimize ranking loss functions such as `struct prec@k(\u00b7) as well Kar et al. [2014]. It is useful to note that the requirement for mini-batches goes away in ranking and multi-label classification settings, for our algorithms can be applied to individual data points in those settings (e.g. individual queries in ranking settings). At every time instant t, our algorithms receive a batch of b points Xt = [ xt , . . . ,x b t ] and rank these points using the existing model. Let \u2206t denote the prec@k loss (equation 1) at time t. If \u2206t = 0 i.e. all top k ranks are occupied by positive points, then the model is not updated. Otherwise, the model is updated using the false positives and negatives. For sake of simplicity, we will only look at linear models in this paper. Depending on the kind of updates we make, we get two variants of the perceptron rule for prec@k. Our first algorithm, PERCEPTRON@K-AVG, updates the model using a combination of all the false positives and negatives (see Algorithm 1). The effect of the update is a very natural one \u2013 it explicitly boosts the scores of the positive points that failed to reach the top ranks, and attenuates the scores of the negative points that got very high scores. It is interesting to note that in the limiting case of k = 1 and unit batch length (i.e. b = 1), the PERCEPTRON@K-AVG update reduces to that of the standard perceptron algorithm Rosenblatt [1958], Minsky and Papert [1988] for the choice \u0177t = sign(st).", "startOffset": 139, "endOffset": 1489}, {"referenceID": 16, "context": "Mini-batch methods have recently gained popularity and have been used to optimize ranking loss functions such as `struct prec@k(\u00b7) as well Kar et al. [2014]. It is useful to note that the requirement for mini-batches goes away in ranking and multi-label classification settings, for our algorithms can be applied to individual data points in those settings (e.g. individual queries in ranking settings). At every time instant t, our algorithms receive a batch of b points Xt = [ xt , . . . ,x b t ] and rank these points using the existing model. Let \u2206t denote the prec@k loss (equation 1) at time t. If \u2206t = 0 i.e. all top k ranks are occupied by positive points, then the model is not updated. Otherwise, the model is updated using the false positives and negatives. For sake of simplicity, we will only look at linear models in this paper. Depending on the kind of updates we make, we get two variants of the perceptron rule for prec@k. Our first algorithm, PERCEPTRON@K-AVG, updates the model using a combination of all the false positives and negatives (see Algorithm 1). The effect of the update is a very natural one \u2013 it explicitly boosts the scores of the positive points that failed to reach the top ranks, and attenuates the scores of the negative points that got very high scores. It is interesting to note that in the limiting case of k = 1 and unit batch length (i.e. b = 1), the PERCEPTRON@K-AVG update reduces to that of the standard perceptron algorithm Rosenblatt [1958], Minsky and Papert [1988] for the choice \u0177t = sign(st).", "startOffset": 139, "endOffset": 1515}, {"referenceID": 22, "context": "The next lemma establishes that, similar to the classical perceptron Novikoff [1962], PERCEPTRON@K-AVG also enjoys a mistake bound.", "startOffset": 69, "endOffset": 85}, {"referenceID": 21, "context": "Similar to the classical perceptron mistake bound Novikoff [1962], the above bound can also be reduced to a simpler convergence bound in separable settings.", "startOffset": 50, "endOffset": 66}, {"referenceID": 12, "context": "Hence for several datasets, PERCEPTRON@K-AVG might be able to find a perfect ranking while at the same time, it might be impossible for standard binary classification techniques to find any reasonable classifier in poly-time Guruswami and Raghavendra [2009]. We note that PERCEPTRON@K-AVG performs updates with all the false negatives in the mini-batches.", "startOffset": 225, "endOffset": 258}, {"referenceID": 20, "context": "[2014], Narasimhan et al. [2015] who propose to use mini-batch methods to overcome this problem Kar et al.", "startOffset": 8, "endOffset": 33}, {"referenceID": 16, "context": "[2015] who propose to use mini-batch methods to overcome this problem Kar et al. [2014]. By combining the ` prec@k(\u00b7) surrogate with mini-batch-style processing, we design SGD@K-AVG (Algorithm 3), a scalable SGD algorithm for optimizing prec@k.", "startOffset": 70, "endOffset": 88}, {"referenceID": 16, "context": "Recently, Kar et al. [2014] also established a similar result for the `struct prec@k(\u00b7) surrogate.", "startOffset": 10, "endOffset": 28}, {"referenceID": 14, "context": "Methods: We compared both perceptron algorithms, SGD@K-AVG, as well as an SGD solver for the `max prec@k(\u00b7) surrogate, with the cutting plane-based SVMPerf solver of Joachims [2005]. We also compare against stochastic", "startOffset": 166, "endOffset": 182}, {"referenceID": 16, "context": "1PMB solver of Kar et al. [2014]. The perceptron and SGD methods were given a maximum of 25 passes over the data with a batch length of 500.", "startOffset": 15, "endOffset": 33}, {"referenceID": 30, "context": "This will allow a standard L\u221e covering number argument Zhang [2002] to give us the required uniform convergence results.", "startOffset": 55, "endOffset": 68}, {"referenceID": 1, "context": "where the third step follows from Bernstein\u2019s inequality (which holds in situations with sampling without replacement as well Boucheron et al. [2004]) since |T(v) \u00b7 h(v)| \u2264 1 for all v and we have assumed b \u2265 1 \u03ba log 2 \u03b4 .", "startOffset": 126, "endOffset": 150}, {"referenceID": 16, "context": "The proof of this theorem closely follows that of Theorems 7 and 8 in Kar et al. [2014]. More specifically, Theorem 6 from Kar et al.", "startOffset": 70, "endOffset": 88}, {"referenceID": 16, "context": "The proof of this theorem closely follows that of Theorems 7 and 8 in Kar et al. [2014]. More specifically, Theorem 6 from Kar et al. [2014] ensures that any convex loss function demonstrating uniform convergence would ensure a result of the kind we are trying to prove.", "startOffset": 70, "endOffset": 141}], "year": 2015, "abstractText": "The problem of maximizing precision at the top of a ranked list, often dubbed Precision@k (prec@k), finds relevance in myriad learning applications such as ranking, multi-label classification, and learning with severe label imbalance. However, despite its popularity, there exist significant gaps in our understanding of this problem and its associated performance measure. The most notable of these is the lack of a convex upper bounding surrogate for prec@k. We also lack scalable perceptron and stochastic gradient descent algorithms for optimizing this performance measure. In this paper we make key contributions in these directions. At the heart of our results is a family of truly upper bounding surrogates for prec@k. These surrogates are motivated in a principled manner and enjoy attractive properties such as consistency to prec@k under various natural margin/noise conditions. These surrogates are then used to design a class of novel perceptron algorithms for optimizing prec@k with provable mistake bounds. We also devise scalable stochastic gradient descent style methods for this problem with provable convergence bounds. Our proofs rely on novel uniform convergence bounds which require an in-depth analysis of the structural properties of prec@k and its surrogates. We conclude with experimental results comparing our algorithms with state-of-the-art cutting plane and stochastic gradient algorithms for maximizing prec@k.", "creator": "LaTeX with hyperref package"}}}