{"id": "1506.00019", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-May-2015", "title": "A Critical Review of Recurrent Neural Networks for Sequence Learning", "abstract": "Countless learning tasks require awareness of time. Image captioning, speech synthesis, and video game playing all require that a model generate sequences of outputs. In other domains, such as time series prediction, video analysis, and music information retrieval, a model must learn from sequences of inputs. Significantly more interactive tasks, such as natural language translation, engaging in dialogue, and robotic control, often demand both.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Fri, 29 May 2015 20:16:51 GMT  (500kb,D)", "http://arxiv.org/abs/1506.00019v1", null], ["v2", "Mon, 29 Jun 2015 20:01:00 GMT  (583kb,D)", "http://arxiv.org/abs/1506.00019v2", null], ["v3", "Wed, 23 Sep 2015 04:59:24 GMT  (598kb,D)", "http://arxiv.org/abs/1506.00019v3", null], ["v4", "Sat, 17 Oct 2015 05:06:11 GMT  (598kb,D)", "http://arxiv.org/abs/1506.00019v4", null]], "reviews": [], "SUBJECTS": "cs.LG cs.NE", "authors": ["zachary c lipton", "john berkowitz", "charles elkan"], "accepted": false, "id": "1506.00019"}, "pdf": {"name": "1506.00019.pdf", "metadata": {"source": "CRF", "title": "A Critical Review of Recurrent Neural Networks for Sequence Learning", "authors": ["Zachary C. Lipton"], "emails": ["zlipton@cs.ucsd.edu"], "sections": [{"heading": null, "text": "Recurrent neural networks (RNNs) are a powerful family of connectionist models that capture time dynamics via cycles in the graph. Unlike feedforward neural networks, recurrent networks can process examples one at a time, retaining a state, or memory, that reflects an arbitrarily long context window. While these networks have long been difficult to train and often contain millions of parameters, recent advances in network architectures, optimization techniques, and parallel computation have enabled large-scale learning with recurrent nets.\nOver the past few years, systems based on state of the art long shortterm memory (LSTM) and bidirectional recurrent neural network (BRNN) architectures have demonstrated record-setting performance on tasks as varied as image captioning, language translation, and handwriting recognition. In this review of the literature we synthesize the body of research that over the past three decades has yielded and reduced to practice these powerful models. When appropriate, we reconcile conflicting notation and nomenclature. Our goal is to provide a mostly self-contained explication of state of the art systems, together with a historical perspective and ample references to the primary research."}, {"heading": "1 Introduction", "text": "Recurrent neural networks (RNNs) are a superset of feedforward neural networks, augmented with the ability to pass information across time steps. They\nar X\niv :1\n50 6.\n00 01\n9v 1\n[ cs\n.L G\n] 2\nare a rich family of models capable of nearly arbitrary computation. A wellknown result by Siegelman and Sontag from 1991 demonstrated that a finite sized recurrent neural network with sigmoidal activation functions can simulate a universal Turing machine [54]. In practice, the ability to model temporal dependencies makes recurrent neural networks especially suited to tasks where input and/or output consist of sequences of points that are not independent."}, {"heading": "1.1 Comparison to Prior Work", "text": "The literature on recurrent neural networks can seem impenetrable to the uninitiated. Shorter papers assume familiarity with a large body of background literature. Diagrams are frequently underspecified, failing to indicate which edges span time steps and which don\u2019t. Worse, jargon abounds while notation is frequently inconsistent across papers or overloaded within papers. Readers are frequently in the unenviable position of having to synthesize conflicting information across many papers in order to understand but one. For example, in many papers subscripts index both nodes and time steps. In others, h simultaneously stands for link functions and a layer of hidden nodes. The variable t simultaneously stands for both time indices and targets, sometimes in the same equation. Many terrific breakthrough papers have appeared recently, but clear reviews of recurrent neural network literature are rare.\nAmong the most useful resources are Alex Graves\u2019 2012 book on supervised sequence labelling with recurrent neural networks [24] and Felix Gers\u2019 doctoral thesis [19]. More recently, [15] covers recurrent neural nets for language modeling. Other resources focus on a specific technical aspect such as [50], which surveys gradient calculations in recurrent neural networks. In this review paper, we aim to provide a readable, intuitive, and consistently notated review on recurrent neural networks for sequence learning. We emphasize models, algorithms, and results, but focus equally on distilling the intuitions that have guided this largely heuristic and empirical field. In addition to concrete modeling details, we offer qualitative arguments, a historical perspective, and comparisons to alternative methodology where appropriate."}, {"heading": "1.2 Why Recurrent Nets?", "text": "In this section, we address the fundamental reasons why recurrent neural networks warrant serious study for modeling sequential input and output. To be clear, we are motivated by a desire to achieve empirical results. This warrants clarification because recurrent nets have roots in both cognitive modeling and supervised machine learning, and owing to this difference of perspectives, many of these papers have different aims and priorities. In the foundational papers, generally published in cognitive science and computational neuroscience journals ([33], [34], [18]), biologically plausible mechanisms are emphasized. In other papers ([53], [57], [35]), biological inspiration is downplayed in favor of achieving empirical results on important tasks and datasets. Given the empirical aim,\nwe now address three significant questions one might reasonably want answered before reading further.\nWhy Explicitly Model Time?\nIn light of the practical success and economic value of time-agnostic models, this is a fair question. Support vector machines, logistic regression, and feedforward networks have proved immensely useful without explicitly modeling time. Arguably, it is precisely the assumption of independence that has led to much recent progress in machine learning. Further, many models implicitly capture time by concatenating each input with some number of its immediate predecessors and successors, presenting the machine learning model with a sliding window of context about each point of interest. This approach has been used with deep belief nets for speech modeling in [43].\nUnfortunately, despite the usefulness of the independence assumption, it precludes modeling long-range time-dependencies. For example, a model trained using a finite-length context window of length 5 could never be trained to answer the simple question, \u201cwhat was the data point seen 10 time steps ago?\u201d For a practical application such as call center automation, such a limited system might learn to route calls, but could never participate in an extended dialogue. Since the earliest conception of artificial intelligence, we have sought to build systems that interact with humans in time. In Alan Turing\u2019s groundbreaking paper Computing Machinery and Intelligence, he proposes an \u201cImitation Game\u201d which judges a machine\u2019s intelligence by its ability to convincingly engage in dialogue [65]. Besides dialogue systems, modern interactive systems of economic importance include self-driving cars and robotic surgery, among others. Ignoring an explicit model of time, it seems unlikely that any combination of classifiers or regressors can be cobbled together to provide this functionality.\nWhy Neural Networks and Not Markov Models?\nRecurrent neural networks are not the first models to capture time dependencies. Markov chains, which model transitions between observed sequences of states (s(1), s(2), ... , s(T )), were first described by mathematician Andrey Markov in 1906. Hidden Markov models (HMMs), which model observed data (o(1), o(2), ..., o(T )) as probabilistically dependent upon unobserved states, were described in the 1950s and have been widely studied since the 1960s. However, traditional Markov model approaches are limited because their states must be drawn from a modestly sized discrete state space sj \u2208 S. The Viterbi algorithm, which is used to perform efficient inference on hidden Markov models, scales in time O(|S|2). Further, the transition table capturing the probability of moving between any two adjacent states is of size |S|2. Thus, standard operations are infeasible with an HMM when the set of possible hidden states is larger than roughly 106 states. Further, each hidden state s(t) can depend only on the previous state s(t\u22121). While it is possible to extend any Markov model to account for a larger context window by creating a new state-space equal to the cross\nproduct of the possible states at each time in the window, this procedure grows the state space exponentially with the size of the window, rendering Markov models computationally impractical for modeling long-range dependencies.\nGiven the limitations of Markov models, we ought to explain why it is sensible that connectionist models, i.e., artificial neural networks, should fare better. First, recurrent neural networks can capture long-range time dependencies, overcoming the chief limitation of Markov models. This point requires a careful explanation. As in Markov models, any state in a traditional RNN depends only on the current input as well as the state of the network at the previous time step 1. However, the hidden state at any time step can contain information from an arbitrarily long context window. This is possible because the number of distinct states that can be represented in a hidden layer of nodes grows exponentially with the number of nodes in the layer. Even if each node took only binary values, the network could represent 2N states where N is the number of nodes in the hidden layer. Given real-valued outputs, even assuming the limited precision of 64 bit numbers, a single hidden layer of nodes can represent 264 N\ndistinct states. While the potential expressive power grows exponentially with the number of nodes in the hidden representation, the complexity of both inference and training grows only quadratically.\nSecond, it is generally desirable to extend neural networks to tackle any supervised learning problem because they are powerful learning models that achieve state of the art results in a wide range of supervised learning tasks. Over the past several years, storage has become more affordable, datasets have grown far larger, and the field of parallel computing has advanced considerably. In the setting of such large high-dimensional datasets, simple linear models under-fit and often underutilize computing resources. Deep learning methods, in particular those based on deep belief networks (DNNs), which are greedily built by stacking restricted Boltzmann machines, and convolutional neural networks, which exploit the local dependency of visual information, have demonstrated record-setting results on many important applications. Neural networks are especially well-suited for machine perception tasks, where the raw underlying features are not individually informative. This success is attributed to their ability to learn hierarchical representations, unlike traditional algorithms, which rely upon hand-engineered features. However, despite their power, feedforward neural nets have limitations. Most notably, they rely on the assumption of independence among the data points. Additionally, these networks generally rely on input consisting of fixed length vectors. Thus it is sensible to extend these powerful learning tools to model data with temporal structure, especially in the many domains where neural nets are already the state of the art.\n1 Bidirectional recurrent neural networks (BRNNs) [53] extend RNNs to model dependence on both past states and future states. Traditional RNNs only model the dependence of each event on the past. This extension is especially useful for sequence to sequence learning with fixed length examples.\nAre RNNs Too Expressive?\nAs described earlier, finite-sized RNNs with sigmoidal activations are Turing complete. The capability of RNNs to run arbitrary computation clearly demonstrates their expressive power, but one could argue that the C programming language is equally capable of expressing arbitrary programs. And yet there are no papers claiming that the invention of C represents a panacea for machine learning. Out of the box, C offers no simple way of efficiently exploring the space of programs. There is no straightforward way to calculate the gradient of an arbitrary C program to minimize a chosen loss function. Further, the biggest problem with treating the set of programs expressible in C as a family of machine learning models is that this set is far too large. Given any finite sized dataset, there exist countless programs which can overfit the data, generating desired output but failing to generalize to test data.\nWhy then should RNN\u2019s not suffer from similar problems? First, given any fixed architecture (set of nodes, edges, and activation functions), the recurrent neural networks described in this paper are fully differentiable end to end. The derivative of the loss function can always be calculated with respect to each of the parameters (weights) in the model. Second, while the Turing-completeness of finite-length RNNs is an impressive property, given any fixed-size RNN and a specific architecture, it is not actually possible to generate any arbitrary program. Further, unlike an arbitrary program composed in C, a recurrent neural network can be regularized via standard techniques such as weight decay, dropout, and limiting the degrees of freedom."}, {"heading": "2 Background", "text": "Here we introduce formal notation and provide a brief background on neural networks."}, {"heading": "2.1 Time", "text": "To be clear, RNNs are not limited to sequences which index time. They have been used successfully on non-temporal sequence data, including genetic data [3]. However, computation proceeds in time, and many important applications have an explicit or implicit temporal aspect. While we refer to time throughout this paper, the methods described here are applicable to wider family of tasks.\nIn this paper, by time, we refer to data points x(t) that arrive and desired outputs y(t) that are generated in a discrete sequence of time steps indexed by t. We use superscripts with parentheses and not subscripts to obviate confusion between time steps and neurons. Our sequences may be of finite length or countably infinite. When they are finite, we call the maximum time index of the sequence T . Thus a sequence of consecutive inputs can be notated (x(1),x(2), ...,x(T )) and outputs can be notated (y(1),y(2), ...,y(T )) These time steps may be equally spaced samples from a continuous real-world process. Examples would include the still images that comprise the frames of videos or the\ndiscrete amplitudes sampled at fixed intervals to comprise audio recordings. The time steps may also be ordinal, with no exact correspondence to durations. In fact, these techniques can be extended to domains including genetic sequences, where the sequence has a defined order but no real correspondence to time. This is the case with natural language. In the word sequence \u201cJohn Coltrane plays the saxophone\u201d, x(1) = John, x(2) = Coltrane, etc."}, {"heading": "2.2 Neural Networks", "text": "Neural networks are biologically inspired models of computation. Generally, a neural network consists of a set of artificial neurons, commonly referred to as nodes or units, and a set of directed edges between them, which intuitively represent the synapses in a biological neural network. Associated with each neuron j is an activation function lj , which is sometimes called a link function. We use the notation \u201clj\u201d and not \u201chj\u201d (unlike some other papers) to distinguish the activation function lj from the values of the hidden nodes in a network, which is commonly notated h in the RNN literature.\nAssociated with each edge from node j\u2032 to j is a weight wjj\u2032 . Following the convention adopted in several foundational recurrent net papers ([32], [19], [21], [63]), we index neurons with j and j\u2032, and by wjj\u2032 , we denote the weight corresponding to the directed edge from node j\u2032 to node j. It is important to note that in many papers, textbooks, and lecture notes, the indices are flipped and wj\u2032j 6= wjj\u2032 denotes the weight on the directed edge from the node j\u2032 to the node j as in [17] and on Wikipedia [69].\nThe value vj of each neuron j is calculated by applying its activation function to a weighted sum of its inputs (Figure 1):\nvj = lj \u2211 j\u2032 wjj\u2032 \u00b7 vj\u2032  . For convenience, we term the weighted sum inside the parenthesis the incoming activation and notate it as aj . We represent this entire process in figures by depicting neurons as circles and edges as arrows connecting them. When appropriate, we mark the exact activation function with a symbol, e.g., \u03c3 for sigmoid.\nCommon choices for the activation function include the sigmoid \u03c3(z) = 1/(1 + e\u2212z) and the tanh function \u03c6(z) = (ez \u2212 e\u2212z)/(ez + e\u2212z) which has become common in feedforward neural nets and was applied to recurrent nets in [63]. Another activation which has become the state of the art in deep learning research is the rectified linear unit (ReLU) lj(z) = max(0, z). These units have been demonstrated to improve the performance of many deep neural networks ([43], [47], [73]) on tasks as varied as speech processing and object recognition, and have been used in recurrent neural networks by [7].\nThe activation function at the output nodes depends upon the task. For multi-class classification, we apply a softmax nonlinearity to the layer. The\nsoftmax function calculates\ny\u0302k = eak\u2211K\nk\u2032=1 e ak\u2032\nwhere K is the total number of outputs. The denominator is normalization consisting of a sum of exponentials over all output nodes, ensuring that the output sums to 1. For multilabel classification the activation function is simply a point-wise sigmoid. For regression we may have linear output. Due to the overwhelming number of current applications involving multi-class classification, especially for recurrent nets, in this paper, unless otherwise specified, we assume that softmax is applied at the output."}, {"heading": "2.3 Feedforward Neural Networks", "text": "With a neural model of computation, one must determine the order in which computation should proceed. Should nodes be sampled one at a time and updated, or should the value of all nodes be calculated at once and then all updates applied simultaneously? Feedforward neural networks (Figure 2) are a restricted class of neural networks which deal with this problem by forbidding cycles in the graph. Thus all nodes can be arranged into layers. The outputs in each layer can be calculated given the outputs from the lower layers.\nThe input x to a feedforward network is presented by setting the values of the lowest layer. Each higher layer is then successively computed until output is generated at the topmost layer y\u0302. These networks are frequently used for supervised learning tasks such as classification and regression. Learning is accomplished by iteratively updating each of the weights to minimize a loss function, L(y\u0302,y), which penalizes the distance between the output y\u0302 and the target y. Backpropagation, an algorithm introduced to neural networks in [52],\ncomputes the gradient of the loss with respect to each parameter using the chain rule. While the optimization surfaces for neural networks are highly non-convex, and exact optimization is known to be an NP-Hard problem, a large body of work on heuristic pre-training and optimization techniques has led to impressive empirical success on many supervised learning tasks. Convolutional neural networks, developed by Yann LeCun, [38] are a variant of feedforward neural network that, since 2012, hold records in many computer vision tasks, such as object detection [36].\nFeedforward networks, however, are limited. After each example is processed, the entire state of the network is lost. If each data point is independently sampled, this presents no problem. But if data points are related in time, this is unacceptable. Frames from video, snippets of audio, and words pulled from sentences, represent settings where the independence assumption fails."}, {"heading": "2.4 Training Neural Networks via Backpropagation", "text": "The most successful algorithm for training neural networks is backpropagation, introduced to neural networks by Rumelhart et al. in 1985 [52]. Backpropagation uses the chain rule to calculate the derivative of a loss function L with respect to each parameter in the network. The weights are then adjusted by gradient descent. Because the loss surface is non-convex, there is no assurance that backpropagation will reach a global minima. However, in practice, networks trained with backpropagation and gradient following techniques have been remarkably successful. In practice, most networks are trained with stochastic gradient descent (SGD) using mini-batches. Here, w.l.o.g. we discuss only the\ncase with batch size equal to 1. The stochastic gradient update equation is given by w \u2190 w \u2212 \u03b7\u2207wFi where \u03b7 is the learning rate and \u2207wFi is the gradient of the objective function with respect to the parameters w as calculated on a single example (xi, yi).\nIn practice, many variants of SGD are used to accelerate learning. Some popular heuristics, such as AdaGrad [16], AdaDelta [72], and RMSprop [1], adaptively tune the learning rate for each feature. AdaGrad, arguably the most popular, adapts the learning rate by caching the sum of squared gradients with respect to each parameter at each time step. The step size for each feature is scaled to the inverse of this cache. This leads to fast convergence on convex error surfaces, but because the cached sum is monotonically increasing, AdaGrad has a monotonically decreasing learning rate. This may be undesirable on highly non-convex loss surfaces. RMSprop modifies AdaGrad by introducing a decay factor on the cache, transforming the monotonic growing cache into a moving average. Momentum methods are another common SGD variant used to train neural networks. These methods add to each update a decaying sum of the previous updates. When the momentum parameter is well-tuned and the network is initialized well, momentum methods can train deep nets and recurrent nets competitively with more computationally expensive methods like the Hessian Free optimizer [62].\nTo calculate the gradient in a feedforward neural network, backpropagation proceeds as follows. First, an example is forward propagated through the network to produce a value vj at each node and outputs y\u0302 at the topmost layer. Then, a loss function L(y\u0302k, yk) is assessed at each output node k. Subsequently, for each output node k, we can calculate\n\u03b4k = \u2202L(y\u0302k, yk)\n\u2202y\u0302k \u00b7 l\u2032k(ak).\nGiven these values \u03b4k, for each node in the level prior we can calculate\n\u03b4j = l \u2032(aj) \u2211 k \u03b4k \u00b7 wkj .\nThis calculation is performed successively for each lower layer to calculate \u03b4j for every node j given the \u03b4 values for each node connected by an outgoing edge. Each value \u03b4j represents the derivative \u2202L/aj of the total loss function w.r.t. that node\u2019s incoming activation. Given the values vj calculated on the forward pass, and the values \u03b4j calculated on the backward pass, the derivative of the loss L with respect a given parameter wjj\u2032 is given by\n\u2202L \u2202wjj\u2032 = \u03b4jvj\u2032 .\nLarge scale feedforward neural networks trained via backpropagation have set many large-scale machine learning records, most notably on the computer vision task of object detection ([39], [36]).\nSeveral other methods have been explored for learning the weights in a neural network. Early work, including Hopfield nets [33], learned via a Hebbian principle but did not produce networks useful for discriminative tasks. A number of papers from the 1990s ([6], [27]) championed the idea of learning neural networks with genetic algorithms with some even claiming that achieving success on real-world problems by applying many small changes to a network\u2019s weights was impossible. Despite the subsequent success of backpropagation, interest in genetic algorithms persists. Several recent papers explore genetic algorithms for neural networks, especially as means of learning the architecture of neural networks, a problem not addressed by backpropagation ([5], [28]). By the architecture we mean the number of layers, the number of nodes in each, the connectivity pattern among the layers, the choice of activation functions, etc.\nOne open question in neural network research is how to exploit sparsity in training. In a neural network with sigmoidal or tanh activation functions, the nodes in each layer never take value exactly 0. Thus, even if the inputs are sparse, the nodes at each hidden layer are not. However, a rectified linear units (ReLUs) introduce sparsity to hidden layers [22]. In this setting, a promising path may be to store the sparsity pattern when computing each layer\u2019s values and use it to speed up computation of the next layer in the network. A growing body of recent work ([12], [37], [55], [40]), thus read shows that given sparse inputs to a linear model with any standard regularizer, sparsity can be fully exploited even if the gradient is not sparse (owing to regularization). Given sparse hidden layers, these approaches can be extended to the layer-wise computations in neural networks."}, {"heading": "3 Recurrent Neural Networks", "text": "Recurrent neural networks are a strict superset of feedforward neural networks, augmented by the inclusion of recurrent edges that span adjacent time steps, introducing a notion of time to the model. While RNNs may not contain cycles among the conventional edges, recurrent edges may form cycles, including selfconnections. At time t, nodes receiving input along recurrent edges receive input activation from the current example x(t) and also from hidden nodes h(t\u22121) in the network\u2019s previous state. The output y\u0302(t) is calculated given the hidden state h(t) at that time step. Thus, input x(t\u22121) at time t\u2212 1 can influence the output y\u0302(t) at time t by way of these recurrent connections.\nWe can show in two equations, all calculations necessary for computation at each time step on the forward pass in a simple recurrent neural network:\nh(t) = \u03c3(Whxx +Whhh (t\u22121) + bh)\ny\u0302(t) = softmax(Wyhh (t) + by)\nHere Whx is the matrix of weights between the input and hidden layers and Whh is the matrix of recurrent weights between the hidden layers at adjacent\ntime steps. The vectors bh and by are biases which allow each node to learn an offset.\nMost of the models discussed in this paper consist of networks with recurrent hidden layers. However, some proposed models, such as Jordan Networks, allow for connections between the outputs in one state and the hidden layer in the next. Others, such as Sutskever et al.\u2019s model for sequence to sequence learning [64], compute the output at each time step and pass a representation of this information as the input at the following time step.\nA simple recurrent network is depicted in Figure 3. The dynamics of this network across time steps can be visualized by unfolding the network (Figure 4). Given this picture, the model can be interpreted not as cyclic, but rather as a deep network with one layer per time step and shared weights across time steps. It\u2019s then clear that the unfolded network can be trained across many time steps using backpropagation. This algorithm is called backpropagation through time (BPTT), and was introduced in 1990 [68]."}, {"heading": "3.1 Past Approaches", "text": "Early foundational work on recurrent networks took in the 1980s. In 1982, Hopfield introduced a family of recurrent neural networks [33]. We\u2019ll avoid a prolonged discussion of these networks as they are not currently used for sequence learning. Hopfield\u2019s nets have some pattern recognition capabilities but offer no clear method for supervised training. These networks are defined by the values of the weights between nodes and the link functions are simple thresholding at 0. In these nets, a pattern is placed in the network by setting\nthe values of the nodes. The network then runs for some time according to its update rules, and eventually a pattern is read out. The networks are useful for recovering a stored pattern from a corrupted version and are the forerunners of Boltzmann machines and auto-encoders.\nJordan networks (Figure 5), introduced by Michael Jordan in 1986, present an early architecture for supervised learning on sequences ([34]). A Jordan network resembles a feedforward network with a single hidden layer, but is ex-\ntended with context units. 2 Outputs are fed into the context units, which then feed in to the hidden nodes at the following time step. Additionally, context units have self-connected edges. Intuitively, these self-connected edges gives Jordan networks a means to send information across multiple time steps without perturbing the output at each intermediary time step. In Jordan\u2019s setup, the network was used to plan actions and thus these context units allow the network to remember actions taken (outputs) at the previous time steps. Several modern architectures utilize some form of direct feedback from output nodes. [64] translates sentences between natural languages. When generating text sequences, the word chosen at each time step is fed into the network at the following time step.\nElman networks, introduced in [18], simplify the structure in the Jordan network. Associated with each unit in the hidden layer is a single context unit. Each context unit j\u2032 takes as input the state of the corresponding hidden node j at the previous time step, along an edge of unit weight wj\u2032j = 1. Effectively, this entire setup is equivalent to a simple RNN in which each hidden node has a single self-connected recurrent edge. Some of Elman\u2019s ideas, including fixedweight edges and the importance of self-connected recurrent edges in hidden nodes survive in Hochreiter and Schmidhuber\u2019s subsequent work on Long ShortTerm Memory [32].\nIn the paper, Elman trains the network using backpropagation and demonstrates that the network can learn long-range time dependencies. The paper features two sets of experiments. The first extends the logic operation exclusive OR (XOR) to the time domain by concatenating sequences of three tokens. For\n2 In Jordan\u2019s paper, he calls these \u201cstate units\u201d. Elman calls a corresponding structure \u201ccontext units\u201d. In this paper we simplify terminology by using only \u201ccontext units\u201d.\neach three-token segment, e.g. \u201c011\u201d, the first two tokens (\u201c01\u201d) are chosen randomly and the third (\u201c1\u201d) is chosen by performing XOR on them. A completely random guess should achieve accuracy of 50%. A perfect system should perform the same as random for the first two tokens, but guess the third token perfectly, achieving accuracy of 66.6...%. Elman\u2019s simple network does in fact do get close to this maximum achievable score."}, {"heading": "3.2 Training Recurrent Networks", "text": "Learning with recurrent neural networks has long been considered to be difficult. As with all neural networks, the optimization is NP-Hard. But learning on recurrent networks can be especially hard due to the difficulty of learning long-range dependencies as described by Bengio et al in 1994 [9] and expanded upon in [31]. The well known problems of vanishing and exploding gradients occur when propagating errors across many time steps. As a trivial example, consider a network with a single input node, a single output node, and a single recurrent hidden node (Figure 7). Now consider an input passed to the network at time \u03c4 and an error calculated at time t, assuming input of 0 in the intervening time steps. Owing to the weight tying across time steps (the recurrent edge at hidden node j always has the same weight), the impact of the input at time \u03c4 on the output at time t will either explode exponentially or rapidly approach zero as t\u2212 \u03c4 grows large, depending on whether the weight |wjj | > 1 or |wjj | < 1 and also upon the activation function in the hidden node (Figure 8). Given activation function lj = \u03c3, the vanishing gradient problem is more pressing, but with a rectified linear unit max(0, x), it\u2019s easier to imagine the exploding gradient, even with this trivial example. In [49], Pascanu et al. give a thorough mathematical treatment of the vanishing and exploding gradient problems, characterizing exact conditions under which these problems may occur. Given these conditions under which the gradient may vanish or explode, they suggest an approach to training via a regularization term, which forces the weights to values where the gradient neither vanishes nor explodes.\nTruncated backpropagation through time (TBPTT) is one solution to this problem for continuously running networks [70]. With TBPTT, some maximum number of time steps is set along which error can be propagated. While TBPTT with a small cutoff can be used to alleviate the exploding gradient problem, it requires that one sacrifice the ability to learn long-range dependencies.\nThe optimization problem represents a more fundamental obstacle that cannot as easily be dealt with by modifying network architecture. It has been known since at least 1993 that optimizing even a 3-layer neural network is NPComplete [11]. However, recent empirical and theoretical studies suggest that the problem may not be as hard in practice as once thought. [14] shows that while many critical points exist on the error surfaces of large neural networks, the ratio of saddle points to true local minima increases exponentially with the size of the network\nFast implementations and improved gradient following heuristics have rendered RNN training feasible. For example, implementations of forward and\nbackward propagation using GPUs, such as Theano ( [10]) and Torch ([13]), have made it easy to implement fast training algorithms. In 1996, prior to the introduction of the LSTM, attempts to train recurrent nets to bridge long time gaps were shown to perform no better than random guessing [30]. However, successfully trained RNNs are now relatively common. Sutskever and Martens reported success training recurrent neural networks with a HessianFree, i.e., truncated Newton approach [45] and applied it to a network which learns to generate text one character at a time in [63]. In the paper that described the abundance of saddle points on the error surfaces of neural networks ([14]), the authors present a saddle-free version of Newton\u2019s method. Unlike Newton\u2019s method, which is attracted to critical points, including saddle points, this variant is specially designed to escape from them. Experimental results include a demonstration of improved performance on recurrent networks. Newton\u2019s method requires computing the Hessian, which is prohibitively expensive for large networks, scaling quadratically with the number of parameters. While their algorithm only approximates the Hessian, it is still computationally expensive compared to SGD. Thus the authors describe a hybrid approach whereby the saddle-free Newton method is applied in places where SGD appears to be stuck."}, {"heading": "3.3 Modern RNNs", "text": "The most successful RNN architectures for sequence learning date to two papers from 1997. The first, Long Short-Term Memory, by Hochreiter and Schmidhuber, introduces the memory cell, a unit of computation that replaces traditional artificial neurons in the hidden layer of a network. With these memory cells, networks are able to overcome some difficulties with training encountered in earlier recurrent nets. The second, Bidirectional Recurrent Neural Networks, by Schuster and Paliwal, introduces the BRNN architecture in which information from both the future and the past are used to determine the output at any time t. This is in contrast to previous systems, in which only past input can affect the output, and has been used successfully for sequence labeling tasks in natural language processing, among others. Fortunately, the two innovations are not mutually exclusive, and have been successfully combined by Graves et al. for phoneme classification [26] and handwriting recognition [25]."}, {"heading": "3.3.1 Long Short-Term Memory (LSTM)", "text": "In 1997, to overcome the problem of vanishing gradients, Hochreiter and Schmidhuber introduced the LSTM model. This model resembles a standard neural network with a recurrent hidden layer, only each ordinary node (Figure 1) in the hidden layer is replaced with a memory cell (Figure 9). The memory cell contains a node with a self-connected recurrent edge of weight 1, ensuring that the gradient can pass across many time steps without vanishing or exploding.\nTo distinguish that we are referencing a memory cell and not an ordinary node, we use the index c.\nThe term \u201cLong Short-Term Memory\u201d comes from the following intuition. Simpler recurrent neural networks have long term memory in the form of weights. The weights change very slowly over time encoding general knowledge about the data. They also have short term memory in the form of ephemeral activations, which pass from each node\u2019s output to successive nodes. The LSTM model introduces an intermediary sort of memory via the memory cell. A memory cell is a composite of simpler units with the novel addition of multiplicative nodes, represented in diagrams with \u03a0. All elements of the LSTM cell are enumerated and described below.\n\u2022 Internal State: At the heart of each memory cell is a node s with linear activation, which is referred to in the original paper as the \u201dinternal state\u201d of the cell. We index cells with c and thus the internal state of a cell c is sc.\n\u2022 Constant error carousel: The internal state sc has a self-connected (recurrent) edge with weight 1. This edge, called the constant error carousel, spans adjacent time steps with constant weight, assuring that error can flow across time steps without vanishing.\n\u2022 Input Node: This node behaves as an ordinary neuron, taking input from the rest of the network (at the previous time step) as well as from the input. In the original paper and most subsequent work the input node is labeled g. We adhere to this convention but note that it may be confusing as g does not stand for gate. In the original paper, the gates are called yin and yout but this is confusing because y generally stands for output in the machine learning literature. Seeking comprehensibility, we break with this convention and use i, f , and o to refer to input, forget and output gates respectively as in [64]. When we use vector notation we are referring to the values of the nodes in an entire layer of cells. For example, g is a vector containing the value of g at each memory cell in a layer. When the subscript c is used, it is to refer to an individual memory cell.\n\u2022 Multiplicative Gating: Multiplicative gates are distinctive features of the LSTM model. Here a sigmoidal unit called a gate is learned given the input and the incoming recurrent connections from the previous time step. Some value of interest is then multiplied by this output. If the gate outputs 0, flow through the gate is cut off. If the gate outputs 1, all activation is passed through the gate.\n\u2013 Input gate: The original LSTM contains two gates. The first is an input gate ic, which is multiplied by the input node gc.\n\u2013 Output gate: The second gate is termed the output gate, which we notate as oc. This gate is multiplied by the value of the internal state sc to produce the value of vc output by the memory cell . This then feeds into the LSTM hidden layer at the next time step h(t+1) as well as the output nodes y\u0302(t) at the current time step.\nSince the original LSTM was introduced, several variations have been proposed. Forget gates, proposed in 2000 by Gers and Schmidhuber [21], add a gate similar to input and output gates to allow the network to flush information from the constant error carousel. Also in 2000, Gers and Schmidhuber proposed peephole connections [20], which pass from the carousel directly to the input and output gates of that same node without first having to pass through the output gate. They report that these connections improve performance on timing tasks where the network must learn to measure precise intervals between events. While peephole connections are not common in modern papers, forget gates have become a mainstay of LSTM work.\nPut formally, computation in the LSTM model proceeds according to the following calculations which must be evaluated at each time step. This gives the full algorithm for a modern LSTM with forget gates.\ng(t) = \u03c6(Wgxx (t) +Wihh (t\u22121) + bg)\ni(t) = \u03c3(Wixx (t) +Wihh (t\u22121) + bi)\nf (t) = \u03c3(Wfxx (t) +Wfhh (t\u22121) + bf )\no(t) = \u03c3(Woxx (t) +Wohh (t\u22121) + bo)\ns(t) = g(t) i(i) + s(t\u22121) f (t)\nh(t) = s(t) o(t)\nwhere stands for element-wise multiplication. The calculations for the simpler LSTM without forget gates is given by setting f (t) = 1 for all t. We use the tanh function \u03c6 for the input node g following the latest state of the art setup of Zaremba and Sutskever in [71]. However, in the original LSTM paper [32], the activation function for g is the sigmoid \u03c3. Again, h(t\u22121) is a vector containing the values vc output by each memory cell c in the hidden layer at the previous time step.\nIntuitively, in terms of the forward pass, the LSTM can learn when to let activation into the internal state. So long as the input gate takes value 0, no activation can get in. Similarly, the output gate learns when to let the value out. When both gates are closed, the activation is trapped in the LSTM, neither growing nor shrinking, nor affecting the output at the intermediary time steps. In terms of the backwards pass, the constant error carousel enables the gradient to propagate back across many time steps, neither exploding nor vanishing. In this sense, the gates are learning when to let error in, and when to let it out. In practice, the LSTM has shown a superior ability to learn long-range dependencies as compared to simple RNNs. Consequently, the majority of state of the art application papers covered in this review use the LSTM model."}, {"heading": "3.4 Bidirectional Recurrent Neural Networks (BRNNs)", "text": "Along with the LSTM, one of the most used RNN setups is the bidirectional recurrent neural network (BRNN) (Figure 11) first described in [53]. In this architecture, there are two layers of hidden nodes. Both hidden layers are connected to input and output. The two hidden layers are differentiated in that the first has recurrent connections from the past time steps while in the second the direction of recurrent of connections is flipped, passing activation backwards in time. Given a fixed length sequence, the BRNN can be learned with ordinary backpropagation. The following three equations describe a BRNN:\nh (t) f = \u03c3(Whfxx +Whfhfh (t\u22121) f + bhf )\nh (t) b = \u03c3(Whbxx +Whbhbhb (t+1) + bhb)\ny\u0302(t) = softmax(Wyhfhf (t) +Wyhbhb (t) + by)\nWhere h (t) f and h (t) b correspond to the hidden layers in the forwards and backwards directions respectively. One limitation of the BRNN is that cannot run continuously, as it requires a fixed endpoint in both the future and in the past. Further, it is not an appropriate machine learning algorithm for the online setting, as it is implausible to receive information from the future, i.e., sequence elements that have not been observed. But for sequence prediction over a sequence of fixed length, it is often sensible to account for both past and future data. Consider the natural language task of part of speech tagging. Given a word in a sentence, information about both the words which precede and those which succeed it is useful for predicting\nthat word\u2019s part of speech. Karpathy et al. use such a network for generating captions for images [35].\nThe LSTM and BRNN are in fact compatible ideas. The former introduces a new basic unit from which to compose a hidden layer, while the latter concerns the wiring of the hidden layers, regardless of what nodes they contain. Such an approach, termed a BLSTM was used by Graves et al. to achieve state of the art results on handwriting recognition and phoneme classification [25] [26]."}, {"heading": "4 Applications of LSTM and BRNN", "text": "In the previous sections, we introduced the basic building blocks from which nearly all state of the art recurrent neural networks are composed. Now, we\u2019ll look at several application areas where recurrent networks have been employed successfully. We\u2019ll quickly introduce the representations used for input and output and the commonly used performance metrics. Then we will survey state of the art results in machine translation, image captioning, video captioning, and handwriting recognition."}, {"heading": "4.1 Representing Natural Language for Input and Output", "text": "Many applications of RNNs involve text processing. Some applications, e.g. image captioning, involve generating strings of text. Others, such as machine translation and dialogue systems, require both inputting and outputting text.\nIn this section, we provide the background necessary to understand how text is represented in most recurrent net models.\nWhen words are output at each time step, generally the output consists of a softmax vector y(t) \u2208 RK where K is the size of the vocabulary. A softmax layer is like an element-wise logistic function that is normalized so that all of its components sum to 1. Intuitively these outputs correspond to probabilities that each word is the correct output at that time step.\nFor application where inputs consist of sequences of words, typically the words are fed to the network one at a time as inputs in consecutive time steps. In these cases, the simplest way to represent words is a one-hot encoding, using binary vectors with a length equal to the size of the vocabulary, e.g. \u201c1000\u201d and \u201c0100\u201d would represent the first and second words in the vocabulary respectively. Such an encoding is discussed in [18] among others. However, this encoding is inefficient, requiring as many bits as the vocabulary is large. Further, it offers no direct way to capture different aspects of similarity between words in the encoding itself. Thus it is more common to model words with a distributed representation using a meaning vector. In some cases, these meanings for words are learned given a large corpus of supervised data, but it is common to initialize the meaning vectors using an embedding based on word co-occurence statistics. Freely available code to produce word vectors from co-occurrence stats include Glove from Pennington Socher and Manning [51], and word2vec [23], which implements a word embedding algorithm from Mikolov et al. [46].\nSuch distributed representations for symbolic data were described by Hinton in 1986 [29], used extensively for natural language by Bengio et al. in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]). For clarity we point out that these recursive networks, which are sometimes referred to as \u201cRNNs\u201d are not recurrent neural nets. In contrast to RNNs which model arbitrary dependencies between inputs at different points in the sequence, recursive networks assume a tree structure where each word in a sentence is a leaf and each sentence can be represented as a binary tree. In this model, each internal node has a meaning vector which can be calculated by concatenating the meanings of its children and multiplying the composite vector by an encoding matrix. Each meaning vector mj \u2208 Rd and the encoding matrix Ae \u2208 R2d\u00d7d. The composite meaning mp \u2208 Rd given to the parent p of two child nodes l and r in the syntax tree is\nmp = \u03c3(Ae[ml;mr] T )\nThis method seems restricted to sentences, and incompatible with the online setting where the full sequence may not be fixed in advance. Additionally, while it has been successfully used for classification tasks, it offers no generative model for composing text.\nIn many experiments with recurrent neural networks ([18], [63], [71]), input is fed in one character at a time (and output generated one character at a time). While the output is nearly always a softmax layer, many papers omit details\nof how they represent single-character inputs. It seems reasonable to infer that characters are encoded with a one-hot encoding. We know of no cases of paper using a distributed representation at the single-character level."}, {"heading": "4.1.1 Evaluation Methodology", "text": "One serious obstacle to training systems to output variable length sequences of words are the flaws of the available performance metrics. Developed in 2002, BLEU score, a common evaluation metric for machine translation, is related to modified unigram precision [48]. It is extended by taking the geometric mean of the n-gram precisions for all values of n between 1 and some upper limit N . In practice, 4 is a typical value for N , shown to maximize agreement with human raters. Because precision can be made high by offering absurdly short translations, the authors of BLEU introduce a brevity penalty BP . Where q is the length of the candidate translation and r is the length of the reference translations the brevity penalty is expressed as\nBP =\n{ 1 if q > r\ne(1\u2212r/q) if q <= r .\nThen the BLEU score can be calculated as\nBLEU = BP \u00b7 exp ( N\u2211 n=1 wn log pn )\nwhere wn is a uniform weight 1/N and pn is the modified n-gram precision. BLEU score is commonly used in recent papers to evaluate both translation and captioning systems. While BLEU score does appear highly correlated with human judgments, there is no guarantee that any given translation with a higher BLEU score is superior to another which receives a lower BLEU score. In fact, while BLEU scores agree with human judgement across large sets of translations, they are significantly less accurate at the sentence level.\nMETEOR, introduced in 2005 by Banerjee and Lavie is an alternative metric intended to overcome these weaknesses of the BLEU score [4]. METEOR is scored based on explicit word to word matches between candidates and references. When multiple references exist, the best score is used. Unlike BLEU , METEOR exploits known synonyms and stemming. First they compute an F-score\nF\u03b1 = P \u00b7R\n\u03b1 \u00b7 P + (1\u2212 \u03b1) \u00b7R based on single word matches where P is the precision and R is the recall. Then they calculate a fragmenting penalty Pen \u221d ch/m where ch is the smallest number of chunks of consecutive words such that the words are adjacent in both the candidate and the reference, and m is the total number of matched unigrams yielding the score:\nMETEOR = (1\u2212 Pen) \u00b7 F\u03b1.\nEmpirically, this metric has been found to agree more with human raters than BLEU score.\nHowever, METEOR is less straight-forward to calculate than BLEU . To replicate the METEOR score reported by another party, one must exactly replicate their stemming and synonym matching, as well as the calculations. Both metrics rely upon having the exact same set of candidate translations.\nEven in the straightforward case of binary classification, without time dependencies, commonly used performance metrics like F1 give rise to complicated thresholding strategies which may not accord with any reasonable intuition of what should constitute good performance [41]. Along the same lines, given these new performance metrics which are weak proxies for our objectives and which cannot be optimized directly, it may be difficult to differentiate systems which are truly stronger and those which most meticulously game the performance metrics of interest."}, {"heading": "4.2 Text Translation", "text": "Natural language translation is a fundamental problem in machine learning that resists solutions with shallow methods. Some tasks, like document classification, can be performed successfully with representations like bag-of-words, which ignore word order. But word order is essential in translation. The sentences \u201cScientist killed by raging virus\u201d and \u201cVirus killed by raging scientist\u201d have identical bag-of-words representations.\nIn Sequence to Sequence Learning, published in 2014, Sutskever et al. present a translation model using two multilayered LSTMs and demonstrate impressive performance translating from English to French. The first LSTM is used for encoding an input phrase from the source language and one for decoding the output phrase in the target language. Their model works according to the following procedure (Figure 12):\n\u2022 The source phrase is fed to the encode LSTM, one word at a time. The inputs are word vectors. This LSTM does not output anything. In practice, the authors found that significantly better results were achieved when the input sentence was fed into the network in reverse order.\n\u2022 When the end of the phrase is reached, a special input which indicates the beginning of the sentence is fed to the decoder LSTM. This second LSTM gets as input the start token, and also the final state of the encoder This LSTM outputs softmax probabilities over the vocabulary at each time step.\n\u2022 A word is chosen and fed to the network at the next step. At this time step, the network receives activation along all recurrent edges as well as the word vector of the chosen word.\nFor training, the true inputs are fed to the encoder, the true translation is fed to the decoder, and loss is propagated back from the outputs of the decoder.\nThe network is trained to maximize the likelihood of the correct translation. At inference time a left to right beam search is used to determine which words to output. A few among the most likely next words are chosen for expansion after each time step. The beam search ends when the network outputs an endof-sentence (EOS ) token. They train the model using only stochastic gradient descent, without momentum, halving the learning rate every half epoch, after the first five. Using this approach, they achieve a BLEU score of 34.81, which outperforms the best previous neural network NLP systems, and is very close to the best published results, including systems that have explicitly programmed domain expertise. When their system is used to rerank candidate translations from another system, they achieved a BLEU score of 36.5\nAnother RNN approach to language translation is presented by Auli et al. in Joint Language and Translation Modeling with Recurrent Neural Networks. Their RNN model uses the word embeddings of Mikolov [2] and a lattice representation of the decoder output to facilitate search over the space of possible translations. In their lattice, each node corresponds to a sequence of words. They report a BLEU score of 28.5 on French-English translation tasks. Both papers report results on data from WMT datasets but Sutskever et al. only report results on English to French translation while Auli et al. report French to English translation. Thus it is impossible to directly compare the performance of the two models."}, {"heading": "4.3 Image Captioning", "text": "Recently, recurrent neural networks have been used successfully for image captioning, [35, 44, 67]. In this task, a training set consists of input images x and target captions y. Given a large set of image-caption pairs, a model is trained\nto predict the appropriate caption for an image. Vinyals et al. follow up on the success in language to language translation by considering captioning as a case of image to language translation. Instead of both encoding and decoding with LSTMs, they introduce the idea of encoding an image with a convolutional neural network, and then decoding it with an LSTM. This idea is the core of several papers which address this topic. This work clearly precedes [35] as it is cited throughout, but [44] claim it as an independent innovation. With this architecture, they achieve then state of the art results on the Pascal, Flickr30k, and COCO datasets.\nKarpathy et al. similarly use a convolutional neural network to encode images together with a bidirectional neural network to decode translations, using word2vec embeddings as word representations [35]. They consider both fullframe evaluations and a model that captures correspondences between image regions and text snippets. At inference, their procedure resembles the one described for Sutskever et al., where sentences are decoded one word at a time. The most probable word is chosen and fed to the network at the next time step. This process is repeated until an EOS token is produced."}, {"heading": "4.4 Other Interesting Applications", "text": "Handwriting recognition is an application area where bidirectional LSTMs have been used to achieve state of the art results. In work by Liwicki, Graves et al. ( [42], [25]), data is collected from a whiteboard using an eBeam interface. The interface collects the (x, y) coordinates of the pen at regularly sampled time steps. In the more recent paper, they use a bidirectional LSTM model, outperforming an HMM model by achieving 81.5% word-level accuracy, compared to 70.1% for the HMM.\nIn the last year, a number of papers have emerged, that extend the success of recurrent networks for translation and image captioning to new domains. Among the most interesting of these applications are unsupervised video encoding [61], video captioning [66] and program execution [71]. In [66], Venugopalan et al. demonstrate a sequence to sequence architecture similar to that which Sutskever uses for natural language translation. However, instead of both encoding and decoding words, they encode frames from a video and decode words. At each time step the input to the encoding LSTM is the topmost hidden layer of convolutional neural network. At decoding time, the network outputs probabilities over the vocabulary at each time step.\nIn Learning to Execute ([71]), Zaremba and Sutskever experiment with networks which read computer programs one character at a time and predict their output. They focus on programs which output integers and find that for simple programs, including adding two nine-digit numbers, their network, which uses LSTM units, several stacked hidden layers, and makes a single left to right pass through the program, can predict the output with 99% accuracy."}, {"heading": "5 Conclusion", "text": "Over the past thirty-five years, recurrent networks have gone from impractical models, primarily of interest for cognitive modeling and computational neuroscience, to powerful and practical tools for large-scale supervised learning. This progress owes to advances in model architectures, training algorithms, and parallel computing. Recurrent nets are especially interesting because they seem able to overcome many of the extreme restrictions generally placed on data by traditional machine learning approaches. With recurrent nets, the assumption of independence between consecutive examples is broken, the assumption of fixed-dimension input is broken, and yet RNN models perform competitively with or outperform the state of the art on many tasks.\nWhile LSTMs and BRNNs set records, we find it noteworthy that many advances come from novel architectures rather than fundamentally novel algorithms. It seems that research exploring the space of possible models, either via genetic algorithms or a Markov Chain Monte Carlo based approach, should be promising. Along these lines, we note that neural networks seem to offer a wide range of easily transferable techniques. New activation functions, training procedures, initializations procedures, etc. are generally transferable across networks and tasks, often conferring similar benefits. As the number of such techniques grows, the practicality of testing all combinations diminishes. However it seems reasonable to infer that as a community, neural network researchers are exploring the space of a model architectures and configurations much as a genetic algorithm might, mixing and matching techniques, with a fitness function in the form of evaluation metrics on major datasets of interest.\nThis suggests two things. First, as stated before, this body of research would benefit from automated procedures to explore the space of models. Second, as we build systems designed to perform more complex tasks, we would benefit from improved fitness functions. BLEU inspires less confidence than the accuracy reported on a binary classification task. To this end, when possible, it seems prudent to individually test techniques first with classic feedforward networks on datasets with established benchmarks before applying them to recurrent networks in settings with less concrete evaluation criteria.\nLastly, the rapid success of recurrent neural networks on natural language tasks leads us to believe that extensions of this work to longer form text would be fruitful. Additionally, we imagine that dialogue systems could be built along similar principles to the architectures used for translation, encoding prompts and generating responses, retaining the entirety of conversation history as contextual information."}, {"heading": "Acknowledgements", "text": "My research is funded by generous support from the Division of Biomedical Informatics at UCSD, via a training grant from the National Library of Medicine. This review has benefited from insightful comments from Charles Elkan, John\nBerkowitz, Balakrishnan Narayanaswamy, Stefanos Poulis, Sharad Vikram."}], "references": [{"title": "Joint language and translation modeling with recurrent neural networks", "author": ["Michael Auli", "Michel Galley", "Chris Quirk", "Geoffrey Zweig"], "venue": "In EMNLP,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "The principled design of large-scale recursive neural network architectures\u2013DAG-RNNs and the protein structure prediction problem", "author": ["Pierre Baldi", "Gianluca Pollastri"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "METEOR: An automatic metric for MT evaluation with improved correlation with human judgments. In Proceedings of the acl workshop on intrinsic and extrinsic evaluation measures for machine translation and/or summarization", "author": ["Satanjeev Banerjee", "Alon Lavie"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2005}, {"title": "Evolving memory cell structures for sequence learning", "author": ["Justin Bayer", "Daan Wierstra", "Julian Togelius", "J\u00fcrgen Schmidhuber"], "venue": "In Artificial Neural Networks\u2013ICANN", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2009}, {"title": "Evolving networks: Using the genetic algorithm with connectionist learning", "author": ["Richard K Belew", "John McInerney", "Nicol N Schraudolph"], "venue": "In In. Citeseer,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1990}, {"title": "Advances in optimizing recurrent networks", "author": ["Yoshua Bengio", "Nicolas Boulanger-Lewandowski", "Razvan Pascanu"], "venue": "In Acoustics, Speech and Signal Processing (ICASSP),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "A neural probabilistic language model", "author": ["Yoshua Bengio", "R\u00e9jean Ducharme", "Pascal Vincent", "Christian Janvin"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2003}, {"title": "Learning long-term dependencies with gradient descent is difficult", "author": ["Yoshua Bengio", "Patrice Simard", "Paolo Frasconi"], "venue": "Neural Networks, IEEE Transactions on,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1994}, {"title": "Theano: a CPU and GPU math expression compiler", "author": ["James Bergstra", "Olivier Breuleux", "Fr\u00e9d\u00e9ric Bastien", "Pascal Lamblin", "Razvan Pascanu", "Guillaume Desjardins", "Joseph Turian", "David Warde-Farley", "Yoshua Bengio"], "venue": "In Proceedings of the Python for scientific computing conference (SciPy),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Training a 3-node neural network is NP-complete", "author": ["Avrim L Blum", "Ronald L Rivest"], "venue": "In Machine learning: From theory to applications,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1993}, {"title": "Lazy sparse stochastic gradient descent for regularized multinomial logistic regression", "author": ["Bob Carpenter"], "venue": "Alias-i, Inc., Tech. Rep, pages", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Torch7: A matlab-like environment for machine learning", "author": ["Ronan Collobert", "Koray Kavukcuoglu", "Cl\u00e9ment Farabet"], "venue": "In BigLearn, NIPS Workshop, number EPFL-CONF-192376,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2011}, {"title": "Identifying and attacking the saddle point problem in high-dimensional non-convex optimization", "author": ["Yann N Dauphin", "Razvan Pascanu", "Caglar Gulcehre", "Kyunghyun Cho", "Surya Ganguli", "Yoshua Bengio"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "A survey on the application of recurrent neural networks to statistical language modeling", "author": ["Wim De Mulder", "Steven Bethard", "Marie-Francine Moens"], "venue": "Computer Speech & Language,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["John Duchi", "Elad Hazan", "Yoram Singer"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2011}, {"title": "Finding structure in time", "author": ["Jeffrey L Elman"], "venue": "Cognitive science,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1990}, {"title": "Long short-term memory in recurrent neural networks", "author": ["Felix Gers"], "venue": "Unpublished PhD dissertation, E\u0301cole Polytechnique Fe\u0301de\u0301rale de Lausanne, Lausanne, Switzerland,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Recurrent nets that time and count", "author": ["Felix A Gers", "J\u00fcrgen Schmidhuber"], "venue": "In Neural Networks,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2000}, {"title": "Learning to forget: Continual prediction with LSTM", "author": ["Felix A Gers", "J\u00fcrgen Schmidhuber", "Fred Cummins"], "venue": "Neural computation,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2000}, {"title": "Deep sparse rectifier networks", "author": ["Xavier Glorot", "Antoine Bordes", "Yoshua Bengio"], "venue": "In Proceedings of the 14th International Conference on Artificial Intelligence and Statistics. JMLR W&CP Volume,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "word2vec explained: deriving mikolov et al.\u2019s negative-sampling word-embedding method", "author": ["Yoav Goldberg", "Omer Levy"], "venue": "arXiv preprint arXiv:1402.3722,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2014}, {"title": "Supervised sequence labelling with recurrent neural networks, volume 385", "author": ["Alex Graves"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "A novel connectionist system for unconstrained handwriting recognition", "author": ["Alex Graves", "Marcus Liwicki", "Santiago Fern\u00e1ndez", "Roman Bertolami", "Horst Bunke", "J\u00fcrgen Schmidhuber"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Framewise phoneme classification with bidirectional LSTM and other neural network architectures", "author": ["Alex Graves", "J\u00fcrgen Schmidhuber"], "venue": "Neural Networks,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "Neural network synthesis using cellular encoding and the genetic algorithm", "author": ["Frederic Gruau"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1994}, {"title": "Optimizing neural networks with genetic algorithms", "author": ["Steven A Harp", "Tariq Samad"], "venue": "In Proceedings of the 54th American Power Conference, Chicago,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2013}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural computation,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1997}, {"title": "Neural networks and physical systems with emergent collective computational abilities", "author": ["John J Hopfield"], "venue": "Proceedings of the national academy of sciences,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1982}, {"title": "Serial order: A parallel distributed processing approach", "author": ["Michael I Jordan"], "venue": "Advances in psychology,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1997}, {"title": "Deep visual-semantic alignments for generating image descriptions", "author": ["Andrej Karpathy", "Li Fei-Fei"], "venue": "arXiv preprint arXiv:1412.2306,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}, {"title": "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing", "author": ["Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2012}, {"title": "Sparse online learning via truncated gradient", "author": ["John Langford", "Lihong Li", "Tong Zhang"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2009}, {"title": "Handwritten digit recognition with a backpropagation network. In Advances in neural information processing systems", "author": ["B Boser Le Cun", "John S Denker", "D Henderson", "Richard E Howard", "W Hubbard", "Lawrence D Jackel"], "venue": null, "citeRegEx": "38", "shortCiteRegEx": "38", "year": 1990}, {"title": "Efficient elastic net regularization for sparse linear models", "author": ["Zachary C Lipton", "Charles Elkan"], "venue": null, "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2015}, {"title": "Optimal thresholding of classifiers to maximize F1 measure", "author": ["Zachary C Lipton", "Charles Elkan", "Balakrishnan Naryanaswamy"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2014}, {"title": "A novel approach to on-line handwriting recognition based on bidirectional long short-term memory networks", "author": ["Marcus Liwicki", "Alex Graves", "Horst Bunke", "J\u00fcrgen Schmidhuber"], "venue": "In Proc. 9th Int. Conf. on Document Analysis and Recognition,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2007}, {"title": "Recurrent neural networks for noise reduction in robust ASR", "author": ["Andrew L Maas", "Quoc V Le", "Tyler M O\u2019Neil", "Oriol Vinyals", "Patrick Nguyen", "Andrew Y Ng"], "venue": "In INTERSPEECH. Citeseer,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2012}, {"title": "Deep captioning with multimodal recurrent neural networks (m-RNN)", "author": ["Junhua Mao", "Wei Xu", "Yi Yang", "Jiang Wang", "Alan Yuille"], "venue": "arXiv preprint arXiv:1412.6632,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2014}, {"title": "Learning recurrent neural networks with hessian-free optimization", "author": ["James Martens", "Ilya Sutskever"], "venue": "In Proceedings of the 28th International Conference on Machine Learning", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2011}, {"title": "Efficient estimation of word representations in vector space", "author": ["Tomas Mikolov", "Kai Chen", "Greg Corrado", "Jeffrey Dean"], "venue": "arXiv preprint arXiv:1301.3781,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2013}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["Vinod Nair", "Geoffrey E Hinton"], "venue": "In Proceedings of the 27th International Conference on Machine Learning", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2010}, {"title": "BLEU: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting on association for computational linguistics, pages 311\u2013318", "author": ["Kishore Papineni", "Salim Roukos", "Todd Ward", "Wei-Jing Zhu"], "venue": "Association for Computational Linguistics,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2002}, {"title": "On the difficulty of training recurrent neural networks", "author": ["Razvan Pascanu", "Tomas Mikolov", "Yoshua Bengio"], "venue": "arXiv preprint arXiv:1211.5063,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2012}, {"title": "Gradient calculations for dynamic recurrent neural networks: A survey", "author": ["Barak A Pearlmutter"], "venue": "Neural Networks, IEEE Transactions on,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1995}, {"title": "Glove: Global vectors for word representation", "author": ["Jeffrey Pennington", "Richard Socher", "Christopher D Manning"], "venue": "Proceedings of the Empiricial Methods in Natural Language Processing (EMNLP 2014),", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2014}, {"title": "Learning internal representations by error propagation", "author": ["David E Rumelhart", "Geoffrey E Hinton", "Ronald J Williams"], "venue": "Technical report, DTIC Document,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1985}, {"title": "Bidirectional recurrent neural networks", "author": ["Mike Schuster", "Kuldip K Paliwal"], "venue": "Signal Processing, IEEE Transactions on,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 1997}, {"title": "Turing computability with neural nets", "author": ["Hava T Siegelmann", "Eduardo D Sontag"], "venue": "Applied Mathematics Letters,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 1991}, {"title": "Efficient learning using forward-backward splitting", "author": ["Yoram Singer", "John C Duchi"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2009}, {"title": "Dynamic pooling and unfolding recursive autoencoders for paraphrase detection", "author": ["Richard Socher", "Eric H Huang", "Jeffrey Pennin", "Christopher D Manning", "Andrew Y Ng"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2011}, {"title": "Grounded compositional semantics for finding and describing images with sentences", "author": ["Richard Socher", "Andrej Karpathy", "Quoc V Le", "Christopher D Manning", "Andrew Y Ng"], "venue": "Transactions of the Association for Computational Linguistics,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2014}, {"title": "Parsing natural scenes and natural language with recursive neural networks", "author": ["Richard Socher", "Cliff C Lin", "Chris Manning", "Andrew Y Ng"], "venue": "In Proceedings of the 28th international conference on machine learning", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2011}, {"title": "Learning continuous phrase representations and syntactic parsing with recursive neural networks", "author": ["Richard Socher", "Christopher D Manning", "Andrew Y Ng"], "venue": "In Proceedings of the NIPS-2010 Deep Learning and Unsupervised Feature Learning Workshop,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2010}, {"title": "Semi-supervised recursive autoencoders for predicting sentiment distributions", "author": ["Richard Socher", "Jeffrey Pennington", "Eric H Huang", "Andrew Y Ng", "Christopher D Manning"], "venue": "In Proceedings of the Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 2011}, {"title": "Unsupervised learning of video representations using LSTMs", "author": ["Nitish Srivastava", "Elman Mansimov", "Ruslan Salakhutdinov"], "venue": "arXiv preprint arXiv:1502.04681,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2015}, {"title": "On the importance of initialization and momentum in deep learning", "author": ["Ilya Sutskever", "James Martens", "George Dahl", "Geoffrey Hinton"], "venue": "In Proceedings of the 30th International Conference on Machine Learning", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 2013}, {"title": "Generating text with recurrent neural networks", "author": ["Ilya Sutskever", "James Martens", "Geoffrey E Hinton"], "venue": "In Proceedings of the 28th International Conference on Machine Learning", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 2011}, {"title": "Sequence to sequence learning with neural networks", "author": ["Ilya Sutskever", "Oriol Vinyals", "Quoc VV Le"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "64", "shortCiteRegEx": "64", "year": 2014}, {"title": "Computing machinery and intelligence", "author": ["Alan M Turing"], "venue": "Mind, pages 433\u2013", "citeRegEx": "65", "shortCiteRegEx": "65", "year": 1950}, {"title": "Sequence to sequence\u2013video to text", "author": ["Subhashini Venugopalan", "Marcus Rohrbach", "Jeff Donahue", "Raymond Mooney", "Trevor Darrell", "Kate Saenko"], "venue": "arXiv preprint arXiv:1505.00487,", "citeRegEx": "66", "shortCiteRegEx": "66", "year": 2015}, {"title": "Show and tell: A neural image caption generator", "author": ["Oriol Vinyals", "Alexander Toshev", "Samy Bengio", "Dumitru Erhan"], "venue": "arXiv preprint arXiv:1411.4555,", "citeRegEx": "67", "shortCiteRegEx": "67", "year": 2014}, {"title": "Backpropagation through time: what it does and how to do it", "author": ["Paul J Werbos"], "venue": "Proceedings of the IEEE,", "citeRegEx": "68", "shortCiteRegEx": "68", "year": 1990}, {"title": "A learning algorithm for continually running fully recurrent neural networks", "author": ["Ronald J Williams", "David Zipser"], "venue": "Neural computation,", "citeRegEx": "70", "shortCiteRegEx": "70", "year": 1989}, {"title": "Learning to execute", "author": ["Wojciech Zaremba", "Ilya Sutskever"], "venue": "arXiv preprint arXiv:1410.4615,", "citeRegEx": "71", "shortCiteRegEx": "71", "year": 2014}, {"title": "Adadelta: an adaptive learning rate method", "author": ["Matthew D Zeiler"], "venue": "arXiv preprint arXiv:1212.5701,", "citeRegEx": "72", "shortCiteRegEx": "72", "year": 2012}, {"title": "On rectified linear units for speech processing", "author": ["Matthew D Zeiler", "M Ranzato", "Rajat Monga", "M Mao", "K Yang", "Quoc Viet Le", "Patrick Nguyen", "A Senior", "Vincent Vanhoucke", "Jeffrey Dean"], "venue": "In Acoustics, Speech and Signal Processing (ICASSP),", "citeRegEx": "73", "shortCiteRegEx": "73", "year": 2013}], "referenceMentions": [{"referenceID": 47, "context": "A wellknown result by Siegelman and Sontag from 1991 demonstrated that a finite sized recurrent neural network with sigmoidal activation functions can simulate a universal Turing machine [54].", "startOffset": 187, "endOffset": 191}, {"referenceID": 21, "context": "Among the most useful resources are Alex Graves\u2019 2012 book on supervised sequence labelling with recurrent neural networks [24] and Felix Gers\u2019 doctoral thesis [19].", "startOffset": 123, "endOffset": 127}, {"referenceID": 16, "context": "Among the most useful resources are Alex Graves\u2019 2012 book on supervised sequence labelling with recurrent neural networks [24] and Felix Gers\u2019 doctoral thesis [19].", "startOffset": 160, "endOffset": 164}, {"referenceID": 13, "context": "More recently, [15] covers recurrent neural nets for language modeling.", "startOffset": 15, "endOffset": 19}, {"referenceID": 43, "context": "Other resources focus on a specific technical aspect such as [50], which surveys gradient calculations in recurrent neural networks.", "startOffset": 61, "endOffset": 65}, {"referenceID": 27, "context": "In the foundational papers, generally published in cognitive science and computational neuroscience journals ([33], [34], [18]), biologically plausible mechanisms are emphasized.", "startOffset": 110, "endOffset": 114}, {"referenceID": 28, "context": "In the foundational papers, generally published in cognitive science and computational neuroscience journals ([33], [34], [18]), biologically plausible mechanisms are emphasized.", "startOffset": 116, "endOffset": 120}, {"referenceID": 15, "context": "In the foundational papers, generally published in cognitive science and computational neuroscience journals ([33], [34], [18]), biologically plausible mechanisms are emphasized.", "startOffset": 122, "endOffset": 126}, {"referenceID": 46, "context": "In other papers ([53], [57], [35]), biological inspiration is downplayed in favor of achieving empirical results on important tasks and datasets.", "startOffset": 17, "endOffset": 21}, {"referenceID": 50, "context": "In other papers ([53], [57], [35]), biological inspiration is downplayed in favor of achieving empirical results on important tasks and datasets.", "startOffset": 23, "endOffset": 27}, {"referenceID": 29, "context": "In other papers ([53], [57], [35]), biological inspiration is downplayed in favor of achieving empirical results on important tasks and datasets.", "startOffset": 29, "endOffset": 33}, {"referenceID": 36, "context": "This approach has been used with deep belief nets for speech modeling in [43].", "startOffset": 73, "endOffset": 77}, {"referenceID": 58, "context": "In Alan Turing\u2019s groundbreaking paper Computing Machinery and Intelligence, he proposes an \u201cImitation Game\u201d which judges a machine\u2019s intelligence by its ability to convincingly engage in dialogue [65].", "startOffset": 196, "endOffset": 200}, {"referenceID": 46, "context": "1 Bidirectional recurrent neural networks (BRNNs) [53] extend RNNs to model dependence on both past states and future states.", "startOffset": 50, "endOffset": 54}, {"referenceID": 1, "context": "They have been used successfully on non-temporal sequence data, including genetic data [3].", "startOffset": 87, "endOffset": 90}, {"referenceID": 26, "context": "Following the convention adopted in several foundational recurrent net papers ([32], [19], [21], [63]), we index neurons with j and j\u2032, and by wjj\u2032 , we denote the weight corresponding to the directed edge from node j\u2032 to node j.", "startOffset": 79, "endOffset": 83}, {"referenceID": 16, "context": "Following the convention adopted in several foundational recurrent net papers ([32], [19], [21], [63]), we index neurons with j and j\u2032, and by wjj\u2032 , we denote the weight corresponding to the directed edge from node j\u2032 to node j.", "startOffset": 85, "endOffset": 89}, {"referenceID": 18, "context": "Following the convention adopted in several foundational recurrent net papers ([32], [19], [21], [63]), we index neurons with j and j\u2032, and by wjj\u2032 , we denote the weight corresponding to the directed edge from node j\u2032 to node j.", "startOffset": 91, "endOffset": 95}, {"referenceID": 56, "context": "Following the convention adopted in several foundational recurrent net papers ([32], [19], [21], [63]), we index neurons with j and j\u2032, and by wjj\u2032 , we denote the weight corresponding to the directed edge from node j\u2032 to node j.", "startOffset": 97, "endOffset": 101}, {"referenceID": 56, "context": "Common choices for the activation function include the sigmoid \u03c3(z) = 1/(1 + e\u2212z) and the tanh function \u03c6(z) = (e \u2212 e\u2212z)/(ez + e\u2212z) which has become common in feedforward neural nets and was applied to recurrent nets in [63].", "startOffset": 220, "endOffset": 224}, {"referenceID": 36, "context": "These units have been demonstrated to improve the performance of many deep neural networks ([43], [47], [73]) on tasks as varied as speech processing and object recognition, and have been used in recurrent neural networks by [7].", "startOffset": 92, "endOffset": 96}, {"referenceID": 40, "context": "These units have been demonstrated to improve the performance of many deep neural networks ([43], [47], [73]) on tasks as varied as speech processing and object recognition, and have been used in recurrent neural networks by [7].", "startOffset": 98, "endOffset": 102}, {"referenceID": 65, "context": "These units have been demonstrated to improve the performance of many deep neural networks ([43], [47], [73]) on tasks as varied as speech processing and object recognition, and have been used in recurrent neural networks by [7].", "startOffset": 104, "endOffset": 108}, {"referenceID": 5, "context": "These units have been demonstrated to improve the performance of many deep neural networks ([43], [47], [73]) on tasks as varied as speech processing and object recognition, and have been used in recurrent neural networks by [7].", "startOffset": 225, "endOffset": 228}, {"referenceID": 45, "context": "Backpropagation, an algorithm introduced to neural networks in [52],", "startOffset": 63, "endOffset": 67}, {"referenceID": 32, "context": "Convolutional neural networks, developed by Yann LeCun, [38] are a variant of feedforward neural network that, since 2012, hold records in many computer vision tasks, such as object detection [36].", "startOffset": 56, "endOffset": 60}, {"referenceID": 30, "context": "Convolutional neural networks, developed by Yann LeCun, [38] are a variant of feedforward neural network that, since 2012, hold records in many computer vision tasks, such as object detection [36].", "startOffset": 192, "endOffset": 196}, {"referenceID": 45, "context": "in 1985 [52].", "startOffset": 8, "endOffset": 12}, {"referenceID": 14, "context": "Some popular heuristics, such as AdaGrad [16], AdaDelta [72], and RMSprop [1], adaptively tune the learning rate for each feature.", "startOffset": 41, "endOffset": 45}, {"referenceID": 64, "context": "Some popular heuristics, such as AdaGrad [16], AdaDelta [72], and RMSprop [1], adaptively tune the learning rate for each feature.", "startOffset": 56, "endOffset": 60}, {"referenceID": 55, "context": "When the momentum parameter is well-tuned and the network is initialized well, momentum methods can train deep nets and recurrent nets competitively with more computationally expensive methods like the Hessian Free optimizer [62].", "startOffset": 225, "endOffset": 229}, {"referenceID": 30, "context": "Large scale feedforward neural networks trained via backpropagation have set many large-scale machine learning records, most notably on the computer vision task of object detection ([39], [36]).", "startOffset": 188, "endOffset": 192}, {"referenceID": 27, "context": "Early work, including Hopfield nets [33], learned via a Hebbian principle but did not produce networks useful for discriminative tasks.", "startOffset": 36, "endOffset": 40}, {"referenceID": 4, "context": "A number of papers from the 1990s ([6], [27]) championed the idea of learning neural networks with genetic algorithms with some even claiming that achieving success on real-world problems by applying many small changes to a network\u2019s weights was impossible.", "startOffset": 35, "endOffset": 38}, {"referenceID": 24, "context": "A number of papers from the 1990s ([6], [27]) championed the idea of learning neural networks with genetic algorithms with some even claiming that achieving success on real-world problems by applying many small changes to a network\u2019s weights was impossible.", "startOffset": 40, "endOffset": 44}, {"referenceID": 3, "context": "Several recent papers explore genetic algorithms for neural networks, especially as means of learning the architecture of neural networks, a problem not addressed by backpropagation ([5], [28]).", "startOffset": 183, "endOffset": 186}, {"referenceID": 25, "context": "Several recent papers explore genetic algorithms for neural networks, especially as means of learning the architecture of neural networks, a problem not addressed by backpropagation ([5], [28]).", "startOffset": 188, "endOffset": 192}, {"referenceID": 19, "context": "However, a rectified linear units (ReLUs) introduce sparsity to hidden layers [22].", "startOffset": 78, "endOffset": 82}, {"referenceID": 10, "context": "A growing body of recent work ([12], [37], [55], [40]), thus read shows that given sparse inputs to a linear model with any standard regularizer, sparsity can be fully exploited even if the gradient is not sparse (owing to regularization).", "startOffset": 31, "endOffset": 35}, {"referenceID": 31, "context": "A growing body of recent work ([12], [37], [55], [40]), thus read shows that given sparse inputs to a linear model with any standard regularizer, sparsity can be fully exploited even if the gradient is not sparse (owing to regularization).", "startOffset": 37, "endOffset": 41}, {"referenceID": 48, "context": "A growing body of recent work ([12], [37], [55], [40]), thus read shows that given sparse inputs to a linear model with any standard regularizer, sparsity can be fully exploited even if the gradient is not sparse (owing to regularization).", "startOffset": 43, "endOffset": 47}, {"referenceID": 33, "context": "A growing body of recent work ([12], [37], [55], [40]), thus read shows that given sparse inputs to a linear model with any standard regularizer, sparsity can be fully exploited even if the gradient is not sparse (owing to regularization).", "startOffset": 49, "endOffset": 53}, {"referenceID": 57, "context": "\u2019s model for sequence to sequence learning [64], compute the output at each time step and pass a representation of this information as the input at the following time step.", "startOffset": 43, "endOffset": 47}, {"referenceID": 61, "context": "This algorithm is called backpropagation through time (BPTT), and was introduced in 1990 [68].", "startOffset": 89, "endOffset": 93}, {"referenceID": 27, "context": "In 1982, Hopfield introduced a family of recurrent neural networks [33].", "startOffset": 67, "endOffset": 71}, {"referenceID": 28, "context": "Jordan networks (Figure 5), introduced by Michael Jordan in 1986, present an early architecture for supervised learning on sequences ([34]).", "startOffset": 134, "endOffset": 138}, {"referenceID": 15, "context": "Figure 6: An Elman network as described in Finding Structure in Time (1990) [18].", "startOffset": 76, "endOffset": 80}, {"referenceID": 57, "context": "[64] translates sentences between natural languages.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "Elman networks, introduced in [18], simplify the structure in the Jordan network.", "startOffset": 30, "endOffset": 34}, {"referenceID": 26, "context": "Some of Elman\u2019s ideas, including fixedweight edges and the importance of self-connected recurrent edges in hidden nodes survive in Hochreiter and Schmidhuber\u2019s subsequent work on Long ShortTerm Memory [32].", "startOffset": 201, "endOffset": 205}, {"referenceID": 7, "context": "But learning on recurrent networks can be especially hard due to the difficulty of learning long-range dependencies as described by Bengio et al in 1994 [9] and expanded upon in [31].", "startOffset": 153, "endOffset": 156}, {"referenceID": 42, "context": "In [49], Pascanu et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 62, "context": "Truncated backpropagation through time (TBPTT) is one solution to this problem for continuously running networks [70].", "startOffset": 113, "endOffset": 117}, {"referenceID": 9, "context": "It has been known since at least 1993 that optimizing even a 3-layer neural network is NPComplete [11].", "startOffset": 98, "endOffset": 102}, {"referenceID": 12, "context": "[14] shows that while many critical points exist on the error surfaces of large neural networks, the ratio of saddle points to true local minima increases exponentially with the size of the network Fast implementations and improved gradient following heuristics have rendered RNN training feasible.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "An illustration like this appears in [24]", "startOffset": 37, "endOffset": 41}, {"referenceID": 8, "context": "backward propagation using GPUs, such as Theano ( [10]) and Torch ([13]), have made it easy to implement fast training algorithms.", "startOffset": 50, "endOffset": 54}, {"referenceID": 11, "context": "backward propagation using GPUs, such as Theano ( [10]) and Torch ([13]), have made it easy to implement fast training algorithms.", "startOffset": 67, "endOffset": 71}, {"referenceID": 38, "context": ", truncated Newton approach [45] and applied it to a network which learns to generate text one character at a time in [63].", "startOffset": 28, "endOffset": 32}, {"referenceID": 56, "context": ", truncated Newton approach [45] and applied it to a network which learns to generate text one character at a time in [63].", "startOffset": 118, "endOffset": 122}, {"referenceID": 12, "context": "In the paper that described the abundance of saddle points on the error surfaces of neural networks ([14]), the authors present a saddle-free version of Newton\u2019s method.", "startOffset": 101, "endOffset": 105}, {"referenceID": 23, "context": "for phoneme classification [26] and handwriting recognition [25].", "startOffset": 27, "endOffset": 31}, {"referenceID": 22, "context": "for phoneme classification [26] and handwriting recognition [25].", "startOffset": 60, "endOffset": 64}, {"referenceID": 26, "context": "Figure 9: LSTM memory cell as initially described in Hochreiter [32].", "startOffset": 64, "endOffset": 68}, {"referenceID": 57, "context": "Seeking comprehensibility, we break with this convention and use i, f , and o to refer to input, forget and output gates respectively as in [64].", "startOffset": 140, "endOffset": 144}, {"referenceID": 18, "context": "in [21].", "startOffset": 3, "endOffset": 7}, {"referenceID": 18, "context": "Forget gates, proposed in 2000 by Gers and Schmidhuber [21], add a gate similar to input and output gates to allow the network to flush information from the constant error carousel.", "startOffset": 55, "endOffset": 59}, {"referenceID": 17, "context": "Also in 2000, Gers and Schmidhuber proposed peephole connections [20], which pass from the carousel directly to the input and output gates of that same node without first having to pass through the output gate.", "startOffset": 65, "endOffset": 69}, {"referenceID": 63, "context": "We use the tanh function \u03c6 for the input node g following the latest state of the art setup of Zaremba and Sutskever in [71].", "startOffset": 120, "endOffset": 124}, {"referenceID": 26, "context": "However, in the original LSTM paper [32], the activation function for g is the sigmoid \u03c3.", "startOffset": 36, "endOffset": 40}, {"referenceID": 46, "context": "Along with the LSTM, one of the most used RNN setups is the bidirectional recurrent neural network (BRNN) (Figure 11) first described in [53].", "startOffset": 137, "endOffset": 141}, {"referenceID": 46, "context": "Figure 11: Structure of a bidirectional recurrent neural network as described by Schuster and Paliwal in [53].", "startOffset": 105, "endOffset": 109}, {"referenceID": 29, "context": "use such a network for generating captions for images [35].", "startOffset": 54, "endOffset": 58}, {"referenceID": 22, "context": "to achieve state of the art results on handwriting recognition and phoneme classification [25] [26].", "startOffset": 90, "endOffset": 94}, {"referenceID": 23, "context": "to achieve state of the art results on handwriting recognition and phoneme classification [25] [26].", "startOffset": 95, "endOffset": 99}, {"referenceID": 15, "context": "Such an encoding is discussed in [18] among others.", "startOffset": 33, "endOffset": 37}, {"referenceID": 44, "context": "Freely available code to produce word vectors from co-occurrence stats include Glove from Pennington Socher and Manning [51], and word2vec [23], which implements a word embedding algorithm from Mikolov et al.", "startOffset": 120, "endOffset": 124}, {"referenceID": 20, "context": "Freely available code to produce word vectors from co-occurrence stats include Glove from Pennington Socher and Manning [51], and word2vec [23], which implements a word embedding algorithm from Mikolov et al.", "startOffset": 139, "endOffset": 143}, {"referenceID": 39, "context": "[46].", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]).", "startOffset": 8, "endOffset": 11}, {"referenceID": 52, "context": "in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]).", "startOffset": 186, "endOffset": 190}, {"referenceID": 49, "context": "in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]).", "startOffset": 192, "endOffset": 196}, {"referenceID": 53, "context": "in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]).", "startOffset": 198, "endOffset": 202}, {"referenceID": 51, "context": "in 2003 [8], and more recently brought to wider attention in the deep learning community by Socher, Manning and Ng in a number of papers describing Recursive Autoencoder (RAE) networks ([59], [56], [60], [58]).", "startOffset": 204, "endOffset": 208}, {"referenceID": 15, "context": "In many experiments with recurrent neural networks ([18], [63], [71]), input is fed in one character at a time (and output generated one character at a time).", "startOffset": 52, "endOffset": 56}, {"referenceID": 56, "context": "In many experiments with recurrent neural networks ([18], [63], [71]), input is fed in one character at a time (and output generated one character at a time).", "startOffset": 58, "endOffset": 62}, {"referenceID": 63, "context": "In many experiments with recurrent neural networks ([18], [63], [71]), input is fed in one character at a time (and output generated one character at a time).", "startOffset": 64, "endOffset": 68}, {"referenceID": 41, "context": "Developed in 2002, BLEU score, a common evaluation metric for machine translation, is related to modified unigram precision [48].", "startOffset": 124, "endOffset": 128}, {"referenceID": 2, "context": "METEOR, introduced in 2005 by Banerjee and Lavie is an alternative metric intended to overcome these weaknesses of the BLEU score [4].", "startOffset": 130, "endOffset": 133}, {"referenceID": 34, "context": "Even in the straightforward case of binary classification, without time dependencies, commonly used performance metrics like F1 give rise to complicated thresholding strategies which may not accord with any reasonable intuition of what should constitute good performance [41].", "startOffset": 271, "endOffset": 275}, {"referenceID": 57, "context": "[64].", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "Their RNN model uses the word embeddings of Mikolov [2] and a lattice representation of the decoder output to facilitate search over the space of possible translations.", "startOffset": 52, "endOffset": 55}, {"referenceID": 29, "context": "Recently, recurrent neural networks have been used successfully for image captioning, [35, 44, 67].", "startOffset": 86, "endOffset": 98}, {"referenceID": 37, "context": "Recently, recurrent neural networks have been used successfully for image captioning, [35, 44, 67].", "startOffset": 86, "endOffset": 98}, {"referenceID": 60, "context": "Recently, recurrent neural networks have been used successfully for image captioning, [35, 44, 67].", "startOffset": 86, "endOffset": 98}, {"referenceID": 29, "context": "This work clearly precedes [35] as it is cited throughout, but [44] claim it as an independent innovation.", "startOffset": 27, "endOffset": 31}, {"referenceID": 37, "context": "This work clearly precedes [35] as it is cited throughout, but [44] claim it as an independent innovation.", "startOffset": 63, "endOffset": 67}, {"referenceID": 29, "context": "similarly use a convolutional neural network to encode images together with a bidirectional neural network to decode translations, using word2vec embeddings as word representations [35].", "startOffset": 181, "endOffset": 185}, {"referenceID": 35, "context": "( [42], [25]), data is collected from a whiteboard using an eBeam interface.", "startOffset": 2, "endOffset": 6}, {"referenceID": 22, "context": "( [42], [25]), data is collected from a whiteboard using an eBeam interface.", "startOffset": 8, "endOffset": 12}, {"referenceID": 54, "context": "Among the most interesting of these applications are unsupervised video encoding [61], video captioning [66] and program execution [71].", "startOffset": 81, "endOffset": 85}, {"referenceID": 59, "context": "Among the most interesting of these applications are unsupervised video encoding [61], video captioning [66] and program execution [71].", "startOffset": 104, "endOffset": 108}, {"referenceID": 63, "context": "Among the most interesting of these applications are unsupervised video encoding [61], video captioning [66] and program execution [71].", "startOffset": 131, "endOffset": 135}, {"referenceID": 59, "context": "In [66], Venugopalan et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 63, "context": "In Learning to Execute ([71]), Zaremba and Sutskever experiment with networks which read computer programs one character at a time and predict their output.", "startOffset": 24, "endOffset": 28}], "year": 2015, "abstractText": "Countless learning tasks require awareness of time. Image captioning, speech synthesis, and video game playing all require that a model generate sequences of outputs. In other domains, such as time series prediction, video analysis, and music information retrieval, a model must learn from sequences of inputs. Significantly more interactive tasks, such as natural language translation, engaging in dialogue, and robotic control, often", "creator": "LaTeX with hyperref package"}}}