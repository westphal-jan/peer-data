{"id": "1506.04449", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2015", "title": "Compressing Convolutional Neural Networks", "abstract": "Convolutional neural networks (CNN) are increasingly used in many areas of computer vision. They are particularly attractive because of their ability to \"absorb\" great quantities of labeled data through millions of parameters. However, as model sizes increase, so do the storage and memory requirements of the classifiers. A classifier that can be used to estimate a person's memory and perform a task based on a model of a person's brain has a greater amount of complexity. So it is not surprising that the first generation of the field of artificial neural networks, in addition to the recent advances in artificial neural networks, is now being deployed to be deployed to the deep neural networks.\n\n\n\nThe next step in the process is to make a new classifier suitable for the tasks that need to be performed in order to \"absorb\" the information presented to the computer to fit into it, thereby producing an equivalent \"machine learning,\" which is an excellent way of looking at information and interpreting it.\n\"At first we thought about an artificial neural network, but what we realized was that if we had an artificial neural network, it would be very difficult to predict, because we would have to deal with very low complexity challenges. But we developed a model to do this,\" said John Beasley, professor of engineering at the University of Washington.\nIt uses an enormous amount of computational power to build algorithms using the same methods, but also the same techniques. Using data from dozens of different different neural networks to figure out the best and best algorithm, Beasley also developed the \"fostal neural network,\" a system that, he said, would be \"observed on a variety of different types of networked devices.\"\n\"The idea is to look at data from different layers of neural networks and, for example, look at a dataset of individuals,\" Beasley said. \"The model is a really easy one to use, and it allows you to understand, to understand, to predict and apply mathematical features to people's behaviors.\"\n\"It's a really easy one to use, and it allows you to understand, to predict and apply mathematical features to people's behaviors.\"\nBut in the next few years, Beasley's method of learning about deep learning is being rolled out into all kinds of models. While the technology is still very expensive, a new classifier would be needed to model and analyze thousands of data from thousands of different networks.\n\"As a result of the recent advancements in artificial neural networks, we now know that our neural", "histories": [["v1", "Sun, 14 Jun 2015 23:16:40 GMT  (536kb,D)", "http://arxiv.org/abs/1506.04449v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.CV cs.NE", "authors": ["wenlin chen", "james t wilson", "stephen tyree", "kilian q weinberger", "yixin chen"], "accepted": false, "id": "1506.04449"}, "pdf": {"name": "1506.04449.pdf", "metadata": {"source": "CRF", "title": "Compressing Convolutional Neural Networks", "authors": ["Wenlin Chen", "James T. Wilson", "Stephen Tyree", "Kilian Q. Weinberger", "Yixin Chen"], "emails": ["j.wilson}@wustl.edu", "styree@nvidia.com", "kilian@wustl.edu,", "chen@cse.wustl.edu"], "sections": [{"heading": "1 Introduction", "text": "In the recent years convolutional neural networks (CNN) have lead to impressive results in object recognition [17], face verification [24] and audio classification [20]. Problems that seemed impossibly hard only five years ago can now be solved at better than human accuracy [15]. Although CNNs have been known for a quarter of a century [12], only recently have their superb generalization abilities been accepted widely across the machine learning and computer vision communities. This broad acceptance coincides with the release of very large collections of labeled data [9]. Deep networks and CNNs are particularly well suited to learn from large quantities of data, in part because they can have arbitrarily many parameters. As data sets grow, so do model sizes. In 2012, the first winner of the ImageNet competition that used a CNN had already 240MB of parameters and the most recent winning model, in 2014, required 567MB [26].\nIndependently, there has been another parallel shift of computing from servers and workstations to mobile platforms. As of January 2014 there have already been more web searches through smart phones than computers1. Today speech recognition is primarily used on cell phones with intelligent assistants such as Apple\u2019s Siri, Google Now or Microsoft\u2019s Cortana. As this trend continues, we are expecting machine learning applications to also shift increasingly towards mobile devices. However, the disjunction of deep learning with ever increasing model sizes and mobile computing reveals\n1http://tinyurl.com/omd58sq\nar X\niv :1\n50 6.\n04 44\n9v 1\n[ cs\n.L G\n] 1\n4 Ju\nan inherent dilemma. Mobile devices have tight memory and storage limitations. For example, even the most recent iPhone 6 only features 1GB of RAM, most of which must be used by the operating system or the application itself. In addition, developers must make their apps compatible with the most limited phone still in circulation, often restricting models to just a few megabytes of parameters.\nIn response, there has been a recent interest in reducing the model sizes of deep networks. Denil et al. [10] use low-rank decomposition of the weight matrices to reduce the effective number of parameters in the network. Bucilu et al. [4] and Ba et al. [1] show that complex models can be compressed into 1-layer neural networks. Independently, the model size of neural networks can be reduced effectively through reduced bit precision [7].\nIn this paper we propose a novel approach for neural network compression targeted especially for CNNs. We build on recent work by Chen et al. [5], who show that weights of fully connected networks can be effectively compressed with the hashing trick [30]. Due to the nature of local pixel correlation in images (i.e. spatial locality), filters in CNNs tend to be smooth. We transform these filters into frequency domain with the discrete cosine transform (DCT) [22]. In frequency space, the filters are naturally dominated by low frequency components. Our compression takes this smoothness property into account and randomly hashes the frequency components of all CNN filters at a given layer into one common set of hash buckets. All components inside one hash bucket share the same value. As lower frequency components are more pronounced than higher frequencies, we allow collisions only between similar frequencies and allocate fewer hash buckets for the high frequencies (which are less important).\nOur approach has several compelling properties: 1. The number of parameters in the CNN is independent of the number of convolutional filters; 2. During testing we only need to add a low-cost hash function and the inverse DCT transformation to any existing CNN code for filter reconstruction; 3. During training, the hashed weights can be learned with simple back-propagation [2]\u2014the gradient of a hash bucket value is the sum of gradients of all hashed frequency components in that bucket.\nWe evaluate our compression scheme on eight deep learning image benchmark data sets and compare against four competitive baselines. Although all compression schemes lead to lower test accuracy as the compression increases, our FreshNets method is by far the most effective compression method and yields the lowest generalization error rates on almost all classification tasks."}, {"heading": "2 Background", "text": "Feature Hashing (a.k.a the hashing trick) [8, 25, 30] has been previously studied as a technique for reducing model storage size. In general, it can be regarded as a dimensionality reduction method that maps an input vector x \u2208 Rd to a much smaller feature space via a mapping \u03c6 :Rd \u2192 Rk where k d. The mapping \u03c6 is a composite of two approximately uniform auxiliary hash functions h :N\u2192 {1, . . . , k} and \u03be :N\u2192 {\u22121,+1}. The jth element of the k-dimensional hashed input is defined as\n\u03c6j(x) = \u2211\ni:h(i)=j\n\u03be(i) xi.\nAs shown in [30], a key property of feature hashing is its preservation of inner product operations, where inner products after hashing produce the correct pre-hash inner product in expectation:\nE[\u03c6(x)>\u03c6(y)]\u03c6 = x>y.\nThis property holds because of the bias correcting sign factor \u03be(i). With feature hashing, models are directly learned in the much smaller space Rk, which not only speeds up training and evaluation but also significantly conserves memory. For example, a linear classifier in the original space could occupy O(d) memory for model parameters, but when learned in the hashed space only requires O(k) parameters. The information loss induced by hash collision is much less severe for sparse feature vectors and can be counteracted through multiple hashing [25] or larger hash tables [30].\nDiscrete Cosine Transform (DCT) [22]. Methods built on the DCT are widely used for compressing images and movies, including forming the standard technique for JPEG [29]. DCT expresses a function as a weighted combination of sinusoids of different phases/frequencies where the weight of each sinusoid reflects the magnitude of the corresponding frequency in the input. When employed\nwith sufficient numerical precision and without quantization or other compression operations, the DCT and inverse DCT (projecting frequency inputs back to the spatial domain) are lossless. Compression is made possible in images by local smoothness of pixels (e.g. a blue sky) which can be well represented regionally by fewer non-zero frequency components. Though highly related to the discrete Fourier transformation (DFT), DCT is often preferable for compression tasks because of its spectral compaction property where weights for most images tend to be concentrated in a few low-frequency components of the DCT [22]. Further, the DCT transformation yields a real-valued representation, unlike the DFT whose representation has imaginary components. Given an input matrix V \u2208Rd\u00d7d, the corresponding matrix V\u2208Rd\u00d7d in frequency domain after DCT is defined as:\nVj1j2 = sj1sj2 d\u22121\u2211 i1=0 d\u22121\u2211 i2=0 c(i1, i2, j1, j2) Vi1i2 , (1)\nwhere c(i1, i2, j1, j2) = cos [ \u03c0\nd\n( i1 + 1\n2\n) j1 ] cos [ \u03c0\nd\n( i2 + 1\n2\n) j2 ] is the cosine basis function, and sj= \u221a 1 d when j=0 and sj= \u221a 2 d otherwise. We use the shorthand fdct to denote the DCT operation in Eq. (1), i.e. V = fdct(V ). The inverse DCT converts V from the frequency domain back to the spatial domain, reconstructing V without loss:\nVi1i2 = d\u22121\u2211 j1=0 d\u22121\u2211 j2=0 sj1sj2 c(i1, i2, j1, j2) Vj1j2 . (2)\nWe denote the inverse DCT function in Eq. (2) as f\u22121dct, i.e. V = f \u22121 dct(V).\n3 Frequency-Sensitive Hashed Nets w ei gh ts 2.9 1.11.53.2 -0.52.5 -2.1 1.3\n3.2\n1.1\n1.1\n-0.5\n2.5\n-2.1\n1.5\n-0.5\n1.3\n2.9\n1.1\n1.1\n-0.5\n-2.1\n2.5\n-0.5\n1.5\n1.3\n2.6\n0.4\n2.3\n-1.6\n-0.7\n1.1\n2.4\n2.2\n0.9\n2.0\n1.2\n0.7\n3.5\n1.5\n-1.8\n1.4\n2.2\n0.4\nf 1dct\nfr eq\nue nc\ny do\nm ai n sp at ia l d om ai n\nV\nV\nw\nreconstruct virtual frequencies\nmap to spatial domainf 1 dct\nFilter 1 Filter 2\nw0 w1 w2 w3 w4\nhj , \u21e0hj , \u21e0\nFigure 1: A schematic illustration of FreshNets. Two spatial filters are reconstructed from the frequency weights in vector w. The frequency weights are accessed with two hash functions and then transformed to the spatial domain. The vector w is partitioned into subvectors wj shared by all entries with similar frequency (corresponding to index sum j = j1 + j2). Colors indicate which hash bucket was accessed.\nHere we present FreshNets, a method for using weight sharing to reduce the model size (and memory demands) of convolutional neural networks. Similar to the work of Chen et al. [5], we achieve smaller models by randomly forcing weights throughout the network to share identical values. Unlike previous work, we implement the weight sharing and gradient updates of convolutional filters in the frequency domain. These sharing constraints are made prior to training, and we learn frequency weights under the sharing assignments. Since the assignments are made with a hash function, they incur no additional storage.\nFilters in spatial and frequency domain. Let the matrix V k` \u2208 Rd\u00d7d denote the weight matrix of the d\u00d7d convolutional filter that connects the kth input plane to the `th output plane. (For notational convenience we assume square filters and only consider the filters in a single layer of the network.) The weights of all filters in a convolutional layer can be denoted by a 4-dimensional tensor V \u2208 Rm\u00d7n\u00d7d\u00d7d where m and n are the number of input planes and output planes, respectively, resulting in a total of m \u00d7 n \u00d7 d2 parameters. Convolutional filters can be represented equivalently in either the spatial or frequency domain, mapping between the two via the DCT and its inverse. We denote the filter in frequency domain as Vk`=fdct(V k`)\u2208Rd\u00d7d and recover the original spatial representation through V k` = f\u22121dct(Vk`), as defined in Eq. (1) and (2), respectively. The tensor of all filters is denoted V\u2208Rm\u00d7n\u00d7d\u00d7d.\nRandom Weight Sharing by Hashing. We would like to reduce the number of model parameters to exactly K values stored in a weight vector w\u2208RK , where K m\u00d7n\u00d7 d2. To achieve this, we\nrandomly assign a value from w to each filter frequency weight in V . A na\u0131\u0308ve implementation of this random weight sharing would introduce an auxiliary matrix for V to track the weight assignments, using to significant additional memory. To address this problem, Chen et al. [5] advocate use of the hashing trick to (pseudo-)randomly assign shared parameters. Using the hashing trick, we tie each filter weight Vk`j1j2 to an element of w indexed by the output of a hash function h(\u00b7):\nVk`j1,j2 = \u03be(k, `, j1, j2) wh(k,`,j1,j2), (3) where h(k, `, j1, j2)\u2208{1, \u00b7 \u00b7 \u00b7 ,K}, and \u03be(k, `, j1, j2)\u2208{\u00b11} is a sign factor computed by a second hash function \u03be(\u00b7) to preserve inner-products in expectation as described in Section 2. With the mapping in Eq. (3), we can implement shared parameter assignments with no additional storage cost. (For a schematic illustration, see Figure 1. The figure also incorporates a frequency sensitive hashing scheme discussed later in this section.)\nGradients over Shared Frequency Weights. Typical convolutional neural networks learn filters in the spatial domain. As our shared weights are stored in the frequency domain, we derive the gradient with respect to filter parameters in frequency space. Following Eq. (2), we express the gradient of parameters in the spatial domain w.r.t. their counterparts in the frequency domain:\n\u2202V k`i1i2 \u2202Vk`j1j2 = sj1sj2 c(i1, i2, j1, j2). (4)\nLet L be the loss function adopted for training. Using standard back-propagation, we can derive the gradient w.r.t. filter parameters in the spatial domain, \u2202L\n\u2202V k`i1i2 . By the chain rule with Eq. (4), we\nexpress the gradient of L in the frequency domain:\n\u2202L \u2202Vk`j1j2 = d\u22121\u2211 i1=0 d\u22121\u2211 i2=0 \u2202L \u2202V k`i1i2 \u2202V k`i1i2 \u2202Vk`j1j2 = sj1sj2 d\u22121\u2211 i1=0 d\u22121\u2211 i2=0 c(i1, i2, j1, j2) \u2202L \u2202V k`i1i2 . (5)\nComparing with Eq. (1), we see that the gradient in the frequency domain is merely the DCT of the gradient in the spatial domain:\n\u2202L \u2202Vk` = fdct ( \u2202L \u2202V k` ) . (6)\nWe compute gradient for each shared weight wh by simply summing over the gradient at each filter parameter where the weight is assigned, i.e. all Vk`j1j2 where h = h(k, `, j1, j2):\n\u2202L \u2202wh = m\u2211 k=0 n\u2211 `=0 d\u22121\u2211 j1=0 d\u22121\u2211 j2=0 \u2202L \u2202Vk`j1j2 \u2202Vk`j1j2 \u2202wh = \u2211\nk,`,j1,j2: h=h(k,`,j1,j2)\n\u03be(k, `, j1, j2) [ fdct ( \u2202L \u2202V k` )] j1j2\n(7)\nwhere [A]j1j2 denotes the (j1, j2) entry in matrix A.\nhigher frequency\nVk` Vk`\nFigure 2: An example of a filter in spatial (left) and frequency domain (right).\nFrequency Sensitive Hashing. Figure 2 shows a filter in spatial (left) and frequency (right) domains. In the spatial domain CNN filters are smooth [17] due to the local pixel smoothness in natural images. In the frequency domain this corresponds to components with large magnitudes in the low frequencies, depicted in the upper left half of Vk` in Figure 2. Correspondingly, the high frequencies, in the bottom right half of Vk`, have magnitudes near zero. As components of different frequency groups tend to be of different magnitudes (and thereby varying importance to the spatial structure of the filter), we want to avoid collisions between high and low\nfrequency components. Therefore, we assign separate hash spaces to different frequency groups. In particular, we partition the K values of w into sub-vectors w0, . . . ,w2d\u22122 of sizes K0, . . . ,K2d\u22122, where \u2211 j Kj = K. This partitioning allows parameters with the same frequency, corresponding to their index sum j = j1+ j2, to be hashed into a corresponding dedicated hash space wj . We rewrite Eq. (3) with the new frequency sensitive shared weight assignments:\nVk`j1,j2 = \u03be(k, `, j1, j2) w j hj(k,`,j1,j2)\nwhere hj(\u00b7) maps an input key to a natural number in {1, \u00b7 \u00b7 \u00b7 ,Kj} and j=j1+j2. We define a compression rate rj \u2208 (0, 1] for each frequency region j and assign Kj = rjNj . A smaller rj induces more collisions during hashing, leading to increased weight sharing. Since lower frequency components tend to be of higher importance, making collisions more hurtful, we commonly assign larger rj (fewer collisions) to low-frequency regions. Intuitively, given a size budget for the whole convolutional layer, we want to squeeze the hash space of high frequency region to save space for low frequency regions. These compression rates can either be assigned by hand or determined programmatically by cross-validation, as demonstrated in Section 5."}, {"heading": "4 Related Work", "text": "Several recent studies have confirmed that there is significant redundancy in the parameters learned in deep neural networks. Recent work by Denil et al. [10] learns parameters in fully-connected layers after decomposition into two low-rank matrices, i.e. W =AB where W \u2208Rm\u00d7n, A\u2208Rm\u00d7k and B \u2208 Rk\u00d7n. In this way, the original O(mn) parameters could be stored with O(k(m+n)) storage, where k min(m,n). Several works apply related approaches to speed up the evaluation time with convolutional neural networks. Two works propose to approximate convolutional filters by a weighted linear combination of basis filters [23, 16]. In this setting, the convolution operation only needs to be performed with the small set of basis filters. The desired output feature maps are computed by matrix multiplication as the weighted sum of these basis convolutions. Further speedup can be achieved by learning rank-one basis filters so that the convolution operations are very cheap to compute [11, 19]. Based on this idea, Denton et al. [11] advocate decomposing the four-dimensional tensor of the filter weights into a sum of different rank-one, four-dimensional tensors. In addition, they adopt bi-clustering to group filters such that each subgroup can be better approximated by rank-one tensors.\nIn each of these works, evaluation time is the main focus, with any resulting storage reduction achieved merely as a side effect. Other works focus entirely on compressing the fully-connected layers of CNNs [13, 31]. However, with the trend toward architectures with fewer fully connected layers and additional convolutional layers [27], compression of filters is of increased importance. Another technique for speeding up convolutional neural network evaluation is computing convolutions in the Fourier frequency domain, as convolution in the spatial domain is equivalent to (comparatively lower-cost) element-wise multiplication in the frequency domain [21, 28]. Unlike FreshNets, for a filter of size d \u00d7 d and an image of size n \u00d7 n where n > d, Mathieu et al. [21] convert the filter to its frequency domain of size n \u00d7 n by oversampling the frequencies, which is necessary for doing element-wise multiplication with a larger image but also increases the memory overhead at test time. Training in the Fourier frequency domain may be advantageous for similar reasons, particularly when convolutions are being performed over large 3-D volumes [3].\nMost relevant to this work is HashedNets [5] which compresses the fully connected layers of deep neural networks. This method uses the hashing trick to efficiently implement parameter sharing prior to learning, achieving notable compression with less loss of accuracy than the competing baselines which relied on low-rank decomposition or learning in randomly sparse architectures."}, {"heading": "5 Experimental Results", "text": "In this section, we conduct several comprehensive experiments on benchmark datasets to evaluate the performance of FreshNets.\nDatasets. We experiment with eight benchmark datasets: CIFAR10, CIFAR100, SVHN and five challenging variants of MNIST. The CIFAR10 dataset contains 60000 images of 32\u00d7 32 pixels with three color channels. Images are selected from ten classes with each class consisting of 6000 unique instances. The CIFAR100 dataset also contains 60000 32\u00d732 images, but is more challenging since the images are selected from 100 classes (each class has 600 images). For both CIFAR datasets, 50000 images are designated for training and the remaining 10000 images for testing. To improve accuracy on CIFAR100, we augment by horizontal reflection and cropping [17], resulting in 0.8M training images. The SVHN dataset is a large collection of digits (10 classes) cropped from realworld scenes, consisting of 73257 training images, 26032 testing images and 531131 less difficult\nimages for additional training. In our experiments, we use all available training images, for a total of 604388 training samples. For the MNIST variants [18], each variation either reduces the training size (MNIST-07) or amends the original digits by rotation (ROT), background superimposition (BGRAND and BG-IMG), or a combination thereof (BG-ROT). We preprocess all datasets with whitening (except CIFAR100 and SVHN which were prohibitively large).\nBaselines. We compare the proposed FreshNets with four baseline methods: HashedNets [5], low-rank decomposition (LRD) [10], filter dropping (DropFilt) and frequency dropping (DropFreq). HashedNets was first proposed to compress fully-connected layers in deep neural networks via the hashing trick. In this baseline, we apply the hashing trick directly to the convolutional layer by hashing filter weights in the spatial domain. This induces random weight sharing across all filters in a single convolutional layer. Additionally, we compare against low-rank decomposition of the convolutional filters [10]. Following the method in [11], we unfold the four-dimensional filter tensor to form a two dimensional matrix on which we apply the low-rank decomposition. The parameters of the decomposition are fine-tuned via back-propagation. DropFreq learns parameters in the DCT frequency domain but sets high frequency components to 0 to meet the compression requirement. DropFilt compresses simply by reducing the number of filters in each convolutional layer.\nAll methods were implemented using Torch7 [6] and run on NVIDIA GTX TITAN graphics cards with 2688 cores and 6GB of global memory. Model parameters are stored and updated as 32 bit floating-point values.2\nComprehensive evaluation. We adopt the network network architecture shown in Table 1 for all datasets. The architecture is a deep convolutional neural network consisting of five convolutional layers (with 5 \u00d7 5 filters) and one fully-connected layer. Before convolution, input feature maps are zero-padded such that output maps remain the same size as the (un-padded) input maps after convolution. Max-pooling is performed after convolutions in layers 2, 4 and 5 with filter size 2\u00d7 2 and stride 2, reducing both input map dimensions by half. Rectified linear units are adopted as the activation function throughout. The output of the network is a softmax function over labels.\n2The compression rates of all methods could be further improved by learning and storing parameters in lower precision [7, 14].\nIn this architecture, the convolutional layers hold the majority of parameters (1.2 million in convolutional layer v.s. 40 thousand in the fully connected layer with 10 output classes). During training, we optimize parameters using mini-batch gradient descent with batch size 64 and momentum 0.9. We use 20 percent of the training set as a validation set for early stopping. For FreshNets, we use a frequency-sensitive compression scheme which increases\nweight sharing among higher frequency components.3 For all baselines, we apply HashedNets [5] to the fully connected layer at the corresponding level of compression. All error results are reported on the test set.\nTable 2(a) and (b) show the comprehensive evaluation of all methods under compression ratios 1/16 and 1/64, respectively. We exclude DropFilt and DropFreq in Table 2(b) because neither supports 1/64 compression in this architecture for all layers. For all methods, the fully connected layer (top layer) is compressed by HashedNets [5] at the corresponding compression rate. In this way, the final size of the entire network respects the specified compression ratio. For reference, we also show the error rate of a standard convolutional neural network (CNN, columns 2 and 8) with the fully-connected layer compressed by HashedNets and no compression in the convolutional layers. Excluding this reference, we highlight the method with best test error on each dataset in bold.\nWe discern several general trends. In Table 2(a), we observe the performance of the DropFilt and DropFreq at 1/16 compression. At this compression rate, DropFilt corresponds to a network 1/16 filters at each layer: 2, 4, 4, 8, 16 at layers 1\u22125 respectively. This architecture yields particularly poor test accuracy, including essentially random predictions on three datasets. DropFreq, which at 1/16 compression parameterizes each filter in the original network by only 1 or 2 low-frequency values in the DCT frequency space, performs with similarly poor accuracy. Low rank decomposition (LRD) and HashedNets each yield similar performance at both 1/16 and 1/64 compression. Neither explicitly considers the smoothness inherent in learned convolutional filters, instead compressing the filters in the spatial domain. Our method, FreshNets, consistently outperforms all baselines, particularly at the higher compression rate as shown in Table 2(b). Using the same model in Table 1, Figure 3 shows more complete curves of test errors with multiple compression factors on the CIFAR10 and ROT datasets.\nVarying compression by frequency. As mentioned in Section 3, we allow a higher collision rate in the high frequency components than in the low frequency components for each filter. To demonstrate the utility of this scheme, we evaluate several hash compression schemes. Systematically, we set the compression rate of the jth frequency band rj with a parameterized function, i.e. rj = f(j).\n3We evaluate several frequency-sensitive schemes later in this section, but for this comprehensive evaluation we set frequency compression rates by a rescaled beta distribution with \u03b1 = 0.25 and \u03b2 = 2.5 for all layers.\nIn this experiment, we use the beta distribution: f(j;\u03b1, \u03b2) = Zx\u03b1\u22121(1 \u2212 x)\u03b2\u22121, where x= j+12k\u22121 is a real number between 0 and 1, k is the filter size, and Z is a normalizing factor such that the resulting distribution of parameters meets the target parameter budget K, i.e. \u22112k\u22122 j=0 rjNj = K. We adjust \u03b1 and \u03b2 to control the compression rate for each frequency region. As shown in Figure 4, we have multiple pairs of \u03b1 and \u03b2, each of which results in a different compression scheme. For example, if \u03b1 = 0.25 and \u03b2 = 2.5, the compression rate monotonically decreases as a function of component frequency, meaning more parameter sharing among high frequency components (blue curve in Figure 4).\nTo quickly evaluate the performance of each scheme, we use a simple four-layer FreshNets where the first two layers are DCT-hashed convolutional layers (with 5 \u00d7 5 filters) containing 32 and 64 feature maps respectively, and the last two layers are fully connected layers. We test FreshNets on CIFAR10 with each of the compression schemes shown in Figure 4. In each, weight sharing is limited to be within groups of similar frequencies, as described in Section 3, however number of unique weights shared within each group is varied. We denote the compression scheme with \u03b1, \u03b2 = 1 (red curve) as a frequency-oblivious scheme since it produces a uniform compression independent of frequency. In the inset bar plot in Figure 4, we report test error normalized by the test error of the frequency-oblivious scheme and averaged over compression rates 1, 1/2, 1/4, 1/16, 1/64, and 1/256. We can see that the proposed scheme with fewer shared weights allocated to high frequency components (represented by the blue curve) outperforms all other compression schemes. An inverse scheme where the high frequency regions have the lowest collision rate (purple curve) performs the worst. These empirical results fit our assumption that the low frequency components of a filter are more important than the high frequency components.\nFilter visualization. We investigate the smoothness of the learned convolutional filters in Figure 5 by visualizing the filter weights (first layer) of (a) a standard, uncompressed CNN, (b) FreshNets, and (c) HashedNets (with weight sharing in the spatial domain). For this experiment, we again apply a four layer network with two convolutional layers but adopt larger filters (11\u00d7 11) for better visualization. All three networks are trained on MNIST, and both FreshNets and HashedNets have 1/16 compression on the first convolutional layer. When plotting, we scale the values in each filter matrix to the range [0, 255]. Hence, white and black pixels stand for large positive and negative weights, respectively. We observe that, although more blurry due to the compression, the filter weights of FreshNets are still smooth while weights in HashedNets appear more chaotic."}, {"heading": "6 Conclusion", "text": "In this paper we present FreshNets, a method for learning convolutional neural networks with dramatically compressed model storage. Harnessing the hashing trick for parameter-free random weight sharing and leveraging the smoothness inherent in convolutional filters, FreshNets compresses parameters in a frequency-sensitive fashion such that significant model parameters (e.g. low-frequency components) are better preserved. As such, FreshNets preserves prediction accuracy significantly better than competing baselines at high compression rates."}], "references": [{"title": "Do deep nets really need to be deep", "author": ["J. Ba", "R. Caruana"], "venue": "In NIPS,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2014}, {"title": "Neural Networks for Pattern Recognition", "author": ["C.M. Bishop"], "venue": "Oxford University Press, Inc.,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1995}, {"title": "Efficient training of convolutional deep belief networks in the frequency domain for application to high-resolution 2d and 3d images", "author": ["T. Brosch", "R. Tam"], "venue": "Neural Computation, 27(1):211\u2013227,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Model compression", "author": ["C. Bucilua", "R. Caruana", "A. Niculescu-Mizil"], "venue": "KDD,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2006}, {"title": "Compressing neural networks with the hashing trick", "author": ["W. Chen", "J.T. Wilson", "S. Tyree", "K.Q. Weinberger", "Y. Chen"], "venue": "ICML,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2015}, {"title": "Torch7: A matlab-like environment for machine learning", "author": ["R. Collobert", "K. Kavukcuoglu", "C. Farabet"], "venue": "BigLearn, NIPS Workshop,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Low precision storage for deep learning", "author": ["M. Courbariaux", "Y. Bengio", "J.-P. David"], "venue": "arXiv preprint arXiv:1412.7024,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "A sparse johnson: Lindenstrauss transform", "author": ["A. Dasgupta", "R. Kumar", "T. Sarl\u00f3s"], "venue": "Proceedings of the forty-second ACM symposium on Theory of computing, pages 341\u2013350. ACM,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Imagenet: A large-scale hierarchical image database", "author": ["J. Deng", "W. Dong", "R. Socher", "L.-J. Li", "K. Li", "L. Fei-Fei"], "venue": "Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on, pages 248\u2013255. IEEE,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Predicting parameters in deep learning", "author": ["M. Denil", "B. Shakibi", "L. Dinh", "N. de Freitas"], "venue": "In NIPS,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2013}, {"title": "Exploiting linear structure within convolutional networks for efficient evaluation", "author": ["E.L. Denton", "W. Zaremba", "J. Bruna", "Y. LeCun", "R. Fergus"], "venue": "Advances in Neural Information Processing Systems, pages 1269\u20131277,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Neocognitron: A self-organizing neural network model for a mechanism of pattern recognition unaffected by shift in position", "author": ["K. Fukushima"], "venue": "Biological cybernetics, 36(4):193\u2013202,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1980}, {"title": "Compressing deep convolutional networks using vector quantization", "author": ["Y. Gong", "L. Liu", "M. Yang", "L. Bourdev"], "venue": "arXiv preprint arXiv:1412.6115,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Deep learning with limited numerical precision", "author": ["S. Gupta", "A. Agrawal", "K. Gopalakrishnan", "P. Narayanan"], "venue": "arXiv preprint arXiv:1502.02551,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": "arXiv preprint arXiv:1502.01852,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Speeding up convolutional neural networks with low rank expansions", "author": ["M. Jaderberg", "A. Vedaldi", "A. Zisserman"], "venue": "arXiv preprint arXiv:1405.3866,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2014}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "NIPS,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "An empirical evaluation of deep architectures on problems with many factors of variation", "author": ["H. Larochelle", "D. Erhan", "A.C. Courville", "J. Bergstra", "Y. Bengio"], "venue": "ICML, pages 473\u2013480,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "Speeding-up convolutional neural networks using fine-tuned cp-decomposition", "author": ["V. Lebedev", "Y. Ganin", "M. Rakhuba", "I. Oseledets", "V. Lempitsky"], "venue": "arXiv preprint arXiv:1412.6553,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "Unsupervised feature learning for audio classification using convolutional deep belief networks", "author": ["H. Lee", "P. Pham", "Y. Largman", "A.Y. Ng"], "venue": "Advances in neural information processing systems, pages 1096\u2013 1104,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2009}, {"title": "Fast training of convolutional networks through ffts", "author": ["M. Mathieu", "M. Henaff", "Y. LeCun"], "venue": "arXiv preprint arXiv:1312.5851,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2013}, {"title": "Discrete cosine transform: algorithms, advantages, applications", "author": ["K.R. Rao", "P. Yip"], "venue": "Academic press,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Learning separable filters", "author": ["R. Rigamonti", "A. Sironi", "V. Lepetit", "P. Fua"], "venue": "CVPR,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "Facenet: A unified embedding for face recognition and clustering", "author": ["F. Schroff", "D. Kalenichenko", "J. Philbin"], "venue": "arXiv preprint arXiv:1503.03832,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "Hash kernels for structured data", "author": ["Q. Shi", "J. Petterson", "G. Dror", "J. Langford", "A. Smola", "S. Vishwanathan"], "venue": "Journal of Machine Learning Research, 10:2615\u20132637, Dec.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2009}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["K. Simonyan", "A. Zisserman"], "venue": "CoRR, abs/1409.1556,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2014}, {"title": "Going deeper with convolutions", "author": ["C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich"], "venue": "arXiv preprint arXiv:1409.4842,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2014}, {"title": "Fast convolutional nets with fbfft: A gpu performance evaluation", "author": ["N. Vasilache", "J. Johnson", "M. Mathieu", "S. Chintala", "S. Piantino", "Y. LeCun"], "venue": "arXiv preprint arXiv:1412.7580,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2014}, {"title": "The jpeg still picture compression standard", "author": ["G.K. Wallace"], "venue": "Communications of the ACM, 34(4):30\u201344,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1991}, {"title": "Feature hashing for large scale multitask learning", "author": ["K. Weinberger", "A. Dasgupta", "J. Langford", "A. Smola", "J. Attenberg"], "venue": "ICML,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2009}, {"title": "Deep fried convnets", "author": ["Z. Yang", "M. Moczulski", "M. Denil", "N. de Freitas", "A. Smola", "L. Song", "Z. Wang"], "venue": "arXiv preprint arXiv:1412.7149,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2014}], "referenceMentions": [{"referenceID": 16, "context": "In the recent years convolutional neural networks (CNN) have lead to impressive results in object recognition [17], face verification [24] and audio classification [20].", "startOffset": 110, "endOffset": 114}, {"referenceID": 23, "context": "In the recent years convolutional neural networks (CNN) have lead to impressive results in object recognition [17], face verification [24] and audio classification [20].", "startOffset": 134, "endOffset": 138}, {"referenceID": 19, "context": "In the recent years convolutional neural networks (CNN) have lead to impressive results in object recognition [17], face verification [24] and audio classification [20].", "startOffset": 164, "endOffset": 168}, {"referenceID": 14, "context": "Problems that seemed impossibly hard only five years ago can now be solved at better than human accuracy [15].", "startOffset": 105, "endOffset": 109}, {"referenceID": 11, "context": "Although CNNs have been known for a quarter of a century [12], only recently have their superb generalization abilities been accepted widely across the machine learning and computer vision communities.", "startOffset": 57, "endOffset": 61}, {"referenceID": 8, "context": "This broad acceptance coincides with the release of very large collections of labeled data [9].", "startOffset": 91, "endOffset": 94}, {"referenceID": 25, "context": "In 2012, the first winner of the ImageNet competition that used a CNN had already 240MB of parameters and the most recent winning model, in 2014, required 567MB [26].", "startOffset": 161, "endOffset": 165}, {"referenceID": 9, "context": "[10] use low-rank decomposition of the weight matrices to reduce the effective number of parameters in the network.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4] and Ba et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "[1] show that complex models can be compressed into 1-layer neural networks.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "Independently, the model size of neural networks can be reduced effectively through reduced bit precision [7].", "startOffset": 106, "endOffset": 109}, {"referenceID": 4, "context": "[5], who show that weights of fully connected networks can be effectively compressed with the hashing trick [30].", "startOffset": 0, "endOffset": 3}, {"referenceID": 29, "context": "[5], who show that weights of fully connected networks can be effectively compressed with the hashing trick [30].", "startOffset": 108, "endOffset": 112}, {"referenceID": 21, "context": "We transform these filters into frequency domain with the discrete cosine transform (DCT) [22].", "startOffset": 90, "endOffset": 94}, {"referenceID": 1, "context": "During training, the hashed weights can be learned with simple back-propagation [2]\u2014the gradient of a hash bucket value is the sum of gradients of all hashed frequency components in that bucket.", "startOffset": 80, "endOffset": 83}, {"referenceID": 7, "context": "a the hashing trick) [8, 25, 30] has been previously studied as a technique for reducing model storage size.", "startOffset": 21, "endOffset": 32}, {"referenceID": 24, "context": "a the hashing trick) [8, 25, 30] has been previously studied as a technique for reducing model storage size.", "startOffset": 21, "endOffset": 32}, {"referenceID": 29, "context": "a the hashing trick) [8, 25, 30] has been previously studied as a technique for reducing model storage size.", "startOffset": 21, "endOffset": 32}, {"referenceID": 29, "context": "As shown in [30], a key property of feature hashing is its preservation of inner product operations, where inner products after hashing produce the correct pre-hash inner product in expectation: E[\u03c6(x)\u03c6(y)]\u03c6 = x>y.", "startOffset": 12, "endOffset": 16}, {"referenceID": 24, "context": "The information loss induced by hash collision is much less severe for sparse feature vectors and can be counteracted through multiple hashing [25] or larger hash tables [30].", "startOffset": 143, "endOffset": 147}, {"referenceID": 29, "context": "The information loss induced by hash collision is much less severe for sparse feature vectors and can be counteracted through multiple hashing [25] or larger hash tables [30].", "startOffset": 170, "endOffset": 174}, {"referenceID": 21, "context": "Discrete Cosine Transform (DCT) [22].", "startOffset": 32, "endOffset": 36}, {"referenceID": 28, "context": "Methods built on the DCT are widely used for compressing images and movies, including forming the standard technique for JPEG [29].", "startOffset": 126, "endOffset": 130}, {"referenceID": 21, "context": "Though highly related to the discrete Fourier transformation (DFT), DCT is often preferable for compression tasks because of its spectral compaction property where weights for most images tend to be concentrated in a few low-frequency components of the DCT [22].", "startOffset": 257, "endOffset": 261}, {"referenceID": 4, "context": "[5], we achieve smaller models by randomly forcing weights throughout the network to share identical values.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5] advocate use of the hashing trick to (pseudo-)randomly assign shared parameters.", "startOffset": 0, "endOffset": 3}, {"referenceID": 16, "context": "In the spatial domain CNN filters are smooth [17] due to the local pixel smoothness in natural images.", "startOffset": 45, "endOffset": 49}, {"referenceID": 9, "context": "[10] learns parameters in fully-connected layers after decomposition into two low-rank matrices, i.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "Two works propose to approximate convolutional filters by a weighted linear combination of basis filters [23, 16].", "startOffset": 105, "endOffset": 113}, {"referenceID": 15, "context": "Two works propose to approximate convolutional filters by a weighted linear combination of basis filters [23, 16].", "startOffset": 105, "endOffset": 113}, {"referenceID": 10, "context": "Further speedup can be achieved by learning rank-one basis filters so that the convolution operations are very cheap to compute [11, 19].", "startOffset": 128, "endOffset": 136}, {"referenceID": 18, "context": "Further speedup can be achieved by learning rank-one basis filters so that the convolution operations are very cheap to compute [11, 19].", "startOffset": 128, "endOffset": 136}, {"referenceID": 10, "context": "[11] advocate decomposing the four-dimensional tensor of the filter weights into a sum of different rank-one, four-dimensional tensors.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "Other works focus entirely on compressing the fully-connected layers of CNNs [13, 31].", "startOffset": 77, "endOffset": 85}, {"referenceID": 30, "context": "Other works focus entirely on compressing the fully-connected layers of CNNs [13, 31].", "startOffset": 77, "endOffset": 85}, {"referenceID": 26, "context": "However, with the trend toward architectures with fewer fully connected layers and additional convolutional layers [27], compression of filters is of increased importance.", "startOffset": 115, "endOffset": 119}, {"referenceID": 20, "context": "Another technique for speeding up convolutional neural network evaluation is computing convolutions in the Fourier frequency domain, as convolution in the spatial domain is equivalent to (comparatively lower-cost) element-wise multiplication in the frequency domain [21, 28].", "startOffset": 266, "endOffset": 274}, {"referenceID": 27, "context": "Another technique for speeding up convolutional neural network evaluation is computing convolutions in the Fourier frequency domain, as convolution in the spatial domain is equivalent to (comparatively lower-cost) element-wise multiplication in the frequency domain [21, 28].", "startOffset": 266, "endOffset": 274}, {"referenceID": 20, "context": "[21] convert the filter to its frequency domain of size n \u00d7 n by oversampling the frequencies, which is necessary for doing element-wise multiplication with a larger image but also increases the memory overhead at test time.", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "Training in the Fourier frequency domain may be advantageous for similar reasons, particularly when convolutions are being performed over large 3-D volumes [3].", "startOffset": 156, "endOffset": 159}, {"referenceID": 4, "context": "Most relevant to this work is HashedNets [5] which compresses the fully connected layers of deep neural networks.", "startOffset": 41, "endOffset": 44}, {"referenceID": 16, "context": "To improve accuracy on CIFAR100, we augment by horizontal reflection and cropping [17], resulting in 0.", "startOffset": 82, "endOffset": 86}, {"referenceID": 17, "context": "For the MNIST variants [18], each variation either reduces the training size (MNIST-07) or amends the original digits by rotation (ROT), background superimposition (BGRAND and BG-IMG), or a combination thereof (BG-ROT).", "startOffset": 23, "endOffset": 27}, {"referenceID": 4, "context": "We compare the proposed FreshNets with four baseline methods: HashedNets [5], low-rank decomposition (LRD) [10], filter dropping (DropFilt) and frequency dropping (DropFreq).", "startOffset": 73, "endOffset": 76}, {"referenceID": 9, "context": "We compare the proposed FreshNets with four baseline methods: HashedNets [5], low-rank decomposition (LRD) [10], filter dropping (DropFilt) and frequency dropping (DropFreq).", "startOffset": 107, "endOffset": 111}, {"referenceID": 9, "context": "Additionally, we compare against low-rank decomposition of the convolutional filters [10].", "startOffset": 85, "endOffset": 89}, {"referenceID": 10, "context": "Following the method in [11], we unfold the four-dimensional filter tensor to form a two dimensional matrix on which we apply the low-rank decomposition.", "startOffset": 24, "endOffset": 28}, {"referenceID": 5, "context": "All methods were implemented using Torch7 [6] and run on NVIDIA GTX TITAN graphics cards with 2688 cores and 6GB of global memory.", "startOffset": 42, "endOffset": 45}, {"referenceID": 6, "context": "The compression rates of all methods could be further improved by learning and storing parameters in lower precision [7, 14].", "startOffset": 117, "endOffset": 124}, {"referenceID": 13, "context": "The compression rates of all methods could be further improved by learning and storing parameters in lower precision [7, 14].", "startOffset": 117, "endOffset": 124}, {"referenceID": 4, "context": "3 For all baselines, we apply HashedNets [5] to the fully connected layer at the corresponding level of compression.", "startOffset": 41, "endOffset": 44}, {"referenceID": 4, "context": "For all methods, the fully connected layer (top layer) is compressed by HashedNets [5] at the corresponding compression rate.", "startOffset": 83, "endOffset": 86}], "year": 2015, "abstractText": "Convolutional neural networks (CNN) are increasingly used in many areas of computer vision. They are particularly attractive because of their ability to \u201cabsorb\u201d great quantities of labeled data through millions of parameters. However, as model sizes increase, so do the storage and memory requirements of the classifiers. We present a novel network architecture, Frequency-Sensitive Hashed Nets (FreshNets), which exploits inherent redundancy in both convolutional layers and fully-connected layers of a deep learning model, leading to dramatic savings in memory and storage consumption. Based on the key observation that the weights of learned convolutional filters are typically smooth and low-frequency, we first convert filter weights to the frequency domain with a discrete cosine transform (DCT) and use a low-cost hash function to randomly group frequency parameters into hash buckets. All parameters assigned the same hash bucket share a single value learned with standard back-propagation. To further reduce model size we allocate fewer hash buckets to high-frequency components, which are generally less important. We evaluate FreshNets on eight data sets, and show that it leads to drastically better compressed performance than several relevant baselines.", "creator": "LaTeX with hyperref package"}}}