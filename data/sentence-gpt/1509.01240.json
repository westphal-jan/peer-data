{"id": "1509.01240", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Sep-2015", "title": "Train faster, generalize better: Stability of stochastic gradient descent", "abstract": "We show that any model trained by a stochastic gradient method with few iterations has vanishing generalization error. We prove this by showing the method is algorithmically stable in the sense of Bousquet and Elisseeff. Our analysis only employs elementary tools from convex and continuous optimization for the first time. The main findings in this article are based on our previous work. The method also provides a means for inferring Bousquet and Elisseeff (with special exception that the original stochastic gradient algorithm used by Dallinoff and his collaborators) for the two stochastic models. A single, highly effective one is a simple stochastic gradient method for estimating and understanding the fundamental problem of the first two stochastic models (the first one is linear in terms of the direction of the direction of the left hand) and a second one is a simple linear model for generating linear models in three different directions.\n\n\n\nIn order to demonstrate the ability to perform a stochastic gradient optimization, we have implemented a single optimization method with some key assumptions: First, we set the first iteration to the left. Second, we add the second one to the first iteration of the stochastic gradient algorithm. Third, we add the final one to the second iteration of the stochastic gradient algorithm. These assumptions also provide important features such as the potential accuracy of the first model.\nThe first version of the algorithm uses an explicit linear model. The first iteration of the stochastic gradient algorithm is used as a general algorithm to determine the average distance that is generated on all dimensions of the surface by a single stochastic gradient algorithm. The first iteration of the algorithm uses an explicit linear model.\nThe second iteration of the stochastic gradient algorithm uses a single linear model. The first iteration of the stochastic gradient algorithm is used as a general algorithm to determine the average distance that is generated on all dimensions of the surface by a single stochastic gradient algorithm. The first iteration of the stochastic gradient algorithm is used as a general algorithm to determine the average distance that is generated on all dimensions of the surface by a single stochastic gradient algorithm. The first iteration of the stochastic gradient algorithm is used as a general algorithm to determine the average distance that is generated on all dimensions of the surface by a single stochastic gradient algorithm. The first iteration of the stochastic gradient algorithm is used as a general algorithm to determine the average distance that is generated on all dimensions of the", "histories": [["v1", "Thu, 3 Sep 2015 19:53:40 GMT  (31kb)", "http://arxiv.org/abs/1509.01240v1", null], ["v2", "Sun, 7 Feb 2016 17:06:58 GMT  (444kb,D)", "http://arxiv.org/abs/1509.01240v2", null]], "reviews": [], "SUBJECTS": "cs.LG math.OC stat.ML", "authors": ["moritz hardt", "ben recht", "yoram singer"], "accepted": true, "id": "1509.01240"}, "pdf": {"name": "1509.01240.pdf", "metadata": {"source": "CRF", "title": "Stability of stochastic gradient descent", "authors": ["Moritz Hardt", "Benjamin Recht", "Yoram Singer"], "emails": ["mrtz@google.com", "brecht@berkeley.edu,", "singer@google.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 9.\n01 24\n0v 1\n[ cs\n.L G\n] 3\nS ep\nApplying our results to the convex case, we provide new explanations for why multiple epochs of stochastic gradient descent generalize well in practice. In the nonconvex case, we provide a new interpretation of common practices in neural networks, and provide a formal rationale for stability-promoting mechanisms in training large, deep models. Conceptually, our findings underscore the importance of reducing training time beyond its obvious benefit."}, {"heading": "1 Introduction", "text": "The most widely used optimization method in machine learning practice is stochastic gradient method (SGM). Stochastic gradient methods aim to minimize the empirical risk of a model by repeatedly computing the gradient of a loss function on a single training example, or a batch of few examples, and updating the model parameters accordingly. SGM is scalable, robust, and performs well across many different domains ranging from smooth and strongly convex problems to complex non-convex objectives.\nIn a nutshell, our results establish that:\nAny model trained with stochastic gradient method in a reasonable amount of time attains small generalization error.\nAs training time is inevitably limited in practice, our results help to explain the strong generalization performance of stochastic gradient methods observed in practice. More concretely, we bound the generalization error of a model in terms of the number of iterations that stochastic gradient method took in order to train the model. Our main analysis tool is to employ the notion of algorithmic stability due to Bousquet and Elisseeff [4]. We demonstrate that the stochastic gradient method is\n\u2217Email: mrtz@google.com \u2020Email: brecht@berkeley.edu, work performed at Google. \u2021Email: singer@google.com\nstable provided that the objective is relatively smooth and the number of steps taken is sufficiently small.\nIt is common in practice to perform a linear number of steps in the size of the sample and to access each data point multiple times. Our results show in a broad range of settings that, provided the number of iterations is linear in the number of data points, the generalization error is bounded by a vanishing function of the sample size. The results hold true even for complex models with large number of parameters and no explicit regularization term in the objective. Namely, fast training time by itself is sufficient to prevent overfitting.\nOur bounds are algorithm specific: Since the number of iterations we allow can be larger than the sample size, an arbitrary algorithm could easily achieve small training error by memorizing all training data with no generalization ability whatsoever. In contrast, if the stochastic gradient method manages to overfit the training data in a reasonable number of iterations, it is still guaranteed to generalize.\nConceptually, we show that minimizing training time is not only beneficial for the obvious computational advantages, but in addition has the important by-product of decreasing generalization error. Consequently, it may make sense for practitioners to focus on minimizing training time, for instance, by designing model architectures for which stochastic gradient method converges fastest to a desired error level."}, {"heading": "1.1 Our contributions", "text": "Our focus is on generating generalization bounds for models learned with stochastic gradient descent. Recall that the generalization bound is the expected difference between the error a model incurs on a training set versus the error incurred on a new data point, sampled from the same distribution that generated the training data. Throughout, we assume we are training models using n sampled data points.\nOur results build on a fundamental connection between the generalization error of an algorithm and its stability properties. Roughly speaking, an algorithm is stable if the training error it achieves varies only slightly if we change any single training data point. The precise notion of stability we use is known as uniform stability due to [4]. It states that a randomized algorithm A is uniformly stable if for all data sets differing in only one element, the learned models produce nearly the same predictions. We review this method in Section 2, and provide a new adaptation of this theory to iterative algorithms.\nIn Section 3, we show that stochastic gradient is uniformly stable, and our techniques mimic its convergence proofs. For convex loss functions, we prove that the stability measure decreases as a function of the sum of the step sizes. For strongly convex loss functions, we show that stochastic gradient is stable, even if we train for an arbitrarily long time.\nMore surprisingly, our results carry over to the case where the loss-function is non-convex. In this case we show that the method generalizes provided the steps are sufficiently small and the number of iterations is not too large. More specifically, we show the number of steps of stochastic gradient can grow as nc for a small c > 1. This provides some explanation as to why neural networks can be trained for multiple epochs of stochastic gradient and still exhibit excellent generalization. In Section 4, we furthermore show that various heuristics used in practice, especially in the deep learning community, help to increase the stability of stochastic gradient method. For example, the popular dropout scheme [19, 39] improves all of our bounds. Similarly, \u21132-regularization improves\nthe exponent of n in our non-convex result. In fact, we can drive the exponent arbitrarily close to 1/2 while preserving the non-convexity of the problem.\nWe can combine our bounds on the generalization error of stochastic gradient method with optimization bounds quantifying the convergence of the empirical loss achieved by SGM. In Section 5, we show that models trained for multiple epochs match classic bounds for stochastic gradient [27,28]."}, {"heading": "1.2 Related work", "text": "There is a venerable line of work on stability and generalization dating back more than thirty years [4, 8, 18, 25, 38]. The landmark work by Bousquet and Elisseeff [4] introduced the notion of uniform stability that we rely on. They showed that several important classification techniques are uniformly stable. In particular, under certain regularity assumptions, it was shown that the optimizer of a regularized empirical loss minimization problem is uniformly stable. Previous work generally applies only to the exact minimizer of specific optimization problems. It is not immediately evident on how to compute a generalization bound for an approximate minimizer such as one found by using stochastic gradient. Subsequent work studied stability bounds for randomized algorithms but focused on random perturbations of the cost function, such as those induced by bootstrapping or bagging [9]. This manuscript differs from this foundational work in that it derives stability bounds about the learning procedure, analyzing algorithmic properties that induce stability.\nStochastic gradient descent, of course, is closely related to our inquiry. Classic results by Nemirovski and Yudin show that the stochastic gradient method produces are nearly optimal for empirical risk minimization of convex loss functions [11,26\u201328]. These results have been extended by many machine learning researchers, yielding tighter bounds and probabilistic guarantees [13,14,34]. However, there is an important limitation of all of this prior art. The derived generalization bounds only hold for single passes over the data. That is, in order for the bounds to be valid, each training example must be used no more than once in a stochastic gradient update. In practice, of course, one tends to run multiple epochs of the stochastic gradient method. Our results resolve this issue by combining stability with optimization error. We use the foundational results to estimate the error on the empirical risk and then use stability to derive a deviation from the true risk. This enables us to study the risk incurred by multiple epochs and provide simple analyses of regularization methods for convex stochastic gradient. We compare our results to this related work in Section 5. We note that Rosasco and Villa obtain risk bounds for least squares minimization with an incremental gradient method in terms of the number of epochs [36]. These bounds are akin to our study in Section 5, although our results are incomparable due to various different assumptions.\nFinally, we note that in the non-convex case, the stochastic gradient method is remarkably successful for training large neural networks [2, 19]. However, our theoretical understanding of this method is limited. Several authors have shown that the stochastic gradient method finds a stationary point of nonconvex cost functions [12, 21]. Beyond asymptotic convergence to stationary points, little is known about finding models with low training or generalization error in the nonconvex case. There have recently been several important studies investigating optimal training of neural nets. For example Livni et al. show that networks with polynomial activations can be learned in a greedy fashion [24]. Janzamin et al. [16] show that two layer neural networks can be learned using tensor methods. Arora et al. [1] show that two-layer sparse coding dictionaries can be learned via stochastic gradient. Our work complements these developments: rather than providing new insights into mechanisms that yield low training error, we provide insights into mechanisms\nthat yield low generalization error. If one can achieve low training error quickly on a nonconvex problem with stochastic gradient, our results guarantee that the resulting model generalizes well."}, {"heading": "2 Stability of randomized iterative algorithms", "text": "Consider the following general setting of supervised learning. There is an unknown joint distribution D over pairs of labeled examples from a product space X \u00d7 Y. We receive a sample S = (z1, . . . , zn) of n examples drawn i.i.d. from D. Our goal is to find a model w with small population risk, defined as:\nR[w] def = Ez\u223cD f(w; z) .\nHere, where f is a loss function and f(w; z) designates the loss of the model described by w encountered on example z.\nSince we cannot measure the objective R[w] directly, we instead use a sample-averaged proxy, the empirical risk, defined as\nRS [w] def =\n1\nn\nn \u2211\ni=1\nf(w; zi) ,\nThe generalization error of a model w is the difference RS [w]\u2212R[w]. When w = A(S) is chosen as a function of the data by a potentially randomized algorithm A it makes sense to consider the expected generalization error\n\u01ebgen def = E[RS [A(S)] \u2212R[A(S)]] , (2.1)\nwhere the expectation is over the randomness of A and the sample S. In order to bound the generalization error of an algorithm, we employ with the following notion of uniform stability in which we allow randomized algorithms as well.\nDefinition 2.1. A randomized algorithm A is \u01eb-uniformly stable if for all data sets S, S\u2032 \u2208 Zn such that S and S\u2032 differ in at most one example, we have\nsup z EA\n[ f(A(S); z) \u2212 f(A(S\u2032); z) ] \u2264 \u01eb . (2.2)\nHere, the expectation is taken only over the internal randomness of A. We will denote by \u01ebstab(A,n) the infimum over all \u01eb for which (2.2) holds. We will omit the tuple (A,n) when it is clear from the context.\nWe recall the important theorem that uniform stability implies generalization in expectation. Since our notion of stability differs slightly from existing ones with respect to the randomness of the algorithm, we include a proof for the sake of completeness. The proof is very similar to the argument in Lemma 7 of [4].\nTheorem 2.2 (Generalization in expectation). Let A be \u01eb-uniformly stable. Then,\n|ES,A [RS[A(S)] \u2212R[A(S)]]| \u2264 \u01eb .\nProof. Denote by S = (z1, . . . , zn) and S \u2032 = (z\u20321, . . . , z \u2032 n) two independent random samples and let S(i) = (z1, . . . , zi\u22121, z \u2032 i, zi+1, . . . , zn) be the sample that is identical to S except in the i\u2019th example where we replace zi with z \u2032 i. With this notation, we get that\nES EA [RS [A(S)]] = ES EA\n[\n1\nn\nn \u2211\ni=1\nf(A(S); zi)\n]\n= ES ES\u2032 EA\n[\n1\nn\nn \u2211\ni=1\nf(A(S(i)); z\u2032i)\n]\n= ES ES\u2032 EA\n[\n1\nn\nn \u2211\ni=1\nf(A(S); z\u2032i)\n]\n+ \u03b4\n= ES EA [R[A(S)]] + \u03b4,\nwhere we can express \u03b4 as\n\u03b4 = ES ES\u2032 EA\n[\n1\nn\nn \u2211\ni=1\nf(A(S(i)); z\u2032i)\u2212 1\nn\nn \u2211\ni=1\nf(A(S); z\u2032i)\n]\n.\nFurthermore, taking the supremum over any two data sets S, S\u2032 differing in only one sample, we can bound the difference as\n|\u03b4| \u2264 sup S,S\u2032,z EA\n[ f(A(S); z) \u2212 EA f(A(S\u2032); z) ] \u2264 \u01eb,\nby our assumption on the uniform stability of A. The claim follows.\nTheorem 2.2 proves that if an algorithm is uniformly stable, then its generalization is small. We now turn to some properties of iterative algorithms that control their uniform stability."}, {"heading": "2.1 Properties of update rules", "text": "We consider general update rules of the form G : \u2126 \u2192 \u2126 which map a point w \u2208 \u2126 in the parameter space to another point G(w). The most common update is the gradient update rule\nG(w) = w \u2212 \u03b1\u2207f(w) ,\nwhere \u03b1 \u2265 0 is a step size and f : \u2126 \u2192 R is a function that we want to optimize. The canonical update rule we will consider in this manuscript is an incremental gradient update, where G(w) = w \u2212 \u03b1\u2207f(w) for some convex function f . We will return to a detailed discussion of this specific update in the sequel, but the reader should keep this particular example in mind throughout the remainder of this section.\nThe following two definitions provide the foundation of our analysis of how two different sequences of update rules diverge when iterated from the same starting point. These definitions will ultimately be useful when analyzing the stability of stochastic gradient descent.\nDefinition 2.3. An update rule is \u03b7-expansive if\nsup v,w\u2208\u2126 \u2016G(v) \u2212G(w)\u2016 \u2016v \u2212w\u2016 \u2264 \u03b7 . (2.3)\nDefinition 2.4. An update rule is \u03c3-bounded if\nsup w\u2208\u2126\n\u2016w \u2212G(w)\u2016 \u2264 \u03c3 . (2.4)\nWith these two properties, we can establish the following lemma of how a sequence of updates to a model diverge when the training set is perturbed.\nLemma 2.5 (Growth recursion). Fix an arbitrary sequence of updates G1, . . . , GT and another sequence G\u20321, . . . , G \u2032 T . Let w0 = w \u2032 0 be a starting point in \u2126 and define \u03b4t = \u2016w\u2032t \u2212 wt\u2016 where wt, w\u2032t are defined recursively through\nwt+1 = Gt(wt) w \u2032 t+1 = Gt(w \u2032 t) . (t > 0)\nThen, we have the recurrence relation\n\u03b40 = 0\n\u03b4t+1 \u2264 { \u03b7\u03b4t Gt = G \u2032 t is \u03b7-expansive\nmin(\u03b7, 1)\u03b4t + 2\u03c3t Gt and G \u2032 t are \u03c3-bounded, Gt is \u03b7 expansive\n(t > 0)\nProof. The first bound on \u03b4t follow directly from the assumption that Gt = G \u2032 t and the definition of expansiveness. For the second bound, recall from Definition 2.4 that if Gt and G \u2032 t are \u03c3-bounded, then by the triangle inequality,\n\u03b4t+1 = \u2016G(wt)\u2212G\u2032(w\u2032t)\u2016 \u2264 \u2016G(wt)\u2212 wt + w\u2032t \u2212G\u2032(w\u2032t)\u2016+ \u2016wt \u2212 w\u2032t\u2016 \u2264 \u03b4t + \u2016G(wt)\u2212 wt\u2016+ \u2016G(w\u2032t)\u2212 w\u2032t\u2016 \u2264 \u03b4t + 2\u03c3 ,\nwhich gives half of the second bound. We can alternatively bound \u03b4t+1 as\n\u03b4t+1 = \u2016Gt(wt)\u2212G\u2032t(w\u2032t)\u2016 = \u2016Gt(wt)\u2212Gt(w\u2032t) +Gt(w\u2032t)\u2212G\u2032t(w\u2032t)\u2016 \u2264 \u2016Gt(wt)\u2212Gt(w\u2032t)\u2016+ \u2016Gt(w\u2032t)\u2212G\u2032t(w\u2032t)\u2016 \u2264 \u2016Gt(wt)\u2212Gt(w\u2032t)\u2016+ \u2016w\u2032t \u2212Gt(w\u2032t)\u2016+ \u2016w\u2032t \u2212G\u2032t(w\u2032t)\u2016 \u2264 \u03b7\u03b4t + 2\u03c3 .\nWe now turn to using these lemmas to analyze one of the core algorithms in statistical learning: the stochastic gradient method."}, {"heading": "3 Stability of Stochastic Gradient Descent", "text": "Given n labeled examples S = (z1, . . . , zn) where zi = (xi, yi) \u2208 X \u00d7 Y, consider a decomposable objective function\nf(w) = 1\nn\nn \u2211\ni=1\nf(w; (xi, yi)),\nwhere f(w; (xi, yi)) denotes the loss of w on the example (xi, yi). The stochastic gradient update for this problem with learning rate \u03b1t > 0 is given by\nwt+1 = wt \u2212 \u03b1t\u2207wf(wt; zit) .\nStochastic gradient method (SGM) is the algorithm resulting from performing stochastic gradient updates T times where the indices it are randomly chosen. There are two popular schemes for choosing the examples\u2019 indices. One is to pick it uniformly at random in {1, . . . , n} at each step. The other is to choose a random permutation over {1, . . . , n} and cycle through the examples repeatedly in the order determined by the permutation. Our results hold for both variants.\nIn parallel with the previous section the stochastic gradient method is akin to applying the gradient update rule defined as follows.\nDefinition 3.1. For a nonnegative step size \u03b1 \u2265 0 and a function f : \u2126 \u2192 R, we define the gradient update rule Gf,\u03b1 as\nGf,\u03b1(w) = w \u2212 \u03b1\u2207f(w) ."}, {"heading": "3.1 Proof idea: Stability of stochastic gradient method", "text": "In order to prove that the stochastic gradient method is stable, we will analyze the output of the algorithm on two data sets that differ in precisely one location. Note that if the loss function is L-Lipschitz, we have E |f(w; ) \u2212 f(w\u2032; z)| \u2264 LE \u2016w \u2212 w\u2032\u2016 for any w and w\u2032. Hence, it suffices to analyze how wt and w \u2032 t diverge in the domain as a function of time t. Recalling that wt is obtained from wt\u22121 via a gradient update, our goal is to bound \u03b4t = \u2016wt\u2212w\u2032t\u2016 recursively and in expectation as a function of \u03b4t\u22121.\nThere are two cases to consider. In the first case, SGM selects the index of an example at step t on which is identical in S and S\u2032. In this case, the gradients added to wt and w \u2032 t are identical. Unfortunately, it could still be the case that \u03b4t grows. Below, we will show how to control \u03b4t in terms of the convexity and smoothness properties of the stochastic gradients.\nThe second case to consider is when SGM selects the one example to update in which S and S\u2032 differ. Note that this happens only with probability 1/n if examples are selected randomly. In this case, we simply bound the increase in \u03b4t by the norm of the two gradient \u2207f(wt\u22121, z) and \u2207f(w\u2032t\u22121; z\u2032). The sum of the norms is bounded by 2\u03b1tL and we obtain \u03b4t \u2264 \u03b4t +2\u03b1tL. Combining the two cases, we can then solve a simple recurrence relation to obtain a bound on \u03b4T .\nThis simple approach suffices to obtain the desired result in the convex case, but there are additional difficulties in the non-convex case. Here, we need to use an intriguing stability property of stochastic gradient method. Specifically, the first time step t0 at which SGM even encounters the example in which S and S\u2032 differ is a random variable in {1, . . . , n} which tends to be relatively large. Specifically, for any m \u2208 {1, . . . , n}, the probability that t0 \u2264 m is upper bounded by m/n. This allows us to argue that SGM has a long \u201cburn-in period\u201d where \u03b4t does not grow at all. Once \u03b4t begins to grow, the step size has already decayed allowing us to obtain a non-trivial bound.\nWe now turn to making this argument precise."}, {"heading": "3.2 Expansion properties of stochastic gradients", "text": "Let us now record some of the core properties of the stochastic gradient update. The gradient update rule is bounded provided that the function f satisfies the following common Lipschitz condition.\nDefinition 3.2. We say that f is L-Lipschitz if for all points u in the domain of f we have \u2016\u2207f(x)\u2016 \u2264 L. This implies that\n|f(u)\u2212 f(v)| \u2264 L\u2016u\u2212 v\u2016 . (3.1)\nLemma 3.3. Assume that f is L-Lipschitz. Then, the gradient update Gf,\u03b1 is (\u03b1L)-bounded.\nProof. By our Lipschitz assumption, \u2016w \u2212Gf,\u03b1(w)\u2016 = \u2016\u03b1\u2207f(w)\u2016 \u2264 \u03b1L .\nWe now turn to expansiveness. As we will see shortly, different expansion properties are achieved for non-convex, convex, and strongly convex functions.\nDefinition 3.4. A function f : \u2126 \u2192 R is convex if for all u, v \u2208 \u2126 we have\nf(u) \u2265 f(v) + \u3008\u2207f(v), u\u2212 v\u3009 .\nDefinition 3.5. A function f : \u2126 \u2192 R is \u03b3-strongly convex if for all u, v \u2208 \u2126 we have\nf(u) \u2265 f(v) + \u3008\u2207f(v), u\u2212 v\u3009+ \u03b3 2 \u2016u\u2212 v\u20162 .\nThe following standard notion of smoothness leads to a bound on how expansive the gradient update is.\nDefinition 3.6. A function f : \u2126 \u2192 R is \u03b2-smooth if for all for all u, v \u2208 \u2126 we have\n\u2016\u2207f(u)\u2212\u2207f(v)\u2016 \u2264 \u03b2\u2016u\u2212 v\u2016 . (3.2)\nIn general, smoothness will imply that the gradient updates cannot be overly expansive. When the function is also convex and the step size is sufficiently small the gradient update becomes non-expansive. When the function is additionally strongly convex, the gradient update becomes contractive in the sense that \u03b7 will be less than one and u and v will actually shrink closer to one another. The majority of the following results can be found in several textbooks and monographs. Notable references are Polyak [33] and Nesterov [29]. We include proofs in the appendix for completeness.\nLemma 3.7. Assume that f is \u03b2-smooth. Then, the following properties hold.\n1. Gf,\u03b1 is (1 + \u03b1\u03b2)-expansive.\n2. Assume in addition that f is convex. Then, for any \u03b1 \u2264 2/\u03b2, the gradient update Gf,\u03b1 is 1-expansive.\n3. Assume in addition that f is \u03b3-strongly convex. Then, for \u03b1 \u2264 2\u03b2+\u03b3 , Gf,\u03b1 is ( 1\u2212 2\u03b1\u03b2\u03b3\u03b2+\u03b3 ) -\nexpansive.\nWe will also make use of the following convenient lemma for analyzing the stability of the stochastic gradient method.\nLemma 3.8. Assume that the loss function f(\u00b7 ; z) is L-Lipschitz for all z. Let S and S\u2032 be two samples of size n differing in only a single example. Denote by wT and w \u2032 T the output of T steps of SGM on S and S\u2032, respectively. Then, for every z \u2208 X \u00d7 Y and every t0 \u2208 {0, 1, . . . , n}, under both the random update rule and the random permutation rule, we have\nE \u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223 \u2223 \u2264 t0 n + LE [\u03b4T | \u03b4t0 = 0] .\nProof. Let S and S\u2032 be two samples of size n differing in only a single example, and let z \u2208 X \u00d7 Y be an arbitrary example. Consider running SGM on sample S and S\u2032, respectively. As stated, wT and w \u2032 T denote the corresponding outputs of SGM. Let E = 1[\u03b4t0 = 0] denote the event that \u03b4t0 = 0. We have,\nE\n\u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; z) \u2223 \u2223 = P {E}E [ \u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; z) \u2223 \u2223 | E ]\n+ P {Ec}E [ \u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223 \u2223 | Ec ]\n\u2264 E [ \u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; z) \u2223 \u2223 | E ] + P {Ec} \u2264 LE [\u2225\n\u2225wT \u2212 w\u2032T \u2225 \u2225 | E ] + P {Ec} .\nThe first inequality uses the fact that |f(wT ; z)\u2212 f(w\u2032T ; z)| \u2264 1, from our assumption on the range of the function f. The second inequality follows from the Lipschitz assumption.\nIt remains to bound P {Ec} . Toward that end, let i\u2217 \u2208 {1, . . . , n} denote the position in which S and S\u2032 differ and consider the random variable I assuming the index of the first time step in which SGM uses the example zi\u2217 . Note that when I > t0, then we must have that \u03b4t0 = 0, since the execution on S and S\u2032 is identical until step t0. Hence,\nP {Ec} = P {\u03b4t0 6= 0} \u2264 P {I \u2264 t0} .\nUnder the random permutation rule, I is a uniformly random number in {1, . . . , n} and therefore\nP {I \u2264 t0} = t0 n .\nThis proves the claim we stated for the random permutation rule. For the random selection rule, we have by the union bound P {I \u2264 t0} \u2264 \u2211t0 t=1 P {I = t} = t0n . This completes the proof.\nHenceforth we will no longer mention which random selection rule we use as the proofs are almost identical for both rules."}, {"heading": "3.3 Convex optimization", "text": "We begin with a simple stability bound for convex loss minimization via stochastic gradient method.\nTheorem 3.9. Assume that the loss function f(\u00b7 ; z) \u2208 [0, 1] is \u03b2-smooth, convex and L-Lipschitz for every z. Suppose that we run SGM with step sizes \u03b1t \u2264 2/\u03b2 for T steps. Then, SGM satisfies uniform stability with\n\u01ebstab \u2264 2L2\nn\nT \u2211\nt=1\n\u03b1t .\nProof. Let S and S\u2032 be two samples of size n differing in only a single example. Consider the gradient updates G1, . . . , GT and G \u2032 1, . . . , G \u2032 T induced by running SGM on sample S and S\n\u2032, respectively. Let wT and w \u2032 T denote the corresponding outputs of SGM.\nWe now fix an example z \u2208 X \u00d7 Y and apply Lemma 3.8 to f(\u00b7 ; z) with t0 = 0, to get\nE \u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223 \u2223 \u2264 LE [\u03b4T | \u03b40 = 0] = LE [\u03b4T ] , (3.3)\nwhere \u03b4t = \u2016wT \u2212 w\u2032T \u2016. Observe that at step t, with probability 1 \u2212 1/n, the example selected by SGM is the same in both S and S\u2032. In this case we have that Gt = G \u2032 t and we can use the 1- expansivity of the update rule Gt which follows from Lemma 3.7.2 using the fact that the objective function is convex and that \u03b1t \u2264 2/\u03b2. With probability 1/n the selected example is different in which case we use that both Gt and G \u2032 t are \u03b1tL-bounded as a consequence of Lemma 3.3. Hence, we can apply Lemma 2.5 and linearity of expectation to conclude that for every t,\nE [\u03b4t+1] \u2264 ( 1\u2212 1 n ) E [\u03b4t] + 1 n E [\u03b4t] + 2\u03b1tL n = E [\u03b4t] + 2L\u03b1t n . (3.4)\nUnraveling the recursion gives\nE [\u03b4T ] \u2264 2L\nn\nT \u2211\nt=1\n\u03b1t .\nPlugging this back into equation (3.3), we obtain\nE\n\u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223\n\u2223 \u2264 2L 2\nn\nT \u2211\nt=1\n\u03b1t .\nSince this bounds holds for all S, S\u2032 and z, we obtain the desired bound on the uniform stability."}, {"heading": "3.4 Strongly convex optimization", "text": "In the strongly convex case our bound has no dependence on the number of steps at all.\nTheorem 3.10. Assume that the loss function f(\u00b7 ; z) \u2208 [0, 1] is \u03b3-strongly convex, L-Lipschitz and \u03b2-smooth for all z. Suppose we run SGM with constant step size \u03b1 \u2264 1/\u03b2 for T steps. Then, SGM satisfies uniform stability with\n\u01ebstab \u2264 2L2\n\u03b3n .\nProof. The proof is analogous to that of Theorem 3.9 with a slightly different recurrence relation. We repeat the the argument of completeness. Let S and S\u2032 be two samples of size n differing in only a single example. Consider the gradient updates G1, . . . , GT and G \u2032 1, . . . , G \u2032 T induced by running SGM on sample S and S\u2032, respectively. Let wT and w \u2032 T denote the corresponding outputs of SGM.\nApplying Lemma 3.8 with t0 = 0, we obtain\nE \u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223 \u2223 \u2264 LE [\u03b4T | \u03b40 = 0] = LE [\u03b4T ] , (3.5)\nwhere \u03b4t = \u2016wT \u2212 w\u2032T \u2016. Observe that at step t, with probability 1 \u2212 1/n, the example selected by SGM is the same in both S and S\u2032. In this case we have that Gt = G \u2032 t. We can now apply the following useful simplification of Lemma 3.7.3 if \u03b1 \u2264 1/\u03b2. Since we also require that \u03b1 \u2264 2\u03b2+\u03b3 we\nget that 2\u03b1\u03b2\u03b3\u03b2+\u03b3 \u2265 \u03b12\u03b2\u03b3 \u2265 \u03b1\u03b3, thus Gf,\u03b1 is (1 \u2212 \u03b1\u03b3)-expansive. With probability 1/n the selected example is different in which case we use that both Gt and G \u2032 t are \u03b1L-bounded as a consequence of Lemma 3.3 which appears in the next section. Hence, we can apply Lemma 2.5 and linearity of expectation to conclude that for every t,\nE \u03b4t+1 \u2264 ( 1\u2212 1 n ) (1\u2212 \u03b1\u03b3)E \u03b4t + 1 n (1\u2212 \u03b1\u03b3)E \u03b4t + 2\u03b1L n (3.6)\n= (1\u2212 \u03b1\u03b3)E \u03b4t + 2\u03b1L\nn\nUnraveling the recursion gives\nE \u03b4T \u2264 2L\u03b1\nn\nT \u2211\nt=0\n(1\u2212 \u03b1\u03b3)t \u2264 2L \u03b3n .\nPlugging the above inequality into equation (3.3), we obtain\nE \u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; z) \u2223\n\u2223 \u2264 2L 2\n\u03b3n .\nSince this bounds holds for all S, S\u2032 and z, the lemma follows.\nWe would like to note that a nearly identical result holds for a \u201cstaircase\u201d decaying step-size that is also popular in machine learning and stochastic optimization.\nTheorem 3.11. Assume that the loss function f(\u00b7 ; z) \u2208 [0, 1] is \u03b3-strongly convex, L-Lipschitz, and \u03b2-smooth function for all z. Suppose we run SGM with step sizes \u03b1t = 1 \u03b3t . Then, SGM has uniform stability of\n\u01ebstab \u2264 2L2 + \u03b2\n\u03b3n .\nProof. Note that once t > \u03b2\u03b3 , the iterates are contractive with contractivity 1\u2212\u03b1t\u03b3 \u2264 1\u2212 1t . Thus, for t \u2265 t0 := \u03b2\u03b3 , we have\nE[\u03b4t+1] \u2264 (1\u2212 1n)(1\u2212 \u03b1t\u03b3)E[\u03b4t] + 1n((1 \u2212 \u03b1t\u03b3)E[\u03b4t] + 2\u03b1tL)\n= (1\u2212 \u03b1t\u03b3)E[\u03b4t] + 2\u03b1tL\nn\n=\n(\n1\u2212 1 t\n)\nE[\u03b4t] + 2L\n\u03b3tn .\nAssuming that \u03b4t0 = 0 and expanding this recursion, we find.\nE[\u03b4T ] \u2264 T \u2211\nt=t0\n{\nT \u220f\ns=t+1\n(\n1\u2212 1 s\n)\n}\n2L \u03b3tn =\nT \u2211\nt=t0\nt\nT\n2L \u03b3tn = T \u2212 t0 T 2L \u03b3n .\nNow, the result follows from Lemma 3.8 while the fact that t0 = \u03b2 \u03b3 ."}, {"heading": "3.5 Non-convex optimization", "text": "In this section we prove stability results for stochastic gradient methods that do not require convexity. We will still assume that the objective function is smooth and Lipschitz as defined previously.\nTheorem 3.12. Assume that f(\u00b7; z) \u2208 [0, 1] is an L-Lipschitz and \u03b2-smooth loss function for every z. Suppose that we run SGM for T steps with monotonically non-increasing step sizes \u03b1t \u2264 c/t. Then, SGM has uniform stability with\n\u01ebstab \u2264 1 + 1/\u03b2c\nn\u2212 1 (2cL 2)\n1 \u03b2c+1T \u03b2c \u03b2c+1\nIn particular, omitting constant factors that depend on \u03b2, c, and L, we get\n\u01ebstab / T 1\u22121/(\u03b2c+1)\nn .\nProof. Let S and S\u2032 be two samples of size n differing in only a single example. Consider the gradient updates G1, . . . , GT and G \u2032 1, . . . , G \u2032 T induced by running SGM on sample S and S\n\u2032, respectively. Let wT and w \u2032 T denote the corresponding outputs of SGM.\nBy Lemma 3.8, we have for every t0 \u2208 {1, . . . , n},\nE \u2223 \u2223f(wT ; z) \u2212 f(w\u2032T ; z) \u2223 \u2223 \u2264 t0 n + LE [\u03b4T | \u03b4t0 = 0] , (3.7)\nwhere \u03b4t = \u2016wT \u2212w\u2032T \u2016. To simplify notation, let \u2206t = E [\u03b4T | \u03b4t0 = 0] . We will bound \u2206t a function of t0 and then minimize for t0.\nToward this goal, observe that at step t, with probability 1\u22121/n, the example selected by SGM is the same in both S and S\u2032. In this case we have that Gt = G \u2032 t and we can use the (1 + \u03b1t\u03b2)expansivity of the update rule Gt which follows from our smoothness assumption via Lemma 3.7.1. With probability 1/n the selected example is different in which case we use that both Gt and G \u2032 t are \u03b1tL-bounded as a consequence of Lemma 3.3. Hence, we can apply Lemma 2.5 and linearity of expectation to conclude that for every t \u2265 t0,\n\u2206t+1 \u2264 ( 1\u2212 1 n ) (1 + \u03b1t\u03b2)\u2206t + 1 n \u2206t + 2\u03b1tL n\n\u2264 ( 1\nn + (1\u2212 1/n)(1 + c\u03b2/t)\n)\n\u2206t + 2cL\ntn\n=\n(\n1 + (1\u2212 1/n)c\u03b2 t\n)\n\u2206t + 2cL\ntn\n\u2264 exp ( (1\u2212 1/n)c\u03b2 t ) \u2206t + 2cL tn .\nHere we used that 1 + x \u2264 exp(x) for all x.\nUsing the fact that \u2206t0 = 0, we can unwind this recurrence relation from T down to t0 + 1. This gives\n\u2206T \u2264 T \u2211\nt=t0+1\n{\nT \u220f\nk=t+1\nexp (\n(1\u2212 1n) \u03b2c k\n)\n}\n2cL\ntn\n= T \u2211\nt=t0+1\nexp\n(\n(1\u2212 1n)\u03b2c T \u2211\nk=t+1\n1 k\n)\n2cL\ntn\n\u2264 T \u2211\nt=t0+1\nexp ( (1\u2212 1n)\u03b2c log(Tt ) ) 2cL\ntn\n= 2cL\nn T \u03b2c(1\u22121/n)\nT \u2211\nt=t0+1\nt\u2212\u03b2c(1\u22121/n)\u22121\n\u2264 1 (1\u2212 1/n)\u03b2c 2cL n\n(\nT\nt0\n)\u03b2c(1\u22121/n)\n\u2264 2L \u03b2(n\u2212 1)\n(\nT\nt0\n)\u03b2c\n,\nPlugging this bound into (3.7), we get\nE\n\u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; ) \u2223 \u2223 \u2264 t0 n + 2L2 \u03b2(n \u2212 1)\n(\nT\nt0\n)\u03b2c\n.\nLetting q = \u03b2c, the right hand side is approximately minimized when\nt0 = ( 2cL2 )\n1 q+1 T q q+1 .\nThis setting gives us\nE\n\u2223 \u2223f(wT ; z)\u2212 f(w\u2032T ; z) \u2223 \u2223 \u2264 1 + 1/q n\u2212 1 ( 2cL2 ) 1 q+1 T q q+1 = 1 + 1/\u03b2c n\u2212 1 (2cL 2) 1 \u03b2c+1T \u03b2c \u03b2c+1 .\nSince the bound we just derived holds for all S, S\u2032 and z, we immediately get the claimed upper bound on the uniform stability."}, {"heading": "4 Stability-inducing operations", "text": "In light of our results, it makes sense to analyse for operations that increase the stability of the stochastic gradient method. We show in this section that pleasingly several popular heuristics and methods indeed improve the stability of SGM. Our rather straightforward analyses both to strengthen the bounds we previously obtained and provides an explanation of empirical success of the methods we overview.\nWeight Decay and Regularization. Weight decay is a simple and effective that often improves generalization [20].\nDefinition 4.1. Let f : \u2126 \u2192 \u2126, be a differentiable function. We define the gradient update with weight decay at rate \u00b5 as Gf,\u00b5,\u03b1(w) = (1\u2212 \u03b1\u00b5)w \u2212 \u03b1\u2207f(w).\nIt is easy to verify that the above update rule is equivalent to performing a gradient update on the \u21132-regularized objective g(w) = f(w) + \u00b5 2 \u2016w\u20162.\nLemma 4.2. Assume that f is \u03b2-smooth. Then, Gf,\u00b5,\u03b1 is (1 + \u03b1(\u03b2 \u2212 \u00b5))-expansive.\nProof. Let G = Gf,\u00b5,\u03b1. By triangle inequality and our smoothness assumption,\n\u2016G(v) \u2212G(w)\u2016 \u2264 (1\u2212 \u03b1\u00b5)\u2016v \u2212 w\u2016+ \u03b1\u2016\u2207f(w)\u2212\u2207f(v)\u2016 \u2264 (1\u2212 \u03b1\u00b5)\u2016v \u2212 w\u2016+ \u03b1\u03b2\u2016w \u2212 v\u2016 = (1\u2212 \u03b1\u00b5 + \u03b1\u03b2)\u2016v \u2212 w\u2016 .\nThe above lemma shows as that a regularization parameter \u00b5 counters a smoothness parameter \u03b2. Once r > \u03b2, the gradient update with decay becomes contractive. Any theorem we proved in previous sections that has a dependence on \u03b2 leads to a corresponding theorem for stochastic gradient with weight decay in which \u03b2 is replaced with \u03b2 \u2212 \u00b5.\nGradient Clipping. It is common when training deep neural networks to enforce bounds on the norm of the gradients encountered by SGD. This is often done by either truncation, scaling, or dropping of examples that cause an exceptionally large value of the gradient norm. Any such heuristic directly leads to a bound on the Lipschitz parameter L that appears in our bounds. It is also easy to introduce a varying Lipschitz parameter Lt to account for possibly different values.\nDropout. Dropout [39] is a popular and effective heuristic for preventing large neural networks from overfitting. Here we prove that, indeed, dropout improves all of our stability bounds generically. From the point of view of stochastic gradient descent, dropout is equivalent to setting a fraction of the gradient weights to zero. That is, instead of updating with a stochastic gradient \u2207f(w; z) we instead update with a perturbed gradient D\u2207f(w; z) which is is typically identical to \u2207f(w; z) in some of the coordinates and equal to 0 on the remaining coordinates, although our definition is a fair bit more general.\nDefinition 4.3. We say that a randomized map D : \u2126 \u2192 \u2126 is a dropout operator with dropout rate s if for every v \u2208 D we have E \u2016Dv\u2016 = s\u2016v\u2016. For a differentiable function f : \u2126 \u2192 \u2126, we let DGf,\u03b1 denote the dropout gradient update defined as DGf,\u03b1(v) = v \u2212 \u03b1P\u2207f(v)\nAs expected, the dropout update improves the effective Lipschitz constant of the objective function.\nLemma 4.4. Assume that f is L-Lipschitz. Then, the dropout update DGf,\u03b1 with dropout rate s is (s\u03b1L)-bounded.\nProof. By our Lipschitz assumption and linearity of expectation,\nE \u2016Gf,\u03b1(v)\u2212 v\u2016 = \u03b1E \u2016D\u2207f(v)\u2016 = \u03b1sE \u2016\u2207f(v)\u2016 \u2264 \u03b1sL, .\nFrom this lemma we can obtain various corollaries by replacing L with sL in our theorems.\nProjections and Proximal Steps. Related to regularization, there are many popular updates which follow a stochastic gradient update with a projection onto a set or some statistical shrinkage operation. The vast majority of these operations can be understood as applying a proximal-point operation associated with a convex function. Similar to the gradient operation, we can define the proximal update rule.\nDefinition 4.5. For a nonnegative step size \u03b1 \u2265 0 and a function f : \u2126 \u2192 R, we define the proximal update rule Pf,\u03b1 as\nPf,\u03b1(w) = argmin v\n1 2 \u2016w \u2212 v\u20162 + \u03b1f(v) . (4.1)\nFor example, Euclidean projection is the proximal point operation associated with the indicator of the associated set. Soft-thresholding is the proximal point operator associated with the \u21131-norm. For more information, see the surveys by Combettes and Wajs [6] or Parikh and Boyd [32].\nAn elementary proof of the following Lemma, due to Rockafellar [35], can be found in the appendix.\nLemma 4.6. If f is convex, the proximal update (4.1) is 1-expansive.\nIn particular, this Lemma implies that the Euclidean projection onto a convex set is 1-expansive. Note that in many important cases, proximal operators are actually contractive. That is, they are \u03b7-expansive with \u03b7 < 1. An notable example is when f(\u00b7) is the Euclidean norm for which the update rule is \u03b7-expansive with \u03b7 = (1 + \u03b1)\u22121. So stability can be induced by the choice of an appropriate prox-operation, which can always be interpreted as some form of regularization.\nModel Averaging. Model averaging refers to the idea of averaging out the iterates wt obtained by a run of SGD. In convex optimization, model averaging is sometimes observed to lead to better empirical performance of SGM and closely replated updates such as the Perceptron [10]. Here we show that model averaging improves our bound for the convex optimization by a constant factor.\nTheorem 4.7. Assume that f : \u2126 \u2192 [0, 1] is a decomposable convex L-Lipschitz \u03b2-smooth function and that we run SGD with step sizes \u03b1t \u2264 \u03b1 \u2264 2/\u03b2 for T steps. Then, the average of the first T iterates of SGD has uniform stability of \u01ebstab \u2264 \u03b1TL 2\nn .\nProof. Let w\u0304T = 1 T\nT \u2211\nt=1\nwt denoet the average of the stochastic gradient iterates. Since\nwt = t \u2211\nk=1\n\u03b1\u2207f(wk; (xk, yk)) ,\nwe have\nw\u0304T = \u03b1\nT \u2211\nt=1\nT \u2212 t+ 1 T \u2207f(wk; (xk, yk))\nUsing Lemma 3.8, the deviation between w\u0304t and w\u0304 \u2032 t obeys\n\u03b4t \u2264 (1\u2212 1/n)\u03b4t\u22121 + 1\nn\n(\n\u03b4t\u22121 + 2\u03b1L T \u2212 t+ 1\nT\n)\n.\nwhich implies\n\u03b4T \u2264 2\u03b1L\nn\nT \u2211\nt=1\nT \u2212 t+ 1 T = \u03b1L(T + 1) n .\nSince f is L-Lipschitz, we have\nE |f(w\u0304T )\u2212 f(w\u0304\u2032T )| \u2264 L\u2016w\u0304T \u2212 w\u0304\u2032T \u2016 \u2264 \u03b1(T + 1)L2\nn .\nHere the expectation is taken over the algorithm and hence the claim follows by our definition of uniform stability."}, {"heading": "5 Convex risk minimization", "text": "We now outline how our generalization bounds lead to bounds on the population risk achieved by SGM in the convex setting. We restrict our attention to the convex case where we can contrast against known results. The main feature of our results is that we show that one can achieve bounds comparable or perhaps better than known results on stochastic gradient for risk minimization by running for multiple passes over the data set.\nThe key to the analysis in this section is to decompose the risk estimates into an optimization error term and a stability term. The optimization error designates how closely we optimize the empirical risk or a proxy of the empirical risk. By optimizing with stochastic gradient, we will be able to balance this optimization accuracy against how well we generalize. These results are inspired by the work of Bousquet and Bottou who provided similar analyses for SGM based on uniform convergence [3]. However, our stability results will yield sharper bounds.\nThroughout this section, our risk decomposition works as follows. We define the optimization error to be the gap between the empirical risk and minimum empirical risk in expectation:\n\u01ebopt(w) def = E [ RS [w]\u2212RS [wS\u22c6 ] ] where wS\u22c6 = argminw RS [w] .\nBy Theorem 2.2, the expected risk of a w output by SGM is bounded as\nE[R[w]] \u2264 E[RS [w]] + \u01ebstab \u2264 E[RS [wS\u22c6 ]] + \u01ebopt(w) + \u01ebstab\nIn general, the optimization error decreases with the number of SGM iterations while the stability increases. Balancing these two terms will thus provide a reasonable excess risk against the empirical risk minimizer. Note that our analysis involves the expected minimum empirical risk which could be considerably smaller than the minimum risk. However, as we now show, it can never be larger.\nLemma 5.1. Let w\u22c6 denote the minimizer of the population risk and w S \u22c6 denote the minimizer of the empirical risk given a sampled data set S. Then E[RS [w S \u22c6 ]] \u2264 R[w\u22c6].\nProof.\nR[w\u22c6] = inf w R[w] = inf w Ez[f(w; z)]\n= inf w ES\n[\n1 n\nn \u2211\ni=1\nf(w; zi))\n]\n\u2265 inf w ES\n[\n1 n\nn \u2211\ni=1\nf(wS\u22c6 ; zi))\n]\n= ES\n[\n1 n\nn \u2211\ni=1\nf(wS\u22c6 ; zi)\n]\n= E[RS [w S \u22c6 ]] .\nTo analyze the optimization error, we will make use of a classical result due to Nemirovski and Yudin [28].\nTheorem 5.2. Assume we run stochastic gradient descent with constant stepsize \u03b1 on a convex function\nR[w] = Ez[f(w; z)] .\nAssume further that \u2016\u2207f(w; z)\u2016 \u2264 L and \u2016w0 \u2212 w\u22c6\u2016 \u2264 D for some minimizer w\u22c6 of J . Let w\u0304T denote the average of the T iterates of the algorithm. Then we have\nR[w\u0304T ] \u2264 R[w\u22c6] + 12 D2\nT\u03b1 + 12L 2\u03b1 .\nThe upper bound stated in the previous theorem is known to be tight even if the function is \u03b2-smooth [28]\nIf we plug in the population risk for J in the previous theorem, we directly obtain a generalization bound for SGM that holds when we make a single pass over the data. The theorem requires fresh samples from the distribution in each update step of SGM. Hence, given n data points, we cannot make more than n steps, and each sample must not be used more than once.\nCorollary 5.3. Let f be a convex loss function satisfying \u2016\u2207f(w, z)\u2016 \u2264 L and let w\u22c6 be a minimizer of the population risk R[w] = Ez f(w; z). Suppose we make a single pass of SGM over the sample S = (z1, . . . , zn) with a suitably chosen fixed step size starting from a point w0 that satisfies \u2016w0 \u2212 w\u22c6\u2016 \u2264 D. Then, the average w\u0304n of the iterates satisfies\nE[R[w\u0304n]] \u2264 R[w\u22c6] + DL\u221a n . (5.1)\nWe now contrast this bound with what follows from our results.\nProposition 5.4. Let S = (z1, . . . , zn) be a sample of size n. Let f be a \u03b2-smooth convex loss function satisfying \u2016\u2207f(w, z)\u2016 \u2264 L and let wS\u22c6 be a minimizer of the empirical risk RS [w] =\n1 n \u2211n i=1 f(w; zi). Suppose we run T steps of SGM with suitably chosen step size from a starting point w0 that satisfies \u2016w0 \u2212wS\u22c6 \u2016 \u2264 D. Then, the average w\u0304T over the iterates satisfies\nE[R[w\u0304T ]] \u2264 E[RS [wS\u22c6 ]] + DL\u221a n\n\u221a\nn+ 2T\nT .\nProof. On the one hand, applying Theorem 5.2 to the empirical risk RS , we get\n\u01ebopt(w\u0304T ) \u2264 12 D2\nT\u03b1 + 12L 2\u03b1 .\nHere, wS\u22c6 is an empirical risk minimizer. On the other hand, by our stability bound from Theorem 4.7,\n\u01ebstab \u2264 TL2\u03b1\nn\nCombining these two inequalities we have,\nE[R[w\u0304T ]] \u2264 E[Remp[wS\u22c6 ]] + 12 D2\nT\u03b1 + 12L 2\n(\n1 + 2T\nn\n)\n\u03b1\nChoosing \u03b1 to be\n\u03b1 = D \u221a n\nL \u221a T (n+ 2T ) ,\nyields the bound provided in the proposition.\nNote that the bound from our stability analysis is not directly comparable to Corollary 5.3 as we are comparing against the expected minimum empirical risk rather than the minimum risk. Lemma 5.1 implies that the excess risk in our bound is at most worse by a factor of \u221a 3 compared with Corollary 5.3 when T = n. Moreover, the excess risk in our bound tends to a factor merely\u221a 2 larger than the Nemirovski-Yudin bound as T goes to infinity. In contrast, the classical bound does not apply when T > n."}, {"heading": "6 Future Work and Open Problems", "text": "Our analysis parts from much previous work in that we directly analyze the generalization performance of an algorithm rather than the solution of an optimization problem. In doing so we build on the toolkit usually used to prove that algorithms converge in objective value.\nThis approach could be more powerful than analyzing optimality conditions, as it may be easier to understand how each data point affects a procedure rather than an optimal solution. It also has the advantage that the generalization bound holds even if the algorithm fails to find a unique optimal solution as is common in non-convex problems.\nIn addition to this broader perspective on algorithms for learning, there are many exciting theoretical and empirical directions that we intend to pursue in future work. We close this manuscript by detailing some of the more concrete open problems and avenues for direct empirical validation.\nHigh Probability Bounds The results in this paper are all in expectation. Similar to the wellknown proofs of the stochastic gradient method, deriving bounds on the expected risk is relatively straightforward, but high probability bounds need more attention and care [26, 34]. In the case of stability, the standard techniques from Bousquet and Elisseeff require uniform stability on the order of O(1/n) to apply exponential concentration inequalities like McDiaramid\u2019s [4]. For larger values of the stability parameter \u01ebstab, it is more difficult to construct such high probability bounds. In our setting, things are further complicated by the fact that our algorithm is itself randomized, and thus a concentration inequality must be devised to account for both the randomness in the data and in the training algorithm. Since differential privacy and stability are closely related, one possibility is to derive concentration via an algorithmic method, similar to the one developed by Nissim and Stemmer [31].\nStability of the gradient method Since gradient descent can be considered a \u201climiting case\u201d of the stochastic gradient descent method, one can use an argument like our Growth Recursion Lemma (Lemma 2.5) to analyze its stability. Such an argument provides an estimate of \u01ebstab \u2264 \u03b1Tn where \u03b1 is the step size and T is the number of iterations. Generic bounds for convex functions suggest that gradient descent achieves an optimization error of O(1/T ). Thus, a generalization bound of O(1/ \u221a n) is achievable, but at a computational complexity of O(n1.5). SGM, on the other hand, achieves a generalization of O(1/ \u221a n) in time O(n).\nIn the non-convex case, we are unable to prove any reasonable form of stability at all. We are unable to apply our \u201cburn-in\u201d argument to the gradient method, and thus trajectories may diverge exponentially quickly. Poor generalization behavior of gradient descent has been observed in practice, but lower bounds for this approach are necessary to rule out a stable implementation for non-convex machine learning.\nAcceleration and momentum We have described how many of the best practices in neural net training can be understood as stability inducing operations. One very important technique that we did not discuss is momentum. In momentum methods, the update is a linear combination of the current iterate and the previous direction. For convex problems, momentum is known to decrease the number of iterations required by stochastic gradient descent [22]. For general nonlinear problems, is believed to decrease the number of iterations required to achieve low-training error [33,37]. However, it is not clear that momentum adds stability. Indeed, in the case of convex optimization, momentum methods are less robust to noise than gradient methods [7, 23]. Thus, it is possible that momentum speeds up training but adversely impacts generalization.\nEmpirical Validation Most notably, we hope to investigate whether these theoretical developments parallel empirical behavior. For such an investigation, it is necessary to devise efficient methods to measure the stability exhibited by stochastic gradient. We can then determine if the models that generalize in practice are indeed the most stable ones. Moreover, we can verify whether minor algorithmic modifications that induce stability also result in the models which generalize best. We expect to perform such experiments in the near future.\nModel Selection Another related avenue that bridges theory and practice is using stability as a method for model selection. In particular, our results imply that the models that train the fastest also generalize the best. This suggests that a heuristic for model selection would be to run many\ndifferent parameter settings and choose the model which results in the lowest training error most quickly. This idea is relatively simple to try in practice, and ideas from bandit optimization can be applied to efficiently search with this heuristic cost [15, 17]. From the theoretical perspective, understanding the sensibility of this heuristic would require understanding lower bounds for generalizability. Are there necessary conditions which state that models which take a long training time by SGM generalize less well than those with short training times?\nHigh capacity models that train quickly If the models can be trained quickly via stochastic gradient, our results prove that these models will generalize. However, this manuscript provides no guidance as to how to build a model where training is stable and training error is low. Designing a family of models which both has high capacity and can be trained quickly would be of significant theoretical and practical interest.\nIndeed, the capacity of models trained in current practice steadily increases as growing computational power makes it possible to effectively train larger models. It is not uncommon for some models, such as large neural networks, to have more free parameters than the size of the sample yet have rather small generalization error [19,40]. In fact, sometimes increasing the model capacity even seems to decrease the generalization error [30]. Is it possible to understand this phenomena via stability? How can we find models which provably both have high capacity and train quickly?\nAlgorithm Design Finally, we note that stability may also provide new ideas for designing learning rules. There are a variety of successful methods in machine learning and signal processing that do not compute an exact stochastic gradient, yet are known to find quality stationary points in theory and practice [5]. Do the ideas developed in this paper provide new insights into how to design learning rules that accelerate the convergence and improve the generalization of SGM?"}, {"heading": "Acknowledgements", "text": "The authors would like to thank John Duchi, Vineet Gupta, Kevin Jamieson, Eric Price, Nati Srebro, and Oriol Vinyals for their insightful feedback and helpful suggestions."}, {"heading": "A Elementary properties of convex functions", "text": "Proof of Lemma 3.7.1. Let G = Gf,\u03b1. By triangle inequality and our smoothness assumption,\n\u2016G(v) \u2212G(w)\u2016 \u2264 \u2016v \u2212 w\u2016+ \u03b1\u2016\u2207f(w)\u2212\u2207f(v)\u2016 \u2264 \u2016v \u2212 w\u2016+ \u03b1\u03b2\u2016w \u2212 v\u2016 = (1 + \u03b1\u03b2)\u2016v \u2212 w\u2016 .\nProof of Lemma 3.7.2. Convexity and \u03b2-smoothness implies that the gradients are co-coercive, namely\n\u3008\u2207f(v)\u2212\u2207f(w), v \u2212 w\u3009 \u2265 1 \u03b2 \u2016\u2207f(v)\u2212\u2207f(w)\u20162 . (A.1)\nWe conclude that\n\u2016Gf,\u03b1(v)\u2212Gf,\u03b1(w)\u20162 = \u2016v \u2212 w\u20162 \u2212 2\u03b1\u3008\u2207f(v) \u2212\u2207f(w), v \u2212 w\u3009+ \u03b12\u2016\u2207f(v)\u2212\u2207f(w)\u20162\n\u2264 \u2016v \u2212 w\u20162 \u2212 (\n2\u03b1 \u03b2 \u2212 \u03b1\n2 )\n\u2016\u2207f(v)\u2212\u2207f(w)\u20162\n\u2264 \u2016v \u2212 w\u20162 .\nProof of Lemma 3.7.3. First, note that if f is \u03b3 strongly convex, then \u03d5(w) = f(w) \u2212 \u03b32\u2016w\u20162 is convex with (\u03b2 \u2212 \u03b3)-smooth. Hence, applying (A.1) to \u03d5 yields the inequality\n\u3008\u2207f(v)\u2212\u2207f(w), v \u2212 w, \u3009 \u2265 \u03b2\u03b3 \u03b2 + \u03b3 \u2016v \u2212 w\u20162 + 1 \u03b2 + \u03b3 \u2016\u2207f(v)\u2212\u2207f(w)\u20162\nUsing this inequality gives\n\u2016Gf,\u03b1(v)\u2212Gf,\u03b1(w)\u2016 = \u2016v \u2212w\u20162 \u2212 2\u03b1\u3008\u2207f(v) \u2212\u2207f(w), v \u2212 w, \u3009+ \u03b12\u2016\u2207f(v)\u2212\u2207f(w)\u20162\n\u2264 ( 1\u2212 2 \u03b1\u03b2\u03b3 \u03b2 + \u03b3 ) \u2016v \u2212 w\u20162 \u2212 \u03b1 ( 2 \u03b2 + \u03b3 \u2212 \u03b1 ) \u2016\u2207f(v)\u2212\u2207f(w)\u20162 .\nThe lemma follows.\nProof of Lemma 4.6. This proof is due to Rockafellar [35]. Define\nP\u03bd(w) = argmin v\n1\n2\u03bd \u2016w \u2212 v\u20162 + f(v) . (A.2)\nThis is the proximal mapping associated with f . Define the map Q\u03bd(w) := w \u2212 P\u03bd(w). Then, by the optimality conditions associated with (A.2), we have\n\u03bd\u22121Q\u03bd(w) \u2208 \u2202f(P\u03bd(w)) .\nBy convexity of f , we then have\n\u3008P\u03bd(v)\u2212 P\u03bd(w), Q\u03bd(v)\u2212Q\u03bd(w)\u3009 \u2265 0 .\nUsing this inequality, we have\n\u2016v \u2212 w\u20162 = \u2016[P\u03bd(v)\u2212 P\u03bd(w)] + [Q\u03bd(v) \u2212Q\u03bd(w)]\u20162\n= \u2016P\u03bd(v)\u2212 P\u03bd(w)\u20162 + 2\u3008P\u03bd(v)\u2212 P\u03bd(w), Q\u03bd(v) \u2212Q\u03bd(w)\u3009+ \u2016Q\u03bd(v)\u2212Q\u03bd(w)\u20162 \u2265 \u2016P\u03bd(v)\u2212 P\u03bd(w)\u20162 ,\nthus completing the proof."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "<lb>We show that any model trained by a stochastic gradient method with few iterations has<lb>vanishing generalization error. We prove this by showing the method is algorithmically stable<lb>in the sense of Bousquet and Elisseeff. Our analysis only employs elementary tools from convex<lb>and continuous optimization. Our results apply to both convex and non-convex optimization<lb>under standard Lipschitz and smoothness assumptions.<lb>Applying our results to the convex case, we provide new explanations for why multiple<lb>epochs of stochastic gradient descent generalize well in practice. In the nonconvex case, we<lb>provide a new interpretation of common practices in neural networks, and provide a formal<lb>rationale for stability-promoting mechanisms in training large, deep models. Conceptually, our<lb>findings underscore the importance of reducing training time beyond its obvious benefit.", "creator": "LaTeX with hyperref package"}}}