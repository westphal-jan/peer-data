{"id": "1509.06254", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Sep-2015", "title": "Hybrid Optimization Algorithm for Large-Scale QoS-Aware Service Composition", "abstract": "In this paper we present a hybrid approach for automatic composition of Web services that generates semantic input-output based compositions with optimal end-to-end QoS, minimizing the number of services of the resulting composition. The proposed approach has four main steps: 1) generation of the composition graph for a request; 2) computation of the optimal composition that minimizes a single objective QoS function; 3) multi-step optimizations to reduce the search space by identifying equivalent and dominated services; and 4) hybrid local-global search to extract the optimal QoS with the minimum number of services. An extensive validation with the datasets of the Web Service Challenge 2009-2010 and randomly generated datasets shows that: 1) the combination of local and global optimization is a general and powerful technique to extract optimal compositions in diverse scenarios; and 2) the hybrid strategy performs better than the state-of-the-art, obtaining solutions with less services and optimal QoS.\n\n\n\n\nThis paper demonstrates a new approach for the optimization of the composition graph for a request in which only the relevant service was generated. The computational methods used for the generation of the composition graph in this paper have been used to generate semantic input-output based compositions. The current approach is only applied to the application of the computational approach to the composition graph in the case of query-driven algorithms. The computational approach has a number of major features:\nThe concept of the computation of an application for the processing of the composition graph is similar to the approach described in this paper: a system of algorithms that is not only based on the algorithm (and the individual user) but also the algorithm-dependent features of the computation. The algorithm-independent features of the computation can be used to produce semantic input-output based compositions that can achieve a given semantic input-output based composition. This paper uses a simple algebraic approach to derive a graph, which is more complicated than that used to create a complex application for the processing of the composition graph. A linear algorithm is not always the case but also the algorithm-independent features of the computation. The graph is also used in the case of query-driven algorithms to obtain semantic input-output based composition. This paper uses a simple algebraic approach to derive a graph, which is more complicated than that used to create a complex application for the processing of the composition graph. A linear algorithm is not always the case but also the algorithm-independent features of the computation. The graph is also used in the case of query-driven algorithms to obtain semantic input-output", "histories": [["v1", "Mon, 21 Sep 2015 14:56:28 GMT  (243kb,D)", "http://arxiv.org/abs/1509.06254v1", "Preprint accepted to appear in IEEE Transactions on Services Computing 2015"]], "COMMENTS": "Preprint accepted to appear in IEEE Transactions on Services Computing 2015", "reviews": [], "SUBJECTS": "cs.AI cs.NI", "authors": ["pablo rodriguez-mier", "manuel mucientes", "manuel lama"], "accepted": false, "id": "1509.06254"}, "pdf": {"name": "1509.06254.pdf", "metadata": {"source": "CRF", "title": "Hybrid Optimization Algorithm for Large-Scale QoS-Aware Service Composition", "authors": ["Pablo Rodriguez-Mier", "Manuel Mucientes", "Manuel Lama"], "emails": ["pablo.rodriguez.mier@usc.es", "manuel.mucientes@usc.es", "manuel.lama@usc.es"], "sections": [{"heading": null, "text": "Keywords\u2014Service Composition; Service Optimization; Hybrid Algorithm; QoS-aware; Semantic Web Services.\nF"}, {"heading": "1 INTRODUCTION", "text": "W EB services are self-describing software applica-tions that can be published, discovered and invoked accross the Web using standard technologies [1]. The functionality of a Web service is mainly determined by the functional properties that describe their behaviour in terms of its inputs, outputs, and also possibly additional descriptions that the services may have, such as preconditions and effects. These four characteristics, commonly abbreviated IOPEs, allow the composition and aggregation of Web services into composite Web services that achieve more complex functionalities and, therefore, solve complex user needs that cannot be satisfied with atomic Web services. However, compositions should go beyond achieving a concrete functionality and take into account other requirements such as Quality-ofService (QoS) to generate also compositions that fit the needs of different contexts. The QoS determines the value of different quality properties of services such as response time (total time a service takes to respond to a request) or throughput (number of invocations supported in a given time interval), among others characteristics. These properties apply both to single services and to composite services, where each individual service in the composition contributes to the global QoS. For composite services this implies that having many different services with similar or identical functionality, but different QoS,\n\u2022 P. Rodriguez-Mier, M. Mucientes and M. Lama work at the Centro de Investigacio\u0301n en Tecnolox\u0131\u0301as da Informacio\u0301n (CiTIUS), Universidade de Santiago de Compostela, Spain. E-mail: {pablo.rodriguez.mier,manuel.mucientes,manuel.lama}@usc.es\nc\u00a9 2015 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this work in other works.\nmay lead to a large amount of possible compositions that satisfy the same functionality with different QoS but also with a different number of services.\nHowever, the problem of generating automatic compositions that satisfy a given request with an optimal QoS is a very complex task, specially in large-scale environments, where many service providers offer services with similar functionality but with different QoS. This has motivated researchers to explore efficient strategies to generate QoS-aware Web service compositions from different perspectives [2], [3]. But despite the large number of strategies proposed so far, the problem of finding automatic compositions that minimize the number of services while guaranteeing the optimal end-to-end QoS is rarely considered. Instead, most of the work has focused on optimizing the global QoS of a composition or improving the execution time of the composition engines. An analysis of the literature shows that only a few works take into consideration the number of services of the resulting optimal QoS compositions. Some notable examples are [4]\u2013[7]. Although most of these composition engines are quite efficient in terms of computation time, none of them are able to effectively minimize the total number of services of the solution while keeping the optimal QoS.\nThe ability to provide not only optimal QoS but also an optimal number of services is specially important in large-scale scenarios, where the large number of services and the possible interactions among them may lead to a vast amount of possible solutions with different number of services but also with the same optimal QoS for a given problem. Moreover, there can be situations where certain QoS values are missing or cannot be measured. Although the prediction of QoS can partially alleviate this problem [8], it is not always possible to have historical data in order to build statistical models to accurately predict missing QoS. In this context, opti-\nar X\niv :1\n50 9.\n06 25\n4v 1\n[ cs\n.A I]\n2 1\nSe p\n20 15\nmizing not only the available QoS but also the number of services of the composition may indirectly improve other missing properties. This has important benefits for brokers, customers and service providers. From the broker point of view, the generation of smaller compositions is interesting to achieve manageable compositions that are easier to execute, monitor, debug, deploy and scale. On the other hand, customers can also benefit from smaller compositions, specially when there are multiple solutions with the same optimal end-to-end QoS but different number of services. This is even more important when service providers do not offer fine-grained QoS metrics, since decreasing the number of services involved in the composition may indirectly improve other quality parameters such as communication overhead, risk of failure, connection latency, etc. This is also interesting from the perspective of service providers. For example, if the customer wants the cheapest composition, the solution with fewer services from the same provider may also require less resources for the same task.\nHowever, one of the main difficulties when looking for optimal solutions is that it usually requires to explore the complete search space among all possible combinations of services, which is a hard combinatorial problem. In fact, finding the optimal composition with the minimum number of services is NP-Hard (see Appendix A). Thus, achieving a reasonable trade-off between solution quality and execution time in large-scale environments is far from trivial, and hardly achievable without adequate optimizations.\nIn this paper we focus on the automatic generation of semantic input-output compositions, minimizing both a single QoS criterion and the total number of services subject to the optimal QoS. The main contributions are: \u2022 A multi-step optimization pipeline based on the\nanalysis of non-relevant, equivalent and dominated services in terms of interface functionality and QoS. \u2022 A fast local search strategy that guarantees to obtain a near-optimal number of services while satisfying the optimal end-to-end QoS for an inputoutput based composition request. \u2022 An optimal combinatorial search that can improve the solution obtained with the local search strategy by performing an exhaustive combinatorial search to select the composition with the minimum number of services for the optimal QoS.\nWe tested our proposal using the Web Service Challenge 2009-2010 datasets and, also, a different randomly generated dataset with a variable number of services. The rest of the paper is organized as follows: Sec. 4 introduces the composition problem, Sec. 5 describes the proposed approach, Sec. 6 presents the results obtained, and Sec. 7 gives some final remarks."}, {"heading": "2 RELATED WORK", "text": "Automatic composition of services is a fundamental and complex problem in the field of Service Oriented Com-\nputing, which has been approached from many different perspectives depending on what kinds of assumptions are made [2], [3], [9], [10]. AI Planning techniques have been traditionally used in service composition to generate valid composition plans by mapping services to actions in the planning domain [11]\u2013[16]. These techniques work under the assumption that services are complex operators that are well defined in terms of IOPEs, so the problem can be translated to a planning problem and solved using classical planning algorithms. Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners. As a result, and partly given by the complexity of generating satisfiable plans in the planning domain, these approaches do not generate neither optimal plans (minimizing the number of actions) nor optimal QoSaware compositions.\nOther approaches have studied the QoS-aware composition problem from the perspective of Operation Research, providing interesting strategies for optimal selection of services and optimizing the global QoS of the composition subject to multiple QoS constraints. A common strategy is to reduce the composition problem to a combinatorial Knapsack-based problem, which is generally solved using constraint satisfaction algorithms (such as Integer Programming) [19]\u2013[23] or Evolutionary Algorithms [24], [25]. Some relevant approaches are [19], [22]. In [19] the authors present AgFlow, a QoS middleware for service composition. They analyze two different methods for QoS optimization, a local selection and a global selection strategy. The second strategy is able to optimize the global end-to-end QoS of the composition using a Integer Linear Programming method, which performs better than the suboptimal local selection strategy. Similarly, in [22] the authors propose a hybrid QoS selection approach that combines a global optimization strategy with local selection for large-scale QoS composition. The assumption made by all these approaches is that there is only one composition workflow with a fixed set of abstract tasks, where each abstract task can be implemented by a concrete service. Both the composition workflow and the service candidates for each abstract task are assumed to be prefined beforehand, so these techniques are not able to produce compositions with variable size.\nA different category of techniques are graph-based approaches that 1) generate the entire composition by selecting and combining relevant services and 2) optimize the global QoS of the composition. These techniques usually combine variants or new ideas inspired by different fields, such as AI Planning, Operations Research or Heuristic Search, in order to resolve more efficiently the automatic QoS composition, usually for a single QoS criterion. Some relevant approaches in this category are the top-3 winners of the Web Service Challenge (WSC) 2009-2010 [4]\u2013[6]. Concretely, the winners of the WSC challenge [4], presented an approach that automatically\ndiscovers and composes services, optimizing the global QoS. This approach also includes an optimization phase to reduce the number of services of the solution. Although the proposed algorithm has in general good performance, as demonstrated in the WSC, it cannot guarantee to obtain optimal solutions in terms of number of services. The other participants of the WSC have also the same limitation.\nA recent and interesting approach in this category has been recently presented by Jiang et al. [26]. In this paper, the authors analyze the problem of generating top K query compositions by relaxing the optimality of the QoS in order to introduce service variability. However, the compositions are generated at the expense of worsening the optimal QoS, instead of looking first for all possible composition alternatives with the minimum number of services that guarantee the optimal QoS.\nAnother interesting graph-based approach has been presented in [7]. In this paper, the authors propose a service removal strategy that detects services that are redundant in terms of functionality and QoS. Results show that service removal techniques can be very effective to reduce the number of services before extracting the final composition, as anticipated by other similar approaches [27]\u2013[29]. However, some important limitations of this work are: 1) The QoS is not always optimal, since the graph generated for the composition is not complete as it does not contain all the relations between services (it is acyclic) and 2) although the redundancy removal is an effective technique that can be used also to prune the search space, this strategy itself cannot provide optimal results in terms of number of services, and it should be combined with exhaustive search to improve the solutions obtained.\nIn summary, despite the large number of approaches for automatic QoS-aware service composition there is a lack of efficient techniques that are not only able to optimize the global end-to-end QoS, but also effectively minimize the number of services of the composition. This paper aims to provide an efficient graph-based approach that uses a hybrid local-global optimization algorithm in order to find optimal compositions both in terms of single QoS criteria and in terms of minimum number of services."}, {"heading": "3 MOTIVATION", "text": "The aim of the automatic service composition problem, as considered in this paper, is to automatically select the best combination of available QoS-aware services in a way that can fulfil a user request that otherwise could not be solved by just invoking a single, existing service. This request is specified in terms of the information that the user provides (inputs), and the information it expects to obtain (outputs). The resulting composition should meet this request with an optimal, single criterion end-to-end QoS and using as less services as possible.\nA motivating example of the problem is shown in Fig. 1. The figure represents a graph with all the relevant services for a request R where the inputs are {ont3:IPAddress, ont2:MerchantCode} and the output is {xsd:boolean}. The goal of this example is to obtain a composition to predict whether a business transaction is fraudulent or not. Each service (associated to a response time QoS) is represented by squares. Inputs and outputs are represented by circles. The graph also contains edges connecting outputs and inputs. These edges represent valid semantic matches whenever an output of a service can be passed as an input of a different service. As can be seen, there are some inputs (ont1:Location,ont3:Payment) that can be matched by more than one output, so there are many different ways to combine services to achieve the same goal.\nAlthough finding the proper combination of services in terms of their inputs/outputs is essential to generate a solution, it is not enough to obtain good compositions, since there can exist different combinations of services with different QoS. Moreover, many different combinations of services may produce compositions with a different number of services but the same end-toend QoS. For example, in Fig. 1 we can select WS EPayment service or the Secure Payment service to process the electronic payment. However, the second service has a higher response time. Using this leads to a sub-optimal end-to-end QoS of 420 ms. However, there are other situations where the selection of different services leads to compositions with different size but same end-to-end QoS. For example, both Free Geoloc Service or the Premium Geoloc Service can be selected to translate an IP to a Location. Although the second one has a better average response time (40 ms), it requires an additional service to obtain the ClientID for verification purposes. However, selecting the Premium Geoloc Service or the Free Geoloc Service does not have an impact on the global QoS, since the ML Predictor Service has to wait longer to obtain the Transaction parameter (200 ms), but it has an impact on the total number of services of the solution.\nThe goal of this paper is to automatically generate, given a composition request, a graph like the one represented in Fig. 1 as well as to extract the optimal endto-end QoS composition with the minimum number of services from that graph."}, {"heading": "4 PROBLEM FORMULATION", "text": "We herein formalize the main concepts and assumptions regarding the composition model used in our approach, which consists of a semantic, graph-centric representation of the service composition. These concepts are captured in three main models: 1) a service model, which is used to represent services and define how services can be connected or matched to generate composite services; 2) a graph-based composition model, which is used to represent both service interactions and compositions; and 3) a QoS computation model, which provides the\noperators required to compute the global QoS in a graphbased composition."}, {"heading": "4.1 Semantic Service Model", "text": "The automatic composition of services requires a mechanism to select appropiated services based on their functional descriptions, as well as to automatic match the services together by linking their inputs and outputs to generate executable data-flow compositions. To this end, we introduce here the main concepts that we use in this paper to support the automatic generation of compositions. This model is an extension of a previous model used in [30] to include QoS properties.\nDefinition 1. A Composition Request R is defined as a tuple R = {IR, OR}, where IR is the set of provided inputs, and OR the set of expected outputs. Each input and output is related to a semantic concept from the set C of the concepts defined in an ontology Ont (Inw, Outw \u2286 C). We say that a composition satisfies the request R if it can be invoked with the inputs in IR and returns the outputs in OR.\nDefinition 2. A Semantic Web Service (hereafter \u201cservice\u201d) can be defined as a tuple w = {Inw, Outw, Qw} \u2208 W where Inw is a set of inputs required to invoke w, Outw is the set of outputs returned by w after its execution, Qw = {q1w, . . . , qnw} is the set of QoS values associated to the service, and W is the set of all services available in the service registry.\nEach input and output is related to a semantic concept from the set C of the concepts defined in an ontology Ont (Inw, Outw \u2286 C). Each QoS value qiw \u2208 Qw has a concrete type associated to a set of valid values Q. For example, the QoS values of a service w with two different measures, an average response time of 20 ms and an average throughput of 1000 invocations/second, is represented as Qw = {20ms, 1000 inv/s}, where 20ms \u2208 QRT and 1000 inv/s \u2208 QTH .\nSemantic inputs and outputs are used to compose the functionality of multiple services by matching their inputs and outputs together. In order to measure the quality of the match, we need a matchmaking mechanism that exploits the semantic I/O information of the services. The different matchmaking degrees that are contemplated are exact, plugin, subsumes and fail [31].\nDefinition 3. Given a, b \u2208 C, degree(a,b) returns the degree of match between both concepts (exact, plugin, subsume or fail), which is determined by the logical relationship of both concepts within the Ontology.\nDefinition 4. Given a, b \u2208 C, match(a,b) holds if degree(a, b) 6= fail.\nIn order to determine which concepts are matched by other concepts, we define a matchmaking operator \u201c\u2297\u201d that given two sets of concepts C1, C2 \u2286 C, it returns the concepts from C2 matched by C1.\nDefinition 5. Given C1, C2 \u2286 C, we define \u201c\u2297 : C \u00d7 C \u2192 C\u201d such that C1 \u2297 C2 = {c2 \u2208 C2|match(c1, c2), c1 \u2208 C1}.\nWe can use the previous operator to define the concepts of full and partial matching between concepts.\nDefinition 6. Given C1, C2 \u2286 C, a full matching between C1 and C2 exists if C1\u2297C2 = C2, whereas a partial matching exists if C1 \u2297 C2 \u2282 C2. Definition 7. Given a set of concepts C \u2032 \u2286 C, a service w = {Inw, Outw} is invokable if C \u2032\u2297 Inw = Inw, i.e., there is a full match between the provided set of concepts C \u2032 and Inw, so the information required by w is fully satisfied.\nThis internal model used by the algorithm, which captures the core components required to perform semantic matchmaking and composition of services, is agnostic to how semantic services are represented. Thus, the algo-\nrithm is not bound to any concrete service description. Concretely, different service descriptions can be handled by the algorithm through the use of iServe importers for OWL-S, WSMO-lite, SAWSDL or MicroWSMO. For further details see [32]."}, {"heading": "4.2 Graph-Based Composition Model", "text": "In a nutshell, a data-flow composition of services can be seen as a set of services connected together through their inputs and output, using the semantic model defined before, in a way that every service in the composition is invocable and the invocation of each service in the composition can transform a set of inputs into a set of outputs. These concepts can be naturally captured by graphs, where the vertices represent inputs, outputs and services, and the edges represent semantic matches between inputs and outputs. Here we define the notion of Service Match Graph and Service Composition Graph. The Service Match Graph is a graph that captures all the existent dependencies (matches) between all the relevant services for a composition request. The Service Composition Graph is a particular case of the Service Match Graph that represents a composition contained in the Service Match Graph.\nThe Service Match Graph represents the space of all possible valid solutions for a composition request R, and it is defined as a directed graph GS = (V,E), where: \u2022 V = WR \u222a I \u222a O \u222a {So, Si} is the set of vertices of\nthe graph, where WR \u2286 W is the set of relevant services, I is the set of inputs and O is the set of outputs. Si and So are two special services, called Source and Sink defined as So = {\u2205, IR}, Si = {OR, \u2205}. \u2022 E = IW \u222aWO\u222aOI is the set of edges in the graph where: \u25e6 IW \u2286 {(iw, w) | iw \u2208 I \u2227 w \u2208 W} is the set\nof input edges, i.e., edges connecting input concepts to their services. \u25e6 WO \u2286 {(w, ow) | w \u2208 W \u2227 ow \u2208 O} is the set of output edges, i.e., edges connecting services with their output concepts. \u25e6 OI \u2286 {(ow, iw\u2032) | ow, iw\u2032 \u2208 (I \u222a O) \u2227 match(ow, iw\u2032)} is the set of edges that represent a semantic match between an output of w and an input of w\u2032.\nThere are also some restrictions in the edge set to ensure that each input/output belongs to a single service: \u2022 \u2200i \u2208 I d+GS (i) = 1 \u2227 chGS (i) = {w}, w \u2208 W (each\ninput has only one outgoing edge which connects the input with its service) \u2022 \u2200o \u2208 O,d\u2212GS (o) = 1 \u2227 parGS (o) = {w}, w \u2208 W (each output has only one incoming edge which connects the output with its service)\nFunction d+GS (v) returns the outdegree of a vertex v \u2208 GS (number of children vertices connected to v), whereas d\u2212GS (v) returns the indegree of a vertex v (number of\nparent vertices connected to v). The functions chG(v) and parG(v) are the functions that returns the children vertices of v and the parent vertices of v \u2208 GS , respectively.\nFig. 1 shows an example of a Service Match Graph where each service is associated with its average response time. As can be seen, this graph contains many different compositions since there are inputs in the graph that can be matched by the outputs of different services. For example, the parent nodes of the input ont1:Location of the service ML Service Predictor (parG(ont1:Location)) in Fig. 1 are ont1:GeoLocation and ont1:Place, so the input is matched by two outputs d\u2212GS (ont1:Location) = 2.\nA Service Composition Graph, denoted as GC = (V,E), represents a solution for the composition request where each input is exactly matched by one output. Formally, it is a subgraph of Service Match Graph (GC \u2286 GS) that satisfies the following conditions: \u2022 \u2200i \u2208 I, d\u2212GC (i) = 1 (each input is strictly matched\nby one output) \u2022 GC is a Directed Acyclic Graph (DAG)\nThese conditions are important in order to guarantee that a solution is valid, i.e, each input is matched by an output of a service and each service is invocable (all inputs on the composition are matched with no cyclic dependencies). This definition of service composition is language-agnostic, so the resulting DAG is a representation of a solution for the composition problem which can be translated to a concrete language, such as OWL-S or BPEL."}, {"heading": "4.3 QoS Computation Model", "text": "Before looking for optimal QoS service compositions, we need first to define a model to work with QoS over compositions of services which allow us to determine the best QoS that can be achieved for a given composition request on a service repository. When many services are chained together in a composition, the QoS of each individual service contributes to the global QoS of the composition. For example, suppose we want to measure the total response time of a simple composition with two services chained in sequence. The total response time is calculated as the sum of the response time of each service in the composition. However, if the composition has two services in parallel, the total time of the composition is given by the slowest services. Thus, the calculation of the QoS of a composition depends on the type of the QoS and on the structure of the composition.\nIn order to define the common rules to operate with QoS values in composite services, many approaches use a QoS computation model based on workflow patterns [33], which is adequate to measure the QoS of controlflow based compositions. However, this paper focuses on the automatic generation of optimal QoS-aware compositions driven by the data-flow analysis of the service dependencies (input-output matches) that are represented as a Service Match Graph.\nIn this section we explain the general graph-centric QoS computation model that we use, based on the path algebra defined in [34]. This model is better suited to compute QoS values in a Service Match Graph, which, for extension, is also applicable to the particular case of the Service Composition Graph.\nDefinition 8. (Q,\u2295, , ) is a QoS algebraic structure to operate with a set of QoS values, denoted as Q. This set is equipped with the following elements: \u2022 \u2295 : Q \u00d7 Q \u2192 Q is a closed binary operation for\naggregating QoS values \u2022 : Q \u00d7 Q \u2192 Q is a binary operation for subtracting\nQoS values \u2022 is a total order relation on Q This algebraic structure has the following properties: 1) Q is closed under \u2295 (any aggregation of two QoS\nvalues always returns a QoS value) 2) The set Q contains an identity element e such that \u2200a \u2208 Q, a\u2295 e = e\u2295 a = a 3) The set Q contains a zero element \u03c6 such that \u2200a \u2208 Q,\u03c6\u2295 a = a\u2295 \u03c6 = \u03c6 4) The operator \u2295 is associative 5) The operator \u2295 is monotone for (preserves\norder). This implies that \u2200a, b, c \u2208 Q, a b \u21d4 a\u2295 c b\u2295 c 6) The operator is the inverse of \u2295: a b = c \u21d4 a = c\u2295 b\nTable 1 shows an example of the concrete elements in this algebra. Note that, for the sake of brevity, only the response time and throughput operators are represented in Table 1. However, other QoS properties such as cost, availability, reputation, etc, can also be defined by instantiating the corresponding operators. We denote QRT the set of QoS values for response time (in milliseconds), QTH the set of QoS values for throughput (invocations/second). The total order comparator is required to be able to order and compare different QoS values. Given two QoS values a, b \u2208 Q, a b means that a is equal or better than b, whereas b a means that a is equal or worse than b. The order depends on the concrete comparator defined on Q. For example, QRT uses the comparator \u2264 to order the response time, so a, b \u2208 QRT , a b \u21d4 a \u2264 b. For example, given two response times 10ms, 20ms \u2208 QRT , 10ms \u227a 20ms (10ms is better than 20ms) since 10ms < 20ms. However, QTH uses the comparator \u2265, so a, b \u2208 QTH , a b \u21d4 a \u2265 b. For example, given two throughput values 10 inv/s, 20 inv/s \u2208 QTH , 20 inv/s \u227a 10 inv/s (20 inv/s is better than 10 inv/s) since 20 inv/s > 10 inv/s. This order relation also affects the behavior of the min and max functions. The min function always selects the best QoS value, whereas the max function always selects the worst QoS value.\nDefinition 9. FQ(w) : W \u2192 Q is a function that given a service w \u2208 W , it returns its corresponding QoS value from Qw with type Q. This function can be seen as a function to measure the QoS of a service.\nDefinition 10. VQ(w) : W \u2192 Q is a function that given a service w, it returns its aggregated QoS value. This is defined as:\nVQ(w) =\n{ max \u2200i\u2208Inw (V inQ (i))\u2295 FQ(w) if Inw 6= \u2205\nFQ(w) if Inw = \u2205 (1)\nInformally, this function calculates the aggregated QoS of a service by taking the worst value of the QoS of its inputs plus the current QoS value of the service itself. Taking for example the service Premium Geoloc Service from Fig. 1, VQRT (Premium Geoloc Service) is computed as max(V inQRT (ont3:IP Address), V in QRT\n(ont4:ClientID))\u229540ms, which is max(0ms, 20ms)\u2295 40ms = 60ms (see Def. 12). Definition 11. V outQ (ow) : O \u2192 Q is a function that given an output of a service w, ow \u2208 O, it returns its aggregated QoS value. The aggregated QoS of an output is equal to the aggregated QoS of a service. Thus, it is defined as:\nV outQ (ow) = VQ(w) (2)\nFor example, the aggregated QoS of the output ont1:Place (V outQRT (ont1:Place)) is equal to the aggregated QoS of its service Premium Geoloc Service (VQRT (Premium Geoloc Service)), which is equal to 60ms.\nDefinition 12. V inQ (iw) : I \u2192 Q is a function that given an input of a service w, iw \u2208 I , it returns its optimal aggregated QoS value. This function is defined as:\nV inQ (iw) =  \u03c6 if d\u2212GS (iw) = 0 V outQ (ow\u2032), ow\u2032 \u2208 parG(iw) if d \u2212 GS (iw) = 1\nmin \u2200ow\u2032\u2208parG(iw)\n(V outQ (ow\u2032)) if d \u2212 GS (iw) > 1 (3)\nGiven an input iw \u2208 Inw of a service w, this function returns the accumulated QoS for that input. If the evaluated input is not matched by any output (d\u2212GS (iw) = 0), then the accumulated QoS of the input is undefined. If the evaluated input is matched by just one output (d\u2212GS (iw) = 1), then its accumulated QoS value is equal to the accumulated QoS of that output. If the evaluated input can be matched by more than one output (d\u2212GS (iw) > 1), i.e., there are many services that can match that input, then its accumulated QoS value is computed by selecting the optimal (best) QoS.\nFor example, the optimal aggregated QoS of the input ont3:Payment from Transaction\nService (V inQRT (ont3:Payment)) is calculated as min(V outQRT (ont3:PaymentID), V out QRT (ont5:PayInfo)) = 70ms.\nDefinition 13. We define V GQ (g) : G \u2192 Q as a function that given a Service Match Graph g = (V,E), it returns its optimal aggregated QoS value. This is defined as:\nV GQ (g) = VQ(Si), Si \u2208 V (4)\nBasically, the optimal QoS of a Service Match Graph GS corresponds with the optimal aggregated QoS of its service Si \u2208 GS ."}, {"heading": "4.4 Composition Problem", "text": "Given a composition request R = {IR, OR}, a set of semantic services W , a semantic model and a QoS algebra, the composition problem considered in this paper consists of generating the Service Match Graph GS and selecting a composition graph GC \u2282 GS such that:\n1) \u2200G\u2032C , V GQ (GC) \u2264 V GQ (G\u2032C), i.e., the composition graph has the best possible QoS 2) WR \u2286 V, |WR| is minimized (the composition graph contains the minimum number of services)"}, {"heading": "5 COMPOSITION ALGORITHM", "text": "On the basis of the formal definition of the automatic QoS-aware composition problem, in this section we present our hybrid approach strategy for automatic, large-scale composition of services with optimal QoS, minimizing the services involved in the composition. The approach works as follows: given a request, a directed graph with the relevant services for the request is generated. Once the graph is built, an optimal label-correcting forward search is performed in polynomial time in order to compute the global optimal QoS. This information is used later in a multi-step pruning phase to remove suboptimal services. Finally, a hybrid local/global search is performed within a fixed time limit to extract the optimal solution from the graph. The local search returns a nearoptimal solution fast whereas the global search performs an incremental search to extract the composition with the minimum number of services in the remaining time. In this section we explain each step of the algorithm, namely: 1) generation of the Service Match Graph; 2) calculation of the optimal end-to-end QoS; 3) multi-step graph optimizations and 4) hybrid algorithm."}, {"heading": "5.1 Generation of the Service Match Graph", "text": "Given a composition request, which specifies the inputs provided by the user as well as the outputs it expects to obtain, and a set of available services, the first step consists of locating all the relevant services that can be part of the final composition, as well as computing all possible matches between their inputs and outputs, according to the semantic model presented in Sec. 4.1. The output of this step is a Service Match Graph that\ncontains many possible valid compositions for the request, as the one represented in Fig. 3. In a nutshell, the generation of the graph is calculated by selecting all invocable services layer by layer, starting with So in the first layer (the source service whose outputs are the inputs of the request) and terminating with Si in the last layer (the sink service whose inputs are the outputs of the request) [35].\nThe pseudocode of the algorithm is shown in Fig. 2. The algorithm runs in polynomial time, selecting Wselected \u2286 W services at each step. At each layer, the algorithm finds a potential set of relevant services whose inputs are matched by some outputs generated in the previous layer using the \u2297 operator (L.6). Then, for each potential eligible service, the algorithm checks whether the service is invokable or not (i.e., all its inputs are matched by outputs of previous layers) by checking if all the unmatched inputs of the service are matches. All the inputs that are matched are removed from the unmatched set of inputs for the current service (L.11). If the service is invokable (has no unmatched inputs), it is selected and its outputs are added to the set of the available concepts. In case the service still has some unmatched inputs, these inputs are stored in a map to check it again in the next layer. For example, the first eligible services for the request shown in Fig. 3 are the services in the layer L1, which correspond with the services whose inputs are fully matched by IR (the set of output concepts produced in L0). The second eligible services are those services (placed in L2) whose inputs are fully matched by the outputs of the previous layers, and so on. The algorithm stops when no more services are added to the set of selected services. Finally, COMPUTE-GRAPH\ncomputes all possible matches between the outputs and the inputs of the selected services. The output of this process is a complete Service Match Graph that can contain cycles, as the one depicted in Fig. 3."}, {"heading": "5.2 Optimal end-to-end QoS", "text": "Once the Service Match Graph is computed for a composition request, the next step is to calculate the best endto-end QoS achievable in the Service Match Graph. The optimal end-to-end QoS can be computed in polynomial time using a shortest path algorithm to calculate the best aggregated QoS values for each input and output of the graph, i.e., the best QoS values at which the outputs can be generated and the inputs are matched. In order to compute the optimal QoS, we use a generalized Dijkstrabased label-setting algorithm computed forwards from So to Si [36], based on the algebraic model of the QoS presented in Sec. 4. The optimality of the algorithm is guaranteed as long as the function defined to aggregate the QoS values (\u2297) is monotonic, in order to satisfy the principle of optimality. A proof can be found in [37].\nFig. 4 shows the pseudocode of the generalized Dijkstra-based label-setting algorithm. The algorithm starts assigning infinite QoS cost to each input in the graph in the table qos. An infinite cost for an input means that the input is still not resolved. The first service to be processed is So. Each time a service w is processed from the queue, the best accumulated QoS cost of each input iw\u2032 matched by the outputs of the service w is recalculated. If there is an improvement (i.e., a match with a better QoS is discovered) the affected service is stored in updated to recompute its new aggregated QoS. Finally, for each service w \u2208 updated, we recompute its aggregated QoS using the updated values of each affected input. If the QoS has been improved, the service is added to the queue to expand it later."}, {"heading": "5.3 Graph optimizations", "text": "Finding the composition with the minimum number of services is a very hard combinatorial problem which,\nin most cases, has a very large search space, mainly determined by the size of the Service Match Graph. In order to improve the scalability with the number of services, we apply a set of admissible optimizations to reduce the search space. At each pass, the algorithm analyzes different criteria to identify services that are redundant or can be substituted by better ones, so the size of the graph decreases monotonically. The different passes that are sequentially applied are: 1) elimination of services that do not contribute to the outputs of the request; 2) pruning of services that lead to suboptimal QoS; 3) combination of interface (inputs/outputs) and QoS equivalent services; and 4) replacement of interface and QoS dominated services. These optimizations are an extension of the optimizations presented in [30] to support QoS.\nThe first pass selects the set of reachable services in the Service Match Graph. Starting from the inputs of Si, it selects all those services whose outputs match any inputs of Si. This step is repeated with the new services until the empty set is selected. Those services that were not selected do not contribute to the expected outputs of the composition and can be safely removed from the graph.\nThe second pass prunes the services of the graph that are suboptimal in terms of QoS, i.e., they cannot be part of any optimal QoS composition. To do so, we compute the maximum admissible QoS bound for each input in the graph. In a nutshell, the maximum bound of the inputs of a service w can be calculated by selecting the maximum QoS bound among the bounds of all inputs matched by the outputs of the service w and subtracting the QoS of w. This can be recursively defined as:\nmaxiQ(iw) =\n=\n{ VQ(w) FQ(w) if Outw = \u2205\nmax \u2200ow,\u2200iw\u2032\u2208chG(ow)\n(maxiQ(iw\u2032)) FQ(w) if Outw 6= \u2205\nThe value of maxiQ for each input in the graph can be easily calculated by propagating the bounds from Si to So. For example, in Fig. 1, we start computing the maximum bound of the inputs of Si (xsd:boolean). Since Si has no outputs, maxiQ(xsd:boolean) is calculated as VQ(Si) FQ(Si) = 410 ms \u2212 0 ms. Then, we select all the services whose outputs match xsd:boolean. In this case there is just one service, ML Predictor Service. The bounds of its inputs are now computed by subtracting out the FQ(ML Predictor Service) from the maximum bound of the inputs that this service matches. Since there is just one input matched (xsd:boolean from Si) whose bound is 410 ms, we have maxiQ(i) = 410ms\u2212 210ms = 200ms for each input i of the service. In the next step, we have three services that match the new calculated inputs (Free Geoloc Service, Premium Geoloc Service and Transaction Service). The maximum bounds of the inputs of these services are 200ms \u2212 180ms = 20ms, 200ms \u2212 40ms = 160ms and 200ms \u2212 130ms = 70ms respectively. Note that, since the maximum bound of Transaction Service is 70ms, the service Secure Payment is out of the bounds (its output QoS is 80 ms), so it can be safely pruned.\nThe third and the forth pass analyze service equivalences and dominances in the Service Match Graph. It is very frequent to find services from different providers that offer similar services with overlapping interfaces (inputs/outputs). In scenarios like this, it is easy to end up with large Service Match Graph that make very hard to find optimal compositions in reasonable time. One way to reduce the complexity without losing information is to analyze the interface equivalence and dominance between services in order to combine those that are equivalent, or replace those that are dominated in terms of the interface they provide and the QoS they offer. In a nutshell, we check three objectives to compare services: the amount of information they need to be invoked (inputs), the amount of information they return (outputs), and their QoS. If a set of services are equal in all objectives, they are equivalent and they can be combined into an abstract service with several possible implementations. If a service is equal in all objectives and at least better in one objective (it requires less information to be invoked, produces more information or has a better QoS), then the service dominates the other service. A more detailed description of the interface and dominance optimizations is described in [30].\nNote that optimizations are applied right before all semantic matches are computed in the Service Match Graph, since the optimizations are based on the analysis of the I/O matches among services. For this reason, they cannot be applied during the calculation of the graph\n(this would require to precompute in advance missing relations during the graph generation, which does not provide any benefit as this is what the Service Match Graph generation algorithm already does). On the other hand, optimizations are applied sequentially to save computation time, since the number of services in the graph decreases monotonically in each step. In order to take advantage of this, faster optimizations are applied first so that the slower optimizations in the pipeline can work with a reduced set of services."}, {"heading": "5.4 Hybrid algorithm", "text": "Each service in the composition graph may have different services that match each input, thus there may exist multiple combinations of services that satisfy the composition request with the same or different QoS. The goal of the hybrid search is to extract good solutions from the composition graph, optimizing the total number of involved services in the composition and guaranteeing the optimal QoS. Thus, for each input we select just one service of the graph to match that input, until the best combination is found. The hybrid search performs a local search to extract a good solution and in the remaining time, it tries to improve the solution by running a global search.\nFig. 5 shows the pseudocode of the local search strategy. The algorithm starts with a composition graph, the inputs of the service Si marked as unresolved (the expected outputs of the request) and the service Si selected to be part of the solution. An unresolved input is an input that can be matched by many different outputs but no decision has been made yet. Using the list of the unresolved inputs to be matched, the method RANKRESOLVERS returns a list of services that match any of the unresolved inputs. Services are ranked according to the number of unresolved inputs that match, so the service that matches more inputs is considered first to be part of the solution. Then, for each input that the selected service can match, the method CYCLE performs a forward search to check if resolving the selected input with that service leads to a cycle. For example, in Fig. 3, if we select the service K to match the input of I after having decided to resolve the input of K with the service I , we end up with an invalid composition, so K is an invalid resolver for I and it must be discarded. Once all resolvable inputs are collected in resolved, the method RESOLVE creates a copy of the current graph where the inputs in unresolved are matched only by the selected service, i.e., any other match between any output from a different service to that input is removed from the graph. If the selected service was not already selected, then all its inputs are then marked as unresolved and a recursive call to LSBT is performed to select a new service to resolve the remaining inputs, until a solution is found. If a dead end is reached (a solution that has no services to resolve the remaining inputs without cycles)\nthe algorithm backtracks to a previous state to try a different service (L.7).\nAn implementation of the CYCLE method is provided in 6. The algorithm performs a look-ahead check in a breadth-first fashion to determine whether matching the selected input i with an output of the service w leads to a cyclic dependency. This is done by traversing only the resolved matches, i.e., inputs that are matched by just one output of a service, until the selected service w is reached, proving the existence of a cycle. A more memory efficient implementation of the cycle algorithm can be done using the Tarjan\u2019s strongly connected components algorithm [38], stopping at the first strongly connected component detected.\nAfter the local search is used to find a good solution, the global search is performed in the remaining time to obtain a better solution by exhaustively exploring the space of possible solutions. In a nutshell, this algorithm works as follows: Given a Service Match Graph GS , with some unresolved inputs, which initially are the inputs of the service Si, the algorithm selects an input to be resolved and for each service candidate that can be used to resolve that input, it generates a copy of the graph GS but with the input resolved (i.e., the selected service is the only one that matches the unresolved input). The algorithm enqueues each new graph to be expanded again, and repeats the process by extracting the graph with the minimum number of services from the queue, until it eventually finds a graph with no unresolved inputs.\nFig. 7 shows the pseudocode of the global search\nalgorithm. The algorithm starts computing the optimal QoS of the graph with the method QoS-UPDATE. This method returns a key-value table qos[i, q] where each key corresponds with an input i of the graph, and each value q its optimal aggregated QoS q = V inQ (i). Then, the inputs of the service Si of the graph are added to Iun to mark them as unresolved (L.8). In order to minimize the number of possible candidates for each unresolved input, we compute and propagate a range of valid QoS values, called QoS bounds, and defined as an interval [min,max]. These bounds determine the range of valid accumulated QoS values of the outputs that can be used to match each of the unresolved inputs without exceeding the optimal end-to-end QoS of the final composition. The min value is the optimal QoS for the input, i.e., there is no output in the graph that can match the input with a lower QoS, whereas the max value is the maximum QoS value supported. If this bound is exceeded, the total aggregated QoS of the composition worsens. For example, in Fig. 1, the bounds of the input ont4:ClientID of the service Premium Geoloc Service are [20ms, 160ms]. If we exceed the min bound (20 ms), the output QoS of the service gets worse (> 60ms), which also affects the optimal QoS of the input ont1:Location. However, as long as the max bound is not exceeded (\u2264 160ms), the optimal accumulated QoS of the ML Predictor Service would not be affected.\nThe method COMPUTE-VQ is used to compute the value of the VQ function (Eq. 1) using the best QoS values of inputs, stored in qos (qos[i] = V inQ (i)). A tuple \u3008GS , Iun, qos,Wsel\u3009, where GS is the current graph, Iun are the unresolved inputs of GS , qos is the best aggregated QoS values for each input in GS and Wsel is the set of the selected services, defines the components of a partial solution. Each partial solution is stored in a priority queue, which is sorted by the number of services Wsel. This allows an exploration of the search\nspace in a breadth-first fashion, so the solution with the minimum number of services is always expanded first. At each iteration, a partial solution is extracted from the queue to be refined (L.12). If the partial solution has no unresolved inputs, the solution is complete, and has the minimum number of services. If the partial solution still has some unresolved inputs, it is refined by selecting an unresolved input with the method SELECT. This method selects the input to be resolved, using a minimum-remaining-values heuristic. This heuristic selects always the input with less resolvers (services candidates) in order to minimize the branching factor. The list of services that can match the selected input with a total aggregated QoS value within the [min,max] bound is calculated with the method RESOLVERS. For each valid service, the algorithm performs a look-ahead search to check whether using the current service to resolve the selected input leads to an unavoidable cycle. If so, the service is prematurely discarded to save computation time and space. If it does not lead to a cycle, then a copy of the graph (G\u2032S) with the selected input resolved is generated, and the input is also removed from the set of unresolved inputs. Using the optimal aggregated QoS values for the inputs of the graph, stored in qos, the algorithm computes the aggregated QoS value of the service w. If this value is worse than the min bound (COMPUTE-VQ(w, qos\u2032) min), then the aggregated QoS value of some inputs and outputs of the graph may be affected. Thus, a repropagation of the QoS values for each input and output is computed again over the new graph G\u2032S (L.22). For example, if the Business Service Info increments its response time to 40 ms, a repropagation is required to recompute the accumulated QoS of all the services that may be affected. In this case, the Premium Geoloc Service increments its accumulated QoS cost from 60 ms to 80 ms, as well as the optimal QoS of the ont1:Location.\nFinally, if the current service is not part of the current solution, its inputs are added to the unresolved table, and a new bound for each input is computed. The min bound corresponds with the optimal value, which is stored in qos\u2032. In order to compute the max bound, we need to subtract the QoS of the selected service (FQ(w)) from the max bound of the resolved input, using the operator (L.25). This new partial solution is inserted in the queue to be expanded later on."}, {"heading": "6 EVALUATION", "text": "In order to evaluate the performance of the proposed approach, we conducted two different experiments. In the first experiment, we evaluated the approach using the datasets of the Web Service Challenge 2009-2010 [39]. The goal of this first experiment was to evaluate the peformance and scalability of the proposed approach on large-scale service repositories. In the second experiment, we tested the algorithm with five random datasets in order to better analyze the differences of the performance\nbetween the local and the global search. All tests were executed with a time limit of 5 min. Solutions produced by our algorithm are represented as Service Composition Graphs (no BPEL was generated)."}, {"heading": "6.1 Web Service Challenge 2009-2010 datasets", "text": "The datasets of the Web Service Challenge 2009-2010 range from 572 to 15,211 services with two different QoS properties: response time and throughput. Table 2 shows the results obtained for each dataset and for each QoS property. The response time is the average time (measured in milliseconds) that a service takes to respond to a request. The throughput, as defined in the WSC, is the average ratio of invocations per second supported by a service.\nRow #Graph services shows the number of services of the composition graph and #Graph services (opt) the number of services after applying the graph optimizations. As can be seen, the optimizations reduce, on average, by 64% the number of services in the initial composition graph. This indicates that equivalence and dominance analysis of the QoS and the functionality of services is a\npowerful technique to reduce the search space in large scale problems. Rows Local search and Global search show the number of services of the solution obtained with each respective method as well as the total amount of time spent in the search. The global search found the best solution for each dataset and for each QoS property, except for the dataset 04, where the composition with the minimum number of services could not be found due to combinatorial explosion. However, in those cases, the local search strategy is able to find an alternative solution very fast. Note also that, in many cases, the local search obtains the best solution (comparing it with the global search) except for the throughput in datasets 03 and 05.\nWe have compared our approach with the top-3 of the Web Service Challenge 2010 [40]. Table 3 shows this comparison following the same format and the same rules of the Web Service Challenge. The format, rules and other details of the challenge are described in [40]. Third and forth columns show the response time and the throughput obtained for each dataset. Note that, since all these algorithms minimize a single QoS, these values are computed by executing the algorithm twice, one for each QoS. Unfortunately, the results provided by the WSC organization in [40] show only the minimum number of services for both executions (fifth column). Thus, the number of services obtained for both the response time and throughput is unknown, which makes it hard to compare with our results. Even so, using the same evaluation criteria, our approach obtains the optimal QoS for the response time and the throughput, and also improves the number of services in D-04 (40 vs 73) and D-05 (30 vs 32) with respect to the solutions obtained by the winner of the challenge (the minimum number of services obtained for each dataset is highlighted). The last column shows the total execution time of each algorithm. The total time includes the time spent to\nobtain the solution for the response time and for the throughput.\nOur approach takes, in general, more time to obtain a solution. However, it should be noted that we show the best results achieved by the hybrid approach, i.e., if the global search improves the solution of the local search, we show that solution along with the time taken by the global search. Anyway, the local search always provide a first good solution very fast. For example, as can be seen in Table 2, the optimal solution for D-05 has 30 services and has been obtained in 119.322 s, but the local search obtained a solution with 31 services in 2.56 s, still better than the solution with 32 services obtained by [4] (Table 3). Moreover, it should also be noted that the problem of finding the optimal composition with minimum number of services and optimal QoS is much harder than just optimizing the QoS objective function, which is the problem solved by the participants of the WSC 2010. Although the problem is intractable and requires exponential time, it can be optimally solved for many particular instances in a reasonable amount of time using adequate optimizations even in large datasets as shown in Tables 2 and 5. This is one of the main reasons why a combination of a local and global search can achieve good results in a wide variety of situations, in contrast with pure greedy strategies or with pure global optimization algorithms.\nWe also compare the results obtained with Chen et al. [7], who offer a detailed analysis of their results. This comparison is shown in Table 4. Solutions are compared according to their QoS and number of services. A solution is better if 1) its overall QoS is better or 2) has the same QoS but less services. The results show that our\nalgorithm always gets same or better results. Concretely, it finds solutions with optimal QoS and less services in D-01, D-02, D-04 and D-05 (response time), and D-03 (throughput). It also finds a solution with a better QoS (4000 inv/s vs 2000 inv/s) in D-04 (throughput)."}, {"heading": "6.2 Randomly generated datasets", "text": "Although the global search is able to obtain solutions with a lower number of services, a first look at the results with the WSC dataset might suggest that the difference of both strategies is not very significant, as most of the obtained solutions have the same number of services. However, this may be due to a bias in the repository, since all the datasets of the WSC are generated using the same random model. In order to better evaluate and characterize the performance of the hybrid algorithm, we generated a new set of five random datasets that range from 1,000 to 9,000 services. These datasets are available at https://wiki.citius.usc.es/inv: downloadable results:ws-random-qos. Table 5 shows the solutions obtained.\nWe found that in these datasets, the solutions obtained with the global search strategy are, on average,\n\u2248 16% smaller than the ones obtained with the local search, whereas the differences in seach time are less pronounced than in the previous experiment. These findings suggest that the performance of each strategy highly depends on the underlying structure of the service repository, which is mostly determined by the number of services and the existing matching relations.\nIn order to test whether these differences are statistically significant or not, we conducted a nonparametric test using the binomial sign test for two dependent samples with a total of 20 datasets (5 WSC w/response time + 5 WSC w/throughput + 5 Random w/response time + 5 Random w/throughput). The null hypothesis was rejected with p-value \u2248 0.01 [41], meaning that both strategies (local and global search) find significantly different solutions. Thus, a hybrid strategy can perform better in many different scenarios, since it achieves a good tradeoff between quality and execution time.\nThis evaluation shows that, on one hand, the combination of local and global optimization is a general and powerful technique to extract optimal compositions in diverse scenarios, as it brings the best of both worlds. This is specially important when only a little or nothing is known concerning the structure of the underlying repository of services. On the other hand, the results obtained with the Web Service Challenge 2009-2010 show that the hybrid strategy performs better than the stateof-the-art, obtaining solutions with less services and optimal QoS."}, {"heading": "7 CONCLUSIONS", "text": "In this paper we have presented a hybrid algorithm to automatically build semantic input-output based compositions minimizing the total number of services while guaranteeing the optimal QoS. The proposed approach combines a set of graph optimizations and a localglobal search to extract the optimal composition from the graph. Results obtained with the Web Service Challenge 2009-2010 datasets show that the combination of graph optimizations with a local-global search strategy performs better than the state-of-the-art, as it obtained solutions with less services and optimal QoS. Moreover, the evaluation with a set of randomly generated datasets shows that the hybrid strategy is well suited to perform compositions in diverse scenarios, as it can achieve a good tradeoff between quality and execution time."}, {"heading": "APPENDIX A COMPUTATIONAL COMPLEXITY", "text": "The calculation of the optimal QoS can be computed in polynomial time for a given Service Match Graph using classical shortest path algorithms such as Dijkstra or Bellman-Ford. But, as stated in the introduction, there can exist multiple solutions with the same global QoS but different number of services. Thus, in many scenarios, optimizing the QoS objective function is not enough to\nprovide the best possible answer. However, it turns out that optimizing the number of services of a composition is an intractable problem. The next theorem proves that the Service Minimization Problem (SMP) is a NP-Hard combinatorial optimization problem.\nTheorem. Finding the minimum number of services whose outputs match a given set of unresolved (unmatched) concepts is a NP-Hard combinatorial optimization problem.\nProof: We will show that the Service Minimization Problem (SMP) is NP-Hard by proving that the optimization version of the Set Cover Problem (SCP), a well-known NP-Hard problem, is polynomial-time Karp reducible to SMP SCP \u2264P SMP . The optimization version of the SCP problem is defined as follows: given a set of elements U = {u1, . . . , um} and a set S of subsets of U , find the smallest set (cover) C \u2286 S of subsets of S whose union is U . The decision version of this problem, stated as that of deciding whether exists a cover CSCP of size k or less (|CSCP | \u2264 k), is NP-Complete. We will also consider the simplest form of the SMP that can be contained in a Service Match Graph, which is defined as follows: given a service wU and a set of candidate services WS = {w1, . . . , wn} such that Ow1 \u2297 IwU 6= \u2205 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Own \u2297 IwU 6= \u2205, select the smallest subset of services from WS such that the union of the outputs of the services from WS , OWS , satisfies OWS \u2297 IwU = IwU , i.e., the outputs of the services contained in WS match all the inputs of wU . As in the SCP, the decision version of this optimization problem is defined as that of deciding whether exists a subset of candidate services CSMP of size k or less (|CSMP | \u2264 k) such that the union of the outputs of the services in CSMP match all the inputs of wU .\nIn order to prove that the SMP optimization problem is NP-Hard, we need to demonstrate that its corresponding decision problem is NP-Complete. We will therefore reduce the SCP problem by means of a function \u03d5 that transforms any arbitrary instance of the SCP into an instance of the SMP in polynomial time. We have to prove that 1) \u03d5(U, S) is a SMP problem; 2) \u03d5 runs in polynomial time; and 3) there is a set covering of \u03d5(U, S) of size k or less if and only if there is a set covering of U in S of size k or less.\nGiven a pair (U, S), we define \u03d5(U, S) = (wU ,WS) such that: \u2022 wU = {IwU = U = {u1, . . . , un}, \u2205}, where ui is the\nith unresolved input of wU . \u2022 \u2200si = {ui1 , . . . , uin} \u2208 S, \u2203wi \u2208 WS such that wi = {\u2205, Owi} and Owi \u2297 IwU = si\nBy this definition, the \u03d5(U, S) maps each element u \u2208 U to an input of the service wU . Each subset si \u2208 S is also mapped to a service whose outputs match exactly the inputs of wU that correspond with the elements of si. This mapping can be computed by adding a match from an arbitrary output of each service wi \u2208WS to each input ui \u2208 si, which clearly runs in linear time in the size of\nU . Moreover, \u03d5(U, S) is a Service Minimization Problem according to its definition.\nNow suppose there is a set covering |C| \u2264 k,C \u2286 S of U . Thus, \u2200u \u2208 U,\u2203ci \u2208 C such that u \u2208 c. From the services (wU ,WS) constructed from (U, S) by \u03d5(U, S), there exists wi \u2208 WS such that Owi \u2297 IwU = ci \u2286 IwU , and so \u22c3 i(Owi \u2297 IwU ) = IwU = C, i.e., the outputs of the services from the set WS of size k or less represent a cover of the Service Minimization Problem \u03d5(U, S)."}, {"heading": "APPENDIX B ALGORITHM ANALYSIS AND DISCUSSION", "text": "The proposed approach consists of a hybrid algorithm that optimizes both the global QoS and selects the composition with the minimum number of services that preserves the optimal QoS. As demonstrated in Appendix A, the problem of minimizing the number of services is NP-Hard. Thus, under the P 6= NP assumption, there is no polynomial time algorithm that can exactly solve this optimization problem. However, although it is in general intractable, in practice many instances of the problem, as shown in the evaluation section, can be optimally solved in reasonable time. In those situations, it may be preferable to provide optimal solutions instead of just sub-optimal ones. Our approach takes advantage of a hybrid strategy that combines a local search and a global search plus the use of preprocessing optimizations and search optimizations (minimum-remaining-values heuristic, cycle detection, QoS bounds propagation) in order to achieve a good trade-off between optimality of the solution and computation time. Here we analyze the complexity of the proposed techniques.\nB.1 Cycle detection The cycle detection is implemented as a Look-Ahead strategy, that traverses all the resolved matches, starting from the current service (the one selected to resolve a new unresolved input), until no more services are reachable. This strategy seeks to discover whether the current service is a valid candidate or not by checking if it can lead to a dependency cycle, so it can be prematurely discarded. The cycle detection algorithm takes O(|V |+|E|), since every service, input, output and match between inputs and outputs have to be traversed in worst-case.\nB.2 QoS Update The QoS update method calculates the optimal end-toend QoS through the graph. This method is also used to recalculate optimal QoS bounds whenever a local QoS bound is excedeed. This problem can be modeled as a shortest path problem with generalized costs for QoS (as shown in Section 4.3) and solved using Dijkstra\u2019s algorithm. The worst-case time complexity of this algorithm\nis as follows: given a Service Match Graph GS = (V,E), where WR \u2282 V is the set of services in the graph, there are at most |WR| calls to POP method to extract the lowest scored service from the queue. Since the queue is implemented as a binary heap, the POP and INSERT methods have a time of O(log(n)), where n is the size of the queue. Thus, in the worst case, the running time is O(|WR| \u00b7 log(|WR|)), plus the (at most) |E| updates of neighbor services that are reinserted into the queue. Therefore, the overall time is O((|E|+ |WR|) \u00b7 log(WR)).\nB.3 Local search\nThis method performs a heuristically guided local search to minimize the number of services of the optimal endto-end QoS composition. At each step, it selects the most promising candidate by selecting the one with fewer inputs that matches the largest number of unresolved inputs. If the algorithm gets stuck at some point, i.e., it reaches a point where no service can be selected without leading to a cyclic dependency, it backtracks to try the next most promising candidate service. The algorithm calls RANK-RESOLVERS to rank the candidates according to the number of unresolved inputs that each candidate can match and, in case of draw the service with less inputs is preferred. The sorting of services takes O(n \u00b7 log(n)) using merge sort, where n is the number of services. Each time a service is selected, the method RESOLVE creates an updated copy of the graph in O(|V |+ |E|).\nAssumming non-cyclic dependencies in the Service Match Graph, in the worst case the algorithm have to select all the services from the graph until no unresolved inputs are left. Thus, in the first step t|WR| the algorithm ranks all the |WR| services in O(|WR| \u00b7 log(|WR|)), selects the first one and generates a new copy of the graph in O(|V | + |E|). The running time of this step is O(|WR| \u00b7 log(|WR|) + O(|V | + |E|) = O(|WR| \u00b7 log(|WR|)). In the next step t|WR|\u22121, the algorithm ranks |WR| \u2212 1 services, selects the best one, creates a copy of the graph and so on. Therefore, the asymptotic upper bound of the running time of t|WR| + t|WR|\u22121 + \u00b7 \u00b7 \u00b7+ t1 is O(|WR| \u00b7 log(|WR|)).\nIn the absence of the assumption of non-cyclic dependencies, the asymptotic upper bound analysis shows that the time complexity grows exponentially with the depth of the search, since in the worst-case the algorithm fails (backtracks) at each step until the last combination of services is explored. However, in practice, this upper bound seems far from the average-case. As shown in the evaluation (Section 6), the growth of the time with respect to the size of the graph is closer to the bestcase scenario, since an exponential number of backtracks due to cylic dependencies is extremely rare. In any case, the algorithm can be easily adapted to perform better in the worst-case scenario, for example by limiting the number of candidates to the top-K best services for each unresolved input.\nB.4 Global search The aim of the global search algorithm is to perform an exhaustive search to find the minimum combination of services that satisfy the composition request with optimal QoS. The algorithm explores every possible valid combination of services in a breadth-first fashion by resolving one input at a time. For each unresolved input with k > 1 candidates, new k different states are created by calling the RESOLVE method and pushed to the queue for further expansion. In order to calculate an asymptotic upper bound for the time complexity, we can compute the number of combinations of services that the algorithm needs to extract from the queue in the worstcase. To this end, we first count the maximum number of combinations (solutions) that we can generate for a simple graph with fixed size and then we generalize the problem for a graph of any size.\nLeft graph from Figure 8 shows an example of a Service Match Graph with 4 services (excluding Si and So). As can be seen, Si requires two inputs, 1 and 2. On the other hand, the outputs of A and B match the input 1 whereas the outputs of services C and D match the input 2. Therefore, in order to match both inputs, we can select services A and C, A and D, B and C or B and D (2\u00d7 2 combinations). By computing all possible combinations, we can reduce the graph from the left, where Si has two inputs, to the graph from the right, where Si has just one input.\nIn general, given a service w with |Iw| = k inputs and c1, c2, . . . , ck set of candidate services for each input, there are \u220f i |ci| combinations of services, i.e., we can replace the k inputs with k sets of candidate services by one input with \u220f i |ci| candidates. Since each service can have in turn some inputs with other candidates, we can recursively replace each service with all the possible combinations of services that can be generated. This process leads to a flattening of the graph until there\nis just one level with all the possible combinations of services (compositions) that can be generated for a given Service Match Graph. Thus, the problem of counting the number of possible solutions in the worst-case can be reduced to the following: given a Service Match Graph with |WR| services, what is the maximum of products of partitions of WR? More formally, given a set S (|S| \u2265 1), choose n partitions c1, c2, . . . , cn such that \u2211 i |ci| = |S|\nand \u220f i |ci| is maximized. For example, given 11 services, we can take 3 groups of 3 services and one with the remaining 2 services, so the product of the partition is 33 \u00b7 2 = 54, which is the maximum. Finding an upper bound for this value will gives us an upper bound for the maximum number of compositions that can be enumerated in the worst-case, i.e., for the most complex Service Match Graph that can be generated with |WR| services. It can be proved that, for any set of size n, the maximum can be obtained by partitioning the set into groups of 2 and 3 elements, with no more than 2 groups of 2 elements. From this it follows that the maximum product is bounded by 3n/3, so we can conclude that O(3n/3) is a tight asymptotic upper bound on the running time in the worst-case.\nHowever, it should be noted that although the calculation of an optimal solution for the problem in the worst-case requires exponential time with the size of the graph, in practice, the number of services for a particular request is usually orders of magnitude lower that the number of available services in the dataset (see Table 2 and 4). In addition to this, the optimizations introduced in Section 5.3 plus the global QoS bound propagation, the minimum-remaining-values heuristic and cycle detection used in the global search are aimed to reduce further the size of the explored search space by decreasing the number of analyzed services."}, {"heading": "APPENDIX C DIFFERENCES WITH PREVIOUS WORK", "text": "In [30] we presented an integrated approach for discovery and composition of semantic Web services. However, the framework does not include any of the novelties that are presented in this approach. Our previous work presents an integrated framework for automatic I/O driven discovery and composition of semantic Web services and analyzes the impact of the discovery in the whole process, but with no QoS support. In contrast, in this work we present a hybrid composition algorithm that optimizes both QoS and the number of services, which is a different and a harder problem. The main differences are: \u2022 The Service Model has been extended to give sup-\nport for QoS properties. \u2022 The computation of the Service Match Graph for this\nproblem is different. In this work, all the semantic matches between all the services in the graph are computed in order to be able to guarantee\nan optimal end-to-end QoS. However, in [30], the Service Match Graph contains only the matches from the outputs of previous layers to the inputs of subsequent layers, i.e., the inputs of a service that appears in the ith layer can be matched only by the outputs of services that are in any jth layer where j \u2208 [0, i \u2212 1]. This condition is enough to find the smallest composition (in terms of number of services and length of the composition) but it is not enough to guarantee the optimal QoS since there are missing relations that can be part of the optimal solution. \u2022 Service Match Graph optimizations have been extended to take into account QoS. Also, a new step in the optimization pipeline has been included to prune suboptimal QoS services (i.e., services that cannot be part of the optimal solution). \u2022 The proposed composition algorithm is completely different. The algorithm from [30] is focused on the minimization of Web services using an A* algorithm with admissible state-space pruning. However, this technique is not enough to cope with the complexity of this new problem at large scale. Thus, we developed a new algorithm which consists of a hybrid strategy to optimize both global end-toend QoS and the number of services, which is a different and also a harder problem."}, {"heading": "ACKNOWLEDGMENT", "text": "This work was supported by the Spanish Ministry of Economy and Competitiveness (MEC) under grant TIN2014-56633-C3-1-R and the Galician Ministry of Education under the project CN2012/151. Pablo Rodr\u0131\u0301guezMier is supported by an FPU Grant from the MEC (ref. AP2010-1078)."}], "references": [{"title": "A Survey of Automated Web Service Composition Methods", "author": ["J. Rao", "X. Su"], "venue": "International Workshop on Semantic Web Services and Web Process Composition, 2004, pp. 43\u201354.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "QoS-Aware Service Composition: A Survey", "author": ["A. Strunk"], "venue": "IEEE European Conference on Web Services, 2010, pp. 67\u201374.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Two-Phase Graph Search Algorithm for QoS-Aware Automatic Service Composition", "author": ["W. Jiang", "S. Hu", "Z. Huang", "Z. Liu", "Q.D. Handler"], "venue": "International Conference on Service-Oriented Computing and Applications, 2010, pp. 1\u20134.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "A QoS-Driven Approach for Semantic Service Composition", "author": ["Y. Yan", "B. Xu", "Z. Gu", "S. Luo"], "venue": "IEEE International Conference on Commerce and Enterprise Computing, 2009, pp. 523\u2013526.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Optimal QoS-Aware Web Service Composition", "author": ["M. Aiello", "E.E. Khoury", "A. Lazovik", "P. Ratelband"], "venue": "IEEE International Conference on Commerce and Enterprise Computing, 2009, pp. 491\u2013494.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2009}, {"title": "Redundant Service Removal in QoS-Aware Service Composition", "author": ["M. Chen", "Y. Yan"], "venue": "IEEE International Conference on Web Services (ICWS), 2012, pp. 431\u2013439.  ACCEPTED TO APPEAR IN IEEE TRANSACTIONS ON SERVICES COMPUTING 2015, DOI 10.1109/TSC.2015.2480396  17", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Collaborative Web Service QoS Prediction via Neighborhood Integrated Matrix Factorization", "author": ["Z. Zheng", "H. Ma", "M.R. Lyu", "I. King"], "venue": "IEEE Transactions on Services Computing, vol. 6, no. 3, pp. 289\u2013299, 2013.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "A survey on web services composition", "author": ["S. Dustdar", "W. Schreiner"], "venue": "International Journal of Web and Grid Services, vol. 1, no. 1, pp. 1\u201330, 2005.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "Web Service Composition as Planning, Revisited: In Between Background Theories and Initial State Uncertainty", "author": ["J. Hoffmann", "P. Bertoli", "M. Pistore"], "venue": "Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence, 2007, pp. 1013\u20131018.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "SWORD : A Developer Toolkit for Web Service Composition", "author": ["S.R. Ponnekanti", "A. Fox"], "venue": "11th World Wide Web Conference, 2002.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Web Service Composition as Planning", "author": ["M. Carman", "L. Serafini", "P. Traverso"], "venue": "Workshop on planning for web services (ICAPS), 2003, pp. 1636\u20131642.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2003}, {"title": "HTN planning for Web Service composition using SHOP2", "author": ["E. Sirin", "B. Parsia", "D. Wu", "J. Hendler", "D. Nau"], "venue": "Web Semantics: Science, Services and Agents on the World Wide Web, vol. 1, no. 4, pp. 377\u2013396, 2004.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2004}, {"title": "Planning for Semantic Web Services", "author": ["E. Sirin", "B. Parsia"], "venue": "Semantic Web Services Workshop at 3rd International Semantic Web Conference, 2004, pp. 33\u201340.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2004}, {"title": "Semantic Web Service Composition Planning with OWLS-Xplan", "author": ["M. Klusch", "A. Gerber", "M. Schmidt"], "venue": "Proceedings of the AAAI Fall Symposium on Semantic Web and Agents, 2005.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2005}, {"title": "SEMAPLAN: Combining planning with semantic matching to achieve Web service composition", "author": ["R. Akkiraju", "B. Srivastava", "A.A. Ivan", "R. Goodwin", "T. Syeda- Mahmood"], "venue": "IEEE International Conference on Web Services (ICWS), 2006, pp. 37\u201344.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2006}, {"title": "An Integrated Approach to Automated Semantic Web Service Composition through Planning", "author": ["O. Hatzi", "D. Vrakas", "M. Nikolaidou", "N. Bassiliades", "D. Anagnostopoulos", "I. Vlahavas"], "venue": "IEEE Transactions on Services Computing, vol. 5, no. 3, pp. 1\u201314, 2012.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "Web Service Planner (WSPR): An Effective and Scalable Web Service Composition Algorithm", "author": ["S. Oh", "D. Lee", "S.R.T. Kumara"], "venue": "International Journal of Web Service Research, vol. 4, no. 1, pp. 1\u201322, 2007.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "Qos-Aware Middleware for Web Services Composition", "author": ["L. Zeng", "B. Benatallah", "A.H. Ngu", "M. Dumas", "J. Kalagnanam", "H. Chang"], "venue": "IEEE Transactions on Software Engineering, vol. 30, no. 5, pp. 311\u2013327, 2004.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2004}, {"title": "Service selection algorithms for Web services with end-to-end QoS constraints", "author": ["T. Yu", "K.-J. Lin"], "venue": "Information Systems and e- Business Management, vol. 3, no. 2, pp. 103\u2013126, 2005.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "Heuristics for QoS-aware Web Service Composition", "author": ["R. Berbner", "M. Spahn", "N. Repp", "O. Heckmann", "R. Steinmetz"], "venue": "International Conference on Web Services (ICWS), 2006, pp. 72\u201382.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2006}, {"title": "Combining global optimization with local selection for efficient QoS-aware service composition", "author": ["M. Alrifai", "T. Risse"], "venue": "18th International Conference on World Wide Web (WWW), 2009, pp. 881\u2013890.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "QoS- Aware Dynamic Composition of Web Services Using Numerical Temporal Planning", "author": ["G. Zou", "Q. Lu", "Y. Chen", "R. Huang", "Y. Xu", "Y. Xiang"], "venue": "IEEE Transactions on Services Computing, vol. 7, no. 1, pp. 18\u201331, 2014.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "An approach for QoS-aware service composition based on genetic algorithms", "author": ["G. Canfora", "M.D. Penta", "R. Esposito", "M.L. Villani"], "venue": "Genetic and Evolutionary Computation Conference (GECCO), 2005, pp. 1069\u20131075.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2005}, {"title": "E3: A Multiobjective Optimization Framework for SLA-Aware Service Composition", "author": ["H. Wada", "J. Suzuki", "Y. Yamano", "K. Oba"], "venue": " IEEE Transactions on Services Computing, vol. 5, no. 3, pp. 358\u2013372, 2012.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2012}, {"title": "Top K Query for QoS-Aware Automatic Service Composition", "author": ["W. Jiang", "S. Hu", "Z. Liu"], "venue": "IEEE Transactions on Services Computing, vol. 7, no. 4, pp. 681\u2013695, 2014.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2014}, {"title": "Efficient Multi- Granularity Service Composition", "author": ["L. Barakat", "S. Miles", "I. Poernomo", "M. Luck"], "venue": "IEEE International Conference on Web Services (ICWS), 2011, pp. 227\u2013234.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2011}, {"title": "QoS-aware Automatic Service Composition by Applying Functional Clustering", "author": ["F. Wagner", "F. Ishikawa", "S. Honiden"], "venue": "IEEE International Conference on Web Services (ICWS), 2011, pp. 89\u201396.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2011}, {"title": "Automatic web service composition with a heuristic-based search algorithm", "author": ["P. Rodriguez-Mier", "M. Mucientes", "M. Lama"], "venue": "IEEE International Conference on Web Services (ICWS), 2011, pp. 81\u201388.", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "An Integrated Semantic Web Service Discovery and Composition Framework", "author": ["P. Rodriguez Mier", "C. Pedrinaci", "M. Lama", "M. Mucientes"], "venue": "IEEE Transactions on Services Computing, 2015 (DOI 10.1109/TSC.2015.2402679).", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "Semantic Matching of Web Services Capabilities", "author": ["M. Paolucci", "T. Kawamura", "T.R. Payne", "K.P. Sycara"], "venue": "The Semantic Web - ISWC 2002, 2002, pp. 333\u2013347.", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}, {"title": "iServe: a linked services publishing platform", "author": ["C. Pedrinaci", "D. Liu", "M. Maleshkova", "D. Lambert", "J. Kopecky", "J. Domingue"], "venue": "CEUR Workshop Proceedings, vol. 596, 2010.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2010}, {"title": "Quality of service for workflows and web service processes", "author": ["J. Cardoso", "A. Sheth", "J. Miller", "J. Arnold", "K. Kochut"], "venue": "Web Semantics, vol. 1, pp. 281\u2013308, 2004.", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2004}, {"title": "Graphs and networks", "author": ["B. Carr\u00e9"], "venue": null, "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1979}, {"title": "An Optimal and Complete Algorithm for Automatic Web Service Composition", "author": ["P. Rodr\u0131\u0301guez-Mier", "M. Mucientes", "J.C. Vidal", "M. Lama"], "venue": "International Journal of Web Service Research, vol. 9, no. 2, pp. 1\u201320, 2012.", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2012}, {"title": "A Dynamic QoS-Aware Semantic Web Service Composition Algorithm", "author": ["P. Rodriguez-Mier", "M. Mucientes", "M. Lama"], "venue": "International Conference on Service-Oriented Computing (ICSOC), 2012, pp. 623\u2013630.", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2012}, {"title": "Algebra and algorithms for QoS path computation and hop-by-hop routing in the internet", "author": ["J.L. Sobrinho"], "venue": "IEEE/ACM Transactions on Networking, vol. 10, no. 4, pp. 541\u2013550, 2002.", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2002}, {"title": "Depth-first search and linear graph algorithms", "author": ["R. Tarjan"], "venue": "SIAM journal on computing, vol. 1, no. 2, pp. 146\u2013160, 1972.", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1972}, {"title": "WSC- 2009: a quality of service-oriented web services challenge", "author": ["S. Kona", "A. Bansal", "M.B. Blake", "S. Bleul", "T. Weise"], "venue": "IEEE International Conference on Commerce and Enterprise Computing, 2009, pp. 487\u2013490.", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2009}, {"title": "Web Service Challenge 2010", "author": ["T. Weise"], "venue": "http://www.it-weise. de/documents/files/W2010WSC pres.pdf, 2010, [Online; accessed May-2015].", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2010}, {"title": "STAC: a web platform for the comparison of algorithms using statistical tests", "author": ["I. Rodr\u0131\u0301guez-Fdez", "A. Canosa", "M. Mucientes", "A. Bugar\u0131\u0301n"], "venue": "IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), 2015.", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "This has motivated researchers to explore efficient strategies to generate QoS-aware Web service compositions from different perspectives [2], [3].", "startOffset": 138, "endOffset": 141}, {"referenceID": 1, "context": "This has motivated researchers to explore efficient strategies to generate QoS-aware Web service compositions from different perspectives [2], [3].", "startOffset": 143, "endOffset": 146}, {"referenceID": 2, "context": "Some notable examples are [4]\u2013[7].", "startOffset": 26, "endOffset": 29}, {"referenceID": 5, "context": "Some notable examples are [4]\u2013[7].", "startOffset": 30, "endOffset": 33}, {"referenceID": 6, "context": "Although the prediction of QoS can partially alleviate this problem [8], it is not always possible to have historical data in order to build statistical models to accurately predict missing QoS.", "startOffset": 68, "endOffset": 71}, {"referenceID": 0, "context": "Automatic composition of services is a fundamental and complex problem in the field of Service Oriented Computing, which has been approached from many different perspectives depending on what kinds of assumptions are made [2], [3], [9], [10].", "startOffset": 222, "endOffset": 225}, {"referenceID": 1, "context": "Automatic composition of services is a fundamental and complex problem in the field of Service Oriented Computing, which has been approached from many different perspectives depending on what kinds of assumptions are made [2], [3], [9], [10].", "startOffset": 227, "endOffset": 230}, {"referenceID": 7, "context": "Automatic composition of services is a fundamental and complex problem in the field of Service Oriented Computing, which has been approached from many different perspectives depending on what kinds of assumptions are made [2], [3], [9], [10].", "startOffset": 232, "endOffset": 235}, {"referenceID": 8, "context": "Automatic composition of services is a fundamental and complex problem in the field of Service Oriented Computing, which has been approached from many different perspectives depending on what kinds of assumptions are made [2], [3], [9], [10].", "startOffset": 237, "endOffset": 241}, {"referenceID": 9, "context": "AI Planning techniques have been traditionally used in service composition to generate valid composition plans by mapping services to actions in the planning domain [11]\u2013[16].", "startOffset": 165, "endOffset": 169}, {"referenceID": 14, "context": "AI Planning techniques have been traditionally used in service composition to generate valid composition plans by mapping services to actions in the planning domain [11]\u2013[16].", "startOffset": 170, "endOffset": 174}, {"referenceID": 11, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 84, "endOffset": 88}, {"referenceID": 14, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 90, "endOffset": 94}, {"referenceID": 15, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 96, "endOffset": 100}, {"referenceID": 13, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 127, "endOffset": 131}, {"referenceID": 14, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 133, "endOffset": 137}, {"referenceID": 16, "context": "Most of these approaches have been mainly focused on exploiting semantic techniques [13], [16], [17] and developing heuristics [15], [16], [18] to improve the performance of the planners.", "startOffset": 139, "endOffset": 143}, {"referenceID": 17, "context": "A common strategy is to reduce the composition problem to a combinatorial Knapsack-based problem, which is generally solved using constraint satisfaction algorithms (such as Integer Programming) [19]\u2013[23] or Evolutionary Algorithms [24], [25].", "startOffset": 195, "endOffset": 199}, {"referenceID": 21, "context": "A common strategy is to reduce the composition problem to a combinatorial Knapsack-based problem, which is generally solved using constraint satisfaction algorithms (such as Integer Programming) [19]\u2013[23] or Evolutionary Algorithms [24], [25].", "startOffset": 200, "endOffset": 204}, {"referenceID": 22, "context": "A common strategy is to reduce the composition problem to a combinatorial Knapsack-based problem, which is generally solved using constraint satisfaction algorithms (such as Integer Programming) [19]\u2013[23] or Evolutionary Algorithms [24], [25].", "startOffset": 232, "endOffset": 236}, {"referenceID": 23, "context": "A common strategy is to reduce the composition problem to a combinatorial Knapsack-based problem, which is generally solved using constraint satisfaction algorithms (such as Integer Programming) [19]\u2013[23] or Evolutionary Algorithms [24], [25].", "startOffset": 238, "endOffset": 242}, {"referenceID": 17, "context": "Some relevant approaches are [19], [22].", "startOffset": 29, "endOffset": 33}, {"referenceID": 20, "context": "Some relevant approaches are [19], [22].", "startOffset": 35, "endOffset": 39}, {"referenceID": 17, "context": "In [19] the authors present AgFlow, a QoS middleware for service composition.", "startOffset": 3, "endOffset": 7}, {"referenceID": 20, "context": "Similarly, in [22] the authors propose a hybrid QoS selection approach that combines a global optimization strategy with local selection for large-scale QoS composition.", "startOffset": 14, "endOffset": 18}, {"referenceID": 2, "context": "Some relevant approaches in this category are the top-3 winners of the Web Service Challenge (WSC) 2009-2010 [4]\u2013[6].", "startOffset": 109, "endOffset": 112}, {"referenceID": 4, "context": "Some relevant approaches in this category are the top-3 winners of the Web Service Challenge (WSC) 2009-2010 [4]\u2013[6].", "startOffset": 113, "endOffset": 116}, {"referenceID": 2, "context": "Concretely, the winners of the WSC challenge [4], presented an approach that automatically", "startOffset": 45, "endOffset": 48}, {"referenceID": 24, "context": "[26].", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "Another interesting graph-based approach has been presented in [7].", "startOffset": 63, "endOffset": 66}, {"referenceID": 25, "context": "Results show that service removal techniques can be very effective to reduce the number of services before extracting the final composition, as anticipated by other similar approaches [27]\u2013[29].", "startOffset": 184, "endOffset": 188}, {"referenceID": 27, "context": "Results show that service removal techniques can be very effective to reduce the number of services before extracting the final composition, as anticipated by other similar approaches [27]\u2013[29].", "startOffset": 189, "endOffset": 193}, {"referenceID": 28, "context": "This model is an extension of a previous model used in [30] to include QoS properties.", "startOffset": 55, "endOffset": 59}, {"referenceID": 29, "context": "The different matchmaking degrees that are contemplated are exact, plugin, subsumes and fail [31].", "startOffset": 93, "endOffset": 97}, {"referenceID": 30, "context": "For further details see [32].", "startOffset": 24, "endOffset": 28}, {"referenceID": 31, "context": "In order to define the common rules to operate with QoS values in composite services, many approaches use a QoS computation model based on workflow patterns [33], which is adequate to measure the QoS of controlflow based compositions.", "startOffset": 157, "endOffset": 161}, {"referenceID": 32, "context": "In this section we explain the general graph-centric QoS computation model that we use, based on the path algebra defined in [34].", "startOffset": 125, "endOffset": 129}, {"referenceID": 33, "context": "In a nutshell, the generation of the graph is calculated by selecting all invocable services layer by layer, starting with So in the first layer (the source service whose outputs are the inputs of the request) and terminating with Si in the last layer (the sink service whose inputs are the outputs of the request) [35].", "startOffset": 315, "endOffset": 319}, {"referenceID": 34, "context": "In order to compute the optimal QoS, we use a generalized Dijkstrabased label-setting algorithm computed forwards from So to Si [36], based on the algebraic model of the QoS presented in Sec.", "startOffset": 128, "endOffset": 132}, {"referenceID": 35, "context": "A proof can be found in [37].", "startOffset": 24, "endOffset": 28}, {"referenceID": 28, "context": "These optimizations are an extension of the optimizations presented in [30] to support QoS.", "startOffset": 71, "endOffset": 75}, {"referenceID": 28, "context": "A more detailed description of the interface and dominance optimizations is described in [30].", "startOffset": 89, "endOffset": 93}, {"referenceID": 36, "context": "A more memory efficient implementation of the cycle algorithm can be done using the Tarjan\u2019s strongly connected components algorithm [38], stopping at the first strongly connected component detected.", "startOffset": 133, "endOffset": 137}, {"referenceID": 37, "context": "In the first experiment, we evaluated the approach using the datasets of the Web Service Challenge 2009-2010 [39].", "startOffset": 109, "endOffset": 113}, {"referenceID": 38, "context": "We have compared our approach with the top-3 of the Web Service Challenge 2010 [40].", "startOffset": 79, "endOffset": 83}, {"referenceID": 38, "context": "The format, rules and other details of the challenge are described in [40].", "startOffset": 70, "endOffset": 74}, {"referenceID": 38, "context": "Unfortunately, the results provided by the WSC organization in [40] show only the minimum number of services for both executions (fifth column).", "startOffset": 63, "endOffset": 67}, {"referenceID": 2, "context": "D-01 CAS [4] 500 15,000 5 78", "startOffset": 9, "endOffset": 12}, {"referenceID": 4, "context": "RUG [6] 500 15,000 10 188", "startOffset": 4, "endOffset": 7}, {"referenceID": 3, "context": "Tsinghua [5] 500 15,000 9 109", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": "D-02 CAS [4] 1,690 6,000 20 94", "startOffset": 9, "endOffset": 12}, {"referenceID": 4, "context": "RUG [6] 1,690 6,000 40 234", "startOffset": 4, "endOffset": 7}, {"referenceID": 3, "context": "Tsinghua [5] 1,690 6,000 36 140", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": "D-03 CAS [4] 760 4,000 10 78", "startOffset": 9, "endOffset": 12}, {"referenceID": 4, "context": "RUG [6] 760 4,000 11 234", "startOffset": 4, "endOffset": 7}, {"referenceID": 3, "context": "Tsinghua [5] 760 4,000 18 125", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": "D-04 CAS [4] 1,470 4,000 73 156", "startOffset": 9, "endOffset": 12}, {"referenceID": 4, "context": "RUG [6] 1470 4,000 133 390", "startOffset": 4, "endOffset": 7}, {"referenceID": 3, "context": "Tsinghua [5] 1,470 4,000 133 188", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": "D-05 CAS [4] 4,070 4,000 32 63", "startOffset": 9, "endOffset": 12}, {"referenceID": 4, "context": "RUG [6] 4,070 4,000 4,772 907", "startOffset": 4, "endOffset": 7}, {"referenceID": 3, "context": "Tsinghua [5] 4,070 4,000 4,772 531", "startOffset": 9, "endOffset": 12}, {"referenceID": 2, "context": "56 s, still better than the solution with 32 services obtained by [4] (Table 3).", "startOffset": 66, "endOffset": 69}, {"referenceID": 5, "context": "[7], who offer a detailed analysis of their results.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "TABLE 4 Detailed comparison with [7]", "startOffset": 33, "endOffset": 36}, {"referenceID": 39, "context": "01 [41], meaning that both strategies (local and global search) find significantly different solutions.", "startOffset": 3, "endOffset": 7}, {"referenceID": 28, "context": "In [30] we presented an integrated approach for discovery and composition of semantic Web services.", "startOffset": 3, "endOffset": 7}, {"referenceID": 28, "context": "However, in [30], the Service Match Graph contains only the matches from the outputs of previous layers to the inputs of subsequent layers, i.", "startOffset": 12, "endOffset": 16}, {"referenceID": 28, "context": "The algorithm from [30] is focused on the minimization of Web services using an A* algorithm with admissible state-space pruning.", "startOffset": 19, "endOffset": 23}], "year": 2015, "abstractText": "In this paper we present a hybrid approach for automatic composition of Web services that generates semantic inputoutput based compositions with optimal end-to-end QoS, minimizing the number of services of the resulting composition. The proposed approach has four main steps: 1) generation of the composition graph for a request; 2) computation of the optimal composition that minimizes a single objective QoS function; 3) multi-step optimizations to reduce the search space by identifying equivalent and dominated services; and 4) hybrid local-global search to extract the optimal QoS with the minimum number of services. An extensive validation with the datasets of the Web Service Challenge 2009-2010 and randomly generated datasets shows that: 1) the combination of local and global optimization is a general and powerful technique to extract optimal compositions in diverse scenarios; and 2) the hybrid strategy performs better than the state-of-the-art, obtaining solutions with less services and optimal QoS. Keywords\u2014Service Composition; Service Optimization; Hybrid Algorithm; QoS-aware; Semantic Web Services.", "creator": "LaTeX with hyperref package"}}}