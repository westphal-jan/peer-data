{"id": "1511.00924", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Nov-2015", "title": "Bound Your Models! How to Make OWL an ASP Modeling Language", "abstract": "To exploit the Web Ontology Language OWL as an answer set programming (ASP) language, we introduce the notion of bounded model semantics, as an intuitive and computationally advantageous alternative to its classical semantics. We show that a translation into ASP allows for solving a wide range of bounded-model reasoning tasks, including satisfiability and axiom entailment but also novel ones such as model extraction and enumeration. Ultimately, our work facilitates harnessing advanced semantic web modeling environments for the logic programming community through an \"off-label use\" of OWL as an alternative to the classical semantics of ASP. This approach leads to a more complex approach to software architecture. The OWL is a distributed, open source, distributed and open source implementation of ASP.NET applications. Each of the applications are also considered as a part of the application and we believe that the underlying OWL approach will improve the performance of the application in large numbers.", "histories": [["v1", "Tue, 3 Nov 2015 14:38:53 GMT  (42kb)", "http://arxiv.org/abs/1511.00924v1", "International Workshop on User-Oriented Logic Programming (IULP 2015), co-located with the 31st International Conference on Logic Programming (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz, pages 33-49, August 2015"]], "COMMENTS": "International Workshop on User-Oriented Logic Programming (IULP 2015), co-located with the 31st International Conference on Logic Programming (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz, pages 33-49, August 2015", "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["sarah alice gaggl", "sebastian rudolph", "lukas schweizer"], "accepted": false, "id": "1511.00924"}, "pdf": {"name": "1511.00924.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Sarah Alice Gaggl", "Sebastian Rudolph", "Lukas Schweizer"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n51 1.\n00 92\n4v 1\n[ cs\n.P L\n] 3\nN ov\n2 01\nKeywords: Answer Set Programming, Bounded-Model Semantics, Semantic Web"}, {"heading": "1 Introduction", "text": "Answer set programming (ASP) is a powerful declarative language for knowledge representation and reasoning [4]. In ASP the knowledge is encoded in a set of logical rules and interpreted under the stable model semantics [8,9]. Recent developements led to powerful systems e.g. dlv [17], and gringo/clasp [6], to name some of them, which are capable to solve a large variety of problems [7]. In particular, ASP has shown to be well suited for big combinatorial search problems, as the dedicated solvers are specially designed to enumerate all solutions [2].\nHowever, it has often been noted that, while being a powerful and versatile formalism, popularity and widespread adoption of logic programming in general and answer set programming in particular is hindered by the non-availability of user-friendly and scalable editing environments.\nOn the other side, formalisms coming with a more elaborate modeling tool support \u2013 most notably the Web Ontology Language OWL [31] \u2013 are often preferred, even if the application scenario actually is of a constraint-satisfaction type which does not go well with OWL\u2019s standard semantics allowing for models of arbitrary size. Ontology editors like Prote\u0301ge\u0301 [16] provide user-friendly interfaces and combined with the natural language alike Manchester syntax [12] possesses perspicuous access to a presumably complex and involved formalism.\nWe propose bounded model reasoning as an intuitive and simple approach to overcome this situation. Thereby, we endow OWL with a non-standard modeltheoretic semantics and modifying the modelhood condition by restricting the\ndomain to a finite set of bounded size, induced by the named individuals occurring in the given OWL ontology. We note that this additional condition can be axiomatized in the latest version of OWL. While reasoning in OWL under the classical semantics is N2ExpTime-complete [15], we show that reasoning under the bounded model semantics is merely NP-complete. Still, employing the axiomatization, existing OWL reasoners struggle on bounded model reasoning, due to the heavy combinatorics involved.\nTherefore, we propose a different approach and definine a translation of SROIQ knowledge bases (the logical counterparts to OWL ontologies) into answer set programs [4], such that the set of bounded models coincides with the set of answer sets of the obtained program, allowing us to use existing answer set solvers (see [2] for an overview) for bounded model reasoning. Next to the inferencing tasks typically used in semantic web technologies, this approach also allows for solving other, non-standard reasoning problems like model enumeration.\nThe benefits are manifolded, whereas in this work we particularly emphasize OWL as modeling language for typical constraint-satisfaction-type problems. The translation based approach can be seen as higher-level layer on top of the ASP language. Although we focus on the description logic SROIQ and its native DL syntax, other syntax specifications like the OWL 2 Manchester Syntax [12] very well strive towards user-friendliness by means of natural language features.\nWe have implemented the proposed approach, for which first preliminary evaluations on typical constraint-satisfaction-type problems not only demonstrate feasibility, but also suggest significant improvement compared to the axiomatized approach using highly optimized OWL reasoners.\nThe article is organized as follows. In Section 2 we introduce the necessary background on description logics and ASP. Then, in Section 3 we define the bounded model semantics and analyze their complexity. The particular encoding of a SROIQ knowledge base into ASP is given in Section 4. A preliminary evaluation of the implemented system is summarized in Section 5. Finally, we conclude in Section 6 and discuss possible future directions."}, {"heading": "2 Preliminaries", "text": "In this section we provide the necessary background of description logics and answer set programming."}, {"heading": "2.1 Description Logics", "text": "OWL 2 DL, the version of the Web Ontology Language we focus on, is defined based on description logics (DLs, [3,25]). We briefly recap the description logic SROIQ (for details see [13]). Let NI , NC , and NR be finite, disjoint sets called individual names, concept names and role names respectively. These atomic entities can be used to form complex ones as displayed in Table 1. A SROIQ knowledge base is a tuple (A, T ,R) where A is a SROIQ ABox, T is a SROIQ\nTBox and R is a SROIQ RBox. Table 2 presents the respective axiom types available in the three parts, and we will refer to each TBox axiom as general concept inclusion (GCI). The original definition of SROIQ contained more RBox axioms (expressing transitivity, (a)symmetry, (ir)reflexivity of roles), but these can be shown to be syntactic sugar. Moreover, the definition of SROIQ contains so-called global restrictions which prevents certain axioms from occurring together. These complicated restrictions, while crucial for the decidability of classical reasoning in SROIQ are not necessary for the bounded-model reasoning considered here, hence we omit them for the sake of brevity.\nThe semantics of SROIQ is defined via interpretations I = (\u2206I , \u00b7I) composed of a non-empty set \u2206I called the domain of I and a function \u00b7I mapping individual names to elements of \u2206I , concept names to subsets of \u2206I and role names to subsets of \u2206I \u00d7 \u2206I . This mapping is extended to complex role and concept expressions (cf. Table 1) and finally used to define satisfaction of axioms (see Table 2). We say that I satisfies a knowledge base K = (A, T ,R) (or I is a model of K, written: I |= K) if it satisfies all axioms of A, T , and R. We say\nthat a knowledge base K entails an axiom \u03b1 (written K |= \u03b1) if all models of K are models of \u03b1."}, {"heading": "2.2 Answer-Set Programming", "text": "We give a brief overview of the syntax and semantics of disjunctive logic programs under the answer-sets semantics [9]. We fix a countable set U of (domain) elements, also called constants ; and suppose a total order < over the domain elements. An atom is an expression p(t1, . . . , tn), where p is a predicate of arity n \u2265 0 and each ti is either a variable or an element from U . An atom is ground if it is free of variables. BU denotes the set of all ground atoms over U . A (disjunctive) rule \u03c1 is of the form\na1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 an \u2190 b1, . . . , bk, not bk+1, . . . , not bm,\nwith n \u2265 0, m \u2265 k \u2265 0, n+m > 0, where a1, . . . , an, b1, . . . , bm are atoms, or a count expression of the form #count{l : l1, . . . , li} \u22b2\u22b3 u, where l is an atom and lj = pj or lj = not pj , for pj an atom, 1 \u2264 j \u2264 i, u a non-negative integer, and \u22b2\u22b3 \u2208 {\u2264, <,=, >,\u2265}. Moreover, \u201cnot \u201d denotes default negation. The head of \u03c1 is the setH(\u03c1) = {a1, . . . , an} and the body of \u03c1 is B(\u03c1) = {b1, . . . , bk, not bk+1, . . . , not bm}. Furthermore, B +(\u03c1) = {b1, . . . , bk} and B \u2212(\u03c1) = {bk+1, . . . , bm}. A rule \u03c1 is normal if n \u2264 1 and a constraint if n = 0. A rule \u03c1 is safe if each variable in \u03c1 occurs in B+(r). A rule \u03c1 is ground if no variable occurs in \u03c1. A fact is a ground rule with empty body and no disjunction. An (input) database is a set of facts. A program is a finite set of rules. For a program \u03a0 and an input database D, we often write \u03a0(D) instead of D \u222a\u03a0 . If each rule in a program is normal (resp. ground), we call the program normal (resp. ground).\nFor any program\u03a0 , let U\u03a0 be the set of all constants appearing in \u03a0 . Gr (\u03a0) is the set of rules \u03c1\u03c3 obtained by applying, to each rule \u03c1 \u2208 \u03a0 , all possible substitutions \u03c3 from the variables in \u03c1 to elements of U\u03a0 . For count-expressions, {l : l1, . . . , ln} denotes the set of all ground instantiations of l, governed through {l1, . . . , ln}. An interpretation I \u2286 BU satisfies a ground rule \u03c1 iff H(\u03c1) \u2229 I 6= \u2205 whenever B+(\u03c1) \u2286 I, B\u2212(\u03c1) \u2229 I = \u2205, and for each contained count-expression, N \u22b2\u22b3 u holds, where N is the cardinality of the set of ground instantiations of l, N = |{l | l1, . . . , ln}|, for \u22b2\u22b3 \u2208 {\u2264, <,=, >,\u2265} and u a non-negative integer. I satisfies a ground program \u03a0 , if each \u03c1 \u2208 \u03a0 is satisfied by I. A non-ground rule \u03c1 (resp., a program \u03a0) is satisfied by an interpretation I iff I satisfies all groundings of \u03c1 (resp., Gr(\u03a0)). I \u2286 BU is an answer set of \u03a0 iff it is a subsetminimal set satisfying the Gelfond-Lifschitz reduct \u03a0I = {H(\u03c1) \u2190 B+(\u03c1) | I \u2229 B\u2212(\u03c1) = \u2205, \u03c1 \u2208 Gr(\u03a0)}. For a program \u03a0 , we denote the set of its answer sets by AS(\u03a0)."}, {"heading": "3 Bounded Models", "text": "When reasoning in description logics, models can be of arbitrary cardinality. In many applications, however, the domain of interest is known to be finite. In\nfact, restricting DL reasoning to models of finite domain size (called finite model reasoning, a natural assumption in database theory), has become the focus of intense studies lately [18,5,24].\nAs opposed to assuming the domain to be merely finite (but of arbitrary, unknown size), we consider the case where the domain has an a priori known cardinality, more precisely, when the domain coincides with the set of named individuals mentioned in the knowledge base. We refer to such models as bounded models and argue that in many applications this modification of the standard DL semantics represents a more intuitive definition of what is considered and expected as model of some knowledge base.1\nDefinition 1 (Bounded-Model Semantics). Let K be a SROIQ knowledge base. An interpretation I = (\u2206I , \u00b7I) is said to be individual-bounded w.r.t. K, if all of the following holds:\n1. \u2206I = {a | a \u2208 NI(K)}, 2. for each individual a \u2208 NI(K), aI = a.\nAccordingly, we call an interpretation I (individual-)bounded model of K, if I is an individual-bounded interpretation w.r.t. K and I |= K holds. A knowledge base K is called bounded-model-satisfiable if it has a bounded model. We say K bounded-model-entails an axiom \u03b1 (written K |=bm \u03b1) if every bounded model of K is also a model of \u03b1.\nNote that, under the bounded-model semantics, there is a one-to-one correspondence between (bounded) interpretations and sets of ground facts, if one assumes the set of domain elements fixed and known. That is, for every bounded-model interpretation I = (\u2206I , \u00b7I), we find exactly one Abox AI with atomic concept assertions and role assertions defined by AI := {r(a, b) | (a, b) \u2208 rI} \u222a {A(a) | a \u2208 AI} and likewise, every such Abox A gives rise to a corresponding interpretation IA. This allows us to use ABoxes as representations of models.\nWe briefly demonstrate the effects of bounded model semantics as opposed to finite model semantics (with entailment |=fin) and the classical semantics. Let K = (A, T ,R) with A = {A(a), A(b), s(a, b)}, T = {\u22a4 \u2291 \u2203r.B,\u22a4 \u2291 61 r\u2212.\u22a4}, and R = {Dis(s, r)}. First we note that K has a bounded (hence finite) model I representable as AI = {A(a), A(b), B(a), B(b), s(a, b), r(a, a), r(b, b)}, thus K is satisfiable under all three semantics. Then \u03b1 = \u22a4 \u2291 \u2203r.\u2203r.B holds in all models of K, therefore K |= \u03b1, K |=fin \u03b1, and K |=bm \u03b1. Opposed to this, \u03b2 = \u22a4 \u2291 B merely holds in all finite models, whence K |=fin \u03b2 and K |=bm \u03b2, but K 6|= \u03b2. Finally, \u03b3 = \u22a4 \u2291 \u2203r.Self only holds in all bounded models, thus K |=bm \u03b3, but K 6|=fin \u03b3 and K 6|= \u03b3.\n1 In fact, when working with practicioners performing modeling tasks in OWL, we often found this to be their primary intuition, and OWL to be \u201cabused\u201d as a constraint language for an underlying fixed domain."}, {"heading": "3.1 Extraction & Enumeration of Bounded Models", "text": "When performing satisfiability checking in DLs (the primary reasoning task considered there), a model constructed by a reasoner merely serves as witness to claim satisfiability, rather than an accessible artifact. However, as mentioned before, our approach aims at scenarios where a knowledge base is a formal problem description for which each model represents one solution. Then, retrieval of one, several, or all models is a natural task, as opposed to merely checking existence. With model extraction we denote the task of materializing an identified model in order to be able to work with it, i.e. to inspect it in full detail and reuse it in downstream processes. The natural continuation of model extraction is to make all models explicit, performing model enumeration. Conveniently, for both tasks we can use the introduced model representation via ABoxes.\nMost existing DL reasoning algorithms attempt to successively construct a model representation of a given knowledge base. However, most of the existing tableaux reasoners do not reveal the constructed model, besides the fact that in the non-bounded case models might end up being infinite such that an explicit representation is impossible. Regarding enumeration, we state that this task is not supported \u2013 not even implicitly \u2013 by any state-of-the-art DL reasoner, also due to the reason that in the non-bounded case, the number of models is typically infinite and even uncountable. We want to stick to the notions of model extraction and enumeration as their meaning should be quite intuitive. Although, in the general first-order case the term model expansion is used, e.g. in the work of Mitchell and Ternovska [19]. There, an initial (partial) interpretation representing a problem instance is expanded to ultimately become a model for the encoded problem."}, {"heading": "3.2 Complexity of Bounded Model Reasoning", "text": "The combined complexity of reasoning in SROIQ over arbitrary interpretations is known to be N2ExpTime-complete [15]. Still, it is considered to be usable in practice since worst-case knowledge bases would be of very artificial nature. Restricting to bounded models leads to a drastic drop in complexity.\nTheorem 1. The combined complexity of checking bounded-model satisfiability of SROIQ knowledge bases is NP-complete.\nProof. (Sketch) To show membership, we note that after guessing an interpretation I, (bounded) modelhood can be checked in polynomial time. For this we let C contain all the concept expressions occurring in K (including subexpressions). Furthermore, let R contain all role expressions and role chains (including subchains) occurring in K. Obviously, C and R are of polynomial size. Then, in a bottom-up fashion, we can compute the extension CI of every element C of C and the extension rI of every element r of R along the defined semantics. Obviously, each such computation step requires only polynomial time. Finally, based on the computed extensions, every axiom of K can be checked \u2013 again in polynomial time.\nTo show hardness, we note that any 3SAT problem can be reduced to boundedmodel satisfiability as follows: Let L = {L1, . . . , Ln} be a set of 3-clauses. Then satisfiability of\n\u2227 {\u21131,\u21132,\u21133}\u2208L (\u21131 \u2228 \u21132 \u2228 \u21133) coincides with the bounded-\nmodel satisfiability of the knowledge base containing the two axioms \u22a4(a) and \u22a4 \u2291\nd {\u21131,\u21132,\u21133}\u2208L\n(C\u21131 \u2294 C\u21132 \u2294 C\u21133), where C\u2113i = Ap if \u2113i = p and C\u2113i = \u00acAp if \u2113i = \u00acp for any propositional symbol p.\nNote that this finding contrasts with the observation that bounded-model reasoning in first-order logic is PSpace-complete. We omit the full proof here, just noting that membership and hardness can be easily shown based on the fact that checking modelhood in FOL is known to be PSpace-complete [30] and, for the membership part, keeping in mind that NPSpace=PSpace thanks to Savitch\u2019s Theorem [28]. This emphasizes the fact that, while the boundedmodel restriction turns reasoning in FOL decidable, restricting to SROIQ still gives a further advantage in terms of complexity (assuming P 6= NP).\n3.3 Axiomatization of Bounded Models inside SROIQ\nWhen introducing a new semantics for some logic, it is worthwhile to ask if existing reasoners can be used. Indeed, it is easy to see that, assuming {a1, . . . , an} = NI(K), adding the SROIQ GCI \u22a4 \u2291 {a1, . . . , an} as well as the set of inequality axioms containing ai 6\u2248 aj with i < j to K will rule out exactly all the non-bounded models of K. Denoting these additional axioms with BM, we then find that K is bounded-model satisfiable iff K\u222aBM is satisfiable under the classical DL semantics and, likewise, K |=bm \u03b1 iff K \u222a BM |= \u03b1 for any axiom \u03b1. Consequently, any off-the-shelf SROIQ reasoner can be used for bounded-model reasoning, at least when it comes to the classical reasoning tasks.\nHowever, the fact that the currently available DL reasoners are not optimized towards reasoning with axioms of the prescribed type (featuring disjunctions over potentially large sets of individuals) and that available reasoners do not support model extraction and model enumeration led us to develop an alternative computational approach based on ASP.\n4 Encoding SROIQ Knowledge Bases into ASP\nWe propose an encoding of an arbitrary SROIQ knowledge base K, into an answer set program \u03a0(K), such that the set of answer sets AS(\u03a0(K)), coincides with the set of bounded models of the given knowledge base. This allows us to use existing ASP machinery to perform both standard reasoning as well as model extraction and model enumeration quite elegantly. Intuitively, the set of all bounded models defines a search space, which can be traversed searching for models, guided by appropriate constraints. We thus propose an ASP encoding consisting of a generating part \u03a0gen(K), defining all potential candidate interpretations, and a constraining part \u03a0chk(K), ruling out interpretations violating the knowledge base.\nNote: A is an atomic concept, C(i) are arbitrary concept expressions, C is a possibly empty disjunction of concept expressions, D is not a literal concept. The function \u00ac\u0307 is defined as \u00ac\u0307(\u00acA) = A and \u00ac\u0307(A) = \u00acA for some atomic concept A.\nOur translation into ASP requires a knowledge base in normal form which can be obtained by an easy syntactic transformation.\nDefinition 2 (Normalized Form [22]). A GCI is normalized, if it is of the form \u22a4 \u2291 \u2294n i=1 Ci, where Ci is of the form B, {a}, \u2200r.B, \u2203r.Self , \u00ac\u2203r.Self , \u2265 n r.B, or \u2264 n r.B, for B a literal concept, r a role, and n a positive integer. A TBox T is normalized, if each GCI in T is normalized. An ABox A is normalized if each concept assertion in A contains only a literal concept, each role assertion in A contains only an atomic role, and A contains at least one assertion. An RBox R is normalized, if each role inclusion axiom is of the form r \u2291 r\u2032 or r1 \u25e6 r2 \u2291 r\u2032. A SROIQ knowledge base K = (A, T ,R) is normalized if A, T , and R are normalized.\nGiven K= (A, T ,R), the normalized form \u2126(K) is obtained by applying a transformation \u2126, given in Table 3, which is mainly standard in DLs [22]. The normalized knowledge base \u2126(K) is a model-conservative extension of K, i.e. every (bounded) model of \u2126(K) is a (bounded) model of K and every (bounded) model of K can be turned into a (bounded) model of \u2126(K) by finding appropriate\ninterpretions for the concepts and roles introduced by \u2126. Thereby it is straightforward to extract a model for K, given a model of \u2126(K). In the remainder, we will assume a knowledge base in normalized form, if not stated otherwise."}, {"heading": "4.1 Candidate Generation", "text": "As shown, any potential bounded interpretation IB is induced by a set of individual assertionsB, such that for each concept name A, role name r and individuals a, b occurring in K, either A(a) \u2208 B, or \u00acA(a) \u2208 B and either r(a, b) \u2208 B or \u00acr(a, b) \u2208 B. This construction is straightforward to encode via subsequent rules:\n\u03a0gen(K) := {A(X) :\u2212 not \u00acA(X), \u22a4(X) | A \u2208 NC(K)}\u222a (1)\n{\u00acA(X) :\u2212 not A(X), \u22a4(X) | A \u2208 NC(K)}\u222a (2)\n{ar(r,X, Y ) :\u2212 not \u00acar(r,X, Y ),\u22a4(X),\u22a4(Y ) | r \u2208 NR(K)}\u222a (3)\n{\u00acar(r,X, Y ) :\u2212 not ar(r,X, Y ),\u22a4(X),\u22a4(Y ) | r \u2208 NR(K)}\u222a (4)\n{\u22a4(a) | a \u2208 NI(K)}. (5)\nRecall, that a rule is unsafe, if a variable that occurs in the head does not occur in any positive body literal. The predicate \u22a4(X) ensures safe rules, each of the guessing rules (1\u20134) would otherwise be unsafe. This predicate represents the \u22a4-concept, to which the statement (5) asserts each individual present in K. The function ar takes care of potential inverse roles (cf. Table 4). Whereas \u201cnot \u201d denotes default negation, \u00ac is without attached semantics and merely used as syntactic counterpart to the DL vocabulary. We show now that \u03a0gen(K) computes BK, the set of all constructible B, and each B \u2208 BK determines a solution of \u03a0gen(K).\nProposition 1 (BK = AS(\u03a0gen(K))). Let K=(A, T ,R) be a SROIQ knowledge base and \u03a0gen(K) the logic program obtained by the translation given in (1\u20135). Then, it holds that BK coincides with the set of all answer sets of \u03a0gen(K)."}, {"heading": "4.2 Axiom Encoding", "text": "In the next step, we turn each axiom \u03b1 \u2208 R \u222a T into a constraint, ultimately ruling out those candidate interpretations not satisfying \u03b1. Moreover, each individual assertion in the ABox A restricts the search space further, since for some present fact A(a) any solution candidate containing \u00acA(a) is eliminated. We will successively introduce appropriate encodings for axioms of each knowledge base component, altogether manifested in the program \u03a0chk(K) and will finally show that the program \u03a0(K) = \u03a0gen(K) \u222a\u03a0chk(K) computes all bounded models of K.\nEncoding TBox Axioms Since T is normalized, each GCI is of certain form which simplifies the encoding. We obtain \u03a0chk(T ) as follows:\n\u03a0chk(T ) := {:\u2212 trans(C1), . . . , trans(Cn) | for each \u22a4 \u2291 n\u2294\ni=1\nCi in T } (6)\nEach concept expression Ci is translated according to the function trans(Ci) depicted in Table 4. Note, each Ci is only one of the ones given in Definition 2, the ones given in the first column; i.e. not complex, with the nice effect of trans(Ci) to be realized non-recursively.\nEncoding RBox Axioms Role assertions and role inclusion axioms are also transformed into constraints, grouped in the program\u03a0chk(R). According to their DL semantics, this yields:\n\u03a0chk(R) := {:\u2212 ar (r,X, Y ), not ar(s,X, Y ) | r \u2291 s \u2208 R} \u222a (7)\n{:\u2212 ar (s,X, Y ), ar (r,X, Y ) | Dis(r, s) \u2208 R} \u222a (8)\n{:\u2212 ar (s1, X, Y ), ar (s2, Y, Z), not ar (r,X, Z) |s1 \u25e6 s2 \u2291 r \u2208 R}. (9)\nEncoding ABox Axioms The ABox A itself represents an input database, which we can directly use. However, it remains to check whether A does not contain contradictory knowledge; i.e. propositional clashes of the form {A(a),\u00acA(a)} \u2208 A. Hence, the program \u03a0chk(A) consists of A and one additional constraint for each concept and role name ruling out inconsistent input ABoxes.\n\u03a0chk(A) := A \u222a (10)\n{:\u2212 A(X), \u00acA(X) | A \u2208 NC(K)} \u222a (11)\n{:\u2212 ar(r,X, Y ), \u00acar (r,X, Y ) | r \u2208 NR(K)}. (12)\nNote that the presence of {A(a),\u00acA(a)} \u2208 A does not cause an unsatisfiable program under the answer set semantics, since \u00ac does not have any meaning under the semantics; \u00acA is treated as just another predicate name. Thus, the imposed constraints simulate the known DL semantics.\nTheorem 2. Let K= (A, T ,R) be a normalized SROIQ knowledge base, and \u03a0(K)=\u03a0gen(K) \u222a \u03a0chk(K) be the program obtained by applying Rules (1\u201312). Then, it holds:\nAS(\u03a0(K)) = {B |B \u2208 BK and IB |= K}\nWith this theorem in place, we benefit from the translation in many aspects. Most notably, in addition to the standard DL reasoning tasks, model extraction and model enumeration can be carried out without additional efforts, since both are natural tasks for answer set solvers."}, {"heading": "5 Evaluation", "text": "We implemented our approach as an open-source tool, named Wolpertinger.2 The obtained logic programs can be evaluated with most modern ASP solvers. However, the evaluation was conducted using Clingo [6] for grounding and solving, since it currently is the most prominent solver leading the latest competitions [2]. We present preliminary evaluation results based on simple ontologies, encoding constraint-satisfaction-type combinatorial problems. Existing OWL ontologies typically used for benchmarking, e.g. SNOMED or GALEN [29,23], do not fit our purpose, since they are modeled with the classical semantics in mind and often have little or no ABox information.\nOur tests provide runtimes of Wolpertinger and the popular HermiT reasoner [10]. Whereas a direct comparison would not be fair, the conducted tests shall merely show the feasibility of our approach and the infeasibility of the axiomatization using standard DL reasoners. The evaluation itself is conducted on a standard desktop machine.3"}, {"heading": "5.1 Unsatisfiability", "text": "We construct an unsatisfiable knowledge base Kn=(An, T n, \u2205), with Tn and An as follows:\nT n = {A1 \u2291 \u2203r.A2, . . . , An \u2291 \u2203r.An+1} \u222a (13)\n{Ai \u2293 Aj \u2291 \u22a5 | 1 \u2264 i < j \u2264 n+ 1} (14)\nAn = {A1(a1),\u22a4(a1), . . . ,\u22a4(an)} (15)\nInspired by common pigeonhole-type problems, we have Kn enforce an r-chain of length n+ 1 without repeating elements, yet, given only n individuals such a\n2 https://github.com/wolpertinger-reasoner 3 Unix operating system, 1.8 Ghz Intel Core i7 Processor, 4GB memory. Both tools are executed with standard Java-VM settings.\nmodel cannot exist. Table 5 depicts the runtimes for detecting unsatisfiability of Kn, for increasing n. The durations correspond to the pure solving time of Clingo and pure reasoning time of HermiT, respectively, as both Wolpertinger and HermiT have a comparable preprocessing. As the figures suggest,Kn is a potential worst-case scenario, where both tools are doomed to test all combinations. On this task, Wolpertinger constantly outperforms HermiT. For K11, HermiT is stopped after 15 minutes, whereas Wolpertinger detects unsatisfiability within 85 seconds."}, {"heading": "5.2 Model Extraction and Model Enumeration", "text": "With Table 6, we next provide some figures for model extraction and partial enumeration (retrieving a given number of bounded models). To this end, we created a knowledge base modeling fully and correctly filled Sudokus, featuring 108 named individuals, 13 concept names and 1 role name. When invoking a satisfiability test on this knowledge base using HermiT, no answer was given within 15 minutes.\nOn average, Wolpertinger provides a solution for a given Sudoku instance in around 6 seconds, of which more than 5 seconds are needed for grounding, while the actual solving is done in less than 0.1 seconds. For model enumeration, we used the knowledge base but removed information concerning pre-filled cells, turning the task into generating new Sudoku instances. The size of the grounded program is 13MB, the grounding process taking around 6 seconds as reflected in Table 6."}, {"heading": "6 Conclusion", "text": "With this paper, we have established the starting point for further developments on the theoretical and practical side, as well as we can identify benefits for both, the description logic and logic programming community. For the latter, our approach enables one to use OWL as ASP modeling language and therefore make use of the available tool support. Although modeling features are limited, we argue that quite large and involved problem scenarios can be modeled in OWL ontologies. Clearly, evaluations of our system with respect to such ontologies remain as imperative issue.\nComplementarily, model extraction and enumeration supplement DL reasoning tasks for which our ASP translation represents not only a feasible approach, but apparently also a use case of ASP in another research field. Moreover, the framework may be extended to realize non-standard reasoning tasks useful for debugging purposes such as axiom pinpointing, explanation, justification and abduction, exploiting the innate capabilities of ASP to realize minimization as well as model enumeration.\nOn a more practical level, the proposed translation can certainly be optimized to exploit more built-in features of today\u2019s ASP solvers. In terms of harnessing the convenience of OWL modeling environments, we will implement an OWL API reasoner interface for Wolpertinger, such that it can e.g., be seamlessly be integrated with other OWL software, such as Prote\u0301ge\u0301 [16].\nRegarding future theoretical DL investigations, in recent years, significant extensions of the modeling and querying capabilities of DLs have been proposed and partially implemented. A major such extension is considering the reasoning task of answering queries, most prominently (unions of) conjunctive queries, positive queries, conjunctive 2-way regular path queries, and monadically defined queries subsuming all of the former [27]. It is not overly difficult to show that answering all these query types over SROIQ knowledge bases (and hence over OWL ontologies) under the bounded model semantics is \u03a02P -complete, which again contrasts with the much worse results (if any) for the unbounded case [26,11]. Moreover, as all these query formalisms can be straightforwardly expressed in a rule-based way, an integration in our framework is immediate. In the same way, rule-based extensions of OWL \u2013 monotonic [14,21] or nonmonotonic [20,1] \u2013 should be straightforward to accommodate, at the cost of the combined complexity jumping to ExpTime or NExpTime."}, {"heading": "Acknowledgements", "text": "We are grateful for all the valuable feedback from our colleagues and the anonymous workshop reviewers, which helped greatly to improve this work."}, {"heading": "A Proofs", "text": "Proof of Theorem 2 By Proposition 1, \u03a0gen(K) computes the set BK. It remains to show, that \u03a0chk(K) obeys the bounded model semantics, and consequently excludes each B \u2208 BK not inducing a bounded model IB.\nAS(\u03a0(K)) \u2286 {B |B \u2208 BK and IB |= K} Let I \u2208 AS(\u03a0(K)) be an answer set of \u03a0(K). From Proposition 1, we know I \u2208 BK. We show now that the interpretation II induced by I is a bounded model of K, and therefore II |= \u03b1, for each axiom \u03b1 \u2208 K. Then, let\n\u03b1 \u2208 R: we distinguish role disjointness, and role inclusion axioms: \u03b1 \u2208 Ra: Let \u03b1 = Dis(r, s) \u2208 Ra, then by definition of \u03a0chk(R), there is a ground constraint \u03c1\u03b1 = :\u2212 s(a, b), r(a, b) in Gr(\u03a0chk(R)), for all individuals a, b \u2208 NI(K). Since I is an answer set, {s(a, b), r(a, b)} 6\u2208 I. Consequently either (a, b) \u2208 sII , or (a, b) \u2208 rII , hence II |= Dis(r, s). \u03b1 \u2208 Rh: then let \u03b1 be of the form s1 \u25e6 s2 \u2291 r, with s1, s2, r \u2208 NR(K), and \u03c1\u03b1 = :\u2212 s1(a1, a2), s2(a2, a3), not r(a1, a3) be the ground constraint in Gr(\u03a0chk(R)). Since I is an answer set, we have that, if s1(a1, a2) and s2(a2, a3) \u2208 I implies r(a1, a3) \u2208 I. And consequently (a1, a2) \u2208 s1II , (a2, a3) \u2208 s2II and (a1, a3) \u2208 rII , thus II |= s1 \u25e6 s2 \u2291 r. \u03b1 \u2208 T : then \u03b1 is normalized and of the form \u22a4 \u2291 \u2294n\ni=1 Ci. In Rule (6), \u03b1 is turned into a constraint \u03c1\u03b1 = :\u2212 trans(C1), . . . , trans(Cn) in \u03a0chk(T ). Since I is an answer set, it does not violate any of the grounded instances of \u03c1\u03b1 in Gr(\u03a0chk(T )). Suppose now towards contradiction, II induced by I does not satisfy \u03b1, II 6|= \u03b1. Then, II 6|= Ci, for all 1 \u2264 i \u2264 n. However, since I does not violate \u03c1\u03b1, in each of the ground instantiations of \u03c1\u03b1, there is exists a trans(Ci) which is not satisfied by I, 1 \u2264 i \u2264 n. Then, Ci is one of the expressions given in Definition 2, and we distinguish:\nCi = A: then trans(Ci) = not A(X), and A(a) \u2208 I for any a \u2208 NI(K). Consequently a \u2208 AII 6= \u2205, which contradicts the assumption II 6|= Ci. Ci = \u00acA: then trans(Ci) = A(X), and \u00acA(a) \u2208 I for any a \u2208 NI(K). Consequently a \u2208 (\u00acA)II 6= \u2205, which contradicts the assumption II 6|= Ci. Ci = {a}: then trans(Ci) = {not Oa(X)} and Oa(a), thus necessarily Oa(a) \u2208 I. In order to not satisfy trans(Ci), X = a. Consequently we have a \u2208 OIIa with Oa as nominal guard concept, and therefore {a}\nII = {a}, which contradicts the assumption. Ci = \u2200r.A: then trans(Ci) = {r(X,YA), not A(Ya)}, and A(b) \u2208 I whenever r(a, b) \u2208 I. Consequently, (a, b) \u2208 rII implies b \u2208 AII , which contradicts the assumption II 6|= Ci. Ci = \u2265 n r.A: then trans(Ci) = #count{r(X,YA) : A(YA)} < n, and more or equal than n, say m, atoms r(a, b) \u2208 I and A(b) \u2208 I. Consequently we find also m pairs (a, b) \u2208 rII and b \u2208 AII , which contradicts the assumption. All remaining cases can be treated analogously.\n\u03b1 \u2208 A: I satisfies \u03a0chk(A), in particular A \u2286 I. Moreover, none of the imposed constraints in \u03a0chk(A) is violated, proving consistency of A, and therefore {A(a), \u00acA(a)} 6\u2208 I and {r(a, b), \u00acr(a, b)} 6\u2208 I for all concept names A \u2208 NC(K), role names r \u2208 NR(K) and individuals a, b \u2208 NI(K).\nAS(\u03a0(K)) \u2287 {B |B \u2208 BK and IB |= K} Let IB be a bounded model of K, induced by some B \u2208 BK. We show that B is an answer set of \u03a0(K) = \u03a0gen(K)\u222a \u03a0chk(K). From Proposition 1 we know, that B is an answer set of \u03a0gen(K), thus it remains to show that B satisfies \u03a0chk(K) and therefore does not violate any of the imposed constraints. Since IB |= \u03b1, for each \u03b1 \u2208 K, let\n\u03b1 \u2208 R: we distinguish again role disjointness and role chain axioms. \u03b1 \u2208 Ra: Let \u03b1 = Dis(r, s) \u2208 Ra and \u03c1\u03b1 = r(X,Y ), s(X,Y ), be the constraint according to Rule (8). Since IB |= \u03b1, for all a, b \u2208 NI(K) we find, that {r(a, b), s(a, b)} 6\u2208 B, and consequently none of the grounded instances of \u03c1\u03b1 is violated by B. \u03b1 \u2208 Rh: then \u03b1 is of the form s1 \u25e6 s2 \u2291 r, with s1, s2, r \u2208 NR(K), and \u03c1\u03b1 = :\u2212 s1(X,Y1), s2(Yn, Z), not r(X,Z) is the constraint according to Rule (9). Since IB |= \u03b1, for all a1, a2, a3 \u2208 NI(K) we have that if s1(a1, a2) and sn(a2, a3) \u2208 B, then r(a1, a3) \u2208 B. Consequently, \u03c1\u03b1 is not violated by B. \u03b1 \u2208 T : then \u03b1 is normalized and of the form \u22a4 \u2291 \u2294n\ni=1 Ci, which is satisfied\nby IB, iff C IB i 6= \u2205 for some 1 \u2264 i \u2264 n. Let \u03c1\u03b1 = :\u2212 trans(C1), . . . , trans(Cn) be the constraint obtained from \u03b1, applying Rule (6). We need to show that B does not violate the constraint. Let Ci be the concept expression for which CIBi 6= \u2205 holds, 1 \u2264 i \u2264 n, and Ci is one of the expressions given in Definition 2, in particular we have:\nCi = A: then A IB = {a |A(a) \u2208 B}. Consequently, for each of those A(a) \u2208 B, trans(A) = not A(X) is not satisfied. Ci = \u00acA: then \u00acAIB = {a | \u00acA(a) \u2208 B}. Consequently, for each of those \u00acA(a) \u2208 B, trans(\u00acA) = A(X) is not satisfied. Ci = \u2203r.Self : then (\u2203r.Self )II = {a | r(a, a) \u2208 B}. Consequently, trans(\u2203r.Self ) = not r(X,X) is not satisfied for those r(a, a) \u2208 B. Ci =\u2264 r n.A: then (\u2264 r n.A)IB = {a |#{r(a, b) and A(b) \u2208 B} = m \u2264 n}. Consequently, trans(\u2264 r n.A) = #count{r(X,YA) : A(YA)} > n, is not satisfied since there are m such r(a, b) \u2208 B with A(b) \u2208 B. All remaining cases can be treated analogously. \u03b1 \u2208 A: then \u03b1 \u2208 B, as well as \u03b1 \u2208 \u03a0chk(A), since by definition A \u2208 \u03a0chk(A). In general, since IB |= K, A is consistent and therefore {A(a),\u00acA(a)} 6\u2208 B, as well as {r(a, b),\u00acr(a, b)} 6\u2208 B for all concept names A, role names r and individuals a, b."}], "references": [{"title": "Query-Driven Procedures for Hybrid MKNF Knowledge Bases", "author": ["J.J. Alferes", "M. Knorr", "T. Swift"], "venue": "ACM Transactions on Computational Logic 14(2), 16:1\u201316:43", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2013}, {"title": "The Fourth Answer Set Programming Competition: Preliminary Report", "author": ["M. Alviano", "F. Calimeri", "G. Charwat", "M. Dao-Tran", "C. Dodaro", "G. Ianni", "T. Krennwallner", "M. Kronegger", "J. Oetsch", "A. Pfandler", "J. P\u00fchrer", "C. Redl", "F. Ricca", "P. Schneider", "M. Schwengerer", "L.K. Spendier", "J.P. Wallner", "G. Xiao"], "venue": "Cabalar, P., Son, T.C. (eds.) Proc. of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2013). LNCS, vol. 8148, pp. 42\u201353. Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "The Description Logic Handbook: Theory, Implementation, and Applications", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P. Patel-Schneider"], "venue": "Cambridge University Press, second edn.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2007}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Commun. ACM 54(12), 92\u2013103", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Finite model reasoning in description logics", "author": ["D. Calvanese"], "venue": "Proc. of the International Workshop on Description Logics (DL 1996). pp. 25\u201336", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1996}, {"title": "Potassco: The Potsdam Answer Set Solving Collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning 6, 1\u2013238", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Kowalski, R.A., Bowen, K.A. (eds.) Proc. of the 5th International Conference and Symposium on Logic Programming. pp. 1070\u20131080. MIT Press", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1988}, {"title": "Classical Negation in Logic Programs and Disjunctive Databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Comput. 9(3/4), 365\u2013386", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1991}, {"title": "HermiT: an OWL 2 reasoner", "author": ["B. Glimm", "I. Horrocks", "B. Motik", "G. Stoilos", "Z. Wang"], "venue": "Journal of Automated Reasoning 53(3), 245\u2013269", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Status QIO: An Update", "author": ["B. Glimm", "Y. Kazakov", "C. Lutz"], "venue": "Rosati, R., Rudolph, S., Zakharyaschev, M. (eds.) Proc. of the 24th International Workshop on Description Logics (DL 2011). CEUR Workshop Proceedings, vol. 745. CEUR-WS.org", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2011}, {"title": "OWL 2 Web Ontology Language Manchester Syntax", "author": ["M. Horridge", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "The Even More Irresistible SROIQ", "author": ["I. Horrocks", "O. Kutz", "U. Sattler"], "venue": "Doherty, P., Mylopoulos, J., Welty, C.A. (eds.) Proc. of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR 2006). pp. 57\u201367. AAAI Press", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "SWRL: A Semantic Web Rule Language", "author": ["I. Horrocks", "P.F. Patel-Schneider", "H. Boley", "S. Tabet", "B.N. Grosof", "M. Dean"], "venue": "W3C Member Submission", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2004}, {"title": "RIQ and SROIQ are harder than SHOIQ", "author": ["Y. Kazakov"], "venue": "Brewka, G., Lang, J. (eds.) Proc. of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008). pp. 274\u2013284. AAAI Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "Editing Description Logic Ontologies with the Prot\u00e9g\u00e9 OWL Plugin", "author": ["H. Knublauch", "M.A. Musen", "A.L. Rector"], "venue": "Haarslev, V., M\u00f6ller, R. (eds.) Proc. of the International Workshop on Description Logics (DL 2004). CEUR Workshop Proceedings, vol. 104. CEUR-WS.org", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Trans. Comput. Log. 7(3), 499\u2013562", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "The complexity of finite model reasoning in description logics", "author": ["C. Lutz", "U. Sattler", "L. Tendera"], "venue": "Information and Computation 199(1-2), 132\u2013171", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2005}, {"title": "A framework for representing and solving NP search problems", "author": ["D.G. Mitchell", "E. Ternovska"], "venue": "Proc. of AAAI. vol. 5, pp. 430\u2013435", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "Reconciling description logics and rules", "author": ["B. Motik", "R. Rosati"], "venue": "Journal of the ACM 57(5)", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2010}, {"title": "Query Answering for OWL DL with Rules", "author": ["B. Motik", "U. Sattler", "R. Studer"], "venue": "Journal of Web Semantics 3(1), 41\u201360", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2005}, {"title": "Hypertableau Reasoning for Description Logics", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "Artificial Intelligence Research 36, 165\u2013228", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "Experience building a large, re-usable medical ontology using a description logic with transitivity and concept inclusions", "author": ["A. Rector", "I. Horrocks"], "venue": "Proc. of the Workshop on Ontological Engineering", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1997}, {"title": "Finite Model Reasoning in DL-Lite", "author": ["R. Rosati"], "venue": "Bechhofer, S., Hauswirth, M., Hoffmann, J., Koubarakis, M. (eds.) Proc. of the 5th European Semantic Web Conference on The Semantic Web: Research and Applications (ESWC 2008). LNCS, vol. 5021, p. 215. Springer", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "Foundations of Description Logics", "author": ["S. Rudolph"], "venue": "Polleres, A., d\u2019Amato, C., Arenas, M., Handschuh, S., Kroner, P., Ossowski, S., Patel-Schneider, P.F. (eds.) Reasoning Web. 7th International Summer School 2011, Tutorial Lectures. LNCS, vol. 6848, pp. 76\u2013136. Springer", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2011}, {"title": "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend", "author": ["S. Rudolph", "B. Glimm"], "venue": "Journal of Artificial Intelligence Research 39,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2010}, {"title": "Flag & Check: Data Access with Monadically Defined Queries", "author": ["S. Rudolph", "M. Kr\u00f6tzsch"], "venue": "Hull, R., Fan, W. (eds.) Proc. of the 32nd Symposium on Principles of Database Systems (PODS\u201913). pp. 151\u2013162. ACM", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2013}, {"title": "Relationships Between Nondeterministic and Deterministic Tape Complexities", "author": ["W.J. Savitch"], "venue": "J. Comput. Syst. Sci. 4(2), 177\u2013192", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1970}, {"title": "SNOMED RT: a reference terminology for health care", "author": ["K.A. Spackman", "K.E. Campbell", "R.A. C\u00f4t\u00e9"], "venue": "AMIA 1997, American Medical Informatics Association Annual Symposium. AMIA", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1997}, {"title": "The Complexity of Decision Problems in Automata Theory and Logic", "author": ["L.J. Stockmeyer"], "venue": "Ph.D. thesis, Massachusetts Institute of Technology", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1974}, {"title": "OWL 2 Web Ontology Language: Document Overview", "author": ["W3C OWL Working Group"], "venue": "W3C Recommendation, http://www.w3.org/TR/owl2-overview", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 3, "context": "Answer set programming (ASP) is a powerful declarative language for knowledge representation and reasoning [4].", "startOffset": 107, "endOffset": 110}, {"referenceID": 7, "context": "In ASP the knowledge is encoded in a set of logical rules and interpreted under the stable model semantics [8,9].", "startOffset": 107, "endOffset": 112}, {"referenceID": 8, "context": "In ASP the knowledge is encoded in a set of logical rules and interpreted under the stable model semantics [8,9].", "startOffset": 107, "endOffset": 112}, {"referenceID": 16, "context": "dlv [17], and gringo/clasp [6], to name some of them, which are capable to solve a large variety of problems [7].", "startOffset": 4, "endOffset": 8}, {"referenceID": 5, "context": "dlv [17], and gringo/clasp [6], to name some of them, which are capable to solve a large variety of problems [7].", "startOffset": 27, "endOffset": 30}, {"referenceID": 6, "context": "dlv [17], and gringo/clasp [6], to name some of them, which are capable to solve a large variety of problems [7].", "startOffset": 109, "endOffset": 112}, {"referenceID": 1, "context": "In particular, ASP has shown to be well suited for big combinatorial search problems, as the dedicated solvers are specially designed to enumerate all solutions [2].", "startOffset": 161, "endOffset": 164}, {"referenceID": 30, "context": "On the other side, formalisms coming with a more elaborate modeling tool support \u2013 most notably the Web Ontology Language OWL [31] \u2013 are often preferred, even if the application scenario actually is of a constraint-satisfaction type which does not go well with OWL\u2019s standard semantics allowing for models of arbitrary size.", "startOffset": 126, "endOffset": 130}, {"referenceID": 15, "context": "Ontology editors like Prot\u00e9g\u00e9 [16] provide user-friendly interfaces and combined with the natural language alike Manchester syntax [12] possesses perspicuous access to a presumably complex and involved formalism.", "startOffset": 30, "endOffset": 34}, {"referenceID": 11, "context": "Ontology editors like Prot\u00e9g\u00e9 [16] provide user-friendly interfaces and combined with the natural language alike Manchester syntax [12] possesses perspicuous access to a presumably complex and involved formalism.", "startOffset": 131, "endOffset": 135}, {"referenceID": 14, "context": "While reasoning in OWL under the classical semantics is N2ExpTime-complete [15], we show that reasoning under the bounded model semantics is merely NP-complete.", "startOffset": 75, "endOffset": 79}, {"referenceID": 3, "context": "Therefore, we propose a different approach and definine a translation of SROIQ knowledge bases (the logical counterparts to OWL ontologies) into answer set programs [4], such that the set of bounded models coincides with the set of answer sets of the obtained program, allowing us to use existing answer set solvers (see [2] for an overview) for bounded model reasoning.", "startOffset": 165, "endOffset": 168}, {"referenceID": 1, "context": "Therefore, we propose a different approach and definine a translation of SROIQ knowledge bases (the logical counterparts to OWL ontologies) into answer set programs [4], such that the set of bounded models coincides with the set of answer sets of the obtained program, allowing us to use existing answer set solvers (see [2] for an overview) for bounded model reasoning.", "startOffset": 321, "endOffset": 324}, {"referenceID": 11, "context": "Although we focus on the description logic SROIQ and its native DL syntax, other syntax specifications like the OWL 2 Manchester Syntax [12] very well strive towards user-friendliness by means of natural language features.", "startOffset": 136, "endOffset": 140}, {"referenceID": 2, "context": "OWL 2 DL, the version of the Web Ontology Language we focus on, is defined based on description logics (DLs, [3,25]).", "startOffset": 109, "endOffset": 115}, {"referenceID": 24, "context": "OWL 2 DL, the version of the Web Ontology Language we focus on, is defined based on description logics (DLs, [3,25]).", "startOffset": 109, "endOffset": 115}, {"referenceID": 12, "context": "We briefly recap the description logic SROIQ (for details see [13]).", "startOffset": 62, "endOffset": 66}, {"referenceID": 8, "context": "We give a brief overview of the syntax and semantics of disjunctive logic programs under the answer-sets semantics [9].", "startOffset": 115, "endOffset": 118}, {"referenceID": 17, "context": "fact, restricting DL reasoning to models of finite domain size (called finite model reasoning, a natural assumption in database theory), has become the focus of intense studies lately [18,5,24].", "startOffset": 184, "endOffset": 193}, {"referenceID": 4, "context": "fact, restricting DL reasoning to models of finite domain size (called finite model reasoning, a natural assumption in database theory), has become the focus of intense studies lately [18,5,24].", "startOffset": 184, "endOffset": 193}, {"referenceID": 23, "context": "fact, restricting DL reasoning to models of finite domain size (called finite model reasoning, a natural assumption in database theory), has become the focus of intense studies lately [18,5,24].", "startOffset": 184, "endOffset": 193}, {"referenceID": 18, "context": "in the work of Mitchell and Ternovska [19].", "startOffset": 38, "endOffset": 42}, {"referenceID": 14, "context": "The combined complexity of reasoning in SROIQ over arbitrary interpretations is known to be N2ExpTime-complete [15].", "startOffset": 111, "endOffset": 115}, {"referenceID": 29, "context": "We omit the full proof here, just noting that membership and hardness can be easily shown based on the fact that checking modelhood in FOL is known to be PSpace-complete [30] and, for the membership part, keeping in mind that NPSpace=PSpace thanks to Savitch\u2019s Theorem [28].", "startOffset": 170, "endOffset": 174}, {"referenceID": 27, "context": "We omit the full proof here, just noting that membership and hardness can be easily shown based on the fact that checking modelhood in FOL is known to be PSpace-complete [30] and, for the membership part, keeping in mind that NPSpace=PSpace thanks to Savitch\u2019s Theorem [28].", "startOffset": 269, "endOffset": 273}, {"referenceID": 21, "context": "Definition 2 (Normalized Form [22]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 21, "context": "Given K= (A, T ,R), the normalized form \u03a9(K) is obtained by applying a transformation \u03a9, given in Table 3, which is mainly standard in DLs [22].", "startOffset": 139, "endOffset": 143}, {"referenceID": 5, "context": "However, the evaluation was conducted using Clingo [6] for grounding and solving, since it currently is the most prominent solver leading the latest competitions [2].", "startOffset": 51, "endOffset": 54}, {"referenceID": 1, "context": "However, the evaluation was conducted using Clingo [6] for grounding and solving, since it currently is the most prominent solver leading the latest competitions [2].", "startOffset": 162, "endOffset": 165}, {"referenceID": 28, "context": "SNOMED or GALEN [29,23], do not fit our purpose, since they are modeled with the classical semantics in mind and often have little or no ABox information.", "startOffset": 16, "endOffset": 23}, {"referenceID": 22, "context": "SNOMED or GALEN [29,23], do not fit our purpose, since they are modeled with the classical semantics in mind and often have little or no ABox information.", "startOffset": 16, "endOffset": 23}, {"referenceID": 9, "context": "Our tests provide runtimes of Wolpertinger and the popular HermiT reasoner [10].", "startOffset": 75, "endOffset": 79}, {"referenceID": 15, "context": ", be seamlessly be integrated with other OWL software, such as Prot\u00e9g\u00e9 [16].", "startOffset": 71, "endOffset": 75}, {"referenceID": 26, "context": "A major such extension is considering the reasoning task of answering queries, most prominently (unions of) conjunctive queries, positive queries, conjunctive 2-way regular path queries, and monadically defined queries subsuming all of the former [27].", "startOffset": 247, "endOffset": 251}, {"referenceID": 25, "context": "It is not overly difficult to show that answering all these query types over SROIQ knowledge bases (and hence over OWL ontologies) under the bounded model semantics is \u03a0 P -complete, which again contrasts with the much worse results (if any) for the unbounded case [26,11].", "startOffset": 265, "endOffset": 272}, {"referenceID": 10, "context": "It is not overly difficult to show that answering all these query types over SROIQ knowledge bases (and hence over OWL ontologies) under the bounded model semantics is \u03a0 P -complete, which again contrasts with the much worse results (if any) for the unbounded case [26,11].", "startOffset": 265, "endOffset": 272}, {"referenceID": 13, "context": "In the same way, rule-based extensions of OWL \u2013 monotonic [14,21] or nonmonotonic [20,1] \u2013 should be straightforward to accommodate, at the cost of the combined complexity jumping to ExpTime or NExpTime.", "startOffset": 58, "endOffset": 65}, {"referenceID": 20, "context": "In the same way, rule-based extensions of OWL \u2013 monotonic [14,21] or nonmonotonic [20,1] \u2013 should be straightforward to accommodate, at the cost of the combined complexity jumping to ExpTime or NExpTime.", "startOffset": 58, "endOffset": 65}, {"referenceID": 19, "context": "In the same way, rule-based extensions of OWL \u2013 monotonic [14,21] or nonmonotonic [20,1] \u2013 should be straightforward to accommodate, at the cost of the combined complexity jumping to ExpTime or NExpTime.", "startOffset": 82, "endOffset": 88}, {"referenceID": 0, "context": "In the same way, rule-based extensions of OWL \u2013 monotonic [14,21] or nonmonotonic [20,1] \u2013 should be straightforward to accommodate, at the cost of the combined complexity jumping to ExpTime or NExpTime.", "startOffset": 82, "endOffset": 88}], "year": 2015, "abstractText": "To exploit the Web Ontology Language OWL as an answer set programming (ASP) language, we introduce the notion of bounded model semantics, as an intuitive and computationally advantageous alternative to its classical semantics. We show that a translation into ASP allows for solving a wide range of bounded-model reasoning tasks, including satisfiability and axiom entailment but also novel ones such as model extraction and enumeration. Ultimately, our work facilitates harnessing advanced semantic web modeling environments for the logic programming community through an \u201coff-label use\u201d of OWL.", "creator": "LaTeX with hyperref package"}}}