{"id": "1511.01754", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Nov-2015", "title": "Symmetry-invariant optimization in deep networks", "abstract": "Recent works have highlighted scale invariance or symmetry that is present in the weight space of a typical deep network and the adverse effect that it has on the Euclidean gradient based stochastic gradient descent optimization. In this work, we show that these and other commonly used deep networks, such as those which use a max-pooling and sub-sampling layer, possess more complex forms of symmetry arising from scaling based reparameterization of the network weights. We then propose two symmetry-invariant gradient based weight updates for stochastic gradient descent based learning. Our empirical evidence based on the MNIST dataset shows that these updates improve the test performance without sacrificing the computational efficiency of the weight updates. We also show the results of training with one of the proposed weight updates on an image segmentation problem.\n\n\n\n\nMutation of the Model\nThis work is presented as a cross-product of the model. The network weights are computed using an order of magnitude scaling algorithm. As the network weights are generated the network weights are computed by an order of magnitude scaling. The weights are generated using a simple formula called the first algorithm. For example, we have found that the training model has a randomization gradient based on the number of times it has an increase in the weights by 10% for all data (that is, the training model has an increase in the weights by 8% over the previous generation) and that the gradient training model has an increase in the weights by 12% for all data (that is, the training model has an increase in the weights by 12% over the previous generation). This results in a gradient of over 1 percent for all data (the training model has an increase in the weights by 16% over the previous generation) and that the gradient training model has an increase in the weights by 15% over the previous generation). In general, a model can perform the same basic test if it has an increase in the weights by 0.25% for all data (that is, the training model has an increase in the weights by 15% over the previous generation). However, a model can perform the same basic test if it has an increase in the weights by 15% over the previous generation). However, a model can perform the same basic test if it has an increase in the weights by 10% over the previous generation. In general, a model can perform the same basic test if it has an increase in the weights by 0.25% for all data (that is, the training model has an increase", "histories": [["v1", "Thu, 5 Nov 2015 14:17:40 GMT  (1798kb,D)", "https://arxiv.org/abs/1511.01754v1", "Submitted to ICLR 2016. arXiv admin note: text overlap witharXiv:1511.01029"], ["v2", "Sat, 7 Nov 2015 19:01:03 GMT  (1798kb,D)", "http://arxiv.org/abs/1511.01754v2", "Submitted to ICLR 2016. arXiv admin note: text overlap witharXiv:1511.01029"]], "COMMENTS": "Submitted to ICLR 2016. arXiv admin note: text overlap witharXiv:1511.01029", "reviews": [], "SUBJECTS": "cs.LG cs.AI cs.CV", "authors": ["vijay badrinarayanan", "bamdev mishra", "roberto cipolla"], "accepted": false, "id": "1511.01754"}, "pdf": {"name": "1511.01754.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Vijay Badrinarayanan", "Bamdev Mishra"], "emails": ["vb292@cam.ac.uk", "bamdevm@amazon.com", "roberto@cam.ac.uk"], "sections": [{"heading": null, "text": "Recent works have highlighted scale invariance or symmetry that is present in the weight space of a typical deep network and the adverse effect that it has on the Euclidean gradient based stochastic gradient descent optimization. In this work, we show that these and other commonly used deep networks, such as those which use a max-pooling and sub-sampling layer, possess more complex forms of symmetry arising from scaling based reparameterization of the network weights. We then propose two symmetry-invariant gradient based weight updates for stochastic gradient descent based learning. Our empirical evidence based on the MNIST dataset shows that these updates improve the test performance without sacrificing the computational efficiency of the weight updates. We also show the results of training with one of the proposed weight updates on an image segmentation problem."}, {"heading": "1 INTRODUCTION", "text": "Stochastic gradient descent (SGD) has been the workhorse for optimization of deep networks (Bottou, 2010). The most well-known form uses Euclidean gradients with a varying learning rate to optimize the weights of a deep network. In this regard, the recent work (Neyshabur et al., 2015) has brought to light simple scale invariance properties or symmetries in the weight space, which commonly used deep networks possess. These symmetries or invariance to reparameterizations of the weights imply that although the loss function remains invariant, the Euclidean gradient varies based on the chosen parameterization. In particular, the Euclidean gradient scales inversely to the scaling of the variable (Neyshabur et al., 2015). This leads to very different trajectories for different reparameterizations of the weights during the training process (Neyshabur et al., 2015).\n\u2217This work was initiated while the author was with the Department of Electrical Engineering and Computer Science, University of Lie\u0300ge, 4000 Lie\u0300ge, Belgium and was visiting the Department of Engineering (Control Group), University of Cambridge, Cambridge, UK.\nar X\niv :1\n51 1.\n01 75\n4v 2\n[ cs\nAlthough these issues have been raised recently, the precursor to these methods is the early work of Amari (1998), who proposed the use of natural gradients to tackle weight space symmetries in neural networks. The idea is to compute the steepest descent direction for weight update on the manifold defined by these symmetries and use this direction to update the weights. The Euclidean gradient direction which ignores these symmetries is no longer the steepest descent direction. Recently, Pascanu & Bengio (2013) proposed a second order method using natural gradients for deep networks. Natural neural networks, on the other hand, define a reparameterization of the network weights such that the Euclidean and natural gradient based updates are the same (Desjardins et al., 2015). They use a block-diagonal approximation of the Fisher information matrix as an approximate natural metric (a particular inner product) to motivate their proposed reparameterization (Pascanu & Bengio, 2013). The works of Ollivier (2015a;b) define several metrics that are also based on approximations of the Fisher information matrix or the Hessian of the loss function to perform scaleinvariant optimization. Most of the above-mentioned proposals are either computationally expensive to implement or they need modifications to the architecture. On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journe\u0301e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).\nIn this paper, our analysis into some commonly used networks shows that there exists more complex forms of symmetries which can affect optimization, and hence there is a need to define simpler weight updates which take into account these invariances. Accordingly, we look at two ways of resolving the symmetries. Both result from a geometric viewpoint on the manifold of the search space. The proposed symmetry-invariant updates are numerically efficient to implement. Even though the focus of the paper is on SGD algorithms, it should be noted that the updates proposed in Table 1 can readily be extended to first and second order batch algorithms (Absil et al., 2008). This paper builds upon and extend our recent work in (Badrinarayanan et al., 2015b).\nIn Section 2, we analyze the weight space symmetries which exist in a deep architecture commonly for classification, where each layer is composed of a fully connected network, followed by reLU non-linearity and a max-pooling-sub-sampling step. We then analyze an extension of this architecture, where the output of the fully connected network is batch normalized which has been shown\nto significantly speed up optimization (Ioffe & Szegedy, 2015). Such architectures in their convolutional form are currently been used for practical problems such as image segmentation, e.g., in (Badrinarayanan et al., 2015a). Section 3 discusses manifold optimization techniques to address the symmetries and we propose simple weight updates and give a motivation behind those. The proposed updates are shown in Table 1. Finally, numerical experiments are discussed in Sections 4, 5, and 6.\nThe stochastic gradient descent algorithms with the proposed updates are implemented in Matlab and Manopt (Boumal et al., 2014). The codes are available at http://bamdevmishra.com/ codes/deepnetworks."}, {"heading": "2 ARCHITECTURES AND SYMMETRY ANALYSIS", "text": "To keep the exposition simple, we consider a two layer deep architecture that is shown in Figure 1. Each layer in Arch1 has typical components commonly found in convolutional neural networks (LeCun et al., 2015) such as multiplication with a trainable weight matrix (e.g., W1 and W2), elementwise rectification ReLU, 2 \u00d7 1 max-pooling with stride 2, and sub-sampling. The final layer is a trainable soft-max classifier \u03b8 which predicts the probabilities of the relevant K classes. Arch2 has an additional batch normalization layer when compared to Arch1 (Ioffe & Szegedy, 2015). The analysis in this section readily extends to deeper architectures which use the same components as Arch1 and Arch2.\nThe rows of the weight matrices W1 and W2 correspond to filters in layers 1 and 2, respectively. The dimension of each row corresponds to the input dimension of the layer. For example, for the MNIST digits dataset, the input is a 784 dimensional vector and with 64 filters in each of the layers, the dimensionality of W1 is 64 \u00d7 784 and that of W2 is 32 \u00d7 64. The dimension of \u03b8 is 10 \u00d7 32, where each row corresponds to a trainable class vector.\nThe element-wise ReLU operation is defined for Arch1 as\nr1,j = max(h1,j),\u2200j \u2208 h, and similarly for Arch2. However, the ReLU operation in Arch2 is performed after the batch normalization (BN) step. The max-pooling and sub-sampling steps are performed as follows,\nm1,k = max(r1,k, r1,k+1),\u2200k \u2208 m. The cross-entropy objective or loss function for a training example of class k is defined below;\nL(W1,W2, \u03b8) = \u2212 log yk(W1,W2, \u03b8). During training the loss is summed over a mini-batch of training examples.\nConsider the following reparameterization of the trainable parameters\nW\u03031 = \u03b10W1 and W\u03032 = \u03b2W2 (1)\nfor the network in Figure 1 with 8 filters per layer, where \u03b10 is a positive scalar and \u03b2 = Diag(\u03b21, \u03b21, \u03b22, \u03b22, \u03b23, \u03b23, \u03b24, \u03b24), where \u03b2i > 0 for i = {1, 2, 3, 4} and Diag(\u00b7) is an operator which creates a diagonal matrix with its argument placed along the diagonal. It should be noted that there are repeating elements along the diagonal of \u03b2, which comes up because of the max-pooling operation. Under these reparameterizations, the changes to the other intermediate outputs in layer 1 are h\u03031 = \u03b10h1, r\u03031 = \u03b10r1, and m\u03031 = \u03b10m1. Subsequently, the effect on layer 2 are h\u03032 = \u03b10\u03b2h2, r\u03032 = \u03b10\u03b2r1, and m\u03032 = \u03b10\u03b2sm2, where \u03b2s = Diag(\u03b21, \u03b22, \u03b23, \u03b24).\nNow, let us reparameterize the class vectors (rows) of the \u03b8 matrix as\n\u03b8\u0303k = \u03b8k 1\n\u03b10 \u03b2\u22121s for k = {1, . . . ,K}, (2)\nthen evaluating the predicted class probabilities we have,\ny\u0303k = e\u03b8\u0303km\u03032\u2211\nl=1:K e \u03b8\u0303lm\u03032\n= e\u03b8k 1 \u03b10 \u03b2\u22121s \u03b10\u03b2sm2\u2211\nl=1:K e \u03b8l\n1 \u03b10 \u03b2\u22121s \u03b10\u03b2sm2\n= yk.\nHence, we see that if the weights and classifier parameters are reparameterized as shown in (1) and (2), then it leaves the loss unchanged. Therefore, there exists continuous symmetries or reparameterizations of W1, W2, and \u03b8 which leave the loss function unchanged. It should be noted that our analysis differs from (Neyshabur et al., 2015), where the authors deal with a simpler case wherein \u03b2 = 1\u03b10 is a scalar and \u03b8 is reparameterization free. It should be emphasized is that the reparameterizations (1) of W1 and W2 act from the left side (i.e., on the rows) and the reparameterization (2) on \u03b8 acts from the right side (i.e., on the columns).\nThe difference between Arch1 and Arch2 is in the introduction of a batch normalization layer in Arch 2 (Ioffe & Szegedy, 2015). Figure 2 shows the network. The idea behind this layer is to reduce the change in distribution of the input features at different layers over the course of optimization so as to speed up convergence. This is accomplished by normalizing each feature (element) in the h1 and h2 layers to have zero-mean unit variance over each mini-batch. Then a separate and trainable scale and shift is applied to the resulting features to obtain b1 and b2, respectively. This effectively models the distribution of the features in h1 and h2 as Gaussians whose mean and variance are learnt during training. Empirical results in (Ioffe & Szegedy, 2015) show that this normalization significantly improves convergence and our experiments also support this result. The zero-mean unit-variance normalization of the elements of h1 and h2 allows for more complex symmetries to exist in the network. Consider the following reparameterizations\nW\u03031 = \u03b1W1 and W\u03032 = \u03b2W2, (3)\nwhere \u03b1 = Diag(\u03b11, \u03b12, \u03b13, \u03b14, \u03b15, \u03b16, \u03b17, \u03b18) and \u03b2 = Diag(\u03b21, \u03b22, \u03b23, \u03b24, \u03b25, \u03b26, \u03b27, \u03b28) and the elements of \u03b1, \u03b2 can be any real number. This loss is invariant to this reparameterization of the weights as can be seen by following a similar derivation shown for Arch1. It should be noted that the additional parameters used in Arch2, proposed in (Ioffe & Szegedy, 2015), are left unchanged.\nUnfortunately, the Euclidean gradient of the weights used in standard SGD weight update is not invariant to these reparameterizations of the weights such as those possible in Arch1 and Arch2. This can be seen in the simple example of a function f : R\u2192 R : x 7\u2192 f(x) that is invariant under the transformation x\u0303 = \u03b1x for all non-zero scalar \u03b1, i.e., f(x\u0303) = f(x). Equivalently,\n\u2202f(x\u0303) \u2202x\u0303 = \u2202f(x\u0303) \u2202x \u2202x \u2202x\u0303 = \u2202f(x) \u2202x 1 \u03b1 , (4)\nwhere \u2202f(x)/\u2202x is the Euclidean gradient of f at x. As is clear in (4), the Euclidean gradient is not invariant to reparameterizations, i.e., it scales inversely to the scaling of the variable x. Consequently, the optimization trajectory can vary significantly based on the chosen parameterization. On the other hand, a scale-invariant gradient scales proportionally to that of the scaling of the variable. This issue can be resolved either by defining a suitable non-Euclidean gradient which is invariant to reparameterizations or by placing appropriate constraints on the filter weights as we show in the following section (Absil et al., 2008, Chapter 3) ."}, {"heading": "3 RESOLVING SYMMETRY ISSUES USING MANIFOLD OPTIMIZATION", "text": "We propose two ways of resolving the symmetries that arise in deep architectures. First, we follow the approach of (Amari, 1998; Edelman et al., 1998; Absil et al., 2008) to equip the search space with a new non-Euclidean metric to resolve the symmetries present. Second, we break the symmetries by forcing the filter weights to be on the unit-norm manifold. In both these case, our updates are simple to implement in a stochastic gradient descent setting on manifolds (Bonnabel, 2013). The proposed updates are shown for a two layer deep network. However, the updates can be readily extended to deeper architectures.\nConsider a weight vector w \u2208 Rn, the Euclidean squared length of a small incremental vector dw connecting w and w + dw is given by\n\u2016dw\u20162 = n\u2211 i=1 (dwi) 2. (5)\nFor a non-Euclidean coordinate system, however, the notion of squared distance is given by the Riemannian metric\n\u2016dw\u20162G = dwTGdw, (6)\nwhere the matrix G is a positive definite matrix. If G is the identity matrix, then the coordinate system in (6) is Euclidean. The steepest descent direction for a loss function `(w) under the metric (6) is given by \u2207\u0303`(w) = G\u22121\u2207`(w), where \u2207`(w) is the Euclidean gradient and \u2207\u0303`(w) is the Riemannian gradient under the metric (6). Consequently, the first order weight update is of the form\n\u2207\u0303`(w) = G\u22121\u2207`(w) wt+1 = wt \u2212 \u03bb\u2207\u0303`(w), (7)\nwhere wt is the current weight, \u2207`(w) is the Euclidean gradient, wt+1 is the updated weight, and \u03bb is the learning rate. Therefore, to resolve the symmetries for (W1,W2, \u03b8) discussed in Section 2, we propose the novel Riemannian metric\n\u2016dW1\u20162GW1 = Tr(dW T 1 GW1dW1) \u2016dW2\u20162GW2 = Tr(dW T 2 GW2dW2) \u2016d\u03b8\u20162\u03b8 = Tr(d\u03b8T d\u03b8G\u03b8),\nwhere GW1 = (Diag(diag(W1W T 1 )))\n\u22121, GW2 = (Diag(diag(W2W T 2 )))\n\u22121, and G\u03b8 = (Diag(diag(\u03b8 T \u03b8)))\u22121.\n(8)\nHere Tr(\u00b7) takes the trace of a square matrix, Diag(\u00b7) is an operator which creates a diagonal matrix with its argument placed along the diagonal, and diag(\u00b7) is an operator which extracts the diagonal elements of the argument matrix. It should be noted that G is defined separately for the weights W1, W2, and \u03b8 in (6), which is invariant to the reparameterizations shown in (1) and (2) for Arch1 and (3) for Arch2. It should be noted that G\u03b8 in (8) acts from the right side in the case of \u03b8. The motivation behind the metric choice in (8) comes from the classical notion of right and left invariances in differential geometry, but now restricted to diagonal elements. To show the invariance of the proposed metric, we consider the invariance for \u03b8 in Arch1 as an example.\n\u2016d\u03b8\u0303\u20162G\u03b8\u0303 = Tr(d\u03b8\u0303G\u03b8\u0303d\u03b8\u0303 T ) = Tr((d\u03b8 1\u03b10 \u03b2 \u22121 s )(Diag(diag( 1 \u03b10 \u03b2\u2212Ts \u03b8 T \u03b8 1\u03b10 \u03b2 \u22121 s ))) \u22121\n( 1\u03b10 \u03b2 \u2212T s d\u03b8 T ))\n= Tr(d\u03b8 1\u03b10 \u03b2 \u22121 s \u03b2s\u03b10(Diag(diag(\u03b8 T \u03b8)))\u22121\u03b10\u03b2 T s \u03b2 \u2212T s 1 \u03b10 d\u03b8T ) = Tr(d\u03b8(Diag(diag(\u03b8T \u03b8)))\u22121d\u03b8T ) = \u2016d\u03b8\u20162G\u03b8 ,\nand therefore, the squared length (6) is left unchanged (i.e., the metric is invariant) under the considered reparameterization of \u03b8 in (2). Similar derivations show that the metric in (8) is invariant to reparameterizations in W1 and W2. We term the proposed metric in (8), collectively as the scaled metric (SM). The scaled metric SM is equally applicable as an invariant metric for Arch2 which possesses symmetries shown in (3).\nAnother way to resolve the symmetries that exist in Arch1 and Arch2 is to constrain the weight vectors (filters) in W1 and W2 to lie on the oblique manifold (Absil et al., 2008; Boumal et al., 2014), i.e., each filter in the fully connected layers is constrained to have unit Euclidean norm.\nEquivalently, we impose the constraints diag(W1WT1 ) = 1 and diag(W2W T 2 ) = 1, where diag(\u00b7) is an operator which extracts the diagonal elements of the argument matrix.\nConsider a weight vector w \u2208 Rn with the constraint wTw = 1. (For example, wT is a row of W1.) The steepest descent direction for a loss `(w) with w on the unit-norm manifold is computed \u2207\u0303`(w) = \u2207`(w) \u2212 (wT\u2207`(w))w, where \u2207`(w) is the Euclidean gradient and \u2207\u0303`(w) is the Riemannian gradient on the unit-norm manifold (Absil et al., 2008, Chapter 3). Effectively, the normal component of the Euclidean gradient, i.e., (wT\u2207`(w))w, is subtracted to result in the tangential (to the unit-norm manifold) component. Following the tangential direction takes the update out of the manifold, which is then pulled back to the manifold with a retraction operation (Absil et al., 2008, Example 4.1.1). Finally, an update of the weight w on the unit-norm manifold is of the form\n\u2207\u0303`(w) = \u2207`(w)\u2212 (wT\u2207`(w))w w\u0303t+1 = wt \u2212 \u03bb\u2207\u0303`(w) wt+1 = w\u0303t+1/\u2016w\u0303t+1\u2016,\n(9)\nwhere wt is the current weight,\u2207`(w) is the Euclidean gradient, wt+1 is the updated weight, and \u03bb is the learning rate. It should be noted when W1 and W2 are constrained, the \u03b8 variable is reparameterization free.\nBoth the proposed weight updates, (7) that is based on the scaled metric (SM) and (9) that is based on the unit-norm (UN) constraint, can be used in a stochastic gradient descent (SGD) setting which we use in our experiments described in the following section. It should be emphasized that the proposed updates are numerically efficient to implement. The Euclidean gradients are computed efficiently using gradient back-propagation (Rumelhart et al., 1986).\nThe proposed symmetry-invariant updates for a loss function L(W1,W2, \u03b8) in Arch1 and Arch2 type networks are shown in Table 1. Here (W t1 ,W t 2 , \u03b8 t) is the current weight, (W t+11 ,W t+1 2 , \u03b8\nt+1) is the updated weight, \u03bb is the learning rate, and \u2207W1L(W t1 ,W t2 , \u03b8t), \u2207W2L(W t1 ,W t2 , \u03b8t), and \u2207\u03b8L(W t1 ,W t2 , \u03b8t) are the partial derivatives of the loss L with respect to W1, W2, and \u03b8, respectively at (W t1 ,W t 2 , \u03b8 t). The matrices GW t1 , GW t2 , and G\u03b8t are defined in (8) at (W t 1 ,W t 2 , \u03b8\nt). The operator Orth(\u00b7) normalizes the rows of the input argument. \u03a0W (\u00b7) is the linear projection operation that projects an arbitrary matrix onto the tangent space of the oblique manifold at an element W . Specifically, it is defined as \u03a0W (Z) = Z\u2212Diag(diag((ZWT ))W (Boumal et al., 2014), where Diag(\u00b7) is an operator which creates a diagonal matrix with its argument placed along the diagonal and diag(\u00b7) is an operator which extracts the diagonal elements of the argument matrix. The additional parameters used in Arch2 are updated as proposed in (Ioffe & Szegedy, 2015). It should be noted that G\u22121\u03b8 acts from the right side in the update of \u03b8.\nThe convergence analysis of SGD on manifolds follows the developments in (Bottou, 2010; Bonnabel, 2013)."}, {"heading": "4 EXPERIMENTAL SETUP", "text": "We train both two and four layer deep Arch1 and Arch2 networks to perform digit classification on the MNIST dataset. This dataset has 60000 training images and 10000 testing images. For both these architectures we use 64 features per layer. The digit images are rasterized into a 784 dimensional vector as input to the network(s). No input pre-processing is performed. The weights in each layer are drawn from a standard Gaussian and each filter is unit-normalized. The soft-max class vectors are also drawn from a standard Gaussian and each class vector is unit-normalized.\nWe use stochastic gradient descent based optimization as this is the most widely used technique for training deep networks. The three different weight updates that we compare within this first-order framework are scaled metric (SM), unit-norm (UN), and balanced SGD (B-SGD). B-SGD uses the Euclidean updates, but wherein the starting values of filters and class vectors are unit-normalized. BSGD is also studied as a benchmark algorithm in (Neyshabur et al., 2015). We choose a mini-batch size of 100 samples.\nWe choose the base learning rate from the set 10\u2212p for p \u2208 {2, 3, 4, 5} for each training run of the experimental network. To select the optimal learning rate from this set, we create a validation set of 500 images from the training set for testing. We then train the network with each learning rate\nusing a randomly chosen set of 1000 images from the training set for 50 epochs. At the start of each epoch, the training set is randomly permuted and mini-batches are sampled in a sequence ensuring each training sample is used only once within an epoch. We record the error on the validation set measured as the error per validation sample for each candidate base learning rate. Then the candidate rate which corresponds to the lowest validation error is selected and used for training the network on the full training set. We repeat this process of learning rate selection and training of the network with the full training set 10 times for each of the three weight update strategies. For each of these runs, we measure the mean and variance of the test error. We ignore a small proportion of runs where the validation error diverged.\nFor training each network, we use the two well known protocols for annealing or decaying the learning rate; the bold-driver (annealing) protocol (Hinton, 2008) and the exponential decay protocol. For the exponential decay protocol, we choose a decay factor of 0.95 after each epoch. In all, for each network, we use two protocols, three different weight update strategies, and 10 training runs for each combination thus totaling sixty training runs.\nFor each training run on the full dataset, we choose 50000 randomly chosen samples as the training set and the remaining 10000 samples for validation. We train for a minimum of 25 epochs and a maximum of 60 epochs. When the bold driver protocol is used, we terminate the training if, (i) the training error is less than 10\u22125, (ii) the validation error increases with respect to the one measured 5 epochs earlier, (iii) successive validation error measurements differ less than 10\u22125."}, {"heading": "5 RESULTS AND ANALYSIS", "text": "The mean and standard deviation of the test error for various training combinations are tabulated in Table 2. From these quantitative figures we can observe that Arch2 performs significantly better than Arch1. This emphasizes the ability of batch normalization to improve performance (Ioffe & Szegedy, 2015). Arch1 results are characterized by high mean and large standard deviation values for all three weight updates. However, there is no clear indication of the superiority of one protocol over the other. While the bold driver protocol improves the performance of B-SGD, it worsens the performance of SM and UN in the four layer deep network. The exponential decay protocol produces the best result in combination with the UN weight updates and has better performance for SM and UN for the four layer deep network. The good performance of UN can be explained by the fact that it allows for better gradient back-propagation (Rumelhart et al., 1986) as the norm of the filters are constrained to be unit norm.\nThe Arch2 network which includes batch normalization (Ioffe & Szegedy, 2015) helps improve gradient back-propagation by constraining the scales of the input feature maps to each layer. The beneficial result of adding this layer is clearly visible from our results where we see both SM and UN perform much better than B-SGD with the bold driver protocol. Both the mean and standard deviation of the test error are the lowest for SM and UN when both the two and four layer deep networks are considered. The bold driver protocol performs better than the exponential decay protocol for all the considered weight updates. The annealing protocol seems more suitable when sufficient regularization is in place as in Arch2 with SM and UN.\nWe show the mean trajectories of the test error over the training epochs for the four layer deep Arch1 and Arch2 in Figure 3. For Arch1, we show the results using the exponential decay protocol and for Arch2 we show results using the bold driver protocol. In practice, when using bold driver, the training is terminated based on the stopping criterion at most after 30 epochs.\nThe best results are obtained using Arch2 with SM and UN weight updates and with the bold driver learning rate annealing protocol. SM and UN absorb the symmetries present in Arch2 and help improve performance over what is achieved by standard batch normalization alone. The use of SM and UN can also be seen as a way to regularize the weights of the network during training without introducing any hyper-parameters, e.g., a weight decay term.\nThe quantitative results show that SM for a two layer deep network with the bold driver protocol performs better than using the B-SGD update for training a four layer deep network with exponential decay of the learning rate. It is also noteworthy to observe that the performance difference between the two and four layer deep Arch2 network is not very large. This raises the question for future research as to whether some of these networks necessarily have to be that deep (Ba & Caruana, 2014) or it can be made shallower (and efficient) by better optimization."}, {"heading": "6 APPLICATION TO IMAGE SEGMENTATION", "text": "We apply SGD with the proposed UN weight updates in Table 1 for training SegNet, a deep convolutional network proposed for road scene image segmentation into multiple classes (Badrinarayanan et al., 2015a). This network, although convolutional, possesses the same symmetries as those analyzed for Arch2 in (3). The network is trained for 100 epochs on the CamVid (Brostow et al., 2009)\ntraining set of 367 images. The predictions of the trained SegNet on some sample test images from the dataset can be seen in Figure 3. These qualitative results indicate the usefulness of our analysis and symmetry-invariant weight updates for larger networks that arise in practice."}, {"heading": "7 CONCLUSION", "text": "We have highlighted the symmetries that exist in the weight space of currently popular deep neural network architectures. We have shown that these symmetries can be handled well in stochastic gradient descent optimization framework either by designing an appropriate non-Euclidean metric or by imposing a unit-norm constraint on the filter weights. Both of these strategies take into account the manifold structure on which the weights of the network reside and lead to symmetry-invariant weight updates. The empirical results show the test performance can be improved using our proposed symmetry-invariant weight updates even on modern architectures. As a future research direction, we would exploit these techniques for deep convolutional neural networks used in practical applications."}, {"heading": "ACKNOWLEDGMENTS", "text": "Vijay Badrinarayanan and Roberto Cipolla were supported by a sponsorship from Toyota Motor Europe, Belgium. Bamdev Mishra was supported as an FNRS research fellow (Belgian Fund for Scientific Research). The scientific responsibility rests with its authors."}], "references": [{"title": "Riemannian geometry of Grassmann manifolds with a view on algorithmic computation", "author": ["Absil", "P.-A", "R. Mahony", "R. Sepulchre"], "venue": "Acta Applicandae Mathematicae,", "citeRegEx": "Absil et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Absil et al\\.", "year": 2004}, {"title": "Optimization Algorithms on Matrix Manifolds", "author": ["Absil", "P.-A", "R. Mahony", "R. Sepulchre"], "venue": null, "citeRegEx": "Absil et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Absil et al\\.", "year": 2008}, {"title": "Natural gradient works efficiently in learning", "author": ["Amari", "S.-I"], "venue": "Neural computation,", "citeRegEx": "Amari and S..I.,? \\Q1998\\E", "shortCiteRegEx": "Amari and S..I.", "year": 1998}, {"title": "SegNet: a deep convolutional encoder-decoder architecture for robust semantic pixel-wise labelling", "author": ["V. Badrinarayanan", "A. Handa", "R. Cipolla"], "venue": "Technical report,", "citeRegEx": "Badrinarayanan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Badrinarayanan et al\\.", "year": 2015}, {"title": "Understanding symmetries in deep networks", "author": ["V. Badrinarayanan", "B. Mishra", "R. Cipolla"], "venue": "Technical report,", "citeRegEx": "Badrinarayanan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Badrinarayanan et al\\.", "year": 2015}, {"title": "Stochastic gradient descent on Riemannian manifolds", "author": ["S. Bonnabel"], "venue": "IEEE Transactions on Automatic Control,", "citeRegEx": "Bonnabel,? \\Q2013\\E", "shortCiteRegEx": "Bonnabel", "year": 2013}, {"title": "Large-scale machine learning with stochastic gradient descent", "author": ["L. Bottou"], "venue": "In International Conference on Computational Statistics (COMPSTAT),", "citeRegEx": "Bottou,? \\Q2010\\E", "shortCiteRegEx": "Bottou", "year": 2010}, {"title": "Low-rank matrix completion via preconditioned optimization on the Grassmann manifold", "author": ["N. Boumal", "Absil", "P.-A"], "venue": "Linear Algebra and its Applications,", "citeRegEx": "Boumal et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Boumal et al\\.", "year": 2015}, {"title": "Manopt, a matlab toolbox for optimization on manifolds", "author": ["N. Boumal", "B. Mishra", "Absil", "P.-A", "R. Sepulchre"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Boumal et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Boumal et al\\.", "year": 2014}, {"title": "Semantic object classes in video: A high-definition ground truth database", "author": ["G. Brostow", "J. Fauqueur", "R. Cipolla"], "venue": "Pattern Recognition Letters,", "citeRegEx": "Brostow et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Brostow et al\\.", "year": 2009}, {"title": "The geometry of algorithms with orthogonality constraints", "author": ["A. Edelman", "T.A. Arias", "S.T. Smith"], "venue": "SIAM Journal on Matrix Analysis and Applications,", "citeRegEx": "Edelman et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Edelman et al\\.", "year": 1998}, {"title": "URL https://www. cs.toronto.edu/ \u0303hinton/csc2515/notes/lec6tutorial.pdf. Ioffe, S. and Szegedy, C. Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["G. Hinton"], "venue": "In International Conference on Machine learning (ICML),", "citeRegEx": "Hinton,? \\Q2008\\E", "shortCiteRegEx": "Hinton", "year": 2008}, {"title": "Low-rank optimization on the cone of positive semidefinite matrices", "author": ["M. Journ\u00e9e", "F. Bach", "Absil", "P.-A", "R. Sepulchre"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "Journ\u00e9e et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Journ\u00e9e et al\\.", "year": 2010}, {"title": "Optimization algorithms exploiting unitary constraints", "author": ["J.H. Manton"], "venue": "IEEE Transactions on Signal Processing,", "citeRegEx": "Manton,? \\Q2002\\E", "shortCiteRegEx": "Manton", "year": 2002}, {"title": "Path-sgd: Path-normalized optimization in deep neural networks", "author": ["B. Neyshabur", "R. Salakhutdinov", "N. Srebro"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "Riemannian metrics for neural networks I: Feedforward networks", "author": ["Y. Ollivier"], "venue": "Information and Inference,", "citeRegEx": "Ollivier,? \\Q2015\\E", "shortCiteRegEx": "Ollivier", "year": 2015}, {"title": "Riemannian metrics for neural networks II: Recurrent networks and learning symbolic data sequences", "author": ["Y. Ollivier"], "venue": "Information and Inference,", "citeRegEx": "Ollivier,? \\Q2015\\E", "shortCiteRegEx": "Ollivier", "year": 2015}, {"title": "Revisiting natural gradient for deep networks", "author": ["R. Pascanu", "Y. Bengio"], "venue": "Technical report,", "citeRegEx": "Pascanu and Bengio,? \\Q2013\\E", "shortCiteRegEx": "Pascanu and Bengio", "year": 2013}], "referenceMentions": [{"referenceID": 6, "context": "Stochastic gradient descent (SGD) has been the workhorse for optimization of deep networks (Bottou, 2010).", "startOffset": 91, "endOffset": 105}, {"referenceID": 14, "context": "In this regard, the recent work (Neyshabur et al., 2015) has brought to light simple scale invariance properties or symmetries in the weight space, which commonly used deep networks possess.", "startOffset": 32, "endOffset": 56}, {"referenceID": 14, "context": "In particular, the Euclidean gradient scales inversely to the scaling of the variable (Neyshabur et al., 2015).", "startOffset": 86, "endOffset": 110}, {"referenceID": 14, "context": "This leads to very different trajectories for different reparameterizations of the weights during the training process (Neyshabur et al., 2015).", "startOffset": 119, "endOffset": 143}, {"referenceID": 1, "context": "On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journ\u00e9e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).", "startOffset": 177, "endOffset": 323}, {"referenceID": 12, "context": "On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journ\u00e9e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).", "startOffset": 177, "endOffset": 323}, {"referenceID": 0, "context": "On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journ\u00e9e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).", "startOffset": 177, "endOffset": 323}, {"referenceID": 10, "context": "On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journ\u00e9e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).", "startOffset": 177, "endOffset": 323}, {"referenceID": 13, "context": "On the other hand, optimization over a manifold with symmetries has been a topic of much research and provides guidance to other simpler metric choices as we show in this paper (Absil et al., 2008; Mishra & Sepulchre, 2014; Boumal & Absil, 2015; Journ\u00e9e et al., 2010; Absil et al., 2004; Edelman et al., 1998; Manton, 2002).", "startOffset": 177, "endOffset": 323}, {"referenceID": 1, "context": "Even though the focus of the paper is on SGD algorithms, it should be noted that the updates proposed in Table 1 can readily be extended to first and second order batch algorithms (Absil et al., 2008).", "startOffset": 180, "endOffset": 200}, {"referenceID": 8, "context": "The stochastic gradient descent algorithms with the proposed updates are implemented in Matlab and Manopt (Boumal et al., 2014).", "startOffset": 106, "endOffset": 127}, {"referenceID": 14, "context": "It should be noted that our analysis differs from (Neyshabur et al., 2015), where the authors deal with a simpler case wherein \u03b2 = 1 \u03b10 is a scalar and \u03b8 is reparameterization free.", "startOffset": 50, "endOffset": 74}, {"referenceID": 10, "context": "First, we follow the approach of (Amari, 1998; Edelman et al., 1998; Absil et al., 2008) to equip the search space with a new non-Euclidean metric to resolve the symmetries present.", "startOffset": 33, "endOffset": 88}, {"referenceID": 1, "context": "First, we follow the approach of (Amari, 1998; Edelman et al., 1998; Absil et al., 2008) to equip the search space with a new non-Euclidean metric to resolve the symmetries present.", "startOffset": 33, "endOffset": 88}, {"referenceID": 5, "context": "In both these case, our updates are simple to implement in a stochastic gradient descent setting on manifolds (Bonnabel, 2013).", "startOffset": 110, "endOffset": 126}, {"referenceID": 1, "context": "Another way to resolve the symmetries that exist in Arch1 and Arch2 is to constrain the weight vectors (filters) in W1 and W2 to lie on the oblique manifold (Absil et al., 2008; Boumal et al., 2014), i.", "startOffset": 157, "endOffset": 198}, {"referenceID": 8, "context": "Another way to resolve the symmetries that exist in Arch1 and Arch2 is to constrain the weight vectors (filters) in W1 and W2 to lie on the oblique manifold (Absil et al., 2008; Boumal et al., 2014), i.", "startOffset": 157, "endOffset": 198}, {"referenceID": 8, "context": "Specifically, it is defined as \u03a0W (Z) = Z\u2212Diag(diag((ZW ))W (Boumal et al., 2014), where Diag(\u00b7) is an operator which creates a diagonal matrix with its argument placed along the diagonal and diag(\u00b7) is an operator which extracts the diagonal elements of the argument matrix.", "startOffset": 60, "endOffset": 81}, {"referenceID": 6, "context": "The convergence analysis of SGD on manifolds follows the developments in (Bottou, 2010; Bonnabel, 2013).", "startOffset": 73, "endOffset": 103}, {"referenceID": 5, "context": "The convergence analysis of SGD on manifolds follows the developments in (Bottou, 2010; Bonnabel, 2013).", "startOffset": 73, "endOffset": 103}, {"referenceID": 14, "context": "BSGD is also studied as a benchmark algorithm in (Neyshabur et al., 2015).", "startOffset": 49, "endOffset": 73}, {"referenceID": 11, "context": "For training each network, we use the two well known protocols for annealing or decaying the learning rate; the bold-driver (annealing) protocol (Hinton, 2008) and the exponential decay protocol.", "startOffset": 145, "endOffset": 159}, {"referenceID": 9, "context": "The network is trained for 100 epochs on the CamVid (Brostow et al., 2009)", "startOffset": 52, "endOffset": 74}], "year": 2015, "abstractText": "Recent works have highlighted scale invariance or symmetry that is present in the weight space of a typical deep network and the adverse effect that it has on the Euclidean gradient based stochastic gradient descent optimization. In this work, we show that these and other commonly used deep networks, such as those which use a max-pooling and sub-sampling layer, possess more complex forms of symmetry arising from scaling based reparameterization of the network weights. We then propose two symmetry-invariant gradient based weight updates for stochastic gradient descent based learning. Our empirical evidence based on the MNIST dataset shows that these updates improve the test performance without sacrificing the computational efficiency of the weight updates. We also show the results of training with one of the proposed weight updates on an image segmentation problem.", "creator": "LaTeX with hyperref package"}}}