{"id": "1511.03958", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Nov-2015", "title": "Software Agents with Concerns of their Own", "abstract": "We claim that it is possible to have artificial software agents for which their actions and the world they inhabit have first-person or intrinsic meanings. The first-person or intrinsic meaning of an entity to a system is defined as its relation with the system's goals and capabilities, given the properties of the environment in which it operates. Therefore, for a system to develop first-person meanings, it must see itself as a goal-directed actor, facing limitations and opportunities dictated by its own capabilities, and by the properties of the environment. The first part of the paper discusses this claim in the context of arguments against and proposals addressing the development of computer programs with first-person meanings. A set of definitions is also presented, most importantly the concepts of cold and phenomenal first-person meanings. The second part of the paper presents preliminary proposals and achievements, resulting of actual software implementations, within a research approach that aims to develop software agents that intrinsically understand their actions and what happens to them. As a result, an agent with no a priori notion of its goals and capabilities, and of the properties of its environment acquires all these notions by observing itself in action. The cold first-person meanings of the agent's actions and of what happens to it are defined using these acquired notions. Although not solving the full problem of first-person meanings, the proposed approach and preliminary results allow us some confidence to address the problems yet to be considered, in particular the phenomenal aspect of first-person meanings. This paper provides additional evidence that the concepts of cold and phenomenal first-person meanings are useful in understanding how machines interact and interact with others.\n\n\n\n\nTo further study the properties of cold and phenomenal first-person meanings, see our previous work (1) and (2) (3) (4). The next section is presented with the second part of this paper with a review.\n\n1. How to obtain a computer software agent for which the system operates\nThis paper outlines the first step in creating software agents for which they are intended to be a product of a system in which the program is designed. The first step of a software agent, when used to produce its first-person meaning, is the first step in developing a software agent for which its functions are based, or at least indirectly, derived. The first step is to create a software agent for which its functions are based; the second step is to develop the software agent for which its functions are based. The second step is to create a software agent for which its functions are based;", "histories": [["v1", "Thu, 12 Nov 2015 16:39:21 GMT  (349kb)", "http://arxiv.org/abs/1511.03958v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["luis botelho", "luis nunes", "ricardo ribeiro", "rui j lopes"], "accepted": false, "id": "1511.03958"}, "pdf": {"name": "1511.03958.pdf", "metadata": {"source": "META", "title": "Software Agents with Concerns of their Own", "authors": ["Lu\u00eds Botelho", "Lu\u00eds Nunes", "Ricardo Ribeiro", "Rui J. Lopes"], "emails": ["Luis.Botelho@iscte.pt"], "sections": [{"heading": null, "text": "Running head: SOFTWARE AGENTS WITH CONCERNS OF THEIR OWN 1\nSoftware Agents with Concerns of their Own\nLu\u00eds Botelho Lu\u00eds Nunes Ricardo Ribeiro Rui J. Lopes\nInstituto Universit\u00e1rio de Lisboa (ISCTE-IUL)\nAuthor Notes\nLu\u00eds Botelho, Lu\u00eds Nunes and Rui J. Lopes, Instituto de Telecomunica\u00e7\u00f5es (IT-IUL) and\nDepartment of Information Science and Technology of Instituto Universit\u00e1rio de Lisboa (ISCTE-IUL)\nRicardo Ribeiro, Instituto de Engenharia de Sistemas e Computadores (INESC-ID) and\nDepartment of Information Science and Technology of Instituto Universit\u00e1rio de Lisboa (ISCTE-IUL)\nThis work was done in the scope of R&D Units 50008 and 50021, partially supported by national funds through Funda\u00e7\u00e3o para a Ci\u00eancia e a Tecnologia (FCT) with references UID/EEA/50008/2013 and UID/CEC/50021/2013\nCorrespondence concerning this article should be addressed to Lu\u00eds Botelho, of the Department of Information Science and Technology of Instituto Universit\u00e1rio de Lisboa (ISCTE-IUL), Av. das For\u00e7as Armadas 1649-026, Lisboa, Portugal.\nContact: Luis.Botelho@iscte.pt\nAbstract\nWe claim that it is possible to have artificial software agents for which their actions and the world they inhabit have first-person or intrinsic meanings. The first-person or intrinsic meaning of an entity to a system is defined as its relation with the system\u2019s goals and capabilities, given the properties of the environment in which it operates. Therefore, for a system to develop first-person meanings, it must see itself as a goal-directed actor, facing limitations and opportunities dictated by its own capabilities, and by the properties of the environment.\nThe first part of the paper discusses this claim in the context of arguments against and proposals addressing the development of computer programs with first-person meanings. A set of definitions is also presented, most importantly the concepts of cold and phenomenal first-person meanings.\nThe second part of the paper presents preliminary proposals and achievements, resulting of actual software implementations, within a research approach that aims to develop software agents that intrinsically understand their actions and what happens to them. As a result, an agent with no a priori notion of its goals and capabilities, and of the properties of its environment acquires all these notions by observing itself in action. The cold first-person meanings of the agent\u2019s actions and of what happens to it are defined using these acquired notions.\nAlthough not solving the full problem of first-person meanings, the proposed approach and preliminary results allow us some confidence to address the problems yet to be considered, in particular the phenomenal aspect of first-person meanings.\nKeywords: First-person meaning; intrinsic understanding; goals; capabilities; properties of the environment\nSoftware Agents with Concerns of their Own\nIntroduction\nIn a debate that came to be better known as the symbol grounding problem (Harnad, 1990), several scientists have expressed their opinions that artificial intelligence would never lead to actual intelligent systems (e.g., Searle, 1980; Penrose, 1989; Ziemke, 1999; and, Froese & Ziemke, 2009). For these authors, artificial systems do not understand what happens to them, the symbols they possess, and what they do. That is, even when an artificial system exhibits a meaningful behavior, that meaningfulness is in the head of the observer; it is not an intrinsic interpretation of the artificial system itself.\nWe argue that it is possible to develop computer programs for which, objects, events, and situations have intrinsic meanings to the computer program, that is, first-person meanings. We use italics because we are applying to machines, an expression explicitly intended for people.\nSeveral of our arguments rely on the view that at least simple non-conscious living beings and artificial systems share the fundamental property of being purely rule-following mechanisms. That is, their behavior in a given state (internal and external) is completely determined by the interaction between the natural or artificial forces applicable to their inner workings and the properties of that state. Relevant forces applicable to artificial systems may include the instructions of a computer program. Relevant forces applicable to living beings include electrical and gravitational forces. From this point of view, at least simple rule-following living beings face the same objections, regarding the possibility of developing first-person meanings, as those\npresented to artificial intelligence by their critics, especially that the meaningfulness of the behavior of simple organisms is in the head of the observer. And, just as first-person meanings have emerged through evolution from non-conscious beings, we believe that they can also develop in artificial systems.\nThis paper presents our arguments and claims, our proposed research framework, and its preliminary results. It describes a set of conceptually defined, computationally implemented, and demonstrated concepts and mechanisms that support the development of first-person meanings, and the enactment of meaningful behavior. The described mechanisms and achieved results are integrated within the context of the presented research framework.\nThe next section presents some terminology, emphasizes the main contribution of the paper, and discusses the five assumptions of our proposed research framework. That research framework and the defined, implemented, and demonstrated concepts, mechanisms, and results are detailed in section \u201cResearch Approach, Proposals, and Achievements\u201d.\nResearch Assumptions: Terminology, Contribution, and Discussion\nThis paper discusses several concepts whose definitions are not widely accepted. In some cases, each author uses his/her own definitions. In other cases, not even a definition is presented in the hope that the common sense understanding of the concept is enough for the purpose of the discussion. In the next sub section we explain the sense in which several concepts are used in the paper, and we emphasize the main contribution of the paper. Then, we present a brief example\nthat illustrates the way we use those concepts. Finally, we present and discuss our research assumptions."}, {"heading": "Background Concepts and Main Innovative Contribution", "text": "Without any intention of providing a comprehensive view of consciousness, we need to present a few distinctions that will be used to explain other concepts. Consciousness has several manifestations and properties such as the autobiographic sense of the self, awareness, declarative reasoning and language. We will use the term \u201cawareness\u201d and derivatives to refer only to the knowledge or information one has by virtue of being conscious. In the sense that it is used hereunder, awareness is not meant to include for instance declarative reasoning and language. The special kind of awareness referring to the self would be termed self-awareness.\nAs any other manifestation of consciousness, awareness has a phenomenal component: when we are aware, we have phenomenal experiences, we have sensations with certain qualities, we feel. The phenomenal component of consciousness was termed the hard problem of consciousness by David Chalmers (1995). In the scope of this article, it is helpful to distinguish the information, stripped of any sensations, to which a sentient individual has access when he or she is aware of something. For instance when I am aware of the presence of my children, I experience a sensation (phenomenal) and I know that (I have access to the information that) they are present (cold).\nIn the remainder of this paper, we will use the expressions phenomenal awareness to refer to the sensations one feels because one is aware of something, and cold awareness to refer to the\ninformation, stripped of sensations, to which a sentient individual has access because it is aware of something.\nFinally, consciousness is also associated with a sense of continuity. When a person experiences and has access to information about the object of consciousness, for instance the image of an apple, the qualities of the experience and the information the person had access to, during the experience, will persistently be associated with the same object of consciousness (and to others, such as the members of the same class). This sense of continuity of consciousness is possibly ensured by autobiographic memory. Dam\u00e1sio (1999) distinguishes core consciousness from extended consciousness. Each time a person encounters an object of which he or she becomes aware, there is a pulse of core consciousness. Each pulse of core consciousness is a short duration event; alone, it does not ensure the sense of continuity. Only extended consciousness, possibly relying on autobiographic or episodic memory, provides that sense of continuity.\nFirst-person meanings, intrinsic meanings and concerns. A system has (or develops) first-person meanings of things, situations or events if those things, situations or events have (or acquire) meaning for the system itself. This expression is used in contrast with what happens when the meaning is in the mind of the observer (third-person meanings), but not in the system itself. In computer science, when a token has (or acquires) meaning, it is (or becomes) a symbol. We can think of the meaning of a symbol as the object, the situation, or the event that it refers to. In this paper, we are interested on a different aspect of meaning, namely the importance of the object, situation or event to the system itself. Thus, in this view, given that the importance of an object for a system reflects the relation of the object with the system\u2019s goals (or values, or any other\nsource of motivation such as the need to survive), it is important to stress that, in the sense that we use the expression in this paper, first-person meanings require goals.\nBesides, the system must be aware of the importance of the meaningful object, situation or event in face of the system\u2019s goals, capabilities, and the properties of the environment, irrespective of whether or not an observer recognizes such importance. Hence, first-person meanings also require awareness.\nGiven the above characterization, the first-person meanings of objects, situations or events reflect a value system the agent is aware of. In this sense, when an object, an event, or a situation has first-person meanings for an agent, that agent has concerns about that object, event, or situation.\nCold first-person meanings, phenomenal first-person meanings and consciousness. A system has (or develops) first-person meanings of things, situations or events only if the system is aware of the intrinsic importance of those things, situations, and events to itself. If the recognition of such intrinsic importance results from mere cold awareness, we say the agent has cold first-person meanings or cold concerns. However, if the recognition of such intrinsic importance is the result of phenomenal awareness, if it is experienced, we say the system has phenomenal first-person meanings or phenomenal concerns. It is important to stress that the cold awareness involved in cold first-person meanings does not ensure the sense of continuity often associated with consciousness.\nWe claim that (cold viz. phenomenal) first-person meanings of objects, situations or events are a manifestation of (cold viz. phenomenal) consciousness in the sense that we require that the system is aware of the importance of those objects, situations or events to itself. However, we do not equate first-person meanings with consciousness because consciousness has other manifestations such as autobiographic sense of the self, declarative reasoning, and language.\nGiven the distinctions presented so far, we are in the position of describing the main contribution of the paper and also to clearly identify some aspects of the general problem that are not addressed in it. First of all, we restate that this paper is concerned only with one aspect of firstperson meanings, namely the importance of objects, situations and events to the system. This is a difference regarding other work addressing first-person meanings, for example the work by Harnad (1990), Cangelosi, Greco, and Harnad (2002), Vogt (2002), Machado and Botelho (2006), and Steels (2003, 2008), which focuses on the symbol grounding problem, namely the problem of directly or indirectly grounding each symbol of an artificial system on the object, situation or event referred to by the symbol.\nWe assume that goals, value systems, or other sources of motivation (such as the need to stay alive and the need to preserve our genes) are sources of importance. If an event facilitates or impairs the achievement of someone\u2019s goals, then that event is important for that someone. If a situation is unrelated to someone\u2019s goals, then the situation is unimportant to that someone. That is, first-person meanings or concerns require goals (or other kinds of motives). In this paper, for the sake of simplicity, and because the distinction is not the focus of this research, we often use the term goals to refer to all types of motives.\nPossibly the most significant innovative contributions of this paper are (i) recognizing that, for the purpose of developing first-person meanings, it is not required that a system really has goals \u2013 it is enough that the system sees itself as being goal-directed; and (ii) providing an approach for a program with no explicit notion of goals to discover that it has (or might have) goals and thereafter start interpreting its behavior and what happens to it as if it were goal-directed. To the best of our knowledge, no other work has ever addressed the problem of first-person meanings in this way.\nWe claim the above contribution to be significant given that it represents a way around a plethora of objections about first-personhood, living beings, materialism, and computer programs. In fact, it has been argued (e.g., Dreyfus, 1972; and, Thompson and Stapleton, 2009) that only living beings can develop intrinsic meanings because only living beings have intrinsic motives (the need to survive). To those arguments we reply that all that happens with simple organisms as bacteria is acting as determined by the interplay between their state (internal or external) and applicable natural forces \u2013 similarly to computer programs, they are just rule following systems. However, this position faces a second sort of objections.\nSearle (1980), for example, says that (syntactic) rule-following systems cannot generate meanings (semantics) because semantics cannot arise from syntax. It is maybe this argument that reveals the potential importance of our contribution. The possibility of first-person meanings does not elude the rule-following nature of organisms and computer programs because the system does not have to exceed its nature, if it is to develop first-person meanings. In our view, it has to interpret itself as being goal-directed. That is, first-personhood is within reach of rule-following systems.\nAlthough required, it is not enough for a system to see itself as goal-directed to develop first-person meanings. If the system had super powers, it would not be concerned about its goals, because there would not be true obstacles to their achievement. The importance of things, situations, and events is also dependent on the system\u2019s capabilities. Additionally, the environment in which the system operates may also represent opportunities or constraints regarding the possibility of the system achieving its goals, given its capabilities. This paper contributes to realize the described relationship and to provide the means for a computer program, originally with no notion of its goals and capabilities, and of the constraints or opportunities created by its environment, to learn them just by observing itself in action.\nWe claim that the presented contributions address the problem of developing cold first-person meanings, in the sense that it enables an agent to start interpreting its behavior and what happens to it as if it were a goal-directed constrained entity. That is, the agent has cold awareness of the relation between objects, situations and events and the possibility of achieving its goals, given its limited capabilities, and the constraints and opportunities created by the environment.\nAlthough recognizing that solving the full problem of first-person meanings requires phenomenal awareness, the present paper does not contribute to solve this more difficult problem. This will be an important object of future research."}, {"heading": "Brief Example", "text": "We briefly present a short imagined example that illustrates our point of view and concepts.\nA robot was programmed to weld the external panel of car doors and then to assemble the doors\nto the car. It has no goals because it is just following the instructions contained in its control program. It also does not have any notions of its capabilities nor of the properties of the environment. Using one of the proposed algorithms, the robot starts seeing itself as if it were motivated to achieve a situation in which it has assembled the doors to the car and has welded the external panels to the doors.\nIn addition to believing that it has these goals, it also becomes aware of its capabilities, for instance, assembling a door to the car, grabbing the weld torch and using it to weld door panels.\nThe robot also discovers properties of the environment, such as that it must weld the panel to the door before it can assemble the door to the car because, although having the door panel welded is not a pre-condition to assemble the door, it cannot weld the door panel if the door is already assembled to the car.\nIn the eyes of the robot, a situation in which it has assembled the doors to the car and has welded the external panels to the doors means that it has fulfilled its goals \u2013 it is positively valued by the robot. A situation in which the robot holds the welding torch is also meaningful to the robot, in the first-person sense, because it knows the situation contributes to enable it to weld the door panel, which is one of its goals. The situation is positively valued by the robot. The door, the door panel, the car, the welding station are meaningful, positively valued objects for the robot as it knows it uses them to achieve its goals. A situation in which the welding station is broken is also meaningful to the robot because it knows that it will not be capable of achieving its goals. This situation is negatively valued by the robot.\nIf the robot does not have feelings, in the phenomenal sense, the described meanings (positive and negative) are cold first-person meanings \u2013 the robot has cold concerns about those meaningful situations and objects.\nIf the robot phenomenally feels the situation in which the welding station is broken, the situation has phenomenal first-person meaning to the robot \u2013 the robot has phenomenal concerns about it.\nFinally, the car engine, the car paint, the situation in which the engine is not assembled to the car, and the event in which another robot damaged the car engine have no importance to the robot in the light of its learned goals. The robot does not have any concerns about the car engine or the other robots.\nSection \u201cResearch Approach, Proposals and Achievements\u201d describes the domain-independent definitions and algorithms used by an agent with no prior notion of its goals, its capabilities, and the properties of the domain, to become aware of all this information. After that, the agent is capable of explaining the meaning of events and situations, which, from its own point of view, acquire importance with respect to its goals, its capabilities, and the properties of the domain. Results are presented for a demonstration scenario."}, {"heading": "Research Assumptions", "text": "Without a test, it is impossible to rigorously determine if a specific computer program has developed first-person meanings. Unfortunately, such a test has not yet been developed. Two major difficulties are hindering its development. The first difficulty arises from our insufficient\nunderstanding of what it means to have first-person meanings. Although we have provided requirements for a program to develop first-person meanings, we do not make any claim regarding the process used by the program to fulfill those requirements (e.g., individual development / historical evolution / preprogramming).\nThe second difficulty comes from the fact that, even if it were possible to define a test for\nfirst-person meanings applicable to animals, it could happen that the same test would not be applicable to computer programs. To see that this may be the case, consider the mirror test for self-awareness (Gallup, 1970). This test was created by psychologist Gordon Gallup Jr. to determine whether a non-human animal possesses the ability of self-recognition, and has been used as a self-awareness test. If an animal, in the presence of a mirror, is capable of adjusting its behavior towards itself (e.g., touching a marked part of its body that becomes visible only in the mirror), then the animal recognizes itself in the mirror, which, for some, is evidence that the animal is self-aware.\nIf a computer program passes an adapted version of this test, it would not necessarily mean that the program is self-aware because it could have been programed to exhibit the kind of behavior that would indicate self-awareness if the test had been applied to an animal. Possibly, this test would reveal that a program is self-aware only if we knew the program was defined in a certain way. Gold and Scassellati (2009) developed an unsupervised learning algorithm that enables a robot to reliably distinguish its own moving parts from those of others, just by looking at a mirror. Although the authors explicitly state they do not claim that their robot is conscious, we may be willing to interpret this experiment as revealing self-awareness. However, this would happen only because we know that the robot uses an unsupervised learning algorithm \u2013 it was\nnot explicitly programmed to recognize itself. We still need better tests that do not rely on our knowledge of the way the program is written.\nWithout a test directed at determining the existence of first-person meanings, the discussion about the possibility of having computer programs with first-person meanings and the discussion about the way to achieve them cannot be more than just argumentative. We are aware of the arguments used by detractors of artificial intelligence. However, those arguments, as well as ours, may have flaws. Nevertheless, we think that pursuing the research objective of having computer programs with first-person meanings, even though it might be unachievable (which we do not believe), will have a beneficial impact on both our understanding of the problem and the possibility to create more effective computer programs capable of facing more complex problems.\nWe firmly believe that it is possible to have computer programs with first-person meanings. Our point of view and the research we have been doing is based on the following research assumptions:\n1. It is possible to achieve software agents that develop first-person meanings, starting with\nsoftware systems with no such capabilities, either through historical evolution or through individual development. 2. Individuals may develop first-person meanings only if they are aware of those meanings. 3. The agent\u2019s goals, the description of the agent\u2019s capabilities, and the description of properties\nof the domain are fundamental concepts on top of which the agent may be capable of developing first-person meanings.\n4. For the purpose of the present research, it is not important to know if the agent is really\nguided by goals. It is also not important to understand the evolutionary process by which organisms would have become goal-directed individuals. What is actually important is finding a way an agent starts seeing itself as goal-directed.\n5. After the agent acquires the knowledge of its assumed goals, and the description of its\ncapabilities, tasks and environment, it is important for the agent to adopt them, and their relationships, and to shape its future behavior accordingly.\nThe next sub sections discuss related work, both objections and proposals, regarding the possibility of having computer programs that develop first-person meanings in the framework of our research assumptions. We start with a discussion of claims about the theoretical impossibility to create computer programs that develop first-person meanings. In particular, we analyze the position that only living beings are capable of developing them. Then, we discuss three groups of proposals regarding this problem. The first group addresses the sub problem of symbol reference. The second group stresses the need of a motivation system. Finally, the third group proposes that instead of building computer programs that develop first-person meanings, computer scientists should embrace the problem of building software environments from which the desired programs would emerge.\nTheoretical impossibility of building computer programs with first-person meanings\nFor Searle (1980) and also for Penrose (1989), only exact copies of living beings would be capable of first-person meanings because consciousness is generated at the physical level of the brain, in the context provided by the body to which it is coupled.\nWe argue that this does not have to be the case because we can start by creating a functional architecture (see Pylyshyn, 1980) with the same properties of the brain coupled to its body, at the desired level of abstraction. Then, it would be possible to create the processes responsible for first-person meanings on top of that functional architecture (but see Block, 1996 for arguments against functionalism).\nPenrose puts forth a more difficult argument: since mathematicians can prove propositions that, according to G\u00f6del (1931), cannot be proved by a computer program, there must be processes taking place in the human mind that are not computable. Given that, for Penrose, the only known non-computable physical phenomenon is quantic objective reduction, he hypothesized that consciousness would have a quantic basis. Hameroff and Penrose (1996, 2014) propose a model of consciousness whose physical basis is the quantic objective reduction taking place in the microtubules of the brain cells, which is not computable. Since we require that agents are aware of first-person meanings, a manifestation of consciousness, this argument undermines the functionalist approach since it would be impossible to create a computer program capable of exhibiting the desired properties at the quantic level because they were assumed to be non-computable.\nLaForte, Hayes, and Ford (1998), and Krajewski (2007) show that Penrose\u2019s conclusion that the human mind involves non-computable processes is wrong. LaForte, Hayes, and Ford show that the mathematicians that have proved the sentences that are not provable by an algorithm could only do that because they did not prove the soundness of their proofing procedure, which would be required for a proper proof. According to these authors, this proofing the soundness of the used proof procedure is impossible, even for those mathematicians. Krajewski presents and\nproves a general theorem, which shows that every kind of argument similar to that of Penrose must be either circular or lead to an inconsistency.\nIn addition, we think that, even if some process in the human mind were non-computable (which we do not believe), that process would not have to be the one responsible for awareness.\nZiemke (1999), Froese and Ziemke (2009), and Sharkey and Ziemke (2001) claim that any externally developed mechanisms aimed at creating meanings for a computer program will always produce arbitrary results for the computer program itself exactly because they are externally created.\nTo overcome this obstacle the computer program would have to create and maintain, from within, its whole network of parts and processes, as it is the case with living beings. This way, the meaning development mechanism of the program, being developed and maintained by the program itself, would produce non arbitrary meanings for the program.\nEsteves and Botelho (2007) presented an approach, according to which, the computer program develops and maintains all of its parts and processes from within, starting from an initial pre-programmed zygote. Since this initial zygote is pre-programmed, the approach continues to face objections because the initial zygote of living beings is the result of the co-evolution of the species and its environment; it was not externally created.\nWe believe that the fact that a living being develops itself and all its parts and processes from within does not constitute an advantage concerning the possibility of having first-person\nmeanings. The requirements for a system to develop first-person meanings are (i) being capable of determining the importance of objects, events, and situations in face of their goals, their capabilities, and the characteristics of the domain; and (ii) being aware of that importance. To do this, the system just needs to see itself as if it were a constrained goal-directed entity in relation with its environment, considering that \u201cseeing itself in a certain way\u201d is being aware. Rulefollowing systems, for instance simple living beings and computer programs with no awareness, do not in fact have goals; they just do what the forces applicable to their inner workings impose them given what happens to them. Therefore, a rule-following system sees itself as goal-directed only if it is capable of rationalizing what it does and what happens to it as if it had goals.\nSimple organisms and first-person meanings\nThompson and Stapleton (2009), and Froese and Ziemke (2009) claim that the life of even the simplest organism can be described as a sense-making activity. For instance, a specific motile bacterium moves along the gradient of sugar concentration towards its highest value, as a result of its metabolism. Even simple organisms, as the mentioned bacterium, regulate their interactions with the world in such a way that transforms the world into a place of salience, meaning, and value. According to these authors, this shows how the relation of even simple organisms with their environment becomes meaningful as a result of the organisms\u2019 metabolism.\nThompson (2011) and Froese (2015) recognize that this kind of meaning (sense-making) is not to be equated with the first-person perspective of conscious beings. However, Froese and Ziemke (2009) believe that it is impossible to have systems with first-person meanings that are not rooted on the lower-level sense-making mechanisms resulting of their metabolism.\nWe argue that the meaningfulness that is created by simple organisms as bacteria, as a result of their metabolism, is in the head of an external observer, exactly in the same way that critics of artificial intelligence have identified in the meaningfulness of the behavior of artificial systems. In fact, the behavior of simple organisms results, in each moment, of the interplay between the natural forces applicable to their inner workings and their state (internal and external), at that moment. In short, simple organisms are just rule-following systems, exactly in the same way as computer programs. None of them has a first-person perspective of what they do and of their environment. The requirement for the emergence of a first-person perspective in a system is the capability of relating what it does and what happens to it with its assumed goals, its capabilities, and the constraints and opportunities its environment places on the possibility of the system to achieve its goals. However, pure rule-following mechanisms do not have goals. Goals and goal-based explanations are useful abstractions that enable observers to better understand the behavior of complex systems. Goals do not exist for rule-following mechanisms.\nHow then is a system to develop a first-person perspective, if it does not have any goals or other motives? Only systems capable of rationalizing (explaining) their behavior and their environment as if they were constrained goal-directed entities can have a first-person perspective.\nThis is the reason we claim that, regarding the development of first-person meanings, it is not important to know whether or not the system actually has goals; what is important is seeing itself as a goal-directed entity.\nGiven that the sense-making of simple organisms is not an intrinsic property of those organisms but, instead, lies in the mind of the observer, and hence metabolism is not a requisite for first-person meanings, we believe that it is possible to individually develop or to historically evolve computer programs with no first-person meanings into computer programs with first-person meanings. The mentioned development or evolution process must, among other things, provide the resulting computer programs with the capability to see themselves as constrained goal-directed entities, and to become aware of the importance of things, events, and situations relative to the program\u2019s goals, capabilities, and to the properties of its environment."}, {"heading": "The sub problem of symbol reference", "text": "Harnad (1990), Cangelosi, Greco, and Harnad (2002) ground the symbols of their systems on the system\u2019s sensors. Mugan and Kuipers (2012) ground the plans of their robots on the motor commands of their actuators.\nVogt (2002), Steels (2003, 2008), and Machado and Botelho (2006) involve their systems in especially designed social interactions through which they develop, from scratch, a shared lexicon of symbols, each of which is connected to the object (and sometimes the category) they represent.\nAnderson and Perlis (2005) claim that computational tokens have or acquire representational powers for the computer program if they play consistent behavior guiding roles for the program. In this case, the meaning of each symbol is rooted in its behavior guiding role, that is, in its causal powers. Even though the behavior of the computer program is consistently dependent on\neach symbol (due to the assumed consistent behavior guiding powers of the symbol), the program would not be capable of stating the meaning of each of its symbols.\nAll these approaches address the reference sub-problem of the first-person meanings problem. This article is focused not on the reference sub-problem, but on the importance sub-problem of the first-person meanings problem.\nFor Brooks (1991), symbols and symbolic processing are not required for intelligent behavior therefore its robots avoid the symbol grounding problem. In our point of view, if the robot is to determine the importance of objects, events, and situations, it must see all it does and all that happens to it in the light of its goals. Besides, as Vogt (2002) argues, several high-level mental activities, as language, require symbols (but see Cuffari, di Paolo, and de Jaegher, 2014 for a contrasting opinion)."}, {"heading": "The necessity of a motivation system", "text": "For Dreyfus (1972), systems may develop first-person meanings only if they have body with body-related needs, which give rise to motivated behavior. Steels (1996) and Birk (1997) developed robots that successfully learn to stay alive in their environment relying only on mechanisms aimed at preserving internal variables within specified values, which may be seen as a form of motivated behavior. Savage (2003) discusses a set of processes by which complex motivated behavior can be developed in artificial agents, either by gradual improvement through the agent\u2019s experience or by historical evolution.\nWe fully agree that a motivational system is required for first-person meanings. However, we argue that, even if the presented systems act as if they knew what is important to them, they do not really have any idea of the importance of objects, events, and situations. To develop first-person meanings, they need to be aware of such importance.\nEmergence of agents with first-person meanings\nAs already stated before, Froese and Ziemke (2009), among others, contend that it is impossible to build computer programs with first-person meanings because the computer program would have to create and maintain itself and the whole network of its parts and processes from within. As a way to circumvent this problem, Froese and Ziemke (2009) present the quite radical idea that instead of trying to build programs with first-person meanings, scientists should focus on the definition and creation of environments with such dynamics that enable the emergence of computer programs with first-person meanings.\nWe feel sympathetic towards this idea, which we thoroughly considered adopting and implementing. Although we have not yet excluded this possibility, we have decided to tread a more traditional route for the following reason. Since we know of no literature reporting the emergence, from currently existing environments, of computer programs with first-person meanings, we think that currently existing environments will not do. Therefore, we would need to create new and different environments from which the desired computer programs would emerge. However we cannot be sure that a computer program with first-person meanings emerging from the new environment would be capable of tackling the problems of currently existing environments. Chances are that the emerging program would contribute to our\nunderstanding of the problem but not to solve the problems of currently existing environments for which we already need better programs. Besides, we feel that the problem of defining environments from which the desired computer programs would emerge is even less understood than the problem of defining the desired programs in the first place.\nResearch Approach, Proposals and Achievements\nFollowing the research assumptions presented in the previous section, our research agenda consists of investigating the following problems:\n1. Mechanisms by which a computer program (i) discovers that its behavior is (or might be)\ngoal-directed, (ii) discovers the description of its capabilities, and (iii) discovers properties of the task it performs and the environment it inhabits; 2. Mechanisms by which a computer program may use its knowledge about (cold awareness of)\nits goals, its capabilities, and the properties of the task it performs and of the environment it inhabits to create cold first-person meanings of objects, events and situations; 3. Mechanisms by which a computer program may use its knowledge about its goals, about its\ncapabilities, and about the properties of the task it performs and of the environment it inhabits to shape its future behavior;\n4. Mechanisms by which phenomenal experience may be developed in computer programs. We\nare interested, in particular, in the phenomenal awareness of the importance of objects, events, and situations in relation to the agent\u2019s goals, its capabilities, and the constraints and opportunities presented by the environment, which is the phenomenal component of first-person meanings, in the sense we have chosen to address.\n5. Everything we do in engineering must be validated therefore all the described problems must\nbe associated with adequate validation procedures. However, designing formal validation procedures for some of our targeted research goals, in particular feelings in the phenomenological sense, will be a major challenge. The design of such validation procedures is another problem of the proposed approach. However, we believe that designing such tests will only be possible after we have gained a deeper understanding of the concepts we are dealing with.\nThis paper contributes mainly to the two first problems of the presented research agenda. A smaller contribution to the third problem is also presented.\nThe first subsection of the present section describes the concepts that have been acquired by an initial program with no understanding of what it does and of what happens to it, and the domain independent algorithms that have been used for the acquisition of those concepts.\nThe second subsection describes a proof of concept scenario and shows that the achieved results encourage furthering our research."}, {"heading": "Understanding what happens", "text": "The conceptual framework of our work is represented in Fig. 1. The software agent is situated in its environment through its sensors and actuators. In addition to the sensors and actuators, the software agent has three additional components: the executor, the observer, and the adopter.\nFig.1 About Here\nFig. 1 - Functional conceptual framework\nAll of these components share the same sensors and actuators. Besides, the observer component has direct access to the actions executed by the executor component. The executor component is programmed to execute a given task with no sense of goals, with no explicit knowledge describing the agent capabilities (sensors and actuators), and with no explicit representations of the domain. It just senses the environment, through the agent\u2019s sensors, decides what to do (this does not have to involve any deliberative process relying on explicit knowledge representations), and acts on it through the agent\u2019s actuators. The observer component senses the environment exactly as sensed by the executor component, and also senses the actions being performed by the executor. The observer is responsible for learning the agent\u2019s goals, the description of the agent\u2019s capabilities, and several properties of the agent domain. The adopter uses the knowledge acquired by the observer to shape the agent future behavior and to produce conscious feelings of what happens, that is, phenomenal first-person meanings. This conceptual framework is described at the functional level. That is, the different agent components correspond to agent functions, not necessarily to different structural components.\nThe main focus of the work reported hereunder is the observer functional component and a small part of the adopter functional component. We have not addressed the generation of conscious feelings, in the phenomenological sense.\nIn what follows, a behavioral instance is the sequence of actions the agent\u2019s executor component performs. A behavioral class is the set of behavioral instances with the same purpose, i.e., the set\nof behaviors the agent executes at the service of alternative configurations of the same task the agent\u2019s executor was programmed to perform.\nIn the remainder of the section, a behavioral instance is described as an initial state followed by a sequence of action-state pairs. The state of the last action-state pair of the sequence is called the final state. As the agent\u2019s executor executes the actions of a behavioral instance, the agent\u2019s observer senses the states and the executed actions.\nWe have defined a set of concepts to be learned by the agent\u2019s observer component as it observes what is being done by the agent\u2019s executor component. Some of the defined descriptions are properties of the observed entities of the domain (Table 1, e.g., Proposition/1, Action/1 and Goal/1). The other descriptions relate entities of the domain (Table 3 and Table 2, e.g., Achieved/3, Contributed/2, MustPrecede/2, Effects/1). Domain entities comprise actions and propositions. A state is a set of positive atomic propositions representing their conjunction. For convenience, states are identified by unique identifiers. We have chosen to use non negative integers to index states. State S0 of a behavioral instance is its initial state. States are numbered by increasing order of their occurrence.\nDescriptions are organized into two other groups according to a different criterion: those that apply only to specific behavioral instances (Table 3, e.g., Achieved/3 and Contributed/2) and those that are independent of specific behavioral instances (Table 2, e.g., MustPrecede/2 and Precond/1).\nFinally, some descriptions are represented by functions (e.g., Effects/1) whereas others are represented by predicates (e.g., Achieved/3, MustPrecede/2).\nTable 1 \u2013 Learned entity properties\nTable About Here\nTable 2 \u2013 Descriptions that relate entities. Applicable to all behaviors\nTable About Here\nTable 3 \u2013 Descriptions that relate entities. Applicable to specific behaviors\nTable About Here\nOf the mentioned learned concepts, the predicates Goal and Desired capture the agent\u2019s goals; the predicate Action and the functions Precond, PosEffects, NegEffects, and ValidityCondition describe the agent\u2019s capabilities; and the predicates MustPrecede and Mandatory represent properties of the environment. These last two also capture cold first-person or intrinsic meanings of specified properties of the environment to the agent because, if the agent is to fulfill its goals, it knows it must satisfy these two classes of constraints (for all behavioral instances of the same class). All the above concepts represent cold first-person meanings or are used to define the predicates Contributed and Achieved. These latter predicates also represent cold first-person meanings of specified properties of the environment observed by the agent and of specific actions performed by the agent in the particular considered behavior.\nSome of the presented concepts can be formally defined (e.g., fluent propositions). In such cases, we present the axioms that can be used for their deduction. Some other concepts are not formally defined (e.g., goals). We have defined and implemented totally domain independent algorithms\nthat were used by the agent\u2019s observer component to learn all the described concepts. In the remainder of this section, we present the fundamental ideas behind each of those algorithms.\nPropositions and actions. Propositions and actions are the output of the agent\u2019s sensors.\nA state is exactly the set of propositions observed by the agent sensors at a given time instant. For convenience, the State/1 predicate holds state identifiers instead of state propositions. The function StateProps/1, applied to a state identifier, returns the set of propositions true in the state identified by the specified state identifier.\nThe predicate Proposition/1 is determined through the set union of all states of all behavioral instances of the agent. The predicate StaticProposition/1 is determined through the set intersection of all states of all behavioral instances of the agent.\nKnowing the set of all propositions and the set of all static propositions, it is possible to determine the fluent propositions using the following axiom schema:\n(Proposition(P) \u2227 \u00acStaticProposition(P)) \u21d2 FluentProposition(P)\nThat is, the set of fluent propositions is the difference between the set of all propositions and the set of the static propositions. Although implementation details are not important, all the algorithms have been implemented in the Prolog language. The implementation of all presented deduction axiom schemata is remarkably similar to the actual axioms. This is illustrated by the following example corresponding to the axiom schema just presented.\nfluent_proposition(P) :- proposition(P), not static_proposition(P).\nThe predicate Action/1 is computed through the set union of the actions observed in all behavioral instances of the agent.\nAgent goals: Goal/1. The agent\u2019s goals, learned through the observation of its behavior,\nare represented by the predicate Goal/1. Goal(PropsSet) means the agent behaves as if its goal were the conjunction of all propositions in the set PropSet.\nWhether or not the agent really has goals, the purpose of this research is to provide the means for the agent to understand its relation with the environment as if its behavior were guided by goals. We have assumed that, in case of success, the agent behavior ends when the agent\u2019s goals are achieved. This assumption is the basis for the proposed goal discovery algorithm. The set of agent\u2019s goals is determined through the intersection of the sets of fluent propositions of the final states of all the observed behavioral instances of the same class. We have provided an example of the implementation of an axiom schema (for the deduction of fluent propositions). However, not all algorithms correspond to logical axioms; several are learning algorithms that must process all instances of the same class of behaviors. In general, those learning algorithms implement set operations with the entities of the domain. The following pseudo-code exemplifies that class of algorithms for the case of determining the goals of the agent. This time, we do not provide the Prolog code because procedural Prolog code is not straightforward to understand for non-Prolog programmers.\ncompute_goals(List_of_behaviors) { foreach Behavior in List_of_behaviors { load_beahvior(Behavior) FluentProps = last_state_fluent_props() update_goals(FluentProps) } } update_goals(NewGoals) { if goals do not exist yet then store goal(NewGoals) else { remove goal(PreviousGoals) UpdatedGoals = setintersection(PreviousGoals, NewGoals) store goal(UpdatedGoals) } }\nUpon completion, the fact goal(Goals) will represent the set of the agent\u2019s goals. It is worth noting that the presented pseudo-code does not directly correspond to the actual implementation. The actual program does not implement a separate process for computing goals; it performs several computations at once, for instance the set of observed propositions, the set of observed actions, and the set of goals, among others.\nMainly for convenience, we propose the definition of a desired proposition as a proposition that is one of the agent goals. This definition leads to the following axiom schema.\n(Goal(PSet) \u2227 P\u2208PSet) \u21d2 Desired(P)\nThe algorithm used for determining desired propositions just needs to have access to the set of the agent\u2019s goals.\nMandatory propositions: Mandatory/1. We say that if a proposition P must precede\nanother proposition and P is not one of the agent\u2019s goals then P is mandatory. We believe it would be possible to identify other conditions under which a proposition should be considered mandatory but, for the moment, we will stick to this one.\nKnowing that a proposition is mandatory is meaningful to the agent, given that it knows that it will only achieve its goals if its behavior includes a state in which the mandatory proposition holds.\nThe following axiom schema captures the proposed intuition.\n(\u2203q MustPrecede(P, q) \u2227 \u00acDesired(P)) \u21d2 Mandatory(P)\nAs it will be seen later, MustPrecede(Prop1, Prop2) means that, due to the way the world works, to the task structure, and to the agent goals and capabilities, if propositions Prop1 and Prop2 occur in a behavioral instance then either they both occur in the initial state or Prop1 must occur before Prop2.\nThe algorithm for computing the predicate Mandatory/1 restricts the set of all fluent propositions to those that are not desired but must precede another proposition.\nPrecedence relations: MustPrecede(Prop1, Prop2). As it has been defined, a\nprecedence relation is intrinsically meaningful to the agent because it knows it cannot achieve its goals if it does not satisfy the learned precedence.\nWe start by the definition of the precedence relation for a single behavioral instance. Then we provide the general definition, valid for all behavioral instances of the same class.\nBefore the definition, a note about transitivity of the precedence relation, as it is used in our research, is in place. Contrarily to the usual precedence concept, the precedence relation, as we have conceptualized it, is not transitive. It is possible to have MustPrecede (P1, P2) and MustPrecede(P2, P3) without MustPrecede(P1, P3). Consider the example of the following two behavioral instances, B1 and B2:\nFig.2 About Here\nFig. 2 - Precedence relation in two examples\nThe precedence relation shared by the two behaviors B1 and B2 consists only of the pairs <P1, P2> and <P2, P3>, but not by the pair <P1, P3>. If we had defined the precedence relation as being transitive, one of the pairs <P1, P2> or <P2, P3> would have to be excluded. The major problem then would have been to decide which of them to exclude. Instead of finding a criterion to exclude one of these pairs, we decided to define the precedence relation as non-transitive.\nPrecedence in a singular behavioral instance: Precedes(P1, P2) holds for a given instance of a behavioral class if the propositions P1 and P2 are both true in the initial state; or if P1 occurs before P2, and P1 is not a precondition of one of the actions of the action sequence that leads from the state in which P1 is true (but not P2) to the state in which P2 is true.\nThat is, if P1 and P2 are not true in the initial state, there must be a sequence of actions, ActSequence, such that (i) performing ActSequence in the state S1 leads to the state S2; (ii) P1 is a member of StateProps(S1), and P2 is a member of the difference (StateProps(S2) \u2013 StateProps(S1)); and (iii) P1 is not a member of the set of preconditions of any actions in ActSequence. StateProps(S) represents the set of propositions of the state identified by S.\nPrecedence relation, defined in a class of behaviors: MustPrecede(P1, P2) holds for a behavioral class, iff, for each instance of that behavioral class, b, in which both P1 and P2 occur, P1 precedes P2 in that behavioral instance, b: Precedes(P1, P2). To avoid situations in which the precedence relation is satisfied exclusively by behavioral instances in which P1 and P2 occur simultaneously in the initial state, we additionally impose that there must be at least one behavioral instance in which P1 actually precedes P2.\nThe algorithm that learns the precedence relation by observation closely follows the described definition. First we defined an algorithm that discovers the precedence relation in a single instance of the behavioral class. Then, we defined the algorithm that checks if the precedence relation holds in all behavioral instances and if there is at least one of them in which P1 actually precedes P2. This second component of the algorithm calls the single instance component, discarding those behavioral instances in which P1 and P2 do not occur at all.\nAction preconditions: Precond(Act). Precond/1 is a function such that Precond(Act) represents the set of all preconditions of action Act. Action preconditions are propositions that must be true for the action to be executed.\nThe algorithm to determine the preconditions of an action performs the intersection of the sets of fluent propositions of all states of all behavioral instances in which the action is executed.\nAlthough this idea is correct, the fact that some actions are performed only too few times, even if all instances of the same behavioral class are considered, may lead to sets of preconditions with more propositions than those actually necessary for the action to be executed.\nTo circumvent this problem, it was necessary to generalize actions instead of considering only the observed instances of the same action. For example, instead of considering every instance of a given action (such as Move(A, P1, B), moving block A from position P1 to the top of block B), it is necessary to consider the abstract action (Move(block, from, to), in which block, from and to are variables). Using generalization of the action arguments allowed the algorithm to discover the correct set of action preconditions.\nIn addition to solving the mentioned problem, caused by action instances that are seldom executed, generalization enables to use the abstract action preconditions for problems that require action instances that were never observed, as it is the case in planning problems. This second reason led us to use generalization also for determining the action effects and the action validity conditions.\nAction effects: PosEffects(Act) and NegEffects(Act). PosEffects/1 and NegEffects/1 are\nfunctions that return action effects. PosEffects(Act) represents the set of the positive effects of the action Act; and NegEffects(Act) represents the set of its negative effects.\nThe action\u2019s positive effects are the propositions that become true immediately after the action is executed. The action\u2019s negative effects are those propositions that were true before the action is executed and cease to be true immediately after the action is executed.\nThe set of positive effects of an instance of an action is determined as the difference between the set of propositions of the state observed immediately after the action instance has been executed and the set of propositions holding in the state in which the action instance was executed.\nThe set of negative effects of an instance of an action is obtained through the difference between the set of propositions of the state in which the action instance was executed and the set of propositions of the state immediately after the execution.\nAfter determining the effects of all action instances, the algorithm performs generalization on the action arguments, leading to the general expression of the effects of all observed actions.\nAction validity condition: ValidityCondition(Act). The functional expression\nValidityCondition(Act) represents the conditions that must be satisfied by variables of the action Act that make it a valid action. That is, it specifies the valid instantiations of those variables. For instance, the validity condition of the blocks world action Move(block, from, to) is that the variable block must be a block, the variables from and to must be places where a block can be placed, and all the variables must have different values:\n(Block(block) \u2227 Place(from) \u2227 Place(to) \u2227 block \u2260 from \u2227 block \u2260 to \u2227 from \u2260 to)\nWe emphasize that, as it was the case with preconditions and effects, it is necessary, for certain problems such as planning, that the action validity condition is generalized, i.e., it must specify a set of values for the variables that is more general than just the observed instantiations.\nThe main idea underlying the algorithm used for determining a generalized validity condition of an action consists of finding the static predicates that cover all the observed instances of the same action. First the algorithm tries to apply each one-place predicate to each of the action variables and checks if all observed instances of the action are covered by the tried predicates. Then, the algorithm tries to apply all binary static predicates to all ordered pairs of variables. Then it moves to the ternary predicates, and so on, until all static predicates have been tried.\nEach time the algorithm tries to use an N-ary static predicate with all N-ary tuples of variables, it uses first the predicates with a smaller extension as a way of avoiding overgeneralizations, which would have a greater likability of being wrong.\nDescription of specific behaviors: Achieved/3 and Contributed/3. Achieved/3 and Contributed/3 and Achieved/3 do not reflect general properties of actions or propositions. They reflect the usefulness, the purpose, of specific actions and propositions of specific behaviors.\nThe relationships Achieved(State, Act, PropsSet) and Contributed(State, Prop, Act) represent the cold first-person meanings of actions and propositions of specific behaviors to the agent.\nAchieved(State, Act, PropsSet) expresses the agent\u2019s knowledge of the reasons justifying the execution of a given action in a specific behavior: achieving one of its goals or as a means to\nachieve a state in which another action could be and was actually executed. The propositions in the set PropsSet constitute the relevant effects of the action Act, executed in the state State of the specific observed behavior. Action effect, in the sense that the action was executed in a state in which no such propositions were true leading to a state in which they all become true. Relevant in the sense that each of them is either one of the agent\u2019s goals or one of the preconditions of an action that actually used it in a future state of the same behavior.\nContributed(State, Prop, Act) expresses the agent\u2019s knowledge of the usefulness of a given proposition, true in a specific state of a specific behavior: being the precondition of an action actually executed at that state. Proposition Prop, true in state State of the specific observed behavior, contributed to the execution of action Act in the same state of the same behavior, because it is one of Act\u2019s preconditions.\nFor the formalization of the axiom schema that can be used for the deduction of Contributed/3 relationships, it is necessary to use the predicate NextState/3 that has not yet been introduced. NextState(S1, A, S2) relates a state identifier (S1), the action that is performed in that state (A), and the identifier of the new state resulting of the action execution (S2). NextState/3, as well as State/1 and StateProps/1, refers to states, actions and propositions actually observed by the\nobserver component of the agent. For instance, \u2203t NextState(S, A, t) means that (i) there is a state\nin the considered observed behavior, identified by S, and that (ii) the action A was actually executed in that state, leading to another state whose identification is not specified. These predicates and function do not refer to possibilities; they refer to actually executed behavior.\n( State(S) \u2227 P\u2208StateProps(S) \u2227 Action(A) \u2227\n\u2203r NextState(S, A, r) \u2227 P\u2208Precond(A) ) \u21d2 Contributed(S, P, A)\nThe positive effect P of action A1 is relevant if P is one of the agent goals or if P is one of the preconditions of a second action A2 that could be executed after A1 because that very occurrence of P was true when A2 was executed. If A2 has been executed in a state occurring after the one that ensues immediately after the execution of A1, P must be true in all states, from S until the state in which A2 was executed.\nThe axiom schemata for the deduction of the relevant effects of an action requires the definition of the relation PathTrue/3 such that PathTrue(Si, Sj, P) means that P is true in all states from Si to Sj inclusive.\n(State(S) \u2227 State(T) \u2227 S \u2264 T \u2227 \u00ac\u2203r (State(r) \u2227 S \u2264 r \u2264 T \u2227 P\u2209StateProps(r)))\n\u21d2 PathTrue(S, T, P)\nThe relation \u2264, between state identifiers, reflects a temporal ordering among states. Being S and T two state identifiers, S \u2264 T means that the state identified by S occurred before the state identified by T, or that they identify the same state.\n( State(S) \u2227 Action(A) \u2227 \u2203r NextState(S, A, r) \u2227\nDesired(P) \u2227 P\u2208PosEffects(A) ) \u21d2 RelevantEffect(S, A, P)\n\u2203r ( State(S) \u2227 Action(A) \u2227 NextState(S, A, r) \u2227 P\u2208PosEffects(A) \u2227\n\u2203t (State(t) \u2227 S \u2264 t \u2227 PathTrue(r, t, P) \u2227 \u2203a Contributed(t, P, a)) )\n\u21d2 RelevantEffect(S, A, P)\nPropsSet, in the relationship Achieved(S, A, PropsSet) represents the set of the relevant effects of the action A, executed in the state S. The following axiom schema captures the definition:\nAchieved(S, A, {p: RelevantEffect(S, A, p)})\nThe algorithms for determining the relations Contributed/3 and Achieved/3 apply the axiom schemata presented for their deduction, for which they need the following relations and functions: State/1, Action/1, Desired/1, StateProps/1, NextState/3 and Precond/1. Determining Achieved/3 also requires the relation Contributed/3 (or else, its definition).\nFor determining the relation Contributed/3 the algorithm computes, for all states of the considered behavior, the set of tuples <S, P, A> such that the proposition P, true in the state S, is one of the preconditions of the action A, executed in state S.\nFor determining the relevant effects of an action (i.e., relation RelevantEffects/3), the algorithm computes all tuples <S, A, P> such that the action A, executed in the state S,\n(i) generated at least one of the agent goals (P); or\n(ii) generated one of the preconditions P of another action (A\u2019) executed in a future state; P\nwas true in all states from the one immediately after the execution of A until the one in which A\u2019 was executed.\nThese tuples are then used to generate the tuples of Achieved/3 relation, which include, in their third element, the set of all relevant effects of A, executed in the state S."}, {"heading": "Proof of Concept and Discussion", "text": "The described definitions and algorithms were demonstrated in a simple scenario of the blocks world. Given their independence of the domain, the presented definitions and algorithms could have been demonstrated in other scenarios.\nBlocks world scenario. In this version of the blocks world, the agent moves blocks\naround until they are all stacked on top of each other. The place where the blocks will be stacked is irrelevant. There are always three equal blocks \u2013 A, B, and C \u2013 and four spaces on a table \u2013 P1, P2, P3, and P4. Each block may be placed on one of the table positions or on top of any other block. The predicate Place/1 is used to hold the places where blocks may be located. The final stack must contain the block B on top of the block C and the block A on top of the block B.\nFig.3 About Here\nFig. 3 - Example of a blocks world problem\nTwo blocks cannot be placed on the same position therefore a block can only be moved to a place if the place is clear. Predicate Clear/1 is true for clear places. The agent can only move a block at a time, and only if the block to be moved does not have any other block on top of it. The predicate On/2 is used to specify the relation between a block and the place in which it is positioned. On(block, place) means that the specified block is positioned on the specified place.\nThe states of the world contain only positive instances of the Clear/1 and On/2 predicates, which are accessible to all functional components of the agent through its sensors. The agent\u2019s only action schema, Move(block, from, to), moves the specified block, from the specified place (from), to the specified place (to).\nWe have made some simplifications in the demonstration to be described. These simplifications will be relaxed in future experiments. First, we assume that the agent\u2019s observer component recognizes each time a final states is reached; final states are always successful.\nAccording to the second simplification, each action produces always the same effects. Conditional and imperfect actions were not considered.\nThird, we have also assumed that the agent has perfect access to all relevant aspects of the world.\nAll initial configurations (e.g., 120) were automatically generated and the agent\u2019s executor component had to stack the blocks in each of them, which represents 120 instances of the same class of behavior. The states and the actions of each behavior were recorded on a file. The 120\nfiles were processed by the defined algorithms, which acquired the defined concepts and generated explanations of the agent\u2019s behaviors.\nGeneral results. Our algorithms have correctly discovered all the described concepts. In\nparticular they discovered the sets of domain entities: propositions, fluent propositions (e.g., On(A, B), Clear(A)), static propositions (e.g., Block(A), Place(P1)) and actions (e.g., Move(A, P1, B)).\nThe agent\u2019s observer functional component also discovered the agent\u2019s goals:\nGoal({On(A, B), On(B, C), Clear(A)})\nOne might argue that Clear(A) is not a goal; it is a necessity in the sense that it is true in all states of the described world in which the blocks A, B, and C are stacked. Although we have not solved this problem, we have in mind an approach that would generate experiences that would be capable of distinguishing true goals from mere necessities. The experiments would be designed to confirm or disconfirm goals under suspicion. Since the space of all possible experiments would be intractable, the mentioned approach should also provide a way of identifying goals under suspicion. For instance, if a certain proposition is the precondition of any action that achieves one of the agent\u2019s goals, maybe that proposition is not a true goal, but a necessity.\nDesired propositions are individual agent goals. Accordingly, the agent\u2019s observer component correctly identified the following desired propositions: Desired(On(A, B)), Desired(On(B, C)), Desired(Clear(A)).\nThe agent\u2019s observer component correctly discovered that On(B, C) must be achieved before it can achieve On(A, B): MustPrecede(On(B, C), On(A, B)).\nIn fact, the agent would never be capable of achieving its goals if this precedence relation is not observed. Moreover, On(B, C) is not a precondition of the actions that achieve On(A, B). The precedence relation arises strictly of the relation between the agent goals and its capabilities.\nGiven the deduction axiom for the Mandatory/1 relation, the agent\u2019s observer component didn\u2019t identify any mandatory proposition because, although On(B, C) must precede On(A, B), On(B, C) is also a goal, and goals were not defined as mandatory.\nOnly to test the deduction axiom and corresponding algorithm, we have artificially added the proposition GoalPrecedingProp before the proposition On(A, B) is achieved. Since GoalPrecedingProp is not a goal, it was identified as a mandatory proposition, which agrees with our preliminary definition:\nMandatory(GoalPrecedingProp).\nThe agent\u2019s observer component was also capable of discovering the generalized action descriptions:\nPrecond(Move(block, from, to)) = {On(block, from), Clear(block), Clear(to)}\nPosEffects(Move(block, from, to)) = {On(block, to), Clear(from)}\nNegEffects(Move(block, from, to)) = {On(block, from), Clear(to)}\nValidityCondition(Move(block, from, to)) =\n(Block(block) \u2227 Place(from) \u2227 Place(to) \u2227 block \u2260 from \u2227 block \u2260 to \u2227 from \u2260 to)\nTo learn the inequality relationships (\u2260) between all pairs of variables, it was necessary to equip the agent with sensors for the equality relation (=) and provide it with prior knowledge that, for\nany two terms, (X\u2260Y) \u2261 \u00ac(X = Y).\nThe following equality relationships among blocks and among table spaces were introduced in all states of all agent behaviors: A=A, B=B, C=C, P1=P1, P2=P2, P3=P3, P4=P4. These relationships were correctly learned as static relationships.\nThe algorithm was then allowed to use all static propositions together with the inequality relation and its definition in terms of the equality relation. This allowed the algorithm to correctly use the inequality relationships among all variables, when determining the action validity condition.\nExplaining specific behaviors. Achieved/3 and Contributed/3 are the relations that\nprovide meaning to specific behaviors. As explained, Achieved(State, Action, PropSet) and Contributed(State, Prop, Action) express the importance of specific actions and specific propositions in specific behaviors. Their importance is always explained in direct or indirect relation to the agent goals, hence Achieved/3 and Contributed/3, we argue, represent cold first-person meanings. They will become true first-person meanings when they are consciously felt by the agent, in the phenomenological sense.\nThe agent\u2019s observer component correctly explained all agent behaviors. However, it is impossible and useless to show the explanations of all actions of all 120 observed behaviors. Instead, we describe an example behavioral instance (Fig. 4) and we illustrate the explanations discovered by the agent\u2019s observer component.\nFig.4 About Here\nFig. 4 - Example of a behavioral instance\nWe start with the Achieved/3 explanations. The agent was capable of describing the relevant effects of all actions, but we provide only two examples of the generated explanations.\nAchieved(S1, Move(A, B, P2), {On(A, P2), Clear(B)})\nThis means that the action Move(A, B, P2), executed in state S1, led to a state (S2) in which block A is located on place P2, On(A, P2), and block B is clear, Clear(B). These two effects are relevant because the propositions On(A, P2) and Clear(B) were not true in state S1, and because Clear(B) is one of the preconditions of the action Move(B, P1, C), actually executed in state S2, and On(A, P2) is one of the preconditions of action Move(A, P2, B), actually executed in state S3. Although Move(A, P2, B) has not been executed immediately in state S2, the proposition On(A, P2) held true in states S2 and S3, which means it was actually used by the action Move(A, P2, B).\nAchieved(S2, Move(B, P1, C), {On(B, C)})\nThis means that the action Move(B, P1, C), executed in state S2, led to a state (S3) in which the block B is placed on top of block C, On(B, C). This is relevant because, although On(B, C) is not the precondition of any of the actions executed afterwards, it is one of the agent\u2019s goals.\nThe agent\u2019s observer component was also capable of finding meaning in the propositions that occur in the states of the agent behavior. Once again, we provide two examples that illustrate the results.\nContributed(S0, Clear(A), Move(A, C, B))\nClear(A), true in state S0, contributed to the action Move(A, C, B), actually executed in state S0, because it is one of its preconditions.\nContributed(S0, Clear(B), Move(A, C, B))\nClear(B), true in state S0, contributed to the action Move(A, C, B), actually executed in state S0, because it is one of its preconditions.\nAchieved/3 and Contributed/3 relationships can be chained to provide an explanation of the whole behavior.\nWe have also implemented a small exploratory fraction of the agent\u2019s adopter functional component. As can be seen in Fig. 4, the agent we have programmed to perform tasks in the blocks world is not an optimal agent. In fact the first two of its actions, in the depicted behavior,\nshould have been replaced by Move(A, C, P2) or Move(A, C, P4). However, if the description of the agent\u2019s actions (Precond/1, PosEffects/1, NegEffects/1 and ValidityCondition/1) and the agent goals are used in a planning algorithm, the agent will exhibit a better behavior. We have actually used a planning algorithm to which we have provided the agent goals and the descriptions of its actions. As expected, the algorithm produced an optimized behavior. This means that an agent can improve its future performance after it understands the goals that move its behavior, the description of its capabilities, and the properties of the environment.\nConclusions\nWe have argued that it is possible to have computer programs that develop first-person meanings of what they do and of what happens to them. Our belief relies on the following more fundamental one: along the evolution of life, there was a stage in which the most sophisticated living beings, although with brains and nervous systems, did not develop first-person meanings. As computer programs, they were pure rule-following systems, in the sense that their behavior was determined by the forces applicable to their inner workings. Yet, in a more recent stage of evolution, those living beings gave rise to other more sophisticated ones, capable of developing first-person meanings. That is, a rule-following system with no first-person meanings can evolve or develop into a system with first-person meanings. We note however that an appropriate test would be a significant advancement.\nDam\u00e1sio (1999) suggests that the concerns of an individual arise only if the individual is consciously aware of what he or she does and of what happens to him or her. While fully adopting this position, we extend it by saying that cold awareness is not enough; it is necessary\nto feel, to be phenomenally aware of what one does and of what happens to us. Varela and Depraz (2005), and Colombetti (2014) also recognize the primordial importance of the feeling body to consciousness. First-person meanings do not arise of some yet to be understood magic trick of pure rule-following; they are created by our rationalization capabilities and by our phenomenal experience.\nFrom the above argument, we propose that for a program to develop first-person meanings, it has first to start seeing itself as a goal-directed entity, so that it can explain what happens in terms of its relationship with its goals. Then it must adopt the goals it learns to have, as well as acquired goal-based explanations. For this adoption process, (i) the program\u2019s future behavior must reflect the knowledge the program acquires about itself and about its environment and tasks; and (ii) the program must feel the importance of objects, events, and situations to its goals, its capabilities, and the constraints and opportunities presented by its environment. The research described in this paper contributed to the less demanding problem of the agent becoming aware (in the cold sense) of its goals, its capabilities, its behavior, and everything that surrounds it, and use that awareness to develop cold first-person meanings of objects, events, and situations. We have also made a smaller contribution to enable an agent that has acquired the mentioned knowledge of its goals, of its capabilities, and of the properties of the environment to use that knowledge to shape its future behavior.\nAlthough we believe that a program may have first-person meanings comparable with ours only when it consciously feels, we are firmly convinced that it is possible to start right now with what could be called cold first-person meanings.\nWe proposed a research framework aimed at the development of agents having first-person meanings. The proposed framework was shaped by five research assumptions. Finally, we described the research we have recently done and its results.\nThe research we have described will be pursued in several ways. First of all, we have to drop some simplifying hypotheses we have used to facilitate this work. The agent\u2019s observer component should not know a priori when the agent\u2019s executor component has reached the final state of its task and if the task was successfully accomplished or if anything failed. The agent world should not be fully accessible to its sensors, and both the agent sensors and actuators should not be perfect. Not everything returned by the agent sensors should always exactly match reality; and not all agent actions should have absolutely predictable effects. All aspects of the reported research may be made more robust. We will also expand our work to tackle persistent goals, such as staying alive.\nIt will also be important that the agent\u2019s observer component monitors the changes in the agent\u2019s internal state, in addition to just observing what happens in the external world. This might enable the agent to interpret what it does as a strategy to preserve or to achieve desired properties of its internal state.\nAll the algorithms used in the research presented in this paper, although totally domain independent, were especially designed for our problems. It might be insightful to approach all the learning problems (those in which the agent\u2019s observer component considers all instances of the same behavior) using existing general-purpose learning algorithms and compare the results with those of the special-purpose algorithms we have designed.\nThe vocabulary we have proposed to represent the agent intrinsic understanding of what it does and what happens to it is still not enough. For instance, the agent does not have yet the vocabulary to express astonishment, and it has little capability to express properties of the environment. We will investigate new concepts, to be learned by the agent, which will empower it with capabilities for a richer understanding of what it does and what happens to it.\nAnother way this work will be pursued will be by investigating better mechanisms by which our computer programs may use the knowledge they acquire about themselves and the environment they inhabit to better shape their future behavior.\nFinally, we will start a research endeavor on what it means for an agent to consciously feel what it does and what surrounds it. A rigorous test must be developed, but its design requires a deeper understanding of what is feeling in the phenomenological sense.\nReferences\nAnderson, M. L., & Perlis, D. R. (2005). The roots of self-awareness. Phenomenology and the\nCognitive Sciences, 4 (3), 297\u2013333. doi:10.1007/s11097-005-4068-0\nBirk, A. (1997). Robot Learning and Self-Sufficiency: What the energy-level can tell us about a\nrobot's performance. In A. Birk, & J. Demiris (Eds.) Learning Robots: Proceedings of the Sixth European Workshop on Learning Robots (EWLR-6), Lecture Notes in Computer Science, 1545, (pp. 109-125). London: Springer\nBlock, N. (1996). What is functionalism?. Revised version of the entry on functionalism in The\nEncyclopedia of Philosophy Supplement. Macmillan (retrieved from http://www.nyu.edu/gsas/dept/philo/faculty/block/papers/functionalism.pdf)\nBrooks, R.A. (1991). Intelligence without representation. Artificial Intelligence, 47(1-3), 139-\n159\nCangelosi, A., Greco, A., & Harnad, S. 2002. Symbol Grounding and the Symbolic Theft\nHypothesis. In Cangelosi, A. & Parisi, D. (Eds). Simulating the Evolution of Language. London: Springer\nChalmers, D.J. (1992). Subsymbolic computation and the Chinese room. In J. Dinsmore (Ed.)\nThe Symbolic and Connectionist Paradigms: Closing the Gap. Lawrence Erlbaum, pp. 25- 48.\nChalmers, D.J. 1995. Facing Up to the Problem of Consciousness. Journal of Consciousness\nStudies, 2(3), 200-219.\nColombetti, G. (2014). The Feeling Body: Affective Science Meets the Enactive Mind.\nCambridge, MA: The MIT Press\nCuffari, E.C., di Paolo, E., & de Jaegher, H. (2014). From participatory sense-making to\nlanguage: there and back again. Phenomenology and the Cognitive Sciences, 1-37. DOI 10.1007/s11097-014-9404-9\nDam\u00e1sio, A. (1999). The feeling of what happens. Body, emotion and making of consciousness. .\nNew York: Harcourt Brace, ISBN: 0156010755\nDreyfus, H. (1972). What Computers Can't Do. Cambridge, MA: MIT Press, ISBN\n0-06-090613-8\nEsteves, A.S., & Botelho, L.B. (2007). The Centrifugal Development of Artificial Agents: a\nresearch agenda. In Proceedings of the workshop on Self-Organized Systems (SOS) of the Summer Computer Simulation Conference (SCSC'07)\nFroese, T. (2015). Beyond neurophenomenology: A review of Colombetti\u2019s The Feeling Body.\nNew Ideas in Psychology (in press)\nFroese, T., & Ziemke, T. (2009). Enactive artificial intelligence: Investigating the systemic\norganization of life and mind. Artificial Intelligence, 173(3-4), 466-500\nGallup, G.G. Jr. (1970). Chimpanzees: Self recognition. Science, 167 (3914), 86\u201387\nG\u00f6del, K. (1931). \u00dcber formal unentscheidbare S\u00e4tze der Principia Mathematica und verwandter\nSysteme, I. Monatshefte f\u00fcr Mathematik und Physik 38,173-198. DOI 10.1007/BF01700692. [On formally undecidable propositions of Principia Mathematica and related systems I. In S. Feferman (Ed) (1989) Kurt G\u00f6del collected works, Vol. I, 144-195. Oxford University Press]\nGold, K., & Scassellati, B. (2009). Using probabilistic reasoning over time to self-recognize.\nRobotics and Autonomous Systems 57, 384-392\nHameroff, S., & Penrose, R. (1996). Orchestrated reduction of quantum coherence in brain\nmicrotubules: A model for consciousness. Mathematics and Computers in Simulation, 40(3\u20134), 453\u2013480. DOI: 10.1016/0378-4754(96)80476-9\nHameroff, S., & Penrose, R. (2014). Consciousness in the universe. A review of the\u2018Orch\nOR\u2019theory. Physics of Life Reviews,11(1), 39\u201378\nHarnad, S. (1990). The Symbol Grounding Problem. Physica D, 42, 335-346\nKrajewski, S. (2007). On G\u00f6del\u2019s Theorem and Mechanism: Inconsistency or Unsoundness is\nUnavoidable in any Attempt to \u2018Out-G\u00f6del\u2019 the Mechanist. Fundamenta Informaticae 81(1-3), 173-181\nLaForte, G., Hayes, P.J., & Ford, K.M. 1998. Why Godel's Theorem Cannot Refute\nComputationalism. Artificial Intelligence 104(1-2), 265\u2013286.\nMachado, J., & Botelho, L.M. (2006). Software agents that learn through observation.\nIn Proceedings of the International Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS 2006)\nMugan, J., & Kuipers, B. (2012). Autonomous Learning of High-Level States and Actions in\nContinuous Environments. IEEE Transactions on Autonomous Mental Development 4(1), 70-86. DOI: 10.1109/TAMD.2011.2160943\nPenrose, R. (1989). The Emperor's New Mind: Concerning Computers, Minds and the Laws of\nPhysics. Oxford: Oxford University Press, ISBN 0-19-851973-7\nPylyshyn, Z. (1980). Computation and cognition: issues in the foundations of cognitive science.\nThe Behavioral and Brain Sciences, 3(1), 111-169\nSavage, T. (2003). The grounding of motivation in artificial animals: Indices of motivational\nbehavior. Cognitive Systems Research, 4(1), 23-55\nSearle, J.R. (1980). Minds, brains and programs. Behavioral and Brain Sciences, 3(3), 417\u2013424\nSharkey, N., & Ziemke, T. (2001). Mechanistic verses phenomenal embodiment: can robot\nembodiment lead to strong AI? Cognitive Systems Research, 2(4), 251 \u2013 262\nSteels, L. (1996). Discovering the competitors. Journal of Adaptive Behavior, 4(2), 173-199\nSteels, L. (2003). Evolving grounded communication for robots. Trends in Cognitive Sciences,\n7(7), 308\u2013312\nSteels, L. (2008). The Symbol Grounding Problem Has Been Solved. So What's Next? In M. de\nVega (Ed.) Symbols and Embodiment: Debates on Meaning and Cognition. Oxford University Press\nThompson, E. (2011). Reply to Commentaries. Journal of Consciousness Studies, 18(5-6),\n176-223\nThompson, E., & Stapleton, M. (2009). Making Sense of Sense-Making. Topoi, 28(1), 23-30.\nDOI: 10.1007/s11245-008-9043-2\nVarela, F. J., & Depraz, N. (2005). At the source of time: Valence and the constitutional\ndynamics of affect. Journal of Consciousness Studies, 12(8-10), 61-81\nVogt, P. (2002). The physical symbol grounding problem. Cognitive Systems Research, 3(3),\n429-457\nZiemke, T. (1999). Rethinking Grounding. In A. Riegler, M. Peschl, & A. von Stein (Eds.)\nUnderstanding Representation in the Cognitive Science. New York: Plenum Press. ISBN: 978-0-306-46286-3"}], "references": [{"title": "The roots of self-awareness", "author": ["M.L. Anderson", "D.R. Perlis"], "venue": "Phenomenology and the Cognitive Sciences,", "citeRegEx": "Anderson and Perlis,? \\Q2005\\E", "shortCiteRegEx": "Anderson and Perlis", "year": 2005}, {"title": "Robot Learning and Self-Sufficiency: What the energy-level can tell us about a robot's performance", "author": ["A. Birk"], "venue": "Learning Robots: Proceedings of the Sixth European Workshop on Learning Robots (EWLR-6), Lecture Notes in Computer Science,", "citeRegEx": "Birk,? \\Q1997\\E", "shortCiteRegEx": "Birk", "year": 1997}, {"title": "Intelligence without representation", "author": [], "venue": "Artificial Intelligence,", "citeRegEx": "Brooks,? \\Q1991\\E", "shortCiteRegEx": "Brooks", "year": 1991}, {"title": "Symbol Grounding and the Symbolic Theft Hypothesis", "author": ["A. Cangelosi", "A. Greco", "S. Harnad"], "venue": "Simulating the Evolution of Language", "citeRegEx": "Cangelosi et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Cangelosi et al\\.", "year": 2002}, {"title": "Facing Up to the Problem of Consciousness", "author": ["D.J. Chalmers"], "venue": "Journal of Consciousness", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1995}, {"title": "What Computers Can't Do", "author": ["New York: Harcourt Brace"], "venue": null, "citeRegEx": "Brace,? \\Q1972\\E", "shortCiteRegEx": "Brace", "year": 1972}, {"title": "The Centrifugal Development of Artificial Agents", "author": ["A.S. Esteves", "L.B. Botelho"], "venue": null, "citeRegEx": "Esteves and Botelho,? \\Q2007\\E", "shortCiteRegEx": "Esteves and Botelho", "year": 2007}, {"title": "Enactive artificial intelligence: Investigating the systemic", "author": ["T. Froese", "T. Ziemke"], "venue": "New Ideas in Psychology", "citeRegEx": "Froese and Ziemke,? \\Q2009\\E", "shortCiteRegEx": "Froese and Ziemke", "year": 2009}, {"title": "\u00dcber formal unentscheidbare S\u00e4tze der Principia Mathematica und verwandter", "author": ["Gallup", "G.G. Jr."], "venue": "organization of life and mind. Artificial Intelligence,", "citeRegEx": "Gallup and Jr.,? \\Q1970\\E", "shortCiteRegEx": "Gallup and Jr.", "year": 1970}, {"title": "Using probabilistic reasoning over time to self-recognize", "author": ["K. Gold", "B. Scassellati"], "venue": "Robotics and Autonomous Systems", "citeRegEx": "Gold and Scassellati,? \\Q2009\\E", "shortCiteRegEx": "Gold and Scassellati", "year": 2009}, {"title": "Orchestrated reduction of quantum coherence in brain microtubules: A model for consciousness", "author": ["S. Hameroff", "R. Penrose"], "venue": "Mathematics and Computers in Simulation,", "citeRegEx": "Hameroff and Penrose,? \\Q1996\\E", "shortCiteRegEx": "Hameroff and Penrose", "year": 1996}, {"title": "Consciousness in the universe. A review of the\u2018Orch OR\u2019theory", "author": ["S. Hameroff", "R. Penrose"], "venue": "Physics of Life", "citeRegEx": "Hameroff and Penrose,? \\Q2014\\E", "shortCiteRegEx": "Hameroff and Penrose", "year": 2014}, {"title": "The Symbol Grounding Problem", "author": ["S. Harnad"], "venue": "Physica D,", "citeRegEx": "Harnad,? \\Q1990\\E", "shortCiteRegEx": "Harnad", "year": 1990}, {"title": "On G\u00f6del\u2019s Theorem and Mechanism: Inconsistency or Unsoundness is Unavoidable in any Attempt to \u2018Out-G\u00f6del\u2019 the Mechanist", "author": ["S. Krajewski"], "venue": "Fundamenta Informaticae", "citeRegEx": "Krajewski,? \\Q2007\\E", "shortCiteRegEx": "Krajewski", "year": 2007}, {"title": "Why Godel's Theorem Cannot Refute Computationalism", "author": ["G. LaForte", "P.J. Hayes", "K.M. Ford"], "venue": "Artificial Intelligence", "citeRegEx": "LaForte et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LaForte et al\\.", "year": 1998}, {"title": "Software agents that learn through observation", "author": ["J. Machado", "L.M. Botelho"], "venue": "In Proceedings of the International Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS", "citeRegEx": "Machado and Botelho,? \\Q2006\\E", "shortCiteRegEx": "Machado and Botelho", "year": 2006}, {"title": "Autonomous Learning of High-Level States and Actions in Continuous Environments", "author": ["J. Mugan", "B. Kuipers"], "venue": "IEEE Transactions on Autonomous Mental Development", "citeRegEx": "Mugan and Kuipers,? \\Q2012\\E", "shortCiteRegEx": "Mugan and Kuipers", "year": 2012}, {"title": "The Symbol Grounding Problem Has Been Solved. So What's Next", "author": ["L. Steels"], "venue": "In M. de Vega (Ed.) Symbols and Embodiment: Debates on Meaning and Cognition", "citeRegEx": "Steels,? \\Q2008\\E", "shortCiteRegEx": "Steels", "year": 2008}, {"title": "Reply to Commentaries", "author": ["E. Thompson"], "venue": "Journal of Consciousness Studies,", "citeRegEx": "Thompson,? \\Q2011\\E", "shortCiteRegEx": "Thompson", "year": 2011}, {"title": "At the source of time: Valence and the constitutional dynamics of affect", "author": ["F.J. Varela", "N. Depraz"], "venue": "Journal of Consciousness Studies,", "citeRegEx": "Varela and Depraz,? \\Q2005\\E", "shortCiteRegEx": "Varela and Depraz", "year": 2005}, {"title": "The physical symbol grounding problem", "author": ["P. Vogt"], "venue": "Cognitive Systems Research,", "citeRegEx": "Vogt,? \\Q2002\\E", "shortCiteRegEx": "Vogt", "year": 2002}, {"title": "Rethinking Grounding", "author": ["T. Ziemke"], "venue": null, "citeRegEx": "Ziemke,? \\Q1999\\E", "shortCiteRegEx": "Ziemke", "year": 1999}], "referenceMentions": [{"referenceID": 12, "context": "Introduction In a debate that came to be better known as the symbol grounding problem (Harnad, 1990), several scientists have expressed their opinions that artificial intelligence would never lead to actual intelligent systems (e.", "startOffset": 86, "endOffset": 100}, {"referenceID": 21, "context": "Introduction In a debate that came to be better known as the symbol grounding problem (Harnad, 1990), several scientists have expressed their opinions that artificial intelligence would never lead to actual intelligent systems (e.g., Searle, 1980; Penrose, 1989; Ziemke, 1999; and, Froese & Ziemke, 2009).", "startOffset": 227, "endOffset": 304}, {"referenceID": 12, "context": "This is a difference regarding other work addressing first-person meanings, for example the work by Harnad (1990), Cangelosi, Greco, and Harnad (2002), Vogt (2002), Machado and Botelho (2006), and Steels (2003, 2008), which focuses on the symbol grounding problem, namely the problem of directly or indirectly grounding each symbol of an artificial system on the object, situation or event referred to by the symbol.", "startOffset": 100, "endOffset": 114}, {"referenceID": 12, "context": "This is a difference regarding other work addressing first-person meanings, for example the work by Harnad (1990), Cangelosi, Greco, and Harnad (2002), Vogt (2002), Machado and Botelho (2006), and Steels (2003, 2008), which focuses on the symbol grounding problem, namely the problem of directly or indirectly grounding each symbol of an artificial system on the object, situation or event referred to by the symbol.", "startOffset": 100, "endOffset": 151}, {"referenceID": 12, "context": "This is a difference regarding other work addressing first-person meanings, for example the work by Harnad (1990), Cangelosi, Greco, and Harnad (2002), Vogt (2002), Machado and Botelho (2006), and Steels (2003, 2008), which focuses on the symbol grounding problem, namely the problem of directly or indirectly grounding each symbol of an artificial system on the object, situation or event referred to by the symbol.", "startOffset": 100, "endOffset": 164}, {"referenceID": 12, "context": "This is a difference regarding other work addressing first-person meanings, for example the work by Harnad (1990), Cangelosi, Greco, and Harnad (2002), Vogt (2002), Machado and Botelho (2006), and Steels (2003, 2008), which focuses on the symbol grounding problem, namely the problem of directly or indirectly grounding each symbol of an artificial system on the object, situation or event referred to by the symbol.", "startOffset": 100, "endOffset": 192}, {"referenceID": 9, "context": "Gold and Scassellati (2009) developed an unsupervised learning algorithm that enables a robot to reliably distinguish its own moving parts from those of others, just by looking at a mirror.", "startOffset": 0, "endOffset": 28}, {"referenceID": 13, "context": "LaForte, Hayes, and Ford (1998), and Krajewski (2007) show that Penrose\u2019s conclusion that the human mind involves non-computable processes is wrong.", "startOffset": 37, "endOffset": 54}, {"referenceID": 7, "context": "Ziemke (1999), Froese and Ziemke (2009), and Sharkey and Ziemke (2001) claim that any externally developed mechanisms aimed at creating meanings for a computer program will always produce arbitrary results for the computer program itself exactly because they are externally created.", "startOffset": 15, "endOffset": 40}, {"referenceID": 7, "context": "Ziemke (1999), Froese and Ziemke (2009), and Sharkey and Ziemke (2001) claim that any externally developed mechanisms aimed at creating meanings for a computer program will always produce arbitrary results for the computer program itself exactly because they are externally created.", "startOffset": 15, "endOffset": 71}, {"referenceID": 7, "context": "Thompson and Stapleton (2009), and Froese and Ziemke (2009) claim that the life of even the simplest organism can be described as a sense-making activity.", "startOffset": 35, "endOffset": 60}, {"referenceID": 7, "context": "However, Froese and Ziemke (2009) believe that it is impossible to have systems with first-person meanings that are not rooted on the lower-level sense-making mechanisms resulting of their metabolism.", "startOffset": 9, "endOffset": 34}, {"referenceID": 15, "context": "Vogt (2002), Steels (2003, 2008), and Machado and Botelho (2006) involve their systems in especially designed social interactions through which they develop, from scratch, a shared lexicon of symbols, each of which is connected to the object (and sometimes the category) they represent.", "startOffset": 38, "endOffset": 65}, {"referenceID": 2, "context": "For Brooks (1991), symbols and symbolic processing are not required for intelligent behavior therefore its robots avoid the symbol grounding problem.", "startOffset": 4, "endOffset": 18}, {"referenceID": 2, "context": "For Brooks (1991), symbols and symbolic processing are not required for intelligent behavior therefore its robots avoid the symbol grounding problem. In our point of view, if the robot is to determine the importance of objects, events, and situations, it must see all it does and all that happens to it in the light of its goals. Besides, as Vogt (2002) argues, several high-level mental activities, as language, require symbols (but see Cuffari, di Paolo, and de Jaegher, 2014 for a contrasting opinion).", "startOffset": 4, "endOffset": 354}, {"referenceID": 16, "context": "Steels (1996) and Birk (1997) developed robots that successfully learn to stay alive in their environment relying only on mechanisms aimed at preserving internal variables within specified values, which may be seen as a form of motivated behavior.", "startOffset": 0, "endOffset": 14}, {"referenceID": 1, "context": "Steels (1996) and Birk (1997) developed robots that successfully learn to stay alive in their environment relying only on mechanisms aimed at preserving internal variables within specified values, which may be seen as a form of motivated behavior.", "startOffset": 18, "endOffset": 30}, {"referenceID": 1, "context": "Steels (1996) and Birk (1997) developed robots that successfully learn to stay alive in their environment relying only on mechanisms aimed at preserving internal variables within specified values, which may be seen as a form of motivated behavior. Savage (2003) discusses a set of processes by which complex motivated behavior can be developed in artificial agents, either by gradual improvement through the agent\u2019s experience or by historical evolution.", "startOffset": 18, "endOffset": 262}, {"referenceID": 7, "context": "As already stated before, Froese and Ziemke (2009), among others, contend that it is impossible to build computer programs with first-person meanings because the computer program would have to create and maintain itself and the whole network of its parts and processes from within.", "startOffset": 26, "endOffset": 51}, {"referenceID": 7, "context": "As already stated before, Froese and Ziemke (2009), among others, contend that it is impossible to build computer programs with first-person meanings because the computer program would have to create and maintain itself and the whole network of its parts and processes from within. As a way to circumvent this problem, Froese and Ziemke (2009) present the quite radical idea that instead of trying to build programs with first-person meanings, scientists should focus on the definition and creation of environments with such dynamics that enable the emergence of computer programs with first-person meanings.", "startOffset": 26, "endOffset": 344}, {"referenceID": 19, "context": "Varela and Depraz (2005), and Colombetti (2014) also recognize the primordial importance of the feeling body to consciousness.", "startOffset": 0, "endOffset": 25}, {"referenceID": 19, "context": "Varela and Depraz (2005), and Colombetti (2014) also recognize the primordial importance of the feeling body to consciousness.", "startOffset": 0, "endOffset": 48}], "year": 2015, "abstractText": null, "creator": "Word"}}}