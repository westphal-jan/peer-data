{"id": "1511.06747", "review": {"conference": "iclr", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Nov-2015", "title": "Data-Dependent Path Normalization in Neural Networks", "abstract": "We propose a unified framework for neural net normalization, regularization and optimization, which includes Path-SGD and Batch-Normalization and interpolates between them across two different dimensions. Through this framework we investigate issue of invariance of the optimization, data dependence and the connection with natural gradients.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Fri, 20 Nov 2015 20:27:45 GMT  (107kb,D)", "http://arxiv.org/abs/1511.06747v1", "12 pages, 3 figures"], ["v2", "Mon, 14 Dec 2015 20:52:51 GMT  (109kb,D)", "http://arxiv.org/abs/1511.06747v2", "14 pages, 3 figures"], ["v3", "Fri, 8 Jan 2016 20:13:03 GMT  (134kb,D)", "http://arxiv.org/abs/1511.06747v3", "17 pages, 3 figures"], ["v4", "Tue, 19 Jan 2016 20:57:47 GMT  (294kb,D)", "http://arxiv.org/abs/1511.06747v4", "17 pages, 3 figures"]], "COMMENTS": "12 pages, 3 figures", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["behnam neyshabur", "ryota tomioka", "ruslan salakhutdinov", "nathan srebro"], "accepted": true, "id": "1511.06747"}, "pdf": {"name": "1511.06747.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Behnam Neyshabur", "Ryota Tomioka"], "emails": ["bneyshabur@ttic.edu", "ryoto@microsoft.com", "rsalakhu@cs.toronto.edu", "nati@ttic.edu"], "sections": [{"heading": "1 INTRODUCTION", "text": "The choice of optimization method for non-convex, over-parametrized models such as feed-forward neural networks is crucial to the success of learning\u2014not only does it affect the runtime until convergence, but it also effects which minimum (or potentially local minimum) we will converge to, and thus the generalization ability of the resulting model. Optimization methods are inherently tied to a choice of geometry over parameter space, which in turns induces a geometry over model space, which plays an important role in regularization and generalization (Neyshabur et al., 2015c).\nIn the past year, two efficient alternative optimization approaches for feed-forward neural networks were proposed, based on intuitions about parametrization, normalization and the geometry of parameter space: Path-SGD (Neyshabur et al., 2015a) was derived as steepest descent algorithm with respect to the `2-path regularizer; The `2-path regularizer is the sum over all paths in the network of the squared product over all weights in the path (Neyshabur et al., 2015b). The `2-path regularizer is equivalent to per-unit `2 regularization (maximum over all units of `2 norm of incoming weights to the unit) but is invariant to weight reparametrization. On the other hand, batch-normalization (Ioffe & Szegedy, 2015) was derived as a way of controlling the variance of the input each unit receives. In this paper, we propose a unified framework which includes both approaches, and allows us to obtain additional methods which interpolate between them. Using our unified framework, we can also tease apart and combine two different aspects of these two approaches: data-dependence and invariance to weight-rebalancing.\nMore specifically, our unified framework is based on a quantity we refer to as \u03b3v (defined in Section 2) that can be calculated for each node v in the network recursively. This measure is parametrized by a choice of \u201cnormalization matrix\u201d R, and different choices for this matrix incorporate different amounts of data dependencies: for path-SGD, R is a non-data-dependent diagonal matrix, while for batch normalization it is a data-dependent covariance matrix, and we can interpolate between the two extremes. Once \u03b3v is defined, and for any choice of R, we define two different optimization approaches: one relying on a normalized re-parameterization at each layer, as in batch normalization (Section 3), and the other an approximate steepest descent as in path-SGD, which we refer to as DDP-SGD (Data Dependent Path SGD) and can be implemented efficiently via forward and backward propagation on the network (Section 4). We can now mix and match between the choice of R and the choice of optimization approach.\nar X\niv :1\n51 1.\n06 74\n7v 1\n[ cs\n.L G\n] 2\n0 N\nov 2\nOne particular advantage of the approximate steepest descent approach (DDP-SGD) over the normalization approach is that it is invariant to weight rebalancing (discussed in Section 5). This is true regardless of the amount of data-dependence used. That is, it operates more directly on the model (the function defined by the weights) rather than the parametrization (the values of the weights themselves). This brings us to a more general discussion of parametrization invariance in feedforward networks (Section 6).\nOur unified framework and study of in invariances also allows us to relate the different optimization approaches to Natural Gradients (Amari, 1998). In particular, we show that DDP-SGD with full data-dependence can be seen as an efficient approximation of the natural gradient using only the diagonal of the Fisher information matrix (as opposed to the full matrix).\nRELATED WORKS\nThere has been an ongoing effort for better understanding of the optimization in deep networks and several heuristics have been suggested to improve the training (Le Cun et al., 1998; Larochelle et al., 2009; Glorot & Bengio, 2010; Sutskever et al., 2013). In order to incorporate the curvature information, several methods have proposed different ways to approximate Fisher information matrix in deep learning models (Desjardins et al., 2015; Martens & Grosse, 2015; Grosse & Salakhudinov, 2015). Pascanu & Bengio (2014) also discusses the connections between Natural Gradients and some of the other proposed methods for training neural networks: Hessian-Free Optimization (Martens, 2010), Krylov Subspace Descent (Vinyals & Povey, 2011) and TONGA (Roux et al., 2008).\nFEEDFORWARD NEURAL NETS\nLet G = (V,E) be a directed acyclic graph with nin input nodes (those with only outgoing connections) and nout output nodes (those with only incoming connection). We associate a weight we for e \u2208 E and define fw : Rnin \u2192 Rnout recursively as follows:\nfw(x)[v] = zv (v \u2208 Vout), (1) yv = \u03c3 (zv) , zv = \u2329 w\u2192v, yN in(v) \u232a = \u2211 u\u2208N in(v) wu\u2192v \u00b7 yu (v /\u2208 Vin),\nyv = x[v] (v \u2208 Vin),\nwhere x[v] denotes the element of vector x corresponding to input unit v, Vin and Vout are the set of input and output nodes, respectively, N in(v) and N out(v) are the set of nodes that are endpoints of incoming edges to v and outgoing edges from v respectively, and \u03c3 is the Rectified Linear Unit (ReLU) activation, i.e. \u03c3(z) = max(0, z). Moreover, we refer to the vector of incoming and outgoing edges to node v by w\u2192v and wv\u2192 respectively. Similarly, yN in(v) and yN out(v) are defined as vectors of values of y for all nodes in N in(v) and N out(v) respectively."}, {"heading": "2 A UNIFIED FRAMEWORK", "text": "We define a measure on each node as follows:\n\u03b32v(w) = w > \u2192vRvw\u2192v (2)\nwhere Rv is a positive semidefinite matrix. We will focus on a specific class of matrices Rv; that is for any 0 \u2264 \u03b1 \u2264 1, we look at:\nRv = \u03b1E [ yN in(v)y > N in(v) ] + (1\u2212 \u03b1) diag ( \u03b32N in(v)(w) ) (3)\nTherefore, for each node v the measure \u03b3 can be calculated as: \u03b32v(w) = \u03b1E [ z2v ] + (1\u2212 \u03b1)w>\u2192v diag ( \u03b32N in(v)(w) ) w\u2192v (v /\u2208 Vin), (4)\nwhere for any v \u2208 Vin, we define \u03b3v = 1. Intuitively, \u03b32v is a convex combination of the variance of the input node v receives and a regularization term that is a weighted norm of incoming weights to\nv. This provides a regularized approximation of the variance for the node v. The interesting point here is that the weight of this weighted norm is nothing but the regularized approximation of the variances of nodes in the previous layer.\nWe can now define the DDP-regularizer of a given network as follows: \u03b32net(w) = \u2211 v\u2208Vout \u03b32v(w) (5)\nSuch a measure induces a complexity measure on functions f that can be presented by network G. The complexity of f based on DDP-regularizer over G can be defined as the complexity of the simplest setting that represent the function:\n\u03b32(f) = inf fG,w=f \u03b32net(w) (6)\nThe DDP-regularizer coincides with the (squared) per-unit `2 norm for \u03b1 = 0 and the per-unit input variance for \u03b1 = 1. Therefore, normalizing each unit based on this measure leads to a generalization of batch normalization and taking the steepest descent direction with respect to this measure leads to a generalization of path-SGD.\nFor simplicity of the notation, we use \u03b32 instead of \u03b32(w) in the rest of the paper."}, {"heading": "3 BATCH-NORMALIZED NETWORKS", "text": "Here we formulate Batch-Normalization based on the measure \u03b3. In the Batch-Normalization formulation, for each node v we normalize the output of the linear layer before the activations which is equivalent to the reparameterization w\u0303\u2192v = 1\u03b3vw\u2192v\n1. Suppose that during the training, we use mini-batches of size n to estimate the second moments. Then the gradients can be calculated as follows:\n\u2202`\n\u2202w\u2192v = n\u2211 i=1 \u2202` \u2202z (i) v y(i)N(v) \u03b3v \u2212 z(i)v \u03b1 n \u2211n i=1 y (i) N in(v) \u2329 y (i) N in(v) , w\u2192v \u232a + (1\u2212 \u03b1)w\u2192v \u03b3v  (7) \u2202`\n\u2202y (i) u\n= \u2211\nv\u2208N(u)\u2192\nwu\u2192v \u03b3v \u2202`\n\u2202z (i) v\n\u2212 \u03b1 n n\u2211 j=1 \u2202` \u2202z (j) v z (i) v z (j) v wu\u2192v \u03b3v  (8) =\n\u2211 v\u2208N(u)\u2192 wu\u2192v \u03b3v  \u2202` \u2202z (i) v \u2212 1 n n\u2211 j=1 \u2202` \u2202z (j) v \u2212 \u03b1z (i) v n n\u2211 j=1 \u2202` \u2202z (j) v z(j)v  Here, \u03b1 = 1 corresponds to the original batch-normalization (Ioffe & Szegedy, 2015); i.e. normalizing the outputs based by the standard deviation, \u03b1 = 0 corresponds to normalizing the output of each hidden unit by `2 norm of the incoming weights to that unit and 0 < \u03b1 < 1 combine this two measure and to obtain a regularized variance.\nInterestingly, we can observe that for any node v the updates direction of incoming weights to v is exactly orthogonal to the weights. i.e. we have that \u2329 w\u2192v,\n\u2202` \u2202w\u2192v\n\u232a = 0. That means weight updates\n1In Batch Normalization as presented in (Ioffe & Szegedy, 2015), the output of node v is calculated as yv = [rz\u0302v+\u03b8]+ where r and \u03b8 are extra scaling and bias parameters and z\u0302v = zv\u2212E[zv ]\u03b3v . While our framework can be easily updated to include these changes, we have removed them for simplicity. Also, note that the for networks with RELU activations, extra scaling parameters in the middle layers are not affecting the expressive power of the network because one can simply propagate the scalings to the top layer.\nin Batch-Normalized networks are done in a way that it prevents the norm of weights to change considerably after each updates."}, {"heading": "4 APPROXIMATE STEEPEST DESCENT OPTIMIZATION", "text": "We now consider the steepest descent direction with respect to DDP regularizer \u03b32. Note that \u03b32net is not convex. However, we can approximate \u03b32net by a convex quadratic function \u03b3\u0302 2 net. For any parameter w, if the diagonal of the hessian H\u03b32net has positive entries, we can approximate \u03b3 2 net by \u03b3\u03022net where hessian H\u03b3\u03022net is the diagonal of H\u03b32net . Now, the Bregman Divergence for \u03b3\u0302 2 net can be written as:\nD\u03b3\u03022net(w,w \u2032) = \u2016w \u2212 w\u2032\u2016H\n\u03b3\u03022net = \u2211 e\u2208E \u22022\u03b32net \u2202w2e (we \u2212 w\u2032e)2 (9)\nTherefore, the steepest descent update with respect to the distance D\u03b3\u03022net can be obtained as follows:\nw(t+1) = min w \u03b7 \u2329 \u2207L(w), w \u2212 w(t) \u232a + 1 2 D\u03b3\u03022net(w,w (t))\nSolving for w gives us the following update rule:\nw(t+1)e = we \u2212 \u03b7\n\u03bae(w)\n\u2202L\n\u2202we (w(t)) (10)\nwhere \u03bae(w) = 12 \u22022\u03b32net \u2202w2e ."}, {"heading": "4.1 IMPLEMENTATION", "text": "In order to compute the second derivatives \u03bae(w) = \u22022\u03b32net \u2202w2e , we first calculate the first derivative. The backpropagation can be done through \u03b32u and z (i) u but this makes it difficult to find the second derivatives. Instead we propagate the loss through \u03b32u and the second order terms of the form z (i) u1 z (i) u2 :\n\u2202\u03b32net \u2202\u03b32u\n= (1\u2212 \u03b1) \u2211\nv\u2208N out(u)\n\u2202\u03b32net \u2202\u03b32v w2u\u2192v (11)\n\u2202\u03b32net\n\u2202(z (i) u1 z (i) u2 )\n= \u03b1 [ \u2202\u03b32net \u2202\u03b32u1 ] u1=u2 +  \u2211 (v1,v2)\u2208(N out(u1))2 \u2202\u03b32net \u2202(z (i) v1 z (i) v2 ) wu1\u2192v1wu2\u2192v2  z (i) u1 >0,z (i) u2 >0\n(12) Now we can calculate the partials for wu\u2192v as follows:\n\u2202\u03b32net \u2202wu\u2192v = 2(1\u2212 \u03b1)\u2202\u03b3 2 net \u2202\u03b32v \u03b32uwu\u2192v + 2 n\u2211 i=1 \u2211 v\u2032\u2208N out(u) \u2202\u03b32net \u2202(z (i) v z (i) v\u2032 ) y(i)u z (i) v\u2032 (13)\nSince the partials \u2202\u03b3 2 net \u2202\u03b32u and \u2202\u03b3 2 net\n\u2202(z (i) u1 z (i) u2\n) do not depend on wu\u2192v , the second order derivative can be\ncalculated directly:\n\u03bau\u2192v(w) = 1\n2 \u22022\u03b32net \u2202w2u\u2192v = (1\u2212 \u03b1)\u2202\u03b3 2 net \u2202\u03b32v \u03b32u + n\u2211 i=1 \u2202\u03b32net \u2202 ( z (i) v 2) (y(i)u )2 (14) The above computation can be done in the time equal to |Vout| backpropagation on the mini-batch (plus only a single backpropagation for \u03b32) as follows:\n\u03bau\u2192v(w) = 1\n2 \u22022\u03b32net \u2202w2u\u2192v = (1\u2212 \u03b1)\u2202\u03b3 2 net \u2202\u03b32v \u03b32u + n\u2211 i=1 ( y(i)u )2 \u2211 v\u2032\u2208Vout\n( \u2202z\n(i) v\u2032 \u2202z (i) v\n)2 (15)\nIt is also sensible to define the path-regularizer as the maximum of \u03b3 over output units (instead of sum):\n\u03b3\u03032net = max v\u2208Vout \u03b32v\nIn that case, the computational complexity boils down to a single extra backpropagation on the mini-batch:\n\u03bau\u2192v(w) = 1\n2 \u22022\u03b3\u03032net \u2202w2u\u2192v = (1\u2212 \u03b1)\u2202\u03b3\u0303 2 net \u2202\u03b32v \u03b32u + n\u2211 i=1 ( y(i)u )2\u2202z(i)vmaxi \u2202z (i) v 2 (16) where vmaxi = arg maxv\u2208Vout\n\u2223\u2223\u03b32v \u2223\u2223"}, {"heading": "4.2 RELATION TO NATURAL GRADIENT", "text": "In this section, we show that DDP-SGD is a diagonal approximation of Natural Gradient. For any network and a probability distribution defined on the outputs, we can approximate the Fisher information matrix with its diagonal elements (see appendix A for more information). In this case the update step normalizes each dimension of the gradient with the corresponding element on the diagonal of Fisher information matrix:\nw(t+1)e = we \u2212 \u03b7\nF (w)[e, e]\n\u2202L\n\u2202we (w(t)). (17)\nFor a multivariate gaussian with unit variance and centralized at the output of the network, namely log q(c|x) = 12 \u2211 v\u2032\u2208Vout(cv\u2032 \u2212 zv\u2032) 2 + const., the diagonal can be calculated as:\nF (w)[u\u2192 v, u\u2192 v] = Ex\u223cp(x) [ y2u \u2211 v\u2032\u2208Vout ( \u2202zv\u2032 \u2202zv )2] , (18)\nusing (34). This is exactly equal to DDP-SGD for \u03b1 = 1. In classification tasks, we usually use softmax activations and it that case, the diagonal of Fisher Information can be calculated as:\nF (w)[u\u2192 v, u\u2192 v] = E [ y2u \u2211 v\u2032\u2208Vout \u2211 v\u2032\u2032\u2208Vout (1v\u2032=v\u2032\u2032 \u00b7 \u03c3soft(zv\u2032)\u2212 \u03c3soft(zv\u2032)\u03c3soft(zv\u2032\u2032)) \u2202zv\u2032 \u2202zv \u00b7 \u2202zv \u2032\u2032 \u2202zv ] (19) where \u03c3soft is the softmax function and we have that \u03c3soft(zv) = e zv\u2211\nv\u2032\u2208Vout ezv\u2032\n. The above values\ncan be calculated as fast as |Vout| backpropagation on the mini-batch. Moreover, considering the connection between DDP-SGD and the diagonal of outer product of Jacobians, we can consider adding the path-regularizer to the diagonal of Fisher information."}, {"heading": "5 NODE-WISE INVARIANCE", "text": "We say that network G is invariant to transformation T : R|E| \u2192 R|E|, if fw = fT (w). We also say that an update rule A : R|E| \u2192 R|E| is invariant to transformation T if and only if fA(w) = fA(T (w)). It is desirable for an update rule to have the same invariances as its inputs (Neyshabur et al., 2015a).\nAn example of invariance in feedforward networks is node-wise rescaling (or rebalancing). For any positive scalar \u03b1 and for any internal node v (v /\u2208 Vin and v /\u2208 Vout), the following transformation w\u0303 = T (w) satisfies fw = fw\u0303:\nw\u0303v\u2192j = \u03b1wv\u2192j (j \u2208 N out(v)), (20) w\u0303k\u2192v = \u03b1 \u22121wk\u2192v (k \u2208 N in(v))"}, {"heading": "5.1 DDP-SGD ON FEEDFORWARD NETWORKS", "text": "Here we show that DDP-SGD is node-wise rescaling invariant. We already observed that feedforward networks are node-wise rescaling invariant. To see if DDP-SGD is also node-wise rescaling invariant, we calculate the update rule for w\u0303v\u2192j in equation (20):\nw\u0303+v\u2192j = \u03b1wv\u2192j \u2212 \u03b12\u03b7\n\u03bav\u2192j(w)\n\u2202L\n\u03b1\u2202wv\u2192j (wv\u2192j)\n= \u03b1 ( w \u2212 \u03b7\n\u03bav\u2192j(w)\n\u2202L\n\u2202wv\u2192j (wv\u2192j)\n) = \u03b1w+v\u2192j\nTherefore, DDP-SGD is node-wise rescaling invariant."}, {"heading": "5.2 SGD ON BATCH NORMALIZED NETWORKS", "text": "The SGD update rule on Batch Normalized networks is not invariant to the network invariances. Batch-Normalized networks are not node-wise rescaling invariant. Instead, they are invariant to rescaling the incoming weights of nodes. To check the invariance of SGD, we consider the following transformation for a scalar \u03b1 > 0:\nw\u0303k\u2192v = \u03b1wk\u2192v (k \u2208 N in(v))\nThe Batch-Normalized network is invariant to the above transformation because the output of each node is normalized. The SGD update rule is however not invariant to this transformation:\nw\u0303+k\u2192v = \u03b1wk\u2192v \u2212 \u03b7 \u2202L\n\u03b1\u2202wk\u2192v (wk\u2192v) 6= \u03b1 ( wk\u2192v \u2212 \u03b7 \u2202L\n\u2202wk\u2192v (wk\u2192v)\n) = \u03b1w+k\u2192v"}, {"heading": "6 UNDERSTANDING INVARIANCES", "text": "The neural network model fw(x) can alternatively be expressed as the sum over all directed paths from every input node to each output node as follows:\nfw(x)[v] = \u2211\np\u2208\u03a0(v)\ngp(x) \u00b7 \u03c0p(w) \u00b7 x[head(p)], (21)\nwhere \u03a0(v) is the set of all directed path from any input node to v, head(p) is the first node of path p, gp(x) takes 1 if all the rectified linear units along path p is active and zero otherwise, and\n\u03c0p(w) = \u220f\ne\u2208E(p)\nw(e) (22)\nis the product of the weights along path p; E(p) denotes the set of edges that appear along path p."}, {"heading": "6.1 CONTINUOUSLY DEFORMABLE TRANSFORMATIONS", "text": "We say that network G is invariant to transformation T : R|E| \u2192 R|E|, if fw = fT (w). Another example of transformation T such that fw = fT (w) is switching two units. Suppose two units u, v \u2208 V share the same set of children and parents. This is typically the case for internal nodes of fully-connected layered network. Then we can define w\u0303 = T (w) so that\nw\u0303u\u2192j = wv\u2192j , w\u0303v\u2192j = wu\u2192j (j \u2208 N out(u)), w\u0303k\u2192u = wk\u2192v, w\u0303k\u2192v = wk\u2192u (k \u2208 N in(u)).\nThis transformation is smooth (it is actually linear) but not continuously deformable in the sense that the two parameter vectors w and T (w) can be arbitrarily far away in the parameter space. Invariances that are not continuously deformable induce isolated sets of points that correspond to the same input-output mapping in the parameter space. We will leave the characterization of non-deformable invariances as future work as they will not affect the behavior of gradient based optimization algorithms at least locally.\nIn contrast to the node-switching invariance, the node-wise rescaling (20) is continuously deformable (take \u03b1 = 1). More precisely, a transformation T is continuously deformable if there is a continuous family of transformations Tt (0 \u2264 t \u2264 1) such that\nT0(w) = w, T1(w) = T (w).\nThis notion of invariance allows us to talk about the subspace spanned by the infinitesimal changes in the parameters to which the model is invariant at a point w, namely\nN(w) = {\u03b4 \u2208 R|E| : fw+\u03b4 = fw +O(\u2016\u03b4\u20162)}. (23) In fact, by Taylor expansion\nfw+\u03b4 = fw + (\u2207wfw)\u03b4 +O(\u2016\u03b4\u20162), so N(w) is the null space of the Jacobian \u2207wfw of fw at w, and thus a linear space. Note that although it is possible to find many more direction than the dimension of N(w) at any given input point x that fw+\u03b4(x) = fw(x) + O(\u2016\u03b4\u20162), we are interested in characterizing the set of directions that the model is invariant to regardless of the input x as we define in (23)."}, {"heading": "6.2 THE FISHER INFORMATION AND NATURAL GRADIENT", "text": "One approach for addressing the issue of invariance for neural network training is the natural gradient algorithm (Amari, 1998).\nUsing the path-based definition of the network model (21), we have\n\u2202 log q(c|x) \u2202we = \u2211 v\u2208Vout \u2202 log q(c|x) \u2202yv \u2202yv \u2202we\n= \u2211 v\u2208Vout \u2211 p\u2208\u03a0(v) \u2202\u03c0p(w) \u2202we \u00b7 \u2202 log q(c|x) \u2202yv \u00b7 gp(x) \u00b7 x[head(p)].\nThus the Fisher information matrix (33) can be rewritten as F (w)[e, e\u2032] = \u2211 p\u2208\u03a0 \u2211 p\u2032\u2208\u03a0 \u2202\u03c0p(w) \u2202we \u2202\u03c0p\u2032(w) \u2202we\u2032 C[p, p\u2032]\nwhere \u03a0 = \u222av\u2208Vout\u03a0(v) is the set of all the paths , and the (uncentered) path covariance matrix C is defined as follows:\nC[p, p\u2032] = Ex\u223cp(x)Ec\u223cq(c|x) [ \u2202 log q(c|x) \u2202ytail(p) \u2202 log q(c|x) \u2202ytail(p\u2032) \u00b7 gp(x)gp\u2032(x) \u00b7 x[head(p)]x[head(p\u2032)] ] .\n(24)\nHOW NATURAL GRADIENT RELATES TO INVARIANCE\nConsider a simple fully-connected two layer network with one output node, two hidden units, and two input units (see Figure 2(a)). There are four paths and the path Jacobian matrix J = (\u2202\u03c0p(w)/\u2202we) can be written as follows:\nJ =  w5 0 0 0 0 w5 0 0 0 0 w6 0 0 0 0 w6 w1 w2 0 0 0 0 w3 w4 \nWe consider two cases, in the first case, the hidden units have the rectified linear activation function and the path covariance matrix can be written as\nC = Ex\u223cp(x)Ec\u223cq(c|x) [( \u2202 log q(c|x) \u2202yout )2 \u00b7 ( g21(x) g1(x)g2(x) g1(x)g2(x) g 2 2(x) ) \u2297 ( (x[1])2 x[1]x[2] x[1]x[2] (x[2])2 )] ,\n(25) where \u2297 denotes the Kronecker product. Note that the first two paths and the last two paths each share the same hidden unit. Therefore the path covariance matrix (before expectation) can be written as the Kronecker product of the (uncentered) covariance of the activations of the two hidden units and the (uncentered) covariance of the input x.\nGenerally speaking the rank of the Kronecker product of two matrices is the product of their ranks. Typically the rank of the path covariance matrix (25) is 4 if the input covariance matrix is not degenerate and the connections to the two hidden units are not identical, although we cannot take the expectation of the two matrices independently. Since all the columns of the path Jacobian matrix are linearly independent, the rank of the Fisher information matrix for this network with the rectified linear activation is 4.\nIn the second case, the hidden units have the linear activation function \u03c3j(z) = z. Therefore gj(x) = 1 regardless of the input x.Thus the path covariance matrix simplifies to\nC = Ex\u223cp(x)Ec\u223cq(c|x) [( \u2202 log q(c|x) \u2202yout )2 \u00b7 ( 1 1 1 1 ) \u2297 ( (x[1])2 x[1]x[2] x[1]x[2] (x[2])2 )] , (26)\nNow even if the input covariance matrix has full rank, the rank of the path covariance matrix (26) and the Fisher information matrix cannot be larger than 2. This is expected, because if the hidden units are linear, the network is equivalent to a network with one output unit directly connected to the two input units.\nAs we have seen in the above example, the rank of the Fisher information captures the degrees of freedom of the model (which equals the number of parameters minus the number of invariances) in a parameterization independent but source distribution dependent manner. It is sensitive to both the invariance induced by the network structure (captured in the path Jacobian matrix J) and the correlation of the paths (captured in the path covariance matrix C)."}, {"heading": "6.3 THE JACOBIAN", "text": "In order to remove the source distribution dependence of the Fisher information, let us study the structure of the Jacobian\u2207wfw in more detail. From (21), we have\n\u2207wfw(x)[v] = \u2211\np\u2208\u03a0(v)\n\u2207w\u03c0p(w) \u00b7 gp(x) \u00b7 x[head(p)] (27)\n= Jv\u03c6v(x), (28) where Jv = (\u2207w\u03c0p(w))p\u2208\u03a0(v) is the path Jacobian corresponding to output node v and has the dimension of the number of parameters |E| times the number of paths |\u03a0(v)|, and \u03c6v(x) is a |\u03a0(v)| dimensional vector with gp(x)x[i] in the corresponding entry. Note that although path activation gp(x) is a function of w, it is insensitive to an infinitesimal change in the parameter, unless the input to one of the rectified linear activation functions along path p is at exactly zero, which happens with probability zero. Thus we treat gp(x) as constant here.\nIn order to study how many invariances there are, we can look at the rank of Jacobian \u2207wf(w), because the subspace of locally invariant directions N(w) is exactly the null space of\u2207wf(w). We define the rank of the Jacobian \u2207wfw as the dimension of the space spanned by vectors of the form \u2207wfw(x)[v] for all output node v and all input x. The above definition allows us to sidestep the source distribution dependence of Fisher information matrix. Nevertheless the rank of the Jacobian defined above is equal to the rank of the Fisher information if the support of the source distribution is unbounded.\nNow we reduce the rank of the Jacobian \u2207wfw to the rank of the path Jacobian matrix J , which is purely a combinatorial quantity as we see in the next two theorems.\nTheorem 1. The rank of the Jacobian is at most the rank of the path Jacobian matrix J = (Jv)v\u2208Vout , i.e., the column-wise concatenation of Jv for all v \u2208 Vout. The equality holds if the dimension of the space spanned by \u03c6(x) = (\u03c6>1 (x), . . . , \u03c6 > |Vout(x))\n>, i.e. the row-wise concatenation of \u03c6v(x), equals the total number of paths \u2211 v |\u03a0(v)|.\nProof. The first part is true because any vector of the form \u2207wfw(x)[v] defined in (27) lies in the span of Jv . The second part is trivially true.\nTheorem 2. The rank of the path Jacobian matrix J is equal to the number of parameters |E| minus the number of internal nodes of the network.\nNote that the dimension of the space spanned by node-wise rescaling (20) equals the number of internal nodes. Therefore, node-wise rescaling is the only type of continuously deformable invariance for ReLU networks that holds in a distribution independent sense.\nLet us consider a simple 3 layer network with 2 nodes in each layer except for the output layer, which has only 1 node (see Figure 2(b)). The number of parameters is 10 (4, 4, and 2 in each layer respectively) and 8 paths. The Jacobian\u2207wfw(x) can be written as\u2207wfw(x) = J\u03c6(x), where:\nJ =  w5w9 w5w9 w6w9 w6w9 w9w1 w9w2 w9w3 w9w4\nw5w1 w5w2 w6w3 w6w4\nw7w10 w7w10\nw8w10 w8w10\nw10w1 w10w2 w10w3 w10w4\nw7w1 w7w2 w8w3 w8w4\n (29)\nand\n\u03c6(x)> = [g1(x)x[1] g2(x)x[2] g3(x)x[1] g4(x)x[2] g5(x)x[1] g6(x)x[2] g7(x)x[1] g8(x)x[2]] .\nThe rank of J in (29) is equal to 6, which is smaller than both the number of parameters and the number of paths.\nCONCLUSION AND FUTURE WORK\nWe proposed a unified framework as a complexity measure or regularizer for neural networks and discussed normalization and optimization with respect to this regularizer. We further showed how this measure interpolates between data-dependent and data-independent regularizers and discussed how Path-SGD and Batch-Normalization are special cases of optimization with respect to this measure. We also looked at the issue of invariances and brought new insights to this area. Empirical evaluation of different settings in the suggested unified framework is the subject of future work."}, {"heading": "A NATURAL GRADIENT", "text": "The natural gradient algorithm achieves invariance to local reparameterization by applying the inverse of the Fisher information matrix F (w(t)) at the current parameter w(t) to the negative gradient direction as follows:\nw(t+1) = w(t) + \u03b7\u2206(natural),\nwhere\n\u2206(natural) = argmin \u2206\u2208R|E| \u2329 \u2212\u2202L \u2202w (w(t)),\u2206 \u232a , s.t. \u2206>F (w(t))\u2206 \u2264 \u03b42 (30)\n= \u2212F\u22121(w(t))\u2202L \u2202w (w(t)). (31)\nHere F (w) is the Fisher information matrix at pointw and is defined with respect to the probabilistic view of the neural network model (1), which we describe in more detail below.\nSuppose that we are solving a classification problem and the final layer of the network is fed into a softmax layer that determines the probability of candidate classes given the input x. Then the neural network with the softmax layer can be viewed as a conditional probability distribution\nq(c|x) = exp(fw(x)[vc])\u2211 v\u2208v\u2208Vout exp(fw(x)[v]) , (32)\nwhere vc is the output node corresponding to the candidate class c. If we are solving a regression problem a Gaussian distribution is probably more appropriate for q(c|x). Given the conditional probability distribution q(c|x), the Fisher information matrix can be defined as follows:\nF (w)[e, e\u2032] = Ex\u223cp(x)Ec\u223cq(c|x) [ \u2202 log q(c|x)\n\u2202we\n\u2202 log q(c|x) \u2202we\u2032\n] , (33)\nwhere p(x) is the marginal distribution of the data.\nSince we have \u2202 log q(c|x) \u2202wu\u2192v = \u2202 log q(c|x) \u2202zv \u00b7 yu = \u2211 v\u2032\u2208Vout \u2202 log q(c|x) \u2202zv\u2032 \u00b7 \u2202zv \u2032 \u2202zv \u00b7 yu (34)\nusing the chain rule, each entry of the Fisher information matrix can be computed efficiently by forward and backward propagations on a minibatch."}, {"heading": "B PROOF OF THEOREM 2", "text": "Proof. First, J can be written as an Hadamard product between path incidence matrix M and a rank-one matrix as follows:\nJ = M \u25e6 ( w\u22121\u03c0>(w) ) ,\nwhere M is the path incidence matrix whose i, j entry is one if the ith edge is part of the jth path, w\u22121 is an entry-wise inverse of the parameter vector w, \u03c0(w) = (\u03c0p(w)) is a vector containing the product along each path in each entry, and > denotes transpose. Since we can rewrite\nJ = diag(w\u22121) \u00b7M \u00b7 diag(\u03c0(w)),\nwe see that (generically) the rank of J is equal to the rank of zero-one matrix M .\nNote that the rank of M is equal to the number of linearly independent columns of M , in other words, the number of linearly independent paths. In general, most paths are not independent. For example, in Figure 2(b), we can see that the path w2w7w10 can be produced by combining 3 paths w1w5w9, w1w7w10, and w2w5w9.\nIn order to count the number of independent paths, we use mathematical induction. For simplicity, consider a layered graph with d layers. All the edges from the (d \u2212 1)th layer nodes to the output layer nodes are linearly independent, because they correspond to different parameters. So far we have ndnd\u22121 independent paths.\nNext, take one node u0 (e.g., the leftmost node) from the layer below. All the paths starting from this node through the layers above are linearly independent. However, other nodes in this layer only contributes linearly to the number of independent paths. This is the case because we can take an edge (u, v), where u is one of the remaining nd\u22122 \u2212 1 vertices in the (d\u2212 2)th layer and v is one of the nd\u22121 nodes in the (d\u2212 1)th layer, and we can take any path (say p0) from there to the top layer. Then this is the only independent path that uses the edge (u, v), because any other combination of edge (u, v) and path p from v to the top layer can be produced as follows (see Figure 3):\n(u, v)\u2192 p = (u, v)\u2192 p0 \u2212 (u0, v)\u2192 p0 + (u0, v)\u2192 p.\nTherefore after considering all nodes in the d\u2212 2th layer, we have\nndnd\u22121 + nd\u22121(nd\u22122 \u2212 1)\nindependent paths. Doing this calculation inductively, we have\nndnd\u22121 + nd\u22121(nd\u22122 \u2212 1) + \u00b7 \u00b7 \u00b7+ n1(n0 \u2212 1)\nindependent paths, where n0 is the number of input units. This number is clearly equal to the number of parameters (ndnd\u22121 + \u00b7 \u00b7 \u00b7+ n1n0) minus the number of internal nodes (nd\u22121 + \u00b7 \u00b7 \u00b7+ n1)."}], "references": [{"title": "Natural gradient works efficiently in learning", "author": ["Amari", "Shun-Ichi"], "venue": "Neural computation,", "citeRegEx": "Amari and Shun.Ichi.,? \\Q1998\\E", "shortCiteRegEx": "Amari and Shun.Ichi.", "year": 1998}, {"title": "Understanding the difficulty of training deep feedforward neural networks", "author": ["Glorot", "Xavier", "Bengio", "Yoshua"], "venue": "In AISTATS,", "citeRegEx": "Glorot et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Glorot et al\\.", "year": 2010}, {"title": "Scaling up natural gradient by sparsely factorizing the inverse Fisher matrix", "author": ["Grosse", "Roger", "Salakhudinov", "Ruslan"], "venue": "In ICML,", "citeRegEx": "Grosse et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Grosse et al\\.", "year": 2015}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["Ioffe", "Sergey", "Szegedy", "Christian"], "venue": "In ICML,", "citeRegEx": "Ioffe et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ioffe et al\\.", "year": 2015}, {"title": "Exploring strategies for training deep neural networks", "author": ["Larochelle", "Hugo", "Bengio", "Yoshua", "Louradour", "J\u00e9r\u00f4me", "Lamblin", "Pascal"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Larochelle et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Larochelle et al\\.", "year": 2009}, {"title": "Springer Verlag, 1998", "author": ["Le Cun", "Yann", "Bottou", "L\u00e9on", "Orr", "Genevieve B.", "M\u00fcller", "Klaus-Robert. Efficient backprop. In Neural Networks", "Tricks of the Trade", "Lecture Notes in Computer Science LNCS"], "venue": "URL http://leon.bottou.org/papers/lecun-98x.", "citeRegEx": "Cun et al\\.,? 1524", "shortCiteRegEx": "Cun et al\\.", "year": 1524}, {"title": "Deep learning via hessian-free optimization", "author": ["Martens", "James"], "venue": "In ICML,", "citeRegEx": "Martens and James.,? \\Q2010\\E", "shortCiteRegEx": "Martens and James.", "year": 2010}, {"title": "Optimizing neural networks with Kronecker-factored approximate curvature", "author": ["Martens", "James", "Grosse", "Roger"], "venue": "In ICML,", "citeRegEx": "Martens et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Martens et al\\.", "year": 2015}, {"title": "Path-SGD: Path-normalized optimization in deep neural networks", "author": ["Neyshabur", "Behnam", "Salakhutdinov", "Ruslan", "Srebro", "Nathan"], "venue": "In NIPS,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "Norm-based capacity control in neural networks", "author": ["Neyshabur", "Behnam", "Tomioka", "Ryota", "Srebro", "Nathan"], "venue": "In COLT,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "In search of the real inductive bias: On the role of implicit regularization in deep learning", "author": ["Neyshabur", "Behnam", "Tomioka", "Ryota", "Srebro", "Nathan"], "venue": "International Conference on Learning Representations (ICLR) workshop track,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "Revisiting natural gradient for deep networks", "author": ["Pascanu", "Razvan", "Bengio", "Yoshua"], "venue": "In ICLR,", "citeRegEx": "Pascanu et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pascanu et al\\.", "year": 2014}, {"title": "Topmoumoute online natural gradient algorithm", "author": ["Roux", "Nicolas L", "Manzagol", "Pierre-Antoine", "Bengio", "Yoshua"], "venue": "In NIPS,", "citeRegEx": "Roux et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Roux et al\\.", "year": 2008}, {"title": "On the importance of initialization and momentum in deep learning", "author": ["Sutskever", "Ilya", "Martens", "James", "Dahl", "George", "Hinton", "Geoffrey"], "venue": "In ICML,", "citeRegEx": "Sutskever et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2013}, {"title": "Krylov subspace descent for deep learning", "author": ["Vinyals", "Oriol", "Povey", "Daniel"], "venue": "In ICML,", "citeRegEx": "Vinyals et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Vinyals et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 4, "context": "RELATED WORKS There has been an ongoing effort for better understanding of the optimization in deep networks and several heuristics have been suggested to improve the training (Le Cun et al., 1998; Larochelle et al., 2009; Glorot & Bengio, 2010; Sutskever et al., 2013).", "startOffset": 176, "endOffset": 269}, {"referenceID": 13, "context": "RELATED WORKS There has been an ongoing effort for better understanding of the optimization in deep networks and several heuristics have been suggested to improve the training (Le Cun et al., 1998; Larochelle et al., 2009; Glorot & Bengio, 2010; Sutskever et al., 2013).", "startOffset": 176, "endOffset": 269}, {"referenceID": 12, "context": "Pascanu & Bengio (2014) also discusses the connections between Natural Gradients and some of the other proposed methods for training neural networks: Hessian-Free Optimization (Martens, 2010), Krylov Subspace Descent (Vinyals & Povey, 2011) and TONGA (Roux et al., 2008).", "startOffset": 251, "endOffset": 270}, {"referenceID": 4, "context": ", 1998; Larochelle et al., 2009; Glorot & Bengio, 2010; Sutskever et al., 2013). In order to incorporate the curvature information, several methods have proposed different ways to approximate Fisher information matrix in deep learning models (Desjardins et al., 2015; Martens & Grosse, 2015; Grosse & Salakhudinov, 2015). Pascanu & Bengio (2014) also discusses the connections between Natural Gradients and some of the other proposed methods for training neural networks: Hessian-Free Optimization (Martens, 2010), Krylov Subspace Descent (Vinyals & Povey, 2011) and TONGA (Roux et al.", "startOffset": 8, "endOffset": 346}], "year": 2017, "abstractText": "We propose a unified framework for neural net normalization, regularization and optimization, which includes Path-SGD and Batch-Normalization and interpolates between them across two different dimensions. Through this framework we investigate issue of invariance of the optimization, data dependence and the connection with natural gradients.", "creator": "LaTeX with hyperref package"}}}