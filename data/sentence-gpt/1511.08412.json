{"id": "1511.08412", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Nov-2015", "title": "Beyond OWL 2 QL in OBDA: Rewritings and Approximations (Extended Version)", "abstract": "Ontology-based data access (OBDA) is a novel paradigm facilitating access to relational data, realized by linking data sources to an ontology by means of declarative mappings. DL-Lite_R, the current language of choice for OBDA, has been designed with the goal of delegating query answering to the underlying database engine, and thus is restricted in expressive power. ERI, a framework for data collection and query management, has provided powerful tools for data collection and query management.\n\n\n\nThe following text and code are extracted from the database.\n\nData:\n\"I have found that the structure of a dataset that we have used for a single operation is not as symmetric or more compact as the original one (the one that we did not have to do it). Therefore, it does not necessarily include the same pattern that we have previously had.\nI am concerned that in order to describe the structure of a dataset, we need to provide the underlying type (e.g., to the database) as the structure of a dataset as opposed to the one and the same set of data types. Furthermore, because of the similarity of the two properties of the data type, we should not have any difficulties defining data types.\nData Types:\n\"We know that we should specify the type in relation to the object (the data type) to which data should be contained by the object.\n\"We should also create a schema for which the structure will be derived.\n\"We must also define the type of the data type for which data should be contained.\n\"We should define the data type for which data will be stored.\n\"It is the order of the data type for which data should be stored, which is the order of the data type.\n\"The order of the data type is of the data type for which data will be stored.\n\"It is the order of the data type for which data will be stored.\n\"We must specify the type of the data type for which data will be stored.\n\"This is the order of the data type for which data should be stored.\n\"A schema for which data will be stored.\n\"This is the order of the data type for which data will be stored.\n\"This is the order of the data type for which data will be stored.\n\"The order of the data type for which data will be stored.\n\"The order of the data type for which data will be stored.", "histories": [["v1", "Thu, 26 Nov 2015 15:12:20 GMT  (54kb)", "http://arxiv.org/abs/1511.08412v1", "The extended version of the AAAI 2016 paper \"Beyond OWL 2 QL in OBDA: Rewritings and Approximations\" by Elena Botoeva, Diego Calvanese, Valerio Santarelli, Domenico Fabio Savo, Alessandro Solimando,and Guohui Xiao"], ["v2", "Tue, 1 Dec 2015 18:26:09 GMT  (51kb)", "http://arxiv.org/abs/1511.08412v2", "The extended version of the AAAI 2016 paper \"Beyond OWL 2 QL in OBDA: Rewritings and Approximations\" by Elena Botoeva, Diego Calvanese, Valerio Santarelli, Domenico Fabio Savo, Alessandro Solimando,and Guohui Xiao"]], "COMMENTS": "The extended version of the AAAI 2016 paper \"Beyond OWL 2 QL in OBDA: Rewritings and Approximations\" by Elena Botoeva, Diego Calvanese, Valerio Santarelli, Domenico Fabio Savo, Alessandro Solimando,and Guohui Xiao", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["elena botoeva", "diego calvanese", "valerio santarelli", "domenico fabio savo", "alessandro solimando", "guohui xiao"], "accepted": false, "id": "1511.08412"}, "pdf": {"name": "1511.08412.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["lastname@inf.unibz.it", "lastname@dis.uniroma1.it", "alessandro.solimando@unige.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n51 1.\n08 41\n2v 1\n[ cs\n.A I]\n2 6\nN ov\n2 01"}, {"heading": "1 Introduction", "text": "Ontology-Based Data Access (OBDA) is a popular paradigm that enables end users to access data sources through an ontology, abstracting away low level details of the data sources themselves. The ontology provides a high-level description of the domain of interest, and is semantically linked to the data sources by means of a set of mapping assertions (Calvanese et al. 2009; Giese et al. 2015). Typically, the data sources are represented as relational data, the ontology is constituted by a set of logical axioms over concepts and roles, and each mapping assertion relates an SQL query over the database to a concept or role of the ontology.\nAs an example, consider a bank domain, where we can specify that a checking account in the name of a person is a simple account by means of the axiom (expressed in description logic notation) CAcc \u2293 \u2203inNameOf.Person \u2291 SAcc. We assume that the information about the accounts and their\nCopyright \u00a9 2015, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nowners is stored in a database D, and that the ontology terms CAcc, inNameOf, and Person are connected to D respectively via the mapping assertions sql1(x) CAcc(x), sql2(x, y) inNameOf(x, y) and sql3(x) Person(x), where each sql i is a (possibly very complex) SQL query over D. Suppose now that the user intends to extract all simple accounts from D. Formulating such a query directly over D would require to know precisely how D is structured, and thus could be complicated. Instead, exploiting OBDA, the user can simply query the ontology with q(x) = SAcc(x), and rely on the OBDA system to get the answers.\nMaking OBDA work efficiently over large amounts of data, requires that query answering over the ontology is first-order (FO)-rewritable1 (Calvanese et al. 2007; Artale et al. 2009), which in turn limits the expressiveness of the ontology language, and the degree of detail with which the domain of interest can be captured. The current language of choice for OBDA is DL-LiteR, the logic underlying OWL 2 QL (Motik et al. 2009), which has been specifically designed to ensure FO-rewritability of query answering. Hence, it does not allow one to express disjunctive information, and any form of recursion on the data (e.g., as resulting from qualified existentials on the left-hand side of concept inclusions), since using such constructs in general causes the loss of FO-rewritability (Calvanese et al. 2013). For this reason, in many situations the expressive power of DLLiteR is too restricted to capture real-world scenarios; e.g., the axiom in our example is not expressible in DL-LiteR.\nThe aim of this work is to overcome these limitations of DL-LiteR by allowing the use of additional constructs in the ontology. To be able to exploit the added value coming from OBDA in real-world settings, an important requirement is the efficiency of query answering, achieved through a rewriting-based approach. This is only possible for ontology languages that are FOrewritable. Two general mechanisms that have been proposed to cope with computational complexity coming from high expressiveness of ontology languages, and that allow one to regain FO-rewritability, are conservative rewriting (Lutz, Piro, and Wolter 2011) and approximation (Ren, Pan, and Zhao 2010; Console et al. 2014). Given an ontology in a powerful language, in the former approach it\n1Recall that FO queries constitute the core of SQL.\nis rewritten, when possible, into an equivalent one in a restricted language, while in the latter it is approximated, thus losing part of its semantics.\nIn this work, we significantly extend the practical impact of both approaches by bringing into the picture the mapping, an essential component of OBDA that has been ignored so far. Indeed, it is a fairly expressive component of an OBDA system, since it allows one to make use of arbitrary SQL (hence FO) queries to relate the content of the data source to the elements of the ontology. Hence, a natural question is how one can use the mapping component to capture as much as possible additional domain semantics, resulting in better approximations or more cases where conservative rewritings are possible, while maintaining a DL-LiteR ontology.\nWe illustrate how this can be done on our running example, where the non-DL-LiteR axiom can be encoded by adding the assertion sql1(x) \u22b2\u22b3 sql2(x, y) \u22b2\u22b3 sql3(y) SAcc(x) to the mapping. This assertion connects D directly to the ontology term SAcc by making use of a join of the SQL queries in the original mapping. We observe that the resulting mapping, together with the ontology in which the non-DL-LiteR axiom has been removed, constitutes a conservative rewriting of the original OBDA specification.\nIn this paper, we elaborate on this idea, by introducing a novel framework for rewriting and approximation of OBDA specifications. Specifically, we provide a notion of rewriting based on query inseparability of OBDA specifications (Bienvenu and Rosati 2015). To deal with those cases where it is not possible to rewrite the OBDA specification into a query inseparable one whose ontology is in DL-LiteR, we give a notion of approximation that is sound for query answering. We develop techniques for rewriting and approximation of OBDA specifications based on compiling the extra expressiveness into the mappings. We target rather expressive ontology languages, and for Horn-ALCHIQ, a Horn fragment of OWL 2, we study decidability of existence of OBDA rewritings, and techniques to compute them when they exist, and to approximate them, otherwise.\nWe have implemented our techniques in a prototype system called Ontoprox, which exploits functionalities provided by the Ontop (Rodriguez-Muro, Kontchakov, and Zakharyaschev 2013) and Clipper systems (Eiter et al. 2012) to rewrite or approximate an OBDA specification expressed in Horn-SHIQ to one that can be directly processed by any OBDA system. We have evaluated Ontoprox over synthetic and real OBDA instances against (i) the default Ontop behavior, (ii) local semantic approximation (LSA), (iii) global semantic approximation (GSA), and (iv) Clipper over materialized ABoxes. We observe that using Ontoprox, for a few queries we have been able to obtain more answers (in fact, complete answers, as confirmed by Clipper). However, for most of the queries Ontoprox showed no difference with respect to the default Ontop behavior. One reason for this is that in the real-world scenarios, the mapping designers put significant effort to manually create complex mappings that overcome the limitations of DL-LiteR. Essentially they follow the principle of the technique presented here, and therefore the resulting OBDA specifications are already \u201ccomplete\u201d by\ndesign. The observations above immediately imply a significant practical value of our approach, which can be used to facilitate the design of new OBDA specifications for existing expressive ontologies: instead of a manual compilation, which is cumbersome, error-prone, and difficult to maintain, mapping designers can write straightforward mappings, and the resulting OBDA specification can then be automatically transformed into a DL-LiteR specification with rich mappings.\nThe paper is structured as follows. In Section 2, we provide some preliminary notions, and in Section 3, we present our framework of OBDA rewriting and approximation. In Section 4, we illustrate a technique for computing the OBDA-rewriting of a given Horn-ALCHIQ specification. In Section 5, we address the problem of OBDArewritability, and show how to obtain an approximation when a rewriting does not exist. In Section 6, we discuss our prototype Ontoprox and experiments. Finally, in Section 7, we conclude the paper.\nThe omitted proofs can be found in the appendix."}, {"heading": "2 Preliminaries", "text": "We give some basic notions about ontologies and OBDA."}, {"heading": "2.1 Ontologies", "text": "We introduce some preliminary notions on ontologies. We assume to have the following pairwise disjoint countably infinite alphabets: NC of concept names, NR of role names, and NI of constants (also called individuals).\nWe consider ontologies expressed in Description Logics (DLs). Here we present the logics Horn-ALCHIQ, the Horn fragment of SHIQ without role transitivity, and DLLiteR, for which we develop some of the technical results in the paper. However, the general approximation framework is applicable to any fragment of OWL 2.\nA Horn-ALCHIQ TBox in normal form is a finite set of axioms: concept inclusions (CIs) d i Ai \u2291 C, role inclusions (RIs) R1 \u2291 R2 and role disjointness axioms R1 \u2293 R2 \u2291 \u22a5, where A, Ai denote concept names, R, R1, R2 denote role names P or their inverses P\u2212, and C denotes a concept of the form \u22a5, A, \u2203R.A, \u2200R.A, or \u22641R.A (Kazakov 2009). For an inverse role R = P\u2212, we use R\u2212 to denote P . \u22a5 denotes the empty concept/role. A DL-LiteR TBox is a finite set of axioms of the formB1 \u2291 B2, B1\u2293B2 \u2291 \u22a5, R1 \u2291 R2, andR1\u2293R2 \u2291 \u22a5, whereBi denotes a concept of the form A or \u2203R.\u22a4. In what follows, for simplicity we write \u2203R instead of \u2203R.\u22a4, and we use N to denote either a concept or a role name. We also assume that all TBoxes are in normal form.\nAn ABox is a finite set of membership assertions of the form A(c) or P (c, c\u2032), where c, c\u2032 \u2208 NI. For a DL L, an L-ontology is a pair O = \u3008T ,A\u3009, where T is an L-TBox and A is an ABox. A signature \u03a3 is a finite set of concept and role names. An ontology O is said to be defined over (or simply, over) \u03a3 if all the concept and role names occurring in it belong to \u03a3 (and likewise for TBoxes, ABoxes, concept inclusions, etc.). When T is over \u03a3, we denote by sig(T ) the subset of \u03a3 actually occurring in T . Moreover we denote with Ind(A), the set of individuals appearing in A.\nThe semantics, models, and the notions of satisfaction and consistency of ontologies are defined in the standard way. We only point out that we adopt the Unique Name Assumption (UNA), and for simplicity we also assume to have standard names, i.e., for every interpretation I and every constant c \u2208 NI interpreted by I, we have that cI = c."}, {"heading": "2.2 OBDA and Mappings", "text": "Let S be a relational schema over a countably infinite set NS of database predicates. For simplicity, we assume to deal with plain relational schemas without constraints, and with database instances that directly store abstract objects (as opposed to values). In other words, a database instance D of S is a set of ground atoms over the predicates in NS and the constants in NI.2 Queries over S are expressed in SQL. We use \u03d5(~x) to denote that query \u03d5 has ~x = x1, . . . , xn as free (i.e., answer) variables, where n is the arity of \u03d5. Given a database instance D of S and a query \u03d5 over S, ans(\u03d5,D) denotes the set of tuples of constants in NI computed by evaluating \u03d5 over D.\nIn OBDA, one provides access to an (external) database through an ontology TBox, which is connected to the database by means of a mapping. Given a source schema S and a TBox T , a (GAV) mapping assertion between S and T has the form \u03d5(x) A(x) or \u03d5\u2032(x, x\u2032) P (x, x\u2032), where A and P are respectively concept and role names, and \u03d5(x), \u03d5\u2032(x, x\u2032) are arbitrary (SQL) queries expressed over S.\nAn OBDA specification is a triple P = \u3008T ,M,S\u3009, where T is a DL TBox, S is a relational schema, and M is a finite set of mapping assertions. Without loss of generality, we assume that all concept and role names appearing in M are contained in sig(T ). An OBDA instance is a pair \u3008P ,D\u3009, where P is an OBDA specification, and D is a database instance for S. This means that we can directly transfer through the mapping the objects retrieved from the database into the concepts and roles of the TBox. Indeed, given the mapping assertion \u03d5(x) A(x), intuitively, the query\u03d5(x) is evaluated overD and the returned set ans(\u03d5,D) of objects is used to instantiate the conceptA; similarly for an assertion \u03d5(x, x\u2032) P (x, x\u2032).\nThe semantics of an OBDA instance \u3008P ,D\u3009, where P = \u3008T ,M,S\u3009, is specified in terms of interpretations of the concepts and roles in T , given the database instance D. We define it by relying on the following (virtual3) ABox\nAM,D = {N(~o) | ~o \u2208 ans(\u03d5,D) and \u03d5(~x) N(~x) in M}\ngenerated by M from D, where N is a concept or role name in T . Then, a model of \u3008P ,D\u3009 is simply a model of the ontology \u3008T ,AM,D\u3009.\nFollowing Di Pinto et al. (2013), we split each mapping assertion m = \u03d5(~x) N(~x) in M into two parts by introducing an intermediate view name Vm for the SQL query \u03d5(~x). We obtain a low-level mapping assertion of the form \u03d5(~x) Vm(~x), and a high-level mapping assertion of the\n2All our results easily extend to the case where objects are constructed from retrieved database values (Calvanese et al. 2009).\n3We call such an ABox \u2019virtual\u2019, because we are not interested in actually materializing its facts.\nform Vm(~x) N(~x). In our technical development, we deal only with the high-level mappings. Hence, we abstract away the low-level mapping part, and in the following we directly consider the intermediate views as our data sources."}, {"heading": "2.3 Query Answering", "text": "We consider conjunctive queries, which are the basic and most important querying mechanism in relational database systems and ontologies. A conjunctive query (CQ) q(~x) over a signature \u03a3 is a formula \u2203~y. \u03d5(~x, ~y), where \u03d5 is a conjunction of atoms N(~z), such that N is a concept or role name in \u03a3, and ~z are variables from ~x and ~y. The set of certain answers to a CQ q(~x) over an ontology \u3008T ,A\u3009, denoted cert(q, \u3008T ,A\u3009), is the set of tuples ~c of elements from Ind(A) of the same length as ~x, such that q(~c) (considered as a FO sentence) holds in every model of \u3008T ,A\u3009. We mention two more query classes. An atomic query (AQ) is a CQ consisting of exactly one atom whose variables are all free. A CQ with inequalities (CQ 6=) is a CQ that may contain inequality atoms between the variables of the predicate atoms.\nGiven a CQ q, an OBDA specification P = \u3008T ,M,S\u3009 and a database D, the answer to q over the OBDA instance \u3008P ,D\u3009, denoted cert(q,P ,D), is defined as cert(q, \u3008T ,AM,D\u3009). Observe that, when D is inconsistent with P (i.e., \u3008P ,D\u3009 does not have a model), then cert(q,P ,D) is the set of all possible tuples of constants in AM,D (of the same arity as q)."}, {"heading": "3 An OBDA Rewriting Framework", "text": "We extend the notion of query inseparability of ontologies (Botoeva et al. 2014) to OBDA specifications. We adopt the proposal by Bienvenu and Rosati (2015), but we do not enforce preservation of inconsistency. Definition 1. Let \u03a3 be a signature. Two OBDA specifications P1 = \u3008T1,M1,S\u3009 and P2 = \u3008T2,M2,S\u3009 are \u03a3-CQ inseparable if cert(q,P1,D) = cert(q,P2,D), for every CQ q over \u03a3 and every database instance D of S.\nIn OBDA, one must deal with the trade-off between the computational complexity of query answering and the expressiveness of the ontology language. Suppose that for an OBDA specification P = \u3008T ,M,S\u3009, T is expressed in an ontology language L that does not allow for efficient query answering. A possible solution is to exploit the expressive power of the mapping layer to compute a new OBDA specification P \u2032 = \u3008T \u2032,M\u2032,S\u3009 in which T \u2032 is expressed in a language Lt more suitable for query answering than L. The aim is to encode in M\u2032 not only M but also part of the semantics of T , so that P \u2032 is query-inseparable from P . This leads to the notion of rewriting of OBDA specifications. Definition 2. Let Lt be an ontology language. The OBDA specification P \u2032 = \u3008T \u2032,M\u2032,S\u3009 is a CQ-rewriting in Lt of the OBDA specification P = \u3008T ,M,S\u3009 if (i) sig(T ) \u2286 sig(T \u2032), (ii) T \u2032 is an Lt-TBox, and (iii) P and P \u2032 are \u03a3CQ inseparable, for \u03a3 = sig(T ). If such P \u2032 exists, we say that P is CQ-rewritable into Lt.\nWe observe that the new OBDA specification can be defined over a signature that is an extension of that of the original TBox. This is specified by condition (i). In condition (ii),\nwe impose that the new ontology is specified in the target language Lt. Finally, condition (iii) imposes that the OBDA specifications cannot be distinguished by CQs over the original TBox. Note that the definition allows for changing the ontology and the mappings, but not the source schema, accounting for the fact that the data sources might not be under the control of the designer of the OBDA specification.\nAs expected, it is not always possible to obtain a CQrewriting of P in an ontology language Lt that allows for efficient query answering. Indeed, the combined expressiveness of Lt with the new mappings might not be sufficient to simulate query answering over P without loss. In these cases, we can resort to approximating query answers over P in a sound way, which means that the answers to queries posed over the new specification are contained in those produced by querying P . Hence, we say that the OBDA specification P \u2032 = \u3008T \u2032,M\u2032,S\u3009 is a sound CQ-approximation in Lt of the OBDA specification P = \u3008T ,M,S\u3009 if P \u2032 satisfies (i), (ii), and cert(q,P \u2032,D) \u2286 cert(q,P ,D), for each CQ q over sig(T ) and for each instance D of S.\nNext, we study CQ-rewritability of OBDA specifications into DL-LiteR, developing suitable techniques."}, {"heading": "4 Rewriting OBDA Specifications", "text": "In this section, we develop our OBDA rewriting technique, which relies on Datalog rewritings of the TBox (and mappings). Recall that a Datalog program (with inequalities) is a finite set of definite Horn clauses without functions symbols, i.e., rules of the form head \u2190 \u03d5, where \u03d5 is a finite non-empty list of predicate atoms and guarded inequalities called the body of the rule, and head is an atom, called the head of the rule, all of whose variables occur in the body. The predicates that occur in rule heads are called intensional (IDB), the other predicates are called extensional (EDB)."}, {"heading": "4.1 ET-mappings", "text": "Now, we extend the notion of T-mappings introduced by Rodriguez-Muro, Kontchakov, and Zakharyaschev (2013), and define the notion of an ET-mapping that results from compiling into the mapping the expressiveness of ontology languages that are Datalog rewritable, as introduced below.\nWe first introduce notation we need. Let \u03a0 be a Datalog program and N an IDB predicate. For a database D over the EDB predicates of \u03a0, let N i\u03a0(D) denote the set of facts about N that can be deduced from D by at most i \u2265 1 applications of the rules in \u03a0, and let N\u221e\u03a0 (D) = \u22c3 i\u22651 N i \u03a0(D). It is known that the predicate N\u221e\u03a0 (\u00b7) defined by N in \u03a0 can be characterized by a possibly infinite union of CQ 6=s (Cosmadakis et al. 1988), i.e., there exist CQ 6=s \u03d5N0 , \u03d5 N 1 , . . . such that for every D, we have N\u221e\u03a0 (D) = \u22c3 i\u22650{N(~a) | ~a \u2208 ans(\u03d5Ni ,D)}. The \u03d5 N i \u2019s are called the expansions of N and can be described in terms of expansion trees (see Appendix A.1). We denote by \u03a6\u03a0(N) the set of expansion trees for N in \u03a0, and abusing notation also the (possibly infinite) union of CQ 6=s corresponding to it. Note that \u03a6\u03a0(N) might be infinite due to the presence of IDB predicates that are recursive, i.e., either directly or indirectly refer to themselves.\nWe call a TBox T Datalog rewritable if it admits a translation \u03a0T to Datalog that preserves consistency and answers to AQs (see, e.g., the translations by Hustadt, Motik, and Sattler (2005), Eiter et al. (2012), and Trivela et al. (2015) for Horn-SHIQ, and by Cuenca Grau et al. (2013) for SHI). We assume that \u03a0T makes use of a special nullary predicate \u22a5 that encodes inconsistency, i.e., for an ABox A, \u3008T ,A\u3009 is consistent iff \u22a5\u221e\u03a0T (A) is empty.\n4 We also assume that \u03a0T includes the following auxiliary rules, which ensure that \u03a0T derives all possible facts constructed over sig(T ) and Ind(A) whenever \u3008T ,A\u3009 is inconsistent:\n\u22a4\u2206(x) \u2190 A(x); \u22a4\u2206(x) \u2190 P (x, y); \u22a4\u2206(y) \u2190 P (x, y); A(x) \u2190 \u22a5,\u22a4\u2206(x); P (x, y) \u2190 \u22a5,\u22a4\u2206(x),\u22a4\u2206(y);\nwhere A and P respectively range over concept and role names in sig(T ), and \u22a4\u2206 is a fresh unary predicate denoting the set of all the individuals appearing in A.\nIn the following, we denote with \u03a0M the (high-level) mapping M viewed as Datalog, and with \u03a0T ,M the Datalog program \u03a0T \u222a \u03a0M associated to a Datalog rewritable TBox T and a mappingM. From the properties of the translation \u03a0T (and the simple structure of \u03a0M), we obtain that \u03a0T ,M satisfies the following:\nLemma 3. Let \u3008T ,M,S\u3009 be an OBDA specification where T is Datalog rewritable. Then, for every database instance D of S, concept or role name N of T , and ~a in Ind(AM,D), we have that \u3008T ,AM,D\u3009 |= N(~a) iff N(~a) \u2208 N\u221e\u03a0T ,M(D).\nFor a predicate N , we say that an expansion \u03d5N \u2208 \u03a6\u03a0T ,M(N) is DB-defined if \u03d5\nN is defined over database predicates. Now we are ready to define ET-mappings.\nDefinition 4. Let \u3008T ,M,S\u3009 be an OBDA specification where T is Datalog rewritable. The ET-mapping for M and T , denoted etmT (M), is defined as the set of assertions of the form \u03d5N (~x) N(~x) such that N is a concept or role name in T , and \u03d5N \u2208 \u03a6\u03a0T ,M(N) is DB-defined.\nIt is easy to show that, for M\u2032 = etmT (M) and each database instance D, the virtual ABox AM\u2032,D (which can be defined for ET-mappings as for ordinary mappings) contains all facts entailed by \u3008T ,AM,D\u3009. In this sense, the ETmapping etmT (M) plays for a Datalog rewritable TBox T the same role as T-mappings play for (the simpler) DL-LiteR TBoxes. Note that, in general, an ET-mapping is not a mapping, as it may contain infinitely many assertions. However, AM\u2032,D is still finite, given that it is constructed over the finite number of constants appearing in D.\n4.2 Rewriting Horn-ALCHIQ OBDA Specifications to DL-LiteR\nLet \u3008T ,M,S\u3009 be an OBDA specification, where T is a Horn-ALCHIQ TBox over a signature \u03a3. Figure 1 describes the algorithm RewObda(T ,M), which constructs a DL-LiteR TBox Tr and an ET-mapping Mc such that \u3008Tr,Mc,S\u3009 is \u03a3-CQ inseparable from \u3008T ,M,S\u3009.\nIn Step 2, the algorithm applies to T1 the normalization procedure norm\u2203, which gets rid of concepts of the form\n4Here we simply consider A as a database.\n\u2203R.( d A\u2032j) in the right-hand side of CIs. This is achieved by the following well-known substitution (Artale et al. 2009): every CI dm i=1 Ai \u2291 \u2203R.( dn j=1 A\n\u2032 j) in T1 is replaced withdm\ni=1 Ai \u2291 \u2203Pnew , Pnew \u2291 R, and \u22a4 \u2291 \u2200Pnew .A \u2032 j , for 1 \u2264 j \u2264 n, where Pnew is a fresh role name. Notice that the latter two forms of inclusions introduced by norm\u2203 are actually in DL-LiteR, as \u22a4 \u2291 \u2200Pnew .A\u2032j is equivalent to \u2203P\u2212\nnew \u2291 A\u2032j . In Step 3, the algorithm applies to T2 a further normalization procedure, norm\u2293, which introduces a fresh concept name AA1\u2293\u00b7\u00b7\u00b7\u2293An for each concept conjunction A1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 An appearing in T2, and adds A1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 An \u2261 AA1\u2293\u00b7\u00b7\u00b7\u2293An\n5 to the TBox. Note that norm\u2203(T1) and norm\u2293(T2) are model-conservative extensions of T1 and T2, respectively (Lutz, Walther, and Wolter 2007), as one can easily show. We denote by rew(T ) the resulting TBox Tr, which in general is exponential in the size of T , and by comp(T ,M) the resulting ET-mapping Mc, which in general is infinite. Example 5. Assume that the domain knowledge is represented by the axiom about bank accounts from Section 1. The normalization of this axiom is the TBox T b = {Person \u2291 \u2200inNameOf\u2212.A1,CAcc\u2293A1 \u2291 SAcc}. Assume that the database schema Sb consists of the two relations ENT(ID, TYPE,EMPID), PROD(NUM,TYPE,CUSTID), whose data are mapped to the ontology terms by means of the following mapping M:\nmP: SELECT ID AS X FROM ENT WHERE ENT.TYPE=\u2019P\u2019 Person(X) mN: SELECT NUM AS X,CUSTID AS Y FROM PROD inNameOf(X,Y) mC: SELECT NUM AS X FROM PROD P WHERE P.TYPE=\u2019B\u2019 CAcc(X)\nWe will work with the corresponding high-level mapping Mb consisting of the assertions:\nhP : {x | VPerson(x)} Person(x) hN : {x, y | VinNameOf(x, y)} inNameOf(x, y) hC : {x | VCAcc(x)} CAcc(x)\nNow, consider the OBDA specification Pb = \u3008T b,Mb,Sb\u3009. The RewObda algorithm invoked on (T b,Mb) produces:\n\u2022 The intermediate TBoxes T b1 and T b 2 coinciding with T b, and T b3 extending T\nb with ACAcc\u2293A1 \u2261 CAcc \u2293 A1. \u2022 The ET-mapping Mbc = etmT b\n3\n(Mb), which extends Mb\nwith the assertions {x | VinNameOf(x, y), VPerson(y)} A1(x),\n5We use \u2261 to abbreviate inclusion in both directions.\n{x | VCAcc(x), VinNameOf(x, y), VPerson(y)} SAcc(x), and {x | VCAcc(x), VinNameOf(x, y), VPerson(y)} ACAcc\u2293A1(x).\nThe algorithm returns the DL-LiteR TBox T br = {ACAcc\u2293A1 \u2291 CAcc, ACAcc\u2293A1 \u2291 A1, ACAcc\u2293A1 \u2291 SAcc} and the mapping Mbc. It is possible to show that P b DL-LiteR = \u3008T br ,M b c,S b\u3009 is a CQ-rewriting of Pb into DL-LiteR.\nThe TBox T3 obtained as an intermediate result in Step 3 of RewObda(T ,M), is a model-conservative extension of T that is tailored towards capturing in DL-LiteR the answers to tree-shaped CQs. This is obtained by introducing in Step 2 sufficiently new role names, and in Step 3 new concept names, so as to capture entailed axioms that generate the tree-shaped parts of models. On the other hand, the ET-mapping Mc = comp(T ,M) is such that it generates from a database instance a virtual ABox Av that is complete with respect to all ABox facts that might be involved in the generation of the tree-shaped parts of models of Tr and Av. This allows us to prove the main result of this section.\nTheorem 6. Let \u3008T ,M,S\u3009 be an OBDA specification such that T is a Horn-ALCHIQ TBox, and let \u3008Tr,Mc\u3009 = RewObda(T ,M). Then \u3008T ,M,S\u3009 and \u3008Tr,Mc,S\u3009 are \u03a3CQ inseparable, for \u03a3 = sig(T ).\nClearly, \u3008Tr,Mc,S\u3009 is a candidate for being a CQ-rewriting of \u3008T ,M,S\u3009 into DL-LiteR. However, since Mc might be an infinite set, \u3008Tr,Mc,S\u3009 might not be an OBDA specification and hence might not be effectively usable for query answering. Next we address this issue, and show that in some cases we obtain proper CQ-rewritings, while in others we have to resort to approximations."}, {"heading": "5 Approximating OBDA Specifications", "text": "To obtain from an ET-mapping a proper mapping, we exploit the notion of predicate boundedness in Datalog, and use a bound on the depth of Datalog expansion trees.\nAn IDB predicate N is said to be bounded in a Datalog program \u03a0, if there exists a constant k depending only on \u03a0 such that, for every database D, we have Nk\u03a0(D) = N \u221e \u03a0 (D) (Cosmadakis et al. 1988). If N is bounded in \u03a0, then there exists an equivalent Datalog program \u03a0\u2032 such that \u03a6\u03a0\u2032(N) is finite, and thus represents a finite union of CQ 6=s. It is well known that predicate boundedness for Datalog is undecidable in general (Gaifman et al. 1987). We say that \u2126 is a boundedness oracle if for a Datalog program \u03a0 and a predicate N it returns one of the three answers: N is bounded in \u03a0, N is not bounded in \u03a0, or unknown. When N is bounded, \u2126 returns also a finite union of CQ 6=s, denoted \u2126\u03a0(N), defining N . Given a constant k, \u03a6k\u03a0(N) denotes the set of trees (and the corresponding union of CQ 6=s) in \u03a6\u03a0(N) of depth at most k, hence \u03a6k\u03a0(N) is always finite.\nWe introduce a cutting operator cut\u2126k , which is parametric with respect to the cutting depth k > 0 and the boundedness oracle \u2126, which, when applied to a predicate N and a Datalog program \u03a0, returns a finite union of CQ 6=s as follows:\ncut\u2126k ( N,\u03a0 ) =\n{\n\u2126\u03a0(N), if N is bounded in \u03a0 w.r.t. \u2126 \u03a6k\u03a0(N), otherwise.\nWe apply cutting also to ET-mappings: given an ET-mapping\netmT (M), the mapping cut\u2126k (etmT (M)) is the (finite) set of mapping assertions \u03d5N (~x) N(~x) s.t. N is a concept or role name in T , and \u03d5N \u2208 cut\u2126k (N,\u03a0T ,M) is DB-defined.\nThe following theorem provides a sufficient condition for CQ-rewritability into DL-LiteR in terms of the well-known notion of first-order (FO)-rewritability, which we recall here: a query q is FO-rewritable with respect to a TBox T , if there exists a FO query q\u2032 such that cert(q, \u3008T ,A\u3009) = ans(q\u2032,A), for every ABox A over sig(T ) (viewed as a database). It uses the fact that if an AQ is FO-rewritable with respect to a Horn-ALCHIQ TBox T , then it is actually rewritable into a union of CQ 6=s, and the fact that if T is FO-rewritable for AQs (i.e., every AQ is FO-rewritable with respect to T ), then each concept and role name is bounded in \u03a0T (Lutz and Wolter 2011; Bienvenu, Lutz, and Wolter 2013).\nTheorem 7. Let \u3008T ,M,S\u3009 be an OBDA specification such that T is a Horn-ALCHIQ TBox. Further, let Tr = rew(T ) and M\u2032 = cut\u2126k (comp(T ,M)), for a boundedness oracle \u2126 and some k > 0. If T is FO-rewritable for AQs, then \u3008T ,M,S\u3009 is CQ-rewritable into DL-LiteR, and \u3008Tr,M\u2032,S\u3009 is its CQ-rewriting. Otherwise, \u3008Tr ,M\u2032,S\u3009 is a sound CQapproximation of \u3008T ,M,S\u3009 in DL-LiteR.\nThe above result provides us with decidable conditions for rewritability of OBDA specifications in several significant cases. It is shown by Bienvenu, Lutz, and Wolter (2013) and Lutz and Wolter (2011) that FO-rewritability of AQs relative to Horn-SHI-TBoxes, Horn-ALCF -TBoxes, and Horn-ALCIF -TBoxes of depth two is decidable. In fact, these FO-rewritability algorithms provide us with a boundedness oracle \u2126: for each concept and role name N in T , they return a FO-rewriting of the AQ N(~x) that combined with the mapping M results in \u2126\u03a0T ,M(N).\nUnfortunately, a complete characterization of CQrewritability into DL-LiteR is not possible if arbitrary FOqueries are allowed in the (low-level) mapping.\nTheorem 8. The problem of checking whether an OBDA specification with an EL ontology and FO source queries in the mapping is CQ-rewritable into DL-LiteR is undecidable.\nHowever, if we admit only unions of CQs in the (lowlevel) mapping, we can fully characterize CQ-rewritability.\nTheorem 9. The problem of checking whether an OBDA specification with a Horn-ALCHI ontology of depth one and unions of CQs as source queries in the mapping is CQrewritable into DL-LiteR is decidable."}, {"heading": "6 Implementation and Experiments", "text": "To demonstrate the feasibility of our OBDA specification rewriting technique, we have implemented a prototype system called Ontoprox6 and evaluated it over synthetic and real OBDA instances. Our system relies on the OBDA reasoner Ontop7 and the complete Horn-SHIQ CQ-answering system Clipper8, used as Java libraries. Ontoprox also relies on\n6 https://github.com/ontop/ontoprox 7 http://ontop.inf.unibz.it/ 8 http://www.kr.tuwien.ac.at/research/systems/clipper/\na standard Prolog engine and on an OWL 2 reasoner (SWIprolog9 and HermiT10, resp.).\nEssentially, Ontoprox implements the rewriting and compiling procedure described in Figure 1, but instead of computing the (possibly infinite) ET-mapping comp(T ,M), it computes its finite part cutk(comp(T ,M)). So, it gets as input an OWL 2 OBDA specification \u3008TOWL2,M,S\u3009 and a positive integer k, and produces a DL-LiteR OBDA specification that can be used with any OBDA system. Below we describe some of the implementation details:\n(a) TOWL2 is first approximated to the Horn-SHIQ TBox T by dropping the axioms outside this fragment.\n(b) T is translated into a (possibly recursive) Datalog program \u03a0 and saturated with all CIs of the form d Ai \u2291\n\u2203R.( d\nA\u2032j), using functionalities provided by Clipper.\n(c) The expansions cutk(\u03a6\u03a0(X)) are computed by an auxiliary Prolog program using Prolog meta-programming.\n(d) To produce actual mappings that can be used by an OBDA reasoner, the views in the high-level mapping cutk(comp(T ,M)) are replaced with their original SQL definitions using functionalities of Ontop.\n(e) The DL-LiteR closure is computed by relying on the OWL 2 reasoner for Horn-SHIQ TBox classification.\nFor the experiments, we have considered two scenarios:\nUOBM. The university ontology benchmark (UOBM) (Ma et al. 2006) comes with a SHOIN ontology (with 69 concepts, 35 roles, 9 attributes, and 204 TBox axioms), and an ABox generator. We have designed a database schema for the generated ABox, converted the ABox to a 10MB database instance for the schema, and manually created the mapping, consisting of 96 assertions11.\nAmong others, we have considered the following queries:\nQu1 : SELECT DISTINCT ?X WHERE { ?X a ub:Person . }\nQu2 : SELECT DISTINCT ?X WHERE { ?X a ub:Employee . }\nQu3 : SELECT DISTINCT ?X ?Y WHERE { ?X rdf:type ub:ResearchGroup . ?X ub:subOrganizationOf ?Y . }\n9 http://www.swi-prolog.org/\n10 http://hermit-reasoner.com/ 11 https://github.com/ontop/ontop-examples/tree/master/aaai-2016-ontoprox/uobm\nTable 1: Query evaluation with respect to 5 setups (number of answers / running time in seconds)\nOntop LSA GSA Ontoprox Clipper\nUOBM Qu1 14,129 / 1.02 14,197 / 0.50 14,197 / 1.50 14,197 / 0.68 14,197 / 20.7 Qu2 1,105 / 0.13 2,170 / 0.38 2,170 / 1.22 2,170 / 0.68 2,170 / 20.6 Qu3 235 / 0.10 235 / 0.44 235 / 1.76 247 / 0.31 247 / 22.1 Qu4 19 / 0.08 19 / 0.26 19 / 0.91 38 / 0.28 38 / 21.0\nTelecom Qt1 0 / 3.05 0 / 0.64 0 / 2.09 82,455 / 5.05 N/A Qt2 0 / 0.66 0 / 0.17 0 / 0.72 16,487 / 224 N/A Qt3 5,201,363 / 152 5,201,363 / 203 5,201,363 / 817 5,260,346 / 483 N/A\nQu4 : SELECT DISTINCT ?X ?Y ?Z WHERE { ?X rdf:type ub:Chair . ?X ub:worksFor ?Y .\n?Y rdf:type ub:Department . ?Y ub:subOrganizationOf ?Z . }\nTelecom benchmark. The telecommunications ontology models a portion of the network of a leading telecommunications company, namely the portion connecting subscribers to the operating centers of their service providers. The current specification consists of an OWL 2 ontology with 152 concepts, 53 roles, 73 attributes, 458 TBox axioms, and of a mapping with 264 mapping assertions. The database instance contains 32GB of real-world data. In the following, we only provide a description of some of the queries because the telecommunications ontology itself is bound by a confidentiality agreement.\n\u2022 Query Qt1 asks, for each cable in the telecommunications network, the single segments of which the cable is composed, and the network line (from one device to another one) that the cable covers. For each cable, it also returns its bandwidth and its status (functioning, non-functioning, etc.). \u2022 Query Qt2 asks for each path in the network that runs on fiber-optic cable, to return the specific device from which the path originates, and also requires to provide the number of different channels that are available in the path. \u2022 Query Qt3 asks, for each cable in the telecommunications network, the port to which the cable is attached, the slot on the device in which the port is installed, and, for each such slot, its status and its type. For each cable, it also returns its status.\nFor each OBDA instance \u3008\u3008T ,M,S\u3009,D\u3009, we have evaluated the number of query answers and the query answering time with respect to five different setups:\n(1) The default behavior of Ontop v1.15, which simply ignores all non-DL-LiteR axioms in T , i.e., using \u3008T 1,M,S\u3009 where T 1 are all the DL-LiteR axioms in T .\n(2) The local semantic approximation (LSA) of T in DLLiteR, i.e., using \u3008T 2,M,S\u3009 where T 2 is obtained as the union, for each axiom \u03b1 \u2208 T , of the set of DL-LiteR axioms \u0393(\u03b1) entailed by \u03b1 (Console et al. 2014).\n(3) The global semantic approximation (GSA) of T in DLLiteR, i.e., using \u3008T 3,M,S\u3009 where T 3 is the DL-LiteR\nclosure of T (Pan and Thomas 2007).\n(4) Result of Ontoprox, \u3008rew(T ), cut5(comp(T ,M)),S\u3009.\n(5) Clipper over the materialization of the virtual ABox.\nIn Table 1, we present details of the evaluation for some of the queries for which we obtained significant results. In Table 2, we provide statistics about the Ontoprox precomputations. The performed evaluation led to the following findings:\n\u2022 Compared to the default Ontop behavior, LSA produces more answers for 2 queries out of 4 for UOBM.\n\u2022 Compared to LSA, Ontoprox produces more answers for 2 queries out of 4 for UOBM, and for all Telecom queries.\n\u2022 For UOBM, Ontoprox answers are complete, as confirmed by the comparison with the results provided by Clipper. We cannot determine completeness for the Telecom queries, the Telecom database was too large and its materialization in an ABox was not feasible.\n\u2022 Query answering of Ontoprox is ~3\u20135 times slower than Ontop, when the result sets are of comparable size (note that for Qt2 the result set is significantly larger).\n\u2022 The size of the new DL-LiteR OBDA specifications is comparable with that of the original specifications."}, {"heading": "7 Conclusions", "text": "We proposed a novel framework for rewriting and approximation of OBDA specifications in an expressive ontology language to OBDA specifications in a weaker language, in which the core idea is to exploit the mapping layer to encode part of the semantics of the original OBDA specification, and we developed techniques for DL-LiteR as the target language. We intend to extend our technique to Horn-SHIQ, and, more generally, to Datalog rewritable TBoxes (Cuenca Grau et al. 2013). Further, we are going to deepen our understanding of the computational complexity of deciding CQ-rewritability of OBDA specifications into DLLiteR. We also plan to carry out more extensive experiments, considering queries that contain existentially quantified variables. This will allow us to verify the effectiveness of RewObda, which was designed specifically to deal with existentially implied objects.\nAcknowledgement. This paper is supported by the EU under the large-scale integrating project (IP) Optique (Scal-\nable End-user Access to Big Data), grant agreement n. FP7318338. We would like to thank Martin Rezk for insightful discussions, and Benjamin Cogrel and Elem Gu\u0308zel for help with the experimentation."}, {"heading": "A Appendix", "text": "A.1 Expansion of Datalog Programs\nWe recall here the notion of the expansion trees (Cosmadakis et al. 1988). Formally, an expansion tree for a predicate N in a Datalog program \u03a0 is a finite tree \u03d5N\u03a0 satisfying the following conditions: \u2022 Each node x of \u03d5N\u03a0 is labeled by a pair of the form (\u03b1x, \u03c1x), where \u03b1x is an IDB atom and \u03c1x is an instance of a rule of \u03a0 such that the head of \u03c1x is \u03b1x. Moreover, the variables in the body of \u03c1x either occur in \u03b1x or they do not occur in the label of any node above x in the tree. \u2022 The IDB atom labeling the root of \u03d5N\u03a0 is an N -atom. \u2022 If x is a node, where \u03b1x = Y (~t), \u03c1x = Y (~t) \u2190 Y1(~t1), . . . , Ym(~tm), and the IDB atoms in the body of \u03c1x are Yi1(~t i1), . . . , Yi\u2113(~t i\u2113), then x has \u2113 children, re-\nspectively labeled with the atoms Yi1 (~t i1), . . . , Yi\u2113(~t i\u2113). In particular, if \u03c1x is an initialization rule (i.e., the body of \u03c1x does not contain an IDB predicate), then x is a leaf.\nA.2 Proofs of Section 4.1\nIn the following, for an OBDA specification P and a database instance D, if \u3008P ,D\u3009 has a model, we say that D is consistent with P .\nLemma 3. Let \u3008T ,M,S\u3009 be an OBDA specification where T is Datalog rewritable. Then, for every database instance D of S, concept or role name N of T , and ~a in Ind(AM,D), we have that \u3008T ,AM,D\u3009 |= N(~a) iff N(~a) \u2208 N\u221e\u03a0T ,M(D).\nProof. We assume that the Datalog translation \u03a0T of T satisfies the following properties (see, e.g., Theorem 1 in (Hustadt, Motik, and Sattler 2005) and Proposition 2 in (Eiter et al. 2012)):\n\u22c6 for every ABox A, \u3008T ,A\u3009 is consistent iff \u22a5\u221e\u03a0T (A) is empty, and if \u3008T ,A\u3009 is consistent, then for every concept or role name N of T and ~a in Ind(A), \u3008T ,A\u3009 |= N(~a) iff N(~a) \u2208 N\u221e\u03a0T (A).\nRecall that for an ABox A such that \u3008T ,A\u3009 is inconsistent, \u3008T ,A\u3009 entails all possible facts of the form N(~a) for a concept or role name N of T and ~a in Ind(AM,D). We prove that the translation \u03a0T containing the auxiliary rules involving \u22a4\u2206 and \u22a5 satisfies a stronger property:\n\u22c6\u22c6 for every ABox A, for every concept or role name N of T and ~a in Ind(A), \u3008T ,A\u3009 |= N(~a) iff N(~a) \u2208 N\u221e\u03a0T (A).\nIndeed, it is easy to see that considering that (i) \u22a4\u2206 contains precisely Ind(A), i.e., \u22a4\u2206(a) \u2208 \u22a4\u2206 \u221e \u03a0T (A) for each a \u2208 Ind(A), and (ii) if \u22a5 is true in \u03a0T (A), then for each concept or role name N of T and ~a in Ind(AM,D), we have that N(~a) \u2208 N\u221e\u03a0T (A).\nAs \u03a0T ,M = \u03a0T \u222a \u03a0M, the statement of the lemma follows directly from the property \u22c6\u22c6 of \u03a0T and the fact that the rules in \u03a0M connect two disjoint vocabularies.\nLemma 10. Let \u3008T ,M,S\u3009 be an OBDA specification where T is Datalog rewritable, and M\u2032 = etmT (M). Then for every database instance D of S, we have that AM\u2032,D is exactly the set of all facts entailed by \u3008T, AM,D\u3009, i.e., assertions of the form A(a), P (a, b) for a, b \u2208 Ind(AM,D), A,P \u2208 sig(T ).\nProof. Let D be a database instance of S, a \u2208 Ind(AM,D), A a concept name in sig(T ). Then\n\u2022 \u3008T, AM,D\u3009 |= A(a) iff (by Lemma 3) \u2022 A(a) \u2208 A\u221e\u03a0T ,M(D) iff (by the properties of expansions)\n\u2022 there exists DB-defined \u03d5 \u2208 \u03a6\u03a0T ,M(A) such that a \u2208 ans(\u03d5,D).\nLet \u3008T, AM,D\u3009 |= A(a). By construction of M\u2032, the mapping assertion \u03a6\u03a0T ,M(A) A(x) is in M\n\u2032. We conclude that A(a) \u2208 AM\u2032,D . Now, assume that A(a) \u2208 AM\u2032,D . It follows that in M\u2032 there is a mapping assertion \u03a6\u03a0T ,M(A) A(x) and a \u2208 ans(\u03d5,D) for some \u03d5 \u2208 \u03a6\u03a0T ,M(A). We conclude that \u3008T, AM,D\u3009 |= A(a).\nThe proof for role assertions is analogous.\nA.3 Proof of Theorem 6 We start by showing a sufficient condition for \u03a3-CQ inseparability of OBDA specifications.\nA homomorphism between two interpretations is a mapping between their domains that preserves constants and relations. A model of an ontology O that can be homomorphically embedded in every model of O is called a canonical model of O, from now on denoted CO . The notion of canonical model is important in the context of CQ answering, since answers to CQs are preserved under homomorphisms, i.e., if q(~a) holds in an interpretation I, and there is a homomorphism from I to an interpretation I \u2032, then q(~a) holds in I \u2032 (Chandra and Merlin 1977). It follows that certain answers can be characterized as the answers over the canonical model.\nLemma 11. Let O = \u3008T ,A\u3009 be a consistent ontology that has a canonical model CO, q(~x) a CQ, and ~a a tuple from Ind(A). Then ~a \u2208 cert(q,O) iff CO satisfies q(~a).\nIt is well known that Horn variants of DLs have the canonical model property (Eiter et al. 2012; Botoeva et al. 2014), i.e., every satisfiable ontology O admits a (possibly infinite) canonical model.\nA \u03a3-homomorphism is a mapping that preserves constants and relations in \u03a3. Given two interpretations I and J , we say that I is (\u03a3-)homomorphically embeddable into J if there exists a (\u03a3-)homomorphism from I to J . Moreover, I and J are (\u03a3-)homomorphically equivalent if they are (\u03a3-)homomorphically embeddable into each other. The following characterization can be easily derived from Lemma 11, the property of canonical models, and the definitions of certain answers.\nLemma 12. Let \u03a3 be a signature, and P1 = \u3008T1,M1,S\u3009 and P2 = \u3008T2,M2,S\u3009 two OBDA specifications. Assume that for every ABox A, both \u3008T1,A\u3009 and \u3008T2,A\u3009 admit a canonical model. If\n\u2022 for every database instance D of S that is consistent with both P1 and P2, we have that C\u3008T1,AM1,D\u3009 and C\u3008T2,AM2,D\u3009 are \u03a3-homomorphically equivalent, and \u2022 for every database instance D of S that is inconsistent with P1 or P2, we have that \u3008T1,AM1,D\u3009 and \u3008T2,AM2,D\u3009 entail the same ABox facts over \u03a3,\nthen P1 and P2 are \u03a3-CQ inseparable.\nNow we show several properties of the intermediate and final TBoxes obtained during the RewObda(T ,M) procedure. First, we show that, for ABoxes containing a single assertion, the DL-LiteR TBox Tr generates a canonical model equivalent to the canonical model generated by the intermediate Horn-ALCHIQ TBox T3.\nLemma 13. Let T be a Horn-ALCHIQ TBox, T3 the TBox obtained in step 3 of RewObda(T ,M), and Tr = rew(T ). Also, for A a concept name in sig(T3) and a \u2208 NI, let A = {A(a)} be an ABox such that \u3008T3,A\u3009 is consistent. Then C\u3008T3,A\u3009 is homomorphically equivalent to C\u3008Tr,A\u3009.\nProof. In this proof, we call an element \u03c3\u2032 a successor of \u03c3 in a canonical model C of \u3008T ,A\u3009, for \u03c3, \u03c3\u2032 \u2208 \u2206C , if \u03c3\u2032 is added (i.e., generated) to satisfy an existential assertion \u03b1 of the form d Ai \u2291 \u2203( d Qj).( d A\u2032k) such that \u03c3 \u2208 ACi . Here we assume a construction of the canonical model that is \u201cminimal\u201d and uniquely defined: a new successor \u03c3\u2032 of \u03c3 is generated only if there is no other element \u03b4 of \u2206C that can be used to satisfy \u03b1, in this case we employ the following naming convention: \u03c3\u2032 is a path of the form \u03c3 \u00b7w({Qj},{A\u2032k}). In particular, if there is a role P in T such that it only appears on the left-hand side of role inclusions, and T |= { d Ai \u2291 \u2203P, P \u2291 Qj , \u2203P\u2212 \u2291 A\u2032k}, then \u03c3 has to have a successor \u03b4 introduced to satisfy the assertion d Ai \u2291 \u2203P , so \u03b4 can be used to satisfy \u03b1 and no new successor \u03c3\u2032 is generated. Also, if the predecessor \u03b4\u2032 of \u03c3 is such that \u03b4\u2032 \u2208 (A\u2032k)\nC and (\u03c3, \u03b4\u2032) \u2208 QCj , then no new successor is introduced. Here, we call each fresh role name Pnew introduced by the normalization procedure norm\u2203 a generating DL-LiteR-role precisely because it satisfies the above properties. Note that for a generating DL-LiteR-role P , the concept \u2203P\u2212 has no non-empty sub-concepts and P does not appear in constructs \u2203P .C where C is a concept distinct from \u22a4. Therefore, the element introduced as a P -successor of \u03c3 can be simply named \u03c3 \u00b7 wP (or \u03c3 \u00b7 vP to distinguish between two canonical models).\nObserve that sig(T3) = sig(Tr). Let A be a satisfiable concept name in sig(T3), andA = {A(a)}. Denote by C1 the canonical model of \u3008T3,A\u3009, and by C2 the canonical model of \u3008Tr,A\u3009.\nFirst, for each element in \u2206C1 distinct from a, we prove that it is of the form aw1 \u00b7 \u00b7 \u00b7wn, where each wi = wP for some generating DL-LiteR-role P . Suppose that \u03c3 \u2208 \u2206C1 , \u03c3 \u2208 BC1i , 1 \u2264 i \u2264 k, and T3 |= \u03b1 where \u03b1 = B1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Bk \u2291 \u2203Q.(A1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Am). By induction on the length of \u03c3, we find an element \u03b4 \u2208 \u2206C1 such that \u03b4 \u2208 AC1i , 1 \u2264 i \u2264 m, (\u03c3, \u03b4) \u2208 QC1 , and \u03b4 is of the desired form. Note that without loss of generality we may assume that none of\nB1, . . . , Bk and none ofA1, . . . , Am is a fresh concept name introduced by norm\u2293 as we can substitute each such name with its definition. Therefore, {B1, . . . , Bk, A1, . . . , Am} \u2286 sig(T ). Consider the following cases: (a) If Q \u2208 sig(T ), then by step 1 \u03b1 \u2208 T1, and by norm\u2203 in step 2, T2 (hence, T3) contains axioms B1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Bk \u2291 \u2203P , P \u2291 Q, \u2203P\u2212 \u2291 Ai, 1 \u2264 i \u2264 m, for a fresh role name P . If \u03c3 = a, then we set \u03b4 = awP \u2208 \u2206C1 , for which it holds that that awP \u2208 A C1 i , 1 \u2264 i \u2264 m, and (a, awP ) \u2208 Q\nC1 . If \u03c3 = \u03c3\u2032wS for some generating DL-LiteR-role S, and it is not the case that T3 |= S \u2291 Q\u2212 and \u03c3\u2032 \u2208 A C1 i , then we set \u03b4 = \u03c3wP , for which we have that \u03c3wP \u2208 A C1 i , 1 \u2264 i \u2264 m, and (\u03c3, \u03c3wP ) \u2208 QC1 . Otherwise we set \u03b4 = \u03c3\u2032, which is of the desired form. (b) If Q /\u2208 sig(T ), then Q is a fresh generating DL-LiteR role introduced by norm\u2203. It means that there exists a CId A\u2032j \u2291 \u2203S.( d A\u2032\u2032l ) in T1 such that T2 contains axiomsd\nA\u2032j \u2291 \u2203Q, Q \u2291 S, and \u22a4 \u2291 \u2200Q.A \u2032\u2032 l . Since Q occurs only in these axioms, it must be the case that T3 |= B1 \u2293 \u00b7 \u00b7 \u00b7 \u2293Bk \u2291 d A\u2032j and T3 |= d A\u2032\u2032l \u2291 A1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Am. Because of the former, we obtain that \u03c3 \u2208 (A\u2032j) C1 , and similarly to (a) that there is an element \u03b4 \u2208 \u2206C1 such that \u03b4 \u2208 (A\u2032\u2032l )\nC1 and (\u03c3, \u03b4) \u2208 QC1 . Because of the latter, we also have that \u03b4 \u2208 AC1i , 1 \u2264 i \u2264 m.\nSecond, we show that there exists a \u03a3-homomorphism from C1 to C2, by constructing one. Let a \u2208 BC1 for a basic concept B. Then it must be that T3 |= A \u2291 B. By construction, Tr |= A \u2291 B, and therefore a \u2208 BC2 . So we can set h(a) = a.\nLet \u03c3 \u2208 \u2206C1 such that h(\u03c3) is set, h(\u03c3) = \u03b4, and \u03c3wP \u2208 \u2206C1 . Then \u03c3 \u2208 (\u2203P )C1 , hence \u03b4 \u2208 (\u2203P )C2 . Since P is a generating DL-LiteR-role in T3, and Tr is derived from T3, it follows that P is a generating DL-LiteR-role in Tr, hence there exists a successor \u03b4vP \u2208 \u2206C2 . By construction of Tr, it follows that we can set h(\u03c3wP ) = \u03b4vP (that is, the homomorphism conditions are satisfied).\nFinally, as for a homomorphism from C2 to C1, its existence follows from the fact that T3 |= Tr: C2 is homomorphically embeddable into each model I of \u3008Tr,A\u3009 and as T3 |= Tr, C1 is a model of \u3008Tr,A\u3009 as well.\nIn general, however, Tr does not preserve ABox entailments for non-singleton ABoxes. Example 14. Consider the following TBox T , together with the computed T3 and Tr:\nT = {B \u2293 C \u2291 A, B \u2293 C \u2291 \u2203P} T3 = T \u222a {AB\u2293C \u2261 B \u2293 C, AB\u2293C \u2291 \u2203P} Tr = {AB\u2293C \u2291 A,AB\u2293C \u2291 B,AB\u2293C \u2291 C,AB\u2293C \u2291 \u2203P}\nThen, for A = {B(a), C(a)} an ABox, \u3008T3,A\u3009 |= A(a), however \u3008Tr,A\u3009 6|= A(a).\nNext, we extend Lemma 13 towards arbitrary ABoxes. To do so, we consider ABoxes that are closed with respect to T3, where an ABox A is closed with respect to a TBox T if A = EABox(T ,A) where EABox(T ,A) is the set of all membership assertions over sig(T ) and Ind(A) entailed by \u3008T ,A\u3009. We say that an ABox A is complete (within\nRewObda(T ,M)), if it is closed with respect to T3. The following result is a corollary of Lemma 13.\nLemma 15. Let T be a Horn-ALCHIQ TBox, T3 the TBox obtained in step 3 of RewObda(T ,M), and Tr = rew(T ). Then for each ABoxA that is complete and such that \u3008T3,A\u3009 is consistent, we have that C\u3008T3,A\u3009 and C\u3008Tr,A\u3009 are homomorphically equivalent.\nProof. We use the same assumptions for the canonical model as in the proof of Lemma 13. Denote by C1 the canonical model of \u3008T3,A\u3009, and by C2 the canonical model of \u3008Tr,A\u3009 for a complete ABox A. The existence of a homomorphism from C2 to C1 is straightforward. We show that there exists a homomorphism from C1 to C2. Let a \u2208 Ind(A), it is sufficient to show that for each successor awP of a in C1, there is a successor avP of a in C2. The rest of the proof follows from Lemma 13.\nLet \u03c3 be a successor of a in C1. It follows from the proof of Lemma 13 that \u03c3 is of the form awP whereP is a generating DL-LiteR role and \u3008T3,A\u3009 |= \u2203P (a) (moreover, there exists no individual b \u2208 Ind(A) such that R(a, b) \u2208 A for each role R with T3 |= P \u2291 R and B(b) \u2208 A for each concept name B with T3 |= \u2203P\u2212 \u2291 B).\nWe show that \u3008Tr,A\u3009 |= \u2203P (a). Recall that T3 contains all possible CIs with \u2203P on the right-hand side. From \u3008T3,A\u3009 |= \u2203P (a), it follows that there exists a CI A1\u2293\u00b7 \u00b7 \u00b7\u2293 An \u2291 \u2203P in T3, n \u2265 1, such that Ai(a) \u2208 A. If n = 1, then Tr |= A1 \u2291 \u2203P , hence \u3008Tr,A\u3009 |= \u2203P (a). Assume that n > 1, then by step 3 T3 contains AA1\u2293\u00b7\u00b7\u00b7\u2293An \u2261 A1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 An, therefore Tr contains AA1\u2293\u00b7\u00b7\u00b7\u2293An \u2291 \u2203P , and since A is closed with respect to T3, A contains AA1\u2293\u00b7\u00b7\u00b7\u2293An(a). Finally, we obtain that Tr |= \u2203P (a).\nNow, as no individual b can be used as a P -successor of a, in C2 there is a successor avP of a.\nThe result above is significant, because the mapping Mc = comp(T ,M) is such that it generates from a database instance a virtual ABox that is complete (within comp(T ,M)). Finally, combined with Lemmas 10 and 15, we are ready to prove Theorem 6.\nTheorem 6. Let \u3008T ,M,S\u3009 be an OBDA specification,\u03a3 = sig(T ), and \u3008Tr,Mc\u3009 = RewObda(T ,M). Then, for each database instance D of S and for each \u03a3-query q, we have that cert(q, \u3008T ,M,S\u3009,D) = cert(q, \u3008Tr ,Mc,S\u3009,D).\nProof. (a) Let D be an instance of S inconsistent with \u3008T ,M,S\u3009. By Lemma 10 AMc,D = EABox(\u3008T3,AM,D\u3009), and since D is inconsistent with \u3008T3,M,S\u3009, we have that AMc,D contains all possible facts over sig(T ). The axioms in Tr do not add more facts.\n(b) We show that for each database instance D of S consistent with \u3008T ,M,S\u3009, the canonical models C\u3008T ,AM,D\u3009 and C\u3008Tr,AMc,D\u3009 are \u03a3-homomorphically equivalent.\n(I) We observe that by Lemma 10, it follows that AMc,D is closed with respect to T3.\n(II) We show that C\u3008T ,A\u3009 is \u03a3-homomorphically equivalent to C\u3008T3,A\u3009, where A is an ABox and \u03a3 = sig(T ). The interesting direction is the existence of a \u03a3-homomorphism\nfrom C\u3008T3,A\u3009 to C\u3008T ,A\u3009. Since T3 is a model-conservative extension of T , C\u3008T ,A\u3009 can be extended without changing the interpretations of symbols in \u03a3 to a model I of \u3008T3,A\u3009. By definition of canonical model, there exists a homomorphism from C\u3008T3,A\u3009 to I and since I agrees with C\u3008T ,A\u3009 on \u03a3, we obtain that there exists a \u03a3-homomorphism from C\u3008T3,A\u3009 to C\u3008T ,A\u3009.\n(III) We show that EABox\u03a3(T ,AMc,D) = EABox\u03a3(T ,AM,D), where \u03a3 = sig(T ) and EABox\u03a3(T ,A) is the projection of EABox(T ,A) on \u03a3. Assume that A(a) \u2208 EABox(T3,AMc,D) such that A(a) /\u2208 EABox(T ,AM,D). Then A is a fresh concept introduced in step 3, hence A /\u2208 \u03a3 and EABox\u03a3(T3,AMc,D) = EABox\u03a3(T ,AM,D). Combining it with (II), we conclude that EABox\u03a3(T ,AMc,D) = EABox\u03a3(T ,AM,D).\nNow, by Lemma 15 and (I), by (II) and by (III) we obtain the following (\u03a3-)homomorphic equivalences \u2261 (\u2261\u03a3):\nC\u3008Tr,AMc,D\u3009 \u2261 C\u3008T3,AMc,D\u3009 \u2261\u03a3 C\u3008T ,AMc,D\u3009 \u2261\u03a3 C\u3008T ,AM,D\u3009.\nHence, C\u3008Tr,AMc,D\u3009 and C\u3008T ,AM,D\u3009 are \u03a3-homomorphically equivalent.\nFinally, by Lemma 12 and (a), (b), we conclude that \u3008T ,M,S\u3009 and \u3008Tr,Mc,S\u3009 are \u03a3-CQ inseparable.\nA.4 Proofs of Section 5\nTheorem 7. Let \u3008T ,M,S\u3009 be an OBDA specification such that T is a Horn-ALCHIQ TBox. Further, let Tr = rew(T ) and M\u2032 = cut\u2126k (comp(T ,M)), for a boundedness oracle \u2126 and some k > 0. If T is FO-rewritable for AQs, then \u3008T ,M,S\u3009 is CQ-rewritable into DL-LiteR, and \u3008Tr,M\u2032,S\u3009 is its CQ-rewriting. Otherwise, \u3008Tr,M\u2032,S\u3009 is a sound CQapproximation of \u3008T ,M,S\u3009 in DL-LiteR.\nProof. We note that since T is a TBox of depth 1 (it is assumed to be in normal form), if T is FO-rewritable for AQs then by (Lutz and Wolter 2011, Lemma 5) T is FOrewritable for CQs.\nTheorem 8. The problem of checking whether an OBDA specification with an EL ontology and FO source queries in the mapping is CQ-rewritable into DL-LiteR is undecidable.\nProof. Proof by reduction from the satisfiability problem of first-order logic.\nLet \u03d5 be a closed first-order formula. We construct an OBDA specification P = \u3008T ,M,S\u3009 such that P is CQrewritable into DL-LiteR iff \u03d5 is unsatisfiable.\nWe set T = {\u2203R.A \u2291 A}. S contains all predicates in \u03d5, a binary relation tableR and a unary relation tableA such that tableR, tableA do not occur in \u03d5. M consists of two mapping assertions: tableR(x, y) \u2227 \u03d5 R(x, y) and tableA(x) A(x).\nAssume that \u03d5 is unsatisfiable. Then for each database instance D of S we have that R is empty in AM,D. It is straightforward to see that \u3008\u2205,M,S\u3009 is a CQ-rewriting of P into DL-LiteR.\nAssume that \u03d5 is satisfiable and, for the sake of contradiction, suppose that P is CQ-rewritable into DL-LiteR and\nP \u2032 = \u3008T \u2032,M\u2032,S\u3009 is such a CQ-rewriting where T \u2032 is a DL-LiteR TBox. Now, consider an instance of the reachability problem G = (V,E) and two vertices s, t \u2208 V . Let D be a database instance that satisfies \u03d5 and such that for each (v, u) \u2208 E, (v, u) \u2208 tableR and s \u2208 tableA. It is the standard reduction of the reachability problem to query answering in EL, therefore t \u2208 cert(A(x), \u3008P ,D\u3009) iff t is reachable from s in G. Since P \u2032 is a rewriting of Pand T \u2032 is a DL-LiteR TBox, there exists a FO-query qA(x) such that cert(A(x), \u3008P ,D\u3009) = cert(A(x), \u3008P \u2032,D\u3009) = ans(qA(x),D). Thus, we obtain that t \u2208 ans(qA(x),D) iff t is reachable from s in G. It means that we can solve the reachability problem by evaluating a FO-query over the database encoding the graph, which contradicts the NLOGSPACE-hardness of the reachability problem. Contradiction rises from the assumption that P is CQ-rewritable into DL-LiteR.\nTheorem 9. The problem of checking whether an OBDA specification with a Horn-ALCHI ontology of depth one and unions of CQs as source queries in the mapping is CQrewritable into DL-LiteR is decidable.\nProof. Let P = \u3008T ,M,S\u3009 be an OBDA specification (here we do not split M into high- and low-level mappings). We construct a monadic Datalog program\u03a0 without inequalities worst case exponential in the size of T and M such that\n\u03a0 is program bounded iff P is CQ-rewritable into DL-LiteR, (1) where \u03a0 is said to be program bounded if each predicate N mentioned in \u03a0 is bounded in \u03a0, and a Datalog program \u03a0 is monadic if all its IDB predicates are monadic (unary). It is known that program boundedness of monadic Datalog programs without inequalities in decidable in 3EXPTIME (Cosmadakis et al. 1988). Thus, we obtain a 4EXPTIME algorithm for deciding CQ-rewritability into DL-LiteR.\nLet T3 be the TBox obtained as an intermediate result in Step 3 of RewObda(T ,M). Then \u03a0 is the monadic Datalog program such that\nA\u221e\u03a0 (D) = A \u221e \u03a0T3,M (D), (2)\nfor each instance D of S and each concept A in T3,\nand \u03d5A is DB-defined for each \u03d5A \u2208 \u03a6\u03a0(A). Observe that the Datalog translation \u03a0T3,M of the Horn-ALCHI TBox T3 is a Datalog program without inequalities. Therefore, we have that \u03a0 is a monadic Datalog program without inequalities and its program boundedness is decidable. Moreover, observe that \u03a6\u03a01(P ) is a finite union of CQs for each role name P in T3. We first prove (1), then we show how \u03a0 is constructed.\nAssume that \u03a0 is program bounded and let \u2126 be a boundedness oracle for it. Note that since \u03a0 is bounded, for a concept name A, cut\u2126k (A,\u03a0) does not depend on the value of k. Next, let Tr = rew(T ), and Mc be the set of \u2022 mapping assertions \u03d5A(x) A(x) such that A is a con-\ncept name in T3 and \u03d5A \u2208 cut\u2126k (A,\u03a0), and of \u2022 mapping assertions \u03d5P (x, y) P (x, y) such that P is a\nrole name in T3 and \u03d5P \u2208 \u03a6\u03a0T3,M(P ).\nIt is straightforward to see that \u3008Tr,Mc,S\u3009 is a CQrewriting of \u3008T ,M,S\u3009 into DL-LiteR.\nAssume that \u03a0 is CQ-rewritable into DL-LiteR and \u3008T \u2032,M\u2032,S\u3009 is its CQ-rewriting where the source queries in M\u2032 are unions of CQs. Let N be a concept or role name in T and denote by qN (~x) the rewriting of the query N(~x) into a union of CQs over S with respect to \u3008T \u2032,M\u2032,S\u3009 (recall that the rewriting of N(~x) with respect to T \u2032 is a union of CQs, and since M\u2032 contains unions of CQs as source queries, qN (~x) is also a union of CQs).\nWe construct now a Datalog program \u03a0\u2032 consisting of the rules N(~x) \u2190 \u03d5N (~x), for a concept or role name N in T and a CQ \u03d5N (~x) \u2208 qN (~x). Obviously, \u03a0\u2032 is program bounded. Since \u3008T \u2032,M\u2032,S\u3009 is a CQ-rewriting of \u3008T ,M,S\u3009, and T3 is a model-conservative extension of T , we have that N\u221e\u03a0\u2032 (D) = N \u221e \u03a0T ,M (D) = N\u221e\u03a0T3,M (D), for each instance D of S and each concept or role name N in T . Next, because of (2), we have that A\u221e\u03a0\u2032(D) = A \u221e \u03a0 (D) for each instance D of S and each concept name A in T . Now, we set the finite union of CQs \u2126\u03a0(A) for each concept name A in T3: \u2022 if A is a concept name in T , then \u2126\u03a0(A) = \u03a6\u03a0\u2032(A) \u2022 otherwise, A is introduced for a concept conjunctionA1\u2293 \u00b7 \u00b7 \u00b7\u2293An in Step 3, then \u2126\u03a0(A) is the DNF of the formula \u03a6\u03a0\u2032(A1)\u2227 \u00b7 \u00b7 \u00b7 \u2227\u03a6\u03a0\u2032(An) where each \u03a6\u03a0\u2032 is viewed as a formula in DNF. Hence, we obtain that \u03a0 is program bounded.\nWe now show how \u03a0 is constructed from \u03a0T3,M. First, we remove from \u03a0T3,M the rules which are not reachable from the database predicates. Namely, let \u03a01 be the set of rules \u03c0 = head \u2190 X1, . . . , Xn in \u03a0T3,M such that there are sets of rules \u03c11, . . . , \u03c1m in \u03a0T3,M such that \u03c1m is a set of rules from \u03a0M, the predicates in the bodies of the rules in \u03c1i\u22121 are exactly the predicates in the heads of the rules in \u03c1i, for 2 \u2264 i \u2264 m, and \u03c11 = {\u03c0}. It should be clear that N\u221e\u03a01(D) = N \u221e \u03a0T3,M\n(D), for each instance D of S and each concept or role name N in T3.\nThen\u03a0 is the monadic Datalog program such that for each instance D of S and each concept name A in T3, A\u221e\u03a0 (D) = A\u221e\u03a01(D). We obtain \u03a0 by substituting each occurrence in the body of a rule of an atom of the form R(x, y), for R a role in T , by \u03a6\u03a01(R), and by removing all rules whose head predicates are roles. Namely for the former, let \u03c1 = head \u2190 \u03d5,R(x, y) be a rule in \u03a01. Then we replace \u03c1 with the rules, head \u2190 \u03d5, \u03c8, for each CQ \u03c8 \u2208 \u03a6\u03a01(R). We repeat this procedure until we get a Datalog program \u03a0 where no atom of the form R(x, y), for a role R in T3, occurs in the a body of a rule. Observe that \u03a6\u03a01(R) is always finite.\nIt is easy to see that \u03a0 is as required."}], "references": [{"title": "The DL-Lite family and relations", "author": ["Artale"], "venue": "J. of Artificial Intelligence Research", "citeRegEx": "Artale,? \\Q2009\\E", "shortCiteRegEx": "Artale", "year": 2009}, {"title": "R", "author": ["M. Bienvenu", "Rosati"], "venue": "2015. Query-based comparison of OBDA specifications. In Proc. of the 28th Int. Workshop on Description Logic (DL), volume", "citeRegEx": "Bienvenu and Rosati 2015", "shortCiteRegEx": null, "year": 1350}, {"title": "First-order rewritability of atomic queries in Horn description logics", "author": ["Lutz Bienvenu", "M. Wolter 2013] Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI),", "citeRegEx": "Bienvenu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bienvenu et al\\.", "year": 2013}, {"title": "Query inseparability for description logic knowledge bases", "author": ["Botoeva"], "venue": "In Proc. of the 14th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Botoeva,? \\Q2014\\E", "shortCiteRegEx": "Botoeva", "year": 2014}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["Calvanese"], "venue": "J. of Automated Reasoning", "citeRegEx": "Calvanese,? \\Q2007\\E", "shortCiteRegEx": "Calvanese", "year": 2007}, {"title": "Ontologies and databases: The DL-Lite approach", "author": ["Calvanese"], "venue": null, "citeRegEx": "Calvanese,? \\Q2009\\E", "shortCiteRegEx": "Calvanese", "year": 2009}, {"title": "Data complexity of query answering in description logics", "author": ["Calvanese"], "venue": "Artificial Intelligence", "citeRegEx": "Calvanese,? \\Q2013\\E", "shortCiteRegEx": "Calvanese", "year": 2013}, {"title": "P", "author": ["A.K. Chandra", "Merlin"], "venue": "M.", "citeRegEx": "Chandra and Merlin 1977", "shortCiteRegEx": null, "year": 1977}, {"title": "D", "author": ["M. Console", "J. Mora", "R. Rosati", "V. Santarelli", "Savo"], "venue": "F.", "citeRegEx": "Console et al. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "M", "author": ["S.S. Cosmadakis", "H. Gaifman", "P.C. Kanellakis", "Vardi"], "venue": "Y.", "citeRegEx": "Cosmadakis et al. 1988", "shortCiteRegEx": null, "year": 1988}, {"title": "Computing datalog rewritings beyond Horn ontologies", "author": ["Cuenca Grau"], "venue": "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI),", "citeRegEx": "Grau,? \\Q2013\\E", "shortCiteRegEx": "Grau", "year": 2013}, {"title": "D", "author": ["F. Di Pinto", "D. Lembo", "M. Lenzerini", "R. Mancini", "A. Poggi", "R. Rosati", "M. Ruzzi", "Savo"], "venue": "F.", "citeRegEx": "Di Pinto et al. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Query rewriting for Horn-SHIQ plus rules", "author": ["Eiter"], "venue": "In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI),", "citeRegEx": "Eiter,? \\Q2012\\E", "shortCiteRegEx": "Eiter", "year": 2012}, {"title": "M", "author": ["H. Gaifman", "H.G. Mairson", "Y. Sagiv", "Vardi"], "venue": "Y.", "citeRegEx": "Gaifman et al. 1987", "shortCiteRegEx": null, "year": 1987}, {"title": "\u00d6", "author": ["M. Giese", "A. Soylu", "G. Vega-Gorgojo", "A. Waaler", "P. Haase", "E. Jim\u00e9nez-Ruiz", "D. Lanti", "M. Rezk", "G. Xiao", "\u00d6z\u00e7ep"], "venue": "L.; and Rosati, R.", "citeRegEx": "Giese et al. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Data complexity of reasoning in very expressive description logics", "author": ["Motik Hustadt", "U. Sattler 2005] Hustadt", "B. Motik", "U. Sattler"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI),", "citeRegEx": "Hustadt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2005}, {"title": "and Wolter", "author": ["C. Lutz"], "venue": "F.", "citeRegEx": "Lutz and Wolter 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Description logic TBoxes: Model-theoretic characterizations and rewritability", "author": ["Piro Lutz", "C. Wolter 2011] Lutz", "R. Piro", "F. Wolter"], "venue": "In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI),", "citeRegEx": "Lutz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2011}, {"title": "Conservative extensions in expressive description logics", "author": ["Walther Lutz", "C. Wolter 2007] Lutz", "D. Walther", "F. Wolter"], "venue": "In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI),", "citeRegEx": "Lutz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2007}, {"title": "Towards a complete OWL ontology benchmark", "author": ["Ma"], "venue": "In Proc. of the 3rd European Semantic Web Conf. (ESWC),", "citeRegEx": "Ma,? \\Q2006\\E", "shortCiteRegEx": "Ma", "year": 2006}, {"title": "and Thomas", "author": ["J.Z. Pan"], "venue": "E.", "citeRegEx": "Pan and Thomas 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "J", "author": ["Ren, Y.", "Pan"], "venue": "Z.; and Zhao, Y.", "citeRegEx": "Ren. Pan. and Zhao 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Ontology-based data access: Ontop of databases", "author": ["Kontchakov Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev"], "venue": null, "citeRegEx": "Rodriguez.Muro et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Rodriguez.Muro et al\\.", "year": 2013}, {"title": "Optimising resolution-based rewriting algorithms for OWL ontologies", "author": ["Trivela"], "venue": "J. of Web Semantics", "citeRegEx": "Trivela,? \\Q2015\\E", "shortCiteRegEx": "Trivela", "year": 2015}, {"title": "Expansion of Datalog Programs We recall here the notion of the expansion trees (Cosmadakis et al. 1988). Formally, an expansion tree for a predicate N in a Datalog program \u03a0 is a finite tree", "author": ["A Appendix A"], "venue": null, "citeRegEx": "A.1,? \\Q1988\\E", "shortCiteRegEx": "A.1", "year": 1988}], "referenceMentions": [], "year": 2017, "abstractText": "Ontology-based data access (OBDA) is a novel paradigm facilitating access to relational data, realized by linking data sources to an ontology by means of declarative mappings. DL-LiteR, the current language of choice for OBDA, has been designed with the goal of delegating query answering to the underlying database engine, and thus is restricted in expressive power. E.g., it does not allow one to express disjunctive information, and any form of recursion on the data. The aim of this paper is to overcome these limitations of DLLiteR, and extend OBDA to more expressive ontology languages, while still leveraging the underlying relational technology for query answering. We achieve this by relying on two well-known mechanisms, namely conservative rewriting and approximation, but significantly extend their practical impact by bringing into the picture the mapping, an essential component of OBDA. Specifically, we develop techniques to rewrite OBDA specifications with an expressive ontology to \u201cequivalent\u201d ones with a DL-LiteR ontology, if possible, and to approximate them otherwise. We do so by exploiting the high expressive power of the mapping layer to capture part of the domain semantics of rich ontology languages. We have implemented our techniques making use of a state-of-the-art OBDA system, and we have shown their feasibility and effectiveness with experiments on synthetic and real-world data.", "creator": "LaTeX with hyperref package"}}}