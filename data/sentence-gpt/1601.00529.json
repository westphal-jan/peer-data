{"id": "1601.00529", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Jan-2016", "title": "Programming in logic without logic programming", "abstract": "In previous work, we proposed a logic-based framework in which computation is the execution of actions in an attempt to make reactive rules of the form if antecedent then consequent true in a canonical model of a logic program determined by an initial state, sequence of events, and the resulting sequence of subsequent states. In this model-theoretic semantics, reactive rules are the driving force, and logic programs play only a supporting role. In this way, each state has its own specific rules and requirements, but with respect to computation and actions, each state has its own unique rules. For instance, while a state can have a specific set of specific rules (i.e. a state with an initial state, at some point in time, when the previous state was already in its initial state, at some point in time, when it is already in its initial state, there is no \"rules\" in the state that can be applied to a state and can be applied to any state with a different type of state. Thus, if there is no state that is at a time in time, it can be applied to any state with any kind of state.\n\n\n\n\nThe next step is to write the following language language language specification:\nThis language language specification introduces the following language language specification:\nThis language specification introduces the following language specification:\nThis language specification introduces the following language specification:\nThis language specification introduces the following language specification:\nThe language specification introduces the following language specification:\nThis language specification introduces the following language specification:\nIn this language specification, the following language specification includes:\nThere is a new, existing, or new \"state.\" A state defined by a state of a new state that is defined by an initial state, sequence of events, and the resulting sequence of subsequent states:\nThe definition of a state defined by a state of a new state that is defined by an initial state, sequence of events, and the resulting sequence of subsequent states:\nTo get to this point, we need to create a method that can be invoked to execute the action. The following language specification defines the following language specification:\nThis language specification is based on a specification made up of two simple functions:\nAs such, the application logic will allow an example in which a function is a class, a method that is a class, a method that is an abstract type of function. This way, the application logic will allow the application logic to execute the action using the new function in order to be applied to", "histories": [["v1", "Mon, 4 Jan 2016 15:09:38 GMT  (523kb)", "http://arxiv.org/abs/1601.00529v1", null], ["v2", "Tue, 5 Jan 2016 15:06:29 GMT  (523kb)", "http://arxiv.org/abs/1601.00529v2", "Under consideration in Theory and Practice of Logic Programming (TPLP)"]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["robert kowalski", "fariba sadri"], "accepted": false, "id": "1601.00529"}, "pdf": {"name": "1601.00529.pdf", "metadata": {"source": "CRF", "title": "Programming in Logic Without Logic Programming", "authors": ["Robert Kowalski", "Fariba Sadri"], "emails": ["rak@doc.ic.ac.uk}", "fs@doc.ic.ac.uk}"], "sections": [{"heading": null, "text": "In previous work, we proposed a logic-based framework in which computation is the execution of actions in an attempt to make reactive rules of the form if antecedent then consequent true in a canonical model of a logic program determined by an initial state, sequence of events, and the resulting sequence of subsequent states. In this model-theoretic semantics, reactive rules are the driving force, and logic programs play only a supporting role.\nIn the canonical model, states, actions and other events are represented with timestamps. But in the operational semantics, for the sake of efficiency, timestamps are omitted and only the current state is maintained. State transitions are performed reactively by executing actions to make the consequents of rules true whenever the antecedents become true. This operational semantics is sound, but incomplete. It cannot make reactive rules true by preventing their antecedents from becoming true, or by proactively making their consequents true before their antecedents become true.\nIn this paper, we characterize the notion of reactive model, and prove that the operational semantics can generate all and only such models. In order to focus on the main issues, we omit the logic programming component of the framework.\nKeywords: KELPS, LPS, model generation, reactive models, state transition systems __________________________________________________________________________\n1 Introduction\nState transition systems play an important role in many areas of Computing. They underpin the operational semantics of imperative programming languages, the dynamic behavior of database management systems, and many aspects of knowledge representation in artificial intelligence. In many of these systems, state transitions are performed by executing reactive rules of the form if antecedent then consequent, which describe relationships between earlier and later states and events. Such reactive rules occur explicitly as condition-action rules in production systems, eventcondition-action rules in active databases, and transition rules in Abstract State Machines (Gurevich 2000). They are implicit in Statecharts (Harel 1987) and BDI agents plans (Rao and Georgeff 1995). They are the core of Reaction RuleML (Paschke et al. 2012).\nDespite the apparently logical syntax of reactive rules in these systems, hardly any of these systems give if-then rules a logical interpretation. In this paper, we investigate the semantics of a logical language, KELPS, in which programs are sets\nof reactive rules of the form X [antecedent Y [consequent]] in classical, firstorder logic (FOL), and computation is understood as generating a sequence of state transitions with the purpose of making the reactive rules true.\nKELPS (Kowalski and Sadri 2012) is the reactive Kernel of LPS (Kowalski and Sadri 2009, 2010, 2011, 2012, 2014, 2015), a Logic-based agent and Production\nSystem language, which combines reactive rules and logic programs. KELPS is obtained from LPS by dropping the logic programming component of LPS. It is in this sense that KELPS is a language for programming in logic without logic programming.\nThe operational semantics (OS) of KELPS is similar to that of imperative reactive rule languages, which maintain only a single current state, using destructive state transitions. However the model-theoretic semantics of KELPS combines all the states into a single model, by associating time stamps with facts, actions and external events.\nIn (Kowalski and Sadri 2010, 2011, 2014, 2015), we showed that the OS of LPS (and therefore of KELPS) is sound: Any sequence of states and events that the OS recognizes as solving the computational task generates a model that makes the reactive rules true. In this paper, we investigate the completeness of the OS of KELPS, and show that the OS can generate all reactive models, in which the consequents of reactive rules are made true after their antecedents become true. However, the OS of KELPS (and therefore of LPS) is incomplete, because it can generate only reactive models.\nThe OS of KELPS cannot generate models that proactively make consequents true whether or not their antecedents become true; that preventively make antecedents false to avoid making their consequents true; or that make their antecedents true, and are then forced to make their consequents true. Moreover, it does not generate models that contain actions that are irrelevant to the computational task.\nBecause the OS of KELPS is similar to that of imperative reactive rule languages, the incompleteness of the KELPS OS shows that the operational semantics of conventional reactive system languages are also incomplete, if their reactive rules are read as logical implications.\nLPS (and therefore KELPS) is a scaled-down and optimised version of abductive logic programming (ALP) (Kakas et al. 1998). There exist proof procedures for ALP that can generate proactive and preventative models, but avoid generating obviously irrelevant actions. In section 6.2, we discuss the relationship between KELPS/LPS and ALP.\nFigure 1 illustrates KELPS and some of the different kinds of models that are allowed by the model-theoretic semantics of KELPs. There is a single reactive rule stating that if you see a wolf at time T then you cry wolf at time T+1. An external event, see-wolf, occurs at time 3. The reactive model includes all and only the external events and the actions (here, the single action cry-wolf at time 4) that are motivated by the reactive rule and triggered by the external events.\nThe example in Figure 2 is a variant of that in Figure 1. The reactive rule in Figure 2 states that you cry wolf if you see a wolf and you are outside. The state records whether or not the agent is outside. The causal theory updates the state as a result of\nboth external events and actions. The agent is initially outdoors. Both models in Figure 2 include all the timestamped facts belonging to any state, all the timestamped external events, and all the timestamped actions motivated by the reactive rule. The non-reactive, preventative model includes an action of going inside, which prevents the need for crying wolf. Of course, another non-reactive model can include both actions.\nIn this paper, we characterize the reactive models I generated by the KELPS OS. These models all have the property that every action in I is motivated by being an instance of an action that occurs explicitly in the consequent of a rule whose earlier conditions (in the antecedent or consequent of the rule) are already true.\nIn the remainder of the paper, we present KELPS, its model-theoretic and operational semantics, the relationship between the two semantics, the relationship with related work, and future work.\nThis paper extends an earlier paper (Kowalski and Sadri 2014) by including proofs of all the theorems (in the Appendix), extending KELPS to allow more general FOL conditions, simplifying many of the definitions, and including an extensive comparison with related approaches."}, {"heading": "2 KELPS", "text": "The example in Figure 3 illustrates additional features of the language. In this example, the consequent of the rule consists of two alternative plans with deadlines: When an order is received from a reliable customer, then the item needs to be dispatched, and an invoice needs to be sent within 3 time units of receiving the order. Alternatively, an apology needs to be sent within 5 time units. Temporal constraints are defined by an auxiliary theory, which is not presented here. They are solved by means of a constraint solver, as in constraint logic programming (Jaffar and Lassez 1987).\nActions in KELPS can be executed concurrently. Consistency is maintained by monitoring the preconditions of sets of events. In this example, a precondition ensures that the same item is not dispatched to two different customers at the same time. We will see later that preconditions can also be used to prevent sending an apology if the item has already been dispatched.\nThe semantics of KELPS is non-deterministic: It does not matter which alternative plan is chosen. However in practice, some alternatives are better than others. For example, it may be a good strategy to try first a plan with the earliest deadline, and to try later an alternative plan with a later deadline if the earlier plan has failed.\nAny actions performed in the earlier, partially executed plan are committed choices, which cannot be undone by rolling back time. At best, their effects can be undone only by performing compensating actions later in time.\nIn a practical implementation, for most applications, it would be desirable to provide a method to control the choice of alternatives. However, for lack of space, we do not address such control issues in this paper.\nThe operational semantics of KELPS maintains a single current state Si at time i. It reasons with the reactive rules, to generate a set of actions actsi+1, which it combines with a set of external events exti+1, to produce a consistent set of concurrent events evi+1 = exti+1  actsi+1. The events evi+1 are used to update the current state Si, generating the successor state Si+1 = succ(Si, evi+1) by deleting facts that are terminated by the events evi+1 and adding facts that are initiated by evi+1.\nIn KELPS, states are represented by sets of atomic sentences (also called ground atoms, facts or fluents). Events are also represented by atomic sentences. Such sets of atomic sentences can be understood either syntactically as theories or sematically as model-theoretic structures. It is this second, model-theoretic interpretation that underpins the logical semantics of KELPS.\nStates and events can be represented with or without timestamps. The representation without timestamps (e.g. outdoors, reliable(bob)) facilitates destructive updates, because if a fact is not terminated by a set of events then the fact without timestamps simply persists from one state to the next. However, the representation with timestamps (e.g. outdoors(0), reliable(bob, 0)) makes it possible to combine all states and events into a single model-theoretic structure."}, {"heading": "2.1 Vocabulary", "text": "KELPS is a first-order, sorted language, including a sort for time. In the version of KELPS presented in this paper, we assume that time is linear and discrete, and that the succession of timepoints is represented by the ticks of a logical clock, where 1, 2, ... stand for s(0), s(s(0)), \u2026., t+1 stands for s(t) and t+n stands for sn(t). Thus Si represents the state at time i, and evi+1 represents the set of events taking place in the transition from state Si to Si+1. Other representations of time are also possible.\nPredicates: The predicate symbols of the language are partitioned into sets representing fluents, events, auxiliary predicates and meta-predicates:\nFluent predicates represent facts in the states Si. The last argument i of a timestamped fluent atom p(t1, \u2026, tn, i) is a time parameter, representing the time i \u2265\n0 of the state Si to which the fluent belongs. The unstamped fluent atom p(t1, \u2026, tn) is the same atom without this timestamp.\nEvent predicates represent events contributing to the transition from one state to the next. The last argument of a timestamped event atom e(t1, \u2026, tn, i) is a time parameter, representing the time i \u2265 1 of the successor state Si. The unstamped event atom e(t1, \u2026, tn) is the same atom without this time parameter. Event predicates are partitioned into external event predicates and action predicates.\nFluent and event predicates can have time parameters, called reference times, that are not timestamps. For example in deadline(Task, D, T), the time parameter D is a reference time, which expresses that at time T the deadline for Task is D.\nAuxiliary predicates are of two kinds: Time-independent predicates, for example isa(book, item), do not include time parameters. Temporal constraint predicates,\nincluding inequalities of the form T1 < T2 and T1  T2 between timepoints, and functional relationships among timepoints, such as max(T1, T2, T) and min(T1, T2, T) have only time parameters.\nIn KELPS, temporal constraints constrain the timestamps of fluents and events. As a consequence, every temporal constraint in a reactive rule contains at least one time parameter that occurs as a timestamp in a fluent or event atom of the rule.\nIn LPS, auxiliary predicates are defined by logic programs. In KELPS, they are defined more simply by a (possibly infinite) set Aux of atomic sentences. In the case of auxiliary temporal constraint predicates, this assumption is equivalent to the assumption made in the semantics of constraint logic programming (CLP). The KELPS OS exploits this relationship with CLP by using a constraint solver to simplify temporal constraints and to check them for satisfiability.\nThe meta-predicates consist of the two predicates initiates(events, fluent) and terminates(events, fluent), which specify the post-conditions of events and perform state transitions, as illustrated in Figure 2. The first argument is a set of events, to cater for the case where two events together have different effects from the individual events on their own (as when you buy two books and get the cheaper one for half price; or when two people push a heavy object that cannot be moved by one person alone). The second argument is a fluent without timestamps. In LPS, these metapredicates are defined by logic programs. In KELPS, they are defined by atomic sentences1 in a causal theory C, which also contains constraints on the preconditions and co-occurrence of events. 2\nNotation: If Si is a set of fluents without timestamps, representing a single state, then Si* represents the same set of fluents with the same timestamp i. If eventsi is a set of events without timestamps, all taking place in the transition from state Si-1 to state Si, then eventsi* represents the same set of events with the same timestamp i."}, {"heading": "2.2 KELPS Framework", "text": "1 In the examples, in Figure 3 and elsewhere in the paper, we use variables in the definitions\nof auxiliary predicates as a shorthand for the set of all the well-sorted ground instances of\nthe definitions. 2 In some earlier papers, this causal theory was called a \u201cdomain theory\u201d.\nDefinition. A KELPS framework (or program) is a triple <R, Aux, C>, where R is a set of reactive rules, Aux is a set of ground atoms defining auxiliary predicates, and C is a causal theory.\nRules in R are constructed from formulas that represent complex patterns of states and events, expressed as conjunctions of FOL conditions and temporal constraints.\nOperationally, an FOL condition is a query to Aux  Si*  evi*, which is the timestamped state at time i, augmented with the most recent set of events and the definition of the time-independent auxiliary predicates. For example, the FOL condition:\nItem D [manages(M, D, T)  item(Item, D)  instock(Item, T)]\nbehaves as a query that returns managers M all of whose departments D have all of their items Item in stock at time T. The variables Item and D are said to be bound in the condition, and the variables M and T are unbound in the condition. We will see later that, depending where the condition occurs in a reactive rule, the variables M and T will be either universally or existential quantified in the rule.\nDefinition. An FOL condition is an FOL formula containing exactly one timestamp, which is either a constant or a variable, whose atoms are either fluent atoms, event atoms or time-independent auxiliary predicates. If the timestamp is a variable, then it is not bound by any quantifier in the FOL condition.\nDefinition. A complex pattern of states and events (complex for short) is a possibly empty conjunction of FOL conditions and temporal constraints. All time variables in temporal constraints in the complex occur as time parameters in FOL conditions of the complex or are functionally dependent on such time parameters.\nFor example, T3 is functionally dependent on T1 and T2 in max(T1, T2, T3), and T2 is functionally dependent on T1 in plus(T1, 3, T2).\nDefinition. A reactive rule (or simply rule) is a sentence of the form:\nX [antecedent Y [consequent]] where:\n X is the set of all variables, including time variables, occurring in antecedent and not bound in FOL conditions. Y is the set of all variables, including time\nvariables, occurring only in consequent and not bound in FOL conditions.\n consequent is a disjunction consequent1  ... consequentn.  antecedent and each antecedent  consequenti is a complex.  For every substitution  that replaces the time variables in X and Y by ground\ntimes and such that the temporal constraints in antecedent  and consequent \nare true in Aux, all timestamps in FOL conditions in consequent  are later than\nor equal to all timestamps in FOL conditions in antecedent .\n Every temporal constraint in consequenti contains at least one timestamp variable that occurs in an FOL condition in consequenti or is functionally dependent\non such timestamp variables.\nIntuitively, the next-to-last bullet restricts reactive rules to ones whose antecedent is a conjunction of FOL conditions about the past or present and whose consequent is a disjunction of conjunctions of FOL conditions about the present or future. The last bullet prevents such rules as p(T1) q(T2) T1<10  T1<T2, with a constraint T1<10 in the consequent that only constrains a timestamp in the antecedent.\nBecause of the restrictions on quantifiers, and because of the logical equivalence\nY [p  q]  Y p  Z q, we can omit the quantifiers X and Y, and simply write antecedent  consequent or antecedent  consequent1 ... consequentn. Variables that are unbound in an FOL condition become bound either universally or existentially, depending on where the condition occurs in a rule. For example, if the condition Item D [manages(M, D, T)  item(Item, D)  instock(Item, T)] occurs in the antecedent of a rule, then M and T are bound by the universal quantifiers of the rule. If the condition occurs in the consequent of a rule, and M and T do not occur in the antecedent of the rule, then M and T are bound by the existential quantifiers of the consequent of the rule. To avoid ambiguity, if an FOL condition is the consequent of a rule with an empty antecedent, then we write the rule in the form\ntrue  consequent. Note that, in the operational semantics, all the components of an FOL condition\nare evaluated together in Aux  Si*  evi*. Several such FOL conditions can be evaluated at the same time i, if their timestamps can all be unified to time i. Note also that, if antecedent is empty, then antecedent is equivalent to true. If consequent is empty, then consequent is equivalent to false.\nAn FOL condition that contains an action atom can be evaluated in Aux  Si* \nevi*, like any other FOL condition. However, an action atom act that is a conjunct of an FOL condition of the form3 conjunct1  act  conjunct2 in the consequent of a rule can also be selected as a candidate for execution in the transition to the next state Si+1. Such action atoms are called bare action atoms.\nDefinition. Let consequenti of a rule be of the form conjunct1  act  conjunct2 where act is an action atom, then act is a bare action atom in consequenti.\nState transitions are performed by means of a causal theory, which imposes preconditions on sets of events and defines the postconditions of sets of events.\nDefinition. A causal theory, C = Cpost  Cpre, consists of two parts: Cpost is a set of atomic sentences defining the predicates initiates and terminates. Cpre is a set of sentences of the form current(T-1)  events(T) false, where current(T-1) is a (possibly empty) FOL condition with timestamp T-1, events(T) is a non-empty FOL condition with timestamp T containing no fluents, and all variables not explicitly bound in FOL conditions are implicitly universally quantified.\nThe syntax of Cpre allows the specification of such typical preconditions for the execution of a single action as:\n3 For simplicity we say that a formula has a particular form when we mean that the formula\ncan be rewritten into that form simply by reordering conjunctions and disjunctions, taking commutativity and associativity into account.\n\u00ac in-stock(Item, T-1)  dispatch(C, Item, T)  false\nwhere in-stock(Item) is a fluent, initiated and terminated by such actions as stock(Item) and dispatch(C, Item), respectively. The syntax of Cpre also allows the prohibition of such concurrent sets of events as:\ndispatch(C1, Item, T)  dispatch(C2, Item, T)  C1  C2  false\nIt is also possible to specify that certain actions must co-occur:\nleave-house(T)  \u00ac take-keys (T)  false.\nIn the example of Figure 3, sending an apology if an item has already been dispatched or is being dispatched can be prevented by means of the preconditions:\ndispatched(C, Item, T)  send-apology(C, Item, T)  false\ndispatch(C, Item, T)]  send-apology(C, Item, T)  false\nwhere dispatched(C, Item) is a fluent initiated by the action dispatch(C, Item).\nThe use of atomic sentences to define the predicates initiates and terminates is similar to the use of add-lists and delete-lists in STRIPS (Fikes and Nilsson 1972). However, it is more general, because the first argument of both predicates is a set of events. Defining the fluents initiated and terminated by sets of concurrent events explicitly by means of atomic sentences is not very practical, but it clarifies the model-theoretic semantics and simplifies the operational semantics. Moreover, it paves the way for the more practical representation in which initiates and terminates are defined by logic programs in LPS."}, {"heading": "3 The KELPS Model-theoretic Semantics", "text": "In the model-theoretic semantics of KELPS, the truth values of the rules R and the preconditions Cpre are defined according to the standard, non-modal semantics of classical first-order logic. This contrasts with the semantics of modal logics, in which states are represented by possible worlds, linked by accessibility relations.\nIn the operational semantics of KELPS, states are updated by adding and deleting\nfluents. Fluents that are not affected by the update are left untouched:\nDefinition. If <R, Aux, C> is a KELPS framework, S is a set of unstamped fluents, representing a single state, and ev is a set of unstamped events, representing concurrent events, then the associated successor state is:\nsucc(S, ev) = (S \u2013 {p | terminates(ev, p)  Cpost })  {p | initiates(ev, p)  Cpost}.\nIn the model-theoretic semantics, fluents and events are all timestamped, so they can\nbe included in a single model-theoretic structure M = Aux  S*  ev*:\nNotation. If S0 is an initial state, ext1, \u2026 , exti, \u2026, is a sequence of sets of external events and acts1, \u2026 , actsi, \u2026 is a sequence of sets of actions, then:\nS* = S0*  \u2026  Si*  \u2026 where Si+1 = succ(Si, evi+1) ev* = ev0*  \u2026  evi*  \u2026 where ev0 = {} and evi = exti  actsi, for i 1.\nComputation in a conventional reactive system consists in generating a stream act1,\u2026, acti,\u2026 of actions in response to a stream ev1,\u2026 evi,\u2026. of external events and previously generated actions. Computation in KELPS is similar, but it has a purpose, namely to make the reactive rules and the preconditions of actions true:\nDefinition. Given a KELPS framework <R, Aux, C> and initial state S0, the computational task is, for every i \u2265 0, and for every sequence ev0 \u2026 evi of sets of external events and previously generated actions, to generate a set actsi+1 of actions such that R  Cpre is true in the Herbrand interpretation M = Aux  S*  ev*.\nThe definition of truth for reactive rules is the classic definition for sentences of FOL. As a consequence, the computational task allows the generation of actions that make the rules true by making their antecedents false, or by making their consequents true whether their antecedents are true or false. It also allows the performance of actions that are irrelevant to the task. These kinds of \u201cpreventative\u201d, \u201cproactive\u201d or \u201cirrelevant\u201d actions cannot be generated by conventional reactive systems. Nor can they be generated by KELPS. In this paper, we identify the kind of reactive models that are generated by the KELPS operational semantics.\nNote that in KELPS the generated actions actsi+1 need not be a direct reaction to\nthe current situation Si*  evi*. They can be a partial response to earlier situations."}, {"heading": "3.1 Herbrand interpretations", "text": "The semantics of Herbrand interpretations is a simplified version of the standard semantics of first-order logic.\nDefinition. Given a sorted first-order language, the Herbrand universe U is the set of all well-sorted ground (i.e variable-free) terms that can be constructed from the non-empty set of constants and function symbols of the vocabulary. The Herbrand base is the set of all well-sorted ground atoms that can be constructed from the predicate symbols and the ground terms of the vocabulary. A Herbrand interpretation is a subset of the Herbrand base. A Herbrand model M of a set S of sentences is a Herbrand interpretation such that every sentence in S is true in M.\nOne difference from the standard definition of truth is the base case: If I is a Her-\nbrand interpretation, then a ground atom A is true in I if and only if A  I. The other difference is the definition of truth for universally and existentially quantified sen-\ntences: A sentence of the form X s(X) is true if and only if for all t  U, where t\nhas the same sort as X, the sentence s(t) is true. Similarly, X s(X) is true if and only\nif for some t  U, where t has the same sort as X, the sentence s(t) is true. For this to be sensible, the Herbrand universe U needs to be non-empty, as in the standard definition of truth.\nThus, a ruleX [antecedent Y [consequent1  ... consequentn]] is true in I if and only if, for every ground instance antecedent  that is true in I, there exists a ground instance consequenti   that is also true in I. Here the substitutions  and  replace the variables X and Y, respectively, by terms of the appropriate sort in the Herbrand universe U. For simplicity, we assume that, except for time parameters, all fluents have the same ground instances over U in all states."}, {"heading": "3.2 The temporal structure of KELPS interpretations", "text": "The timestamping of fluents and events, and the restrictions on the syntax of KELPS provide Herbrand interpretations of KELPS programs with a rich structure of subinterpretations. This structure is captured by the following theorem, which is an immediate consequence of the definition of truth.\nTheorem 1. Given a KELPS framework <R, Aux, C>, initial state S0, and sequence of sets of events ev0 \u2026 evi: 1. If s is a conjunction of temporal constraints whose time parameters are all\nground, then s is true in Aux  S*  ev* if and only if s is true in Aux.\n2. If s is a conjunction of FOL conditions and temporal constraints whose time parameters are all ground, then:\na. If all the timestamps in s are the same time i,\nthen s is true in Aux  S*  ev* if and only if s is true in Aux  Si*  evi*.\nb. If i is the latest timestamp in s, then s is true in Aux  S*  ev*\nif and only if s is true in Aux  S0*  ... Si*  ev0*  ...  evi*.\nThere is an obvious similarity with the possible world semantics of modal logic.\nEach Aux  Si*  evi* is similar to a possible world, and the single interpretation Aux  S*  ev* is similar to a complete frame of possible worlds and accessibility relations. In the possible world semantics, fluents belong to possible worlds, and events belong to accessibility relations. But in KELPS, all fluents and events are\ntimestamped and contained in the single interpretation M = Aux  S*  ev*."}, {"heading": "3.3 Sequencing", "text": "The temporal constraints of a complex impose a partial order on the timestamps of the FOL conditions in the complex. Although these timestamps are partially ordered, the complex is used to recognize or generate linearly ordered sequences of states satisfying the FOL conditions of the complex.\nIt is useful to have a notation in the meta-language that distinguishes between the different sequences represented by the same complex. This notation is not part of the KELPS object language, but is useful for defining reactive interpretations and the operational semantics of KELPS. Intuitively, a sequencing of the form earlier < later means that the FOL conditions in earlier can be evaluated (recognised or generated) before the FOL conditions in later.\nDefinition. Let earlier and earlier  later be complexes.4 Then earlier  later has a\nsequencing of the form earlier < later (or of the form earlier  later) if and only if\nthere exists a substitution  for all the time variables in earlier  later such that:\n all the temporal constraints in earlier   later  are true in Aux\n all the timestamps in FOL conditions in earlier  are earlier than (or earlier than\nor equal to) all the timestamps in FOL conditions in later .\nNotice that both p(T) < true and true < p(T) are allowed sequencings of p(T). For\nexample, the complex p(T1) q(T2) has the strict sequencings: p(T1) < q(T2), q(T2) < p(T1), true < p(T1)  q(T2) and p(T1)  q(T2) < true. In some of our earlier papers, we allowed actions selected for execution to contain non-timestamp variables. These variables are instantiated, when they are successfully executed, as feedback from the environment. In this paper, we restrict the selection of actions to ones that have no such variables. For this purpose, we require KELPS frameworks to be range-restricted:\nDefinition. A KELPS framework <R, Aux, C> is range restricted if and only if, for every bare action atom act containing non-timestamp variables in a rule in R of the\nform antecedent  [other  [earlier  act  rest]], there is a sequencing anteced-\nent  earlier < act  rest such that all the non-timestamp variables in act occur in antecedent or earlier."}, {"heading": "3.4 Reactive interpretations", "text": "Figure 1 and Figure 2 exemplify different kinds of models of a KELPS program. The following definition characterizes reactive interpretations and models. Loosely speaking, an action occurs in a reactive interpretation if and only if it occurs as a bare action atom in one of the alternative consequents of an instance of a reactive rule, and all earlier FOL conditions in the antecedent and the alternative consequent of the instance of the rule are already true in the interpretation before the time of the action.\nDefinition. Given a range restricted KELPS framework <R, Aux, C>, initial state S0 and set ev* of timestamped events, let Cpre be true in I = Aux  S*  ev*, and let ev* = ext*  acts* be a partitioning of ev* into external events ext* and actions\nacts*. Then I is reactive if and only if, for every action action  I, there exists a rule\nr  R of the form antecedent  [other  [earlier  act  rest]], and there exists a substitution  such that r  supports action, in the sense that:\na) action is act \nb) antecedent   earlier  < act   rest \nc) antecedent   earlier   act  is true in I.\nI is a reactive model of <R, Aux, C> if and only if I is a reactive interpretation and R is true in I.\n4 It is not sufficient to require later to be a complex because we want to allow later to have temporal constraints with time variables occurring in earlier.\nNote that condition (b) allows rest  to be false in I."}, {"heading": "4 The KELPS Operational Semantics", "text": "The operational semantics exploits the internal structure of KELPS interpretations\nAux  S*  ev* to generate them by progressively extending a partial interpretation\nAux  S0*  ... Si*  ev0*  ... evi* one step at a time. Moreover, it does so by maintaining only the unstamped current state Si and the events evi that gave rise to Si, without remembering earlier states and events.\nTo recognise complex sequences of states and events in the antecedents of rules without remembering past states and events, the OS maintains a current set of partially evaluated rules Ri, which need to be monitored in the future. For example, suppose that Ri that contains the rule:\ncry-wolf(T)  \u00achelp-arrives(T+1)  cry-wolf(T+2)\nand that evi* contains the event occurrence cry-wolf(i). Then the OS evaluates the condition cry-wolf(T) in the augmented current state and adds to Ri the new rule:\n\u00achelp-arrives(i+1)  cry-wolf(i+2)\nThe OS also maintains a goal state Gi containing partially evaluated alternative plans to be made true in the future. For example, if evi+1* does not contain the event occurrence help-arrives(i+1), then the OS evaluates \u00achelp-arrives(i+1) in the augmented current state to true, and adds to Gi+1 the new, top-level goal cry-wolf(i+2).\nLogically, a goal state Gi is a conjunction Gi1  ...  Gin, where each Gij is a disjunction of partially evaluated alternative plans for making true the consequent of an instance of a rule whose antecedent has already become true. To be more precise,\neach disjunct in Gij is the instantiated remainder later  of a rule antecedent  [other  [earlier  later]] in R whose earlier part antecedent   earlier  is al-\nready true in the partial interpretation Aux  S0*  ... Si*  ev0*  ... evi* generated so far. Because of their similarity to goal clauses in logic programming, such\ndisjuncts later  are also called goal clauses in KELPS. Operationally, the goal state Gi is a set (conjunction) of independent threads Gij, and each thread is a goal tree. The root node is the instantiated consequent of a rule whose antecedent has already become true. The non-root nodes are goal clauses. The goal tree representation helps to structure the search space of alternative plans, and to guide the search for alternatives. If the goal trees are searched in a depth-first fashion, then they can be implemented by stacks, as in Prolog. Backtracking is possible, but previously generated actions and states cannot be undone.\nThe following abstract specification of the OS ignores many optimizations that can improve efficiency. These are described in (Kowalski and Sadri 2010, 2011, 2012, 2014). Some of these optimizations restrict the models that can be generated, and hence affect the relationship between the interpretations generated by the OS and the interpretations sanctioned by the definition of reactive interpretation.\nIn the following definition, the OS is presented as an agent cycle. At the end of each cycle, external events are input and combined with selected actions. The result-\ning combined set of events is used to update the current state. In other versions of the OS, these updates were performed at the beginning of the cycle.\nDefinition. The OS Cycle. Given a range restricted KELPS framework <R, Aux, C> and an initial state S0, let ev0 = {}. Let G0 be the goal state obtained by creating, for every rule r in R of the form true  consequent, a goal tree with consequent at the root, and adding each disjunct of consequent whose constraints are satisfiable in Aux as a child of the root. Let R0 be R without these rules.\nFor i \u2265 0, given Si, Ri, Gi and evi, the i-th cycle consists of the following steps:\nStep 1. Evaluate antecedents. (a) For every sequencing current  < later  of the\nantecedent of an instance r of a rule r of the form current  later consequent in Ri, where current is a non-empty complex, add later   consequent  as a new reactive rule to Ri, if: 1. current  is true in Aux  Si*  evi*, 2.  instantiates all and only the variables in current, 3.  instantiates all the variable timestamps in FOL conditions in current to i, 4. current contains all the temporal constraints in the antecedent of r that become true in Aux as the result of evaluating the FOL conditions in current. (b) If later  is empty (equivalent to true) then delete later   consequent  from\nRi and start a new thread in Gi with consequent  at the root. Add each disjunct of consequent  whose constraints are satisfiable in Aux as a child of the root.\nStep 2. Evaluate goal clauses. Choose a set of sequencings current  < later  of instances C of goal clauses C, where current is a non-empty complex, from one or more threads in Gi. For each such choice, add later  to Gi as a child of C, if:  current is true in Aux  Si*  evi*, 2.  instantiates all and only the variables in current,\n3.  instantiates all the variable timestamps in FOL conditions in current to i, 4. current contains all the temporal constraints in C that become true in Aux as the result of evaluating the FOL conditions in current.\nStep 3. Choose candidate actions. Choose a set of sequencings actions \u03c4  rest \u03c4 of instances C \u03c4 of goal clauses C from one or more threads in Gi, where \u03c4 instantiates all and only the timestamp variables in actions to i+1, and actions \u03c4 is the conjunction of all the ground bare action atoms in C \u03c4 that have the timestamp i+1. Let candidate-actsi+1 be the set of all the action atoms in all such actions \u03c4.\nStep 4. Update Si, Gi, Ri. Choose 5 a subset actsi+1*  candidate-actsi+1 such that Cpre is true in Aux  Si*  evi*  evi+1*, where evi+1* = exti+1*  actsi+1* and the external events exti+1* are given. Let Si+1 = succ(Si, evi+1), Gi+1 = Gi and Ri+1 = Ri.\n5 Note that if an action act in a goal clause C is selected in step 3 and is successfully executed\nin step 4, then C is a candidate to be selected in step 2 of the next cycle, and act is a candidate to be selected for evaluation to true in C. Moreover, other occurrences of act in other goal clauses can be evaluated to true in the same cycle, even if they were not selected in step 3 of the previous cycle.\nNote that the OS can attempt to make an instance of a consequent of a reactive rule true even though the same instance of the consequent has already been made true. This can be avoided easily in the OS, by adding an extra case (b) to step 2, analogous to case (b) of step 1, but would make the corresponding definition of reactive interpretations more complex. However, there are other optimisations that can be made to the OS, without affecting the definition of reactive interpretation. These optimisations include removing from Ri rules whose antecedents are timed out, and removing from Gi goal clauses containing a fluent or event atom that is timed out."}, {"heading": "5 Relationships between the Model-theoretic and the Operational Semantics", "text": "The proof of soundness for the OS of LPS (Kowalski and Sadri 2010, 2011, 2014), also applies to KELPS, and details of the proof are given in the appendix:\nTheorem 2. Soundness. Given a KELPS framework <R, Aux, C>, initial state S0 and sequence ext1,\u2026, exti,\u2026 of sets of external events, suppose that the OS generates the sequences of sets acts1,\u2026, actsi,\u2026 of actions and S1,\u2026, Si,\u2026 of states. Then R  Cpre is true in I = Aux  S*  ev* if, for every goal tree that is added to a goal state Gi, i \u2265 0, the goal clause true is added to the same goal tree in some goal state Gj, j \u2265 i.\nThe following theorem characterises the interpretations generated by the OS. It is a correctness result for reactive interpretations. The detailed proof is in the appendix.\nTheorem 3. Every interpretation generated by the OS is reactive. Given a range restricted KELPS framework <R, Aux, C>, initial state S0 and set of external events ext*, let acts* be the set of actions generated by the OS, and ev* = ext*  acts*.\nThen I = Aux  S*  ev* is a reactive interpretation.\nProof Sketch: Here is a sketch of the proof for the case where all variables in X and Y in rules X [antecedent Y [consequent]] have been replaced by all their ground instances, and all the resulting ground temporal constraints have been evaluated, so that the resulting rules no longer contain any temporal constraints:\nTo show that any action generated by the OS is supported, we show more generally that, if a goal clause C is in a goal state Gi, where i \u2265 0, then there exists a rule in R of the form antecedent  [other  [earlier  C]] such that earlier < C and\nantecedent and earlier are true in Aux  S0*  ...  Si*  ev0* \u2026  evi*.\nIf an action act is generated by the OS, then it belongs to some actsi+1, i \u2265 0, and act is selected as a candidate in step 3 at time i from a goal clause in Gi that has a sequencing act \u2264 rest. It follows that r supports act, and I is supported.\nThe following theorem is a kind of completeness result for reactive interpretations. The detailed proof is in the appendix.\nTheorem 4. Every reactive interpretation can be generated by the OS. Given a range restricted KELPS framework <R, Aux, C>, initial state S0 and external events ext*, let acts* be a set of actions such that I = Aux  S*  ev*, where ev* = ext*\n acts*, is a reactive interpretation. Then there exist choices in steps 2, 3 and 4 such that the OS generates acts* (and therefore generates I).\nProof Sketch: Here is a sketch for the case where all the variables X and Y in rules X [antecedent Y [consequent]] are replaced by their ground instances, and all temporal constraints have been evaluated:\nLet acti  acts* be an action at time i supported by a rule r  R. Then r has the\nform antecedent  [other  [early  acti  rest]], where antecedent  early is true in Aux  S0*  ...  Si-1*  ev0* \u2026  evi-1*. It suffices to show that Gi contains a goal clause of the form acti  rest, because then the OS can choose candidate actions in step 3 and a combination evi* = exti*  actsi*, of external events and candidate actions in step 4, such that actsi* is the set of all such actions acti.\nTo show that Gi contains a goal clause of the form acti  rest, we show more generally that for all times k  i, and for all r  R that support an action in actsi* there exist choices in steps 2, 3 and 4 such that either:\n r has the form antecedent [other  [early  late]] where late is in Gk and\nantecedent  early is true in Aux  S0*  ...  Sk-1*  ev0* \u2026 evk-1* or\n r has the form earlier later  consequent, where later  consequent is in Rk\nand earlier is true in Aux  S0*  ...  Sk-1*  ev0* \u2026  evk-1*.\nFrame axioms. Most logic-based causal theories in AI employ frame axioms to represent and reason about change of state. These frame axioms represent the property that a fluent persists from one state to the next, unless it is terminated by the events that give rise to the state transition. They are used either to reason forwards to copy fluents unchanged from one state to the next, or to reason backwards to determine whether a fluent holds in a state by determining whether holds in the previous state. The use of destructive assignment in LPS and KELPS avoids these computationally expensive forms of reasoning.\nIn (Kowalski and Sadri 2015), we show that frame axioms are an emergent property of the LPS operational semantics. This is analogous to showing, for example, that associativity of addition is an emergent property of a program that computes addition. The proof for LPS also applies to KELPS. In fact, the proof does not depend on the OS, but only on the definition of succ(Si, evi+1):\nTheorem 5. Frame axioms are an emergent property. Given definitions Cpost of the predicates initiates and terminates, initial state S0 and sequence of sets of concurrent events ev1, \u2026, evi, ..., let I = Cpost  S*  ev*, where:\nS* = S0*  \u2026  Si*  \u2026 where Si+1 = succ(Si, evi+1) and ev* = ev1*  \u2026  evi*  \u2026.\nThen for all evi +1, i \u2265 0 and fluents p, the following sentence is true in I:\n[initiates(evi+1, p)  p(i+1)] \n[p(i)  \u00ac terminates(evi+1, p)  p(i+1)]"}, {"heading": "6 Related Work", "text": "The development of KELPS/LPS has been influenced by work in many different areas of computing, including programming, databases and artificial intelligence. To\nmake the task of comparison with related work more manageable, we focus primarily on comparing KELPS/LPS with other approaches that attempt to give a logical semantics to rule-based systems. Our earlier papers (Kowalski and Sadri 2009, 2010, 2011, 2012, 2014, 2015) include extensive comparisons between LPS and many of these systems. In this paper, we relate the earlier comparisons with KELPS, and include other related work."}, {"heading": "6.1 LPS", "text": "First, we need to clarify the relationship between KELPS and LPS. Consider, for example, a reactive rule in LPS, which expresses a robot\u2019s goal of replying with a sentence to any sentence said by an agent called \u201cturing\u201d:\nsentence(turing, T1, T2) sentence(robot, T3, T4)  T2 < T3 < T2 + 3 sec\nHere the predicate sentence represents a composite event or action with its start and end times. In LPS, the predicate can be defined by a logic program, which can be used both to recognize and to generate sentences. The logic program could include, among other clauses defining the predicates np and vp, such clauses as:\nsentence(Agent, T1, T3) np(Agent, T1, T2)  vp(Agent, T2, T3) adj(Agent, T, T+1) say(Agent, human, T, T+1) noun(Agent, T, T+1) say(Agent, human, T, T+1)\nHere say represents a primitive event with its start and end times, In KELPS, such a primitive event is represented more simply with only its end time.\nIn KELPS, it is possible to get a similar effect to LPS, by replacing the one rule\nby infinitely many rules, including for example the rule:\nsay(turing, i, 2)  say(turing, am, 3)  say(turing, human, 4)\n say(robot, you, 6)  say(robot, are, 7)  say(robot, intelligent, 8)\nThis is neither practical nor desirable, which is why LPS has both reactive rules and logic programs. As far as we know, other than CHR (section 6.4), there is no other language not derived from ALP that combines reactive rules and logic programs, but retains their separate character. Most languages that have only reactive rules simulate logic programs by treating goals as facts. Most approaches that give a logical semantics to reactive rules translate them into logic programs.\nIn this paper, we have restricted our attention to reactive rules in KELPS only\nbecause it simplifies and clarifies the investigation of completeness."}, {"heading": "6.2 Abductive Logic Programming (ALP) and the Event Calculus", "text": "LPS (and therefore KELPS) originated in our earlier work on ALP (Fung and Kowalski 1997; Kakas et al 1998) and ALP agents (Kowalski and Sadri 1999, 2009; Kowalski 2011). ALP extends logic programming by allowing certain predicates (called abducible or open predicates) to be assumed in order to solve a problem. These assumptions are restricted by means of integrity constraints. In ALP agents,\nthe abducible predicates represent actions, and the integrity constraints include reactive rules. The main difference is that KELPS/LPS uses destructive updates for state transitions, whereas ALP agents use the event calculus (Kowalski and Sergot 1986). Although the event calculus has been viewed as solving the frame problem (Shanahan 1997), we believe that it cannot compete for practical applications with destructive change of state. However, destructive change of state does not have an obvious logical semantics. In particular, if states are axiomatic theories, which are syntactic objects, then destructive change of state is problematic, because it is not possible to change the axioms during the course of trying to prove a theorem.\nKELPS/LPS retains the ontology of the event calculus but replaces explicit reasoning with event calculus axioms by implicit construction of timestamped Herbrand interpretations. As a consequence, KELPS/LPS can generate only reactive models. In contrast, the use of the event calculus in ALP agents can also generate preventative and proactive models.\nLPS inherits from ALP the property that models can contain irrelevant actions. In ALP, irrelevant actions can be avoided by minimizing the set of actions contained in a model. In LPS, the generation of irrelevant actions is reduced by generating only reactive interpretations, which contain only actions that are instances of action atoms that occur explicitly in the consequents of reactive rules."}, {"heading": "6.3 MetateM", "text": "To the best of our knowledge, MetateM (Barringer et al 1996) is the only other framework not based on ALP that describes state transitions by reactive rules in logical form and that treats computation as model generation. Programs in MetateM consist of sentences in modal temporal logic of the form:\n\u2018past and present formula\u2019 implies \u2018present or future formula\u2019\nComputation consists in generating a model in which all such sentences are true. MetateM does not formally distinguish between events and fluents, and does not have an explicit causal theory, but frame axioms and other logic programs are written, as needed, in the form of reactive rules.\nLike KELPS, MetateM lacks the logic programs of LPS. The main differences are that, in KELPS, time is represented explicitly, models are classical rather than modal, and models are constructed by means of destructive updates. In LPS, there is the further difference that logic programs are separate from and additional to reactive rules.\n(Barringer et al 1996) presents an operational semantics for propositional MetateM without external events. Despite the claim (on page 148) that the MetateM OS is complete, our examples of non-reactive models for KELPS can be translated into MetateM, and show that the MetateM OS can generate only reactive models, and therefore is incomplete."}, {"heading": "6.4 Constraint Handling Rules (CHR)", "text": "Closer to LPS in syntactic structure and expressive power is the language CHR (constraint handling rules) (Fr\u00fchwirth 1998, 2009). As in LPS, there are two kinds of rules: equivalences and propagation rules. Equivalences can be used like ordinary\nlogic programs, but can also be used for simplification. Propagation rules are logical implications, which are used to reason forward, like reactive rules in KELPS. CHR (Abdennadher and Sch\u00fctz 1998) extends CHR to include disjunctions in the consequents of propagation rules, more like reactive rules in KELPS.\nThe operational semantics of propagation rules in CHR is similar to that of KELPS, and the operational semantics of propagation rules and equivalences is similar to that of LPS. CHR has a classical logic semantics, in which computation is interpreted as theorem-proving, similar to that of the IFF proof-procedure (Fung and Kowalski 1997). This semantics does not justify destructive updates. But CHR also has a translation into linear logic (Betz and Fr\u00fchwirth, 2005), which justifies destructive updates in the style of LPS, but without the use of timestamps.\nThe linear logic semantics of CHR is very different from the model-theoretic semantics of KELPS/LPS, in which time is represented explicitly, and state transitions are performed by means of a causal theory. Although propagation rules are similar to reactive rules, it is not clear how the completeness and incompleteness of the KELPS/LPS OS relate to the completeness results for CHR/ CHR."}, {"heading": "6.5 Production systems (PS)", "text": "Production systems are computer languages in which programs are sets of sentences of the form if conditions then actions. State transitions are performed by evaluating the conditions in the current state and executing the corresponding actions, performing \u201cconflict resolution\u201d to choose between conflicting actions. The chosen actions destructively update the current state.\nIt was the attempt to understand the logic of production systems and their relationship with logic programs that led to the development of LPS (which explains the PS in LPS). Several other authors have also attempted to provide production rules with a logical semantics, mostly by mapping them into logic programs. Raschid (1994), in particular, transforms production rules into logic programs, and uses the fixed point semantics of logic programming to perform forward chaining. Baral and Lobo (1995), on the other hand, translate production rules into the situation calculus represented as a logic program with the stable model semantics.\nMore recently, Dam\u00e1sio et al 2010) use incremental Answer Set Programming (ASP) to realize different conflict resolution strategies for the RIF-PRD production system dialect. Eiter et al. (2012) simulate production systems in ASP with an interface to an external environment, performing state changes by updating and accessing the environment via action atoms and external atoms. Gebser et al. (2011) use disjunctive logic programs (but without existential quantifiers) to represent reactive rules in ASP, for \u201creasoning about real-time dynamic systems running online in changing environments\u201d.\nTo the best of our knowledge, none of these mappings into logic programs per-\nform destructive updates in the manner of production systems and KELPS/LPS.\nIn contrast with these approaches, KELPS/LPS reformulates production rules as reactive rules, and not as logic programs. In LPS, logic programs are like \u201cdeductive\u201d databases, and reactive rules are like database integrity constraints."}, {"heading": "6.6 Integrity Constraints", "text": "The model-theoretic semantics of KELPS, which is fundamental to the investigation of completeness in this paper, is based upon the model-theoretic semantics of integrity constraints in deductive databases and ALP. However, from a historical perspective (Kowalski 2014), the model-theoretic semantics is only one of two main alternatives. The other alternative is the theorem-hood view, in which integrity constraints (and queries) are meant to be theorems that are a logical consequence of the database regarded as a theory.\nIn the parallel world of logic programming, there has been a shift away from the theorem-proving view of computation to a model-generation view. Our own work on the semantics of KELPS/LPS has followed this shift from theorem-proving to model-generation. In LPS, the semantics of logic programs (Kowalski and Sadri 2015) is in the spirit of the well-founded semantics (Van Gelder et al, 1991). But in the case of KELPS, the role of logic programs is played more simply by sets of ground atoms, which are equivalent to relational databases.\nReactive rules in KLEPS/LPS are similar in syntax to integrity constraints in the form of disjunctive tuple-generating dependencies in relational databases (Wang et al. 2001). But, whereas in relational databases the main focus has been on the problem of deciding whether a given set of tuple-generating dependencies logically implies another dependency, in KELPS/LPS the focus is on generating a model that makes integrity constraints in the form of reactive rules R and preconditions Cpre true.\nIn recent years, most of the activity in deductive databases has become associated with Datalog, in which databases are logic programs without function symbols. Datalog\u00b1 (Cal\u00ec et al. 2009) extends Datalog with existential rules, which are similar in syntax to reactive rules in KELPS/LPS (but without disjunctive consequents), and which can similarly be viewed as integrity constraints. However, whereas reactive rules and logic programs are separate components of LPS, in Datalog\u00b1 logic programs are a special case of existential rules. So in effect, Datalog\u00b1 does not distinguish between the database and integrity constraints. Moreover, it deals only with one database state at a time, and does not deal with database updates.\nDatalog\u00b1 generates answers to queries by using a bottom-up procedure, called the chase (Maier et al, 1979), which is also used in (Wang et al. 2001). Gavanelli et al (2015) map Datalog\u00b1 into ALP, and show how the SCIFF proof procedure Alberti et al. 2008), which extends the IFF proof procedure of (Fung and Kowalski, 1997) generates the same answers as the chase procedure. The IFF proof procedure, in turn, is one of the progenitors of the KELPS/LPS OS.\nThe IFF proof procedure, in turn, is similar to the SATCHMO proof procedure (Manthey and Bry, 1988) for the full clausal form of first-order logic. SATCHMO is a bottom-up procedure, which can be viewed both as a resolution-based theoremprover and as a model-generator."}, {"heading": "6.7 Transaction Logic", "text": "Transaction Logic (TR) (Bonner and Kifer 1993) is a logic-based formalism for defining transactions, which are similar to complex plans in KELPS/LPS, and which similarly update states of a logic program or database. Transactions in TR have a logical, model-theoretic semantics, which, like the possible world semantics of\nmodal logic, is based on sets of possible worlds (or states). But unlike modal logic, the truth value of a transaction is defined along a path of states, starting with the state at the beginning of the transaction and ending with the state at the end of the transaction. As in KELPS/LPS, state transitions are performed by means of destructive updates. Although there is no direct analogue of the reactive rules of KELPS/LPS, they can be simulated by transactions. Rezk and Kifer (2012) use such a simulation to give a logic-based semantics to a production system language.\nKELPS shares with TR the view of computation as making a goal true by generating a sequence of destructively updated states. Moreover, the inclusion of FOL conditions in KELPS/LPS was largely inspired by similar FOL conditions in TR transactions. The main differences are that, in KELPS, transactions are the consequents of reactive rules that are triggered when the antecedents become true, time is represented explicitly, and all states, actions and events are combined into a single modeltheoretic structure.\nTRev (Gomes and Alferes 2014) extends TR by combining the generation of complex transactions with the recognition of complex events. As a consequence, its expressive power is similar to KELPS, but it represents complex events and complex transactions separately, without combining them into reactive rules that are logical implications."}, {"heading": "6.8 Active Databases", "text": "A number of researchers have attempted to develop logic-based semantics for active databases. The majority of these approaches map reactive rules in the form of eventcondition-action (ECA) rules into logic programs. For example, both Zaniolo (1993) and Lausen et al. (1998) use frame axioms similar to those in Theorem 5, and reduce ECA rules to logic programs such as action(T+1) condition(T)  event(T+1). Fernandes et al. (1997) give separate logical formalisations of events, conditions and actions, but without combining them into reactive rules that are logical implications.\nLike production systems, and unlike KELPS/LPS, active databases are restricted to rules whose antecedents query the current state, and whose consequents update the current state."}, {"heading": "6.9 Agent Languages", "text": "Bailey et al. (1995) argue that, although they differ in their intended applications and research communities, many agent languages developed in AI are similar to active database systems. In particular, agent plans in BDI agents are similar to ECA rules in active databases. Moreover, both BDI agents and active databases maintain a destructively updated database state, and lack a declarative semantics.\nLPS is a direct descendant of ALP agents, which embed ALP in the thinking component of a BDI-like agent cycle. In ALP agents, a logic program represents the agent\u2019s beliefs, and initial goals and integrity constraints represent the agent\u2019s goals (or desires). The database is updated by using the event calculus, using frame axioms. The ALP agent approach was developed further in the KGP agent model (Mancarella et al. 2009). In contrast, the operational semantics of LPS employs a destructively updated database, which represents the current state.\nThe destructive updates of LPS were inspired in part by their use in BDI-agent languages such as AgentSpeak (Rao 1996). Programs in AgentSpeak are collections of statements of the form:\nevent E: conditions C  goals G and actions A.\nThe event E can be the addition or deletion of a belief literal or a goal atom, stored in a database. The conditions C query the database, and the goals G and actions A update the database by adding or deleting goals and beliefs. As a result, plans combine some of the functionality of both reactive rules and logic programs in LPS. However, they do not allow complex events in the event or conditions part of plans, and they do not include temporal constraints. Moreover, they do not a have a logical\nsemantics. In fact, when E is the addition of a belief literal, the arrow  is opposite to the arrow of logical implication in KELPS/LPS.\nA number of authors have also developed agent languages and systems in a logic programming context. For example in DALI (Costantini and Tocchio 2014) and EVOLP (Brogi 2002) events transform an initial agent logic program into a sequence of logic programs. ERA (Alferes et al. 2006) extends EVOLP with complex events, complex actions, and event-condition-action rules. The semantics of the evolutionary sequence of logic programs in DALI, EVOLP and ERA is given by an associated sequence of models. In ERA, ECA rules are translated into logic pro-\ngrams of the form action condition  event. In contrast, KELPS/LPS distinguishes between the semantics of logic programs and reactive rules, and combines the sequence of states and events into a single model using timestamps.\nFLUX (Thielscher 2005) is a constraint logic programming language for implementing intelligent agents using the fluent calculus. One of the objectives of the fluent calculus is to avoid the computational inefficiency of reasoning with frame axioms, by reifying states as lists of fluents. However, the list representation requires the explicit use of recursion both to query whether a fluent is a member of a list representing a state, and to delete a fluent if it is terminated by an action. Arguably, this is nearly as inefficient as reasoning with explicit frame axioms. In contrast, in KELPS/LPS, states are not represented explicitly in the language, but are represented implicitly by sets of fluents, and membership and deletion are performed by associative look-up. In FLUX, states can be updated by sensing actions, but there seems to be no analogue of the reactive rules of KELPS/LPS.\nIn (Governatori and Rotolo, 2013), the authors present an efficient algorithm for computing argumentation-style extensions in temporal defeasible logic (TDL). Programs in TDL are logical implications with time stamps, similar to reactive rules in KELPS. The time complexity of the algorithm is proportional to the size of the rules, which is much more efficient than explicit reasoning with event calculus style frame axioms. However, because the algorithm is not described in terms of destructive updates, it is difficult to compare it directly with the OS of KELPS.\nMost of these approaches focus on the internal reasoning of individual agents, treating other agents as part of the external environment. In contrast, SCIFF (Alberti et al. 2008) focuses directly on the specification and verification of multi-agent systems, abstracting away from the internal structure of individual agents. It uses ALP to represent the expected behavior of agents and a variant of the IFF proof procedure (Fung and Kowalski 1997), to verify that actual behaviour conforms to expectations.\nIntegrity constraints in SCIFF resemble ECA rules, but are used to specify the occurrence of events, and not to generate them. Events are timestamped, but are not related to fluents by a causal theory."}, {"heading": "6.10 Reactive Systems Programming Languages", "text": "Although LPS has its origins in logic programming, which is Turing complete, the kernel of LPS is its reactive rules. This shift from logic programs to reactive rules reflects our better appreciation of the fundamental role of state transition systems in all areas of computing, including reactive systems programming languages.\nAs David Harel (1987) puts it: \u201cMuch of the literature also seems to be in agreement that states and events are a piori a rather natural medium for describing the dynamic behaviour of a complex system.... A basic fragment of such a description is a state transition, which takes the general form when event Y occurs in state A, if condition C is true at the time, the system transfers to state B\u201d. Harel contrasts such reactive systems with \u201ctransformational systems\u201d, which transform inputs into outputs in a purely declarative manner. Arguably, LPS reconciles Harel\u2019s two kinds of computational systems, with reactive rules providing the reactive part, and logic programs providing structure for the \u201ctransformational\u201d part.\nIn contrast, Shapiro (1989) argues that concurrent logic programming languages are well suited for specifying reactive systems. In these languages, the state of a computation consists of a goal, which is a sequence of atoms and an assignment of values to variables in the goals. Programs are guarded Horn clauses, which have the form head  guard  body. Goal atoms that match the head and satisfy the guard are reduced to the goal atoms in the body.\nEach goal atom is viewed as a process, and the goal as a whole is viewed as a network of concurrent processes. Processes communicate by instantiating shared logical variables. The external environment is represented by a process whose behaviour is specified by another concurrent logic program.\nThis approach to reactive systems is very different from that of KELPS/LPS, in which states are sets of time-stamped atoms. Operationally, KELPS/LPS is closer to coordination languages, such as Linda (Carriero and Gelernter, 1989), in which processes interact through the medium of a shared state.\nWhereas Harel sees the need for both transformational and reactive systems, and Shapiro reduces both kinds of systems to logic programs, Gurevich (2000) models all varieties of computation by abstract state machines (ASM), programmed by rules of the form if guard then assignments. States are abstract, model-theoretic structures consisting of objects and functions. State transitions are performed by evaluating the all the guards of rules if guard then assignments that are true in the current state and executing all of the corresponding assignments destructively and in parallel.\nRules in ASM are similar to condition-action rules in production systems and to reactive rules in KELPS. However, ASM rules are more restricted than KELP/LPS rules, whose antecedents and consequents can involve an entire complex of temporally constrained FOL conditions. Compared with LPS, in which all states are combined in a single model, only the individual states in ASM are model-theoretic in character. Moreover, the if-then syntax of guarded assignments in ASM does not mean logical implication."}, {"heading": "7 Conclusions and Future Work", "text": "This paper makes a contribution to analyzing the relationship between the operational and model-theoretic semantics of KELPS. In the future, it would be useful to extend the results to LPS. It would also be interesting to extend the OS to capture more of the non-reactive interpretations that satisfy the model-theoretic semantics.\nOn the practical side, it would be useful to extend reactive rules to allow more complex event conditions. This extension would not affect the model-theoretic semantics, and can be implemented, for example, by storing a window of past events. It is also important to explore the treatment of concurrency in greater depth, especially in the context of multi-agent systems, in which the external events of a single agent include actions generated by other agents.\nThere are a number of implementations of LPS. Making some of these available\nfor wider use is a major priority for future work."}, {"heading": "Acknowledgements", "text": "We are grateful to the anonymous referees for their careful reading of our earlier submission, and for their many helpful comments."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "In previous work, we proposed a logic-based framework in which computation is the execution of actions in an attempt to make reactive rules of the form if antecedent then consequent true in a canonical model of a logic program determined by an initial state, sequence of events, and the resulting sequence of subsequent states. In this model-theoretic semantics, reactive rules are the driving force, and logic programs play only a supporting role. In the canonical model, states, actions and other events are represented with timestamps. But in the operational semantics, for the sake of efficiency, timestamps are omitted and only the current state is maintained. State transitions are performed reactively by executing actions to make the consequents of rules true whenever the antecedents become true. This operational semantics is sound, but incomplete. It cannot make reactive rules true by preventing their antecedents from becoming true, or by proactively making their consequents true before their antecedents become true. In this paper, we characterize the notion of reactive model, and prove that the operational semantics can generate all and only such models. In order to focus on the main issues, we omit the logic programming component of the framework.", "creator": "Microsoft\u00ae Word 2010"}}}