{"id": "1601.02433", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Jan-2016", "title": "Git4Voc: Git-based Versioning for Collaborative Vocabulary Development", "abstract": "Collaborative vocabulary development in the context of data integration is the process of finding consensus between the experts of the different systems and domains. The complexity of this process is increased with the number of involved people, the variety of the systems to be integrated and the dynamics of their domain. In this paper we advocate that the realization of a powerful version control system is the heart of the problem. However, our goal is to explore the dynamics of this process using a large corpus of data. This paper shows how this approach is used to determine the dynamics of data in data analysis, and discusses the various issues of what to expect in this field of research in a new area.\n\n\n\n\n1. Data is now considered a set of components in a data analysis system. This framework is based on a dataset of approximately 200 million people and allows for the creation and sharing of various aspects of data. The dataset, which is composed of the following data sets:\n\n\n1. The value of a data set:\n\n1. The value of the data set:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1. The number of entities:\n1", "histories": [["v1", "Mon, 11 Jan 2016 13:11:51 GMT  (452kb,D)", "http://arxiv.org/abs/1601.02433v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.HC", "authors": ["lavdim halilaj", "irl\\'an grangel-gonz\\'alez", "g\\\"okhan coskun", "s\\\"oren auer"], "accepted": false, "id": "1601.02433"}, "pdf": {"name": "1601.02433.pdf", "metadata": {"source": "CRF", "title": "Git4Voc: Git-based Versioning for Collaborative Vocabulary Development", "authors": ["Lavdim Halilaj", "G\u00f6khan Coskun", "S\u00f6ren Auer"], "emails": ["halilaj@cs.uni-bonn.de", "grangel@cs.uni-bonn.de", "coskun@cs.uni-bonn.de", "auer@cs.uni-bonn.de"], "sections": [{"heading": null, "text": "Index Terms\u2014version control system; collaborative vocabulary development; git;\nI. INTRODUCTION\nOne of the key obstacles for the wider deployment of semantic technologies is the lack of comprehensive vocabularies. This is because vocabulary development requires a significant investment, which is difficult to make by a single person or organisation. If we look at current vocabularies (e.g. LOV1), we observe that they are rather simplistic. For a total of 457 vocabularies listed in LOV, a straightforward query against the LOV SPARQL endpoint tells us that the average number of classes for each vocabulary is 42 whereas the average number of properties is 59. Omitting the four vocabularies with the highest number of classes and properties, these figures decrease to 31 classes and 37 properties on average. We also observe that a large number of crucial domains is not or only superficially covered by existing vocabularies. One of the main reasons for the lack of vocabularies is also the lack of adequate methodological and tool support.\nAt the same time, the problem of integrating data from different systems receives ever-increasing attention. Identifying\n1http://lov.okfn.org\nthe main terms across heterogeneous data sources by finding a consensus between the developers and defining a shared vocabulary is an effective approach to tackle this problem. However, this process, which we refer to as collaborative vocabulary development, itself is a complex problem to be solved. In fact, the main challenge for the vocabulary engineers is to work collaboratively on a shared objective in a harmonic and efficient way while avoiding misunderstandings, uncertainty and ambiguity. The quality of the produced vocabularies is another challenge that should be tackled as well. In [1], we identified and elaborated important aspects for vocabulary development such as: reuse, vocabulary structure, naming conventions, multilinguality, documentation, validation and authoring. These aspects are relevant from collaborative point of view as well. Taking into consideration above aspects will impact the quality of vocabulary itself.\nTherefore, finding a suitable collaboration methodology is exacerbated by the number and diversity of the involved stakeholders as well as the complexity of the domains. Due to the open, distributed and participatory nature of the Web, such a solution is of paramount interest for the Semantic Web community.\nOur approach to tackle the mentioned problem is to focus on supporting the collaborative vocabulary development with a well-known method for distributed version control in a domain-agnostic way. In this regard, we have chosen Git for the following two reasons. On the one hand, Git is a mature version control system supported by sophisticated tools and broadly used in software development projects. More than 10 million repositories2 are hosted on GitHub for open source and commercial projects [2]. On the other hand, existing popular vocabularies like schema.org3, Description of a Project (DOAP)4, the music ontology5 publish their efforts in GitHub to leverage the contribution of the community. This indicates that the vocabulary development community is already familiar with Git.\nThe remainder of this paper is structured as follows: In section II we present a comprehensive list of requirements\n2https://github.com/blog/1724-10-million-repositories 3https://github.com/schemaorg/schemaorg 4https://github.com/edumbill/doap 5https://github.com/motools/musicontology\nar X\niv :1\n60 1.\n02 43\n3v 1\n[ cs\n.A I]\n1 1\nJa n\n20 16\naggregated from the current state of the art and our ongoing work on MobiVoc6 and SCORVoc7. In section III we present Git4Voc which comprises guidelines how Git can be used for collaborative vocabulary development. With Git4Voc we propose to utilize Git\u2019s hooks mechanism to realize vocabularspecific features. In section IV we demonstrate concrete example of hook implementations. We provide an overview about related work in section V. The conclusion and an outlook to future work are presented in section VI."}, {"heading": "II. REQUIREMENTS OF COLLABORATIVE VOCABULARY DEVELOPMENT", "text": "Collaborative vocabulary development is considered to be very related to the broad field of software development. In fact, most proposals for supporting the former are inspired by experiences in the latter. However, a vocabulary is not totally equal to software code. The development of vocabularies raises challenges which are new and not or at least not to that extend raised during software development. In this section we focus on requirements which are more critical for vocabularies. We gathered these requirements by aggregating insights from the current state of the art and our own experiences during the development of MobiVoc8 and SCORVoc9. In the following these requirements are presented in detail.\nCommunication support (R1) Collaborative vocabulary development is about finding consensus between members of a team. In order to share ideas and finding agreements, communication among the contributors is essential [3]. During the whole life cycle, especially in agile development, supporting and recording discussions, changes and their reasons are crucial [4]. This is especially very important in the case of heterogeneous teams with experts from different domains. Some critical examples to be communicated within a team are introducing new elements, extending or modifying the subsumption hierarchy, integration of external resources and changing the underlying semantic expressivity [5]. An effective communication has a significant impact on the quality of the collaboration and its outcome.\nProvenance of information (R2) In collaborative development the capability to track the changes made by contributors is an important feature [4]. This is due to the fact that each change in the vocabulary reflects the understanding of the authors regarding the domain. In case of disagreements, it is necessary to know which change was made by whom at which time and for what reason.\nDifferent roles (R3) Creating vocabularies with the purpose of realizing data integration across heterogeneous independent systems, involves domain experts from various fields with different levels of expertise. For instance, in large projects like the Gene Ontology10 (GO) many participants and curators take part in the development process. Most participants can only\n6https://github.com/vocol/mobivoc 7http://purl.org/eis/vocab/scor 8https://github.com/vocol/mobivoc 9http://purl.org/eis/vocab/scor 10http://www.geneontology.org/\nadd comments and discuss terms. A core team is allowed to edit the main components of the vocabulary by adding modules, classes, properties, removing terms and performing refactoring. For that reason, there is a need for the definition of roles along with the permissions [5], [4], [6], [7].\nWorkflow independence (R4) The overall field of methodologies and workflows for collaborative vocabulary development is changing continuously [4]. To the best of our knowledge, there are no established methodologies nor workflows which are broadly applied. Tools supporting collaboration should be generic and be able to adapt in highly dynamic context. Therefore, it is important that a system is flexible enough to be used within different methodologies and workflows.\nQuality assurance (R5) Developing vocabularies includes many requirements of quality assurance. Syntax and semantic correctness as well as the application of best practices on designing vocabularies are some of the quality aspects. Therefore providing tool support is a significant feature to prevent contributors from making errors. Later correcting phases might lead to a wasting of resources in terms of time and money.\nDocumentation generation (R6) As mentioned before, a team for vocabulary development comprises domain experts with less technical expertise in knowledge representation and engineering tools. In order to enable them contributing to the development process, providing user friendly view to the current state of the vocabulary is vital. Therefore, an automatic documentation generation feature is necessary.\nDeltas among versions (R7) Collaborative development of vocabularies should respond to the evolution of the knowledge domain [7]. It should also respect the evolution of connected vocabularies within the Linked Data Cloud, in order to avoid semantic inconsistencies. Therefore, support for detecting and documenting the semantic difference between versions is needed, to enable developers to understand the mentioned evolutions. This includes the modification, the addition of new elements (i.e. classes, properties) as well as the removal of existing terms. Authors of well-known vocabularies such as SKOS11 and schema.org12 publish release notes containing what has been changed among different versions.\nEditor agnostic (R8) In contrast to software code, vocabularies are abstract artefacts which can be serialized with different techniques. Since contributors can use different editors which style the syntax in different ways, the support of the collaboration must be editor agnostic and syntax independent.\nModularity (R9) Modularization is recognized as an important step in collaborative vocabulary building [8]. Reusability, the decrease of complexity, ownership and customization are some of the benefits of vocabulary modularization. Some studies report that there is no universal way to perform this process and that the choice of a particular technique should be guided by application specific requirements [9]. In contrast, other reports show that a module in a mid-sized vocabulary should contain between 200 and 300 lines of code [10]. Especially\n11http://www.w3.org/2004/02/skos/history 12http://schema.org/docs/releases.html\nin an agile development process with large vocabularies and many contributors, it is of paramount importance that the system provides means to support the modularization activity.\nMultilinguality (R10) In order to have a wide range of applicability to different cultures and communities, vocabulary terms must be translated into various languages [11]. The localization (and internationalization) process of vocabularies should be supported by the system.\nLabeling versions (R11) Release versions of vocabularies should be labeled appropriately. This ensures that users that can be humans or machines have always the possibility to use specific version, not only the latest one."}, {"heading": "III. GIT4VOC", "text": "In this section we present Git4Voc. On the one hand, we propose guidelines how Git can be used for collaborative vocabulary development project. On the other hand, we present how the requirements from section II can be technically implemented by Git hooks. Additionally, in terms of guidelines we analyzed best practices from collaborative software development and identified the following aspects as critical for the quality of the vocabulary: (1) management of generated information; (2) rights management; (3) branching and merging; (4) automate development and deployment tasks by hooks; (5) tool independence; (6) vocabulary organization structure; and (7) labeling of release versions. In the next subsections we show in detail how our approach responds to the above mentioned requirements."}, {"heading": "A. Management of Generated Information", "text": "During the development process a bunch of information is generated by the contributors. The capability to manage this information within the entire project life-cycle is essential. In fact, value added services like GitHub, GitLab or BitBucket enrich Git functionality with powerful information management features. For instance, issues are a great way of tracking communications, reporting problems as well as bug fixes and announcing version releases. Communities like schema.org manage their discussions using GitHub. The above mentioned means support requirement (R1). Based on this fact, we propose that activities gathered in Table II should be documented. If possible, the name of issues should correspond to the name of the activities.\nAnother important requirement in collaborative vocabulary development is the ability to view the history of the changes (called traceability in software engineering). This addresses the requirement (R2). Using commands git log and git diff a user can explore the history of the commits and the differences between them. Each commit should be realized based on Best Commit Practices13. In vocabulary development the atomicity of commits is of paramount importance.\n13http://www.git-tower.com/learn/git/ebook/command-line/appendix/best-practices"}, {"heading": "B. Rights Management", "text": "Standalone solutions such as GitLab14 and Gitolite15 as well as third-party services like Bitbucket16 and GitHub17 offer basic options for user rights managements, like reading, writing, posting, adding new team members and adding tags. However, even with these solutions a high level of user management i.e. restricting editing a specified number or type of classes, properties or instances cannot be achieved with Git. In order to address requirement (R3), we explore a combination of branching and hooks.\nWith the combination of branching and hooks with role definition for users, fine grained access management can be achieved. Concretely, by using server-side hooks, realizing rights managements on top of user roles is possible. For instance, an implementation of a pre-push hook can check for the user\u2019s role and permissions and deny if the necessary rights according the activity and branch are not set.\nTable I shows common roles and their permissions, with respect to the defined categories of activities. In a trusted environment right management can also be realized with client-side hooks. An example for this is depicted in Listing 3, where the user is denied to push to the master branch."}, {"heading": "C. Branching and Merging", "text": "Git is a very flexible tool, which addresses requirement (R4). Using Git, teams are able to organize their work in different types of workflows18. Branching strategies affect the quality in collaborative software development [12], [13]. Vocabulary development is mostly accepted to be a specific type of software development. Therefore, it is considered that the branching strategy affects the quality of the vocabularies. Well-known projects such as schema.org use branches to organize their work. In order to design a branching model, it is important to understand the possible activities that a team can perform. In this regard, we collected common activities of collaborative vocabulary development which are listed in Table II. Aiming at producing a vocabulary with good quality, the entire team should be aware of these activities and how to face them in the development process. Due to their impact\n14https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/permissions/permissions.md 15https://github.com/sitaramc/gitolite 16https://confluence.atlassian.com/display/BITBUCKET/Add+Users,+Set+\nPermissions,+and+Review+Account+Plans 17https://help.github.com/articles/permission-levels-for-an-organization-repository 18https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow\non the overall vocabulary, we have classified these activities into three categories: (1) basic activities (ACT1, ACT7, ACT9), (2) semantic issues (ACT2, ACT3, ACT4, ACT5, ACT6, ACT8) and (3) structural issues (ACT10, ACT11).\nThis led us to the branching model that is depicted in Figure 1. We designed different branches to handle the mentioned categories. Basic activities have to be performed in the Develop Branch. For the second category we propose a dedicated branch called Semantic Issues. In case of the third category a branch named Structural Issues has to be applied. It is important to bear in mind that we are not restricting the flexibility of Git regarding branches. On the contrary, other branches can be used as a complement of this model. Nevertheless, our approach of branching model will help developers because those branches are connected to specific activities in collaborative vocabulary development.\nOur solution is built on top of the best practices for branching in software development19."}, {"heading": "D. Automate Development and Deployment Tasks by Hooks", "text": "Despite the fact that Git has many implemented features, it allows extending its functionality by using so-called hooks. This is a mechanism that allows running scripts before or after specific Git events. Based on the execution place, two types\n19http://nvie.com/posts/a-successful-git-branching-model\nof hooks are distinguished, client-side and server-side hooks. Due to space limitations, the examples in this article showcase only client-side hooks. In order to address requirements (R5) and (R6), we implemented the following three important tasks for collaborative vocabulary development: (1) syntax checking, (2) assessing vocabularies against best design practices and (3) documentation generation. Figure 2 illustrates how these examples are integrated into the commit process.\nAfter modifying the local vocabulary and adding changes to the stage phase, the next step is to commit the current state to the local repository. The initialization of commit triggers a hook named pre-commit. Listing 3 shows our implementation of this hook which realizes the tasks syntax checking and best practice assessment. First, it retrieves all modified files with extensions such as rdf, owl, ttl and checks for syntax errors by using Rapper20. In case that vocabularies fail to pass the validation process, the commit is canceled. The user is notified with a message which shows detailed description about the error which comprised of the file name, line number and the error type. If syntax validation is passed successfully, the modified files are posted to the OOPS21 Web Service through curl, a command-line HTTP client. This service assesses vocabulary files for certain quality metrics. The result of this is a descriptive message that contains recommendations of best practices for vocabulary development. If no errors exist, the pre-commit hook is finished and the commit is accepted. Afterwards a post-commit hook is called. Listing 4 demonstrates our implementation of a post-commit hook for documentation generation in a human friendly format. This script uses Parrot22 as an external tool.\nFor security reasons Git repository services do not allow to automatically distribute predefined hooks on cloning phase. In order to accomplish this task, the repository itself should have a dedicated folder that contains the implemented hooks. After the first clone, these hooks need to be copied to the .git/hooks directory. For that purpose, we implemented a script\n20http://librdf.org/raptor/ 21http://oops-ws.oeg-upm.net/ 22https://bitbucket.org/fundacionctic/parrot/\nwhich needs to be executed after cloning the repository. Once this process is finished, predefined hooks will be automatically executed after each commit. However, when the hooks have been changed, e.g. to use different validation or documentation generation tools, this script has to be executed again. Apart from installing the hooks, this script can also be used to download and install tools like Rapper, which are necessary for the hooks. If these tools are to be placed within the local repository, the file .gitignore should be used to prevent them from being pushed to the remote repository.\nGit does not show semantic diffs between versions of vocabulary. Owl2VCS [14] shows deltas among different versions. By using such a tool and hooks, generated deltas can be published is human friendly format as well. This corresponds to the requirement (R7)."}, {"heading": "E. Tool Independence", "text": "Collaborative working with Git can be facilitated by using vocabulary editors like Prote\u0301ge\u030123, TopBraid Composer24, Neon Toolkit25. As each of them has different algorithms for writing files, there might arise consistency problems in case that contributors are not using the same editor. For instance, one contributor use Prote\u0301ge\u0301, whereas another one uses Neon Toolkit. They are editing the same file simultaneously. After saving it, different representations of that file will be created. As a consequence Git recognizes lot of changes and asks for conflict resolution. This is due to fact that Git is a version control based on text line changing. It detects when a line has been changed from the previous version. In such a case using\n23http://protege.stanford.edu/ 24http://www.topquadrant.com/tools/IDE-topbraid-composer-maestro-edition/ 25http://neon-toolkit.org/wiki/Main Page.html\nthe merge tool is necessary, which is a time consuming and error prone task that could lead to information lose.\nIn order to avoid the above mentioned problems, we propose the use of Turtle format. This addresses the requirement (R8). A similar approach describes a pattern to express data on GitHub storing it in CSV files26. Listing 1 presents our proposal to write one triple per line.\nListing 1: One triple per line @prefix rdf: <h t t p : / / www. w3 . org /1999/02/22 \u2212 r d f\u2212syn t ax\u2212ns #>. @prefix rdfs: <h t t p : / / www. w3 . org / 2 0 0 0 / 0 1 / r d f\u2212schema #>. @prefix owl: <h t t p : / / www. w3 . org / 2 0 0 2 / 0 7 / owl#>. @prefix scor: <h t t p : / / p u r l . o rg / e i s / vocab / s c o r #>. @prefix vs: <h t t p : / / www. w3 . org / 2 0 0 3 / 0 6 / sw\u2212vocab\u2212s t a t u s / ns #>.\nscor:Process rdf:type owl:Class ; rdfs:comment \"A process is a unique activity...\"@en ; rdfs:label \"Process\"@en ; rdfs:isDefinedBy scor: ; vs:term_status \"testing\".\nscor:Enable rdfs:subClassOf scor:Process ; rdfs:comment \"Enable describes the ...\"; rdfs:label \"Enable\".\nF. Vocabulary Organization Structure\nGit\u2019s basic functionalities do not support modularizing code or vocabularies. Therefore, in order to address the requirement (R9), we propose some guidelines for organizing the vocabulary in files where each file represents a module. Considering the fact that each line should represent a triple and based on the insights on [10], we propose that files should not contain more than 300 triples. We highlight three possible forms of organizing the files. All of these cases use single Git repository to store the files.\n1. The complete vocabulary is contained in one single file. When the vocabulary is small (e.g. contains less than 300 lines of code) and represents a domain which cannot be divided in sub domains, it should be saved within one single file. If the number of contributors is relatively small and the domain of the vocabulary is very focused, organizing it into one single file might be possible, even if it exceeds 300 lines of code. However, if the comprehensibility is exacerbated, splitting it into different files should be considered.\n2. The vocabulary is split in multiple files. If the vocabulary contains more than 300 lines of code or covers a complex domain, it should be organized into different sub domains or modules. In this regard, we mapped sub domains with modules. When the sub domains themselves are small enough they should be represented by different files within the parent folder. There exists patterns for vocabulary modularization [15]. We developed the MobiVoc based on the pattern n modules importing 1 module. In this case, 1 module was the vocabulary itself. The n modules like Aircraft, Fuel were saved in separate files. Each file represents a specific sub domain. By following this approach, domain experts can contribute independently to vocabulary development according to their\n26http://blog.okfn.org/2013/07/02/git-and-github-for-data/\nfield of expertise. Figure 3 depicts the structure of MobiVoc and its modules.\n3. Vocabulary modules are stored in files and folders. For huge vocabularies that comprises complex domains, splitting it into files is not sufficient. This would lead to a large amount of files within a single folder. Therefore, if the sub domains are large enough to be split into files they should be represented by folders. Each folder contains files which represents modules. In this case, the folder and file structure should reflect the complex hierarchy of the overall domain.\nThrough splitting the vocabulary in files for specific purposes, the requirement (R10) is addressed as well. This can be achieved by creating dedicated files for translating. In these files users with the role Translators can contribute by translating the terms into the required language."}, {"heading": "G. Labeling of Release Versions", "text": "Based on requirement (R11), proper labeling of release versions is vital, as it facilitates re-usability. One of the common ways to realize that is to deploy each release version in different files. However, this could lead to following problems as identified in [16]: (1) the number of files could increase rapidly, (2) choosing versions creates confusion, (3) maintenance needs additional resources and (4) synchronizing with latest version from dependent applications requires additional effort. To avoid the above mentioned problems, we have kept versions of vocabularies in the same file. These versions are separated by Git implemented functionality of tagging and saved in the master branch which is part of the branching model and illustrated in Figure 1. It is possible to create and filter tags at any time. Moreover, users can obtain a specific version of the vocabulary just by giving the tag name. Therefore, each released version of a vocabulary must have a version number. Based on the scheme from [17] and the mentioned categories of activities in Table II, we propose tagging different versions according to the following pattern: v[StI.SeI.BA], where StI stands for Structural Issues, SeI for Semantic Issues and BaA for Basic Activities. Each\ncategory is related with a number, in the respective position. Changes in the vocabulary regarding to the categories are commonly reflected by increasing the numbers. For instance, the difference between releases v[1.0.0] and v[2.0.0] shows structural issue changes (StI).\nIV. IMPLEMENTATION\nWe have developed Git4Voc27, which is an environment for collaborative vocabulary development. Table III provides an overview which of the previously described requirements are fulfilled by Git4Voc. This solution combines Git4Voc with a set of state-of-the-art tools like Rapper, OOPS Service and Parrot. Each tool is exchangeable and can be easily replaced by alternatives. They provide services which are called by the hooks mechanism. In the following these hooks are presented in detail.\nThe Listing 2 shows an example how predefined hooks are copied into the .git/hooks folder after cloning the repository. In addition, it shows installing of the tools: Raptor and Parrot and their necessary libraries in case they do not exist.\nListing 2: Install Hooks and Tools #!/bin/sh # Copy the modified hooks for i in \u2018ls -1 hooks\u2018 do\ncp hooks/$i .git/hooks/$i done # Create directory for necessary tools if [ -d \"$tools\" ]; then mkdir -p \"tools\" ... fi cd tools\n#Install Raptor if [ ! -d \"$Raptor\" ]; then curl -O http://download.librdf.org/source/raptor2-2.0.15.\ntar.gz ... sudo apt-get install libxml2-dev libxslt1-dev python-dev sudo apt-get -y install raptor2-utils ...\nfi\n#Install Parrot if [ ! -e \"parrot-jar-with-dependencies.jar\" ]; then curl -O https://github.com/vocol/vocol/raw/master/Hooks/ tools/parrot-jar-with-dependencies.jar fi\n...\nThe pre-commit hook is adapted to prevent users from committing to the master branch as shown in the Listing 3. This example can be further customized to restrict committing to other branches as well. By doing so, a low level of rights management is achieved on the local repository, before the changes are pushed to the remote repository. Furthermore, to reduce the efforts needed for subsequent corrections, we integrated tools for (1) syntax validation; and (2) checking for bad modeling practices. For the first, the Rapper tool is used, which validates each turtle file for syntactic errors. For the second, we used OOPS Web Service to scan vocabulary files for bad modeling practices.\n27https://github.com/vocol/vocol/tree/master/Git4Voc\nListing 3: Pre-Commit Hook: Syntax validation and checking for bad modeling practices #!/bin/bash currentBranch=$(git symbolic-ref HEAD)\nif [ \"$currentBranch\" = \"refs/heads/master\" ]; then echo \"Not allowed to commit to master branch!\" exit 1 else # Get only modified files with ttl extension files=$(git diff --cached --name-only --diff-filter=ACM\n| grep \".ttl$\") ...\nfor file in ${files}; do # Validate each file using Rapper res=$(rapper -i turtle \"${files}\" -c 2>&1) ...\nif ! $error; then for file in ${files}; do fileContent=\u2018cat ${files}\u2018 request=\"<?xml ...>\" res=$(curl -X POST -d \"$request\" -H \"Content-\nType: application/xml\" http://oops-ws.oegupm.net/rest)\n... done\nfi\nif ${succeed}; then echo \"COMMIT SUCCEEDED\" else echo \"COMMIT FAILED\" exit 1\nfi fi\nThe Listing 4 shows the post-commit hook, which uses Parrot to create the human friendly representation of the developed vocabulary. The generated content is saved as a single HTML file which consists of all vocabulary elements. User is able to navigate through entire vocabulary by merely selecting the element name. Moreover, in order to create different representation style of the vocabulary, alternative tools such as: Widoco28, Specgen29, Dowl30, etc. (c.f. commented part of the code) can be used as well.\nListing 4: Post-Commit Hook: Documentation Generation #!/bin/sh files=$(git diff --cached --name-only --diff-filter=ACM |\ngrep \".ttl$\")\n28https://github.com/dgarijo/Widoco 29https://github.com/specgen/specgen 30https://github.com/ldodds/dowl\nif [ \"$files\" = \"\" ]; then exit 0 fi\nfor file in ${files}; do # Generate documentation using Parrot java -jar @path/parrot-jar-with-dependencies.jar -i \"${\nfile}\" -o \"${file}\".html # Generate documentation using Widoco # java -jar @path/widoco-0.0.1-jar-with-dependencies.\njar -ontFile \"${file}\" -outFolder /home/ ...\ndone echo \"\\Documentation Generation is completed.\\n\" exit 1"}, {"heading": "V. RELATED WORK", "text": "Collaborative vocabulary development is an active research area in the Semantic Web community [19]. Existing approaches like WebProte\u0301ge\u0301 [20] provides a collaborative web frontend for a subset of the functionality of the Prote\u0301ge\u0301 OWL editor. The aim of WebProte\u0301ge\u0301, is to lower the threshold for collaborative ontology development. Neologism [21] is a vocabulary publishing platform, with a focus on ease of use and compatibility with Linked Data principles. Neologism focuses more on vocabulary publishing and less on collaboration. VocBench [22], is an open source web application for editing thesauri complying with the SKOS and SKOS-XL standards. VocBench has a focus on collaboration, supported by workflow management for content validation and publication.\nThe main limitation of the aforementioned tools is the lack of version control. Therefore, we only consider approaches focused on using version control systems for collaborative vocabulary development.\nSVoNt [23] extends the functionality of Apache SubVersion (SVN) by providing a possibility for versioning OWL conform lightweight description logic. SVN manipulates only with deltas of files, therefore SVoNt use a separate server to create conceptual changes between versions of ontologies. These changes are generated as a result of diff operation between the modified ontology and the base ontology. ContentCVS [24] is a Prote\u0301ge\u0301 plugin. It adapts concepts from concurrent versioning to enable developers to work in parallel. Moreover, it has features for conflict detection and resolution by checking structure and semantic of the ontology versions. In [17] is described\nhow the developers of RDA Vocabularies31 adopt rules from SemVer32 to realize a meaningful versioning using Git. Additionally, it provides general notes for organizing the vocabulary development in branches. [25] describes Owl2VCS, a toolset designed to facilitate version control of OWL 2 ontologies using version control systems. It can be integrated as an external tool with Git, Mercurial and Subversion and provide algorithms for structural diff [14]. However, none of the above mentioned approaches cover all the identified requirements (c.f. section II) for collaborative vocabulary development. On the contrary, our work analyze and address each one of them by using Git and Git4Voc as an extension."}, {"heading": "VI. CONCLUSION AND FUTURE WORK", "text": "In this paper, we investigated the applicability of Git for collaborative vocabulary development. We defined collaborative vocabulary development as the process of identifying the main terms across heterogeneous data sources by finding a consensus between the developers. The main challenge in this regard is the realization of a powerful collaborative environment. Distributed version control systems enable developers around the world to work collaboratively on complex software systems. Since software and vocabularies are not the same, we analyzed their differences in detail by identifying requirements for a version control system that supports collaborative vocabulary development. Our approach extends plain Git functionality by utilizing the hooks mechanism in combination with external tools to address these requirements. The presented approach is easily extensible and can accommodate additional external tools.\nRegarding the future work, we are going to extend our approach with the full implementation of server side hooks. By doing so, tasks like: deploying specific versions of vocabularies to a dedicated server, generating deferencable URI\u2019s, ontology partitioning and modularization tasks can be performed in a fully automated way. We also plan to develop and integrate a tool that validates vocabularies against conventions [1] and provides recommendations for solving possible issues. This will lead to a convenience and less error prone collaborative vocabulary development environment. As a result, all generated artefacts will be publicly accessible from all interested parts."}, {"heading": "ACKNOWLEDGMENTS", "text": "This work is supported by the German Ministry for Education and Research funded project LUCID and European Commission under the Seventh Framework Program FP7 for grant 601043 (http://diachron-fp7.eu)."}], "references": [{"title": "Towards vocabulary development by convention", "author": ["I. Grangel-Gonz\u00e1lez", "L. Halilaj", "G. Coskun", "S. Auer"], "venue": "7th International Joint Conference on Knowledge Discovery, Knowledge Engineering and Knowledge Management, Vol 2, 2015, pp. 334\u2013343. 31http://www.rdaregistry.info 32http://www.semver.org", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2015}, {"title": "Open source-style collaborative development practices in commercial projects using github", "author": ["E. Kalliamvakou", "D. Damian", "K. Blincoe", "L. Singer", "D. German"], "venue": "37th International Conference on Software Engineering (ICSE15), 2015.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "A framework for ontology evolution in collaborative environments", "author": ["N.F. Noy", "A. Chugh", "W. Liu", "M.A. Musen"], "venue": "ISWC. Springer, 2006, pp. 544\u2013558.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2006}, {"title": "Collaborative ontology development on the (semantic) web.", "author": ["N.F. Noy", "T. Tudorache"], "venue": "AAAI Spring Symposium: Symbiotic Relationships between Semantic Web and Knowledge Engineering,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "The state of multi-user ontology engineering.", "author": ["J. Seidenberg", "A.L. Rector"], "venue": "in WoMO. Citeseer,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "A knowledge base driven user interface for collaborative ontology development", "author": ["T. Tudorache", "N.F. Noy", "S.M. Falconer", "M.A. Musen"], "venue": "16th International Conference on Intelligent User Interfaces. ACM, 2011, pp. 411\u2013414.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Collaborative ontology engineering: a survey", "author": ["E. Simperl", "M. Luczak-R\u00f6sch"], "venue": "The Knowledge Engineering Review, vol. 29, no. 01, pp. 101\u2013 131, 2014.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "The neon methodology for ontology engineering", "author": ["M.C. Suarez-Figueroa", "A. G\u00f3mez-P\u00e9rez", "M. Fernandez-Lopez"], "venue": "Ontology engineering in a networked world. Springer, 2012, pp. 9\u201334.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Ontology modularization for knowledge selection: Experiments and evaluations", "author": ["M. d\u2019Aquin", "A. Schlicht", "H. Stuckenschmidt", "M. Sabou"], "venue": "Database and Expert Systems Applications. Springer, 2007, pp. 874\u2013883.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2007}, {"title": "Towards structural criteria for ontology modularization", "author": ["A. Schlicht", "H. Stuckenschmidt"], "venue": "ISWC 2006 Workshop on Modular Ontologies. Citeseer, 2006.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "Challenges for the multilingual web of data", "author": ["J. Gracia", "E. Montiel-Ponsoda", "P. Cimiano", "A. G\u00f3mez-P\u00e9rez", "P. Buitelaar", "J. McCrae"], "venue": "Journal of Web Semantics, vol. 11, pp. 63\u201371, 2012.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Branching and merging: an investigation into current version control practices", "author": ["S. Phillips", "J. Sillito", "R. Walker"], "venue": "4th International Workshop on Cooperative and Human Aspects of Software Engineering. ACM, 2011, pp. 9\u201315.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2011}, {"title": "The effect of branching strategies on software quality", "author": ["E. Shihab", "C. Bird", "T. Zimmermann"], "venue": "ACM-IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM). IEEE, 2012, pp. 301\u2013310.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Ecco: A hybrid diff tool for owl 2 ontologies.", "author": ["R.S. Gon\u00e7alves", "B. Parsia", "U. Sattler"], "venue": "OWLED,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Characterizing modular ontologies", "author": ["S.B. Abbes", "A. Scheuermann", "T. Meilender", "M. d\u2019Aquin"], "venue": "7th International Conference on Formal Ontologies in Information Systems (FOIS), 2012, pp. 13\u201325.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Versioning owl ontologies using temporal tags", "author": ["P. Bedi", "S. Marwaha"], "venue": "International Journal of Computer, Control, Quantum and Information Engineering, 2007.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2007}, {"title": "Versioning vocabularies in a linked data world", "author": ["J.P. Diane I. Hillmann", "Gordon Dunsire"], "venue": "IFLA Lion, 2014.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "A holistic approach to collaborative ontology development based on change management", "author": ["R. Palma", "O. Corcho", "A. G\u00f3mez-P\u00e9rez", "P. Haase"], "venue": "Journal of Web Semantics, vol. 9, no. 3, pp. 299\u2013314, 2011.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Webprot\u00e9g\u00e9: A collaborative ontology editor and knowledge acquisition tool for the web", "author": ["T. Tudorache", "C. Nyulas", "N.F. Noy", "M.A. Musen"], "venue": "Semantic Web, vol. 4, no. 1, 2013.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "Neologism: Easy vocabulary publishing", "author": ["C. Basca", "S. Corlosquet", "R. Cyganiak", "S. Fern\u00e1ndez", "T. Schandl"], "venue": "2008.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2008}, {"title": "Vocbench: A web application for collaborative development of multilingual thesauri", "author": ["A. Stellato", "S. Rajbhandari", "A. Turbati", "M. Fiorelli", "C. Caracciolo", "T. Lorenzetti", "J. Keizer", "M.T. Pazienza"], "venue": "The Semantic Web. Latest Advances and New Domains. Springer, 2015, pp. 38\u201353.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Svont-version control of owl ontologies on the concept level.", "author": ["M. Luczak-R\u00f6sch", "G. Coskun", "A. Paschke", "M. Rothe", "R. Tolksdorf"], "venue": "GI Jahrestagung (2),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Contentcvs: A cvs-based collaborative ontology engineering tool.", "author": ["E. Jim\u00e9nez-Ruiz", "B.C. Grau", "I. Horrocks", "R.B. Llavori"], "venue": "in SWAT4LS. Citeseer,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "In [1], we identified and elaborated important aspects for vocabulary development such as: reuse, vocabulary structure, naming conventions, multilinguality, documentation, validation and authoring.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "More than 10 million repositories2 are hosted on GitHub for open source and commercial projects [2].", "startOffset": 96, "endOffset": 99}, {"referenceID": 2, "context": "In order to share ideas and finding agreements, communication among the contributors is essential [3].", "startOffset": 98, "endOffset": 101}, {"referenceID": 3, "context": "During the whole life cycle, especially in agile development, supporting and recording discussions, changes and their reasons are crucial [4].", "startOffset": 138, "endOffset": 141}, {"referenceID": 4, "context": "Some critical examples to be communicated within a team are introducing new elements, extending or modifying the subsumption hierarchy, integration of external resources and changing the underlying semantic expressivity [5].", "startOffset": 220, "endOffset": 223}, {"referenceID": 3, "context": "Provenance of information (R2) In collaborative development the capability to track the changes made by contributors is an important feature [4].", "startOffset": 141, "endOffset": 144}, {"referenceID": 4, "context": "For that reason, there is a need for the definition of roles along with the permissions [5], [4], [6], [7].", "startOffset": 88, "endOffset": 91}, {"referenceID": 3, "context": "For that reason, there is a need for the definition of roles along with the permissions [5], [4], [6], [7].", "startOffset": 93, "endOffset": 96}, {"referenceID": 5, "context": "For that reason, there is a need for the definition of roles along with the permissions [5], [4], [6], [7].", "startOffset": 98, "endOffset": 101}, {"referenceID": 6, "context": "For that reason, there is a need for the definition of roles along with the permissions [5], [4], [6], [7].", "startOffset": 103, "endOffset": 106}, {"referenceID": 3, "context": "Workflow independence (R4) The overall field of methodologies and workflows for collaborative vocabulary development is changing continuously [4].", "startOffset": 142, "endOffset": 145}, {"referenceID": 6, "context": "Deltas among versions (R7) Collaborative development of vocabularies should respond to the evolution of the knowledge domain [7].", "startOffset": 125, "endOffset": 128}, {"referenceID": 7, "context": "Modularity (R9) Modularization is recognized as an important step in collaborative vocabulary building [8].", "startOffset": 103, "endOffset": 106}, {"referenceID": 8, "context": "Some studies report that there is no universal way to perform this process and that the choice of a particular technique should be guided by application specific requirements [9].", "startOffset": 175, "endOffset": 178}, {"referenceID": 9, "context": "In contrast, other reports show that a module in a mid-sized vocabulary should contain between 200 and 300 lines of code [10].", "startOffset": 121, "endOffset": 125}, {"referenceID": 10, "context": "Multilinguality (R10) In order to have a wide range of applicability to different cultures and communities, vocabulary terms must be translated into various languages [11].", "startOffset": 167, "endOffset": 171}, {"referenceID": 11, "context": "Branching strategies affect the quality in collaborative software development [12], [13].", "startOffset": 78, "endOffset": 82}, {"referenceID": 12, "context": "Branching strategies affect the quality in collaborative software development [12], [13].", "startOffset": 84, "endOffset": 88}, {"referenceID": 13, "context": "Owl2VCS [14] shows deltas among different versions.", "startOffset": 8, "endOffset": 12}, {"referenceID": 9, "context": "Considering the fact that each line should represent a triple and based on the insights on [10], we propose that files should not contain more than 300 triples.", "startOffset": 91, "endOffset": 95}, {"referenceID": 14, "context": "There exists patterns for vocabulary modularization [15].", "startOffset": 52, "endOffset": 56}, {"referenceID": 15, "context": "However, this could lead to following problems as identified in [16]: (1) the number of files could increase rapidly, (2) choosing versions creates confusion, (3) maintenance needs additional resources and (4) synchronizing with latest version from dependent applications requires additional effort.", "startOffset": 64, "endOffset": 68}, {"referenceID": 16, "context": "Based on the scheme from [17] and the mentioned categories of activities in Table II, we propose tagging different versions according to the following pattern: v[StI.", "startOffset": 25, "endOffset": 29}, {"referenceID": 17, "context": "Collaborative vocabulary development is an active research area in the Semantic Web community [19].", "startOffset": 94, "endOffset": 98}, {"referenceID": 18, "context": "Existing approaches like WebProt\u00e9g\u00e9 [20] provides a collaborative web frontend for a subset of the functionality of the Prot\u00e9g\u00e9 OWL editor.", "startOffset": 36, "endOffset": 40}, {"referenceID": 19, "context": "Neologism [21] is a vocabulary publishing platform, with a focus on ease of use and compatibility with Linked Data principles.", "startOffset": 10, "endOffset": 14}, {"referenceID": 20, "context": "VocBench [22], is an open source web application for editing thesauri complying with the SKOS and SKOS-XL standards.", "startOffset": 9, "endOffset": 13}, {"referenceID": 21, "context": "SVoNt [23] extends the functionality of Apache SubVersion (SVN) by providing a possibility for versioning OWL conform lightweight description logic.", "startOffset": 6, "endOffset": 10}, {"referenceID": 22, "context": "ContentCVS [24] is a Prot\u00e9g\u00e9 plugin.", "startOffset": 11, "endOffset": 15}, {"referenceID": 16, "context": "In [17] is described", "startOffset": 3, "endOffset": 7}, {"referenceID": 13, "context": "It can be integrated as an external tool with Git, Mercurial and Subversion and provide algorithms for structural diff [14].", "startOffset": 119, "endOffset": 123}, {"referenceID": 0, "context": "We also plan to develop and integrate a tool that validates vocabularies against conventions [1] and provides recommendations for solving possible issues.", "startOffset": 93, "endOffset": 96}], "year": 2016, "abstractText": "Collaborative vocabulary development in the context of data integration is the process of finding consensus between the experts of the different systems and domains. The complexity of this process is increased with the number of involved people, the variety of the systems to be integrated and the dynamics of their domain. In this paper we advocate that the realization of a powerful version control system is the heart of the problem. Driven by this idea and the success of Git in the context of software development, we investigate the applicability of Git for collaborative vocabulary development. Even though vocabulary development and software development have much more similarities than differences there are still important differences. These need to be considered within the development of a successful versioning and collaboration system for vocabulary development. Therefore, this paper starts by presenting the challenges we were faced with during the creation of vocabularies collaboratively and discusses its distinction to software development. Based on these insights we propose Git4Voc which comprises guidelines how Git can be adopted to vocabulary development. Finally, we demonstrate how Git hooks can be implemented to go beyond the plain functionality of Git by realizing vocabulary-specific features like syntactic validation and semantic diffs.", "creator": "LaTeX with hyperref package"}}}