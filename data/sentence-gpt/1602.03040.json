{"id": "1602.03040", "review": {"conference": "EMNLP", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2016", "title": "The Structured Weighted Violations Perceptron Algorithm", "abstract": "We present the Structured Weighted Violations Perceptron (SWVP) algorithm, a new perceptron algorithm for structured prediction, that generalizes the Collins Structured Perceptron (CSP, (Collins, 2002)). Unlike CSP, the update rule of SWVP explicitly exploits the internal structure of the predicted labels. We prove that for linearly separable training sets, SWVP converges to a weight vector that separates the data, under certain conditions on the parameters of the algorithm. We further prove bounds for SWVP on: (a) the number of updates in the separable case; (b) mistakes in the non-separable case; and (c) the probability to misclassify an unseen example (generalization), and show that for most SWVP variants these bounds are tighter than those of the CSP special case. In synthetic data experiments where data is drawn from a generative hidden variable model, SWVP provides substantial improvements over CSP. In the natural experiment, SWVP is applied to a generalized set of fixed discriminative features in the models. This approach is more than likely to achieve an adequate weight of information in a set of random-state model models.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Tue, 9 Feb 2016 15:51:19 GMT  (229kb)", "https://arxiv.org/abs/1602.03040v1", null], ["v2", "Mon, 6 Jun 2016 08:00:15 GMT  (261kb,D)", "http://arxiv.org/abs/1602.03040v2", null], ["v3", "Wed, 14 Sep 2016 07:24:10 GMT  (75kb,D)", "http://arxiv.org/abs/1602.03040v3", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["rotem dror", "roi reichart"], "accepted": true, "id": "1602.03040"}, "pdf": {"name": "1602.03040.pdf", "metadata": {"source": "CRF", "title": "The Structured Weighted Violations Perceptron Algorithm", "authors": ["Rotem Dror"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The structured perceptron ((Collins, 2002), henceforth denoted CSP) is a prominent training algorithm for structured prediction models in NLP, due to its effective parameter estimation and simple implementation. It has been utilized in numerous NLP applications including word segmentation and POS tagging (Zhang and Clark, 2008), dependency parsing (Koo and Collins, 2010; Goldberg and Elhadad, 2010; Martins et al., 2013), semantic parsing (Zettlemoyer and Collins, 2007) and information extraction (Hoffmann et al., 2011; Reichart and Barzilay, 2012), if to name just a few.\nLike some training algorithms in structured prediction (e.g. structured SVM (Taskar et al., 2004; Tsochantaridis et al., 2005), MIRA (Crammer and Singer, 2003) and LaSo (Daume\u0301 III and Marcu,\n2005)), CSP considers in its update rule the difference between complete predicted and gold standard labels (Sec. 2). Unlike others (e.g. factored MIRA (McDonald et al., 2005b; McDonald et al., 2005a) and dual-loss based methods (Meshi et al., 2010)) it does not exploit the structure of the predicted label. This may result in valuable information being lost.\nConsider, for example, the gold and predicted dependency trees of Figure 3.1. The substantial difference between the trees may be mostly due to the difference in roots (are and worse, respectively). Parameter update w.r.t this mistake may thus be more useful than an update w.r.t the complete trees.\nIn this work we present a new perceptron algorithm with an update rule that exploits the structure of a predicted label when it differs from the gold label (Section 3). Our algorithm is called The Structured Weighted Violations Perceptron (SWVP) as its update rule is based on a weighted sum of updates w.r.t violating assignments and non-violating assignments: assignments to the input example, derived from the predicted label, that score higher (for violations) and lower (for non-violations) than the gold standard label according to the current model.\nOur concept of violating assignment is based on Huang et al. (2012) that presented a variant of the CSP algorithm where the argmax inference problem is replaced with a violation finding function. Their update rule, however, is identical to that of the CSP algorithm. Importantly, although CSP and the above variant do not exploit the internal structure of the predicted label, they are special cases of SWVP.\nIn Section 4 we prove that for a linearly separable training set, SWVP converges to a linear separator of\nar X\niv :1\n60 2.\n03 04\n0v 3\n[ cs\n.L G\n] 1\n4 Se\np 20\nthe data under certain conditions on the parameters of the algorithm, that are respected by the CSP special case. We further prove mistake and generalization bounds for SWVP, and show that in the general case the SWVP bounds are tighter than the CSP\u2019s.\nIn Section 5 we show that SWVP allows aggressive updates, that exploit only violating assignments derived from the predicted label, and more balanced updates, that exploit both violating and non-violating assignments. In experiments with synthetic data generated by an HMM, we demonstrate that various SWVP variants substantially outperform CSP training. We also provide initial encouraging dependency parsing results, indicating the potential of SWVP for real world NLP applications."}, {"heading": "2 The Collins Structured Perceptron", "text": "In structured prediction the task is to find a mapping f : X \u2192 Y , where y \u2208 Y is a structured object rather than a scalar, and a feature mapping \u03c6(x, y) : X \u00d7 Y(x) \u2192 Rd is given. In this work we denote Y(x) = {y\u2032|y\u2032 \u2208 DY Lx}, where Lx, a scalar, is the size of the allowed output sequence for an input x andDY is the domain of y\u2032i for every i \u2208 {1, . . . Lx}. 1 Our results, however, hold for the general case of an output space with variable size vectors as well.\nThe CSP algorithm (Algorithm 1) aims to learn a parameter (or weight) vector w \u2208 Rd, that separates the training data, i.e. for each training example (x, y) it holds that: y = arg maxy\u2032\u2208Y(x) w \u00b7\u03c6(x, y\u2032). To find such a vector the algorithm iterates over the training set examples and solves the above inference (argmax) problem. If the inferred label y\u2217 differs from the gold label y the update w = w + \u2206\u03c6(x, y, y\u2217) is performed. For linearly separable training data (see definition 4), CSP is proved to converge to a vector w separating the training data.\nCollins and Roark (2004) and Huang et al. (2012) expanded the CSP algorithm by proposing various alternatives to the argmax inference problem which is often intractable in structured prediction problems (e.g. in high-order graph-based dependency parsing (McDonald and Pereira, 2006)). The basic idea is replacing the argmax problem with the search for a violation: an output label that the model scores higher\n1In the general case Lx is a set of output sizes, which may be finite or infinite (as in constituency parsing (Collins, 1997)).\nAlgorithm 1 The Structured Perceptron (CSP) Input: data D = {xi, yi}ni=1, feature mapping \u03c6 Output: parameter vector w \u2208 Rd Define: \u2206\u03c6(x, y, z) , \u03c6(x, y)\u2212 \u03c6(x, z)\n1: Initialize w = 0. 2: repeat 3: for each (xi, yi) \u2208 D do 4: y\u2217 = arg max\ny\u2032\u2208Y(xi) w \u00b7 \u03c6(xi, y\u2032)\n5: if y\u2217 6= yi then 6: w = w + \u2206\u03c6(xi, yi, y\u2217) 7: end if 8: end for 9: until Convergence\nthan the gold standard label. The update rule in these CSP variants is, however, identical to the CSP\u2019s. We, in contrast, propose a novel update rule that exploits the internal structure of the model\u2019s prediction regardless of the way this prediction is generated."}, {"heading": "3 The Structured Weighted Violations Perceptron (SWVP)", "text": "SWVP exploits the internal structure of a predicted label y\u2217 6= y for a training example (x, y) \u2208 D, by updating the weight vector with respect to substructures of y\u2217. We start by presenting the fundamental concepts at the basis of our algorithm."}, {"heading": "3.1 Basic Concepts", "text": "Sub-structure Sets We start with two fundamental definitions: (1) An individual sub-structure of a structured object (or label) y \u2208 DY Lx , denoted with J , is defined to be a subset of indexes J \u2286 [Lx];2 and (2) A set of substructures for a training example (x, y), denoted with JJx, is defined as JJx \u2286 2[Lx].\nMixed Assignment We next define the concept of a mixed assignment: Definition 1. For a training pair (x, y) and a predicted label y\u2217 \u2208 Y(x), y\u2217 6= y, a mixed assignment (MA) vector denoted as mJ(y\u2217, y) is defined with respect to J \u2208 JJx as follows:\nmJk (y \u2217, y) = { y\u2217k k \u2208 J yk else\nThat is, a mixed assignment is a new label, derived from the predicted label y\u2217, that is identical to y\u2217 in all indexes in J and to y otherwise. For simplicity we denote mJ(y\u2217, y) = mJ when the reference y\u2217 and y labels are clear from the context.\n2We use the notation [n] = {1, 2, . . . n}.\nConsider, for example, the trees of Figure 3.1, assuming that the top tree is y, the middle tree is y\u2217 and J = [2, 5].3 In the mJ(y\u2217, y) (bottom) tree the heads of all the words are identical to those of the top tree, except for the heads of mistakes and of then.\nViolation The next central concept is that of a violation, originally presented by Huang et al. (2012):\nDefinition 2. A triple (x, y, y\u2217) is said to be a violation with respect to a training example (x, y) and a parameter vector w if for y\u2217 \u2208 Y(x) it holds that y\u2217 6= y and w \u00b7\u2206\u03c6(x, y, y\u2217) \u2264 0.\nThe SWVP algorithm distinguishes between MAs that are violations, and ones that are not. For a triplet (x, y, y\u2217) and a set of substructures JJx \u2286 2[Lx] we provide the following notations:\nI(y\u2217, y, JJx) v = {J \u2208 JJx|mJ 6= y,w\u00b7\u2206\u03c6(x, y,mJ) \u2264 0}\nI(y\u2217, y, JJx) nv = {J \u2208 JJx|mJ 6= y,w\u00b7\u2206\u03c6(x, y,mJ) > 0}\nThis notation divides the set of substructures into two subsets, one consisting of the substructures that yield violating MAs and one consisting of the substructures that yield non-violating MAs. Here again when the reference label y\u2217 and the set JJx are known we denote: I(y\u2217, y, JJx)v = Iv, I(y\u2217, y, JJx)nv = Inv and I = Iv \u222a Inv.\nWeighted Violations The key idea of SWVP is the exploitation of the internal structure of the predicted label in the update rule. For this aim at each iteration we define the set of substructures, JJx, and then, for each J \u2208 JJx, update the parameter vector, w, with respect to the mixed assignments, MAJ \u2019s. This is a more flexible setup compared to CSP, as we can update with respect to the predicted output (if it is a violation, as is promised if inference is performed via argmax), if we wish to do so, as well as with respect to other mixed assignments.\nNaturally, not all mixed assignments are equally important for the update rule. Hence, we weigh the different updates using a weight vector \u03b3. This paper therefore extends the observation of Huang et al. (2012) that perceptron parameter update can be performed w.r.t violations (Section 2), by showing that w can actually be updated w.r.t linear combinations of mixed assignments, under certain conditions on the selected weights.\n3We index the dependency tree words from 1 onwards."}, {"heading": "3.2 Algorithm", "text": "With these definitions we can present the SWVP algorithm (Algorithm 2). SWVP is in fact a family of algorithms differing with respect to two decisions that can be made at each pass over each training example (x, y): the choice of the set JJx and the implementation of the SETGAMMA function.\nSWVP is very similar to CSP except for in the update rule. Like in CSP, the algorithm iterates over the training data examples and for each example it first predicts a label according to the current parameter vector w (inference is discussed in Section 4.2, property 2). The main difference from CSP is in the update rule (lines 6-12). Here, for each substructure in the substructure set, J \u2208 JJx, the algorithm generates a mixed assignment mJ (lines 7-9). Then, w is updated with a weighted sum of the mixed assignments (line 11), unlike in CSP where the update is held w.r.t the predicted assignment only.\nThe \u03b3(mJ) weights assigned to each of the \u2206\u03c6(x, y,mJ) updates are defined by a SETGAMMA function (line 10). Intuitively, a \u03b3(mJ) weight should be higher the more the mixed assignment is assumed to convey useful information that can guide the update of w in the right direction. In Section 4 we detail the conditions on SETGAMMA under which SWVP converges, and in Section 5 we describe various SETGAMMA implementations.\nGoing back to the example of Figure 3.1, one would assume (Sec. 1) that the head word prediction for worse is pivotal to the substantial difference between the two top trees (UAS of 0.2). CSP does not directly exploit this observation as it only updates its parameter vector with respect to the differences between complete assignments: w = w + \u2206\u03c6(x, y, z).\nIn contrast, SWVP can exploit this observation in various ways. For example, it can generate a mixed\nassignment for each of the erroneous arcs where all other words are assigned their correct arc (according to the gold tree) except for that specific arc which is kept as in the bottom tree. Then, higher weights can be assigned to errors that seem more central than others. We elaborate on this in the next two sections.\nAlgorithm 2 The Structured Weighted Violations Perceptron Input: data D = {xi, yi}ni=1, feature mapping \u03c6 Output: parameter vector w \u2208 Rd Define: \u2206\u03c6(x, y, z) , \u03c6(x, y)\u2212 \u03c6(x, z)\n1: Initialize w = 0. 2: repeat 3: for each (xi, yi) \u2208 D do 4: y\u2217 = arg max\ny\u2032\u2208Y(xi) w \u00b7 \u03c6(xi, y\u2032)\n5: if y\u2217 6= yi then 6: Define: JJxi \u2286 2[Lxi ] 7: for J \u2208 JJxi do\n8: Define: mJ s.t. mJk = { y\u2217k k \u2208 J yik else\n9: end for 10: \u03b3 = SETGAMMA() 11: w = w + \u2211 J\u2208Iv\u222aInv \u03b3(mJ )\u2206\u03c6(xi, yi,mJ ) 12: end if 13: end for 14: until Convergence"}, {"heading": "4 Theory", "text": "We start this section with the convergence conditions on the \u03b3 vector which weighs the mixed assignment updates in the SWVP update rule (line 11). Then, using these conditions, we describe the relation between the SWVP and the CSP algorithms. After that, we prove the convergence of SWVP and analyse the derived properties of the algorithm.\n\u03b3 Selection Conditions Our main observation in this section is that SWVP converges under two conditions: (a) the training set D is linearly separable; and (b) for any parameter vector w achievable by the algorithm, there exists (x, y) \u2208 D with JJx \u2286 2[Lx], such that for the predicted output y\u2217 6= y, SETGAMMA returns a \u03b3 weight vector that respects the \u03b3 selection conditions defined as follows: Definition 3. The \u03b3 selection conditions for the SWVP algorithm are (I = Iv \u222a Inv):\n(1) \u2211 J\u2208I \u03b3(mJ) = 1. \u03b3(mJ) \u2265 0, \u2200J \u2208 I.\n(2) w \u00b7 \u2211 J\u2208I \u03b3(mJ)\u2206\u03c6(xi, yi,mJ) \u2264 0.\nWith this definition we are ready to prove the following property.\nSWVP Generalizes the CSP Algorithm We now show that the CSP algorithm is a special case of SWVP. CSP can be derived from SWVP when taking: JJx = {[Lx]}, and \u03b3(m[Lx]) = 1 for every (x, y) \u2208 D. With these parameters, the \u03b3 selection conditions hold for every w and y\u2217. Condition (1) holds trivially as there is only one \u03b3 coefficient and it is equal to 1. Condition (2) holds as y\u2217 = m[Lx] and hence I = {[Lx]} and w \u00b7\n\u2211 J\u2208I \u2206\u03c6(x, y,mJ) \u2264 0."}, {"heading": "4.1 Convergence for Linearly Separable Data", "text": "Here we give the theorem regarding the convergence of the SWVP in the separable case. We first define: Definition 4. A data set D = {xi, yi}ni=1 is linearly separable with margin \u03b4 > 0 if there exists some vector u with \u2016u\u20162 = 1 such that for all i:\nu \u00b7\u2206\u03c6(xi, yi, z) \u2265 \u03b4,\u2200z \u2208 Y(xi).\nDefinition 5. The radius of a data set D = {xi, yi}ni=1 is the minimal scalar R s.t for all i:\n\u2016\u2206\u03c6(xi, yi, z)\u2016 \u2264 R, \u2200z \u2208 Y(xi).\nWe next extend these definitions:\nDefinition 6. Given a data set D = {xi, yi}ni=1 and a set JJ = {JJxi \u2286 2[Lxi ]|(xi, yi) \u2208 D}, D is linearly separable w.r.t JJ , with margin \u03b4JJ > 0 if there exists a vector u with \u2016u\u20162 = 1 such that: u \u00b7 \u2206\u03c6(xi, yi,mJ(z, yi)) \u2265 \u03b4JJ for all i, z \u2208 Y(xi), J \u2208 JJxi . Definition 7. The mixed assignment radius w.r.t JJ of a data set D = {xi, yi}ni=1 is a constant RJJ s.t for all i it holds that:\n\u2016\u2206\u03c6(xi, yi,mJ(z, yi))\u2016 \u2264 RJJ , \u2200z \u2208 Y(xi), J \u2208 JJxi .\nWith these definitions we can make the following observation (proof in A): Observation 1. For linearly separable data D and a set JJ , every unit vector u that separates the data with margin \u03b4, also separates the data with respect to mixed assignments with JJ , with margin \u03b4JJ \u2265 \u03b4. Likewise, it holds that RJJ \u2264 R.\nWe can now state our convergence theorem. While the proof of this theorem resembles that of the CSP (Collins, 2002), unlike the CSP proof the SWVP proof relies on the \u03b3 selection conditions presented above and on the Jensen inequality.\nTheorem 1. For any dataset D, linearly separable with respect to JJ with margin \u03b4JJ > 0, the SWVP algorithm terminates after t \u2264 (R JJ )2\n(\u03b4JJ )2 steps, where\nRJJ is the mixed assignment radius of D w.r.t. JJ .\nProof. Let wt be the weight vector before the tth update, thus w1 = 0. Suppose the tth update occurs on example (x, y), i.e. for the predicted output y\u2217 it holds that y\u2217 6= y. We will bound \u2016wt+1\u20162 from both sides. First, it follows from the update rule of the algorithm that: wt+1 = wt +\n\u2211 J\u2208Iv\u222aInv \u03b3(mJ)\u2206\u03c6(x, y,mJ).\nFor simplicity, in this proof we will use the notation Iv \u222a Inv = I . Hence, multiplying each side of the equation by u yields:\nu \u00b7 wt+1 = u \u00b7 wt + u \u00b7 \u2211 J\u2208I \u03b3(mJ)\u2206\u03c6(x, y,mJ)\n= u \u00b7 wt + \u2211 J\u2208I \u03b3(mJ)u \u00b7\u2206\u03c6(x, y,mJ)\n\u2265 u \u00b7 wt + \u2211 J\u2208I \u03b3(mJ)\u03b4JJ (margin property) \u2265 u \u00b7 wt + \u03b4JJ \u2265 . . . \u2265 t\u03b4JJ .\nThe last inequality holds because \u2211\nJ\u2208I \u03b3(m J) =\n1. From this we get that \u2016wt+1\u20162 \u2265 (\u03b4JJ)2t2 since \u2016u\u2016=1. Second,\n\u2016wt+1\u20162 = \u2016wt + \u2211 J\u2208I \u03b3(mJ)\u2206\u03c6(x, y,mJ)\u20162\n= \u2016wt\u20162 + \u2016 \u2211 J\u2208I \u03b3(mJ)\u2206\u03a6(x, y,mJ)\u20162\n+ 2wt \u00b7 \u2211 J\u2208I \u03b3(mJ)\u2206\u03a6(x, y,mJ).\nFrom \u03b3 selection condition (2) we get that: \u2016wt+1\u20162 \u2264 \u2016wt\u20162 + \u2016 \u2211 J\u2208I \u03b3(mJ)\u2206\u03a6(x, y,mJ)\u20162\n\u2264 \u2016wt\u20162 + \u2211 J\u2208I \u03b3(mJ)\u2016\u2206\u03a6(x, y,mJ)\u20162 \u2264 \u2016wt\u20162 + (RJJ)2. (radius property)\nThe inequality one before the last results from the Jensen inequality which holds due to (a) \u03b3 selection condition (1); and (b) the squared norm function being convex. From this we finally get:\n\u2016wt+1\u20162 \u2264 \u2016wt\u20162 + (RJJ)2 \u2264 . . . \u2264 t(RJJ)2.\nCombining the two steps we get: (\u03b4JJ)2t2 \u2264 \u2016wt+1\u20162 \u2264 t(RJJ)2.\nFrom this it is easy to derive the upper bound in the theorem: t \u2264 (R JJ )2\n(\u03b4JJ )2 ."}, {"heading": "4.2 Convergence Properties", "text": "We next point on three properties of the SWVP algorithm, derived from its convergence proof:\nProperty 1 (tighter iterations bound) The convergence proof of CSP (Collins, 2002) is given for a vector u that linearly separates the data, with margin \u03b4 and for a data radius R. Following observation 1, it holds that in our case, u also linearly separates the data with respect to mixed assignments with a set JJ and with margin \u03b4JJ \u2265 \u03b4. Together with the definition of RJJ \u2264 R we get that: (R JJ )2\n(\u03b4JJ )2 \u2264 R2 \u03b42 .\nThis means that the bound on the number of updates made by SWVP is tighter than the bound of CSP.\nProperty 2 (inference) From the \u03b3 selection conditions it holds that any label from which at least one violating MA can be derived through JJx is suitable for an update. This is because in such a case we can choose, for example, a SETGAMMA function that assigns the weight of 1 to that MA, and the weight of 0 to all other MAs.\nAlgorithm 2 employs the argmax inference function, following the basic reasoning that it is a good choice to base the parameter update on. Importantly, if the inference function is argmax and the algorithm performs an update (y\u2217 6= y), this means that y\u2217, the output of the argmax function, is a violating MA by definition. However, it is obvious that solving the inference problem and the optimal \u03b3 assignment problems jointly may result in more informed parameter (w) updates. We leave a deeper investigation of this issue to future research.\nProperty 3 (dynamic updates) The \u03b3 selection conditions paragraph states two conditions ((a) and (b)) under which the convergence proof holds. While it is trivial for SETGAMMA to generate a \u03b3 vector that respects condition (a), if there is a parameter vector w\u2019 achievable by the algorithm for which SETGAMMA cannot generate \u03b3 that respects condition (b), SWVP gets stuck when reaching w\u2019.\nThis problem can be solved with dynamic updates. A deep look into the convergence proof reveals that the set JJx and the SETGAMMA function can actually differ between iterations. While this will change the bound on the number of iterations, it will not change the fact that the algorithm converges if the data is linearly separable. This makes SWVP highly flexible as it can always\nback off to the CSP setup of JJx = {[Lx]}, and \u2200(x, y) \u2208 D : \u03b3(m[Lx]) = 1, update its parameters and continue with its original JJ and SETGAMMA when this option becomes feasible. If this does not happen, the algorithm can continue till convergence with the CSP setup."}, {"heading": "4.3 Mistake and Generalization Bounds", "text": "The following bounds are proved: the number of updates in the separable case (see Theorem 1); the number of mistakes in the non-separable case (see Appendix B); and the probability to misclassify an unseen example (see Appendix B). It can be shown that in the general case these bounds are tighter than those of the CSP special case. We next discuss variants of SWVP."}, {"heading": "5 Passive Aggressive SWVP", "text": "Here we present types of update rules that can be implemented within SWVP. Such rule types are defined by: (a) the selection of \u03b3, which should respect the \u03b3 selection conditions (see Definition 3) and (b) the selection of JJ = {JJx \u2286 2[Lx]|(x, y) \u2208 D}, the substructure sets for the training examples.\n\u03b3 Selection A first approach we consider is the aggressive approach4 where only mixed assignments that are violations {mJ : J \u2208 Iv} are exploited (i.e. for all J \u2208 Inv, \u03b3(mJ) = 0). Note, that in this case condition (2) of the \u03b3 selection conditions trivially holds as: w \u00b7\n\u2211 J\u2208Iv \u03b3(mJ)\u2206\u03c6(x, y,mJ) \u2264 0.\nThe only remaining requirement is that condition (1) also holds, i.e. that \u2211 J\u2208Iv \u03b3(m J) = 1.\nThe opposite, passive approach, exploits only non-violating MA\u2019s {mJ : J \u2208 Inv}. However, such \u03b3 assignments do not respect \u03b3 selection condition (2), as they yield: w \u00b7\u2211\nJ\u2208Inv \u03b3(m J)\u2206\u03c6(x, y,mJ) \u2264 0 which holds if and only if for every J \u2208 Inv, \u03b3(mJ) = 0 that in turn contradicts condition (1).\nFinally, we can take a balanced approach which gives a positive \u03b3 coefficient for at least one violating MA and at least one positive \u03b3 coefficient for a non-violating MA. This approach is allowed by SWVP as long as both \u03b3 selection conditions hold.\n4We borrow the term passive-aggressive from (Crammer et al., 2006), despite the substantial difference between the works.\nWe implemented two weighting methods, both based on the concept of margin: (1) Weighted Margin (WM): \u03b3(mJ) = |w\u00b7\u2206\u03c6(x,y,mJ )|\u03b2\u2211 J\u2032\u2208JJx |w\u00b7\u2206\u03c6(x,y,mJ\u2032 )|\u03b2 (2) Weighted Margin Rank (WMR):\n\u03b3(mJ) = ( |JJx|\u2212r |JJx| )\u03b2 . where r is the rank of |w \u00b7 \u2206\u03c6(x, y,mJ(y\u2217, y))| among the |w \u00b7\u2206\u03c6(x, y,mJ \u2032(y\u2217, y))| values for J \u2032 \u2208 JJx.\nBoth schemes were implemented twice, within a balanced approach (denoted as B) and an aggressive approach (denoted as A).5 The aggressive schemes respect both \u03b3 selection conditions. The balanced schemes, however, respect the first condition but not necessarily the second. Since all models that employ the balanced weighting schemes converged after at most 10 iterations, we did not impose this condition (which we could do by, e.g., excluding terms for J \u2208 Inv till condition (2) holds).\nJJ Selection Another choice that strongly affects the updates made by SWVP is that of JJ . A choice of JJx = 2[Lx], for every (x, y) \u2208 D results in an update rule which considers all possible mixing assignments derived from the predicted label y\u2217 and the gold label y. Such an update rule, however, requires computing a sum over an exponential number of terms (2Lx) and is therefore highly inefficient.\nAmong the wide range of alternative approaches, in this paper we exploit single difference mixed assignments. In this approach we define: JJ = {JJx = {{1}, {2}, . . . {Lx}}|(x, y) \u2208 D}. For a training pair (x, y) \u2208 D, a predicted label y\u2217 and J = {j} \u2208 JJx, we will have:\nmJk (y \u2217, y) = { yk k 6= j y\u2217k k = j\nUnder this approach for the pair (x, y) \u2208 D only Lx terms are summed in the SWVP update rule. We leave a further investigation of JJ selection approaches to future research."}, {"heading": "6 Experiments", "text": "Synthetic Data We experiment with synthetic data generated by a linear-chain, first-\n5 For the aggressive approach the equations for schemes (1) and (2) are changed such that JJx is replaced with I(y\u2217, y, JJx) v .\norder Hidden Markov Model (HMM, (Rabiner and Juang, 1986)). Our learning algorithm is a liner-chain conditional random field (CRF, (Lafferty et al., 2001)): P (y|x) =\n1 Z(x) \u220f i=1:Lx\nexp(w \u00b7 \u03c6(yi\u22121, yi, x)) (where Z(x) is a normalization factor) with binary indicator features {xi, yi, yi\u22121, (xi, yi), (yi, yi\u22121), (xi, yi, yi\u22121)} for the triplet (yi, yi\u22121, x).\nA dataset is generated by iteratively sampling K items, each is sampled as follows. We first sample a hidden state, y1, from a uniform prior distribution. Then, iteratively, for i = 1, 2, . . . , Lx we sample an observed state from the emission probability and (for i < Lx) a hidden state from the transition probability. We experimented in 3 setups. In each setup we generated 10 datasets that were subsequently divided to a 7000 items training set, a 2000 items development set and a 1000 items test set. In all datasets, for each item, we set Lx = 8. We experiment in three conditions: (1) simple(++), learnable(+++), (2) simple(++), learnable(++) and (3) simple(+), learnable(+).6\nFor each dataset (3 setups, 10 datasets per setup) we train variants of the SWVP algorithm differing in the \u03b3 selection strategy (WM or WMR, Section 5), being aggressive (A) or passive (B), and in their \u03b2 parameter (\u03b2 = {0.5, 1, . . . , 5}). Training is done on the training subset and the best performing variant on the development subset is applied to the test subset. For CSP no development set is employed as there is no hyper-parameter to tune. We report averaged accuracy (fraction of observed states for which the model successfully predicts the hidden state value) across the test sets, together with the standard deviation.\nDependency Parsing We also report initial dependency parsing results. We implemented our algorithms within the TurboParser (Martins et al., 2013).\n6 Denoting Dx = [Cx], Dy = [Cy], and a permutation of a vector v with perm(v), the parameters of the different setups are: (1) simple(++), learnable(+++): Cx = 5, Cy = 3, P (y\u2032|y) = perm(0.7, 0.2, 0.1), P (x|y) = perm(0.75, 0.1, 0.05, 0.05, 0.05). (2) simple(++), learnable(++): Cx = 5, Cy = 3, P (y\u2032|y) = perm(0.5, 0.3, 0.2), P (x|y) = perm(0.6, 0.15, 0.1, 0.1, 0.05). (3) simple(+), learnable(+): Cx = 20 , Cy = 7 , P (y\u2032|y) = perm(0.7, 0.2, 0.1, 0, . . . , 0)), P (x|y) = perm(0.4, 0.2, 0.1, 0.1, 0.1, 0, . . . , 0).\nThat is, every other aspect of the parser: feature set, probabilistic pruning algorithm, inference algorithm etc., is kept fixed but training is performed with SWVP. We compare our results to the parser performance with CSP training (which comes with the standard implementation of the parser).\nWe experiment with the datasets of the CoNLL 2007 shared task on multilingual dependency parsing (Nilsson et al., 2007), for a total of 9 languages. We followed the standard train/test split of these dataset. For SWVP, we randomly sampled 1000 sentences from each training set to serve as development sets and tuned the parameters as in the synthetic data experiments. CSP is trained on the training set and applied to the test set without any development set involved. We report the Unlabeled Attachment Score (UAS) for each language and model."}, {"heading": "7 Results", "text": "Synthetic Data Table 1 presents our results. In all three setups an SWVP algorithm is superior. Averaged accuracy differences between the best performing algorithms and CSP are: 3.72 (B-WMR, (simple(++), learnable(+++))), 5.29 (B-WM, (simple(++), learnable(++))) and 5.18 (A-WM, (simple(+), learnable(+))). In all setups SWVP outperforms CSP in terms of averaged performance (except from B-WMR for (simple(+), learnable(+))). Moreover, the weighted models are more stable than CSP, as indicated by the lower standard deviation of their accuracy scores. Finally, for the more simple and learnable datasets the SWVP models outperform CSP in the majority of cases (7-10/10).\nWe measure generalization from development to test data in two ways. First, for each SWVP algorithm we count the number of times its \u03b2 parameter results in an algorithm that outperforms the CSP on the development set but not on the test set (not shown in the table). Of the 120 comparisons reported in the table (4 SWVP models, 3 setups, 10 comparisons per model/setup combination) this happened once (A-MV, (simple(++), learnable(+++)).\nSecond, we count the number of times the best development set value of the \u03b2 hyper-parameter is also the best value on the test set, or the test set accuracy with the best development set \u03b2 is at most 0.5% lower than that with the best test set \u03b2. The Gener-\nalization column of the table shows that this has not happened in all of the 120 runs of SWVP.\nDependency Parsing Results are given in Table 2. For the SWVP trained models we report three numbers: (a) B-WM is the standard setup where the \u03b2 hyper parameter is tuned on the development data; (b) For Top B-WM we first selected the models with a UAS score within 0.1% of the best development data result, and of these we report the UAS of the model that performs best on the test set; and (c) Test B-WM reports results when \u03b2 is tuned on the test set. This measure provides an upper bound on SWVP with our simplistic JJ (Section 5).\nOur results indicate the potential of SWVP. Despite our simple JJ set, Top B-WM and Test B-WM improve over CSP in 5/9 and 6/9 cases in first order parsing, respectively, and in 7/9 cases in second order parsing. In the latter case, Test B-WM improves the UAS over CSP in 0.22% on average across languages. Unfortunately, SWVP still does not generalize well from train to test data as indicated, e.g., by the modest improvements B-WM achieves over CSP in only 5 of 9 languages in second order parsing."}, {"heading": "8 Conclusions", "text": "We presented the Structured Weighted Violations Perceptron (SWVP) algorithm, a generalization of the Structured Perceptron (CSP) algorithm that explicitly exploits the internal structure of the predicted label in its update rule. We proved the convergence of the algorithm for linearly separable training sets under certain conditions on its parameters, and provided generalization and mistake bounds.\nIn experiments we explored only very simple configurations of the SWVP parameters - \u03b3 and JJ . Nevertheless, several of our SWVP variants outperformed the CSP special case in synthetic data experiments. In dependency parsing experiments, SWVP demonstrated some improvements over CSP, but these do not generalize well. While we find these results somewhat encouraging, they emphasize the need to explore the much more flexible \u03b3 and JJ selection strategies allowed by SWVP (Sec. 4.2). In future work we will hence develop \u03b3 and JJ selection algorithms, where selection is ideally performed jointly with inference (property 2, Sec. 4.2), to make SWVP practically useful in NLP applications."}, {"heading": "A Proof Observation 1.", "text": "Observation 1. For linearly separable data D and a set JJ , every unit vector u that separates the data with margin \u03b4, also separates the data with respect to mixed assignments with JJ , with margin \u03b4JJ \u2265 \u03b4. Likewise, it holds that RJJ \u2264 R.\nProof. For every training example (x, y) \u2208 D, it holds that: \u222az\u2208Y(x)mJ(z, y) \u2286 Y(x). As u separates the data with margin \u03b4, it holds that:\nu \u00b7\u2206\u03c6(x, y,mJ(z, y)) \u2265 \u03b4JJx , \u2200z \u2208 Y(x), J \u2208 JJx. u \u00b7\u2206\u03c6(x, y, z) \u2265 \u03b4, \u2200z \u2208 Y(x).\nTherefore also \u03b4JJx \u2265 \u03b4. As the last inequality holds for every (x, y) \u2208 D we get that \u03b4JJ = min(x,y)\u2208D \u03b4JJx \u2265 \u03b4. From the same considerations it holds that RJJ \u2264 R. This is because RJJ is the radius of a subset of the dataset with radius R (proper subset if \u2203(x, y) \u2208 D, [Lx] /\u2208 JJx, non-proper subset otherwise)."}, {"heading": "B Mistake and Generalization Bounds - Non Separable Case", "text": "Mistake Bound Here we provide a mistake bound for the algorithm in the non-separable case. We start with the following definition and observation:\nDefinition 8. Given an example (xi, yi) \u2208 D, for a u, \u03b4 pair define:\nri = u \u00b7 \u03c6(xi, yi)\u2212 max z\u2208Y(xi) u \u00b7 \u03c6(xi, z)\ni = max{0, \u03b4 \u2212 ri}\nri JJ = u \u00b7 \u03c6(xi, yi)\u2212 max\nz\u2208Y(xi),J\u2208JJxi u \u00b7 \u03c6(xi,mJ(z, yi))\nFinally define: Du,\u03b4 = \u221a n\u2211 i=1 2i\nObservation 2. For all i: ri \u2264 riJJ . Observation 2 easily follows from Definition 8. Following this observation we denote: rdiff = mini{ri\nJJ \u2212 ri} \u2265 0 and present the next theorem: Theorem 2. For any training sequence D, for the first pass over the training set of the CSP and the\nSWVP algorithms respectively, it holds that:\n#mistakes\u2212 CSP \u2264 min u:\u2016u\u2016=1,\u03b4>0\n(R+Du,\u03b4) 2\n\u03b42 .\n#mistakes\u2212 SWV P \u2264 min u:\u2016u\u2016=1,\u03b4>0\n(RJJ +Du,\u03b4) 2\n(\u03b4 + rdiff )2 .\nAs RJJ \u2264 R (Observation 1) and rdiff \u2265 0, we get a tighter bound for SWVP. The proof for #mistakes-CSP is given at (Collins, 2002). The proof for #mistakes-SWVP is given below.\nProof. We transform the representation \u03c6(x, y) \u2208 Rd into a new representation \u03c8(x, y) \u2208 Rd+n as follows: for i = 1, ..., d : \u03c8i(x, y) = \u03c6i(x, y), for j = 1, ..., n : \u03c8d+j(x, y) = \u2206 if (x, y) = (xj , yj) and 0 otherwise, where \u2206 > 0 is a parameter. Given a u, \u03b4 pair define v \u2208 Rd+n as follows: for i = 1, ..., d : vi = ui, for j = 1, ..., n : vd+j = j \u2206 . Under these definitions we have:\nv \u00b7 \u03c8(xi, yi)\u2212 v \u00b7 \u03c8(xi, z) \u2265 \u03b4, \u2200i, z \u2208 Y(xi).\nFor every i, z \u2208 Y(xi), J \u2208 JJxi :\nv \u00b7 \u03c8(xi, yi)\u2212 v \u00b7 \u03c8(xi,mJ(z, yi)) \u2265 \u03b4 + rdiff .\n\u2016\u03c8(xi, yi)\u2212 \u03c8(xi,mJ(z, yi))\u20162 \u2264 (RJJ)2 + \u22062.\nLast, we have,\n\u2016v\u20162 = \u2016u\u20162 + n\u2211 i=1 2i \u22062 = 1 + D2u,\u03b4 \u22062 .\nWe get that the vector v\u2016v\u2016 linearly separates the data with respect to single decision assignments with margin \u03b4\u221a\n1+ D2 U,\u03b4\n\u22062\n. Likewise, v\u2016v\u2016 linearly separates\nthe data with respect to mixed assignments with JJ , with margin \u03b4+r\ndiff\u221a 1+\nDu,\u03b4 \u22062\n. Notice that the first pass\nof SWVP with representation \u03a8 is identical to the first pass with representation \u03a6 because the parameter weight for the additional features affects only a single example of the training data and do not affect the classification of test examples. By theorem 1 this means that the first pass of SWVP with representation \u03a8 makes at most ((R\nJJ )2+\u22062) (\u03b4+rdiff )2\n\u00b7 ( 1 +\nD2u,\u03b4 \u22062\n) .\nWe minimize this w.r.t \u2206, which gives: \u2206 =\u221a RJJDu,\u03b4, and obtain the result guaranteed in the theorem.\nWe have bounded the number of mistakes SWVP is making in an on-line setup. We next provide guarantees as to how well the algorithm generalizes to a new example.\nGeneralization Bound Let us consider the training set D as an ordered sequence: D = {(x1, y1), . . . , (xn, yn)}, and let us run the SWVP online algorithm on this sequence. At each round t = 1, . . . , n, the algorithm may update the weight vector w, so we get a sequence of weight vectors w1, . . . ,wn, from which we can create an hypotheses sequence of the form ht(x) = arg maxy\u2032\u2208Y(x) wt \u00b7 \u03c6(x, y\u2032).\nTo check the algorithm success in generalizing to a new test example (xn+1, yn+1), we need to decide which hypothesis to use from the above sequence, under the assumption that both the training examples and the new test example are drawn i.i.d from an (unknown) distribution P (x, y).\nFreund and Schapire (1999) presented the voted perceptron, a batch variant of the perceptron algorithm, and (Collins, 2002) presented an approximation for this variant called the averaged parameters perceptron that holds the same generalization guarantees. We adapt the averaged parameters setting to our algorithm. The resulting adaptation of (Freund and Schapire, 1999) then states:\nTheorem 3 (Freund & Schapire 99). Assume all examples are generated i.i.d. at random. Let (x1, y1), . . . , (xn, yn) be a sequence of training examples and let (xn+1, yn+1) be a test example. For a pair u, \u03b4 such that \u2016u\u2016 = 1 and \u03b4 > 0 define Du,\u03b4 as before. Then the probability (over the choice of n+1 examples) that the voted SWVP algorithm does not predict yn+1 on test instance xn+1 is at most\n2\nn+ 1 En+1\n( inf\nu:\u2016u\u2016=1,\u03b4>0 (RJJ +DU,\u03b4) 2 (\u03b4 + rdiff )2\n)\nwhere En+1 is an expected value taken over n + 1 examples.\nNote that the adaptation of (Freund and Schapire, 1999) to the original CSP algorithm provided by (Collins, 2002) gives the generalization bound\nof 2n+1En+1 (\ninf u:\u2016u\u2016=1,\u03b4>0\n(R+DU,\u03b4) 2\n\u03b42\n) . This means\nthat the generalization bound of SWVP is upper\nbounded by the generalization bound of CSP (convergence property 1 and theorem 2)."}, {"heading": "Acknowledgments", "text": "The second author was partly supported by a research grant from the GIF Young Scientists\u2019 Program (No. I-2388-407.6/2015): Syntactic Parsing in Context."}], "references": [{"title": "Incremental parsing with the perceptron algorithm", "author": ["Collins", "Roark2004] Michael Collins", "Brian Roark"], "venue": "In Proc. of ACL", "citeRegEx": "Collins et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Collins et al\\.", "year": 2004}, {"title": "Three generative, lexicalised models for statistical parsing", "author": ["Michael Collins"], "venue": "In Proc. of ACL,", "citeRegEx": "Collins.,? \\Q1997\\E", "shortCiteRegEx": "Collins.", "year": 1997}, {"title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms", "author": ["Michael Collins"], "venue": "In Proc. of EMNLP,", "citeRegEx": "Collins.,? \\Q2002\\E", "shortCiteRegEx": "Collins.", "year": 2002}, {"title": "Ultraconservative online algorithms for multiclass problems", "author": ["Crammer", "Singer2003] Koby Crammer", "Yoram Singer"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Crammer et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Crammer et al\\.", "year": 2003}, {"title": "Learning as search optimization: Approximate large margin methods for structured prediction", "author": ["III Daum\u00e9", "III Marcu2005] Hal Daum\u00e9", "Marcu. Daniel"], "venue": "In Proc. of ICML,", "citeRegEx": "Daum\u00e9 et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Daum\u00e9 et al\\.", "year": 2005}, {"title": "Large margin classification using the perceptron algorithm", "author": ["Freund", "Schapire1999] Yoav Freund", "Robert E Schapire"], "venue": "Machine learning,", "citeRegEx": "Freund et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Freund et al\\.", "year": 1999}, {"title": "An efficient algorithm for easyfirst non-directional dependency parsing", "author": ["Goldberg", "Elhadad2010] Yoav Goldberg", "Michael Elhadad"], "venue": "In Proc. of NAACL-HLT", "citeRegEx": "Goldberg et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Goldberg et al\\.", "year": 2010}, {"title": "Knowledge-based weak supervision for information extraction of overlapping relations", "author": ["Congle Zhang", "Xiao Ling", "Luke Zettlemoyer", "Daniel S Weld"], "venue": "In Proc. of ACL", "citeRegEx": "Hoffmann et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Hoffmann et al\\.", "year": 2011}, {"title": "Structured perceptron with inexact search", "author": ["Huang et al.2012] Liang Huang", "Suphan Fayong", "Yang Guo"], "venue": "In Proc. of NAACL-HLT,", "citeRegEx": "Huang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2012}, {"title": "Efficient third-order dependency parsers", "author": ["Koo", "Collins2010] Terry Koo", "Michael Collins"], "venue": "In Proc. of ACL,", "citeRegEx": "Koo et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Koo et al\\.", "year": 2010}, {"title": "Conditional random fields: Probabilistic models for segmenting and labeling sequence data", "author": ["Andrew McCallum", "Fernando CN Pereira"], "venue": "In Proc. of ICML", "citeRegEx": "Lafferty et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lafferty et al\\.", "year": 2001}, {"title": "Turning on the turbo: Fast third-order non-projective turbo parsers", "author": ["Miguel Almeida", "Noah A Smith"], "venue": "In Prc. of ACL short papers,", "citeRegEx": "Martins et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Martins et al\\.", "year": 2013}, {"title": "Online learning of approximate dependency parsing algorithms", "author": ["McDonald", "Pereira2006] Ryan T McDonald", "Fernando CN Pereira"], "venue": "In Proc. of EACL", "citeRegEx": "McDonald et al\\.,? \\Q2006\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2006}, {"title": "Online largemargin training of dependency parsers", "author": ["Koby Crammer", "Fernando Pereira"], "venue": "In Proc. of ACL,", "citeRegEx": "McDonald et al\\.,? \\Q2005\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2005}, {"title": "Nonprojective dependency parsing using spanning tree algorithms", "author": ["Fernando Pereira", "Kiril Ribarov", "Jan Haji\u010d"], "venue": "In Proc. of EMNLP-HLT,", "citeRegEx": "McDonald et al\\.,? \\Q2005\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2005}, {"title": "Learning efficiently with approximate inference via dual losses", "author": ["Meshi et al.2010] Ofer Meshi", "David Sontag", "Tommi Jaakkola", "Amir Globerson"], "venue": "In Proc. of ICML", "citeRegEx": "Meshi et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Meshi et al\\.", "year": 2010}, {"title": "The conll 2007 shared task on dependency parsing", "author": ["Nilsson et al.2007] Jens Nilsson", "Sebastian Riedel", "Deniz Yuret"], "venue": "In Proceedings of the CoNLL shared task session of EMNLP-CoNLL,", "citeRegEx": "Nilsson et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nilsson et al\\.", "year": 2007}, {"title": "An introduction to hidden markov models", "author": ["Rabiner", "Juang1986] Lawrence Rabiner", "BiingHwang Juang"], "venue": "ASSP Magazine,", "citeRegEx": "Rabiner et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Rabiner et al\\.", "year": 1986}, {"title": "Multi event extraction guided by global constraints", "author": ["Reichart", "Barzilay2012] Roi Reichart", "Regina Barzilay"], "venue": "In Proc. of NAACL-HLT", "citeRegEx": "Reichart et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Reichart et al\\.", "year": 2012}, {"title": "Max-margin markov networks", "author": ["Taskar et al.2004] Ben Taskar", "Carlos Guestrin", "Daphne Koller"], "venue": "In Proc. of NIPS", "citeRegEx": "Taskar et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Taskar et al\\.", "year": 2004}, {"title": "Large margin methods for structured and interdependent output variables", "author": ["Thorsten Joachims", "Thomas Hofmann", "Yasemin Altun"], "venue": "In Journal of Machine Learning Research,", "citeRegEx": "Tsochantaridis et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Tsochantaridis et al\\.", "year": 2005}, {"title": "Online learning of relaxed ccg grammars for parsing to logical form", "author": ["Zettlemoyer", "Collins2007] Luke S Zettlemoyer", "Michael Collins"], "venue": "In Proc. of EMNLP-CoNLL,", "citeRegEx": "Zettlemoyer et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Zettlemoyer et al\\.", "year": 2007}, {"title": "Joint word segmentation and pos tagging using a single perceptron", "author": ["Zhang", "Clark2008] Yue Zhang", "Stephen Clark"], "venue": "In proc. of ACL,", "citeRegEx": "Zhang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 2, "context": "We present the Structured Weighted Violations Perceptron (SWVP) algorithm, a new structured prediction algorithm that generalizes the Collins Structured Perceptron (CSP, (Collins, 2002)).", "startOffset": 170, "endOffset": 185}, {"referenceID": 2, "context": "The structured perceptron ((Collins, 2002), henceforth denoted CSP) is a prominent training algorithm for structured prediction models in NLP, due to its effective parameter estimation and simple implementation.", "startOffset": 27, "endOffset": 42}, {"referenceID": 11, "context": "It has been utilized in numerous NLP applications including word segmentation and POS tagging (Zhang and Clark, 2008), dependency parsing (Koo and Collins, 2010; Goldberg and Elhadad, 2010; Martins et al., 2013), semantic parsing (Zettlemoyer and Collins, 2007) and information extraction (Hoffmann et al.", "startOffset": 138, "endOffset": 211}, {"referenceID": 7, "context": ", 2013), semantic parsing (Zettlemoyer and Collins, 2007) and information extraction (Hoffmann et al., 2011; Reichart and Barzilay, 2012), if to name just a few.", "startOffset": 85, "endOffset": 137}, {"referenceID": 19, "context": "structured SVM (Taskar et al., 2004; Tsochantaridis et al., 2005), MIRA (Crammer and Singer, 2003) and LaSo (Daum\u00e9 III and Marcu, 2005)), CSP considers in its update rule the difference between complete predicted and gold standard labels (Sec.", "startOffset": 15, "endOffset": 65}, {"referenceID": 20, "context": "structured SVM (Taskar et al., 2004; Tsochantaridis et al., 2005), MIRA (Crammer and Singer, 2003) and LaSo (Daum\u00e9 III and Marcu, 2005)), CSP considers in its update rule the difference between complete predicted and gold standard labels (Sec.", "startOffset": 15, "endOffset": 65}, {"referenceID": 15, "context": ", 2005a) and dual-loss based methods (Meshi et al., 2010)) it does not exploit the structure of the predicted label.", "startOffset": 37, "endOffset": 57}, {"referenceID": 8, "context": "Our concept of violating assignment is based on Huang et al. (2012) that presented a variant of the CSP algorithm where the argmax inference problem is replaced with a violation finding function.", "startOffset": 48, "endOffset": 68}, {"referenceID": 1, "context": "In the general case Lx is a set of output sizes, which may be finite or infinite (as in constituency parsing (Collins, 1997)).", "startOffset": 109, "endOffset": 124}, {"referenceID": 8, "context": "Violation The next central concept is that of a violation, originally presented by Huang et al. (2012):", "startOffset": 83, "endOffset": 103}, {"referenceID": 8, "context": "This paper therefore extends the observation of Huang et al. (2012) that perceptron parameter update can be performed w.", "startOffset": 48, "endOffset": 68}, {"referenceID": 2, "context": "While the proof of this theorem resembles that of the CSP (Collins, 2002), unlike the CSP proof the SWVP proof relies on the \u03b3 selection conditions presented above and on the Jensen inequality.", "startOffset": 58, "endOffset": 73}, {"referenceID": 2, "context": "Property 1 (tighter iterations bound) The convergence proof of CSP (Collins, 2002) is given for a vector u that linearly separates the data, with margin \u03b4 and for a data radius R.", "startOffset": 67, "endOffset": 82}, {"referenceID": 10, "context": "Our learning algorithm is a liner-chain conditional random field (CRF, (Lafferty et al., 2001)): P (y|x) =", "startOffset": 71, "endOffset": 94}, {"referenceID": 11, "context": "We implemented our algorithms within the TurboParser (Martins et al., 2013).", "startOffset": 53, "endOffset": 75}, {"referenceID": 16, "context": "We experiment with the datasets of the CoNLL 2007 shared task on multilingual dependency parsing (Nilsson et al., 2007), for a total of 9 languages.", "startOffset": 97, "endOffset": 119}, {"referenceID": 2, "context": "The proof for #mistakes-CSP is given at (Collins, 2002).", "startOffset": 40, "endOffset": 55}, {"referenceID": 2, "context": "Freund and Schapire (1999) presented the voted perceptron, a batch variant of the perceptron algorithm, and (Collins, 2002) presented an approximation for this variant called the averaged parameters perceptron that holds the same generalization guarantees.", "startOffset": 108, "endOffset": 123}, {"referenceID": 2, "context": "Note that the adaptation of (Freund and Schapire, 1999) to the original CSP algorithm provided by (Collins, 2002) gives the generalization bound", "startOffset": 98, "endOffset": 113}], "year": 2016, "abstractText": "We present the Structured Weighted Violations Perceptron (SWVP) algorithm, a new structured prediction algorithm that generalizes the Collins Structured Perceptron (CSP, (Collins, 2002)). Unlike CSP, the update rule of SWVP explicitly exploits the internal structure of the predicted labels. We prove the convergence of SWVP for linearly separable training sets, provide mistake and generalization bounds, and show that in the general case these bounds are tighter than those of the CSP special case. In synthetic data experiments with data drawn from an HMM, various variants of SWVP substantially outperform its CSP special case. SWVP also provides encouraging initial dependency parsing results.", "creator": "LaTeX with hyperref package"}}}