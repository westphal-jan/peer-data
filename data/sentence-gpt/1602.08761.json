{"id": "1602.08761", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Feb-2016", "title": "Resource Constrained Structured Prediction", "abstract": "We study the problem of structured prediction under test-time budget constraints. We propose a novel approach applicable to a wide range of structured prediction problems in computer vision and natural language processing. Our approach seeks to adaptively generate computationally costly features during test-time in order to reduce the computational cost of prediction while maintaining prediction performance. We show that training the adaptive feature generation system can be reduced to a series of structured learning problems, resulting in efficient training using existing structured learning algorithms. This framework provides theoretical justification for several existing heuristic approaches found in literature. We evaluate our proposed adaptive system on two real-world structured prediction tasks, optical character recognition (OCR) and dependency parsing. For OCR our method cuts the feature acquisition time by half coming within a 1% margin of top accuracy. For dependency parsing we realize an overall runtime gain of 20% without significant loss in performance. The model is a model of functional, predictive, and predictive processing in the computational learning and prediction systems.", "histories": [["v1", "Sun, 28 Feb 2016 19:44:57 GMT  (458kb,D)", "https://arxiv.org/abs/1602.08761v1", null], ["v2", "Wed, 8 Jun 2016 01:31:01 GMT  (446kb,D)", "http://arxiv.org/abs/1602.08761v2", null]], "reviews": [], "SUBJECTS": "stat.ML cs.CL cs.CV cs.LG", "authors": ["tolga bolukbasi", "kai-wei chang", "joseph wang", "venkatesh saligrama"], "accepted": true, "id": "1602.08761"}, "pdf": {"name": "1602.08761.pdf", "metadata": {"source": "CRF", "title": "Resource Constrained Structured Prediction", "authors": ["Tolga Bolukbasi", "Kai-Wei Chang", "Joseph Wang", "Venkatesh Saligrama"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Structured prediction is a powerful and flexible framework for making a joint prediction over mutually dependent output variables. It has been successfully applied to a wide range of computer vision and natural language processing tasks ranging from text classification to human detection. However, the superior performance and flexibility of structured predictors come at the cost of computational complexity. In order to construct computationally efficient algorithms, a trade-off must be made between the expressiveness and speed of structured models.\nThe cost of inference in structured prediction can be broken down into three parts: acquiring the features, evaluating the part responses and solving a combinatorial optimization problem to make a prediction based on part responses. Past research has focused on evaluating part responses and solving the combinatorial optimization problem, and proposed efficient inference algorithms for specific structures (e.g., Viterbi and CKY parsing algorithms) and general structures (e.g., variational inference [8]). However, these methods overlook feature acquisition and part response, which are bottlenecks when the underlying structure is relative simple or is efficiently solved.\nConsider the dependency parsing task, where the goal is to create a directed tree that describes semantic relations between words in a sentence. The task can be formulated as a structured prediction problem, where the inference problem concerns finding the maximum spanning trees (MSTs) in a directed graphs [12]. Each node in the graph represents a word, and the directed edge (xi, xj) represents how likely xj depends on xi. Fig. 1 shows an example of a dependency parse and the trade off between a rich set of features and the prediction time. Introducing complex features has the potential to increase system performance, however they only distinguish among a small subset of \u201cdifficult\u201d parts. Therefore, computing complex features for all parts on every example is both computationally costly and unnecessary to achieve high levels of performance.\nWe address the problem of structured prediction under test-time budget constraints, where the goal is to learn a system that is computationally efficient during test-time with little loss of predictive performance. We consider test-time costs associated with the computational cost of evaluating feature transforms or acquiring new sensor measurements. Intuitively, our goal is to learn a system\nar X\niv :1\n60 2.\n08 76\n1v 2\n[ st\nat .M\nL ]\n8 J\nun 2\n01 6\nthat identifies the parts in each example incorrectly classified/localized using \u201ccheap\u201d features and additionally yield large reductions in error over the entire structure given \u201cexpensive\u201d features due to improved distinguishability and relationships to other parts in the example.\nWe consider two forms of the budgeted structured learning problem, prediction under expected budget constraints and anytime prediction. For both cases, we consider the streaming test-time scenario where the system operates on each test example without observation or interaction of other test examples. In the expected budget constraint setting, the system chooses features to acquire for each example, to minimize prediction error subject to an average feature cost constraint. A fixed budget is given by the user during training time, and during test-time, the system is tasked with both allocating resources as well as determining the features to be acquired with the allocated resources. In the anytime structured prediction setting, the system chooses features to be acquired sequentially for each example to minimize prediction error at each time step, allowing for accurate prediction at anytime. No budget is specified by the user during training time. Instead,the system sequentially chooses features to minimize prediction error at any time as features are acquired. This setting requires a single system able to predict for any budget constraint on each example.\nWe learn systems capable of adaptive feature acquisition for both settings. We propose learning policy functions to exploit relationships between parts and adapt to varying length examples. This problem naturally reduces policy learning to a structured learning problem, allowing the original model to be used with minor modification. The resulting systems reduce prediction cost during test-time with minimal loss of predictive performance. We summarize our contributions as follows: \u2022 Formulation of structured prediction under expected budget constraints and anytime prediction. \u2022 Reduction of both these settings to conventional structured prediction problems. \u2022 Demonstration that structured models benefit from having access to features of multiple complexities and can perform well when a only a subset of parts use the expensive features."}, {"heading": "2 Budgeted Structured Learning", "text": "We begin with reviewing structured prediction problem and formulating it under an expected budget constraint. We then extend the formulation to anytime structured prediction.\nStructured Prediction: The goal in structured prediction is to learn a function, F , that maps from an input space, X , to a structure space, Y . In contrast to multi-class classification, the space of outputs Y is not simply categorical but instead is assumed to be some exponential space of outputs (often of varying size dependent on the feature space) containing some underlying structure, generally represented by multiple parts and relationships between parts. For example, in dependency parsing, x \u2208 X are features representing a sentence (e.g., words, pos tags), and y \u2208 Y is a parse tree. In a structured prediction model, the mapping function F is often modeled as F \u2261 maxy\u2208Y \u03a8(x, y), where \u03a8 : (X,Y )\u2192 R is a scoring function. We assume the score can be broken up into sub-scores across components C, \u03a8(x, y) = \u2211 c\u2208C \u03c8c(x, yc), where yc is the output assignment associated with the component c. The number of sub-components, |C|, varies across examples. For the dependency parsing example, each c is an edge in the directed graphs, and yc is an indicator variable for whether the edge is in the parse tree. The score of a parse tree consists of the scores \u03c8c(x, yc) of all its edges."}, {"heading": "2.1 Structured Prediction Under an Expected Budget", "text": "Our goal is to reduce the cost of prediction during test-time (representing computational time, energy consumption, etc.). We consider the case where a variety of scoring functions are available to be used for each component. Additionally, associated with each scoring function is an evaluation cost (such as the time or energy consumption required to extract the features for the scoring function).\nFor each example, we define a state S \u2208 S, where the space of states is defined S = {0, 1}K\u00d7|C|, representing which of the K features is used for the |C| components during prediction. In the state, the element S(k, c) = 1 indicates that the kth feature will be used during prediction for component c. For any state S, we define the evaluation cost: c(S) = \u2211 c\u2208C \u2211 k\u2208K S(k, c)\u03b4k, where \u03b4k is the (known) cost of evaluating the kth feature for a single part.\nWe assume that we are given a structured prediction model F : X \u00d7 S \u2192 Y that maps from a set of features X \u2208 X and a state S \u2208 S to a structured label prediction Y\u0302 \u2208 Y . For a predicted label, we have a loss L : Y \u00d7 Y \u2192 R that maps from a predicted and true structured label, Y\u0302 and Y , respectively, to an error cost, generally either an indicator error, L(Y\u0302 , Y ) = 1\u2212 \u220fk i=1 1Y\u0302 (i)=Y (i),\nor a Hamming error, L(Y\u0302 , Y ) = \u2211k i=1 1Y\u0302 (i) 6=Y (i). For an example (X,Y ) and state S, we now define the modified loss C(X,Y, S) = L (F (X,S), Y ) + \u03bbc(S) that represents the error induced by predicting a label from X using the sensors in S combined with the cost of acquiring the sensors in S, where \u03bb is a trade-off pattern adjusted according to the budget B1. A small value of \u03bb encourages correct classification at the expense of feature cost, whereas a large value of \u03bb penalizes use of costly features, enforcing a tighter budget constraint. We define a policy \u03c0 : X \u2192 S that maps from the feature space X and the initial state S0 to a new state. For ease of reference, we refer to this policy as the feature selection policy. Our goal is to learn a policy \u03c0 chosen from a family of functions \u03a0 that, for a given example X , maps to a state with minimal expected modified loss, \u03c0\u2217 = argmin\u03c0\u2208\u03a0ED [C (X,Y, \u03c0 (X))] . In practice, D denotes a set of I.I.D training examples:\n\u03c0\u2217 = argmin\u03c0\u2208\u03a0 \u2211n\ni=1 C (Xi, Yi, \u03c0 (Xi)) . (1)\nNote that the objective of the minimization can be expanded with respect to the space of states, allowing the optimization problem in (1) to be expressed \u03c0\u2217 = argmin\u03c0\u2208\u03a0 \u2211n i=1 \u2211 S\u2208S C (Xi, Yi, S)1\u03c0(Xi)=S . From this, we can reformulate the problem of learning a policy as a structured learning problem. Theorem 2.1. The minimization in (1) is equivalent to the structured learning problem:\nargmin \u03c0\u2208\u03a0 n\u2211 i=1 \u2211 S\u2208S ( max S\u0303\u2208S C(Xi, Yi, S\u0303)\u2212 C (Xi, Yi, S) ) 1\u03c0(Xi)6=S .\nProofs can be found in Suppl. Material. Theorem 2.1 maps the policy learning problem in (1) to a weighted structured learning problem. For each example Xi, an example/label pair is created for each state S with an importance weight representing the savings lost by not choosing the state S.\nUnfortunately, the expansion of the cost function over the space of states introduces the summation over the combinatorial space of states. To avoid this, we instead introduce an approximation to the objective in (1). Using a single indicator function, we formulate the approximate policy\n\u03c0\u0302 = argmin\u03c0\u2208\u03a0 \u2211n\ni=1\n[ W (Xi, Yi)1\u03c0(Xi)6=S\u2217(Xi,Yi) + C (Xi, Yi, S \u2217(Xi, Yi)) ] , (2)\nwhere the pseudo-label is defined: S\u2217(Xi, Yi) = argminS\u2208S C (Xi, Yi, S) (3)\nand the example weight is defined asW (Xi, Yi) = maxS\u2032\u2208S C (Xi, Yi, S\u2032)\u2212C (Xi, Yi, S\u2217(Xi, Yi)). This formulation reduces the objective from a summation over the combinatorial set of states to a single indicator function for each example and represents an upper-bound on the original risk. Theorem 2.2. The objective in (2) is an upper-bound on the objective in (1).\nNote that the second term (2) is not dependent on \u03c0. Thus, Theorem 2.2 leads to an efficient algorithm for learning a policy function \u03c0 by solving an importance-weighted structured learning problem:\n\u03c0\u0302 = argmin\u03c0\u2208\u03a0 \u2211n\ni=1 W (Xi, Yi)1\u03c0(Xi)6=S\u2217(Xi,Yi), (4)\nwhere each example Xi having a pseudo-label S\u2217(Xi, Yi) and importance weight W (Xi, Yi).\n1Our framework does not restrict the type of modified loss, C(X,Y, S), or the state cost, C(S) and extends to general losses\nCombinatorial Search Space: Finding the psuedo-label in Eqn. (3) involves searching over the combinatorially large search space of states, S, which is computationally intractable. Instead, we present trajectory-based and parsimonious pseudo-labels for approximating S\u2217.\nTrajectory Search: The trajectory-based pseudo-label is a greedy approximation to the optimization in Eqn. (3). To this end, define S+i as the 1-stage feasible transitions: Sti = {S | d(S, S\u0302 t\u22121 i ) \u2264 1, S \u2227 S\u0302t\u22121i = S\u0302 t\u22121 i }, where d is the Hamming distance. We define a trajectory of states S\u0302ti where S\u0302ti = argminS\u2208Sti C(Xi, Yi, S). The initial state is assumed to be S\u0302 0 i = 0\nK\u00d7|C| where none of the K features are evaluated for the C components. For each example i, we obtain a trajectory S0i , S 1 i , . . . , S T i , where the terminal state S T i is the all-one state. We choose the pseudo-label from the trajectory: S\u0302\u2217i = argminS\u2208{S\u03020i ,...,S\u0302Ti } C(Xi, Yi, S). Note that by restricting the search space of states differing by a single component, the approximation needs to only perform a polynomial search over states as opposed to the exhaustive combinatorial search in Eqn. (3). Observe that the modified loss is not strictly decreasing, as the cost of adding features may outweigh the reduction in loss at any time. Empirically, this approach is computationally tractable and is shown to produce strong results.\nParsimonious Search: Rather than a trajectory search, which requires an inference update as we acquire more features, we consider an alternative one stage update here. The idea is to look for 1-step transitions that can potentially improve the cost. We then simultaneously update all the features that produce improvement. This obviates the need for a trajectory search. In addition we can incorporate a guaranteed loss improvement for our parsimonious search. S+i \u2208 argminS\u2208Sti 1{C(Xi,Yi,St\u22121i )\u2265C(Xi,Yi,S)+\u03c4}. Note that the potential candidate transitions can be non-unique and thus we generate a collection of potential state transitions, S+i . To obtain the final state we take the union over these transitions, namely, S\u0302\u2217 = \u2228 S\u2208S+i\nS. Suppose we set the margin \u03c4 = 0, replace the cost-function with the loss function then this optimization is relatively simple (assuming that acquiring more features does not increase the loss). This is because the new state is simply the collection of transitions where the sub-components are incorrect. Finding the parsinomious pseudo-label is computationally efficient and empirically shows similar performance to the trajectory-based pseudo-label.\nChoosing the pseudo-label requires knowledge of the budget B to set the cost trade-off parameter \u03bb. If the budget is unspecified or varies over time, a system capable of adapting to changing budget demands is necessary. To handle this scenario, we propose an anytime system in the next section."}, {"heading": "2.2 Anytime Structured Prediction", "text": "In many applications, the budget constraint is unknown a priori or varies from example to example due to changing resource availability and an expected budget system as in Section 2.1 does not yield a feasible system. We instead consider the problem of learning an anytime system [6]. In this setting, a single system is designed such that when a new example arrives during test-time, features are acquired until an arbitrary budget constraint (that may vary over different examples) is met for the particular example. Note that an anytime system is a special case of the expected budget constrained system. Instead of an expected budget, instead a hard per-example budget is given. A single system is applied to all feasible budgets, as opposed to learning unique systems for each budget constraint.\nWe model the anytime learning problem as sequential state selection. The goal is to select a trajectory of states, starting from an initial state S0 = 0k\u00d7|C| where all components use features with negligible cost. To select this trajectory of states, we define policy functions \u03c01, . . . , \u03c0T , where \u03c0t : X \u00d7S \u2192 S is a function that maps from a set of structured features X and current state S to a new state S\u2032.\nThe sequential selection system is then defined by the policy functions \u03c01, . . . , \u03c0T . For an exampleX , the policy functions produce a trajectory of states S1(X) . . . , ST (X) defined as follows: St(X) = \u03c0t(X,St\u22121(X)), S0(X) = S0.\nOur goal is to learn a system with small expected loss at any time t \u2208 [0, T ]. Formally, we define this as the average modified loss of the system over the trajectory of states:\n\u03c0\u22171 , ...,\u03c0 \u2217 T = argmin\u03c01,...,\u03c0T\u2208\u03a0(1/T )ED [\u2211T t=1 C ( X,Y, St(X) )] (5)\nAlgorithm 1 Anytime Policy Learning input Training set, {Xi, Yi}i=1,...,n set S0i = 0 \u2200i = 1, ..., n, t = 1 while A(Si) 6= \u2205 for any i do\nTrain \u03c0t according to Thm. 2.3 for i \u2208 [n] do\nUpdate states: Sti = \u03c0t(Xi, S t\u22121 i )\nt\u2190 t+ 1 return \u03c0 = {\u03c01, . . . , \u03c0T }\nAlgorithm 2 Anytime Structured Prediction input Policy, \u03c01, ..., \u03c0T , Example, X , Budget, B set S0 = 0, t = 0 while A(St) 6= \u2205 and c(St) < B do\nSt+1 = \u03c0t(X,S t), t\u2190 t+ 1\nreturn y = F (X,St)\nwhere \u03a0 is a user-specified family of functions. Unfortunately, the problem of learning the policy functions is highly coupled due to the dependence of the state trajectory on all policy functions. Note that as there is no fixed budget, the choice of \u03bb dictates the behavior of the anytime system. Decreasing \u03bb leads to larger increases in classification performance at the expense of budget granularity.\nWe propose a greedy approximation to the policy learning problem by sequentially learning policy functions \u03c01, . . . , \u03c0T that minimize the modified loss:\n\u03c0t = argmin\u03c0\u2208\u03a0ED [ C ( X,Y, St(X) )] (6)\nfor t \u2208 {1, . . . , T}. Note that the \u03c0t selected in (6) does not take into account the future effect on the loss in (5). We consider \u03c0t in (6) to be a greedy approximation as it is instead chosen to minimize the immediate loss at time t.\nWe restrict the output space of states for the policy \u03c0t to have the same non-zero components as the previous state with a single feature added. This space of states can be defined S(S) = {S\u2032|d(S\u2032, S) = 1, S\u2032 \u2227 S = S}, where d is the Hamming distance. Note that this mirrors the trajectory used for the trajectory-based pseudo-label.\nAs in Section 2.1, we take an empirical risk minimization approach to learning policies. To this end we sequentially learn a set of function \u03c01, . . . , \u03c0T minimizing the risk:\nargmin \u03c0\u2208\u03a0 n\u2211 i=1 \u2211 s\u2208S(St\u22121(Xi)) C (Xi, Yi, s)1\u03c0(Xi,St\u22121(Xi))=s, (7)\nenumerating over the space of states that the policy \u03c0t can map each example. Note that the space of states S(St\u22121(Xi)) may be empty if all features are acquired for example Xi by step t\u2212 1. As in Thm. 2.1, the problem of learning the sequence of policy functions \u03c01, . . . , \u03c0T can be viewed as a weighted structured learning problem. Theorem 2.3. The optimization problem in (7) is equivalent to solving an importance weighted structured learning problem using an indicator risk of the form:\nargmin \u03c0\u2208\u03a0 n\u2211 i=1 \u2211 s\u2208S(St\u22121(Xi)) W (Xi, Yi, s)1\u03c0(Xi,St\u22121(Xi)) 6=s, (8)\nwhere the weight is defined: W (Xi, Yi, s) = maxs\u2032\u2208S(St\u22121(Xi)) C(Xi, Yi, s \u2032)\u2212 C (Xi, Yi, s) .\nThis is equivalent to an importance weighted structured learning problem, where each state s in S(St\u22121(Xi)) defines a pseudo-label for the example Xi with an associated importance( maxs\u2032\u2208S(St\u22121(Xi)) C(Xi, Yi, s \u2032)\u2212 C (Xi, Yi, s) ) .\nTheorem 2.3 reduces the problem of learning a policy to an importance weighted structured learning problem. Replacement of the indicators with upper-bounding convex surrogate functions results in a convex minimization problem to learn the policies \u03c01, ..., \u03c0T . In particular, use of a hinge-loss surrogate converts this problem to the commonly used structural SVM. Experimental results show significant cost savings by applying this sequential policy.\nThe training algorithm is presented in Algorithm 1. At time t = 0, the policy \u03c01 is trained to minimize the immediate loss. Given this policy, the states of examples at time t = 1 are fixed, and \u03c02 is trained to minimize the immediate loss given these states. The algorithm continues learning policies until every feature for every example as been acquired. During test-time, the system sequentially applies the trained policy functions until the specified budget is reaches, as shown in Algorithm 2."}, {"heading": "3 Related Work", "text": "Multi-class prediction with test-time budget has received significant attention (see e.g., [20, 3, 1, 9, 26, 18, 10, 21, 22]). Fundamentally, multi-class classification based approaches cannot be directly applied to structured settings for two reasons: (1) Structured Feature Selection Policy: Unlike multiclass prediction, in a structured setting, we have many parts with associated features and costs for each part. This often requires a coupled adaptive part by part feature selection policy applied to varying structures; (2) Structured Inference Costs: In contrast to multi-class prediction, structured prediction requires solving a constrained optimization problem in test-time, which is often computationally expensive and must be taken into account.\nStrubell et al. [16] improve the speed of a parser that operates on search-based structured prediction models, where joint prediction is decomposed to a sequence of decisions. In such a case, resourceconstrained multi-class approaches can be applied, however this reduction only applies to search-based models that are fundamentally different from the graph-based models we discussed (with different types of theoretical guarantees and use cases). Applying their policy to the case of graphical models requires repeated inferences, dramatically increasing the computational cost when inference is slow.2\nSimilar observations apply to Weiss et al. [23, 25], who present a scheme for adaptive feature selection assuming the computational costs of policy execution and inference are negligible. Their approach uses a reinforcement learning scheme, requiring inference at each step of their policy to estimate rewards. For complex inference tasks, repeatedly executing the policy (performing inference) can negate any computational gains induced by adaptive feature selection (see Fig. 3 in [25]).\nHe et al. [7] use imitation learning to adaptively select features for dependency parsing. Their approach can be viewed as an approximation of Eqn. (4) with a parsimonious search. Although their policy avoids performing inference to estimate reward, multiple inferences are required for each instance due to the design of action space. Overhead is avoided by exploiting the specific inference structure (maximal spanning tree over fully connected graph), and it is unclear if it can be generalized.\nMethods to increase the speed of inference (predicting the given part responses) have been proposed [24, 14]. These approaches can be incorporated into our approach to further reduce computational cost and therefore are complementary. More focused research has improved the speed of individual algorithms such as object detection using deformable parts models [4, 27] and dependency parsing [7, 16]. These methods are specialized, failing to generalize to varying graph size and/or structures and relying on problem-specific heuristics or algorithm-specific properties.\nAdaptive features approaches have been designed to improve accuracy, including easy-first decoding strategies [5, 15], however these methods focus on performance as opposed to computational cost."}, {"heading": "4 Experiments", "text": "In this section, we demonstrate the effectiveness of the proposed algorithm on two structured prediction tasks in different domains: dependency parsing and OCR. We report the results on both anytime and expected case policies and refer to the latter one as one-shot policy. Our focus is mainly on the policy and not on achieving the state of the art performance on either of these domains.\nAt a high-level, policies for resource constrained structured prediction must manage & tradeoff benefits of three resources, namely, feature acquisition costs, intermediate inferencing costs, and policy overhead costs that decides between feature acquisition and inferencing. Some methods as described earlier account for feature costs but not inference and overhead costs. Other methods incorporate inference into their policy (meta-features) for selecting new features but do not account for the resulting policy overhead. Our approach poses policy optimization as a structured learning problem and in turn jointly optimizes these resources as demonstrated empirically in our experiments.\nWe compare our system to the Q-learning approach in [25] and two baselines: a uniform policy and a myopic policy. The uniform policy takes random part level actions. The uniform policy will help us show that the performance of our policy does not come from removing redundant features, but clever allocation of them among samples. As a second baseline, we adapt the myopic policy used by\n2The equivalent policy of [16] applied to our inference algorithm is marked as the myopic policy in our experiments. Due to the high cost of repeated inference, the resulting policy is computationally intensive.\nFigure 3: The performance of our one-shot policy (in red) is compared to the uniform strategy (in black) and policy of Weiss et. al. [25] for the OCR dataset. Although the policy with complex features is more efficient with features, the simple feature policy has a lower total run-time in the low budget region due to the overhead of additional inference.\n[18] to the structured prediction case. The myopic policy runs the structured predictor initially on all cheap features, then looks at the total confidence of the classifier normalized by the sample size (e.g. sentence length). If the confidence is below a threshold, it chooses to acquire expensive features for all positions. Finally, we compare against the Q-learning method proposed by [25]. This method requires global features for structures with varying size. From now on we will refer to features that require access to more than one part as complex features and part level features as simple features. In their case, they use confidence feedback from the structured predictor which induces additional inference overhead for the policy. In addition to this, it is not straightforward to apply this approach to do part by part feature selection on structures with varying sizes.\nWe adopt Structured-SVM [19] to solve the policy learning problems for expected and anytime cases defined in (4) and (8), respectively. For the structure of the policy \u03c0 we use a graph with no edges due to its simplicity. In this form, the policy learning problem can be written as a sample weighted SVM. We discuss the details in the appendix due to space constraints.\nWe show in the following that complex features indeed benefit the policy, but simple features perform better for cases where the inference time and feature costs are comparable and the additional overhead is unwanted. Finally, we show that part by part selection outperforms global selection.\nOptical Character Recognition We tested our algorithm on a sequence-label problem, the OCR dataset [17] composed of 6,877 handwritten words, where each word is represented as a sequence of 16x8 binary letter images. We use a linear-chain Markov model, and similar to the setup in [23, 21], use raw pixel values and HOG features with 3x3 cell size as our feature templates. We split the data such that 90% percent is used for training and 10% is used for test.\nFig. 3 shows the average letter accuracy vs. total running time. The proposed system reduces the budget for all performance levels, with a savings of up to 50 percent at the top performance. Note that Weiss13 can not operate on part by part level when the graph structure is varying. We see that using complex part by part selection has significant advantage over using uniform feature templates. Furthermore, Fig 2 shows the behavior of the policy on an individual example for the anytime model, significant gains in accuracy are made in first several steps by correctly identifying the noisy letters.\nDependency Parsing We follow the setting in [7] and conduct experiments on English Penn Treebank (PTB) corpus [11]. All algorithms are implemented based on the graph-based dependency parser [12] in Illinois-SL library [2], where the code is optimized for speed. Two sets of feature templates are considered for the parser. 3 The first (\u03c8Full) considers the part-of-speech (POS) tags and lexicons of xi, xj , and their surrounding words (see [12]). The other (\u03c8POS) only considers the POS features.\n3 Complex features often contribute to small performance improvement. Adding complex or redundant features can easily yield arbitrarily large speedups, and comparing speedups of different systems with different accuracy levels is not meaningful (see Fig. 3 in [7]). In addition, greedy-style parser such as [16] might be faster by nature. Discussing different architecture and features is outside the scope of this paper.\nThe policy assigns one of these two feature templates to each word in the sentence, such that all the directed edges (xi, xj) corresponding to the word xi share the same feature templates. The first feature template, \u03c8POS, takes 165 \u00b5s per word and the second feature template, \u03c8Full, takes 275 \u00b5s per word to extract the features and compute edge scores. The decoding by Chu\u2013Liu-Edmonds algorithm is 75 \u00b5s per word, supporting our hypothesis that feature extraction makes a significant portion of the total running time yet the inference time is not negligible. Due to the space limit, we present further details of the experiment setting in the appendix.\nFig. 4 shows the test performance (unlabeled attachment accuracy) along with inference time. We see that all one-shot policies perform similarly, losing negligible accuracy when using half of the available expensive features. When we apply the length dictionary filtering heuristic in [7, 13], our parser achieves 89.7% UAS on PTB section 23 with overall running time merely 7.5 seconds (I/O excluded, 10s with I/O) and obtains 2.9X total speed-up with losing only 1% UAS comparing to the baseline. 4 This significant speed-up over an efficient implementation is remarkable. 5\nAlthough marginal, one-shot policy with greedy trajectory has the strongest performance in low budget regions. This is because the greedy trajectory search has better granularity than parsimonious search in choosing positions that decrease the loss early on. The anytime policy is below one-shot policy for all budget levels. As discussed in 2.2, the anytime policy is more constrained in that it has to achieve a fixed budget for all examples. The naive myopic policy performs worse than uniform since it has to run inference on samples with low confidence two times, adding approximately 4.5 seconds of extra time for the full test dataset. We then explore the effect of importance weights for the greedy policy. We notice a small improvement. We hypothesize that this is due to the policy functional complexity being a limiting factor.\nWe also conduct ablative studies to better understand the policy behavior. Fig. 4 shows the distribution of depth for the words that use expensive and cheap features in the ground truth dependency tree. We expect investing more time on the low-depth words (root in the extreme) to yield higher accuracy gains. We observe this phenomenon empirically, as the policy concentrates on extracting features close to the root.\n4This heuristic only works for parsing. Therefore, we exclude it when presenting Figure 4 as it does not reflect the performance of policies in general.\n5In contrast, the baseline system in [7] is slow than us by about three times. When operating in the accuracy level of 90%, Figure 3 in [7] shows that their final system takes about 20s. We acknowledge that [7] use different features, policy settings, and hardware from ours; therefore these numbers might not be comparable."}, {"heading": "A Proofs", "text": "Proof of Theorem 2.1 The objective in (1) can be expressed:\nn\u2211 i=1 \u2211 S\u2208S C (Xi, Yi, S)1\u03c0(Xi)=S\n= n\u2211 i=1 \u2211 S\u2208S C (Xi, Yi, S) ( 1\u2212 1\u03c0(Xi)6=S ) =\nn\u2211 i=1 [ max S\u2032\u2208S C(Xi, Yi, S \u2032)\u2212max S\u2032\u2208S C(Xi, Yi, S \u2032)\n+ \u2211 S\u2208S C (Xi, Yi, S) ( 1\u2212 1\u03c0(Xi)6=s\n) ] .\nNote that \u2211 S\u2208S ( 1\u2212 1\u03c0(Xi)6=S ) = 1, allowing for further simplification:\n= n\u2211 i=1 [ max S\u2032\u2208S C(Xi, Yi, s \u2032)\n+ \u2211 s\u2208S ( C (Xi, Yi, S)\u2212max S\u2032\u2208S C(Xi, Yi, S \u2032) ) ( 1\u2212 1\u03c0(Xi)6=S ) ]\n= n\u2211 i=1 [ max S\u2032\u2208S C(Xi, Yi, S \u2032)\n+ \u2211 S\u2208S ( max S\u2032\u2208S C(Xi, Yi, S \u2032)\u2212 C (Xi, Yi, S) )( 1\u03c0(Xi)6=s \u2212 1 ) ] .\nRemoving constant terms (that do not affect the output of the argmin) yields the expression in Thm. 2.1.\nProof of Theorem 2.2 For a single example/label pair (Xi, Yi), consider the two possible values of the term in the summation of (4). In the event that \u03c0(Xi) = S\u2217(Xi, Yi):\nW (Xi, Yi)1\u03c0(Xi)6=S\u2217(Xi,Yi) + C(Xi, Yi, S \u2217(Xi, Yi))\n= C(Xi, Yi, S \u2217(Xi, Yi)),\nwhich is equivalent to the value of (2) if \u03c0(Xi) = S\u2217(Xi, Yi). Otherwise, \u03c0(Xi) 6= S\u2217(Xi, Yi), and therefore:\nW (Xi, Yi)1\u03c0(Xi)6=S\u2217(Xi,Yi) + C(Xi, Yi, S \u2217(Xi, Yi))\n=W (Xi, Yi) + C(Xi, Yi, S \u2217(Xi, Yi))\n= max S\u2032\u2208S\nC(Xi, Yi, S \u2032).\nThis is an upper-bound on (1), and therefore (2) is a valid upper-bound on (1).\nProof of Theorem 2.3 Note that the objective in (7) can be expressed:\nn\u2211 i=1 \u2211 S\u2208S(St\u22121(Xi)) C (Xi, Yi, S)1\u03c0(Xi,St\u22121(Xi))=S\n= n\u2211 i=1 \u2211 S\u2208S(St\u22121(Xi)) C (Xi, Yi, S) ( 1\u2212 1\u03c0(Xi,St\u22121(Xi))6=S ) =\nn\u2211 i=1\n[ max\nS\u2032\u2208S(St\u22121(Xi) C(Xi, Yi, S\n\u2032)\n\u2212 max S\u2032\u2208S(St\u22121(Xi))\nC(Xi, Yi, S \u2032)\n+ \u2211\nS\u2208S(St\u22121(Xi))\nC (Xi, Yi, S) ( 1\u2212 1\u03c0(Xi,St\u22121(Xi))6=S ) ] .\nNote that \u2211 S\u2208S(St\u22121)(Xi) ( 1\u2212 1\u03c0(Xi,St\u22121(Xi))6=S ) = 1, allowing for further simplification:\n= n\u2211 i=1\n[ max\nS\u2032\u2208S(St\u22121)(Xi) C(Xi, Yi, S\n\u2032)\n+ \u2211\nS\u2208S(St\u22121(Xi))\n( C (Xi, Yi, S)\n\u2212 max S\u2032\u2208S(St\u22121(Xi))\nC(Xi, Yi, S \u2032) )( 1\u2212 1\u03c0(Xi,St\u22121(Xi))6=s ) ]\n= n\u2211 i=1\n[ max\nS\u2032\u2208S(St\u22121(Xi)) C(Xi, Yi, S\n\u2032)\n+ \u2211\nS\u2208S(St\u22121(Xi))\n( max\nS\u2032\u2208S(St\u22121)(Xi)) C(Xi, Yi, S\n\u2032)\n\u2212C (Xi, Yi, S) )( 1\u03c0(Xi,St\u22121(Xi))6=S \u2212 1 ) ] .\nRemoving constant terms (that do not affect the output of the argmin) yields the expression in (8).\nB Implementation details\nDependency parsing We split PTB corpus into two parts, Sections 02-22 and Section 23 as training and test sets. We then conduct a modified cross-validation mechanism to train the feature selector and the dependency parser. Note that the cost of policy is dependent on the structured predictor. Therefore, learning policy on the same training set of the predictor may cause the structured loss to be overly optimistic. We follow the cross validation scheme in to deal with this issue by splitting the training data into n folds. For each fold, we generate label predictions based on the structured predictor trained on the remaining folds. Finally, we gather these label predictions and train a policy on the complete data.\nThe dependency parser is trained by the averaged Structured Perceptron modelwith learning rate and number of epochs set to be 0.1 and 50, respectively. This setting achieves the best test performance as reported in Notice that if we trained two dependency models with different feature sets separately the scale of the edge scores may be different, resulting sub-optimal test performance. To fix this issue, we generate data with random edge features and train the model to minimize the joint loss over all states.\nminw\u03bb||w||2 + 1\nn n\u2211 i=1 ES [L(Fw(Xi, S), Yi)]\nFinally, We found that for dependency parsing expensive features are only necessary in several critical locations in the sentence. Therefore, budget levels above 10% turned out to be unachievable for any feature-tradeoff parameter lambda in the pseudo-labels. To obtain those regions, we varied the class weights of feature templates in the training of one-shot feature selector."}], "references": [{"title": "Fast classification using sparse decision DAGs", "author": ["R. Busa-Fekete", "D. Benbouzid", "B. K\u00e9gl"], "venue": "29th International Conference on Machine Learning ", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "IllinoisSL: A JAVA Library for Structured Prediction", "author": ["K.-W. Chang", "S. Upadhyay", "M.-W. Chang", "V. Srikumar", "D. Roth"], "venue": "arXiv preprint arXiv:1509.07179", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "Classifier cascade for minimizing feature evaluation cost", "author": ["M. Chen", "K.Q. Weinberger", "O. Chapelle", "D. Kedem", "Z. Xu"], "venue": "International Conference on Artificial Intelligence and Statistics, pages 218\u2013226", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Object detection with discriminatively trained part-based models", "author": ["P.F. Felzenszwalb", "R.B. Girshick", "D. McAllester", "D. Ramanan"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on, 32(9):1627\u2013 1645", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "An efficient algorithm for easy-first non-directional dependency parsing", "author": ["Y. Goldberg", "M. Elhadad"], "venue": "Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 742\u2013750. Association for Computational Linguistics", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Speedboost: Anytime prediction with uniform near-optimality", "author": ["A. Grubb", "D. Bagnell"], "venue": "International Conference on Artificial Intelligence and Statistics, pages 458\u2013466", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "Dynamic Feature Selection for Dependency Parsing", "author": ["H. He", "H. Daum\u00e9 III", "J. Eisner"], "venue": "EMNLP, pages 1455\u20131464", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "An introduction to variational methods for graphical models", "author": ["M.I. Jordan", "Z. Ghahramani", "T.S. Jaakkola", "L.K. Saul"], "venue": "Machine learning, 37(2):183\u2013233", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1999}, {"title": "Dynamic feature selection for classification on a budget", "author": ["S. Karayev", "M. Fritz", "T. Darrell"], "venue": "International Conference on Machine Learning (ICML): Workshop on Prediction with Sequential Models", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Feature-Cost Sensitive Learning with Submodular Trees of Classifiers", "author": ["M.J. Kusner", "W. Chen", "Q. Zhou", "Z.E. Xu", "K.Q. Weinberger", "Y. Chen"], "venue": "AAAI, pages 1939\u20131945", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Building a large annotated corpus of English: The Penn Treebank", "author": ["M.P. Marcus", "M.A. Marcinkiewicz", "B. Santorini"], "venue": "Computational linguistics, 19(2):313\u2013330", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1993}, {"title": "Non-projective dependency parsing using spanning tree algorithms", "author": ["R. McDonald", "F. Pereira", "K. Ribarov", "J. Haji\u010d"], "venue": "Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing, pages 523\u2013530. Association for Computational Linguistics", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}, {"title": "Vine pruning for efficient multi-pass dependency parsing learned prioritization for trading off accuracy and speed", "author": ["A. Rush", "S. Petrov"], "venue": "NAACL", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Learning Where to Sample in Structured Prediction", "author": ["T. Shi", "J. Steinhardt", "P. Liang"], "venue": "AISTATS", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "Easy-first Coreference Resolution", "author": ["V. Stoyanov", "J. Eisner"], "venue": "COLING, pages 2519\u20132534. Citeseer", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Learning Dynamic Feature Selection for Fast Sequential Prediction", "author": ["E. Strubell", "L. Vilnis", "K. Silverstein", "A. McCallum"], "venue": "arXiv preprint arXiv:1505.06169", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "Max-Margin Markov Networks", "author": ["B. Taskar", "C. Guestrin", "D. Koller"], "venue": "Advances in Neural Information Processing Systems, page None", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}, {"title": "Supervised sequential classification under budget constraints", "author": ["K. Trapeznikov", "V. Saligrama"], "venue": "Proceedings of the Sixteenth International Conference on Artificial Intelligence and Statistics, pages 581\u2013589", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Large margin methods for structured and interdependent output variables", "author": ["I. Tsochantaridis", "T. Joachims", "T. Hofmann", "Y. Altun"], "venue": "Journal of Machine Learning Research, pages 1453\u20131484", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "Robust real-time object detection", "author": ["P. Viola", "M. Jones"], "venue": "International Journal of Computer Vision, 4", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2001}, {"title": "Model selection by linear programming", "author": ["J. Wang", "T. Bolukbasi", "K. Trapeznikov", "V. Saligrama"], "venue": "Computer Vision\u2013ECCV 2014, pages 647\u2013662. Springer", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "An LP for Sequential Learning Under Budgets", "author": ["J. Wang", "K. Trapeznikov", "V. Saligrama"], "venue": "Proceedings of the Seventeenth International Conference on Artificial Intelligence and Statistics, pages 987\u2013995", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Dynamic structured model selection", "author": ["D. Weiss", "B. Sapp", "B. Taskar"], "venue": "Proceedings of the IEEE International Conference on Computer Vision, pages 2656\u20132663", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "Structured Prediction Cascades", "author": ["D. Weiss", "B. Taskar"], "venue": "International Conference on Artificial Intelligence and Statistics, pages 916\u2013923", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2010}, {"title": "Learning adaptive value of information for structured prediction", "author": ["D.J. Weiss", "B. Taskar"], "venue": "Advances in Neural Information Processing Systems, pages 953\u2013961", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Cost-Sensitive Tree of Classifiers", "author": ["Z. Xu", "M. Kusner", "M. Chen", "K.Q. Weinberger"], "venue": "Proceedings of the 30th International Conference on Machine Learning (ICML-13), pages 133\u2013141", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2013}, {"title": "Active deformable part models inference", "author": ["M. Zhu", "N. Atanasov", "G.J. Pappas", "K. Daniilidis"], "venue": "Computer Vision\u2013ECCV 2014, pages 281\u2013296. Springer", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2014}], "referenceMentions": [{"referenceID": 7, "context": ", variational inference [8]).", "startOffset": 24, "endOffset": 27}, {"referenceID": 11, "context": "The task can be formulated as a structured prediction problem, where the inference problem concerns finding the maximum spanning trees (MSTs) in a directed graphs [12].", "startOffset": 163, "endOffset": 167}, {"referenceID": 5, "context": "We instead consider the problem of learning an anytime system [6].", "startOffset": 62, "endOffset": 65}, {"referenceID": 19, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 2, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 0, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 8, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 25, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 17, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 9, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 20, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 21, "context": ", [20, 3, 1, 9, 26, 18, 10, 21, 22]).", "startOffset": 2, "endOffset": 35}, {"referenceID": 15, "context": "[16] improve the speed of a parser that operates on search-based structured prediction models, where joint prediction is decomposed to a sequence of decisions.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[23, 25], who present a scheme for adaptive feature selection assuming the computational costs of policy execution and inference are negligible.", "startOffset": 0, "endOffset": 8}, {"referenceID": 24, "context": "[23, 25], who present a scheme for adaptive feature selection assuming the computational costs of policy execution and inference are negligible.", "startOffset": 0, "endOffset": 8}, {"referenceID": 24, "context": "3 in [25]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 6, "context": "[7] use imitation learning to adaptively select features for dependency parsing.", "startOffset": 0, "endOffset": 3}, {"referenceID": 23, "context": "Methods to increase the speed of inference (predicting the given part responses) have been proposed [24, 14].", "startOffset": 100, "endOffset": 108}, {"referenceID": 13, "context": "Methods to increase the speed of inference (predicting the given part responses) have been proposed [24, 14].", "startOffset": 100, "endOffset": 108}, {"referenceID": 3, "context": "More focused research has improved the speed of individual algorithms such as object detection using deformable parts models [4, 27] and dependency parsing [7, 16].", "startOffset": 125, "endOffset": 132}, {"referenceID": 26, "context": "More focused research has improved the speed of individual algorithms such as object detection using deformable parts models [4, 27] and dependency parsing [7, 16].", "startOffset": 125, "endOffset": 132}, {"referenceID": 6, "context": "More focused research has improved the speed of individual algorithms such as object detection using deformable parts models [4, 27] and dependency parsing [7, 16].", "startOffset": 156, "endOffset": 163}, {"referenceID": 15, "context": "More focused research has improved the speed of individual algorithms such as object detection using deformable parts models [4, 27] and dependency parsing [7, 16].", "startOffset": 156, "endOffset": 163}, {"referenceID": 4, "context": "Adaptive features approaches have been designed to improve accuracy, including easy-first decoding strategies [5, 15], however these methods focus on performance as opposed to computational cost.", "startOffset": 110, "endOffset": 117}, {"referenceID": 14, "context": "Adaptive features approaches have been designed to improve accuracy, including easy-first decoding strategies [5, 15], however these methods focus on performance as opposed to computational cost.", "startOffset": 110, "endOffset": 117}, {"referenceID": 24, "context": "We compare our system to the Q-learning approach in [25] and two baselines: a uniform policy and a myopic policy.", "startOffset": 52, "endOffset": 56}, {"referenceID": 15, "context": "The equivalent policy of [16] applied to our inference algorithm is marked as the myopic policy in our experiments.", "startOffset": 25, "endOffset": 29}, {"referenceID": 24, "context": "[25] for the OCR dataset.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18] to the structured prediction case.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "Finally, we compare against the Q-learning method proposed by [25].", "startOffset": 62, "endOffset": 66}, {"referenceID": 18, "context": "We adopt Structured-SVM [19] to solve the policy learning problems for expected and anytime cases defined in (4) and (8), respectively.", "startOffset": 24, "endOffset": 28}, {"referenceID": 16, "context": "Optical Character Recognition We tested our algorithm on a sequence-label problem, the OCR dataset [17] composed of 6,877 handwritten words, where each word is represented as a sequence of 16x8 binary letter images.", "startOffset": 99, "endOffset": 103}, {"referenceID": 22, "context": "We use a linear-chain Markov model, and similar to the setup in [23, 21], use raw pixel values and HOG features with 3x3 cell size as our feature templates.", "startOffset": 64, "endOffset": 72}, {"referenceID": 20, "context": "We use a linear-chain Markov model, and similar to the setup in [23, 21], use raw pixel values and HOG features with 3x3 cell size as our feature templates.", "startOffset": 64, "endOffset": 72}, {"referenceID": 6, "context": "Dependency Parsing We follow the setting in [7] and conduct experiments on English Penn Treebank (PTB) corpus [11].", "startOffset": 44, "endOffset": 47}, {"referenceID": 10, "context": "Dependency Parsing We follow the setting in [7] and conduct experiments on English Penn Treebank (PTB) corpus [11].", "startOffset": 110, "endOffset": 114}, {"referenceID": 11, "context": "All algorithms are implemented based on the graph-based dependency parser [12] in Illinois-SL library [2], where the code is optimized for speed.", "startOffset": 74, "endOffset": 78}, {"referenceID": 1, "context": "All algorithms are implemented based on the graph-based dependency parser [12] in Illinois-SL library [2], where the code is optimized for speed.", "startOffset": 102, "endOffset": 105}, {"referenceID": 11, "context": "3 The first (\u03c8Full) considers the part-of-speech (POS) tags and lexicons of xi, xj , and their surrounding words (see [12]).", "startOffset": 118, "endOffset": 122}, {"referenceID": 6, "context": "3 in [7]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 15, "context": "In addition, greedy-style parser such as [16] might be faster by nature.", "startOffset": 41, "endOffset": 45}, {"referenceID": 6, "context": "When we apply the length dictionary filtering heuristic in [7, 13], our parser achieves 89.", "startOffset": 59, "endOffset": 66}, {"referenceID": 12, "context": "When we apply the length dictionary filtering heuristic in [7, 13], our parser achieves 89.", "startOffset": 59, "endOffset": 66}, {"referenceID": 6, "context": "In contrast, the baseline system in [7] is slow than us by about three times.", "startOffset": 36, "endOffset": 39}, {"referenceID": 6, "context": "When operating in the accuracy level of 90%, Figure 3 in [7] shows that their final system takes about 20s.", "startOffset": 57, "endOffset": 60}, {"referenceID": 6, "context": "We acknowledge that [7] use different features, policy settings, and hardware from ours; therefore these numbers might not be comparable.", "startOffset": 20, "endOffset": 23}], "year": 2016, "abstractText": "We study the problem of structured prediction under test-time budget constraints. We propose a novel approach applicable to a wide range of structured prediction problems in computer vision and natural language processing. Our approach seeks to adaptively generate computationally costly features during test-time in order to reduce the computational cost of prediction while maintaining prediction performance. We show that training the adaptive feature generation system can be reduced to a series of structured learning problems, resulting in efficient training using existing structured learning algorithms. This framework provides theoretical justification for several existing heuristic approaches found in literature. We evaluate our proposed adaptive system on two structured prediction tasks, optical character recognition (OCR) and dependency parsing and show strong performance in reduction of the feature costs without degrading accuracy.", "creator": "LaTeX with hyperref package"}}}