{"id": "1603.02839", "review": {"conference": "icml", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Mar-2016", "title": "Starting Small -- Learning with Adaptive Sample Sizes", "abstract": "For many machine learning problems, data is abundant and it may be prohibitive to make multiple passes through the full training set. In this context, we investigate strategies for dynamically increasing the effective sample size, when using iterative methods such as stochastic gradient descent. Our interest is motivated by the rise of variance-reduced methods, which achieve linear convergence rates that scale favorably for smaller sample sizes. Exploiting this feature, we show -- theoretically and empirically -- how to obtain significant speed-ups with a novel algorithm that reaches statistical accuracy on an $n$-sample in $2n$, instead of $n \\log n$ steps.\n\n\n\n\n\n\nWe start by applying the S.H.I.E.L.D. method to a number of randomly generated steps for each step. We then use the gradient gradient descent model to compute the number of times a step has been chosen to pass into the entire training set. We use the gradient descent and gradient descent methods in the example below. We apply the gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below, and then pass into the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a random value in the input (for example, we use gradient descent and gradient descent methods in the example below. The gradient descent method is applied to the whole training set with a", "histories": [["v1", "Wed, 9 Mar 2016 10:52:53 GMT  (561kb)", "http://arxiv.org/abs/1603.02839v1", null], ["v2", "Fri, 7 Oct 2016 12:33:13 GMT  (774kb)", "http://arxiv.org/abs/1603.02839v2", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["hadi daneshmand", "aurelien lucchi", "thomas hofmann"], "accepted": true, "id": "1603.02839"}, "pdf": {"name": "1603.02839.pdf", "metadata": {"source": "META", "title": "Starting Small \u2013 Learning with Adaptive Sample Sizes", "authors": ["Hadi Daneshmand", "Aurelien Lucchi"], "emails": ["HADI.DANESHMAND@INF.ETHZ.CH", "AURELIEN.LUCCHI@INF.ETHZ.CH", "THOMAS.HOFMANN@INF.ETHZ.CH"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 3.\n02 83\n9v 1\n[ cs\n.L G\n] 9\nM ar"}, {"heading": "1. Introduction", "text": "In empirical risk minimization (ERM) (Vapnik, 1998) the training set S is used to define a sample risk RS , which is then minimized with regard to a pre-defined function class. One effectively equates learning algorithms with optimization algorithms. However, for all practical purposes an approximate solution of RS will be sufficient, as long as the optimization error is small relative to the statistical accuracy at sample size n := |S|. This is important for massive data sets, where optimization to numerical precision is infeasible. Instead of performing early stopping on black-box optimization, one ought to understand the trade-offs between statistical and computational accuracy, cf. (Chandrasekaran & Jordan, 2013). In this paper, we investigate a much neglected facet of this topic, namely how to dynamically control the effective sample size in optimization.\nMany large-scale optimization algorithms are iterative: they use sampled or aggregated data to perform a sequence\nof update steps. This includes the popular family of gradient descent methods. Often, the computational complexity increases with the size of the training sample, e.g. in steepest-descent, where the cost of a gradient computation scales with n. Does one really need a highly accurate gradient though, in particular in the early phase of optimization? Why not use subsets Tt \u2286 S which are increased in size with the iteration count t, matching-up statistical accuracy with optimization accuracy in a dynamic manner? This is the general program we pursue in this paper. In order to make this idea concrete and to reach competitive results, we focus on a recent variant of stochastic gradient descent (SGD), which is known as SAGA (Defazio et al., 2014). As we will show, this algorithm has a particularly interesting property in how its convergence rate depends on n."}, {"heading": "1.1. Empirical Risk Minimization", "text": "Formally, we assume that training examples x \u2208 S \u2286 X have been drawn i.i.d. from some underlying, but unknown probability distribution P . We fix a function class F parametrized by weight vectors w \u2208 Rd and define the expected risk as R(w) := Efx(w), where f is an x-indexed family of loss functions, often convex. We denote the minimum and the minimizer of R(w) over F by R\u2217 and w\u2217, respectively. Given that P is unknown, ERM suggests to rely on the empirical (or sample) risk with regard to S\nRS(w) := 1\nn\n\u2211 x\u2208S fx(w), w \u2217 S := argmin w\u2208F RS(w) . (1)\nNote that one may absorb a regularizer in the definition of the loss fx."}, {"heading": "1.2. Generalization bounds", "text": "The relation between w\u2217 and w\u2217S has been widely studied in the literature on learning theory. It is usually analysed with the help of uniform convergence bounds that take the\ngeneric form (Boucheron et al., 2005)\nES\n[\nsup w\u2208F\n|R(w) \u2212RS(w)| ] \u2264 H(n) , (2)\nwhere the expectation is over a random n-sample S. Here H is a bound that depends on n, usually through a ratio n/d, where d is the capacity of F (e.g. VC dimension). In the realizable case, we may be able to observe a favorable H(n) \u221d d/n, whereas in the pessimistic case, we may only be able to establish weaker bounds such as H(n) \u221d \u221a\nd/n (e.g. for linear function classes); see also (Bousquet & Bottou, 2008). We ignore additional log factors that can be eliminated using the \u201dchaining\u201d technique (Bousquet, 2002; Bousquet & Bottou, 2008)."}, {"heading": "1.3. Statistical efficiency", "text": "Assume now that we have some approximate optimization algorithm, which given S produces solutions wS that are on average \u01eb(n) optimal, i.e. ES [RS(wS)\u2212R\u2217S ] \u2264 \u01eb(n). One can then provide the following quality guarantee in expectation over sample sets S (Bousquet & Bottou, 2008)\nESR(wS)\u2212R\u2217 \u2264 H(n) + \u01eb(n) , (3)\nwhich is an additive decomposition of the expected solution suboptimality into an estimation (or statistical) error H(n) and an optimization (or computational) error \u01eb(n). For a given computational budget, one typically finds that \u01eb(n) is increasing with n, whereas H(n) is always decreasing. This hints at a trade-off, which may suggest to chose a sample size m < n. Intuitively speaking, concentrating the computational budget on fewer data may be better than spreading computations too thinly."}, {"heading": "1.4. Stochastic Gradient Optimization", "text": "For large scale problems, stochastic gradient descent is a method of choice in order to optimize problems of the form given in Eq. (1). Yet, while SGD update directions equal the true (negative) gradient direction in expectation, high variance typically leads to sub-linear convergence. This is where variance-reducing methods for ERM such as SAG (Roux et al., 2012), SVRG (Johnson & Zhang, 2013), and SAGA (Defazio et al., 2014) come into play. We focus on the latter here, where one can establish the following result on the convergence rate (see appendix).\nLemma 1. Let all fx be convex with L-Lipschitz continuous gradients and assume that RS is \u00b5-strongly convex. Then the suboptimality of the SAGA iterate wt after t steps is w.h.p. over a randomly sampled S bounded by\nEA [ RS(wt)\u2212R\u2217S ] \u2264 \u03c1tnCS , \u03c1n = 1\u2212min ( 1 n , \u00b5 L ) ,\nwhere the expectation is over the algorithmic randomness.\nThis highlights two different regimes: For small n, the condition number \u03ba := L\u00b5 dictates how fast the optimization algorithm converges. On the other hand, for large n, the convergence rate of SAGA becomes \u03c1n = 1\u2212 1n ."}, {"heading": "1.5. Contributions", "text": "Our main question is: can we obtain faster convergence to a statistically accurate solution by running SAGA on an initially smaller sample, whose size is then gradually increased? Motivated by a simple, yet succinct analysis, we present a novel algorithm, called DYNASAGA that implements this idea and achieves \u01eb(n) \u2264 H(n) after only 2n iterations."}, {"heading": "2. Related Work", "text": "Stochastic approximation is a powerful tool for minimizing objective Eq. (1) for convex loss functions. The pioneering work of (Robbins & Monro, 1951) is essentially a streaming SGD method where each observation is used only once. Another major milestones has been the idea of iterate averaging (Polyak & Juditsky, 1992). A thorough theoretical analysis of asymptotic convergence of SGD can be found in (Kushner & Yin, 2003), whereas some non-asymptotic results have been presented in (Moulines & Bach, 2011).\nA line of recent work known as variance-reduced SGD, e.g. (Roux et al., 2012; Shalev-Shwartz & Zhang, 2013; Johnson & Zhang, 2013; Defazio et al., 2014), has exploited the finite sum structure of the empirical risk to establish linear convergence for strongly convex objectives. There is also evidence of slightly improved statistical efficiency (Babanezhad et al., 2015). (Frostig et al., 2015) provides a non-asymptotic analysis of a streaming SVRG algorithm (SSVRG), for which a a convergence rate approaching that of the ERM is established.\nThere have also been approaches of non-uniform sampling of data points, e.g. by (Schmidt et al., 2013; He & Taka\u0301c, 2015), with the goal of sampling more important data points more often. This direction is largely orthogonal to our dynamic sizing of the sample, which is purely based on random subsampling."}, {"heading": "3. Methodology", "text": ""}, {"heading": "3.1. Setting and Assumptions", "text": "We work under the assumptions made in Lemma 1 and focus on the large data regime, where n \u2265 \u03ba and the geometric rate of convergence of SAGA depends on n through \u03c1n = 1\u2212 1/n. This is an interesting regime as the guaranteed progress per update is larger for smaller samples.\nThis form of \u03c1n implies for the case of performing t = n\niterations, i.e. performing one pass1:\nE [RS(wn)\u2212R\u2217S ] \u2264 ( 1\u2212 1 n\n)n\nCS \u2264 CS e . (4)\nSo we are guaranteed to improve the solution suboptimality on average by a factor 1/e per pass. This in turn implies that in order to get to a guaranteed accuracy O(n\u2212\u03b1), we need O(\u03b1n log n) update steps."}, {"heading": "3.2. Sample Size Optimization", "text": "For illustrative purposes, let us use the above result to select a sample size for SAGA, which yields the best guarantees.\nProposition 2. Assume H(m) = D/m and n is given. Define C to be an upper-bound on CS , \u2200S (from Lemma 1), then for m \u2265 \u03ba, V (m) := Dm + Ce\u2212 n m provides a bound on the expected suboptimality of SAGA. It is minimized for the choice\nm\u2217 = max\n{\n\u03ba, n\nlogn+ log CD\n}\n.\nProof. The first claim follows directly from the assumptions and Lemma 1. Moreover the tightest bound is obtained by differentiating V with regard to 1/m and solving for m (see Lemma 9 in appendix).\nThe result implies that we will perform roughly logn + log CD epochs on the optimally sized sample. Also the value of the bound is (for simplicity, assuming C = D)\nV (m\u2217) = logn\nn +\n1 n \u2264 V (n) = 1 n + 1 e , (5)\n1The SAGA analysis holds for i.i.d. sampling, so strictly speaking this is not a pass, but corresponds to n update steps.\nshowing that the single pass approximation error on the full sample is too large (constant), relative to the statistical accuracy."}, {"heading": "3.3. Dynamic Sample Growth", "text": "As we have seen, optimizing over a smaller sample can be beneficial (if we believe the significance of the bounds). But why chose a single sample size once and for all? A smaller sample set seems advantageous early on, but as an optimization algorithm approaches the empirical minimizer, it is hit by the statistical accuracy limit. This suggests that we should dynamically increment the size of the sample set. We illustrate this idea in Figure 2. In order to analyze such a dynamic sampling scheme, we need to relate the suboptimality on a sub-sample T to a suboptimality bound on S. We establish a basic result in the following theorem.\nTheorem 3. Let w be an (\u01eb, T )-optimal solution, i.e. RT (w)\u2212R\u2217T \u2264 \u01eb, where T \u2286 S, m := |T |, n := |S|. Then the suboptimality of w for RS is bounded w.h.p. in the choice of T as:\nES [RS(w)\u2212R\u2217S ] \u2264 \u01eb+ n\u2212m\nn H(m) . (6)\nProof. Consider the following equality\nRS(w) \u2212R\u2217S = RS(w) (1) \u2213 RT (w) (2) \u2213 R\u2217T (3) \u2212 R\u2217S We bound the three involved differences (in expectation) as follows: (2): RT (w) \u2212 R\u2217T \u2264 \u01eb by assumption. (3): ES [RT (w\u2217T )\u2212RS(w\u2217S)] \u2264 0 as T \u2286 S. For (1) we apply the bound (see Lemma 10 in the appendix)\nES|T [RS(w)\u2212RT (w)] \u2264 n\u2212m\nn |R(w) \u2212RT (w)| .\nMoreover\nET [R(w)\u2212RT (w)] \u2264 sup w\u2032 |R(w\u2032)\u2212RT (w\u2032)| \u2264 H(m)\nby Eq. (2), which concludes the proof.\nIn plain English, this result suggests the following: If we have optimized w to (\u01eb, T ) accuracy on a sub-sample T and we want to continue optimizing on a larger sample S \u2287 T , then we can bound the suboptimality onRS by the same \u01eb plus an additional \u201dswitching cost\u201d of (n\u2212m)/n \u00b7H(m)."}, {"heading": "4. Algorithms & Analysis", "text": ""}, {"heading": "4.1. Computational Limited Learning", "text": "The work of (Bottou, 2010) emphasized that for massive data sets the limiting factor of any learning algorithm will\nbe its computational complexity T , rather than the number of samples n. For SGD this computational limit typically translates into the number of stochastic gradients evaluated by the algorithm, i.e. T becomes the number of update steps. One obvious strategy with abundant data is to sample a new data point in every iteration. There are asymptotic results establishing bounds for various SGD variants in (Bousquet & Bottou, 2008). However, SAGA and related algorithms rely on memorizing past stochastic gradients, cf. (Hofmann et al., 2015), which makes it beneficial to revisit data points, and which is at the root of results such as Lemma 1. This leads to a qualitatively different behavior and our findings indicate that indeed, the trade-offs for large scale learning need to be re-visited, cf. Table 1."}, {"heading": "4.2. SAGA with Dynamic Sample Sizes", "text": "We suggest to modify SAGA to work with a dynamic sample size schedule. Let us define a schedule as a monotonic function M : Z+ \u2192 Z+, where t is the iteration number and M(t) the effective sample size used at t. We assume that a sequence of data points X = (x1, . . . ,xn) drawn from P is given such that M induces a nested sequence of samples Tt := {xi : 1 \u2264 i \u2264 M(t)}.\nAlgorithm 2 DYNASAGA 1: Input:\ntraining examples X = (x1,x2, . . . ,xn), xi \u223c P total number of iterations T (e.g. T = 2n) starting point w0 \u2208 Rd (e.g w0 = 0) learning rate \u03b7 > 0 (e.g. \u03b7 = 14L ) sample schedule M : [1 : T ] \u2192 [1 : n]\n2: w \u2190 w0 3: for i = 1, . . . , n do 4: \u03b1i \u2190 \u2207fxi(w0) {can also be done on the fly} 5: end for 6: for t = 1, . . . , T do 7: sample xi \u223c Uniform(x1, . . . ,xM(t)) 8: g \u2190 \u2207fxi(wt\u22121) 9: A \u2190 \u2211M(t)j=1 \u03b1j/M(t) {can be done incrementally}\n10: wt \u2190 wt\u22121 \u2212 \u03b7 (g \u2212 \u03b1i +A) 11: \u03b1i \u2190 g 12: end for\nDYNASAGA generalizes SAGA (Defazio et al., 2014) in that it samples data points non-uniformly at each iteration. Specifically, for a given schedule M and iteration t, it samples uniformly from Tt, but ignores X \u2212 Tt. The pseudocode for DYNASAGA is shown in Algorithm 1."}, {"heading": "4.3. Upper Bound Recurrence", "text": "We pursue the strategy of using the basic inequalities obtained so far and to stitch them together in the form of a recurrence. At any iteration t we allow ourselves the choice to augment the current sample of size m by some increment \u25b3m \u2265 0. We define an upper bound function U as follows\nU(t, n) = min\n\n\n \u03c1nU(t \u2212 1, n) min m<n [ U(t,m) + n\u2212mn H(m) ] , (7)\nsuch that U(0,m) = \u03be, where the initial error \u03be is defined as:\n\u03be := 4L\n\u00b5\n[ R(w0)\u2212R(w\u2217) ] . (8)\nWe refer the reader to Lemma 8 in the Appendix for further details on how to derive the expression for \u03be.\nThe construction of Eq. (7) is motivated by the following result:\nProposition 4. W.h.p. over the random n-sample X , the iterate sequence wt generated by DYNASAGA fulfils\nEX [ RTn(wt)\u2212R\u2217Tn ] \u2264 U(t, n) .\nProof. By induction over t. The result for t = 0 follows directly from Lemma 8. The first case in Eq. (7) for the\ninduction step (fixed sample size) follows from Lemma 1. The second case holds by virtue of Theorem 3 for any m, hence also for the minimum.\nAlthough the U-recursion can be solved for small n using dynamic programming (assuming knowledge of all constants), we analyse a much simpler heuristics and its n \u2192 \u221e behavior. This leads to interesting insights, while being very practical. In particular, our algorithm is an anytime algorithm, which does not require knowledge of the total number of iterations T ahead of time."}, {"heading": "4.4. Sample Schedules", "text": "In this section, we present and analyse two adaptive sample-size schemes for DYNASAGA.\nLINEAR We start with sample size \u03ba and perform 2\u03ba steps. From then on, we add a new sample every other iteration. The effective sample size is thus\nMLIN(t) = max { 2\u03ba, \u2308 t 2 \u2309}\n(9)\nNote that this strategy defines an upper bound on U(2t, t) and U(2t+ 1, t).\nALTERNATING We have also implemented a variant where we perform updates in alternation: every other iteration we sample a new data point, which is added to the set. However, we also force an update on this fresh sample. In alternation, we simply re-sample an existing data point uniformly at random. We do not provide a theoretical analysis for this scheme but show experimentally that it slightly outperforms the LINEAR strategy (see results in the appendix). We thus report results for the ALTERNATING strategy in the experimental section."}, {"heading": "4.5. Analysis", "text": "We now provide an analysis that establishes the convergence rate of the LINEAR strategy.\nLemma 5. For H(n) = Dn\u2212\u03b1, 0 < \u03b1 \u2264 1, the LINEAR strategy obtains the following suboptimality\nU(2n, n) \u2264 H (n) + \u03be 2 (\u03ba n\n)2\n(10)\nProof. By induction over n. The base case follows from Cm \u2264 \u03be. Using Eq. (7) and (10) for the inductive case, we get\nU (2(n+ 1), n+ 1) (7) \u2264 \u03c12n+1\n[\nU (2n, n) + 1\nn+ 1 H(n)\n]\n(10) \u2264 \u03be\n2\n(\n\u03ba\nn+ 1\n)2\n+ n2 (n+ 2)\n(n+ 1) 3 H(n)\nNote that by definition of the logarithmic function, log [n(n+ 2)] < 2 log(n+ 1), and moreover\nn\nn+ 1 H(n) H(n+ 1) =\nn1\u2212\u03b1\n(n+ 1)1\u2212\u03b1 \u2264 1 ,\nwhich completes the proof.\nThis means that for large enough n the LINEAR strategy is able to approach the statistical accuracy with 2n iterations, i.e. two \u201dpasses\u201d over the data. Note the very significant improvement relative to the log n factor inherent to the optimal fixed sample size choice (see Table 1 for a comparison of these two bounds).\nWhat does that imply for the T = n case that we have been emphasizing? It is simple to state an answer as a corollary.\nCorollary 6. Under the same assumptions as Lemma 5, it holds for even n\nU(n, n) \u2264 ( 3 \u00b7 2\u03b1\u22121 ) H (n) + 2\u03be (\u03ba\nn\n)2\nProof. Note that with Eq. (7) (a) and Lemma 5 (b) we get\nU(2n, 2n) (a) \u2264 U(2n, n) + 1\n2 H(n)\n(b) \u2264 3\n2 H(n) + 2\u03be\n( \u03ba\n2n\n)2\nThe fact that H(n) = 2\u03b1H(2n) completes the proof.\nThe proof of the above corollary suggests to only use n = T/2 samples, when performing T steps and to simply ignore the other half (that potentially could have been sampled). One might wonder if a better strategy than the LINEAR one could be defined, e.g. by iterating more than twice on each newly added sample or by increasing the sample size by more than one. The next lemma answers this question and proves that the LINEAR strategy is optimal for large-scale datasets as long as H(n) \u221d 1/n. Lemma 7. Assume that H(n) \u221d D/n, then the LINEAR strategy is optimal for all sample size n > \u03ba.\nProof. Here, we briefly state a sketch of the proof . The details are presented in Appendix A.2. First, we reformulate the problem of the optimal sample size schedule in terms of number of iterations on each samples size. Given that this problem is convex, we can use the KKT conditions to prove the optimality of incrementing by one sample (see Lemma 12) and iterating twice on each sample size (see Lemma 13)."}, {"heading": "5. Experimental Results", "text": "We present experimental results on synthetic as well as real-world data, which largely confirms the above analysis."}, {"heading": "5.1. Baselines", "text": "We compare DYNASAGA (both the LINEAR and ALTERNATING strategy) to various optimization methods presented in Section 2. This includes SGD (with constant and decreasing step-size), SAGA, streaming SVRG (SSVRG) as well as the mixed SGD/SVRG approach presented in (Babanezhad et al., 2015)."}, {"heading": "5.2. Experiment on synthetic data", "text": "We consider linear regression, where inputs a \u2208 Rd are drawn from a Gaussian distribution N (0,\u03a3d\u00d7d) and outputs are corrupted by additive noise y = \u3008x,w\u2217\u3009 + \u01eb, \u01eb \u223c N ( 0, \u03c32 ) . We are given n i.i.d observations of this\nmodel, S = {(ai, yi)}ni=1, from which we compute the least squares risk RS(w) = 1n \u2211n i=1 (\u3008ai,w\u3009 \u2212 yi) 2.\nBy considering the matrix An to be a row-wise arrangement of the input vectors ai, we can write the Hessian matrix of Rn(w) as \u03a3n = 1nATnAn. When n \u226b d, the matrix \u03a3n converges to \u03a3 and we can therefore assume that Rn(w) is \u00b5-strongly convex and L-Lipschitz where the constants \u00b5 and L are the smallest and largest eigenvalues of \u03a3. We experiment with two different values for the condition number \u03ba.\nCase \u03ba = \u221a n: We use a diagonal \u03a3 with elements decreasing from 1 to 1\u221a n , hence \u03ba = \u221a n. In this particular case the analysis derived in Lemma 5 predicts an upper\nbound U(n, n) < O( 1n ) which is confirmed by the results shown in Figure 3.\nCase \u03ba = n 3 4 : When \u03ba = n 3 4 , the term ( \u03ba n )2 is the dominating term in the proposed upper-bound. In this case, U(n, n) is thus upper-bounded by O (\n1\u221a n\n)\n, which is once\nagain verified experimentally in Figure 3."}, {"heading": "5.3. Experiments on Real Datasets", "text": "We also ran experiments on several real-world datasets in order to compare the performance of DYNASAGA to stateof-the-art methods. The details of the datasets are shown in Table 2. Throughout all the experiments we used the lo-\ngistic loss with a regularizer \u03bb = 1\u221a n 2. Figures 4, and 5 show the suboptimality on the empirical risk and expected risk after a single pass over the datasets. The various parameters used for the baseline methods are described in Table 3. A critical factor in the performance of most baselines, especially SGD, is the selection of the step-size. We picked the best-performing step-size within the common range guided by existing theoretical analyses, specifically \u03b7 = 1/L and \u03b7 = CC+\u00b5t for various values of C. Overall, we can see that DYNASAGA performs very well, both as an optimization as well as a learning algorithm. SGD is also very competitive and typically achieves faster convergence than the other baselines, however, its behaviour is not stable throughout all the datasets. The SGD variant with decreasing step-size is typically very fast in the early stages but then slows down after a certain number of steps. The results on the RCV dataset are somehow surprising as SGD with constant step-size clearly outperforms all methods but we show in the appendix that its behaviour gets worse as we increase the condition number. As can be seen very clearly, DYNASAGA yields excellent solutions in terms of expected risk after one pass (see suboptimality values that intersect with the vertical red dashed lines)."}, {"heading": "6. Conclusion", "text": "We have presented a new methodology to exploit the tradeoff between computational and statistical complexity, in order to achieve fast convergence to a statistically efficient solution. Specifically, we have focussed on a modification of SAGA and suggested a simple dynamic sampling schedule that adds one new data point every other update step. Our analysis shows competitive convergence rates both in term of suboptimality on the empirical risk as well as (more importantly) the expected risk in a one pass or a two pass setting. These results have been validated experimentally.\nOur approach depends on the underlying optimization\n2We also present some additional results for various regularizers of the form \u03bb = 1\nnp , p < 1 in the appendix\nmethod only through its convergence rate for minimizing an empirical risk. We thus suspect that a similar sample size adaption is applicable to a much wider range of algorithms, including to non-convex optimization methods for deep learning."}, {"heading": "A. Appendix", "text": "A.1. Proofs\nProof of Lemma 1.\nProof. We start with the convergence rate of SAGA established in (Defazio et al., 2014) as\nEA [ \u2016wt \u2212w\u2217S\u20162 ] \u2264 \u03c1t|S| [ \u2016w0 \u2212w\u2217S\u20162 + |S|\n\u00b5|S|+ L ( RS(w0)\u2212 \u3008\u2207RS(w\u2217S),w0 \u2212w\u2217S\u3009 \u2212 R\u2217S )\n]\n. (11)\nWe then use the L-smoothness assumption of fx(w) to relate the suboptimality on the function values to the bound in Eq. (11).\nEA [ |RS(wt)\u2212RS(w\u2217S)| ] = EA [ |Ex\u2208S [ fx(w t) ] \u2212Ex\u2208S [fx(w\u2217S)] | ]\nL\u2212smoothness \u2264 LEA [ \u2016wt \u2212w\u2217S\u20162 ]\nEq. 11 \u2264 \u03c1t|S|CS ,\nwhere CS is the initial suboptimality on the empirical risk defined as:\nCS = L\n[ \u2016w0 \u2212w\u2217S\u20162 + |S|\n\u00b5|S|+ L ( RS(w0)\u2212 \u3008\u2207RS(w\u2217S),w0 \u2212w\u2217S\u3009 \u2212 R\u2217S )\n]\n(12)\nNote that this initial error depends on the set S and its size |S|. In the following Lemma, we propose an upper bound on this initial error that is independent of S\nLemma 8. W.h.p, the initial suboptimality error of sample S is bounded by:\nCS \u2264 \u03be := 4L\n\u00b5\n[ R(w0)\u2212R(w\u2217) ]\nProof. We first use the fact that RS(w) is \u00b5-strongly convex as well as the optimality of w\u2217S to bound CS as\nCS := L\n( \u2016w0 \u2212w\u2217S\u20162 + |S|\n\u00b5|S|+ L [ RS(w0)\u2212 \u3008\u2207RS(w\u2217S),w0 \u2212w\u2217S\u3009 \u2212 RS(w\u2217S) ]\n)\n\u2264 L \u00b5 [ RS(w0)\u2212RS(w\u2217S) ] + |S|L \u00b5|S| + L [ RS(w0)\u2212 \u3008\u2207RS(w\u2217S),w0 \u2212w\u2217S\u3009 \u2212 RS(w\u2217S) ]\n\u2264 L \u00b5 [ RS(w0)\u2212RS(w\u2217S) ] + |S|L \u00b5|S| + L [ RS(w0)\u2212RS(w\u2217S) ]\n(L>0)\n\u2264 2L \u00b5 [ RS(w0)\u2212RS(w\u2217S) ]\n\u2264 2L \u00b5\n[\nRS(w0) [1] \u2213 R(w0) [2] \u2213 R(w\u2217) [3] \u2213 R(w\u2217S)\u2212RS(w\u2217S)\n]\nWe use the generalization bounds in (Vapnik, 1998) to upper bound [1] and [2]. For [3], we used the uniform convergence rate of the ERM that implies (Vapnik, 1998):\nR(w\u2217S)\u2212R(w\u2217) \u2264 c sup w |RS(w)\u2212R(w)|,\nwhere c is a constant. We then get\nCS w.h.p \u2264 2L\n\u00b5\n[ H(|S|) +R(w0)\u2212R(w\u2217) + cH(|S|) +H(|S|) ] . (13)\nWe also make the further assumption that with high probability the initial suboptimality is greater than a constant factor of the statistical accuracy, i.e. R(w0)\u2212R(w\u2217) > (2 + c)H(|S|). We can then further upper bound CS as\nCS \u2264 4L\n\u00b5\n[ R(w0)\u2212R(w\u2217) ] . (14)\nLemma 9 (for Proposition 2).\nV (m) := D\nm + Ce\u2212 n m , then argmin 0<m\u2264n V (m) =\nn\nlog nCD\nProof.\ndV\ndm\u22121 = D \u2212 nCe\u2212 nm != 0\n\u21d0\u21d2 e\u2212 nm = D nC \u21d0\u21d2 n m = log nC D\nSolving for m, this indeed corresponds to a minimum which can be verified by checking the boundary values m = n and m \u2192 0. Lemma 10 (for Theorem 3).\nES|T [RS(w)\u2212RT (w)] \u2264 n\u2212m\nn |R(w) \u2212RT (w)| .\nProof.\nES|T [RS(w)\u2212RT (w)] = ES\u2212T |T [RS(w)\u2212RT (w)]\n= ES\u2212T\n\n\n1\nn\n\n\n\u2211 x\u2208T fx(w) + \u2211 y\u2208S\u2212T fy(w)\n\n\u2212 1 m \u2211\nx\u2208T fx(w)\n\n\n= n\u2212m\nn ES\u2212T\n\n\n1\nn\u2212m \u2211 y\u2208S\u2212T fy(w) \u2212RT (w)\n\n\n= n\u2212m\nn ES\u2212T\n\n\n1\nn\u2212m \u2211 y\u2208S\u2212T fy(w) \u2212RT (w)\n\n\n= n\u2212m\nn [ES\u2212T [RS\u2212T (w)] \u2212RT (w)]\n= n\u2212m\nn [R(w) \u2212RT (w)]\nA.2. Optimality of the LINEAR Strategy\nWe here introduce a new notation and chose to represent a sample size schedule by a vector tn = \u3008tm\u3009,m < n where tm denotes the number of iterations on sample size m. Note that the total number of iterations up to the sample size n is T = \u2211\nm<n tm. We define n \u2212 as the sample size that we iterate on immediately before sample size n, i.e.\nn\u2212 = max{k < n : tk > 0}. (15)\nWe now rewrite the suboptimality bound in terms of the sample size schedule tn as\nA(tn) = ES [RS(w(tn))\u2212RS(w\u2217)]\n= \u03c1tnn\n(\nA(tn \u2212 ) + n\u2212 n\u2212\nn H(n\u2212)\n)\n, (16)\nwhere the second equality is derived using Lemma 1 and Theorem 3.\nOne can relate the upper bound U(n, n) to A(tn) using the following constrained program:\nU(n, n) = min tn\nA(tn) (17)\nSubject to \u2200m \u2264 n : \u2212tm \u2264 0 \u2211\nm\u2264n tm = n\nIn the following we aim at showing that the LINEAR Strategy is the optimal solution of Equation 16. We first prove a Lemma that will be used in the rest of our analysis.\nLemma 11 (Expansion of A(tn)). if H(n) = D/n, then\nA(tn) := C(tn) +\nn \u2211\nm=m0+1\nBm(t n), where (18)\nC(tn) := \u03be\nn \u220f\ni=m0\n( i\u2212 1 i\n)ti\n, Bm(t n) :=\nD\n(m\u2212 1)m\nn \u220f\ni=m\n( i\u2212 1 i\n)ti\n. (19)\nProof. Although one could painstakingly unroll the recursivity in Equation 16, we here provide a simple induction proof. First, one can easily verify that the equation holds for n = m0. For the inductive step, we assume it holds for n\u2212 and prove it holds for all {k : n\u2212 < k \u2264 n}. According to the definition of n\u2212, we have tk = 0 for all n\u2212 < k < n, and therefore\n\u03c1tkk =\nk \u220f\nm=n\u2212+1\n\u03c1tmm . (20)\nWe will also make use of the following equality in our analysis:\nk \u2212 n\u2212 k H(n\u2212) = H(n\u2212)\u2212H(k) (H(n)=D/n)= k \u2211\nm=n\u2212+1\nH(m\u2212 1)\u2212H(m). (21)\nWe are now ready to prove the inductive step.\nA(tk) EQ 16 = \u03c1tkk\n(\nA(tn \u2212 ) + k \u2212 n\u2212\nk H(n\u2212)\n)\n(22)\n= \u03c1tkk\n\nC(tn \u2212 ) +\nn\u2212 \u2211\nm=m0+1\nBm(t n\u2212) + k \u2212 n\u2212 k H(n\u2212)\n\n (23)\nEQ 19, 20 = C(tk) +\nn\u2212 \u2211\nm=m0+1\nBm(t k) + \u03c1tkk\n( k \u2212 n\u2212 k H(n\u2212) )\n(24)\nEQ 21 = C(tk) +\nn\u2212 \u2211\nm=m0+1\nBm(t k) + \u03c1tkk\nk \u2211\nm=n\u2212+1\nD\n(m\u2212 1)m (25)\nEQ 20 = C(tk) +\nn\u2212 \u2211\nm=m0+1\nBm(t k) +\nk \u2211\nm=n\u2212+1\nBm(t k) (26)\n= C(tk) +\nk \u2211\nm=m0+1\nBm(t k) (27)\nUsing the definitions provided in Lemma 11, we investigate the optimality conditions of the optimal sample size strategy. In the following, we simplify our notations and write Bm and C instead of Bm(tn) and C(tn).\nAs a first step in our analysis, we introduce the following equations based on the definitions of Bm and C.\nBm = 1 m(m\u2212 1) \u220f\ni\u2265m\n( i\u2212 1 i )ti = m+ 1 m\u2212 1 ( m\u2212 1 m )tm Bm+1 . (28)\nn \u220f\ni=m\n( i \u2212 1 i )ti = n \u220f\ni=m\nexp\n(\nlog\n(\n( i\u2212 1 i\n)ti ))\n= exp\n[\nn \u2211\ni=m\nti log\n(\n1\u2212 1 i\n)\n]\n. (29)\nWe now compute the derivative of A(tn\u2217 ) as\n\u2202A(tn\u2217 )\n\u2202tm = log(1\u2212 1 m )\n(\nC(tn) +\nm \u2211\nk=m0+1\nBk(t n)\n)\n\u2243 \u2212 1 m\n(\nC +\nm \u2211\nk=m0+1\nBk\n)\n. (30)\nC(tn) and Bm(tn) are log-convex (hence convex) functions with respect to tn. Since the sum operator preserves convexity (Boyd & Vandenberghe, 2004), A(tn) is convex as well. Let \u03bbi, \u03bd denote the Lagrangian coefficients associated with the inequality and equality constraints respectively. According the KKT conditions (Boyd & Vandenberghe, 2004) for the the optimal solution, the following inequalities hold:\n\u03bbm \u2265 0 (31) \u2212\u03bbmt\u2217m = 0 (32)\n\u2202A(tn\u2217 )\n\u2202tm \u2212 \u03bbm + \u03bd = 0 (33)\nAccording the above condition there are two possible cases for the partial derivative \u2202A(t n \u2217 )\n\u2202tm :\n\u2022 For the case of t\u2217m > 0, the slackness condition 32 implies that \u03bbm = 0. Then, according to the condition 33:\n\u2202A(tn\u2217 )\n\u2202tm = \u2212\u03bd\nEQ. 30 =\u21d2 1\nm\n(\nC + m \u2211\nk=m0+1\nBk\n)\n= \u03bd (34)\n\u2022 For the case of t\u2217m = 0, \u03bbi > 0(a.) holds based on the complementary slackness condition 32.\n\u2202A(tn\u2217 )\n\u2202tm = \u03bbi \u2212 \u03bd\n(a.) > \u2212\u03bd\nEQ. 30 =\u21d2 1\nm\n(\nC +\nm \u2211\nk=m0+1\nBk\n)\n< \u03bd (35)\nIn the following two lemmas we use the conditions of optimality derived in Equations 34 and 35 to prove optimality of the LINEAR Strategy. Specifically, we first prove that for the optimal strategy, tm > 0 for m0 < m \u2264 n\u2212 and tm = 0 for m > n\u2212. We also prove the optimality of incrementing the sample size by one. In the second lemma, we show that t\u2217m \u2243 2. Lemma 12 (Optimality of sample size increment). For large enough m, a schedule with tm = 0 and tm+1 > 0 cannot be optimal.\nProof. Note that by repeated application of Equation (28) we obtain\nBm+1 < Bm < \u00b7 \u00b7 \u00b7 < Bm\u2212+1 EQ. 34 & 35 < \u03bd (36)\nwhere optimality conditions a. tm\u2212 > 0 (EQ.34) and b. tm\u2212+1 = 0 (EQ.35) yeild the last inequality:\nBm\u2212+1 =\nm\u2212+1 \u2211\nk=m0+1\nBk \u2212 m\u2212 \u2211\nk=m0+1\nBk \u2213 C (37)\na. =\nm\u2212+1 \u2211\nk=m0+1\nBk + C \u2212m\u03bd (38)\nb. < (m+ 1)\u03bd \u2212m\u03bd = \u03bd (39)\nOn the other hand, optimality of a. tm+1 > 0 (EQ.34) and b. tm = 0 (EQ.35) also imply Bm+1 > \u03bd which is in contradiction with the previously established Bm+1 < \u03bd. Indeed, we have\nBm+1 = m+1 \u2211\nk=m0+1\nBk \u2212 m \u2211\nk=m0+1\nBk \u2213 C (40)\na. = (m+ 1)\u03bd \u2212\nm \u2211\nk=m0+1\nBk \u2212 C (41)\nb. > (m+ 1)\u03bd \u2212m\u03bd = \u03bd (42)\nLemma 13 (Optimality of two iterations). Consider tn\u2217 as the minimizer of the optimization problem 17. For sufficiently large m : m0 < m \u2264 n\u2212, t\u2217m \u2243 2.\nProof. Using Lemma 12, t\u2217m > 0 holds for m0 < m \u2264 n\u2212. We proceed with optimality conditions a. t\u2217m > 0 and b. t\u2217m\u22121 > 0 in equation 34.\nBm =\nm \u2211\nk=m0+1\nBk \u2212 m\u22121 \u2211\nk=m0+1\nBk \u2213 C (43)\na. = m\u03bd \u2212\nm\u22121 \u2211\nk=m0+1\nBk \u2212 C (44)\nb. = m\u03bd \u2212 (m\u2212 1)\u03bd = \u03bd (45)\nConsequently, Bm = Bm+1 = \u03bd. Using Equation 28, one conclude that t\u2217m \u2243 2:\nm\u2212 1 m+ 1 = ( m\u2212 1 m\n)t\u2217m \u21d0\u21d2 t\u2217m = log\n( 1\u2212 2m+1 )\nlog ( 1\u2212 1m ) \u2243 2m m+ 1 \u2243 2 . (46)\nA.3. Additional Experimental results\nA.3.1. COMPARISON OF THE TWO ADAPTIVE SAMPLE SIZE SCHEMES FOR DYNASAGA\nWe here compare the LINEAR and ALTERNATING schemes on the collection of real datasets presented in Table 2 for a regularizer \u03bb = n\u2212 1\n2 . The results for the empirical and expected risk shown in Figure 6 and Figure 7 show that the ALTERNATING scheme slightly outperforms the LINEAR strategy.\nA.3.2. EFFECT OF THE REGULARIZER\nWe here present additional results for various regularizers of the form \u03bb = 1np , p < 1. In the interest of clarity we only show results on four datasets. We can see a similar trend to the main results presented in the paper for \u03bb = 1\u221a\nn where\nDYNASAGAshows very fast convergence in terms of both empirical and expected risk. SGD is also very competitive and typically achieves faster convergence than the other baselines, however, its behaviour is not stable throughout all the datasets.\nA.4. Details of Experiments\nThe various parameters of all baselines and DYNASAGA are represented in Table 3."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "For many machine learning problems, data is abundant and it may be prohibitive to make multiple passes through the full training set. In this context, we investigate strategies for dynamically increasing the effective sample size, when using iterative methods such as stochastic gradient descent. Our interest is motivated by the rise of variance-reduced methods, which achieve linear convergence rates that scale favorably for smaller sample sizes. Exploiting this feature, we show \u2013 theoretically and empirically \u2013 how to obtain significant speed-ups with a novel algorithm that reaches statistical accuracy on an n-sample in 2n, instead of n logn steps.", "creator": "LaTeX with hyperref package"}}}