{"id": "1605.04263", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2016", "title": "OBDA Constraints for Effective Query Answering (Extended Version)", "abstract": "In Ontology Based Data Access (OBDA) users pose SPARQL queries over an ontology that lies on top of relational datasources. These queries are translated on-the-fly into SQL queries by OBDA systems. Standard SPARQL-to-SQL translation techniques in OBDA often produce SQL queries containing redundant joins and unions, even after a number of semantic and structural optimizations.\n\n\n\n\nThe use of query-to-SQL translation techniques in OBDA has led to the introduction of many possible alternatives to ODF based data access. ODF provides a variety of useful information and support services that can be used to make query queries more complete. These data-access solutions provide advanced data management and can be used to make querying query queries more complete.\nIn general, ODF provides more information about an ODF-based data access solution such as the time and format of an ODF query.\nHowever, a lack of a single or multiple query query will make queries more complete in order to achieve maximum coverage.\nIn general, ODF provides a series of database-driven and multi-column relational data access solutions which are implemented in a variety of ways.\nAs an example of how ODF could improve our database-driven relational data access strategies, consider a simple set of query-to-SQL data access options.\nThis collection of SQL data-access options could help us understand the complexity of ODF. If you would like to learn more, click here.\nA Query, or Query, for example, would be a query to the SQL Server database, then the following query would be a query to the SQL Server database (as described in the previous section).\nA Query, or Query, for example, would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a query to the SQL Server database, then the following query would be a", "histories": [["v1", "Fri, 13 May 2016 17:29:28 GMT  (552kb)", "https://arxiv.org/abs/1605.04263v1", null], ["v2", "Mon, 16 May 2016 09:21:26 GMT  (569kb)", "http://arxiv.org/abs/1605.04263v2", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["dag hovland", "davide lanti", "martin rezk", "guohui xiao"], "accepted": false, "id": "1605.04263"}, "pdf": {"name": "1605.04263.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Dag Hovland", "Davide Lanti", "Martin Rezk", "Guohui Xiao"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 5.\n04 26\n3v 2\n[ cs\n.D B\n] 1\n6 M"}, {"heading": "1 Introduction", "text": "In Ontology Based Data Access (OBDA) [18], the complexity of data storage is hidden by a conceptual layer on top of an existing relational database (DB). Such a conceptual layer, realized by an ontology, provides a convenient vocabulary for user queries, and captures domain knowledge (e.g., hierarchies of concepts) that can be used to enrich query answers over incomplete data. The ontology is connected to the relational database through a declarative specification given in terms of mappings that relate each term in the ontology (each class and property) to a (SQL) view over the database. The mappings and the database define a (virtual) RDF graph that, together with the ontology, can be queried using the SPARQL query language.\nTo answer a SPARQL query over the conceptual layer, a typical OBDA system translates it into an equivalent SQL query over the original database. The translation procedure has two major stages: (1) rewriting the input SPARQL query with respect to the ontology and (2) unfolding the rewritten query with respect to the mappings. A wellknown theoretical result is that the size of the translation is worst-case exponential in the size of the input query [13]. These worst-case scenarios are not only theoretical, but they also occur in real-world applications, as shown in [16], where some user SPARQL queries are translated into SQL queries containing thousands of join and union operators. This is mainly due to (i) SPARQL queries containing joins of ontological terms with rich hierarchies, which lead to redundant unions [19]; and (ii) reifications of n-ary relations in the database into triples over the RDF data model, which lead to SQL translations containing several (mostly redundant) self-joins. How to reduce the impact of\n2 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nexponential blow-ups through optimization techniques so as to make OBDA applicable to real-world scenarios is one of the main open problems in current OBDA research.\nThe standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5]. Semantic optimizations use explicit integrity constraints (such as primary and foreign keys) to remove redundant joins and unions from the translated queries. Structural optimizations are in charge of reshaping the translations so as to take advantage of database indexes.\nThe main problem addressed in this paper is that these optimizations cannot exploit constraints that go beyond database dependencies, such as domain constraints (e.g., people have only one age, except for Chinese people who have two ages), or storage policies in the organization (e.g., table married must contain all the married employees). We address this problem by proposing two novel classes of constraints that go beyond database dependencies. The first type of constraint, exact predicate, intuitively describes classes and properties whose elements can be retrieved without the help of the ontology. The second type of constraint, virtual functional dependency (VFD), intuitively describes a functional dependency over the virtual RDF graph exposed by the ontology, the mappings, and the database. These notions are used to enrich the OBDA specification so as to allow the OBDA system to identify and prune redundancies from the translated queries. To help the design of enriched specifications, we provide tools that detect the satisfied constraints within a given OBDA instance. We extend the OBDA system Ontop so as to exploit the enriched specification, and evaluate it in both a largescale industrial setting provided by the petroleum company Statoil, and in an ad-hoc artificial and scalable benchmark with different commercial and free relational database engines as back-ends. Both sets of experiments reveal a drastic reduction on the size of translated queries, which in some cases is reduced by orders of magnitudes. This allows for a major performance improvement of query answering.\nThe rest of the paper is structured as follows: Preliminaries are provided in Section 2. In Section 3 we describe how state-of-the-art OBDA systems work, and highlight the problems with the current optimization techniques. In Section 4 we formally introduce our novel OBDA constraints, and show how they can be used to optimize translated queries. In Section 5 we provide an evaluation of the impact of the proposed optimization techniques on the performance of query answering. In Section 6 we briefly survey other related works. Section 7 concludes the paper. The omitted proofs and extended experiments with Wisconsin benchmark can be found in the appendix."}, {"heading": "2 Preliminaries", "text": "We assume the reader to be familiar with relational algebra and SQL queries, as well as with ontology languages and in particular with the OWL 2 QL1 profile. To simplify the notation we express OWL 2 QL axioms by their description logic counterpart DLLiteR [4]. Notation-wise, we will denote tuples with the bold faces; e.g., x is a tuple.\nOntology and RDF Graphs. The building block of an ontology is a vocabulary (NC , NR), where NC , NR are respectively countably infinite disjoint sets of class names and (object or datatype) property names. A predicate is either a class name or a property name. An ontology is a finite set of axioms constructed out a vocabulary, and it describes a domain\n1 http://www.w3.org/TR/owl2-overview/\nOBDA Constraints for Effective Query Answering (Extended Version) 3\nof interest. These axioms of an ontology can be serialized into a concrete syntax. In the following we use the Turtle syntax for readability.\nExample 1. The ontology from Statoil captures the domain knowledge related to oil extraction activities. Relevant axioms for our examples are:\n:isInWell rdfs:domain :Wellbore :isInWell rdfs:range :Well\n:hasInterval rdfs:domain :Wellbore :hasInterval rdfs:range :WellboreInterval\n:completionDate rdfs:domain :Wellbore\n:ProdWellbore rdfs:subClassOf :DevelopWellbore :DevelopWellbore rdfs:subClassOf :Wellbore\nThe first five axioms specify domains and ranges of the properties :isInWell, :hasInterval, and :completionDate. The last two state the hierarchy between different wellbore2 classes.\nGiven a countably infinite set NI of individual names disjoint from NC and NR, an assertion is an expression of the form A(i) or P(i1, i2), where i, i1, i2 \u2208 NI , A \u2208 NC , P \u2208 NR. An OWL 2 QL knowledge base (KB) is a pair (T ,A) where T is an OWL 2 QL ontology and A is a set of assertions (also called ABox). Semantics for entailment of assertions (|=) in OWL 2 QL KBs is given through Tarski-style interpretations in the usual way [1]. Given a KB (T ,A), the saturation of A with respect to T is the set of assertions AT = {A(s) | (T ,A) |= A(s)} \u222a {P(s, o) | (T ,A) |= P(s, o)}. In the following, it is convenient to view assertions A(s) and P(s, o) as the RDF triples (s, rdf:type, A) and (s, P, o), respectively . Hence, we view a set of assertions also as an RDF graph GA defined as GA = {(s, rdf:type, A) | A(s) \u2208 A} \u222a {(s, P, o) | P(s, o) \u2208 A}. Moreover, the saturated RDF graph G(T ,A) associated to a knowledge base (T ,A) consists of the set of triples entailed by (T ,A), i.e. G(T ,A) = GAT .\nOBDA and Mappings. Given a vocabulary (NC , NR) and a database schema \u03a3, a mapping is an expression of the form A( f1(x1)) \u2190 sql(y) or P( f1(x1), f2(x2)) \u2190 sql(y), where A \u2208 NC , P \u2208 NR, f1, f2 are function symbols, xi \u2286 y, for i = 1, 2, and sql(y) is an SQL query in \u03a3 having output attributes y. Given Q in NC \u222a NR, a mapping m is defining Q if Q is on the left hand side of m.\nGiven an SQL query q and a DB instance D, qD denotes the set of answers to q over D. Given a database instance D, and a set of mappings M, we define the virtual assertions set AM,D as follows:\nAM,D = {A( f (o)) | o \u2208 \u03c0x(sql(y))D and A( f (x)) \u2190 sql(y) in M} \u222a {P( f (o), g(o\u2019)) | (o, o\u2019) \u2208 \u03c0x1,x2 (sql(y)) D and P( f (x1), g(x2)) \u2190 sql(y) in M}\nIn the Turtle syntax for mappings, we use templates\u2013strings with placeholders\u2013for specifying the functions (like f and g above) that map database values into URIs and literals. For instance, the string <http://statoil.com/{id}> is a URI template where \u201cid\u201d is an attribute; when id is instantiated as \u201c1\u201d, it generates the URI <http://statoil.com/1>.\nAn OBDA specification is a triple S = (T ,M, \u03a3) where T is an ontology, \u03a3 is a database schema with key dependencies, and M is a set of mappings between T and \u03a3. Given an OBDA specification S and a database instance D, we call the pair (S, D) an OBDA instance. Given an OBDA instance O = ((T ,M, \u03a3), D), the virtual RDF graph\n2 A wellbore is a three-dimensional representation of a hole in the ground.\n4 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nexposed by O is the RDF graph GAM,D ; the saturated virtual RDF graph GO exposed by O is the RDF graph G(T ,AM,D).\nExample 2. The mappings for the classes and properties introduced in Example 1 are:\n:Wellbore-{wellbore s} rdf:type :Wellbore \u2190 SELECT wellbore s FROM wellbore WHERE wellbore.r existence kd nm = \u2019actual\u2019\n:Wellbore-{wellbore s} :isInWell :Well-{well s} \u2190 SELECT well s, wellbore s FROM wellbore WHERE wellbore.r existence kd nm = \u2019actual\u2019\n:Wellbore-{wellbore s} :hasInterval :WellboreInterval-{wellbore intv s} \u2190 SELECT wellbore s, wellbore intv s FROM wellbore interval\n:Wellbore-{wellbore s} :completionDate \u2018{year}-{month}-{day}\u2019\u02c6\u02c6xsd:date \u2190 SELECT wellbore s, year, month, day FROM wellbore WHERE wellbore.r existence kd nm = \u2019actual\u2019\n:Wellbore-{wellbore s} rdf:type :ProdWellbore \u2190 SELECT w.wellbore s AS wellbore s FROM wellbore w, facility clsn WHERE complex-expression\nQuery Answering in OWL 2 QL KBs. A conjunctive query q(x) is a first order formula of the form \u2203y. \u03d5(x, y), where \u03d5(x, y) is a conjunction of equalities and atoms of the form A(t), P(t1, t2) (where A \u2208 NC , P \u2208 NR), and each t, t1, t2 is either a term or an individual variable in x, y. Given a conjunctive query q(x) and a knowledge base K := (T ,A), a tuple i \u2208 N |x|I is a certain answer to q(x) iff K |= q(i). The task of query answering in OWL 2 QL (DL-LiteR) can be addressed by query rewriting techniques [4]. For an OWL 2 QL ontology T , a conjunctive query q can be rewritten to a union qr of conjunctive queries such that for each assertion set A and each tuple of individuals i \u2208 N |x|I , it holds (T ,A) |= q(i) \u21d4 A |= qr(i). Many rewriting techniques have been proposed in the literature [14,22,3].\nSPARQL [9] is a W3C standard language designed to query RDF graphs. Its vocabulary contains four pairwise disjoint and countably infinite sets of symbols: I for IRIs, B for blank nodes, L for RDF literals, and V for variables. The elements of C = I\u222aB\u222aL are called RDF terms. A triple pattern is an element of (C \u222a V) \u00d7 I \u00d7 (C \u222a V). A basic graph pattern (BGP) is a finite set of joins of triple patterns. BGPs can be combined using the SPARQL operators join, optional, filter, projection, etc.\nExample 3. The following SPARQL query, containing a BGP with three triple patterns, returns all the wellbores, their completion dates, and the well where they are contained.\nSELECT * WHERE {?wlb rdf:type :Wellbore. ?wlb:completionDate ?cmpl. ?wlb:isInWell ?w.}\nTo ease the presentation of the technical development, in the rest of this paper we adopt the OWL 2 QL entailment regime for SPARQL query answering [15], but disallow complex class/property expressions in the query. Intuitively this restriction states that each BGP can be seen as a conjunctive query without existentially quantified variables. Under this restricted OWL 2 QL entailment regime, the task of answering a SPARQL query q over a knowledge base (T ,A) can be reduced to answering q over the saturated graph G(T ,A) under the simple entailment regime. This restriction can be lifted with the help of a standard query rewriting step [15].\nOBDA Constraints for Effective Query Answering (Extended Version) 5"}, {"heading": "3 SPARQL Query Answering in OBDA", "text": "In this section we describe the typical steps that an OBDA system performs to answer SPARQL queries and discuss the performance challenges. To do so, we pick the representative state-of-the-art OBDA system Ontop and discuss its functioning in detail.\nDuring its start-up, Ontop classifies the ontology, \u201ccompiles\u201d the ontology into the mappings generating the so-called T -mappings [19], and removes redundant mappings by using inclusion dependencies (e.g., foreign keys) contained in the database schema. Intuitively, T -mappings expose a saturated RDF graph. Formally, given a basic OBDA specification S = (T ,M, \u03a3), the mappings MT are T -mappings for S if, for every OBDA instance O = (S, D), GO = G(AMT ,D).\nExample 4. The T -mappings for our running example are those in Example 2 plus\n:Wellbore-{wellbore s} rdf:type :Wellbore \u2190 SELECT wellbore s FROM wellbore WHERE wellbore.r existence kd nm = \u2019actual\u2019\n:Wellbore-{wellbore s} rdf:type :Wellbore \u2190 SELECT wellbore s, wellbore intv s FROM wellbore interval\n:Wellbore-{wellbore s} rdf:type :Wellbore \u2190 SELECT w.wellbore s FROM wellbore w, facility clsn WHERE ... complex-expression\nThe new mappings are derived from the domain of the properties :isInWell, :completionDate, and because :ProdWellbore is a sub-class of :Wellbore.\nAfter the start-up, in the query answering stage, Ontop translates the input SPARQL query into an SQL query, evaluates it, and returns the answers to the end-user. We divide this stage in five phases: (a) the SPARQL query is rewritten using the tree-witness rewriting algorithm; (b) the rewritten SPARQL query is unfolded into an SQL query using T -mappings; (c) the resulting SQL query is optimized; (d) the optimized SQL query is executed by the database engine; (e) the SQL result is translated into the answer to the original SPARQL query. For the sake of simplicity, we disregard phase (a) since it goes out of the scope of this paper (cf. [10]), and phases (d) and (e) because they are straightforward. In the following we elaborate on phases (b) and (c).\nFrom SPARQL to SQL. In phase (b) the rewritten SPARQL query is unfolded into an SQL query using T -mappings. The rewritten query is first transformed into a tree representation of its SPARQL algebra expression. The algorithm starts by replacing each leaf of the tree, that is, a triple pattern of the form (s, p, o), with the union of the SQL queries defining p in the T -mapping. Such SQL queries are obtained as follows: given a triple pattern p = ?x rdf:type :A, and a mapping m = :A( f (y\u2032)) \u2190 sql(y), the SQL unfolding unf(p,m) of p by m is the SQL query SELECT \u03c4( f (y\u2032)) AS x FROM sql(y), where \u03c4 is an SQL function filling the placeholders in f with values in y\u2032. We denote the sub-expression \u201cSELECT \u03c4( f (y\u2032)) AS x\u201d by \u03c0x/ f (y\u2032). The notions of \u201cunf\u201d and \u201c\u03c0\u201d are defined similarly for properties.\nExample 5. Consider the triple pattern p = ?wlb :completionDate ?d, and the fourth mapping m from Example 2. Then the SQL unfolding unf(p,m) is the SQL query\nSELECT CONCAT(\":Wellbore-\",well s) AS wlb,CONCAT(\"\u2018\",year,\"-\",month,\"-\", day,\"\u2019\u02c6\u02c6xsd:date\") AS d FROM wellbore WHERE wellbore.r existence kd nm = \u2019actual\u2019\n6 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nGiven a triple pattern p and a set of mappings M, the SQL unfolding unf(p,M) of p by M is the SQL union \u222am\u2208M{unf(p,m) | unf(p,m) is defined}.\nOnce the leaves are processed, the algorithm processes the upper levels in the tree, where the SPARQL operators are translated into the corresponding SQL operators (Project, InnerJoin, LeftJoin, Union, and Filter). Once the root is translated the process terminates and the resulting SQL expression is returned.\nExample 6. The unfolded SQL query for the SPARQL query in Example 3 and T - mappings in Example 4 has the following shape:\n(\u03c0wlb/ sql:Wellbore \u222a \u03c0wlb/ sql:ProdWellbore \u222a \u03c0wlb/ sql:hasInterval)\nZ (\u03c0wlb/ ,cmp/^sql:completionDate) Z (\u03c0wlb/ ,w/\u25e6sql:isInWell)\nwhere = :Wellbore-{wellbore s}, ^ = \u2018{year}-{month}-{day}\u2019\u02c6\u02c6xsd:date, \u25e6 = :Well-{well s}, and sqlP is the SQL query in the mapping defining the class/property P.\nOptimizing the generated SQL queries. At this point, the unfolded SQL queries are merely of theoretical value as they would not be efficiently executable by any database system. A problem comes from the fact that they contain joins over the results of builtin database functions, which are expensive to evaluate. Another problem is that the unfoldings are usually verbose, often containing thousands of unions and join operators. Structural and semantic optimizations are in charge of dealing with these two problems.\nStructural Optimizations. To ease the presentation, we assume the queries to contain only one BGP. Extending to the general case is straightforward. An SQL unfolding of a BGP has the shape of a join of unions Q = Q1 Z Q2 . . . Z Qn, where each Qi is a union of sub-queries. The first step is to remove duplicate sub-queries in each Qi. In the second step, Q is transformed into a union of joins. In the third step, all joins of the kind \u03c0x/ f sql1(z) Z \u03c0x/gsql2(w) where f , g are removed because they do not produce any answer. In the fourth step, the occurrences of the SQL function \u03c0 for creating URIs are pushed to the root of the query tree so as to obtain efficient queries where the joins are over database values rather than over URIs. Finally, duplicates in the union are removed.\nSemantic Optimizations. SQL queries are semantically analyzed with the goal of transforming them into a more efficient form. The analyses are based on database integrity constraints (precisely, primary and foreign keys) explicitly defined in the database schema. These constraints are used to identify and remove redundant self-joins and unions from the unfolded SQL query.\nHow Optimized are Optimized Queries? There are real-world cases where the optimizations discussed above are not enough to mitigate the exponential explosion caused by the unfolding. As a result, the unfolded SQL queries cannot be efficiently handled by DB engines [16]. However, the same queries can usually be manually formulated in a succint way by database managers. A reason for this is that database dependencies cannot model certain domain constraints or storage policies that are available to the database manager but not to the OBDA system. The next example, inspired by the Statoil use case explained in Section 5, illustrates this issue.\nExample 7. The data stored at Statoil has certain properties that derive from domain constraints or storage policies. Consider a modified version of the query defining the\nOBDA Constraints for Effective Query Answering (Extended Version) 7\nclass :Wellbore where all the attributes are projected out. According to storage policies for the database table wellbore, the result of the evaluation of this query against any database instance must satisfy the following constraints: (i) it must contain all the wellbores3 in the ontology (modulo templates); (ii) every tuple in the result must contain the information about name, date, and well (no nulls); (iii) for each wellbore in the result, there is exactly one date/well that is tagged as \u2018actual\u2019.\nQuery with Redundant Unions. Consider the SPARQL query retrieving all the wellbores, namely SELECT * WHERE {?wlb rdf:type :Wellbore.}. By ontological reasoning, the query will retrieve also the wellbores that can be inferred from the subclasses of :Wellbore and from the properties where :Wellbore is the domain or range. Thus, after unfolding and optimizations, the resulting SQL query has the structure \u03c0wlb/ (sql1), with sql1 = (sql:Wellbore\u222a sql:ProdWellbore\u222a\u03c0#sql:hasInterval), where = :Wellbore-{wellbore s}, and # = wellbore s. However, all the answers returned by sql1 are also returned by the query sql:Wellbore alone, when these two queries are evaluated on a data instance satisfying item (i).\nQuery with Redundant Joins. For the SPARQL query in Example 3, the unfolded and optimized SQL translation is of the form \u03c0wlb/ ,cmp/^,w/\u25e6(sql2) with sql2 = sql1 Z sql:completionDate Z sql:isInWell. Observe that the answers from sql2 could also be retrieved from a projection and a selection over wellbore. This is because sql1 could be simplified to sql:Wellbore and items (ii) and (iii). The problem we highlight here is that this \u201coptimized\u201d SQL query contains two redundant joins if storage policies and domain constraints are taken into account.\nIt is important to remark that the constraints in the previous example cannot be expressed through schema dependencies like foreign or primary keys (because these constraints are defined over the output relations of SQL queries in the mappings, rather than over database relations4). Therefore, current state-of-the-art optimizations applied in OBDA cannot exploit this information."}, {"heading": "4 OBDA Constraints", "text": "We now formalize two properties over an OBDA instance: exact predicates and virtual functional dependencies. We will then enrich the OBDA specification with a constraints component, stating that all the instances for the specification display such properties.We show how this additional constraint component can be used to identify and remove redundant unions and joins from the unfolded queries.\nFrom now on, let O = (S, D) be an OBDA instance of a specificationS = (T ,M, \u03a3)."}, {"heading": "4.1 Exact Predicates in an OBDA Instance", "text": "In real world scenarios it often happens that axioms in the ontology do not enrich the answers to queries. Often this is due to storage policies not available to the OBDA system. This fact leads to redundant unions in the generated SQL, as shown in Example 7. In this section we show how certain properties defined on the mappings and the\n3 i.e., individuals in the class :Wellbore 4 Materializing the SQL in the mappings is not an option, since the schema is fixed.\n8 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\npredicates, ideally deriving from such constraints, can be used to reduce the number of redundant unions in the generated SQL queries for a given OBDA instance.\nDefinition 1 (Exact Mapping). Let M\u2032 be a set of mappings defining a predicate A. We say that M\u2032 is exact for A in O if O |= A(a) if and only if ((\u2205,M\u2032, \u03a3), D) |= A(a).\nIn practice it is often the case that the mappings for a particular predicate declared in the OBDA specification are already exact. This leads us to the next definition.\nDefinition 2 (Exact Predicate). A predicate A is exact in O if the set of all the mappings in M defining A are exact for A in O.\nRecall that Ontop adds new mappings to the initial set of mappings through the T - mapping technique. For exact predicates, this can be avoided while producing the same saturated virtual RDF graph. Fewer mappings lead to unfoldings with less unions.\nProposition 1. Let M\u2032 be exact for the predicate A in T . Let M\u2032 T be the result of replacing all the mappings defining A in MT by M\u2032. Then GO = G((\u2205,M \u2032 T ,\u03a3),D).\nExample 8. The T -mappings for :Wellbore consist of four mappings (see Example 4). However, :Wellbore is an exact class (Example 7). Therefore we can drop the three T -mappings for :Wellbore inferred from the ontology, and leave only its original mapping."}, {"heading": "4.2 Functional Dependencies in an OBDA instance", "text": "Recall that in database theory a functional dependency (abbr. FD) is an expression of the form x \u2192 y, read x functionally determines y, where x and y are tuples of attributes. We say that x \u2192 y is over an attributes set R if x \u2286 R and y \u2286 R. Finally, x \u2192 y is satisfied by a relation I on R if x \u2192 y is over R and for all tuples u, v \u2208 I, if the value u[x] of x in u is equal to the value v[x] of x in v, then u[y] = v[y]. Whenever R is clear from the context, we simply say that x \u2192 y is satisfied in I.\nA virtual functional dependency intuitively describes a functional dependency on a saturated virtual RDF graph. We identify two types of virtual functional dependencies:\n\u2013 Branching VFD: This dependency describes the relation between an object and a set of functional properties providing information about this object. Intuitively, it corresponds to a \u201cstar\u201d of \u201cfunctional-like\u201d5 properties in the virtual RDF graph. For instance, given a person, the properties describing its (unique) gender, national id, biological mother, etc. are a branching VFD. \u2013 Path VFD: This dependency describes the case when, from a given individual and a list of properties, there is at most one path that can be followed using the properties in the list. For instance, x works in a single department y, and y has a single manager w, and w works for a single company z. We use these notions to identify those cases where a SPARQL join of properties translates into a redundant SQL join.\n5 A property which is functional when restricting its domain/range to individuals generated from a single template.\nOBDA Constraints for Effective Query Answering (Extended Version) 9\nDefinition 3 (Virtual Functional Dependency). Let t be a template, and S t be the set of individuals in GO generated from t. Let P, P1, . . . , Pn be properties in T . Then\n\u2013 A branching VFD is an expression of the form t 7\u2192b P1 \u00b7 \u00b7 \u00b7 Pn. A VFD t 7\u2192b P is satisfied in O if for each element s \u2208 S t, there are no o , o\u2032 in GO such that {(s, P, o), (s, P, o\u2032)} \u2286 GO. A VFD t 7\u2192b P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O if t 7\u2192b Pi is satisfied in O for each i \u2208 {1, . . . , n}. \u2013 A path VFD is an expression of the form t 7\u2192p P1 \u00b7 \u00b7 \u00b7 Pn. A VFD t 7\u2192p P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O if for each s \u2208 S t there is at most one list of nodes (o1, . . . , on) in GO\nsuch that {(s, P1, o1), . . . , (on\u22121, Pn, on)} \u2286 GO.\nThe next example shows, similarly as in [23], that general path VFDs cannot be expressed as a combination of path VFDs of length 1.\nExample 9. Let GO = {(s, P1, o1), (o1, P2, o2), (s, P1, o\u20321)}, and t a template such that S t = {s}. Then, t 7\u2192p P1P2 is clearly satisfied in O. However, t 7\u2192p P1 is not.\nA property P might not be functional, but still t 7\u2192b P might be satisfied in O for some t.\nExample 10. Let GO = {(s, P, o1), (s, P, o2), (s\u2032, P, o3)}, and t a template such that S t = {s\u2032}. Then, the VFD t 7\u2192p P is satisfied in O, but P is not functional.\nA functional dependency satisfied in the virtual RDF graph might not correspond to a functional dependency over the database relations. We show this with an example:\nExample 11. Consider the following instance of the view wellbore.\nwellbore s year month day r existence kd nm well s\n002 2010 04 01 historic 1 002 2009 04 01 actual 1\nThe mapping defining :completionDate (c.f. Example 2) uses the view wellbore and has a filter r existence kd nm=\u2019actual\u2019. Observe that there is no FD (wellbore s\u2192 year month day). However, the VFD :Wellbore-{} 7\u2192b :completionDate is satisfied with this data instance, since in GO the wellbore :Wellbore-002 is connected to a single date \"2010-04-01\"\u02c6\u02c6xsd:date through :completionDate.\nFunctional dependencies satisfied in a database instance often do not correspond to any VFD at the virtual level. We show this with an example:\nExample 12. Consider the table T1(x, y, z) with a single tuple: (1, 2, 3). Clearly x \u2192 y and x \u2192 z are FDs satisfied in T1. Now consider the following mappings:\n:{x} P1 :{y} \u2190 SELECT * FROM T1 :{x} P1 :{z} \u2190 SELECT * FROM T1\nClearly, there is no VFD involving P1.\nHence, the shape of the mappings affects the satisfiability of VFDs. Moreover, the ontology can also affect satisfiability. We show this with an example:\n10 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nExample 13. Consider again the data instance DE from Example 12, and the mappings ME\n:{x} P1 :{y} \u2190 SELECT * FROM T1 :{x} P2 :{z} \u2190 SELECT * FROM T1\nConsider an OBDA instance OE = ((\u2205,ME, \u03a3E)DE). Then the virtual functional dependencies :{} 7\u2192b P1 and :{} 7\u2192b P2 are satisfied in O. Consider another OBDA instance O\u2032E = ((TE ,ME , \u03a3E), DE), where TE = {P1 rdfs:subClassOf P2}. Then the two VFDs above are not satisfied in O\u2032E .\nVFD Based Optimization In this section we show how to optimize queries using VFDs. Due to space limitations, we focus on branching VFDs. The results for path VFDs are analogous and can be found in the appendix, as well as proofs.\nDefinition 4. The set of mappings M is basic for T if, for each property P in T , P is defined by at most one mapping in MT . We say that O is basic if M is basic for T .\nTo ease the presentation, from now on we assume O to be basic. We denote the (unique) mapping for Pi in T , i \u2208 {1, . . . ,m}, as\ntid(xi) Pi t i r(yi) \u2190 sqli(zi).\nwhere tid, and t i r are templates for the domain and range of Pi, and xi, yi are lists of attributes in zi. The list zi is the list of projected attributes, which we assume to be the maximal list of attributes that can be projected from sqli.\nAlthough we only consider basic instances, we show in the appendix how the results from this section can also be applied to the general case.\nWe also assume that queries sqli(zi) always contain a filter expression of the form \u03c3notNull(xi ,yi), even if we do not specify it explicitly in the examples, since URIs cannot be generated from nulls [6]. Without loss of generality, we assume that z1 contains all the attributes in x1,y1, . . . , yn.\nIn order to check satisfiability for a VFD in an OBDA instance one can analyze the DB based on the mappings and the ontology. The next lemma formalizes this intuition.\nLemma 1. Let P1, . . . , Pn be properties in T such that, for each 1 \u2264 i < n, tid = t 1 d. Then, the VFD t1d 7\u2192 b P1 . . . Pn is satisfied in O if and only if, for each 1 \u2264 i \u2264 n, the FD xi \u2192 yi is satisfied on sqli(zi) D.\nExample 14. Consider the properties :inWell and :completionDate from our running example. The lemma above suggests that the VFD :Wellbore-{} 7\u2192b :isInWell :completionDate is satisfied in our OBDA instance with a database instance D if and only if (i) wellbore s\u2192well s is satisfied in sqlD:isInWell, and (ii) wellbore s\u2192year month day is satisfied in sql D :completionDate.\nFrom Example 7, there is an organization constraint for the view wellbore forcing only one completion date for each \u201cactual\u201d wellbore. As a consequence, the two FDs (i) and (ii) hold in any database D following this organization constraint. Therefore, the VFD in such instance is also satisfied.\nWe now show how VFDs can be used to find redundant joins that can be eliminated in the SQL translations.\nOBDA Constraints for Effective Query Answering (Extended Version) 11\nDefinition 5 (Optimizing Branching VFD). Let t be a template. An optimizing branching VFD is an expression of the form t b P1 \u00b7 \u00b7 \u00b7Pn. An optimizing VFD t b P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O if t 7\u2192b P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O, and for each i \u2208 {1, . . . , n} it holds\n\u03c0x1,yi sql1(z1) D \u2286 \u03c1x1/xi (\u03c0xi ,yi sqli(zi)) D (1)\nExample 15. Recall that the VFD :Wellbore-{} 7\u2192b :isInWell, :completionDate in Example 14 is satisfied in our OBDA instance. The precondition (1) holds because (a) the properties are defined by the same SQL query (modulo projection) and (b) the organization constraint \u201ceach wellbore entry must contain the information about name, date, and well (no nulls)\u201d. Thus, the optimizing VFD :Wellbore-{} b :isInWell, :completionDate is satisfied in this instance.\nLemma 2. Consider n properties P1, . . . , Pn with tid = t 1 d, for each 1 \u2264 i \u2264 n, and for which t1d b P1 \u00b7 \u00b7 \u00b7Pn is satisfied in O. Then\n\u03c0\u03b3(sql1(z1))D = \u03c0\u03b3(sql1(z1) Zx1=x2 sql2(z2) Z \u00b7 \u00b7 \u00b7 Zx1=xn sqln(zn)) D,\nwhere \u03b3 = x1, y1, . . . , yn.\nWe now show how virtual functional dependencies can be used in presence of triple patterns of the form ?z rdf:type C. As for properties, We assume that for each concept C j we have a single T -mapping of the form C j(t j(x)) \u2190 sql j(z j).\nDefinition 6 (Domain Optimizing Class Expression). A domain optimizing class expression (domain OCE) is an expression of the form t j dPi C j. We say that t j d Pi\nC j is satisfied in O if t j = tid and \u03c0xsql j(z j) D \u2287 \u03c1x/xi (\u03c0xi sqli(zi)) D.\nDefinition 7 (Range Optimizing Class Expression). A range optimizing class expression (range OCE) is an expression of the form t j rP C j. We say that t j r Pi\nC j is satisfied in O if t j = tir and \u03c0xsql j(z j) D \u2287 \u03c1x/yi (\u03c0yi sqli(zi)) D .\nOptimizing VFDs and classes give us a tool to identify those BGPs whose SQL translation can be optimized by removing redundant joins.\nDefinition 8 (Optimizable branching BGP). A BGP \u03b2 is optimizable w.r.t. v = td b P1 . . . Pn if (i) v is satisfied in O; (ii) the BGP of triple patterns in \u03b2 involving properties is of the form ?v P1 ?v1. ...?v Pn ?vn.; and (iii) for each triple pattern of the form ?u rdf:type C in \u03b2 , ?u is either the subject of some Pi and tid d Pi\nC is satisfied in O , or ?u is in the object of some Pi and tir r Pi C is satisfied in O.\nFinally, we prove that the standard SQL translation of optimizable BGPs contains redundant SQL joins that can be safely removed.\nTheorem 1. Let \u03b2 be an optimizable BGP w.r.t. td x P1 . . . Pn (x = b, p) in O. Let \u03c0v/t1d,v1/t 1 r ,...,vn/t n r sql\u03b2 be the SQL translation of \u03b2 as explained in Section 3. Let sql\u2032\u03b2 = sql1(x1, y1 . . . , yn). Then sql D \u03b2 and sql\u2032D \u03b2 return the same answers.\n12 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nCorollary 1. Let Q be a SPARQL query. Let sqlQ be the SQL translation of Q as explained in Section 3. Let sql\u2032Q be the SQL translation of Q where all the SQL expressions corresponding to an optimizable BGPs w.r.t. a set of VFDs have been optimized as stated in Theorem 1. Then sqlDQ and sql \u2032D Q return the same answers.\nExample 16. It is clear that the class :Wellbore is optimizing w.r.t. the domain of :completionDate and :isInWell. Since :Wellbore-{} b :completionDate, :isInWell is satisfied (c.f. Example 15), one can allow the semantic optimizations to safely remove redundant joins in query sql1, sketched in Example 7. From Theorem 1, it follows that, sql:Wellbore Z sql:completionDate Z sql:isInWell can be by simplified to sql:Wellbore."}, {"heading": "4.3 Enriching the OBDA Specification with Constraints", "text": "We propose to enrich the traditional OBDA specification with a constraint component, so as to allow the OBDA system to perform enhanced optimization as described in the previous section. More formally, an OBDA specification with constraints is a tuple Sconstr = (S,C) where S is an OBDA specification and C is a set of exact mappings, exact predicates, optimizing virtual functional dependencies, and optimizing class expressions. An instance of Sconstr is an OBDA instance of S satisfying the constraints in C. Our intention is to be able to use more of the constraints that exist in real databases for query optimization, since we often see that these cannot be expressed by existing database constraints (i.e. keys). Since S does not necessarily imply C, checking the validity of C may have to take into account more information than just S . The constraints C may be known to hold e.g. by policy, or be enforced by external tools, e.g., as in the case mentioned in the experiments below, by the tool used to enter data into the database.\nIn order to aid the user in the specification of C, we implemented tools to identify what exact mappings and optimizing virtual functional dependencies are satisfied in a given OBDA instance (see appendix). . The user can then verify whether these suggested constraints hold in general, for example because they derive from storage policies or domain knowledge, and provide them as parameters to the OBDA system. The user intervention is necessary, because constraints derived from actual data can be an artifact of the current situation of the database.\nOptimizing VFD Constraints. We have implemented a tool that automatically finds a restricted type of optimizing VFDs satisfied in a given OBDA instance and we have extended Ontop to complement semantic optimization using these VFDs. This implementation aims to mitigate the problem of redundant self-joins resulting from reifying relational tables. Although this is a simple case, it is extremely common in practice and, as we show in our experiments in Section 5, this class of VFDs is powerful enough to sensibly improve the execution times in real world scenarios.\nExact Predicates Constraints. We implemented a tool to find exact predicates, and we extended Ontop to optimize T -mappings with them. For each predicate P in the ontology T of an OBDA instance O, the tool constructs the query q that returns all the individual/pairs in P. Then it evaluates q in the two OBDA instances O and ((\u2205,M, \u03a3), D). If the answers for q coincide in both instances, then P is exact.\nOBDA Constraints for Effective Query Answering (Extended Version) 13"}, {"heading": "5 Experiments", "text": "In this section we present a set of experiments evaluating the techniques described above. In the appendix we ran additional controlled experiments using an OBDA benchmark built on top of the Wisconsin benchmark [7], and obtain similar results to the ones here.\nStatoil Scenario In this section we briefly describe the Statoil use-case, and the challenges it presents for OBDA. At Statoil, users access several databases on a daily basis, and one of the most important ones is the Exploration and Production Data Store (EPDS) database. EPDS is a large legacy SQL (Oracle 10g) database comprising over 1500 tables (some of them with up to 10 million tuples) and 1600 views. The complexity of the SQL schema of EPDS is such that it is counter-productive and error-prone to manually write queries over the relational database. Thus, end-users either use only a set of tools with predefined SQL queries to access the database, or interact with IT experts so as to formulate the right query. The latter process can take weeks. This situation triggered the introduction of OBDA in Statoil in the context of the Optique project [13]. In order to test OBDA at Statoil, the users provided 60 queries (in natural language) that are relevant to their job, and that cannot be easily performed or formulated at the moment. The Optique partners formulated these queries in SPARQL, and handcrafted an ontology, and a set of mappings connecting EPDS to the ontology. The ontology contains 90 classes, 37 object properties, and 31 data properties; and there are more than 140 mappings. The queries have between 0 to 2 complex filter expressions (with several arithmetic and string operations), 0 to 5 nested optionals, modifiers such as ORDER BY and DISTINCT, and up to 32 joins.\nExperiment Results. The queries were executed sequentially on a HP ProLiant server with 24 Intel Xeon CPUs (X5650 @ 2.67 GHz), 283 GB of RAM. Each query was evaluated three times and we took the average. We ran the experiments with 4 exact concepts and 15 virtual functional dependencies, found with our tools and validated by database experts. The 60 SPARQL queries have been executed over Ontop with and without the optimizations for exact predicates and virtual functional dependencies. We consider that a query times out if the average execution time is greater than 20 minutes.\nThe results are summarized in Table 1 and Figure 1. We can see that the proposed optimizations allow Ontop to critically reduce the query size and improve the performance of the query execution by orders of magnitude. Specifically, in Figure 1 we compare standard optimizations with and without the techniques presented here. Observe\n14 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nthat the average successful query execution time is higher with new optimizations than without because the number of successfully executed queries increases. With standard optimizations, 17 SPARQL queries time out. With both novel optimizations enabled, only four queries still time out.\nA total of 27 SPARQL queries get a more compact SQL translation with new optimizations enabled. The largest proportional decrease in size of the SQL query is 94%, from 171k chars, to 10k. The largest absolute decrease in size of the SQL is 408k chars. Note that the number of unions in the SQL may decrease also only with VFD-based optimization. Since the VFD-based optimization removes joins, more unions may become equivalent and are therefore removed. The maximum measured decrease in execution time is on a query that times out with standard optimizations, but uses 3.7 seconds with new optimizations."}, {"heading": "6 Related work", "text": "Dependencies have been intensively studied in the context of traditional relational databases [2]. Our work is related to the one in [23]; in particular their notion of path functional dependency is close to the notion of path VFD presented here. However, they do not consider neither ontologies, nor databases, and their dependencies are not meant to be used to optimize queries. There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF do not necessarily correspond to a VFD (when considering the ontology). Besides, these works do not tackle the issue of SQL query optimization.\nThe notion of perfect mapping [8] is strongly related to the notion of exact mapping. However there is a substantial difference: a perfect mapping must be entailed by the OBDA specification, whereas exact mappings are additional constraints that enrich the OBDA specification. For instance, perfect mappings would not be effective in the Statoil use case, where organizational constraints and storage policies are not entailed by the OBDA specification. The notion of EBox [21,17] was proposed as an attempt to include constraints in OBDA. However, EBox axioms are defined through a T -box like syntax. These axioms cannot express constraints based on templates like virtual functional dependencies."}, {"heading": "7 Conclusions", "text": "In this work we presented two novel optimization techniques for OBDA that complement standard optimizations in the area, and enable efficient SPARQL query answering over enterprise relational data. We provided theoretical foundations for these techniques\nOBDA Constraints for Effective Query Answering (Extended Version) 15\nbased on two novel OBDA constraints: virtual functional dependencies, and exact predicates. We implemented these techniques in our OBDA system Ontop and empirically showed their effectiveness through extensive experiments that display improvements on the query execution time up to orders of magnitude.\nAcknowledgement. This work is partially supported by the EU under IP project Optique (Scalable End-user Access to Big Data), grant agreement n. FP7-318338."}, {"heading": "A Appendix", "text": ""}, {"heading": "A.1 Background On SPARQL to SQL", "text": "In this section, we recap the complete SPARQL to SQL translation [15]. This background will be used for the proofs in the following sections.\nSPARQL under Simple Entailment SPARQL is a W3C standard language designed to query RDF graphs. Its vocabulary contains four pairwise disjoint and countably infinite sets of symbols: I for IRIs, B for blank nodes, L for RDF literals, and V for variables. The elements of C = I \u222a B \u222a L are called RDF terms. A triple pattern is an element of (C \u222a V)\u00d7 (I\u222a V)\u00d7 (C \u222a V). A basic graph pattern (BGP) is a finite set of triple patterns. Finally, a graph pattern, P, is an expression defined by the grammar\nP ::= BGP | Filter(P, F) | Bind(P, v, c) | Union(P1, P2)\n| Join(P1, P2) | Opt(P1, P2, F),\nwhere F, a filter, is a formula constructed from atoms of the form bound(v), (v = c), (v = v\u2032), for v, v\u2032 \u2208 V, c \u2208 C, and possibly other built-in predicates using the logical connectives \u2227 and \u00ac. The set of variables in P is denoted by var(P).\nA SPARQL query is a graph pattern P with a solution modifier, which specifies the answer variables\u2014the variables in P whose values we are interested in\u2014and the form of the output (we ignore other solution modifiers for simplicity). The values to variables are given by solution mappings, which are partial maps s : V\u2192 C with (possibly empty) domain dom(s). In this paper, we use the set-based (rather than bag-based, as in the specification) semantics for SPARQL. For sets S 1 and S 2 of solution mappings, a filter F, a variable v \u2208 V and a term c \u2208 C, let\n\u2013 Filter(S , F) = {s \u2208 S | F s = \u22a4}; \u2013 Bind(S , v, c) = {s \u2295 {v 7\u2192 c} | s \u2208 S } (provided that v < dom(s), for s \u2208 S ); \u2013 Union(S 1, S 2) = {s | s \u2208 S 1 or s \u2208 S 2}; \u2013 Join(S 1, S 2) = {s1 \u2295 s2 | s1 \u2208 S 1 and s2 \u2208 S 2 are compatible}; \u2013 Opt(S 1, S 2, F) = Filter(Join(S 1, S 2), F) \u222a {s1 \u2208 S 1 | for all s2 \u2208 S 2,\neither s1, s2 are incompatible or F s1\u2295s2 , \u22a4}.\nHere, s1 and s2 are compatible if s1(v) = s2(v), for any v \u2208 dom(s1) \u2229 dom(s2), in which case s1 \u2295 s2 is a solution mapping with s1 \u2295 s2 : v 7\u2192 s1(v), for v \u2208 dom(s1), s1 \u2295 s2 : v 7\u2192 s2(v), for v \u2208 dom(s2), and domain dom(s1) \u222a dom(s2). The truth-value F s \u2208 {\u22a4,\u22a5, \u03b5} of a filter F under a solution mapping s is defined inductively:\n\u2013 (bound(v))s is \u22a4 if v \u2208 dom(s) and \u22a5 otherwise; \u2013 (v = c)s = \u03b5 if v < dom(s); otherwise, (v = c)s is the classical truth-value of the\npredicate s(v) = c; similarly, (v = v\u2032)s = \u03b5 if either v or v\u2032 < dom(s); otherwise, (v = v\u2032)s is the classical truth-value of the predicate s(v) = s(v\u2032);\n\u2013 (\u00acF)s = { \u03b5, if F s = \u03b5, \u00acF s, otherwise, and (F1 \u2227 F2)s =\n           \u22a5, if F s1 = \u22a5 or F s 2 = \u22a5, \u22a4, if F s1 = F s 2 = \u22a4,\n\u03b5, otherwise.\n18 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nFinally, given an RDF graph G, the answer to a graph pattern P over G is the set ~P G of solution mappings defined by induction using the operations above and starting from the following base case: for a basic graph pattern B,\n~B G = {s : var(B) \u2192 C | s(B) \u2286 G}, (2)\nwhere s(B) is the set of triples resulting from substituting each variable u in B by s(u). This semantics is known as simple entailment.\nTranslating SPARQL under Simple Entailment to SQL We recap the basics of relational algebra and SQL (see e.g., [?]). Let U be a finite (possibly empty) set of attributes. A tuple over U is a map t : U \u2192 \u2206, where \u2206 is the underlying domain, which always contains a distinguished element null. A (|U |-ary) relation over U is a finite set of tuples over U (again, we use the set-based rather than bag-based semantics). A filter F over U is a formula constructed from atoms isNull(U \u2032), (u = c) and (u = u\u2032), where U \u2032 \u2286 U, u, u\u2032 \u2208 U and c \u2208 \u2206, using the connectives \u2227 and \u00ac. Let F be a filter with variables U and let t be a tuple over U. The truth-value F t \u2208 {\u22a4,\u22a5, \u03b5} of F over t is defined inductively:\n\u2013 (isNull(U \u2032))t is \u22a4 if t(u) is null, for all u \u2208 U \u2032, and \u22a5 otherwise; \u2013 (u = c)t = \u03b5 if t(u) is null; otherwise, (u = c)t is the classical truth-value of the\npredicate t(u) = c; similarly, (u = u\u2032)t = \u03b5 if either t(u) or t(u\u2032) is null; otherwise, (u = u\u2032)t is the classical truth-value of the predicate t(u) = t(u\u2032);\n\u2013 (\u00acF)t =\n       \u03b5, if F t = \u03b5, \u00acF t, otherwise, and (F1 \u2227 F2)t =\n           \u22a5, if F t1 = \u22a5 or F t 2 = \u22a5, \u22a4, if F t1 = F t 2 = \u22a4,\n\u03b5, otherwise.\n(Note that \u00ac and\u2227 are interpreted in the same three-valued logic as in SPARQL.) We use standard relational algebra operations such as union, difference, projection, selection, renaming and natural (inner) join. Let Ri be a relation over Ui, i = 1, 2.\n\u2013 If U1 = U2 then the standard R1 \u222a R2 and R1 \\ R2 are relations over U1. \u2013 If U \u2286 U1 then \u03c0UR1 = R1|U is a relation over U. \u2013 If F is a filter over U1 then \u03c3FR1 = {t \u2208 R1 | F t = \u22a4} is a relation over U1. \u2013 If v < U1 and u \u2208 U1 then \u03c1v/uR1 = { tv/u | t \u2208 R1 }\n, where tv/u : v 7\u2192 t(u) and tv/u : u\u2032 7\u2192 t(u\u2032), for u\u2032 \u2208 U1 \\ {u}, is a relation over (U1 \\ {u}) \u222a {v}. \u2013 R1 Z R2 = {t1 \u2295 t2 | t1 \u2208 R1 and t2 \u2208 R2 are compatible} is a relation over U1 \u222a U2. Here, t1 and t2 are compatible if t1(u) = t2(u) , null, for all u \u2208 U1 \u2229 U2, in which case a tuple t1 \u2295 t2 over U1 \u222a U2 is defined by taking t1 \u2295 t2 : u 7\u2192 t1(u), for u \u2208 U1, and t1 \u2295 t2 : u 7\u2192 t2(u), for u \u2208 U2 (note that if u is null in either of the tuples then they are incompatible).\nTo bridge the gap between partial functions (solution mappings) in SPARQL and total mappings (on attributes) in SQL, we require one more operation (expressible in SQL):\n\u2013 If U \u2229 U1 = \u2205 then the padding \u00b5U R1 is R1 Z nullU , where nullU is the relation consisting of a single tuple t over U with t : u 7\u2192 null, for all u \u2208 U.\nOBDA Constraints for Effective Query Answering (Extended Version) 19\nBy an SQL query, Q, we understand any expression constructed from relation symbols (each over a fixed set of attributes) and filters using the relational algebra operations given above (and complying with all restrictions on the structure). Suppose Q is an SQL query and D a data instance which, for any relation symbol in the schema under consideration, gives a concrete relation over the corresponding set of attributes. The answer to Q over D is a relation \u2016Q\u2016D defined inductively in the obvious way starting from the base case: for a relation symbol Q, \u2016Q\u2016D is the corresponding relation in D.\nWe now define a translation, \u03c4, which, given a graph pattern P, returns an SQL query \u03c4(P) with the same answers as P. More formally, for a set of variables V , let extV be a function transforming any solution mapping s with dom(s) \u2286 V to a tuple over V by padding it with nulls:\nextV (s) = {v 7\u2192 s(v) | v \u2208 dom(s)} \u222a {v 7\u2192 null | v \u2208 V \\ dom(s)}.\nThe relational answer to P over G is \u2016P\u2016G = {extvar(P)(s) | s \u2208 ~P G}. The SQL query \u03c4(P) will be such that, for any RDF graph G, the relational answer to P over G coincides with the answer to \u03c4(P) over triple(G), the database instance storing G as a ternary relation triple with the attributes subj, pred, obj. First, we define the translation of a SPARQL filter F by taking \u03c4(F) to be the SQL filter obtained by replacing each bound(v) with \u00acisNull(v) (other built-in predicates can be handled similarly).\nProposition 2. Let F be a SPARQL filter and let V be the set of variables in F. Then F s = (\u03c4(F))extV (s), for any solution mapping s with dom(s) \u2286 V.\nThe definition of \u03c4 proceeds by induction on the construction of P. Note that we can always assume that graph patterns under simple entailment do not contain blank nodes because they can be replaced by fresh variables. It follows that a BGP {tp1, . . . , tpn} is equivalent to Join({tp1}, Join({tp2}, . . . )). So, for the basis of induction we set\n\u03c4({\u3008s, p, o\u3009}) =\n                       \u03c0\u2205\u03c3(subj=s)\u2227(pred=p)\u2227(obj=o) triple, if s, p, o \u2208 I \u222a L, \u03c0s\u03c1s/subj \u03c3(pred=p)\u2227(obj=o) triple, if s \u2208 V and p, o \u2208 I \u222a L, \u03c0s,o\u03c1s/subj \u03c1o/obj \u03c3pred=p triple, if s, o \u2208 V, s , o, p \u2208 I \u222a L,\n\u03c0s\u03c1s/subj \u03c3(pred=p)\u2227(subj=obj) triple, if s, o \u2208 V, s = o, p \u2208 I \u222a L, . . .\n(the remaining cases are similar). Now, if P1 and P2 are graph patterns and F1 and F are filters containing only variables in var(P1) and var(P1)\u222a var(P2), respectively, then we set Ui = var(Pi), i = 1, 2, and\n\u03c4(Filter(P1, F1)) = \u03c3\u03c4(F1 )\u03c4(P1), \u03c4(Bind(P1, v, c)) = \u03c4(P1) Z {v 7\u2192 c},\n\u03c4(Union(P1, P2)) = \u00b5U2\\U1\u03c4(P1) \u222a \u00b5U1\\U2\u03c4(P2), \u03c4(Join(P1, P2)) = \u22c3\nV1,V2\u2286U1\u2229U2 V1\u2229V2=\u2205\n[ (\u03c0U1\\V1\u03c3isNull(V1)\u03c4(P1))Z (\u03c0U2\\V2\u03c3isNull(V2)\u03c4(P2)) ] ,\n\u03c4(Opt(P1, P2, F)) = \u03c4(Filter(Join(P1, P2), F)) \u222a\n\u00b5U2\\U1 ( \u03c4(P1) \\ \u22c3\nV1\u2286U1\u2229U2\n\u00b5V1\u03c0U1\\V1\u03c4(Filter(Join(P V1,U1\u2229U2 1 , P2), F)) ) ,\n20 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nwhere PV,U = Filter(P, \u2227 v\u2208V \u00acbound(v) \u2227 \u2227 v\u2208U\\V bound(v)). It is readily seen that any \u03c4(P) is a valid SQL query and defines a relation over var(P); in particular, \u03c4(Join(P1, P2)) is a relation over \u22c3\ni=1,2(Ui \\ Vi) = U1 \u222a U2 = var(Join(P1, P2)).\nTheorem 2. For any RDF graph G and any graph pattern P, \u2016P\u2016G = \u2016\u03c4(P)\u2016triple(G).\nR2RML Mappings The SQL translation of a SPARQL query constructed above has to be evaluated over the ternary relation triple(G) representing the virtual RDF graph G. Our aim now is to transform it to an SQL query over the actual database, which is related to G by means of an R2RML mapping [6]. We begin with a simple example.\nExample 17. The following R2RML mapping (in the Turtle syntax) populates an object property ub:UGDegreeFrom from a relational table students, whose attributes id and degreeuniid identify graduate students and their universities:\n:m1 a rr:TripleMap; rr:logicalTable [ rr:sqlQuery \u201dSELECT * FROM students WHERE stype=1\u201d ]; rr:subjectMap [ rr:template \u201d/GradStudent{id}\u201d ] ; rr:predicateObjectMap [ rr:predicate ub:UGDegreeFrom ;\nrr:objectMap [ rr:template \u201d/Uni{degreeuniid}\u201d ] ]\nMore specifically, for each tuple in the query, an R2RML processor generates an RDF triple with the predicate ub:UGDegreeFrom and the subject and object constructed from attributes id and degreeuniid, respectively, using IRI templates.\nOur aim now is as follows: given an R2RML mapping M, we are going to define an SQL query trM(triple) that constructs the relational representation triple(GD,M) of the virtual RDF graph GD,M obtained by M from any given data instance D. Without loss of generality and to simplify presentation, we assume that each triple map has\n\u2013 one logical table (rr:sqlQuery), \u2013 one subject map (rr:subjectMap), which does not have resource typing (rr:class), \u2013 and one predicate-object map with one rr:predicateMap and one rr:objectMap.\nThis normal form can be achieved by introducing predicate-object maps with rdf:type and splitting any triple map into a number of triple maps with the same logical table and subject. We also assume that triple maps contain no referencing object maps (rr:parentTriplesMap, etc.) since they can be eliminated using joint SQL queries [6]. Finally, we assume that the term maps (i.e., subject, predicate and object maps) contain no constant shortcuts and are of the form [rr:column v], [rr:constant c] or [rr:template s].\nGiven a triple map m with a logical table (SQL query) R, we construct a selection \u03c3\u00acisNull(v1) \u00b7 \u00b7 \u00b7\u03c3\u00acisNull(vk)R, where v1, . . . , vk are the referenced columns of m (attributes of R in the term maps in m)\u2014this is done to exclude tuples that contain null [6]. To construct trm, the selection filter is prefixed with projection \u03c0subj,pred,obj and, for each of the three term maps, either with renaming (e.g., with \u03c1obj/v if the object map is of the form [rr:column v]) or with value creation (if the term map is of the form [rr:constant c] or [rr:template s]; in the latter case, we use the built-in string concatenation function ). For instance, the mapping :m1 from Example 17 is converted to the SQL query\nSELECT (\u2019/GradStudent\u2019 id) AS subj, \u2019ub:UGDegreeFrom\u2019 AS pred, (\u2019/Uni\u2019 degreeuniid) AS obj FROM students\nWHERE (id IS NOT NULL) AND (degreeuniid IS NOT NULL) AND (stype=1).\nOBDA Constraints for Effective Query Answering (Extended Version) 21\nGiven an R2RML mapping M, we set trM(triple) = \u22c3 m\u2208M trm.\nProposition 3. For any R2RML mapping M and data instance D, t \u2208 \u2016trM(triple)\u2016D if and only if t \u2208 triple(GD,M).\nFinally, given a graph pattern P and an R2RML mappingM, we define trM(\u03c4(P)) to be the result of replacing every occurrence of the relation triple in the query \u03c4(P), constructed in Section A.1, with trM(triple). By Theorem 2 and Proposition 3, we obtain:\nTheorem 3. For any graph pattern P, R2RML mappingM and data instance D, \u2016P\u2016GD,M = \u2016trM(\u03c4(P))\u2016D."}, {"heading": "A.2 Proofs of Section 4.1", "text": "Proposition 1. Let M\u2032 be exact for the predicate A in T . Let M\u2032 T be the result of replacing all the mappings defining A in MT by M\u2032. Then GO = G((\u2205,M \u2032 T ,\u03a3),D).\nProof (Sketch). By the definition of T -mappings, we have GO = G\u2205,MT ,D. For all predicates other than A, MT and M\u2032T produce the same set of triples since the mappings defining them are identical. For the predicate A, since M\u2032 is exact in O, MT and M\u2032T also produce same set of triples. Therefore G\u2205,MT ,D = G\u2205,M \u2032 T ,D."}, {"heading": "A.3 Proofs of Section 4.2", "text": "Lemma 1. Let P1, . . . , Pn be properties in T such that, for each 1 \u2264 i < n, tid = t 1 d. Then, the VFD t1d 7\u2192 b P1 . . . Pn is satisfied in O if and only if, for each 1 \u2264 i \u2264 n, the FD xi \u2192 yi is satisfied on sqli(zi) D.\nProof. t1d 7\u2192 b P1 . . . Pn is satisfied in GO m (Definition 3) \u2200s \u2208 S t1d : \u22001 \u2264 i \u2264 n : (s, o) \u2208 P GO i \u2227 (s, o \u2032) \u2208 PG O i \u21d2 o = o \u2032 m (Mappings assumptions for Pi) \u22001 \u2264 i \u2264 n : \u2200u \u2208 \u03c0xi\u03c3notNull(xi ,yi) sqli(zi) D : (u, y) \u2208 \u03c0xiyi\u03c3notNull(xi ,yi)sqli(zi) D \u2227 (u, y\u2019) \u2208 \u03c0xiyi\u03c3notNull(xi ,yi) sqli(zi) D \u21d2 y = y\u2019 m (Definition of Functional Dependency) \u22001 \u2264 i \u2264 n : xi \u2192 yi is satisfied in \u03c0xiyi\u03c3notNull(xi ,yi) sqli(zi) D m \u22001 \u2264 i \u2264 n : xi \u2192 yi is satisfied in \u03c3notNull(xi,yi) sqli(zi) D\nLemma 2. Consider n properties P1, . . . , Pn in T with tid = t 1 d, for each 1 \u2264 i \u2264 n, and for which t1d b P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O. Then\n\u03c0\u03b3(sql1(z1))D = \u03c0\u03b3(sql1(z1) Zx1=x2 sql2(z2) Z \u00b7 \u00b7 \u00b7 Zx1=xn sqln(zn)) D,\nwhere \u03b3 = x1, y1, . . . , yn.\n22 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\nProof. The direction \u2286 of the equality can be obtained easily. Here we prove the direction \u2287.\nLet qDbranch denote the right hand side expression in the equality. Assume the containment \u2287 does not hold. Then, this means there exists a tuple (s, v1, . . . , vn) such that\n\u2013 (u, v1, . . . , vn) \u2208 qDbranch, and \u2013 (u, v1, . . . , vn) < \u03c0x1,v1,...,vn\u03c3notNull(x1,y1)sql1(z1) D\nThe above implies that there exists an index j, 1 \u2264 j \u2264 n, such that\n\u2013 (u, v j) \u2208 \u03c0x1,y j q D branch, and \u2013 (u, v j) < \u03c0x1,y j\u03c3notNull(x1,y1)sql1(z1) D\nThen, we can distinguish three cases:\n1. u < \u03c0x1\u03c3notNull(x1,y1)sql1(z1). Then u < \u03c0x1 q D branch, hence (u, v j) < \u03c0x1,y j q D branch; contradiction. 2. (u, v\u2032j) \u2208 \u03c0x1,y j\u03c3notNull(x1,y1)sql1(z1), and v \u2032 j = null.\nSince t1d b P1 \u00b7 \u00b7 \u00b7 Pn is satisfied inO, it must be (u, null) \u2208 \u03c0x j ,y j\u03c3notNull(x j ,y j)sql j(z j) D, which is impossible.\n3. (u, v\u2032j) \u2208 \u03c0x1,y j\u03c3notNull(x1,y1)sql1(z1) D, v j , v\u2032j and not v j nor v \u2032 j is null.\nThis violates the hypothesis that t1d b P1 \u00b7 \u00b7 \u00b7Pn is satisfied in O, because of Lemma 1.\nHence, by contradiction we conclude that the containment \u2287 must hold."}, {"heading": "Results and Proofs for PATH VFDs", "text": "Lemma 3. Let P1, . . . , Pn be properties in T such that, for each 1 \u2264 i \u2264 n, tri = tdi+1 . Then, the VFD t1d 7\u2192\np P1 . . . Pn is satisfied in O if and only if the FD x1 \u2192 y1 \u00b7 \u00b7 \u00b7 yn is satisfied in:\n\u03c0x1y1\u00b7\u00b7\u00b7yn (sql1(z1)) Zy1=x2 sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn sqln(zn)) D\nProof. t1d 7\u2192 p P1 . . .Pn is satisfied in GO m (Definition 3) \u2200s \u2208 S 1td : \u2203 unique list \u3008o1, . . . , on\u3009 in G O such that {(s, P1, o1), . . . , (on\u22121 ,Pn, on)} \u2286 GO m \u2200s \u2208 S 1td : \u2200o1, . . . , on, o \u2032 1, . . . , o \u2032 n in G O : (s, o1) \u2208 PG O 1 \u2227 . . . \u2227 (on\u22121 , on) \u2208 P GO n \u2227 (s, o\u20321) \u2208 P GO 1 \u2227 . . . \u2227 (o \u2032 n\u22121, o \u2032 n) \u2208 P GO n \u21d2 o1 = o\u20321, . . . , on = o \u2032 n m (Mappings assumptions for Pi)\n\u2200u \u2208 \u03c0x1\u03c3notNull(x1) sql1(z1) D :\n\u2200v1, v\u20321 \u2208 \u03c0y1\u03c3notNull(y1) sql1(z1) D : . . . : \u2200vn, v\u2032n \u2208 \u03c0yn\u03c3notNull(yn )sqln(zn) D : (u, v1) \u2208 \u03c0x1y1\u03c3notNull(x1 ,y1) sql1(z1) D \u2227 . . . \u2227 (vn\u22121, vn) \u2208 \u03c0xnyn\u03c3notNull(xn ,yn ) sqln(zn) D \u2227 (u, v\u20321) \u2208 \u03c0x1y1\u03c3notNull(x1 ,y1) sql1(z1) D \u2227 . . . \u2227 (v\u2032n\u22121, v \u2032 n) \u2208 \u03c0xnyn\u03c3notNull(xn ,yn ) sqln(zn) D \u21d2 v1 = v\u20321, . . . , vn = v \u2032 n\nOBDA Constraints for Effective Query Answering (Extended Version) 23\nm (Standard Translation AND assumptions on templates)\n\u2200u \u2208 \u03c0x1\u03c3notNull(x1) sql1(z1) D :\n\u2200v1, v\u20321 \u2208 \u03c0y1\u03c3notNull(y1) sql1(z1) D : . . . : \u2200vn, v\u2032n \u2208 \u03c0yn\u03c3notNull(yn )sqln(zn) D :\n(u, v1, . . . , vn) \u2208 \u03c0x1y1 ...yn (\u03c3notNull(x1 ,y1) \u0302sql1(z1) Zy1=x2 \u03c3notNull(x2 ,y2) sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn \u03c3notNull(xn ,yn ) sqln(zn))\nD \u2227\n(u, v\u20321, . . . , v \u2032 n) \u2208 \u03c0x1y1 ...yn (\u03c3notNull(x1 ,y1) \u0302sql1(z1) Zy1=x2 \u03c3notNull(x2 ,y2) sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn \u03c3notNull(xn ,yn ) sqln(zn)) D \u21d2\nv1 = v\u20321, . . . , vn = v \u2032 n\nm (Definition of Functional Dependency) x1 \u2192 y1 . . . yn is satisfied in \u03c0x1y1 ...yn ( \u0302sql1(z1) Zy1=x2 sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn sqln(zn)) D\nExample 18. Consider the following set of T -mappings for an OBDA setting O:\nf(id,name) P1 g(friend)\u2190 SELECT id, name, friend FROM T g(friend) P2 h(friend age)\u2190 SELECT friend, friend age FROM T\nThen the lemma above suggests that the VFD f 7\u2192p P1P2 is satisfied in O if and only if the FD id name\u2192 friend friend age is satisfied in (T Z f riend= f riend T )D.\nDefinition 9 (Optimizing Path VFD). Let t be a template, and P1, . . . , Pn be properties in T . An optimizing path VFD is an expression of the form t p P1 \u00b7 \u00b7 \u00b7 Pn. An optimizing VFD t p P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O if t 7\u2192p P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O and\n\u03c0x1y1...yn sql1(z1) D \u2286 qDpath (3)\nwhere\nqpath = \u03c0x1y1...yn (sql1(z1) Zy1=x2 sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn sqln(zn)).\nLemma 4. Consider n properties P1, . . . , Pn in T with tri = tdi+1 , for each 1 \u2264 i < n, and for which t1d p P1 \u00b7 \u00b7 \u00b7 Pn is satisfied in O. Then\n\u03c0x1y1...yn sql1(z1) D = qDpath\nwhere qpath is the same as in the Definition 9.\nProof. (Sketch) The argument is similar to the one of the proof for Lemma 2, by using Lemma 3.\nDefinition 10 (Optimizable path BGP). A BGP \u03b2 is optimizable w.r.t. v = td p P1 . . . Pn if (i) v is satisfied in O; (ii) the BGP of triple patterns in \u03b2 involving properties is of the form ?v0 P1 ?v1. ...?vn\u22121 Pn ?vn.; and (iii) for every triple pattern of the form ?u rdf:type C in \u03b2, ?u is the subject of some Pi (i = 1 . . .n) and tid d Pi\nC is satisfied in O , or ?u is the object of some Pi (i = 1 . . .n) and tir r Pi C is satisfied in O.\n24 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2"}, {"heading": "Proofs for Main Results", "text": "Theorem 1. Let \u03b2 be an optimizable BGP w.r.t. td x P1 . . . Pn (x = b, p) in O. Let \u03c0v/t1d,v1/t 1 r ,...,vn/t n r sql\u03b2 be the SQL translation of \u03b2 as explained in Section 3. Let sql\u2032\u03b2 = sql1(x1, y1 . . . , yn). Then sql D \u03b2 and sql\u2032D \u03b2 return the same answers.\nProof. Assume that td p P1...Pn\n. The proof for branching functional dependencies is analogous.\nFrom the definition of \u03c4 for triple pattern and the definition of the \u03c4 for Z for BGPs it follows that the BGP \u03b2 will be translated as:\n(\u03c0v0,v1\u03c1v/subj \u03c1v1/obj \u03c3pred=P1 triple) Zv1=v2 ...\nZvn\u22122=vn\u22121 (\u03c0vn\u22121,vn\u03c1vn\u22121/subj \u03c1vn/obj\u03c3pred=Pn triple)\n(4)\nThe table triple is replaced by the definition of the triple patterns in the mappings as follows:\n(\u03c0v0,v1\u03c1v0/subj \u03c1v1/obj\u03c3pred=P1\u03c0pred/P1,subj/t1d ,obj/t1r (sql1(z1))) Zv1=v2 ...\nZvn\u22122=vn\u22121 (\u03c0vn\u22121,vn\u03c1vn\u22121/subj \u03c1vn/obj\u03c3pred=Pn\u03c0pred/Pn,subj/tnd ,obj/tnr )(sqln(zn))))\n(5)\nThis expression can be simplified to:\n(\u03c0v0,v1\u03c1v0/subj \u03c1v1/obj \u03c0subj/t1d ,obj/t1r (sql1(z1))) Zv1=v2 ...\nZvn\u22122=vn\u22121 (\u03c0vn\u22121,vn\u03c1vn\u22121/subj \u03c1vn/obj \u03c0subj/tnd ,obj/tnr )(sqln(zn))))\n(6)\nBy definition we know that the template in the range of Pi\u22121 coincide with the template in Pi. Thus, we can remove them from the join over ui\u2019s in (??) and make the join over the attributes xi, yi instead of the URIs. Therefore, \u03b2 can be rewritten to\n\u03c0v0/t1d ,v1/t 1 r ,...,vn/t n r (sql1(z1) Zy1=x2 sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn sqln(zn)) (7)\nSince \u03b2 is optimizable, we know that\n\u03c0x1y1...yn sql1(z1) = \u03c0x1y1...yn (sql1(z1) Zy1=x2 sql2(z2) Zy2=x3 \u00b7 \u00b7 \u00b7 Zyn\u22121=xn sqln(zn))\n(8)\nTherefore, we can simplify (7) to \u03c0v/t1d,v1/t1r ,...,vn/tnr (sql1(z1)). This proves the Theorem.\nOBDA Constraints for Effective Query Answering (Extended Version) 25"}, {"heading": "A.4 Lifting Basic OBDA Instance Assumption", "text": "We show that the \u201cbasic OBDA instance assumption\u201d in Section 4.2 is not a real restriction. A SPARQL query over a T -mapping with predicates of multiple templates can be rewritten to another SPARQL query over another T -mapping with predicates of only single template.\nAs usual, we assume an OBDA instance ((T ,M, \u03a3), D), and let MT be a T -mapping. Suppose a predicate A is defined by k mapping assertions using different template\nin MT : A(t1d(x), t 1 r (y)) \u2190 sql1(z)\n. . .\nA(tkd(x), t k r (y)) \u2190 sqlk(z)\nDefine MA T be the mapping obtained by replacing the assertions for the A with the following k mapping assertions defining k fresh predicates Ai (i = 1, . . . , k):\nA1(t 1 d(x), t 1 r k(y)) \u2190 sql1(z)\n. . .\nAk(tkd(x), t k r (y)) \u2190 sqlk(z)\nSuppose that Q is a SPARQL query using predicate A. The idea is to construct another SPARQL query Q\u2032 such that ~Q (MT ,D) = ~Q \u2032 (MA T ,D). The construction is performed on each triple pattern using A. Suppose B is a triple pattern occurring in Q; we take B+ to be the union of B[A 7\u2192 Ai], i = 1 . . . k\nwhere B[A 7\u2192 Ai] is a triple pattern obtained by replacing all the occurrences of A in B with Ai. Finally Q\u2032 is defined as the SPARQL query obtained by replacing all the triple patterns B with B+.\nLemma 5. ~B (MT ,D) = ~B + (MA\nT ,D)\nProof. We only prove the case where B is a single triple pattern of the form B = (?x, rdf:type, A), since the case where A is a property can be proved analogously. In this case,\nB+ = (?x, rdf:type, A1) Union . . .Union (?x, rdf:type, Ak)\nSuppose that {?x 7\u2192 a} is a solution mapping, i.e., A(a) is in the RDF graph exposed by MT and D. It follows that there is a mapping assertion A(t(x)) \u2190 sqli(z) \u2208 MT , such that a = t(x0) for some template t0 and tuple x0. Since Ai(t(x)) \u2190 sqli(z) \u2208 MAT , we have Ai(t(x0)) is in the RDF graph exposed by MAT and D. Then {x 7\u2192 a} is a solution mapping of (?x, rdf:type, Ai) and also of B+.\nThe other direction can be proved analogously.\nTheorem 4. ~Q (MT ,D) = ~Q \u2032 (MA\nT ,D)\nProof. The proof is a standard induction over the structure of the SPARQL queries. The base case of proof is the triple pattern case, and has been proved in Lemma 5. The inductive case can be proved easily.\nBy exhaustingly apply Theorem 4 to all predicates of different templates, one can lift the restriction of \u201cbasic OBDA instance\u201d.\n26 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2"}, {"heading": "A.5 Wisconsin Benchmark", "text": "We setup an environment based on the Wisconsin Benchmark [7]. This benchmark was designed for the systematic evaluation of database performance with respect to different query characteristics. The benchmark comes with a schema that is designed so one can quickly understand the structure of each table and the distribution of each attribute value. This allows easy construction of queries that isolate the features that need to be tested. The benchmark also comes with a data generator to populate the schema. Unlike EPDS, the benchmark database contains synthetic data that allows easily specifying a wide range of retrieval queries. For instance, in EPDS it is very difficult to specify a selection query with a 20% or 30% selectivity factor. This task becomes even harder when we include joins into the picture.\nThe benchmark defines a single table schema (which can be used to instantiate multiple tables). The table, which we now call \u201cWisconsin table\u201d, contains 16 attributes, and a primary key (unique2) with integers from 0 to 100 million randomly ordered.\nWe refer the reader to [7] for details on the algorithm that populates the schema.\nDataset We used Postgres 9.1, and DB2 9.7 as Ontop backends. The query optimizers were left with the default configurations. All the table statistics were updated.\nFor each DB engine we created a database, each with 10 tables: 5 Wisconsin tables (Tabi, i = 1, . . . , 5), and 5 tables materializing the join of the former tables. For instance, view123 materializes the join of the tables Tab1, Tab2, and Tab3. Each table contains 100 million rows, and each of the databases occupied ca. 400GB of disk space.\nHardware We ran the experiments in an HP Proliant server with 24 Intel Xeon CPUs (@3.47GHz), 106GB of RAM and five 1TB 15K RPM HD. Ontop was run with 6GB Java heap space. The OS is Ubuntu 12.04 LTS 64-bit edition.\nIn these experiments, we ran each query 3 times, and we averaged the execution times. There was a warm-up phase, where we ran 4 random queries not belonging to the tests.\nEvaluating the Impact of VFD-based Optimization The experiments in this section measure the impact of optimization based on VFDs. Optimizations based on branching VFDs and path VFDs produce the same effect in the resulting SQL query, therefore, for concreteness we focus on branching VFD. The performance gain for path VFD is similar.\nRecall that we started studying this scenario because EPDS contains thousands of views that lack primary/foreign keys, and some of them cannot be avoided in the mappings. This prevents OBDA semantic optimizations to take place.\nThe following experiments evaluate the trade-off of using views or their definitions depending on: (i) type of mappings (using views or view definitions); (ii) the complexity of the user query (# of SPARQL joins); (iii) the complexity of the mapping definition (# of SQL joins); (iv) the selectivity of the query; (v) the VFD optimization ON/OFF; (vi) the DB engine (DB2/PostgreSQL);\nIn the following we describe the queries, mappings and the OBDA specifications and instances used in the different experiments.\nOBDA Constraints for Effective Query Answering (Extended Version) 27\nQueries In this experiment we tested a set of 36 queries each varying on: (i) the number of SPARQL joins (1-3), (ii) SQL joins in the mappings (1-4), and (iii) selectivity of the query (3 different values). The SPARQL queries have the following shape:\nSELECT ?x ?y WHERE {\n?x a : Class \u2212 n \u2212 S QLs . ?x : Property1 \u2212 n \u2212 S QLs ?y1 . . . . ?x : Propertym \u2212 n \u2212 S QLs ?ym . Filter( ?ym < k% ) }\nwhere Class-n-SQLs and Propertyi-n-SQLs are classes and properties defined by mappings which source is either an SQL join of n = 1 . . .4 tables, or a materialized view of the join of n tables. Subindex m represents the number of SPARQL joins, 1 to 3. Regarding the selectivity of k%, we did the experiments with the following values: (i) 0.0001% (100 results); (ii) 0.01% (10.000 results); (iii) 0.1% (100.000 results). These queries do not belong to the Wisconsin benchmark.\nOBDA Specifications We have two OBDA settings, one where classes and properties are populated using an SQL that use original tables with primary keys (1-4 joins) (K1); and a second one where predicates are populated using materialized views (materializing 1-4 joins). This second setting we tested with VFD optimization (K2) and without optimization (K3). In the first OBDA setting, all the property subjects are mapped into the tables primary keys. There are no axioms in the ontology. All the individuals have the same template t.\nLet S t be the set of all individuals. In K2 there are 12 branching VFDs of the form S t 7\u2192b :Propertym-n-SQLs for every n = 1 . . . 4, m = 1 . . .3. The optimizable VFDs contain intuitively the properties populated from the same view, that is, S t 7\u2192b :Property1-n-SQLs, :Property2-n-SQLs, :Property3-n-SQLs for n = 1 . . .4.\nDiscussion and Results The results of the experiments are shown in Figure 2. Each qi/ j represents the query with i SPARQL joins over properties mapped to j SQL joins.\nThere is almost no difference between the results with different selectivity, so for clarity we averaged the run times over different selectivities. Since the experiment was run three times, each point in the figure represents the average of 9 query executions.\nThe experiment results in Figure 2 show that all the SPARQL queries perform better in K2 than in K3 in both DB engines. Moreover, in all cases queries in K2 perform at least twice as fast as the ones in K3, even getting close to the performance of K1.\nIn Ontop-Postgres, the execution of the hardest SPARQL queries in K1 is 1 order of magnitude faster than in K2. The execution of these queries in K2 is 4 times faster than in K3. In Ontop-DB2, the performance gap between the SPARQL queries in K3 and K2 is smaller. The SPARQL queries in K1 are slightly faster than the queries in K2. The execution in K2 is 2 times faster than in K3.\nIn Ontop-Postgres and Ontop-DB2, the translations of the SPARQL queries resulting from the K3 scenario contain self-joins of the non-indexed views that force the DB engines to create hash tables for all intermediate join results which increases the start-up cost of the joins, and the overall execution time. One can observe that in both, Ontop-Postgres and Ontop-DB2, the number of SPARQL joins strongly affect the performance of the query in K3. In both cases, the SPARQL queries in K2, because of our\n28 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2\noptimization technique, get translated into a join-free SQL query that requires a single sequential scan of the unindexed view. However, the cost of scanning the whole view to perform a non-indexed filter is still higher than the cost of joins (nested joins in both) of the indexed tables in K1.\nEvaluating the Impact of Exact Mappings In this test we evaluate the exact mapping optimization technique described in Section 4.1. This experiment is inspired by the use case in EPDS where optimization based on exact mapping can help. The following experiments evaluate the impact of the optimization depending on: (i) the complexity of the query (# of SPARQL joins); (ii) the selectivity of the query; (iii) the number of specified exact classes; (iv) the DB engine (DB2/PostgreSQL).\nIn the following we describe the tables, ontology, mappings, queries and exact predicate specifications used in the experiment.\nOBDA Specifications The ontology contains four classes A1, A2, A3, A4, one object property R and one data property S . The classes form a hierarchy\nA1 rdfs:subClassOf A2, A2 rdfs:subClassOf A3, A3 rdfs:subClassOf A4.\nThe mappings for classes Ai (i = 1, . . . , 4) are defined over the primary key of Tabi with different filters, in such a way that each Ai is exact. The mappings for R and S are defined over the primary key column and another unique column (unique1) of Tab5.\nQueries In this experiment we tested 6 queries (q1, . . . , q6) varying on: (i) the number of classes and properties in the SPARQL (1-3) and (ii) the classes used in the query. For instance, q3 is\nOBDA Constraints for Effective Query Answering (Extended Version) 29\nSELECT * WHERE {?x a :A3. ?x :R y. ?y a :A4.\nOPTIONAL { ?x :S ?u . } OPTIONAL { ?y :S ?v . }. }\nExact Concepts We consider the following four exact concept specifications: E0 = \u2205, E1 = {A1, A2}, E2 = {A1, A2, A3}, E3 = {A1, A2, A3, A4}. Observe that E0 corresponds to the case where no exact mapping optimization is applied.\nDiscussion and Results The results of the experiments are shown in Figure 3. The results show that the exact mapping optimization improves the performance of all SPARQL queries in both database engines. In particular, under the full optimization setting E3, none of the queries time out (20 mins), and the hardest queries perform orders of magnitude faster than in E0 and even E1.\nThe performance gain is the result of the elimination of redundant unions. For instance, under E0, SPARQL query q3 is translated into a SQL query with 12 unions, but 11 of them are redundant; applying E3 removes all the redundant unions.\n30 Dag Hovland1, Davide Lanti2, Martin Rezk2, and Guohui Xiao2"}, {"heading": "A.6 Experiments Material and Tools", "text": "All the material related to the Wisconsin experiment, as well as the tools used to find exact mappings and virtual functional dependencies, can be found on\nhttps://github.com/ontop/ontop-examples/tree/master/ruleml-2016."}], "references": [{"title": "editors", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "The Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press, 2nd edition,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "The implication problem for data dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "In Proc. of ICALP, volume 115 of LNCS, pages 73\u201385. Springer,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1981}, {"title": "Tractable queries for lightweight description logics", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus", "G. Xiao"], "venue": "In Proc. of IJCAI. IJCAI/AAAI,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "JAR, 39(3):385\u2013429,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "Semantic query optimization in expert systems and database systems", "author": ["U.S. Chakravarthy", "D.H. Fishman", "J. Minker"], "venue": "In Proc. of DEXA, pages 659\u2013674,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1986}, {"title": "R2RML: RDB to RDF mapping language", "author": ["S. Das", "S. Sundara", "R. Cyganiak"], "venue": "W3C Recommendation, W3C, Sept.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "The wisconsin benchmark: Past, present, and future", "author": ["D.J. DeWitt"], "venue": "In J. Gray, editor, The Benchmark Handbook. Morgan Kaufmann,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1993}, {"title": "Optimizing query rewriting in ontology-based data access", "author": ["F. Di Pinto", "D. Lembo", "M. Lenzerini", "R. Mancini", "A. Poggi", "R. Rosati", "M. Ruzzi", "D.F. Savo"], "venue": "In Proc. of EDBT, pages 561\u2013572. ACM Press,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "and C", "author": ["B. Glim"], "venue": "Ogbuji. SPARQL 1.1 entailment regimes. W3C Recommendation, W3C, Mar.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "The price of query rewriting in ontology-based data access", "author": ["G. Gottlob", "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "T. Schwentick", "M. Zakharyaschev"], "venue": "AIJ, 213:42\u201359,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Using conditional functional dependency to discover abnormal data in RDF graphs", "author": ["B. He", "L. Zou", "D. Zhao"], "venue": "In Proc. of SWIM, pages 43:1\u201343:7. ACM,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "OBDA constraints for effective query answering (extended version)", "author": ["D. Hovland", "D. Lanti", "M. Rezk", "G. Xiao"], "venue": "CoRR Technical Report abs/1605.04263, arXiv.org e-Print archive,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2016}, {"title": "Exponential lower bounds and separation for query rewriting", "author": ["S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev"], "venue": "In Proc. of ICALP, pages 263\u2013274. Springer,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Conjunctive query answering with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of KR, pages 275\u2013285,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Answering SPARQL queries over databases under OWL 2 QL entailment regime", "author": ["R. Kontchakov", "M. Rezk", "M. Rodriguez-Muro", "G. Xiao", "M. Zakharyaschev"], "venue": "In Proc. of ISWC, volume 8796 of LNCS, pages 552\u2013567. Springer,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "The NPD benchmark: Reality check for OBDA systems", "author": ["D. Lanti", "M. Rezk", "G. Xiao", "D. Calvanese"], "venue": "In Proc. of EDBT,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "kyrie2: Query rewriting under extensional constraints in elhio", "author": ["J. Mora", "R. Rosati", "O. Corcho"], "venue": "In Proc. of ISWC, pages 568\u2013583,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. on Data Semantics, X:133\u2013173,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Ontology-based data access: Ontop of databases", "author": ["M. Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of ISWC, volume 8218 of LNCS, pages 558\u2013573. Springer,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2013}, {"title": "Efficient SPARQL-to-SQL with R2RML mappings", "author": ["M. Rodriguez-Muro", "M. Rezk"], "venue": "J. of Web Semantics,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Prexto: Query rewriting under extensional constraints in DL-Lite", "author": ["R. Rosati"], "venue": "In Proc. of ESWC, pages 360\u2013374,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2012}, {"title": "Improving query answering over DL-Lite ontologies", "author": ["R. Rosati", "A. Almatelli"], "venue": "In Proc. of KR, pages 290\u2013300,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2010}, {"title": "Reasoning about functional dependencies generalized for semantic data models", "author": ["G.E. Weddell"], "venue": "ACM Trans. Database Syst., 17(1):32\u201364, Mar.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1992}, {"title": "Extending functional dependency to detect abnormal data in RDF graphs", "author": ["Y. Yu", "J. Heflin"], "venue": "In Proc. of ISWC, volume 7031, pages 794\u2013809. Springer, October", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 17, "context": "1 Introduction In Ontology Based Data Access (OBDA) [18], the complexity of data storage is hidden by a conceptual layer on top of an existing relational database (DB).", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "A wellknown theoretical result is that the size of the translation is worst-case exponential in the size of the input query [13].", "startOffset": 124, "endOffset": 128}, {"referenceID": 15, "context": "These worst-case scenarios are not only theoretical, but they also occur in real-world applications, as shown in [16], where some user SPARQL queries are translated into SQL queries containing thousands of join and union operators.", "startOffset": 113, "endOffset": 117}, {"referenceID": 18, "context": "This is mainly due to (i) SPARQL queries containing joins of ontological terms with rich hierarchies, which lead to redundant unions [19]; and (ii) reifications of n-ary relations in the database into triples over the RDF data model, which lead to SQL translations containing several (mostly redundant) self-joins.", "startOffset": 133, "endOffset": 137}, {"referenceID": 18, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 97, "endOffset": 104}, {"referenceID": 19, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 97, "endOffset": 104}, {"referenceID": 4, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 139, "endOffset": 142}, {"referenceID": 3, "context": "To simplify the notation we express OWL 2 QL axioms by their description logic counterpart DLLiteR [4].", "startOffset": 99, "endOffset": 102}, {"referenceID": 0, "context": "Semantics for entailment of assertions (|=) in OWL 2 QL KBs is given through Tarski-style interpretations in the usual way [1].", "startOffset": 123, "endOffset": 126}, {"referenceID": 3, "context": "The task of query answering in OWL 2 QL (DL-LiteR) can be addressed by query rewriting techniques [4].", "startOffset": 98, "endOffset": 101}, {"referenceID": 13, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 21, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 2, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 8, "context": "SPARQL [9] is a W3C standard language designed to query RDF graphs.", "startOffset": 7, "endOffset": 10}, {"referenceID": 14, "context": "To ease the presentation of the technical development, in the rest of this paper we adopt the OWL 2 QL entailment regime for SPARQL query answering [15], but disallow complex class/property expressions in the query.", "startOffset": 148, "endOffset": 152}, {"referenceID": 14, "context": "This restriction can be lifted with the help of a standard query rewriting step [15].", "startOffset": 80, "endOffset": 84}, {"referenceID": 18, "context": "During its start-up, Ontop classifies the ontology, \u201ccompiles\u201d the ontology into the mappings generating the so-called T -mappings [19], and removes redundant mappings by using inclusion dependencies (e.", "startOffset": 131, "endOffset": 135}, {"referenceID": 9, "context": "[10]), and phases (d) and (e) because they are straightforward.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "As a result, the unfolded SQL queries cannot be efficiently handled by DB engines [16].", "startOffset": 82, "endOffset": 86}, {"referenceID": 22, "context": "The next example shows, similarly as in [23], that general path VFDs cannot be expressed as a combination of path VFDs of length 1.", "startOffset": 40, "endOffset": 44}, {"referenceID": 5, "context": "We also assume that queries sqli(zi) always contain a filter expression of the form \u03c3notNull(xi ,yi), even if we do not specify it explicitly in the examples, since URIs cannot be generated from nulls [6].", "startOffset": 201, "endOffset": 204}, {"referenceID": 6, "context": "In the appendix we ran additional controlled experiments using an OBDA benchmark built on top of the Wisconsin benchmark [7], and obtain similar results to the ones here.", "startOffset": 121, "endOffset": 124}, {"referenceID": 12, "context": "This situation triggered the introduction of OBDA in Statoil in the context of the Optique project [13].", "startOffset": 99, "endOffset": 103}, {"referenceID": 1, "context": "6 Related work Dependencies have been intensively studied in the context of traditional relational databases [2].", "startOffset": 109, "endOffset": 112}, {"referenceID": 22, "context": "Our work is related to the one in [23]; in particular their notion of path functional dependency is close to the notion of path VFD presented here.", "startOffset": 34, "endOffset": 38}, {"referenceID": 23, "context": "There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF do not necessarily correspond to a VFD (when considering the ontology).", "startOffset": 64, "endOffset": 71}, {"referenceID": 10, "context": "There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF do not necessarily correspond to a VFD (when considering the ontology).", "startOffset": 64, "endOffset": 71}, {"referenceID": 7, "context": "The notion of perfect mapping [8] is strongly related to the notion of exact mapping.", "startOffset": 30, "endOffset": 33}, {"referenceID": 20, "context": "The notion of EBox [21,17] was proposed as an attempt to include constraints in OBDA.", "startOffset": 19, "endOffset": 26}, {"referenceID": 16, "context": "The notion of EBox [21,17] was proposed as an attempt to include constraints in OBDA.", "startOffset": 19, "endOffset": 26}], "year": 2016, "abstractText": "In Ontology Based Data Access (OBDA) users pose SPARQL queries over an ontology that lies on top of relational datasources. These queries are translated on-the-fly into SQL queries by OBDA systems. Standard SPARQL-to-SQL translation techniques in OBDA often produce SQL queries containing redundant joins and unions, even after a number of semantic and structural optimizations. These redundancies are detrimental to the performance of query answering, especially in complex industrial OBDA scenarios with large enterprise databases. To address this issue, we introduce two novel notions of OBDA constraints and show how to exploit them for efficient query answering. We conduct an extensive set of experiments on large datasets using real world data and queries, showing that these techniques strongly improve the performance of query answering up to orders of magnitude.", "creator": "LaTeX with hyperref package"}}}