{"id": "1605.06465", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2016", "title": "Swapout: Learning an ensemble of deep architectures", "abstract": "We describe Swapout, a new stochastic training method, that outperforms ResNets of identical network structure yielding impressive results on CIFAR-10 and CIFAR-100. Swapout samples from a rich set of architectures including dropout, stochastic depth and residual architectures as special cases. When viewed as a regularization method swapout not only inhibits co-adaptation of units in a layer, similar to dropout, but also across network layers. This is an exciting step forward in enabling new models of network structure that are particularly robust on CIFAR-100 and CIFAR-100.\n\n\n\n\nThe full version of this article is available as a PDF\n\nAcknowledgements\nThe following are an initial drafts of this paper and are not necessarily part of the paper's original proposal.\nReferences\n\nBureau of Research; CIFAR, 2009.\nSiemens, M. and D. D. F. T. , N.C. and J.G. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S. P. , \"A key study finding of a scalable network structure and structure by Rene G. G\u00fcnzer, E. W. and F. S", "histories": [["v1", "Fri, 20 May 2016 18:39:33 GMT  (206kb,D)", "http://arxiv.org/abs/1605.06465v1", "Submitted to NIPS 2016"]], "COMMENTS": "Submitted to NIPS 2016", "reviews": [], "SUBJECTS": "cs.CV cs.LG cs.NE", "authors": ["saurabh singh", "derek hoiem", "david a forsyth"], "accepted": true, "id": "1605.06465"}, "pdf": {"name": "1605.06465.pdf", "metadata": {"source": "CRF", "title": "Swapout: Learning an ensemble of deep architectures", "authors": ["Saurabh Singh", "Derek Hoiem", "David Forsyth"], "emails": ["daf}@illinois.edu"], "sections": [{"heading": "1 Introduction", "text": "This paper describes swapout, a stochastic training method for general deep networks. Swapout is a generalization of dropout [17] and stochastic depth [6] methods. Dropout zeros the output of individual units at random during training, while stochastic depth skips entire layers at random during training. In comparison, the most general swapout network produces the value of each output unit independently by reporting the sum of a randomly selected subset of current and all previous layer outputs for that unit. As a result, while some units in a layer may act like normal feedforward units, others may produce skip connections and yet others may produce a sum of several earlier outputs. In effect, our method averages over a very large set of architectures that includes all architectures used by dropout and all used by stochastic depth.\nOur experimental work focuses on a version of swapout which is a natural generalization of the residual network [4, 5]. We show that this results in improvements in accuracy over residual networks with the same number of layers.\nImprovements in accuracy are often sought by increasing the depth, leading to serious practical difficulties. The number of parameters rises sharply, although recent works such as [16, 19] have addressed this by reducing the filter size [16, 19]. Another issue resulting from increased depth is the difficulty of training longer chains of dependent variables. Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10]. At the time of writing, the deepest networks that have been successfully trained are residual networks (1001 layers [5]). We show that increasing the depth of our swapout networks increases their accuracy.\nThere is compelling experimental evidence that these very large depths are helpful, though this may be because architectural innovations introduced to make networks trainable reduce the capacity of the layers. The theoretical evidence that a depth of 1000 is required for practical problems is thin.\nar X\niv :1\n60 5.\n06 46\n5v 1\n[ cs\n.C V\n] 2\n0 M\nay 2\nBengio and Dellaleau argue that circuit efficiency constraints suggest increasing depth is important, because there are functions that require exponentially large shallow networks to compute [1]. Less experimental interest has been displayed in the width of the networks (the number of filters in a convolutional layer). We show that increasing the width of our swapout networks leads to significant improvements in their accuracy; an appropriately wide swapout network is competitive with a deep residual network that is 1.5 orders of magnitude deeper and has more parameters.\nContributions: Swapout is a novel stochastic training scheme that can sample from a rich set of architectures including dropout, stochastic depth and residual architectures as special cases. Swapout improves the performance of the residual networks for a model of the same depth. Wider but much shallower swapout networks are competitive with very deep residual networks."}, {"heading": "2 Related Work", "text": "Convolutional neural networks have a long history (see the introduction of [9]). They are now intensively studied as a result of recent successes (e.g. [8]). Increasing the number of layers in a network improves performance [16, 19] if the network can be trained. A variety of significant architectural innovations improve trainability, including: the ReLU [12, 2]; batch normalization [7]; and allowing signals to skip layers.\nOur method exploits this skipping process. Highway networks use gated skip connections to allow information and gradients to pass unimpeded across several layers [18]. Residual networks use identity skip connections to further improve training [4]; extremely deep residual networks can be trained, and perform well [5]. In contrast to these architectures, our method skips at the unit level (below), and does so randomly.\nOur method employs randomness at training time. For a review of the history of random methods, see the introduction of [14], which shows that entirely randomly chosen features can produce an SVM that generalizes well. Randomly dropping out unit values (dropout [17]) discourages coadaptation between units. Randomly skipping layers (stochastic depth) [6] during training reliably leads to improvements at test time, likely because doing so regularizes the network. The precise details of the regularization remain uncertain, but it appears that stochastic depth represents a form of tying between layers; when a layer is dropped, other layers are encouraged to be able to replace it. Each method can be seen as training a network that averages over a family of architectures during inference. Dropout averages over architectures with \u201cmissing\u201d units and stochastic depth averages over architectures with \u201cmissing\u201d layers. Other successful recent randomized methods include dropconnect [20] which generalizes dropout by dropping individual connections instead of units (so dropping several connections together), and stochastic pooling [21] (which regularizes by replacing the deterministic pooling by randomized pooling). In contrast, our method skips layers randomly at a unit level enjoying the benefits of each method.\nRecent results show that (a) stochastic gradient descent with sufficiently few steps is stable (in the sense that changes to training data do not unreasonably disrupt predictions) and (b) dropout enhances that property, by reducing the value of a Lipschitz constant ([3], Lemma 4.4). We show our method enjoys the same behavior as dropout in this framework.\nLike dropout, the network trained with swapout depends on random variables. A reasonable strategy at test time with such a network is to evaluate multiple instances (with different samples used for the random variables) and average. Reliable improvements in accuracy are achievable by training distinct models (which have distinct sets of parameters), then averaging predictions [19], thereby forming an explicit ensemble. In contrast, each of the instances of our network in an average would draw from the same set of parameters (we call this an implicit ensemble). Srivastava et al. argue that, at test time, random values in a dropout network should be replaced with expectations, rather than taking an average over multiple instances [17] (though they use explicit ensembles, increasing the computational cost). Considerations include runtime at test; the number of samples required; variance; and experimental accuracy results. For our model, accurate values of these expectations are not available. In Section 4, we show that (a) swapout networks that use estimates of these expectations outperform strong comparable baselines and (b) in turn, these are outperformed by swapout networks that use an implicit ensemble."}, {"heading": "3 Swapout", "text": "Notation and terminology: We use capital letters to represent tensors and to represent elementwise product (broadcasted for scalars). We use boldface 0 and 1 to represent tensors of 0 and 1 respectively. A network block is a set of simple layers in some specific configuration e.g. a convolution followed by a ReLU or a residual network block [4]. Several such potentially different blocks can be connected in the form of a directed acyclic graph to form the full network model.\nDropout kills individual units randomly; stochastic depth skips entire blocks of units randomly. Swapout allows individual units to be dropped, or to skip blocks randomly. Implementing swapout is a straightforward generalization of dropout. Let X be the input to some network block that computes F (X). The u\u2019th unit produces F (u)(X) as output. Let \u0398 be a tensor of i.i.d. Bernoulli random variables. Dropout computes the output Y of that block as\nY = \u0398 F (X). (1)\nIt is natural to think of dropout as randomly selecting an output from the set F (u) = {0, F (u)(X)} for the u\u2019th unit.\nSwapout generalizes dropout by expanding the choice ofF (u). Now write {\u0398i} forN distinct tensors of iid Bernoulli random variables indexed by i and with corresponding parameters {\u03b8i}. Let {Fi} be corresponding tensors consisting of values already computed somewhere in the network. Note that one of these Fi can be X itself (identity). However, Fi are not restricted to being a function of X and we drop the X to indicate this. Most natural choices for Fi are the outputs of earlier layers. Swapout computes the output of the layer in question by computing\nY = N\u2211 i=1 \u0398i Fi (2)\nand so, for unit u, we have F (u) = {F (u)1 , F (u) 2 , . . . , F (u) 1 + F (u) 2 , . . . , \u2211 i F (u) i }. We study the simplest case where\nY = \u03981 X + \u03982 F (X) (3)\nso that, for unit u, we have F (u) = {0, X(u), F (u)(X), X(u) + F (u)(X)}. Thus, each unit in the layer could be:\n1) dropped (choose 0); 2) a feedforward unit (choose F (u)(X));\n3) skipped (choose X(u));\n4) or a residual network unit (choose X(u) + F (u)(X)).\nSince a swapout network can clearly imitate a residual network, and since residual networks are currently the best-performing networks on various standard benchmarks, we perform exhaustive experimental comparisons with them.\nIf one accepts the view of dropout and stochastic depth as averaging over a set of architectures, then swapout extends the set of architectures used. Appropriate random choices of \u03981 and \u03982 yield: all architectures covered by dropout; all architectures covered by stochastic depth; and block level skip connections. But other choices yield unit level skip and residual connections.\nSwapout retains important properties of dropout. Swapout discourages co-adaptation by dropping units, but also by on occasion presenting units with inputs that have come from earlier layers. Dropout has been shown to enhance the stability of stochastic gradient descent ([3], lemma 4.4). This applies to swapout in its most general form, too. We extend the notation of that paper, and write L for a Lipschitz constant that applies to the network, \u2207f(v) for the gradient of the network f with parameters v, and D\u2207f(v) for the gradient of the dropped out version of the network. The crucial point in the relevant enabling lemma is that E[||Df(v) ||] < E[||\u2207f(v) ||] \u2264 L (the inequality implies improvements). Now write\u2207S [f ] (v) for the gradient of a swapout network, and \u2207G [f ] (v) for the gradient of the swapout network which achieves the largest Lipschitz constant by choice of \u0398i (this exists, because \u0398i is discrete). First, a Lipschitz constant applies to this network; second, E[||\u2207S [f ] (v) ||] \u2264 E[||\u2207G [f ] (v) ||] \u2264 L, so swapout makes stability no worse; third, we speculate light conditions on f should provide E[||\u2207S [f ] (v) ||] < E[||\u2207G [f ] (v) ||] \u2264 L, improving stability ([3] Section 4)."}, {"heading": "3.1 Inference in Stochastic Networks", "text": "A model trained with swapout represents an entire family of networks with tied parameters, where members of the family were sampled randomly during training. There are two options for inference. We could either replace random variables with their expected values, as recommended by Srivastava et al. [17] (deterministic inference). Alternatively, we could sample several members of the family at random, and average their predictions (stochastic inference).\nThere is an important difference between swapout and dropout. In a dropout network, one can estimate expectations exactly (as long as the network isn\u2019t trained with batch normalization, below). This is because E[ReLU[\u0398 F (X)]] = ReLU[E[\u0398 F (X)]] (recall \u0398 is a tensor of Bernoulli random variables, and thus non-negative).\nIn a swapout network, one usually can not estimate expectations exactly. The problem is that E[ReLU[(\u03981X + \u03982Y )]] is not the same as ReLU[E[(\u03981X + \u03982Y )]] in general. Estimates of expectations that ignore this are successful, as the experiments show, but stochastic inference gives significantly better results.\nSrivastava et al. argue that deterministic inference is significantly less expensive in computation. We believe that Srivastava et al. may have overestimated how many samples are required for an accurate average, because they use distinct dropout networks in the average (Figure 11 in [17]). Our experience of stochastic inference with swapout has been positive, with the number of samples needed for good behavior small (Figure 2). Furthermore, computational costs of inference are smaller when each instance of the network uses the same parameters\nA technically more delicate point is that both dropout and swapout networks interact poorly with batch normalization if one uses deterministic inference. The problem is that the estimates collected by batch normalization during training may not reflect test time statistics. To see this consider two random variables X and Y and let \u03981,\u03982 \u223c Bernoulli(\u03b8). While E[\u03981X + \u03982Y ] = E[\u03b8X + \u03b8Y ] = \u03b8X + \u03b8Y , it can be shown that Var[\u03981X + \u03982Y ] \u2265 Var[\u03b8X + \u03b8Y ] with equality holding only for \u03b8 = 0 and \u03b8 = 1. Thus, the variance estimates collected by Batch Normalization during training do not represent the statistics observed during testing if the expected values of \u03981 and \u03982 are used in a deterministic inference scheme. These errors in scale estimation accumulate as more and more layers are stacked. This may explain why [6] reports that dropout doesn\u2019t lead to any improvement when used in residual networks with batch normalization."}, {"heading": "3.2 Baseline comparison methods", "text": "ResNets: We compare with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2).\nDropout: We use standard dropout (replace equation 3 with equation 1).\nLayer Dropout: We replace equation 3 by Y = X + \u0398(1\u00d71)F (X). Here \u0398(1\u00d71) is a single Bernoulli random variable shared across all units.\nSkipForward: Equation 3 introduces two stochastic parameters \u03981 and \u03982. We also explore and compare with a simpler architecture, SkipForward, that introduces only one parameter but samples from a smaller set F (u) = {X(u), F (u)(X)} as below.\nY = \u0398 X + (1\u2212\u0398) F (X) (4)"}, {"heading": "4 Experiments", "text": "We experiment extensively on the CIFAR-10 dataset and demonstrate that a model trained with swapout outperforms a comparable ResNet model. Further, a 32 layer wider model matches the performance of a 1001 layer ResNet on both CIFAR-10 and CIFAR-100 datasets.\nModel: We experiment with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2). However, our implementation (referred to as ResNet Ours) has the following modifications which improve the performance of the original model (Table 1). Between blocks of different feature sizes we subsample using average pooling instead of strided convolutions and use projection shortcuts with learned parameters. For final prediction we follow a scheme similar to Network in Network [11]. We replace average pooling and fully connected layer by a 1x1 convolution layer followed by global average pooling to predict the logits that are fed into the softmax.\nLayers in ResNets are arranged in three groups with all convolutional layers in a group containing equal number of filters. We represent the number of filters in each group as a tuple with the smallest size as (16, 32, 64) (as used in [4]for CIFAR-10). We refer to this as width and experiment with various multiples of this base size represented as W \u00d7 1, W \u00d7 2 etc.\nTraining: We train using SGD with a batch size of 128, momentum of 0.9 and weight decay of 0.0001. Unless otherwise specified, we train all the models for a total 256 epochs. Starting from an initial learning rate of 0.1, we drop it by a factor of 10 after 196 epochs and then again after 224 epochs. We do the standard augmentation of left-right flips and random translations of up to four pixels. For translation, we pad the images by 4 pixels on all the sides and sample a random 32x32 crop. All the images in a mini-batch use the same crop. Note that dropout slows convergence ([17], A.4), and swapout should do so too for similar reasons. Thus using the same training schedule for all the methods should disadvantage swapout.\nModels trained with Swapout consistently outperform baselines: Table 1 compares Swapout with various 20 layer baselines. Models trained with Swapout consistently outperform all other models of similar architecture.\nThe stochastic training schedule matters: Different layers in a swapout network could be trained with different parameters of their Bernoulli distributions (the stochastic training schedule). Table 2 shows that different stochastic training schedules have a significant affect on the performance. We report the performance with deterministic as well as stochastic inference. These schedules differ in how the values of parameters \u03b81 and \u03b82 of the Bernoulli random variables in equation 3 are set for the different layers. Note that \u03b81 = \u03b82 = 0.5 corresponds to the maximum stochasticity. A schedule with less randomness in the early layers (bottom row) performs the best. This is expected because Swapout adds per unit noise and early layers have the largest number of units. Thus, low stochasticity in early layers significantly reduces the randomness in the system. We use this schedule for all the experiments unless otherwise stated.\nSwapout improves over ResNet architecture: From Table 3 it is evident that networks trained with Swapout consistently show better performance than corresponding ResNets, for most choices of width investigated, using just the deterministic inference. This difference indicates that the performance improvement is not just an ensemble effect.\nStochastic inference outperforms deterministic inference: Table 3 shows that the stochastic inference scheme outperforms the deterministic scheme in all the experiments. Prediction for each image is done by averaging the results of 30 stochastic forward passes. This difference is not just due to the widely reported effect that an ensemble of networks is better as networks in our ensemble share parameters. Instead, stochastic inference produces more accurate expectations and interacts better with batch normalization.\nStochastic inference needs few samples for a good estimate: Figure 2 shows the estimated accuracies as a function of the number of forward passes per image. It is evident that relatively few samples are enough for a good estimate of the mean. Compare Figure-11 of [17], which implies \u223c 50 samples are required.\nIncrease in width leads to considerable performance improvements: The number of filters in a convolutional layer is its width. Table 3 shows that the performance of a 20 layer model improves considerably as the width is increased both for the baseline ResNet v2 architecture as well as\nthe models trained with Swapout. Swapout is better able to use the available capacity than the corresponding ResNet with similar architecture and number of parameters. Table 4 compares models trained with Swapout with other approaches on CIFAR-10 while Table 5 compares on CIFAR-100. On both datasets our shallower but wider model compares well with 1001 layer ResNet model.\nSwapout uses parameters efficiently: Persistently over tables 1, 3, and 4, Swapout models with fewer parameters outperform other comparable models. For example, Swapout v2(32) W \u00d7 4 gets 4.76% error with 7.43M parameters in comparison to the ResNet version at 4.91% with 10.2M parameters.\nExperiments on CIFAR-100 confirm our results: Table 5 shows that Swapout is very effective as it improves the performance of a 20 layer model (ResNet Ours) by more than 2%. Widening the network and reducing the stochasticity leads to further improvements. Further, a wider but relatively shallow model trained with Swapout (22.72%; 7.46M params) is competitive with the best performing, very deep (1001 layer) latest ResNet model (22.71%;10.2M params)."}, {"heading": "5 Discussion and future work", "text": "Swapout is a stochastic training method that shows reliable improvements in performance and leads to networks that use parameters efficiently. Relatively shallow swapout networks give comparable performance to extremely deep residual networks.\nWe have shown that different stochastic training schedules produce different behaviors, but have not searched for the best schedule in any systematic way. It may be possible to obtain improvements by doing so. We have described an extremely general swapout mechanism. It is straightforward using equation 2 to apply swapout to inception networks [19] (by using several different functions of the input and a sufficiently general form of convolution); to recurrent convolutional networks [13] (by\nchoosing Fi to have the form F \u25e6 F \u25e6 F . . .); and to gated networks. All our experiments focus on comparisons to residual networks because these are the current top performers on CIFAR-10 and CIFAR-100. It would be interesting to experiment with other versions of the method.\nAs with dropout and batch normalization, it is difficult to give a crisp explanation of why swapout works. We believe that our results support the idea that swapout causes some form of improvement in the optimization process. This is because relatively shallow networks with swapout reliably work as well as or better than quite deep alternatives; and because swapout is notably and reliably more efficient in its use of parameters than comparable deeper networks. Unlike dropout, swapout will often propagate gradients while still forcing units not to co-adapt. Furthermore, our swapout networks involve some form of tying between layers. When a unit sometimes sees layer i and sometimes layer i\u2212 j, the gradient signal will be exploited to encourage the two layers to behave similarly. The reason swapout is successful likely involves both of these points.\nAcknowledgments: This work is supported in part by ONR MURI Awards N00014-10-1-0934 and N00014-16-1-2007. We would like to thank NVIDIA for donating some of the GPUs used in this work."}], "references": [{"title": "On the expressive power of deep architectures", "author": ["Y. Bengio", "O. Delalleau"], "venue": "Proceedings of the 22nd International Conference on Algorithmic Learning Theory,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "Deep sparse rectifier neural networks", "author": ["X. Glorot", "A. Bordes", "Y. Bengio"], "venue": "AISTATS,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Train faster, generalize better: Stability of stochastic gradient descent", "author": ["M. Hardt", "B. Recht", "Y. Singer"], "venue": "CoRR, abs/1509.01240,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Deep residual learning for image recognition", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": "CoRR, abs/1512.03385,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Identity mappings in deep residual networks", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": "CoRR, abs/1603.05027,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2016}, {"title": "Deep networks with stochastic depth", "author": ["G. Huang", "Y. Sun", "Z. Liu", "D. Sedra", "K.Q. Weinberger"], "venue": "CoRR, abs/1603.09382,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2016}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["S. Ioffe", "C. Szegedy"], "venue": "CoRR, abs/1502.03167,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2015}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "NIPS,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Gradient-based learning applied to document recognition", "author": ["Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner"], "venue": "Proceedings of the IEEE,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1998}, {"title": "Deeply-supervised nets", "author": ["C.-Y. Lee", "S. Xie", "P. Gallagher", "Z. Zhang", "Z. Tu"], "venue": "AISTATS,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2015}, {"title": "Network in network", "author": ["M. Lin", "Q. Chen", "S. Yan"], "venue": "CoRR, abs/1312.4400,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["V. Nair", "G.E. Hinton"], "venue": "ICML,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Recurrent convolutional neural networks for scene parsing", "author": ["P.H. Pinheiro", "R. Collobert"], "venue": "arXiv preprint arXiv:1306.2795,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2013}, {"title": "Random features for large-scale kernel machines", "author": ["A. Rahimi", "B. Recht"], "venue": "NIPS,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Fitnets: Hints for thin deep nets", "author": ["A. Romero", "N. Ballas", "S.E. Kahou", "A. Chassang", "C. Gatta", "Y. Bengio"], "venue": "ICLR,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["K. Simonyan", "A. Zisserman"], "venue": "CoRR, abs/1409.1556,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2014}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["N. Srivastava", "G. Hinton", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Training very deep networks", "author": ["R.K. Srivastava", "K. Greff", "J. Schmidhuber"], "venue": "NIPS,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2015}, {"title": "Going deeper with convolutions", "author": ["C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S.E. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich"], "venue": "CoRR, abs/1409.4842,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "Regularization of neural networks using dropconnect", "author": ["L. Wan", "M. Zeiler", "S. Zhang", "Y.L. Cun", "R. Fergus"], "venue": "ICML, pages 1058\u20131066,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "Stochastic pooling for regularization of deep convolutional neural networks", "author": ["M.D. Zeiler", "R. Fergus"], "venue": "arXiv preprint arXiv:1301.3557,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2013}], "referenceMentions": [{"referenceID": 16, "context": "Swapout samples from a rich set of architectures including dropout [17], stochastic depth [6] and residual architectures [4, 5] as special cases.", "startOffset": 67, "endOffset": 71}, {"referenceID": 5, "context": "Swapout samples from a rich set of architectures including dropout [17], stochastic depth [6] and residual architectures [4, 5] as special cases.", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "Swapout samples from a rich set of architectures including dropout [17], stochastic depth [6] and residual architectures [4, 5] as special cases.", "startOffset": 121, "endOffset": 127}, {"referenceID": 4, "context": "Swapout samples from a rich set of architectures including dropout [17], stochastic depth [6] and residual architectures [4, 5] as special cases.", "startOffset": 121, "endOffset": 127}, {"referenceID": 16, "context": "Swapout is a generalization of dropout [17] and stochastic depth [6] methods.", "startOffset": 39, "endOffset": 43}, {"referenceID": 5, "context": "Swapout is a generalization of dropout [17] and stochastic depth [6] methods.", "startOffset": 65, "endOffset": 68}, {"referenceID": 3, "context": "Our experimental work focuses on a version of swapout which is a natural generalization of the residual network [4, 5].", "startOffset": 112, "endOffset": 118}, {"referenceID": 4, "context": "Our experimental work focuses on a version of swapout which is a natural generalization of the residual network [4, 5].", "startOffset": 112, "endOffset": 118}, {"referenceID": 15, "context": "The number of parameters rises sharply, although recent works such as [16, 19] have addressed this by reducing the filter size [16, 19].", "startOffset": 70, "endOffset": 78}, {"referenceID": 18, "context": "The number of parameters rises sharply, although recent works such as [16, 19] have addressed this by reducing the filter size [16, 19].", "startOffset": 70, "endOffset": 78}, {"referenceID": 15, "context": "The number of parameters rises sharply, although recent works such as [16, 19] have addressed this by reducing the filter size [16, 19].", "startOffset": 127, "endOffset": 135}, {"referenceID": 18, "context": "The number of parameters rises sharply, although recent works such as [16, 19] have addressed this by reducing the filter size [16, 19].", "startOffset": 127, "endOffset": 135}, {"referenceID": 18, "context": "Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10].", "startOffset": 131, "endOffset": 142}, {"referenceID": 17, "context": "Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10].", "startOffset": 131, "endOffset": 142}, {"referenceID": 3, "context": "Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10].", "startOffset": 131, "endOffset": 142}, {"referenceID": 18, "context": "Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10].", "startOffset": 200, "endOffset": 208}, {"referenceID": 9, "context": "Such difficulties have been addressed by architectural innovations that introduce shorter paths from input to loss either directly [19, 18, 4] or with additional losses applied to intermediate layers [19, 10].", "startOffset": 200, "endOffset": 208}, {"referenceID": 4, "context": "At the time of writing, the deepest networks that have been successfully trained are residual networks (1001 layers [5]).", "startOffset": 116, "endOffset": 119}, {"referenceID": 0, "context": "Bengio and Dellaleau argue that circuit efficiency constraints suggest increasing depth is important, because there are functions that require exponentially large shallow networks to compute [1].", "startOffset": 191, "endOffset": 194}, {"referenceID": 8, "context": "Convolutional neural networks have a long history (see the introduction of [9]).", "startOffset": 75, "endOffset": 78}, {"referenceID": 7, "context": "[8]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 15, "context": "Increasing the number of layers in a network improves performance [16, 19] if the network can be trained.", "startOffset": 66, "endOffset": 74}, {"referenceID": 18, "context": "Increasing the number of layers in a network improves performance [16, 19] if the network can be trained.", "startOffset": 66, "endOffset": 74}, {"referenceID": 11, "context": "A variety of significant architectural innovations improve trainability, including: the ReLU [12, 2]; batch normalization [7]; and allowing signals to skip layers.", "startOffset": 93, "endOffset": 100}, {"referenceID": 1, "context": "A variety of significant architectural innovations improve trainability, including: the ReLU [12, 2]; batch normalization [7]; and allowing signals to skip layers.", "startOffset": 93, "endOffset": 100}, {"referenceID": 6, "context": "A variety of significant architectural innovations improve trainability, including: the ReLU [12, 2]; batch normalization [7]; and allowing signals to skip layers.", "startOffset": 122, "endOffset": 125}, {"referenceID": 17, "context": "Highway networks use gated skip connections to allow information and gradients to pass unimpeded across several layers [18].", "startOffset": 119, "endOffset": 123}, {"referenceID": 3, "context": "Residual networks use identity skip connections to further improve training [4]; extremely deep residual networks can be trained, and perform well [5].", "startOffset": 76, "endOffset": 79}, {"referenceID": 4, "context": "Residual networks use identity skip connections to further improve training [4]; extremely deep residual networks can be trained, and perform well [5].", "startOffset": 147, "endOffset": 150}, {"referenceID": 13, "context": "For a review of the history of random methods, see the introduction of [14], which shows that entirely randomly chosen features can produce an SVM that generalizes well.", "startOffset": 71, "endOffset": 75}, {"referenceID": 16, "context": "Randomly dropping out unit values (dropout [17]) discourages coadaptation between units.", "startOffset": 43, "endOffset": 47}, {"referenceID": 5, "context": "Randomly skipping layers (stochastic depth) [6] during training reliably leads to improvements at test time, likely because doing so regularizes the network.", "startOffset": 44, "endOffset": 47}, {"referenceID": 19, "context": "Other successful recent randomized methods include dropconnect [20] which generalizes dropout by dropping individual connections instead of units (so dropping several connections together), and stochastic pooling [21] (which regularizes by replacing the deterministic pooling by randomized pooling).", "startOffset": 63, "endOffset": 67}, {"referenceID": 20, "context": "Other successful recent randomized methods include dropconnect [20] which generalizes dropout by dropping individual connections instead of units (so dropping several connections together), and stochastic pooling [21] (which regularizes by replacing the deterministic pooling by randomized pooling).", "startOffset": 213, "endOffset": 217}, {"referenceID": 2, "context": "Recent results show that (a) stochastic gradient descent with sufficiently few steps is stable (in the sense that changes to training data do not unreasonably disrupt predictions) and (b) dropout enhances that property, by reducing the value of a Lipschitz constant ([3], Lemma 4.", "startOffset": 267, "endOffset": 270}, {"referenceID": 18, "context": "Reliable improvements in accuracy are achievable by training distinct models (which have distinct sets of parameters), then averaging predictions [19], thereby forming an explicit ensemble.", "startOffset": 146, "endOffset": 150}, {"referenceID": 16, "context": "argue that, at test time, random values in a dropout network should be replaced with expectations, rather than taking an average over multiple instances [17] (though they use explicit ensembles, increasing the computational cost).", "startOffset": 153, "endOffset": 157}, {"referenceID": 3, "context": "a convolution followed by a ReLU or a residual network block [4].", "startOffset": 61, "endOffset": 64}, {"referenceID": 2, "context": "Dropout has been shown to enhance the stability of stochastic gradient descent ([3], lemma 4.", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "First, a Lipschitz constant applies to this network; second, E[||\u2207S [f ] (v) ||] \u2264 E[||\u2207G [f ] (v) ||] \u2264 L, so swapout makes stability no worse; third, we speculate light conditions on f should provide E[||\u2207S [f ] (v) ||] < E[||\u2207G [f ] (v) ||] \u2264 L, improving stability ([3] Section 4).", "startOffset": 270, "endOffset": 273}, {"referenceID": 16, "context": "[17] (deterministic inference).", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "may have overestimated how many samples are required for an accurate average, because they use distinct dropout networks in the average (Figure 11 in [17]).", "startOffset": 150, "endOffset": 154}, {"referenceID": 5, "context": "This may explain why [6] reports that dropout doesn\u2019t lead to any improvement when used in residual networks with batch normalization.", "startOffset": 21, "endOffset": 24}, {"referenceID": 3, "context": "ResNets: We compare with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2).", "startOffset": 62, "endOffset": 65}, {"referenceID": 4, "context": "ResNets: We compare with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2).", "startOffset": 92, "endOffset": 95}, {"referenceID": 3, "context": "Model: We experiment with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2).", "startOffset": 63, "endOffset": 66}, {"referenceID": 4, "context": "Model: We experiment with ResNet architectures as described in [4](referred to as v1) and in [5](referred to as v2).", "startOffset": 93, "endOffset": 96}, {"referenceID": 10, "context": "For final prediction we follow a scheme similar to Network in Network [11].", "startOffset": 70, "endOffset": 74}, {"referenceID": 3, "context": "We represent the number of filters in each group as a tuple with the smallest size as (16, 32, 64) (as used in [4]for CIFAR-10).", "startOffset": 111, "endOffset": 114}, {"referenceID": 16, "context": "Note that dropout slows convergence ([17], A.", "startOffset": 37, "endOffset": 41}, {"referenceID": 3, "context": "v1 and v2 represent residual block architectures in [4] and [5] respectively.", "startOffset": 52, "endOffset": 55}, {"referenceID": 4, "context": "v1 and v2 represent residual block architectures in [4] and [5] respectively.", "startOffset": 60, "endOffset": 63}, {"referenceID": 3, "context": "Method Width #Params Error(%) ResNet v1 [4] W \u00d7 1 0.", "startOffset": 40, "endOffset": 43}, {"referenceID": 5, "context": "Linear(a, b) refers to linear interpolation from a to b from the first block to the last (see [6]).", "startOffset": 94, "endOffset": 97}, {"referenceID": 16, "context": "Compare Figure-11 of [17], which implies \u223c 50 samples are required.", "startOffset": 21, "endOffset": 25}, {"referenceID": 3, "context": "ResNets [4] contain three groups of layers with all convolutional layers in a group containing equal number of filters.", "startOffset": 8, "endOffset": 11}, {"referenceID": 19, "context": "DropConnect [20] 9.", "startOffset": 12, "endOffset": 16}, {"referenceID": 10, "context": "32 NIN [11] 8.", "startOffset": 7, "endOffset": 11}, {"referenceID": 14, "context": "81 FitNet(19) [15] 8.", "startOffset": 14, "endOffset": 18}, {"referenceID": 9, "context": "39 DSN [10] 7.", "startOffset": 7, "endOffset": 11}, {"referenceID": 17, "context": "97 Highway[18] 7.", "startOffset": 10, "endOffset": 14}, {"referenceID": 3, "context": "60 ResNet v1(110) [4] 1.", "startOffset": 18, "endOffset": 21}, {"referenceID": 5, "context": "41 Stochastic Depth v1(1202) [6] 19.", "startOffset": 29, "endOffset": 32}, {"referenceID": 4, "context": "58 ResNet v2 (1001) [5] 10.", "startOffset": 20, "endOffset": 23}, {"referenceID": 18, "context": "It is straightforward using equation 2 to apply swapout to inception networks [19] (by using several different functions of the input and a sufficiently general form of convolution); to recurrent convolutional networks [13] (by", "startOffset": 78, "endOffset": 82}, {"referenceID": 12, "context": "It is straightforward using equation 2 to apply swapout to inception networks [19] (by using several different functions of the input and a sufficiently general form of convolution); to recurrent convolutional networks [13] (by", "startOffset": 219, "endOffset": 223}, {"referenceID": 10, "context": "NIN [11] 35.", "startOffset": 4, "endOffset": 8}, {"referenceID": 9, "context": "68 DSN [10] 34.", "startOffset": 7, "endOffset": 11}, {"referenceID": 14, "context": "57 FitNet [15] 35.", "startOffset": 10, "endOffset": 14}, {"referenceID": 17, "context": "04 Highway [18] 32.", "startOffset": 11, "endOffset": 15}, {"referenceID": 3, "context": "39 ResNet v1 (110) [4] 1.", "startOffset": 19, "endOffset": 22}, {"referenceID": 5, "context": "22 Stochastic Depth v1 (110) [6] 1.", "startOffset": 29, "endOffset": 32}, {"referenceID": 4, "context": "58 ResNet v2 (164) [5] 1.", "startOffset": 19, "endOffset": 22}, {"referenceID": 4, "context": "33 ResNet v2 (1001) [5] 10.", "startOffset": 20, "endOffset": 23}], "year": 2016, "abstractText": "We describe Swapout, a new stochastic training method, that outperforms ResNets of identical network structure yielding impressive results on CIFAR-10 and CIFAR100. Swapout samples from a rich set of architectures including dropout [17], stochastic depth [6] and residual architectures [4, 5] as special cases. When viewed as a regularization method swapout not only inhibits co-adaptation of units in a layer, similar to dropout, but also across network layers. We conjecture that swapout achieves strong regularization by implicitly tying the parameters across layers. When viewed as an ensemble training method, it samples a much richer set of architectures than existing methods such as dropout or stochastic depth. We propose a parameterization that reveals connections to exiting architectures and suggests a much richer set of architectures to be explored. We show that our formulation suggests an efficient training method and validate our conclusions on CIFAR-10 and CIFAR-100 matching state of the art accuracy. Remarkably, our 32 layer wider model performs similar to a 1001 layer ResNet model.", "creator": "LaTeX with hyperref package"}}}