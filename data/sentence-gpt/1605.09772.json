{"id": "1605.09772", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-May-2016", "title": "Technical Report: Directed Controller Synthesis of Discrete Event Systems", "abstract": "This paper presents a Directed Controller Synthesis (DCS) technique for discrete event systems. The DCS method explores the solution space for reactive controllers guided by a domain-independent heuristic. The heuristic is derived from an efficient abstraction of the environment based on the componentized way in which complex environments are described, including the properties of the environment. The purpose of the method is to analyze the state of the controller through a series of computations, with the input and output fields of the controller. The DCS method is also designed for use with a finite number of controllers with many more components, which will be required to achieve the desired user experience. The paper is titled, \u2020A Guide to the D-Wave DCS, which is intended to present the method in a realistic way to inform the user with an approach to the system.\u2020 A simplified method for analyzing the state of the controller by a domain-independent heuristic is implemented by a class-independent heuristic. The principal goals of the method are: A user has to interact with the interface within the controller, by connecting a component, which is dependent on the properties of the controller. The main goal of the method is to learn to interact with the interface within the controller, by connecting the controller to the controller via a component and communicating with the interface in a functional manner. The main goal of the method is to learn to interact with the interface within the controller, by connecting the controller to the controller via a component and communicating with the interface in a functional manner.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Tue, 31 May 2016 19:12:41 GMT  (74kb)", "http://arxiv.org/abs/1605.09772v1", "8 pages, submitted to the 55th IEEE Conference on Decision and Control"]], "COMMENTS": "8 pages, submitted to the 55th IEEE Conference on Decision and Control", "reviews": [], "SUBJECTS": "cs.SY cs.AI cs.SE", "authors": ["daniel ciolek", "victor braberman", "nicol\\'as d'ippolito", "sebasti\\'an uchitel"], "accepted": false, "id": "1605.09772"}, "pdf": {"name": "1605.09772.pdf", "metadata": {"source": "CRF", "title": "Technical Report: Directed Controller Synthesis of Discrete Event Systems", "authors": ["Daniel Ciolek", "Victor Braberman", "Nicol\u00e1s D\u2019Ippolito", "Sebasti\u00e1n Uchitel"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 5.\n09 77\n2v 1\n[ cs\n.S Y\n] 3\n1 M\nay 2\n01 6\nI. INTRODUCTION\nDiscrete Event Systems (DES) are dynamic systems that react to the occurrence of diverse discrete events. DES arise in many domains including robotics, logistics, manufacturing, and communication networks. These applications require control and coordination to ensure that the system goals are achieved. Numerous techniques for automatically verifying the correctness of controllers have been devised in the area of model checking. A different yet related approach, Controller Synthesis, pursues the automatic construction of controllers satisfying a formal specification.\nThe field of synthesis of controllers for DES was introduced by Ramadge and Wonham [1] for controlling systems within a given set of constraints. In this setting, the environment (also called plant) and goals are specified using a formal language, and a procedure generates a correct by construction controller (or supervisor). The environment is usually modeled with state machines whose event sets are partitioned into controllable and uncontrollable actions. A controller must achieve its goals by dynamically disabling some of the controllable actions.\nAn alternative formulation of the controller synthesis problem considers the setting of \u03c9-regular languages [2], instead of an automata-based DES. In this setting two-player games with Boolean objectives (where a win of one player coincides with a loss by the other player) have been suggested to reason about the interaction between the program and the environment [3], [4].\nWe address control problems for behavior models expressed as deterministic Labeled Transition Systems (LTS)\n1. Departamento de Computacio\u0301n, Universidad de Buenos Aires, Argentina 2. Department of Computing, Imperial College, London, UK 3. CONICET\nThis work was submitted to the 55th IEEE Conference on Decision and Control and was partially supported by grants ERC PBM-FIMBSE, ANPCYT PICT 2011-1774, ANPCYT PICT 2012-0724, ANPCYT PICT 2013- 2341, UBACYT 20020130100384BA, UBACYT 20020130300036BA, CONICET PIP 112 201301 00688 CO, PIDDEF 04/ESP/15/BAA.\nand parallel composition (\u2016) defined broadly as a synchronous product. This setting allows to ease the modeling of complex environments by describing its behavior compositionally. Such descriptions are compact and, hence, obtaining the complete behavior of the environment via composition produces an exponential explosion. For this reason we want to avoid the computation of the composition ahead of time, building it on-the-fly instead (hopefully obtaining a solution by exploring a reduced portion of the state space).\nHereinafter we present the Directed Controller Synthesis (DCS) of DES for safety and co-safety (i.e. reachability) goals. Informally, we want the controller to always avoid safety violations while eventually ensuring co-safety objectives. More formally, we make use of the Linear Temporal Logic (LTL) [5] operators. Thus, given the model of the environment components E0, . . . , En, the safety goal GS and the co-safety goal GC , we look for a component M such that when composed with the environment it satisfies the goals, namely E0\u2016 . . . \u2016En\u2016M |= \u00acGS \u2227 \u2666GC .\nDCS explores the solution space for reactive controllers on-the-fly guided by a domain-independent heuristic. The main contribution of this paper is the heuristic derived from an abstraction of the environment that exploits the componentized way in which complex environments are described. We highlight that componentization not only simplifies modeling, but also allows for preprocessing procedures that can improve the applicability of controller synthesis techniques.\nThe paper is organized as follows. Section II comments on previous and related work. Section III provides background. Section IV comments on details to take into account during the on-the-fly exploration of the state space. Section V presents the LTS abstraction and a heuristic derived from it. Section VI reports on the results obtained with our implementation. Finally, section VII discuses some conclusions and avenues for future work."}, {"heading": "II. RELATED WORK", "text": "Traditional controller synthesis techniques for safety objectives look for maximal (i.e. least restrictive) controllers [6], since safety properties can many times be trivially satisfied by restricting the system to an unproductive zone. Maximality comes at a cost in complexity given that it requires to explore the complete state space.\nMonolithic approaches to controller synthesis work with the complete state space but, since it is exponential with respect to the size of the components, explicit representations are impractical. The Model Based Planner (MBP) presented in [7] uses Binary Decision Diagrams (BDD) [8] to keep a symbolic representation of the state space, in an attempt to cope with the state explosion problem. MBP is based on\nthe NuSMV model checker and hence, its input is a model described in the SMV language, implementing different variations of goals (including liveness with CTL).\nContrarily to monolithic approaches, compositional approaches to controller synthesis (as the one implemented by Supremica [9]) build a controller for each component, such that when composed achieve the system requirements. Although this allows to greatly reduce the impact of the state explosion problem it also restricts its application to simple goals, such as safety, since it is not possible to guarantee composability for richer goals.\nController synthesis is also related to the area of Automated Planning, a branch of artificial intelligence. However, the work in planning has been oriented mainly towards nonreactive environments, which are insufficient in the setting in which controller synthesis is applied. MBP provides a translation from a planning input to an SMV script and shows that a planning problem can be solved as a control problem by taking advantage of the advances on model checking [10].\nIn planning the state space is usually represented explicitly, but the construction is performed on-the-fly guided by heuristics [11]. Informed search procedures \u2013 like A* [12] \u2013 are used to perform a goal-directed exploration, generally obtaining a solution by inspecting a reduced portion of the state space. Many variations of the planning problem have been attacked this way and some \u2013 especially those that contemplate nondeterminism such as FOND planning [13] \u2013 are closely related to controller synthesis.\nInspired by planning, informed search procedures have been introduced in model checking to accelerate the search for an error [14], [15]. Although with this approach a trace to an error can be found faster, verifying the correctness of a model still requires to explore the complete state space. Despite the positive results of these techniques, their application to controller synthesis has been scarcely explored.\nIn [16] an on-the-fly synthesis method is presented for discrete and dense-time system, using depth-first search without a heuristic guide. For linear hybrid systems, an on-the-fly informed search algorithm is presented in [17], which excels at design space exploration by quickly assessing whether a problem has no solution, rather than guiding the exploration towards a goal. Finally the Controller Synthesis Module of the CIRCA architecture [18], which works on a timed automaton model, uses heuristics with a limited lookahead and a verification procedure to detect and prune bad choices. In all these approaches the on-the-fly search procedure is similar to ours, but the setting differs since we consider as input the specification of the environment components, and hence the abstractions and heuristics diverge.\nHerein we present an extension to our previous work on the Modal Transition System Analyser (MTSA) [19] tool that now includes the DCS algorithm. As mentioned before, in the present work we focus on safety and co-safety (i.e. reachability) goals, the former being optional while the latter mandatory since the heuristic needs a desirable end to properly direct the search."}, {"heading": "III. BACKGROUND", "text": "Definition 1 (Labeled Transition Systems). A Labeled Transition System (LTS) is a tuple E = (S,A,\u2192, s0), where S is a finite set of states, A is its alphabet, \u2192\u2286 (S \u00d7A\u00d7 S) is a transition relation, and s0 \u2208 S is the initial state.\nNotation 1. Let E and M be LTSs such that:\n\u2022 E = (SE , AE ,\u2192E , s0), with s and s\u2032 states of SE \u2022 M = (TM , AM ,\u2192M , t0), with t and t\u2032 states of TM\nNotation 2 (Step). We denote (s, l, s\u2032) \u2208\u2192 by s l\u2192 s\u2032.\nDefinition 2 (Parallel Composition). The Parallel Composition (\u2016) is a symmetric operator such that it yields an LTS E\u2016M = (SE\u00d7TM , AE\u222aAM ,\u2192E\u2016M , \u3008s0, t0\u3009), where \u2192E\u2016M is a relation that satisfies the following rules:\ns l \u2192E s \u2032\n\u3008s, t\u3009 l \u2192E\u2016M \u3008s\u2032, t\u3009\nl\u2208(AE\\AM ) t\nl \u2192M t \u2032\n\u3008s, t\u3009 l \u2192E\u2016M\u3008s, t\u2032\u3009\nl\u2208(AM\\AE)\ns l \u2192E s \u2032, t l \u2192M t \u2032\n\u3008s, t\u3009 l \u2192E\u2016M \u3008s\u2032, t\u2032\u3009\nl\u2208(AE\u2229AM )\nExample 1. In Fig.1 we show an example of the application of the parallel composition operator (\u2016). Note that synchronizing actions produce an update in the states of both LTSs, while nonshared actions produce an update in only one LTS at a time. Observe also that shared actions that are not available from both LTSs at a given point cannot be executed (e.g. d available from t0 but not from s0 cannot be executed from the initial state \u3008s0, t0\u3009).\nGiven a partition of the alphabet in controllable and uncontrollable actions, a controller M must achieve its goal G by disabling some of the controllable actions in E, while only monitoring uncontrollable actions. We say that a controller M satisfies a goal G in an environment E if and only if every trace accepted by E\u2016M satisfies G.\nDefinition 3 (Trace). A trace of an LTS E is a sequence of labels \u03c0=l0, l1 . . . of AE , for which there exists a sequence of states s0, s1, . . . of SE such that \u2200i\u22650 . si li\u2192E si+1.\nDefinition 4 (Safety). We say that a trace \u03c0 satisfies a safety goal GS given as a set of labels, if and only if a label of GS never occurs in \u03c0.\nDefinition 5 (Co-Safety). We say that a trace \u03c0 satisfies a co-safety goal GC given as a set of labels, if and only if there is at least one occurrence of a label of GC in \u03c0.\nExample 2. In Fig.2 we show two controllers for EI\u2016EII that are guaranteed to reach {d} assuming that only a, b and c are controllable. The controller in Fig.2a simply disables a from the initial state to avoid entering a state where d is no longer reachable. Note that this controller does not force the order of actions b and c, that is, it imposes the least restrictive constraints. On the other hand, the controller in Fig.2b forces the order between actions b and c, hence, despite being correct it is not a maximal controller.\nNotation 3. States of the composition are ordered pairs, however we may need to refer to the step relation for any ordering. For this purpose we may use the following notation:\n{s, t} l \u2192E\u2016M{s \u2032, t\u2032} \u21d4\u3008s, t\u3009 l \u2192E\u2016M \u3008s \u2032, t\u2032\u3009 \u2228 \u3008s, t\u3009 l \u2192E\u2016M \u3008t \u2032, s\u2032\u3009\u2228\n\u3008t, s\u3009 l \u2192E\u2016M \u3008s \u2032, t\u2032\u3009 \u2228 \u3008t, s\u3009 l \u2192E\u2016M \u3008t \u2032, s\u2032\u3009\nWhen using the set notation we relax the convention that s and s\u2032 belong to E while t and t\u2032 belong to M since the order of the states is made irrelevant.\nNotation 4. For brevity we denote that a set of states s0, s1, . . . , sn belongs to a set q, that is to say that \u2200i . 0 \u2264 i \u2264 n \u21d2 si \u2208 q, as [s1, s2, . . . , sn]q ."}, {"heading": "IV. ON-THE-FLY EXPLORATION", "text": "In this section we discuss the main algorithm that constitutes DCS. Given a heuristic function that estimates the distance from a state to a goal, DCS looks for a controller by computing the parallel composition on-the-fly guided by the heuristic. The procedure is a modification of Best First Search (a classical informed search procedure) adapted to account for uncontrollable actions. We keep a priority queue of open states, ordered by their estimated distance to a goal, initialized only with the initial state. At each iteration the algorithm takes the most promising state from the queue and expands a child state following its best unexplored action. The expanded state is evaluated using the heuristic, and it is then inserted in the open queue (the value of the state is set as the estimate of its best unexplored action).\nFor controllable states we need only one successful successor, while for uncontrollable states all their successors have to be able to reach a goal. Thus we allow a controllable state to remain in the open queue as long as it has unexplored actions to broaden the search (i.e. competing with its descendants). Mixed states, that is states with both controllable and uncontrollable actions, are treated as uncontrollable states. This is because mixed states represent a race condition between the controller and the environment, which can always be won by the environment. Thereby the validity of the controller cannot depend on the result of race conditions. This treatment of controllable and uncontrollable nodes is similar to AND/OR search procedures [20].\nWhen a state is recognized either as a co-safety goal or a safety error, it is marked and this information is propagated back to its ancestors until an interrupting state is reached and reopened. The propagation of an error is interrupted when a controllable ancestor with unexplored actions is reached. Whereas, the propagation of a goal is interrupted when an uncontrollable ancestor with unexplored actions is reached. The process is repeated until the initial state is marked as a goal or an error. In the former the states reachable from the initial state form a controller, while in the latter there is no controller.\nObserve that while there is an obvious advantage in exploring the most promising controllable action first, there is no such advantage in exploring the best uncontrollable action since all such actions must lead to a goal. Thus we could avoid the computation of the heuristic for uncontrollable states. Instead we use the reverse ranking and expand the least desirable uncontrollable action first. We do this in an attempt to find an error as fast as possible and consequently being able to close the state avoiding futile exploration.\nIn the worst case, the heuristic misguides the search and the algorithm explores the complete state space. With the additional cost of computing the heuristic for each state, the complexity of the algorithm is worse than its monolithic counterpart. That is, DCS could take an exponential amount of time. In spite of that, if the heuristic accurately guides the exploration with a small computational overhead, great savings could be obtained."}, {"heading": "V. ABSTRACTION AND HEURISTIC", "text": "In this section we present the abstraction we use and the heuristic it induces. The main goal of the heuristic is to provide an estimate of the distance from a state to a goal without computing the parallel composition. However, in order to provide informative estimates the effects of synchronization need to be taken into account to some point. For this reason we build an abstraction of the environment that, instead of considering the cross product of states, it works on sets of states. More precisely, if the states contained in the set can synchronize (with the standard parallel composition), then the synchronizing action must be available from the set.\nAt first glance considering the power set of states may seem detrimental, but we also apply a rule of monotonic growth. That is, the reachable sets of states are restricted to\nsets that contain all the traversed states from the initial state. Thus the abstraction size is polynomial with respect to the number of states in the components. We then use the length of the paths that reach a co-safety goal in the abstraction as an estimate of the real distance to the goal."}, {"heading": "A. LTS Abstraction and Composition", "text": "Intuitively, we build an abstraction that, once it reaches a point where a state is covered, it never drops a state. The abstraction behaves as if, after a transition, not only a new state is covered but also the source state is not left. This progressively distances the abstraction from the real environment (as it collects states), yet it keeps information about the causal relationship between actions.\nWe begin by defining the LTS abstraction for a single LTS, that yields an LTS whose reachable region forms a sequence of sets of states.\nDefinition 6 (LTS Abstraction). The abstraction of an LTS E is an LTS E\u0303 = (2SE , 2AE , E , {s0}), where E is the relation that satisfies:\nq A Eq \u2032 \u21d4 ( \u2200s, s\u2032, a . [s]q \u2227 s a \u2192Es \u2032 \u21d2 [s, s\u2032]q\u2032 \u2227 a\u2208A )\n\u2227 (\n\u2200s\u2032 . [s\u2032]q\u2032 \u21d2 [s \u2032]q \u2228 \u2203s, a . [s]q \u2227 a\u2208A \u2227 s a \u2192Es \u2032 )\nObserve that in the abstraction not only the states are sets of the original states, but also the labels are sets of the original labels. Furthermore, there is only one set of actions available from each set of states, that is, the maximal set of enabled actions.\nWe now define the abstracting composition, an operation for composing these abstracted LTSs. Informally, this operation works by applying a relaxed synchronization rule that follows that of (\u2016), but considering sets of states.\nDefinition 7 (Abstracting Composition). The Abstracting Composition ( \u2248 ) is a symmetric operator in the spirit of (\u2016) that yields an abstract LTS E\u0303 \u2248 M\u0303 = (SE\u0303 \u222a SM\u0303 , AE\u0303 \u222a AM\u0303 , E\u0303 \u2248 M\u0303 , m\u03030 \u222a t\u03030}) and E\u0303 \u2248 M\u0303 is the relation that satisfies:\nq A E\u0303 \u2248 M\u0303 q \u2032 \u21d4 (\n\u2200s,s\u2032,t,t\u2032,a . [s,t]q\u2227\u3008s,t\u3009 a \u2192E\u2016M \u3008s \u2032,t\u2032\u3009 \u21d2 [s\u2032,s,t\u2032,t]q\u2032\u2227a\u2208A )\n\u2227 (\n\u2200s\u2032 . [s\u2032]q\u2032 \u21d2 [s \u2032]q\u2228\u2203s,t,t \u2032,a . [s, t]q\u2227a\u2208A\u2227{s,t} a \u2192E\u2016M{s \u2032, t\u2032} )\nNote that we do not need to compute E\u2016M since we only check locally that states s and t synchronize following the rules in Def.2.\nProperty 1. Given LTSs E and M the number of sets of states reachable in E\u0303 \u2248 M\u0303 is, in worst case, |SE |+ |SM |.\nProof. The proof is immediate given that once every state in SM \u222a SE is included in a set of states q, no other set of states can be reached. Thus, in the worst case each step contributes only one fresh state, leading to |SE |+ |SM | steps before reaching the last possible fresh state.\nExample 3. In Fig.3 we show examples for the LTS abstraction (Def. 6) and the abstracting composition (Def. 7) of LTSs EI and EII . In Fig.3a the abstraction of EI is depicted. The first step of E\u0303I is constituted by the actions a and b (the actions available from s0), reaching a set of states with s1 (the target\nof a) and s2 (the target of b), plus states already reached in previous steps (i.e. s0). The second step only adds the action d available from s2 reaching s3, once all the reachable states are included in the set a self loop captures potential infinite behaviours.\nIn Fig.3b a similar construction is shown for the abstracting composition between E\u0303I and E\u0303II . Note that despite the fact that d is available from t0 it is not available from {s0, t0} since it is a synchronizing action not enabled at s0.\nDespite looking very dissimilar there is a strong relation between a model and its abstraction. In particular if \u03c0 is a trace of E\u2016M , \u03c0 is a path contained in E\u0303 \u2248 M\u0303 . We say that a sequence of actions \u03c0=l0, l1 . . . is a contained path in E\u0303 \u2248 M\u0303 if and only if there is a trace \u03a0=L0, L1 . . . of E\u0303 \u2248 M\u0303 such that \u2200i . li \u2208 Li. Moreover, we may abuse notation and denote that for a given label li exists a set Li such that li \u2208 Li \u2227 q Li E\u0303 \u2248 M\u0303 q \u2032 using directly li as the label of the transition as follows: q li E\u0303 \u2248 M\u0303 q\n\u2032. Note that by Def. 7 every trace of E\u2016M is a path contained in E\u0303 \u2248 M\u0303 . However, not every contained path can be mapped to a trace in E\u2016M . Therefore after computing the abstraction some paths will relate to traces while others will not, yet a priori we have no way to distinguish between these cases. We can easily filter some paths that are obviously uninteresting, such as the paths that contain noncomponent-steps or nonsynchronizing-steps (e.g. s0 c \u2192E\u0303I \u2248 E\u0303II t2). For this reason we define abstracting path to more precisely capture the notion of path that will help us estimate the distance to a goal.\nDefinition 8 (Abstracting Path). We say that a sequence of actions l0, l1, . . . is an abstracting path of E\u0303 \u2248 M\u0303 if and only if there is a sequence of states s0, s1, . . . of SE \u222a SM and a sequence of sets of states q0, q1, . . . of SE\u0303 \u2248 M\u0303 such that:\n\u2200i . ([si]qi \u2227 qi li E\u0303 \u2248 M\u0303 qi+1 \u2227 \u2203t,t \u2032 . {si, t} li\u2192E\u2016M {si+1, t \u2032})\u2228 (si=si+1 \u2227 li=\u03c4 )\nThis definition allows not only for valid intra-LTS steps (e.g. s0 a \u2192E\u0303I \u2248 E\u0303IIs1), but it also allows for inter-LTS steps as long as they are potential synchronization steps (e.g. s0 a \u2192E\u0303I \u2248 E\u0303II t1). This is important since an isolated component may not be able to reach a goal, but it may be necessary for an intermediate synchronization step. Observe that we add a\nspecial action \u03c4 to \u201cdelay\u201d a step from a state [si]qi to actions available from [si]qi+1 . This allows to consider paths that skip necessary synchronization steps, while still considering them in the estimation. This definition filters the paths that are not solely constituted by these intra-LTS and inter-LTS steps. However, it remains that not every abstracting path is a trace, yet we use the length of these paths as an estimate of the expected distance to a co-safety goal.\nProperty 2. Given LTSs E and M every trace \u03c0 of E\u2016M is an abstracting path of E\u0303 \u2248 M\u0303 .\nProof. The proof is straightforward, since given that \u03c0 = l0, l1, . . . is a trace of E\u2016M there exists a sequence of states:\n\u3008s0, t0\u3009 l0\u2192E\u2016M \u3008s1, t1\u3009 l1\u2192E\u2016M . . .\nThen by Def. 7 there exists a sequence of sets of states q0, q1, . . . such that \u2200i . [si, ti]qi and\nq0 l0 E\u0303 \u2248 M\u0303 q1 l1 E\u0303 \u2248 M\u0303 . . .\nTherefore by Def. 8 \u03c0 is an abstracting path of E\u0303 \u2248 M\u0303 .\nWe compute the estimate simply by taking the length of an abstracting path that reaches a co-safety goal. Paths that reach a safety violation are considered to have an infinite (\u221e) distance to the goal. Interestingly, this can never overestimate the distance to the goal, but it can underestimate it. Heuristics that do not overestimate the distance to the goal are called admissible and have been studied in the literature since they enjoy useful properties (e.g. early error detection).\nLemma 1 (Admissibility). The length of an abstracting path that reaches a co-safety goal is an admissible heuristic, that is, it does not overestimate the distance to the goal.\nProof. Note that in the worst case a path \u03c0 reaching a goal is a trace of the environment, thus its length estimates exactly the distance to the goal. In any other case \u03c0 is not a valid sequence of actions of the environment, that is to say is an artifact of the weakened composition rules of the abstraction. Hence \u03c0 may skip some necessary intermediate steps required to actually reach the goal in the environment. Therefore, the length of \u03c0 underestimates the distance to the goal."}, {"heading": "B. Heuristic Computation", "text": "In this section we show how we build the abstraction and compute the heuristic estimates for the actions available from a given state. For computing the heuristic we need all the abstracting paths reaching a goal or an error from an initial state. For this we build a graph whose paths are all such abstracting paths, which is naturally induced from Def. 8. However, instead of explicitly representing the special action \u03c4 , we represent the \u201cdistance\u201d between states by a positive integer that we call generation.\nDefinition 9 (Generation). Given an abstracted LTS E\u0303 we define the generation of a state s of SE\u0303 as the index g of the sequence of sets of states of E\u0303 in which the state s appears for the first time, denoted sg. More formally,\ns g \u21d4 g = max\ni { i | \u2200 0 \u2264 j < i, \u2203lj . qj\nlj E\u0303 qj+1 \u2227 s 6\u2208 qj}\nThe generation is useful since given a transition from a state si into sj with generations n and m respectively, we can deduce the \u201cdistance\u201d between them by subtracting |m\u2212n|.\nDefinition 10 (Abstracting Path Graph). Given LTSs E and M , the Abstracting Path Graph of E\u0303 \u2248 M\u0303 is a graph G(E\u0303 \u2248 M\u0303) = (V , E , gen) where:\n\u2022 V = SE \u222a SM , is a set of vertices formed by states \u2022 E = {(si, l, sj) | \u2203q, q \u2032, t, t\u2032 . [si, t]q \u2227 q l E\u0303 \u2248 M\u0303 q \u2032 \u2227\n{si, t} l \u2192E\u2016M {sj , t \u2032}}, is a set of labeled edges \u2022 gen : V \u2192 N, is a function mapping states to their\nrespective generations Informally, two vertices of the graph are connected by an edge if and only if there is a step, connecting the corresponding states, that is part of an abstracting path.\nExample 4. In Fig.4 we show the abstracting path graph of E\u0303I \u2248 E\u0303II . Each edge of the graph represents a possible step in the abstraction that is a part of an abstracting path. The first column of the graph contains the states at generation 0 (s0 and t0), the second column contains the fresh states at generation 1 (s1, s2, t1 and t2), while the third column contains the fresh states at generation 3 (s3). An edge that skips one or more columns (or generations) represents a fragment of an abstracting path with \u03c4 -steps. For example, the edge labeled d connecting t0 with s3 represents a \u03c4 -step followed by action d. This is because d is not available from the initial state and is delayed (i.e. the path has a length of 2).\nWe can use this graph to build a ranking of the available actions from the initial state of EI\u2016EII , namely \u3008s0, t0\u3009, by measuring the distance to the co-safety goal {d}. The available actions are a, b and c (as mentioned before d is disabled from the initial state). The shortest paths to d starting with b and c have a length of 2, while there are no paths reaching d starting with a. Hence, we estimate an infinite distance to the goal for every path starting with a. Ranking the actions by these estimates directs us to explore the actions b and c. In spite of that, we are underestimating the distance to the goal since our estimation assumes that immediately after either b or c we would be able to execute d. This is an artifact of the weak composition rules since both b and c need to be executed (in any order) before d. Still, these estimates effectively guide the exploration towards the goal.\nIn Fig. 5 we present a procedure that given a state \u3008sE0 , . . . , sEn\u3009 of the composition E0\u2016 . . . \u2016En, and sets of actions desired to reach and to avoid , it returns the information required to compute a heuristic ranking:\n1) errors , a set of states that do not conduce to a goal. 2) goals , a set of transitions connected by a reach action. 3) edges of the abstracting path graph. 4) generations of the states in the graph.\nThe procedure works by iteratively building the sequence of sets of states produced by the abstraction (Def. 7) and, at the same time, the abstracting path graph (Def. 10). At each iteration a new set qg is considered, where g indicates the current generation. We then compute the set of ready transitions, that is, the steps available from qg following the relaxed synchronization rule from Def. 7. Observe that once a transition is processed it is never considered again. Also note that states are considered errors until they show potential to reach a goal (i.e. deadlock states are treated as errors). Since the procedure processes each transition once its complexity is \u0398( \u2223\n\u2223 E\u03030 \u2248 ... \u2248 E\u0303n\n\u2223\n\u2223), which considering the weakened synchronization rules, can be bigger than the actual transitions in the individual components. In the worst case, the complexity cannot surpass the connection of every state by every action, that is to say that its upper-bound complexity is O ( ( \u2211n\ni=0 |AEi |)( \u2211n i=0 |SEi |) 2 )\n. Once we have built the abstracting path graph, obtaining a ranking for the actions enabled from the state \u3008sA, . . . , sN \u3009 is straightforward. The states reached by the goals transitions are set with an estimated distance to a goal of 0, while the states in the errors set are set with an \u221e estimated distance. Then, we propagate these estimates from the states to its parents following the edges backwards. For each step we increase the estimated distance between parent and child according to the information stored in the generations map.\nFor a state with multiple children we keep as an estimate the minimum of its children\u2019s, since we are interested in reaching the goal as fast as possible. When this back-propagation ends, all the enabled actions have an estimated distance to the goal, thus it is just a matter of sorting them with respect to these values. However, the same action could have multiple estimated values since we allow not only intra-LTS transitions but also inter-LTS transitions; in these cases we keep the best (minimum) estimate.\nSummarizing, the procedure computes \u2013 through the construction of the graph \u2013 the length of the abstracting paths starting at a given initial state and reaching a co-safety goal. The algorithm concentrates on the best estimates, which are used to guide the on-the-fly exploration. Thus, it effectively computes an admissible heuristic, since it can never overestimate the distance to the goal (Lemma 1)."}, {"heading": "VI. EVALUATION", "text": "In this section we report on an evaluation of DCS. We compare DCS with three other approaches running on an Intel i7-3770 with 8GB of RAM:\n1) Monolithic explicit state representation, previously implemented in MTSA1 (similar to CTCT [21]). 2) Monolithic symbolic state representation using BDD, implemented in MBP [7]. 3) Compositional explicit state representation implemented in Supremica (SUP) [9].\nThe aim of the evaluation is to assess the gains in scalability with the use of the informed search procedure. For this reason, we want case studies with the capability to scale up to higher complexities. Fortunately, both MBP and Supremica come bundled with the specification for one of the most traditional examples in controller synthesis: Line Transfer (LT); which was first introduced by Wonham [21]. The fact that the models were written by the tools authors\u2019 is important because it reduces the impact of a threat to validity that would be an ill-designed model. However, in order to be able to scale the problem up we had to extend the models, yet we maintain the same structure.\nGiven the complexity of: writing identical specifications in the different formal languages, finding examples that can be scaled up and presenting the results; we opt for concentrating in varying three independent parameters for the LT. This gives us a big enough number of environments with different topologies to evaluate the techniques. Still, this represents another threat to validity, since ideally the techniques should be compared with a more diverse set of inputs.\nThe LT consists of series of machines M1,M2, . . . ,Mn connected by buffers B1, B2, . . . , Bn and ending in a special machine called Test Unit (TU ). A machine Mi takes work pieces from the buffer Bi\u22121 (with the exception of machine M1 that takes the work pieces from the outside). After an undetermined amount of time, the working machine Mi outputs a processed work piece through buffer Bi. Finally, when a work piece reaches the TU it can be accepted and\n1Available at https://bitbucket.org/dciolek/mtsa\ntaken out of the system or it can be rejected and placed back in buffer B1 for reprocessing. The only controllable actions in this case study are the taking of work pieces. An error ensues if a machine tries to take a work piece from an empty buffer or if it tries to place a processed work piece in a full buffer. One of the goals for the controller is to avoid the actions that lead to errors, the other goal is to reach a state where a processed work piece can be accepted or rejected. We do not require the controller to achieve accepted pieces as acceptance and rejection are not decided by the controller.\nThe case study can be scaled in three directions:\n1) Machines (M): number of interconnected machines. 2) Workload (W): maximum number of work pieces a\nmachine can process simultaneously. 3) Capacity (C): capacity of the buffers.\nExample 5. In Fig. 6 we present the TL model as accepted by MTSA, given in the Finite State Processes modeling language (FSP). Technically, FSP is a process calculus, in the spirit of CSP, designed to be easily machine and human readable. FSP includes standard constructs such as action prefix (->), external choice (|), alphabet extension (+) and parallel composition (||).\nWe model the Machines and TU separately; and afterwards the Buffer. The Machine starts idle and can get as many work pieces as its workload allows it. Uncontrollably the processing ends and the element is put in the next buffer. The TU gets an element from the last buffer and can either accept it or reject it making it return to the first buffer. Note that on attempting an invalid operation the Buffer goes into an ERROR state (i.e. a deadlock). The ||Plant process represents the parallel composition between all the processes.\nIn Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].\nWe report the time in seconds required by each tool to synthesize a controller with a Time Out (TO) of 30 minutes.\nAs it can be seen in the table, the number of states in the environment grows very quickly and it soon takes the tools to their limits. Nonetheless, DCS is able to solve all the problems under the second mark. MTSA soon runs Out of Memory (OM) while, despite also working with a full representation of the environment, MBP solves many problems including large instances. Whereas Supremica outperforms the other methods in the simpler cases but falls short on the more complex ones.\nExample 6. Analyzing the controller generated by DCS for the TL case study, we see that the heuristic guides the search for the controller disregarding unnecessary actions such as simultaneously processing multiple work pieces. The controller found by DCS is roughly a sequence of states such that each state is connected with the following with interleaving get and put actions until an accept or reject becomes available. In Fig.7 we show the controller generated by DCS for 2 machines. Despite the fact that the technique pursues a reachability objective, it accidentally finds controllers with cyclic behavior, this is caused by the reopening of already explored states. However, this is not to be expected in general.\nIn a second experiment we assess the boundaries of the technique using \u201cbig scale\u201d cases shown in Fig. 8. We remove the other techniques from the evaluation since they cannot tackle these problems. For ease of presentation we report on a subset of the combinations of the parameters where W and C take the same values. Note that W and C are directly related with the number of states in the Machine and Buffer LTSs respectively, while M relates to the number of components. Thus, the evaluation still allows to see how the technique performs as the complexity and the number of components increase independently.\nSummarizing, we have evaluated DCS against other approaches to controller synthesis. DCS shows promise given that it is able to cope with increasing complexities beyond the capabilities of similar tools. The largest case tackled by DCS considers an environment with 8.9e2734 states (solved in 1728s) generating a controller with 2503 states."}, {"heading": "VII. CONCLUSIONS AND FUTURE WORK", "text": "In this paper we present DCS, a method that looks for a controller exploring the state space on-the-fly guided by a domain-independent heuristic. The method performs better than other approaches both in time and memory for the selected case study, despite its worst case complexity. The approach forgoes maximality since reachability goals allow for a directed search in a reduced portion of the state space.\nThe risk of DCS is that it could fail to properly guide the exploration, triggering an unnecessary large exploration of the state space. Thus, despite our efforts to keep the approach as general as possible, further experiments are required in order to properly asses the generality of the technique. For this reason we plan to work on automatic translations to simplify the comparison with other tools.\nThese preliminary results show promise and hence we intend to extend the technique. Our primary concern is to deal with general liveness goals, since the domain of application of controller synthesis usually have these kind of requirements.\nWe highlight that a compact representation of the problem is essential for extracting useful guidance for the informed\nsearch procedure. Thus, when dealing with DES, elements such as components and synchronization provide vital information to take into account. Furthermore, even when the LTS abstraction achieves remarkable results, there are other heuristics that could be used (instead or in combination) that could perform better. The field of directed controller synthesis is almost uncharted, and we believe it can lead to a leap in the applicability of controller synthesis techniques."}], "references": [{"title": "Supervisory Control of a Class of Discrete Event Processes", "author": ["P.J. Ramadge", "W.M. Wonham"], "venue": "SIAM Journal on Control and Optimization, vol. 25, 1987.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1987}, {"title": "On the Synthesis of a Reactive Module", "author": ["A. Pnueli", "R. Rosner"], "venue": "Proc. 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL, 1989.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1989}, {"title": "Decidability of Second-order Theories and Automata on Infinite Trees", "author": ["M.O. Rabin"], "venue": "Bulletin of the American Mathematical Society , vol. 74, 1968.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1968}, {"title": "The Temporal Semantics of Concurrent Programs", "author": ["A. Pnueli"], "venue": "Proc. of the Int. Symp. on Semantics of Concurrent Computation , 1979.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1979}, {"title": "On the Supremal Controllable Sublanguage of a Given Language", "author": ["Wonham", "W. Murray", "Ramadge", "Peter J."], "venue": "SIAM Journal on Control and Optimization, vol. 25, no. 3, 1987.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1987}, {"title": "A Tool for Controller Synthesis via Symbolic Model Checking", "author": ["A. Gromyko", "M. Pistore", "P. Traverso"], "venue": "Proceeding of the 8th Int. Workshop on Discrete Event Systems, 2006.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2006}, {"title": "Binary Decision Diagrams", "author": ["S.B. Akers"], "venue": "IEEE Transactions in Computers, vol. 27, 1978.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1978}, {"title": "Compositional synthesis of discrete event systems using synthesis abstraction", "author": ["S. Mohajerani", "R. Malik", "S. Ware", "M. Fabian"], "venue": "Control and Decision Conf., CCDC, 2011.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "Planning as Model Checking", "author": ["F. Giunchiglia", "P. Traverso"], "venue": "Recent Advances in AI Planning , vol. 1809 of Lecture Notes in Comp. Sci., 2000.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1809}, {"title": "Planning as Heuristic Search", "author": ["B. Bonet", "H. Geffner"], "venue": "Artificial Intelligence, vol. 129, 2001.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2001}, {"title": "A Formal Basis for the Heuristic Determination of Minimum Cost Paths", "author": ["P.E. Hart", "N.J. Nilsson", "B. Raphael"], "venue": "SIGART Bulletin, no. 37, 1972.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1972}, {"title": "Non-Deterministic Planning with Conditional Effects", "author": ["C.J. Muise", "S.A. McIlraith", "V. Belle"], "venue": "Proc. 24th Int. Conf. on Automated Planning and Scheduling, ICAPS, 2014.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Directed Explicit Model Checking with HSF-SPIN", "author": ["S. Edelkamp", "A. Lluch-Lafuente", "S. Leue"], "venue": "SPIN, vol. 2057 of Lecture Notes in Comp. Sci., 2001.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2001}, {"title": "Adapting an AI Planning Heuristic for Directed Model Checking", "author": ["S. Kupferschmid", "J. Hoffmann", "H. Dierks", "G. Behrmann"], "venue": "Model Checking Software, vol. 3925 of Lecture Notes in Comp. Sci., 2006.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2006}, {"title": "On-the-fly Controller Synthesis for Discrete and Dense Time Systems", "author": ["S. Tripakis", "K. Altisen"], "venue": "Proc. of World Congress on Formal Methods in the development of Computing Systems, vol. 1 of FM, 1999.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1999}, {"title": "On-the-Fly Control Software Synthesis", "author": ["V. Alimguzhin", "F. Mari", "I. Melatti", "I. Salvo", "E. Tronci"], "venue": "Model Checking Software, vol. 7976 of Lecture Notes in Comp. Sci., 2013.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Exploiting Implicit Representations in Timed Automaton Verification for Controller Synthesis", "author": ["R.P. Goldman", "D.J. Musliner", "M.J.S. Pelican"], "venue": "Proc. 5th Int. Workshop of Hybrid Systems: Computation and Control, HSCC, 2002.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2002}, {"title": "MTSA: The Modal Transition System Analyser", "author": ["N. D\u2019Ippolito", "D. Fischbein", "M. Chechik", "S. Uchitel"], "venue": "Proc. 23rd IEEE/ACM Int. Conf. on Automated Software Engineering , ASE, 2008.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2008}, {"title": "On the Optimal Solutions to AND/OR Series-Parallel Graphs", "author": ["R. Simon", "R.C.T. Lee"], "venue": "Journal of the ACM, vol. 18, 1971.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1971}, {"title": "Notes on Control of Discrete-Event Systems.", "author": ["W. Wonham"], "venue": "Dep. of Electrical and Comp. Engineering, University of Toronto,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1999}], "referenceMentions": [{"referenceID": 0, "context": "The field of synthesis of controllers for DES was introduced by Ramadge and Wonham [1] for controlling systems within a given set of constraints.", "startOffset": 83, "endOffset": 86}, {"referenceID": 1, "context": "An alternative formulation of the controller synthesis problem considers the setting of \u03c9-regular languages [2], instead of an automata-based DES.", "startOffset": 108, "endOffset": 111}, {"referenceID": 2, "context": "In this setting two-player games with Boolean objectives (where a win of one player coincides with a loss by the other player) have been suggested to reason about the interaction between the program and the environment [3], [4].", "startOffset": 224, "endOffset": 227}, {"referenceID": 3, "context": "More formally, we make use of the Linear Temporal Logic (LTL) [5] operators.", "startOffset": 62, "endOffset": 65}, {"referenceID": 4, "context": "least restrictive) controllers [6], since safety properties can many times be trivially satisfied by restricting the system to an unproductive zone.", "startOffset": 31, "endOffset": 34}, {"referenceID": 5, "context": "The Model Based Planner (MBP) presented in [7] uses Binary Decision Diagrams (BDD) [8] to keep a symbolic representation of the state space, in an attempt to cope with the state explosion problem.", "startOffset": 43, "endOffset": 46}, {"referenceID": 6, "context": "The Model Based Planner (MBP) presented in [7] uses Binary Decision Diagrams (BDD) [8] to keep a symbolic representation of the state space, in an attempt to cope with the state explosion problem.", "startOffset": 83, "endOffset": 86}, {"referenceID": 7, "context": "Contrarily to monolithic approaches, compositional approaches to controller synthesis (as the one implemented by Supremica [9]) build a controller for each component, such that when composed achieve the system requirements.", "startOffset": 123, "endOffset": 126}, {"referenceID": 8, "context": "MBP provides a translation from a planning input to an SMV script and shows that a planning problem can be solved as a control problem by taking advantage of the advances on model checking [10].", "startOffset": 189, "endOffset": 193}, {"referenceID": 9, "context": "In planning the state space is usually represented explicitly, but the construction is performed on-the-fly guided by heuristics [11].", "startOffset": 129, "endOffset": 133}, {"referenceID": 10, "context": "Informed search procedures \u2013 like A* [12] \u2013 are used to perform a goal-directed exploration, generally obtaining a solution by inspecting a reduced portion of the state space.", "startOffset": 37, "endOffset": 41}, {"referenceID": 11, "context": "Many variations of the planning problem have been attacked this way and some \u2013 especially those that contemplate nondeterminism such as FOND planning [13] \u2013 are closely related to controller synthesis.", "startOffset": 150, "endOffset": 154}, {"referenceID": 12, "context": "Inspired by planning, informed search procedures have been introduced in model checking to accelerate the search for an error [14], [15].", "startOffset": 126, "endOffset": 130}, {"referenceID": 13, "context": "Inspired by planning, informed search procedures have been introduced in model checking to accelerate the search for an error [14], [15].", "startOffset": 132, "endOffset": 136}, {"referenceID": 14, "context": "In [16] an on-the-fly synthesis method is presented for discrete and dense-time system, using depth-first search without a heuristic guide.", "startOffset": 3, "endOffset": 7}, {"referenceID": 15, "context": "For linear hybrid systems, an on-the-fly informed search algorithm is presented in [17], which excels at design space exploration by quickly assessing whether a problem has no solution, rather than guiding the exploration towards a goal.", "startOffset": 83, "endOffset": 87}, {"referenceID": 16, "context": "Finally the Controller Synthesis Module of the CIRCA architecture [18], which works on a timed automaton model, uses heuristics with a limited lookahead and a verification procedure to detect and prune bad choices.", "startOffset": 66, "endOffset": 70}, {"referenceID": 17, "context": "Herein we present an extension to our previous work on the Modal Transition System Analyser (MTSA) [19] tool that now includes the DCS algorithm.", "startOffset": 99, "endOffset": 103}, {"referenceID": 18, "context": "This treatment of controllable and uncontrollable nodes is similar to AND/OR search procedures [20].", "startOffset": 95, "endOffset": 99}, {"referenceID": 19, "context": "1) Monolithic explicit state representation, previously implemented in MTSA1 (similar to CTCT [21]).", "startOffset": 94, "endOffset": 98}, {"referenceID": 5, "context": "2) Monolithic symbolic state representation using BDD, implemented in MBP [7].", "startOffset": 74, "endOffset": 77}, {"referenceID": 7, "context": "3) Compositional explicit state representation implemented in Supremica (SUP) [9].", "startOffset": 78, "endOffset": 81}, {"referenceID": 19, "context": "Fortunately, both MBP and Supremica come bundled with the specification for one of the most traditional examples in controller synthesis: Line Transfer (LT); which was first introduced by Wonham [21].", "startOffset": 195, "endOffset": 199}, {"referenceID": 0, "context": "TU = Idle, Idle = (get[M] -> Testing ), Testing = (ret[1] -> reject -> Idle | accept -> Idle) +{ret[0.", "startOffset": 54, "endOffset": 57}, {"referenceID": 2, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 140, "endOffset": 149}, {"referenceID": 3, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 140, "endOffset": 149}, {"referenceID": 4, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 140, "endOffset": 149}, {"referenceID": 0, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 156, "endOffset": 165}, {"referenceID": 1, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 156, "endOffset": 165}, {"referenceID": 0, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 172, "endOffset": 181}, {"referenceID": 1, "context": "In Table I we consider some \u201csmall scale\u201d cases, in which we consider all the combinations of the parameters for the following values: M in [4, 5, 6], W in [1, 2, 3], C in [1, 2, 3].", "startOffset": 172, "endOffset": 181}], "year": 2016, "abstractText": "This paper presents a Directed Controller Synthesis (DCS) technique for discrete event systems. The DCS method explores the solution space for reactive controllers guided by a domain-independent heuristic. The heuristic is derived from an efficient abstraction of the environment based on the componentized way in which complex environments are described. Then by building the composition of the components on-the-fly DCS obtains a solution by exploring a reduced portion of the state space. This work focuses on untimed discrete event systems with safety and co-safety (i.e. reachability) goals. An evaluation for the technique is presented comparing it to other well-known approaches to controller synthesis (based on symbolic representation and compositional analyses).", "creator": "LaTeX with hyperref package"}}}