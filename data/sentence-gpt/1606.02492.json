{"id": "1606.02492", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2016", "title": "Convolutional Neural Fabrics", "abstract": "Despite the success of convolutional neural networks, selecting the optimal architecture for a given task remains an open problem. Instead of aiming to select a single optimal architecture, we propose a $\"$fabric$\"$ that embeds an exponentially large number of CNN architectures. The fabric consists of a 3D trellis that connects response maps at different layers, scales, and channels with a sparse homogeneous local connectivity pattern, which is used by most convolutional neural networks. After the integration of an appropriate local network, the fabric was built on an \"optimal architecture\" for a particular task.\n\n\n\n\nA common task for convolutional neural networks is selecting the optimal architecture for a given task. In the first few stages of development, it is not always possible to select the optimal architecture for a given task. The first stage of development, where you choose an optimal architecture, is to select the optimal architecture for a given task and then select the optimal architecture for a given task.\nWe consider the optimal architecture for a given task as follows:\nThe first stage of a task is selected through a random selection of layers. The second stage is selected by random selection. As the network becomes denser and denser, each layer of network grows as it becomes denser, and each layer of network grows as the network becomes denser. A layer of network will grow as its weight decreases. The network will grow as its weight decreases. The network will grow as its weight decreases.\nAs a result, the average complexity of the network grows, the average complexity of the network grows, and the average complexity of the network grows.\nThe most common optimization task, which involves random selection, is choosing the optimal architecture for a given task. In each step of development, the best optimization task, which involves random selection, is choosing a suitable architecture for a given task.\nThe most common optimization task, which involves random selection, is choosing a suitable architecture for a given task. In each step of development, the best optimization task, which involves random selection, is choosing a suitable architecture for a given task. In each step of development, the best optimization task, which involves random selection, is choosing a suitable architecture for a given task. In each step of development, the most common optimization task, which involves random selection, is choosing a suitable architecture for a given task.\nThe most common optimization task, which involves random selection, is choosing a suitable architecture for a given task. In each step of development, the", "histories": [["v1", "Wed, 8 Jun 2016 10:17:51 GMT  (655kb,D)", "https://arxiv.org/abs/1606.02492v1", null], ["v2", "Thu, 9 Jun 2016 16:21:57 GMT  (663kb,D)", "http://arxiv.org/abs/1606.02492v2", "Added Supplementary Material"], ["v3", "Fri, 28 Oct 2016 13:10:05 GMT  (1786kb,D)", "http://arxiv.org/abs/1606.02492v3", "Added Final version (To appear at NIPS16 )"], ["v4", "Mon, 30 Jan 2017 12:28:29 GMT  (1770kb,D)", "http://arxiv.org/abs/1606.02492v4", "Corrected typos (In proceedings of NIPS16 )"]], "reviews": [], "SUBJECTS": "cs.CV cs.LG cs.NE", "authors": ["shreyas saxena", "jakob verbeek"], "accepted": true, "id": "1606.02492"}, "pdf": {"name": "1606.02492.pdf", "metadata": {"source": "META", "title": "Convolutional Neural Fabrics", "authors": ["Shreyas Saxena", "Jakob Verbeek", "Jean Kuntzmann"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Convolutional neural networks (CNNs) [15] have proven extremely successful for a wide range of computer vision problems and other applications. In particular, the results of Krizhevsky et al . [13] have caused a major paradigm shift in computer vision from models relying in part on hand-crafted features, to end-to-end trainable systems from the pixels upwards. One of the main problems that holds back further progress using CNNs, as well as deconvolutional variants [24, 26] used for semantic segmentation, is the lack of efficient systematic ways to explore the discrete and exponentially large architecture space. To appreciate the number of possible architectures, consider a standard chain-structured CNN architecture for image classification. The architecture is determined by the following hyper-parameters: (i) number of layers, (ii) number of channels per layer, (iii) filter size per layer, (iv) stride per layer, (v) number of pooling vs . convolutional layers, (vi) type of pooling operator per layer, (vii) size of the pooling regions, (viii) ordering of pooling and convolutional layers, (ix) channel connectivity pattern between layers, and (x) type of activation, e.g . ReLU or MaxOut, per layer. The number of resulting architectures clearly does not allow for (near) exhaustive exploration.\nWe show that all network architectures that can be obtained for various choices of the above ten hyper-parameters are embedded in a \u201cfabric\u201d of convolution and pooling operators. Concretely, the fabric is a three-dimensional trellis of response maps of various resolutions, with only local connections across neighboring layers, scales, and channels. See Figure 1 for a schematic illustration of how fabrics embed different architectures. Each activation in a fabric is computed as a linear function followed by a non-linearity from a multi-dimensional neighborhood (spatial/temporal input dimensions, a scale dimension and a channel dimension) in the previous layer. Setting the only two hyper-parameters, number of layers and channels, is not ciritical as long as they are large enough. We also consider two variants, one in which the channels are fully connected instead of sparsely, and another in which the number of channels doubles if we move to a coarser scale. The latter allows for one to two orders of magnitude more channels, while increasing memory requirements by only 50%.\nAll chain-structured network architectures embedded in the fabric can be recovered by appropriately setting certain connections to zero, so that only a single processing path is active between input and output. General, non-path, weight settings correspond to ensembling many architectures together,\nar X\niv :1\n60 6.\n02 49\n2v 4\n[ cs\n.C V\n] 3\n0 Ja\nn 20\n17\nwhich share parameters where the paths overlap. The acyclic trellis structure allows for learning using standard error back-propagation methods. Learning can thus efficiently configure the fabric to implement each one of exponentially many embedded architectures, as well as ensembles of them. Experimental results competitive with the state of the art validate the effectiveness of our approach.\nThe contributions of our work are: (1) Fabrics allow by and large to sidestep the CNN model architecture selection problem. Avoiding explicitly training and evaluating individual architectures using, e.g ., local-search strategies [2]. (2) While scaling linearly in terms of computation and memory requirements, our approach leverages exponentially many chain-structured architectures in parallel by massively sharing weights among them. (3) Since our fabric is multi-scale by construction, it can naturally generate output at multiple resolutions, e.g. for image classification and semantic segmentation or multi-scale object detection, within a single non-branching network structure."}, {"heading": "2 Related work", "text": "Several chain-structured CNN architectures, including Alex-net [13] and the VGG-16 and VGG-19 networks [27], are widely used for image classification and related tasks. Although very effective, it is not clear that these architectures are the best ones given their computational and memory requirements. Their widespread adoption is in large part due to the lack of more effective methods to find good architectures than trying them one-by-one, possibly initializing parameters from related ones [2].\nCNN architectures for semantic segmentation, as well as other structured prediction tasks such as human pose estimation [25], are often derived from ones developed for image classification, see e.g. [20, 24, 31, 33]. Up-sampling operators are used to increase the resolution of the output, compensating for pooling operators used in earlier layers of the network [24]. Ronneberger et al . [26] present a network with additional links that couple layers with the same resolution near the input and output. Other architectures, see e.g . [3, 7], process the input in parallel across several resolutions, and then fuse all streams by re-sampling to the output resolution. Such architectures induce networks with multiple parallel paths from input to output. We will show that nearly all such networks are embedded in our fabrics, either as paths or other simple sub-graphs.\nWhile multi-dimensional networks have been proposed in the past, e.g. to process non-sequential data with recurrent nets [5, 11], to the best of our knowledge they have not been explored as a \u201cbasis\u201d to span large classes of convolutional neural networks. Misra et al . [23] propose related cross-stitch networks that exchange information across corresponding layers of two copies of the same architecture that produces two different outputs. Their approach is based on Alex-net [13], and does not address the network architecture selection problem. In related work Zhou et al . [34] interlink CNNs that take input from re-scaled versions of the input image. The structure of their network is related to our fabric, but lacks a sparse connectivity pattern across channels. They consider their networks for semantic segmentation, and set the filter sizes per node manually, and\nuse strided max-pooling for down-sampling and nearest neighbor interpolation for up-sampling. The contribution of our work is to show that a similar network structure suffice to span a vast class of network architectures for both dense prediction and classification tasks.\nSpringenberg et al . [29] experimentally observed that the use of max-pooling in CNN architectures is not always beneficial as opposed to using strided convolutions. In our work we go one step further and show that ReLU units and strided convolutions suffice to implement max-pooling operators in our fabrics. Their work, similar to ours, also strives to simplify architecture design. Our results, however, reach much further than only removing pooling operators from the architectural elements. Lee et al . [17] generalize the max and average pooling operators by computing both max and average pooling, and then fusing the result in a possibly data-driven manner. Our fabrics also generalize max and average pooling, but instead of adding elementary operators, we show that settings weights in a network with fewer elementary operators is enough for this generalization.\nKulkarni et al . [14] use `1 regularization to automatically select the number of units in \u201cfullyconnected\u201d layers of CNN architectures for classification. Although their approach does not directly extend to determine more general architectural design choices, it might be possible to use such regularization techniques to select the number of channels and/or layers of our fabrics.\nDropout [30] and swapout [28] are stochastic training methods related to our work. They can be understood as approximately averaging over an exponential number of variations of a given architecture. Our approach, on the other hand, allows to leverage an exponentially large class of architectures (ordering of pooling and convolutional layers, type of pooling operator, etc .) by means of continuous optimization. Note that these approaches are orthogonal and can be applied to fabrics."}, {"heading": "3 The fabric of convolutional neural networks", "text": "In this section we give a precise definition of convolutional neural fabrics, and show in Section 3.2 that most architectural network design choices become irrelevant for sufficiently large fabrics. Finally, we analyze the number of response maps, parameters, and activations of fabrics in Section 3.3."}, {"heading": "3.1 Weaving the convolutional neural fabric", "text": "Each node in the fabric represents one response map with the same dimension D as the input signal (D = 1 for audio, D = 2 for images, D = 3 for video). The fabric over the nodes is spanned by three axes. A layer axis along which all edges advance, which rules out any cycles, and which is analogous to the depth axis of a CNN. A scale axis along which response maps of different resolutions are organized from fine to coarse, neighboring resolutions are separated by a factor two. A channel axis along which different response maps of the same scale and layer are organized. We use S = 1+ log2 N scales when we process inputs of size N\nD, e.g . for 32\u00d732 images we use six scales, so as to obtain a scale pyramid from the full input resolution to the coarsest 1\u00d71 response maps. We now define a sparse and homogeneous edge structure. Each node is connected to a 3\u00d73 scale\u2013 channel neighborhood in the previous layer, i.e. activations at channel c, scale s, and layer l are computed as a(s, c, l) = \u2211 i,j\u2208{\u22121,0,1} conv ( a(c + i, s + j, l \u2212 1), wijscl ) . Input from a finer scale is obtained via strided convolution, and input from a coarser scale by convolution after upsampling by padding zeros around the activations at the coarser level. All convolutions use kernel size 3. Activations are thus a linear function over multi-dimensional neighborhoods, i.e . a four dimensional 3\u00d73\u00d73\u00d73 neighborhood when processing 2D images. The propagation is, however, only convolutional across the input dimensions, and not across the scale and layer axes. The \u201cfully connected\u201d layers of a CNN correspond to nodes along the coarsest 1\u00d71 scale of the fabric. Rectified linear units (ReLUs) are used at all nodes. Figure 1 illustrates the connectivity pattern in 2D, omitting the channel dimension for clarity. The supplementary material contains an illustration of the 3D fabric structure.\nAll channels in the first layer at the input resolution are connected to all channels of the input signal. The first layer contains additional edges to distribute the signal across coarser scales, see the vertical edges in Figure 1. More precisely, within the first layer, channel c at scale s receives input from channels c+ {\u22121, 0, 1} from scale s\u2212 1. Similarly, edges within the last layer collect the signal towards the output. Note that these additional edges do not create any cycles, and that the edge-structure within the first and last layer is reminiscent of the 2D trellis in Figure 1."}, {"heading": "3.2 Stitching convolutional neural networks on the fabric", "text": "We now demonstrate how various architectural choices can be \u201cimplemented\u201d in fabrics, demonstrating they subsume an exponentially large class of network architectures. Learning will configure a fabric to behave as one architecture or another, but more generally as an ensemble of many of them. For all but the last of the following paragraphs, it is sufficient to consider a 2D trellis, as in Figure 1, where each node contains the response maps of C channels with dense connectivity among channels.\nRe-sampling operators. A variety of re-sampling operators is available in fabrics, here we discuss ones with small receptive fields, larger ones are obtained by repetition. Stride-two convolutions are used in fabrics on fine-to-coarse edges, larger strides are obtained by repetition. Average pooling is obtained in fabrics by striding a uniform filter. Coarse-to-fine edges in fabrics up-sample by padding zeros around the coarse activations and then applying convolution. For factor-2 bilinear interpolation we use a filter that has 1 in the center, 1/4 on corners, and 1/2 elsewhere. Nearest neighbor interpolation is obtained using a filter that is 1 in the four top-left entries and zero elsewhere.\nFor max-pooling over a 2\u00d7 2 region, let a and b represent the values of two vertically neighboring pixels. Use one layer and three channels to compute (a + b)/2, (a \u2212 b)/2, and (b \u2212 a)/2. After ReLU, a second layer can compute the sum of the three terms, which equals max(a, b). Each pixel now contains the maximum of its value and that of its vertical neighbor. Repeating the same in the horizontal direction, and sub-sampling by a factor two, gives the output of 2\u00d72 max-pooling. The same process can also be used to show that a network of MaxOut units [4] can be implemented in a network of ReLU units. Although ReLU and MaxOut are thus equivalent in terms of the functions they can implement, for training efficiency it may be more advantageous to use MaxOut networks.\nFilter sizes. To implement a 5\u00d7 5 filter we first compute nine intermediate channels to obtain a vectorized version of the 3\u00d73 neighborhood at each pixel, using filters that contain a single 1, and are zero elsewhere. A second 3\u00d73 convolution can then aggregate values across the original 5\u00d75 patch, and output the desired convolution. Any 5\u00d75 filter can be implemented exactly in this way, not only approximated by factorization, c.f . [27]. Repetition allows to obtain filters of any desired size.\nOrdering convolution and re-sampling. As shown in Figure 1, chain-structured networks correspond to paths in our fabrics. If weights on edges outside a path are set to zero, a chain-structured network with a particular sequencing of convolutions and re-sampling operators is obtained. A trellis that spans S + 1 scales and L+ 1 layers contains more than ( L S ) chain-structured CNNs, since this corresponds to the number of ways to spread S sub-sampling operators across the L steps to go from the first to the last layer. More CNNs are embedded, e.g. by exploiting edges within the first and last layer, or by including intermediate up-sampling operators. Networks beyond chain-structured ones, see e.g . [3, 20, 26], are also embedded in the trellis, by activating a larger subset of edges than a single path, e.g . a tree structure for the multi-scale net of [3].\nChannel connectivity pattern. Although most networks in the literature use dense connectivity across channels between successive layers, this is not a necessity. Krizhevsky et al . [13], for example, use a network that is partially split across two independent processing streams.\nIn Figure 2 we demonstrate that a fabric which is sparsely connected along the channel axis, suffices to emulate densely connected convolutional layers. This is achieved by copying channels, convolving them, and then locally aggregating them. Both the copy and sum process are based on local channel interactions and convolutions with filters that are either entirely zero, or identity filters which are all zero except for a single 1 in the center. While more efficient constructions exist to represent the densely connected layer in our trellis, the one presented here is simple to understand and suffices to demonstrate feasibility. Note that in practice learning automatically configures the trellis.\nBoth the copy and sum process generally require more than one layer to execute. In the copying process, intermediate ReLUs do not affect the result since the copied values themselves are non-negative outputs of ReLUs. In the convolve-and-sum process care has to be taken since one convolution might give negative outputs, even if the sum of convolutions is positive. To handle this correctly, it suffices to shift the activations by subtracting from the bias of every convolution i the minimum possible corresponding output amini (which always exists for a bounded input domain). Using the adjusted bias, the output of the convolution is now guaranteed to be non-negative, and to propagate properly in the copy and sum process. In the last step of summing the convolved channels, we can add back\u2211\ni a min i to shift the activations back to recover the desired sum of convolved channels."}, {"heading": "3.3 Analysis of the number of parameters and activations", "text": "For our analysis we ignore border effects, and consider every node to be an internal one. In the top row of Table 1 we state the total number of response maps throughout the fabric, and the number of parameters when channels are sparsely or densely connected. We also state the number of activations, which determines the memory usage of back-propagation during learning.\nWhile embedding an exponential number of architectures in the number of layers L and channels C, the number of activations and thus the memory cost during learning grows only linearly in C and L. Since each scale reduces the number of elements by a factor 2D, the total number of elements across scales is bounded by 2D/(2D \u2212 1) times the number of elements ND at the input resolution. The number of parameters is linear in the number of layers L, and number of scales S. For sparsely connected channels, the number of parameters grows also linearly with the number of channels C , while it grows quadratically with C in case of dense connectivity.\nAs an example, the largest models we trained for 32\u00d732 input have L = 16 layers and C = 256 channels, resulting in 2M parameters (170M for dense), and 6M activations. For 256\u00d7256 input we used upto L = 16 layers and C = 64 channels, resulting in 0.7 M parameters (16M for dense), and 89M activations. For reference, the VGG-19 model has 144M parameters and 14M activations.\nChannel-doubling fabrics. Doubling the number of channels when moving to coarser scales is used in many well-known architectures, see e.g . [26, 27]. In the second row of Table 1 we analyze fabrics with channel-doubling instead of a constant number of channels per scale. This results in C2S channels throughout the scale pyramid in each layer, instead of CS when using a constant number of channels per scale, where we use C to denote the number of \u201cbase channels\u201d at the finest resolution. For 32\u00d732 input images the total number of channels is roughly 11\u00d7 larger, while for 256\u00d7256 images we get roughly 57\u00d7 more channels. The last column of Table 1 shows that the number of activations, however, grows only by 50% due to the coarsening of the maps.\nWith dense channel connections and 2D data, the amount of computation per node is constant, as at a coarser resolution there are 4\u00d7 less activations, but interactions among 2\u00d72 more channels. Therefore, in such fabrics the amount of computation grows linearly in the number of scales as compared to a single embedded CNN. For sparse channel connections, we adapt the local connectivity pattern between nodes to accommodate for the varying number channels per scale, see Figure 3 for an illustration. Each node still connects to nine other nodes at the previous layer: two inputs from scale s\u2212 1, three from scale s, and four from scale s+ 1. The computational cost thus also grows only\nby 50% as compared to using a constant number of channels per scale. In this case, the number of parameters grows by the same factor 2S/S as the number of channels. In case of dense connections, however, the number of parameters explodes with a factor 7184\nS/S. That is, roughly a factor 265 for 32\u00d732 input, and 11,327 for 256\u00d7256 input. Therefore, channel-doubling fabrics appear most useful with sparse channel connectivity. Experiments with channel-doubling fabrics are left for future work."}, {"heading": "4 Experimental evaluation results", "text": "In this section we first present the datasets used in our experiments, followed by evaluation results."}, {"heading": "4.1 Datasets and experimental protocol", "text": "Part Labels dataset. This dataset [10] consists of 2,927 face images from the LFW dataset [8], with pixel-level annotations into the classes hair, skin, and background. We use the standard evaluation protocol which specifies training, validation and test sets of 1,500, 500 and 927 images, respectively. We report accuracy at pixel-level and superpixel-level. For superpixel we average the class probabilities over the contained pixels. We used horizontal flipping for data augmentation.\nMNIST. This dataset [16] consists of 28\u00d728 pixel images of the handwritten digits 0, . . . , 9. We use the standard split of the dataset into 50k training samples, 10k validation samples and 10k test samples. Pixel values are normalized to [0, 1] by dividing them by 255. We augment the train data by randomly positioning the original image on a 32\u00d732 pixel canvas. CIFAR10. The CIFAR-10 dataset (http://www.cs.toronto.edu/~kriz/cifar.html) consists of 50k 32\u00d732 training images and 10k testing images in 10 classes. We hold out 5k training images as validation set, and use the remaining 45k as the training set. To augment the data, we follow common practice, see e.g . [4, 18], and pad the images with zeros to a 40\u00d740 image and then take a random 32\u00d732 crop, in addition we add horizontally flipped versions of these images. Training. We train our fabrics using SGD with momentum of 0.9. After each node in the trellis we apply batch normalization [9], and regularize the model with weight decay of 10\u22124, but did not apply dropout [30]. We use the validation set to determine the optimal number of training epochs, and then train a final model from the train and validation data and report performance on the test set. We release our Caffe-based implementation at http://thoth.inrialpes.fr/~verbeek/fabrics."}, {"heading": "4.2 Experimental results", "text": "For all three datasets we trained sparse and dense fabrics with various numbers of channels and layers. In all cases we used a constant number of channels per scale. The results across all these settings can be found in Appendix A.3, here we report only the best results from these. On all three datasets, larger trellises perform comparable or better than smaller ones. So in practice the choice of these only two hyper-parameters of our model is not critical, as long as a large enough trellis is used.\nPart Labels. On this data set we obtained a super-pixel accuracy of 95.6% using both sparse and dense trellises. In Figure 4 we show two examples of predicted segmentation maps. Table 2 compares our results with the state of the art, both in terms of accuracy and the number of parameters. Our results are slightly worse than [31, 33], but the latter are based on the VGG-16 network. That network has roughly 4, 000\u00d7 more parameters than our sparse trellis, and has been trained from over 1M ImageNet images. We trained our model from scratch using only 2,000 images. Moreover, [10, 19, 31] also include CRF and/or RBM models to encode spatial shape priors. In contrast, our results with convolutional neural fabrics (CNF) are obtained by predicting all pixels independently.\nMNIST. We obtain error rates of 0.48% and 0.33% with sparse and dense fabrics respectively. In Table 3 we compare our results to a selection of recent state-of-the-art work. We excluded several more accurate results reported in the literature, since they are based on significantly more elaborate data augmentation methods. Our result with a densely connected fabric is comparable to those of [32], which use similar data augmentation. Our sparse model, which has 20\u00d7 less parameters than the dense variant, yields an error of 0.48% which is slightly higher.\nCIFAR10. In Table 4 we compare our results to the state of the art. Our error rate of 7.43% with a dense fabric is comparable to that reported with MaxOut networks [4]. On this dataset the error of the sparse model, 18.89%, is significantly worse than the dense model. This is either due to a lack of capacity in the sparse model, or due to difficulties in optimization. The best error of 5.84% [22] was obtained using residual connections, without residual connections they report an error of 6.06%.\nVisualization. In Figure 5 we visualize the connection strengths of learned fabrics with dense channel connectivity. We observe qualitative differences between learned fabrics. The semantic segmentation model (left) immediately distributes the signal across the scale pyramid (first layer/column), and then progressively aggregates the multi-scale signal towards the output. In the CIFAR10 classification model the signal is progressively downsampled, exploiting multiple scales in each layer. The figure shows the result of heuristically pruning (by thresholding) the weakest connections to find a smaller sub-network with good performance. We pruned 67% of the connections while increasing the error only from 7.4% to 8.1% after fine-tuning the fabric with the remaining connections. Notice that all up-sampling connections are deactivated after pruning."}, {"heading": "5 Conclusion", "text": "We presented convolutional neural fabrics: homogeneous and locally connected trellises over response maps. Fabrics subsume a large class of convolutional networks. They allow to sidestep the tedious process of specifying, training, and testing individual network architectures in order to find the best ones. While fabrics use more parameters, memory and computation than needed for each of the individual architectures embedded in them, this is far less costly than the resources required to test all embedded architectures one-by-one. Fabrics have only two main hyper-parameters: the number of layers and the number of channels. In practice their setting is not critical: we just need a large enough fabric with enough capacity. We propose variants with dense channel connectivity, and with channel-doubling over scales. The latter strikes a very attractive capacity/memory trade-off.\nIn our experiments we study performance of fabrics for image classification on MNIST and CIFAR10, and of semantic segmentation on Part Labels. We obtain excellent results that are close to the best reported results in the literature on all three datasets. These results suggest that fabrics are competitive with the best hand-crafted CNN architectures, be it using a larger number of parameters in some cases (but much fewer on Part Labels). We expect that results can be further improved by using better optimization schemes such as Adam [12], using dropout [30] or dropconect [32] regularization, and using MaxOut units [4] or residual units [6] to facilitate training of deep fabrics with many channels.\nIn ongoing work we experiment with channel-doubling fabrics, and fabrics for joint image classification, object detection, and segmentation. We also explore channel connectivity patterns in between the sparse and dense options used here. Finally, we work on variants that are convolutional along the scale-axis so as to obtain a scale invariant processing that generalizes better across scales.\nAcknowledgment. We would like to thank NVIDIA for the donation of GPUs used in this research. This work has been partially supported by the LabEx PERSYVAL-Lab (ANR-11-LABX-0025-01)."}, {"heading": "A Supplementary Material", "text": "A.1 Fabric visualizations\nIn Figure 6 we show fabrics learned on the three datasets used in the main paper. The connection strengths are visualized by setting edge widths proportional to the mean squared filter weights related to that connection (mean across the 3\u00d7 3 weights and across all channels). The fabrics used for these visualization use dense channel connectivity.\nClearly, the learned connection patterns differ between the segmentation and the classification datasets, since output needs to be produced at different resolutions for these tasks. Interestingly, the pattern is also different between the two classification datasets. For the task of image classification, we have two models, CIFAR10 (bottom-left) and MNIST (top-right). In the case of MNIST, signal in the fabric is propagated in a band-diagonal pattern, exploiting multiple scales in each layer. With CIFAR10 we observe a similar pattern, but with a small difference. The signal is first processed at the finest scale for a few layers, and then propagated down. These results demonstrate that even for the same task, the fabric is able to configure itself in order to accommodate nuances of the dataset.\nFor the CIFAR-10 dataset we also show the pruned network, obtained by (arbitrarily) pruning all connections below the mean connection strength. After fine-tuning the pruned network, the classification error is 8.1% as compared to 7.4% for the full fabric, while removing 67% of the connections in the fabric.\nA.2 Fabric structure\nIn Figure 7 we illustrate how the multiple inputs to a node in a fabric are combined. Input from a finer scale is processed by strided convolution, from the same scale by normal convolution, and from a coarser scale by first upsampling the signal by zero padding and then convolving the signal. The three input signals are then added, and then a ReLU activation function is applied to the result.\nIn Figure 8 we illustrate the 3D fabric structure when using sparse channel connectivity. In this case, each internal node corresponds to a single response map at a given resolution. Nodes receive input from 3\u00d7 3 nodes from the scale-channel plane of the previous layer. Note that each edge represents a 3\u00d7 3 spatial convolution. Therefore, the input that projects into any \u201cneuron\u201d in the fabric is a 4D tensor of size 3\u00d7 3\u00d7 3\u00d7 3 across two spatial dimensions, a scale and a channel dimension.\nA.3 Additional experimental results\nIn Figure 9 we provide additional segmentation results on the Part Labels data set, both at superpixel and pixel level. In tables 5\u201312 we give detailed experimental results obtained using sparse and dense fabrics of different sizes, and give the corresponding number of parameters for each model.\nThe results reported here are measured on the test set, using models trained on the train set only. In the main paper results are reported on the test set using models trained from both the train and validation data. In both cases the number of training epochs has been selected to maximize performance on the validation data, when training from the train data only.\nOn all three datasets larger fabrics generally give better or comparable results as compared to smaller ones, despite relatively simple regularization by means of weight decay and early stopping. These results show that the number of channels and layers are not critical parameters of our fabrics, it simply suffices to take them large enough."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Despite the success of CNNs, selecting the optimal architecture for a given task<lb>remains an open problem. Instead of aiming to select a single optimal architecture,<lb>we propose a \u201cfabric\u201d that embeds an exponentially large number of architectures.<lb>The fabric consists of a 3D trellis that connects response maps at different layers,<lb>scales, and channels with a sparse homogeneous local connectivity pattern. The<lb>only hyper-parameters of a fabric are the number of channels and layers. While<lb>individual architectures can be recovered as paths, the fabric can in addition<lb>ensemble all embedded architectures together, sharing their weights where their<lb>paths overlap. Parameters can be learned using standard methods based on back-<lb>propagation, at a cost that scales linearly in the fabric size. We present benchmark<lb>results competitive with the state of the art for image classification on MNIST and<lb>CIFAR10, and for semantic segmentation on the Part Labels dataset.", "creator": "LaTeX with hyperref package"}}}