{"id": "1606.03476", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jun-2016", "title": "Generative Adversarial Imitation Learning", "abstract": "Consider learning a policy from example expert behavior, without interaction with the expert or access to reinforcement signal. One approach is to recover the expert's cost function with inverse reinforcement learning, then extract a policy from that cost function with reinforcement learning. This approach is indirect and can be slow. We propose a new general framework for directly extracting a policy from data, as if it were obtained by reinforcement learning following inverse reinforcement learning. We show that a certain instantiation of our framework draws an analogy between imitation learning and generative adversarial networks, from which we derive a model-free imitation learning algorithm that obtains significant performance gains over existing model-free methods in imitating complex behaviors in large, high-dimensional environments.\n\n\n\n\nOur model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-\n\n\nFor example, if we replace the model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-free model-type, we would expect that the current model-free model-free model-free model-free model-free", "histories": [["v1", "Fri, 10 Jun 2016 20:51:29 GMT  (179kb,D)", "http://arxiv.org/abs/1606.03476v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI", "authors": ["jonathan ho", "stefano ermon"], "accepted": true, "id": "1606.03476"}, "pdf": {"name": "1606.03476.pdf", "metadata": {"source": "CRF", "title": "Generative Adversarial Imitation Learning", "authors": ["Jonathan Ho", "Stefano Ermon"], "emails": ["hoj@cs.stanford.edu", "ermon@cs.stanford.edu"], "sections": [{"heading": "1 Introduction", "text": "We are interested in a specific setting of imitation learning\u2014the problem of learning to perform a task from expert demonstrations\u2014in which the learner is given only samples of trajectories from the expert, is not allowed to query the expert for more data while training, and is not provided reinforcement signal of any kind. There are two main approaches suitable for this setting: behavioral cloning [20], which learns a policy as a supervised learning problem over state-action pairs from expert trajectories; and inverse reinforcement learning [25, 18], which finds a cost function under which the expert is uniquely optimal.\nBehavioral cloning, while appealingly simple, only tends to succeed with large amounts of data, due to compounding error caused by covariate shift [23, 24]. Inverse reinforcement learning (IRL), on the other hand, learns a cost function that prioritizes entire trajectories over others, so compounding error, a problem for methods that fit single-timestep decisions, is not an issue. Accordingly, IRL has succeeded in a wide range of problems, from predicting behaviors of taxi drivers [31] to planning footsteps for quadruped robots [22].\nUnfortunately, many IRL algorithms are extremely expensive to run, requiring reinforcement learning in an inner loop. Scaling IRL methods to large environments has thus been the focus of much recent work [7, 14]. Fundamentally, however, IRL learns a cost function, which explains expert behavior but does not directly tell the learner how to act. Given that learner\u2019s true goal often is to take actions imitating the expert\u2014indeed, many IRL algorithms are evaluated on the quality of the optimal actions of the costs they learn\u2014why, then, must we learn a cost function, if doing so possibly incurs significant computational expense yet fails to directly yield actions?\nWe desire an algorithm that tells us explicitly how to act by directly learning a policy. To develop such an algorithm, we begin in Section 3, where we characterize the policy given by running reinforcement learning on a cost function learned by maximum causal entropy IRL [31, 32]. Our characterization introduces a framework for directly learning policies from data, bypassing any intermediate IRL step.\nThen, we instantiate our framework in Sections 4 and 5 with a new model-free imitation learning algorithm. We show that our resulting algorithm is intimately connected to generative adversarial\nar X\niv :1\n60 6.\n03 47\n6v 1\n[ cs\n.L G\n] 1\n0 Ju\nn 20\n16\nnetworks [9], a technique from the deep learning community that has led to recent successes in modeling distributions of natural images: our algorithm harnesses generative adversarial training to fit distributions of states and actions defining expert behavior. We test our algorithm in Section 6, where we find that it outperforms competing methods by a wide margin in training policies for complex, high-dimensional physics-based control tasks over various amounts of expert data."}, {"heading": "2 Background", "text": "Preliminaries R will denote the extended real numbers R \u222a {\u221e}. Section 3 will work with finite state and action spaces S and A to avoid technical machinery out of the scope of this paper (concerning compactness of certain sets of functions), but our algorithms and experiments later in the paper will run in high-dimensional continuous environments. \u03a0 is the set of all stationary stochastic policies that take actions in A given states in S; successor states are drawn from the dynamics model P (s\u2032|s, a). We work in the \u03b3-discounted infinite horizon setting, and we will use an expectation with respect a policy \u03c0 \u2208 \u03a0 to denote an expectation with respect to the trajectory it generates: E\u03c0[c(s, a)] , E [ \u2211\u221e t=0 \u03b3\ntc(st, at)], where s0 \u223c p0, at \u223c \u03c0(\u00b7|st), and st+1 \u223c P (\u00b7|st, at) for t \u2265 0. We will use E\u0302\u03c4 to denote empirical expectation with respect to trajectory samples \u03c4 , and we will always refer to the expert policy as \u03c0E .\nInverse reinforcement learning Suppose we are given an expert policy \u03c0E that we wish to rationalize with IRL. For the remainder of this paper, we will adopt maximum causal entropy IRL [31, 32], which fits a cost function from a family of functions C with the optimization problem\nmaximize c\u2208C ( min \u03c0\u2208\u03a0 \u2212H(\u03c0) + E\u03c0[c(s, a)] ) \u2212 E\u03c0E [c(s, a)] (1)\nwhere H(\u03c0) , E\u03c0[\u2212 log \u03c0(a|s)] is the \u03b3-discounted causal entropy [3] of the policy \u03c0. In practice, \u03c0E will only be provided as a set of trajectories sampled by executing \u03c0E in the environment, so the expected cost of \u03c0E in Eq. (1) is estimated using these samples. Maximum causal entropy IRL looks for a cost function c \u2208 C that assigns low cost to the expert policy and high cost to other policies, thereby allowing the expert policy to be found via a certain reinforcement learning procedure:\nRL(c) = arg min \u03c0\u2208\u03a0\n\u2212H(\u03c0) + E\u03c0[c(s, a)] (2)\nwhich maps a cost function to high-entropy policies that minimize the expected cumulative cost."}, {"heading": "3 Characterizing the induced optimal policy", "text": "To begin our search for an imitation learning algorithm that both bypasses an intermediate IRL step and is suitable for large environments, we will study policies found by reinforcement learning on costs learned by IRL on the largest possible set of cost functions C in Eq. (1): all functions RS\u00d7A = {c : S \u00d7 A \u2192 R}. Using expressive cost function classes, like Gaussian processes [15] and neural networks [7], is crucial to properly explain complex expert behavior without meticulously hand-crafted features. Here, we investigate the best IRL can do with respect to expressiveness, by examining its capabilities with C = RS\u00d7A. Of course, with such a large C, IRL can easily overfit when provided a finite dataset. Therefore, we will incorporate a (closed, proper) convex cost function regularizer \u03c8 : RS\u00d7A \u2192 R into our study. Note that convexity is a not particularly restrictive requirement: \u03c8 must be convex as a function defined on all of RS\u00d7A, not as a function defined on a small parameter space; indeed, the cost regularizers of Finn et al. [7], effective for a range of robotic manipulation tasks, satisfy this requirement. Interestingly, will in fact find that \u03c8 plays a central role in our discussion, not a nuisance in our analysis.\nNow, let us define an IRL primitive procedure, which finds a cost function such that the expert performs better than all other policies, with the cost regularized by \u03c8:\nIRL\u03c8(\u03c0E) = arg max c\u2208RS\u00d7A\n\u2212\u03c8(c) + (\nmin \u03c0\u2208\u03a0 \u2212H(\u03c0) + E\u03c0[c(s, a)]\n) \u2212 E\u03c0E [c(s, a)] (3)\nNow let c\u0303 \u2208 IRL\u03c8(\u03c0E). We are interested in a policy given by RL(c\u0303)\u2014this is the policy given by running reinforcement learning on the output of IRL.\nTo characterize RL(c\u0303), it will be useful to transform optimization problems over policies into convex problems. For a policy \u03c0 \u2208 \u03a0, define its occupancy measure \u03c1\u03c0 : S \u00d7 A \u2192 R as \u03c1\u03c0(s, a) = \u03c0(a|s) \u2211\u221e t=0 \u03b3\ntP (st = s|\u03c0). The occupancy measure can be interpreted as the distribution of state-action pairs that an agent encounters when navigating the environment with policy \u03c0, and it allows us to write E\u03c0[c(s, a)] = \u2211 s,a \u03c1\u03c0(s, a)c(s, a) for any cost function c. A basic result [21] is that the set of valid occupancy measures D , {\u03c1\u03c0 : \u03c0 \u2208 \u03a0} can be written as a feasible set of affine constraints: if p0(s) is the distribution of starting states and P (s\u2032|s, a) is the dynamics model, then D = { \u03c1 : \u03c1 \u2265 0 and \u2211 a \u03c1(s, a) = p0(s) + \u03b3 \u2211 s\u2032,a P (s|s\u2032, a)\u03c1(s\u2032, a) \u2200 s \u2208 S } . Furthermore, there is a one-to-one correspondence between \u03a0 and D: Proposition 3.1 (Theorem 2 of Syed et al. [29]). If \u03c1 \u2208 D, then \u03c1 is the occupancy measure for \u03c0\u03c1(a|s) , \u03c1(s, a)/ \u2211 a\u2032 \u03c1(s, a \u2032), and \u03c0\u03c1 is the only policy whose occupancy measure is \u03c1.\nWe are therefore justified in writing \u03c0\u03c1 to denote the unique policy for an occupancy measure \u03c1. We will need one more tool: for a function f : RS\u00d7A \u2192 R, its convex conjugate f\u2217 : RS\u00d7A \u2192 R is given by f\u2217(x) = supy\u2208RS\u00d7A x T y \u2212 f(y).\nNow, we are ready to characterize RL(c\u0303), the policy learned by RL on the cost recovered by IRL: Proposition 3.2. RL \u25e6 IRL\u03c8(\u03c0E) = arg min\u03c0\u2208\u03a0\u2212H(\u03c0) + \u03c8\u2217(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) (4)\nThe proof of Proposition 3.2 is in Appendix A.1. The proof relies on the observation that the optimal cost function and policy form a saddle point of a certain function. IRL finds one coordinate of this saddle point, and running reinforcement learning on the output of IRL reveals the other coordinate.\nProposition 3.2 tells us that \u03c8-regularized inverse reinforcement learning, implicitly, seeks a policy whose occupancy measure is close to the expert\u2019s, as measured by the convex function \u03c8\u2217. Enticingly, this suggests that various settings of \u03c8 lead to various imitation learning algorithms that directly solve the optimization problem given by Proposition 3.2. We explore such algorithms in Sections 4 and 5, where we show that certain settings of \u03c8 lead to both existing algorithms and a novel one.\nThe special case when \u03c8 is a constant function is particularly illuminating, so we state and show it directly using concepts from convex optimization. Corollary 3.2.1. If \u03c8 is a constant function, c\u0303 \u2208 IRL\u03c8(\u03c0E), and \u03c0\u0303 \u2208 RL(c\u0303), then \u03c1\u03c0\u0303 = \u03c1\u03c0E .\nIn other words, if there were no cost regularization at all, then the recovered policy will exactly match the expert\u2019s occupancy measure. To show this, we will need a lemma that lets us speak about causal entropies of occupancy measures: Lemma 3.1. Let H\u0304(\u03c1) = \u2212 \u2211 s,a \u03c1(s, a) log(\u03c1(s, a)/ \u2211 a\u2032 \u03c1(s, a\n\u2032)). Then, H\u0304 is strictly concave, and for all \u03c0 \u2208 \u03a0 and \u03c1 \u2208 D, we have H(\u03c0) = H\u0304(\u03c1\u03c0) and H\u0304(\u03c1) = H(\u03c0\u03c1).\nThe proof of this lemma is in Appendix A.1. Proposition 3.1 and Lemma 3.1 together allow us to freely switch between policies and occupancy measures when considering functions involving causal entropy and expected costs, as in the following lemma: Lemma 3.2. If L(\u03c0, c) = \u2212H(\u03c0) + E\u03c0[c(s, a)] and L\u0304(\u03c1, c) = \u2212H\u0304(\u03c1) + \u2211 s,a \u03c1(s, a)c(s, a), then, for all cost functions c, L(\u03c0, c) = L\u0304(\u03c1\u03c0, c) for all policies \u03c0 \u2208 \u03a0, and L\u0304(\u03c1, c) = L(\u03c0\u03c1, c) for all occupancy measures \u03c1 \u2208 D.\nNow, we are ready to give a direct proof of Corollary 3.2.1. Proof of Corollary 3.2.1. Define L\u0304(\u03c1, c) = \u2212H\u0304(\u03c1) + \u2211 s,a c(s, a)(\u03c1(s, a)\u2212 \u03c1E(s, a)). Given that \u03c8 is a constant function, we have the following, due to Lemma 3.2:\nc\u0303 \u2208 IRL\u03c8(\u03c0E) = arg max c\u2208RS\u00d7A min \u03c0\u2208\u03a0 \u2212H(\u03c0) + E\u03c0[c(s, a)]\u2212 E\u03c0E [c(s, a)] + const. (5)\n= arg max c\u2208RS\u00d7A min \u03c1\u2208D \u2212H\u0304(\u03c1) + \u2211 s,a \u03c1(s, a)c(s, a)\u2212 \u2211 s,a \u03c1E(s, a)c(s, a) = arg max c\u2208RS\u00d7A min \u03c1\u2208D L\u0304(\u03c1, c). (6)\nThis is the dual of the optimization problem\nminimize \u03c1\u2208D\n\u2212H\u0304(\u03c1) subject to \u03c1(s, a) = \u03c1E(s, a) \u2200 s \u2208 S, a \u2208 A (7)\nwith Lagrangian L\u0304, for which the costs c(s, a) serve as dual variables for equality constraints. Thus, c\u0303 is a dual optimum for (7). Because D is a convex set and \u2212H\u0304 is convex, strong duality holds; moreover, Lemma 3.1 guarantees that \u2212H\u0304 is in fact strictly convex, so the primal optimum can be uniquely recovered from the dual optimum [4, Section 5.5.5] via \u03c1\u0303 = arg min\u03c1\u2208D L\u0304(\u03c1, c\u0303) = arg min\u03c1\u2208D \u2212H\u0304(\u03c1) + \u2211 s,a c\u0303(s, a)\u03c1(s, a) = \u03c1E , where the first equality indicates that \u03c1\u0303 is the unique minimizer of L\u0304(\u00b7, c\u0303), and the third follows from the constraints in the primal problem (7). But if \u03c0\u0303 \u2208 RL(c\u0303), then, by Lemma 3.2, its occupancy measure satisfies \u03c1\u03c0\u0303 = \u03c1\u0303 = \u03c1E .\nFrom this argument, we can deduce the following:\nIRL is a dual of an occupancy measure matching problem, and the recovered cost function is the dual optimum. Classic IRL algorithms that solve reinforcement learning repeatedly in an inner loop, such as the algorithm of Ziebart et al. [31] that runs a variant of value iteration in an inner loop, can be interpreted as a form of dual ascent, in which one repeatedly solves the primal problem (reinforcement learning) with fixed dual values (costs). Dual ascent is effective if solving the unconstrained primal is efficient, but in the case of IRL, it amounts to reinforcement learning!\nThe induced optimal policy is the primal optimum. The induced optimal policy is obtained by running RL after IRL, which is exactly the act of recovering the primal optimum from the dual optimum; that is, optimizing the Lagrangian with the dual variables fixed at the dual optimum values. Strong duality implies that this induced optimal policy is indeed the primal optimum, and therefore matches occupancy measures with the expert. IRL is traditionally defined as the act of finding a cost function such that the expert policy is uniquely optimal, but now, we can alternatively view IRL as a procedure that tries to induce a policy that matches the expert\u2019s occupancy measure."}, {"heading": "4 Practical occupancy measure matching", "text": "We saw in Corollary 3.2.1 that if \u03c8 is constant, the resulting primal problem (7) simply matches occupancy measures with expert at all states and actions. Such an algorithm, however, is not practically useful. In reality, the expert trajectory distribution will be provided only as a finite set of samples, so in large environments, most of the expert\u2019s occupancy measure values will be exactly zero, and exact occupancy measure matching will force the learned policy to never visit these unseen state-action pairs simply due to lack of data. Furthermore, with large environments, we would like to use function approximation to learn a parameterized policy \u03c0\u03b8. The resulting optimization problem of finding the appropriate \u03b8 would have as many constraints as points in S \u00d7A, leading to an intractably large problem and defeating the very purpose of function approximation.\nKeeping in mind that we wish to eventually develop an imitation learning algorithm suitable for large environments, we would like to relax Eq. (7) into the following form, motivated by Proposition 3.2:\nminimize \u03c0\nd\u03c8(\u03c1\u03c0, \u03c1E)\u2212H(\u03c0) (8)\nby modifying the IRL regularizer \u03c8 so that d\u03c8(\u03c1\u03c0, \u03c1E) , \u03c8\u2217(\u03c1\u03c0\u2212\u03c1E) smoothly penalizes violations in difference between the occupancy measures.\nEntropy-regularized apprenticeship learning It turns out that with certain settings of \u03c8, Eq. (8) takes on the form of regularized variants of existing apprenticeship learning algorithms, which indeed do scale to large environments with parameterized policies [11]. For a class of cost functions C \u2282 RS\u00d7A, an apprenticeship learning algorithm finds a policy that performs better than the expert across C, by optimizing the objective\nminimize \u03c0 max c\u2208C E\u03c0[c(s, a)]\u2212 E\u03c0E [c(s, a)] (9)\nClassic apprenticeship learning algorithms restrict C to convex sets given by linear combinations of basis functions f1, . . . , fd, which give rise a feature vector f(s, a) = [f1(s, a), . . . , fd(s, a)] for each state-action pair. Abbeel and Ng [1] and Syed et al. [29] use, respectively,\nClinear = { \u2211 iwifi : \u2016w\u20162 \u2264 1} and Cconvex = { \u2211 iwifi : \u2211 iwi = 1, wi \u2265 0 \u2200i} . (10)\nClinear leads to feature expectation matching [1], which minimizes `2 distance between expected feature vectors: maxc\u2208Clinear E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = \u2016E\u03c0[f(s, a)]\u2212E\u03c0E [f(s, a)]\u20162. Meanwhile, Cconvex leads to MWAL [28] and LPAL [29], which minimize worst-case excess cost among the individual basis functions, as maxc\u2208Cconvex E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = maxi\u2208{1,...,d} E\u03c0[fi(s, a)]\u2212 E\u03c0E [fi(s, a)]. We now show how Eq. (9) is a special case of Eq. (8) with a certain setting of \u03c8. With the indicator function \u03b4C : RS\u00d7A \u2192 R, defined by \u03b4C(c) = 0 if c \u2208 C and +\u221e otherwise, we can write the apprenticeship learning objective (9) as\nmax c\u2208C E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = max c\u2208RS\u00d7A \u2212\u03b4C(c) + \u2211 s,a (\u03c1\u03c0(s, a)\u2212\u03c1\u03c0E(s, a))c(s, a) = \u03b4\u2217C(\u03c1\u03c0\u2212\u03c1\u03c0E)\nTherefore, we see that entropy-regularized apprenticeship learning minimize\n\u03c0 \u2212H(\u03c0) + max c\u2208C E\u03c0[c(s, a)]\u2212 E\u03c0E [c(s, a)] (11)\nis equivalent to performing RL following IRL with cost regularizer \u03c8 = \u03b4C , which forces the implicit IRL procedure to recover a cost function lying in C. Note that we can scale the policy\u2019s entropy regularization strength in Eq. (11) by scaling C by a constant \u03b1 as {\u03b1c : c \u2208 C}, recovering the original apprenticeship objective (9) by taking \u03b1\u2192\u221e.\nCons of apprenticeship learning It is known that apprenticeship learning algorithms generally do not recover expert-like policies if C is too restrictive [29, Section 1]\u2014which is often the case for the linear subspaces used by feature expectation matching, MWAL, and LPAL, unless the basis functions f1, . . . , fd are very carefully designed. Intuitively, unless the true expert cost function (assuming it exists) lies in C, there is no guarantee that if \u03c0 performs better than \u03c0E on all of C, then \u03c0 equals \u03c0E . With the aforementioned insight based on Proposition 3.2 that apprenticeship learning is equivalent to RL following IRL, we can understand exactly why apprenticeship learning may fail to imitate: it forces \u03c0E to be encoded as an element of C. If C does not include a cost function that explains expert behavior well, then attempting to recover a policy from such an encoding will not succeed.\nPros of apprenticeship learning While restrictive cost classes C may not lead to exact imitation, apprenticeship learning with such C can scale to large state and action spaces with policy function approximation. Ho et al. [11] rely on the following policy gradient formula for the apprenticeship objective (9) for a parameterized policy \u03c0\u03b8: \u2207\u03b8 max\nc\u2208C E\u03c0\u03b8 [c(s, a)]\u2212 E\u03c0E [c(s, a)] = \u2207\u03b8E\u03c0\u03b8 [c\u2217(s, a)] = E\u03c0\u03b8 [\u2207\u03b8 log \u03c0\u03b8(a|s)Qc\u2217(s, a)]\nwhere c\u2217= arg max c\u2208C\nE\u03c0\u03b8 [c(s, a)]\u2212 E\u03c0E [c(s, a)], Qc\u2217(s\u0304, a\u0304) = E\u03c0\u03b8 [c\u2217(s\u0304, a\u0304) | s0 = s\u0304, a0 = a\u0304] (12)\nObserving that Eq. (12) is the policy gradient for a reinforcement learning objective with cost c\u2217, Ho et al. propose an algorithm that alternates between two steps:\n1. Sample trajectories of the current policy \u03c0\u03b8i by simulating in the environment, and fit a cost function c\u2217i , as defined in Eq. (12). For the cost classes Clinear and Cconvex (10), this cost fitting amounts to evaluating simple analytical expressions [11].\n2. Form a gradient estimate with Eq. (12) with c\u2217i and the sampled trajectories, and take a trust region policy optimization (TRPO) [26] step to produce \u03c0\u03b8i+1 .\nThis algorithm relies crucially on the TRPO policy step, which is a natural gradient step constrained to ensure that \u03c0\u03b8i+1 does not stray too far \u03c0\u03b8i , as measured by KL divergence between the two policies averaged over the states in the sampled trajectories. This carefully constructed step scheme ensures that divergence does not occur due to high noise in estimating the gradient (12). We refer the reader to Schulman et al. [26] for more details on TRPO.\nWith the TRPO step scheme, Ho et al. were able train large neural network policies for apprenticeship learning with linear cost function classes (10) in environments with hundreds of observation dimensions. Their use of these linear cost function classes, however, limits their approach to settings in which expert behavior is well-described by such classes. We will draw upon their algorithm to develop an imitation learning method that both scales to large environments and imitates arbitrarily complex expert behavior. To do so, we first turn to proposing a new regularizer \u03c8 that wields more expressive power than the regularizers corresponding to Clinear and Cconvex (10)."}, {"heading": "5 Generative adversarial imitation learning", "text": "As discussed in Section 4, the constant regularizer leads to an imitation learning algorithm that exactly matches occupancy measures, but is intractable in large environments. The indicator regularizers for the linear cost function classes (10), on the other hand, lead to algorithms incapable of exactly matching occupancy measures without careful tuning, but are tractable in large environments. We propose the following new cost regularizer that combines the best of both worlds, as we will show in the coming sections:\n\u03c8GA(c) , { E\u03c0E [g(c(s, a))] if c < 0 +\u221e otherwise where g(x) = {\u2212x\u2212 log(1\u2212 ex) if x < 0 +\u221e otherwise (13)\nThis regularizer places low penalty on cost functions c that assign an amount of negative cost to expert state-action pairs; if c, however, assigns large costs (close to zero, which is the upper bound for costs feasible for \u03c8GA) to the expert, then \u03c8GA will heavily penalize c. An interesting property of \u03c8GA is that it is an average over expert data, and therefore can adjust to arbitrary expert datasets. The indicator regularizers \u03b4C , used by the linear apprenticeship learning algorithms described in Section 4, are always fixed, and cannot adapt to data as \u03c8GA can. Perhaps the most important difference between \u03c8GA and \u03b4C , however, is that \u03b4C forces costs to lie in a small subspace spanned by finitely many basis functions, whereas \u03c8GA allows for any cost function, as long as it is negative everywhere.\nOur choice of \u03c8GA is motivated by the following fact, shown in the appendix (Corollary A.1.1):\n\u03c8\u2217GA(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) = max D\u2208(0,1)S\u00d7A E\u03c0[log(D(s, a))] + E\u03c0E [log(1\u2212D(s, a))] (14)\nwhere the maximum ranges over discriminative classifiers D : S \u00d7A \u2192 (0, 1). Equation (14) is the optimal negative log loss of the binary classification problem of distinguishing between state-action pairs of \u03c0 and \u03c0E . It turns out that this optimal loss is (up to a constant shift) the Jensen-Shannon divergence DJS(\u03c1\u03c0, \u03c1\u03c0E ) , DKL (\u03c1\u03c0\u2016(\u03c1\u03c0 + \u03c1E)/2) +DKL (\u03c1E\u2016(\u03c1\u03c0 + \u03c1E)/2), which is a squared metric between distributions [9, 19]. Treating the causal entropy H as a policy regularizer, controlled by \u03bb \u2265 0, we obtain a new imitation learning algorithm:\nminimize \u03c0\n\u03c8\u2217GA(\u03c1\u03c0 \u2212 \u03c1\u03c0E )\u2212 \u03bbH(\u03c0) = DJS(\u03c1\u03c0, \u03c1\u03c0E )\u2212 \u03bbH(\u03c0), (15)\nwhich finds a policy whose occupancy measure minimizes Jensen-Shannon divergence to the expert\u2019s. Equation (15) minimizes a true metric between occupancy measures, so, unlike linear apprenticeship learning algorithms, it can imitate expert policies exactly.\nAlgorithm Equation (15) draws a connection between imitation learning and generative adversarial networks [9], which train a generative model G by having it confuse a discriminative classifier D. The job of D is to distinguish between the distribution of data generated by G and the true data distribution. When D cannot distinguish data generated by G from the true data, then G has successfully matched the true data. In our setting, the learner\u2019s occupancy measure \u03c1\u03c0 is analogous to the data distribution generated by G, and the expert\u2019s occupancy measure \u03c1\u03c0E is analogous to the true data distribution.\nNow, we present a practical algorithm, which we call generative adversarial imitation learning (Algorithm 1), for solving Eq. (15) for model-free imitation in large environments. Explicitly, we wish to find a saddle point (\u03c0,D) of the expression\nE\u03c0[log(D(s, a))] + E\u03c0E [log(1\u2212D(s, a))]\u2212 \u03bbH(\u03c0) (16)\nTo do so, we first introduce function approximation for \u03c0 and D: we will fit a parameterized policy \u03c0\u03b8, with weights \u03b8, and a discriminator network Dw : S \u00d7 A \u2192 (0, 1), with weights w. Then, we alternate between an Adam [12] gradient step on w to increase Eq. (16) with respect to D, and a TRPO step on \u03b8 to decrease Eq. (16) with respect to \u03c0. The TRPO step serves the same purpose as it does with the apprenticeship learning algorithm of Ho et al. [11]: it prevents the policy from changing too much due to noise in the policy gradient. The discriminator network can be interpreted as a local cost function providing learning signal to the policy\u2014specifically, taking a policy step that decreases expected cost with respect to the cost function c(s, a) = logD(s, a) will move toward expert-like regions of state-action space, as classified by the discriminator. (We derive an estimator for the causal entropy gradient\u2207\u03b8H(\u03c0\u03b8) in Appendix A.2.)\nAlgorithm 1 Generative adversarial imitation learning 1: Input: Expert trajectories \u03c4E \u223c \u03c0E , initial policy and discriminator parameters \u03b80, w0 2: for i = 0, 1, 2, . . . do 3: Sample trajectories \u03c4i \u223c \u03c0\u03b8i 4: Update the discriminator parameters from wi to wi+1 with the gradient\nE\u0302\u03c4i [\u2207w log(Dw(s, a))] + E\u0302\u03c4E [\u2207w log(1\u2212Dw(s, a))] (17)\n5: Take a policy step from \u03b8i to \u03b8i+1, using the TRPO rule with cost function log(Dwi+1(s, a)). Specifically, take a KL-constrained natural gradient step with\nE\u0302\u03c4i [\u2207\u03b8 log \u03c0\u03b8(a|s)Q(s, a)]\u2212 \u03bb\u2207\u03b8H(\u03c0\u03b8), where Q(s\u0304, a\u0304) = E\u0302\u03c4i [log(Dwi+1(s, a)) | s0 = s\u0304, a0 = a\u0304]\n(18)\n6: end for"}, {"heading": "6 Experiments", "text": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26]. All environments, other than the classic control tasks, were simulated with MuJoCo [30]. See Appendix B for a complete description of all the tasks.\nEach task comes with a true cost function, defined in the OpenAI Gym [5]. We first generated expert behavior for these tasks by running TRPO [26] on these true cost functions to create expert policies. Then, to evaluate imitation performance with respect to sample complexity of expert data, we sampled datasets of varying trajectory counts from the expert policies. The trajectories constituting each dataset each consisted of about 50 state-action pairs. We tested Algorithm 1 against three baselines:\n1. Behavioral cloning: a given dataset of state-action pairs is split into 70% training data and 30% validation data. The policy is trained with supervised learning, using Adam [12] with minibatches of 128 examples, until validation error stops decreasing.\n2. Feature expectation matching (FEM): the algorithm of Ho et al. [11] using the cost function class Clinear (10) of Abbeel and Ng [1]\n3. Game-theoretic apprenticeship learning (GTAL): the algorithm of Ho et al. [11] using the cost function class Cconvex (10) of Syed and Schapire [28]\nWe used all algorithms to train policies of the same neural network architecture for all tasks: two hidden layers of 100 units each, with tanh nonlinearities in between. The discriminator networks for Algorithm 1 also used the same architecture. All networks were always initialized randomly at the start of each trial. For each task, we gave FEM, GTAL, and Algorithm 1 exactly the same amount of environment interaction for training.\nFigure 1 depicts the results, and the tables in Appendix B provide exact performance numbers. We found that on the classic control tasks (cartpole, acrobot, and mountain car), behavioral cloning suffered in expert data efficiency compared to FEM and GTAL, which for the most part were able produce policies with near-expert performance with a wide range of dataset sizes. On these tasks, our generative adversarial algorithm always produced policies performing better than behavioral cloning, FEM, and GTAL. However, behavioral cloning performed excellently on the Reacher task, on which it was more sample efficient than our algorithm. We were able to slightly improve our algorithm\u2019s performance on Reacher using causal entropy regularization\u2014in the 4-trajectory setting, the improvement from \u03bb = 0 to \u03bb = 10\u22123 was statistically significant over training reruns, according to a one-sided Wilcoxon rank-sum test with p = .05. We used no causal entropy regularization for all other tasks.\nOn the other MuJoCo environments, we saw a large performance boost for our algorithm over the baselines. Our algorithm almost always achieved at least 70% of expert performance for all dataset\nsizes we tested, nearly always dominating all the baselines. FEM and GTAL performed poorly for Ant, producing policies consistently worse than a policy that chooses actions uniformly at random. Behavioral cloning was able to reach satisfactory performance with enough data on HalfCheetah, Hopper, Walker, and Ant; but was unable to achieve more than 60% for Humanoid, on which our algorithm achieved exact expert performance for all tested dataset sizes."}, {"heading": "7 Discussion and outlook", "text": "As we demonstrated, our method is generally quite sample efficient in terms of expert data. However, it is not particularly sample efficient in terms of environment interaction during training. The number of such samples required to estimate the imitation objective gradient (18) was comparable to the number needed for TRPO to train the expert policies from reinforcement signals. We believe that we could significantly improve learning speed for our algorithm by initializing policy parameters with behavioral cloning, which requires no environment interaction at all.\nFundamentally, our method is model free, so it will generally need more environment interaction than model-based methods. Guided cost learning [7], for instance, builds upon guided policy search [13] and inherits its sample efficiency, but also inherits its requirement that the model is well-approximated by iteratively fitted time-varying linear dynamics. Interestingly, both our Algorithm 1 and guided cost learning alternate between policy optimization steps and cost fitting (which we called discriminator fitting), even though the two algorithms are derived completely differently.\nOur approach builds upon a vast line of work on IRL [31, 1, 29, 28], and hence, just like IRL, our approach does not interact with the expert during training. Our method explores randomly to determine which actions bring a policy\u2019s occupancy measure closer to the expert\u2019s, whereas methods that do interact with the expert, like DAgger [24], can simply ask the expert for such actions. Ultimately, we believe that a method that combines well-chosen environment models with expert interaction will win in terms of sample complexity of both expert data and environment interaction."}, {"heading": "Acknowledgments", "text": "We thank Jayesh K. Gupta and John Schulman for assistance and advice. This work was supported by the SAIL-Toyota Center for AI Research, and by a NSF Graduate Research Fellowship (grant no. DGE-114747)."}, {"heading": "A Proofs", "text": "A.1 Proofs for Section 3\nProof of Lemma 3.1. First, we show strict concavity of H\u0304 . Let \u03c1 and \u03c1\u2032 be occupancy measures, and suppose \u03bb \u2208 [0, 1]. For all s and a, the log-sum inequality [6] implies:\n\u2212(\u03bb\u03c1(s, a) + (1\u2212 \u03bb)\u03c1\u2032(s, a)) log \u03bb\u03c1(s, a) + (1\u2212 \u03bb)\u03c1 \u2032(s, a)\u2211\na\u2032(\u03bb\u03c1(s, a \u2032) + (1\u2212 \u03bb)\u03c1\u2032(s, a\u2032))\n(19)\n= \u2212(\u03bb\u03c1(s, a) + (1\u2212 \u03bb)\u03c1\u2032(s, a)) log \u03bb\u03c1(s, a) + (1\u2212 \u03bb)\u03c1 \u2032(s, a) \u03bb \u2211 a\u2032 \u03c1(s, a \u2032) + (1\u2212 \u03bb) \u2211 a\u2032 \u03c1 \u2032(s, a\u2032)\n(20)\n\u2265 \u2212\u03bb\u03c1(s, a) log \u03bb\u03c1(s, a) \u03bb \u2211 a\u2032 \u03c1(s, a \u2032) \u2212 (1\u2212 \u03bb)\u03c1\u2032(s, a) log (1\u2212 \u03bb)\u03c1 \u2032(s, a) (1\u2212 \u03bb) \u2211 a\u2032 \u03c1 \u2032(s, a\u2032)\n(21)\n= \u03bb ( \u2212\u03c1(s, a) log \u03c1(s, a)\u2211\na\u2032 \u03c1(s, a \u2032)\n) + (1\u2212 \u03bb) ( \u2212\u03c1\u2032(s, a) log \u03c1\n\u2032(s, a)\u2211 a\u2032 \u03c1 \u2032(s, a\u2032)\n) , (22)\nwith equality if and only if \u03c0\u03c1 , \u03c1(s, a)/ \u2211 a\u2032 \u03c1(s, a \u2032) = \u03c1\u2032(s, a)/ \u2211 a\u2032 \u03c1 \u2032(s, a\u2032) , \u03c0\u03c1\u2032 . Summing both sides over all s and a shows that H\u0304(\u03bb\u03c1+ (1\u2212 \u03bb)\u03c1\u2032) \u2265 \u03bbH\u0304(\u03c1) + (1\u2212 \u03bb)H\u0304(\u03c1\u2032) with equality if and only if \u03c0\u03c1 = \u03c0\u03c1\u2032 . Applying Proposition 3.1 shows that equality in fact holds if and only if \u03c1 = \u03c1\u2032, so H\u0304 is strictly concave.\nNow, we turn to verifying the last two statements, which also follow from Proposition 3.1 and the definition of occupancy measures. First,\nH(\u03c0) = E\u03c0[\u2212 log \u03c0(a|s)] (23) = \u2212 \u2211 s,a \u03c1\u03c0(s, a) log \u03c0(a|s) (24)\n= \u2212 \u2211 s,a \u03c1\u03c0(s, a) log \u03c1\u03c0(s, a)\u2211 a\u2032 \u03c1\u03c0(s, a \u2032) (25)\n= H\u0304(\u03c1\u03c0), (26)\nand second,\nH\u0304(\u03c1) = \u2212 \u2211 s,a \u03c1(s, a) log \u03c1(s, a)\u2211 a\u2032 \u03c1(s, a \u2032) (27)\n= \u2212 \u2211 s,a \u03c1\u03c0\u03c1(s, a) log \u03c0\u03c1(a|s) (28)\n= E\u03c0\u03c1 [\u2212 log \u03c0\u03c1(a|s)] (29) = H(\u03c0\u03c1). (30)\nProof of Proposition 3.2. This proof relies on properties of saddle points. For a reference, we refer the reader to Hiriart-Urruty and Lemar\u00e9chal [10, section VII.4].\nLet c\u0303 \u2208 IRL\u03c8(\u03c0E), \u03c0\u0303 \u2208 RL(c\u0303) = RL \u25e6 IRL\u03c8(\u03c0E), and\n\u03c0A \u2208 arg min \u03c0 \u2212H(\u03c0) + \u03c8\u2217(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) (31)\n= arg min \u03c0 max c \u2212H(\u03c0)\u2212 \u03c8(c) + \u2211 s,a (\u03c1\u03c0(s, a)\u2212 \u03c1\u03c0E (s, a))c(s, a) (32)\nWe wish to show that \u03c0A = \u03c0\u0303. To do this, let \u03c1A be the occupancy measure of \u03c0A, let \u03c1\u0303 be the occupancy measure of \u03c0\u0303, and define L\u0304 : D \u00d7 RS\u00d7A \u2192 R by\nL\u0304(\u03c1, c) = \u2212H\u0304(\u03c1)\u2212 \u03c8(c) + \u2211 s,a \u03c1(s, a)c(s, a)\u2212 \u2211 s,a \u03c1\u03c0E (s, a)c(s, a). (33)\nThe following relationships then hold, due to Proposition 3.1:\n\u03c1A \u2208 arg min \u03c1\u2208D max c L\u0304(\u03c1, c), (34)\nc\u0303 \u2208 arg max c min \u03c1\u2208D L\u0304(\u03c1, c), (35)\n\u03c1\u0303 \u2208 arg min \u03c1\u2208D L\u0304(\u03c1, c\u0303). (36)\nNow D is compact and convex and RS\u00d7A is convex; furthermore, due to convexity of \u2212H\u0304 and \u03c8, we also have that L\u0304(\u00b7, c) is convex for all c, and that L\u0304(\u03c1, \u00b7) is concave for all \u03c1. Therefore, we can use minimax duality [16]:\nmin \u03c1\u2208D max c\u2208C L\u0304(\u03c1, c) = max c\u2208C min \u03c1\u2208D L\u0304(\u03c1, c) (37)\nHence, from Eqs. (34) and (35), (\u03c1A, c\u0303) is a saddle point of L\u0304, which implies that\n\u03c1A \u2208 arg min \u03c1\u2208D L\u0304(\u03c1, c\u0303). (38)\nBecause L\u0304(\u00b7, c) is strictly convex for all c (Lemma 3.1), Eqs. (36) and (38) imply \u03c1A = \u03c1\u0303. Since policies corresponding to occupancy measures are unique (Proposition 3.1), we get \u03c0A = \u03c0\u0303.\nA.2 Proofs for Section 5\nIn Eq. (13) of Section 5, we described a cost regularizer \u03c8GA, which leads to an imitation learning algorithm (15) that minimizes Jensen-Shannon divergence between occupancy measures. To justify our choice of \u03c8GA, we show how to convert certain surrogate loss functions \u03c6, for binary classification of state-action pairs drawn from the occupancy measures \u03c1\u03c0 and \u03c1\u03c0E , into cost function regularizers \u03c8, for which \u03c8\u2217(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) is the minimum expected risk R\u03c6(\u03c1\u03c0, \u03c1\u03c0E ) for \u03c6:\nR\u03c6(\u03c0, \u03c0E) = \u2211 s,a min \u03b3\u2208R \u03c1\u03c0(s, a)\u03c6(\u03b3) + \u03c1\u03c0E (s, a)\u03c6(\u2212\u03b3) (39)\nSpecifically, we will restrict ourselves to strictly decreasing convex loss functions. Nguyen et al. [19] show a correspondence between minimum expected risks R\u03c6 and f -divergences, of which Jensen-Shannon divergence is a special case. Our following construction, therefore, can generate any imitation learning algorithm that minimizes an f -divergence between occupancy measures, as long as that f -divergence is induced by a strictly decreasing convex surrogate \u03c6.\nProposition A.1. Suppose \u03c6 : R\u2192 R is a strictly decreasing convex function. Let T be the range of \u2212\u03c6, and define g\u03c6 : R\u2192 R and \u03c8\u03c6 : RS\u00d7A \u2192 R by:\ng\u03c6(x) = { \u2212x+ \u03c6(\u2212\u03c6\u22121(\u2212x)) if x \u2208 T +\u221e otherwise\n\u03c8\u03c6(c) =  \u2211 s,a \u03c1\u03c0E (s, a)g\u03c6(c(s, a)) if c(s, a) \u2208 T for all s, a\n+\u221e otherwise\n(40)\nThen, \u03c8\u03c6 is closed, proper, and convex, and RL \u25e6 IRL\u03c8\u03c6(\u03c0E) = arg min\u03c0 \u2212H(\u03c0)\u2212R\u03c6(\u03c1\u03c0, \u03c1\u03c0E ).\nProof. To verify the first claim, it suffices to check that g\u03c6(x) = \u2212x + \u03c6(\u2212\u03c6\u22121(\u2212x)) is closed, proper, and convex. Convexity follows from the fact that x 7\u2192 \u03c6(\u2212\u03c6\u22121(\u2212x)) is convex, because it is a concave function followed by a nonincreasing convex function. Furthermore, because T is nonempty, g\u03c6 is proper. To show that g\u03c6 is closed, note that because \u03c6 is strictly decreasing and convex, the range of \u03c6 is either all of R or an open interval (b,\u221e) for some b \u2208 R. If the range of \u03c6 is R, then g\u03c6 is finite everywhere and is therefore closed. On the other hand, if the range of \u03c6 is (b,\u221e), then \u03c6(x) \u2192 b as x \u2192 \u221e, and \u03c6(x) \u2192 \u221e as x \u2192 \u2212\u221e. Thus, as x \u2192 b, \u03c6\u22121(\u2212x) \u2192 \u221e, so \u03c6(\u2212\u03c6\u22121(\u2212x))\u2192\u221e too, implying that g\u03c6(x)\u2192\u221e as x\u2192 b, which means g\u03c6 is closed.\nNow, we verify the second claim. By Proposition 3.2, all we need to check is that \u2212R\u03c6(\u03c1\u03c0, \u03c1\u03c0E ) = \u03c8\u2217\u03c6(\u03c1\u03c0 \u2212 \u03c1\u03c0E ):\n\u03c8\u2217\u03c6(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) = max c\u2208C \u2211 s,a (\u03c1\u03c0(s, a)\u2212 \u03c1\u03c0E (s, a))c(s, a)\u2212 \u2211 s,a \u03c1\u03c0E (s, a)g\u03c6(c(s, a)) (41)\n= \u2211 s,a max c\u2208T (\u03c1\u03c0(s, a)\u2212 \u03c1\u03c0E (s, a))c\u2212 \u03c1\u03c0E (s, a)[\u2212c+ \u03c6(\u2212\u03c6\u22121(\u2212c))] (42)\n= \u2211 s,a max c\u2208T \u03c1\u03c0(s, a)c\u2212 \u03c1\u03c0E (s, a)\u03c6(\u2212\u03c6\u22121(\u2212c)) (43)\n= \u2211 s,a max \u03b3\u2208R \u03c1\u03c0(s, a)(\u2212\u03c6(\u03b3))\u2212 \u03c1\u03c0E (s, a)\u03c6(\u2212\u03c6\u22121(\u03c6(\u03b3))) (44)\n= \u2211 s,a max \u03b3\u2208R \u03c1\u03c0(s, a)(\u2212\u03c6(\u03b3))\u2212 \u03c1\u03c0E (s, a)\u03c6(\u2212\u03b3) (45)\n= \u2212R\u03c6(\u03c1\u03c0, \u03c1\u03c0E ) (46)\nwhere we made the change of variables c\u2192 \u2212\u03c6(\u03b3), justified because T is the range of \u2212\u03c6.\nHaving showed how to construct a cost function regularizer \u03c8\u03c6 from \u03c6, we obtain, as a corollary, a cost function regularizer for the logistic loss, whose optimal expected risk is, up to a constant, the Jensen-Shannon divergence. Corollary A.1.1. The cost regularizer (13)\n\u03c8GA(c) , { E\u03c0E [g(c(s, a))] if c < 0 +\u221e otherwise where g(x) = {\u2212x\u2212 log(1\u2212 ex) if x < 0 +\u221e otherwise\nsatisfies\n\u03c8\u2217GA(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) = max D\u2208(0,1)S\u00d7A E\u03c0[log(D(s, a))] + E\u03c0E [log(1\u2212D(s, a))]. (47)\nProof. Using the logistic loss \u03c6(x) = log(1 + e\u2212x), we see that Eq. (40) reduces to the claimed \u03c8GA. Applying Proposition A.1, we get\n\u03c8\u2217GA(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) = \u2212R\u03c6(\u03c1\u03c0, \u03c1\u03c0E ) (48)\n= \u2211 s,a max \u03b3\u2208R \u03c1\u03c0(s, a) log ( 1 1 + e\u2212\u03b3 ) + \u03c1\u03c0E (s, a) log ( 1 1 + e\u03b3 ) (49)\n= \u2211 s,a max \u03b3\u2208R \u03c1\u03c0(s, a) log ( 1 1 + e\u2212\u03b3 ) + \u03c1\u03c0E (s, a) log ( 1\u2212 1 1 + e\u2212\u03b3 ) (50)\n= \u2211 s,a max \u03b3\u2208R \u03c1\u03c0(s, a) log(\u03c3(\u03b3)) + \u03c1\u03c0E (s, a) log(1\u2212 \u03c3(\u03b3)), (51)\nwhere \u03c3(x) = 1/(1 + e\u2212x) is the sigmoid function. Because the range of \u03c3 is (0, 1), we can write\n\u03c8\u2217GA(\u03c1\u03c0 \u2212 \u03c1\u03c0E ) = \u2211 s,a max d\u2208(0,1) \u03c1\u03c0(s, a) log d+ \u03c1\u03c0E (s, a) log(1\u2212 d) (52)\n= max D\u2208(0,1)S\u00d7A \u2211 s,a \u03c1\u03c0(s, a) log(D(s, a)) + \u03c1\u03c0E (s, a) log(1\u2212D(s, a)), (53)\nwhich is the desired expression.\nWe conclude with a policy gradient formula for causal entropy. Lemma A.1. The causal entropy gradient is given by\n\u2207\u03b8E\u03c0\u03b8 [\u2212 log \u03c0\u03b8(a|s)] = E\u03c0\u03b8 [\u2207\u03b8 log \u03c0\u03b8(a|s)Qlog(s, a)] , where Qlog(s\u0304, a\u0304) = E\u03c0\u03b8 [\u2212 log \u03c0\u03b8(a|s) | s0 = s\u0304, a0 = a\u0304].\n(54)\nProof. For an occupancy measure \u03c1(s, a), define \u03c1(s) = \u2211 a \u03c1(s, a). Next,\n\u2207\u03b8E\u03c0\u03b8 [\u2212 log \u03c0\u03b8(a|s)] = \u2212\u2207\u03b8 \u2211 s,a \u03c1\u03c0\u03b8 (s, a) log \u03c0\u03b8(a|s)\n= \u2212 \u2211 s,a (\u2207\u03b8\u03c1\u03c0\u03b8 (s, a)) log \u03c0\u03b8(a|s)\u2212 \u2211 s \u03c1\u03c0\u03b8 (s) \u2211 a \u03c0\u03b8(a|s)\u2207\u03b8 log \u03c0\u03b8(a|s)\n= \u2212 \u2211 s,a (\u2207\u03b8\u03c1\u03c0\u03b8 (s, a)) log \u03c0\u03b8(a|s)\u2212 \u2211 s \u03c1\u03c0\u03b8 (s) \u2211 a \u2207\u03b8\u03c0\u03b8(a|s)\nThe second term vanishes, because \u2211 a\u2207\u03b8\u03c0\u03b8(a|s) = \u2207\u03b8 \u2211 a \u03c0\u03b8(a|s) = \u2207\u03b81 = 0. We are left with\n\u2207\u03b8E\u03c0\u03b8 [\u2212 log \u03c0\u03b8(a|s)] = \u2211 s,a (\u2207\u03b8\u03c1\u03c0\u03b8 (s, a))(\u2212 log \u03c0\u03b8(a|s)),\nwhich is the policy gradient for RL with the fixed cost function clog(s, a) , \u2212 log \u03c0\u03b8(a|s). The resulting formula is given by the standard policy gradient formula for clog."}, {"heading": "B Environments and detailed results", "text": "The environments we used for our experiments are from the OpenAI Gym [5]. The names and version numbers of these environments are listed in Table 1, which also lists dimension or cardinality of their observation and action spaces (numbers marked \u201ccontinuous\u201d indicate dimension for a continuous space, and numbers marked \u201cdiscrete\u201d indicate cardinality for a finite space).\nThe amount of environment interaction used for FEM, GTAL, and our algorithm is shown in Table 2. To reduce gradient variance for these three algorithms, we also fit value functions, with the same neural network architecture as the policies, and employed generalized advantage estimation [27] (with \u03b3 = .995 and \u03bb = .97). The exact experimental results are listed in Table 3. Means and standard deviations are computed over 50 trajectories. For the cartpole, mountain car, acrobot, and reacher, these statistics are further computed over 7 policies learned from random initializations."}], "references": [{"title": "Apprenticeship learning via inverse reinforcement learning", "author": ["P. Abbeel", "A.Y. Ng"], "venue": "Proceedings of the 21st International Conference on Machine Learning,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2004}, {"title": "Neuronlike adaptive elements that can solve difficult learning control problems", "author": ["A.G. Barto", "R.S. Sutton", "C.W. Anderson"], "venue": "Systems, Man and Cybernetics, IEEE Transactions on, (5):834\u2013846,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1983}, {"title": "Infinite time horizon maximum causal entropy inverse reinforcement learning", "author": ["M. Bloem", "N. Bambos"], "venue": "Decision and Control (CDC), 2014 IEEE 53rd Annual Conference on, pages 4911\u20134916. IEEE,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Convex optimization", "author": ["S. Boyd", "L. Vandenberghe"], "venue": "Cambridge university press,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2004}, {"title": "OpenAI Gym", "author": ["G. Brockman", "V. Cheung", "L. Pettersson", "J. Schneider", "J. Schulman", "J. Tang", "W. Zaremba"], "venue": "arXiv preprint arXiv:1606.01540,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2016}, {"title": "Elements of information theory", "author": ["T.M. Cover", "J.A. Thomas"], "venue": "John Wiley & Sons,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "Guided cost learning: Deep inverse optimal control via policy optimization", "author": ["C. Finn", "S. Levine", "P. Abbeel"], "venue": "Proceedings of the 33rd International Conference on Machine Learning,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2016}, {"title": "Rlpy: A value-function-based reinforcement learning framework for education and research", "author": ["A. Geramifard", "C. Dann", "R.H. Klein", "W. Dabney", "J.P. How"], "venue": "JMLR,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "Generative adversarial nets", "author": ["I. Goodfellow", "J. Pouget-Abadie", "M. Mirza", "B. Xu", "D. Warde-Farley", "S. Ozair", "A. Courville", "Y. Bengio"], "venue": "NIPS, pages 2672\u20132680,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2014}, {"title": "Convex Analysis and Minimization Algorithms, volume 305", "author": ["J.-B. Hiriart-Urruty", "C. Lemar\u00e9chal"], "venue": "Springer,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1996}, {"title": "Model-free imitation learning with policy optimization", "author": ["J. Ho", "J.K. Gupta", "S. Ermon"], "venue": "Proceedings of the 33rd International Conference on Machine Learning,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "Adam: A method for stochastic optimization", "author": ["D. Kingma", "J. Ba"], "venue": "arXiv preprint arXiv:1412.6980,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2014}, {"title": "Learning neural network policies with guided policy search under unknown dynamics", "author": ["S. Levine", "P. Abbeel"], "venue": "Advances in Neural Information Processing Systems, pages 1071\u20131079,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Continuous inverse optimal control with locally optimal examples", "author": ["S. Levine", "V. Koltun"], "venue": "Proceedings of the 29th International Conference on Machine Learning, pages 41\u201348,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Nonlinear inverse reinforcement learning with gaussian processes", "author": ["S. Levine", "Z. Popovic", "V. Koltun"], "venue": "Advances in Neural Information Processing Systems, pages 19\u201327,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "The minimax principle in asymptotic statistical theory", "author": ["P.W. Millar"], "venue": "Ecole d\u2019Et\u00e9 de Probabilit\u00e9s de Saint-Flour XI\u20141981, pages 75\u2013265. Springer,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1983}, {"title": "Efficient memory-based learning for robot control", "author": ["A.W. Moore", "T. Hall"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1990}, {"title": "Algorithms for inverse reinforcement learning", "author": ["A.Y. Ng", "S. Russell"], "venue": "ICML,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2000}, {"title": "On surrogate loss functions and f-divergences", "author": ["X. Nguyen", "M.J. Wainwright", "M.I. Jordan"], "venue": "The Annals of Statistics, pages 876\u2013904,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "Efficient training of artificial neural networks for autonomous navigation", "author": ["D.A. Pomerleau"], "venue": "Neural Computation, 3(1):88\u201397,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1991}, {"title": "Markov decision processes: discrete stochastic dynamic programming", "author": ["M.L. Puterman"], "venue": "John Wiley & Sons,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Learning to search: Functional gradient techniques for imitation learning", "author": ["N.D. Ratliff", "D. Silver", "J.A. Bagnell"], "venue": "Autonomous Robots, 27(1):25\u201353,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "Efficient reductions for imitation learning", "author": ["S. Ross", "D. Bagnell"], "venue": "AISTATS, pages 661\u2013668,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2010}, {"title": "A reduction of imitation learning and structured prediction to no-regret online learning", "author": ["S. Ross", "G.J. Gordon", "D. Bagnell"], "venue": "AISTATS, pages 627\u2013635,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}, {"title": "Learning agents for uncertain environments", "author": ["S. Russell"], "venue": "Proceedings of the Eleventh Annual Conference on Computational Learning Theory, pages 101\u2013103. ACM,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1998}, {"title": "Trust region policy optimization", "author": ["J. Schulman", "S. Levine", "P. Abbeel", "M. Jordan", "P. Moritz"], "venue": "Proceedings of The 32nd International Conference on Machine Learning, pages 1889\u20131897,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "High-dimensional continuous control using generalized advantage estimation", "author": ["J. Schulman", "P. Moritz", "S. Levine", "M. Jordan", "P. Abbeel"], "venue": "arXiv preprint arXiv:1506.02438,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2015}, {"title": "A game-theoretic approach to apprenticeship learning", "author": ["U. Syed", "R.E. Schapire"], "venue": "Advances in Neural Information Processing Systems, pages 1449\u20131456,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2007}, {"title": "Apprenticeship learning using linear programming", "author": ["U. Syed", "M. Bowling", "R.E. Schapire"], "venue": "Proceedings of the 25th International Conference on Machine Learning, pages 1032\u20131039,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2008}, {"title": "Mujoco: A physics engine for model-based control", "author": ["E. Todorov", "T. Erez", "Y. Tassa"], "venue": "Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pages 5026\u20135033. IEEE,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}, {"title": "Maximum entropy inverse reinforcement learning", "author": ["B.D. Ziebart", "A. Maas", "J.A. Bagnell", "A.K. Dey"], "venue": "AAAI, AAAI\u201908,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2008}, {"title": "Modeling interaction via the principle of maximum causal entropy", "author": ["B.D. Ziebart", "J.A. Bagnell", "A.K. Dey"], "venue": "ICML, pages 1255\u20131262,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 19, "context": "There are two main approaches suitable for this setting: behavioral cloning [20], which learns a policy as a supervised learning problem over state-action pairs from expert trajectories; and inverse reinforcement learning [25, 18], which finds a cost function under which the expert is uniquely optimal.", "startOffset": 76, "endOffset": 80}, {"referenceID": 24, "context": "There are two main approaches suitable for this setting: behavioral cloning [20], which learns a policy as a supervised learning problem over state-action pairs from expert trajectories; and inverse reinforcement learning [25, 18], which finds a cost function under which the expert is uniquely optimal.", "startOffset": 222, "endOffset": 230}, {"referenceID": 17, "context": "There are two main approaches suitable for this setting: behavioral cloning [20], which learns a policy as a supervised learning problem over state-action pairs from expert trajectories; and inverse reinforcement learning [25, 18], which finds a cost function under which the expert is uniquely optimal.", "startOffset": 222, "endOffset": 230}, {"referenceID": 22, "context": "Behavioral cloning, while appealingly simple, only tends to succeed with large amounts of data, due to compounding error caused by covariate shift [23, 24].", "startOffset": 147, "endOffset": 155}, {"referenceID": 23, "context": "Behavioral cloning, while appealingly simple, only tends to succeed with large amounts of data, due to compounding error caused by covariate shift [23, 24].", "startOffset": 147, "endOffset": 155}, {"referenceID": 30, "context": "Accordingly, IRL has succeeded in a wide range of problems, from predicting behaviors of taxi drivers [31] to planning footsteps for quadruped robots [22].", "startOffset": 102, "endOffset": 106}, {"referenceID": 21, "context": "Accordingly, IRL has succeeded in a wide range of problems, from predicting behaviors of taxi drivers [31] to planning footsteps for quadruped robots [22].", "startOffset": 150, "endOffset": 154}, {"referenceID": 6, "context": "Scaling IRL methods to large environments has thus been the focus of much recent work [7, 14].", "startOffset": 86, "endOffset": 93}, {"referenceID": 13, "context": "Scaling IRL methods to large environments has thus been the focus of much recent work [7, 14].", "startOffset": 86, "endOffset": 93}, {"referenceID": 30, "context": "To develop such an algorithm, we begin in Section 3, where we characterize the policy given by running reinforcement learning on a cost function learned by maximum causal entropy IRL [31, 32].", "startOffset": 183, "endOffset": 191}, {"referenceID": 31, "context": "To develop such an algorithm, we begin in Section 3, where we characterize the policy given by running reinforcement learning on a cost function learned by maximum causal entropy IRL [31, 32].", "startOffset": 183, "endOffset": 191}, {"referenceID": 8, "context": "networks [9], a technique from the deep learning community that has led to recent successes in modeling distributions of natural images: our algorithm harnesses generative adversarial training to fit distributions of states and actions defining expert behavior.", "startOffset": 9, "endOffset": 12}, {"referenceID": 30, "context": "For the remainder of this paper, we will adopt maximum causal entropy IRL [31, 32], which fits a cost function from a family of functions C with the optimization problem", "startOffset": 74, "endOffset": 82}, {"referenceID": 31, "context": "For the remainder of this paper, we will adopt maximum causal entropy IRL [31, 32], which fits a cost function from a family of functions C with the optimization problem", "startOffset": 74, "endOffset": 82}, {"referenceID": 2, "context": "where H(\u03c0) , E\u03c0[\u2212 log \u03c0(a|s)] is the \u03b3-discounted causal entropy [3] of the policy \u03c0.", "startOffset": 65, "endOffset": 68}, {"referenceID": 14, "context": "Using expressive cost function classes, like Gaussian processes [15] and neural networks [7], is crucial to properly explain complex expert behavior without meticulously hand-crafted features.", "startOffset": 64, "endOffset": 68}, {"referenceID": 6, "context": "Using expressive cost function classes, like Gaussian processes [15] and neural networks [7], is crucial to properly explain complex expert behavior without meticulously hand-crafted features.", "startOffset": 89, "endOffset": 92}, {"referenceID": 6, "context": "[7], effective for a range of robotic manipulation tasks, satisfy this requirement.", "startOffset": 0, "endOffset": 3}, {"referenceID": 20, "context": "A basic result [21] is that the set of valid occupancy measures D , {\u03c1\u03c0 : \u03c0 \u2208 \u03a0} can be written as a feasible set of affine constraints: if p0(s) is the distribution of starting states and P (s\u2032|s, a) is the dynamics model, then D = { \u03c1 : \u03c1 \u2265 0 and \u2211 a \u03c1(s, a) = p0(s) + \u03b3 \u2211 s\u2032,a P (s|s\u2032, a)\u03c1(s\u2032, a) \u2200 s \u2208 S } .", "startOffset": 15, "endOffset": 19}, {"referenceID": 28, "context": "[29]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "[31] that runs a variant of value iteration in an inner loop, can be interpreted as a form of dual ascent, in which one repeatedly solves the primal problem (reinforcement learning) with fixed dual values (costs).", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "(8) takes on the form of regularized variants of existing apprenticeship learning algorithms, which indeed do scale to large environments with parameterized policies [11].", "startOffset": 166, "endOffset": 170}, {"referenceID": 0, "context": "Abbeel and Ng [1] and Syed et al.", "startOffset": 14, "endOffset": 17}, {"referenceID": 28, "context": "[29] use, respectively, Clinear = { \u2211 iwifi : \u2016w\u20162 \u2264 1} and Cconvex = { \u2211 iwifi : \u2211 iwi = 1, wi \u2265 0 \u2200i} .", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "Clinear leads to feature expectation matching [1], which minimizes `2 distance between expected feature vectors: maxc\u2208Clinear E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = \u2016E\u03c0[f(s, a)]\u2212E\u03c0E [f(s, a)]\u20162.", "startOffset": 46, "endOffset": 49}, {"referenceID": 27, "context": "Meanwhile, Cconvex leads to MWAL [28] and LPAL [29], which minimize worst-case excess cost among the individual basis functions, as maxc\u2208Cconvex E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = maxi\u2208{1,.", "startOffset": 33, "endOffset": 37}, {"referenceID": 28, "context": "Meanwhile, Cconvex leads to MWAL [28] and LPAL [29], which minimize worst-case excess cost among the individual basis functions, as maxc\u2208Cconvex E\u03c0[c(s, a)]\u2212E\u03c0E [c(s, a)] = maxi\u2208{1,.", "startOffset": 47, "endOffset": 51}, {"referenceID": 10, "context": "[11] rely on the following policy gradient formula for the apprenticeship objective (9) for a parameterized policy \u03c0\u03b8: \u2207\u03b8 max c\u2208C E\u03c0\u03b8 [c(s, a)]\u2212 E\u03c0E [c(s, a)] = \u2207\u03b8E\u03c0\u03b8 [c\u2217(s, a)] = E\u03c0\u03b8 [\u2207\u03b8 log \u03c0\u03b8(a|s)Qc\u2217(s, a)] where c\u2217= arg max c\u2208C E\u03c0\u03b8 [c(s, a)]\u2212 E\u03c0E [c(s, a)], Qc\u2217(s\u0304, \u0101) = E\u03c0\u03b8 [c\u2217(s\u0304, \u0101) | s0 = s\u0304, a0 = \u0101] (12)", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "For the cost classes Clinear and Cconvex (10), this cost fitting amounts to evaluating simple analytical expressions [11].", "startOffset": 117, "endOffset": 121}, {"referenceID": 25, "context": "(12) with ci and the sampled trajectories, and take a trust region policy optimization (TRPO) [26] step to produce \u03c0\u03b8i+1 .", "startOffset": 94, "endOffset": 98}, {"referenceID": 25, "context": "[26] for more details on TRPO.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "It turns out that this optimal loss is (up to a constant shift) the Jensen-Shannon divergence DJS(\u03c1\u03c0, \u03c1\u03c0E ) , DKL (\u03c1\u03c0\u2016(\u03c1\u03c0 + \u03c1E)/2) +DKL (\u03c1E\u2016(\u03c1\u03c0 + \u03c1E)/2), which is a squared metric between distributions [9, 19].", "startOffset": 202, "endOffset": 209}, {"referenceID": 18, "context": "It turns out that this optimal loss is (up to a constant shift) the Jensen-Shannon divergence DJS(\u03c1\u03c0, \u03c1\u03c0E ) , DKL (\u03c1\u03c0\u2016(\u03c1\u03c0 + \u03c1E)/2) +DKL (\u03c1E\u2016(\u03c1\u03c0 + \u03c1E)/2), which is a squared metric between distributions [9, 19].", "startOffset": 202, "endOffset": 209}, {"referenceID": 8, "context": "Algorithm Equation (15) draws a connection between imitation learning and generative adversarial networks [9], which train a generative model G by having it confuse a discriminative classifier D.", "startOffset": 106, "endOffset": 109}, {"referenceID": 11, "context": "Then, we alternate between an Adam [12] gradient step on w to increase Eq.", "startOffset": 35, "endOffset": 39}, {"referenceID": 10, "context": "[11]: it prevents the policy from changing too much due to noise in the policy gradient.", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26].", "startOffset": 163, "endOffset": 166}, {"referenceID": 7, "context": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26].", "startOffset": 176, "endOffset": 179}, {"referenceID": 16, "context": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26].", "startOffset": 198, "endOffset": 202}, {"referenceID": 26, "context": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26].", "startOffset": 331, "endOffset": 339}, {"referenceID": 25, "context": "We evaluated Algorithm 1 against baselines on 9 physics-based control tasks, ranging from lowdimensional control tasks from the classic RL literature\u2014the cartpole [2], acrobot [8], and mountain car [17]\u2014to difficult high-dimensional tasks such as a 3D humanoid locomotion, solved only recently by model-free reinforcement learning [27, 26].", "startOffset": 331, "endOffset": 339}, {"referenceID": 29, "context": "All environments, other than the classic control tasks, were simulated with MuJoCo [30].", "startOffset": 83, "endOffset": 87}, {"referenceID": 4, "context": "Each task comes with a true cost function, defined in the OpenAI Gym [5].", "startOffset": 69, "endOffset": 72}, {"referenceID": 25, "context": "We first generated expert behavior for these tasks by running TRPO [26] on these true cost functions to create expert policies.", "startOffset": 67, "endOffset": 71}, {"referenceID": 11, "context": "The policy is trained with supervised learning, using Adam [12] with minibatches of 128 examples, until validation error stops decreasing.", "startOffset": 59, "endOffset": 63}, {"referenceID": 10, "context": "[11] using the cost function class Clinear (10) of Abbeel and Ng [1] 3.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "[11] using the cost function class Clinear (10) of Abbeel and Ng [1] 3.", "startOffset": 65, "endOffset": 68}, {"referenceID": 10, "context": "[11] using the cost function class Cconvex (10) of Syed and Schapire [28]", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "[11] using the cost function class Cconvex (10) of Syed and Schapire [28]", "startOffset": 69, "endOffset": 73}, {"referenceID": 6, "context": "Guided cost learning [7], for instance, builds upon guided policy search [13] and inherits its sample efficiency, but also inherits its requirement that the model is well-approximated by iteratively fitted time-varying linear dynamics.", "startOffset": 21, "endOffset": 24}, {"referenceID": 12, "context": "Guided cost learning [7], for instance, builds upon guided policy search [13] and inherits its sample efficiency, but also inherits its requirement that the model is well-approximated by iteratively fitted time-varying linear dynamics.", "startOffset": 73, "endOffset": 77}, {"referenceID": 30, "context": "Our approach builds upon a vast line of work on IRL [31, 1, 29, 28], and hence, just like IRL, our approach does not interact with the expert during training.", "startOffset": 52, "endOffset": 67}, {"referenceID": 0, "context": "Our approach builds upon a vast line of work on IRL [31, 1, 29, 28], and hence, just like IRL, our approach does not interact with the expert during training.", "startOffset": 52, "endOffset": 67}, {"referenceID": 28, "context": "Our approach builds upon a vast line of work on IRL [31, 1, 29, 28], and hence, just like IRL, our approach does not interact with the expert during training.", "startOffset": 52, "endOffset": 67}, {"referenceID": 27, "context": "Our approach builds upon a vast line of work on IRL [31, 1, 29, 28], and hence, just like IRL, our approach does not interact with the expert during training.", "startOffset": 52, "endOffset": 67}, {"referenceID": 23, "context": "Our method explores randomly to determine which actions bring a policy\u2019s occupancy measure closer to the expert\u2019s, whereas methods that do interact with the expert, like DAgger [24], can simply ask the expert for such actions.", "startOffset": 177, "endOffset": 181}], "year": 2016, "abstractText": "Consider learning a policy from example expert behavior, without interaction with the expert or access to reinforcement signal. One approach is to recover the expert\u2019s cost function with inverse reinforcement learning, then extract a policy from that cost function with reinforcement learning. This approach is indirect and can be slow. We propose a new general framework for directly extracting a policy from data, as if it were obtained by reinforcement learning following inverse reinforcement learning. We show that a certain instantiation of our framework draws an analogy between imitation learning and generative adversarial networks, from which we derive a model-free imitation learning algorithm that obtains significant performance gains over existing model-free methods in imitating complex behaviors in large, high-dimensional environments.", "creator": "LaTeX with hyperref package"}}}