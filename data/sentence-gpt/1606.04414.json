{"id": "1606.04414", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2016", "title": "The Parallel Knowledge Gradient Method for Batch Bayesian Optimization", "abstract": "In many applications of black-box optimization, one can evaluate multiple points simultaneously, e.g. when evaluating the performances of several different neural network architectures in a parallel computing environment.\n\n\n\nIn the next section, we'll see some performance tests, e.g. where we will analyze various performance tests. This means that our test sets will not have the same performance and that our performance tests will only have some performance and that our test sets will only have the same performance.\nThis will help you improve your tests faster and better!\nIn this tutorial, we will also learn to use a different class of training methods:\nAll training methods can be learned by following the first rule.\nThe second rule in this tutorial will only be used for the training method:\nThe first rule in this tutorial will only be used for the training method:\nThe second rule in this tutorial will only be used for the training method:\nThe second rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third rule in this tutorial will only be used for the training method:\nThe third", "histories": [["v1", "Tue, 14 Jun 2016 15:12:01 GMT  (48kb)", "https://arxiv.org/abs/1606.04414v1", "12 pages, 4 figures"], ["v2", "Sat, 29 Oct 2016 05:47:09 GMT  (645kb,D)", "http://arxiv.org/abs/1606.04414v2", "12 pages, 5 figures, Neural Information Processing Systems (NIPS), 2016"], ["v3", "Sat, 21 Jan 2017 20:49:18 GMT  (646kb,D)", "http://arxiv.org/abs/1606.04414v3", "12 pages, 5 figures. Advances In Neural Information Processing Systems, pp. 3126-3134. 2016"]], "COMMENTS": "12 pages, 4 figures", "reviews": [], "SUBJECTS": "stat.ML cs.AI cs.LG", "authors": ["jian wu", "peter i frazier"], "accepted": true, "id": "1606.04414"}, "pdf": {"name": "1606.04414.pdf", "metadata": {"source": "CRF", "title": "The Parallel Knowledge Gradient Method for Batch Bayesian Optimization", "authors": ["Jian Wu", "Peter I. Frazier"], "emails": ["pf98}@cornell.edu"], "sections": [{"heading": "1 Introduction", "text": "In Bayesian optimization [19] (BO), we wish to optimize a derivative-free expensive-to-evaluate function f with feasible domain A \u2286 Rd,\nmin x\u2208A f(x),\nwith as few function evaluations as possible. In this paper, we assume that membership in the domain A is easy to evaluate and we can evaluate f only at points in A. We assume that evaluations of f are either noise-free, or have additive independent normally distributed noise. We consider the parallel setting, in which we perform more than one simultaneous evaluation of f .\nBO typically puts a Gaussian process prior distribution on the function f , updating this prior distribution with each new observation of f , and choosing the next point or points to evaluate by maximizing an acquisition function that quantifies the benefit of evaluating the objective as a function of where it is evaluated. In comparison with other global optimization algorithms, BO often finds \u201cnear optimal\u201d function values with fewer evaluations [19]. As a consequence, BO is useful when function evaluation is time-consuming, such as when training and testing complex machine learning algorithms (e.g. deep neural networks) or tuning algorithms on large-scale dataset (e.g. ImageNet) [4]. Recently, BO has become popular in machine learning as it is highly effective in tuning hyperparameters of machine learning algorithms [8, 9, 19, 22].\nMost previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26]. While in practice, we can often evaluate several different choices in parallel, such as multiple machines can simultaneously train the machine learning algorithm with different sets of hyperparameters. In this paper, we assume that we can access q \u2265 1 evaluations simultaneously at each iteration. Then we develop a new parallel acquisition function to guide where to evaluate next based on the decision-theoretical analysis.\nOur Contributions. We propose a novel batch BO method which measures the information gain of evaluating q points via a new acquisition function, the parallel knowledge gradient (q-KG). This\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n60 6.\n04 41\n4v 3\n[ st\nat .M\nL ]\n2 1\nJa n\n20 17\nmethod is derived using a decision-theoretic analysis that chooses the set of points to evaluate next that is optimal in the average-case with respect to the posterior when there is only one batch of points remaining. Naively maximizing q-KG would be extremely computationally intensive, especially when q is large, and so, in this paper, we develop a method based on infinitesimal perturbation analysis (IPA) [26] to evaluate q-KG\u2019s gradient efficiently, allowing its efficient optimization. In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3]. q-KG provides especially large value when function evaluations are noisy. The code in this paper is available at https://github.com/wujian16/qKG.\nThe rest of the paper is organized as follows. Section 2 reviews related work. Section 3 gives background on Gaussian processes and defines notation used later. Section 4 proposes our new acquisition function q-KG for batch BO. Section 5 provides our computationally efficient approach to maximizing q-KG. Section 6 presents the empirical performance of q-KG and several benchmarks on synthetic functions and real problems. Finally, Section 7 concludes the paper."}, {"heading": "2 Related work", "text": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms. BO algorithms consist of two components: a statistical model describing the function and an acquisition function guiding evaluations. In practice, Gaussian Process (GP) [16] is the mostly widely used statistical model due to its flexibility and tractability. Much of the literature in BO focuses on designing good acquisition functions that reach optima with as few evaluations as possible. Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].\nRecently, a few papers have extended BO to the parallel setting, aiming to choose a batch of points to evaluate next in each iteration, rather than just a single point. [10, 19] suggests parallelizing EI by iteratively constructing a batch, in each iteration adding the point with maximal single-evaluation EI averaged over the posterior distribution of previously selected points. [10] also proposes an algorithm called \u201cconstant liar\", which iteratively constructs a batch of points to sample by maximizing singleevaluation while pretending that points previously added to the batch have already returned values.\nThere are also work extending UCB to the parallel setting. [5] proposes the GP-BUCB policy, which selects points sequentially by a UCB criterion until filling the batch. Each time one point is selected, the algorithm updates the kernel function while keeping the mean function fixed. [3] proposes an algorithm combining UCB with pure exploration, called GP-UCB-PE. In this algorithm, the first point is selected according to a UCB criterion; then the remaining points are selected to encourage the diversity of the batch. These two algorithms extending UCB do not require Monte Carlo sampling, making them fast and scalable. However, UCB criteria are usually designed to minimize cumulative regret rather than immediate regret, causing these methods to underperform in BO, where we wish to minimize simple regret.\nThe parallel methods above construct the batch of points in an iterative greedy fashion, optimizing some single-evaluation acquisition function while holding the other points in the batch fixed. The acquisition function we propose considers the batch of points collectively, and we choose the batch to jointly optimize this acquisition function. Other recent papers that value points collectively include [2] which optimizes the parallel EI by a closed-form formula, [15, 26], in which gradient-based methods are proposed to jointly optimize a parallel EI criterion, and [18], which proposes a parallel version of the ES algorithm and uses Monte Carlo Sampling to optimize the parallel ES acquisition function.\nWe compare against methods from a number of these previous papers in our numerical experiments, and demonstrate that we provide an improvement, especially in problems with noisy evaluations.\nOur method is also closely related to the knowledge gradient (KG) method [7, 17] for the non-batch (sequential) setting, which chooses the Bayes-optimal point to evaluate if only one iteration is left [17], and the final solution that we choose is not restricted to be one of the points we evaluate. (Expected improvement is Bayes-optimal if the solution is restricted to be one of the points we evaluate.) We go beyond this previous work in two aspects. First, we generalize to the parallel setting.\nSecond, while the sequential setting allows evaluating the KG acquisition function exactly, evaluation requires Monte Carlo in the parallel setting, and so we develop more sophisticated computational techniques to optimize our acquisition function. Recently, [27] studies a nested batch knowledge gradient policy. However, they optimize over a finite discrete feasible set, where the gradient of KG does not exist. As a result, their computation of KG is much less efficient than ours. Moreover, they focus on a nesting structure from materials science not present in our setting."}, {"heading": "3 Background on Gaussian processes", "text": "In this section, we state our prior on f , briefly discuss well known results about Gaussian processes (GP), and introduce notation used later. We put a Gaussian process prior over the function f : A\u2192 R, which is specified by its mean function \u00b5(x) : A\u2192 R and kernel function K(x1,x2) : A\u00d7A\u2192 R. We assume either exact or independent normally distributed measurement errors, i.e. the evaluation y(xi) at point xi satisfies\ny(xi) | f(xi) \u223c N (f(xi), \u03c32(xi)), where \u03c32 : A\u2192 R+ is a known function describing the variance of the measurement errors. If \u03c32 is not known, we can also estimate it as we do in Section 6.\nSupposing we have measured f at n points x(1:n) := {x(1),x(2), \u00b7 \u00b7 \u00b7 ,x(n)} and obtained corresponding measurements y(1:n), we can then combine these observed function values with our prior to obtain a posterior distribution on f . This posterior distribution is still a Gaussian process with the mean function \u00b5(n) and the kernel function K(n) as follows\n\u00b5(n)(x) = \u00b5(x) +K(x,x(1:n)) ( K(x(1:n),x(1:n)) + diag{\u03c32(x(1)), \u00b7 \u00b7 \u00b7 , \u03c32(x(n))} )\u22121 (y(1:n) \u2212 \u00b5(x(1:n))),\nK(n)(x1,x2) = K(x1,x2) \u2212K(x1,x(1:n)) ( K(x(1:n),x(1:n)) + diag{\u03c32(x(1)), \u00b7 \u00b7 \u00b7 , \u03c32(x(n))} )\u22121 K(x(1:n),x2).\n(3.1)\n4 Parallel knowledge gradient (q-KG)\nIn this section, we propose a novel parallel Bayesian optimization algorithm by generalizing the concept of the knowledge gradient from [7] to the parallel setting. The knowledge gradient policy in [7] for discrete A chooses the next sampling decision by maximizing the expected incremental value of a measurement, without assuming (as expected improvement does) that the point returned as the optimum must be a previously sampled point.\nWe now show how to compute this expected incremental value of an additional iteration in the parallel setting. Suppose that we have observed n function values. If we were to stop measuring now, minx\u2208A \u00b5\n(n)(x) would be the minimum of the predictor of the GP. If instead we took one more batch of samples, minx\u2208A \u00b5(n+q)(x) would be the minimum of the predictor of the GP. The difference between these quantities, minx\u2208A \u00b5(n)(x)\u2212minx\u2208A \u00b5(n+q)(x), is the increment in expected solution quality (given the posterior after n+ q samples) that results from the additional batch of samples.\nThis increment in solution quality is random given the posterior after n samples, because minx\u2208A \u00b5\n(n+q)(x) is itself a random vector due to its dependence on the outcome of the samples. We can compute the probability distribution of this difference (with more details given below), and the q-KG algorithm values the sampling decision z(1:q) := {z1, z2, \u00b7 \u00b7 \u00b7 , zq} according to its expected value, which we call the parallel knowledge gradient factor, and indicate it using the notation q-KG. Formally, we define the q-KG factor for a set of candidate points to sample z(1:q) as\nq-KG(z(1:q),A) = min x\u2208A \u00b5(n)(x)\u2212 En [ min x\u2208A \u00b5(n+q)(x)|y(z(1:q)) ] , (4.1)\nwhere En [\u00b7] := E [ \u00b7|x(1:n), y(1:n) ] is the expectation taken with respect to the posterior distribution after n evaluations. Then we choose to evaluate the next batch of q points that maximizes the parallel knowledge gradient,\nmax z(1:q)\u2282A\nq-KG(z(1:q),A). (4.2)\nBy construction, the parallel knowledge gradient policy is Bayes-optimal for minimizing the minimum of the predictor of the GP if only one decision is remaining. The q-KG algorithm will reduce to the parallel EI algorithm if function evaluations are noise-free and the final recommendation is restricted to the previous sampling decisions. Because under the two conditions above, the increment in expected solution quality will become\nmin x\u2208x(1:n) \u00b5(n)(x)\u2212 min x\u2208x(1:n)\u222az(1:q)\n\u00b5(n+q)(x) = min y(1:n) \u2212min { y(1:n), min\nx\u2208z(1:q) \u00b5(n+q)(x) } = ( min y(1:n) \u2212 min\nx\u2208z(1:q) \u00b5(n+q)(x)\n)+ ,\nwhich is exactly the parallel EI acquisition function. However, computing q-KG and its gradient is very expensive. We will address the computational issues in Section 5. The full description of the q-KG algorithm is summarized as follows.\nAlgorithm 1 The q-KG algorithm Require: the number of initial stage samples I , and the number of main stage sampling iterations N .\n1: Initial Stage: draw I initial samples from a latin hypercube design in A, x(i) for i = 1, . . . , I . 2: Main Stange: 3: for s = 1 to N do 4: Solve (A.1), i.e. get (z\u22171 , z \u2217 2 , \u00b7 \u00b7 \u00b7 , z\u2217q ) = argmaxz(1:q)\u2282Aq-KG(z(1:q),A) 5: Sample these points (z\u22171 , z \u2217 2 , \u00b7 \u00b7 \u00b7 , z\u2217q ), re-train the hyperparameters of the GP by MLE, and update the posterior distribution of f . 6: end for 7: return x\u2217 = argminx\u2208A\u00b5(I+Nq)(x).\n5 Computation of q-KG\nIn this section, we provide the strategy to maximize q-KG by a gradient-based optimizer. In Section 5.1 and Section 5.2, we describe how to compute q-KG and its gradient when A is finite in (4.1). Section 5.3 describes an effective way to discretize A in (4.1). The readers should note that there are two As here, one is in (4.1) which is used to compute the q-KG factor given a sampling decision z(1:q). The other is the feasible domain in (A.1) (z(1:q) \u2282 A) that we optimize over. We are discretizing the first A.\n5.1 Estimating q-KG when A is finite in (4.1)\nFollowing [7], we express \u00b5(n+q)(x) as \u00b5(n+q)(x) = \u00b5(n)(x) +K(n)(x, z(1:q)) ( K(n)(z(1:q), z(1:q))\n+diag{\u03c32(z(1)), \u00b7 \u00b7 \u00b7 , \u03c32(z(q))} )\u22121 ( y(z(1:q))\u2212 \u00b5(n)(z(1:q)) ) .\nBecause y(z(1:q)) \u2212 \u00b5(n)(z(1:q)) is normally distributed with zero mean and covariance matrix K(n)(z(1:q), z(1:q))+diag{\u03c32(z(1)), \u00b7 \u00b7 \u00b7 , \u03c32(z(q))}with respect to the posterior after n observations, we can rewrite \u00b5(n+q)(x) as\n\u00b5(n+q)(x) = \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq, (5.1)\nwhere Zq is a standard q-dimensional normal random vector, and\n\u03c3\u0303n(x, z (1:q)) = K(n)(x, z(1:q))(D(n)(z(1:q))T )\u22121,\nwhere D(n)(z(1:q)) is the Cholesky factor of the covariance matrix K(n)(z(1:q), z(1:q)) + diag{\u03c32(z(1)), \u00b7 \u00b7 \u00b7 , \u03c32(z(q))}. Now we can compute the q-KG factor using Monte Carlo sampling when A is finite: we can sample Zq, compute (5.1), then plug in (4.1), repeat many times and take average.\n5.2 Estimating the gradient of q-KG when A is finite in (4.1)\nIn this section, we propose an unbiased estimator of the gradient of q-KG using IPA when A is finite. Accessing a stochastic gradient makes optimization much easier. By (5.1), we express q-KG as\nq-KG(z(1:q),A) = EZq ( g(z(1:q),A, Zq) ) , (5.2)\nwhere g = minx\u2208A \u00b5(n)(x)\u2212minx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq ) . Under the condition that \u00b5 and K are continuously differentiable, one can show that (please see the details in the supplementary materials)\n\u2202\n\u2202zij q-KG(z(1:q),A) = EZq\n( \u2202\n\u2202zij g(z(1:q),A, Zq)\n) , (5.3)\nwhere zij is the jth dimension of the ith point in z(1:q). By the formula of g,\n\u2202\n\u2202zij g(z(1:q),A, Zq) =\n\u2202 \u2202zij \u00b5(n)(x\u2217(before))\u2212 \u2202 \u2202zij \u00b5(n)(x\u2217(after))\n\u2212 \u2202 \u2202zij \u03c3\u0303n(x \u2217(after), z(1:q))Zq\nwhere x\u2217(before) = argminx\u2208A\u00b5 (n)(x), x\u2217(after) = argminx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq ) , and\n\u2202\n\u2202zij \u03c3\u0303n(x\n\u2217(after), z(1:q)) = ( \u2202\n\u2202zij K(n)(x\u2217(after), z(1:q))\n) (D(n)(z(1:q))T )\u22121\n\u2212K(n)(x\u2217(after), z(1:q))(D(n)(z(1:q))T )\u22121( \u2202\n\u2202zij D(n)(z(1:q))T\n) (D(n)(z(1:q))T )\u22121.\nNow we can sample many times and take average to estimate the gradient of q-KG via (5.3). This technique is called infinitesimal perturbation analysis (IPA) in gradient estimation [14]. Since we can estimate the gradient of q-KG efficiently when A is finite, we will apply some standard gradient-based optimization algorithms, such as multi-start stochastic gradient ascent to maximize q-KG.\n5.3 Approximating q-KG when A is infinite in (4.1) through discretization\nWe have specified how to maximize q-KG when A is finite in (4.1), but usually A is infinite. In this case, we will discretize A to approximate q-KG, and then maximize over the approximate q-KG. The discretization itself is an interesting research topic [17].\nIn this paper, the discrete set An is not chosen statically, but evolves over time: specifically, we suggest drawing M samples from the global optima of the posterior distribution of the Gaussian process (please refer to [11, 18] for a description of this technique). This sample set, denoted by AMn , is then extended by the locations of previously sampled points x(1:n) and the set of candidate points z(1:q). Then (4.1) can be restated as\nq-KG(z(1:q),An) = min x\u2208An\n\u00b5(n)(x)\u2212 En [\nmin x\u2208An\n\u00b5(n+q)(x)|y(z(1:q)) ] , (5.4)\nwhere An = AMn \u222a x(1:n) \u222a z(1:q). For the experimental evaluation we recompute AMn in every iteration after updating the posterior of the Gaussian process."}, {"heading": "6 Numerical experiments", "text": "We conduct experiments in two different settings: the noise-free setting and the noisy setting. In both settings, we test the algorithms on well-known synthetic functions chosen from [1] and practical problems. Following previous literature [19], we use a constant mean prior and the ARD Mate\u0301rn 5/2 kernel. In the noisy setting, we assume that \u03c32(x) is constant across the domain A, and we estimate it together with other hyperparameters in the GP using maximum likelihood estimation (MLE). We set M = 1000 to discretize the domain following the strategy in Section 5.3. In general, the q-KG\nalgorithm performs as well or better than state-of-art benchmark algorithms on both synthetic and real problems. It performs especially well in the noisy setting.\nBefore describing the details of the empirical results, we highlight the implementation details of our method and the open-source implementations of the benchmark methods. Our implementation inherits the open-source implementation of parallel EI from the Metrics Optimization Engine [25], which is fully implemented in C++ with a python interface. We reuse their GP regression and GP hyperparameter fitting methods and implement the q-KG method in C++. Besides comparing to parallel EI in [25], we also compare our method to a well-known heuristic parallel EI implemented in Spearmint [12], the parallel UCB algorithm (GP-BUCB) and parallel UCB with pure exploration (GP-UCB-PE) both implemented in Gpoptimization [6]."}, {"heading": "6.1 Noise-free problems", "text": "In this section, we focus our attention on the noise-free setting, in which we can evaluate the objective exactly. We show that parallel knowledge gradient outperforms or is competitive with state-of-art benchmarks on several well-known test functions and tuning practical machine learning algorithms."}, {"heading": "6.1.1 Synthetic functions", "text": "First, we test our algorithm along with the benchmarks on 4 well-known synthetic test functions: Branin2 on the domain [\u221215, 15]2, Rosenbrock3 on the domain [\u22122, 2]3, Ackley5 on the domain [\u22122, 2]5, and Hartmann6 on the domain [0, 1]6. We initiate our algorithms by randomly sampling 2d + 2 points from a Latin hypercube design, where d is the dimension of the problem. Figure 5 reports the mean and the standard deviation of the base 10 logarithm of the immediate regret by running 100 random initializations with batch size q = 4.\nThe results show that q-KG is significantly better on Rosenbrock3, Ackley5 and Hartmann6, and is slightly worse than the best of the other benchmarks on Branin2. Especially on Rosenbrock3 and Ackley5, q-KG makes dramatic progress in early iterations."}, {"heading": "6.1.2 Tuning logistic regression and convolutional neural networks (CNN)", "text": "In this section, we test the algorithms on two practical problems: tuning logistic regression on the MNIST dataset and tuning CNN on the CIFAR10 dataset. We set the batch size to q = 4.\nFirst, we tune logistic regression on the MNIST dataset. This task is to classify handwritten digits from images, and is a 10-class classification problem. We train logistic regression on a training set with 60000 instances with a given set of hyperparameters and test it on a test set with 10000 instances. We tune 4 hyperparameters: mini batch size from 10 to 2000, training iterations from 100 to 10000, the `2 regularization parameter from 0 to 1, and learning rate from 0 to 1. We report the mean and standard deviation of the test error for 20 independent runs. From the results, one can see that both algorithms are making progress at the initial stage while q-KG can maintain this progress for longer and results in a better algorithm configuration in general.\nIn the second experiment, we tune a CNN on CIFAR10 dataset. This is also a 10-class classification problem. We train the CNN on the 50000 training data with certain hyperparameters and test it on the test set with 10000 instances. For the network architecture, we choose the one in tensorflow tutorial. It consists of 2 convolutional layers, 2 fully connected layers, and on top of them is a softmax layer for final classification. We tune totally 8 hyperparameters: the mini batch size from 10 to 1000, training epoch from 1 to 10, the `2 regularization parameter from 0 to 1, learning rate from 0 to 1, the kernel size from 2 to 10, the number of channels in convolutional layers from 10 to 1000, the number of hidden units in fully connected layers from 100 to 1000, and the dropout rate from 0 to 1. We report the mean and standard deviation of the test error for 5 independent runs. In this example, the q-KG is making better (more aggressive) progress than parallel EI even in the initial stage and maintain this advantage to the end. This architecture has been carefully tuned by the human expert, and achieve a test error around 14%, and our automatic algorithm improves it to around 11%."}, {"heading": "6.2 Noisy problems", "text": "In this section, we study problems with noisy function evaluations. Our results show that the performance gains over benchmark algorithms from q-KG evident in the noise-free setting are even larger in the noisy setting."}, {"heading": "6.2.1 Noisy synthetic functions", "text": "We test on the same 4 synthetic functions from the noise-free setting, and add independent gaussian noise with standard deviation \u03c3 = 0.5 to the function evaluation. The algorithms are not given this standard deviation, and must learn it from data.\nThe results in Figure 4 show that q-KG is consistently better than or at least competitive with all competing methods. Also observe that the performance advantage of q-KG is larger than for noise-free problems."}, {"heading": "6.2.2 Noisy logistic regression with small test sets", "text": "Testing on a large test set such as ImageNet is slow, especially when we must test many times for different hyperparameters. To speed up hyperparameter tuning, we may instead test the algorithm on a subset of the testing data to approximate the test error on the full set. We study the performance of our algorithm and benchmarks in this scenario, focusing on tuning logistic regression on MNIST. We train logistic regression on the full training set of 60, 000, but we test the algorithm by testing on 1, 000 randomly selected samples from the test set, which provides a noisy approximation of the test error on the full test set.\nWe report the mean and standard deviation of the test error on the full set using the hyperparameters recommended by each parallel BO algorithm for 20 independent runs. The result shows that q-KG is better than both versions of parallel EI, and its final test error is close to the noise-free test error (which is substantially more expensive to obtain). As we saw with synthetic test functions, q-KG\u2019s performance advantage in the noisy setting is wider than in the noise-free setting."}, {"heading": "Acknowledgments", "text": "The authors were partially supported by NSF CAREER CMMI-1254298, NSF CMMI-1536895, NSF IIS-1247696, AFOSR FA9550-12-1-0200, AFOSR FA9550-15-1-0038, and AFOSR FA9550-16-10046."}, {"heading": "7 Conclusions", "text": "In this paper, we introduce a novel batch Bayesian optimization method q-KG, derived from a decision-theoretical perspective, and develop a computational method to implement it efficiently. We show that q-KG outperforms or is competitive with the state-of-art benchmark algorithms on several synthetic functions and in tuning practical machine learning algorithms.\nSupplementary Material A Asynchronous q-KG Optimization\nThe (A.1) corresponds to the synchronous q-KG optimization, in which we wait for all q points from our previous batch to finish before searching for a new batch of q points. However, in some applications, we may wish to generate a new batch of points to evaluate next while p(< q) points are still being evaluated, before we have their values. This is common in training machine learning algorithms, where different machine learning models do not necessarily finish at the same time.\nmax z(1:q)\u2282A\nq-KG(z(1:q),A). (A.1)\nWe can generalize (A.1) to the asynchronous q-KG optimization. Given that p points are still under evaluation, now we would like to recommend a batch of q points to evaluate. As we did for the synchronous q-KG optimization above, now we estimate the q-KG of the combined q + p points only with respect to the q points that we need to recommend. Then we proceed the same way via gradient-based algorithms."}, {"heading": "B Speed-up analysis", "text": "Next, we compare q-KG at different levels of parallelism against the fully sequential KG algorithm. We test the algorithms with different batch sizes on two noisy synthetic functions Branin2 and Hartmann6, whose standard deviation of the noise is \u03c3 = 0.5. From the results, our parallel knowledge gradient method does provide a speed-up as q goes up."}, {"heading": "C The unbiasedness of the stochastic gradient estimator", "text": "Recall that in Section 5 of the main document, we have expressed the q-KG factor as follows, q-KG(z(1:q),A) = E ( g(z(1:q),A, Zq) ) (C.1)\nwhere the expectation is taken over Zq and\ng(z(1:q),A, Zq) = min x\u2208A \u00b5(n)(x)\u2212min x\u2208A\n( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq ) ,\n\u03c3\u0303n(x, z (1:q)) = K(n)(x, z(1:q))(D(n)(z(1:q))T )\u22121.\nThe main purpose of this section is to prove the following proposition. Proposition 1. When A is finite, under the condition that \u00b5 and K are continuous differentiable,\n\u2202\n\u2202zij q-KG(z(1:q),A) \u2223\u2223\u2223\u2223 z(1:q)=\u03b8(1:q) = E ( \u2202 \u2202zij g(z(1:q),A, Zq) ) \u2223\u2223\u2223\u2223 z(1:q)=\u03b8(1:q) , (C.2)\nwhere 1 \u2264 i \u2264 q, 1 \u2264 j \u2264 d, zij is the jth dimension of the ith point in z(1:q) and \u03b8(1:q) \u2208 the interior of Aq .\nWithout loss of generality, we assume that (1) i and j are fixed in advance and (2) A = [0, 1]d, we would like to prove that (C.2) is correct. Before proceeding, we define one more notation fA,Zq (zij) := g(z\n(1:q),A, Zq) where z(1:q) equals to \u03b8(1:q) component-wise except for zij . To prove it, we cite Theorem 1 in [14], which requires three conditions to make (C.2) valid: there exists an open neighborhood \u0398 = (0, 1) of \u03b8ij where \u03b8ij is the jth dimension of ith point in \u03b8(1:q) such that (i) fA,Zq (zij) is continuous in \u0398 for any fixed A and Zq, (ii) fA,Zq (zij) is differentiable except on a denumerable set in \u0398 for any given A and Zq, (iii) the derivative of fA,Zq (zij) (when it exists) is uniformly bounded by \u0393(Zq) for all zij \u2208 \u0398, and the expectation of \u0393(Zq) is finite.\nC.1 The proof of condition (i)\nUnder the condition that the mean function \u00b5 and the kernel function K are continuous differentiable, we see that for any given x, \u03c3\u0303n(x, z(1:q)) is continuous differentiable in z(1:q) by the result that the multiplication, the inverse (when the inverse exists) and the Cholesky operators [? ] preserve continuous differentiability. When A is finite, we see that g(z(1:q),A, Zq) = minx\u2208A \u00b5(n)(x) \u2212 minx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq )\nis continuous in z(1:q). Then fA,Zq (zij) is also continuous in zij by the definition of the function fA,Zq (zij).\nC.2 The proof of condition (ii)\nBy the expression that fA,Zq (zij) = minx\u2208A \u00b5 (n)(x) \u2212 minx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq ) , if both argminx\u2208A\u00b5 (n)(x) and argminx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq )\nare unique, then fA,Zq (zij) is differentiable at zij . We define D(A) \u2282 \u0398 to be the set that fA,Zq (zij) is not differentiable, then we see that\nD(A) \u2282 \u222ax,x\u2032\u2208A { zij \u2208 \u0398 : \u00b5(n)(x) = \u00b5(n)(x\u2032), d\u00b5(n)(x)\ndzij 6= d\u00b5\n(n)(x\u2032)\ndzij\n} \u222a\n\u222ax,x\u2032\u2208A { zij \u2208 \u0398 : hx(zij) = hx\u2032(zij), dhx(zij)\ndzij 6= dhx \u2032(zij) dzij\n}\nwhere hx(zij) := \u00b5(n)(x) + \u03c3\u0303n(x, z(1:q))Zq. \u00b5(n)(x) ( \u00b5(n)(x\u2032) ) depend on zij if x = zi (x\u2032 = zi) where zi is the ith point of z(1:q). As A is finite, we only need to show that { zij \u2208 \u0398 : \u00b5(n)(x) = \u00b5(n)(x\u2032), d\u00b5 (n)(x) dzij 6= d\u00b5 (n)(x\u2032) dzij } and{\nzij \u2208 \u0398 : hx(zij) = hx\u2032(zij), dhx(zij)dzij 6= dhx\u2032 (zij) dzij\n} is denumerable.\nDefining \u03b7(zij) := hx1(zij) \u2212 hx2(zij) on \u0398, one can see that \u03b7(zij) is continuous differentiable on \u0398. We would like to show that E := { zij \u2208 \u0398 : \u03b7(zij) = 0, d\u03b7(zij)dzij 6= 0 } is denumerable. To prove it, we will show that E contains only isolated points. Then one can use a theorem in real analysis: any set of isolated points in R is denumerable (see the proof of statement 4.2.25 on page 165 in [23]). To prove that E only contains isolated points, we use the definition of an isolated point: y \u2208 E is an isolated point of E if and only if x \u2208 E is not a limit point of E. We will prove by contradiction, suppose that y \u2208 E is a limit point of E, then it means that there exists a sequence of points y1, y2, \u00b7 \u00b7 \u00b7 all belong to E such that limn\u2192\u221e yn = zij . However, by the definition of derivative and \u03b7(yn) = \u03b7(zij) = 0, 0 6= d\u03b7(y)dy \u2223\u2223 y=zij = limn\u2192\u221e \u03b7(yn)\u2212\u03b7(zij)\nyn\u2212zij = limn\u2192\u221e 0 = 0, a contradiction. So we conclude that E only contains isolated points, so is denumerable.\nDefining \u03b4(zij) := \u00b5(n)(x1) \u2212 \u00b5(n)(x2) on \u0398, \u03b4(zij) is also continuous differentiable on \u0398, then one can similarly prove that { zij \u2208 \u0398 : \u03b4(zij) = 0, d\u03b4(zij)dzij 6= 0 } is denumerable.\nC.3 The proof of condition (iii)\nRecall that from Section 5 of the main document,\nd\ndzij f(zij ,A, Zq) =\n\u2202\n\u2202zij g(z(1:q),A, Zq)\n= \u2202 \u2202zij \u00b5(n)(x\u2217(before))\u2212 \u2202 \u2202zij \u00b5(n)(x\u2217(after))\n\u2212 \u2202 \u2202zij \u03c3\u0303n(z (1:q), x\u2217(after))Zq,\nwhere x\u2217(before) = argminx\u2208A\u00b5 (n)(x), x\u2217(after) = argminx\u2208A ( \u00b5(n)(x) + \u03c3\u0303n(x, z (1:q))Zq ) , and\n\u2202\n\u2202zij \u03c3\u0303n(z\n(1:q), x\u2217(after)) = ( \u2202\n\u2202zij K(n)(x\u2217(after), z(1:q))\n) (D(n)(z(1:q))T )\u22121\n\u2212D(n)(x\u2217(after), z(1:q))(D(n)(z(1:q))T )\u22121( \u2202\n\u2202zij D(n)(z(1:q))T\n) (D(n)(z(1:q))T )\u22121.\nWe can calculate the \u2202\u2202zij\u00b5 (n)(x) as follows\n\u2202\n\u2202zij \u00b5(n)(x) =\n{ \u2202 \u2202zij \u00b5(n)(zi) if x = zi, i.e. the ith point of z(1:q)\n0 otherwise.\nUsing the fact that \u00b5 is continuously differentiable and A is compact, then \u2202\u2202zij\u00b5 (n)(x) is bounded by some B > 0. By the result that \u2202\u2202zij \u03c3\u0303n(z (1:q), x\u2217(after)) is continous, it is bounded by a\nvector 0 \u2264 \u039b < \u221e as A is compact. Then \u2223\u2223\u2223 ddzij f(zij ,A, Zq)\u2223\u2223\u2223 \u2264 2B + \u2211qi=1 \u039bi|zi| where\nZq = (z1, \u00b7 \u00b7 \u00b7 , zq)T . And E ( \u2211q i=1 \u039bi|zi|) = \u221a 2/\u03c0 \u2211q i=1 \u039bi <\u221e."}, {"heading": "D The convergence of stochastic gradient ascent", "text": "In this section, we will prove that SGA converges to a stationary point. We follow the same idea of proving the Theorem 2 in [26].\nFirst, it requires the step size \u03b3t satisfying \u03b3t \u2192 0 as t \u2192 \u221e, \u2211\u221e t=0 \u03b3t = \u221e and \u2211\u221e t=0 \u03b3 2 t < \u221e. Second, it requires the second moment of the gradient estimator is finite. In the above section 1.3, we have show that | \u2202\u2202zij g(z (1:q),A, Zq)| \u2264 2B + \u2211q i=1 \u039bi|zi|, then E( \u2202 \u2202zij\ng(z(1:q),A, Zq))2 \u2264 4B2 + \u2211q i=1 \u039b 2 i + 4B \u221a 2/\u03c0 \u2211q i=1 \u039bi <\u221e."}], "references": [{"title": "Optimization test problems. http://www.sfu.ca/~ssurjano/optimization", "author": ["D. Bingham"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2015}, {"title": "Fast computation of the multi-points expected improvement with applications in batch selection", "author": ["C. Chevalier", "D. Ginsbourger"], "venue": "In Learning and Intelligent Optimization,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Parallel gaussian process optimization with upper confidence bound and pure exploration", "author": ["E. Contal", "D. Buffoni", "A. Robicquet", "N. Vayatis"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Deep learning: Methods and applications", "author": ["L. Deng", "D. Yu"], "venue": "Foundations and Trends in Signal Processing,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Parallelizing exploration-exploitation tradeoffs in gaussian process bandit optimization", "author": ["T. Desautels", "A. Krause", "J.W. Burdick"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Gpoptimization. https://reine.cmla.ens-cachan.fr/e.contal/ gpoptimization", "author": ["E.C. etal"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2015}, {"title": "The knowledge-gradient policy for correlated normal beliefs", "author": ["P. Frazier", "W. Powell", "S. Dayanik"], "venue": "INFORMS journal on Computing,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Bayesian optimization with inequality constraints", "author": ["J.R. Gardner", "M.J. Kusner", "Z.E. Xu", "K.Q. Weinberger", "J. Cunningham"], "venue": "In ICML,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "Bayesian optimization with unknown constraints", "author": ["M. Gelbart", "J. Snoek", "R. Adams"], "venue": "In Proceedings of the Thirtieth Conference Annual Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "Kriging is well-suited to parallelize optimization", "author": ["D. Ginsbourger", "R. Le Riche", "L. Carraro"], "venue": "In Computational Intelligence in Expensive Optimization Problems,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Predictive entropy search for efficient global optimization of black-box functions", "author": ["J.M. Hern\u00e1ndez-Lobato", "M.W. Hoffman", "Z. Ghahramani"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2014}, {"title": "Efficient global optimization of expensive black-box functions", "author": ["D.R. Jones", "M. Schonlau", "W.J. Welch"], "venue": "Journal of Global optimization,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1998}, {"title": "A unified view of the IPA, SF, and LR gradient estimation techniques", "author": ["P. L\u2019Ecuyer"], "venue": "Management Science,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1990}, {"title": "Differentiating the multipoint expected improvement for optimal batch design", "author": ["S. Marmin", "C. Chevalier", "D. Ginsbourger"], "venue": "In International Workshop on Machine Learning, Optimization and Big Data,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "Gaussian processes for machine learning", "author": ["C.E. Rasmussen"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2006}, {"title": "The correlated knowledge gradient for simulation optimization of continuous parameters using gaussian process regression", "author": ["W. Scott", "P. Frazier", "W. Powell"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2011}, {"title": "Parallel predictive entropy search for batch global optimization of expensive objective functions", "author": ["A. Shah", "Z. Ghahramani"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Practical bayesian optimization of machine learning algorithms. In Advances in neural information processing systems, pages 2951\u20132959", "author": ["J. Snoek", "H. Larochelle", "R.P. Adams"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "Input warping for bayesian optimization of non-stationary functions", "author": ["J. Snoek", "K. Swersky", "R. Zemel", "R. Adams"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "Gaussian process optimization in the bandit setting: No regret and experimental design", "author": ["N. Srinivas", "A. Krause", "M. Seeger", "S.M. Kakade"], "venue": "In Proceedings of the 27th International Conference on Machine Learning", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2010}, {"title": "Multi-task bayesian optimization. In Advances in neural information processing systems, pages 2004\u20132012", "author": ["K. Swersky", "J. Snoek", "R.P. Adams"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2013}, {"title": "Elementary real analysis", "author": ["B.S. Thomson", "J.B. Bruckner", "A.M. Bruckner"], "venue": "ClassicalReal- Analysis. com", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2008}, {"title": "Global optimization, volume 350 of lecture notes in computer science", "author": ["A. T\u00f6rn", "A. Zilinskas"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1989}, {"title": "Metrics optimization engine. http://yelp", "author": ["J. Wang", "S.C. Clark", "E. Liu", "P.I. Frazier"], "venue": "github.io/MOE/. Last accessed on 2016-01-21", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2014}, {"title": "Parallel bayesian global optimization of expensive functions", "author": ["J. Wang", "S.C. Clark", "E. Liu", "P.I. Frazier"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2015}, {"title": "Nested-batch-mode learning and stochastic optimization with an application to sequential multistage testing in materials science", "author": ["Y. Wang", "K.G. Reyes", "K.A. Brown", "C.A. Mirkin", "W.B. Powell"], "venue": "SIAM Journal on Scientific Computing,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}], "referenceMentions": [{"referenceID": 17, "context": "In Bayesian optimization [19] (BO), we wish to optimize a derivative-free expensive-to-evaluate function f with feasible domain A \u2286 R,", "startOffset": 25, "endOffset": 29}, {"referenceID": 17, "context": "In comparison with other global optimization algorithms, BO often finds \u201cnear optimal\u201d function values with fewer evaluations [19].", "startOffset": 126, "endOffset": 130}, {"referenceID": 3, "context": "ImageNet) [4].", "startOffset": 10, "endOffset": 13}, {"referenceID": 7, "context": "Recently, BO has become popular in machine learning as it is highly effective in tuning hyperparameters of machine learning algorithms [8, 9, 19, 22].", "startOffset": 135, "endOffset": 149}, {"referenceID": 8, "context": "Recently, BO has become popular in machine learning as it is highly effective in tuning hyperparameters of machine learning algorithms [8, 9, 19, 22].", "startOffset": 135, "endOffset": 149}, {"referenceID": 17, "context": "Recently, BO has become popular in machine learning as it is highly effective in tuning hyperparameters of machine learning algorithms [8, 9, 19, 22].", "startOffset": 135, "endOffset": 149}, {"referenceID": 20, "context": "Recently, BO has become popular in machine learning as it is highly effective in tuning hyperparameters of machine learning algorithms [8, 9, 19, 22].", "startOffset": 135, "endOffset": 149}, {"referenceID": 11, "context": "Most previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26].", "startOffset": 86, "endOffset": 90}, {"referenceID": 2, "context": "Most previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26].", "startOffset": 156, "endOffset": 170}, {"referenceID": 4, "context": "Most previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26].", "startOffset": 156, "endOffset": 170}, {"referenceID": 16, "context": "Most previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26].", "startOffset": 156, "endOffset": 170}, {"referenceID": 24, "context": "Most previous work in BO assumes that we evaluate the objective function sequentially [13], though a few recent papers have considered parallel evaluations [3, 5, 18, 26].", "startOffset": 156, "endOffset": 170}, {"referenceID": 24, "context": "Naively maximizing q-KG would be extremely computationally intensive, especially when q is large, and so, in this paper, we develop a method based on infinitesimal perturbation analysis (IPA) [26] to evaluate q-KG\u2019s gradient efficiently, allowing its efficient optimization.", "startOffset": 192, "endOffset": 196}, {"referenceID": 1, "context": "In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3].", "startOffset": 199, "endOffset": 210}, {"referenceID": 17, "context": "In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3].", "startOffset": 199, "endOffset": 210}, {"referenceID": 24, "context": "In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3].", "startOffset": 199, "endOffset": 210}, {"referenceID": 4, "context": "In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3].", "startOffset": 222, "endOffset": 225}, {"referenceID": 2, "context": "In our experiments on both synthetic functions and tuning practical machine learning algorithms, q-KG consistently finds better function values than other parallel BO algorithms, such as parallel EI [2, 19, 26], batch UCB [5] and parallel UCB with exploration [3].", "startOffset": 260, "endOffset": 263}, {"referenceID": 7, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 8, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 16, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 17, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 18, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 20, "context": "Within the past several years, the machine learning community has revisited BO [8, 9, 18, 19, 20, 22] due to its huge success in tuning hyperparameters of complex machine learning algorithms.", "startOffset": 79, "endOffset": 101}, {"referenceID": 14, "context": "In practice, Gaussian Process (GP) [16] is the mostly widely used statistical model due to its flexibility and tractability.", "startOffset": 35, "endOffset": 39}, {"referenceID": 22, "context": "Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].", "startOffset": 199, "endOffset": 203}, {"referenceID": 11, "context": "Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].", "startOffset": 231, "endOffset": 235}, {"referenceID": 19, "context": "Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].", "startOffset": 266, "endOffset": 270}, {"referenceID": 10, "context": "Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].", "startOffset": 292, "endOffset": 296}, {"referenceID": 15, "context": "Maximizing this acquisition function usually provides a single point to evaluate next, with common acquisition functions for sequential Bayesian optimization including probability of improvement (PI)[24], expected improvement (EI) [13], upper confidence bound (UCB) [21], entropy search (ES) [11], and knowledge gradient (KG) [17].", "startOffset": 326, "endOffset": 330}, {"referenceID": 9, "context": "[10, 19] suggests parallelizing EI by iteratively constructing a batch, in each iteration adding the point with maximal single-evaluation EI averaged over the posterior distribution of previously selected points.", "startOffset": 0, "endOffset": 8}, {"referenceID": 17, "context": "[10, 19] suggests parallelizing EI by iteratively constructing a batch, in each iteration adding the point with maximal single-evaluation EI averaged over the posterior distribution of previously selected points.", "startOffset": 0, "endOffset": 8}, {"referenceID": 9, "context": "[10] also proposes an algorithm called \u201cconstant liar\", which iteratively constructs a batch of points to sample by maximizing singleevaluation while pretending that points previously added to the batch have already returned values.", "startOffset": 0, "endOffset": 4}, {"referenceID": 4, "context": "[5] proposes the GP-BUCB policy, which selects points sequentially by a UCB criterion until filling the batch.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] proposes an algorithm combining UCB with pure exploration, called GP-UCB-PE.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "Other recent papers that value points collectively include [2] which optimizes the parallel EI by a closed-form formula, [15, 26], in which gradient-based methods are proposed to jointly optimize a parallel EI criterion, and [18], which proposes a parallel version of the ES algorithm and uses Monte Carlo Sampling to optimize the parallel ES acquisition function.", "startOffset": 59, "endOffset": 62}, {"referenceID": 13, "context": "Other recent papers that value points collectively include [2] which optimizes the parallel EI by a closed-form formula, [15, 26], in which gradient-based methods are proposed to jointly optimize a parallel EI criterion, and [18], which proposes a parallel version of the ES algorithm and uses Monte Carlo Sampling to optimize the parallel ES acquisition function.", "startOffset": 121, "endOffset": 129}, {"referenceID": 24, "context": "Other recent papers that value points collectively include [2] which optimizes the parallel EI by a closed-form formula, [15, 26], in which gradient-based methods are proposed to jointly optimize a parallel EI criterion, and [18], which proposes a parallel version of the ES algorithm and uses Monte Carlo Sampling to optimize the parallel ES acquisition function.", "startOffset": 121, "endOffset": 129}, {"referenceID": 16, "context": "Other recent papers that value points collectively include [2] which optimizes the parallel EI by a closed-form formula, [15, 26], in which gradient-based methods are proposed to jointly optimize a parallel EI criterion, and [18], which proposes a parallel version of the ES algorithm and uses Monte Carlo Sampling to optimize the parallel ES acquisition function.", "startOffset": 225, "endOffset": 229}, {"referenceID": 6, "context": "Our method is also closely related to the knowledge gradient (KG) method [7, 17] for the non-batch (sequential) setting, which chooses the Bayes-optimal point to evaluate if only one iteration is left [17], and the final solution that we choose is not restricted to be one of the points we evaluate.", "startOffset": 73, "endOffset": 80}, {"referenceID": 15, "context": "Our method is also closely related to the knowledge gradient (KG) method [7, 17] for the non-batch (sequential) setting, which chooses the Bayes-optimal point to evaluate if only one iteration is left [17], and the final solution that we choose is not restricted to be one of the points we evaluate.", "startOffset": 73, "endOffset": 80}, {"referenceID": 15, "context": "Our method is also closely related to the knowledge gradient (KG) method [7, 17] for the non-batch (sequential) setting, which chooses the Bayes-optimal point to evaluate if only one iteration is left [17], and the final solution that we choose is not restricted to be one of the points we evaluate.", "startOffset": 201, "endOffset": 205}, {"referenceID": 25, "context": "Recently, [27] studies a nested batch knowledge gradient policy.", "startOffset": 10, "endOffset": 14}, {"referenceID": 6, "context": "In this section, we propose a novel parallel Bayesian optimization algorithm by generalizing the concept of the knowledge gradient from [7] to the parallel setting.", "startOffset": 136, "endOffset": 139}, {"referenceID": 6, "context": "The knowledge gradient policy in [7] for discrete A chooses the next sampling decision by maximizing the expected incremental value of a measurement, without assuming (as expected improvement does) that the point returned as the optimum must be a previously sampled point.", "startOffset": 33, "endOffset": 36}, {"referenceID": 6, "context": "1) Following [7], we express \u03bc(x) as \u03bc(x) = \u03bc(x) +K(x, z) ( K(z, z)", "startOffset": 13, "endOffset": 16}, {"referenceID": 12, "context": "This technique is called infinitesimal perturbation analysis (IPA) in gradient estimation [14].", "startOffset": 90, "endOffset": 94}, {"referenceID": 15, "context": "The discretization itself is an interesting research topic [17].", "startOffset": 59, "endOffset": 63}, {"referenceID": 10, "context": "In this paper, the discrete set An is not chosen statically, but evolves over time: specifically, we suggest drawing M samples from the global optima of the posterior distribution of the Gaussian process (please refer to [11, 18] for a description of this technique).", "startOffset": 221, "endOffset": 229}, {"referenceID": 16, "context": "In this paper, the discrete set An is not chosen statically, but evolves over time: specifically, we suggest drawing M samples from the global optima of the posterior distribution of the Gaussian process (please refer to [11, 18] for a description of this technique).", "startOffset": 221, "endOffset": 229}, {"referenceID": 0, "context": "In both settings, we test the algorithms on well-known synthetic functions chosen from [1] and practical problems.", "startOffset": 87, "endOffset": 90}, {"referenceID": 17, "context": "Following previous literature [19], we use a constant mean prior and the ARD Mat\u00e9rn 5/2 kernel.", "startOffset": 30, "endOffset": 34}, {"referenceID": 23, "context": "Our implementation inherits the open-source implementation of parallel EI from the Metrics Optimization Engine [25], which is fully implemented in C++ with a python interface.", "startOffset": 111, "endOffset": 115}, {"referenceID": 23, "context": "Besides comparing to parallel EI in [25], we also compare our method to a well-known heuristic parallel EI implemented in Spearmint [12], the parallel UCB algorithm (GP-BUCB) and parallel UCB with pure exploration (GP-UCB-PE) both implemented in Gpoptimization [6].", "startOffset": 36, "endOffset": 40}, {"referenceID": 5, "context": "Besides comparing to parallel EI in [25], we also compare our method to a well-known heuristic parallel EI implemented in Spearmint [12], the parallel UCB algorithm (GP-BUCB) and parallel UCB with pure exploration (GP-UCB-PE) both implemented in Gpoptimization [6].", "startOffset": 261, "endOffset": 264}, {"referenceID": 0, "context": "First, we test our algorithm along with the benchmarks on 4 well-known synthetic test functions: Branin2 on the domain [\u221215, 15], Rosenbrock3 on the domain [\u22122, 2], Ackley5 on the domain [\u22122, 2], and Hartmann6 on the domain [0, 1].", "startOffset": 224, "endOffset": 230}, {"referenceID": 0, "context": "Without loss of generality, we assume that (1) i and j are fixed in advance and (2) A = [0, 1], we would like to prove that (C.", "startOffset": 88, "endOffset": 94}, {"referenceID": 12, "context": "To prove it, we cite Theorem 1 in [14], which requires three conditions to make (C.", "startOffset": 34, "endOffset": 38}, {"referenceID": 21, "context": "25 on page 165 in [23]).", "startOffset": 18, "endOffset": 22}, {"referenceID": 24, "context": "We follow the same idea of proving the Theorem 2 in [26].", "startOffset": 52, "endOffset": 56}], "year": 2017, "abstractText": "In many applications of black-box optimization, one can evaluate multiple points simultaneously, e.g. when evaluating the performances of several different neural networks in a parallel computing environment. In this paper, we develop a novel batch Bayesian optimization algorithm \u2014 the parallel knowledge gradient method. By construction, this method provides the one-step Bayes optimal batch of points to sample. We provide an efficient strategy for computing this Bayes-optimal batch of points, and we demonstrate that the parallel knowledge gradient method finds global optima significantly faster than previous batch Bayesian optimization algorithms on both synthetic test functions and when tuning hyperparameters of practical machine learning algorithms, especially when function evaluations are noisy.", "creator": "LaTeX with hyperref package"}}}