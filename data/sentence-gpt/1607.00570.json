{"id": "1607.00570", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Jul-2016", "title": "Representation learning for very short texts using weighted word embedding aggregation", "abstract": "Short text messages such as tweets are very noisy and sparse in their use of vocabulary. Traditional textual representations, such as tf-idf, have difficulty grasping the semantic meaning of such texts, which is important in applications such as event detection, opinion mining, news recommendation, etc. We constructed a method based on semantic word embeddings and frequency information to arrive at low-dimensional representations for short texts designed to capture semantic similarity. For this purpose we designed a weight-based model and a learning procedure based on a novel median-based loss function. This paper discusses the details of our model and the optimization methods, together with the experimental results on both Wikipedia and Twitter data. We find that our method outperforms the baseline approaches in the experiments, and that it generalizes well on different word embeddings without retraining. Our method is therefore capable of retaining most of the semantic information in the text, and is applicable out-of-the-box. A high-dimensional classification model that is designed to predict a high-dimensional classification model can be used by any type of language. An approach to generalizing a high-dimensional classification model can be used by any language in which it is capable of retaining most of the semantic information in the text, and is applicable out-of-the-box. This method is also useful in generalizing a high-dimensional classification model, when it has not yet been proven to work in most languages.", "histories": [["v1", "Sat, 2 Jul 2016 23:10:09 GMT  (473kb,D)", "http://arxiv.org/abs/1607.00570v1", "8 pages, 3 figures, 2 tables, appears in Pattern Recognition Letters"]], "COMMENTS": "8 pages, 3 figures, 2 tables, appears in Pattern Recognition Letters", "reviews": [], "SUBJECTS": "cs.IR cs.CL", "authors": ["cedric de boom", "steven van canneyt", "thomas demeester", "bart dhoedt"], "accepted": false, "id": "1607.00570"}, "pdf": {"name": "1607.00570.pdf", "metadata": {"source": "META", "title": "Representation learning for very short texts using weighted word embedding aggregation", "authors": ["Cedric De Booma", "Steven Van Canneyta", "Thomas Demeestera", "Bart Dhoedta"], "emails": ["cedric.deboom@ugent.be"], "sections": [{"heading": null, "text": "Short text messages such as tweets are very noisy and sparse in their use of vocabulary. Traditional textual representations, such as tf-idf, have difficulty grasping the semantic meaning of such texts, which is important in applications such as event detection, opinion mining, news recommendation, etc. We constructed a method based on semantic word embeddings and frequency information to arrive at low-dimensional representations for short texts designed to capture semantic similarity. For this purpose we designed a weight-based model and a learning procedure based on a novel median-based loss function. This paper discusses the details of our model and the optimization methods, together with the experimental results on both Wikipedia and Twitter data. We find that our method outperforms the baseline approaches in the experiments, and that it generalizes well on different word embeddings without retraining. Our method is therefore capable of retaining most of the semantic information in the text, and is applicable out-of-the-box.\nc\u00a9 2016 Elsevier Ltd. All rights reserved."}, {"heading": "1. Introduction", "text": "Short pieces of texts reach us every day through the use of social media such as Twitter, newspaper headlines, and texting. Especially on social media, millions of such short texts are sent every day, and it quickly becomes a daunting task to find similar messages among them, which is at the core of applications such as event detection (De Boom et al. (2015b)), news recommendation (Jonnalagedda and Gauch (2013)), etc.\nIn this paper we address the issue of finding an effective vector representation for a very short text fragment. By effective we mean that the representation should grasp most of the semantic information in that fragment. For this we use semantic word embeddings to represent individual words, and we learn how to weigh every word in the text through the use of tf-idf (term frequency - inverse document frequency) information to arrive at an overall representation of the fragment.\nThese representations will be evaluated through a semantic similarity task. It is therefore important to point out that textual similarity can be achieved on different levels. At the most strict level, the similarity measure between two texts is often defined as being (near) paraphrases. In a more relaxed setting one is interested in topic- and subject-related texts. For example, if a\ne-mail: cedric.deboom@ugent.be (Cedric De Boom )\nsentence is about the release of a new Star Wars episode and another about Darth Vader, they will be dissimilar in the most strict sense, although they share the same underlying subject. In this paper we focus on the broader concept of topic-based semantic similarity, as this is often applicable in the already mentioned use cases of event detection and recommendation.\nOur main contributions are threefold. First, we construct a technique to calculate effective text representations by weighing word embeddings, for both fixed- and variable-length texts. Second, we devise a novel median-based loss function to be used in the context of minibatch learning to mitigate the negative effect of outliers. Finally we create a dataset of semantically related and non-related pairs of text from both Wikipedia and Twitter, on which the proposed techniques are evaluated.\nWe will show that our technique outperforms most of the baselines in a semantic similarity task. We will also demonstrate that our technique is independent of the word embeddings being used, so that the technique is directly applicable and thus does not require additional model training when used in different contexts, in contrast to most state-of-the art techniques.\nIn the next section, we start with a summary of the related work, and our own methodology will be devised in Section 3. Next we explain how data is collected in Section 4, after which we discuss our experimental results in Section 5.\nar X\niv :1\n60 7.\n00 57\n0v 1\n[ cs\n.I R\n] 2\nJ ul\n2 01\n6\n2"}, {"heading": "2. Related work", "text": "In this work we use so-called word embeddings as a basic building block to construct text representations. Such an embedding is a distributed vector representation of a single word in a fixed-dimensional semantic space, as opposed to term tfidf vectors, in which a word is represented by a one-hot vector (Achananuparp et al. (2008); Manning et al. (2009)). A word\u2019s term frequency (tf) is the number of times the word occurs in the considered document, and a word\u2019s document frequency (df) is the number of documents in the considered corpus that contain that word. Its (smoothed) inverse document frequency (idf) is defined as:\nidf , log N\n1 + df , (1)\nin which N is the number of documents in the corpus (Manning et al. (2009)). A tf-idf-based similarity measure is based on exact word overlap. As texts become smaller in length, however, the probability of having words in common decreases. Furthermore, these measures ignore synonyms and any semantic relatedness between different words, and are prone to negative effects of homonyms.\nInstead of relying on exact word overlap, one can incorporate semantic information into the similarity process. Latent Semantic Indexing (LSI) and Latent Dirichlet Allocation (LDA) are two examples, in which every word is projected into a semantic (topic) space (Deerwester et al. (1990); Blei et al. (2003)). At test time, inference is performed to obtain a semantic vector for a particular sentence. Both training and inference of standard LSI and LDA, however, are computationally expensive on large vocabularies.\nAlthough LSI and LDA have been used with success in the past, Skip-gram models have been shown to outperform them in various tasks (Mikolov et al. (2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window.\nOnce the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)). Such an approach, however, requires either an input of fixed length or aggregation operations \u2013 such as dynamic k-max pooling (Kalchbrenner et al. (2014)) \u2013 to arrive at a sentence representation that has the same dimensionality for every input. Recurrent neural networks (RNNs) and variants can overcome the problem of fixed dimensionality or aggregation, since one can feed word after word in the system and in the end arrive at a text representation (Sutskever et al. (2014); Sordoni et al. (2015); Sundermeyer et al. (2015)). The recently introduced Skip-thought vectors, heavily inspired on Skip-gram, combine the learning of word embeddings with the learning of a useful sentence representation using an RNN encoder and decoder (Kiros et al. (2015)). RNN-based methods present a lot\n1Available at code.google.com/archive/p/word2vec\nof advantages over MLPs and convolutional networks, but still retraining is required when using different types of embeddings.\nParagraph2vec is another method, inspired by the Skip-gram algorithm, to derive sentence vectors (Le and Mikolov (2014)). The technique requires the user to train vectors for frequently occurring word groups. The method, however, is not usable in a streaming or on-the-fly fashion, since it requires retraining for unseen word groups at test time.\nAggregating word embeddings through a mean, max, min. . . function is still one of the most easy and widely used techniques to derive sentence embeddings, often in combination with an MLP or convolutional network (Weston et al. (2014); dos Santos and Gatti (2014); Yin and Schu\u0308tze (2015); Collobert et al. (2011)). On one hand, the word order is lost, which can be important in e.g. paraphrase identification. On the other hand, the methods are simple, out-of-the-box and do not require a fixed length input.\nRelated to the concepts of semantic similarity and weighted embedding aggregation, there is extensive literature. Kusner et al. (2015) calculate a similarity metric between documents based on the travel distance of word embeddings from one document to another one. We on the other hand will derive vectors for the documents themselves. Kenter and de Rijke (2015) learn semantic features for every sentence in the dataset based on a saliency weighted network for which the BM25 algorithm is used. However, the features are being learned for every sentence prior to test time, and therefore not applicable in a realtime streaming context. Finally, Kang et al. (2014) calculate a cosine similarity matrix between the words of two sentences that are sorted based on their idf value, which they use as a feature vector for an MLP. Their approach is similar to our work in the sense that the authors use idf information to rescale term contribution. Their primary goal, however, is calculating semantic similarity instead of learning a sentence representation. In fact, the authors totally discard the original word embeddings and only use the calculated cosine similarity features."}, {"heading": "3. Methodology", "text": "The core principle of our methodology is to assign a weight to each word in a short text. These weights are determined based on the idf value of the individual words in that text. The idea is that important words \u2013 i.e. words that are needed to determine most of the text\u2019s semantics \u2013 usually have higher idf values than less important words, such as articles and auxiliaries. . . Indeed, the latter appear more frequently in various different texts, while words with a high idf value mostly occur in similar contexts. The final goal is to combine the weighted words into a semantically effective, single text representation.\nTo achieve this goal, we will model the problem of finding a suitable text representation as a semantic similarity task between couples of short texts. In order to classify such couples of text fragments into either semantically related pairs or nonrelated pairs, the vector representations of these two texts are directly compared. In this paper we use a simple threshold function on the distance between the two text representations, as we\n3 want related pairs to lie close to each other in their representation space, and non-related pairs to lie far apart:\ng(t1, t2) = pair if d(t1, t2) \u2264 \u03b8non-pair if d(t1, t2) > \u03b8 . (2) In this expression t1 and t2 are two short text vector representations of dimensionality \u03bd, d : (x, y) \u2208 R2\u03bd \u2192 R+ is a vector distance function of choice (e.g. cosine distance, euclidean distance. . . ), \u03b8 is a threshold, and g(\u00b7) is the binary prediction of semantic relatedness."}, {"heading": "3.1. Basic architecture", "text": "As mentioned before, we will assign a weight to each word in a text according to that word\u2019s idf value. To learn these weights, we devise a model that is visualised in Figure 1. In the learning scheme, we use related and non-related couples of text as input data. First, the words in every text are sorted from high to low idf values. Original word order is therefore discarded, as is the case in usual standard aggregation operations. After that, every embedding vector for each of the sorted words is multiplied with a weight that can be learned. Finally, the weighted vectors are averaged to arrive at a single text representation.\nIn more detail, consider a dataset D consisting of couples of short texts. An arbitrary couple is denoted by C, and the two texts of C by C\u03b1 and C\u03b2. We indicate the vector representation of word j in text C\u03b1 by C\u03b1j . All word vectors have the same dimensionality \u03bd. Each text C\u03b1 also has an associated length n(C\u03b1), i.e. the number of words in C\u03b1. For now, in this section, we assume that n , n(C\u03b1) = n(C\u03b2),\u2200C \u2208 D, a notion we will relax in Section 3.3. The final goal of our methodology is to arrive at a vector representation for both texts in C, denoted by t(C\u03b1) and t(C\u03b2). Denoting the sorted texts as C\u03b1 \u2032 and C\u03b2 \u2032 , we arrive at a vector representation t(C\u03b1) and t(C\u03b2) through the following equation:\n\u2200` \u2208 {\u03b1, \u03b2} : t(C`) = 1 n n\u2211 j=1 w j \u00b7C` \u2032 j , (3)\nin which w j, j \u2208 {1, . . . , n} are the weights to be learned. As such, we create a weighted sum of the individual embeddings, the weights of which are only related to the rank order according to the idf values of all words in the fragment.\nThe model we construct through this procedure is related to the siamese neural network with parameter sharing from the early nineties (Bromley et al. (1993)). The learning procedure of such models is as follows. We first calculate the vector representations for both texts in a particular couple through Equation (3), both using the same weights, after which we compare the two vector representations through a loss function L ( t(C\u03b1), t(C\u03b2) ) that we wish to minimize. After that, the weights are updated through a gradient descent procedure using a learning rate \u03b7:\n\u2200 j \u2208 {1, . . . , n} : w j \u2190 w j \u2212 \u03b7 \u00b7 \u2202\n\u2202w j L\n( t(C\u03b1), t(C\u03b2) ) . (4)\nthe quick brown fox jumped over the lazy dog jumped lazy quick dog fox brown over the the idf sort"}, {"heading": "3.2. Loss functions", "text": "As pointed out in the beginning of this section, we want to have semantically related texts to lie close to each other in the representation space, and non-related texts to lie far apart from each other. We can visually inspect the distribution of the distances between every couple in the dataset. In fact, we calculate two distributions, one for the related pairs and one for the non-related pairs. Two examples of such distributions, created using Twitter data and an average word embedding text representation, are shown in Figure 2. Related pairs tend to lie closer to each other than non-related pairs. There is however a considerable overlap between the two distributions. This means that making binary decisions on similarity based on a well-chosen distance threshold will lead to a large error. The goal is to reduce this error, and thus to minimize the overlap between the two distributions. Directly minimizing the overlap is difficult, since it requires the overlap as a function of the model weights. We will instead describe two different loss functions as an approximation to this problem.\nThe first loss function is related to the contrastive loss function regularly used in siamese neural architectures (Hadsell\n4 et al. (2006)). We define the quantity pC as follows:\npC , 1 if C is a related pair,\u22121 if C is a non-related pair. (5) The loss function, which we will conveniently call the contrastive-based loss, is then given by:\nLc ( t(C\u03b1), t(C\u03b2) ) = pC \u00b7 d ( t(C\u03b1), t(C\u03b2) ) , (6)\nin which d : (x, y) \u2208 R2\u03bd \u2192 R+ is a vector distance function of choice, as before. Note that, when trying to minimize this loss, related pairs will get pushed to each other in the representation space, while non-related pairs will get dragged apart.\nThis loss function, however, has two main problems. First, there is an imbalance between the loss for related pairs and nonrelated pairs, in which the latter can get an arbitrarily negative loss, while the related pairs\u2019 loss cannot be pushed below zero. To solve this, we could add a maximum possible distance \u2013 which is e.g. 1 in the case of cosine distance \u2013 but this cannot be generalized to arbitrary distance functions. Second, this loss function can skew distance distributions, so that minimizing overlap between distributions is not guaranteed. In fact, the overlap can even increase while minimizing this loss. This happens, for example, when the distance between some of the related pairs can be drastically reduced while other related pairs get dragged farther apart, and vice versa for the non-related pairs. The loss function as such allows this to happen, since it can focus on data points that are easier to shift towards or away from each other and it can ignore what happens to the other data points. As long as the contribution of these shifts to the overall loss remains dominant, the loss will diminish, although the predictions according to Equation (2) will be worse. Despite these problems we still consider this loss function due to its simplicity. The derivative with respect to weight w j is given by:\n\u2202\n\u2202w j Lc\n( t(C\u03b1), t(C\u03b2) ) =\npC n\n( \u2207d(x, y) )\u2223\u2223\u2223\u2223 x= 1n \u2211n j=1 w jC \u03b1\u2032 j ,y= 1 n \u2211n j=1 w jC \u03b2\u2032 j C\u03b1\u2032jC\u03b2\u2032j  . (7)\nIn a second loss function we try to mitigate the loss imbalance and potential skewing of the distributions caused by the contrastive-based loss function. For this purpose we will use the median, as it is a very robust statistic insensitive to outliers. As we need multiple data points to calculate the median, this loss function can only be used in the context of minibatch gradient descent, in which the number of positive and negative examples in each minibatch is balanced. In practice we consider a minibatch B \u2282 D of n(B) randomly sampled data points, in which there are exactly n(B)/2 related pairs and n(B)/2 non-related pairs. We consider the couple of texts M(B) \u2208 B as the median couple if \u00b5(B) = d(M(B)\u03b1,M(B)\u03b2) is the median of all distances between the couples in B:\nM(B) , arg median C\u2208B\nd(C\u03b1,C\u03b2); (8)\n\u00b5(B) , median C\u2208B\nd(C\u03b1,C\u03b2). (9)\nSince minibatch B is randomly sampled, we can consider \u00b5(B) as an approximation to the optimal split point between related and non-related pairs, in the sense of threshold \u03b8 in Equation (2). We thus consider all related pairs with a distance larger than \u00b5(B), and all non-related pairs with a distance smaller than \u00b5(B) to be classified incorrectly. Since minimizing a 0-1 loss is NP-hard, we use a scaled cross-entropy function in our loss, which we will call the median-based loss:\nLm ( t(C\u03b1), t(C\u03b2), B ) = ln [ 1 + exp ( \u2212 \u03bapC ( \u00b5(B) \u2212 d(t(C\u03b1), t(C\u03b2))))] , (10)\nin which \u03ba is a hyperparameter. The derivative with respect to weight w j is given by the following expression (in which \u03c3(\u00b7) is the sigmoid function):\n\u2202\n\u2202w j Lm\n( t(C\u03b1), t(C\u03b2), B ) = \u03ba\u03c3 ( \u2212\u03bapC ( \u00b5(B) \u2212 d ( t(C\u03b1), t(C\u03b2)\n))) \u00b7 \u2202 \u2202w j ( Lc ( t(C\u03b1), t(C\u03b2) ) \u2212 Lc ( t(M(B)\u03b1), t(M(B)\u03b2) )) . (11)"}, {"heading": "3.3. Texts with variable length", "text": "The method described thus far is only applicable to short texts of a fixed length, which is limiting. In this section we will extend our technique to texts of a variable, but given maximum length. For this purpose we have devised multiple approaches, of which we will elaborate the one that performed best in the experiments.\nSuppose that all texts have a fixed maximum length of nmax. In the learning procedure we will learn a total of nmax weights with the techniques described earlier. To find the weights for a text with length m \u2264 nmax we will use subsampling and linear interpolation. That is, for an arbitrary text C` we first find the sequence of real-valued indices I(C`, j), j \u2208 { 1, . . . , n(C`)\n} through subsampling:\n\u2200 j \u2208 { 1, . . . , n(C`) } : I(C`, j) , 1 +\n( j \u2212 1)(nmax \u2212 1) n(C`) \u2212 1 . (12)\nThen, in the second step, we calculate the new weights z j(C`), j \u2208 { 1, . . . , n(C`) } for the words in C` through linear interpolation, in which is arbitrarily small:\n\u2200 j \u2208 { 1, . . . , n(C`) } : z j(C`) ,\n(wdI j(C`)e \u2212 wbI j(C`)c)(I(C`, j) \u2212 bI j(C`)c) dI j(C`)e \u2212 bI j(C`)c + + wdI j(C`)e. (13)\nIn this, d\u00b7e and b\u00b7c are resp. the ceil and floor functions. Finally, Equation (3) needs to be updated with these new weights instead of w j:\n\u2200` \u2208 {\u03b1, \u03b2} : t(C`) = 1 n(C`\u2032 )\nn(C` \u2032 )\u2211\nj=1\nz j(C` \u2032 ) \u00b7C`\u2032j . (14)\nCalculating the derivative of the new weights with respect to the original weights is straightforward.\n5"}, {"heading": "4. Data collection", "text": "To train the weights for the individual embeddings and to conduct experiments, we collect data from different sources. First we gather textual pairs from Wikipedia which we will use as a base dataset to finetune our methodology. We will also use this dataset to test our hypotheses and perform initial experiments. The second dataset will consist of Twitter message pairs, which we will use to show that our method can be used in a practical streaming context."}, {"heading": "4.1. Wikipedia", "text": "We will perform our initial experiments in a base setting using English Wikipedia articles. The most important benefit of using Wikipedia is that there is a lot of well structured data. It is therefore a good starting point to collect a ground truth to finetune our methodology.\nWe use the English Wikipedia dump of March 4th 2015, and we remove its markup and punctuation. We convert all letters to lower case and every number is replaced by a single character \u20180\u2019 (zero). Next we construct related pairs of texts which both have the same, fixed length n. To do this, we take a Wikipedia article and we extract n consecutive words out of a paragraph. Then we skip two words, after which we extract the next n consecutive words, as long as they remain in the same paragraph. To extract non-related text pairs we follow the same procedure, but we make sure that the two texts are from different articles, which we choose at random. This approach is closely related to the data collection practice used in (Hu et al. (2014)). We want to emphasize again that our vision of semantic similarity is one of topic-based similarity instead of paraphrase-similarity, as discussed in the introduction. This notion is reflected in our data collection. We extract a total of 4.9 million related pairs and 4.9 million non-related pairs, each for fixed-length texts of 20 words long. We also extract 4.9 million related and nonrelated pairs of which the texts varies in length between 10 and 30 words. All datasets are divided into a train set of 1.5 million pairs, a test set of 1.5 million pairs and a validation set of 1.9 million pairs."}, {"heading": "4.2. Twitter", "text": "Twitter is a very different kind of medium than Wikipedia. Wikipedia articles are written in a formal register and mostly consist of linguistically correct sentences. Twitter messages, on the other hand, count no more than 140 characters and are full of spelling errors, abbreviations and slang.\nWe propose that two tweets are semantically related if they are generated by the same event. As in (De Boom et al. (2015b)), we require that such an event is represented by one or more hashtags. Since Twitter posts and associated events are very noisy by nature, we restrict ourselves to tweets by 100 English news agencies. We manually created this list through inspection of their Twitter accounts; the list is available through our GitHub page, see Section 6.\nWe gathered 341 949 tweets from all news agencies through the Twitter REST API at the end of August 2015. We convert\nall words to lowercase, replace all numbers by the single character \u20180\u2019 and remove non-informative hashtags such as #breaking, #update and #news. To generate related pairs out of these tweets, we consider four simple heuristic rules:\n1. The number of words in each tweet, different from hashtags, mentions or URLs, should be at least 5.\n2. The Jaccard similarity between the set of hashtags in both tweets should be at least 0.5.\n3. The tweets should be sent no more than 15 minutes from each other.\n4. The Jaccard similarity between the set of words in both tweets should be less than 0.5.\nWe add the last rule in order to have sufficient word dissimilarity between the pairs, as tweets that mostly contain the same words are too easy to relate. To generate non-related pairs, we remove rule 3 and rule 2 is changed: the Jaccard similarity between sets of hashtags should now be zero. Using these heuristics, we generate a train set of 15 000 pairs, a validation set of 20 000 pairs and a test set of 13 645 pairs, of which we remove all overlapping hashtags. We manually label 200 generated pairs and non-pairs, and we achieve an error rate of 28%. Due to the used heuristics and the linguistic nature of tweets in general, the ground truth can be considered very noisy; achieving an error rate lower than around 28% on this dataset will therefore be difficult, and the gain would not lead to a better model of the human notion of similarity anyway."}, {"heading": "5. Experiments", "text": "In this section we discuss the results of several experiments on all aspects of our methodology given the data we collected. First we will discuss some results using the Wikipedia dataset, after which we also take a look at the Twitter dataset. We will use two performance metrics in our evaluation. The first is the optimal split error, i.e. we classify all pairs according to Equation (2) \u2013 after determining the optimal split point \u03b8 \u2013 and we determine the classification error rate. A second performance metric is the Jensen-Shannon (JS) divergence. This is a symmetric distance measure between two probability distributions, related to the \u2013 well-known, but asymmetric \u2013 KL divergence. We will use it to capture the difference between the related and non-related pairs\u2019 distributions, as shown in Figure 2. The bigger the JS divergence, the greater the difference between the two distributions.\nIn our experiments we will use Google\u2019s word2vec software to calculate word embeddings. We choose Skip-gram with negative sampling as the learning algorithm, using a context window of five words and 400 dimensions. We feed an entire cleaned English Wikipedia dump of March 4th 2015 to the algorithm, after which we arrive at a total vocabulary size of 2.2 million words. Since we also need document frequencies, we calculate these for each of the vocabulary words using the same Wikipedia dump.\nIn previous work we showed that using an Euclidean distance function leads to a much better separation between related and non-related pairs than the more often used cosine distance, so\n6 0 5 10 15 20 0.0 0.2 0.4 0.6 0.8 1.0 Contrastive loss Median loss\n1 6 11 16 Weight index j\nW ei\ngh tm\nag ni\ntu de\nw j\n1\nFigure 3. Plot of the learned weight magnitudes for texts of 20 words long.\nwe will also use the Euclidean distance throughout our experiments here (De Boom et al. (2015a)). Calculating the gradient of this distance function \u2013 which is used in Equation (7) \u2013 is straightforward.\nTo obtain the results hereafter, we use the following procedure. We use the train set to train the weights w j in Equation (3). The validation set is used to determine the optimal split point \u03b8 in Equation (2). Finally predictions and evaluations are made on the test set. In the next two subsections we discuss the results on the Wikipedia and Twitter datasets."}, {"heading": "5.1. Baselines", "text": "We will compare the performance of our methods to several baseline mechanisms that construct sentence vector representations. The simplest and most widely used baseline is a tf-idf vector. Comparing two tf-idf vectors is done through a standard cosine similarity. In a second baseline we simply take, for every dimension, the mean across all embeddings:\n\u2200` \u2208 {\u03b1, \u03b2} : \u2200k \u2208 {1, . . . , \u03bd} : t(C`)k = mean j C`j,k. (15)\nIn the third baseline we replace the mean by a maximum operation. Taking a mean or a maximum is a very common approach to combine word embeddings \u2013 or other intermediary representations in an NLP architecture \u2013 into a sentence representation. We can also replace the maximum in Equation (15) by a minimum. The fourth baseline is a concatenation of the maximum and minimum vectors, resulting in a vector having two times the original dimensionality (\u2018min/max\u2019). We can also apply the three previous baselines \u2013 i.e. \u2018mean\u2019, \u2018max\u2019 and \u2018min/max\u2019 \u2013 only considering words with a high idf value (\u2018top 30% idf\u2019). That is, we sort the words in a text based on their idf values, and we take the mean or maximum of the top 30%. In a final baseline we weigh each word in the sentence with its corresponding idf value and then take the mean (\u2018mean, idf-weighted\u2019)."}, {"heading": "5.2. Details on the learning procedure", "text": "In the results below we use the methodology from Section 3 to learn weights for individual words in a short text. All\nprocedures are implemented with the Theano2 framework and executed using an Nvidia Tesla K40 GPU. We use mini-batch stochastic gradient descent as learning procedure and L2 regularization on the weights. The total loss for one training batch thus becomes:\nLtotal = Lbatch + \u03bb nmax\u2211 j=1 w2j . (16)\nIn this, we empirically set parameter \u03bb to 0.001, andLbatch is either equal to the contrastive or median-based loss depending on the experiment. The batch size is equal to 100 text couples, of which 50 are related pairs and 50 are non-related pairs. An initial learning rate \u03b7 of 0.01 is employed, which we immediately lower to 0.001 once the average epoch loss starts to deteriorate. After that, we stop training when the loss difference between epochs is below 0.05%. The weights are initialized uniformly to a value of 0.5. The entire procedure is visualised in Algorithm 1. To determine the optimal value of the hyperparameter \u03ba in the median-based loss, we use five-fold cross-validation and a grid search procedure.\nAlgorithm 1: Detailed training procedure 1 \u2200 j : w j \u2190 0.5 2 \u03b7\u2190 0.01 3 Lmean-old \u2190 \u221e 4 repeat 5 Lmean = 0 .new epoch 6 for batch i \u2208 dataset do 7 Ltotal \u2190 Lbatchi + \u03bb \u2211nmax j=1 w 2 j 8 \u2200 j : w j \u2190 w j \u2212 \u03b7 \u00b7 \u2202\u2202w jLtotal .gradient descent 9 Lmean \u2190 (i\u22121)Lmean+Ltotali .update mean loss\n10 if \u03b7 > 0.001 \u2227 Lmean > Lmean-old then 11 \u03b7\u2190 0.001 12 if \u03b7 == 0.001 \u2227 Lmean-old \u2212 Lmean < 0.0005 then 13 STOP\n14 Lmean-old \u2190 Lmean 15 until STOP"}, {"heading": "5.3. Results on Wikipedia", "text": "We train weights for Wikipedia texts with a fixed length of 20 words using the training procedure described in the previous section. The weights already converge before the first training epoch is finished, that is, without having seen all examples in the train set. This is due to the simplicity of our model \u2013 i.e. there are only limited degrees of freedom to be learned \u2013 and the large train set. Through cross-validation and grid-search we find an optimal value for \u03ba = 160 used in the median-based loss. The resulting weights for texts of 20 words long are visualized in Figure 3, for both the contrastive- and median-based loss. In both cases, the weights drop in magnitude with increasing\n2deeplearning.net/software/theano\n7\nindex; this confirms the hypothesis that words with a low idf contribute less to the overall meaning of a sentence than high idf words. For the median-based loss, the first word is clearly the most important one, as the second weight is only half the first weight. It is important to point out that we observe a similar monotonically decreasing pattern for texts of 10 words and 30 words long, which means that we use an equal proportion of important to less important words, no matter how long the sentence is. From the 16th word on, the weights are close to zero, so these words almost never contribute to the meaning of a text. In comparison, there are, by experiment, eight non-informative words on average in a text of twenty words long.\nThe results of the experiments are summarized in Table 1. In a first experiment we compare the performance of our approach to all baselines for texts of length 20 and with word embeddings trained on Wikipedia. Our method significantly outperforms all baselines (p < 0.001, two-tailed binomial test) by a high margin for both losses. We also see that a plain tf-idf vector can compete with the simplest and most widely used baselines. We further notice that concatenating the minimum and maximum vectors performs approx 2.25% better than when using a maximum vector alone, which implies that the sign in word embeddings holds semantically relevant information.\nIn a second experiment we vary the length of the texts between 10 and 30 words. The overall performance drop can be addressed to the presence of text pairs with a length shorter than 20 words. Tf-idf now outperforms all baselines. For texts of 30 words the probability of word overlap is after all much higher than for texts of 10 words long; pairs of long texts thus help lower the error rate for tf-idf. Our method is still the overall best performer (p < 0.001, two-tailed binomial test), but this time the median-based loss is able to improve the contrastive-based loss by a high margin of almost 5% in split error, showing that the former loss is much more robust in a variable-length setting.\nFinally, we also performed experiments with word embeddings from Google News, see footnote 1. We want to stress that we did not retrain the weights for this experiment in order to test whether our technique is indeed applicable out-ofthe-box. There is only 20.6% vocabulary overlap between the Wikipedia and Google word2vec model, and there are only 300 dimensions instead of 400, which together can explain the overall performance drop of the word embedding techniques. It is also possible that the Google embeddings are no right fit to be\nused on Wikipedia texts. Although our model was not trained to perform well on Google embeddings, we still achieve the best error rate of all embedding baselines (p < 0.001, two-tailed binomial test), and again the median loss outperforms the contrastive loss by approx 5%. Tf-idf, on the other hand, is the clear winner here; it did almost not suffer from the vocabulary reduction. It shows that vector dimensionality and context of usage are important factors in choosing or training word embeddings."}, {"heading": "5.4. Results on Twitter", "text": "Next we perform experiments on the data collected from Twitter. We do not train additional word embeddings for Twitter, but we keep using the Wikipedia embeddings, since we have restricted ourselves to tweets of news publishers, who mainly use clean language. We also keep the same setting for \u03ba as in the Wikipedia experiments.\nThe results for the Twitter experiments are shown in Table 2. As expected, the error rate is quite high given the noise present in the dataset. We also notice that the split error remains slightly higher than the human error rate of 28%. Tf-idf performs worst in this experiment. Compared to Wikipedia, tfidf vectors for tweets are much sparser, which leads to a higher error rate. Tf-idf is clearly not fit to represent tweets efficiently. The baselines on the other hand have a much better, but overall comparable performance. Our method with median-based loss performs the best. The approach using contrastive loss performs worst among all embedding baselines, as during training the distribution of distances between related and between non-related texts rapidly gets skewed and develops additional modes. This causes the overall training loss to decrease, while the overlap between the related pairs\u2019 and non-related pairs\u2019 distribution further increases. The overall improvement of the median-based loss over the idf-weighted baseline is not statistically significant (p > 0.05, two-tailed binomial test); so, based on this Twitter dataset alone, we cannot draw any statistically sound conclusion whether our method is better in terms of split error than the idf-weighted baseline. Combined with the results from Table 1, however, we can conclude that choosing medianbased learned weights is generally recommended.\n8"}, {"heading": "6. Conclusion", "text": "We devised an effective method to derive vector representations for very short fragments of text. For this purpose we learned to weigh word embeddings based on their idf value, using both a contrastive-based loss function and a novel median-based loss function that can effectively mitigate the effect of outliers. Our method is applicable to texts of a fixed length, but can easily be extended to texts of a variable length through subsampling and linear interpolation of the learned weights. Our method can be applied out-of-the-box, that is, there is no need to retrain the model when using different types of word embeddings. We showed that our method outperforms widely-used baselines that naively combine word embeddings into a text representation, using both toy Wikipedia and real-word Twitter data. All code for this paper is readily available on our GitHub page github.com/cedricdeboom/ RepresentationLearning."}, {"heading": "Acknowledgments", "text": "This work is soon to be published in Pattern Recognition Letters. Cedric De Boom is funded by a Ph.D. grant of the Flanders Research Foundation (FWO). Steven Van Canneyt is funded by a Ph.D. grant of the Agency for Innovation by Science and Technology in Flanders (IWT). We acknowledge Nvidia for its generous hardware support."}], "references": [{"title": "The Evaluation of Sentence Similarity Measures, DaWaK", "author": ["P Achananuparp"], "venue": null, "citeRegEx": "Achananuparp,? \\Q2008\\E", "shortCiteRegEx": "Achananuparp", "year": 2008}, {"title": "Latent dirichlet allocation", "author": ["Blei", "D.M"], "venue": null, "citeRegEx": "Blei and D.M,? \\Q2003\\E", "shortCiteRegEx": "Blei and D.M", "year": 2003}, {"title": "Learning Semantic Similarity for Very Short Texts", "author": ["C JMLR. De Boom"], "venue": null, "citeRegEx": "Boom,? \\Q2015\\E", "shortCiteRegEx": "Boom", "year": 2015}, {"title": "2015b. Semantics-driven Event Clustering in Twitter", "author": ["C in: ICDMW. De Boom"], "venue": null, "citeRegEx": "Boom,? \\Q2015\\E", "shortCiteRegEx": "Boom", "year": 2015}, {"title": "Indexing by Latent Semantic Analysis. JASIS", "author": ["Feeds", "#MSM. Deerwester", "S.C"], "venue": "Hadsell, R., et al.,", "citeRegEx": "Feeds. et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Feeds. et al\\.", "year": 1990}, {"title": "Convolutional Neural Network Architectures for Matching", "author": ["Mapping", "B CVPR. Hu"], "venue": null, "citeRegEx": "Mapping. and Hu,? \\Q2014\\E", "shortCiteRegEx": "Mapping. and Hu", "year": 2014}, {"title": "Personalized News Recommendation", "author": ["S. Gauch"], "venue": null, "citeRegEx": "Jonnalagedda and Gauch,? \\Q2013\\E", "shortCiteRegEx": "Jonnalagedda and Gauch", "year": 2013}, {"title": "A Convolutional Neural Network for Modelling", "author": ["Twitter", "N WI-IAT. Kalchbrenner"], "venue": null, "citeRegEx": "Twitter and Kalchbrenner,? \\Q2014\\E", "shortCiteRegEx": "Twitter and Kalchbrenner", "year": 2014}, {"title": "A Short Texts Matching Method using Shallow", "author": ["Sentences", "L. ACL. Kang", "B Hu"], "venue": null, "citeRegEx": "Sentences et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sentences et al\\.", "year": 2014}, {"title": "Skip-Thought Vectors. arXiv.org arXiv:1506.06726v1", "author": ["R CIKM. Kiros"], "venue": "Kusner, M.J., et al.,", "citeRegEx": "Kiros,? \\Q2015\\E", "shortCiteRegEx": "Kiros", "year": 2015}, {"title": "Distributed Representations of Sentences", "author": ["Q.V. ICML. Le", "T. Mikolov"], "venue": null, "citeRegEx": "Le and Mikolov,? \\Q2014\\E", "shortCiteRegEx": "Le and Mikolov", "year": 2014}, {"title": "N-gram-Based Low-Dimensional Representa", "author": ["R. Collobert"], "venue": null, "citeRegEx": "Lebret and Collobert,? \\Q2015\\E", "shortCiteRegEx": "Lebret and Collobert", "year": 2015}, {"title": "Efficient Estimation of Word Representations in Vec", "author": ["T Press. Mikolov"], "venue": null, "citeRegEx": "Mikolov,? \\Q2013\\E", "shortCiteRegEx": "Mikolov", "year": 2013}, {"title": "TagSpace: Semantic embeddings from hashtags", "author": ["works", "J NIPS. Weston"], "venue": null, "citeRegEx": "works and Weston,? \\Q2014\\E", "shortCiteRegEx": "works and Weston", "year": 2014}, {"title": "Convolutional Neural Network for Paraphrase", "author": ["W. NAACL. Yin", "H. Sch\u00fctze"], "venue": null, "citeRegEx": "Yin and Sch\u00fctze,? \\Q2015\\E", "shortCiteRegEx": "Yin and Sch\u00fctze", "year": 2015}], "referenceMentions": [{"referenceID": 2, "context": "Especially on social media, millions of such short texts are sent every day, and it quickly becomes a daunting task to find similar messages among them, which is at the core of applications such as event detection (De Boom et al. (2015b)), news recommendation (Jonnalagedda and Gauch (2013)), etc.", "startOffset": 218, "endOffset": 238}, {"referenceID": 2, "context": "Especially on social media, millions of such short texts are sent every day, and it quickly becomes a daunting task to find similar messages among them, which is at the core of applications such as event detection (De Boom et al. (2015b)), news recommendation (Jonnalagedda and Gauch (2013)), etc.", "startOffset": 218, "endOffset": 291}, {"referenceID": 0, "context": "Such an embedding is a distributed vector representation of a single word in a fixed-dimensional semantic space, as opposed to term tfidf vectors, in which a word is represented by a one-hot vector (Achananuparp et al. (2008); Manning et al.", "startOffset": 199, "endOffset": 226}, {"referenceID": 0, "context": "Such an embedding is a distributed vector representation of a single word in a fixed-dimensional semantic space, as opposed to term tfidf vectors, in which a word is represented by a one-hot vector (Achananuparp et al. (2008); Manning et al. (2009)).", "startOffset": 199, "endOffset": 249}, {"referenceID": 10, "context": "Although LSI and LDA have been used with success in the past, Skip-gram models have been shown to outperform them in various tasks (Mikolov et al. (2013); Lebret and Collobert (2015)).", "startOffset": 132, "endOffset": 154}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)).", "startOffset": 8, "endOffset": 36}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al.", "startOffset": 8, "endOffset": 476}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al.", "startOffset": 8, "endOffset": 494}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)).", "startOffset": 8, "endOffset": 512}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)).", "startOffset": 8, "endOffset": 538}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)). Such an approach, however, requires either an input of fixed length or aggregation operations \u2013 such as dynamic k-max pooling (Kalchbrenner et al. (2014)) \u2013 to arrive at a sentence representation that has the same dimensionality for every input.", "startOffset": 8, "endOffset": 694}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)). Such an approach, however, requires either an input of fixed length or aggregation operations \u2013 such as dynamic k-max pooling (Kalchbrenner et al. (2014)) \u2013 to arrive at a sentence representation that has the same dimensionality for every input. Recurrent neural networks (RNNs) and variants can overcome the problem of fixed dimensionality or aggregation, since one can feed word after word in the system and in the end arrive at a text representation (Sutskever et al. (2014); Sordoni et al.", "startOffset": 8, "endOffset": 1018}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)). Such an approach, however, requires either an input of fixed length or aggregation operations \u2013 such as dynamic k-max pooling (Kalchbrenner et al. (2014)) \u2013 to arrive at a sentence representation that has the same dimensionality for every input. Recurrent neural networks (RNNs) and variants can overcome the problem of fixed dimensionality or aggregation, since one can feed word after word in the system and in the end arrive at a text representation (Sutskever et al. (2014); Sordoni et al. (2015); Sundermeyer et al.", "startOffset": 8, "endOffset": 1041}, {"referenceID": 10, "context": "(2013); Lebret and Collobert (2015)). In Skip-gram, part of Google\u2019s word2vec toolkit1, distributed word embeddings are learned through a neural network architecture to predict its surrounding words in a fixed window. Once the word embeddings are obtained, we have to combine them into a useful sentence representation. One possibility is to use an multilayer perceptron (MLP) with the whole sentence as an input, or a 1D convolutional neural network (Collobert et al. (2011); Hu et al. (2014); Xu et al. (2015); Johnson and Zhang (2015)). Such an approach, however, requires either an input of fixed length or aggregation operations \u2013 such as dynamic k-max pooling (Kalchbrenner et al. (2014)) \u2013 to arrive at a sentence representation that has the same dimensionality for every input. Recurrent neural networks (RNNs) and variants can overcome the problem of fixed dimensionality or aggregation, since one can feed word after word in the system and in the end arrive at a text representation (Sutskever et al. (2014); Sordoni et al. (2015); Sundermeyer et al. (2015)).", "startOffset": 8, "endOffset": 1068}, {"referenceID": 9, "context": "The recently introduced Skip-thought vectors, heavily inspired on Skip-gram, combine the learning of word embeddings with the learning of a useful sentence representation using an RNN encoder and decoder (Kiros et al. (2015)).", "startOffset": 205, "endOffset": 225}, {"referenceID": 10, "context": "Paragraph2vec is another method, inspired by the Skip-gram algorithm, to derive sentence vectors (Le and Mikolov (2014)).", "startOffset": 98, "endOffset": 120}, {"referenceID": 14, "context": "(2014); dos Santos and Gatti (2014); Yin and Sch\u00fctze (2015); Collobert et al.", "startOffset": 37, "endOffset": 60}, {"referenceID": 14, "context": "(2014); dos Santos and Gatti (2014); Yin and Sch\u00fctze (2015); Collobert et al. (2011)).", "startOffset": 37, "endOffset": 85}, {"referenceID": 2, "context": "As in (De Boom et al. (2015b)), we require that such an event is represented by one or more hashtags.", "startOffset": 10, "endOffset": 30}, {"referenceID": 2, "context": "we will also use the Euclidean distance throughout our experiments here (De Boom et al. (2015a)).", "startOffset": 76, "endOffset": 96}], "year": 2016, "abstractText": "Short text messages such as tweets are very noisy and sparse in their use of vocabulary. Traditional textual representations, such as tf-idf, have difficulty grasping the semantic meaning of such texts, which is important in applications such as event detection, opinion mining, news recommendation, etc. We constructed a method based on semantic word embeddings and frequency information to arrive at low-dimensional representations for short texts designed to capture semantic similarity. For this purpose we designed a weight-based model and a learning procedure based on a novel median-based loss function. This paper discusses the details of our model and the optimization methods, together with the experimental results on both Wikipedia and Twitter data. We find that our method outperforms the baseline approaches in the experiments, and that it generalizes well on different word embeddings without retraining. Our method is therefore capable of retaining most of the semantic information in the text, and is applicable out-of-the-box. c \u00a9 2016 Elsevier Ltd. All rights reserved.", "creator": "LaTeX with hyperref package"}}}