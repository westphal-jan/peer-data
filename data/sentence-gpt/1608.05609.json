{"id": "1608.05609", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Aug-2016", "title": "Implementing a Relevance Tracker Module", "abstract": "PC(ID) extends propositional logic with inductive definitions: rule sets under the well-founded semantics. Recently, a notion of relevance was introduced for this language. This notion determines the set of undecided literals that can still influence the satisfiability of a PC(ID) formula in a given partial assignment. The idea is that the PC(ID) solver can make decisions only on relevant literals without losing soundness and thus safely ignore irrelevant literals. The idea of validity of this concept is called proof of proof of validity (PD) or proof of validity (PL), which is used to formulate proof of validity in non-fictional forms. This logic is called proof of validity (PD), which is used to formulate proof of validity in non-fictional forms. A proof of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. This proof of validity in a given input (D), where the input has a certain validity for each input, may be evaluated with a subset of the input in the output. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. This proof of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models (BMP) will depend on the validity of the input in a given input. The proofs of validity in the computer-driven computational models", "histories": [["v1", "Fri, 19 Aug 2016 14:19:21 GMT  (129kb)", "http://arxiv.org/abs/1608.05609v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["joachim jansen", "jo devriendt", "bart bogaerts", "gerda janssens", "marc denecker"], "accepted": false, "id": "1608.05609"}, "pdf": {"name": "1608.05609.pdf", "metadata": {"source": "CRF", "title": "Implementing a Relevance Tracker Module", "authors": ["Joachim Jansen", "Jo Devriendt", "Bart Bogaerts", "Gerda Janssens", "Marc Denecker"], "emails": ["first.lastname@kuleuven.be,", "bart.bogaerts@aalto.fi"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 8.\n05 60\n9v 1\n[ cs\n.A I]\n1 9\nA ug"}, {"heading": "1 Introduction", "text": "Since the addition of conflict-driven clause learning [Marques-Silva and Sakallah, 1999], SAT solvers have made huge leaps forward. Now that these highly-performant SAT-solvers exist, research often stretches beyond SAT by extending the language supported by SAT with richer language constructs. Research fields such as SAT Modulo Theories (SMT) [Barrett et al., 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczyn\u0301ski, 1999] could be seen as following this approach. In this paper, we focus on the logic PC(ID): the Propositional Calculus extended with Inductive Definitions [Marie\u0308n et al., 2007]. The satisfiability problem for PC(ID) encodings is called SAT(ID) [Marie\u0308n et al., 2008]. SAT(ID) can be formalised as SAT modulo a theory of inductive definitions and is closely related to answer set solving. In fact, all the work we introduce in this paper is also applicable to so-called generate-define-test answer set programs.\nRecently we [Jansen et al., 2016] defined a notion of relevance for SAT(ID). The idea is that we identify a set of literals that can contribute to a solution, and then limit the solver to only make choices on those literals. We call such literals relevant. Furthermore, instead of searching for a variable assignment that satisfies the PC(ID) theory, we search for a partial assignment that contains sufficient information to guarantee satisfiability. Our approach is based on the notion of justifications [Denecker and De Schreye, 1993; Denecker et al., 2015]. As a small example, consider the following theory.\npT . \n  \n   pT \u2190 a \u2227 b. a \u2190 d \u2228 \u00ace \u2228 f. b \u2190 c \u2228 \u00acg \u2228 h. e \u2190 f \u2228 \u00ach \u2228 i.\n\n  \n  \nThis theory contains one constraint, that pT must hold, and a definition (between \u2018{\u2019 and \u2018}\u2019) of pT in terms of variables a to i. One way to check satisfiability would be to generate an assignment of all variables that satisfies the above theory (this is the classical approach to solving such problems). What we do, on the other hand, is to search for a partial assignment to these variables such that pT is justified in that partial assignment. Consider for example the partial assignment where pT , a, b, c and d are true and everything else is unknown. In this assignment, a and b are justified because d and c hold respectively; pT is justified because both a and b are justified. This suffices to determine satisfiability of the theory, without considering the definition of e for instance.\nIntuitively, a literal is relevant if it can contribute to justifying the theory. In the above example, as soon as d is assigned true, the variable e becomes irrelevant. From that point onwards, search should not take e\u2019s defining rule into account.\nJansen et al. [2016] have studied relevance extensively from the theoretical perspective and ran experiments to determine how relevance influences the number of choices and the number of conflicts a solver encounters. These experiments concluded that VSIDS chooses a significant number of relevant literals, and that prevention of decisions on irrelevant literals can lead to significant performance gains in some hand-constructed examples. The actual implementation has not yet been described in detail. That is exactly the goal of this paper. The insights presented in this paper should make it possible to implement relevance in other solvers as well, for instance in ASP solvers. In fact, our implementation heavily relies on components that are already present in modern ASP solvers. To be precise, we reuse propagation mechanisms for inductive definitions and an unfounded set detection algorithm.\nThe main contributions of this paper are (1) the introduction of a method to keep track of justification status in a SAT(ID) solver, (2) the introduction of a method to keep track of relevance status in a SAT(ID) solver, and (3) a discussion on the properties of these implementations."}, {"heading": "2 Preliminiaries: SAT(ID), Relevance", "text": "Here we give a short introduction on PC(ID), SAT(ID), justifications, relevance, and recall how relevance can be exploited to improve PC(ID) solvers. For a more elaborate exposition we refer to Jansen et al. [2016]."}, {"heading": "2.1 PC(ID)", "text": "We briefly recall the syntax and semantics of Propositional Calculus extended with Inductive Definitions (PC(ID)) [Marie\u0308n, 2009].\nA truth value is one of {t, f ,u}; t represents true, f false and u unknown. The truth order \u2264t on truth values is given by f \u2264t u \u2264t t, the precision order \u2264p is given by u \u2264p f and u \u2264p t. Let \u03a3 be a finite set of symbols called atoms. A literal l is an atom p or its negation \u00acp. In the former case, we call l positive, in the latter, we call l negative. We use \u03a3 to denote the set of all literals over \u03a3. If l is a literal, we use |l| to denote the atom of l, i.e., to denote p whenever l = p or l = \u00acp. We use \u223cl to denote the literal that is the negation of l, i.e., \u223cp = \u00acp and \u223c\u00acp = p. Propositional formulas are defined as usual. We use \u03d5 \u21d2 \u03c8 for material implication, i.e., as a shorthand for \u00ac\u03d5 \u2228 \u03c8.\nA partial interpretation I is a mapping from \u03a3 to truth values. We use the notation {pt1, . . . , p t n, q f 1, . . . , q f m} for the partial interpretation that maps the pi to t, the qi to f and all other atoms to u. We call a partial interpretation two-valued if it does not map any atom to u. If I and I \u2032 are partial interpretations, we say that I is less precise than I \u2032 (notation I \u2264p I \u2032) if for all p \u2208 \u03a3, I(p) \u2264p I \u2032(p). If \u03d5 is a propositional formula, we use \u03d5I to denote the truth value (t, f or u) of \u03d5 in I, based on the Kleene truth tables [Kleene, 1938]. If I is a partial interpretation and l a literal, we use I[l : t] to denote the partial interpretation equal to I, except that it interprets l as t (and similar for f , u). If \u03a3\u2032 \u2286 \u03a3, we use the notation I|\u03a3\u2032 to indicate the restriction of I to symbols in \u03a3\u2032. This restriction is a partial interpretation of \u03a3 and satisfies I|\u03a3\u2032(p) = u if p /\u2208 \u03a3\u2032 and I|\u03a3\u2032(p) = I(p) otherwise. In the rest of this text, when we just say interpretation, we mean a twovalued partial interpretation. An interpretation I is completely characterised by the set of atoms p such that I(p) = t. As such, slightly abusing notation, we often identify an interpretation with a set of atoms.\nAn inductive definition \u2206 over \u03a3 is a finite set of rules of the form p \u2190 \u03d5 where p \u2208 \u03a3 and \u03d5 is a propositional formula over \u03a3. We call p the head of the rule and \u03d5 the body of the rule. We call p defined in \u2206 if p occurs as the head of a rule in \u2206. The set of all symbols defined in \u2206 is denoted by defs(\u2206). All other symbols are called open in \u2206. The set of open symbols in \u2206 is denoted opens(\u2206). We say that a literal l is defined in \u2206 if |l| \u2208 defs(\u2206). We use the parametrised well-founded semantics for inductive definitions [Denecker and Vennekens, 2007]. That is, interpretation I is a model of\u2206 (denoted I |= \u2206) if I is the well-founded model of \u2206 in context I|opens(\u2206). We call an inductive definition total if for every interpretation I of the open symbols, the well-founded model in context I is a two-valued interpretation.\nA PC(ID) theory T over \u03a3 is a set of propositional formulas, called constraints, and inductive definitions over\u03a3. Interpretation I is a model of T if I is a model of all definitions and constraints in T . Without loss of generality [Marie\u0308n, 2009], we assume that every PC(ID) theory is in Definition Normal Form (DEFNF), where T = {pT , \u2206} and \u2013 pT is an atom,\n\u2013 \u2206 is an inductive definition defining pT , \u2013 every rule in \u2206 is of the form p \u2190 l1 \u2299 \u00b7 \u00b7 \u00b7 \u2299 ln, where \u2299 is either \u2227 or \u2228, p\nis an atom, and each of the li are literals, \u2013 every atom p is defined in at most one rule of \u2206.\nA rule in which \u2299 is \u2227, respectively \u2228 is called a conjunctive, respectively disjunctive, rule. The rules in a definition \u2206 impose a direct dependency relation, denoted dd\u2206, between literals, defined as follows. For every rule p\u2190 l1\u2299\u00b7 \u00b7 \u00b7\u2299 ln in \u2206, dd\u2206 contains (p, li) and (\u223cp,\u223cli) for all 1 \u2264 i \u2264 n. The dependency graph of \u2206 is the graph G\u2206 = (\u03a3, dd\u2206).\nFor the remainder of the paper, we assume that some PC(ID) theory T = {pT , \u2206} is fixed.\nIt has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions. Following these arguments, in the rest of this paper we assume \u2206 to be a total definition.\nThe satisfiability problem for PC(ID), i.e., deciding whether a PC(ID) theory has a model, is called SAT(ID). This problem is NP-complete [Marie\u0308n et al., 2008]."}, {"heading": "2.2 Justifications", "text": "Consider a directed graph G = (V,E), with V a set of nodes and E a set of edges. If G contains an edge from l to l\u2032 (i.e., (l, l\u2032) \u2208 E), we say that l is a parent of l\u2032 in G and that l\u2032 is a child of l in G. A node l is called a leaf of G if it has no children in G; otherwise it is called internal in G. Let G\u2032 = (V \u2032, E\u2032) be another graph. We define the union of two graphs (denoted G \u222a G\u2032) as the graph with vertices V \u222a V \u2032 and edges E \u222a E\u2032.\nSuppose l is a literal with p = |l| and p \u2208 defs(\u2206) with defining rule p \u2190 l1 \u2299 \u00b7 \u00b7 \u00b7 \u2299 ln. A set of literals Jd is a direct justification of l in \u2206 if one of the following holds:\n\u2013 l = p, \u2299 is \u2227, and Jd = {l1, . . . , ln}, \u2013 l = p, \u2299 is \u2228, and Jd = {li} for some i, \u2013 l = \u00acp, \u2299 is \u2227, and Jd = {\u223cli} for some i, \u2013 l = \u00acp, \u2299 is \u2228, and Jd = {\u223cl1, . . . ,\u223cln}.\nNote that a direct justification of a literal can only contain children of that literal in the dependency graph.\nA justification [Denecker and De Schreye, 1993; Denecker et al., 2015] J of a definition \u2206 is a subgraph of G\u2206, such that each internal node l \u2208 J is a defined literal and the set of its children is a direct justification of l in \u2206. We say that J contains l if l occurs as node in J . A justification is total if none of its leaves are defined literals. A justification can contain cycles.1 A cycle is called positive\n1 In this text, we assume that \u2206 is finite; in this case cycles are simply loops in the graph. The infinite case is a bit more subtle, and an adapted definition of cycle is required to maintain all results presented below.\n(resp. negative) if it contains only positive (resp. negative) literals. It is called a mixed cycle otherwise.\nIf J is a justification and I a (partial) interpretation, we define the value of J in I, denoted VI(J) as follows: \u2013 VI(J) = f if J contains a leaf l with l\nI = f or a positive cycle (or both). \u2013 VI(J) = u if VI(J) 6= f and J contains a leaf l with lI = u or a mixed cycle\n(or both). \u2013 VI(J) = t otherwise (all leaves are t and cycles, if any, are negative). A literal l is justified (in I, for T ) if there exists a total justification J (of \u2206) that contains l such that VI(J) = t. In this case, we say that such a J justifies l (in I, for T ). It follows from the definition that it is not possible that both l and \u00acl are justified in the same in the same interpretation.\nThe justification status of an atom p (in I, for T ) is defined as follows. The justification status of p is true if and only if the literal p is justified in I for T . The justification status of p is false if and only if the literal \u00acp is justified in I for T . Otherwise the justification status of p is unknown.\nDenecker and De Schreye [1993] and later also Denecker et al. [2015] showed that many semantics of logic programs can be captured by justifications."}, {"heading": "2.3 Relevance", "text": "Now, we recall the central definitions and theorems related to relevance. For a more detailed exposition of the theoretical foundations, we refer to Jansen et al. [2016].\nTheorem 1 ([Jansen et al., 2016]; Theorem 3.1). T is satisfiable if and only if there exists a partial interpretation I and a justification J that justifies pT in I.\nDefinition 1 ([Jansen et al., 2016]; Definition 3.2). Given a PC(ID) theory T = {pT , \u2206} and a partial interpretation I, we inductively define the set of relevant literals, denoted RT ,I, as follows \u2013 pT is relevant if pT is not justified, \u2013 l is relevant if l is not justified and there exists some l\u2032 such that (l\u2032, l) \u2208 dd\u2206\nand l\u2032 is relevant.\nThe central theorem regarding relevance shows that any search algorithm that arrives in a state in which pT is justified by deciding on a literal l that is irrelevant can also arrive in such a state without deciding on l. Hence, if a literal l is irrelevant, choosing on l does not help justifying pT .\nTheorem 2 ([Jansen et al., 2016]; Theorem 3.5). Let T = {pT , \u2206} be a PC(ID) theory. Suppose I is a partial interpretation and l a literal such that I(|l|) = u and l is not relevant in I. If pT is justified in some partial interpretation I \u2032 more precise than I, then pT is also justified in I \u2032[l : f ] and in I \u2032[l : t].\nConsequently, the work suggests adapting SAT(ID) solvers such that they (1) do not make decisions on irrelevant literals, and (2) stop searching when there are no relevant literals left. This requires the underlying solver to keep track of which literals are relevant. This task is incremental in nature: small changes to the state of the solver will result in small changes to the relevance of literals. Since modern solvers work with hunderds of thousands of variables and go through millions of assignment in quick succession, it is essential to do these changes as efficiently as possible."}, {"heading": "3 The Basic Framework", "text": "The aim of this work is to discuss the implementation of an algorithm to keep track of relevant literals.\nAs said in Theorem 1, the solver aims to arrive at a state S where pT is justified in I. The solver does this by making decisions, performing propagation, and backtracking. To prevent the solver from making \u201cuseless\u201d decisions, we need to know whether literals are relevant or not in I.\nWe consider the underlying solver to have an internal state S of the form S = \u3008\u03a3, T , I\u3009, with (1) \u03a3 denoting the set of literals used in the solver, (2) T = {pT , \u2206} a DEFNF theory, and (3) I the current partial interpretation in the solver.\nDuring the search process, the (CDCL) solver adds learned conflict clauses to the theory. However, learned conflict clauses are logical consequences of the theory and because of this we do not consider them to be a part of the theory T in S. Instead, T is reserved for non-learned clauses. We assume T to remain static during the search process. This assumption is valid in most ground-andsolve systems. Recent work focuses on interleaving this process [De Cat et al., 2015]. Extending this work to allow for a changing theory is future work, but should be of limited complexity given the framework we present here.\nThe relevance tracker needs to take into account changes in the solver state, in particular in I. Before we define the interface between the relevance tracker and the solver, we discuss the solver state and its changes.\nDuring the search process, the solver iteratively performs one of the following state changes:\n\u2013 \u3008\u03a3, T , I\u3009 7\u2192 \u3008\u03a3, T , I[l : t]\u3009 a literal l becomes true, or \u2013 \u3008\u03a3, T , I\u3009 7\u2192 \u3008\u03a3, T , I[l : u]\u3009 a literal l becomes unknown.\nNote that this set of operations allows the solver to make a literal l false by making literal \u223cl true.\nIn order to get the necessary information about the changes of the solver and to implement the above revision problem, the relevance tracker listens to notifications. The relevance tracker supports the following interface to the underlying solver.\nnotifyBecomesTrue a literal l becomes true in I\nnotifyBecomesUnknown a literal l becomes unknown in I isRelevant query whether a given literal l is relevant (returns a boolean value)\nMethods notifyBecomesTrue and notifyBecomesUnknownmust be called by the underlying solver when a literal has become true, respectively unknown. The isRelevant method is used by the solver to ask the module whether the given literal is relevant. The relevance information allows the solver to change its underlying heuristic, selecting only relevant literals."}, {"heading": "4 Deriving the justification status of literals", "text": "The definition of relevance relies on knowledge about which literals are justified in the solver. In this section, we discuss how we implemented extraction of this information. We opted to implement a method that re-uses the underlying SAT(ID) solver to keep track of the justification status of literals. The method creates a new atom, called the \u201cjustification atom\u201d, for each defined atom p, denoted as j(p). We call a literal j(p) or \u00acj(p) a justification literal.\nThe intended interpretation of j(p) is that j(p) is true iff p is justified, j(p) is false iff \u00acp is justified and j(p) is unknown otherwise. To ensure that justification literals indeed get the right value, an extra PC(ID) definition \u2206j , denoted the \u201cjustification definition\u201d, is added to the theory T . \u2206j is constructed based on the original definition \u2206 in the following manner. The existing definition \u2206 is copied, except that every defined atom p is replaced with the newly created atom j(p). Thus, of all the atoms in the original definition, only the open atoms remain.\nExample 1. Transforming the original definition\n\u2206 =\n\n      \n       pT \u2190 c1 \u2227 c2 \u2227 c3 \u2227 c4 c1 \u2190 \u00acb \u2228 \u00acd c2 \u2190 a \u2228 b \u2228 \u00acc c3 \u2190 \u00acb \u2228 e \u2228 \u00acf c4 \u2190 d \u2228 f \u2228 \u00aca f \u2190 b \u2228 d\n\n      \n      \nleads to the justification definition\n\u2206j =\n\n      \n      j(pT ) \u2190 j(c1) \u2227 j(c2) \u2227 j(c3) \u2227 j(c4) j(c1) \u2190 \u00acb \u2228 \u00acd j(c2) \u2190 a \u2228 b \u2228 \u00acc j(c3) \u2190 \u00acb \u2228 e \u2228 \u00acj(f) j(c4) \u2190 d \u2228 j(f) \u2228 \u00aca j(f) \u2190 b \u2228 d\n\n      \n     \nIn addition to the creation of this new definition \u2206j , we prohibit the solver from making choices on these justification atoms. Because of this, the value of all j(p) will be purely the result of the underlying propagation mechanism for definitions. Our claim is now that existing propagation mechanisms will propagate\nexactly those literals that are justified. We assume a solver that performs unit propagation and unfounded set propagation [Gebser et al., 2012; Marie\u0308n et al., 2007], i.e., propagation that makes all atoms in an unfounded set false.\nTheorem 3. Let \u2206 be a (total) definition and I a partial interpretation in which all defined symbols of \u2206 are interpreted as u. Let l be a defined literal in \u2206. In this case l is justified in I if and only if l is derivable by unit propagation on the completion2[Clark, 1978] of \u2206 and unfounded set propagations.\nProof (Sketch of the proof). Intuitively, from a sequence of propagations, we can create a justification and vice versa: each justification induces a sequence of propagations. The correspondence is as follows. First for the completion, if \u2206 contains a rule p \u2190 l1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ln, then this rule propagates p = t if and only if each of the li is true. This corresponds to the justification\np\nl1 . . . ln\nAnd similar justification constructs can be defined for when \u00acp is propagated or when the rule is disjunctive.\nUnfounded set propagation essentially corresponds to a justification of a set of negative facts by a negative cycle.\nThe condition that a justification can have no mixed or positive cycles corresponds to the fact that propagation must happen in order. E.g., from the rule p \u2190 p \u2228 q, p can only be propagated if q is true; p cannot be propagated \u201cbecause p is true\u201d. \u2293\u2294\nThe previous theorem establishes that our approach works; a justification literal j(p) will be propagated to true if p is justified (note that p is justified iff j(p) is justified). It also explains why we use a duplicated definition: the theorem only holds if I is an opens(\u2206) interpretation. Since this cannot be enforced (we don\u2019t want to intrude in the solver\u2019s search), we make a copy and never make choices on the copied defined symbols.\nThus, we extend our solver state S = \u3008\u03a3, T , I\u3009 to a S \u2032 = \u3008\u03a3 \u2032 , T \u2032, I \u2032, \u03a3\u2032\u3009 with\n\u2013 \u03a3\u2032 = set containing the newly introduced justification atoms that the solver cannot decide on \u2013 \u03a3 \u2032 = \u03a3 \u222a\u03a3\u2032 \u2013 T \u2032 = {pT , \u2206\u2032} if T = {pT , \u2206} and \u2206\u2032 = \u2206 \u222a\u2206j \u2013 I \u2032 = a partial structure over \u03a3 \u2032\nWith all this in place, we derive the interpretation for justified(l) as follows.\n\u2013 justified(p) is true if and only if j(p) is true in I \u2032, and \u2013 justified(\u00acp) is true if and only if j(p) is false in I \u2032.\n2 The completion of a rule p\u2190 q is the underapproximation using the first-order logic (FO) sentence p\u21d4 q, which demands that p and q hold equal truth values"}, {"heading": "5 Implementing the relevance tracker", "text": "The source code that implements the techniques discussed here can be found at https://dtai.cs.kuleuven.be/static/krr/files/experiments/idp_relevance_ experiments.tar.gz .\nThe solver maintains a subgraph of the dependency graph in order to keep track of the set of relevant literals. This subgraph, denoted as the relevance graph contains all literals that are relevant and all edges between them (in the dependency graph). As such, the task of the tracker is to determine whether a given literal is a member of this graph or not. We store this graph using a data structure, denoted candidate parents(l) that associates a literal with a set of literals called \u201ccandidate parents\u201d. The \u201ccandidate parents\u201d of l are the literals that are parents of l in the relevance graph. I.e., if l is irrelevant, this set is empty, otherwise, it consists of all relevant parents of l in the dependency graph. As such, it can be seen that there is an edge (p, l) in the relevance graph iff p \u2208 candidate parents(l). Thus, l is relevant if and only if l has a non-empty set of candidate parents. We now describe an incremental algorithm to update the set of candidate parents for all literals if the state of the solver changes. We prefer to keep these changes local, i.e., to not reconstruct the entire relevance graph with each solver change.\nWhen the solver state changes, and the set of candidate parents must be updated, care must be taken to detect and remove cyclic dependencies. These cyclic dependencies can arise when a candidate parent is removed from a literal l and the remaining candidate parents of that literal are not reachable from pT anymore but still have l as a candidate parent, creating a loop. A more detailed example is given in Example 2\nExample 2. The following definition has the cyclic dependency of p\u2190 q \u2190 p.\n\n\n pT \u2190 a \u2228 p p\u2190 q q \u2190 p\n\n\n\nInitially I = \u2205, thus nothing is justified and all literals are relevant. Thus, p has candidate parents {pT , q}, and q has candidate parents {p}.\nConsider the case where a becomes true and hence pT becomes justified.\nSimply removing pT from the set of candidate parents of p means that p still has candidate parents {q}, which is actually just a loop leading back to p. Thus, a cycle detection algorithm is needed to force p and q to remain loop-free.\nThus, adding and removing candidate parents is a complicated matter. In Section 5.4 we discuss how this cycle detection is done. For now, we use the following interface for adjusting the set of a candidate parents.\nnotifyAddCandidateParent(l,l\u2032) add l\u2032 to the candidate parents of l notifyRemoveCandidateParent(l,l\u2032) remove l\u2032 from the candidate parents\nof l\nOur definition of candidate parents potentially changes when the following changes take place (note that we already assumed the dependency relation to be non-changeable).\n\u2013 A change in the justification status of l \u2013 A change in the relevance status of a parent literal l\u2032\nThus, we extend the interface of the relevance tracker to also support the following methods.\nnotifyBecomesJustified(l) A literal l goes from unjustified to justified notifyBecomesUnjustified(l) A literal l goes from justified to unjustified notifyBecomesRelevant(l) A literal l goes from irrelevant to relevant notifyBecomesIrrelevant(l) A literal l goes from relevant to irrelevant\nIn the following subsections we present (1) an overview of the data structures in the relevance tracker and (2) the algorithms for the methods in our interface."}, {"heading": "5.1 Data Structures", "text": "The data structures include sets and maps. Unless specified otherwise, we use hash sets and hash maps. The implementation uses std::unordered set and std::unordered map provided by the C++ standard library.\nInternally, we store the dependency relation dd\u2206 using two maps in our module, named children and parents. These data structures map a literal to a set of literals. The first map (children) maps a literal to its set of children in dd\u2206. The second map (parents) maps a literal to its set of parents in dd\u2206. They are initialised using the notifyNewRulemethod. Once they are initialised, they remain fixed.\nWe use a map (to just lit) to transform a normal literal to its justification literal (p 7\u2192 j(p), \u00acp 7\u2192 \u00acj(p)). For efficiency reasons, we also maintain the inverse map to nonjust lit = to just lit\u22121. These maps are initialised when the justification definition \u2206j is created and do not change during execution afterwards.\nWe maintain a set of atoms (is just atom) to identify the justification atoms that were introduced. This set are initialised when the justification definition \u2206j is created and does not change during execution afterwards.\nWe use round brackets to indicate the result of a map lookup, e.g.,\nto just lit(p) = j(p).\nWe use round brackets to do a containment check of sets. More precisely,\nis just atom(p) = true\nif and only if p is in the set is just atom. As mentioned before, the underlying solver is not allowed to make decisions on literals in this set.\nWe maintain a map candidate parents with the invariant that it maps a literal l to the set of candidate parents of l. This map is dynamic throughout execution and changes to this map are performed using the notifyAddCandidateParent and notifyRemoveCandidateParent methods."}, {"heading": "5.2 Notification-based Algorithms", "text": "Given that the invariant of candidate parents is satisfied in solver state S = \u3008\u03a3, T , I\u3009, we wish to perform the necessary changes such that they are satisfied in solver state S \u2032 = \u3008\u03a3, T , I[p : tv]\u3009 with p some atom and tv one of {t, f ,u}.\nWe initiate our notification-based algorithm as follows. If tv = t, then we call notifyBecomesTrue(p). If tv = f , then we call notifyBecomesTrue(\u00acp). If tv = u, then we call notifyBecomesUnknown(p).\nThis call, in turn, can trigger other internal notifications. The implementation of these cascading notifications ensures that candidate parents will comply with its invariant in interpretation S \u2032 after the designated call to notifyBecomesTrue or notifyBecomesUnknown is complete.\nThe relevance tracker implements isRelevant(l) by checking whether candidate parents(l)maps to an empty set or not. This is a correct representation of the relevance status of l if the invariant of candidate parents is satisfied.\nFor methods notifyBecomesTrue(l), notifyBecomesUnknown(l): the given literal can be a normal literal (p or \u00acp) or a justification literal (j(p) or \u00acj(p)). The relevance tracker takes no action for normal literals. If the given literal is a justification literal, then we retrieve the original normal literal and notify the relevance tracker that this literal has become (un)justified. Note that we re-use the notation of |l| to indicate the atom of literal l. notifyBecomesTrue(l): if is just atom(|l|), then call notifyBecomesJustified(to nonjust lit(l)).\nnotifyBecomesUnknown(l): if is just atom(|l|), then call notifyBecomesUnjustified(to nonjust lit(l)). notifyBecomesJustified(l): call notifyRemoveAllCandidateParentsOf(l). notifyBecomesUnjustified(l): for all parents p of l that are relevant, call notifyAddCandidateParent(l,p). notifyBecomesRelevant(l): for all children c of l, call notifyAddCandidateParent(c,l). notifyBecomesIrrelevant(l): for all children c of l, call notifyRemoveCandidateParent(c,l)."}, {"heading": "5.3 Maintaining watches instead of sets of candidates", "text": "The above methods dictate how the candidate parents map should be manipulated. For efficiency reasons, the relevance tracker does not actively maintain this set of candidate parents. Instead it keeps track of a single candidate parent as \u201cwatched\u201d parent. This watched parent is maintained using a map called watched parent(l) that maps a literal to a single parent of l. The method isRelevant(l) now checks whether a given literal l has a watched parent or not.\nWe only keep track of a single watched parent in order to minimize how many times a cycle detection algorithm has to be invoked. The manipulation of the set of candidate parents, along with the invocation of a cycle detection algorithm is done as follows\nnotifyAddCandidateParent(l,l\u2032) Check for the following criteria \u2013 l does not have a watched parent yet \u2013 l is not justified \u2013 l\u2032 is relevant \u2013 l is a child of l\u2032\nIf they are met, make watched parent(l) = l\u2032 and call notifyBecomesRelevant(l). Note that a cyclic dependency check between l and l\u2032 is not needed, since l could not have been a suitable watch for any other literal, as it was not relevant before. notifyRemoveCandidateParent(l,l\u2032) If l had l\u2032 as its watch, remove l\u2032 as watched parent of l. Try to find an alternative candidate parent n such that the following hold. \u2013 n 6= l\u2032\n\u2013 l is a child of n \u2013 l is not justified \u2013 n is relevant \u2013 Use a cycle detection algorithm to verify that setting watched parent(l)\n= n would not create a dependency cycle If such n can be found, set watched parent(l) = n. If such n cannot be found, call notifyBecomesIrrelevant(l).\nThe implementation for the search for an alternative watch is a re-use of an existing \u201cunfounded set detection\u201d algorithm. This algorithm is considered the fastest algorithm to achieve this task to date."}, {"heading": "5.4 Detecting Cycles", "text": "For our implementation of the detection of cycles, we re-use parts of the existing unfounded set propagation algorithm [Gebser et al., 2012; Marie\u0308n et al., 2007]. This algorithm has a subcomponent that searches for cycles over negative literals."}, {"heading": "6 Conclusion and Future Work", "text": "The notion of relevance is related to Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of Logic Programming in the sense that the resulting program of the magic set transformation on a program P and query Q does not execute parts of P that do not contribute towards solving query Q.\nOne area where relevance should give great speedups is stable model counting. When pT is justified, the number of solutions that this partial assignment represents is equal to 2n with n the number of unassigned open atoms in \u2206. Stable model counters generally stop when the justified residual program [Aziz et al., 2015] is empty. Whenever this occurs, pT is justified. However, this does not hold the other way round. There are other cases where pT is justified, but the justified residual program is non-empty. As such, exploiting relevance can ensure cutting out bigger parts of the search tree when model counting.\nIn this paper we have presented our implementation of a relevance tracker module on top of an existing SAT(ID) solver, which consists of two methods; one to keep track of the set of justified literals and one to keep track of the set of relevant literals. Each of them reuses existing techniques, namely the following.\n\u2013 Our method for keeping track of the justification status of literals. This method reuses existing propagation mechanisms. We also prove the correctness of this approach if the underlying solver guarantees completeness with respect to rule application and unfounded set propagation.\n\u2013 Our method for keeping track of the relevance status of literals reuses the existing unfounded set detection techniques [Gebser et al., 2012; Marie\u0308n et al., 2007] for detection of cyclic dependencies between \u201ccandidate parents\u201d.\nGenerate-and-test ASP programs are the most common form of ASP programs, as can be witnessed, e.g., from the benchmarks in the latest ASP competitions [Calimeri et al., 2016]. Generate-and-test ASP programs closely correspond to PC(ID) theories [Denecker et al., 2012]. This paper imposes minimal assumptions on the underlying solver, thus making it possible to translate these ideas to an ASP context. Since experiments have shown [Jansen et al., 2016] that exploiting relevance during solving can reduce the number of decisions, as well as the number of conflicts, it would be interesting to see how relevance might possibly affects existing ASP solvers."}, {"heading": "Acknowledgements", "text": "This research was supported by the project GOA 13/010 Research Fund KU Leuven and projects G.0489.10, G.0357.12 and G.0922.13 of FWO (Research Foundation - Flanders). Bart Bogaerts is supported by the Finnish Center of Excellence in Computational Inference Research (COIN) funded by the Academy of Finland (grant #251170)."}], "references": [{"title": "Principles of Constraint Programming", "author": ["Krzysztof R. Apt"], "venue": null, "citeRegEx": "Apt.,? \\Q2003\\E", "shortCiteRegEx": "Apt.", "year": 2003}, {"title": "Stable model counting and its application in probabilistic logic programming", "author": ["Rehan Abdul Aziz", "Geoffrey Chu", "Christian J. Muise", "Peter James Stuckey"], "venue": null, "citeRegEx": "Aziz et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Aziz et al\\.", "year": 2015}, {"title": "Magic sets and other strange ways to implement logic programs (extended abstract)", "author": ["Francois Bancilhon", "David Maier", "Yehoshua Sagiv", "Jeffrey D Ullman"], "venue": "In Proceedings of the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems,", "citeRegEx": "Bancilhon et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Bancilhon et al\\.", "year": 1986}, {"title": "Satisfiability modulo theories", "author": ["Clark W. Barrett", "Roberto Sebastiani", "Sanjit A. Seshia", "Cesare Tinelli"], "venue": "Handbook of Satisfiability,", "citeRegEx": "Barrett et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2009}, {"title": "Special issue: Database logic progamming on the power of magic", "author": ["Catriel Beeri", "Raghu Ramakrishnan"], "venue": "The Journal of Logic Programming,", "citeRegEx": "Beeri and Ramakrishnan.,? \\Q1991\\E", "shortCiteRegEx": "Beeri and Ramakrishnan.", "year": 1991}, {"title": "Design and results of the fifth answer set programming competition", "author": ["Francesco Calimeri", "Martin Gebser", "Marco Maratea", "Francesco Ricca"], "venue": "Artif. Intell.,", "citeRegEx": "Calimeri et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2016}, {"title": "Negation as failure. In Logic and Data Bases, pages 293\u2013322", "author": ["Keith L. Clark"], "venue": null, "citeRegEx": "Clark.,? \\Q1978\\E", "shortCiteRegEx": "Clark.", "year": 1978}, {"title": "Lazy model expansion: Interleaving grounding with search", "author": ["Broes De Cat", "Marc Denecker", "Maurice Bruynooghe", "Peter J. Stuckey"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Cat et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Cat et al\\.", "year": 2015}, {"title": "The well-founded semantics is the principle of inductive definition", "author": ["Marc Denecker"], "venue": "JELIA, volume 1489 of LNCS,", "citeRegEx": "Denecker.,? \\Q1998\\E", "shortCiteRegEx": "Denecker.", "year": 1998}, {"title": "Justification semantics: A unifying framework for the semantics of logic programs", "author": ["Marc Denecker", "Danny De Schreye"], "venue": "URL https:// lirias.kuleuven.be/handle/123456789/133075", "citeRegEx": "Denecker and Schreye.,? \\Q1993\\E", "shortCiteRegEx": "Denecker and Schreye.", "year": 1993}, {"title": "A logic of nonmonotone inductive definitions", "author": ["Marc Denecker", "Eugenia Ternovska"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "Denecker and Ternovska.,? \\Q2008\\E", "shortCiteRegEx": "Denecker and Ternovska.", "year": 2008}, {"title": "Well-founded semantics and the algebraic theory of non-monotone inductive definitions", "author": ["Marc Denecker", "Joost Vennekens"], "venue": "LPNMR, volume 4483 of Lecture Notes in Computer Science,", "citeRegEx": "Denecker and Vennekens.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2007}, {"title": "The well-founded semantics is the principle of inductive definition, revisited", "author": ["Marc Denecker", "Joost Vennekens"], "venue": "URL http://www.aaai.org/ocs/index.php/KR/KR14/paper/view/7957", "citeRegEx": "Denecker and Vennekens.,? \\Q2014\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2014}, {"title": "A Tarskian informal semantics for answer set programming", "author": ["law Truszczy\u0144ski", "Joost Vennekens"], "venue": "ICLP (Technical Communications),", "citeRegEx": "Truszczy\u0144ski and Vennekens.,? \\Q2012\\E", "shortCiteRegEx": "Truszczy\u0144ski and Vennekens.", "year": 2012}, {"title": "solving: From theory to practice", "author": ["Joachim Jansen", "Bart Bogaerts", "Jo Devriendt", "Gerda Janssens", "Marc Denecker"], "venue": null, "citeRegEx": "Jansen et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Jansen et al\\.", "year": 2012}, {"title": "Model Generation for ID-Logic", "author": ["Maarten Mari\u00ebn"], "venue": "PhD thesis,", "citeRegEx": "Mari\u00ebn.,? \\Q2009\\E", "shortCiteRegEx": "Mari\u00ebn.", "year": 2009}, {"title": "Integrating inductive definitions in SAT", "author": ["Maarten Mari\u00ebn", "Johan Wittocx", "Marc Denecker"], "venue": "In Nachum Derschowitz and Andrei Voronkov, editors, LPAR,", "citeRegEx": "Mari\u00ebn et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Mari\u00ebn et al\\.", "year": 2007}, {"title": "SAT(ID): Satisfiability of propositional logic extended with inductive definitions", "author": ["Maarten Mari\u00ebn", "Johan Wittocx", "Marc Denecker", "Maurice Bruynooghe"], "venue": "SAT, volume 4996 of LNCS,", "citeRegEx": "Mari\u00ebn et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Mari\u00ebn et al\\.", "year": 2008}, {"title": "GRASP: A search algorithm for propositional satisfiability", "author": ["Jo\u00e3o P. Marques-Silva", "Karem A. Sakallah"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "Marques.Silva and Sakallah.,? \\Q1999\\E", "shortCiteRegEx": "Marques.Silva and Sakallah.", "year": 1999}, {"title": "Lazy clause generation: Combining the power of SAT and CP (and MIP?) solving", "author": ["Peter J. Stuckey"], "venue": "In CPAIOR,", "citeRegEx": "Stuckey.,? \\Q2010\\E", "shortCiteRegEx": "Stuckey.", "year": 2010}], "referenceMentions": [{"referenceID": 18, "context": "Since the addition of conflict-driven clause learning [Marques-Silva and Sakallah, 1999], SAT solvers have made huge leaps forward.", "startOffset": 54, "endOffset": 88}, {"referenceID": 3, "context": "Research fields such as SAT Modulo Theories (SMT) [Barrett et al., 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 50, "endOffset": 72}, {"referenceID": 0, "context": ", 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 37, "endOffset": 48}, {"referenceID": 19, "context": ", 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 87, "endOffset": 102}, {"referenceID": 16, "context": "In this paper, we focus on the logic PC(ID): the Propositional Calculus extended with Inductive Definitions [Mari\u00ebn et al., 2007].", "startOffset": 108, "endOffset": 129}, {"referenceID": 17, "context": "The satisfiability problem for PC(ID) encodings is called SAT(ID) [Mari\u00ebn et al., 2008].", "startOffset": 66, "endOffset": 87}, {"referenceID": 14, "context": "Jansen et al. [2016] have studied relevance extensively from the theoretical perspective and ran experiments to determine how relevance influences the number of choices and the number of conflicts a solver encounters.", "startOffset": 0, "endOffset": 21}, {"referenceID": 14, "context": "For a more elaborate exposition we refer to Jansen et al. [2016].", "startOffset": 44, "endOffset": 65}, {"referenceID": 15, "context": "We briefly recall the syntax and semantics of Propositional Calculus extended with Inductive Definitions (PC(ID)) [Mari\u00ebn, 2009].", "startOffset": 114, "endOffset": 128}, {"referenceID": 11, "context": "We use the parametrised well-founded semantics for inductive definitions [Denecker and Vennekens, 2007].", "startOffset": 73, "endOffset": 103}, {"referenceID": 15, "context": "Without loss of generality [Mari\u00ebn, 2009], we assume that every PC(ID) theory is in Definition Normal Form (DEFNF), where T = {pT , \u2206} and \u2013 pT is an atom,", "startOffset": 27, "endOffset": 41}, {"referenceID": 8, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 10, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 12, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 17, "context": "This problem is NP-complete [Mari\u00ebn et al., 2008].", "startOffset": 28, "endOffset": 49}, {"referenceID": 8, "context": "Denecker and De Schreye [1993] and later also Denecker et al.", "startOffset": 0, "endOffset": 31}, {"referenceID": 8, "context": "Denecker and De Schreye [1993] and later also Denecker et al. [2015] showed that many semantics of logic programs can be captured by justifications.", "startOffset": 0, "endOffset": 69}, {"referenceID": 14, "context": "For a more detailed exposition of the theoretical foundations, we refer to Jansen et al. [2016].", "startOffset": 75, "endOffset": 96}, {"referenceID": 16, "context": "We assume a solver that performs unit propagation and unfounded set propagation [Gebser et al., 2012; Mari\u00ebn et al., 2007], i.", "startOffset": 80, "endOffset": 122}, {"referenceID": 6, "context": "In this case l is justified in I if and only if l is derivable by unit propagation on the completion[Clark, 1978] of \u2206 and unfounded set propagations.", "startOffset": 100, "endOffset": 113}, {"referenceID": 16, "context": "For our implementation of the detection of cycles, we re-use parts of the existing unfounded set propagation algorithm [Gebser et al., 2012; Mari\u00ebn et al., 2007].", "startOffset": 119, "endOffset": 161}, {"referenceID": 2, "context": "The notion of relevance is related to Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of Logic Programming in the sense that the resulting program of the magic set transformation on a program P and query Q does not execute parts of P that do not contribute towards solving query Q.", "startOffset": 49, "endOffset": 103}, {"referenceID": 4, "context": "The notion of relevance is related to Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of Logic Programming in the sense that the resulting program of the magic set transformation on a program P and query Q does not execute parts of P that do not contribute towards solving query Q.", "startOffset": 49, "endOffset": 103}, {"referenceID": 1, "context": "Stable model counters generally stop when the justified residual program [Aziz et al., 2015] is empty.", "startOffset": 73, "endOffset": 92}, {"referenceID": 16, "context": "\u2013 Our method for keeping track of the relevance status of literals reuses the existing unfounded set detection techniques [Gebser et al., 2012; Mari\u00ebn et al., 2007] for detection of cyclic dependencies between \u201ccandidate parents\u201d.", "startOffset": 122, "endOffset": 164}, {"referenceID": 5, "context": ", from the benchmarks in the latest ASP competitions [Calimeri et al., 2016].", "startOffset": 53, "endOffset": 76}], "year": 2016, "abstractText": "PC(ID) extends propositional logic with inductive definitions: rule sets under the well-founded semantics. Recently, a notion of relevance was introduced for this language. This notion determines the set of undecided literals that can still influence the satisfiability of a PC(ID) formula in a given partial assignment. The idea is that the PC(ID) solver can make decisions only on relevant literals without losing soundness and thus safely ignore irrelevant literals. One important insight that the relevance of a literal is completely determined by the current solver state. During search, the solver state changes have an effect on the relevance of literals. In this paper, we discuss an incremental, lightweight implementation of a relevance tracker module that can be added to and interact with an out-of-the-box SAT(ID) solver.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}