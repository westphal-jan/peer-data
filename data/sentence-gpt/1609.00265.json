{"id": "1609.00265", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Sep-2016", "title": "Testing $k$-Monotonicity", "abstract": "A Boolean $k$-monotone function defined over a finite poset domain ${\\cal D}$ alternates between the values $0$ and $1$ at most $k$ times on any ascending chain in ${\\cal D}$. Therefore, $k$-monotone functions are natural generalizations of the classical monotone functions, which are the $1$-monotone functions. Motivated by the recent interest in $k$-monotone functions in the context of circuit complexity and learning theory, and by the central role that monotonicity testing plays in the context of property testing, we initiate a systematic study of $k$-monotone functions, in the property testing model. In this model, the goal is to distinguish functions that are $k$-monotone (or are close to being $k$-monotone) from functions that are far from being $k$-monotone. Our results include the following:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Thu, 1 Sep 2016 15:11:52 GMT  (52kb)", "https://arxiv.org/abs/1609.00265v1", null], ["v2", "Wed, 14 Sep 2016 18:53:51 GMT  (51kb)", "http://arxiv.org/abs/1609.00265v2", null]], "reviews": [], "SUBJECTS": "cs.DS cs.DM cs.LG", "authors": ["cl\\'ement l canonne", "elena grigorescu", "siyao guo", "akash kumar", "karl wimmer"], "accepted": false, "id": "1609.00265"}, "pdf": {"name": "1609.00265.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Cl\u00e9ment L. Canonne", "Elena Grigorescu", "Siyao Guo", "Akash Kumar", "Karl Wimmer"], "emails": ["ccanonne@cs.columbia.edu.", "elena-g@purdue.edu.", "sg191@nyu.edu.", "akumar@purdue.edu.", "wimmerk@duq.edu."], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n00 26\n5v 2\n[ cs\n.D S]\n1 4\nMotivated by the recent interest in k-monotone functions in the context of circuit complexity and learning theory, and by the central role that monotonicity testing plays in the context of property testing, we initiate a systematic study of k-monotone functions, in the property testing model. In this model, the goal is to distinguish functions that are k-monotone (or are close to being k-monotone) from functions that are far from being k-monotone.\nOur results include the following:\n1. We demonstrate a separation between testing k-monotonicity and testing monotonicity, on the hypercube domain {0, 1}d, for k \u2265 3; 2. We demonstrate a separation between testing and learning on {0, 1}d, for k = \u03c9(log d): testing k-monotonicity can be performed with 2O( \u221a d\u00b7log d\u00b7log 1/\u03b5) queries, while learning\nk-monotone functions requires 2\u2126(k\u00b7 \u221a d\u00b71/\u03b5) queries (Blais et al. (RANDOM 2015)).\n3. We present a tolerant test for functions f : [n]d \u2192 {0, 1} with complexity independent of n, which makes progress on a problem left open by Berman et al. (STOC 2014).\nOur techniques exploit the testing-by-learning paradigm, use novel applications of Fourier analysis on the grid [n]d, and draw connections to distribution testing techniques.\n\u2217Columbia University. Email: ccanonne@cs.columbia.edu. Research supported by NSF CCF-1115703 and NSF CCF-1319788.\n\u2020Purdue University. Email: elena-g@purdue.edu. Research supported in part by NSF CCF-1649515. \u2021Courant Institute of Mathematical Sciences, New York University. Email: sg191@nyu.edu. \u00a7Purdue University. Email: akumar@purdue.edu. \u00b6Duquesne University. Email: wimmerk@duq.edu.\nContents"}, {"heading": "1 Introduction 3", "text": "1.1 Our results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 Testing k-monotonicity on the hypercube {0, 1}d . . . . . . . . . . . . . . . . 3 1.1.2 Testing k-monotonicity on the hypergrid [n]d . . . . . . . . . . . . . . . . . . 4\n1.2 Proofs overview and technical contribution . . . . . . . . . . . . . . . . . . . . . . . . 6 1.3 Discussion and open problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.4 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.5 Organization of the paper . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9"}, {"heading": "2 Preliminaries 10", "text": ""}, {"heading": "3 On the Boolean hypercube 11", "text": "3.1 Upper bound: beating the learning approach . . . . . . . . . . . . . . . . . . . . . . 11 3.2 Lower bounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.2.1 One-sided lower bounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3.2.2 Two-sided lower bounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14"}, {"heading": "4 On the line 16", "text": "4.1 Upper and lower bounds for one-sided testers . . . . . . . . . . . . . . . . . . . . . . 16 4.2 Upper bound for two-sided testers: proof of Theorem 1.5 . . . . . . . . . . . . . . . . 19\n4.2.1 Testing k-monotonicity over [Ck] . . . . . . . . . . . . . . . . . . . . . . . . . 20 4.2.2 Reducing [n] \u2192 {0, 1} to [Ck] \u2192 {0, 1}. . . . . . . . . . . . . . . . . . . . . . 22"}, {"heading": "5 On the grid 23", "text": "5.1 The case k = 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 5.2 Possible extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27"}, {"heading": "6 On the high-dimensional grid 28", "text": "6.1 Fully tolerant testing with O(kd/(\u03b52 \u2212 \u03b51)))d queries . . . . . . . . . . . . . . . . . . 29 6.2 Tolerant testing via agnostic learning . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n7 Tolerant testing and applications to L1-testing 34"}, {"heading": "A Previous work on monotonicity testing 40", "text": ""}, {"heading": "B Structural results 42", "text": "C Omitted proofs 44"}, {"heading": "1 Introduction", "text": "A function f : D \u2192 {0, 1}, defined over a finite domain D equipped with a partial order, is said to be k-monotone, for some integer k \u2265 0, if there does not exist x1 x2 . . . xk+1 in D such that f(x1) = 1 and f(xi) 6= f(xi+1) for all i \u2208 [k]. Note that 1-monotone functions are the classical monotone functions, satisfying f(x1) \u2264 f(x2), whenever x1 x2.\nMonotone functions have been well-studied on multiple fronts in computational complexity due to their natural structure. They have been celebrated for decades in the property testing literature [GGL+00, DGL+99, FLN+02, BCGM12, CS13b, CS13a, CS14], where we have recently witnessed ultimate results [KMS15, CDST15, BB16], in the circuit complexity literature, where we now have strong lower bounds [RW92, Raz85], and in computational learning, where we now have learning algorithms in numerous learning models [BT96, Ang87, KV94, Ser04, OS07, OW09].\nThe generalized notion of k-monotonicity has also been studied in the context of circuit lower bounds for more than 50 years. In particular, Markov [Mar57] showed that any k-monotone function (even with multiple outputs) can be computed using circuits containing only log k negation gates. The presence of negation gates appears to be a challenge in proving circuit lower bounds: \u201cthe effect of such gates on circuit size remains to a large extent a mystery\u201d [Juk12]. The recent results of Blais et al. [BCO+15] on circuit lower bounds have prompted renewed interest in understanding k-monotone functions from multiple angles, including cryptography, circuit complexity, learning theory, and Fourier analysis ([Ros15, GMOR15, GK15, LZ16]).\nMotivated by the exponential lower bounds on PAC learning k-monotone functions due to [BCO+15], we initiate the study of k-monotonicity in the closely related Property Testing model. In this model, given query access to a function, one must decide if the function is k-monotone, or is far from being k-monotone, by querying the input only in a small number of places."}, {"heading": "1.1 Our results", "text": "We focus on testing k-monotonicity of Boolean functions defined over the d-dimensional hypegrid [n]d, and the hypercube {0, 1}d. We begin our presentation with the results for the hypercube, in order to build intuition into the difficulty of the problem, while comparing our results with the current literature on testing monotonicity. Our stronger results concern the hypegrid [n]d.\n1.1.1 Testing k-monotonicity on the hypercube {0, 1}d In light of the recent results of [KMS15] that provide a O( \u221a d)-query tester for monotonicity, we first show that testing k-monotonicity is strictly harder than testing monotonicity on {0, 1}d, for k \u2265 3. Theorem 1.1. For 1 \u2264 k \u2264 d1/4/2, any one-sided non-adaptive tester for k-monotonicity of functions f : {0, 1}d \u2192 {0, 1} must make (\u2126 ( d/k2 ) )k/4 queries.\nBoth Theorem 1.1 and its proof generalize the \u2126(d1/2) lower bound for testing monotonicity, due to Fischer et al. [FLN+02].\nOn the upper bounds side, while the monotonicity testing problem is providing numerous potential techniques for approaching this new problem [GGL+00, DGL+99, CS13a, BCGM12, CST14, KMS15], most common techniques appear to resist generalizations to k-monotonicity. However, our upper bounds demonstrate a separation between testing and PAC learning k-monotonicity, for large enough values of k = \u03c9(log d).\nTheorem 1.2. There exists a one-sided non-adaptive tester for k-monotonicity of functions f : {0, 1}d \u2192 {0, 1} with query complexity q(d, \u03b5, k) = 2O( \u221a d\u00b7log d\u00b7log 1 \u03b5).\nIndeed, in the related PAC learning model, [BCO+15] shows that learning k-monotone functions\non the hypercube requires 2\u2126(k\u00b7 \u221a d\u00b71/\u03b5) many queries.\nWe further observe that the recent non-adaptive and adaptive 2-sided lower bounds of [CDST15, BB16], imply the same bounds for k-monotonicity, using black box reductions. We summarize the state of the art for testing k-monotonicity on the hypercube in Table 1.\n1.1.2 Testing k-monotonicity on the hypergrid [n]d\nThe remainder of the paper focuses on functions defined over the d-dimensional hypergrid domain [n]d, where we denote by (i1, i2, . . . , in) (j1, j2, . . . , jn) the partial order in which i1 \u2264 j1, i2 \u2264 j2, . . . , in \u2264 jn. Testing monotonicity has received a lot of attention over the d-dimensional hypergrids [GGL+00, EKK+00, Fis04, BRW05, AC06, HK08, BBM12, CS13b, CS13a, CS14, BRY14], where the problem is well-understood, and we refer the reader to Table 4 in the appendix for a detailed review on the state of the art in the area. We summarize our results on testing k-monotonicity over [n]d in Table 2.\nTesting k-monotonicity on the line and the 2-dimensional grid We begin with a study of function f : [n] \u2192 {0, 1}. As before, note that 1-sided tests should always accept k-monotone functions, and so, they must accept unless they discover a violation to k-monotonicity in the form of a sequence x1 x2 . . . xk+1 in [n]d, such that f(x1) = 1 and f(xi) 6= f(xi+1). Therefore, lower bounds for 1-sided k-monotonicity testing must grow at least linearly with k. We show that this is indeed the case for both adaptive and non-adaptive tests, and more over, we give a tight non-adaptive algorithm. Consequently, our results demonstrate that adaptivity does not help in testing k-monotonicity with one-sided error on the line domain.\nTheorem 1.3. Any one-sided (possibly adaptive) tester for k-monotonicity of functions f : [n] \u2192 {0, 1} must have query complexity \u2126 ( k \u03b5 ) .\nThe upper bound generalizes the O(1/\u03b5) tester for monotonicity on the line.\nTheorem 1.4. There exists a one-sided non-adaptive tester for k-monotonicity of functions f : [n] \u2192 {0, 1} with query complexity q(n, \u03b5, k) = O ( k \u03b5 ) .\nTesting with 2-sided error, however, does not require a dependence on k. In fact the problem has been well-studied in the machine learning literature in the context of testing/learning \u201cunion of intervals\u201d [KR00, BBBY12], and in testing geometric properties, in the context of testing surface area [KNOW14, Nee14],1 resulting in an O(1/\u03b57/2)-query algorithm. Namely, the starting point of [BBBY12] (later improved by [KNOW14]) is a \u201cBuffon Needle\u2019s\u201d-type argument, where the crucial quantity to analyze is the noise sensitivity of the function that is the probability that a randomly chosen pair of nearby points cross a \u201cboundary\u201d \u2013 i.e., have different values. (Moreover, the algorithm of [BBBY12] works in the active testing setting: it only requires a weaker access model that the standard query model.)\nWe provide an alternate proof of a poly(1/\u03b5) bound (albeit with a worse exponent) that reveals a surprising connection with distribution testing, namely with the problem of estimating the support size of a distribution.\nTheorem 1.5. There exists a two-sided non-adaptive tester for k-monotonicity of functions f : [n] \u2192 {0, 1} with query complexity q(n, \u03b5, k) = O\u0303 ( 1/\u03b57 ) , independent of k.\nAn immediate implication of Theorem 1.5 is that one can test even n1\u2212\u03b1-monotonicity of f : [n] \u2192 {0, 1}, for every \u03b1 > 0, with a constant number of queries. Hence, there is a separation between 1-sided and 2-sided testing, for k = \u03c9(1).\nTurning to the 2-dimensional grid, we show that 2-monotone functions can be tested with the minimum number of queries one could hope for:\nTheorem 1.6. There exists a two-sided adaptive tester for 2-monotonicity of functions f : [n]2 \u2192 {0, 1} with query complexity q(n, \u03b5) = O ( 1 \u03b5 ) .\nWe also discuss possible generalizations of Theorem 1.6 to general k or d section, Section 5.2.\nTesting k-monotonicity on [n]d, tolerant testing, and distance approximation Moving to the general grid domain [n]d, we show that k-monotonicity is testable with poly(1/\u03b5, k) queries in constant-dimension grids.\nTheorem 1.7. There exists a non-adaptive tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b5, k) = min(O\u0303 ( 1 \u03b52 ( 5kd \u03b5 )d) , 2O\u0303(k \u221a d/\u03b52)).\nIn fact, we obtain more general testing algorithms than in Theorem 1.7, namely our results hold for tolerant testers.\nThe notion of tolerant testing was first introduced in [PRR06] to account for the possibility of noisy data. In this notion, a test should accept inputs that are \u03b51-close to the property, and reject\n1We thank Eric Blais for mentioning the connection, and pointing us to these works\ninputs that are \u03b52-far from the property, where \u03b51 and \u03b52 are given parameters. Tolerant testing is intimately connected to the notion of distance approximation: given tolerant testers for every (\u03b51, \u03b52), there exists an algorithm that estimates the distance to the property within any (additive)\n\u03b5, while incurring only a O\u0303 ( log 1\u03b5 ) factor blow up in the number of queries. Furthermore, [PRR06] shows that both tolerant testing and distance approximation are no harder than agnostic learning. We prove the following general result.\nTheorem 1.8. There exist\n\u2022 a non-adaptive (fully) tolerant tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b51, \u03b52, k) = O\u0303 ( 1 (\u03b52\u2212\u03b51)2 ( 5kd \u03b52\u2212\u03b51 )d) ; \u2022 a non-adaptive tolerant tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b51, \u03b52, k) = 2 O\u0303(k \u221a d/(\u03b52\u22123\u03b51)2), under the restriction that \u03b52 > 3\u03b51.\nTo the best of our knowledge, the only previous results for tolerant testing for monotonicity on [n]d are due to Fattal and Ron [FR10]. They give both additive and multiplicative distance approximations algorithms, and obtain O(d)-multiplicative and \u03b5-additive approximations with query complexity poly(1\u03b5 ). While very efficient, there results only give fully tolerant testers for dimensions d = 1 and d = 2. Our results generalize the work of [FR10] showing existence of tolerant testers for k-monotonicity (and hence for monotonicity) for any dimension d \u2265 1, and any k \u2265 1, but paying the price in the query complexity.\nAs a consequence to Theorem 1.8, we make progress on an open problem of Berman et al. [BRY14], as explained next.\nTesting k-monotonicity under Lp distance The property of being a monotone Boolean function has a natural extension to real-valued functions. Indeed, a real-valued function defined over a finite domain D is monotone if f(x) \u2264 f(y) whenever x y. For real-valued functions the more natural notion of distance is Lp distance, rather than Hamming distance. The study of monotonicity has been extended to real-valued functions in a recent work by Berman et al. [BRY14]. They give tolerant testers for grids of dimension d = 1 and d = 2, and leave open the problem of extending the results to general d, as asked explicitly at the recent Sublinear Algorithms Workshop 2016 [Sub16].\nWe make progress towards solving this open problem, by combining our Theorem 1.8 with a reduction from Lp testing to Hamming testing from [BRY14].\nTheorem 1.9. There exists a non-adaptive tolerant L1-tester for monotonicity of functions f : [n] d \u2192 {0, 1} with query complexity\n\u2022 O\u0303 (\n1 (\u03b52\u2212\u03b51)2\n( 5d\n\u03b52\u2212\u03b51\n)d) , for any 0 \u2264 \u03b51 < \u03b52 \u2264 1;\n\u2022 2O\u0303( \u221a d/(\u03b52\u22123\u03b51)2), for any 0 \u2264 3\u03b51 < \u03b52 \u2264 1."}, {"heading": "1.2 Proofs overview and technical contribution", "text": "Structural properties and the separation between testing and learning on {0, 1}d. We first observe that basic structural properties, such as extendability (i.e. the feature that a function that is monotone on a sub-poset of [n]d can be extended into a monotone function on the\nentire poset domain), and properties of the violation graph (i.e., the graph whose edges encode the violations to monotonicity), extend easily to k-monotonicity (see Appendix B). These properties help us to argue the separation between testing and learning (Theorem 1.2). However, unlike the case of monotonicity testing, these properties do not seem to be enough for showing upper bounds that grow polynomially in d.\nGrid coarsening and testing by implicit/explicit learning. One pervading technique, which underlies all the hypergrid upper bounds in this work, is that of gridding: i.e., partitioning the domain into \u201cblocks\u201d whose size no longer depends on the main parameter of the problem, n. This technique generalizes the approach of [FR10] who performed a similar gridding for dimension d = 2. By simulating query access to the \u201ccoarsened\u201d version of the unknown function (with regard to these blocks), we are able to leverage methods such as testing-by-learning (either fully or partially learning the function), or reduce our testing problem to a (related) question on these nicer \u201ccoarsenings.\u201d (The main challenge here lies in providing efficient and consistent oracle access to the said coarsenings.)\nAt a high-level, the key aspect of k-monotonicity which makes this general approach possible is reminiscent of the concept of heredity in property testing. Specifically, we rely upon the fact that \u201cgridding preserves k-monotonicity:\u201d if f is k-monotone, then so will be its coarsening g \u2013 but now g is much simpler to handle. This allows us to trade the domain [n]d for what is effectively [m]d, with m \u226a n. We point out that this differs from the usual paradigm of dimension reduction: indeed, the latter would reduce the study of a property of functions on [n]d to that of functions on [n]d \u2032 for d\u2032 \u226a d (usually even d\u2032 = 1) by projecting f on a lower-dimensional domain. In contrast, we do not take the dimension down, but instead reduce the size of the alphabet. Moreover, it is worth noting that this gridding technique is also orthogonal to that of range reduction, as used e.g. in [DGL+99]. Indeed, the latter is a reduction of the range of the function from [R] to {0, 1}, while gridding is only concerned about the domain size.\nEstimating the support of distributions. Our proof of the poly(1/\u03b5) upper bound for testing k-monotonicity on the line (Theorem 1.5) rests upon an unexpected connection to distribution testing, namely to the question of support size estimation of a probability distribution. In more detail, we describe how to reduce k-monotonicity testing to the support size estimation problem in (a slight modification of) the Dual access model introduced by Canonne and Rubinfeld [CR14], where the tester is granted samples from an unknown distribution as well as query access to its probability mass function.\nFor our reduction to go through, we first describe how any function f : [n] \u2192 {0, 1} determines a probability distribution Df (on [n]), whose effective support size is directly related to the kmonotonicity of f . We then show how to implement dual access to this Df from queries to f : in order to avoid any dependence on k and n in this step, we resort both to the gridding approach outlined above (allowing us to remove n from the picture) and to a careful argument to \u201ccap\u201d the values of Df returned by our simulated oracle. Indeed, obtaining the exact value of Df (x) for arbitrary x may require \u2126(k) queries to f , which we cannot afford; instead, we argue that only returning Df (x) whenever this value is \u201csmall enough\u201d is sufficient. Finally, we show that implementing this \u201ccapped\u201d dual access oracle is possible with no dependence on k whatsoever, and we can now invoke the support size estimation algorithm of [CR14] to conclude.\nFourier analysis on the hypergrid. We give an algorithm for fully tolerantly testing kmonotonicity whose query complexity in exponential in d. We also describe an alternate tester (with a slightly worse tolerance guarantee) whose query complexity is instead exponential in O\u0303(k \u221a d) for constant distance parameters. As mentioned above, we use our gridding approach combined with tools from learning theory. Specifically, we employ an agnostic learning algorithm of [KKMS08] using polynomial regression. Our coarsening methods allow us to treat the domain as if it were [m]d for some m that is independent of n. To prove that this agnostic learning algorithm will succeed, we turn to Fourier analysis over [m]d. We extend the bound on average sensitivity of k-monotone functions over the Boolean hypercube from [BCO+15] to the hypergrid, and we show that this result implies that the Fourier coefficients are concentrated on \u201csimple\u201d functions."}, {"heading": "1.3 Discussion and open problems", "text": "This is the first work to study k-monotonicity, a natural and well-motivated generalization of monotonicity. Hence this work opens up many intriguing questions in the area of property testing, with potential applications to learning theory, circuit complexity and cryptography. As previously mentioned, the main open problem prompted by our work is the following:\nCan k-monotonicity on the hypercube {0, 1}d be tested with poly(dk) queries?\nA natural 1-sided tester for k-monotonicity is a chain tester: it queries points along a random chain, and rejects only if it finds a violation to k-monotonicity, in the form of a sequence x1 x2 . . . xk+1 in {0, 1}d, such that f(x1) = 1 and f(xi) 6= f(xi+1). In particular, the testers in [GGL+00, CS13a, CST14, KMS15] all directly imply a chain tester. We conjecture that there exists a chain tester for k-monotonicity that succeeds with probability d\u2212O(k).\nAnother important open question concerns the hypergrid domain, and in particular it pushes for a significant strengthening of Theorem 1.7 and Theorem 1.9:\nCan k-monotonicity on the hypergrid [n]d be (tolerantly) tested with 2ok( \u221a d) queries?\nAnswering this question would imply further progress on the L1-testing question for monotonicity, left open in [BRY14, Sub16].\nThere also remains the question of establishing two-sided lower bounds that would go beyond those of monotonicity. Specifically:\nIs there an d\u2126(k)-query two-sided lower bound for k-monotonicity on the hypercube {0, 1}d?\nIn this work we also show surprising connections to distribution testing (e.g. in the proof of Theorem 1.5), and to testing union of intervals and testing surface area (as discussed in Section 4.2). An intriguing direction is to generalize this connection to union of intervals and surface area in higher dimensions, to leverage or gain insight on k-monotonicity on the d-dimensional hypergrid.\nFinally, while we only stated here a few directions, we emphasize that every question that is relevant to monotonicity is also relevant and interesting in the case of k-monotonicity."}, {"heading": "1.4 Related work", "text": "As mentioned, k-monotonicity has deep connections with the notion of negation complexity of functions, which is the minimum number of negation gates needed in a circuit to compute a given function. The power of negation gates is intriguing and far from being understood in the context of circuit lower bounds. Quoting from Jukna\u2019s book [Juk12], the main difficulty in proving nontrivial lower bounds on the size of circuits using AND, OR, and NOT is the presence of NOT gates: we already know how to prove even exponential lower bounds for monotone functions if no NOT gates are allowed. The effect of such gates on circuit size remains to a large extent a mystery.\nThis gap has motivated the study of circuits with few negations. Two notable works successfully extend lower bounds in the monotone setting to negation-limited setting: in [AM05], Amano and Maruoka show superpolynomial circuit lower bounds for (1/6) log log n negations using the Clique function; and recently the breakthrough work of Rossman [Ros15] establishes circuit lower bounds for NC1 with roughly 12 log n negations by drawing upon his lower bound for monotone NC\n1. The divide between the understanding of monotone and non-monotone computation exists in general: while we usually have a fairly good understanding of the monotone case, many things get murky or fail to hold even when a single negation gate is allowed. In order to get a better grasp on negation-limited circuits, a body of recent work has been considering this model in various contexts: Blais et al. [BCO+15] study negation-limited circuits from a computational learning viewpoint, Guo et al. [GMOR15] study the possibility of implementing cryptographic primitives using few negations, and Lin and Zhang [LZ16] are interested in verifying whether some classic Boolean function conjectures hold for the subset of functions computed by negation-limited circuits.\nMany of these results implicitly or explicitly rely on a simple but powerful tool: the decomposition of negation-limited circuits into a composition of some \u201cnice\u201d function with monotone components. Doing so enables one to apply results on separate monotone components, and finally to carefully combine the outcomes (e.g., [GK15]). Though these techniques can yield results for as many as O(log n) negations, they also leave open surprisingly basic questions:\n\u2022 [BCO+15] Can we have an efficient weak learning algorithm for functions computed by circuits with a single negation? \u2022 [GMOR15] Can we obtain pseudorandom generators when allowing only a single negation? In contexts where the circuit size is not the quantity of interest, the equivalent notion of 2- monotone functions is more natural than that of circuits allowing only one negation. Albeit seemingly simple, even the class of 2-monotone functions remains largely a mystery: as exemplified above, many basic yet non-trivial questions, ranging from the structure of their Fourier spectrum to their expressive power of k-monotone functions, remain open."}, {"heading": "1.5 Organization of the paper", "text": "After recalling some notations and definitions in Section 2, we consider the case of the Boolean hypercube in Section 3, where we establish lower bounds on testing k-monotonicity of functions f : {0, 1}d \u2192 {0, 1} for both one- and two-sided algorithms, and provide an algorithm which \u201cbeats\u201d the testing-by-learning approach, showing that testing is provably easier than learning.\nNext, we establish our results for functions on the line in Section 4, starting with the lower and upper bounds for one-sided testers before turning in Section 4.2 to the two-sided upper bound of Theorem 1.3. We then describe in Section 5 our results for functions on the grid [n]2, focusing on the case k = 2; and discussing possible extensions in Section 5.2.\nSection 6 contains our general algorithms for k-monotonicity on the hypergrid [n]d, for arbitrary k and d. We prove Theorem 1.8 in two parts. We establishing its first item (general tolerant testing algorithm with exponential dependence in d) in Section 6.1 (Proposition 6.2). The second item (with query complexity exponential in k \u221a d) is proven in Section 6.2, where we analyze the Fourier-based tolerant tester of Proposition 6.11. We then apply these results to the question of tolerant L1-testing of monotonicity in Section 7, after describing a reduction between monotonicity of functions [n]d \u2192 [0, 1] and of [n]d+1 \u2192 {0, 1}.\nExcept maybe Section 7 which depends on Section 6, all sections are independent and selfcontained, and the reader may choose to read them in any order."}, {"heading": "2 Preliminaries", "text": "We denote by log the binary logarithm, and use O\u0303(\u00b7) to hide polylogarithmic factors in the argument (so that O\u0303(f) = O(f logc f) for some c \u2265 0).\nGiven two functions f, g : X \u2192 Y on a finite domain X , we write dist(f, g) for the (normalized) Hamming distance between them, i.e.\ndist(f, g) = 1 |X | \u2211\nx\u2208X 1{f(x)6=g(x)} = Pr x\u223cX [ f(x) 6= g(x) ]\nwhere x \u223c X refers to x being drawn from the uniform distribution on X . A property of functions from X to Y is a subset P \u2286 XY of these functions; we define the distance of a function f to P as the minimum distance of f to any g \u2208 P:\ndist(f,P) = inf g\u2208P dist(f, g) .\nFor some of our applications, we will also use another notion of distance specific to real-valued functions, the L1 distance (as introduced in the context of property testing in [BRY14]). For f, g : X \u2192 [0, 1], we write\nL1(f, g) = 1 |X | \u2211\nx\u2208X |f(x)\u2212 g(x)| = Ex\u223cX [|f(x)\u2212 g(x)|] \u2208 [0, 1]\nand extend the definition to L1(f,P), for P \u2286 X [0,1], as before.\nProperty testing. We recall the standard definition of testing algorithms, as well as some terminology:\nDefinition 2.1. Let P be a property of functions from X to Y. A q-query testing algorithm for P is a randomized algorithm T which takes as input \u03b5 \u2208 (0, 1] as well as query access to a function f : X \u2192 Y. After making at most q(\u03b5) queries to the function, T either outputs ACCEPT or REJECT, such that the following holds:\n\u2022 if f \u2208 P, then T outputs ACCEPT with probability at least 2/3; (Completeness) \u2022 if dist(f,P) \u2265 \u03b5, then T outputs REJECT with probability at least 2/3; (Soundness)\nwhere the probability is taken over the algorithm\u2019s randomness. If the algorithm only errs in the second case but accepts any function f \u2208 P with probability 1, it is said to be a one-sided tester; otherwise, it is said to be two-sided. Moreover, if the queries made to the function can only depend on the internal randomness of the algorithm, but not on the values obtained during previous queries, it is said to be non-adaptive; otherwise, it is adaptive.\nAdditionally, we will also be interested in tolerant testers \u2013 roughly, algorithms robust to a relaxation of the first item above:\nDefinition 2.2. Let P, X , and Y be as above. A q-query tolerant testing algorithm for P is a randomized algorithm T which takes as input 0 \u2264 \u03b51 < \u03b52 \u2264 1, as well as query access to a function f : X \u2192 Y. After making at most q(\u03b51, \u03b52) calls to the oracle, T outputs either ACCEPT or REJECT, such that the following holds:\n\u2022 if dist(f,P) \u2264 \u03b51, then T outputs ACCEPT with probability at least 2/3; (Completeness) \u2022 if dist(f,P) \u2265 \u03b52, then T outputs REJECT with probability at least 2/3; (Soundness)\nwhere the probability is taken over the algorithm\u2019s randomness. The notions of one-sidedness and adaptivity of Definition 2.1 extend to tolerant testing algorithms as well.\nNote that as stated, in both cases the algorithm \u201cknows\u201d X ,Y, and P; so that the query complexity q can be parameterized by these quantities. More specifically, when considering X = [n]d and the property P of k-monotonicity, we will allow q to depend on n, d, and k. Finally, we shall sometimes require a probability of success 1\u2212\u03b4 instead of the (arbitrary) constant 2/3; by standard techniques, this can be obtained at the cost of a multiplicative O(log(1/\u03b4)) in the query complexity.\nPAC and agnostic learning [Val84] A learning algorithm A for a concept class C of functions f : X \u2192 Y (under the uniform distribution) is given parameters \u03b5, \u03b4 > 0 and sample access to some target function f \u2208 C via labeled samples \u3008x, f(x)\u3009, where x is drawn uniformly at random from X . The algorithm should output a hypothesis h : X \u2192 Y such that dist(h, f) \u2264 \u03b5 with probability at least 1\u2212 \u03b4. The algorithm is efficient if it runs in time poly(n, 1/\u03b5, 1/\u03b4). If A must output h \u2208 C we say it is a proper learning algorithm, otherwise, we say it is an improper learning one.\nMoreover, if A still succeeds when f does not actually belong to C, we say it is an agnostic learning algorithm. Specifically, the hypothesis function h that it outputs must satisfy dist(f, g) \u2264 optf + \u03b5 with probability at least 1\u2212 \u03b4, where optf = ming\u2208C dist(f, g)."}, {"heading": "3 On the Boolean hypercube", "text": "In this section, we focus on k-monotonicity of Boolean functions over the hypercube {0, 1}d. We begin in Section 3.1 with a tester with query complexity 2O\u0303( \u221a d), establishing a strict separation between learning and testing. Section 3.2 is then dedicated to our lower bounds on k-monotonicity testing."}, {"heading": "3.1 Upper bound: beating the learning approach", "text": "In this section, we prove the following theorem:2\n2We note that this result is only interesting in the regime k \u2264 \u221a d: indeed, for k = \u2126 (\u221a d log 1\n\u03b5\n) every function is\n\u03b5-close to k-monotone.\nTheorem 1.2. There exists a one-sided non-adaptive tester for k-monotonicity of functions f : {0, 1}d \u2192 {0, 1} with query complexity q(d, \u03b5, k) = 2O( \u221a d\u00b7log d\u00b7log 1 \u03b5).\nLet us recall the following standard fact.\nFact 3.1. There exists an absolute constant C > 0 such that the number of points of {0, 1}d that do not have integer weights in the middle levels [d2 \u2212 \u221a d log C\u03b5 , d 2 + \u221a d log C\u03b5 ] is at most \u03b52 d\u22121.\nWith that fact in our hands, we now describe the following tester.\n(1) Sample O(1/\u03b5) random points from the middle levels\n(2) For each of the queries in the first step, query all points with Hamming weight in the middle levels which fall in the subcube below and in the subcube above each such random point. We call each of these O(1/\u03b5) collections of queries a superquery .\nThe key idea behind the tester is the extendability lemma, Lemma B.7. The tester tries to find one of the \u201cviolated hyperedges\u201d from the matching of violations that we know exists from Lemma B.7. Now, we analyze the tester.\nProof of Theorem 1.2. Suppose k is odd.3 In this case, given a function f \u03b5-far from k-monotonicity we can assume without loss of generality that f and equals 0 on points with Hamming weight < d2 \u2212 \u221a d log C\u03b5 , and equals 1 on points with Hamming weight > d 2 + \u221a d log C\u03b5 . The resulting function is still \u03b52 -far from being k-monotone.\nNow, by Lemma B.7, we know that there exists a matching Mf of violations to k-monotonicity\nin f of size 12 \u00b7 \u03b52 d k . The set of vertices that participate in these violations has cardinality\n|Mf | \u00b7 \u03b52d\nk =\n\u03b5(k + 1)2d\nk \u2265 \u03b52d\u22121\nWith constant probability, in O(1/\u03b5) queries in the first step, the tester queries a vertex that belongs to some violation from Mf . Then in the next step, the tester finds this violation. Now we bound the number of queries made in a single superquery. Since it involves only 2 \u221a d log C\u03b5 levels\nof the cube, the number of points queried in a single superquery is no more than b = dO( \u221a d log 1 \u03b5 ). The total query complexity of the tester can therefore be upperbounded by b/\u03b5 = dO( \u221a d log 1 \u03b5 ). We emphasize that the number of queries made by this tester has no dependence on k."}, {"heading": "3.2 Lower bounds", "text": "We now turn to lower bounds for testing k-monotonicity of Boolean functions over the hypercube {0, 1}d. In Section 3.2.1, we show that for constant k any one-sided non-adaptive tester for kmonotonicity requires \u2126(dk/4) queries , generalizing the \u2126 (\u221a d ) lower bound for monotonicity due to Fischer et al. [FLN+02]. This bound suggests the problem become strictly harder when k increases: specifically, for k > 2 testing k-monotonicity requires \u03c9( \u221a d) queries, while an O( \u221a d) one-sided non-adaptive upper bound holds for monotonicity testing [KMS15].\n3The case k even is similar. In this case, one may assume that f evaluates to 0 on points with hamming weight everywhere outside the middle levels.\nWe then describe in Section 3.2.2 a general reduction frommonotonicity testing to k-monotonicity testing, for arbitrary constant k. This blackbox reduction allows us to carry any lower bound (possibly 2-sided or adaptive) for monotonicity testing to k-monotonicity. In particular, combining it with the recent lower bounds [CDST15, BB16] for 2-sided monotonicity testing, we obtain an \u2126(d1/2\u2212o(1)) lower bound for non-adaptive k-monotonicity testers, and an \u2126 ( d1/4 ) lower bound for\nadaptive ones."}, {"heading": "3.2.1 One-sided lower bounds", "text": "Theorem 1.1. For 1 \u2264 k \u2264 d1/4/2, any one-sided non-adaptive tester for k-monotonicity of functions f : {0, 1}d \u2192 {0, 1} must make (\u2126 ( d/k2 ) )k/4 queries.\nConsider the family of functions {fS : S \u2286 [d] of size t} where t \u2265 k is a parameter to be determined later and fS is a truncated anti-parity over t input coordinates indexed by S, namely,\nfS =\n{ \u2295i\u2208Sxi if ||x| \u2212 d/2| \u2264 \u221a d,\n0 otherwise.\nTheorem 1.1 immediately follows from the two claims below. In particular,by Claim 3.3, for t \u2264 \u221a d and t = 4k2, fS is \u2126(1)-far from any k-monotone function, and by Claim 3.2, to reject every fS with \u2126(1) probability, q needs to be at least d k/4 \u00b7 ( k2e2t)k/2 = \u2126(d/k2)k/4 when t = 4k2. Claim 3.2. For any non-adaptive q-query algorithm A, there exists fS where |S| = t such that A reveals a violation on fS with probability at most q 2 (2\u221ad\nk )(t k ) / (d k ) .\nClaim 3.3. For k \u2264 t \u2264 \u221a d, fS is \u2126( \u2211\u230a t\u2212k\u221212 \u230b i=0 (t i ) /2t)-far from any k-monotone functions.\nProof of Claim 3.2. Let Q be an arbitrary set of q queries. Without loss of generality, we assume every query z in Q has Hamming weight |z| \u2208 [d2 \u2212 \u221a d, d2 + \u221a d]. We define Qx,z = { y \u2208 Q : x y z } and Rej(Q) = { fS : Q contains a violation for fS }. Note that Rej(Q) =\u22c3 (x,z) : x z\u2208QRej(Qx,z). Hence we can bound the size of Rej(Q) by\n|Rej(Q)| \u2264 \u2211\n(x,z)\u2208Q2 : x z |Rej(Qx,z)| . (1)\nFix any x z \u2208 Q. Because any violation for fS in Qx,z contains at least two points x\u2032 and z\u2032 such that x x\u2032 z\u2032 z, and x\u2032S\u2032 = 0k and z\u2032S\u2032 = 1k, we have xS\u2032 = 0k and zS\u2032 = 1k for some S\u2032 \u2286 S of size k. Note that x and z differ in at most 2 \u221a d coordinates so that there are at most (2\u221ad k ) distinct\nS\u2032 on which xS\u2032 is 0k and zS\u2032 is 1k. Moreover, for each S\u2032 there are at most (d\u2212k t\u2212k ) distinct S such that S\u2032 \u2286 S. Therefore we can bound the size of Rej(Qx,z) by\n|Rej(Qx,z)| \u2264 ( 2 \u221a d\nk )( d\u2212 k t\u2212 k ) . (2)\nCombining (1) and (2) , |Rej(Q)| \u2264 q2 (2\u221ad\nk )(d\u2212k t\u2212k ) . It follows that for any non-adaptive algorithm\nmaking at most q queries,\n\u2211\nS\u2286[d]:|S|=t Pr[A reveals a violation for fS ] \u2264 E[|Rej(Q)|] \u2264 q2\n( 2 \u221a d\nk )( d\u2212 k t\u2212 k ) .\nHence there exists fS such that Pr[A reveals a violation for fS ] \u2264 q2 ( 2 \u221a d k )( d\u2212k t\u2212k)\n(dt) = q2\n(2 \u221a d\nk )( t k) (dk) .\nProof of Claim 3.3. Let f \u2032S be the closest k-monotone function to fS . Let Z denote the set {z \u2208 {0, 1}d\u2212t : d/2\u2212 \u221a d \u2264 |z| \u2264 d/2+ \u221a d\u2212 t}. For any t \u2264 \u221a d, [d\u2212t2 \u2212 \u221a d\u2212t 2 , d\u2212t 2 + \u221a d\u2212t 2 ] is contained in\n[d/2 \u2212 \u221a d, d/2 + \u221a d\u2212 t] so that |Z| = \u2126(2d\u2212t). For any assignment z \u2208 Z on coordinates indexed by [d] \\ S, fS(\u00b7, z) agrees with \u2295i\u2208Sxi and f \u2032S(\u00b7, z) is k-monotone. To finish the proof, it suffices to show that an anti-parity over t inputs is \u2211\u230a t\u2212k\u221212 \u230b i=0 (t k ) /2t-far from any k-monotone function over t inputs. Indeed, this will imply that, for every z \u2208 Z, fS(\u00b7, z) differs from f \u2032S(\u00b7, z) on \u2211\u230a t\u2212k\u221212 \u230b i=0 (t k ) points, and thus finally that fS differs from fS\u2032 on |Z|\u00b7 \u2211\u230a t\u2212k\u221212 \u230b\ni=0\n(t k ) = \u2126(2d\u2212t \u00b7\u2211\u230a t\u2212k\u22121 2 \u230b i=0 (t k ) ) points.\nNow we show that an anti-parity function over t inputs h(x1, . . . , xt) = \u2295ti=1xi is \u2211\u230a t\u2212k\u221212 \u230b i=0 (t i ) /2tfar from any k-monotone function g (over x1, . . . , xt). We begin by noting that we can sample a random point from {0, 1}t by first sampling a random chain C = (x0 = 0t, x1, . . . , xt = 1t) (from all possible chains from 0t to 1t) then outputting xi with probability (t i ) /2t. Thus the distance between h and g, namely Prx[h(x) 6= g(x)], is equal to\nPr C,i\n[h(xi) 6= g(xi)] = EC [ t\u2211\ni=0\n(t i )\n2t \u00b7 1{h(xi)6=g(xi)}\n] = EC [ 1\n2t\nt\u2211\ni=1\n( t\u2212 1 i\u2212 1 ) \u00b7 (1{h(xi)6=g(xi)} + 1{h(xi\u22121)6=g(xi\u22121)}) ]\n(3)\nwhere the last inequality relies on identity (t i ) = (t\u22121 i\u22121 ) + (t\u22121 i ) . For any fixed chain C, because g alternates at most k times, there are at least t \u2212 k choices of i \u2208 [t] such that g(xi\u22121) = g(xi), which implies 1{h(xi)6=g(xi)} + 1{h(xi\u22121)6=g(xi\u22121)} \u2265 1 (due to h(xi\u22121) 6= h(xi)). Thus \u2211t i=1 (t\u22121 i\u22121 ) \u00b7 (1{h(xi)6=g(xi)}+1{h(xi\u22121)6=g(xi\u22121)}) is at least the sum of smallest t\u2212k binomials among (t\u22121\n0\n) , . . . , (t\u22121 t\u22121 )\nwhich is\n\u230a t\u2212k\u221212 \u230b\u2211\ni=0\n( t\u2212 1 i ) + \u230a t\u2212k\u221222 \u230b\u2211\ni=0\n( t\u2212 1\nt\u2212 1\u2212 i\n) = \u230a t\u2212k\u221212 \u230b\u2211\ni=0\n( t\u2212 1 i ) + \u230a t\u2212k\u221222 \u230b\u2211\ni=0\n( t\u2212 1 i ) \u2265 \u230a t\u2212k\u221212 \u230b\u2211\ni=0\n( t\ni\n) ,\nwhich implies Prx[h(x) 6= g(x)] \u2265 12t \u2211\u230a t\u2212k\u221212 \u230b i=0 (t i ) by combining the above with (3)."}, {"heading": "3.2.2 Two-sided lower bounds", "text": "The following theorem gives a construction that enables us to convert monotone functions into k-monotone functions, and functions that are far from monotone into functions that are far from k-monotone.\nTheorem 3.4. There exists an efficiently computable function h : {0, 1}d/2 \u2192 {0, 1} such that for any g : {0, 1}d/2 \u2192 {0, 1}, then g||h : {0, 1}d \u2192 {0, 1} is a Boolean function (defined below) satisfying the following.\n\u2022 if g is monotone, then g||h is a k-monotone function; \u2022 if g is \u03b5-far from monotone, then g||h is \u2126(\u03b5/k)-far from being a k-monotone function;\nwhere (g||h)(x, y) def= g(x)\u2295 h(y) for any x, y \u2208 {0, 1}d/2.\nThe above theorem reduces test monotonicity to testing k-monotonicity (for arbitrary constant k) with the same number of queries to the input function. This theorem allows us to carry any lower bound on monotonicity testing to k-monotonicity, while preserving the characteristics (twosidedness, adaptivity) of the original lower bound. In particular, combining it with the recent recent of [CDST15, BB16], we obtain the following corollary.\nCorollary 3.5. For any c > 0 and k \u2265 1, there exists \u03b5 = \u03b5(k, c) > 0 such that any 2-sided nonadaptive algorithm for testing whether f is k-monotone or \u03b5-far from it requires \u2126(d1/2\u2212c) queries. Any 2-sided adaptive algorithm requires \u2126\u0303 ( d1/4 ) queries.\nTo prove Theorem 3.4, we prove following three claims. Claim 3.6 and Claim 3.7 show that the existence of a (k \u2212 1)-monotone function h for which one can find a big enough set of vertex disjoint paths in the hypercube whose labelling under h satisfies some specific condition will imply Theorem 3.4. Finally in Claim 3.8, we establish the existence of such h, and Theorem 3.4 follows.\nClaim 3.6. Let h : {0, 1}d \u2192 {0, 1} be a (k \u2212 1)-monotone function. Then for any monotone g : {0, 1}d \u2192 {0, 1}, f = g||h is a k-monotone function.\nClaim 3.7. Suppose there exists a h : {0, 1}d \u2192 {0, 1} such that the following holds. There exists at least M paths of length k \u2212 1 such that (i) all paths are vertex disjoint and (ii) for every path y1 \u00b7 \u00b7 \u00b7 yk, h(y1) = 0 and h(yi) 6= h(yi+1) for 1 \u2264 i \u2264 k \u2212 1. Then, for any g : {0, 1}d \u2192 {0, 1} which is \u03b5-far from being a monotone function, the function f = g||h is \u2126(M\n2d \u00b7 \u03b5)-far from being a\nk-monotone function.\nClaim 3.8. For any constant k, there exists an efficient computable h : {0, 1}d \u2192 {0, 1} such that h is a (k \u2212 1)-monotone function and h contains at least (1\u2212od(1))2dk paths of length k\u2212 1 such that all paths are vertex disjoint and for every path y1 \u00b7 \u00b7 \u00b7 yk, h(y1) = 0 and h(yi) 6= h(yi+1) for 1 \u2264 i \u2264 k \u2212 1.\nProof of Claim 3.6. Suppose f = g||h is not k-monotone, then there exist (x1, y1), . . . , (xk+1, yk+1) such that (x1, y1) \u00b7 \u00b7 \u00b7 (xk+1, yk+1), f(x1, y1) = 1 and f(xi, yi) 6= f(xi+1, yi+1) for any 1 \u2264 i \u2264 k. Because g is monotone, either g is constant on x1, . . . , xk+1, or there exists an index 1 < j \u2264 k+ 1 such that g(xi) = 0 for i < j and g(xi) = 1 for i \u2265 j. For the first case, h(yi) = f(xi, yi) for any i and h alters exactly k times on points y1 \u00b7 \u00b7 \u00b7 yk+1. For the second case, h(y1) = f(x1, y1) = 1, and h alters exactly k \u2212 1 times on y1 \u00b7 \u00b7 \u00b7 yj\u22121 yj+1 \u00b7 \u00b7 \u00b7 yk+1. Both cases contradict h being (k \u2212 1)-monotone.\nProof of Claim 3.7. Let Mh be the maximal set of paths of length k such that all paths are vertex disjoint and for every path y1 \u00b7 \u00b7 \u00b7 yk, h(y1) = 0 and h(yi) 6= h(yi+1) for 1 \u2264 i \u2264 k \u2212 1. Let Mg be the maximal set of pairs such that all pairs are vertex disjoint and every pair x1 x2 is a violation for g, i.e., g(x1) = 1 and g(x2) = 0. For each path (y1 \u00b7 \u00b7 \u00b7 yk) \u2208 Mh and any pair (x1 x2) \u2208 Mg, it is easy to see following path is a violation for f ||g being k-monotone :\n(x1, y1), . . . , (x1, yk), (x2, yk).\nLet f \u2032 be the closest k-monotone function to f . For each violating path, f and f \u2032 differ on at least 1 point. Because both Mh and Mg are vertex disjoint, violating paths constructed by taking every\npath in Mh and every pair in Mg are vertex disjoint. Thus f and f \u2032 differ on at least |Mh| \u00d7 |Mg| points and f is (|Mh|\u00b7|Mg| /22d)-far from f \u2032. It is known ([GGL+00]) that for any g : {0, 1}d \u2192 {0, 1} which is \u03b5-far from monotone, |Mg| \u2265 2d\u22121\u03b5. The desired conclusion follows.\nProof of Claim 3.8. Let B1, B2, . . . , Bk be consecutive blocks each consisting of consecutive layers of the hypercube such that for each i \u2208 [k],\n(1\u2212 k\u221a d ) 2d k \u2264 |Bi| \u2264 (1 + k\u221a d ) 2d k .\nBecause k is a constant and every layer contains at most 2d/ \u221a d points, we can always greedily find B1, . . . , Bk one by one. Let h be a function such that h has constant value (i+1 mod 2) on block Bi for 1 \u2264 i \u2264 k. It is easy to see that h is (k \u2212 1)-monotone. Next we prove for any 1 \u2264 j \u2264 k, B1, . . . , Bj contain at least (1\u2212od(1))2d k vertex disjoint paths of length j \u2212 1 such the ith point on every path is in Bi. Claim 3.8 follows from the case j = k. For j = 1, the statement holds by taking all points in B1. For j > 1, assume that B1, . . . , Bj\u22121 contain a set Pj\u22121 of such (1\u2212od(1))2d\nk vertex disjoint paths of length j \u2212 2. Let M be the maximal matching between Bj\u22121 and Bj and let Pj be the set of paths of length j\u22121 constructed in following way: for each path in Pj\u22121 with an endpoint yj\u22121, if there exists yj such that (yj\u22121, yj) \u2208 M , we add the path appended with yj into Pj . Because no points in Bj will be added into two different paths in Pj and Pj\u22121 are vertex disjoint, paths in Pj are vertex disjoint.\nNow we show |M | = min(|Bj\u22121| , |Bj |) which implies |Pj | \u2265 (1\u2212od(1))2 d\nk . Suppose |Bj\u22121| \u2264 |Bj | (the argument is analogous in the other case). For any subset S of Bj\u22121, let fS be the indicator function of the upper closure of S denoted as N(S). It is not hard to check that fS is monotone and thus Pr[fS(x) = 1|x \u2208 Bj] \u2265 Pr[fS(x) = 1|x \u2208 Bj\u22121]. It follows\n|N(S) \u2229Bj | = |Bj |Pr[fS(x) = 1|x \u2208 Bj ] \u2265 |Bj\u22121|Pr[fS(x) = 1|x \u2208 Bj\u22121] \u2265 |S| .\nBy Hall\u2019s theorem, |M | = |Bj\u22121|. By similar argument, we can show |M | = |Bj | when |Bj\u22121| > |Bj|. Thus |M | = min(|Bj\u22121| , |Bj|)."}, {"heading": "4 On the line", "text": "In this section we prove our results on testing k-monotonicity on the line, that is of functions f : [n] \u2192 {0, 1}. We start with Theorem 1.4, which establishes that this can be done non-adaptively with one-sided error, with only O(k/\u03b5) queries; we then turn to Theorem 1.3, which shows that this is the best one can hope for if insisting on one-sidedness. The last result of this section is Theorem 1.5, where we show that \u2013 perhaps unexpectedly \u2013 two-sided algorithms, even nonadaptive, can break this barrier and test k-mononicity with no dependence on k."}, {"heading": "4.1 Upper and lower bounds for one-sided testers", "text": "We first prove the upper bound, restated below:\nTheorem 1.4. There exists a one-sided non-adaptive tester for k-monotonicity of functions f : [n] \u2192 {0, 1} with query complexity q(n, \u03b5, k) = O ( k \u03b5 ) .\nProof. We assume that \u03b5n50k is an integer, 4 and partition the domain into K def = 50k\u03b5 intervals of size \u03b5n50k , the consecutive \u201cblocks\u201d B1, . . . , BK . We then define g : [n] \u2192 {0, 1, \u2217} as the function constant on each block Bi = {bi, . . . , bi+1 \u2212 1}, such that\n\u2022 If f(bi) = f(bi+1 \u2212 1), then g(j) = f(bi) for all j \u2208 Bi; \u2022 otherwise, g(j) = \u2217 for all j \u2208 Bi.\nWe say that a block Bi such that g|Bi = \u2217 is a changepoint block for g. Clearly, given query access to f one can obtain the value of g on any point j \u2208 [n] with only two queries to f . Moreover, defining g\u0303 : [n] \u2192 {0, 1} to be the function obtained from g by replacing \u2217 by 0, we observe the following:\n\u2022 If f is k-monotone, then (i) so is g\u0303, and (ii) f and g\u0303 differ in at most k blocks (namely the changepoint blocks of g), so that dist(f, g) \u2264 k \u00b7 1K = \u03b550 ; \u2022 If f is \u03b5-far from k-monotone, then either (i) g\u0303 is not k-monotone, or (ii) dist(f, g\u0303) > \u03b5. We start by learning g (and thus g\u0303) exactly, using 2K = O(k/\u03b5) non-adaptive queries. Setting\nm def = C k\u03b5 , we also sample m \u2032 \u223c Poisson(m) points5 j1, . . . , jm\u2032 independently and uniformly from [n], where C > 0 is a constant to be determined in the course of the analysis, and query the value of f (and g) on all of them. Then, we reject if either (i) g\u0303 is not k-monotone; or (ii) there exist at least k + 1 distinct blocks which contain a sample sj such that g\u0303(sj) 6= f(sj).\nBy definition, this tester is non-adaptive; and it is not difficult to see it accepts any k-monotone function with probability 1, since in that case f and g (and a fortiori g\u0303) differ in at most k blocks: indeed, these blocks can only be changepoint blocks for g, i.e. blocks where f changes value.\nIt remains to argue soundness: we will show that if f is \u03b5-far from k-monotone, the tester will reject with probability at least 2/3. By the first check made, (i), we can assume in the following that g\u0303 is k-monotone \u2013 as otherwise f is rejected with probability 1 \u2013 and we need to show that (ii) will reject with probability at least 2/3. For each block Bi (where i \u2208 [K]), let pi \u2208 [0, 1K ] be defined as the (normalized) number of points in Bi on which f and g\u0303 differ (we henceforth refer to such a point as a giveaway point):\npi def =\n1\nn\n\u2211\nj\u2208Bi 1{f(j)6=g\u0303(j)}.\nSince f is \u03b5-far from the k-monotone function g\u0303, we have \u2211K\ni=1 pi \u2265 \u03b5. Now, letting Zi be the indicator of the event that among the m\u2032 samples, at least one is giveaway point from Bi, and Z = \u2211K i=1 Zi, we can write Zi = 1{Yi 6=0}, where the (Yi)i\u2208[K] are independent Poisson random variables with Yi \u223c Poisson(mpi). The expected number of blocks in which a giveaway point is sampled is then\nEZ = K\u2211\ni=1\nEZi = K\u2211\ni=1\nPr[Yi 6= 0 ] = K\u2211\ni=1\n(1\u2212 e\u2212mpi)\nSince for every i \u2208 [K] it holds that e\u2212mpi \u2264 1 \u2212 m2 pi (the inequality holding since 0 \u2264 mpi \u2264 1, 4If not, we consider instead \u03b5\u2032 def = 50k\nn\n\u230a \u03b5n\n50k\n\u230b > \u03b5 \u2212 50k\nn > \u03b5 2 if \u03b5 > 100k n ; while if \u03b5 \u2264 100k n we query the entire\nfunction, for a total of n = O ( k \u03b5 ) queries.\n5The fact that we sample Poisson(m) instead ofm is for ease of the analysis; note that due to the tight concentration of Poisson random variables, with probability 1\u2212 o(1) we will have m\u2032 \u2264 2m. If this does not happen, the tester can output ACCEPT, incurring only a small additional error probability (and not affecting the one-sidedness).\nwhich is verified for m \u2264 K), we get\nEZ = K\u2211\ni=1\nEZi \u2265 K\u2211\ni=1\nm\n2 pi \u2265\nm\u03b5 2 \u2265 C 2 k.\nMoreover, by a Chernoff bound, we get that\nPr [ Z < C\n4 k\n] \u2264 e\u2212Ck16 \u2264 e\u2212 C16\nwhich is less that 1/4 for C \u2265 23. Setting C def= 30 satisfies both conditions that m \u2264 K and C \u2265 23, and results in a one-sided non-adaptive tester which rejects functions far from k-monotone with probability at least 1\u2212 14 + o(1) \u2265 23 .\nTurning to the lower bounds against one-sided testers, we show the following:\nTheorem 1.3. Any one-sided (possibly adaptive) tester for k-monotonicity of functions f : [n] \u2192 {0, 1} must have query complexity \u2126 ( k \u03b5 ) . Proof. Since a lower bound of \u2126 ( 1 \u03b5 ) straightforwardly holds, we can restrict ourselves to k \u2265 8, and \u03b5 < 112 ; moreover, we assume without loss of generality that \u03b5n k is an integer, and partition the domain into K def = k\u03b5 intervals of size \u03b5n k , the consecutive \u201cblocks\u201d B1, . . . , BK . For v \u2208 {0, 1}K/2, we define gv : [n] \u2192 {0, 1} as the function which has constant value vi on block B2i\u22121 and has constant value 1 on the remaining blocks.\nConsider the distribution over {gv}v where each coordinate of v is independently set to 0 with probability p def = 6\u03b5, and 1 otherwise. We next show that gv is at least \u03b5-far from any k-monotone function with very high probability over the choice of v. By a Chernoff bound, with probability at least 1\u2212 e\u2212pK/16 = 1\u2212 e\u22123k/8, gv has at least pK/4 = 3k/2 blocks that are 0 blocks. Conditioned on this, it is easy to see that gv is \u03b5-far from k-monotone: indeed, to make it k-monotone one has to flip its value on at least k blocks, and each block contains an \u03b5/k fraction of the domain.\nFix any deterministic adaptive algorithm with query complexity q \u2264 k/(24\u03b5) queries, and denote by x1, . . . , xq the sequence of queries made (when given query access to some function gv). Note that x1 is fixed by the algorithm and that for 1 < i \u2264 q, xi is uniquely determined by previous answers f(x1), . . . , f(xi\u22121). We can sample the distribution {gv}v and answer queries from the given algorithm in the following \u201clazy way\u201d: first, by marking every even blocks with value 1 and initializing a list of queried odd blocks with their values. When a new query x comes, if x was previously queried or belongs to an even block, we return the corresponding stored value. Otherwise, we sample the value, which is 0 with probability 6\u03b5 and 1 otherwise, for the odd block which x belongs to; and mark this block as queried.\nLet y1, . . . , yr be the following subsequence of x1, . . . , xq: yi is the ith query made into an odd block which is not queried in y1, . . . , yi\u22121. Clearly r \u2264 q and y1, . . . , yr reveals a violation if and only if number of 0\u2019s in corresponding answers is at least k/2 + 1. Note, for arbitrary a \u2208 {0, 1}r ,\nPr[ f(y1) = a1, . . . , f(yr) = ar ] = Pr[ f(y1) = a1 ] \u00b7 r\u220f\ni=2\nPr[ f(yi) = ai | f(y1) = a1, . . . , f(yi\u22121) = ai\u22121 ] .\nyi is determined by f(y1) = a1, . . . , f(yi\u22121) = ai\u22121 and by our way of sampling f(yi), we know that for every i it holds that Pr[ f(yi) = ai | f(y1) = a1, . . . , f(yi\u22121) = ai\u22121 ] = 6\u03b5 if ai = 0 and Pr[ f(yi) = ai | f(y1) = a1, . . . , f(yi\u22121) = ai\u22121 ] = 1\u2212 6\u03b5 if ai = 1. Thus.\nPr[ f(y1) = a1, . . . , f(yr) = ar ] = (1\u2212 6\u03b5)|a|(6\u03b5)r\u2212|a|. (4)\nLet Yi be the indicator that f(yi) = 0. We get that, writing F (i,N, p) for the cumulative distribution function of a Binomial with parameters N and p,\nPr\n[ r\u2211\ni=1\nYi \u2265 k\n2 + 1\n] \u2264\n\u2211\na\u2208{0,1}r : |a\u0304|\u2265k/2 (1\u2212 6\u03b5)|a|(6\u03b5)r\u2212|a|\n=\nr\u2212k/2\u2211\n\u2113=0\n( r\n\u2113\n) (1\u2212 6\u03b5)\u2113(6\u03b5)r\u2212\u2113 = F ( r \u2212 k\n2 , r, 1 \u2212 6\u03b5\n)\n= F (r(1\u2212 x), r, 1 \u2212 6\u03b5) (x def= k2r \u2208 (12\u03b5, 1)) \u2264 e\u2212rD(1\u2212x||1\u22126\u03b5) (Relative entropy Chernoff bound6)\nwhere D(p || q) def= p ln pq + (1 \u2212 p) ln 1\u2212p 1\u2212q , and we used the fact that k 2 + 1 \u2264 r \u2264 k24\u03b5 . Rewriting\nslightly the right-hand-side, we obtain\nPr\n[ r\u2211\ni=1\nYi \u2265 k\n2 + 1\n] \u2264 e\u2212 k2\u03a6(x)\nfor \u03a6(x) def = 1x ( (1\u2212 x) ln 1\u2212x1\u22126\u03b5 + x ln x6\u03b5 ) . It is not hard to see that \u03a6 is increasing on [6\u03b5, 1), and since x \u2265 12\u03b5 the right-hand-side is at most e\u2212 k2\u03a6(12\u03b5). It then suffices to observe that, for \u03b5 \u2264 112 , it holds that \u03a6(12\u03b5) \u2265 \u03a6(0) = ln 2\u2212 12 > 18 to conclude that\nPr\n[ r\u2211\ni=1\nYi \u2265 k\n2 + 1\n] \u2264 e\u2212 k16\nand therefore obtain\nPr[ f(y1), . . . , f(yr) contains at least (k/2 + 1) zeros ] \u2264 e\u2212 k 16 .\nCombining the two, this shows that the probability that y1, . . . , yr does not reveal a violation for gv while gv is \u03b5-far from k-monotone is at least 1\u2212 e\u2212k/16 \u2212 e\u22123k/8 > 1/3 (since k \u2265 8). By Yao\u2019s principle, for any (possibly randomized) non-adaptive algorithm A making at most k/(24\u03b5) there exists a fixed v such that gv is \u03b5-far from k-monotone yet A rejects gv with probability less than 2/3. The desired conclusion follows."}, {"heading": "4.2 Upper bound for two-sided testers: proof of Theorem 1.5", "text": "In this section, we prove the two-sided non-adaptive upper bound of Theorem 1.5, restated below:\n6Recall that the relative entropy version of the Chernoff bound states that F (m,N, p) \u2264 e\u2212mD(mN ||p) as long as 0 \u2264 m\nN \u2264 p.\nTheorem 1.5. There exists a two-sided non-adaptive tester for k-monotonicity of functions f : [n] \u2192 {0, 1} with query complexity q(n, \u03b5, k) = O\u0303 ( 1/\u03b57 ) , independent of k.\nIn what follows, we assume that k > 20/\u03b5, as otherwise we can use for instance the O(k/\u03b5)-query (non-adaptive, one-sided) tester of Theorem 1.4 to obtain an O ( 1/\u03b52 ) query complexity.\n4.2.1 Testing k-monotonicity over [Ck]\nWe begin by giving a poly(C/\u03b5)-query tester for k-monotonicity over the domain [Ck]. The tester proceeds by reducing to support size estimation and using (a slight variant of) an algorithm of Canonne and Rubinfeld [CR14]. Let f : [Ck] \u2192 {0, 1}, and suppose f is s-monotone but not (s\u22121)monotone. Then there is a unique partition of [Ck] into s+1 disjoint intervals I1, I2, . . . , Is+1 such that f is constant on each interval; note that this constant value alternates in consecutive intervals. We define a distribution Df over [s + 1] such that Df (i) = |Ii| /(Ck).\nThe algorithm of [CR14] uses \u201cdual access\u201d to D; an oracle that provides a random sample from D, and an oracle that given an element of D, returns the probability mass assigned to this element by D.\nTheorem 4.1 ([CR14, Theorem 14 (rephrased)]). In the access model described above, there exists an algorithm that, on input a threshold n \u2208 N\u2217 and a parameter \u03b5 > 0, and given access to a distribution D (over an arbitrary set) satisfying\nmin x\u2208supp(D) D(x) \u2265 1 n\nestimates the support size |supp(D)| up to an additive \u03b5n, with query complexity O (\n1 \u03b52\n) .\nWe only have access to Df through query access to f . One difficulty is that, to access Df (i), we need to determine where Ii lies in f . For example, finding Df (k/2) requires finding Ik/2, which might require a large number of queries to f .\nWe circumvent this by noting that the algorithm does not require knowing the \u201clabel\u201d of any element in the support of the distribution. The only access required is being able to randomly sample elements according to Df , and evaluate the probability mass on the sampled points.\nLemma 4.2 (Sampling from Df ). Let i \u2208 [n] be chosen uniformly at random, and let j be such that i \u2208 Ij . Then, the distribution of j is exactly Df .\nLemma 4.3 (Evaluating Df (j)). Suppose Ij = {a, a+ 1, . . . , b}. Given i such that i \u2208 Ij , we can find Ij by querying f(i + 1) = f(i + 2) = \u00b7 \u00b7 \u00b7 = f(b) and f(b + 1) 6= f(b), as well as f(i \u2212 1) = f(i\u2212 2) = . . . = f(a) and f(a\u2212 1) 6= f(a). The number of queries to f is b\u2212 a+ 3 = |Ij|+ 3.\nIf we straightforwardly use these approaches to emulate the required oracles to estimate the support size of Df , the number of queries is potentially very large. If we attempt to query Df (j) where |Ij| = \u2126(k), we will need \u2126(k) queries to f . It will be enough for us to \u201ccap\u201d the size of the interval.\nLemma 4.4 (Evaluating Df (j) with a cap). Given i such that i \u2208 Ij, we will query f on every point in [i \u2212 20C/\u03b5, i + 20C/\u03b5]. If |Ij| \u2264 20C/\u03b5, then Ij will be determined by these queries. If these queries do not determine Ij, we know |Ij| > 20C/\u03b5. Beyond querying i, this requires 40C/\u03b5 (nonadaptive) queries.\nClaim 4.5. If f is \u03b5-far from k-monotone, then it is not (1 + \u03b54)k-monotone, and in particular |supp(Df )| > (1 + \u03b54 )k + 1.\nProof. The last part of the statement is immediate from the first, so it suffices to prove the first implication. We show the contrapositive: assuming f is (1 + \u03b54)k-monotone, we will \u201cfix\u201d it into a k-monotone function by changing at most \u03b5n points. In what follows, we assume \u03b5k4 \u2265 1, as otherwise the statement is trivial (any function that is \u03b5-far from k-monotone is a fortiori not k-monotone).\nLet as before \u2113\u2217 be the minimum integer \u2113 for which f is \u2113-monotone: we can assume k < \u2113\u2217 \u2264 (1 + \u03b54)k (as if \u2113\n\u2217 \u2264 k we are done.) Consider as above the maximal consecutive monochromatic intervals I1, . . . , I\u2113\u2217 , and let i be the index of the shortest one. In particular, it must be the case that |Ii| \u2264 n\u2113\u2217+1 . Flipping the value of f on Ii therefore has \u201ccost\u201d at most n\u2113\u2217+1 , and the resulting function f \u2032 is now exactly (\u2113\u2217\u22122)-monotone if 1 < i < \u2113\u2217, and (\u2113\u2217\u22121)-monotone if i \u2208 {1, \u2113\u2217}. This means in particular that repeating the above \u03b54k times is enough to obtain a k-monotone function, and the total cost is upperbounded by\n\u03b5k/4\u2211\nj=0\nn \u2113\u2217 + 1\u2212 2j \u2264 \u03b5k/4\u2211\nj=0\nn k + 1\u2212 2j = k+1\u2211\nj=k(1\u2212 \u03b5 2 )+1\nn j \u2264 n\n\u03b5 2k + 1\n(1\u2212 \u03b54)k + 1 \u2264 n\n3\u03b5 4 k\n(1\u2212 \u03b54)k\nwhere for the last inequality (for the numerator) we used that 1 \u2264 \u03b5k4 . But this last RHS is upperbounded by \u03b5n (as 34x \u2264 x(1 \u2212 14x) for x \u2208 [0, 1]), showing that Therefore, f was \u03b5-close to k-monotone to begin with, which is a contradiction.\nClaim 4.6. To \u03b5-test k-monotonicity of f : [n] \u2192 {0, 1}, it suffices to estimate |Df | to within \u03b5k10 .\nProof. If f is \u03b5-far from k-monotone, then |Df | > (1 + \u03b54)k = k + \u03b54k, and if f is k-monotone, then |Df | \u2264 k + 1. The fact that k > 20/\u03b5 then allows us to conclude.\nClaim 4.7. There exists a two-sided non-adaptive tester for k-monotonicity of functions f : [Ck] \u2192 {0, 1} with query complexity O ( C3\n\u03b53\n) .\nProof. We use the algorithm of [CR14] for estimating support size. Inspecting their algorithm, we see that our cap of 20C/\u03b5 for interval length (and therefore 20/(\u03b5k) for maximum probability reported) might result in further error of the estimate. The algorithm interacts with the unknown function by estimating the expected value of 1/Df (j) over random choices of j with respect to Df . Our cap can only decrease this expectation by at most (\u03b5k)/20. Indeed, the algorithm works by estimating the quantity Ex\u223cDf [ 1 Df (x)\n1{Df (x)>\u03c4}], for some suitable parameter \u03c4 > 0. By capping the value of 1/Df (x) to 20/(\u03b5k), we can therefore only decrease the estimate, and by at most 20/(\u03b5k) \u00b7Df ({ x : Df (x) > (\u03b5k)/20 }) \u2264 20/(\u03b5k).\nThe condition for their algorithm to estimate support size to within \u00b1\u03b5m is that all elements in the support have a probability mass of at least 1/m. Since each nonempty interval has length at least 1, we have minj Df (j) \u2265 (1/Ck). In order for their algorithm to report an estimate within \u00b1\u03b5k/20 of support size, we set \u03b5\u2032 = (\u03b5/20C) in their algorithm.\nThe total error in support size is at most \u03b5k/20+ \u03b5k/20 = \u03b5k/10. By Claim 4.6, this suffices to test \u03b5-test k-monotonicity of f .\nUsing the algorithm of [CR14], we need O(1/\u03b5\u20322) = O ( (C/\u03b5)2 ) queries to Df . For every query\nto Df , we need to make O(C/\u03b5) queries to f , so the overall query complexity is O ( C3/\u03b53 ) .\n4.2.2 Reducing [n] \u2192 {0, 1} to [Ck] \u2192 {0, 1}.\nNow we show how to reduce \u03b5-testing k-monotonicity of f : [n] \u2192 {0, 1} to \u03b5\u2032-testing k-monotonicity of a function g : [Ck] \u2192 {0, 1} for C = poly(1/\u03b5) and \u03b5\u2032 = poly(\u03b5), resulting in a poly(1/\u03b5)-query algorithm for \u03b5-testing k-monotonicity.\nThe first step is (as before) to divide [n] in blocks (disjoint intervals) of size \u03b5n4k if \u03b5 > 8k n (again assuming without loss of generality that \u03b5n4k is an integer), and blocks of size 1 otherwise (in which case n \u2264 8k\u03b5 and we can directly apply the result of Claim 4.7, with C = n/k \u2264 8/\u03b5). Let m = 4k/\u03b5 be the number of resulting blocks, and define fm : [n] \u2192 {0, 1} as the m-block-coarsening of f : namely, for any j \u2208 Bi, we set\nfm(j) = argmaxb\u2208{0,1} Pr k\u2208Bi [fm(k) = b] (majority vote)\nOrdering the blocks B1, B2, . . . , Bm, we also define g : [m] \u2192 {0, 1} such that g(i) = mina\u2208Bi fm(a).\nLemma 4.8. Suppose f is k-monotone. Then f has at most k non-constant blocks, and fm is k-monotone.\nProof. The function f only changes values k times; for a block to be non-constant, the block must contain a pair of points with a value change.\nWe call a block variable if the minority points comprise at least an \u03b5/100-fraction of the block; formally, B is variable if minb\u2208{0,1} Prj\u2208B[f(j) = b] \u2265 \u03b5/100.\nLemma 4.9. Suppose f has s variable blocks. Then dist(f, fm) \u2264 s/m+ \u03b5/100.\nProof. We will estimate the error of fm in computing f on variable blocks and non-variable blocks separately. Each non-variable block B can contribute error on at most \u03b5 |B| /100 points. Each variable block B can contribute error on at most |B| = n/m points. The total number of errors is at most \u03b5n/100 + s(n/m) = n(\u03b5/100 + s/m), yielding the upper bound on dist(f, fm).\nLemma 4.10. Suppose f is promised to be either (i) k-monotone or (ii) such that fm has more\nthan 54k variable blocks. Then we can determine which with O ( 1 \u03b52 log 1\u03b5 ) queries, and probability 9/10.\nProof. We first note that given any fixed block B, it is easy to detect whether it is variable (with probability of failure at most \u03b4) by making O ( 1 \u03b5 log 1 \u03b4 ) uniformly distributed queries in B. Doing so, a variable block will be labelled as such with probability at least 1\u2212 \u03b4, while a constant block will never be marked as variable. (If a block is neither constant nor variable, then any answer will do.)\nLetting s denote the number of variable blocks, we then want to non-adaptively distinguish between s \u2265 54k = 5\u03b516m and s \u2264 k = \u03b54m (since if f were k-monotone, then fm had at most k variable blocks). Doing so with probability at least 19/20 can be done by checking only q = O ( 1 \u03b5 ) blocks chosen uniformly at random: by the above, setting \u03b4 = 120q all of the q checks will also yield the correct answer with probability no less than 9/10, so by a union bound we will distinguish (i) and (ii) with probability at least 9/10. We conclude by observing that all O ( q \u00b7 1\u03b5 log 1q ) = O ( 1 \u03b52 log 1\u03b5 ) queries are indeed non-adaptive.\nClaim 4.11. There exists a two-sided non-adaptive tester for k-monotonicity of functions f : [n] \u2192 {0, 1} with query complexity O\u0303 ( 1 \u03b57 ) .\nProof. We use the estimation/test from the previous lemma as the first part of our tester. Assuming f passes, we can assume that fm has less than 5 4k variable blocks. By Lemma 4.9, dist(f, fm) \u2264 5k 4 /m+ \u03b5 100 = 5\u03b5 32 + \u03b5 100 \u2264 \u03b53 . This part takes O ( 1 \u03b52 log 1 \u03b5 ) queries.\nNow, we apply the tester of Claim 4.7 (with probability of success amplified to 9/10 by standard arguments) to (\u03b5/6)-test k-monotonicity of g : [m] \u2192 {0, 1}, where g(i) is the constant value of fm on Bi, and m = (4k)/\u03b5. Let q be the query complexity of the tester, and set \u03b4 = 1/(10q); to query\ng(i), we randomly query f on O ( 1 \u03b5 log 1 \u03b4 ) points in Bi and take the majority vote. With probability at least 1\u2212 \u03b4, we get the correct value of g(i), and by a union bound all q simulated queries have the correct value with probability at least 9/10.\nTherefore, to get a single query to g, we use O((log q)/\u03b5) queries. In the context of our previous section, we have C = 4/\u03b5, so q = O(C3/\u03b53) = O ( 1/\u03b56 ) and the overall query complexity of this part is O((q log q)/\u03b5) = O (\n1 \u03b57 log 1 \u03b5\n) . This dominates the query complexity of the other part of the\ntester, from Lemma 4.10, which is O (\n1 \u03b52 log 1 \u03b5\n) . By a union bound over the part from Lemma 4.10,\nthe simulation of g, and the call to the tester of Claim 4.7, the algorithm is correct with probability at least 1\u2212 3/10 > 2/3."}, {"heading": "5 On the grid", "text": "We now turn to the grid, and consider k-monotonicity of functions defined on [n]2. More specifically, in this section we prove Theorem 1.6, giving an adaptive tester for 2-mononicity with optimal query complexity, before discussing in Section 5.2 possible extensions of these ideas."}, {"heading": "5.1 The case k = 2", "text": "Theorem 1.6. There exists a two-sided adaptive tester for 2-monotonicity of functions f : [n]2 \u2192 {0, 1} with query complexity q(n, \u03b5) = O ( 1 \u03b5 ) .\nProof. At a high-level, the algorithm relies on two key components: the first is the observation that testing 2-monotonicity of f : [n]2 \u2192 {0, 1} under some suitable additional assumption on f reduces to (tolerant) testing monotonicity of two one-dimensional functions (but with larger range), under the L1 norm. The second is that, given access to an arbitrary f , one can efficiently provide query access to some function g which satisifies this additional assumption, and such that g will also be close to f whenever f is truly 2-monotone.\nCombining the two then enables one to test this function g for 2-monotonicity, and then check whether it is also the case that f and g are sufficiently close. The first step, by the above, can be done efficiently by simulationg query access to g, which in turn allows to (with some additional tricks) simulate access to the corresponding one-dimensional functions: and invoke on these two functions the L1-tester of [BRY14]. (The main challenges there lies in performing this two-level simulation while keeping the number of queries to f low enough; which we achieve by carefully amortizing the queries made overall.)\nDetails. We hereafter assume without loss of generality that f is identically 0 on the bottom and top rows, that is f(1, j) = f(n, j) = 0 for all j \u2208 [n]. (Indeed, we can ensure this is the case by adding two extra columns, extending the domain of f to [n + 2] \u00d7 [n]: note that if f remains 2-monotone if it was already, and can only decrease its distance to 2-monotonicity by O(1/n)).7 For the sake of the proof, we will require the notion of 2-column-wise-monotonicity, defined below:\nDefinition 5.1. A function f : [n]2 \u2192 {0, 1} is said to be 2-column-wise-monotone if, for every j \u2208 [n], its restriction fj : [n]\u00d7{j} \u2192 {0, 1} is 2-monotone. Given such a function f , we define the two sequences (\u2202\u0304fj)j\u2208[n] and (\n\u00af \u2202fj)j\u2208[n] as the sequence of \u201cchangepoints\u201d in the columns. More\nformally, we define\n\u00af \u2202fj = min { i \u2208 [n] : f(i, j) 6= f(1, j) } \u2212 1, \u2202\u0304fj = max { i \u2208 [n] : f(i, j) 6= f(n, j) }+ 1\nfor every j such that f |[n]\u00d7{j} is not constant; and \u00af \u2202fj = \u2202\u0304fj = 1 otherwise. Note that we have \u00af \u2202fj \u2264 \u2202\u0304fj for every column j \u2208 [n].\nAs it turns out, testing 2-monotonicity of functions guaranteed to be 2-column-wise-monotone reduces to testing monotonicity of these two specific subsequences:\nLemma 5.2. Let f : [n]2 \u2192 {0, 1} be 2-column-wise-monotone. If f is 2-monotone, then both sequences (\n\u00af \u2202fj)j\u2208[n] and (\u2202\u0304fj)j\u2208[n] are non-increasing. Moreover, if f is \u03b5-far from 2-monotone,\nthen at least one of the two sequences is \u03b52-far from non-increasing (in Hamming distance).\nIt is possible to refine the above statement to obtain, in the second case, a more precise characterization in terms of the L1 distance of these two sequences to monotonicity. For conciseness, in the rest of this section we denote by M(d)k the class of k-monotone functions on [n]d, and will omit the subscript when k = 1 (i.e., for monotone functions: M(d) = M(d)1 ). Lemma 5.3. Let f : [n]2 \u2192 {0, 1} be 2-column-wise-monotone. If f is \u03b5-far from 2-monotone then at least one of the two sequences is \u03b52 -far from non-increasing (in L1 distance). More precisely:\ndist ( f,M(2)2 ) \u2264 L1(\u2202\u0304f,M(1)) + L1(\n\u00af \u2202f,M(1)) (5)\nWe defer the proof of these two lemmata to Appendix C, and turn to the proof of Theorem 1.6. We first describe a non-optimal tester making O(1/\u03b52) queries; before explaining how to modify it in order to amortize the number of queries, to yield the desired O(1/\u03b5) query complexity.\nSuppose we are given query access to an arbitrary function f : [n]2 \u2192 {0, 1}. For simplicity, as before we assume without loss of generality that \u03b5n16 is an integer, and partition each column into K def = 16\u03b5 intervals of size \u03b5n 16 , that is partition the domain [n] \u00d7 [n] into a grid [16\u03b5 ] \u00d7 [n] (each column being divided in K blocks B1, . . . , BK of size \u03b5n 16 ). This uniquely defines a function g : [n]2 \u2192 {0, 1, \u2217}: for any point x = (i, j) \u2208 [n]2, we let \u2113 \u2208 [K] be the index such that i \u2208 B\u2113 = {b\u2113, . . . , b\u2113+1 \u2212 1}, and set:\n\u2022 g(x) = f(i, b\u2113)), if f(i, b\u2113) = f(i, b\u2113+1 \u2212 1); \u2022 g(x) = \u2217, if f(i, b\u2113) 6= f(i, b\u2113+1 \u2212 1);\n7This will be used in the proof of Lemma 5.2 and Lemma 5.3.\nso that g is constant on any \u201cblock\u201d B\u2113 \u00d7 {i}. Note that we can provide query access to g, at the price of an overhead of 2 queries (to f) per query (to g).\nHowever, this g may not itself be 2-column-wise-monotone; for this reason, we will instead work with a \u201cfixed\u201d version of g which will by construction be 2-column-wise-monotone. In more detail, we define g\u0303 to be the 2-column-wise-monotone function obtained by the following process.\n\u2022 First, we (arbitrarily) set the values \u2217 to 0, so that g becomes a function g : [n]2 \u2192 {0, 1}. \u2022 Define g\u0303 by its restriction on each column: letting (\u2202\u0304gj)j\u2208[n] and (\n\u00af \u2202gj)j\u2208[n] be as defined\nin Definition 5.1 (observing that the quantities are well and uniquely defined even if g is not 2-column-wise-monotone), set\ng\u0303(i, j) =    g(1, j) if i \u2264 \u00af \u2202gj 1\u2212 g(1, j) if \u00af \u2202gj < i < \u2202\u0304gj\ng(n, j) if i \u2265 \u2202\u0304gj\nFrom this construction, it is clear that g\u0303 is 2-column-wise-monotone, and entirely and deterministically determined by g (and therefore by f); moreover we have g\u0303 = g whenever g is itself 2-columnwise-monotone. Furthermore, any query to g\u0303 can straightforwardly be answered by making at most queries O(1/\u03b5) to g, and hence to f .\n\u2022 If f is 2-monotone, then g is \u03b58 -close to f and so is g\u0303; moreover, g\u0303 is 2-monotone as well. Therefore dist(f, g\u0303) \u2264 \u03b58 and dist ( g\u0303,M(2)2 ) = 0. \u2022 If f is \u03b5-far from 2-monotone, then g\u0303 is either (i) \u03b54 -far from f or (ii) 3\u03b54 -far from 2-monotone, since if neither hold then by the triangle inequality f is \u03b5-close to 2-monotone.\nThe tester (first take). The algorithm now proceeds as follows:\n1. simulate query access to g\u0303 (defined as above) to detect if dist ( g\u0303,M(2)2 ) \u2265 \u03b5 using Eq.(5), with\nprobability of failure 16 . More precisely, test monotonicity in L1 distance of both \u00af \u2202g\u0303 and \u2202\u0304g\u0303 with parameter \u03b564 , using the (non-adaptive) algorithm of [BRY14]; and reject if any of these two tests rejects.\n\u2022 If dist ( g\u0303,M(2)2 ) = 0, then\nL1(\u2202\u0304f,M(1)) = L1( \u00af \u2202f,M(1)) = 0\nby Lemma 5.2, and both tests will accept.\n\u2022 If dist ( g\u0303,M(2)2 ) > 3\u03b54 , then\nmax(L1(\u2202\u0304f,M(1)), L1( \u00af \u2202f,M(1))) > 3\u03b5 8\nand at least one of the two tests rejects.\n2. simulate query access to g\u0303 to test whether dist(f, g\u0303) \u2264 \u03b58 vs. dist(f, g\u0303) > \u03b54 , with probability of failure 16 ; 3. return ACCEPT if both of the two tests above passed, REJECT otherwise.\nBy a union bound, the tester is then correct with probability at least 23 ; its query complexity is\n2t \u00b7O ( 1\n\u03b5\n) + ( t\u2032 \u00b7O ( 1\n\u03b5\n) +O ( 1\n\u03b5\n))\nwhere t and t\u2032 are respectively the cost of simulating query access to \u2202\u0304g, \u00af \u2202g, and to g\u0303; as the first step, testing in L1 for for functions defined on the line [n], has query complexity O(1/\u03b5) from [BRY14]. Taking t = t\u2032 = O(1/\u03b5) as discussed above then results in a query complexity of O ( 1/\u03b52 ) .\nHowever, as mentioned previously this is not optimal: as we shall see, we can modify this to obtain instead an O(1/\u03b5) query complexity. In order to \u201camortize\u201d the overall query complexity, we define the following process that specifies a 2-column-wise-monotone function g\u030a:\nInitialization. Let j1, . . . , j1/\u03b5+1 \u2208 [n] be the indices defined by j\u2113 = (\u2113\u2212 1) \u00b7 \u03b5n+ 1 for \u2113 \u2208 [1/\u03b5], and j1/\u03b5+1 = n.\n\u2022 Obtain all the values of g on the j1-st column [n]\u00d7 {j1}, at a cost of O(1/\u03b5) queries to f , to find \u2202\u0304g\u030aj1,\u00af \u2202g\u030aj1. Define g\u030a on this column accordingly. \u2022 Assuming g\u030a has been defined on the j\u2113-th column, define it on the j\u2113+1-th column: starting at the \u201cvertical\u201d positions of the two changepoints \u2202\u0304g\u030aj\u2113,\u00af\n\u2202g\u030aj\u2113 of the previous column, start querying \u201cdownwards\u201d the values of g on the j\u2113+1-th column until candidates values for \u2202\u0304g\u030aj\u2113+1, \u2202\u0304g\u030aj\u2113+1 consistent with g are found or the bottom of the column is reached (in which case the corresponding changepoint \u2202\u0304g\u030aj\u2113+1 or \u00af \u2202g\u030a\u2113+1 is set to 1). After this, define g\u030a on the j\u2113+1-th column to be consistent with these (at most) two changepoints.\nNote that the queries made in this step are adaptive, and the (partial) function g\u030a obtained at the end coincides with g\u0303 if f (and therefore g\u0303) is indeed 2-monotone. This is because in this case, by Lemma 5.2 the sequences (\u2202\u0304g\u0303j)j , (\u00af \u2202g\u0303j)j will be non-decreasing, and therefore the process outlined above will result in \u2202\u0304g\u0303j\u2113 = \u2202\u0304g\u030aj\u2113 and \u00af \u2202g\u0303j\u2113 = \u00af\n\u2202g\u030aj\u2113 for all 1 \u2264 \u2113 \u2264 1/\u03b5 + 1. Moreover, it is not difficult to see that the total number of queries made to f in this initialization step will be O(1/\u03b5): this is because of the fact that we only search for the current changepoint \u2202\u0304g\u030aj\u2113 (resp. \u00af\n\u2202g\u030aj\u2113) starting at the position of the previous one \u2202\u0304g\u030aj\u2113\u22121 (resp.\n\u00af \u2202g\u030aj\u2113\u22121), going downwards only. Since to obtain a changepoint we only query the\npositions of g (and therefore f) at block endpoints, there are in total at most 1/\u03b5 positions to query where starting at one and then only going \u201cdown.\u201d Thus, the number of queries made for each column j\u2113 can be written as O(1) +m\u2113, where \u22111/\u03b5+1\n\u2113=1 m\u2113 \u2264 K = O(1/\u03b5). Query time. When querying the value of g\u030a on a point (i, j), first let \u2113 be the index such that\nj\u2113 \u2264 j < j\u2113+1. Then define \u2202\u0304g\u030aj (resp. \u00af\u2202g\u030aj) by querying the value of g on the j-th column for all at most 1/\u03b5 (block) indices between \u2202\u0304g\u030aj\u2113 and \u2202\u0304g\u030aj\u2113+1 (resp. \u00af \u2202g\u030aj\u2113 and \u00af \u2202g\u030aj\u2113+1) to find the corresponding candidate changepoints:\n\u00af \u2202g\u030aj = min\n{\n\u00af \u2202g\u030aj\u2113+1 \u2264 i \u2264 \u00af\u2202g\u030aj\u2113 : g(i, j) 6= g(1, j)\n} \u2212 1,\n\u2202\u0304g\u030aj = max { \u2202\u0304g\u030aj\u2113+1 \u2264 i \u2264 \u2202\u0304g\u030aj\u2113 : g(i, j) 6= g(n, j) } + 1\nAgain, note that after each query the (partial) function g\u030a obtained so far will coincide with g\u0303 if f (and therefore g\u0303) is indeed 2-monotone; and g\u030a is uniquely determined by f (and in particular does\nnot depend on the actual queries made nor on their order). Finally, the function g\u030a thus defined will always by construction be 2-column-wise-monotone.\nThe tester previously described can then be slightly modified to simulate access to g\u030a instead of g\u0303: by the above discussion, for the completeness case we will have the same guarantees as then g\u030a = g\u0303, while the soundness case stays unchanged:\n\u2022 If f is 2-monotone, then g\u030a = g\u0303 is \u03b58 -close to f ; so dist(f, g\u030a) \u2264 \u03b58 and dist ( g\u030a,M(2)2 ) \u2264 \u03b58 .\n\u2022 If f is \u03b5-far from 2-monotone, then g\u030a is either (i) \u03b54 -far from f or (ii) 3\u03b54 -far from 2-monotone. Thus, the analysis of correctness of the tester carries through with this modification; it only remains to bound the query complexity. We will show that the expected number of queries made is O(1/\u03b5); a bound on the worst-case query complexity will then follow from standard arguments,8 at the price of a constant factor in the O(\u00b7).\nTo give this bound on the expected number of queries, we first observe that the algorithm from [BRY14] we rely on in the first stage of the tester is non-adaptive, and moreover all the queries it makes are uniformly distributed (as it works by a reduction, invoking the non-adaptive, one-sided, sample-based monotonicity tester for functions [n] \u2192 {0, 1}). Similarly, all the queries made in the second stage are uniformly distributed as well.\nTherefore, the expected number of queries a\u2113 made to columns with indices j\u2113 \u2264 j < j\u2113+1 is the same for each \u2113 \u2208 [1/\u03b5 + 1], namely\na\u2113 = q\n1/\u03b5 = O(1).\nwhere q = O ( 1 \u03b5 ) is the total number of queries made to g\u030a (and/or to \u2202\u0304g\u030a,\n\u00af \u2202g\u030a) during the second\nphase of \u201cQuery time.\u201d Now, letting m\u2113 = \u00af \u2202g\u030aj\u2113 \u2212 \u00af\u2202g\u030aj\u2113+1 and m \u2032 \u2113 = \u2202\u0304g\u030aj\u2113 \u2212 \u2202\u0304g\u030aj\u2113+1, we have that the total expected cost of simulating these queries (in terms of queries to f) is upperbounded by\n1 \u03b5\u2211\n\u2113=1\na\u2113 \u00b7 ( O(1) +m\u2113 +m \u2032 \u2113 ) = O\n( 1\n\u03b5\n) +O(1) \u00b7 1 \u03b5\u2211\n\u2113=1\nm\u2113 +O(1) \u00b7 1 \u03b5\u2211\n\u2113=1\nm\u2032\u2113 = O ( 1\n\u03b5\n) .\nSince the total number of queries made to f is the sum of the number of queries made to partly build g\u030a during the \u201cInitialization phase\u201d (which is O(1/\u03b5) by the foregoing discussion), the number of queries made to simulate access to g\u030a or \u2202\u0304g\u030a,\n\u00af \u2202g\u030a during the \u201cQuery time\u201d (which was just shown\nto be O(1/\u03b5) in expectation), and the number of queries directly made to f when testing the distance of f to g\u030a (which is also O(1/\u03b5)), the expected total number of queries is indeed O(1/\u03b5), as claimed."}, {"heading": "5.2 Possible extensions", "text": "We now discuss two possible extensions of the techniques underlying Theorem 1.6, namely to (i) kmonotonicity testing of functions over [n]2, for general k; and (ii) 2-monotonicity testing of functions over [n]d, for general d. (Note that we do provide a different tester for general k and d in the next section, Section 6).\n8Namely, stopping the algorithm and outputting REJECT if the number of queries made exceeds C \u03b5\nfor some absolute constant C > 0, found by applying Markov\u2019s inequality.\nExtending to general k (for d = 2). A natural direction would be to first to generalize Definition 5.1\nto k-column-wise monotone functions f , defining the k sequences ( \u00af \u2202f (1) j )j\u2208[n], . . . , (\u00af \u2202f (k) j )j\u2208[n] of column changepoints with \u00af \u2202f (1) j \u2264 \u00b7 \u00b7 \u00b7 \u2264 \u00af\u2202f (k) j for all j \u2208 [n]. The next step would then be to obtain an analogue of the key lemma of the previous section, Lemma 5.3 to this setting. An issue is that it appears necessary to consider now the L1 distance to (k\u2212 1)-monotonicity of these k sequences, instead of monotonicity as before. Thus, taking this route requires to generalize the definition of k-monotonicity to real-valued functions, but also to develop L1-testers for k-monotonicity over the line.\nThe testing algorithm now follows the same outline as in the previous section, with the same \u201camortizing\u201d idea when invoking this newly obtained L1-tester for k-monotonicity in parallel on the k subsequences, each with probability of failure \u03b4 = 1/(10k) (for a union bound) and approximation parameter \u03b5\u2032 = \u03b5/(10k). (Note that some more optimizations may then help further reduce the query complexity, by \u201csharing\u201d the same set of queries between the k instances of the L1-testing algorithm.)\nExtending to general d (for k = 2). At a very high-level, the tester of Section 5.1 works by reducing 2-monotonicity testing of f : [n]2 \u2192 {0, 1} to monotonicity L1-testing of\n\u00af \u2202f, \u2202\u0304f : [n] \u2192\n[0, 1]. More generally, one can hope to extend this approach to higher dimensions, reducing 2- monotonicity testing of f : [n]d \u2192 {0, 1} to monotonicity L1-testing of\n\u00af \u2202f, \u2202\u0304f : [n]d\u22121 \u2192 [0, 1]: that\nis, testing monotonicity (in L1) of the two (d \u2212 1)-dimensional \u201csurfaces\u201d of changepoints. This in turn could be done invoking the L1 non-adaptive tester of [BRY14] for monotonicity over [n]\nd, which has query complexity O\u0303(d/\u03b5): which may lead to a total query complexity of poly(d, 1/\u03b5), that is polynomial in the dimension. We leave this possible extension as an interesting direction for future work."}, {"heading": "6 On the high-dimensional grid", "text": "In this section, we give two algorithms for tolerant testing, that is testing whether a function f : [n]d \u2192 {0, 1} is \u03b51-close to k-monotone vs. \u03b52-far from k-monotone, establishing Theorem 1.8. The first has query complexity exponential in the dimension d and is fully tolerant, that is works for any setting of 0 \u2264 \u03b51 < \u03b52 \u2264 1. The second applies whenever \u03b52 > 3\u03b51, and has (incomparable) query complexity exponential in O\u0303(k \u221a d/(\u03b52 \u2212 3\u03b51)2). Both of these algorithms can be used for non-tolerant (\u201cregular\u201d) testing by setting \u03b51 = 0 and \u03b52 = \u03b5, which implies Theorem 1.7.\nTheorem 1.8. There exist\n\u2022 a non-adaptive (fully) tolerant tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b51, \u03b52, k) = O\u0303 ( 1 (\u03b52\u2212\u03b51)2 ( 5kd \u03b52\u2212\u03b51 )d) ; \u2022 a non-adaptive tolerant tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b51, \u03b52, k) = 2 O\u0303(k \u221a d/(\u03b52\u22123\u03b51)2), under the restriction that \u03b52 > 3\u03b51.\nAs a corollary, this implies Theorem 1.7, restated below:\nTheorem 1.7. There exists a non-adaptive tester for k-monotonicity of functions f : [n]d \u2192 {0, 1} with query complexity q(n, d, \u03b5, k) = min(O\u0303 ( 1 \u03b52 ( 5kd \u03b5 )d) , 2O\u0303(k \u221a d/\u03b52)).\nFor convenience, we will view in this part of the paper the set [n] as [n] = {0, 1, . . . , n \u2212 1}. Assuming that m divides n, we let Bm,n : [n]d \u2192 [m]d be the mapping such that Bm,n(y)i = \u230ayi/m\u230b for 1 \u2264 i \u2264 m. For x \u2208 [m]d, we define the set B\u22121m,n(x) to be the inverse image of x. Specifically, B\u22121m,n(x) is the set of points of the form m \u00b7 x + [n/m]d, with standard definitions for scalar multiplication and coordinate-wise addition. That is, B\u22121m,n(x) is a \u201ccoset\u201d of [n/m]d points in [n]d. To keep on with the notations of the other sections, we will call these cosets blocks, and will say a function h : [n]d \u2192 {0, 1} is an m-block function if it is constant on each block. Moreover, for clarity of presentation, we will omit the subscripts on B and B\u22121 whenever they are not necessary.\nWe first establish a lemma that will be useful for the proofs of correctness of both algorithms.\nLemma 6.1. Suppose f : [n]d \u2192 {0, 1} is k-monotone. Then there is an m-block function h : [n]d \u2192 {0, 1} such that dist(f, h) < kd/m.\nProof. Fix any k-monotone function f : [n]d \u2192 {0, 1}. We partition [m]d into chains of the form\nCx = { x+ \u2113 \u00b7 1d : \u2113 \u2208 N, x \u2208 [m]d and xi = 0 for some i } .\nThere are md \u2212 (m \u2212 1)d \u2264 dmd\u22121 of these chains: we will show that f can only be nonconstant on at most k blocks of each chain.\nBy contradiction, suppose there exists x \u2208 [m]d such that f is nonconstant on k + 1 different blocks B\u22121(z(i)), where z(1) \u227a z(2) \u227a . . . \u227a z(k) \u227a z(k+1), and each z(i) \u2208 Cx. By construction, we have B\u22121(z(i)) \u227a B\u22121(z(j)) for i < j. For each 1 \u2264 i \u2264 k+1, there are two points v(i)\u2217 , v(i)\u2217\u2217 \u2208 B\u22121(zi) such that v (i) \u2217 \u227a v(i)\u2217\u2217 and f(v(i)\u2217 ) 6= f(v(i)\u2217\u2217 ). By construction v(1)\u2217 \u227a v(1)\u2217\u2217 \u227a v(2)\u2217 \u227a v(2)\u2217\u2217 \u227a v(3)\u2217 \u227a v(3)\u2217\u2217 \u227a . . . \u227a v(k+1)\u2217 \u227a v(k+1)\u2217\u2217 , and there must be at least k + 1 pairs of consecutive points with differing function values. Out of these 2k+2 many points, there is a chain of points v\u0304(1) \u227a v\u0304(2) \u227a . . . \u227a v\u0304(k+1) where f(v\u0304(i)) 6= f(v\u0304(i+1)) for 1 \u2264 i \u2264 k, which is a violation of the k-monotonicity of f .\nThus, in each of the dmd\u22121 many chains of blocks, there can only be k nonconstant blocks. It follows that there are at most kdmd\u22121 nonconstant blocks in total. We now define h(y) to be equal to f(y) if f is constant on B(y), and arbitrarily set h(y) = 0 otherwise. Each set B\u22121(y) contains (n/m)d = nd \u00b7m\u2212d many points, and f is not constant on at most kdmd\u22121 of these. It follows that dist(f, h) \u2264 kdmd\u22121 \u00b7m\u2212d = kd/m."}, {"heading": "6.1 Fully tolerant testing with O(kd/(\u03b52 \u2212 \u03b51)))d queries", "text": "Our first algorithm (Algorithm 1) then proceeds by essentially brute-force learning an m-block function close to the unknown function, and establishes the first item of Theorem 1.8.\nProposition 6.2. Algorithm 1 accepts all functions \u03b51-close to k-monotone functions, and rejects all functions \u03b52-far from k-monotone (with probability at least 2/3). Its query complexity is\nO\n( d (\u03b52\u2212\u03b51)2 ( 5kd \u03b52\u2212\u03b51 + 1 )d log kd\u03b52\u2212\u03b51 ) .\nProof. The algorithm first estimates Pry\u2208B\u22121(x) [ f(y) = b ] for every x \u2208 [m]d and b \u2208 {0, 1} to within \u00b1\u03b15 . We use t = 25 ln(6md)/2\u03b12 points in each block to ensure (by an additive Chernoff bound) that each estimate is correct except with probability at most m\u2212d/3. By a union bound, the probability that all estimates are correct is at least 2/3, and we hereafter condition on this.\nAlgorithm 1 Fully tolerant testing with O(kd/(\u03b52 \u2212 \u03b51)))d queries. Require: Query access to f : [n]d \u2192 {0, 1}, \u03b52 > \u03b51 \u2265 0, a positive integer k 1: \u03b1 \u2190 (\u03b52 \u2212 \u03b51),m \u2190 \u23085kd/\u03b1\u2309, t \u2190 \u230825 ln(6md)/(2\u03b12)\u2309 2: \u22b2 Define a distribution D over [m]d \u00d7 {0, 1}. 3: for x \u2208 [m]d do 4: Query f on t random points Tx \u2286 B\u22121(x). 5: D(x, 0) \u2190 Pry\u2208Tx [ f(y) = 0 ] /md 6: D(x, 1) \u2190 Pry\u2208Tx [ f(y) = 1 ] /md 7: end for 8: \u22b2 Define a distribution D\u2032 over [n]d \u00d7 {0, 1} such that D\u2032(y, b) = D(B(y), b) \u00b7md/nd. 9: if there exists a k-monotone m-block function h such that Pr(y,b)\u223cD\u2032 [ h(y) 6= b ] \u2264 \u03b51 + \u03b12 then\nreturn ACCEPT 10: end if 11: return REJECT\nBy construction, E(x,b)\u223cD[Pry\u2208B\u22121(x) [ f(y) 6= b ]] = Pr(y,b)\u223cD\u2032 [ f(y) 6= b ] \u2264 \u03b15 . In this probability experiment, the marginal distribution of D\u2032 on y is uniform over [n]d.\nLet f\u2217 : [n]d \u2192 {0, 1} be a k-monotone function minimizing Pr[ f(y) 6= f\u2217(y) ]. Lemma 6.1 ensures that there is a k-monotone m-block function h : [n]d \u2192 {0, 1} such that dist(f\u2217, h) < kd/m \u2264 \u03b1/5. Let h\u2217 : [n]d \u2192 {0, 1} be a k-monotone m-block function minimizing dist(f\u2217, h\u2217).\nCompleteness. Suppose dist(f, f\u2217) \u2264 \u03b51. Then by the triangle inequality,\nPr (y,b)\u223cD\u2032 [ h\u2217(y) 6= b ] \u2264 Pr (y,b)\u223cD\u2032 [ h\u2217(y) 6= f\u2217(y) ]+ Pr (y,b)\u223cD\u2032 [ f\u2217(y) 6= f(y) ]+ Pr (y,b)\u223cD\u2032 [ f(y) 6= b ] \u2264 \u03b51+ 2\u03b1 5 .\nwhere to bound the first term Pr(y,b)\u223cD\u2032 [ h \u2217(y) 6= f\u2217(y) ] by dist(f\u2217, h\u2217) \u2264 \u03b1/5 we used the fact that the marginal distribution of y is uniform when (y, b) \u223c D\u2032. Thus, the algorithm will find a k-monotone m-block function close to D (without using any queries to f) and accept.\nSoundness. Suppose dist(f, f\u2217) \u2265 \u03b52. Then by the triangle inequality\nPr (y,b)\u223cD\u2032 [h(y) 6= b] \u2265 Pr (y,b)\u223cD\u2032 [h(y) 6= f(y)]\u2212 Pr (y,b)\u223cD\u2032 [f(y) 6= b]\n\u2265 Pr (y,b)\u223cD\u2032 [f\u2217(y) 6= f(y)]\u2212 Pr (y,b)\u223cD\u2032 [f(y) 6= b] \u2265 \u03b52 \u2212 \u03b1\n5\nfor every k-monotone m-block function h. Since \u03b52 \u2212 2\u03b1/5 \u2265 \u03b51 + 3\u03b1/5, the algorithm never find a k-monotone m-block function h with low error with respect to D, and the algorithm will reject.\nQuery complexity. The algorithm only makes queries in constructing D; the number of queries required is md \u00b7 t = O (\nd \u03b12 ( 5kd \u03b1 + 1 )d log kd\u03b1 ) .\n6.2 Tolerant testing via agnostic learning\nWe now present our second algorithm, Algorithm 2, proving the second item of Theorem 1.8. At its core is the use of an agnostic learning algorithm for k-monotone functions, which we first describe.9\nProposition 6.3. There exists an agnostic learning algorithm for k-monotone functions over [r]d \u2192 {0, 1} with excess error \u03c4 with sample complexity exp(O\u0303(k \u221a d/\u03c42).\nAlgorithm 2 Multiplicative approximation with exp(O\u0303(k \u221a d/((\u03b52 \u2212 3\u03b51)2)) queries Require: Query access to f : [n]d \u2192 {0, 1}, \u03b52 > 3\u03b51 \u2265 0, a positive integer k 1: \u03b1 \u2190 (\u03b52 \u2212 3\u03b51), m \u2190 \u23086kd/\u03b5\u2309 , t \u2190 \u23083d(k + 1)/\u03b5 lnm+ ln 100\u2309 2: Define D to be the distribution over [m]d \u00d7 {0, 1} such that D(x, b) = Pry\u2208B\u22121(x) [ f(y) = b ]. 3: \u22b2 AD(\u03c4, f) denotes the output of an agnostic learner of k-monotone functions with respect to D,\nwith excess error \u03c4 and probability of failure 1/10 4: h : [m]d \u2192 R \u2190 AD(\u03b1/12, f). 5: Estimate Pr(x,b)\u223cD [ h(x) 6= b ] to within \u00b1\u03b1/7 with probability of failure 1/10, using O(1/\u03b12)\nqueries. 6: if the estimate is more than \u03b51 + 5\u03b1 12 then return REJECT 7: end if 8: if dist(h, \u2113) = Prx\u2208[m]d [ h(x) 6= \u2113(x) ] \u2264 2\u03b51+ 5\u03b112 for some k-monotone m-block function \u2113 then\nreturn ACCEPT 9: else return REJECT\n10: end if\nWe will rely on tools from Fourier analysis to prove Proposition 6.3. For this reason, it will be convenient in this section to view the range as {\u22121, 1} instead of {0, 1}.\nDefinition 6.4. For a Boolean function f : [r]d \u2192 {\u22121, 1}, we define\nInf i[f ] = 2Pr [ [f(x) 6= f(x(i)) ]\nwhere x = (x1, x2, . . . , xd) is a uniformly random string over [r] d, and x(i) = (x1, x2, . . . , xi\u22121, x\u2032i, xi+1, . . . , xd)\nfor x\u2032 drawn independently and uniformly from [r]. We also define Inf [f ] = \u2211d\ni=1 Inf i[f ].\nWe first generalize the following result, due to Blais et al., for more general domains:\nProposition 6.5 ([BCO+15]). Let f : {0, 1}d \u2192 {\u22121, 1} be a k-monotone function. Then Inf [f ] \u2264 k \u221a d.\nLemma 6.6 (Generalization). Let f : [r]d \u2192 {\u22121, 1} be a k-monotone function. Then Inf [f ] \u2264 k \u221a d.\n9Recall that an agnostic learner with excess error \u03c4 for some class of functions C is an algorithm that, given an unknown distribution D, an unknown arbitrary function f , and access to random labelled samples \u3008x, f(x)\u3009 where x \u223c D, satisfies the following. It outputs a hypothesis function h\u0302 such that Prx\u223cD [ f(x) 6= h\u0302(x) ] \u2264 optD + \u03c4 with probability at least 2/3, where optD = minh\u2208C Prx\u223cD [ f(x) 6= h(x) ] (i.e., it performs \u201calmost as well as the best function in C\u201d).\nProof. For any two strings y0, y1 \u2208 [r]d, let fy0,y1 : {0, 1}d \u2192 {\u22121, 1} be the function obtained by setting fy0,y1(x) = f(y x), where yx \u2208 [r]d is defined as\nyxi = { min{y0i , y1i } if xi = 0 max{y0i , y1i } if xi = 1\nSince f was a k-monotone function, so is fy0,y1. Thus Inf [fy0,y1 ] \u2264 k \u221a d for every choice of y0 and y1. It is not hard to see that for any fixed i \u2208 [d] the following two processes yield the same distribution over [r]d \u00d7 [r]d:\n\u2022 Draw z \u2208 [r]d, z\u2032i \u2208 [r] independently and uniformly at random, set z\u2032 def = (z1, . . . , zi\u22121, z\u2032i, zi+1, . . . , zd),\nand output (z, z\u2032);\n\u2022 Draw y0, y1 \u2208 [r]d, x \u2208 {0, 1}d independently and uniformly at random, and output (yx, yx(i)). This implies that\nInf [f ] = d\u2211\ni=1\nInf i[f ] = d\u2211\ni=1\n2 Pr z\u2208[r]d\n[f(z) 6= f(z(i))] = d\u2211\ni=1\n2Ey0,y1\u2208[r]d\n[ Pr\nx\u2208{0,1}d\n[ f(yx) 6= f(yx(i))\n]]\n= Ey0,y1\u2208[r]d\n[ d\u2211\ni=1\n2 Pr x\u2208{0,1}d\n[ f(yx) 6= f(yx(i)) ]] = Ey0,y1\u2208[r]d [ d\u2211\ni=1\n2 Pr x\u2208{0,1}d\n[ fy0,y1(x) 6= fy0,y1(x(i))\n]]\n= Ey0,y1 [Inf [fy0,y1 ]] \u2264 Ey0,y1 [k \u221a d] = k \u221a d.\nFor two functions f, g : [r]d \u2192 R, we define the inner product \u3008f, g\u3009 = Ex[f(x)g(x)], where the expectation is taken with respect to the uniform distribution. It is known that for functions f : [r]d \u2192 R, there is a \u201cFourier basis\u201d of orthonormal functions f . To construct such a basis, we can take any orthonormal basis {\u03c60 \u2261 1, \u03c61, . . . , \u03c6|r|\u22121} for functions f : [r] \u2192 R. Given such a basis, a Fourier basis is the collection of functions \u03c6\u03b1, where \u03b1 \u2208 [r]d, and \u03c6\u03b1(x) = \u220fd i=1 \u03c6\u03b1i(xi).\nThen every f : [r]d \u2192 R has a unique representation f = \u2211\u03b1\u2208[r]d f\u0302(\u03b1)\u03c6\u03b1, where f\u0302(\u03b1) = \u3008f, \u03c6\u03b1\u3009 \u2208 R. Many Fourier formul\u00e6 hold in arbitrary Fourier bases, an important example being Parseval\u2019s Identity: \u2211\n\u03b1\u2208[r]d f\u0302(\u03b1) 2 = 1. We will use the following property:\nLemma 6.7 ([O\u2019D14, Proposition 8.23]). For \u03b1 \u2208 [r]d, let |\u03b1| denote the number of nonzero coordinates in \u03b1. Then we have\nInf [f ] = \u2211\n\u03b1\u2208[r]d |\u03b1| f\u0302(\u03b1)2.\nLemma 6.8. If Inf [f ] \u2264 k, then \u2211\n\u03b1:|\u03b1|>k/\u03b5 f\u0302(\u03b1)2 \u2264 \u03b5.\nProof. If not, then Inf [f ] = \u2211 \u03b1 |\u03b1| f\u0302(\u03b1)2 \u2265 \u2211 \u03b1:|\u03b1|>k/\u03b5 |\u03b1| f\u0302(\u03b1)2 \u2265 k\u03b5 \u2211 \u03b1:|\u03b1|>k/\u03b5 f\u0302(\u03b1) 2 > k\u03b5 \u00b7 \u03b5 = k, a contradiction. Lemma 6.9. Let p be the function \u2211\n\u03b1:|\u03b1|\u2264t f\u0302(\u03b1)\u03c6\u03b1. Then\n(i) \u2016p \u2212 f\u201622 = Ex\u2208[r]d[(p(x) \u2212 f(x))2] = \u2211 \u03b1:|\u03b1|>t f\u0302(\u03b1) 2;\n(ii) p is expressible as a linear combination of real-valued functions over [r]d, each of which only depends on at most t coordinates; (iii) p is expressible as a degree-t polynomial over the rd indicator functions 1{xi=j} for 1 \u2264 i \u2264 d and j \u2208 [r].\nTheorem 6.10 ([KKMS08, Theorem 5]). Let C be a class of Boolean functions over X and S a collection of real-valued functions over X such that for every f : X \u2192 {\u22121, 1} in C, there exists a function p : X \u2192 R such that p is expressible as a linear combination of functions from S and \u2016p\u2212 f\u201622 \u2264 \u03c42. Then there is an agnostic learning algorithm for C achieving excess error \u03c4 which has sample complexity poly(|S| , 1/\u03c4).\nImportantly, this algorithm is still successful with inconsistent labelled samples (examples), as long as they come from a distribution on X \u00d7 {\u22121, 1}, where the marginal distribution on X is uniform.\nNow we put all the pieces together. To agnostically learn a k-monotone function, we simply perform the agnostic learning algorithm of [KKMS08] on the distribution D over [m]d \u00d7 {\u22121, 1} defined by\nD(x, b) = Pr y\u2208B\u22121(x) [ f(y) = b ] .\nTo generate a sample (x, b) from D, we draw a uniformly random string in x \u2208 [m]d, and b is the result of a query for the value of f(y) for a uniformly random y \u2208 B\u22121(x). From Lemma 6.9, we can take S to be the set of (k \u221a d/\u03c42)-way products of rd indicator functions. It follows that |S| = ( rd k \u221a d/\u03c42 ) = exp(O\u0303(k \u221a d/\u03c42)).\nProposition 6.11. Algorithm 2 accepts all functions \u03b51-close to k-monotone functions, and rejects all functions \u03b52-far from k-monotone, when \u03b52 > 3\u03b51 (with probability at least 2/3). Its query complexity is exp(O\u0303(k \u221a d/(\u03b52 \u2212 3\u03b51)2)).\nProof. By a union bound, we have that with probability at least 8/10 both Step 5 and Step 4 succeed. We hereafter condition on this.\nCompleteness. Suppose f is \u03b51-close to k-monotone. Lemma 6.1 and the triangle inequality imply that there is a k-monotone m-block function g\u2217 such that dist(f, g\u2217) \u2264 \u03b51 + \u03b1/6. The agnostic learning algorithm thus returns a hypothesis h such that dist(f, h) \u2264 \u03b51 + \u03b1/4. The algorithm estimates this closeness to within \u03b1/7, so the estimate obtained in Step 5 is at most \u03b51 + \u03b5/4 + \u03b5/7 < \u03b51 + 5\u03b1/12 and the algorithm does not reject in this step. By the triangle inequality, h is (2\u03b51 + 5\u03b1/12)-close to k-monotone, and the algorithm will accept. There is no estimation error here, since no queries to f are required.\nSoundness. Now suppose f is \u03b52-far from k-monotone, where \u03b52 = 3\u03b51 + \u03b1 for some \u03b1 > 0. Suppose the algorithm does not reject when estimating dist(f, h), where h is the hypothesis returned by the agnostic learning algorithm. Then dist(f, h) \u2264 \u03b51+5\u03b1/12+\u03b1/7 < \u03b51+7\u03b1/12. By the triangle inequality, if t is a k-monotone function, dist(h, t) \u2265 dist(f, t) \u2212 dist(f, h) > \u03b52 \u2212 (\u03b51 + 7\u03b1/12) = 2\u03b51 + 5\u03b1/12. The algorithm will thus reject in the final step.\nQuery complexity. The query complexity of the algorithm is dominated by the query complexity of the agnostic learning algorithm, which is exp(O\u0303(k \u221a d/\u03b12)) = exp(O\u0303 ( k \u221a d/(\u03b52 \u2212 3\u03b51)2 ) ).\n7 Tolerant testing and applications to L1-testing\nWe now show how our techniques can be applied to solve an open problem on L1 tolerant testing of monotonicity, asked at the Sublinear Algorithms Workshop 2016 [Sub16].\nWe start by describing a reduction lemma from L1 distance to monotonicity of functions in [0, 1]X to Hamming distance to monotonicity of functions in {0, 1}X\u00d7[0,1] (that is, \u201ctrading the range for a dimension\u201d). We note that this idea appears in Berman et al.[BRY14, Lemmata 2.1 and 2.3], although formulated in a slightly different way. For convenience and completeness, we state and prove here the version we shall use.\nIn what follows, we let X be a discrete partially ordered domain equipped with a measure \u00b5,10 that is a tuple (X , , \u00b5); and for a set Y \u2286 R we denote by M(X\u2192Y) \u2286 YX the set of monotone functions from X to Y.\nDefinition 7.1 (Analogue of [BRY14, Definition 2.1]). For a function f : X \u2192 [0, 1], the threshold function T \u25e6 f : X \u00d7 [0, 1] \u2192 {0, 1} is defined by\nT \u25e6 f(x, t) = 1{f(x)\u22651\u2212t} = { 1 if f(x) \u2265 1\u2212 t 0 otherwise.\nThe next fact is immediate from this definition:\nFact 7.2. For any f : X \u2192 [0, 1], it is the case that for every x \u2208 X\nf(x) =\n\u222b 1\n0 T \u25e6 f(x, t)dt.\nMoreover, f \u2208 M(X\u2192[0,1]) if, and only if, T \u25e6 f \u2208 M(X\u00d7[0,1]\u2192{0,1}).\nWe begin by the following characterization, which is immediately obtained from a corresponding theorem of Berman et al.; before stating a slightly modified version that we shall rely upon. For completeness, the proof of the former can be found in Appendix C.\nProposition 7.3 (Analogue of [BRY14, Lemma 2.1]). For any f : X \u2192 [0, 1],\nL1 ( f,M(X\u2192[0,1]) ) = L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) ) = dist ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) )\nProposition 7.4 (Rounding and Range-Dimension Tradeoff). For any f : X \u2192 [0, 1] and parameter m \u2265 1, let Rm def= { 1m , 2m , . . . , 1}. We define the m-rounding of f as \u03a6m \u25e6 f : X \u2192 Rm by\n\u03a6m \u25e6 f(x) = \u2308mf(x)\u2309\nm , x \u2208 X .\nThen we have\n(i) \u2223\u2223\u2223L1 ( f,M(X\u2192[0,1]) ) \u2212 L1 ( \u03a6m \u25e6 f,M(X\u2192Rm) )\u2223\u2223\u2223 \u2264 1m ;\n(ii) L1 ( \u03a6m \u25e6 f,M(X\u2192Rm) ) = dist ( T \u25e6\u03a6m \u25e6 f ,M(X\u00d7Rm\u2192{0,1}) ) .\n10We will only require that (X , \u00b5) be a measurable space with finite measure, that is \u00b5(X ) < \u221e, and shall only hereafter concern ourselves with measurable functions.\nProof of Proposition 7.4. Fix any m \u2265 1. We start the proof of item (i) by the simple observation that if f \u2208 M(X\u2192[0,1]), then \u03a6m \u25e6 f \u2208 M(X\u2192Rm) \u2286 M(X\u2192[0,1]), that is rounding preserves monotonicity; and that \u03a6m \u25e6 g = g for all g : X \u2192 Rm. This, along with the fact that for all f : X \u2192 [0, 1]\nL1(f,\u03a6m \u25e6 f) = 1\n\u00b5(X )\n\u222b\nX \u00b5(dx) |\u03a6m \u25e6 f(x)\u2212 f(x)|\ufe38 \ufe37\ufe37 \ufe38\n\u22641/m\n\u2264 1 m\nimplies by the triangle inequality, for any g \u2208 M(X\u2192Rm) \u2286 M(X\u2192[0,1]), that L1 ( f,M(X\u2192[0,1]) ) \u2264 L1(f, g) \u2264 1\nm +L1(g,\u03a6m \u25e6 g) + L1(\u03a6m \u25e6 f,\u03a6m \u25e6 g) =\n1\nm + 0+L1(\u03a6m \u25e6 f, g) .\nTaking g \u2208 M(X\u2192Rm) that achieves L1(\u03a6m \u25e6 f, g) = L1 ( \u03a6m \u25e6 f,M(X\u2192Rm) ) , we get\nL1 ( f,M(X\u2192[0,1]) ) \u2264 1\nm + L1\n( \u03a6m \u25e6 f,M(X\u2192Rm) ) .\nFor the other direction, we first note that for any two functions f, g : X \u2192 [0, 1], it is the case that L1(f, g) \u2265 L1(\u03a6m \u25e6 f,\u03a6m \u25e6 g)\u2212 1/m (which is immediate from the definition of the rounding operator), and taking g to be the closest monotone function to f this readily yields\nL1 ( f,M(X\u2192[0,1]) ) \u2265 L1(\u03a6m \u25e6 f,\u03a6m \u25e6 g)\u2212 1\nm \u2265 L1\n( \u03a6m \u25e6 f,M(X\u2192Rm) ) \u2212 1\nm .\nFinally, the proof of the second part, item (i), is identical to that of Proposition 7.3, replacing the Lebesgue measure on [0, 1] by the counting measure on Rm. (So that integrals over [0, 1] become sums over Rm, normalized by |Rm| = m.)\nGiven Proposition 7.4, it is now easy to apply the results of Section 6 to obtain a tolerant L1 tester for monotonicity of functions f : [n]d \u2192 [0, 1]. Indeed, given parameters 0 < \u03b51 < \u03b52, one can set the rounding parameter m to \u23084/(\u03b52 \u2212 \u03b51)\u2309; and from query access to f : [n]d \u2192 [0, 1], simulate query access to \u03a6m \u25e6 f and therefore to g def= T \u25e6 \u03a6m \u25e6 f : [n]d \u00d7 Rm \u2192 {0, 1}. By Proposition 7.4 and our choice of m, in order to distinguish\nL1 ( f,M(X\u2192[0,1]) ) \u2264 \u03b51 vs. L1 ( f,M(X\u2192[0,1]) ) \u2265 \u03b52\nit is enough to distinguish\ndist ( g,M(X\u00d7Rm\u2192{0,1}) ) \u2264 \u03b51 + 1\nm vs. dist\n( g,M(X\u00d7Rm\u2192{0,1}) ) \u2265 \u03b52 \u2212 1\nm .\nBy our choice of m, we also have ( \u03b52 \u2212 1m ) \u2212 ( \u03b51 + 1 m ) \u2265 \u03b52\u2212\u03b512 .\nThe last step is to observe that one can view equivalently g as a function g : [n]d\u00d7 [m] \u2192 {0, 1}; by Proposition 7.4 and our choice of m, so that the algorithms of Theorem 1.7 apply.\nTheorem 1.9. There exists a non-adaptive tolerant L1-tester for monotonicity of functions f : [n] d \u2192 {0, 1} with query complexity\n\u2022 O\u0303 (\n1 (\u03b52\u2212\u03b51)2\n( 5d\n\u03b52\u2212\u03b51\n)d) , for any 0 \u2264 \u03b51 < \u03b52 \u2264 1;\n\u2022 2O\u0303( \u221a d/(\u03b52\u22123\u03b51)2), for any 0 \u2264 3\u03b51 < \u03b52 \u2264 1.\nAcknowledgments. We would like to thank Eric Blais for helpful remarks on an earlier version of this paper, and an anonymous reviewer for very detailed and insightful comments."}, {"heading": "A Previous work on monotonicity testing", "text": "In this appendix, we summarize the state-of-the-art on monotonicity testing. We observe that this question has been considered for functions over various domains (e.g. hypergrids, hypercubes and general posets) and ranges (notably Boolean range {0, 1} and unbounded range N); as hypergrids and hypercubes are arguably the domains that have received the most attention in the literature, we will in this overview restrict ourselves on work on these, and refer readers to [FLN+02, BGJ+09] for other various posets. We will also focus on the Boolean range {0, 1}, which is most relevant to our work, and briefly mention the best known results (which are also tight) for unbounded range N. In the end of this section, we include known results for tolerant monotonicity testing.\nBefore we go over those results, we recall some notation: namely, testers can make adaptive (a.) or non-adaptive (n.a.) queries and have 1-sided (1.s.) or 2-sided (2.s.) error. The best one could hope for would then be to obtain 1-sided non-adaptive upper bound, complemented with 2-sided adaptive lower bounds. We note all testers included in below except tolerant testers are 1-sided (almost all of them are non-adaptive) algorithms.\nHypercubes with Boolean Range. The problem of monotonicity testing is introduced by Goldreich et al. [GGL+00] for functions f : {0, 1}d \u2192 {0, 1}. [GGL+00] present a simple \u201cedge tester\u201d with query complexity O(d/\u03b5). A tester with O(d7/8/\u03b53/2) queries, the first improvement in terms of the dependence on d and the first to \u201cbreak\u201d the linear barrier, was presented by Chakrabarty and Seshadhri [CS13a], further improved to O\u0303(d5/6/\u03b54) by Chen et al. [CST14]. Recently, a O\u0303( \u221a d/\u03b52) upper bound was established by Khot et al. [KMS15]. All these upper bounds are obtained for 1-sided, non-adaptive testers.\nFor 1-sided non-adaptive testers, Fischer et al. [FLN+02] showed an \u2126( \u221a d) lower bound. For 2- sided non-adaptive testers, Chen et al. [CST14] obtained an \u2126\u0303(d1/5) lower bound, further improved by Chen et al. [CDST15]) to \u2126(d1/2\u2212c) (for any constant c > 0). All these lower bounds applying to non-adaptive testers, they only imply an \u2126(log d) lower bound for adaptive ones. Recently, Belovs and Blais [BB16] showed an \u2126(d1/4) lower bound for 2-sided adaptive testers, i.e. an exponential improvement over the previous bounds. All mentioned lower bounds hold for constant \u03b5 > 0, and are summarized in Table 3.\nHypergrids with Boolean Range. We remark that most known previous upper bounds for testing monotonicity over hypergrids are for unbounded range, which we will be the focus of the next section. Instead, we only mention here the case of Boolean range, giving in each setting the current best known results. For testing monotonicity over the line with Boolean range (i.e. d = 1 case), both a 1-sided non-adaptive O(1/\u03b5) upper bound and a 2-sided adaptive \u2126(1/\u03b5) lower bound are known (both of them being folklore). For d = 2, Berman et al. [BRY14] showed a tight bound of \u0398((log 1/\u03b5)/\u03b5) for 1-sided non-adaptive testers. Interestingly, they also prove that \u201cadaptivity\u201d\nhelps in the d = 2 case: that is, they establish a 1-sided tight adaptive O(1/\u03b5) upper bound which beats \u2126(log 1/\u03b5)/\u03b5) lower bound for 1-sided non-adaptive testers. For general d, Berman et al. [BRY14] give both a 1-sided non-adaptive tester with query complexity O(d\u03b5 log d \u03b5 ), and a 1-sided\nadaptive tester with query complexity O ( d2d logd\u22121 1\u03b5 + d2 log d \u03b5 ) . The best known results can be found in Table 4.\nUnbounded Range. For unbounded range, tight upper and lower bounds are known for both hypergrid and hypercube domains. Chakrabarty and Seshadhri [CS14] describe a 1-sided nonadaptive tester with O(d log n/\u03b5) queries for the hypergrid [n]d. Later, they show that O(d log n/\u03b5) is essentially optimal even for 2-sided adaptive tester [CS13b]. For the hypercube, [CS14] give a 1-sided non-adaptive tester making O(n/\u03b5) queries, and a matching 2-sided adaptive lower bound is proved by Joshua Brody (mentioned as private communication in [CS13b]). We refer readers to [CS14, CS13b] for overviews on previous results for testing monotonicity over the hypercube and hypergrid with unbounded range. The best known results are summarized in Table 5.\nTolerant Testing. To the best of our knowledge, prior to our work tolerant testers for monotonicity for Boolean functions over the hypergrid were only known for dimension d \u2208 {1, 2}. Specifically, an O( \u03b52\n(\u03b52\u2212\u03b51)2 )-query upper bound is known for d = 1, while an O\u0303( 1 (\u03b52\u2212\u03b51)4 )-query one is known for\nd = 2 [BRY14, FR10]."}, {"heading": "B Structural results", "text": "In this section, we will prove that the distance to k-monotonicity of a Boolean function f can be expressed in a combinatorial way \u2013 which does not require measuring the distance between f and the closest k-monotone function to f . We will prove this for a general finite poset domain buiding up on the ideas of [FLN+02]. In the rest of this section, we denote by P = (V, ) an arbitrary poset, the underlying domain of the function.\nDefinition B.1. We define the forbidden pattern K10 as the sequence of alternating bits K10 = (b1, b2, \u00b7 \u00b7 \u00b7 , bk, bk+1) of length (k+ 1) , where b1 = 1 and all the bits in the sequence alternate, i.e., bi 6= bi+1 \u2200i \u2208 [k].\nA function f : P \u2192 {0, 1} is k-monotone only if it avoids K10. That is, for any x1 \u227a x2 \u227a . . . \u227a xk+1 \u2208 P we have f(xi) 6= K10(i) for some i \u2208 [k + 1].\nUsing insights from the literature on monotonicity testing, we show that functions far from kmonotonicity have a large matching of \u201cviolated hyperedges\u201d in the \u201cviolation hypergraph\u201d which we define shortly. Let us recall the definition of \u201cviolation graph\u201dwhich has been extremely useful with monotonicity testing as seen in [EKK+00, PRR06, HK08, ACCL07, FLN+02].\nDefinition B.2 (Violation graph). Given a function f : P \u2192 {0, 1}, the violation graph of f is defined as Gviol(f) = (P, E(Gviol)) where (x, y) \u2208 E(Gviol) if x, y \u2208 P form a monotonicity violating pair in f \u2013 that is x y but f(x) > f(y).\nThe following theorem about violation graphs has been extremely useful in monotonicity testing literature.\nTheorem B.3. Let f : P \u2192 {0, 1} be a function that is \u03b5-far from monotone. Then, there exists a matching of edges in the violation graph for f of size at least \u03b5 |P| /2.\nNow let us define a generalization of this concept, the violation hypergraph.\nDefinition B.4 (Violation hypergraph). Given a function f : P \u2192 {0, 1}, the violation hypergraph of f is Hviol(f) = (P, E(Hviol)) where (x1, x2, \u00b7 \u00b7 \u00b7 , xk) \u2208 E(Hviol) if the ordered (k + 1)-tuple x1 < x2 < . . . < xk+1 (which is a (k + 1)-uniform hyperedge) forms a violation to k-monotonicity in f .\nNow, we state the main theorem that we intend to prove in this section. This theorem offers an alternate characterization of distance to k-monotonicity that we seek. We recall that a set of edges forms a matching in a hypergraph if any pair of hyperedges is pairwise disjoint.\nTheorem B.5. Let f : P \u2192 {0, 1} be function that is \u03b5-far from k-monotone. Then, there exists a matching of (k + 1)-uniform hyperedges of size at least \u03b5|P|k+1 in the violation hypergraph.\nTo prove this theorem we first exploit the key notion of extendability which we define below. Later we will show that k-monotone functions are extendable.\nDefinition B.6 (Extendability). A property of Boolean functions is said to be extendable over a poset domain if the following holds for any set X \u2286 P: given a function f : X \u2192 {0, 1} which has the property (on X), it is possible to define a function g : P \u2192 {0, 1} such that g(x) = f(x),\u2200x \u2208 X and g has the property.\nIn other words, a property is extendable if for any subset X \u2286 P, given a function defined over the set X which respects the property, it is possible to fill in values outside X such that the new function obtained continues to respect the property. Next, we show that k-monotonicity is an extendable property:\nLemma B.7. k-monotonicity is an extendable property.\nProof of Lemma B.7. Consider X \u2286 P and some function f : X \u2192 {0, 1} which is k-monotone over X. That is, for any x1 < x2 < . . . < xk+1 \u2208 X there exists i \u2208 [k + 1] such that f(xi) 6= K10[i]. Take a minimal point v \u2208 P \\X. That is, for any other point v\u2032 \u2208 P \\X either v \u2264 v\u2032 or v and v\u2032 are not comparable. We will use the following result:\nClaim B.8. There exists a function g : X \u222a {v} \u2192 {0, 1} such that g(x) = f(x) for all x \u2208 X, and g respects k-monotonicity over its domain.\nBefore proving this claim, we show how it implies Lemma B.7. Namely, starting with any function f : X \u2192 {0, 1} which is k-monotone on its domain X, we just keep applying the Claim B.8 inductively until we get a function defined over the entire poset which respects k-monotonicity.\nProof of Claim B.8. We will show this by contradiction. Suppose there is no good assignment available for g(v), that is that both the choices g(v) = 0 and g(v) = 1 lead to a violation to kmonotonicity in g. Consider the choice g(v) = 0. Since this results in a violation to k-monotonicity, we know that there is a path P0 = (x1 \u227a x2 \u227a . . . \u227a xk+1) which is a violation to k-monotonicity. It is clear that v \u2208 P0; let i be such that xi = v. Similarly, there is path P1 = (y1 \u227a y2 \u227a . . . \u227a yk+1) corresponding to g(v) = 1 which also contains the forbidden pattern, and some j such that yj = v. And thus, g(xt) = g(yt), for all t \u2208 [k+1] (as both of the paths indexed by x and y form a violation to k-monotonicity). By the above discussion 2 paths, P0 and P1, meet at v. We will see that one of the two paths P \u20320 = (x1 \u227a x2 \u227a . . . < xi\u22121 \u227a yi \u227a yi+1 \u227a . . . \u227a yk+1) or P \u20321 = (y1 \u227a y2 \u227a . . . < yj\u22121 \u227a xj \u227a xj+1 \u227a . . . \u227a xk+1) is already a violation to k-monotonicity in f . To see this, let us begin by recalling that we let v be the ith vertex on P0 and the j\nth vertex on P1. Now it is clear that i 6= j. Without loss of generality, suppose i < j. In this case, the evaluations of f along path P \u20321 form the forbidden pattern. This is because the function values alternate along the segment (y1 \u227a y2 \u227a . . . \u227a yj\u22121). Also, the function values alternate along the segment (xi \u227a xi+1 \u227a xi+2 \u227a . . . \u227a xk+1). And finally note that since f(yj\u22121) 6= f(yj) and f(yj) = f(xj) we get that f(yj\u22121) 6= f(xj) as well. So, the path P \u20321 indeed contains a violation to k-monotonicity as claimed. The other case, i > j, is analogous. Hence the claim follows.\nIn the next lemma, we show that there is a nice characterization of distance to k-monotonicity in terms of the size of the minimum vertex cover of the violation hypergraph.11\n11Recall that a vertex cover in a hypergraph is just a set of vertices such that every hyperedge contains at least one of the vertices from this set.\nLemma B.9. Let Mk denote the set of k-monotone functions over the poset P, and f : P \u2192 {0, 1}. Then dist(f,Mk) = \u03b5f if, and only if, the size of the minimum vertex cover in Hviol(f) is \u03b5f |P|.\nProof of Lemma B.9. We establish separately the two inequalities.\nClaim B.10. dist(f,Mk) \u2265 |V Cmin(Hviol)|\nProof. Suppose the distance to k-monotonicity is \u03b5f , and let g be a k-monotone achieving it, so that dist(f, g) = \u03b5f . Define X = { x \u2208 P : f(x) 6= g(x) } (thus, |X| = \u03b5f |P|). Let us consider the violation hypergraph for f given as Hviol(f) = (P, E(Hviol)). Now, delete vertices in X and the hyperedges containing any vertex v \u2208 X from this hypergraph. Because X is the smallest set of vertices changing values at which gives a k-monotone function, it follows that every hyperedge in E(Hviol) must contain a vertex in X. Thus, X indeed forms a vertex cover in Hviol(f).\nClaim B.11. dist(f,Mk) \u2264 |V Cmin(Hviol)|\nProof. Suppose the minimum vertex cover in the violation hypergraph has size \u03b5f |P|. We will show that the distance of the function to k-monotonicity is \u03b5f . To see this, let C \u2286 P be the smallest vertex cover of the violation hypergraph of the said size. Observe that deleting C from Hviol(f) removes all the hyperedges, and therefore that the function f restricted to X = P \\ C is k-monotone. And by the extendability of k-monotone functions established in Lemma B.7, it follows that the function can be extended to the rest of the domain (by providing values in the cover C) such that it keeps respecting k-monotonicity. Thus, the distance to k-monotonicity is at most |C| / |P|.\nHaving characterized distance to k-monotonicity as the size of the smallest vertex cover in the violation graph, we are ready to establish Theorem B.5. To do so, we will require the following standard fact:\nFact B.12. Let G = (V,E) be a t-uniform hypergraph. Let M be the maximum matching in G. Then, |M | \u2264 V Cmin(G) \u2264 t |M |\nProof of Theorem B.5. By Lemma B.9, we know that the violation hypergraph, Hviol(f) has a minimum vertex cover of size at least \u03b5f |P|. And by Fact B.12, it is seen that it contains a matching of t-uniform hyperedges of size at least\n\u03b5f t |P|."}, {"heading": "C Omitted proofs", "text": "Proof of Lemma 5.2. The first part of the theorem is straightforward (by contrapositive, if at least one of the two sequences is not non-increasing then we can find a violation of 2-monotonicity). We thus turn to the second part, and show the contrapositive; for this purpose, we require the following result:\nClaim C.1. If f : [n]2 \u2192 {0, 1} is a 2-column-wise monotone function such that (i) f(1, j) = f(n, j) = 0 for all j \u2208 [n] and (ii) both (\n\u00af \u2202fj)j\u2208[n], ( \u00af \u2202hj)j\u2208[n] \u2286 [n] are non-increasing, then f is\n2-monotone.\nProof. By contradiction, suppose there exists a 2-column-wise monotone function f satisfying (i) and (ii), which is not 2-monotone. This last point implies there exists a triple of comparable elements x = (ix, jx) \u227a y = (iy, jy) \u227a z = (iz , jz) constituting a violation, i.e. such that (f(x), f(y), f(z)) = (1, 0, 1). Moreover, since (i) holds we must have 1 < ix \u2264 iy \u2264 iz < n; more precisely, 1 \u2264\n\u00af \u2202fjx < ix \u2264 iy \u2264 iz < \u2202\u0304fjz \u2264 n. As x \u227a y \u227a z, we have jx \u2264 jy \u2264 jz, which\nby the non-increasing assumption (ii) implies that \u00af \u2202fjx \u2265 \u00af\u2202fjy and \u2202\u0304fjy \u2265 \u2202\u0304fjz . But this is not possible, as altogether this leads to \u00af \u2202fjy < iy < \u2202\u0304fjy , i.e. f(y) = 1.\nAssume both sequences ( \u00af \u2202fj)j\u2208[n], ( \u00af \u2202hj)j\u2208[n] \u2286 [n] are \u03b52 -close to non-increasing, and let L,H \u2282 [n] (respectively) be the set of indices where the two sequences need to be changed in order to become non-increasing. By assumption, |L| , |H| \u2264 \u03b5n2 , so |L \u222aH| \u2264 \u03b5n. But to \u201cfix\u201d a value of ( \u00af \u2202fj)j\u2208[n] or (\u2202\u0304fj)j\u2208[n] requires to change the values of the function f inside a single column \u2013 and this can be done preserving its 2-column-wise-monotonicity, so that changing the value of f on at most n points is enough. It follows that making both (\n\u00af \u2202fj)j\u2208[n] and (\u2202\u0304fj)j\u2208[n] non-increasing\nrequires to change f on at most \u03b5n2 points, and with Claim C.1 this results in a function which is 2-monotone. Thus, f is \u03b5-close to 2-monotone.\nProof of Lemma 5.3. Recall that we aim at establishing the following:\ndist ( f,M(2)2 ) \u2264 L1(\u2202\u0304f,M(1)) + L1(\n\u00af \u2202f,M(1)) (6)\nFor notational convenience, we will view in this proof the sequences ( \u00af \u2202f)j , (\u2202\u0304f)j) as functions \u00af \u2202f, \u2202\u0304f : [n] \u2192 [n]. Let \u2113, h : [n] \u2192 [n] (for \u201clow\u201d and \u201dhigh,\u201d respectively) be monotone functions achieving L1(\n\u00af \u2202f,M(1)) and L1(\u2202\u0304f,M(1)), respectively.\n\u2022 As \u00af \u2202f(j) \u2264 \u2202\u0304f(j) for all j \u2208 [n], we will assume \u2113(j) \u2264 h(j) for all j. Otherwise, one can\nconsider instead the functions \u2113\u2032 = min(\u2113, h) and h\u2032 = max(\u2113, h): both will still be monotone (non-increasing), and by construction\n\u2223\u2223\u2113\u2032(j) \u2212 \u00af \u2202f(j) \u2223\u2223+ \u2223\u2223\u2223h\u2032(j)\u2212 \u2202\u0304f(j) \u2223\u2223\u2223 \u2264 |\u2113(j) \u2212 \u00af \u2202f(j)|+ \u2223\u2223\u2223h(j)\u2212 \u2202\u0304f(j) \u2223\u2223\u2223\nfor all j \u2208 [n], so that L1(\u2202\u0304f, \u2113\u2032) + L1( \u00af \u2202f, h\u2032) \u2264 L1(\u2202\u0304f, \u2113) + L1( \u00af \u2202f, h).\n\u2022 From \u2113 and h, we can define a 2-column-wise monotone function g : [n]2 \u2192 [n] such that\n\u00af \u2202g = \u2113 and \u2202\u0304g = h: that is,\ng(i, j) =    0 if i \u2265 h(j) 1 if \u2113(j) < i < h(j)\n0 if i \u2264 \u2113(j)\nfor (i, j) \u2208 [n]2. It is clear that g is 2-column-wise monotone with g(1, j) = g(n, j) = 0 for all j \u2208 [n]; since by construction\n\u00af \u2202g, \u2202\u0304g are non-decreasing, we can invoke Claim C.1 to conclude g is 2-monotone. It\nremains to bound the distance between f and g: writing \u2206j \u2208 {0, . . . , n} for the number of points\non which f and g differ in the j-th column, we have\ndist ( f,M(2)2 ) \u2264 dist(f, g) = 1\nn2\nn\u2211\nj=1\n\u2206j \u2264 1\nn2\nn\u2211\nj=1\n( |\u2113(j) \u2212\n\u00af \u2202f(j)|+\n\u2223\u2223\u2223h(j) \u2212 \u2202\u0304f(j) \u2223\u2223\u2223 )\n= 1\nn2\nn\u2211\nj=1\n|\u2113(j)\u2212 \u00af \u2202f(j)|+ 1 n2\nn\u2211\nj=1\n\u2223\u2223\u2223h(j) \u2212 \u2202\u0304f(j) \u2223\u2223\u2223 = L1(\n\u00af \u2202f, \u2113) + L1\n( \u2202\u0304f, h )\n\u2264 L1( \u00af \u2202f,M(1)) + L1(\u2202\u0304f,M(1))\nwhich concludes the proof.\nProof of Proposition 7.3. We write \u03bd def = \u00b5\u00d7 Leb[0,1] for the product measure on X \u00d7 [0, 1] induced by \u00b5 and the Lebesgue measure on [0, 1]; so that \u03bd(X \u00d7 [0, 1]) = \u00b5(X ) \u00b7 1 = \u00b5(X ). For any fixed t \u2208 [0, 1], let gt \u2208 M(X\u2192{0,1}) be any function achieving L1(T \u25e6 f(\u00b7, t), gt) =\nL1 ( T \u25e6 f(\u00b7, t),M(X\u2192{0,1}) ) , and define g \u2208 [0, 1]X by g\u2032(x) = \u222b 1 0 dtgt(x) for all x \u2208 X : note that g is then monotone by construction.12 Moreover, choose h \u2208 M(X\u00d7[0,1]\u2192{0,1}) as a function achieving L1(T \u25e6 f, h) = L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) ) . Then we have\nL1 ( f,M(X\u2192[0,1]) ) \u2264 L1 ( f, g\u2032 ) = 1\n\u00b5(X )\n\u222b\nX \u00b5(dx)\n\u2223\u2223\u2223\u2223 \u222b 1\n0 dt(T \u25e6 f(x, t)\u2212 gt(x))\n\u2223\u2223\u2223\u2223\n\u2264 1 \u00b5(X )\n\u222b\nX \u00b5(dx)\n\u222b 1\n0 dt |T \u25e6 f(x, t)\u2212 gt(x)|\n=\n\u222b 1\n0 dt\n( 1\n\u00b5(X )\n\u222b\nX \u00b5(dx) |T \u25e6 f(x, t)\u2212 gt(x)|\n) = \u222b 1\n0 dtL1(T \u25e6 f(\u00b7, t), gt)\n\u2264 \u222b 1\n0 dtL1(T \u25e6 f(\u00b7, t), h(\u00b7, t)) =\n\u222b 1\n0 dt\n( 1\n\u00b5(X )\n\u222b\nX \u00b5(dx) |T \u25e6 f(x, t)\u2212 h(x, t)|\n)\n= 1\n\u03bd(X \u00d7 [0, 1])\n\u222b\nX\u00d7[0,1] \u03bd(dx, dt) |T \u25e6 f(x, t)\u2212 h(x, t)|\n= L1(T \u25e6 f, h) = L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) )\nwhere we applied Fact 7.2 (and the definition of g\u2032 = \u222b 1 0 gt) for the first equality, and for the third inequality the fact that h induces (for every fixed t \u2208 [0, 1]) a monotone function h(\u00b7, t) \u2208 M(X\u2192{0,1}): so that L1(T \u25e6 f(\u00b7, t), gt) \u2264 L1(T \u25e6 f(\u00b7, t), h(\u00b7, t)) for all t.\nFor the other direction of the inequality, fix any f : X \u2192 [0, 1], and let g \u2208 M(X\u2192[0,1]) be (any) 12Additionally, since we restrict ourselves to finite X , there are only finitely many distinct functions T \u25e6 f(\u00b7, t) (for\nt \u2208 [0, 1], and therefore only finitely many distinct functions gt.\nfunction achieving L1(f, g) = L1 ( f,M(X\u2192[0,1]) ) . We can write, unrolling the definitions,\nL1 ( f,M(X\u2192[0,1]) ) = 1\n\u00b5(X )\n\u222b\nX \u00b5(dx)|f(x)\u2212 g(x)|\n= 1\n\u00b5(X )\n\u222b\nX \u00b5(dx)\n\u2223\u2223\u2223\u2223 \u222b 1\n0 dt(T \u25e6 f(x, t)\u2212 T \u25e6 g(x, t))\n\u2223\u2223\u2223\u2223\n= 1\n\u00b5(X )\n\u222b\nX \u00b5(dx)\n\u2223\u2223\u2223\u2223 \u222b 1\n0 dt(T \u25e6 f(x, t)\u2212 T \u25e6 g(x, t))\n\u2223\u2223\u2223\u2223\n= 1\n\u00b5(X )\n\u222b\nX \u00b5(dx)\n( \u222b 1\n0 dt(T \u25e6 f(x, t)\u2212 T \u25e6 g(x, t))1{f(x)>g(x)}\n+ (T \u25e6 g(x, t) \u2212 T \u25e6 f(x, t))1{g(x)>f(x)} )\n= 1\n\u00b5(X )\n\u222b\nX\n\u222b 1\n0 dt\u00b5(dx)\n( (T \u25e6 f(x, t)\u2212 T \u25e6 g(x, t))1{f(x)>g(x)}\n+ (T \u25e6 g(x, t) \u2212 T \u25e6 f(x, t))1{g(x)>f(x)} )\n= 1\n\u03bd(X \u00d7 [0, 1])\n\u222b\nX\u00d7[0,1] \u03bd(dx, dt) |T \u25e6 f(x, t)\u2212 T \u25e6 g(x, t)| = L1(T \u25e6 f, T \u25e6 g)\n\u2265 L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) )\nwhere we applied Fact 7.2 for the second equality, the definition of L1 distance for the second-tolast; and to handle the absolute values we used the fact that |a\u2212 b| = (a\u2212 b)1{a>b}+(b\u2212a)1{a>b}, along with the observation that T \u25e6 f(x, t) > T \u25e6 g(x, t) can only hold if f(x) > g(x). Finally, we have L1(T \u25e6 f, T \u25e6 g) \u2265 L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) ) since T \u25e6 g \u2208 M(X\u00d7[0,1]\u2192{0,1}), yielding the desired claim. Finally, the fact that L1 ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) ) = dist ( T \u25e6 f,M(X\u00d7[0,1]\u2192{0,1}) ) is immediate from the Boolean range, as |a\u2212 b| = 1{a6=b} for any a.b \u2208 {0, 1}."}], "references": [{"title": "Information theory in property testing and monotonicity testing in higher dimension", "author": ["Nir Ailon", "Bernard Chazelle"], "venue": "Inf. Comput.,", "citeRegEx": "Ailon and Chazelle.,? \\Q2006\\E", "shortCiteRegEx": "Ailon and Chazelle.", "year": 2006}, {"title": "Estimating the distance to a monotone function", "author": ["Nir Ailon", "Bernard Chazelle", "Seshadhri Comandur", "Ding Liu"], "venue": "Random Struct. Algorithms,", "citeRegEx": "Ailon et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ailon et al\\.", "year": 2007}, {"title": "A superpolynomial lower bound for a circuit computing the Clique function with at most (1/6) log log n negation gates", "author": ["Kazuyuki Amano", "Akira Maruoka"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Amano and Maruoka.,? \\Q2005\\E", "shortCiteRegEx": "Amano and Maruoka.", "year": 2005}, {"title": "Queries and concept learning", "author": ["Dana Angluin"], "venue": "Machine Learning,", "citeRegEx": "Angluin.,? \\Q1987\\E", "shortCiteRegEx": "Angluin.", "year": 1987}, {"title": "A polynomial lower bound for testing monotonicity", "author": ["Aleksandrs Belovs", "Eric Blais"], "venue": "In STOC,", "citeRegEx": "Belovs and Blais.,? \\Q2016\\E", "shortCiteRegEx": "Belovs and Blais.", "year": 2016}, {"title": "Active property testing", "author": ["Maria-Florina Balcan", "Eric Blais", "Avrim Blum", "Liu Yang"], "venue": "In FOCS,", "citeRegEx": "Balcan et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Balcan et al\\.", "year": 2012}, {"title": "Property testing lower bounds via communication complexity", "author": ["Eric Blais", "Joshua Brody", "Kevin Matulef"], "venue": "Computational Complexity,", "citeRegEx": "Blais et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Blais et al\\.", "year": 2012}, {"title": "Monotonicity testing and shortest-path routing on the cube", "author": ["Jop Bri\u00ebt", "Sourav Chakraborty", "David Garc\u00eda-Soriano", "Arie Matsliah"], "venue": "Combinatorica, 32(1):35\u201353,", "citeRegEx": "Bri\u00ebt et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bri\u00ebt et al\\.", "year": 2012}, {"title": "Learning circuits with few negations. In APPROX-RANDOM, volume 40 of LIPIcs, pages 512\u2013527", "author": ["Eric Blais", "Cl\u00e9ment L. Canonne", "Igor Carboni Oliveira", "Rocco A. Servedio", "LiYang Tan"], "venue": "Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,", "citeRegEx": "Blais et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Blais et al\\.", "year": 2015}, {"title": "Transitive-closure spanners", "author": ["Arnab Bhattacharyya", "Elena Grigorescu", "Kyomin Jung", "Sofya Raskhodnikova", "David P. Woodruff"], "venue": "In SODA,", "citeRegEx": "Bhattacharyya et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bhattacharyya et al\\.", "year": 2009}, {"title": "Fast approximate PCPs for multidimensional bin-packing problems", "author": ["T\u016dgkan Batu", "Ronitt Rubinfeld", "Patrick White"], "venue": "Inf. Comput.,", "citeRegEx": "Batu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Batu et al\\.", "year": 2005}, {"title": "Lp-testing. In STOC, pages 164\u2013173", "author": ["Piotr Berman", "Sofya Raskhodnikova", "Grigory Yaroslavtsev"], "venue": null, "citeRegEx": "Berman et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Berman et al\\.", "year": 2014}, {"title": "On the Fourier spectrum of monotone functions", "author": ["Nader H. Bshouty", "Christino Tamon"], "venue": "J. ACM,", "citeRegEx": "Bshouty and Tamon.,? \\Q1996\\E", "shortCiteRegEx": "Bshouty and Tamon.", "year": 1996}, {"title": "Boolean function monotonicity testing requires (almost) n1/2 non-adaptive queries", "author": ["Xi Chen", "Anindya De", "Rocco A. Servedio", "Li-Yang Tan"], "venue": "In STOC,", "citeRegEx": "Chen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2015}, {"title": "Testing probability distributions underlying aggregated data", "author": ["Cl\u00e9ment L. Canonne", "Ronitt Rubinfeld"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Canonne and Rubinfeld.,? \\Q2014\\E", "shortCiteRegEx": "Canonne and Rubinfeld.", "year": 2014}, {"title": "An o(n) monotonicity tester for boolean functions over the hypercube", "author": ["Deeparnab Chakrabarty", "C. Seshadhri"], "venue": "In STOC,", "citeRegEx": "Chakrabarty and Seshadhri.,? \\Q2013\\E", "shortCiteRegEx": "Chakrabarty and Seshadhri.", "year": 2013}, {"title": "Optimal bounds for monotonicity and Lipschitz testing over hypercubes and hypergrids", "author": ["Deeparnab Chakrabarty", "C. Seshadhri"], "venue": "In STOC,", "citeRegEx": "Chakrabarty and Seshadhri.,? \\Q2013\\E", "shortCiteRegEx": "Chakrabarty and Seshadhri.", "year": 2013}, {"title": "An optimal lower bound for monotonicity testing over hypergrids", "author": ["Deeparnab Chakrabarty", "C. Seshadhri"], "venue": "Theory of Computing,", "citeRegEx": "Chakrabarty and Seshadhri.,? \\Q2014\\E", "shortCiteRegEx": "Chakrabarty and Seshadhri.", "year": 2014}, {"title": "An o(n) Monotonicity Tester for Boolean Functions over the Hypercube", "author": ["Deeparnab Chakrabarty", "C. Seshadhri"], "venue": "SIAM J. Comput.,", "citeRegEx": "Chakrabarty and Seshadhri.,? \\Q2016\\E", "shortCiteRegEx": "Chakrabarty and Seshadhri.", "year": 2016}, {"title": "New algorithms and lower bounds for monotonicity testing", "author": ["Xi Chen", "Rocco A. Servedio", "Li-Yang Tan"], "venue": "In FOCS,", "citeRegEx": "Chen et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2014}, {"title": "Improved testing algorithms for monotonicity", "author": ["Yevgeniy Dodis", "Oded Goldreich", "Eric Lehman", "Sofya Raskhodnikova", "Dana Ron", "Alex Samorodnitsky"], "venue": "In RANDOMAPPROX,", "citeRegEx": "Dodis et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Dodis et al\\.", "year": 1999}, {"title": "On the strength of comparisons in property testing", "author": ["Eldar Fischer"], "venue": "Inf. Comput.,", "citeRegEx": "Fischer.,? \\Q2004\\E", "shortCiteRegEx": "Fischer.", "year": 2004}, {"title": "Monotonicity testing over general poset domains", "author": ["Eldar Fischer", "Eric Lehman", "Ilan Newman", "Sofya Raskhodnikova", "Ronitt Rubinfeld", "Alex Samorodnitsky"], "venue": "In Proceedings on 34th Annual ACM Symposium on Theory of Computing, May 19-21,", "citeRegEx": "Fischer et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Fischer et al\\.", "year": 2002}, {"title": "Approximating the distance to monotonicity in high dimensions", "author": ["Shahar Fattal", "Dana Ron"], "venue": "ACM Trans. Algorithms,", "citeRegEx": "Fattal and Ron.,? \\Q2010\\E", "shortCiteRegEx": "Fattal and Ron.", "year": 2010}, {"title": "Negation-limited formulas. In APPROX-RANDOM, volume 40 of LIPIcs, pages 850\u2013866", "author": ["Siyao Guo", "Ilan Komargodski"], "venue": "Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,", "citeRegEx": "Guo and Komargodski.,? \\Q2015\\E", "shortCiteRegEx": "Guo and Komargodski.", "year": 2015}, {"title": "The power of negations in cryptography", "author": ["Siyao Guo", "Tal Malkin", "Igor Carboni Oliveira", "Alon Rosen"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "Guo et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Guo et al\\.", "year": 2015}, {"title": "Testing monotonicity over graph products", "author": ["Shirley Halevy", "Eyal Kushilevitz"], "venue": "Random Struct. Algorithms,", "citeRegEx": "Halevy and Kushilevitz.,? \\Q2008\\E", "shortCiteRegEx": "Halevy and Kushilevitz.", "year": 2008}, {"title": "Agnostically learning halfspaces", "author": ["Adam Tauman Kalai", "Adam R. Klivans", "Yishay Mansour", "Rocco A. Servedio"], "venue": "SIAM J. Comput.,", "citeRegEx": "Kalai et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kalai et al\\.", "year": 2008}, {"title": "On monotonicity testing and Boolean isoperimetric type theorems. In FOCS, pages 52\u201358", "author": ["Subhash Khot", "Dor Minzer", "Muli Safra"], "venue": "IEEE Computer Society,", "citeRegEx": "Khot et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Khot et al\\.", "year": 2015}, {"title": "Testing surface area", "author": ["Pravesh Kothari", "Amir Nayyeri", "Ryan O\u2019Donnell", "Chenggang Wu"], "venue": "In SODA, pages 1204\u20131214", "citeRegEx": "Kothari et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kothari et al\\.", "year": 2014}, {"title": "Testing problems with sublearning sample complexity", "author": ["Michael J. Kearns", "Dana Ron"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "Kearns and Ron.,? \\Q2000\\E", "shortCiteRegEx": "Kearns and Ron.", "year": 2000}, {"title": "Cryptographic limitations on learning Boolean formulae and finite automata", "author": ["Michael J. Kearns", "Leslie G. Valiant"], "venue": "J. ACM,", "citeRegEx": "Kearns and Valiant.,? \\Q1994\\E", "shortCiteRegEx": "Kearns and Valiant.", "year": 1994}, {"title": "Sensitivity conjecture and log-rank conjecture for functions with small alternating numbers", "author": ["Chengyu Lin", "Shengyu Zhang"], "venue": "CoRR, abs/1602.06627,", "citeRegEx": "Lin and Zhang.,? \\Q2016\\E", "shortCiteRegEx": "Lin and Zhang.", "year": 2016}, {"title": "On the inversion complexity of systems of functions", "author": ["A.A. Markov"], "venue": "Doklady Akademii Nauk SSSR,", "citeRegEx": "Markov.,? \\Q1957\\E", "shortCiteRegEx": "Markov.", "year": 1957}, {"title": "On the inversion complexity of a system of functions", "author": ["A.A. Markov"], "venue": "Journal of the ACM,", "citeRegEx": "Markov.,? \\Q1958\\E", "shortCiteRegEx": "Markov.", "year": 1958}, {"title": "Testing surface area with arbitrary accuracy", "author": ["Joe Neeman"], "venue": "In STOC, pages 393\u2013397", "citeRegEx": "Neeman.,? \\Q2014\\E", "shortCiteRegEx": "Neeman.", "year": 2014}, {"title": "Analysis of Boolean Functions", "author": ["Ryan O\u2019Donnell"], "venue": null, "citeRegEx": "O.Donnell.,? \\Q2014\\E", "shortCiteRegEx": "O.Donnell.", "year": 2014}, {"title": "Learning monotone decision trees in polynomial time", "author": ["Ryan O\u2019Donnell", "Rocco A. Servedio"], "venue": "SIAM J. Comput.,", "citeRegEx": "O.Donnell and Servedio.,? \\Q2007\\E", "shortCiteRegEx": "O.Donnell and Servedio.", "year": 2007}, {"title": "KKL, Kruskal\u2013Katona, and monotone nets. In FOCS, pages 725\u2013734", "author": ["Ryan O\u2019Donnell", "Karl Wimmer"], "venue": "IEEE Computer Society,", "citeRegEx": "O.Donnell and Wimmer.,? \\Q2009\\E", "shortCiteRegEx": "O.Donnell and Wimmer.", "year": 2009}, {"title": "Tolerant property testing and distance approximation", "author": ["Michal Parnas", "Dana Ron", "Ronitt Rubinfeld"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Parnas et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Parnas et al\\.", "year": 2006}, {"title": "Lower bounds on the monotone complexity of some Boolean functions", "author": ["Alexander A Razborov"], "venue": "In Doklady Akademii Nauk SSSR,", "citeRegEx": "Razborov.,? \\Q1985\\E", "shortCiteRegEx": "Razborov.", "year": 1985}, {"title": "Correlation bounds against monotone NC", "author": ["Benjamin Rossman"], "venue": "In Conference on Computational Complexity (CCC),", "citeRegEx": "Rossman.,? \\Q2015\\E", "shortCiteRegEx": "Rossman.", "year": 2015}, {"title": "Monotone circuits for matching require linear depth", "author": ["Ran Raz", "Avi Wigderson"], "venue": "J. ACM,", "citeRegEx": "Raz and Wigderson.,? \\Q1992\\E", "shortCiteRegEx": "Raz and Wigderson.", "year": 1992}, {"title": "On learning monotone DNF under product distributions", "author": ["Rocco A. Servedio"], "venue": "Inf. Comput.,", "citeRegEx": "Servedio.,? \\Q2004\\E", "shortCiteRegEx": "Servedio.", "year": 2004}, {"title": "A theory of the learnable", "author": ["Leslie G. Valiant"], "venue": "Commun. ACM,", "citeRegEx": "Valiant.,? \\Q1984\\E", "shortCiteRegEx": "Valiant.", "year": 1984}], "referenceMentions": [], "year": 2016, "abstractText": "A Boolean k-monotone function defined over a finite poset domain D alternates between the values 0 and 1 at most k times on any ascending chain in D. Therefore, k-monotone functions are natural generalizations of the classical monotone functions, which are the 1-monotone functions. Motivated by the recent interest in k-monotone functions in the context of circuit complexity and learning theory, and by the central role that monotonicity testing plays in the context of property testing, we initiate a systematic study of k-monotone functions, in the property testing model. In this model, the goal is to distinguish functions that are k-monotone (or are close to being k-monotone) from functions that are far from being k-monotone. Our results include the following: 1. We demonstrate a separation between testing k-monotonicity and testing monotonicity, on the hypercube domain {0, 1}d, for k \u2265 3; 2. We demonstrate a separation between testing and learning on {0, 1}d, for k = \u03c9(log d): testing k-monotonicity can be performed with 2 \u221a d\u00b7log d\u00b7log 1/\u03b5) queries, while learning k-monotone functions requires 2 \u221a d\u00b71/\u03b5) queries (Blais et al. (RANDOM 2015)). 3. We present a tolerant test for functions f : [n] \u2192 {0, 1} with complexity independent of n, which makes progress on a problem left open by Berman et al. (STOC 2014). Our techniques exploit the testing-by-learning paradigm, use novel applications of Fourier analysis on the grid [n], and draw connections to distribution testing techniques. \u2217Columbia University. Email: ccanonne@cs.columbia.edu. Research supported by NSF CCF-1115703 and NSF CCF-1319788. \u2020Purdue University. Email: elena-g@purdue.edu. Research supported in part by NSF CCF-1649515. \u2021Courant Institute of Mathematical Sciences, New York University. Email: sg191@nyu.edu. \u00a7Purdue University. Email: akumar@purdue.edu. \u00b6Duquesne University. Email: wimmerk@duq.edu.", "creator": "LaTeX with hyperref package"}}}