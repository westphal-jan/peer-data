{"id": "1610.05016", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Oct-2016", "title": "Weekly maintenance scheduling using exact and genetic methods", "abstract": "The weekly maintenance schedule specifies when maintenance activities should be performed on the equipment, taking into account the availability of workers and maintenance bays, and other operational constraints. The current approach to generating this schedule is labour intensive and requires coordination between the maintenance schedulers and operations staff to minimise its impact on the operation of the mine. This paper presents methods for automatically generating this schedule from the list of maintenance tasks to be performed, the availability roster of the maintenance staff, and time windows in which each piece of equipment is available for maintenance work.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Mon, 17 Oct 2016 08:54:47 GMT  (350kb,D)", "http://arxiv.org/abs/1610.05016v1", null]], "reviews": [], "SUBJECTS": "cs.NE cs.AI", "authors": ["andrew w palmer", "robin vujanic", "rew j hill", "steven j scheding"], "accepted": false, "id": "1610.05016"}, "pdf": {"name": "1610.05016.pdf", "metadata": {"source": "CRF", "title": "Weekly maintenance scheduling using exact and genetic methods", "authors": ["Andrew W. Palmer", "Robin Vujanic", "Andrew J. Hill", "Steven J. Scheding"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Maintenance activities are a significant cost in the mining sector, making up between 30% and 60% of the total operating cost of a mine (Singleton & Krellis, 1998; Lewis & Steinberg, 2001; Dhillon, 2008). In addition to direct costs, poorly planned maintenance can have a large impact on mine productivity\u2014equipment spending longer in maintenance than needed effectively reduces the total tonnes of ore that a mine can produce. As a result, generating maintenance schedules that minimise the impact on the operation of the mine is of great importance to mine operators. Existing work on planning maintenance in the mining industry has looked at modelling the reliability of the equipment (Summit & Halomoan, 2015), or focused on long timescales, allocating equipment to tasks with the objective to minimise the expected maintenance costs over the lifetime of the mine (Topal & Ramazan, 2010). This paper examines the problem of generating the weekly maintenance schedule for the multitude of activities to be performed\nar X\niv :1\n61 0.\n05 01\n6v 1\n[ cs\n.N E\n] 1\n7 O\non each piece of equipment, with the objective of minimising the impact of the maintenance on the mine operations. The proposed approach is aware of constraints such as the number of maintenance bays and the availability roster of the maintainers, and is demonstrated on real and simulated datasets that reflect practical problem sizes.\nThe current approach to producing weekly maintenance schedules is largely manual, and requires the dedicated schedulers to coordinate with the operations planners to develop a schedule that satisfies operational constraints. While the intention is that the schedule should be generated once for the week, they are frequently revised to incorporate unexpected breakdown of equipment and delays (Tomlingson, 2007). The aim of this work is to automatically and quickly generate the schedule given the list of maintenance tasks that are to be performed, the availability roster of the maintenance staff, and time windows for each piece of equipment in which the equipment can be taken down for maintenance with minimal impact on the mine operations.\nTo the best of the authors\u2019 knowledge, the weekly maintenance scheduling problem has not been studied in the literature. Some related maintenance scheduling problems are examined by Gopalakrishnan et al. (2001); Deris et al. (1999); Ben Ali et al. (2011); Jiu et al. (2013); Jin et al. (2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al. (2009). Methods for jointly optimising maintenance and production were developed by Pandey et al. (2011); Najid et al. (2011). Najid et al. (2011) formulated this as a Mixed-Integer Linear Program (MILP) and solved it using commercial optimisation software. However, the authors pointed out that only small problem instances were solvable, and stated that they intend to investigate meta-heuristics for solving larger instances.\nThe major difference between the above problems and producing a weekly mine maintenance schedule is in the size of the problem. Typical weekly maintenance schedules can contain over 100 pieces of equipment, with up to 50 individual activities per piece of equipment. Durations for each activity can range from half an hour to several days, and approximately 25 different types of workers, such as fitters, electricians, and boilermakers, are required. The availability of these workers varies both day to day and between the day and night shifts. One of the characteristics of mining in general is that it is very dynamic, with unexpected events such as equipment failures occurring frequently. Thus, one of the requirements of the scheduling system is that it should be computationally fast to allow rapid replanning in response to these unexpected events.\nTwo approaches to this problem are proposed in this paper\u2014a MILP formulation that is solved using Gurobi (Gur, n.d.), and a GA. While the MILP approach generates optimal solutions, it will be shown to be computationally\ninfeasible for realistic problem sizes, motivating the use of the GA. The specific contributions of this paper are:\n\u2022 A MILP formulation of the problem\n\u2022 A GA approach that utilises a greedy heuristic to ensure that feasible schedules are generated from the chromosomes\n\u2022 A comprehensive evaluation of the MILP method and the GA using two different fitness functions\nThe remainder of this paper is structured as follows: Section 2 presents a MILP formulation of the problem, and Section 3 develops the GA. A comparison of the methods is presented in Section 4, and concluding remarks are provided in Section 5."}, {"heading": "2 MILP Formulation", "text": "The weekly maintenance problem is to schedule a given set of tasks (equipment) i \u2208 I with associated subtasks (work orders) j \u2208 Ji. Each task has a ready time that specifies the earliest a task can be started, and a deadline that specifies when it should be completed by. Some tasks require a maintenance bay, and subtasks have a specified duration and worker requirement. Subtasks can have a precedence requirement where they require other subtasks of the task to be performed before it can be performed. An example task with 7 subtasks is shown in Figure 1. The worker requirements of the subtasks in the example are denoted by the colours and specified numbers in the subtasks, and the subtasks have been scheduled to respect the precedence of the subtasks. The schedule is split into discrete, equally-sized time periods. The objective of the problem is to schedule the subtasks to minimise the sum of the makespan and lateness of the tasks. Makespan is simply the length of a task, and lateness is incurred if the task is completed after the deadline. The rest of this section formally presents the MILP model."}, {"heading": "2.1 Indices and Sets", "text": "t \u2208 T time periods, where T = {0, . . . , tmax} i \u2208 I tasks j \u2208 J subtasks p \u2208 P worker types\nThe set of tasks that require a maintenance bay is M \u2286 I, the set of subtasks that compose task i is Ji \u2286 J , and the set of subtasks that must be performed before j is Kj \u2286 J . Subtasks can only belong to one task, so Ji \u2229 Jk = \u2205 \u2200i \u2208 I, k \u2208 I\\{i}."}, {"heading": "2.2 Parameters", "text": "dj the duration of subtask j \u2208 J in time periods rj,p,s,t the number of workers of type p \u2208 P required for sub-\ntask j \u2208 J in timestep t \u2208 T if j started in timestep s \u2208 {max(0, t\u2212 dj , . . . , t)}\nap,t the number of workers of type p \u2208 P available in time period t \u2208 T m the number of maintenance bays bi ready time for task i \u2208 I ci deadline for task i \u2208 I fi the weighting of the makespan of task i \u2208 I gi the weighting of the lateness of task i \u2208 I"}, {"heading": "2.3 Optimisation Variables", "text": "xstartj,t \u2208 {0, 1} 1 iff subtask j \u2208 J starts in time period t \u2208 T xi,t \u2208 {0, 1} 1 iff task i \u2208 I is being performed in time period t \u2208 T xstarti,t \u2208 {0, 1} 1 iff task i \u2208 I starts in time period t \u2208 T xfinishi,t \u2208 {0, 1} 1 iff task i \u2208 I finishes in time period t \u2208 T ymakespani \u2208 R makespan of task i \u2208 I ylatenessi \u2208 R lateness of task i \u2208 I"}, {"heading": "2.4 Objective function", "text": "The objective function is the sum of the weighted makespan and lateness of each task:\nJ = \u2211 i\u2208I fiy makespan i + giy lateness i (1)"}, {"heading": "2.5 Constraints", "text": ""}, {"heading": "2.5.1 Subtasks", "text": "The first set of constraints specify when a subtask can start. Firstly, (2) enforces that each subtask has to start exactly once, and (3) specifies that it has to be completed before the end of the schedule. Constraint (4) encodes the precedence constraints as specified in Kj .\u2211\nt\nxstartj,t = 1 \u2200j \u2208 J (2)\n\u2211 t (txstartj,t ) + dj \u2264 tmax + 1 \u2200j \u2208 J (3)\n\u2211 t (txstartj,t ) \u2265 \u2211 t (txstartk,t ) + dk \u2200j \u2208 J, k \u2208 Kj (4)"}, {"heading": "2.5.2 Tasks", "text": "The next set of constraints deal with the tasks. Constraint (5), similar to (2), specifies that a task can only start once. The period that the task starts in is defined in (6) as the earliest starting period of its subtasks. The makespan of the task is calculated in (7) by specifying that the task must finish no earlier than any of its subtasks. Constraint (8) enforces that the task can only finish once, and (9) specifies that the period in which the task is finished in is no earlier than its start period plus its makespan. The lateness of the task is calculated in (10). Constraint (11) calculates whether a task is being performed in a time period or not based on whether it was being performed in the previous time period, and the time period in which the task starts and finishes. For (11) to work when t = 0, a dummy variable is added for each task in the time period t = \u22121 and assigned the value of 0 in (12).\u2211\nt\nxstarti,t = 1 \u2200i \u2208 I (5)\n\u2211 t (txstarti,t ) \u2264 \u2211 t (txstartj,t ) \u2200i \u2208 I, j \u2208 Ji (6)\n\u2211 t (txstarti,t ) + y makespan i \u2265 \u2211 t (txstartj,t ) + dj \u2200i \u2208 I, j \u2208 Ji (7)\n\u2211 t xfinishi,t = 1 \u2200i \u2208 I (8)\n\u2211 t (txfinishi,t ) \u2265 \u2211 t (txstarti,t ) + y makespan i \u2200i \u2208 I (9)\nylatenessi \u2265 \u2211 t (txfinishi,t )\u2212 ci \u2200i \u2208 I (10)\nxi,t = xi,t\u22121 + x start i,t \u2212 xfinishi,t \u2200i \u2208 I, t \u2208 T (11)\nxi,\u22121 = 0 \u2200i \u2208 I (12)"}, {"heading": "2.5.3 Resources", "text": "There are two resource constraints, namely a limited number of maintenance bays, and a limited number of workers. Constraint (13) enforces a limit on the number of maintenance bays being used in each time period. Note that only a subset of the tasks require a maintenance bay. Constraint (14) encodes the limit on the number of each type of worker in each time period.\u2211\ni\u2208M xi,t \u2264 m \u2200t \u2208 T (13)\n\u2211 j\u2208J \u2211 s\u2208{max(0,t\u2212dj),...,t} xstartj,s rj,p,s,t \u2264 ap,t \u2200p, t (14)"}, {"heading": "2.6 Optimisation Problem", "text": "The maintenance scheduling problem is therefore expressed as the optimisation model P :\nP =\n{ minimise (1)\nsubject to (2)\u2212 (14)\nTwo solution methods to this optimisation problem are proposed\u2014a branch and bound approach using commercial software package Gurobi Gur (n.d.), and a GA that is developed in the next section. As will be shown later in the results, this optimisation problem is hard for Gurobi, motivating the development of the genetic algorithm."}, {"heading": "3 Genetic Algorithm", "text": "Genetic algorithms are a class of meta-heuristics that aim to emulate the process of natural selection. They use a population of chromosomes to represent possible solutions to a problem, with each chromosome consisting of a set of genes that describe the solution. To create a new generation of chromosomes, chromosomes from the current generation are randomly combined in proportion to their fitness. In this way, traits from the strongest chromosomes are most likely to be carried forward to the next generation (Mitchell, 1998). Genes are also randomly mutated to avoid being trapped in local optima. This process is outlined in Figure 2. A common addition to GAs is elitism, in which the best chromosome(s) from the current generation are propagated to the next generation without modification. Elitism guarantees that solution quality will not decrease (Baluja & Caruana, 1995).\nThe set of chromosomes in a given population will be denoted by N . The rest of this section first discusses possible chromosome representations and how a maintenance schedule is generated from a chromosome, before presenting the methods used in each step of the GA."}, {"heading": "3.1 Chromosome representation and schedule generation", "text": "Several different chromosome representations were considered. An obvious representation to choose is a direct representation, where the genes consist of binary variables corresponding to the optimisation variables introduced in Section 2. However, most of the values that this chromosome representation can take result in infeasible schedules due to the constraints on the availability of workers and maintenance bays. Thus, it was desirable to develop a representation that would reliably produce feasible schedules.\nThe chromosome representation proposed for this application is an ordered list of tasks. The tasks are then scheduled using a greedy heuristic in the order specified by the chromosome to determine the values of the optimisation variables outlined in Section 2.3. The greedy heuristic places the subtasks of each task as early as possible while satisfying the constraints in Section 2.5. Provided there is always at least 1 maintenance bay and the minimum number of workers required for any subtasks available in each time period, then this representation is guaranteed to always produce a feasible solution. Figure 3 shows the schedules resulting from using the greedy heuristic on the two possible chromosomes for a scenario with two tasks.\nThe greedy heuristic can fail to produce a feasible schedule in certain cases. For example, if the type of worker required for a specific subtask is only available for a small number of time periods at the beginning of the schedule, and the task requires a maintenance bay, then if the task is too late in the chromosome the greedy heuristic can fail to find a valid spot for the subtasks to be placed."}, {"heading": "3.2 Initial population", "text": "The characteristics of the initial population of chromosomes can have a large impact on the performance of the algorithm (Diaz-Gomez & Hougen, 2007). There is a trade-off between having an initial population that contains good initial solutions, which improves the probability of finding a good final solution (Burke et al. , 2004), and having a diverse initial population, which helps avoid premature convergence (Leung et al. , 1997). To strike a balance between diversity and quality, two of the chromosomes in the initial population are selected using heuristics, while the remaining are randomly generated.\nThe first of the heuristics creates a chromosome by sorting the tasks by their ready times. The reasoning behind this heuristic is that it should avoid situations like Figure 3b where the task with the later ready time is performed in between the subtasks of the other task, leading to a large makespan for the first task. The second heuristic is primarily aimed at producing a feasible schedule in scenarios where many of the chromosomes are unable to be converted into a feasible schedule by the greedy heuristic. Tasks that have subtasks that can only be performed in a limited range of times are placed earlier in the chromosome so that they are likely to be able to be scheduled by the greedy heuristic."}, {"heading": "3.3 Calculating the fitness of a chromosome", "text": "Two fitness functions were investigated. The first fitness function calculates the fitness of the n-th chromosome, \u03c61n, as:\n\u03c61n = max{J\u03bd \u2200\u03bd \u2208 N} \u2212 Jn (15)\nwhere Jn is calculated using the objective function from Eq. (1). Note that the max term considers only the chromosomes that result in a feasible schedule.\nThe second function calculates the fitness, \u03c62n, as:\n\u03c62n = 1 Jn \u2212 \u2211 i\u2208I fimin-makespani (16)\nIn this formula, the minimum possible makespan cost is subtracted from the value of the objective function. A perfect schedule in which all tasks take the minimum possible time and are completed before their deadlines would therefore result in a denominator value of 0, and a corresponding infinite fitness value. Note that if a perfect schedule is found, this can simply be returned as the best schedule without running the GA to completion."}, {"heading": "3.4 Parent selection", "text": "A pair of parents are randomly selected for each chromosome in the next generation in proportion to their fitness using the roulette wheel selection method (Davis, 1991). Chromosomes that do not result in feasible schedules do not have a fitness and are not considered as valid parents."}, {"heading": "3.5 Crossover", "text": "Two-point crossover is used to generate a new chromosome from the two parents, as illustrated in Figure 4. First, one of the parents is selected at random to be the dominant parent and two crossover points in the chromosome are randomly selected. If the number of tasks between the crossover points is larger than the number of tasks outside the crossover points, then the dominant parent\u2019s tasks between the crossover points are copied to the child chromosome. Otherwise, the dominant parent\u2019s tasks outside of the crossover points are copied to the child chromosome. The tasks that were not copied across are then greedily placed into the child chromosome in the order in which they appear in the non-dominant parent."}, {"heading": "3.6 Mutation", "text": "The final step in each round of the GA is to mutate the children. A probabilistic check against the mutation rate is performed for each gene in the chromosome. If the check succeeds, then the gene is swapped with another randomly selected gene in the chromosome. The result of this is shown in Figure 4d."}, {"heading": "4 Computational Study", "text": "Two weekly maintenance schedules from a sample mine were used to generate the input datasets used in this paper. Each weekly schedule had just under 100 pieces of equipment, and each piece of equipment had between 1 and 50 subtasks, yielding a total of approximately 800 subtasks. 25 different types of people were required for performing the work, each with differing availability levels. Some types of people were only available during the day-shift, while others were available during both the day-shift and night-shift, but in varying numbers. Approximately 1/3rd of the pieces of equipment required a maintenance bay, while the remaining were serviced in the field. The mine site under consideration had 5 bays in the maintenance shed available for equipment being serviced.\nThis section first evaluates the performance of the commercial solver and GA approaches as the number of tasks is varied, followed by a comprehensive comparison of the methods on randomly generated datasets with the task and worker tightnesses varied. The commercial solver used was Gurobi (Gur, n.d.), and, unless otherwise specified, a time limit of 600s was used for solving the model. The methods tested were the GA with the fitness function defined in (15) (GA1), the GA with the fitness function defined in (16) (GA2), the Gurobi (MILP), and Gurobi seeded with an initial solution using a heuristic (MILP+H). The heuristic used in the MILP+H method simply sorted the tasks by their ready time.\nThe GA used a population size of 100 chromosomes, 60 generations, a mutation rate of 0.1% per gene, and elitism of 1 chromosome. These values were experimentally found to give good performance. These parameters were not\nvaried for the different fitness functions as the intention was to show the difference due only to the choice of fitness function. The purpose of this paper was also not to determine the optimal parameters for the GA, as these should be tuned for the specific scenario under consideration. Unless otherwise noted, all calculation times are from an i7-4810MQ with 16GB of RAM, and Gurobi was set to use a maximum of 4 threads. The GA was programmed by the authors in Python and is single threaded."}, {"heading": "4.1 Varying the number of tasks", "text": "The performance of the approaches as the size of the problem was varied was first examined. The number of tasks was varied to correspond to approximately 1, 2, 3, 4, 5, 6, and 7 days worth of tasks in the original schedule. Figure 5 shows the optimality gap for each method, where the optimality gap was calculated based on the best lower bound calculated by Gurobi using the following formula:\noptimality gap = best solution cost\nbest bound \u2212 1 (17)\nGurobi was only able to find a solution in the first case, in which it found the optimal solution. When provided with an initial solution, it found the optimal solution in the first two cases, but was unable to improve upon the heuristically generated initial solution in the remaining cases. Figure 6 shows the calculation times of each method. As can be seen, Gurobi very quickly hit the time limit of 600s, while the maximum calculation time for the GA approaches was approximately 230s.\nTo highlight the infeasibility of the commercial solvers for realistic problem sizes, Gurobi was run for 6 hours using 8 threads on the full 7 days worth of tasks. In this case, the models have over 300,000 binary variables to solve for. Even running for 6 hours, Gurobi was unable to find a feasible solution for the MILP model, or improve from the initial solution for the MILP+H model. In addition, Gurobi was unable to improve the lower bound from the lower bound produced by the initial root relaxation of the model."}, {"heading": "4.2 Random scenarios", "text": "A set of random scenarios was generated from the input schedules to comprehensively test the performance of each method. Two aspects of the problem were varied\u2014the tightness of the deadline, and the tightness of the worker availability constraints. While the tightness of the deadline impacts the objective value of the optimal schedule, it does not impact on the difficulty of the problem. The tightness of the worker availability constraints, on the other hand, impacts both the objective value of the optimal schedule as well as the problem difficulty. 100 random scenarios were created by randomly sampling the ready time of each task. The deadline of each task was generated from the ready time, minimum possible makespan of the task, and the specified deadline tightness, \u03c0, using the following formula:\nci = bi + \u03c0 \u00d7min-makespani (18)\nValues of \u03c0 \u2208 {1, 1.5, 2} were tested. Three levels of worker tightness were also considered. The tightest level used the actual number of workers available for the supplied schedules\u2014in this case, there were between 1 and 6 workers of most types available, depending on whether it was the day shift of night shift, while 1 or 2 of the types of workers had 10 workers available. The next tightest level assumed that there were 10 workers of every type available. In this way, most of the worker availability constraints become somewhat irrelevant, reducing the difficulty of the problem. Finally, the loosest level of worker tightness assumed that 15 workers of every type available.\nEach of the 100 random scenarios was tested using every combination of deadline tightness and worker tightness, yielding 900 different scenarios in total. A summary of the results are displayed in Tables 1 and 2. Note that the results for the MILP method are omitted as Gurobi was only able to find a feasible solution in 6 of the 900 instances. The heuristic used to seed the MILP+H method produced feasible solutions in all but 3 of the instances, and in 14 cases Gurobi found the optimal solution. It should be noted, though, that the GA1 and GA2 methods also found the optimal solution in those 14 cases, suggesting that they were particularly easy instances.\nTable 1 shows the average optimality gap of each method calculated using (17) and the best lower bound found by Gurobi. It is clear that Gurobi is significantly outperformed by the GA approaches, while, in general, the GA1 approach outperformed the GA2 approach. Similar to the scenarios in Section 4.1, Gurobi struggled to improve upon both the heuristically generated initial solution and the initial lower bound. It is therefore difficult to comment on how close to the true optimal solution the GA approaches were.\nTable 2 shows the relative performance of each method using the GA1 method as the reference point. As can be seen, the GA1 method clearly outperforms the GA2 approach when both the deadlines and worker constraints are tight, with an almost 5% difference in their costs. As these constraints are loosened, the performance difference between the methods decreases. This is a characteristic of the different fitness functions used\u2014when the cost of the schedules are high, the fitness function in (15) provides much better discrimination between chromosomes than the fitness function in (16). This is highlighted in Figure 7a, where the GA1 approach is shown to converge significantly quicker than the GA2 approach. On the other hand, when the schedule costs are very low, the GA2 method can converge significantly quicker than the GA1 method, as shown in Figure 7b. While GA2 converges faster however, the cost of the best chromosome progresses similarly with the number of generations for both methods."}, {"heading": "5 Conclusion", "text": "This paper developed and compared several methods for automatically generating a maintenance schedule for a typical fleet of mining equipment. Current approaches for scheduling maintenance are manual and time intensive. A mixedinteger linear programming model of the problem was formulated. Commercial optimisation software was unable to sufficiently solve the model, even when supplied with a heuristically generated starting schedule, necessitating the development of alternative strategies. To this end, a genetic algorithm approach was developed, which significantly outperformed the commercial optimisation software. Two fitness functions were also compared, with a linear fitness function shown to in general outperform an inverse fitness function.\nThere are several avenues for future work. Further improvements to the performance of the genetic algorithm without increasing the computation time can be achieved by switching from Python to a compiled language such as C++. Genetic algorithms are also embarrassingly parallelisable, so further reductions in the computation time can be achieved in this way. On the algorithmic side, running multiple independent genetic algorithms in parallel may improve the robustness of the approach by helping to avoid local minima. Dynamically switching the fitness function used based on the current chromosome costs could also yield potential improvements in the convergence rate of the algorithm. Finally, methods for incorporating the previous schedule as a starting point when replanning could be investigated."}, {"heading": "Acknowledgements", "text": "This work was supported by the Rio Tinto Centre for Mine Automation and the Australian Centre for Field Robotics, University of Sydney, Australia."}], "references": [{"title": "Dynamic scheduling of maintenance tasks in the petroleum industry: A reinforcement approach", "author": ["N. Aissani", "B. Beldjilali", "D. Trentesaux"], "venue": "Engineering Applications of Artificial Intelligence,", "citeRegEx": "Aissani et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aissani et al\\.", "year": 2009}, {"title": "Removing the genetics from the standard genetic algorithm", "author": ["Baluja", "Shumeet", "Caruana", "Rich"], "venue": "Icml,", "citeRegEx": "Baluja et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Baluja et al\\.", "year": 1995}, {"title": "Simultaneous scheduling of production and maintenance tasks in the job shop", "author": ["M. Ben Ali", "M. Sassi", "M. Gossa", "Y. Harrath"], "venue": "International Journal of Production Research,", "citeRegEx": "Ali et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ali et al\\.", "year": 2011}, {"title": "Diversity in Genetic Programming: An Analysis of Measures and Correlation with Fitness", "author": ["Burke", "Edmund K", "Gustafson", "Steven", "Kendall", "Graham"], "venue": "IEEE Transactions on Evolutionary Computation,", "citeRegEx": "Burke et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Burke et al\\.", "year": 2004}, {"title": "Handbook of genetic algorithms", "author": ["Davis", "Lawrence."], "venue": "Van Nostrand Reinhold.", "citeRegEx": "Davis and Lawrence.,? 1991", "shortCiteRegEx": "Davis and Lawrence.", "year": 1991}, {"title": "Ship maintenance scheduling by genetic algorithm and constraint-based reasoning", "author": ["Deris", "Safaai", "Omatu", "Sigeru", "Ohta", "Hiroshi", "Shaharudin Kutar", "Lt.Cdr", "Abd Samat", "Pathiah"], "venue": "European Journal of Operational Research,", "citeRegEx": "Deris et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Deris et al\\.", "year": 1999}, {"title": "Mining equipment reliability, maintainability, and safety", "author": ["Dhillon", "Balbir S."], "venue": "Springer Science & Business Media.", "citeRegEx": "Dhillon and S.,? 2008", "shortCiteRegEx": "Dhillon and S.", "year": 2008}, {"title": "Initial Population for Genetic Algorithms: A Metric Approach", "author": ["Diaz-Gomez", "Pa", "Hougen", "Df"], "venue": "Proceedings of the 2007 International Conference on Genetic and Evolutionary Methods,", "citeRegEx": "Diaz.Gomez et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Diaz.Gomez et al\\.", "year": 2007}, {"title": "A tabu search heuristic for preventive maintenance scheduling", "author": ["M Gopalakrishnan", "S Mohan", "Z. He"], "venue": "Computers & Industrial Engineering,", "citeRegEx": "Gopalakrishnan et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Gopalakrishnan et al\\.", "year": 2001}, {"title": "Option model for joint production and preventive maintenance system", "author": ["Jin", "Xiaoning", "Li", "Lin", "Ni", "Jun"], "venue": "International Journal of Production Economics,", "citeRegEx": "Jin et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Jin et al\\.", "year": 2009}, {"title": "The equipment maintenance scheduling problem in a coal production system", "author": ["Jiu", "Song", "Zhou", "Zhili", "Liu", "Jiyin"], "venue": "International Journal of Production Research,", "citeRegEx": "Jiu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Jiu et al\\.", "year": 2013}, {"title": "Degree of population diversity A perspective on premature convergence in genetic algorithms and its Markov chain analysis", "author": ["Leung", "Yee", "Gao", "Yong", "Xu", "Zong Ben"], "venue": "IEEE Transactions on Neural Networks,", "citeRegEx": "Leung et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Leung et al\\.", "year": 1997}, {"title": "Maintenance of mobile mine equipment in the information age", "author": ["Lewis", "Michael W", "Steinberg", "Luiz"], "venue": "Journal of Quality in Maintenance Engineering,", "citeRegEx": "Lewis et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lewis et al\\.", "year": 2001}, {"title": "An Introduction to Genetic Algorithms", "author": ["Mitchell", "Melanie."], "venue": "MIT press.", "citeRegEx": "Mitchell and Melanie.,? 1998", "shortCiteRegEx": "Mitchell and Melanie.", "year": 1998}, {"title": "An integrated production and maintenance planning model with time windows and shortage cost", "author": ["Najid", "Najib M", "Alaoui-Selsouli", "Marouane", "Mohafid", "Abdelmoula"], "venue": "International Journal of Production Research,", "citeRegEx": "Najid et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Najid et al\\.", "year": 2011}, {"title": "A methodology for joint optimization for maintenance planning, process quality and production scheduling", "author": ["Pandey", "Divya", "Kulkarni", "Makarand S", "Vrat", "Prem"], "venue": "Computers & Industrial Engineering,", "citeRegEx": "Pandey et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Pandey et al\\.", "year": 2011}, {"title": "Mine maintenance - the cost of operation", "author": ["T Singleton", "O. Krellis"], "venue": "Coal Operators Conference,", "citeRegEx": "Singleton and Krellis,? \\Q1998\\E", "shortCiteRegEx": "Singleton and Krellis", "year": 1998}, {"title": "Reliability modelling for maintenance scheduling of mobile mining equipment. Pages 526\u2013540", "author": ["Summit", "Raymond", "Halomoan", "David"], "venue": "of: Proceedings of the 11th Biennial Engineering Mathematics and Applications Conference,", "citeRegEx": "Summit et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Summit et al\\.", "year": 2015}, {"title": "Mine Maintenance Management Reader", "author": ["Tomlingson", "Paul D."], "venue": "Society for Mining, Metallurgy, and Exploration.", "citeRegEx": "Tomlingson and D.,? 2007", "shortCiteRegEx": "Tomlingson and D.", "year": 2007}, {"title": "A new MIP model for mine equipment scheduling by minimizing maintenance cost", "author": ["Topal", "Erkan", "Ramazan", "Salih"], "venue": "European Journal of Operational Research,", "citeRegEx": "Topal et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Topal et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 5, "context": "Some related maintenance scheduling problems are examined by Gopalakrishnan et al. (2001); Deris et al.", "startOffset": 61, "endOffset": 90}, {"referenceID": 3, "context": "(2001); Deris et al. (1999); Ben Ali et al.", "startOffset": 8, "endOffset": 28}, {"referenceID": 1, "context": "(1999); Ben Ali et al. (2011); Jiu et al.", "startOffset": 12, "endOffset": 30}, {"referenceID": 1, "context": "(1999); Ben Ali et al. (2011); Jiu et al. (2013); Jin et al.", "startOffset": 12, "endOffset": 49}, {"referenceID": 1, "context": "(1999); Ben Ali et al. (2011); Jiu et al. (2013); Jin et al. (2009); Aissani et al.", "startOffset": 12, "endOffset": 68}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al.", "startOffset": 8, "endOffset": 30}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al.", "startOffset": 8, "endOffset": 52}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al.", "startOffset": 8, "endOffset": 73}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al.", "startOffset": 8, "endOffset": 452}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al. (2009). Methods for jointly optimising maintenance and production were developed by Pandey et al.", "startOffset": 8, "endOffset": 537}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al. (2009). Methods for jointly optimising maintenance and production were developed by Pandey et al. (2011); Najid et al.", "startOffset": 8, "endOffset": 635}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al. (2009). Methods for jointly optimising maintenance and production were developed by Pandey et al. (2011); Najid et al. (2011). Najid et al.", "startOffset": 8, "endOffset": 656}, {"referenceID": 0, "context": "(2009); Aissani et al. (2009); Pandey et al. (2011); Najid et al. (2011). Many of these authors used meta-heuristics such as tabu-search (Gopalakrishnan et al. , 2001) and Genetic Algorithms (GAs) (Deris et al. , 1999; Ben Ali et al. , 2011; Jiu et al. , 2013) to generate a schedule. These meta-heuristic approaches were shown to produce near-optimal solutions in reasonable calculation times. An option-based cost model was used by Jin et al. (2009), while a novel reinforcement learning approach was utilised by Aissani et al. (2009). Methods for jointly optimising maintenance and production were developed by Pandey et al. (2011); Najid et al. (2011). Najid et al. (2011) formulated this as a Mixed-Integer Linear Program (MILP) and solved it using commercial optimisation software.", "startOffset": 8, "endOffset": 677}], "year": 2016, "abstractText": "The weekly maintenance schedule specifies when maintenance activities should be performed on the equipment, taking into account the availability of workers and maintenance bays, and other operational constraints. The current approach to generating this schedule is labour intensive and requires coordination between the maintenance schedulers and operations staff to minimise its impact on the operation of the mine. This paper presents methods for automatically generating this schedule from the list of maintenance tasks to be performed, the availability roster of the maintenance staff, and time windows in which each piece of equipment is available for maintenance. Both Mixed-Integer Linear Programming (MILP) and genetic algorithms are evaluated, with the genetic algorithm shown to significantly outperform the MILP. Two fitness functions for the genetic algorithm are also examined, with a linear fitness function outperforming an inverse fitness function by up to 5% for the same calculation time. The genetic algorithm approach is computationally fast, allowing the schedule to be rapidly recalculated in response to unexpected delays and breakdowns.", "creator": "LaTeX with hyperref package"}}}