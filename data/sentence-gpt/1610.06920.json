{"id": "1610.06920", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Oct-2016", "title": "Bit-pragmatic Deep Neural Network Computing", "abstract": "We quantify a source of ineffectual computations when processing the multiplications of the convolutional layers in Deep Neural Networks (DNNs) and propose Pragmatic (PRA), an architecture that exploits it improving performance and energy efficiency. The source of these ineffectual computations is best understood in the context of conventional multipliers which generate internally multiple terms, that is, products of the multiplicand and powers of two, which added together produce the final product [1]. At runtime, many of these terms are zero as they are generated when the multiplicand is combined with the zero-bits of the multiplicator. While conventional bit-parallel multipliers calculate all terms in parallel to reduce individual product latency, PRA calculates only the non-zero terms using a) on-the-fly conversion of the multiplicator representation into an explicit list of powers of two, and b) hybrid bit-parallel multplicand/bit-serial multiplicator processing units. PRA exploits two sources of ineffectual computations: 1) the aforementioned zero product terms which are the result of the lack of explicitness in the multiplicator representation, and 2) the excess in the representation precision used for both multiplicants and multiplicators, e.g., [2]. Measurements demonstrate that for the convolutional layers, a straightforward variant of PRA improves performance by 2.6x over the DaDiaNao (DaDN) accelerator [3] and by 1.4x over STR [4]. Similarly, PRA improves energy efficiency by 28% and 10% on average compared to DaDN and STR. An improved cross lane synchronication scheme boosts performance improvements to 3.1x over DaDN. Finally, Pragmatic benefits persist even with an 8-bit quantized representation [5]. Although these results provide a novel optimization of the optimization in the DNNs, other features that were overlooked by the authors may not apply to PRA [6] or DNNs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Thu, 20 Oct 2016 22:16:05 GMT  (1108kb,D)", "http://arxiv.org/abs/1610.06920v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI cs.AR cs.CV", "authors": ["j albericio", "p judd", "a delm\\'as", "s sharify", "a moshovos"], "accepted": false, "id": "1610.06920"}, "pdf": {"name": "1610.06920.pdf", "metadata": {"source": "CRF", "title": "Bit-Pragmatic Deep Neural Network Computing", "authors": ["Jorge Albericio", "Patrick Judd", "Alberto Delm\u00e1s", "Sayeh Sharify", "Andreas Moshovos"], "emails": ["moshovos}@ece.utoronto.ca"], "sections": [{"heading": null, "text": "PRA exploits two sources of ineffectual computations: 1) the aforementioned zero product terms which are the result of the lack of explicitness in the multiplicator representation, and 2) the excess in the representation precision used for both multiplicants and multiplicators, e.g., [2]. Measurements demonstrate that for the convolutional layers, a straightforward variant of PRA improves performance by 2.6x over the DaDiaNao (DaDN) accelerator [3] and by 1.4x over STR [4]. Similarly, PRA improves energy efficiency by 28% and 10% on average compared to DaDN and STR. An improved cross lane synchronization scheme boosts performance improvements to 3.1x over DaDN. Finally, Pragmatic benefits persist even with an 8-bit quantized representation [5].\nI. INTRODUCTION\nDeep neural networks (DNNs) have become the state-ofthe-art technique in many recognition tasks such as object [6] and speech recognition [7]. While DNN\u2019s have high computational demands, they are today practical to deploy given the availability of commodity Graphic Processing Units (GPUs) which can exploit the natural parallelism of DNNs. Yet, the need for even more sophisticated DNNs demands even higher performance and energy efficiency motivating special purpose architectures such as the state-of-the-art DaDianNao (DaDN) [3]. With power limiting modern high-performance designs, achieving better energy efficiency is essential can enable further advances [8].\nDNNs comprise a pipeline of layers where more than 92% of the processing time is spent in convolutional layers [3], which this work targets. These layers perform inner products where neurons and synapses are multiplied in pairs, and where the resulting products are added to produce a single output neuron. A typical convolutional layer performs hundreds of inner products, each accepting hundreds to thousands neuron and synapse pairs.\nDNN hardware typically uses either 16-bit fixed-point [3] or quantized 8-bit numbers [5] and bit-parallel compute units. Since the actual precision requirements vary considerably across DNN layers [2], typical DNN hardware ends up processing an excess of bits when processing these inner products [4]. Unless the values processed by a layer need the full value range afforded by the hardware\u2019s representation, an excess of bits, some at the most significant bit positions (prefix bits) and some at the least significant positions (suffix bits), need to be set to zero yet do not contribute to the final outcome. With bit-parallel compute units there is no performance benefit in not processing these excess bits.\nRecent work, Stripes (STR) uses serial-parallel multiplication [9] to avoid processing these zero prefix and suffix bits [4] yielding performance and energy benefits. STR represents the neurons using pre-specified per layer precisions. Given a neuron n represented in p bits and a synapse s represented in, for example, 16-bits, STR processes n bit-serially over p cycles, where in each cycle one bit of n is multiplied by s accumulating the result into a running sum. While STR takes p cycles to compute each product, it can ideally improve performance by 16/p compared to a 16-bit fixed-point bit-parallel hardware by processing 16\u00d7 more neurons and synapse pairs in parallel. The abundant parallelism of DNN convolutional layers makes this possible.\nWhile STR avoids processing the ineffectual suffix and tail bits of neurons that are due to the one-size-fits-all representation of conventional bit-parallel hardware, it still processes many ineffectual neuron bits: Any time a zero bit is multiplied by a synapse it adds nothing to the final output neuron. These ineffectual bits are introduced by the conventional positional number representation. If these multiplications could be avoided it would take even less time to calculate each product improving energy and performance. Section II shows that in state-of-the-art image classification networks show that 93% and 69% of neuron bit and synapse products are ineffectual when using respectively 16-bit fixed-point and 8-bit quantized representations.\nThis work presents Pragmatic (PRA) a DNN accelerator whose goal is to process only the essential (non-zero) bits of the input neurons. PRA subsumes STR not only since a) it avoids processing non-essential bits regardless of their position, but also as b) it obviates the need to determine a priori the specific precision requirements per layer. PRA employs the following four key techniques: 1) on-the-fly conversion of neurons from a storage representation (e.g., conventional\nar X\niv :1\n61 0.\n06 92\n0v 1\n[ cs\n.L G\n] 2\n0 O\nct 2\n01 6\nBit-Parallel Hardware Precision\npositional number or quantized) into an explicit representation of the essential bits only, 2) bit-serial neuron/bit-parallel synapse processing, an idea borrowed from STR but adapted for the aforementioned representation, 3) judicious SIMD (single instruction multiple data) lane grouping to maintain wide memory accesses and to avoid fragmenting and enlarging the multi-MB on-chip synapse memories (Sections V-A4 and V-E), and 4) computation re-arrangement (Section V-D) to reduce datapath area. All evaluated PRA variants maintain wide memory accesses and use highly-parallel SIMD-style (single-instruction multiple-data) computational units. PRA introduces an additional dimension upon which software can improve performance and energy efficiency by controlling neuron values judiciously in order to reduce their essential bit content while maintaining accuracy. This work explores such an alternative, where the software explicitly communicates how many prefix and suffix bits to discard after each layer.\nExperimental measurements with state-of-the-art DNNs demonstrate that most straightforward PRA variant, boosts average performance for the convolutional layers to 2.59x over the state-of-the-art DaDN accelerator compared to the 1.85x performance improvement of STR alone. Pragmatic\u2019s average energy efficiency is 1.48x over DaDN and its area overhead is 1.35x. Another variant further boosts performance to 3.1x over DaDN at the expense of an additional 0.7% area. Software guidance accounts for 19% of these performance benefits."}, {"heading": "II. MOTIVATION", "text": "Let us assume a p-bit bit-parallel multiplier using a straightforward implementation of the \u201cShift and Add\u201d algorithm where n\u00d7s is calculated as \u2211p i=0 ni \u00b7 (s i), where ni the ith bit of n. The multiplier computes p terms, each a product of s and of a bit of n, and adds them to produce the final result. The terms and their sum can be calculated concurrently to reduce latency [1].\nWith such a hardware arrangement there are two sources of ineffectual computations that result from: 1) an Excess of Precision (EoP), and 2) Lack of Explicitness (LoE). Figure 1 shows an example illustrating these sources with a bit-parallel multiplier using an 8-bit unsigned fixed-point number with 4 fractional and 4 integer bits. While 10.101(2) requires just five bits, our 8-bit bit-parallel multiplier will zero-extend it with two prefix and one suffix bits. This is an example of EoP and is\ndue to the fixed-precision hardware. Two additional ineffectual bits appear at positions 1 and -2 as a result of LoE in the positional number representation. In total, five ineffectual bits will be processed generating five ineffectual terms.\nOur number could be represented with an explicit list of its three constituent powers of 2: (1,-1,-3). While such a representation may require more bits and thus be undesirable for storage, coupled with the abundant parallelism that is present in DNNs layers, it provides an opportunity to revisit hardware design improving performance and energy efficiency.\nThe rest of this section motivates Pragmatic by: 1) measuring the fraction of non-zero bits in the neuron stream of stateof-the-art DNNs for three commonly used representations, and 2) estimating the performance improvement which may be possible by processing only the non-zero neuron bits."}, {"heading": "A. Essential Neuron Bit Content", "text": "Table V reports the essential bit content of the neuron stream of state-of-the-art DNNs for two commonly used fixed length representations: 1) 16-bit fixed-point of DaDianNao [3], 2) 8-bit quantized of Tensorflow [5]. The essential bit content is the average number of non-zero bits that are 1. Two measurements are presented per representation: over all neuron values (\u201cAll\u201d), and over the non-zero neurons (\u201cNZ\u201d) as accelerators that can skip zero neurons for fixed-point representations have been recently proposed [10], [11].\nWhen considering all neurons, the essential bit-content is at most 12.7% and 38.4% for the fixed-point and the quantized representations respectively. The measurements are consistent with the neuron values following a normal distribution centered at 0, and then being filtered by a rectifier linear unit (ReLU) function [12]. Even when considering the non-zero neurons the essential bit content remains well below 50% and as the next section will show, there are many non-zero valued neurons suggesting that the potential exists to improve performance and energy efficiency over approaches that target zero valued neurons.\nThese results suggest that a significant number of ineffectual terms are processed with conventional fixed-length hardware. Stripes [4], tackles the excess of precision, exploiting the variability in numerical precision DNNs requirements to increase performance by processing the neurons bit-serially. Pragmatic\u2019s goal is to also exploit the lack of explicitness. As the next section will show, Pragmatic has the potential to greatly improve performance even when compared to Stripes."}, {"heading": "B. Pragmatic\u2019s Potential", "text": "To estimate PRA\u2019s potential, this section compares the number of terms that would be processed by various computing engines for the convolutional layers of state-of-the-art DNNs (see Section VI-A) for the two aforementioned baseline neuron representations. 16-bit Fixed-Point Representation: The following computing engines are considered: 1) baseline representative of DaDN using 16-bit fixed-point bit-parallel units [3], 2) a hypothetical enhanced baseline ZN, that can skip all zero valued neurons,\n3) Cnvlutin (CVN) a practical design that can skip zero value neurons for all but the first layer [11], 4) STR that avoids EoP (see Table II, Section VI-A) [4], 5) an ideal, softwaretransparent PRA, PRA-fp16 that processes only the essential neuron bits, and 6) an ideal PRA, PRA-red, where software communicates in advance how many prefix and suffix bits can be zeroed out after each layer (see Section V-F).\nFigure 2 reports the number of terms normalized over DaDN where each multiplication is accounted for using an equivalent number of terms or equivalently additions: 16 for DaDN, ZN, and CVN, p for a layer using a precision of p bits for STR, and the number of essential neuron bits for PRA-fp16, and for PRA-red. For example, for n = 10.001(2), the number of additions counted would be 16 for DaDN and CVN+, 5 for STR as it could use a 5-bit fixed-point representation, and 2 for PRA-fp16 and PRA-red.\nOn average, STR reduces the number of terms to 53% compared to DaDN while skipping just the zero valued neurons could reduce them to 39% if ZN was practical and to 63% in practice with CVN. PRA-fp16 can ideally reduce the number of additions to just 10% on average, while with software provided precisions per layer, PRA-red reduces the number of additions further to 8% on average. The potential savings are robust across all DNNs remaining above 87% for all DNNs with PRA-red. 8-bit Quantized Representation: Figure 3 shows the relative\nnumber of terms processed for: 1) a bit-parallel baseline, 2) an ideal, yet impractical bit-parallel engine that skips all zero neurons, and 3) PRA. In the interest of space and since PRA subsumes STR and CVN they are not considered. Pragmatic\u2019s potential benefits are significant even with an 8-bit quantized representation. On average, skipping all the zero valued neurons would eliminate only 30% of the terms whereas Pragmatic would remove up to 71% of the terms.\nIn summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4]. It further showed that far less computations are really needed, 10% and 29% on average for the 16-bit fixedpoint and 8-bit quantized representations respectively, if only the essential neuron bits were processed. Finally, software can boost the opportunities for savings by communicating per layer precisions.\nIII. Pragmatic: A SIMPLIFIED EXAMPLE\nThis section illustrates the idea behind Pragmatic via a simplified example. For the purposes of this discussion suffices to know that in a convolutional layer there are typically hundreds to thousands of neurons, each multiplied with a corresponding synapse, and that the synapses are reused several times. Section IV-A describes the relevant computations in more detail.\nThe bit-parallel unit of Figure 4a multiplies two neurons with their respective synapses and via an adder reduces the two products. The unit reads all neuron and synapse bits, (n0 = 001(2), n1 = 010(2)) and (s0 = 001(2), s1 = 111(2)) respectively in a single cycle. As a result, the two sources of inefficiency EoP and LoE manifest here: n0 and n1 are represented using 3 bits instead of 2 respectively due to EoP. Even in 2 bits, they each contain a zero bit due to LoE. As a result, four ineffectual terms are processed when using standard multipliers such as those derived from the Shift and\nAdd algorithm. In general, given N neuron and synapse pairs, this unit will take dN/2e cycles to process them regardless of their precision and the essential bit content of the neurons.\nThe hybrid, bit-serial-neuron/bit-parallel-synapse unit in Figure 4b is representative of STR which tackles EoP. Each cycle, the unit processes one bit from each neuron and hence it takes three cycles to compute the convolution when the neurons are represented using 3 bits each, a slowdown of 3x over the bit-parallel engine. To match the throughput of the bit-parallel engine of Figure 4a, STR takes advantage of synapse reuse and processes multiple neurons groups in parallel. In this example, six neurons (n0 = 001(2), n1 = 010(2), n \u2032 0 = 000(2), n \u2032 1 = 010(2), n \u2032\u2032 0 = 010(2), n \u2032\u2032 1 = 000(2)) are combined with the two synapses as shown. Starting from the least significant position, each cycle one bit per neuron is ANDed with the corresponding synapse. The six AND results are added via the reduction tree and the result is accumulated after being shifted by one bit. Since the specific neuron values could be represented all using 2 bits, STR would need 2 cycles to process all six products compared to the 3 cycles needed by the bit-parallel system, a 3/2\u00d7 speedup. However, Stripes still processes some ineffectual terms. For example, in the first cycle, 4 of the 6 terms are zero yet they are added via the adder tree, wasting computing resources and energy.\nFigure 4c shows a simplified PRA engine. In this example, neurons are no longer represented as vectors of bits but as vectors of offsets of the essential bits. For example, neuron n0 = 001(2) is represented as on0 = (0), and a neuron value of 111(2) would be represented as (2, 1, 0). An outof-band bit (wire) not shown indicates the neuron\u2019s end. A shifter per neuron uses the offsets to effectively multiply the corresponding synapse with the respective power of 2 before passing it to the adder tree. As a result, PRA processes only the non-zero terms avoiding all ineffectual computations that were due to EoP or LoE. For this example, PRA would process six neuron and synapse pairs in a single cycle, a speedup of 3\u00d7 over the bit-parallel engine."}, {"heading": "IV. BACKGROUND", "text": "This work presents Pragmatic as a modification of the state-of-the-art DaDianNao accelerator. Accordingly, this section provides the necessary background information: Section IV-A reviews the operation of convolutional layers, and Section IV-B overviews DaDN and how it processes convolutional layers."}, {"heading": "A. Convolutional Layer Computation", "text": "A convolutional layer processes and produces neuron arrays, that is 3D arrays of real numbers. The layer applies N 3D filters in a sliding window fashion using a constant stride S to produce an output 3D array. The input array contains Nx\u00d7 Ny \u00d7 I neurons. Each of the N filters, contains Fx \u00d7 Fy \u00d7 I synapses which are also real numbers. The output neuron array dimensions are Ox\u00d7Oy\u00d7N , that is its depth equals the filter count. Each filter corresponds to a desired feature and the goal of the layer is to determine where in the input neuron array these features appear. Accordingly, each constituent 2D array along the i dimension of the output neuron array corresponds to a feature. To calculate an output neuron, the layer applies one filter over a window, a filter-sized, or Fx \u00d7 Fy \u00d7 I subarray of the input neuron array. If n(x, y, i) and o(x, y, i) are respectively input and output neurons, and sf (x, y, i) are the synapses of filter f . The output neuron at position (k, l, f) is given by:\no(k, l, f)\ufe38 \ufe37\ufe37 \ufe38 output neuron\n= Fy\u22121\u2211 y=0 Fx\u22121\u2211 x=0 I\u22121\u2211 i=0 sf(y, x, i)\ufe38 \ufe37\ufe37 \ufe38 synapse\n\u00d7n(y + l \u00d7 S, x+ k \u00d7 S, i)\ufe38 \ufe37\ufe37 \ufe38 input neuron\ufe38 \ufe37\ufe37 \ufe38\nwindow\nThe layer applies filters repeatedly over different windows positioned along the X and Y dimensions using a constant stride S, and there is one output neuron per window and filter. Accordingly, the output neuron array dimensions are Ox = (Ix \u2212 Fx)/S + 1, Oy = (Iy \u2212 Fy)/S + 1, and Oi = N . .\n1) Terminology \u2013 Bricks and Pallets:: For clarity, in what follows the term brick refers to a set of 16 elements of a 3D neuron or synapse array which are contiguous along the\ni dimension, e.g., n(x, y, i)...n(x, y, i + 15). Bricks will be denoted by their origin element with a B subscript, e.g., nB(x, y, i). The term pallet refers to a set of 16 bricks corresponding to adjacent, using a stride S, windows along the x or y dimensions, e.g., nB(x, y, i)...nB(x, y+15\u00d7 S, i) and will be denoted as nP (x, y, i). The number of neurons per brick, and bricks per pallet are design parameters."}, {"heading": "B. Baseline System: DaDianNao", "text": "Pragmatic is demonstrated as a modification of the DaDianNao accelerator (DaDN) proposed by Chen et al. [3]. Figure 5a shows a DaDN tile which processes 16 filters concurrently calculating 16 neuron and synapse products per filter for a total of 256 products per cycle. To do, each cycle the tile accepts 16 synapses per filter for total of 256 synapses, and 16 input neurons. The tile multiplies each synapse with only one neuron whereas each neuron is multiplied with 16 synapses, one per filter. The tile reduces the 16 products into a single partial output neuron per filter, for a total of 16 partial output neurons for the tile. Each DaDN chip comprises 16 such tiles, each processing a different set of 16 filters per cycle. Accordingly, each cycle, the whole chip processes 16 neurons and 256\u00d716 = 4K synapses producing 16\u00d716 = 256 partial output neurons.\nInternally, each tile has: 1) a synapse buffer (SB) that provides 256 synapses per cycle one per synapse lane, 2) an input neuron buffer (NBin) which provides 16 neurons per cycle through 16 neuron lanes, and 3) a neuron output buffer (NBout) which accepts 16 partial output neurons per cycle. In the tile\u2019s datapath, or the Neural Functional Unit (NFU) each neuron lane is paired with 16 synapse lanes one from each filter. Each synapse and neuron lane pair feed a multiplier and an adder tree per filter lane reduces the 16 per filter products into a partial sum. In all, the filter lanes produce each a partial sum per cycle, for a total of 16 partial output neurons per NFU. Once a full window is processed, the 16 resulting sums, are fed through a non-linear activation function, f , to produce the 16 final output neurons. The multiplications and reductions needed per cycle are implemented via 256 multipliers one per synapse lane and sixteen 17-input (16 products plus the partial sum from NBout) adder trees one per filter lane.\nDaDN\u2019s main goal was minimizing off-chip bandwidth while maximizing on-chip compute utilization. To avoid fetching synapses from off-chip, DaDN uses a 2MB eDRAM SB per tile for a total of 32MB eDRAM. All inter-layer neuron outputs except for the initial input and the final output are stored in a 4MB shared central eDRAM Neuron Memory (NM) which is connected via a broadcast interconnect to the 16 NBin buffers. Off-chip accesses are needed only for reading the input image, the synapses once per layer, and for writing the final output.\nProcessing starts by reading from external memory the first layer\u2019s filter synapses, and the input image. The synapses are distributed over the SBs and the input is stored into NM. Each cycle an input neuron brick is broadcast to all units. Each units reads 16 synapse bricks from its SB and produces a\npartial output neuron brick which it stores in its NBout. Once computed, the output neurons are stored through NBout to NM and then fed back through the NBins when processing the next layer. Loading the next set of synapses from external memory can be overlapped with the processing of the current layer as necessary."}, {"heading": "V. Pragmatic", "text": "This section presents the Pragmatic architecture. Section V-A describes PRA\u2019s processing approach while Section V-B describes its organization. Sections V-D and V-E present two optimizations that respectively improve area and performance. For simplicity, the description assumes specific values for various design parameters so that PRA performance matches that of the DaDN configuration of Section IV-B in the worst case."}, {"heading": "A. Approach", "text": "PRA\u2019s goal is to process only the essential bits of the input neurons. To do so PRA a) converts, on-the-fly, the input neuron representation into one that contains only the essential bits, and b) processes one essential bit per neuron and a full 16-bit synapse per cycle. Since PRA processes neuron bits serially, it may take up to 16 cycles to produce a product of a neuron and a synapse. To always match or exceed the performance of the bit-parallel units of DaDN, PRA processes more neurons concurrently exploiting the abundant parallelism of the convolutional layers. The remaining of this section describes in turn: 1) an appropriate neuron representation, 2) the way PRA calculates terms, 3) how multiple terms are processed concurrently to maintain performance on par with DaDN in the worst case, and 4) how PRA\u2019s units are supplied with the necessary neurons from NM.\n1) Input Neuron Representation: PRA starts with an input neuron representation where it is straightforward to identify the next essential bit each cycle. One such representation is an explicit list of oneffsets, that is of the constituent powers of two. For example, a neuron n = 5.5(10) = 0101.1(2) would be represented as n = (2, 0,\u22121). In the implementation described herein, neurons are stored in 16-bit fixed-point in NM, and converted on-the-fly in the PRA representation as they are broadcast to the tiles. A single oneffset is processed per neuron per cycle. Each oneffset is represented as (pow, eon) where pow is a 4-bit value and eon a single bit which if set indicates the end of a neuron. For example, n = 101(2) is represented as nPRA = ((0010, 0)(0000, 1)). In the worst case, all bits of an input neuron would be 1 and hence its PRA representation would contain 16 oneffsets.\n2) Calculating a Term: PRA calculates the product of synapse s and neuron n as:\ns\u00d7 n = \u2211 \u2200f\u2208nPRA s\u00d7 2f = \u2211 \u2200f\u2208nPRA (n f)\nThat is, each cycle, the synapse s multiplied by f , the next constituent power two of n, and the result is accumulated. This multiplication can be implemented as a shift and an AND.\n3) Boosting Compute Bandwidth over DaDN: To match DaDN\u2019s performance PRA needs to process the same number of effectual terms per cycle. Each DaDN tile calculates 256 neuron and synapse products per cycle, or 256 \u00d7 16 = 4K terms. While most of these terms will be in practice ineffectual, to guarantee that PRA always performs as well as DaDN it should process 4K terms per cycle. For the time being let us assume that all neurons contain the same number of essential bits, so that when processing multiple neurons in parallel, all units complete at the same time and thus can proceed with the next set of neurons in sync. The next section will relax this constraint.\nSince PRA processes neurons bits serially, it produces one term per neuron bit and synapse pair and thus needs to process 4K such pairs concurrently. The choice of which 4K neuron bit and synapse pairs to process concurrently can adversely affect complexity and performance. For example, it could force an increase in SB capacity and width, or an increase in NM width, or be ineffective due to unit underutilization given the commonly used layer sizes.\nFortunately, it is possible to avoid increasing the capacity and the width of the SB and the NM while keeping the units utilized as in DaDN. Specifically, a PRA tile can read 16 synapse bricks and the equivalent of 256 neuron bits as DaDN\u2019s tiles do (DaDN processes 16 16-bit neurons or 256 neuron bits per cycle). Specifically, as in DaDN, each PRA tile processes 16 synapse bricks concurrently, one per filter. However, differently than DaDN where the 16 synapse bricks are combined with just one neuron brick which is processed bit-parallel, PRA combines each synapse brick with 16 neuron bricks, one from each of 16 windows, which are processed bit-serially. The same 16 neuron bricks are combined with all synapse bricks. These neuron bricks form a pallet enabling the same synapse brick to be combined with all. For example, in a single cycle a PRA title processing filters 0 through 15 could combine combine s0B(x, y, 0), ..., s 1 B5(x, y, 0) with\nnPRAB (x, y, 0), n PRA B (x+2, y, 0), ...n PRA B (x+31, y, 0) assuming a layer with a stride of 2. In this case, s4(x, y, 2) would be paired with nPRA(x, y, 2), nPRA(x + 2, y, 2), ..., nPRA(x + 31, y, 2) to produce the output neurons on(x, y, 4) through on(x+ 15, y, 4).\nAs the example illustrates, this approach allows each synapse to be combined with one neuron per window whereas in DaDN each synapse is combined with one neuron only. In total, 256 essential neuron bits are processed per cycle and given that there are 256 synapses and 16 windows, PRA processes 256 \u00d7 16 = 4K neuron bit and synapse pairs, or terms per cycle producing 256 partial output neurons, 16 per filter, or 16 partial output neuron bricks per cycle.\n4) Supplying the Input Neuron and Synapse Bricks: Thus far it was assumed that all input neurons have the same number of essential bits. Under this assumption, all neuron lanes complete processing their terms at the same time, allowing PRA to move on to the next neuron pallet and the next set of synapse bricks in one step. This allows PRA to reuse STR\u2019s approach for fetching the next pallet from the single-ported NM [4]. Briefly, with unit stride the 256 neurons would be typically all stored in the same NM row or at most over two adjacent NM rows and thus can be fetched in at most two cycles. When the stride is more than one, the neurons will be spread over multiple rows and thus multiple cycles will be needed to fetch them all. Fortunately, fetching the next pallet can be overlapped with processing the current one. Accordingly, if it takes NMC to access the next pallet from NM, while the current pallet requires PC cycles to process, the next pallet will begin processing after max(NMC , PC) cycles. When NMC > PC performance is lost waiting for NM.\nIn practice it highly unlikely that all neurons will have the same number of essential bits. In general, each neuron lane if left unrestricted will advance at a different rate. In the worst case, each neuron lane may end up needing neurons from a\ndifferent neuron brick, thus breaking PRA\u2019s ability to reuse the same synapse brick. This is undesirable if not impractical as it would require partitioning and replicating the SB so that 4K unrelated synapses could be read per cycle, and it would also increase NM complexity and bandwidth.\nFortunately, these complexities can be avoided with palletlevel neuron lane synchronization where all neuron lanes \u201cwait\u201d (a neuron lane that has detected the end of its neuron forces zero terms while waiting) for the one with the most essential bits to finish before proceeding with the next pallet. Under this approach, it does not matter which bits are essential per neuron, only how many exist. Since, it is unlikely that most pallets will contain a neuron with 16 essential terms, PRA will improve performance over DaDN. Section VI-B will show that in practice, this approach improves performance over DaDN and STR. Section V-E will discuss finer-grain synchronization schemes that lead to even better performance. Before doing so, however, the intervening sections detail PRA\u2019s design."}, {"heading": "B. Tile Organization and Operation", "text": "Figure 5b shows the Pragmatic tile architecture which comprises an array of 16\u00d716 = 256 pragmatic inner product units (PIPs). PIP(i,j) processes a neuron oneffset from the ith window and its corresponding synapse from the j-th filter. Specifically, all the PIPs along the i-th row receive the same synapse brick belonging to the i-th filter and all PIPs along the j-th column receive an oneffset from each neuron from one neuron brick belonging to the j-th window.\nThe necessary neuron oneffsets are read from NBin where they have been placed by the Dispatcher and the Oneffset generators units as Section V-C explains. Every cycle NBin sends 256 oneffsets 16 per window lane. All the PIPs in a column receive the same 16 oneffsets, corresponding to the neurons of a single window. When the tile starts to process a new neuron pallet, 256 synapses are read from SB through its 256 synapse lanes as in DaDN and are stored in the synapse registers (SR) of each PIP. The synapse and oneffsets are then processed by the PIPs as the next section describes.\n1) Pragmatic Inner-Product Unit: Figure 6 shows the PIP internals. Every cycle, 16 synapses are combined with their corresponding oneffsets. Each oneffsets controls a shifter effectively multiplying the synapse with a power of two. The shifted synapses are reduced via the adder tree. An AND gate per synapse supports the injection of a null terms when\nnecessary. In the most straightforward design, the oneffsets use 4-bits, each shifter accepts a 16-bit synapse and can shift it by up to 15 bit positions producing a 31-bit output. Finally, the adder tree accepts 31-bit inputs. Section V-D presents an enhanced design that requires narrower components improving area and energy."}, {"heading": "C. Dispatcher and Oneffset Generators", "text": "The Dispatcher reads 16 neuron bricks from NM, as expected by the PRA tiles. The oneffset generator converts their neurons on-the-fly to the oneffset representation, and broadcasts one oneffset per neuron per cycle for a total of 256 oneffsets to all titles. Fetching and assembling the 16 neuron bricks from NM is akin to fetching words with a stride of S from a cache structure. As Section V-A4 discussed this can take multiple cycles depending on the stride and alignment of the initial neuron brick. PRA uses the same dispatcher design as STR [4].\nOnce the 16 neuron bricks have been collected, 256 oneffset generators operate in parallel to locate and communicate the next oneffset per neuron. A straightforward 16-bit leading one detector is sufficient. The latency of the oneffset generators and the dispatcher can be readily hidden as they can be pipelined as desired overlapping them with processing in the PRA tiles.\nD. 2-Stage Shifting\nAny shift can be performed in two stages as two smaller shifts: a K = a (K \u2032 + C) = ((a K \u2032) C). Thus, to shift and add T synapses by different offsets K0, ...,KT , we can decompose the offsets into sums with a common term C, e.g., Ki = K \u2032i + C. Accordingly, PIP processing can be rearranged using a two stage processing where the first stage uses the synapse specific offsets K \u2032i, and the second stage, the common across all synapses offset C:\nT\u2211 i\n(Si Ki)\ufe38 \ufe37\ufe37 \ufe38 1\u2212stage shifting =\nT\u2211 i (Si (K \u2032i + C)) =\n( T\u2211 i\n(Si K \u2032i)\ufe38 \ufe37\ufe37 \ufe38 1st stage ) C\ufe38\ufe37\ufe37\ufe38 2nd stage\nThis arrangement can be used to reduce the width of the synapse shifters and of the adder tree by sharing one common shifter after the adder tree as Figure 7a shows. A design parameter, L, defines the number of bits controlling the synapse shifters. Meaning the design can process oneffsets which differ by less than 2L in a single cycle. This reduces the size of the synapse shifters and reduces the size of the adder tree to support terms of 16+2L\u22121 bits only. As Section VI-B shows, this design reduces the area of the shifters and the adder trees which are the largest components of the PIP. Figure 7b shows an example illustrating how this PIP can handle any combination of oneffsets. Section VI-B studies the impact of L on cost and performance."}, {"heading": "E. Per-Column Neuron Lane Synchronization", "text": "The pallet neuron lane synchronization scheme of Section V-A4 is one of many possible synchronization schemes. Finer-grain neuron lane synchronization schemes are possible leading to higher performance albeit at a cost. This section presents per column neuron lane synchronization, an appealing scheme that, as Section VI-C shows, enhances performance at little additional cost.\nHere each PIP column operates independently but all the PIPs along the same column wait for the neuron with the most essential bits before proceeding to the next neuron brick. Since the PIPs along the same column operate in sync, they all process one set of 16 synapse bricks which can be read using the existing SB interface. However, given that different PIP columns operate now out-of-sync, the SB would be read a higher number of times and become a bottleneck.\nThere are two concerns: 1) different PIP columns may need to perform two independent SB reads while there are only one SB port and one common bus connecting the PIP array to the SB, and 2) there will be repeat accesses to SB that will increase SB energy, while the SB is already a major contribution of energy consumption. These concerns are addressed as follows: 1) only one SB access can proceed per cycle thus a PIP column may need to wait when collisions occur. This way, we do not\nneed an extra SB read port nor an extra set of 4K wires from the SB to the PIP array. 2) A set of SRAM registers, or synapse set registers (SSRs) are introduced in front of the SB each holding a recently read set of 16 synapse bricks. Since all PIP columns will eventually need the same set of synapse bricks, temporarily buffering them avoids fetching them repeatedly from the SB. Once a synapse set has been read into an SSR, it stays there until all PIP columns have copied it (a 4-bit down counter is sufficient for tracking how many PIP columns have yet to read the synapse set). This policy guarantees that the SB is accessed the same number of times as in DaDN. However, stalls may incur as a PIP column has to be able to store a new set of synapses into an SSR when it reads it from the SB. Figure 8 shows an example. Section VI-C evaluates this design.\nSince each neuron lane advances independently, in the worst case, the dispatcher may need to fetch 16 independent neuron bricks each from a different pallet. The Dispatcher can buffer those pallets to avoid rereading NM, which would, at worst, require a 256 pallet buffer. However, given that the number SSRs restricts how far apart the PIP columns can be, and since Section VI-C shows that only one SSR is sufficient, a two pallet buffer in the dispatcher is all that is needed."}, {"heading": "F. The Role of Software", "text": "PRA enables an additional dimension upon which hardware and software can attempt to further boost performance and energy efficiency, that of controlling the essential neuron value content. This work investigates a software guided approach where the precision requirements of each layer are used to zero out a number of prefix and suffix bits at the output of each layer. Using the profiling method of Judd et al., [2], software communicates the precisions needed by each layer as meta-data. The hardware trims the output neurons before writing them to NM using AND gates and precision derived bit masks."}, {"heading": "VI. EVALUATION", "text": "The performance, area and energy efficiency of Pragmatic is compared against DaDN [3] and Stripes [4], two stateof-the-art DNN accelerators. DaDN is the fastest bit-parallel accelerator proposed to date that processes all neuron regardless of theirs values, and STR improves upon DaDN by exploiting the per layer precision requirements of DNNs. Cnvlutin improves upon DaDN by skipping most zero-valued neurons [11], however, Stripes has been shown to outperform it.\nThe rest of this section is organized as follows: Section VI-A presents the the experimental methodology. Sections VI-B and VI-C explore the PRA design space considering respectively single- and 2-stage shifting configurations, and column synchronization. Section VI-D reports energy efficiency for the best configuration. Section VI-E analyzes the contribution of the software provided precisions. Finally, Section VI-F reports performance for designs using an 8-bit quantized representation."}, {"heading": "A. Methodology", "text": "All systems were modelled using the same methodology for consistency. A custom cycle-accurate simulator models execution time. Computation was scheduled such that all designs see the same reuse of synapses and thus the same SB read energy. To estimate power and area, all designs were synthesized with the Synopsis Design Compiler [15] for a TSMC 65nm library. The NBin and NBout SRAM buffers were modelled using CACTI [16]. The eDRAM area and energy were modelled with Destiny [17]. To compare against STR, the per layer numerical representation requirements reported in Table II were found using the methodology of Judd et al. [4]. All PRA configurations studied exploit software provided precisions as per Section V-F. Section VI-E analyzes the impact of this information on overall performance. All performance measurements are for the convolutional layers only which account for more than 92% of the overall execution time in DaDN [3]. PRA does not affect the execution time of the remaining layers."}, {"heading": "B. Single- and 2-stage Shifting", "text": "This section evaluates the single-stage shifting PRA configuration of Sections V-A\u2013 V-B , and the 2-stage shifting\nvariants of Section V-D. Section VI-B1 reports performance while Section VI-B2 reports area and power. In this section, All PRA systems use pallet synchronization.\n1) Performance:: Figure 9 shows the performance of STR (leftmost bars) and of PRA variants relative to DaDN. The PRA systems are labelled with the number of bits used to operate the first-stage, synapse shifters, e.g., the synapse shifters of \u201c2-bit\u201d , or PRA2b, are able to shift to four bit positions (0\u20133). \u201c4-bit\u201d or PRA4b, is the single-stage Pragmatic, or PRAsingle of Sections V-A\u2013 V-B whose synapse shifters can shift to 16 bit positions (0\u201315). It has no second stage shifter.\nPRAsingle improves performance by 2.59\u00d7 on average over DaDN compared to the 1.85\u00d7 average improvement with STR. Performance improvements over DaDN vary from 2.11\u00d7 for VGG19 to 2.97\u00d7 for VGGM. As expected the 2-stage PRA variants offer slightly lower performance than PRAsingle, however, performance with PRA2b and PRA3b is always within 0.2% of PRAsingle. Even PRA0b which does not include any synapse shifters outperforms STR by 20% on average. Given a set of oneffsets, PRA0b will accommodate the minimum nonzero oneffset per cycle via its second level shifter.\n2) Area and Power:: Table III shows the absolute and relative to DaDN area and power. Two area measurements are reported: 1) for the unit excluding the SB, NBin and NBout memory blocks, and 2) for the whole chip comprising 16 units and all memory blocks. Since SB and NM dominate chip area,\nthe per area area overheads Given the performance advantage of PRA, the area and power overheads are justified. PRA2b is particularly appealing as its overall area cost over BASE is only 1.35\u00d7 and its power 2.03\u00d7 while its performance is 2.59\u00d7 on average. Accordingly, we restrict attention to this configuration in the rest of this evaluation."}, {"heading": "C. Per-column synchronization", "text": "1) Performance:: Figure 10 reports the performance for PRA2b with column synchronization and as a function of the number of SSRs as per Section V-E. of Stripes (first bar of each group) and Pragmatic (rest of the bars) relative to DaDN. Configuration PRAxR2b refers to a configuration using x SSRs. Even PRA1R2b boosts performance to 3.1\u00d7 on average close to the 3.45\u00d7 that is ideally possible with PRA\u221eR2b .\n2) Area and Power:: Table IV reports the area per unit, and the area and power per chip. PRA1R2b that offers most performance benefits increases chip area by only 1.35\u00d7 and power by only 2.19\u00d7 over DaDN."}, {"heading": "D. Energy Efficiency", "text": "Figure 11 shows the energy efficiency of various configurations of Pragmatic. Energy Efficiency, or simply efficiency for a system NEW relative to BASE is defined as the ratio EBASE/ENEW of the energy required by BASE to compute all of the convolution layers over that of NEW. For the selected networks, STR is 16% more efficient than DaDN. The power overhead of PRAsingle (PRA4b) is more than the\nspeedup resulting in a circuit that is 5% less efficient than DaDN. PRA2b reduces that power overhead while maintaining performance yielding an efficiency of 28%. PRA1R2b yields the best efficiency at 48% over DaDN."}, {"heading": "E. The Impact of Software", "text": "All PRA configurations studied thus far, used software provided per layer precisions to reduce essential bit content. PRA does not require these precisions to operate. Table V shows what fraction of the performance benefits is due to the software guidance for PRA1R2b , the best configuration studied. The results demonstrate that: 1) PRA would outperform the other architectures even without software guidance, and 2) on average, software guidance improves performance by 19% which is on par with the estimate of Section II for ideal PRA (from 10% to 8%)."}, {"heading": "F. Quantization", "text": "Figure 12 reports performance for DaDN and PRA configurations using the 8-bit quantized representation used in Tensorflow [5], [18]. This quantization uses 8 bits to specify arbitrary minimum and maximum limits per layer for the neurons and the synapses separately, and maps the 256 available 8-bit\nvalues linearly into the resulting interval. This representation has higher flexibility and better utilization than the reduced precision approach of Stripes since the range doesnt have to be symmetrical and the limits dont have to be powers of two, while still allowing straightforward multiplication of the values. The limit values are set to the maximum and the minimum neuron values for each layer and the quantization uses the recommended rounding mode.\nFigure 12 reports performance relative to DaDN for PRAsingle, PRA2b, PRA1R2b , and PRA \u221eR 2b . PRA performance benefits persist and are nearly 3.5\u00d7 for PRA1R2b . Measuring the area and energy of these designs is left for future work, however, the absolute area and energy needed by all will be lower due to the narrower representation. Moreover, given that the tile logic will occupy relatively less area for the whole chip and given that the SB and NM account for significant area and energy, the overall overheads of the PRA designs over DaDN will be lower than that measured for the 16-bit fixed-point configurations."}, {"heading": "VII. RELATED WORK", "text": "The acceleration of Deep Learning is an active area of research and has yielded numerous proposals for hardware acceleration. DaDianNao (DaDN) is the de facto standard for high-performance DNN acceleration [3]. In the interest of space, this section restricts attention to methods that are either directly related to DaDN, or that follow a value-based approach to DNN acceleration, as Pragmatic falls under this category of accelerators. Value-based accelerators exploit the properties of the values being processed to further improve performance or energy beyond what is possible by exploiting computation structure alone. Cnvlutin [11] and Stripes [4][19] are such accelerators and they have been already discussed and compared against in this work.\nPuDianNao is a hardware accelerator that supports seven machine learning algorithms including DNNs [20]. ShiDianNao is a camera-integrated low power accelerator that exploits integration to reduce communication overheads and to\nfurther improve energy efficiency [21]. Cambricon is the first instruction set architecture for Deep Learning [22]. Minerva is a highly automated software and hardware co-design approach targeting ultra low-voltage, highly-efficient DNN accelerators [14]. Eyeriss is a low power, real-time DNN accelerator that exploits zero valued neurons for memory compression and energy reduction [13]. The Efficient Inference Engine (EIE) exploits efficient neuron and synapse representations and pruning to greatly reduce communication costs, to improve energy efficiency and to boost performance by avoiding certain ineffectual computations [10][23]. EIE targets fully-connected (FC) layers and was shown to be 12\u00d7 more efficient than DaDN on FC layers, and 2\u00d7 less efficient for convolutional layers. All aforementioned accelerators use bit-parallel units. While this work has demonstrated Pragmatic as a modification of DaDN, its computation units and potentially, its general approach could be compatible with all aforementioned accelerator designs. This investigation is interesting future work. As newer network architectures like GoogLeNet, NiN and VGG19 rely less on fully connected layers, this work used DaDN as an energy efficient and high performance baseline.\nProfiling has been used to determine the precision requirements of a neural network for a hardwired implementation [24]. EoP has been exploited in general purpose hardware and other application domains. For example, Brooks et al. [25] exploit the prefix bits due to EoP to turn off parts of the datapath improving energy. Park et al. [26], use a similar approach to trade off image quality for improved energy efficiency. Neither approach directly improves performance."}, {"heading": "VIII. CONCLUSION", "text": "To the best of our knowledge Pragmatic is the first DNN accelerator that exploits not only the per layer precision requirements of DNNs but also the essential bit information content of the neuron values. While this work targeted high-performance implementations, Pragmatic\u2019s core approach should be applicable to other hardware accelerators."}], "references": [{"title": "A suggestion for a fast multiplier", "author": ["C.S. Wallace"], "venue": "IEEE Trans. Electronic Computers, vol. 13, no. 1, pp. 14\u201317, 1964.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1964}, {"title": "Reduced-Precision Strategies for Bounded Memory in Deep Neural Nets, arXiv:1511.05236v4 [cs.LG", "author": ["P. Judd", "J. Albericio", "T. Hetherington", "T. Aamodt", "N.E. Jerger", "R. Urtasun", "A. Moshovos"], "venue": "arXiv.org, 2015.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "Dadiannao: A machine-learning supercomputer", "author": ["Y. Chen", "T. Luo", "S. Liu", "S. Zhang", "L. He", "J. Wang", "L. Li", "T. Chen", "Z. Xu", "N. Sun", "O. Temam"], "venue": "Microarchitecture (MICRO), 2014 47th Annual IEEE/ACM International Symposium on, pp. 609\u2013622, Dec 2014.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Stripes: Bit-serial Deep Neural Network Computing", "author": ["P. Judd", "J. Albericio", "A. Moshovos"], "venue": "Computer Architecture Letters, 2016.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2016}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["R.B. Girshick", "J. Donahue", "T. Darrell", "J. Malik"], "venue": "CoRR, vol. abs/1311.2524, 2013.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "Deep speech: Scaling up end-to-end speech recognition", "author": ["A.Y. Hannun", "C. Case", "J. Casper", "B.C. Catanzaro", "G. Diamos", "E. Elsen", "R. Prenger", "S. Satheesh", "S. Sengupta", "A. Coates", "A.Y. Ng"], "venue": "CoRR, vol. abs/1412.5567, 2014.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Dark silicon and the end of multicore scaling", "author": ["H. Esmaeilzadeh", "E. Blem", "R. St. Amant", "K. Sankaralingam", "D. Burger"], "venue": "Proceedings of the 38th Annual International Symposium on Computer Architecture, ISCA \u201911, (New York, NY, USA), pp. 365\u2013376, ACM, 2011.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Bit-serial multipliers and squarers", "author": ["P. Ienne", "M.A. Viredaz"], "venue": "IEEE Transactions on Computers, vol. 43, no. 12, pp. 1445\u20131450, 1994.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1994}, {"title": "EIE: Efficient Inference Engine on Compressed Deep Neural Network", "author": ["S. Han", "X. Liu", "H. Mao", "J. Pu", "A. Pedram", "M.A. Horowitz", "W.J. Dally"], "venue": "arXiv:1602.01528 [cs], Feb. 2016. arXiv: 1602.01528.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2016}, {"title": "Cnvlutin: Ineffectual-neuron-free deep neural network computing", "author": ["J. Albericio", "P. Judd", "T. Hetherington", "T. Aamodt", "N.E. Jerger", "A. Moshovos"], "venue": "2016 IEEE/ACM International Conference on Computer Architecture (ISCA), 2016.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["V. Nair", "G.E. Hinton"], "venue": "Proceedings of the 27th International Conference on Machine Learning (ICML-10), pp. 807\u2013814, 2010.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Eyeriss: An Energy-Efficient Reconfigurable Accelerator for Deep Convolutional Neural Networks", "author": ["Chen", "Yu-Hsin", "Krishna", "Tushar", "Emer", "Joel", "Sze", "Vivienne"], "venue": "IEEE International Solid-State Circuits Conference, ISSCC 2016, Digest of Technical Papers, pp. 262\u2013263, 2016.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2016}, {"title": "Minerva: Enabling lowpower, highly-accurate deep neural network accelerators", "author": ["B. Reagen", "P. Whatmough", "R. Adolf", "S. Rama", "H. Lee", "S.K. Lee", "J.M. Hernndez-Lobato", "G.-Y. Wei", "D. Brooks"], "venue": "International Symposium on Computer Architecture, 2016.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "Destiny: A tool for modeling emerging 3d nvm and edram caches", "author": ["M. Poremba", "S. Mittal", "D. Li", "J. Vetter", "Y. Xie"], "venue": "Design, Automation Test in Europe Conference Exhibition (DATE), 2015, pp. 1543\u20131546, March 2015.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "Stripes: Bit-serial Deep Neural Network Computing", "author": ["P. Judd", "J. Albericio", "T. Hetherington", "T. Aamodt", "A. Moshovos"], "venue": "Proceedings of the 49th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-49, 2016.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2016}, {"title": "PuDianNao: A Polyvalent Machine Learning Accelerator", "author": ["D. Liu", "T. Chen", "S. Liu", "J. Zhou", "S. Zhou", "O. Teman", "X. Feng", "X. Zhou", "Y. Chen"], "venue": "Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS \u201915, (New York, NY, USA), pp. 369\u2013381, ACM, 2015. PuDianNao.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "ShiDianNao: Shifting vision processing closer to the sensor", "author": ["Z. Du", "R. Fasthuber", "T. Chen", "P. Ienne", "L. Li", "T. Luo", "X. Feng", "Y. Chen", "O. Temam"], "venue": "2015 ACM/IEEE 42nd Annual International Symposium on Computer Architecture (ISCA), pp. 92\u2013104, June 2015. ShiDianNao.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2015}, {"title": "Cambricon: An instruction set architecture for neural networks", "author": ["S. Liu", "Z. Du", "J. Tao", "D. Han", "T. Luo", "Y. Xie", "Y. Chen", "T. Chen"], "venue": "2016 IEEE/ACM International Conference on Computer Architecture (ISCA), 2016.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2016}, {"title": "Deep Compression: Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman Coding", "author": ["S. Han", "H. Mao", "W.J. Dally"], "venue": "arXiv:1510.00149 [cs], Oct. 2015. arXiv: 1510.00149.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2015}, {"title": "X1000 real-time phoneme recognition VLSI using feed-forward deep neural networks", "author": ["J. Kim", "K. Hwang", "W. Sung"], "venue": "2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), pp. 7510\u20137514, May 2014.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2014}, {"title": "Dynamically exploiting narrow width operands to improve processor power and performance", "author": ["D. Brooks", "M. Martonosi"], "venue": "Proceedings of the 5th International Symposium on High Performance Computer Architecture, HPCA \u201999, (Washington, DC, USA), pp. 13\u2013, IEEE Computer Society, 1999.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1999}, {"title": "Dynamic Bit-Width Adaptation in DCT: An Approach to Trade Off Image Quality and Computation Energy", "author": ["J. Park", "J.H. Choi", "K. Roy"], "venue": "IEEE Transactions on Very Large Scale Integration (VLSI) Systems, vol. 18, pp. 787\u2013793, May 2010.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "The source of these ineffectual computations is best understood in the context of conventional multipliers which generate internally multiple terms, that is, products of the multiplicand and powers of two, which added together produce the final product [1].", "startOffset": 253, "endOffset": 256}, {"referenceID": 1, "context": ", [2].", "startOffset": 2, "endOffset": 5}, {"referenceID": 2, "context": "6x over the DaDiaNao (DaDN) accelerator [3] and by 1.", "startOffset": 40, "endOffset": 43}, {"referenceID": 3, "context": "4x over STR [4].", "startOffset": 12, "endOffset": 15}, {"referenceID": 4, "context": "Deep neural networks (DNNs) have become the state-ofthe-art technique in many recognition tasks such as object [6] and speech recognition [7].", "startOffset": 111, "endOffset": 114}, {"referenceID": 5, "context": "Deep neural networks (DNNs) have become the state-ofthe-art technique in many recognition tasks such as object [6] and speech recognition [7].", "startOffset": 138, "endOffset": 141}, {"referenceID": 2, "context": "Yet, the need for even more sophisticated DNNs demands even higher performance and energy efficiency motivating special purpose architectures such as the state-of-the-art DaDianNao (DaDN) [3].", "startOffset": 188, "endOffset": 191}, {"referenceID": 6, "context": "With power limiting modern high-performance designs, achieving better energy efficiency is essential can enable further advances [8].", "startOffset": 129, "endOffset": 132}, {"referenceID": 2, "context": "DNNs comprise a pipeline of layers where more than 92% of the processing time is spent in convolutional layers [3], which this work targets.", "startOffset": 111, "endOffset": 114}, {"referenceID": 2, "context": "DNN hardware typically uses either 16-bit fixed-point [3] or quantized 8-bit numbers [5] and bit-parallel compute units.", "startOffset": 54, "endOffset": 57}, {"referenceID": 1, "context": "Since the actual precision requirements vary considerably across DNN layers [2], typical DNN hardware ends up processing an excess of bits when processing these inner products [4].", "startOffset": 76, "endOffset": 79}, {"referenceID": 3, "context": "Since the actual precision requirements vary considerably across DNN layers [2], typical DNN hardware ends up processing an excess of bits when processing these inner products [4].", "startOffset": 176, "endOffset": 179}, {"referenceID": 7, "context": "Recent work, Stripes (STR) uses serial-parallel multiplication [9] to avoid processing these zero prefix and suffix bits [4] yielding performance and energy benefits.", "startOffset": 63, "endOffset": 66}, {"referenceID": 3, "context": "Recent work, Stripes (STR) uses serial-parallel multiplication [9] to avoid processing these zero prefix and suffix bits [4] yielding performance and energy benefits.", "startOffset": 121, "endOffset": 124}, {"referenceID": 0, "context": "The terms and their sum can be calculated concurrently to reduce latency [1].", "startOffset": 73, "endOffset": 76}, {"referenceID": 2, "context": "Table V reports the essential bit content of the neuron stream of state-of-the-art DNNs for two commonly used fixed length representations: 1) 16-bit fixed-point of DaDianNao [3], 2) 8-bit quantized of Tensorflow [5].", "startOffset": 175, "endOffset": 178}, {"referenceID": 8, "context": "Two measurements are presented per representation: over all neuron values (\u201cAll\u201d), and over the non-zero neurons (\u201cNZ\u201d) as accelerators that can skip zero neurons for fixed-point representations have been recently proposed [10], [11].", "startOffset": 223, "endOffset": 227}, {"referenceID": 9, "context": "Two measurements are presented per representation: over all neuron values (\u201cAll\u201d), and over the non-zero neurons (\u201cNZ\u201d) as accelerators that can skip zero neurons for fixed-point representations have been recently proposed [10], [11].", "startOffset": 229, "endOffset": 233}, {"referenceID": 10, "context": "The measurements are consistent with the neuron values following a normal distribution centered at 0, and then being filtered by a rectifier linear unit (ReLU) function [12].", "startOffset": 169, "endOffset": 173}, {"referenceID": 3, "context": "Stripes [4], tackles the excess of precision, exploiting the variability in numerical precision DNNs requirements to increase performance by processing the neurons bit-serially.", "startOffset": 8, "endOffset": 11}, {"referenceID": 2, "context": "16-bit Fixed-Point Representation: The following computing engines are considered: 1) baseline representative of DaDN using 16-bit fixed-point bit-parallel units [3], 2) a hypothetical enhanced baseline ZN, that can skip all zero valued neurons,", "startOffset": 162, "endOffset": 165}, {"referenceID": 9, "context": "3) Cnvlutin (CVN) a practical design that can skip zero value neurons for all but the first layer [11], 4) STR that avoids EoP (see Table II, Section VI-A) [4], 5) an ideal, softwaretransparent PRA, PRA-fp16 that processes only the essential neuron bits, and 6) an ideal PRA, PRA-red, where software communicates in advance how many prefix and suffix bits can be zeroed out after each layer (see Section V-F).", "startOffset": 98, "endOffset": 102}, {"referenceID": 3, "context": "3) Cnvlutin (CVN) a practical design that can skip zero value neurons for all but the first layer [11], 4) STR that avoids EoP (see Table II, Section VI-A) [4], 5) an ideal, softwaretransparent PRA, PRA-fp16 that processes only the essential neuron bits, and 6) an ideal PRA, PRA-red, where software communicates in advance how many prefix and suffix bits can be zeroed out after each layer (see Section V-F).", "startOffset": 156, "endOffset": 159}, {"referenceID": 8, "context": "In summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4].", "startOffset": 93, "endOffset": 97}, {"referenceID": 9, "context": "In summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4].", "startOffset": 99, "endOffset": 103}, {"referenceID": 11, "context": "In summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4].", "startOffset": 105, "endOffset": 109}, {"referenceID": 12, "context": "In summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4].", "startOffset": 111, "endOffset": 115}, {"referenceID": 3, "context": "In summary, this section corroborated past observations that: a) many neuron values are zero [10], [11], [13], [14], and b) only close to a half of the computations performed traditionally is needed if numerical precision is properly adjusted [4].", "startOffset": 243, "endOffset": 246}, {"referenceID": 3, "context": "b) Bit-serial unit with equivalent throughput (Stripes[4]).", "startOffset": 54, "endOffset": 57}, {"referenceID": 2, "context": "[3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "This allows PRA to reuse STR\u2019s approach for fetching the next pallet from the single-ported NM [4].", "startOffset": 95, "endOffset": 98}, {"referenceID": 3, "context": "PRA uses the same dispatcher design as STR [4].", "startOffset": 43, "endOffset": 46}, {"referenceID": 1, "context": ", [2], software communicates the precisions needed by each layer as meta-data.", "startOffset": 2, "endOffset": 5}, {"referenceID": 2, "context": "The performance, area and energy efficiency of Pragmatic is compared against DaDN [3] and Stripes [4], two stateof-the-art DNN accelerators.", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "The performance, area and energy efficiency of Pragmatic is compared against DaDN [3] and Stripes [4], two stateof-the-art DNN accelerators.", "startOffset": 98, "endOffset": 101}, {"referenceID": 9, "context": "Cnvlutin improves upon DaDN by skipping most zero-valued neurons [11], however, Stripes has been shown to outperform it.", "startOffset": 65, "endOffset": 69}, {"referenceID": 13, "context": "The eDRAM area and energy were modelled with Destiny [17].", "startOffset": 53, "endOffset": 57}, {"referenceID": 3, "context": "[4].", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "All performance measurements are for the convolutional layers only which account for more than 92% of the overall execution time in DaDN [3].", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "DaDianNao (DaDN) is the de facto standard for high-performance DNN acceleration [3].", "startOffset": 80, "endOffset": 83}, {"referenceID": 9, "context": "Cnvlutin [11] and Stripes [4][19] are such accelerators and they have been already discussed and compared against in this work.", "startOffset": 9, "endOffset": 13}, {"referenceID": 3, "context": "Cnvlutin [11] and Stripes [4][19] are such accelerators and they have been already discussed and compared against in this work.", "startOffset": 26, "endOffset": 29}, {"referenceID": 14, "context": "Cnvlutin [11] and Stripes [4][19] are such accelerators and they have been already discussed and compared against in this work.", "startOffset": 29, "endOffset": 33}, {"referenceID": 15, "context": "PuDianNao is a hardware accelerator that supports seven machine learning algorithms including DNNs [20].", "startOffset": 99, "endOffset": 103}, {"referenceID": 16, "context": "ShiDianNao is a camera-integrated low power accelerator that exploits integration to reduce communication overheads and to further improve energy efficiency [21].", "startOffset": 157, "endOffset": 161}, {"referenceID": 17, "context": "Cambricon is the first instruction set architecture for Deep Learning [22].", "startOffset": 70, "endOffset": 74}, {"referenceID": 12, "context": "Minerva is a highly automated software and hardware co-design approach targeting ultra low-voltage, highly-efficient DNN accelerators [14].", "startOffset": 134, "endOffset": 138}, {"referenceID": 11, "context": "Eyeriss is a low power, real-time DNN accelerator that exploits zero valued neurons for memory compression and energy reduction [13].", "startOffset": 128, "endOffset": 132}, {"referenceID": 8, "context": "The Efficient Inference Engine (EIE) exploits efficient neuron and synapse representations and pruning to greatly reduce communication costs, to improve energy efficiency and to boost performance by avoiding certain ineffectual computations [10][23].", "startOffset": 241, "endOffset": 245}, {"referenceID": 18, "context": "The Efficient Inference Engine (EIE) exploits efficient neuron and synapse representations and pruning to greatly reduce communication costs, to improve energy efficiency and to boost performance by avoiding certain ineffectual computations [10][23].", "startOffset": 245, "endOffset": 249}, {"referenceID": 19, "context": "Profiling has been used to determine the precision requirements of a neural network for a hardwired implementation [24].", "startOffset": 115, "endOffset": 119}, {"referenceID": 20, "context": "[25] exploit the prefix bits due to EoP to turn off parts of the datapath improving energy.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[26], use a similar approach to trade off image quality for improved energy efficiency.", "startOffset": 0, "endOffset": 4}], "year": 2016, "abstractText": "We quantify a source of ineffectual computations when processing the multiplications of the convolutional layers in Deep Neural Networks (DNNs) and propose Pragmatic (PRA), an architecture that exploits it improving performance and energy efficiency. The source of these ineffectual computations is best understood in the context of conventional multipliers which generate internally multiple terms, that is, products of the multiplicand and powers of two, which added together produce the final product [1]. At runtime, many of these terms are zero as they are generated when the multiplicand is combined with the zero-bits of the multiplicator. While conventional bit-parallel multipliers calculate all terms in parallel to reduce individual product latency, PRA calculates only the non-zero terms using a) on-thefly conversion of the multiplicator representation into an explicit list of powers of two, and b) bit-parallel multplicand/bit-serial multiplicator processing units. PRA exploits two sources of ineffectual computations: 1) the aforementioned zero product terms which are the result of the lack of explicitness in the multiplicator representation, and 2) the excess in the representation precision used for both multiplicants and multiplicators, e.g., [2]. Measurements demonstrate that for the convolutional layers, a straightforward variant of PRA improves performance by 2.6x over the DaDiaNao (DaDN) accelerator [3] and by 1.4x over STR [4]. Similarly, PRA improves energy efficiency by 28% and 10% on average compared to DaDN and STR. An improved cross lane synchronization scheme boosts performance improvements to 3.1x over DaDN. Finally, Pragmatic benefits persist even with an 8-bit quantized representation [5].", "creator": "LaTeX with hyperref package"}}}