{"id": "1610.08445", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Oct-2016", "title": "New Liftable Classes for First-Order Probabilistic Inference", "abstract": "Statistical relational models provide compact encodings of probabilistic dependencies in relational domains, but result in highly intractable graphical models. The goal of lifted inference is to carry out probabilistic inference without needing to reason about each individual separately, by instead treating exchangeable, undistinguished objects as a whole. In this paper, we study the domain recursion inference rule, which, despite its central role in early theoretical results on domain-lifted inference, has later been believed redundant and that is, more efficiently and efficiently with smaller errors than with higher-value domain-lifted inference.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Wed, 26 Oct 2016 18:13:42 GMT  (186kb,D)", "http://arxiv.org/abs/1610.08445v1", "Accepted at NIPS-2016. 22 pages, 1 figure"]], "COMMENTS": "Accepted at NIPS-2016. 22 pages, 1 figure", "reviews": [], "SUBJECTS": "cs.AI stat.ML", "authors": ["seyed mehran kazemi", "angelika kimmig", "guy van den broeck", "david poole"], "accepted": true, "id": "1610.08445"}, "pdf": {"name": "1610.08445.pdf", "metadata": {"source": "CRF", "title": "New Liftable Classes for First-Order Probabilistic Inference", "authors": ["Seyed Mehran Kazemi", "Angelika Kimmig"], "emails": ["smkazemi@cs.ubc.ca", "angelika.kimmig@cs.kuleuven.be", "guyvdb@cs.ucla.edu", "poole@cs.ubc.ca"], "sections": [{"heading": "1 Introduction", "text": "Statistical relational learning (SRL) [8] aims at unifying logic and probability for reasoning and learning in noisy domains, described in terms of individuals (or objects), and the relationships between them. Statistical relational models [10], or template-based models [18] extend Bayesian and Markov networks with individuals and relations, and compactly describe probabilistic dependencies among them. These models encode exchangeability among the objects: individuals that we have the same information about are treated similarly.\nA key challenge with SRL models is the fact that they represent highly intractable, densely connected graphical models, typically with millions of random variables. The aim of lifted inference [23] is to carry out probabilistic inference without needing to reason about each individual separately, by instead treating exchangeable, undistinguished objects as a whole. Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models. These basic exact inference techniques have applications in (tractable) lifted learning [32], where the main task is to efficiently compute partition functions, and in variational and over-symmetric approximations [29, 33]. Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 0.\n08 44\n5v 1\n[ cs\n.A I]\n2 6\nO ct\nThe theoretical study of lifted inference began with the complexity notion of domain-lifted inference [31] (a concept similar to data complexity in databases). Inference is domain-lifted when it runs in time polynomial in the number of individuals in the domain. By identifying liftable classes of models, guaranteeing domain-lifted inference, one can characterize the theoretical power of the various inference rules. For example, the class FO2, encoding dependencies among pairs of individuals (i.e., two logical variables), is liftable [30]. Kazemi and Poole [15] introduce a liftable class called recursively unary, capturing hierarchical simplification rules. Beame et al. [3] identify liftable classes of probabilistic database queries. Such results elevate the specific inference rules and examples to a general principle, and bring lifted inference in line with complexity and database theory [3].\nThis paper studies the domain recursion inference rule, which applies the principle of induction on the domain size. The rule makes one individual A in the domain explicit. Afterwards, the other inference rules simplify the SRL model up to the point where it becomes identical to the original model, except the domain size has decreased. Domain recursion was introduced by Van den Broeck [31] and was central to the proof that FO2 is liftable. However, later work showed that simpler rules suffice to capture FO2 [27], and the domain recursion rule was forgotten.\nWe show that domain recursion is more powerful than expected, and can lift models that are otherwise not amenable to domain-lifted inference. This includes an open problem by Beame et al. [3], asking for an inference rule for a logical sentence called S4. It also includes the symmetric transitivity model, and an encoding of the birthday paradox in first-order logic. There previously did not exist any efficient algorithm to compute the partition function of these SRL models, and we obtain exponential speedups. Next, we prove that domain recursion supports its own large classes of liftable models S 2FO2 subsuming FO2, and S 2RU subsuming recursive unary. All existing exact lifted inference algorithms (e.g., [11, 15, 28]) resort to grounding the theories in S 2FO2 or S 2RU that are not in FO2 or recursively unary, and require time exponential in the domain size.\nThese results will be established using the weighted first-order model counting (WFOMC) formulation of SRL models [28]. WFOMC is close to classical first-order logic, and it can encode many other SRL models, including Markov logic [24], parfactor graphs [23], some probabilistic programs [7], relational Bayesian networks [12], and probabilistic databases [26]. It is a basic specification language that simplifies the development of lifted inference algorithms [3, 11, 28]."}, {"heading": "2 Background and Notation", "text": "A population is a set of constants denoting individuals (or objects). A logical variable (LV) is typed with a population. We represent LVs with lower-case letters, constants with upper-case letters, the population associated with a LV x with \u2206x, and its cardinality with |\u2206x|.That is, a population \u2206x is a set of constants {X1, . . . , Xn}, and we use x \u2208 \u2206x as a shorthand for instantiating x with one of the Xi. A parametrized random variable (PRV) is of the form F(t1, . . . , tk) where F is a predicate symbol and each ti is a LV or a constant. A unary PRV contains exactly one LV and a binary PRV contains exactly two LVs. A grounding of a PRV is obtained by replacing each of its LVs x by one of the individuals in \u2206x.\nA literal is a PRV or its negation. A formula \u03d5 is a literal, a disjunction \u03d51 \u2228 \u03d52 of formulas, a conjunction \u03d51 \u2227 \u03d52 of formulas, or a quantified formula \u2200x \u2208 \u2206x : \u03d5(x) or \u2203x \u2208 \u2206x : \u03d5(x) where x appears in \u03d5(x). A sentence is a formula with all LVs quantified. A clause is a formula not using conjunction. A theory is a set of sentences. A theory is clausal if all its sentences are clauses. An interpretation is an assignment of values to all ground PRVs in a theory. An interpretation I is a model of a theory T , I |= T , if given its value assignments, all sentences in T evaluate to True.\nLet F(T ) be the set of predicate symbols in theory T , and \u03a6 : F(T )\u2192 R and \u03a6 : F(T )\u2192 R be two functions that map each predicate F to weights for ground PRVs F(C1, . . . , Ck) assigned True and False respectively. For an interpretation I of T , let \u03c8True be the set of ground PRVs assigned True, and \u03c8False the ones assigned False. The weight of I is given by \u03c9(I) =\n\u220f F(C1,...,Ck)\u2208\u03c8True \u03a6(F) \u00b7\u220f\nF(C1,...,Ck)\u2208\u03c8False \u03a6(F). Given a theory T and two functions \u03a6 and \u03a6, the weighted first-order model count (WFOMC) of the theory given \u03a6 and \u03a6 is: WFOMC(T |\u03a6,\u03a6) = \u2211 I|=T \u03c9(I).\nIn this paper, we assume that all theories are clausal and do not contain existential quantifiers. The latter can be achieved using the skolemization procedure of Van den Broeck et al. [30], which\ntransforms a theory T with existential quantifiers into a theory T \u2032 without existential quantifiers that has the same weighted model count, in time polynomial in the size of T . That is, our theories are sets of finite-domain, function-free first-order clauses whose LVs are all universally quantified (and typed with a population). Furthermore, when a clause mentions two LVs x1 and x2 with the same population \u2206x, or a LV x with population \u2206x and a constant C \u2208 \u2206x, we assume they refer to different individuals.1\nExample 1. Consider the theory \u2200x \u2208 \u2206x : \u00acSmokes(x) \u2228 Cancer(x) having only one clause and assume \u2206x = {A,B}. The assignment Smokes(A) = True,Smokes(B) = False,Cancer(A) = True,Cancer(B) = True is a model. Assuming \u03a6(Smokes) = 0.2, \u03a6(Cancer) = 0.8, \u03a6(Smokes) = 0.5 and \u03a6(Cancer) = 1.2, the weight of this model is 0.2 \u00b7 0.5 \u00b7 0.8 \u00b7 0.8. This theory has eight other models. The WFOMC can be calculated by summing the weights of all nine models."}, {"heading": "2.1 Converting Inference for SRL Models into WFOMC", "text": "For many SRL models, (lifted) inference can be converted into a WFOMC problem. As an example, consider a Markov logic network (MLN) [24] with weighted formulae (w1 : F1, . . . , wk : Fk). For every weighted formula wi : Fi of this MLN, let theory T have a sentence Auxi \u21d4 Fi such that Auxi is a predicate having all LVs appearing in Fi. Assuming \u03a6(Auxi) = exp(wi), and \u03a6 and \u03a6 are 1 for the other predicates, the partition function of the MLN is equal to WFOMC(T )."}, {"heading": "2.2 Calculating the WFOMC of a Theory", "text": "We now describe a set of rules R that can be applied to a theory to find its WFOMC efficiently; for more details, readers are directed to [28], [22] or [11]. We use the following theory T with two clauses and four PRVs (S(x,m), R(x,m), T(x) and Q(x)) as our running example:\n\u2200x \u2208 \u2206x,m \u2208 \u2206m : Q(x) \u2228 R(x,m) \u2228 S(x,m) \u2200x \u2208 \u2206x,m \u2208 \u2206m : S(x,m) \u2228 T(x)\nLifted Decomposition Assume we ground x in T . Then the clauses mentioning an arbitrary Xi \u2208 \u2206x are \u2200m \u2208 \u2206m : Q(Xi) \u2228 R(Xi,m) \u2228 S(Xi,m) and \u2200m \u2208 \u2206m : S(Xi,m) \u2228 T(Xi). These clauses are totally disconnected from clauses mentioning Xj \u2208 \u2206x (j 6= i), and are the same up to renaming Xi to Xj . Given the exchangeability of the individuals, we can calculate the WFOMC of only the clauses mentioning Xi and raise the result to the power of the number of connected components (|\u2206x|). Assuming T1 is the theory that results from substituting x with Xi, WFOMC(T ) = WFOMC(T1) |\u2206x|.\nCase-Analysis The WFOMC of T1 can be computed by a case-analysis over different assignments of values to a ground PRV, e.g., Q(Xi). Let T2 and T3 represent T1 \u2227 Q(Xi) and T1 \u2227 \u00acQ(Xi) respectively. Then, WFOMC(T1) = WFOMC(T2) + WFOMC(T3). We follow the process for T3 (the process for T2 will be similar) having clauses \u00acQ(Xi), \u2200m \u2208 \u2206m : Q(Xi) \u2228 R(Xi,m) \u2228 S(Xi,m) and \u2200m \u2208 \u2206m : S(Xi,m) \u2228 T(Xi).\nUnit Propagation When a clause in the theory has only one literal, we can propagate the effect of this clause through the theory and remove it2. In T3, \u00acQ(Xi) is a unit clause. Having this unit clause, we can simplify the second clause and get the theory T4 having clauses \u2200m \u2208 \u2206m : R(Xi,m) \u2228 S(Xi,m) and \u2200m \u2208 \u2206m : S(Xi,m) \u2228 T(Xi).\nLifted Case-Analysis Case-analysis can be done for PRVs having one logical variable in a lifted way. Consider the S(Xi,m) in T4. Due to the exchangeability of the individuals, we do not have to consider all possible assignments to all ground PRVs of S(Xi,m), but only the ones where the number of individuals M \u2208 \u2206m for which S(Xi,M) is True (or equivalently False) is different. This means considering |\u2206m|+ 1 cases suffice, corresponding to S(Xi,M) being True for exactly j = 0, . . . , |\u2206m| individuals. Note that we must multiply by (|\u2206m| j ) to account for the number of ways one can select j out of |\u2206m| individuals. Let T4j represent T4 with two more clauses: 1Equivalently, we can disjoin x1 6= x2 or x 6= C to the clause. 2Note that unit propagation may remove clauses and random variables from the theory. To account for them, smoothing multiplies the WFOMC by 2#rv , where #rv represents the number of removed variables.\n\u2200m \u2208 \u2206mT : S(Xi,m) and \u2200m \u2208 \u2206mF : \u00acS(Xi,m), where \u2206mT represents the j individuals in \u2206m for which S(Xi,M) is True, and \u2206mF represents the other |\u2206m| \u2212 j individuals. Then WFOMC(T4) = \u2211\u2206m j=0 ( \u2206m j ) WFOMC(T4j).\nShattering In T4j , the individuals in \u2206m are no longer exchangeable: we know different things about those in \u2206mT and those in \u2206mF . We need to shatter every clause having individuals coming from \u2206m to make the theory exchangeable. To do so, the clause \u2200m \u2208 \u2206m : R(Xi,m)\u2228S(Xi,m) in T4j must be shattered to \u2200m \u2208 \u2206mT : R(Xi,m)\u2228S(Xi,m) and \u2200m \u2208 \u2206mF : R(Xi,m)\u2228S(Xi,m) (and similarly for the other formulae). The shattered theory T5j after unit propagation will have clauses \u2200m \u2208 \u2206mF : R(Xi,m) and \u2200m \u2208 \u2206mF : T(Xi).\nDecomposition, Caching, and Grounding In T5j , the two clauses have different PRVs, i.e., they are disconnected. In such cases, we apply decomposition, i.e., find the WFOMC of each connected component separately and return the product. The WFOMC of the theory can be found by continuing to apply the above rules. In all the above steps, after finding the WFOMC of each (sub-)theory, we store the results in a cache so we can reuse them if the same WFOMC is required again. By following these steps, one can find the WFOMC of many theories in polynomial time. However, if we reach a point where none of the above rules are applicable, we ground one of the populations which makes the process exponential in the number of individuals."}, {"heading": "2.3 Domain-Liftability", "text": "Definition 1. A theory is domain-liftable [31] if calculating its WFOMC is polynomial in |\u2206x1 |, |\u2206x2 |, . . . , |\u2206xk | where x1, x2, . . . , xk represent the LVs in the theory. A class C of theories is domain-liftable if \u2200T \u2208 C, T is domain-liftable.\nSo far, two classes of domain-liftable theories have been recognized: FO2 [30, 31] and recursively unary [15, 22].\nDefinition 2. A theory is in FO2 if all its clauses have up to two LVs. Definition 3. Let T be a theory. T is recursively unary (RU) if for every theory T \u2032 resulting from applying rules inR except lifted case-analysis to T until no more rules apply, there exists some unary PRV in T \u2032 and a generic case of lifted case-analysis on this unary PRV is RU.\nDefinition 4. Let C be a domain-liftable class of theories. We define C to be linear if for any given theory T , determining whether T \u2208 C (i.e. membership checking) can be done in time linear in the size of T , and to be domain size independent if determining whether T \u2208 C is independent of the size of the domains in T . Note that a linear class is domain size independent.\nGiven the above definitions, FO2 is linear. Membership checking can be done for it by a single pass through the theory, counting the number of LVs of each sentence. RU is not linear as its membership checking may be exponential in the size of theory, but it is domain size independent as none of the operations it applies to the input theory depend on the domain sizes. FO2 offers faster membership checking than RU, but as we will show later, RU subsumes FO2. This gives rise to a trade-off between fast membership checking and modelling power for, e.g., (lifted) learning purposes."}, {"heading": "3 The Domain Recursion Rule", "text": "Van den Broeck [31] considered another rule called domain recursion in the set of rules for calculating the WFOMC of a theory. The intuition behind domain recursion is that it modifies a domain \u2206x by making one element explicit: \u2206x = \u2206x\u2032 \u222a {A} with A 6\u2208 \u2206x\u2032 . Then, by applying standard rules in R on this modified theory, the problem is reduced to a WFOMC problem on the original theory, but on a smaller domain \u2206x\u2032 . This lets us compute WFOMC using dynamic programming. We refer to R extended with the domain recursion rule asRD. Example 2. Suppose we have a theory whose only clause is \u2200x, y \u2208 \u2206p : \u00acFriend(x, y) \u2228 Friend(y, x), stating if x is friends with y, y is also friends with x. One way to calculate the WFOMC of this theory is by grounding only one individual in \u2206p and then using R. Let A be an individual in \u2206p and let \u2206p\u2032 = \u2206p \u2212 {A}. We can (using domain recursion) rewrite the theory\nas: \u2200x \u2208 \u2206p\u2032 : \u00acFriend(x,A) \u2228 Friend(A, x), \u2200y \u2208 \u2206p\u2032 : \u00acFriend(A, y) \u2228 Friend(y,A), and \u2200x, y \u2208 \u2206p\u2032 : \u00acFriend(x, y)\u2228Friend(y, x). Lifted case-analysis on Friend(p\u2032, A) and Friend(A, p\u2032), shattering and unit propagation give \u2200x, y \u2208 \u2206p\u2032 : \u00acFriend(x, y) \u2228 Friend(y, x). This theory is equivalent to our initial theory, with the only difference being that the population of people has decreased by one. By keeping a cache of the values of each sub-theory, one can verify that this process finds the WFOMC of the above theory in polynomial-time.\nNote that the theory in Example 2 is in FO2 and as proved in [27], its WFOMC can be computed without using the domain recursion rule3. This proof has caused the domain recursion rule to be forgotten, or even unknown in lifted inference community. In the next section, we revive this rule and identify a class of theories that are only domain-liftable when using the domain recursion rule."}, {"heading": "4 Domain Recursion Makes More Theories Domain-Liftable", "text": "S4 Clause: Beame et al. [3] identified a clause (S4) with four binary PRVs having the same predicate and proved that even though the rulesR in Section 2.2 cannot calculate the WFOMC of that clause, there is a polynomial-time algorithm for finding its WFOMC. They concluded that this set of rulesR for finding the WFOMC of theories does not suffice, asking for new rules to compute their theory. We prove that adding domain recursion to the set achieves this goal. Proposition 1. The theory consisting of the S4 clause \u2200x1, x2 \u2208 \u2206x, y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) \u2228 \u00acS(x1, y2) is domain-liftable usingRD.\nSymmetric Transitivity: Domain-liftable calculation of WFOMC for the transitivity formula is a long-lasting open problem. Symmetric-transitivity is easier as the number of its models corresponds to the Bell number, but solving it using general-purpose rules has been an open problem. Consider clauses \u2200x, y, z \u2208 \u2206p : \u00acF(x, y)\u2228\u00acF(y, z)\u2228 F(x, z) and \u2200x, y \u2208 \u2206p : \u00acF(x, y)\u2228 F(y, x) defining a symmetric-transitivity relation. For example, \u2206p may indicate the population of people and F may indicate friendship. Proposition 2. The symmetric-transitivity theory is domain-liftable usingRD.\nBirthday Paradox: The birthday paradox problem [2] concerns finding the probability that in a set of n randomly chosen people, a pair of them have the same birthday. A first-order encoding of this problem requires WFOMC for a theory with clauses \u2200p \u2208 \u2206p,\u2203d \u2208 \u2206d : Born(p, d), \u2200p \u2208 \u2206p, d1, d2 \u2208 \u2206d : \u00acBorn(p, d1) \u2228 \u00acBorn(p, d2), and \u2200p1, p2 \u2208 \u2206p, d \u2208 \u2206d : \u00acBorn(p1, d) \u2228 \u00acBorn(p2, d), where \u2206p and \u2206d represent the population of people and days. The first two clauses impose the condition that every person is born in exactly one day, and the third clause imposes the \"no two people are born in the same day\" query. Proposition 3. The birthday-paradox theory is domain-liftable usingRD.\n5 S2FO2 and S2RU : New Domain-Liftable Classes\nDefinition 5. Let \u03b1(S) represent a clausal theory using a single binary predicate S such that each clause has exactly two different literals of S, let \u03b1 = \u03b1(S1) \u2227 \u03b1(S2) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1(Sn) where Sis are different binary predicates, and let \u03b2 represent a theory where all clauses c \u2208 \u03b2 contain at most one Si literal, and the clauses c \u2208 \u03b2 that contain an Si literal contain no other literals with more than one LV. Then, S 2FO2 and S 2RU are the classes of theories of the form \u03b1 \u2227 \u03b2 where \u03b2 \u2208 FO2 and \u03b2 \u2208 RU respectively. Theorem 1. S 2FO2 and S 2RU are domain-liftable usingRD.\nIt can be easily verified that S 2FO2 is a linear and S 2RU is a domain size independent class. Example 3. Suppose we have a set \u2206j of jobs and a set \u2206v of volunteers. Every volunteer must be assigned to at most one job, and every job requires no more than one person. If the job involves working with gas, the assigned volunteer must be a non-smoker. And we know that smokers are most probably friends with each other. Then we will have the following first-order theory:\n3This can be done by realizing that the theory is disconnected in the grounding for every pair (A,B) of individuals and applying the lifted case-analysis.\n\u2200v1, v2 \u2208 \u2206v, j \u2208 \u2206j : \u00acAssigned(v1, j) \u2228 \u00acAssigned(v2, j) \u2200v \u2208 \u2206v, j1, j2 \u2208 \u2206j : \u00acAssigned(v, j1) \u2228 \u00acAssigned(v, j2)\n\u2200v \u2208 \u2206v, j \u2208 \u2206j : InvolvesGas(j) \u2227 Assigned(v, j)\u21d2 \u00acSmokes(v) \u2200v1, v2 \u2208 \u2206v : Aux(v1, v2)\u21d4 (Smokes(v1) \u2227 Friends(v1, v2)\u21d2 Smokes(v2))\nAux(v1, v2) is added to capture the probability assigned to the last rule. This theory is not in FO2 and not in RU and is not domain-liftable using R. However, the first two clauses are instances of \u03b1Assigned in Def. 5, the third and fourth are in FO2 (and also in RU ), and the third clause which contains Assigned(v, j) has no other PRVs with more than one LV. Therefore, this theory is in S 2FO2 (and also in S 2RU ) and domain-liftable based on Theorem 1.\nProposition 4. FO2 \u2282 RU , FO2 \u2282 S 2FO2, FO2 \u2282 S 2RU , RU \u2282 S 2RU , S 2FO2 \u2282 S 2RU ."}, {"heading": "6 Experiments and Results", "text": "In order to see the effect of using domain recursion in practice, we find the WFOMC of three theories with and without using the domain recursion rule: 1- the theory in Example 3, 2- the S4 clause, and 3- the symmetric-transitivity. We implemented the domain recursion rule in C++ and compiled the codes using the g++ compiler. We compare our results with the WFOMC-v3.0 software4. Since this software requires domain-liftable input theories, for the first theory we grounded the jobs, for the second we grounded \u2206x, and for the third we grounded \u2206p. For each of these three theories, assuming |\u2206x| = n for all LVs x in the theory, we varied n and plotted the run-time as a function of n. All experiments were done on a 2.8GH core with 4GB RAM under MacOSX. The run-times are reported in seconds. We allowed a maximum of 1000s for each run.\nObtained results can be viewed in Fig. 1. These results are consistent with our theory and indicate the clear advantage of using the domain recursion rule in practice. In Fig. 1(a), the slope of the diagram for domain recursion is approximately 4 which indicates the degree of the polynomial for the time complexity. Similar analysis can be done for the results on S4 clause and the symmetric-transitivity clause represented in Fig. 1(b), (c). The slope of the diagram in these two diagrams is around 5 and 2 respectively, indicating that the time complexity for finding the WFOMC of the S4 clause and the symmetric-transitivity theories are n5 and n2 respectively, where n shows the size of the population."}, {"heading": "7 Discussion", "text": "We can categorize the theories with respect to the domain recursion rule as: 1- theories proved to be domain-liftable using domain recursion (e.g., S4, symmetric-transitivity, and theories in S 2FO2), 2- theories that are domain-liftable using domain recursion, but we have not identified them yet, and 3- theories that are not domain-liftable even when using domain recursion. We leave discovering and characterizing the theories in category 2 and 3 as future work. But here we show that even though the theories in category 3 are not domain-liftable using domain recursion, this rule may still result in exponential speedup for these theories.\n4Available at: https://dtai.cs.kuleuven.be/software/wfomc\nConsider the (non-symmetric) transitivity rule: \u2200x, y, z \u2208 \u2206p : \u00acFriend(x, y) \u2228 \u00acFriend(y, z) \u2228 Friend(x, z). Since none of the rules in R apply to the above theory, the existing lifted inference engines ground \u2206p and calculate the weighted model count (WMC) of the ground theory. By grounding \u2206p, these engines lose great amounts of symmetry. Suppose \u2206p = {A,B,C} and assume we select Friend(A,B) and Friend(A,C) as the first two random variables for case-analysis. Due to the exchangeability of the individuals, the case where Friend(A,B) and Friend(A,C) are assigned to True and False respectively has the same WMC as the case where they are assigned to False and True. However, the current engines fail to exploit this symmetry as they consider grounded individuals non-exchangeable. By applying domain recursion to the above theory, one can exploit the symmetries of the theory. Suppose \u2206p\u2032 = \u2206p \u2212 {P}. Then we can rewrite the theory as follows:\n\u2200y, z \u2208 \u2206p\u2032 : \u00acFriend(P, y) \u2228 \u00acFriend(y, z) \u2228 Friend(P, z) \u2200x, z \u2208 \u2206p\u2032 : \u00acFriend(x, P ) \u2228 \u00acFriend(P, z) \u2228 Friend(x, z) \u2200x, y \u2208 \u2206p\u2032 : \u00acFriend(x, y) \u2228 \u00acFriend(y, P ) \u2228 Friend(x, P ) \u2200x, y, z \u2208 \u2206p\u2032 : \u00acFriend(x, y) \u2228 \u00acFriend(y, z) \u2228 Friend(x, z)\nBy applying lifted case-analysis on Friend(P, y), we do not get back the same theory with reduced population and calculating the WFOMC is still exponential. However, we only generate one branch for the case where Friend(P, y) is True only once. This branch covers both the symmetric cases mentioned above. Exploiting these symmetries reduces the time-complexity exponentially. This suggests that for any given theory, when the rules in R are not applicable one may want to try the domain recursion rule before giving up and resorting to grounding a population."}, {"heading": "8 Conclusion", "text": "We identified new classes of domain-liftable theories called S 2FO2 and S 2RU by reviving the domain recursion rule. We also demonstrated how this rule is useful for theories outside these classes. Our work opens up a future research direction for identifying and characterizing larger classes of theories that are domain-liftable using domain recursion. It also helps us get closer to finding a dichotomy between the theories that are domain-liftable and those that are not, similar to the dichotomy result of Dalvi and Suciu [6] for query answering in probabilistic databases.\nIt has been shown [15, 16] that compiling the WFOMC rules into low-level programs (e.g., C++ programs) offers (approx.) 175x speedup compared to other approaches. While compiling the previously known rules to low-level programs was straightforward, compiling the domain recursion rule to low-level programs without using recursion might be tricky as it relies on the population size of the logical variables. A future research direction would be finding if the domain recursion rule can be efficiently compiled into low-level programs, and measuring the amount of speedup it offers."}, {"heading": "9 Proofs of the Theorems, Propositions, and Lemmas", "text": ""}, {"heading": "9.1 Proof of Proposition 1", "text": "Proof. Let \u2206x\u2032 = \u2206x \u2212 {N}. Applying domain recursion on \u2206x (choosing \u2206y is analogous) gives the following shattered theory on the reduced domain \u2206x\u2032 .\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (1) \u2200x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(N, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (2) \u2200x1 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(N, y1) \u2228 S(N, y2) (3)\n\u2200y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(N, y2) \u2228 \u00acS(N, y1) \u2228 S(N, y2) (4)\nWe now reach to the standard rules R to simplify the output of domain recursion. The last clause is a tautology and can be dropped. The theory contains a unary PRV, namely S(N, y), which is a candidate for lifted case-analysis. Let \u2206yT \u2286 \u2206y be the individuals of \u2206y for which S(N, y) is\nsatisfied, and let \u2206yF = \u2206y \\\u2206yT be its complement in \u2206y . This gives \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (5) \u2200x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(N, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (6) \u2200x1 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(N, y1) \u2228 S(N, y2) (7)\n\u2200y \u2208 \u2206yT : S(N, y) (8) \u2200y \u2208 \u2206yF : \u00acS(N, y) (9)\nUnit propagation creates two independent theories: one containing the S(N, y) atoms, which is trivially liftable, and one containing the other atoms, namely\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (10) \u2200x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : \u00acS(x2, y1) \u2228 S(x2, y2) (11) \u2200x1 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) (12)\nThe last two clauses are equivalent, hence, we have\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (13) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 S(x, y2) (14)\nAfter shattering, we get four copies of the first clause:\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (15) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (16) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (17) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (18) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 S(x, y2) (19)\nThe second and third clauses are subsumed by the last clause, and can be removed:\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (20) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (21) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 S(x, y2) (22)\nLet us now consider the last clause, and ignore the first two for the time being. The last clause is actually in FO2, and the Skolemization-rewriting of reused FO2 variables [30] can be applied, for example to y2 in its second PRV. The last clause is thus replaced by\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) \u2228 \u00acA(x) (23) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) \u2228 A(x) (24) \u2200x \u2208 \u2206x\u2032 : A(x) \u2228 B(x) (25) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) \u2228 B(x) (26)\nNext, we perform lifted case-analysis on A(x\u2032). Let \u2206\u03b1 \u2286 \u2206x\u2032 be the individuals in \u2206x\u2032 for which A(x\u2032) is satisfied, and let \u2206\u03b1\u0304 = \u2206x\u2032 \\\u2206\u03b1 be its complement in \u2206x\u2032 :\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) \u2228 \u00acA(x) (27) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) \u2228 A(x) (28) \u2200x \u2208 \u2206x\u2032 : A(x) \u2228 B(x) (29) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) \u2228 B(x) (30)\n\u2200x \u2208 \u2206\u03b1 : A(x) (31) \u2200x \u2208 \u2206\u03b1\u0304 : \u00acA(x) (32)\nUnit propagation gives two independent theories: a theory containing the predicate A, which is trivially liftable, and the theory\n\u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yF : \u00acS(x, y) (33) \u2200x \u2208 \u2206\u03b1\u0304, y \u2208 \u2206yT : S(x, y) (34) \u2200x \u2208 \u2206\u03b1\u0304 : B(x) (35) \u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yT : S(x, y) \u2228 B(x) (36)\nNext, we perform atom counting on B(x\u2032). Let \u2206\u03b2 \u2286 \u2206\u03b1 be the individuals of \u2206\u03b1 for which B(x\u2032) is satisfied, and let \u2206\u03b2\u0304 = \u2206\u03b1 \\\u2206\u03b2 be its complement in \u2206\u03b1. In other words, the original domain \u2206x is now split up into four parts: \u2206x\u0304 = {N}, \u2206\u03b1\u0304, \u2206\u03b2 , and \u2206\u03b2\u0304 . This gives the theory\n\u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yF : \u00acS(x, y) (37) \u2200x \u2208 \u2206\u03b1\u0304, y \u2208 \u2206yT : S(x, y) (38) \u2200x \u2208 \u2206\u03b1\u0304 : B(x) (39) \u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yT : S(x, y) \u2228 B(x) (40)\n\u2200x \u2208 \u2206\u03b2 : B(x) (41) \u2200x \u2208 \u2206\u03b2\u0304 : \u00acB(x) (42)\nUnit propagation gives two independent theories: a theory containing the predicate B, which is trivially liftable, and the theory\n\u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yF : \u00acS(x, y) (43) \u2200x \u2208 \u2206\u03b1\u0304, y \u2208 \u2206yT : S(x, y) (44) \u2200x \u2208 \u2206\u03b2\u0304 , y \u2208 \u2206yT : S(x, y) (45)\nWe now reintroduce the first removed clause. Clause 20 has nine copies after shattering:\n\u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (46) \u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b2 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (47) \u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b2\u0304 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (48) \u2200x1 \u2208 \u2206\u03b2 , x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (49) \u2200x1 \u2208 \u2206\u03b2 , x2 \u2208 \u2206\u03b2 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (50) \u2200x1 \u2208 \u2206\u03b2 , x2 \u2208 \u2206\u03b2\u0304 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (51) \u2200x1 \u2208 \u2206\u03b2\u0304 , x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (52) \u2200x1 \u2208 \u2206\u03b2\u0304 , x2 \u2208 \u2206\u03b2 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (53) \u2200x1 \u2208 \u2206\u03b2\u0304 , x2 \u2208 \u2206\u03b2\u0304 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (54)\nUnit propagation of clauses 44 and 45 satisfies any clause that has a positive literal whose x domain is \u2206\u03b1\u0304 or \u2206\u03b2\u0304 . This removes all clauses except for\n\u2200x1 \u2208 \u2206\u03b2 , x2 \u2208 \u2206\u03b2 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (55) We now reintroduce the second removed clause. Clause 21 has four copies after shattering:\n\u2200x1 \u2208 \u2206\u03b1, x2 \u2208 \u2206\u03b1, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (56) \u2200x1 \u2208 \u2206\u03b1, x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (57) \u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b1, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (58) \u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (59)\nUnit propagation of clauses 43 satisfies any clause that has a negative literal whose x domain is \u03b1. This removes all clauses except for\n\u2200x1 \u2208 \u2206\u03b1\u0304, x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (60) Putting it all together, we have the theory\n\u2200x1, x2 \u2208 \u2206\u03b2 , y1, y2 \u2208 \u2206yT : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) (61) \u2200x1, x2 \u2208 \u2206\u03b1\u0304, y1, y2 \u2208 \u2206yF : S(x1, y1) \u2228 \u00acS(x1, y2) \u2228 \u00acS(x2, y1) \u2228 S(x1, y2) (62)\n\u2200x \u2208 \u2206\u03b1, y \u2208 \u2206yF : \u00acS(x, y) (63) \u2200x \u2208 \u2206\u03b1\u0304, y \u2208 \u2206yT : S(x, y) (64) \u2200x \u2208 \u2206\u03b2\u0304 , y \u2208 \u2206yT : S(x, y) (65)\nThese five clauses are all independent. The last three are trivially liftable. The first two are simply copies of S4 with modified domains \u2206\u03b2 , \u2206yT , \u2206\u03b1\u0304 and \u2206yF instead of \u2206x and \u2206y. However, we have that |\u2206\u03b2 | < |\u2206x|, |\u2206yT | \u2264 |\u2206y|, |\u2206\u03b1\u0304| < |\u2206x|, and |\u2206yF | \u2264 |\u2206y|. The recursion is thus guaranteed to terminate with \u2206\u03b2 = \u2206\u03b1\u0304 = \u2205. By keeping a cache of WFOMCs for all sizes of \u2206x and \u2206y , we can compute the WFOMC of S4 in PTIME."}, {"heading": "9.2 Proof of Proposition 2", "text": "Proof. Symmetric-transitivity has the following two sentences:\n\u2200x, y, z \u2208 \u2206p : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (66) \u2200x, y \u2208 \u2206p : \u00acF(x, y) \u2228 F(y, x) (67)\nAssuming \u2206q = \u2206p \u2212 {N}:\n\u2200y, z \u2208 \u2206q : \u00acF(N, y) \u2228 \u00acF(y, z) \u2228 F(N, z) (68) \u2200x, z \u2208 \u2206q : \u00acF(x,N) \u2228 \u00acF(N, z) \u2228 F(x, z) (69) \u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (70) \u2200x, y, z \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (71) \u2200y \u2208 \u2206q : \u00acF(N, y) \u2228 F(y,N) (72) \u2200x \u2208 \u2206q : \u00acF(x,N) \u2228 F(N, x) (73) \u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 F(y, x) (74)\nLifted case-analysis on F(N, q) assuming \u2206qT contains individuals in \u2206q for which F(N, q) is true and \u2206qF is the other individuals in \u2206q:\n\u2200y, z \u2208 \u2206q : \u00acF(N, y) \u2228 \u00acF(y, z) \u2228 F(N, z) (75) \u2200x, z \u2208 \u2206q : \u00acF(x,N) \u2228 \u00acF(N, z) \u2228 F(x, z) (76) \u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (77) \u2200x, y, z \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (78) \u2200y \u2208 \u2206q : \u00acF(N, y) \u2228 F(y,N) (79) \u2200x \u2208 \u2206q : \u00acF(x,N) \u2228 F(N, x) (80) \u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 F(y, x) (81) \u2200x \u2208 \u2206qT : F(N, x) (82) \u2200x \u2208 \u2206qF : \u00acF(N, x) (83)\nUnit propagation:\n\u2200y \u2208 \u2206qT , z \u2208 \u2206qF : \u00acF(y, z) (84) \u2200x \u2208 \u2206q, z \u2208 \u2206qT : \u00acF(x,N) \u2228 F(x, z) (85)\n\u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (86) \u2200x, y, z \u2208 \u2206q : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (87) \u2200y \u2208 \u2206qT : F(y,N) (88) \u2200x \u2208 \u2206qF : \u00acF(x,N) (89) \u2200x, y \u2208 \u2206q : \u00acF(x, y) \u2228 F(y, x) (90)\nShattering:\n\u2200y \u2208 \u2206qT , z \u2208 \u2206qF : \u00acF(y, z) (91) \u2200x \u2208 \u2206qT , z \u2208 \u2206qT : \u00acF(x,N) \u2228 F(x, z) (92) \u2200x \u2208 \u2206qF , z \u2208 \u2206qT : \u00acF(x,N) \u2228 F(x, z) (93) \u2200x \u2208 \u2206qT , y \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (94) \u2200x \u2208 \u2206qT , y \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (95) \u2200x \u2208 \u2206qF , y \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (96) \u2200x \u2208 \u2206qF , y \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y,N) \u2228 F(x,N) (97)\n\u2200x \u2208 \u2206qT , y \u2208 \u2206qT , z \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (98) \u2200x \u2208 \u2206qT , y \u2208 \u2206qT , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (99) \u2200x \u2208 \u2206qT , y \u2208 \u2206qF , z \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (100) \u2200x \u2208 \u2206qT , y \u2208 \u2206qF , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (101) \u2200x \u2208 \u2206qF , y \u2208 \u2206qT , z \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (102) \u2200x \u2208 \u2206qF , y \u2208 \u2206qT , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (103) \u2200x \u2208 \u2206qF , y \u2208 \u2206qF , z \u2208 \u2206qT : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (104) \u2200x \u2208 \u2206qF , y \u2208 \u2206qF , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (105)\n\u2200y \u2208 \u2206qT : F(y,N) (106) \u2200x \u2208 \u2206qF : \u00acF(x,N) (107)\n\u2200x \u2208 \u2206qT , y \u2208 \u2206qT : \u00acF(x, y) \u2228 F(y, x) (108) \u2200x \u2208 \u2206qT , y \u2208 \u2206qF : \u00acF(x, y) \u2228 F(y, x) (109) \u2200x \u2208 \u2206qF , y \u2208 \u2206qT : \u00acF(x, y) \u2228 F(y, x) (110) \u2200x \u2208 \u2206qF , y \u2208 \u2206qF : \u00acF(x, y) \u2228 F(y, x) (111)\nUnit propagation:\n\u2200y \u2208 \u2206qT , z \u2208 \u2206qF : \u00acF(y, z) (112) \u2200x \u2208 \u2206qT , z \u2208 \u2206qT : F(x, z) (113) \u2200x \u2208 \u2206qF , y \u2208 \u2206qT : \u00acF(x, y) (114)\n\u2200x \u2208 \u2206qF , y \u2208 \u2206qF , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (115) \u2200y \u2208 \u2206qT : F(y,N) (116) \u2200x \u2208 \u2206qF : \u00acF(x,N) (117)\n\u2200x \u2208 \u2206qF , y \u2208 \u2206qF : \u00acF(x, y) \u2228 F(y, x) (118)\nThe first, second, third, fifth, and sixth clauses are independent of the other clauses and can be reasoned about separately. They can be trivially lifted. The remaining clauses are:\n\u2200x \u2208 \u2206qF , y \u2208 \u2206qF , z \u2208 \u2206qF : \u00acF(x, y) \u2228 \u00acF(y, z) \u2228 F(x, z) (119) \u2200x \u2208 \u2206qF , y \u2208 \u2206qF : \u00acF(x, y) \u2228 F(y, x) (120)\nThe above clauses are an instance of our initial clauses but with smaller domain sizes. We can reason about them by following a similar process, and if we keep sub-results in a cache, the process will be polynomial."}, {"heading": "9.3 Proof of Proposition 3", "text": "Proof. After skolemization [30] for removing the existential quantifier, the birthday-paradox theory contains \u2200p \u2208 \u2206p,\u2200d \u2208 \u2206d : S(p) \u2228 \u00acBorn(p, d), \u2200p \u2208 \u2206p, d1, d2 \u2208 \u2206d : \u00acBorn(p, d1) \u2228 \u00acBorn(p, d2), and \u2200p1, p2 \u2208 \u2206p, d \u2208 \u2206d : \u00acBorn(p1, d) \u2228 \u00acBorn(p2, d), where S is the Skolem predicate. This theory is not in FO2 and not in RU and is not domain-liftable using R. However, this theory is both S 2FO2 and S 2RU as the last two clauses are instances of \u03b1Born, the first one is in FO2 and also in RU and has no PRVs with more than one LV other than Born. Therefore, this theory is domain-liftable based on Theorem 1."}, {"heading": "9.4 Proof of Theorem 1", "text": "Proof. The case where \u03b1 = \u2205 is trivial. Let \u03b1 = \u03b1(S1) \u2227 \u03b1(S2) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1(Sn). Once we remove all PRVs having none or one LV by (lifted) case-analysis, the remaining clauses can be divided into n+ 1 components: the i-th component in the first n components only contains Si literals, and the (n+ 1)-th component contains no Si literals. These components are disconnected from each other, so we can consider each of them separately. The (n + 1)-th component comes from clauses in \u03b2 and is domain-liftable by definition. The following two Lemmas prove that the clauses in the other components are also domain-liftable. The proofs of both lemmas rely on domain recursion.\nLemma 1. A clausal theory with only one predicate S is domain-liftable if all clauses have exactly two different literals of S.\nLemma 2. Suppose {\u2206p1 ,\u2206p2 , . . . ,\u2206pn} are mutually exclusive subsets of \u2206x and {\u2206q1 ,\u2206q2 , . . . ,\u2206qm} are mutually exclusive subsets of \u2206y. We can add any unit clause of the form \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : S(pi, qj) or \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : \u00acS(pi, qj) to the theory in Lemma 1 and the theory is still domain-liftable.\nTherefore, theories in S 2FO2 and S 2RU are domain-liftable."}, {"heading": "9.5 Proof of Lemma 1", "text": "Proof. A theory in this form has a subset of the following clauses:\n\u2200x \u2208 \u2206x, y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (121) \u2200x \u2208 \u2206x, y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (122) \u2200x \u2208 \u2206x, y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (123) \u2200x1, x2 \u2208 \u2206x, y \u2208 \u2206y : S(x1, y) \u2228 S(x2, y) (124) \u2200x1, x2 \u2208 \u2206x, y \u2208 \u2206y : S(x1, y) \u2228 \u00acS(x2, y) (125) \u2200x1, x2 \u2208 \u2206x, y \u2208 \u2206y : \u00acS(x1, y) \u2228 \u00acS(x2, y) (126)\n\u2200x1, x2 \u2208 \u2206x, y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 S(x2, y2) (127) \u2200x1, x2 \u2208 \u2206x, y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x2, y2) (128) \u2200x1, x2 \u2208 \u2206x, y1, y2 \u2208 \u2206y : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (129)\nLet N be an individual in \u2206x. Applying domain recursion on \u2206x\u2032 = \u2206x\u2032 \u2212 {N} for all clauses gives:\nfor (1):\n\u2200y1, y2 \u2208 \u2206y : S(N, y1) \u2228 S(N, y2) (130) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (131)\nfor (2):\n\u2200y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(N, y2) (132) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (133)\nfor (3):\n\u2200y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 \u00acS(N, y2) (134) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (135)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(N, y) \u2228 S(x, y) (136) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 S(x2, y) (137)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(N, y) \u2228 \u00acS(x, y) (138) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(N, y) \u2228 S(x, y) (139)\n\u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 \u00acS(x2, y) (140)\nfor (6):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(N, y) \u2228 \u00acS(x, y) (141) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(x1, y) \u2228 \u00acS(x2, y) (142)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 S(x, y2) (143) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 S(x2, y2) (144)\nfor (8):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(x, y2) (145) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 S(x, y2) (146)\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x2, y2) (147)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 \u00acS(x, y2) (148) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (149)\nThen we can perform lifted case-analysis on S(N, y). For the case where S(N, y) is true for exactly k of the individuals in \u2206y, we update all clauses assuming \u2206yT and \u2206yF represent the individuals for which S(N, y) is True and False respectively, and assuming \u2200y \u2208 \u2206yT : S(N, y) and \u2200y \u2208 \u2206yF : \u00acS(N, y):\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (150)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (151)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (152)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (153) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 S(x2, y) (154)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (155) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (156) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 \u00acS(x2, y) (157)\nfor (6):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (158) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(x1, y) \u2228 \u00acS(x2, y) (159)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206y : S(x, y2) (160) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 S(x2, y2) (161)\nfor (8):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206y : \u00acS(x, y2) (162) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206y : S(x, y2) (163) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x2, y2) (164)\n(165)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206y : \u00acS(x, y2) (166) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (167)\nAfter subsumptions and shattering:\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (168) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (169) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (170)\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (171) (172)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (173) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (174) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (175) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (176)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (177) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (178) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (179) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (180)\nfor (4): (For the second clause, the case where y \u2208 \u2206yF becomes subsumed by the first clause)\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (181) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (182)\nfor (5): (The third clause was subsumed by the first two)\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (183) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (184)\nfor (6): (Similar to (4))\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (185) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x1, y) \u2228 \u00acS(x2, y) (186)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y2) (187) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x, y2) (188) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yT : S(x1, y1) \u2228 S(x2, y2) (189) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x1, y1) \u2228 S(x2, y2) (190)\nfor (8):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y2) (191) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : \u00acS(x, y2) (192) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yT : S(x, y2) (193) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y2) (194)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yT : \u00acS(x, y2) (195) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : \u00acS(x, y2) (196) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (197) \u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (198)\nLooking at the first clause for (7) (and some other clauses), we see that there exists a \u2200y1 \u2208 \u2206yT but y1 does not appear in the formula. If \u2206yT = \u2205, we can ignore this clause. Otherwise, we can ignore \u2200y1 \u2208 \u2206yT . So we consider three cases. When k = 0 (i.e. \u2206yF = \u2206y , \u2206yT = \u2205):\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (199)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (200)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (201)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x, y) (202)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(x, y) (203)\nfor (6):\n\u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(x1, y) \u2228 \u00acS(x2, y) (204)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y2 \u2208 \u2206y : S(x, y2) (205)\nfor (8):\n\u2200x \u2208 \u2206x\u2032 , y2 \u2208 \u2206y : \u00acS(x, y2) (206)\nfor (9):\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1 \u2208 \u2206y, y2 \u2208 \u2206y : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (207)\nIf clause #4 is one of the clauses in the theory, then unit propagation either gives False, or satisfies all the clauses. The same is true for clauses #5, #7, and #8. In a theory not having any of these four clauses, we will be left with a set of clauses that are again a subset of the initial 9 clauses that we started with, but with a smaller domain size. By applying the same procedure, we can count the number of models. When k = |\u2206y| (i.e. \u2206yF = \u2205, \u2206yT = \u2206y), everything is just similar to the k = 0 case.\nWhen 0 < k < |\u2206y| (i.e. neither \u2206yT nor \u2206yF are empty):\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (208) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (209) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (210)\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (211)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (212) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (213) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (214) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (215)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (216) \u2200x \u2208 \u2206x\u2032 , y1\u2206yT , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (217) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (218) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (219)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (220) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (221)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (222) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (223)\nfor (6):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (224) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x1, y) \u2228 \u00acS(x2, y) (225)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (226) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (227)\nfor (8):\nFalse (228)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (229) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (230)\nIf either one of clauses #5, #7, #8 or #9 are in the theory, then unit propagation either gives False or satisfies all clauses. Assume none of these four clauses are in the theory. If both clauses #4 and #6 are in a theory, again unit propagation gives either False or satisfies all clauses. If none of them are in the theory, then the other clauses are a subset of the initial 9 clauses that we started with. So let\u2019s consider the case where we have clause #4 and a subset of the first three clauses (the case with #6 instead of #4 is similar). In this case, if clauses #2 or #3 are in the theory, unit propagation either gives False or satisfies all the clauses. If none of them are in the theory and only #1 is in the theory, we will have the following clauses after unit propagation:\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (231) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (232) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (233)\nThe first clause is independent of the other two clauses. The second and third clauses are just similar to clauses #4 and #1 in the initial list of clauses and we can handle them using the same procedure.\nIf we use a cache to store computations for all subproblems, WFOMC is domain-liftable, i.e. polynomial in the population sizes."}, {"heading": "9.6 Proof of Lemma 2", "text": "Proof. Let \u03c8 be the set of pairs (i, j) such that the singleton clause \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : S(pi, qj) is in the theory, and \u03c8 be the set of pairs (i, j) such that the singleton clause \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : \u00acS(pi, qj) is in the theory. Then the singleton clauses can be written as follows:\n\u2200(i, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : S(pi, qj) (234) \u2200(i, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : \u00acS(pi, qj) (235)\nAnd the 2S clauses are as in Lemma 1. Without loss of generality, let\u2019s assume we select an individual N \u2208 \u2206p1 for domain recursion, and re-write all clauses to separate N from \u2206p1 . Assuming \u2206p\u20321 ,= \u2206p1 \u2212 {N} and \u2206x\u2032 = \u2206x \u2212 {N}, the theory will be:\nFor singletons:\n\u2200(1, j) \u2208 \u03c8 : \u2200qj \u2208 \u2206qj : S(N, qj) (236) \u2200(1, j) \u2208 \u03c8 : \u2200qj \u2208 \u2206qj : \u00acS(N, qj) (237)\n\u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , , qj \u2208 \u2206qj : S(p \u2032 1, qj) (238) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , , qj \u2208 \u2206qj : \u00acS(p \u2032 1, qj) (239) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : S(pi, qj) (240) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : \u00acS(pi, qj) (241)\nfor (1):\n\u2200y1, y2 \u2208 \u2206y : S(N, y1) \u2228 S(N, y2) (242) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (243)\nfor (2):\n\u2200y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(N, y2) (244) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (245)\nfor (3):\n\u2200y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 \u00acS(N, y2) (246) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (247)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(N, y) \u2228 S(x, y) (248) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 S(x2, y) (249)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(N, y) \u2228 \u00acS(x, y) (250) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(N, y) \u2228 S(x, y) (251)\n\u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : S(x1, y) \u2228 \u00acS(x2, y) (252)\nfor (6):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(N, y) \u2228 \u00acS(x, y) (253) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206y : \u00acS(x1, y) \u2228 \u00acS(x2, y) (254)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 S(x, y2) (255) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 S(x2, y2) (256)\nfor (8):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(N, y1) \u2228 \u00acS(x, y2) (257) \u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 S(x, y2) (258)\n\u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x1, y1) \u2228 \u00acS(x2, y2) (259)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(N, y1) \u2228 \u00acS(x, y2) (260) \u2200x1, x2 \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x1, y1) \u2228 \u00acS(x2, y2) (261)\nWe apply lifted case-analysis on each S(N,\u2206qj ). For each j, let \u2206qTj represent the individuals in \u2206qj for which S(N, qj) is true and \u2206qFj be the other individuals. For each j, lifted case-analysis adds two clauses to the theory as follows:\n\u2200qj \u2208 \u2206qTj : S(N, qj) (262) \u2200qj \u2208 \u2206qFj : \u00acS(N, qj) (263)\nWe shatter all other singleton clauses based on these newly added singletons. If the singletons are inconsistent, there is no model. Otherwise, let yT represent \u222ajqTj and yF represent \u222ajqFj . We add the following two singleton clauses to the theory:\n\u2200y \u2208 \u2206yT : S(N, y) (264) \u2200y \u2208 \u2206yF : \u00acS(N, y) (265)\nWe shatter all clauses having 2S based on these two singletons (not considering the shattering caused by the other singletons) and apply unit propagation. Then the theory will be as follows (the details can be checked in Lemma 1. Here we only consider the case where yT 6= \u2205 and yF 6= \u2205; the case where one of them is empty can be considered similarly as in Lemma 1):\nFor singletons:\n\u2200j : \u2200qj \u2208 \u2206qTj : S(N, qj) (266) \u2200j : \u2200qj \u2208 \u2206qFj : \u00acS(N, qj) (267)\n\u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : S(p \u2032 1, qj) (268) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qFj : S(p \u2032 1, qj) (269) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : \u00acS(p \u2032 1, qj) (270) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qFj : \u00acS(p \u2032 1, qj) (271) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : S(pi, qj) (272) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qFj : S(pi, qj) (273) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : \u00acS(pi, qj) (274) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qFj : \u00acS(pi, qj) (275)\nThe two singletons on \u2206yF and \u2206yT :\n\u2200y \u2208 \u2206yT : S(N, y) (276) \u2200y \u2208 \u2206yF : \u00acS(N, y) (277)\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (278) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (279) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (280)\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yF : S(x, y1) \u2228 S(x, y2) (281)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (282) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yT , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (283) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : S(x, y1) \u2228 \u00acS(x, y2) (284) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : S(x, y1) \u2228 \u00acS(x, y2) (285)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (286) \u2200x \u2208 \u2206x\u2032 , y1\u2206yT , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (287) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yT : \u00acS(x, y1) \u2228 \u00acS(x, y2) (288) \u2200x \u2208 \u2206x\u2032 , y1 \u2208 \u2206yF , y2 \u2208 \u2206yF : \u00acS(x, y1) \u2228 \u00acS(x, y2) (289)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (290) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (291)\nfor (5):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (292) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (293)\nfor (6):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (294) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x1, y) \u2228 \u00acS(x2, y) (295)\nfor (7):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x, y) (296) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (297)\nfor (8):\nFalse (298)\nfor (9):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yT : \u00acS(x, y) (299) \u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : \u00acS(x, y) (300)\nClauses number 266, 267, 276 and 277 are disconnected from the rest of the theory and can be reasoned about separately. It is trivial to lift these clauses. Now let\u2019s consider the other clauses.\nIf either one of the clauses #5, #7, #8. or #9 are in the theory, then unit propagation either gives false or satisfies all clauses. The same is true when both #4 and #6 are in the theory. If neither #4 nor #6 are in the theory, then we can conjoin the individuals in \u2206yT and \u2206yF as well as those in \u2206qjT and \u2206qjF and write the theory as follows: For singletons:\n\u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qj : S(p \u2032 1, qj) (301) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qj : \u00acS(p \u2032 1, qj) (302) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : S(pi, qj) (303) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qj : \u00acS(pi, qj) (304)\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 S(x, y2) (305)\nfor (2):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : S(x, y1) \u2228 \u00acS(x, y2) (306)\nfor (3):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206y : \u00acS(x, y1) \u2228 \u00acS(x, y2) (307)\nThis theory is an instance of our initial theory, but with p1 having a smaller domain size. So we can continue this process recursively on the remaining clauses.\nNow let\u2019s consider the case where #4 is in the theory but #6 is not (the case where #6 is in the theory and #4 is not is similar). In this case, if #2 or #3 are in the theory, then unit propagation either gives false or satisfies all the clauses. If #4 and #1 are in the theory, then the theory is as follows:\nFor singletons:\n\u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : S(p \u2032 1, qj) (308) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qFj : S(p \u2032 1, qj) (309) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : \u00acS(p \u2032 1, qj) (310) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qFj : \u00acS(p \u2032 1, qj) (311) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : S(pi, qj) (312) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qFj : S(pi, qj) (313) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : \u00acS(pi, qj) (314) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qFj : \u00acS(pi, qj) (315)\n(316)\nfor (1):\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (317)\nfor (4):\n\u2200x \u2208 \u2206x\u2032 , y \u2208 \u2206yF : S(x, y) (318) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (319)\nClause number 318 and the singleton clauses having qj \u2208 \u2206qFj are disconnected from the rest of the theory and can reasoned about separately. They can be trivially lifted. Once we remove these clauses, the theory will be as follows:\n\u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : S(p \u2032 1, qj) (320) \u2200(1, j) \u2208 \u03c8 : \u2200p\u20321 \u2208 \u2206p\u20321 , qj \u2208 \u2206qTj : \u00acS(p \u2032 1, qj) (321) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : S(pi, qj) (322) \u2200(i 6= 1, j) \u2208 \u03c8 : \u2200pi \u2208 \u2206pi , qj \u2208 \u2206qTj : \u00acS(pi, qj) (323)\n\u2200x \u2208 \u2206x\u2032 , y1, y2 \u2208 \u2206yT : S(x, y1) \u2228 S(x, y2) (324) \u2200x1, x2 \u2208 \u2206x\u2032 , y \u2208 \u2206yT : S(x1, y) \u2228 S(x2, y) (325)\nwhich is an instance of our initial theory, but where \u2206qj s have smaller domain sizes. So we can continue this process recursively on the remaining clauses.\nWe showed that in all cases, after domain recursion we will have an instance of our initial theory again, but with smaller domain sizes. By keeping the WFOMC of sub-problems in a cache, the whole process will be domain-liftable: i.e. polynomial in the population sizes."}, {"heading": "9.7 Proof of Proposition 4", "text": "Proof. Let T \u2208 FO2 and T \u2032 be any of the theories resulting from exhaustively applying rules in R expect lifted case-analysis on T . If T initially contains a unary PRV with predicate S, either it is still unary in T \u2032 or lifted decomposition has replaced the LV with a constant. In the first case, we can follow a generic branch of lifted case-analysis on S, and in the second case, either T \u2032 is empty or all binary PRVs in T have become unary in T \u2032 due to applying the lifted decomposition and we can follow a generic branch of lifted case-analysis for any of these PRVs. The generic branch in both cases is in FO2 and the same procedure can be followed until all theories become empty. If T initially contains only binary PRVs, lifted decomposition applies as the grounding of T is disconnected for each pair of individuals, and after lifted decomposition all PRVs have no LVs. Applying case analysis on all PRVs gives empty theories. Therefore, T \u2208 RU . The theory \u2200x, y, z \u2208 \u2206p : F(x, y) \u2228 F(y, z) \u2228 F(x, y, z) is an example of a RU theory that is not in FO2, showing RU 6\u2282 FO2. FO2 and RU are special cases of S 2FO2 and S 2RU respectively, where \u03b1 = \u2205, showing FO2 \u2282 S 2FO2 and RU \u2282 S 2RU . However, Example 3 is both in S 2FO2 and S 2RU but is not in FO2 and not in RU, showing S 2FO2 6\u2282 FO2 and S 2RU 6\u2282 RU . Since FO2 \u2282 RU and the class of added \u03b1(S) clauses are the same, S 2FO2 \u2282 S 2RU ."}], "references": [{"title": "Lifted online training of relational models with stochastic gradient methods", "author": ["Babak Ahmadi", "Kristian Kersting", "Sriraam Natarajan"], "venue": "In ECML PKDD,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2012}, {"title": "Other questions on probability", "author": ["W.W. Rouse Ball"], "venue": "Mathematical Recreations and Essays, page 45", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1960}, {"title": "Symmetric weighted first-order model counting", "author": ["Paul Beame", "Guy Van den Broeck", "Eric Gribkoff", "Dan Suciu"], "venue": "In PODS,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2015}, {"title": "Automorphism groups of graphical models and lifted variational inference", "author": ["Hung Hai Bui", "Tuyen N Huynh", "Artificial Intelligence Center", "Sebastian Riedel"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Efficient methods for lifted inference with aggregate factors", "author": ["Jaesik Choi", "Rodrigo de Salvo Braz", "Hung H. Bui"], "venue": "In AAAI,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Efficient query evaluation on probabilistic databases", "author": ["Nilesh Dalvi", "Dan Suciu"], "venue": "The VLDB Journal,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2007}, {"title": "ProbLog: A probabilistic Prolog and its application in link discovery", "author": ["Luc De Raedt", "Angelika Kimmig", "Hannu Toivonen"], "venue": "In IJCAI,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Statistical relational artificial intelligence: Logic, probability, and computation", "author": ["Luc De Raedt", "Kristian Kersting", "Sriraam Natarajan", "David Poole"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2016}, {"title": "Lifted first-order probabilistic inference", "author": ["Rodrigo de Salvo Braz", "Eyal Amir", "Dan Roth"], "venue": "In IJCAI,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2005}, {"title": "Introduction to statistical relational learning", "author": ["Lise Getoor", "Ben Taskar"], "venue": "MIT press,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2007}, {"title": "Probabilistic theorem proving", "author": ["Vibhav Gogate", "Pedro Domingos"], "venue": "In UAI, pages 256\u2013265,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Relational Bayesian networks", "author": ["Manfred Jaeger"], "venue": "In UAI. Morgan Kaufmann Publishers Inc.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1997}, {"title": "A fast variational approach for learning Markov random field language models", "author": ["Yacine Jernite", "Alexander M Rush", "David Sontag"], "venue": "In ICML,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "Lifted inference seen from the other side: The tractable features", "author": ["Abhay Jha", "Vibhav Gogate", "Alexandra Meliou", "Dan Suciu"], "venue": "In NIPS,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Knowledge compilation for lifted probabilistic inference: Compiling to a low-level language", "author": ["Seyed Mehran Kazemi", "David Poole"], "venue": "In KR,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2016}, {"title": "Why is compiling lifted inference into a low-level language so effective", "author": ["Seyed Mehran Kazemi", "David Poole"], "venue": "arXiv preprint arXiv:1606.04512,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2016}, {"title": "Counting belief propagation", "author": ["Kristian Kersting", "Babak Ahmadi", "Sriraam Natarajan"], "venue": "In UAI, pages 277\u2013284,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Probabilistic Graphical Models: Principles and Techniques", "author": ["Daphne Koller", "Nir Friedman"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2009}, {"title": "Lifted symmetry detection and breaking for MAP inference", "author": ["Timothy Kopp", "Parag Singla", "Henry Kautz"], "venue": "In NIPS,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Lifted probabilistic inference with counting formulae", "author": ["Brian Milch", "Luke S. Zettlemoyer", "Kristian Kersting", "Michael Haimes", "Leslie Pack Kaelbling"], "venue": "In AAAI,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}, {"title": "Markov chains on orbits of permutation groups", "author": ["Mathias Niepert"], "venue": "In UAI,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "Towards completely lifted search-based probabilistic inference", "author": ["David Poole", "Fahiem Bacchus", "Jacek Kisynski"], "venue": "[cs.AI],", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "First-order probabilistic inference", "author": ["David Poole"], "venue": "In IJCAI, pages 985\u2013991,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "Lifted first-order belief propagation", "author": ["Parag Singla", "Pedro M Domingos"], "venue": "In AAAI,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Probabilistic databases", "author": ["Dan Suciu", "Dan Olteanu", "Christopher R\u00e9", "Christoph Koch"], "venue": "Synthesis Lectures on Data Management,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2011}, {"title": "Completeness results for lifted variable elimination", "author": ["Nima Taghipour", "Daan Fierens", "Guy Van den Broeck", "Jesse Davis", "Hendrik Blockeel"], "venue": "In AISTATS,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2013}, {"title": "Lifted probabilistic inference by first-order knowledge compilation", "author": ["Guy Van den Broeck", "Nima Taghipour", "Wannes Meert", "Jesse Davis", "Luc De Raedt"], "venue": "In IJCAI,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2011}, {"title": "Lifted relax, compensate and then recover: From approximate to exact lifted probabilistic inference", "author": ["Guy Van den Broeck", "Arthur Choi", "Adnan Darwiche"], "venue": "In UAI,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2012}, {"title": "Skolemization for weighted first-order model counting", "author": ["Guy Van den Broeck", "Wannes Meert", "Adnan Darwiche"], "venue": "In KR,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2014}, {"title": "On the completeness of first-order knowledge compilation for lifted probabilistic inference", "author": ["Guy Van den Broeck"], "venue": "In NIPS,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2011}, {"title": "Lifted generative learning of Markov logic networks", "author": ["Jan Van Haaren", "Guy Van den Broeck", "Wannes Meert", "Jesse Davis"], "venue": "Machine Learning,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2015}, {"title": "Evidence-based clustering for scalable inference in Markov logic", "author": ["Deepak Venugopal", "Vibhav Gogate"], "venue": "In ECML PKDD,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2014}, {"title": "Scaling-up importance sampling for Markov logic networks", "author": ["Deepak Venugopal", "Vibhav G Gogate"], "venue": "In NIPS,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2014}], "referenceMentions": [{"referenceID": 7, "context": "Statistical relational learning (SRL) [8] aims at unifying logic and probability for reasoning and learning in noisy domains, described in terms of individuals (or objects), and the relationships between them.", "startOffset": 38, "endOffset": 41}, {"referenceID": 9, "context": "Statistical relational models [10], or template-based models [18] extend Bayesian and Markov networks with individuals and relations, and compactly describe probabilistic dependencies among them.", "startOffset": 30, "endOffset": 34}, {"referenceID": 17, "context": "Statistical relational models [10], or template-based models [18] extend Bayesian and Markov networks with individuals and relations, and compactly describe probabilistic dependencies among them.", "startOffset": 61, "endOffset": 65}, {"referenceID": 22, "context": "The aim of lifted inference [23] is to carry out probabilistic inference without needing to reason about each individual separately, by instead treating exchangeable, undistinguished objects as a whole.", "startOffset": 28, "endOffset": 32}, {"referenceID": 4, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 8, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 10, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 13, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 19, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 21, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 26, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 28, "context": "Over the past decade, a large number of lifted inference rules have been proposed [5, 9, 11, 14, 20, 22, 28, 30], often providing exponential speedups for specific SRL models.", "startOffset": 82, "endOffset": 112}, {"referenceID": 30, "context": "These basic exact inference techniques have applications in (tractable) lifted learning [32], where the main task is to efficiently compute partition functions, and in variational and over-symmetric approximations [29, 33].", "startOffset": 88, "endOffset": 92}, {"referenceID": 27, "context": "These basic exact inference techniques have applications in (tractable) lifted learning [32], where the main task is to efficiently compute partition functions, and in variational and over-symmetric approximations [29, 33].", "startOffset": 214, "endOffset": 222}, {"referenceID": 31, "context": "These basic exact inference techniques have applications in (tractable) lifted learning [32], where the main task is to efficiently compute partition functions, and in variational and over-symmetric approximations [29, 33].", "startOffset": 214, "endOffset": 222}, {"referenceID": 0, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 3, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 12, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 16, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 18, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 20, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 23, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 32, "context": "Moreover, they provided the foundation for a rich literature on approximate lifted inference and learning [1, 4, 13, 17, 19, 21, 25, 34].", "startOffset": 106, "endOffset": 136}, {"referenceID": 29, "context": "The theoretical study of lifted inference began with the complexity notion of domain-lifted inference [31] (a concept similar to data complexity in databases).", "startOffset": 102, "endOffset": 106}, {"referenceID": 28, "context": ", two logical variables), is liftable [30].", "startOffset": 38, "endOffset": 42}, {"referenceID": 14, "context": "Kazemi and Poole [15] introduce a liftable class called recursively unary, capturing hierarchical simplification rules.", "startOffset": 17, "endOffset": 21}, {"referenceID": 2, "context": "[3] identify liftable classes of probabilistic database queries.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "Such results elevate the specific inference rules and examples to a general principle, and bring lifted inference in line with complexity and database theory [3].", "startOffset": 158, "endOffset": 161}, {"referenceID": 29, "context": "Domain recursion was introduced by Van den Broeck [31] and was central to the proof that FO is liftable.", "startOffset": 50, "endOffset": 54}, {"referenceID": 25, "context": "However, later work showed that simpler rules suffice to capture FO [27], and the domain recursion rule was forgotten.", "startOffset": 68, "endOffset": 72}, {"referenceID": 2, "context": "[3], asking for an inference rule for a logical sentence called S4.", "startOffset": 0, "endOffset": 3}, {"referenceID": 10, "context": ", [11, 15, 28]) resort to grounding the theories in S 2FO or S RU that are not in FO or recursively unary, and require time exponential in the domain size.", "startOffset": 2, "endOffset": 14}, {"referenceID": 14, "context": ", [11, 15, 28]) resort to grounding the theories in S 2FO or S RU that are not in FO or recursively unary, and require time exponential in the domain size.", "startOffset": 2, "endOffset": 14}, {"referenceID": 26, "context": ", [11, 15, 28]) resort to grounding the theories in S 2FO or S RU that are not in FO or recursively unary, and require time exponential in the domain size.", "startOffset": 2, "endOffset": 14}, {"referenceID": 26, "context": "These results will be established using the weighted first-order model counting (WFOMC) formulation of SRL models [28].", "startOffset": 114, "endOffset": 118}, {"referenceID": 22, "context": "WFOMC is close to classical first-order logic, and it can encode many other SRL models, including Markov logic [24], parfactor graphs [23], some probabilistic programs [7], relational Bayesian networks [12], and probabilistic databases [26].", "startOffset": 134, "endOffset": 138}, {"referenceID": 6, "context": "WFOMC is close to classical first-order logic, and it can encode many other SRL models, including Markov logic [24], parfactor graphs [23], some probabilistic programs [7], relational Bayesian networks [12], and probabilistic databases [26].", "startOffset": 168, "endOffset": 171}, {"referenceID": 11, "context": "WFOMC is close to classical first-order logic, and it can encode many other SRL models, including Markov logic [24], parfactor graphs [23], some probabilistic programs [7], relational Bayesian networks [12], and probabilistic databases [26].", "startOffset": 202, "endOffset": 206}, {"referenceID": 24, "context": "WFOMC is close to classical first-order logic, and it can encode many other SRL models, including Markov logic [24], parfactor graphs [23], some probabilistic programs [7], relational Bayesian networks [12], and probabilistic databases [26].", "startOffset": 236, "endOffset": 240}, {"referenceID": 2, "context": "It is a basic specification language that simplifies the development of lifted inference algorithms [3, 11, 28].", "startOffset": 100, "endOffset": 111}, {"referenceID": 10, "context": "It is a basic specification language that simplifies the development of lifted inference algorithms [3, 11, 28].", "startOffset": 100, "endOffset": 111}, {"referenceID": 26, "context": "It is a basic specification language that simplifies the development of lifted inference algorithms [3, 11, 28].", "startOffset": 100, "endOffset": 111}, {"referenceID": 28, "context": "[30], which", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "2 Calculating the WFOMC of a Theory We now describe a set of rules R that can be applied to a theory to find its WFOMC efficiently; for more details, readers are directed to [28], [22] or [11].", "startOffset": 174, "endOffset": 178}, {"referenceID": 21, "context": "2 Calculating the WFOMC of a Theory We now describe a set of rules R that can be applied to a theory to find its WFOMC efficiently; for more details, readers are directed to [28], [22] or [11].", "startOffset": 180, "endOffset": 184}, {"referenceID": 10, "context": "2 Calculating the WFOMC of a Theory We now describe a set of rules R that can be applied to a theory to find its WFOMC efficiently; for more details, readers are directed to [28], [22] or [11].", "startOffset": 188, "endOffset": 192}, {"referenceID": 29, "context": "A theory is domain-liftable [31] if calculating its WFOMC is polynomial in |\u2206x1 |, |\u2206x2 |, .", "startOffset": 28, "endOffset": 32}, {"referenceID": 28, "context": "So far, two classes of domain-liftable theories have been recognized: FO [30, 31] and recursively unary [15, 22].", "startOffset": 73, "endOffset": 81}, {"referenceID": 29, "context": "So far, two classes of domain-liftable theories have been recognized: FO [30, 31] and recursively unary [15, 22].", "startOffset": 73, "endOffset": 81}, {"referenceID": 14, "context": "So far, two classes of domain-liftable theories have been recognized: FO [30, 31] and recursively unary [15, 22].", "startOffset": 104, "endOffset": 112}, {"referenceID": 21, "context": "So far, two classes of domain-liftable theories have been recognized: FO [30, 31] and recursively unary [15, 22].", "startOffset": 104, "endOffset": 112}, {"referenceID": 29, "context": "Van den Broeck [31] considered another rule called domain recursion in the set of rules for calculating the WFOMC of a theory.", "startOffset": 15, "endOffset": 19}, {"referenceID": 25, "context": "Note that the theory in Example 2 is in FO and as proved in [27], its WFOMC can be computed without using the domain recursion rule3.", "startOffset": 60, "endOffset": 64}, {"referenceID": 2, "context": "[3] identified a clause (S4) with four binary PRVs having the same predicate and proved that even though the rulesR in Section 2.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "Birthday Paradox: The birthday paradox problem [2] concerns finding the probability that in a set of n randomly chosen people, a pair of them have the same birthday.", "startOffset": 47, "endOffset": 50}, {"referenceID": 5, "context": "It also helps us get closer to finding a dichotomy between the theories that are domain-liftable and those that are not, similar to the dichotomy result of Dalvi and Suciu [6] for query answering in probabilistic databases.", "startOffset": 172, "endOffset": 175}, {"referenceID": 14, "context": "It has been shown [15, 16] that compiling the WFOMC rules into low-level programs (e.", "startOffset": 18, "endOffset": 26}, {"referenceID": 15, "context": "It has been shown [15, 16] that compiling the WFOMC rules into low-level programs (e.", "startOffset": 18, "endOffset": 26}, {"referenceID": 28, "context": "The last clause is actually in FO, and the Skolemization-rewriting of reused FO variables [30] can be applied, for example to y2 in its second PRV.", "startOffset": 90, "endOffset": 94}, {"referenceID": 28, "context": "After skolemization [30] for removing the existential quantifier, the birthday-paradox theory contains \u2200p \u2208 \u2206p,\u2200d \u2208 \u2206d : S(p) \u2228 \u00acBorn(p, d), \u2200p \u2208 \u2206p, d1, d2 \u2208 \u2206d : \u00acBorn(p, d1) \u2228 \u00acBorn(p, d2), and \u2200p1, p2 \u2208 \u2206p, d \u2208 \u2206d : \u00acBorn(p1, d) \u2228 \u00acBorn(p2, d), where S is the Skolem predicate.", "startOffset": 20, "endOffset": 24}], "year": 2016, "abstractText": "Statistical relational models provide compact encodings of probabilistic dependencies in relational domains, but result in highly intractable graphical models. The goal of lifted inference is to carry out probabilistic inference without needing to reason about each individual separately, by instead treating exchangeable, undistinguished objects as a whole. In this paper, we study the domain recursion inference rule, which, despite its central role in early theoretical results on domain-lifted inference, has later been believed redundant. We show that this rule is more powerful than expected, and in fact significantly extends the range of models for which lifted inference runs in time polynomial in the number of individuals in the domain. This includes an open problem called S4, the symmetric transitivity model, and a first-order logic encoding of the birthday paradox. We further identify new classes S 2FO and S RU of domain-liftable theories, which respectively subsume FO and recursively unary theories, the largest classes of domain-liftable theories known so far, and show that using domain recursion can achieve exponential speedup even in theories that cannot fully be lifted with the existing set of inference rules.", "creator": "LaTeX with hyperref package"}}}