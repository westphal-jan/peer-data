{"id": "1611.03530", "review": {"conference": "iclr", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2016", "title": "Understanding deep learning requires rethinking generalization", "abstract": "Despite their massive size, successful deep artificial neural networks can exhibit a remarkably small difference between training and test performance. Conventional wisdom attributes small generalization error either to properties of the model family, or to the regularization techniques used during training. While neural network networks perform better at detecting complex neural network features than other types of neural networks, it is not the result of differences in training and training. Indeed, training of an object, a person, or the object is much more important than training of an object, the latter of which is important.\n\n\n\nThe concept of the neural networks in generalization refers to the ability of neural network participants to perform tasks, such as measuring a variety of tasks and analyzing the results. An important point is that training and learning are different kinds of tasks; this includes the task of visualizing a target area, which is considered a part of the visual task. An advantage of training is that the network participants are trained to perform different types of training tasks.\nIn a previous post, we demonstrated the fact that training can be performed in various levels of training with no time restrictions. This may not be true with the addition of an artificial intelligence to a task. However, the following research provides a further demonstration of the importance of training and training, and demonstrates how training and learning are different types of training.\nFigure 1. Determination of task duration on a task task in training. (a) As a result of training and learning, participants can perform tasks in their respective training styles, with training as an extension of training. A, A, and B. Each task has a unique time constraint, such as whether it contains either a single task, or multiple tasks, which is considered a special task. (b) As a result of training and learning, participants can perform tasks in their respective training styles, with training as an extension of training.\nAs a result of training and learning, participants can perform tasks in their respective training styles, with training as an extension of training. A, A, and B. Each task has a unique time constraint, such as whether it contains either a single task, or multiple tasks, which is considered a special task. (b) As a result of training and learning, participants can perform tasks in their respective training styles, with training as an extension of training. A, A, and B. Each task has a unique time constraint, such as whether it contains either a single task, or multiple tasks, which is considered a special task. (c) As", "histories": [["v1", "Thu, 10 Nov 2016 22:02:36 GMT  (296kb,D)", "http://arxiv.org/abs/1611.03530v1", null], ["v2", "Sun, 26 Feb 2017 19:36:40 GMT  (308kb,D)", "http://arxiv.org/abs/1611.03530v2", "Published in ICLR 2017"]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["chiyuan zhang", "samy bengio", "moritz hardt", "benjamin recht", "oriol vinyals"], "accepted": true, "id": "1611.03530"}, "pdf": {"name": "1611.03530.pdf", "metadata": {"source": "CRF", "title": "UNDERSTANDING DEEP LEARNING REQUIRES RE- THINKING GENERALIZATION", "authors": ["Chiyuan Zhang", "Samy Bengio"], "emails": ["chiyuan@mit.edu", "bengio@google.com", "mrtz@google.com", "recht@berkeley.edu", "vinyals@google.com"], "sections": [{"heading": "1 INTRODUCTION", "text": "Deep artificial neural networks often have far more trainable model parameters than the number of samples they are trained on. Nonetheless, some of these models exhibit remarkably small generalization error, i.e., difference between \u201ctraining error\u201d and \u201ctest error\u201d. At the same time, it is certainly easy to come up with natural model architectures that generalize poorly. What is it then that distinguishes neural networks that generalize well from those that don\u2019t? A satisfying answer to this question would not only help to make neural networks more interpretable, but it might also lead to more principled and reliable model architecture design.\nTo answer such a question, statistical learning theory has proposed a number of different complexity measures that are capable of controlling generalization error. These include VC dimension (Vapnik, 1998), Rademacher complexity (Bartlett & Mendelson, 2003), and uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004). Moreover, when the number of parameters is large, theory suggests that some form of regularization is needed to ensure small generalization error. Regularization may also be implicit as is the case with early stopping."}, {"heading": "1.1 OUR CONTRIBUTIONS", "text": "In this work, we problematize the traditional view of generalization by showing that it is incapable of distinguishing between different neural networks that have radically different generalization performance. \u2217Work performed while interning at Google Brain. \u2020Work performed at Google Brain.\nar X\niv :1\n61 1.\n03 53\n0v 1\n[ cs\n.L G\n] 1\n0 N\nov 2\nRandomization tests. At the heart of our methodology is a variant of the well-known randomization test from non-parametric statistics (Edgington & Onghena, 2007). In a first set of experiments, we train several standard architectures on a copy of the data where the true labels were replaced by random labels. Our central finding can be summarized as:\nDeep neural networks easily fit random labels.\nMore precisely, when trained on a completely random labeling of the true data, neural networks achieve 0 training error. The test error, of course, is no better than random chance as there is no correlation between the training labels and the test labels. In other words, by randomizing labels alone we can force the generalization of a model to jump up considerably without changing the model, its size, hyperparameters, or the optimizer. We establish this fact for several different standard architectures trained on the CIFAR10 and ImageNet classification benchmarks. While simple to state, this observation has profound implications from a statistical learning perspective:\n1. The effective capacity of neural networks is large enough for a brute-force memorization of the entire data set.\n2. Even optimization on random labels remains easy. In fact, training time increases only by a small constant factor compared with training on the true labels.\n3. Randomizing labels is solely a data transformation, leaving all other properties of the learning problem unchanged.\nExtending on this first set of experiments, we also replace the true images by completely random pixels (e.g., Gaussian noise) and observe that convolutional neural networks continue to fit the data with zero training error. This shows that despite their structure, convolutional neural nets can fit random noise. We furthermore vary the amount of randomization, interpolating smoothly between the case of no noise and complete noise. This leads to a range of intermediate learning problems where there remains some level of signal in the labels. We observe a steady deterioration of the generalization error as we increase the noise level. This shows that neural networks are able to capture the remaining signal in the data, while at the same time fit the noisy part using brute-force.\nWe discuss in further detail below how these observations rule out all of VC-dimension, Rademacher complexity, and uniform stability as possible explanations for the generalization performance of state-of-the-art neural networks.\nThe role of explicit regularization. If the model architecture itself isn\u2019t a sufficient regularizer, it remains to see how much explicit regularization helps. We show that explicit forms of regularization, such as weight decay, dropout, and data augmentation, do not adequately explain the generalization error of neural networks. Put differently:\nExplicit regularization may improve generalization performance, but is neither necessary nor by itself sufficient for controlling generalization error.\nIn contrast with classicial convex empirical risk minimization, where explicit regularization is necessary to rule out trivial solutions, we found that regularization plays a rather different role in deep learning. It appears to be more of a tuning parameter that often helps improve the final test error of a model, but the absence of all regularization does not necessarily imply poor generalization error. As reported by Krizhevsky et al. (2012), `2-regularization (weight decay) sometimes even helps optimization, illustrating its poorly understood nature in deep learning.\nFinite sample expressivity. We complement our empirical observations with a theoretical construction showing that generically large neural networks can express any labeling of the training data. More formally, we exhibit a very simple two-layer ReLU network with p = 2n+d parameters that can express any labeling of any sample of size n in d dimensions. A previous construction due to Livni et al. (2014) achieved a similar result with far more parameters, namely, O(dn). While our depth 2 network inevitably has large width, we can also come up with a depth k network in which each layer has only O(n/k) parameters.\nWhile prior expressivity results focused on what functions neural nets can represent over the entire domain, we focus instead on the expressivity of neural nets with regards to a finite sample. In\ncontrast to existing depth separations (Delalleau & Bengio, 2011; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016) in function space, our result shows that even depth-2 networks of linear size can already represent any labeling of the training data.\nThe role of implicit regularization. While explicit regularizers like dropout and weight-decay may not be essential for generalization, it is certainly the case that not all models that fit the training data well generalize well. Indeed, in neural networks, we almost always choose our model as the output of running stochastic gradient descent. Appealing to linear models, we analyze how SGD acts as an implicit regularizer. For linear models, SGD always converges to a solution with small norm. Hence, the algorithm itself is implicitly regularizing the solution. Indeed, we show on small data sets that even Gaussian kernel methods can generalize well with no regularization. Though this doesn\u2019t explain why certain architectures generalize better than other architectures, it does suggest that more investigation is needed to understand exactly what the properties are inherited by models that were trained using SGD."}, {"heading": "1.2 RELATED WORK", "text": "Hardt et al. (2016) give an upper bound on the generalization error of a model trained with stochastic gradient descent in terms of the number of steps gradient descent took. Their analysis goes through the notion of uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004). As we point out in this work, uniform stability of a learning algorithm is independent of the labeling of the training data. Hence, the concept is not strong enough to distinguish between the models trained on the true labels (small generalization error) and models trained on random labels (high generalization error). This also highlights why the analysis of Hardt et al. (2016) for non-convex optimization was rather pessimistic, allowing only a very few passes over the data. Our results show that even empirically training neural networks is not uniformly stable for many passes over the data. Consequently, a weaker stability notion is necessary to make further progress along this direction.\nThere has been much work on the representational power of neural networks, starting from universal approximation theorems for multi-layer perceptrons (Cybenko, 1989; Mhaskar, 1993; Delalleau & Bengio, 2011; Mhaskar & Poggio, 2016; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016). All of these results are at the population level characterizing which mathematical functions certain families of neural networks can express over the entire domain. We instead study the representational power of neural networks for a finite sample of size n. This leads to a very simple proof that even O(n)-sized two-layer perceptrons have universal finite-sample expressivity."}, {"heading": "2 EFFECTIVE CAPACITY OF NEURAL NETWORKS", "text": "Our goal is to understand the effective model capacity of feed-forward neural networks. Toward this goal, we choose a methodology inspired by non-parametric randomization tests. Specifically, we take a candidate architecture and train it both on the true data and on a copy of the data in which the true labels were replaced by random labels. In the second case, there is no longer any relationship between the instances and the class labels. As a result, learning is impossible. Intuition suggests that this impossibility should manifest itself clearly during training, e.g., by training not converging or slowing down substantially. To our surprise, the training process for several standard achitectures is largely unaffected by this transformation of the labels. This poses a conceptual challenge. Whatever justification we had for expecting a small generalization error to begin with must no longer apply to the case of random labels.\nTo gain further insight into this phenomenon, we experiment with different levels of randomization exploring the continuum between no label noise and completely corrupted labels. We also try out different randomizations of the inputs (rather than labels), arriving at the same general conclusion.\nThe experiments are run on two image classification datasets, the CIFAR10 dataset (Krizhevsky & Hinton, 2009) and the ImageNet (Russakovsky et al., 2015) ILSVRC 2012 dataset. We test the Inception V3 (Szegedy et al., 2015) architecture on ImageNet and a smaller version of Inception, Alexnet (Krizhevsky et al., 2012), and MLPs on CIFAR10. Please see Section A in the appendix for details of the experimental setup."}, {"heading": "2.1 FITTING RANDOM LABELS AND PIXELS", "text": "We run our experiments with the following modifications of the labels and input images:\n\u2022 True labels: the original dataset without modification. \u2022 Partially corrupted labels: independently with probability p, the label of each image is\ncorrupted as a uniform random class. \u2022 Random labels: all the labels are replaced with random ones. \u2022 Shuffled pixels: a random permutation of the pixels is chosen and then the same permuta-\ntion is applied to all the images in both training and test set. \u2022 Random pixels: a different random permutation is applied to each image independently. \u2022 Gaussian: A Gaussian distribution (with matching mean and variance) is used to generate\nrandom pixels for each image.\nSurprisingly, stochastic gradient descent with unchanged hyperparameter settings can optimize the weights to fit to random labels perfectly, even though the random labels completely destroy the relationship between images and labels. We further break the structure of the images by shuffling the image pixels, and even completely re-sampling random pixels from a Gaussian distribution. But the networks we tested are still able to fit.\nFigure 1a shows the learning curves of the Inception model on the CIFAR10 dataset under various settings. We expect the objective function to take longer to start decreasing on random labels because initially the label assignments for every training sample is uncorrelated. Therefore, large predictions errors are back-propagated to make large gradients for parameter updates. However, since the random labels are fixed and consistent across epochs, the network starts fitting after going through the training set multiple times. We find the following observations for fitting random labels very interesting: a) we do not need to change the learning rate schedule; b) once the fitting starts, it converges quickly; c) it converges to (over)fit the training set perfectly. Also note that \u201crandom pixels\u201d and \u201cGaussian\u201d start converging faster than \u201crandom labels\u201d. This might be because with random pixels, the inputs are more separated from each other than natural images that originally belong to the same category, therefore, easier to build a network for arbitrary label assignments.\nOn the CIFAR10 dataset, Alexnet and MLPs all converge to zero loss on the training set. The shaded rows in Table 1 show the exact numbers and experimental setup. We also tested random labels on the ImageNet dataset. As shown in the last three rows of Table 2 in the appendix, although it does not reach the perfect 100% top-1 accuracy, 95.20% accuracy is still very surprising for a million random labels from 1000 categories. Note that we did not do any parameter tuning when switching from the true labels to random labels. It is likely that with some modification of the parameters, perfect accuracy could be achieved on random labels. The network also manages to reach \u223c90% top-1 accuracy even with explicit regularizers turned on.\nPartially corrupted labels We further inspect the behavior of neural network training with a varying level of label corruptions from 0 (no corruption) to 1 (complete random labels) on the CIFAR10 dataset. The networks fit the corrupted training set perfectly for all the cases. Figure 1b shows the slowdown of the convergence time with increasing level of label noises. Figure 1c depicts the test errors after convergence. Since the training errors are always zero, the test errors are the same as generalization errors. As the noise level approaches 1, the generalization errors converge to 90% \u2014 the performance of random guessing on CIFAR10."}, {"heading": "2.2 IMPLICATIONS", "text": "In light of our randomization experiments, we discuss how our findings rule out several traditional approaches to generalization.\nRademacher complexity and VC-dimension. Rademacher complexity is commonly used and flexible complexity measure of a hypothesis class. The empirical Rademacher complexity of a hypothesis classH on a dataset {x1, . . . , xn} is defined as\nR\u0302n(H) = E\u03c3 [ sup h\u2208H 1 n n\u2211\ni=1\n\u03c3ih(xi)\n] (1)\nwhere \u03c31, . . . , \u03c3n \u2208 {\u00b11} are i.i.d. uniform random variables. This closely resemble our randomization test. Specifically, R\u0302n(H) measures on averageH\u2019s capability of fitting all possible\u00b11 binary label assignments. Generalization guarantees based on Rademacher complexity directly characterize the convergence rate by O(R\u0302n(H)). However, since the randomization tests suggests the neural networks fit the training set with random labels perfectly, we get R\u0302n(H) = 1, which is trivial for an upper bound of 0-1 loss in binary classification. Therefore, uniform convergence bounds based on Rademacher complexity are not strong enough to characterize the success of deep learning in realistic settings. A similar reasoning rules out VC-dimension. Deep neural networks with more than n parameters have VC-dimension greater than n, which leads to trivial uniform convergence bounds. For neural networks, there is also no direct analog of generalization through margin theory as has been successful for large kernel machines.\nUniform stability. Stepping away from complexity measures of the hypothesis class, we can instead consider properties of the algorithm used for training. This is commonly done with some notion of stability, such as uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004). Uniform stability of an algorithm A measures how sensitive the algorithm is to the replacement of a single example. However, it is solely a property of the algorithm, which does not take into account specifics of the data or the distribution of the labels. It is possible to define weaker notions of stability (Shalev-Shwartz et al., 2010). The weakest such stability measure is directly equivalent to bounding generalization error and does take the data into account. However, it has been difficult to utilize this weaker stability notion effectively."}, {"heading": "3 THE ROLE OF REGULARIZATION", "text": "Most of our randomization tests are performed with explicit regularization turned off. Regularizers are the standard tool in theory and practice to mitigate overfitting in the regime when there are more parameters than data points (Vapnik, 1998). The basic idea is that although the original hypothesis is too large to generalize well, regularizers help confine learning to a subset of the hypothesis space with manageable complexity. By adding an explicit regularizer, say by penalizing the norm of the optimal solution, the effective Rademacher complexity of the possible solutions is dramatically reduced.\nAs we will see, in deep learning, explicit regularization seems to play a rather different role. As the bottom rows of Table 2 in the appendix show, even with dropout and weight decay, InceptionV3 is still able to fit the random training set extremely well if not perfectly. Although not shown explicitly, on CIFAR10, both Inception and MLPs still fit perfectly the random training set with weight decay turned on. However, AlexNet with weight decay turned on fails to converge on random labels. To\ninvestigate the role of regularization in deep learning, we explicitly compare behavior of deep nets learning with and without regularizers.\nInstead of doing a full survey of all kinds of regularization techniques introduced for deep learning, we simply take several commonly used network architectures, and compare the behavior when the turning off the equipped regularizers. The following regularizers are covered:\n\u2022 Data augmentation: augment the training set via domain-specific transformations. For image data, commonly used transformations include random cropping, random perturbation of brightness, saturation, hue and contrast.\n\u2022 Weight decay: equivalent to a `2 regularizer on the weights; also equivalent to a hard constrain of the weights to an Euclidean ball, with the radius decided by the amount of weight decay.\n\u2022 Dropout (Srivastava et al., 2014): mask out each element of a layer output randomly with a given dropout probability. Only the Inception V3 for ImageNet uses dropout in our experiments.\nTable 1 shows the results of Inception, Alexnet and MLPs on CIFAR10, toggling the use of data augmentation and weight decay. Both regularization techniques help to improve the generalization performance, but even with all of the regularizers turned off, all of the models still generalize very well.\nTable 2 in the appendix shows a similar experiment on the ImageNet dataset. A 18% top-1 accuracy drop is observed when we turn off all the regularizers. Specifically, the top-1 accuracy without regularization is 59.80%, while random guessing only achieves 0.1% top-1 accuracy on ImageNet. More strikingly, with data-augmentation on but explicit regularizers off, Inception is able to achieve a top-1 accuracy of 72.95%. Indeed, it seems like the ability to augment the data using known symmetries is significantly more powerful than just tuning weight decay or preventing low training error.\nInception achieves 80.38% top-5 accuracy without regularization, while the reported number of the winner of ILSVRC 2012 (Krizhevsky et al., 2012) achieved 83.6%. So while regularization is important, bigger gains can be achieved by simply changing the model architecture. It is difficult to say that the regularizers count as a fundamental phase change in the generalization capability of deep nets."}, {"heading": "3.1 IMPLICIT REGULARIZATIONS", "text": "Early stopping was shown to implicitly regularize on some convex learning problems (Yao et al., 2007; Lin et al., 2016). In Table 2 in the appendix, we show in parentheses the best test accuracy along the training process. It confirms that early stopping could potentially1 improve the generalization performance. Figure 2a shows the training and testing accuracy on ImageNet. The shaded area indicate the accumulative best test accuracy, as a reference of potential performance gain for early stopping. However, on the CIFAR10 dataset, we do not observe any potential benefit of early stopping.\nBatch normalization (Ioffe & Szegedy, 2015) is an operator that normalizes the layer responses within each mini-batch. It has been widely adopted in many modern neural network architectures such as Inception (Szegedy et al., 2015) and Residual Networks (He et al., 2016). Although not explicitly designed for regularization, batch normalization is usually found to improve the generalization performance. The Inception architecture uses a lot of batch normalization layers. To test the impact of batch normalization, we create a \u201cInception w/o BatchNorm\u201d architecture that is exactly the same as Inception in Figure 3, except with all the batch normalization layers removed. Figure 2b compares the learning curves of the two variants of Inception on CIFAR10, with all the explicit regularizers turned off. The normalization operator helps stablize the learning dynamics, but the impact on the generalization performance is only 3\u223c4%. The exact accuracy is also listed in the section \u201cInception w/o BatchNorm\u201d of Table 1.\nIn summary, our observations on both explicit and implicit regularizers are consistently suggesting that regularizers, when properly tuned, could help to improve the generalization performance. However, it is unlikely that the regularizers are the fundamental reason for generalization, as the networks continue to perform well after all the regularizers removed.\n1We say \u201cpotentially\u201d because to make this statement rigorous, we need to have another isolated test set and test the performance there when we choose early stopping point on the first test set (acting like a validation set)."}, {"heading": "4 FINITE-SAMPLE EXPRESSIVITY", "text": "Much effort has gone into characterizing the expressivity of neural networks, e.g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016). Almost all of these results are at the \u201cpopulation level\u201d showing what functions of the entire domain can and cannot be represented by certain classes of neural networks with the same number of parameters. For example, it is known that at the population level depth k is generically more powerful than depth k \u2212 1. We argue that what is more relevant in practice is the expressive power of neural networks on a finite sample of size n. It is possible to transfer population level results to finite sample results using uniform convergence theorems. However, such uniform convergence bounds would require the sample size to be polynomially large in the dimension of the input and exponential in the depth of the network, posing a clearly unrealistic requirement in practice.\nWe instead directly analyze the finite-sample expressivity of neural networks, noting that this dramatically simplifies the picture. Specifically, as soon as the number of parameters p of a networks is greater than n, even simple two-layer neural networks can represent any function of the input sample. We say that a neural network C can represent any function of a sample of size n in d dimensions if for every sample S \u2286 Rd with |S| = n and every function f : S \u2192 R, there exists a setting of the weights of C such that C(x) = f(x) for every x \u2208 S. Theorem 1. There exists a two-layer neural network with ReLU activations and 2n+d weights that can represent any function on a sample of size n in d dimensions.\nThe proof is given in Section C in the appendix, where we also discuss how to achieve widthO(n/k) with depth k. We remark that it\u2019s a simple exercise to give bounds on the weights of the coefficient vectors in our construction. Lemma 1 gives a bound on the smallest eigenvalue of the matrix A. This can be used to give reasonable bounds on the weight of the solution w."}, {"heading": "5 IMPLICIT REGULARIZATION: AN APPEAL TO LINEAR MODELS", "text": "Although deep neural nets remain mysterious for many reasons, we note in this section that it is not necessarily easy to understand the source of generalization for linear models either. Indeed, it is useful to appeal to the simple case of linear models to see if there are parallel insights that can help us better understand neural networks.\nSuppose we collect n distinct data points {(xi, yi)} where xi are d-dimensional feature vectors and yi are labels. Letting loss denote a nonnegative loss function with loss(y, y) = 0, consider the empirical risk minimization (ERM) problem\nminw\u2208Rd 1 n \u2211n i=1 loss(w Txi, yi) (2)\nIf d \u2265 n, then we can fit any labeling. But is it then possible to generalize with such a rich model class and no explicit regularization?\nLet X denote the n \u00d7 d data matrix whose i-th row is xTi . If X has rank n, then the system of equations Xw = y has an infinite number of solutions regardless of the right hand side. We can find a global minimum in the ERM problem (2) by simply solving this linear system.\nBut do all global minima generalize equally well? Is there a way to determine when one global minimum will generalize whereas another will not? One popular way to understand quality of minima is the curvature of the loss function at the solution. But in the linear case, the curvature of all optimal solutions is the same (Choromanska et al., 2015). To see this, note that in the case when yi is a scalar,\n\u22072 1n \u2211n i=1 loss(w Txi, yi) = 1 nX T diag(\u03b2)X,\n( \u03b2i := \u22022 loss(z,yi) \u2202z2 \u2223\u2223\u2223 z=yi ,\u2200i )\nA similar formula can be found when y is vector valued. In particular, the Hessian is not a function of the choice of w. Moreover, the Hessian is degenerate at all global optimal solutions.\nIf curvature doesn\u2019t distinguish global minima, what does? A promising direction is to consider the workhorse algorithm, stochastic gradient descent (SGD), and inspect which solution SGD converges\nto. Since the SGD update takes the form wt+1 = wt \u2212 \u03b7tetxit where \u03b7t is the step size and et is the prediction error loss. If w0 = 0, we must have that the solution has the form w = \u2211n i=1 \u03b1ixi for some coefficients \u03b1. Hence, if we run SGD we have that w = XT\u03b1 lies in the span of the data points. If we also perfectly interpolate the labels we have Xw = y. Enforcing both of these identities, this reduces to the single equation\nXXT\u03b1 = y (3)\nwhich has a unique solution. Note that this equation only depends on the dot-products between the data points xi. We have thus derived the \u201ckernel trick\u201d (Scho\u0308lkopf et al., 2001)\u2014albeit in a roundabout fashion.\nWe can therefore perfectly fit any set of labels by forming the Gram matrix (aka the kernel matrix) on the data K = XXT and solving the linear system K\u03b1 = y for \u03b1. This is an n\u00d7 n linear system that can be solved on standard workstations whenever n is less than a hundred thousand, as is the case for small benchmarks like CIFAR10 and MNIST.\nQuite surprisingly, fitting the training labels exactly yields excellent performance for convex models. On MNIST with no preprocessing, we are able to achieve a test error of 1.2% by simply solving (3). Note that this is not exactly simple as the kernel matrix requires 30GB to store in memory. Nonetheless, this system can be solved in under 3 minutes in on a commodity workstation with 24 cores and 256 GB of RAM with a conventional LAPACK call. By first applying a Gabor wavelet transform to the data and then solving (3), the error on MNIST drops to 0.6%. Surprisingly, adding regularization does not improve either model\u2019s performance!\nSimilar results follow for CIFAR10. Simply applying a Gaussian kernel on pixels and using no regularization achieves 46% test error. By preprocessing with a random convolutional neural net with 32,000 random filters, this test error drops to 17% error2. Adding `2 regularization further reduces this number to 15% error. Note that this is without any data augmentation.\nNote that this kernel solution has an appealing interpretation in terms of implicit regularization. Simple algebra reveals that it is equivalent to the minimum `2-norm solution of Xw = y. That is, out of all models that exactly fit the data, SGD will often converge to the solution with minimum norm. It is very easy to construct solutions ofXw = y that don\u2019t generalize: for example, one could fit a Gaussian kernel to data and place the centers at random points. Another simple example would be to force the data to fit random labels on the test data. In both cases, the norm of the solution is significantly larger than the minimum norm solution.\nUnfortunately, this notion of minimum norm is not predictive of generalization performance. For example, returning to the MNIST example, the `2-norm of the minimum norm solution with no preprocessing is approximately 220. With wavelet preprocessing, the norm jumps to 390. Yet the test error drops by a factor of 2. So while this minimum-norm intuition may provide some guidance to new algorithm design, it is only a very small piece of the generalization story."}, {"heading": "6 CONCLUSION", "text": "The classical view of machine learning rests on the idea of parsimony. In almost any formulation, learning boils down to extracting low-complexity patterns from data. Brute-force memorization is typically not thought of as an effective form of learning. At the same time, it\u2019s possible that sheer memorization can in part be an effective problem-solving strategy for natural tasks.\nOur results challenge the classical view of learning by showing that many successful neural networks easily have the effective capacity for sheer memorization. This leads us to believe that these models may very well make use of massive memorization when tackling the problems they are trained to solve. It is likely that learning in the traditional sense still occurs in part, but it appears to be deeply intertwined with massive memorization. Classical approaches are therefore poorly suited for reasoning about why these models generalize well.\nWe believe that understanding neural networks requires rethinking generalization. We hope that our paper provides a first stepping stone by problematizing the classical view and pointing towards unresolved conundrums.\n2This conv-net is the Coates & Ng (2012) net, but with the filters selected at random instead of with k-means."}, {"heading": "A EXPERIMENTAL SETUP", "text": "We focus on two image classification datasets, the CIFAR10 dataset (Krizhevsky & Hinton, 2009) and the ImageNet (Russakovsky et al., 2015) ILSVRC 2012 dataset.\nThe CIFAR10 dataset contains 50,000 training and 10,000 validation images, split into 10 classes. Each image is of size 32x32, with 3 color channels. We divide the pixel values by 255 to scale them into [0, 1], crop from the center to get 28x28 inputs, and then normalize them by subtracting the mean and dividing the adjusted standard deviation independently for each image with the per_image_whitening function in TENSORFLOW (Abadi et al., 2015).\nFor the experiment on CIFAR10, we test a simplified Inception (Szegedy et al., 2015) and Alexnet (Krizhevsky et al., 2012) by adapting the architectures to smaller input image sizes. We also test standard multi-layer perceptrons (MLPs) with various number of hidden layers.\nThe small Inception model uses a combination of 1x1 and 3x3 convolution pathways. The detailed architecture is illustrated in Figure 3. The small Alexnet is constructed by two (convolution 5x5 \u2192 max-pool 3x3\u2192 local-response-normalization) modules followed by two fully connected layers with 384 and 192 hidden units, respectively. Finally a 10-way linear layer is used for prediction. The MLPs use fully connected layers. MLP 1x512 means one hidden layer with 512 hidden units. All of the architectures use standard rectified linear activation functions (ReLU).\nFor all experiments on CIFAR10, we train with SGD with a momentum parameter of 0.9. An initial learning rate of 0.1 (for small Inception) or 0.01 (for small Alexnet and MLPs) are used, with a decay factor of 0.95 per training epoch. Unless otherwise specified, for the experiments with randomized labels or pixels, we train the networks without weight decay, dropout, or other forms of explicit regularization. Section 3 discusses the effects of various regularizers on fitting the networks and generalization.\nThe ImageNet dataset contains 1,281,167 training and 50,000 validation images, split into 1000 classes. Each image is resized to 299x299 with 3 color channels. In the experiment on ImageNet, we use the Inception V3 (Szegedy et al., 2015) architecture and reuse the data preprocessing and experimental setup from the TENSORFLOW package. The data pipeline is extended to allow disabling of data augmentation and feeding random labels that are consistent across epochs. We run the ImageNet experiment in a distributed asynchronized SGD system with 50 workers."}, {"heading": "B DETAILED RESULTS ON IMAGENET", "text": "Table 2 shows the performance on Imagenet with true labels and random labels, respectively."}, {"heading": "C PROOF OF THEOREM 1", "text": "Lemma 1. For any two interleaving sequences of n real numbers b1 < x1 < b2 < x2 \u00b7 \u00b7 \u00b7 < bn < xn, the n\u00d7n matrix A = [max{xi\u2212 bj , 0}]ij has full rank. Its smallest eigenvalue is mini xi\u2212 bi.\nProof. By its definition, the matrix A is lower triangular, that is, all entries with i < j vanish. A basic linear algebra fact states that a lower-triangular matrix has full rank if and only if all of the entries on the diagional are nonzero. Since, xi > bi, we have that max{xi \u2212 bi, 0} > 0. Hence, A is invertible. The second claim follows directly from the fact that a lower-triangular matrix has all its eigenvalues on the main diagonal. This in turn follows from the first fact, since A\u2212 \u03bbI can have lower rank only if \u03bb equals one of the diagonal values.\nProof of Theorem 1. For weight vectors w, b \u2208 Rn and a \u2208 Rd, consider the function c : Rn \u2192 R,\nc(x) = \u2211\nj=1\nwj max{\u3008a, x\u3009 \u2212 bj , 0}\nIt is easy to see that c can be expressed by a depth 2 network with ReLU activations.\nNow, fix a sample S = {z1, . . . , zn} of size n and a target vector y \u2208 Rn. To prove the theorem, we need to find weights a, b, w so that yi = c(zi) for all i \u2208 {1, . . . , n} First, choose a and b such that with xi = \u3008a, zi\u3009 we have the interleaving property b1 < x1 < b2 < \u00b7 \u00b7 \u00b7 < bn < xn. This is possible since all zi\u2019s are distinct. Next, consider the set of n equations in the n unknowns w,\nyi = c(zi) , i \u2208 {1, . . . , n} .\nWe have c(zi) = Aw, where A = [max{xi \u2212 bi, 0}]ij is the matrix we encountered in Lemma 1. We chose a and b so that the lemma applies and hence A has full rank. We can now solve the linear system y = Aw to find suitable weights w.\nWhile the construction in the previous proof has inevitably high width given that the depth is 2, it is possible to trade width for depth. The construction is as follows. With the notation from the proof and assuming w.l.o.g. that x1, . . . , xn \u2208 [0, 1], partition the interval [0, 1] into b disjoint intervals I1, . . . , Ib so that each interval Ij contains n/b points. At layer j, apply the construction from the proof to all points in Ij . This requires O(n/b) nodes at level j. This construction results in a circuit of width O(n/b) and depth b + 1 which so far has b outputs (one from each layer). It remains to implement a multiplexer which selects one of the b outputs based on which interval a given input x falls into. This boils down to implementing one (approximate) indicator function fj for each interval Ij and outputting \u2211b j=1 fj(x)oj , where oj is the output of layer j. This results in a single output circuit. Implementing a single indicator function requires constant size and depth with ReLU activiations. Hence, the final size of the construction isO(n) and the depth is b+c for some constant c. Setting k = b\u2212 c gives the next corollary. Corollary 1. For every k \u2265 2, there exists neural network with ReLU activations of depth k, width O(n/k) and O(n + d) weights that can represent any function on a sample of size n in d dimensions."}, {"heading": "D RESULTS OF IMPLICIT REGULARIZATION FOR LINEAR MODELS", "text": "Table 3 list the experiment results of linear models described in Section 5."}], "references": [{"title": "TensorFlow: Large-scale machine learning on heterogeneous systems", "author": ["cent Vanhoucke", "Vijay Vasudevan", "Fernanda Vi\u00e9gas", "Oriol Vinyals", "Pete Warden", "Martin Wattenberg", "Martin Wicke", "Yuan Yu", "Xiaoqiang Zheng"], "venue": null, "citeRegEx": "Vanhoucke et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Vanhoucke et al\\.", "year": 2015}, {"title": "Rademacher and gaussian complexities: risk bounds and structural results", "author": ["Peter L Bartlett", "Shahar Mendelson"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Bartlett and Mendelson.,? \\Q2003\\E", "shortCiteRegEx": "Bartlett and Mendelson.", "year": 2003}, {"title": "Stability and generalization", "author": ["Olivier Bousquet", "Andr\u00e9 Elisseeff"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Bousquet and Elisseeff.,? \\Q2002\\E", "shortCiteRegEx": "Bousquet and Elisseeff.", "year": 2002}, {"title": "The loss surfaces of multilayer networks", "author": ["Anna Choromanska", "Mikael Henaff", "Michael Mathieu", "G\u00e9rard Ben Arous", "Yann LeCun"], "venue": "In AISTATS,", "citeRegEx": "Choromanska et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Choromanska et al\\.", "year": 2015}, {"title": "Learning feature representations with k-means", "author": ["Adam Coates", "Andrew Y. Ng"], "venue": "In Neural Networks: Tricks of the Trade, Reloaded. Springer,", "citeRegEx": "Coates and Ng.,? \\Q2012\\E", "shortCiteRegEx": "Coates and Ng.", "year": 2012}, {"title": "Convolutional Rectifier Networks as Generalized Tensor Decompositions", "author": ["Nadav Cohen", "Amnon Shashua"], "venue": "In ICML,", "citeRegEx": "Cohen and Shashua.,? \\Q2016\\E", "shortCiteRegEx": "Cohen and Shashua.", "year": 2016}, {"title": "Approximation by superposition of sigmoidal functions", "author": ["G Cybenko"], "venue": "Mathematics of Control, Signals and Systems,", "citeRegEx": "Cybenko.,? \\Q1989\\E", "shortCiteRegEx": "Cybenko.", "year": 1989}, {"title": "Shallow vs. Deep Sum-Product Networks", "author": ["Olivier Delalleau", "Yoshua Bengio"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Delalleau and Bengio.,? \\Q2011\\E", "shortCiteRegEx": "Delalleau and Bengio.", "year": 2011}, {"title": "Randomization Tests. Statistics: A Series of Textbooks and Monographs", "author": ["E. Edgington", "P. Onghena"], "venue": "Taylor & Francis,", "citeRegEx": "Edgington and Onghena.,? \\Q2007\\E", "shortCiteRegEx": "Edgington and Onghena.", "year": 2007}, {"title": "The Power of Depth for Feedforward Neural Networks", "author": ["Ronen Eldan", "Ohad Shamir"], "venue": "In COLT,", "citeRegEx": "Eldan and Shamir.,? \\Q2016\\E", "shortCiteRegEx": "Eldan and Shamir.", "year": 2016}, {"title": "Train faster, generalize better: Stability of stochastic gradient descent", "author": ["Moritz Hardt", "Benjamin Recht", "Yoram Singer"], "venue": "In ICML,", "citeRegEx": "Hardt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Hardt et al\\.", "year": 2016}, {"title": "Deep Residual Learning for Image Recognition", "author": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun"], "venue": null, "citeRegEx": "He et al\\.,? \\Q2016\\E", "shortCiteRegEx": "He et al\\.", "year": 2016}, {"title": "Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift", "author": ["Sergey Ioffe", "Christian Szegedy"], "venue": "In ICML,", "citeRegEx": "Ioffe and Szegedy.,? \\Q2015\\E", "shortCiteRegEx": "Ioffe and Szegedy.", "year": 2015}, {"title": "Learning multiple layers of features from tiny images", "author": ["Alex Krizhevsky", "Geoffrey Hinton"], "venue": "Technical report,", "citeRegEx": "Krizhevsky and Hinton.,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky and Hinton.", "year": 2009}, {"title": "ImageNet Classification with Deep Convolutional Neural Networks", "author": ["Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Generalization properties and implicit regularization for multiple passes sgm", "author": ["Junhong Lin", "Raffaello Camoriano", "Lorenzo Rosasco"], "venue": "arXiv preprint arXiv:1605.08375,", "citeRegEx": "Lin et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Lin et al\\.", "year": 2016}, {"title": "On the computational efficiency of training neural networks", "author": ["Roi Livni", "Shai Shalev-Shwartz", "Ohad Shamir"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Livni et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Livni et al\\.", "year": 2014}, {"title": "Deep vs. shallow networks : An approximation theory perspective", "author": ["Hrushikesh Mhaskar", "Tomaso A. Poggio"], "venue": "CoRR, abs/1608.03287,", "citeRegEx": "Mhaskar and Poggio.,? \\Q2016\\E", "shortCiteRegEx": "Mhaskar and Poggio.", "year": 2016}, {"title": "Approximation properties of a multilayered feedforward artificial neural network", "author": ["Hrushikesh Narhar Mhaskar"], "venue": "Advances in Computational Mathematics,", "citeRegEx": "Mhaskar.,? \\Q1993\\E", "shortCiteRegEx": "Mhaskar.", "year": 1993}, {"title": "Statistical learning: Stability is sufficient for generalization and necessary and sufficient for consistency of empirical risk minimization", "author": ["Sayan Mukherjee", "Partha Niyogi", "Tomaso Poggio", "Ryan Rifkin"], "venue": "Technical Report AI Memo 2002-024,", "citeRegEx": "Mukherjee et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Mukherjee et al\\.", "year": 2002}, {"title": "General conditions for predictivity in learning", "author": ["Tomaso Poggio", "Ryan Rifkin", "Sayan Mukherjee", "Partha Niyogi"], "venue": "theory. Nature,", "citeRegEx": "Poggio et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Poggio et al\\.", "year": 2004}, {"title": "Imagenet large scale visual recognition challenge", "author": ["Olga Russakovsky", "Jia Deng", "Hao Su", "Jonathan Krause", "Sanjeev Satheesh", "Sean Ma", "Zhiheng Huang", "Andrej Karpathy", "Aditya Khosla", "Michael Bernstein", "Alexander C. Berg", "Li FeiFei"], "venue": "International Journal of Computer Vision,", "citeRegEx": "Russakovsky et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Russakovsky et al\\.", "year": 2015}, {"title": "A generalized representer theorem", "author": ["Bernhard Sch\u00f6lkopf", "Ralf Herbrich", "Alex J Smola"], "venue": "In COLT,", "citeRegEx": "Sch\u00f6lkopf et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Sch\u00f6lkopf et al\\.", "year": 2001}, {"title": "Learnability, stability and uniform convergence", "author": ["Shai Shalev-Shwartz", "Ohad Shamir", "Nathan Srebro", "Karthik Sridharan"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2010}, {"title": "Dropout: a simple way to prevent neural networks from overfitting", "author": ["Nitish Srivastava", "Geoffrey E Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Srivastava et al\\.,? \\Q1929\\E", "shortCiteRegEx": "Srivastava et al\\.", "year": 1929}, {"title": "Rethinking the inception architecture for computer", "author": ["Christian Szegedy", "Vincent Vanhoucke", "Sergey Ioffe", "Jonathon Shlens", "Zbigniew Wojna"], "venue": "vision. CoRR,", "citeRegEx": "Szegedy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Szegedy et al\\.", "year": 2015}, {"title": "Benefits of depth in neural networks", "author": ["Matus Telgarsky"], "venue": "In COLT,", "citeRegEx": "Telgarsky.,? \\Q2016\\E", "shortCiteRegEx": "Telgarsky.", "year": 2016}, {"title": "Statistical Learning Theory. Adaptive and learning systems for signal processing, communications, and control", "author": ["Vladimir N. Vapnik"], "venue": null, "citeRegEx": "Vapnik.,? \\Q1998\\E", "shortCiteRegEx": "Vapnik.", "year": 1998}, {"title": "On early stopping in gradient descent learning", "author": ["Yuan Yao", "Lorenzo Rosasco", "Andrea Caponnetto"], "venue": "Constructive Approximation,", "citeRegEx": "Yao et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Yao et al\\.", "year": 2007}], "referenceMentions": [{"referenceID": 27, "context": "These include VC dimension (Vapnik, 1998), Rademacher complexity (Bartlett & Mendelson, 2003), and uniform stability (Mukherjee et al.", "startOffset": 27, "endOffset": 41}, {"referenceID": 19, "context": "These include VC dimension (Vapnik, 1998), Rademacher complexity (Bartlett & Mendelson, 2003), and uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 117, "endOffset": 190}, {"referenceID": 20, "context": "These include VC dimension (Vapnik, 1998), Rademacher complexity (Bartlett & Mendelson, 2003), and uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 117, "endOffset": 190}, {"referenceID": 14, "context": "As reported by Krizhevsky et al. (2012), `2-regularization (weight decay) sometimes even helps optimization, illustrating its poorly understood nature in deep learning.", "startOffset": 15, "endOffset": 40}, {"referenceID": 16, "context": "A previous construction due to Livni et al. (2014) achieved a similar result with far more parameters, namely, O(dn).", "startOffset": 31, "endOffset": 51}, {"referenceID": 26, "context": "contrast to existing depth separations (Delalleau & Bengio, 2011; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016) in function space, our result shows that even depth-2 networks of linear size can already represent any labeling of the training data.", "startOffset": 39, "endOffset": 127}, {"referenceID": 19, "context": "Their analysis goes through the notion of uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 60, "endOffset": 133}, {"referenceID": 20, "context": "Their analysis goes through the notion of uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 60, "endOffset": 133}, {"referenceID": 6, "context": "There has been much work on the representational power of neural networks, starting from universal approximation theorems for multi-layer perceptrons (Cybenko, 1989; Mhaskar, 1993; Delalleau & Bengio, 2011; Mhaskar & Poggio, 2016; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016).", "startOffset": 150, "endOffset": 292}, {"referenceID": 18, "context": "There has been much work on the representational power of neural networks, starting from universal approximation theorems for multi-layer perceptrons (Cybenko, 1989; Mhaskar, 1993; Delalleau & Bengio, 2011; Mhaskar & Poggio, 2016; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016).", "startOffset": 150, "endOffset": 292}, {"referenceID": 26, "context": "There has been much work on the representational power of neural networks, starting from universal approximation theorems for multi-layer perceptrons (Cybenko, 1989; Mhaskar, 1993; Delalleau & Bengio, 2011; Mhaskar & Poggio, 2016; Eldan & Shamir, 2016; Telgarsky, 2016; Cohen & Shashua, 2016).", "startOffset": 150, "endOffset": 292}, {"referenceID": 21, "context": "The experiments are run on two image classification datasets, the CIFAR10 dataset (Krizhevsky & Hinton, 2009) and the ImageNet (Russakovsky et al., 2015) ILSVRC 2012 dataset.", "startOffset": 127, "endOffset": 153}, {"referenceID": 25, "context": "We test the Inception V3 (Szegedy et al., 2015) architecture on ImageNet and a smaller version of Inception, Alexnet (Krizhevsky et al.", "startOffset": 25, "endOffset": 47}, {"referenceID": 14, "context": ", 2015) architecture on ImageNet and a smaller version of Inception, Alexnet (Krizhevsky et al., 2012), and MLPs on CIFAR10.", "startOffset": 77, "endOffset": 102}, {"referenceID": 19, "context": "This is commonly done with some notion of stability, such as uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 79, "endOffset": 152}, {"referenceID": 20, "context": "This is commonly done with some notion of stability, such as uniform stability (Mukherjee et al., 2002; Bousquet & Elisseeff, 2002; Poggio et al., 2004).", "startOffset": 79, "endOffset": 152}, {"referenceID": 23, "context": "It is possible to define weaker notions of stability (Shalev-Shwartz et al., 2010).", "startOffset": 53, "endOffset": 82}, {"referenceID": 27, "context": "Regularizers are the standard tool in theory and practice to mitigate overfitting in the regime when there are more parameters than data points (Vapnik, 1998).", "startOffset": 144, "endOffset": 158}, {"referenceID": 14, "context": "38% top-5 accuracy without regularization, while the reported number of the winner of ILSVRC 2012 (Krizhevsky et al., 2012) achieved 83.", "startOffset": 98, "endOffset": 123}, {"referenceID": 28, "context": "Early stopping was shown to implicitly regularize on some convex learning problems (Yao et al., 2007; Lin et al., 2016).", "startOffset": 83, "endOffset": 119}, {"referenceID": 15, "context": "Early stopping was shown to implicitly regularize on some convex learning problems (Yao et al., 2007; Lin et al., 2016).", "startOffset": 83, "endOffset": 119}, {"referenceID": 25, "context": "It has been widely adopted in many modern neural network architectures such as Inception (Szegedy et al., 2015) and Residual Networks (He et al.", "startOffset": 89, "endOffset": 111}, {"referenceID": 11, "context": ", 2015) and Residual Networks (He et al., 2016).", "startOffset": 30, "endOffset": 47}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 18}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 34}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 61}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 86}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 109}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016).", "startOffset": 3, "endOffset": 127}, {"referenceID": 6, "context": "g, Cybenko (1989); Mhaskar (1993); Delalleau & Bengio (2011); Mhaskar & Poggio (2016); Eldan & Shamir (2016); Telgarsky (2016); Cohen & Shashua (2016). Almost all of these results are at the \u201cpopulation level\u201d showing what functions of the entire domain can and cannot be represented by certain classes of neural networks with the same number of parameters.", "startOffset": 3, "endOffset": 151}, {"referenceID": 3, "context": "But in the linear case, the curvature of all optimal solutions is the same (Choromanska et al., 2015).", "startOffset": 75, "endOffset": 101}, {"referenceID": 22, "context": "We have thus derived the \u201ckernel trick\u201d (Sch\u00f6lkopf et al., 2001)\u2014albeit in a roundabout fashion.", "startOffset": 40, "endOffset": 64}], "year": 2016, "abstractText": "Despite their massive size, successful deep artificial neural networks can exhibit a remarkably small difference between training and test performance. Conventional wisdom attributes small generalization error either to properties of the model family, or to the regularization techniques used during training. Through extensive systematic experiments, we show how these traditional approaches fail to explain why large neural networks generalize well in practice. Specifically, our experiments establish that state-of-the-art convolutional networks for image classification trained with stochastic gradient methods easily fit a random labeling of the training data. This phenomenon is qualitatively unaffected by explicit regularization, and occurs even if we replace the true images by completely unstructured random noise. We corroborate these experimental findings with a theoretical construction showing that simple depth two neural networks already have perfect finite sample expressivity as soon as the number of parameters exceeds the number of data points as it usually does in practice. We interpret our experimental findings by comparison with traditional models.", "creator": "LaTeX with hyperref package"}}}