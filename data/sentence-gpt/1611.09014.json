{"id": "1611.09014", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Nov-2016", "title": "Blocking and Other Enhancements for Bottom-Up Model Generation Methods", "abstract": "Model generation is a problem complementary to theorem proving and is important for fault analysis and debugging of formal specifications of security protocols, programs and terminological definitions. This paper discusses several ways of enhancing the paradigm of bottom-up model generation. The two main contributions are new, generalized blocking techniques and a new range-restriction transformation. The blocking techniques are based on simple transformations of the input set together with standard equality reasoning and redundancy elimination techniques. These provide general methods for finding small, finite models. The range-restriction transformation refines existing transformations to range-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and classical range-restriction were tested on the clausal problems of the TPTP Version 6.0.0 with an implementation based on the SPASS theorem prover using a hyperresolution-like refinement. Unrestricted domain blocking gave best results for satisfiable problems showing it is a powerful technique indispensable for bottom-up model generation methods. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Limiting the creation of terms during the inference process by using the new range restricting transformation has paid off, especially when using it together with a shifting transformation. The experimental results also show that classical range restriction with unrestricted blocking provides a useful complementary method. Overall, the results showed bottom-up model generation methods were good for disproving theorems and generating models for satisfiable problems, but less efficient than SPASS in auto mode for unsatisfiable problems. For this paper, we propose that this new feature would be a step in the right direction.", "histories": [["v1", "Mon, 28 Nov 2016 07:54:50 GMT  (49kb)", "https://arxiv.org/abs/1611.09014v1", null], ["v2", "Tue, 29 Nov 2016 22:30:09 GMT  (49kb)", "http://arxiv.org/abs/1611.09014v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["peter baumgartner", "renate a schmidt"], "accepted": false, "id": "1611.09014"}, "pdf": {"name": "1611.09014.pdf", "metadata": {"source": "CRF", "title": "Blocking and Other Enhancements for Bottom-Up Model Generation Methods", "authors": ["Peter Baumgartner", "Renate A. Schmidt"], "emails": [], "sections": [{"heading": null, "text": "Model generation is a problem complementary to theorem proving and is important for fault analysis and debugging of formal specifications of, for example, security protocols, programs and terminological definitions. This paper discusses several ways of enhancing the paradigm of bottom-up model generation. The two main contributions are new, generalized blocking techniques and a new range-restriction transformation. The blocking techniques are based on simple transformations of the input set together with standard equality reasoning and redundancy elimination techniques. These provide general methods for finding small, finite models. The range-restriction transformation refines existing transformations to range-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and a classical range-restriction technique were tested on the clausal problems of the TPTP Version 6.0.0 with an implementation based on the SPASS theorem prover using a hyperresolution-like refinement. Unrestricted domain blocking gave best results for satisfiable problems showing it is a powerful technique indispensable for bottom-up model generation methods. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Limiting the creation of terms during the inference process by using the new range restricting transformation has paid off, especially when using it together with a shifting transformation. The experimental results also show that classical range restriction with unrestricted blocking provides a useful complementary method. Overall, the results showed bottom-up model generation methods were good for disproving theorems and generating models for satisfiable problems, but less efficient than SPASS in auto mode for unsatisfiable problems."}, {"heading": "1 Introduction", "text": "The bottom-up model generation (BUMG) paradigm encompasses a wide family of calculi and proof procedures that explicitly try to construct a model of a given clause set by reading clauses as rules and applying them in a bottom-up way until completion. For instance, variants of hyperresolution and grounding\n\u2217P. Baumgartner, Data61, CSIRO, Australia\nR. A. Schmidt, School of Computer Science, The University of Manchester, UK\n2\ntableau calculi belong to this family. BUMG methods have been known for a long time to useful for proving theorems, comparably little effort has however been undertaken to exploit them for the dual task, namely, computing models for satisfiable problems. This is somewhat surprising, as computing models is recognized as being important in software engineering, model checking, and other applications for fault analysis and debugging of logical specifications.\nOne of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models.\nIn our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found.\nThe second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Scho\u0308nfinkel class.\nOther methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003]. In contrast, MACEstyle model builders such as, for example, the methods of Claessen and So\u0308rensson [2003] and McCune [1994] reduce model search to testing of propositional satisfi-\n3\nability. Being based on a translation, the MACE-style approach is conceptually related, but different to our approach. Both SEM- and MACE-style methods search for finite models, by essentially searching the space of interpretations with domain sizes 1, 2, . . ., in increasing order, until a model is found.\nOur method operates significantly differently, as it is not parameterized by a domain size. Consequently, there is no requirement for iterative deepening over the domain size, and the search for finite models works differently. This way, we can address a problem often found with models computed by these methods: from a pragmatic perspective, they tend to identify too many terms. For instance, for the two unit clauses P(a) and Q(b) there is a model that identifies a and b with the same object. Such models can be counter-intuitive, for instance, in a description logic setting, where unique names are often assumed, but not necessarily explicitly specified. Furthermore, logic programs are typically understood with respect to Herbrand semantics, and it is desirable to develop compatible model building techniques. We present transformations that are more careful at identifying objects than the methods mentioned and thus work closer to a Herbrand semantics.\nThe structure of the paper is as follows. Definitions of basic terminology and notation can be found in Section 2. In Section 3 we recall the characteristic properties of BUMG methods. The main part of the paper are Sections 4 to 9. Sections 4, 5 and 6 define new techniques for generating small models and generating them more efficiently. The techniques are based on a series of transformations including a refined range-restricting transformation (Section 4), instances of standard renaming and flattening (Section 5), and the introduction of blocking in various forms through amendments of the clause set and standard saturation-based equality reasoning (Section 6). Soundness and completeness of the blocking transformations and the combined transformations is shown in Section 7. One consequence of the results is a general decidability result of the Bernays-Scho\u0308nfinkel class for all BUMG methods and related approaches. This is presented in Section 8. In Section 9 we present and discuss results of experiments carried out with our methods on clausal problems in the TPTP library.\nThis paper is an extended and improved version of Baumgartner and Schmidt [2006]."}, {"heading": "2 Basic Definitions", "text": "We use standard terminology from automated reasoning. We assume as given a signature \u03a3 = \u03a3f \u222a \u03a3P of function symbols \u03a3f (including constants) and predicate symbols \u03a3P . As we are working (also) with equality, we assume \u03a3P contains a distinguished binary predicate symbol \u2248, which is used in infix form. Terms, atoms, literals and formulas over \u03a3 and a given (denumerable) set of variables V are defined as usual.\nA clause is a (finite) implicitly universally quantified disjunction of literals. We write clauses in a logic-programming style, that is, we write H1\u2228\u00b7 \u00b7 \u00b7\u2228Hm \u2190 B1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Bk rather than H1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Hm \u2228 \u00acB1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00acBk, where m, k \u2265 0. Each Hi is called a head atom, and each Bj is called a body atom. When writing expressions such as H \u2228H \u2190 B \u2227B we mean any clause whose head literals are H and those in the disjunction of literals H, and whose body literals are B and\n4\nthose in the conjunction of literals B. A clause set is a finite set of clauses. A clause H \u2190 B is said to be range-restricted iff the body B contains all the variables in it. This means that a positive clause H \u2190 \u22a4 is range-restricted only if it is a ground clause. A clause set is range-restricted iff it contains only range-restricted clauses.\nFor a given atom P (t1, . . . , tn) the terms t1, . . . , tn are also called the toplevel terms of P (t1, . . . , tn) (P being \u2248 is permitted). This notion generalizes to clause bodies, clause heads and clauses as expected. For example, for a clause H \u2190 B the top-level terms of its body B are exactly the top-level terms of its body atoms.\nA proper functional term is a term that is neither a variable nor a constant. A (Herbrand) interpretation I is a set of ground atoms, namely, those that are true in the interpretation. Satisfiability/validity in a Herbrand interpretation of ground literals, clauses, and clause sets is defined as usual. Also, as usual, a clause set stands semantically for the set of all its ground instances. We write I |= F to denote that I satisfies F , where F is a ground literal or a (possibly non-ground) clause (set).\nAn E-interpretation is an interpretation that is also a congruence relation on the terms in the signature. If I is an interpretation, we denote by IE the smallest congruence relation on the terms that includes I, which is an E-interpretation. An E-interpretation does not necessarily need to be a Herbrand-E-interpretation and is a standard first-order interpretation I such that (I, \u00b5) |= s \u2248 t if and only if (I, \u00b5)(s) = (I, \u00b5)(t) (where \u00b5 is a valuation, that is, a mapping from the variables to the domain |I| of I). We say that I E-satisfies F iff IE |= F . Instead of IE |= F we write I |=E F .\nIt is well-known that E-interpretations can be characterized by fixing the domain as the Herbrand universe and requiring that for every ground term t, t \u2248 t \u2208 I, and for every ground atom A (including ground equations) the following is true: whenever I |= A[s] and I |= s \u2248 t, then I |= A[t].\nAnother characterization is to add to a given clause setM its equality axioms EAX(\u03a3P \u222a\u03a3f ), that is, the axioms expressing that \u2248 is a congruence relation on the terms and atoms induced by the predicate symbols \u03a3P and function symbols \u03a3f occurring inM . It is well-known thatM is E-satisfiable iffM\u222aEAX(\u03a3P\u222a\u03a3f ) is satisfiable.\nWe work mostly, but not always, with Herbrand interpretations. If not, we always make this clear, and the interpretations considered then are first-order logic interpretations with domains that are (proper) subsets of the Herbrand universe of the clause set under consideration. Such interpretations are called quasi-Herbrand interpretations . When constructing such interpretations the requirement that function symbols are interpreted as total functions over their domain is not always trivially satisfied. For instance, in the presence of a constant a, a unary function symbol f , and the domain {a, f(a)}, say, one has to assign a value in the interpretation to every term. However f(f(a)), for instance, cannot be assigned to itself, as f(f(a)) is not contained in the domain."}, {"heading": "3 BUMG Methods", "text": "Proof procedures based on model generation approaches establish the satisfiability of a problem by trying to build a model for the problem. In this paper\n5\nwe are interested in bottom-up model generation approaches (BUMG). BUMG approaches use a forward reasoning approach where implications or clauses, H \u2190 B, are read as rules and are repeatedly used to derive (instances of) H from (instances of) B until a completion is found.\nThe family of BUMG approaches includes many familiar calculi and proof procedures such as Smullyan type semantic tableaux [Smullyan, 1971], SATCHMO [Manthey and Bry, 1988, Geisler et al., 1997], positive unit hyperresolution (PUHR) tableaux [Bry and Yahya, 2000, Bry and Torge, 1998], the model generation theorem proverMGTP [Fujita et al., 1995] and hypertableaux [Baumgartner et al., 1996]. A well-established and widely known method for BUMG is hyperresolution [Robinson, 1965].\nHyperresolution consists of two inference rules, hyperresolution and factoring. The hyperresolution rule applies to a non-positive clause H \u2190 B1\u2227 . . .\u2227Bn (n 6= 0) and n positive clauses C1 \u2228 B \u2032 1 \u2190 \u22a4, . . . , Cn \u2228 B \u2032 n \u2190 \u22a4, and derives (C1\u2228. . .\u2228Cn\u2228H)\u03c3 \u2190 \u22a4, where \u03c3 is the most general unifier such thatB \u2032 i\u03c3 = Bi\u03c3 for every i \u2208 {1, . . . , n}. The factoring rule derives the clause (C \u2228 B)\u03c3 \u2190 \u22a4 from a positive clause C \u2228 B \u2228 B\u2032 \u2190 \u22a4, where \u03c3 is the most general unifier of B and B\u2032. On range-restricted clauses, when using hyperresolution, factoring amounts to the elimination of duplicate literals in positive clauses and is therefore optional when clauses are viewed as sets.\nA crucial requirement for the effective use of blocking (considered later in Section 6) is support of equality reasoning (for example, ordered paramodulation, ordered rewriting or superposition [Bachmair and Ganzinger, 1998, Nieuwenhuis and Rubio, 2001]), in combination with simplification techniques based on orderings. We refer to Bachmair and Ganzinger [1998, 2001] for general notions of redundancy in saturation-based theorem proving approaches.\nOur experiments show the splitting rule is useful for BUMG. For our blocking transformations, splitting on the positive part of (ground) clauses is in fact mandatory to make it effective. This type of splitting replaces the branch of a derivation containing a positive clause C \u2228 D \u2190 \u22a4, say, by two copies of the branch in which the clause is replaced by C \u2190 \u22a4 and D \u2190 \u22a4, respectively, provided that C and D do not share any variables. Most BUMG procedures support this splitting technique, in particular, the provers we have used do."}, {"heading": "4 Range-Restricting Transformations", "text": "Existing transformations to range-restricted form followManthey and Bry [1988] (or are variations of it). The transformation can be defined by a procedure carrying out the following steps on a given set M of clauses.\n(0) Initialization. Initially, let crr(M) :=M .\n(1) Add a constant. Let dom be a \u2018fresh\u2019 unary predicate symbol not in \u03a3P , and let c be some constant. Extend crr(M) by the clause\ndom(c) \u2190 \u22a4.\nThe constant c can be \u2018fresh\u2019 or belong to \u03a3f .\n(2) Range-restriction. For each clause H \u2190 B in crr(M), let {x1, . . . , xk} be the set of variables occurring in H but not in B. Replace H \u2190 B by the\n6\nclause\nH \u2190 B \u2227 dom(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 dom(xk).\nWe refer to this clause as the clause corresponding to H \u2190 B.\n(3) Enumerate the Herbrand universe. For each n-ary f \u2208 \u03a3f , add the clauses:\ndom(f(x1, . . . , xn)) \u2190 dom(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 dom(xn).\nThe computed set crr(M) is the classical range-restricting transformation ofM . It is not difficult to see that crr(M) is indeed range-restricted for any clause set M . The transformation is sound and complete, that is, M is satisfiable iff crr(M) is satisfiable [Manthey and Bry, 1988, Bry and Yahya, 2000]. The size of crr(M) is linear in the size of M and can be computed in linear time.\nPerhaps the easiest way to understand the transformation is to imagine we use a BUMG method, for example, hyperresolution. The idea is to build the model(s) during the derivation. The clause added in Step (1) ensures that the domain of interpretation given by the domain predicate dom is non-empty. Step (2) turns clauses into range-restricted clauses. This is done by shielding the variables {x1, . . . , xk} in the head, that do not occur negatively, with the added negative domain literals. Clauses that are already range-restricted are unaffected by this step. Step (3) ensures that all elements of the Herbrand universe of the (original) clause set are added to the domain via hyperresolution inference steps.\nAs a consequence a clause setM with at least one non-nullary function symbols causes hyperresolution derivations to be unbounded for crr(M), unlessM is unsatisfiable. This is a negative aspect of the classical range-restricting transformation. However, the method has been shown to be useful for (domain-)minimal model generation when combined with other techniques [Bry and Yahya, 2000, Bry and Torge, 1998]. In particular, Bry and Torge [1998] use splitting and the \u03b4\u2217-rule to generate domain minimal models. In the present research we have evaluated the combination of blocking techniques (introduced later in Section 6) with the classical range-restricting transformation crr. This has shown promising empirical results as presented in Section 9.\nNext, we introduce a new transformation to range-restricted form. Instead of enumerating the generally infinite Herbrand universe in a bottom-up fashion, the intuition is that it generates terms only as needed.\nThe transformation involves extracting the non-variable top-level terms in an atom. Let P (t1, . . . , tn) be an atom and suppose x1, . . . , xn are fresh variables. For all i \u2208 {1, . . . , n} let si = ti, if ti is a variable, and si = xi, otherwise. The atom P (s1, . . . , sn) is called the term abstraction of P (t1, . . . , tn). Let the abstraction substitution \u03b1 be defined by\n\u03b1 = {xi 7\u2192 ti | 1 \u2264 i \u2264 n and ti is not a variable}.\nHence, P (s1, . . . , sn)\u03b1 = P (t1, . . . , tn), that is, \u03b1 reverts the term abstraction. The new range-restricting transformation, denoted by rr, of a clause set M is the clause set obtained by carrying out the following steps (explanations and an example are given afterwards):\n7\n(0) Initialization. Initially, let rr(M) :=M .\n(1) Add a constant. Same as Step (1) in the definition of crr.\n(2) Domain elements from clause bodies. For each clause H \u2190 B in M and each atom P (t1, . . . , tn) from B, let P (s1, . . . , sn) be the term abstraction of P (t1, . . . , tn) and let \u03b1 be the corresponding abstraction substitution. Extend rr(M) by the set\n{dom(xi)\u03b1 \u2190 P (s1, . . . , sn) | 1 \u2264 i \u2264 n and xi 7\u2192 ti \u2208 \u03b1}.\n(3) Range-restriction. Same as Step (2) in the definition of crr.\n(4) Domain elements from \u03a3P . For each n-ary P in \u03a3p, extend rr(M) by the set\n{dom(xi) \u2190 P (x1, . . . , xn) | i \u2264 i \u2264 n}.\n(5) Domain elements from \u03a3f . For each n-ary f in \u03a3f , extend rr(M) by the set\n{dom(xi) \u2190 dom(f(x1, . . . , xn)) | 1 \u2264 i \u2264 n}.\nThe intuition of the transformation reveals itself if we think of what happens when using hyperresolution. The idea is again to build model(s) during the derivation, but this time terms are added to the domain only as necessary. Steps (1) and (3) are the same as Steps (1) and (2) in the definition of crr. The clauses added in Step (2) cause functional terms that occur negatively in the clauses to be inserted into the domain. Step (4) ensures that positively occurring functional terms are added to the domain, and Step (5) ensures that the domain is closed under subterms.\nTo illustrate the steps of the transformation consider the following clause.\nq(x, g(x, y)) \u2228 r(y, z) \u2190 p(a, f(x, y), x) (\u2020)\nIt is added to rr(M) in Step (0). Suppose the clause added in Step (1) is\ndom(a).\nFor Step (2) the term abstraction of the body literal of clause (\u2020) is p(x1, x2, x) and the abstraction substitution is \u03b1 = {x1 7\u2192 a, x2 7\u2192 f(x, y)}. The clauses added in Step (2) are the following:\ndom(a) \u2190 p(x1, x2, x)\ndom(f(x, y)) \u2190 p(x1, x2, x) (\u2021)\nNotice that among the four clauses we have so far the clauses (\u2020) and (\u2021) are not range-restricted. They are however replaced by range-restricted clauses in Step (3), namely:\nq(x, g(x, y)) \u2228 r(y, z) \u2190 p(a, f(x, y), x) \u2227 dom(z) (\u2020\u2020)\ndom(f(x, y)) \u2190 p(x1, x2, x) \u2227 dom(y).\n8\nStep (4) generates clauses responsible for inserting the terms that occur in the heads of clauses into the domain. That is, for each i \u2208 {1, 2, 3} and each j \u2208 {1, 2} these clauses are added.\ndom(xi) \u2190 p(x1, x2, x3)\ndom(xj) \u2190 q(x1, x2)\ndom(xj) \u2190 r(x1, x2)\nFor instance, when a model assigns true to the instance q(a, g(a, f(a, a))) of one of the head atoms of the clause (\u2020\u2020), then dom(a) and dom(g(a, f(a, a))) are also true. It is not necessary to insert the terms of the instance of the other head atom into the domain. The reason is that it does not matter how these (extra) terms are evaluated, or whether the atom is evaluated to true or false in order to satisfy the disjunction.\nThe clauses added in Step (4) alone are not sufficient, however. For each term in the domain all its subterms have to be in the domain, too. This is achieved with the clauses obtained in Step (5). That is, for each j \u2208 {1, 2} these clauses are added.\ndom(xj) \u2190 dom(f(x1, x2))\ndom(xj) \u2190 dom(g(x1, x2))\nFor the purposes of model generation, it is important to note that one particular type of clause in the rr transformation should not be treated as a normal clause. For the equality predicate, Step (4) produces the clauses\ndom(x) \u2190 x \u2248 y dom(y) \u2190 x \u2248 y. (#)\nMost theorem provers simplify these clauses to dom(x). As a consequence this can lead to all negative domain literals being resolved away and all clauses containing a positive domain literal to be subsumed. This means range-restriction is undone. This is what happens in SPASS.\nSince Step (4) clauses really only need to be added for positively occurring predicate symbols an easy solution involves replacing any positive occurrence of the equality predicate by a predicate symbol myequal (say), which is fresh in the signature, and adding the clauses\ndom(x) \u2190 myequal(x, y) dom(y) \u2190 myequal(x, y)\nin Step (4) rather than (#). In addition, the clause set needs to be extended by this definition of myequal.\nx \u2248 y \u2190 myequal(x, y)\nThis solution has the intended effect of adding terms occurring in positive equality literals to the domain, and prevents other inferences or reductions on myequal. It is not difficult to prove that E-satisfiability is preserved in both directions. We will implicitly use this fact in the proofs below.\nProposition 1 (Completeness of range-restriction). Let M be any clause set. If rr(M) is satisfiable then M is satisfiable.\n9\nProof. Suppose rr(M) is satisfiable. Let Irr be a Herbrand model of rr(M). We define a quasi-Herbrand interpretation I and show that it is a model of M .\nFirst, the domain of I is defined as the set |I| = {t | Irr |= dom(t)}. Now, to define a total interpretation for the function symbols, we map each n-ary function symbol f in \u03a3f to the function f I : |I| \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 |I| 7\u2192 |I|, where, for all d1, . . . , dn \u2208 |I|,\nf I(d1, . . . , dn) :=\n{\nf(d1, . . . , dn) if f(d1, . . . , dn) \u2208 |I|, and\nc otherwise.\nHere, the constant c is the one mentioned in Step (1) of the transformation. (It is clear that |I| contains c.)\nNotice that due to Step (5) the domain |I| must contain for each term all its subterms. An easy consequence is that all terms in |I| are evaluated as themselves, exactly as in Herbrand interpretations. Each other (ground) term is evaluated as some other term from |I|. For instance, if |I| = {c, f(c)} then I(f(g(c))) = f I(I(g(c))) = f I(gI(c)) = f I(c) = f(c), since g(c) 6\u2208 |I| and by the definition of gI . We see that f is indeed mapped to a total function over the domain |I|, as required.\nRegarding the interpretation of the predicate symbols in I, define for every n-ary predicate symbol P in \u03a3P and for all d1, . . . , dn \u2208 |I|:\nP (d1, . . . , dn) \u2208 I iff P (d1, . . . , dn) \u2208 Irr . (1)\nThat is, the interpretation of the predicate symbols in I is the same as in Irr under the restriction of the domain to |I| \u2286 |Irr|.\nIt remains to show that I is a model ofM . It suffices to pick a clause H \u2190 B fromM arbitrarily and show that I satisfies this clause. We do this by assuming that I does not satisfy H \u2190 B and deriving a contradiction.\nThat I does not satisfy H \u2190 B means there is a valuation \u00b5 such that (I, \u00b5) |= B but (I, \u00b5) 6|= H. As usual, a valuation is a (total) mapping from the variables to the domain under consideration.\nBecause the domain |I| consists of (ground) terms, the valuation \u00b5 can be seen as a substitution. Thus, B\u00b5 is a set of ground atoms, and B\u00b5 \u2286 I may or may not hold. We show next that if (I, \u00b5) |= B, as given, then B\u00b5 \u2286 I. In other words, the body is satisfied in I because |I| contains all body atoms B\u00b5, but not for the reason that I assigns true to some body atom B with some argument term evaluated to c, and that atom being contained in I. An example for the latter case is |I| = {c}, B = P(x), I = {P(c)} and \u00b5 = {x 7\u2192 a}. Although we have (I, \u00b5) |= P (x), in essence because aI = c, it does not hold that P(a) \u2208 I. The relevance of this result is that it allows syntactically based reasoning further below to show that I is a model of M .\nTo show B\u00b5 \u2286 I it suffices to choose any body literal P (t1, . . . , tn) from B arbitrarily and show P (t1, . . . , tn)\u00b5 \u2208 I. Now from (I, \u00b5) |= B it follows that (I, \u00b5) |= P (t1, . . . , tn). Reading \u00b5 as a ground substitution this means P (I(t1\u00b5), . . . , I(tn\u00b5)) \u2208 I. Using the equivalence (1) it follows that P (I(t1\u00b5), . . . , I(tn\u00b5)) \u2208 Irr. To show P (t1, . . . , tn)\u00b5 \u2208 I, as required, it thus suffices to show I(ti\u00b5) = ti\u00b5, because P (t1, . . . , tn)\u00b5 \u2208 I follows from P (I(t1\u00b5), . . . , I(tn\u00b5)) \u2208 Irr and equivalence (1).\nThus, let us show I(ti\u00b5) = ti\u00b5. By the definition of the interpretation function \u00b7I it is enough to show ti\u00b5 \u2208 |I| (as said above, terms from |I| are\n10\nevaluated to themselves). If ti is a variable then ti\u00b5 \u2208 |I| follows from the fact that \u00b5 was chosen as a substitution into |I|. Assume now that ti is not a variable and let P (s1, . . . , sn) be the term abstraction of P (t1, . . . , tn) and \u03b1 its abstraction substitution. By transformation Step (2), rr(M) includes the clause\ndom(xi)\u03b1 \u2190 P (s1, . . . , sn), (2)\nwhere {xi 7\u2192 ti} \u2208 \u03b1. By the definition of an abstraction, for all j \u2208 {1, . . . , n}, sj is a fresh variable whenever tj is not a variable.\nRecall from above that P (I(t1\u00b5), . . . , I(tn\u00b5)) \u2208 Irr. We are going to show now that with clause (2) this entails dom(ti\u00b5). By the construction of |I| this suffices to prove ti\u00b5 \u2208 |I|, as desired.\nConsider the substitution\n\u00b5\u2032 = \u00b5{xj 7\u2192 I(tj\u00b5) | xj 7\u2192 tj \u2208 \u03b1}.\nIt agrees with \u00b5 (in particular) when tj is a variable and otherwise maps the variable xj to I(tj\u00b5).\nWhen tj is a variable then let sj = tj be the definition of an abstraction. This means sj\u00b5\n\u2032 = sj\u00b5 = tj\u00b5 = I(tj\u00b5) (the latter identity holds, again, because \u00b5 is a substitution into |I| and elements from |I| evaluate to themselves). When tj is not a variable then sj is the variable xj . By construction of \u00b5\n\u2032 we have sj\u00b5 \u2032 = xj\u00b5 \u2032 = I(tj\u00b5). Hence, in both cases sj\u00b5\n\u2032 = I(tj\u00b5). Applying the substitution \u00b5\u2032 to the clause (2) yields\ndom(xi)\u03b1\u00b5 \u2032 \u2190 P (s1, . . . , sn)\u00b5 \u2032 .\nWith the identities sj\u00b5 \u2032 = I(tj\u00b5), the identities dom(xi)\u03b1\u00b5 \u2032 = dom(ti)\u00b5 \u2032 and the fact that P (I(t1\u00b5), . . . , I(tn\u00b5)) \u2208 Irr it follows that dom(ti)\u00b5 \u2032 \u2208 Irr. The substitution \u00b5 and \u00b5\u2032 differ in their domains only on the fresh variables x1, . . . , xn. Therefore dom(ti)\u00b5\n\u2032 = dom(ti)\u00b5 and dom(ti)\u00b5 \u2208 Irr follows, as desired. This was the last subgoal to be proven to establish P (t1, . . . , tn)\u00b5 \u2208 I, which, in turn, remained to be shown to complete the proof that B\u00b5 \u2286 I. The next step in the proof is to show that the clause body of the clause in rr(M) corresponding to H \u2190 B is satisfied by Irr. That clause is the rangerestricted version of the clause H \u2190 B in M . According to Step (3) of the transformation it has the form\nH \u2190 B \u2227 dom(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 dom(xk) (3)\nfor some variables x1, . . . , xk; those occurring in H but not in B. From B\u00b5 \u2286 I as derived above and equivalence (1) it follows that B\u00b5 \u2286 Irr. Recall that \u00b5 is a valuation mapping into the domain |I|. Reading it as a substitution gives xj\u00b5 \u2208 |I|, for all j \u2208 {1, . . . , k}. From the construction of |I| it follows that dom(xj\u00b5) \u2208 Irr. Together with B\u00b5 \u2286 Irr and the fact that Irr is a model of rr(M), and hence of clause (3), it follows that Irr satisfies H\u00b5. This means A\u00b5 \u2208 Irr for some head atom A in H.\nThe atom A is of the form Q(s1, . . . , sm) for some m-ary predicate symbol Q and terms s1, . . . , sm. By Step (4) of the transformation, rr(M) includes, for all i \u2208 {1, . . . ,m} the clause\ndom(xi) \u2190 Q(x1, . . . , xm). (4)\n11\nAgain by reading \u00b5 as a substitution, because Irr is a model of rr(M), and hence of clause (4), and by the identities Q(s1\u00b5, . . . , sm\u00b5) = Q(s1, . . . , sm)\u00b5 = A\u00b5 \u2208 Irr we conclude dom(si\u00b5) \u2208 Irr, for all i \u2208 {1, . . . ,m}. By construction of |I| we have that si\u00b5 \u2208 |I|. By equivalence (1) it follows that Q(s1\u00b5, . . . , sm\u00b5) \u2208 I.\nRecall that Q(s1, . . . , sm) is a head atom of the clause (3) and hence a head atom of the clause H \u2190 B. Further recall that si\u00b5 \u2208 |I| entails that si\u00b5 is evaluated to itself in I. Together with Q(s1\u00b5, . . . , sm\u00b5) \u2208 I this means (I, \u00b5) |= Q(s1, . . . , sm). This is a contradiction to (I, \u00b5) 6|= H as concluded above. The proof is complete.\nThe proof actually gives a characterization of the models associated with a satisfiable clause set rr(M).\nCorollary 1 (Completeness of range-restriction wrt. E-interpretations). Let M be any clause set. If rr(M) is E-satisfiable then M is E-satisfiable.\nProof. We prove the contra-positive statement. Thus assumeM is E-unsatisfiable. Equivalently, M \u222a EAX(\u03a3P \u222a \u03a3f ) is unsatisfiable. By Proposition 1, rr(M \u222a EAX(\u03a3P \u222a\u03a3f )) is unsatisfiable. Observe Steps (2) and (3), which are the only ones that apply directly to the given clauses, have no effect on the equality axioms EAX(\u03a3P \u222a \u03a3f ), except for the reflexivity axiom x \u2248 x, which is replaced by x \u2248 x \u2190 dom(x). The transformed set rr(M \u222a EAX(\u03a3P \u222a \u03a3f )) coincides with\nrr(M) \u222a (EAX(\u03a3P \u222a \u03a3f ) \\ {x \u2248 x}) \u222a {x \u2248 x\u2190 dom(x)}.\nAdding back the reflexivity axiom trivially preserves unsatisfiability, that is, with rr(M \u222a EAX(\u03a3P \u222a \u03a3f )) being unsatisfiable, so is\nrr(M) \u222a EAX(\u03a3P \u222a \u03a3f ) \u222a {x \u2248 x\u2190 dom(x)}.\nThe clause x \u2248 x\u2190 dom(x) can be deleted because it is subsumed by the clause x \u2248 x \u2208 EAX(\u03a3P \u222a \u03a3f ). Hence,\nrr(M) \u222a EAX(\u03a3P \u222a \u03a3f )\nis unsatisfiable, and so rr(M) is E-unsatisfiable.\nWe emphasize that we do not propose to actually use the equality axioms in conjunction with a theorem prover (though they can of course). They serve merely as a theoretical tool to prove completeness of the transformation.\nProposition 2. Let M be any clause set. Then\n(i) The size of rr(M) is bounded by a linear function in the size of M .\n(ii) rr(M) can be computed in quadratic time.\n(iii) rr(M) is range-restricted.\nBy carefully modifying the definition of rr and at the expense of some duplication it is possible to compute the reduction in linear time.\nProposition 2 (iii) confirms that every clauses produced by the rr transformation is range-restricted.\n12\nLet us consider another example to get a better understanding of the rr transformation.\nr(x) \u2190 q(x) \u2227 p(f(x)). (\u2217)\nApplying Steps (2) and (3) of the rr transformation gives us the clause\ndom(f(x)) \u2190 dom(x) \u2227 p(y).\nThis clause is splittable into\ndom(f(x)) \u2190 dom(x) and \u22a5 \u2190 p(y).\nThe first split component clause is an example of an \u2018enumerate the Herbrand universe\u2019 clause from the crr transformation (Step (2) in the definition of crr). Such clauses are unpleasant because they cause the entire Herbrand universe to be enumerated with BUMG approaches.\nBefore describing a solution let us analyze the problem further. The main rationale of our rr transformation is to constrain the generation of domain elements and limit the number of inference steps. The general form of clauses produced by Step (2), followed by Step (3), is the following, where y \u2286 x, x \u2286 y \u222a z and u \u2286 z.\ndom(f(x)) \u2190 dom(y1) \u2227 . . . \u2227 dom(yn) \u2227 P (z)\ndom(f(u)) \u2190 P (z)\nClauses of the first form are often splittable (as in the example above), and can produce clauses of the unwanted form\ndom(f(y)) \u2190 dom(y1) \u2227 . . . \u2227 dom(yn).\nSuppose therefore that splitting of any clause is forbidden when this splits the negative part of the clause (neither SPASS nor a hypertableaux prover do this anyway). Although the two types of clauses above both do reduce the number of terms created, compared to the classical range-restricting transformation, the constraining effect of the first type of clauses is slightly limited. Terms f(s) are not generated, only when no fact P (t) is present or has been derived. When a clause P (t) is present, or as soon as such a clause is derived (for any ground terms t), then terms are freely generated from terms already in the domain with f as the top symbol.\nHere is an example of a clause set for which the derivation is infinite on the rr transformation. (The example is an extension of the example above with the clause p(b) \u2190 \u22a4.)\np(b) \u2190 \u22a4 r(x) \u2190 q(x) \u2227 p(f(x))\nNotice the derivation is infinite on the classical range-restricting transformation as well, due to the generated clauses dom(b) \u2190 \u22a4 and dom(f(x)) \u2190 dom(x).\nThe second type of clauses, dom(f(u)) \u2190 P (z), are less problematic. Here is a concrete example. For \u22a5 \u2190 r(x, f(x)), Step (2) produces the clause\ndom(f(x)) \u2190 r(x, y).\nAlthough this clause, and the general form, still causes larger terms to be built with hyperresolution type inferences, the constraining effect is larger.\nIn the next two sections we discuss ways of improving range-restricting transformations further.\n13"}, {"heading": "5 Shifting Transformation", "text": "The clauses introduced in Step (2) of the new rr transformation to rangerestricted form use abstraction and insert (possibly a large number of) instantiations of terms occurring in the clause bodies into the domain. These are sometimes unnecessary and can lead to non-termination of BUMG procedures.\nThe shifting transformation introduced next can address this problem. It consists of two sub-transformations, basic shifting and partial flattening.\nIfA is an atom P (t1, . . . , tn) then let not A denote the atom not P (t1, . . . , tn), where not P is a fresh predicate symbol which is uniquely associated with the predicate symbol P . If P is the equality symbol \u2248 we write not P as 6\u2248 and use infix notation.\nNow, the basic shifting transformation of a clause set M is the clause set bs(M) obtained from M by carrying out the following steps.\n(0) Initialization. Initially, let bs(M) :=M .\n(1) Shifting deep atoms. Replace each clause in bs(M) of the form H \u2190 B1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Bm \u2227 B, where each atom B1, . . . , Bm contains at least one proper functional term and B contains no proper functional term, by the clause\nH \u2228 not B1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 not Bm \u2190 B.\nEach of the atoms B1, . . . , Bm is called a shifted atom.\n(2) Shifted atom consistency. Extend bs(M) by the clause set\n{\u22a5 \u2190 P (x1, . . . , xn) \u2227 not P (x1, . . . , xn) |\nP is the n-ary predicate symbol of a shifted atom}.\nNotice that we do not add clauses complementary to the \u2018shifted atoms consistency\u2019 clauses, that is, P (x1, . . . , xn) \u2228 not P (x1, . . . , xn) \u2190 \u22a4. They could be included but are superfluous.\nLet us continue the example given at the end of the previous section. We can use basic shifting to move negative occurrences of functional terms into heads. In the example, clause (\u2217) is replaced by\nr(x) \u2228 not p(f(x)) \u2190 q(x) (\u2217\u2217)\n\u22a5 \u2190 not p(x) \u2227 p(x)\ndom(x) \u2190 r(x) dom(x) \u2190 not p(x)\nEven in the presence of an additional clause, say, q(x) \u2190 \u22a4, which leads to the clauses\ndom(a) \u2190 \u22a4 q(x) \u2190 dom(x),\ntermination of BUMG can be achieved. For instance, in a hyperresolution-like mode of operation and with splitting enabled, the SPASS prover [Weidenbach et al., 2007, 2009] splits the derived clause r(a) \u2228 not p(f(a)), considers the case with the smaller literal r(a) first\n14\nand terminates with a model . This is because a finite completion (model) is found without considering the case of the bigger literal not p(f(a)), which would have added the deeper term f(a) to the domain. The same behaviour can be achieved, for example, with the KRHyper BUMG prover, a hypertableaux theorem prover [Wernhard, 2003].\nAs can be seen in the example, the basic shifting transformation trades the generation of new domain elements for a smaller clause body by removing literals from it. Of course, a smaller clause body affects the search space, as then the clause can be used as a premise more often. To (partially) avoid this effect, we propose an additional transformation to be performed prior to the basic shifting transformation.\nFor a clause set M , the partial flattening transformation is the clause set pf(M) obtained by applying the following steps.\n(0) Initialization. Initially, let pf(M) :=M .\n(1) Reflexivity. Extend pf(M) by the unit clause x \u2248 x\u2190 \u22a4.\n(2) Partial flattening. For each clause H \u2190 B in pf(M), let t1, . . . , tn be all top-level terms occurring in the non-equational literals in the body B that are proper functional terms, for some n \u2265 0. Let x1, ..., xn be fresh variables. Replace the clause H \u2190 B[t1, . . . , tn] by the clause\nH \u2190 B[x1, . . . , xn] \u2227 t1 \u2248 x1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 tn \u2248 xn.\nIt should be noted that the equality symbol \u2248 need not be interpreted as equality, but could. (Un-)satisfiability (and logical equivalence) is preserved even when reading it just as \u2018unifiability\u2019. This can be achieved by the clause x \u2248 x \u2190 \u22a4. One should however note that the reflexivity clause is not compatible with introducing the myequal predicate, so this might not always be a possibility. (In our implementation, for this reason the reflexivity clause is not added.)\nIn our running example, applying the transformations pf, bs and rr, in this order, yields the following clauses (among other clauses, which are omitted because they are not relevant to the current discussion).\nr(x) \u2228 f(x) 6\u2248 u\u2190 q(x) \u2227 p(u) dom(x) \u2190 x 6\u2248 y dom(x) \u2190 r(x)\n\u22a5 \u2190 x 6\u2248 y \u2227 x \u2248 y dom(y) \u2190 x 6\u2248 y\nObserve that the first clause is more restricted than the clause (\u2217\u2217) above because of the additional body literal p(u).\nThe reason for not extracting constants during partial flattening is that adding them to the domain does not cause non-termination of BUMG methods. It is preferable to leave them in place in the body literals because they have a stronger constraining effect than the variables introduced otherwise.\nExtracting top-level terms from equations has no effect at all. Consider the unit clause \u22a5 \u2190 f(a) \u2248 b, and its partial flattening \u22a5 \u2190 x \u2248 b \u2227 f(a) \u2248 x. Applying basic shifting yields f(a) 6\u2248 x \u2190 x \u2248 b, and, hyperresolution with x \u2248 x \u2190 \u22a4 gives f(a) 6\u2248 b \u2190 \u22a4. This is the same result as obtained by the transformations as defined. This explains why top-level terms of equational literals are excluded from the definition. (One could consider using \u2018standard\u2019 flattening, that is, recursively extracting terms, but this does not lead to any improvements over the defined transformations.)\n15\nFinally, we combine basic shifting and partial flattening to give the shifting transformation, formally defined by sh := pf \u25e6 bs, that is, sh(M) = bs(pf(M)), for any clause set M .\nProposition 3 (Completeness of shifting). Let M be any clause set. If sh(M) is satisfiable then M is satisfiable.\nProof. Not difficult, since bs (basic shifting) can be seen to be a structural transformation and pf (partial flatting) is a form of term abstraction.\nCorollary 2 (Completeness of shifting wrt. E-interpretations). Let M be any clause set. If sh(M) is E-satisfiable then M is E-satisfiable.\nProof. Using the same line of argument as in the proof of Corollary 1, proving preservation of E-satisfiability can be reduced to proving preservation of satisfiability by means of the equality axioms (observe that the shifting transformation does not modify the equality axioms)."}, {"heading": "6 Blocking", "text": "The final transformation introduced in this paper is called blocking and provides a mechanism for detecting recurrence in the derived models. The blocking transformation is designed to realize a \u2018loop check\u2019 for the construction of a domain, by capitalizing on available, powerful equality reasoning technology and redundancy criteria from saturation-based theorem proving. To be suitable, a resolution-based prover, for instance, should support hyperresolution-style inference, strong equality inference (for example, superposition or ordered rewriting), splitting, and the possibility to search for split-off equations first and standard redundancy elimination techniques.\nThe basic idea behind blocking is to add clauses that cause a case analysis of the form s \u2248 t versus s 6\u2248 t, for (ground) terms s and t. Although such a case analysis obviously leads to a bigger search space, it provides a powerful technique to detect finite models with a BUMG prover. This is because in the case that s \u2248 t is assumed, this new equation may lead to rewriting of otherwise infinitely many terms into one single term. To make this possible, the prover must support the above features, including notably splitting. Among resolution theorem provers splitting has become standard. Splitting was first available in the saturation-based prover SPASS [Weidenbach et al., 2007, 2009], but is now also part of VAMPIRE [Riazanov and Voronkov, 2002] and E [Schulz, 2013]. Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007].\nBlocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework. Unsound theorem proving has been incorporated later in DPLLT-based theorem proving Bonacina et al. [2011].\nIn the following we introduce four different, but closely related, blocking transformations, called subterm domain blocking, subterm predicate blocking, unrestricted domain blocking and unrestricted predicate blocking. Subterm domain\n16\nblocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006]. Subterm predicate blocking is inspired by and related to the blocking technique described in Hustadt and Schmidt [1999]. Unrestricted domain blocking is the first-order version of the unrestricted blocking rule introduced in Schmidt and Tishkovsky [2007] and used for developing terminating tableau calculi for logics with the effective finite model property in Schmidt and Tishkovsky [2008, 2011]."}, {"heading": "6.1 Subterm Domain Blocking", "text": "By definition, the subterm domain blocking transformation of a clause set M is the clause set sdb(M) obtained from M by carrying out the following steps.\n(0) Initialization. Initially, let sdb(M) :=M .\n(1) Axioms describing the subterm relationship. Let sub be a \u2018fresh\u2019 binary predicate symbol not in \u03a3P . Extend sdb(M) by\nsub(x, x) \u2190 dom(x)\nand, for every n-ary function symbol f \u2208 \u03a3f and all i \u2208 {1, . . . , n}, add the clauses\nsub(x, f(x1, . . . , xn)) \u2190 sub(x, xi) \u2227 dom(x) \u2227 dom(f(x1, . . . , xn)).\n(2) Subterm equality case analysis. Extend sdb(M) by these clauses.\nx \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y)\n\u2190 x \u2248 y \u2227 x 6\u2248 y\nThe subterm domain blocking transformation allows to contemplate whether two domain elements that are in a subterm relationship should be identified and merged, or not.\nThis blocking transformation preserves range-restrictedness. In fact, because the dom predicate symbol is mentioned in the definition, the blocking transformation can be applied meaningfully only in combination with range-restricting transformations.\nReading sub(s, t) as \u2018s is a subterm of t\u2019, Step (1) in the blocking transformation might seem overly involved, because an apparently simpler specification of the subterm relationship for the terms of the signature \u03a3f can be given. Namely:\nsub(x, x) \u2190 dom(x) sub(x, f(x1, x2 . . . , xn)) \u2190 sub(x, xi)\nfor every n-ary function symbol f \u2208 \u03a3f and all i \u2208 {1, . . . , n}. This clause set is range-restricted. Yet, this specification is not suitable for our purposes. The problem is that the second clause introduces proper functional terms.\nFor example, for a given constant a and a unary function symbol f, when just dom(a) alone has been derived, a BUMG procedure derives an infinite sequence of clauses:\nsub(a, a), sub(a, f(a)), sub(a, f(f(a))), . . . .\n17\nThis does not happen with the specification in Step (1). It ensures that conclusions of BUMG inferences involving sub are about terms currently in the domain, and the domain is always finite.\nTo justify the clauses added in Step (2) we continue this example and suppose an interpretation that contains dom(a) and dom(f(a)). These might have been derived earlier in the run of a BUMG prover. Then, from the clauses added by blocking, the (necessarily ground) disjunction\nf(a) \u2248 a \u2228 f(a) 6\u2248 a \u2190 \u22a4\nis derivable. Now, it is important to use a BUMG prover with support for splitting and to equip it with an appropriate search strategy. In particular, when deriving a disjunction such as the one above, the \u2248-literal should be split off and the clause set obtained in this case should be searched first . The reason is that the (ground) equation f(a) \u2248 a thereby obtained can then be used for simplification and redundancy testing purposes. For example, should dom(f(f(a))) be derivable now (in the current branch), then any prover based a modern, saturation-based theory of equality reasoning is able to prove it redundant from f(a) \u2248 a and dom(a). Consequently, the domain is not be extended explicitly. The information that dom(f(f(a))) is in the domain is however implicit via the theory of equality."}, {"heading": "6.2 Subterm Predicate Blocking", "text": "Subterm domain blocking defined in the previous section applies blocking to domain terms where one is a proper subterm of the other. The idea of the subterm (unary) predicate blocking transformation is similar, but it merges only the (sub)terms in the extension of unary predicate symbols different to dom in the current interpretation.\nSubterm predicate blocking is defined as follows:\n(0) Initialization. Initially, let spb(M) :=M .\n(1) Axioms describing the subterm relationship. Same as Step (1) in the definition of sdb.\n(2) Subterm equality case analysis. Extend spb(M) by these clauses, for each unary predicate symbol p \u2208 \u03a3P . (Recall that \u03a3P does not contain dom.)\nx \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y) \u2227 p(x) \u2227 p(y)\nFinally, add the clause\n\u2190 x \u2248 y \u2227 x 6\u2248 y\nto spb(M).\nObserve that the only difference between this transformation and the subterm domain blocking transformation lies in Step (2). The clauses x \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y)\u2227 p(x)\u2227 p(y) added here are obviously more restrictive than their\n18\ncounterpart x \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y) in the definition of the subterm domain blocking transformation sdb.\nThat subterm predicate blocking is strictly more restrictive can be seen from the following example, which also helps to explain the rationale behind this transformation.\np(a) \u2190 q(f(x)) \u2190 p(x)\nAny BUMG prover terminates on the transformed clause set and returns the model\n{dom(a), dom(f(a)), p(a), q(f(a)), sub(a, f(a))}.\nNotice that the subterm predicate blocking transformation includes the clauses\nx \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y) \u2227 p(x) \u2227 p(y)\nx \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y) \u2227 q(x) \u2227 q(y).\nThese are however only applicable for sub(s, s), p(s) and q(s) which only lead to redundant BUMG inferences. The motivation behind these clauses is to block two p-literals (say) only when there are two literals p(s) and p(t) where s is a subterm of t. Conversely, if no such loop comes up, as in the example above, there is no reason for blocking. By contrast, the subterm domain blocking transformation sdb with its clause x \u2248 y\u2228x 6\u2248 y \u2190 sub(x, y) would be applicable even for distinct terms, leading to the (unnecessary) split into the cases a \u2248 f(a) and a 6\u2248 f(a).\nFrom a more general perspective, the spb transformation is motivated by the application to description logic knowledge bases [Hustadt and Schmidt, 1999, Baader and Sattler, 2001]. Often, such knowledge bases do not contain cyclic definitions, or only few definitions are cyclic. The subterm predicate transformation aims to apply blocking only to concepts (unary predicates) with cyclic definitions. Below, in Section 6.5, we discuss a description logic example to highlight the differences between the various blocking transformations."}, {"heading": "6.3 Unrestricted Domain Blocking", "text": "The two previous \u2018subterm\u2019 variants of the blocking transformation allow to speculatively identify terms and their subterms. The \u2018unrestricted\u2019 variants introduced next differ from both by allowing speculative identifications of any two terms.\nFor the \u2018domain\u2019 variant, called unrestricted domain blocking transformation, the definition is as follows.\n(0) Initialization. Initially, let udb(M) :=M .\n(1) Domain elements equality case analysis. Extend udb(M) by these clauses.\nx \u2248 y \u2228 x 6\u2248 y \u2190 dom(x) \u2227 dom(y)\n\u2190 x \u2248 y \u2227 x 6\u2248 y\nThere is a clear trade-off between this transformation and the subterm domain blocking transformation sdb. On the one hand, the unrestricted domain\n19\nblocking transformation induces a larger search space, as the bodies of the clauses x \u2248 y \u2228 x 6\u2248 y \u2190 dom(x) \u2227 dom(y) are less constrained than their counterparts in the subterm domain blocking transformation. This becomes obvious after extending the clause body of x \u2248 y \u2228 x 6\u2248 y \u2190 sub(x, y) from the sdb transformation with dom(x)\u2227dom(y), which does not change anything. On the other hand, the unrestricted domain blocking transformation enables the finding of models with smaller domains. This means fewer congruence classes on the Herbrand terms are induced by the equality relation \u2248. As our experiments show, such models can often be found quicker in satisfiable problems, even for the crr transformation.\nUsing the ideas of the termination proof in Schmidt and Tishkovsky [2013] for semantic ground tableau with unrestricted domain blocking for description logics with the expressive power similar to the two-variable fragment of firstorder logic, it can be shown BUMG with unrestricted domain blocking can return finite models, if they exist, even for problems of undecidable fragments. Carrying over also the results in Schmidt and Tishkovsky [2008] implies unrestricted domain blocking can be used in BUMG methods to return domain minimal models for logics with the effective finite model property."}, {"heading": "6.4 Unrestricted Predicate Blocking", "text": "The definition of the last variant of blocking, the unrestricted (unary) predicate blocking transformation, is as follows.\n(0) Initialization. Initially, let upb(M) :=M .\n(1) Term equality case analysis. Extend upb(M) by these clauses, for each unary predicate symbol p \u2208 \u03a3P .\nx \u2248 y \u2228 x 6\u2248 y \u2190 p(x) \u2227 p(y)\nFinally, add the clause\n\u2190 x \u2248 y \u2227 x 6\u2248 y\nto upb(M) .\nThis transformation allows to equate any two (distinct) terms in a p-relation, if there are any. The motivation is a combination of the above, to block cycles on p-literals if they arise, and to compute models with small domains."}, {"heading": "6.5 Comparison on an Example", "text": "It is instructive to compare the effects on the returned models of the four blocking transformations on an example from description logics. To this end, consider the description logic knowledge base (left) and its translation into clause logic (right) in Table 1. Notice that the cycle in the inclusion statements in the TBox (for p1 and p2) means some form of blocking is needed for decidability in tableaubased description logic systems. Likewise, blocking is needed to force BUMG methods to terminate on the translated clause form. Any of the four blocking transformations defined above suffice. Table 2 summarizes the behaviour of these transformations, in terms of interesting relations in the computed model.\n20\nTable 1: Sample description logic knowledge base and clausal form TBox ABox\np1 \u2291 \u2203 r.p2 p2 \u2291 \u2203 r.p1\np1 \u2291 \u2203 s.q\np 1 (a) p1(b)\np2(f(x)) \u2190 p1(x) q(h(x)) \u2190 p1(x)\nr(x, f(x)) \u2190 p 1 (x) s(x, h(x)) \u2190 p 1 (x) p1(g(x)) \u2190 p2(x) p1(a) \u2190\nr(x, g(x)) \u2190 p2(x) p1(b) \u2190\nWhen comparing in detail the blocking techniques developed for description logics it becomes clear that\nthe transformations rr \u25e6 \u03c4 and sh \u25e6 rr \u25e6 \u03c4 , for \u03c4 \u2208 {sdb, spb, udb, upb},\nwhen applied to a knowledge base with the finite model property, in conjunction with a suitable BUMG method (see above), can be refined to simulate various forms of standard blocking techniques used in description logic systems, including subset ancestor blocking and equality ancestor blocking, cf. Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al. [2013]. Because standard loop checking mechanisms used in description logic systems do not require backtracking, appropriate search strategies and restrictions for performing inferences and applying blocking need to be used.\nAn advantage of our approach to blocking as opposed to blocking without equality reasoning used in mainstream description logic systems [Baader and Sattler, 2001] is that it applies to any first-order clause set, not only to clauses from the translation of description logic problems. This makes the approach very general and widely applicable.\nFor instance, our approach makes it possible to extend description logics with arbitrary (first-order expressible) \u2018rule\u2019 languages. \u2018Rules\u2019 provide a connection to (deductive) databases and are being used to represent information that is currently not expressible in the description logics associated with OWL DL. The specification of many natural properties of binary relations and complex statements involving binary relations are outside the scope of most current description logic systems. An example is the statement: individuals who live and\n21\nwork at the same location are home workers. This can be expressed as a Horn rule (clause)\nhomeWorker(x) \u2190 work(x, y) \u2227 live(x, z) \u2227 loc(y, w) \u2227 loc(z, w),\nbut, with some exceptions [Hustadt et al., 1999, Weidenbach et al., 2007], is not expressible in current description logic systems."}, {"heading": "7 Soundness and Completeness of the Transfor-", "text": "mations\nEach of the blocking transformations is complete:\nProposition 4 (Completeness of blocking wrt. E-interpretations). Let M be any clause set. For all \u03c4 \u2208 {sdb, spb, udb, upb}, if \u03c4(M) is E-satisfiable then M is E-satisfiable.\nProof. Not difficult, as M \u2286 \u03c4(M) by definition.\nThe converse, that is, soundness of the transformation, is easy to prove. One basically needs to observe that the clauses added in respectively Steps (2) and (1) of the blocking transformations, realize a case distinction over whether two terms are equal or not. Trivially, one of the two cases always holds.\nPutting all the transformations and the corresponding results together we can state the main theoretical result of the paper.\nTheorem 1 (Completeness of the combined transformations with respect to E-interpretations). Let M be a clause set and suppose tr is any of the transformations in {rr, sh \u25e6 rr} \u222a {rr \u25e6 \u03c4, sh \u25e6 rr \u25e6 \u03c4 | \u03c4 \u2208 {sdb, spb, udb, upb}} or {crr, sh \u25e6 crr} \u222a {crr \u25e6 \u03c4, sh \u25e6 crr \u25e6 \u03c4 | \u03c4 \u2208 {sdb, spb, udb, upb}}. Then:\n(i) tr(M) is range-restricted.\n(ii) tr(M) can be computed in quadratic time.\n(iii) If tr(M) \u222a {x \u2248 x\u2190 dom(x)} is E-satisfiable then M is E-satisfiable.\nThe reverse directions of (iii), that is, soundness of the respective transformations, hold as well. The proofs are either easy or completely standard.\nBy carefully modifying the definition of rr it is possible to compute the reductions in linear time.\nProposition 5. Let M and tr be as in the previous result. Then:\n(i) The size of tr(M) is bounded by a linear function in the size of M .\n(ii) tr(M) can be computed in linear time.\n22"}, {"heading": "8 Decidability of BS classes", "text": "The Bernays-Scho\u0308nfinkel class can be decided using transformations into rangerestricted clauses. Formulae in the Bernays-Scho\u0308nfinkel class are conjunctions of function-free and equality-free formulae of the form \u2203\u2217\u2200\u2217\u03c8, where \u03c8 is free of quantifiers. A clause is a BS clause iff all functional terms occurring in it are constants.\nIt is proved in Schmidt and Hustadt [2005] that hyperresolution and any refinements decide the class of range-restricted BS clauses without equality. Here assume that the language includes equality.\nTheorem 2. The class of range-restricted BS clauses (with equality), is decidable by hyperresolution (and paramodulation) and all refinements.\nThis means all refinements of hyperresolution (and some form of equality reasoning) combined with any translation into range-restricted clauses is a decision procedure for the BS class.\nTherefore:\nCorollary 3. Let M be any set of BS clauses, and suppose tr is any of the transformations in {rr, sh \u25e6 rr} \u222a {rr \u25e6 \u03c4, sh \u25e6 rr \u25e6 \u03c4 | \u03c4 \u2208 {sdb, spb, udb, upb}} and {crr, sh \u25e6 crr} \u222a {crr \u25e6 \u03c4, sh \u25e6 rr \u25e6 \u03c4 | \u03c4 \u2208 {sdb, spb, udb, upb}}. Then:\n(i) Hyperresolution and all refinements decide tr(M).\n(ii) All BUMG methods decide M .\nSince there are linear transformations of first-order formulae into clausal form, and since all the tr transformations are effective reductions of first-order clauses into range-restricted clauses, we obtain the following result.\nTheorem 3.\n(i) There is a quadratic (linear), satisfiability equivalence preserving transformation of any formula in the Bernays-Scho\u0308nfinkel class, and any set of BS clauses, into a set of range-restricted BS clauses.\n(ii) All procedures based on hyperresolution or BUMG decide the class of BS formulae and the class of BS clauses.\nIn Schmidt and Hustadt [2005] a similar but different transformation is used to prove this result for hyperresolution and BS without equality. In fact, what is crucial for deciding the BS class is a grounding method. This can be achieved by any form of range-restriction and hyperresolution-like inferences. Theorem 3.(ii) can therefore be strengthened to include also any instantiation-based method, in particular also methods using on-the-fly instantiation such as semantic Smullyan-type tableaux."}, {"heading": "9 Experimental Evaluation", "text": "We have implemented the transformations described in the previous sections and carried out experiments on problems from the TPTP library, Version 6.0.0.\n23\nThe implementation, in SWI-Prolog, is called Yarralumla (Yet another rangerestriction avoiding loops under much less assumptions). Since the transformations introduced in this paper are defined for clausal problems we have selected for the experiments all the CNF problems from the TPTP suite.\nIn our initial research [Baumgartner and Schmidt, 2006] we used Yarralumla with the MSPASS theorem prover, Version 2.0g.1.4 [Hustadt and Schmidt, 2000]. As the extra features of MSPASS have in the mean time been integrated into the SPASS theorem prover [Weidenbach et al., 2007] and SPASS has significantly evolved since Version 2.0, for the present paper we combined Yarralumla with SPASS Version 3.8d as a BUMG system.\nFor that purpose we modified the code of SPASS in a number of ways. We added one new flag to activate splitting on positive ground equality literals in positive non-Horn clauses. The main inference loop was updapted so that finding a splitting clause and applying splitting has highest priority (unchanged) followed immediately by picking a non-positive blocking clause, that is, clauses of the form s \u2248 t \u2228 H1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Hm \u2190 B1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Bk for m \u2265 0 and k > 0, and performing inferences with it. The selection of splitting clauses was adapted so that positive blocking clauses are always selected, when there are any. Moreover, the first equality literal is split upon. Positive blocking clauses are ground clauses of the form s \u2248 t \u2228 H1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Hm, where m \u2265 1. This adaptation ensures blocking is performed eagerly to keep the set of ground terms small. The tests with Yarralumla were performed using ordered resolution and superposition with selection of at least one negative literal, forward and backward rewriting, unlimited splitting and matching replacement resolution, subsumption deletion and various other simplification rules. This means the inferences are performed in an ordered hyperresolution-style with eager splitting and forward and backward ground rewriting. The derivations constructed are thus BUMG tree derivations, the proofs produced are BUMG refutation proofs, and the models returned are BUMG models.\nWe also tested SPASS Version 3.8d in auto mode on the sample. In auto mode SPASS used ordered resolution with dynamic selection. SPASS automatically turned off splitting for non-Horn clauses. Dynamic selection means typically literals were only selected if multiple maximal literals occur in a clause. This means the behaviour of SPASS in auto mode was very different to that of SPASS-Yarralumla, which always selected a literal in clauses with non-empty negative part. The changes to SPASS in SPASS-Yarralumla meant that splitting was performed eagerly and blocking clauses were targeted, which was not the case with SPASS in auto mode. We tested SPASS in auto mode only on the original files (translated from TPTP syntax to SPASS syntax).\nThe experiments were run on a cluster of 128 Dell PowerEdge M610 Blade Servers each with two Intel Xeon E5620 2.4 GHz processors and 48 GiB main memory each. The time limit was ten minutes (CPU time).\nSPASS-Yarralumla can be downloaded from http://www.cs.man.ac.uk/~schmidt/spass-yarralumla/."}, {"heading": "9.1 Results", "text": "Tables 3 and 4 summarize the results for satisfiable clausal problems in the TPTP library, measuring the number of problems solved with in the time limit. The columns with the heading \u2018#\u2019 give the number of problems in the TPTP\n24\ncategories and the different TPTP rating ranges. The subsequent columns give the number of problems solved within the time limit. The results are presented for the different BUMG methods that were used. For example, sh\u25e6rr\u25e6sdb refers to the method based on the transformation defined by the new range-restriction transformation, shifting and subterm domain blocking. To evaluate the effect of the different forms of blocking the results are grouped into groups of five: no blocking, subterm domain blocking (sdb), unrestricted domain blocking (udb), subterm predicate blocking (spb) and unrestricted predicate blocking (spb). In each group the first column provides the baseline for that group. The last column with the heading \u2018auto\u2019 gives the results for runs of SPASS Version 3.8d in auto mode on the original input files. The runtimes for the problems solved spanned the whole range, from less than one second to all of the time allowed.\nThe best results in each group in each row are highlighted in bold font. The underlined values are the best results for all methods including SPASS in auto mode. As expected the worst results in each group were obtained for the baseline transformations without blocking. This confirms the expectation that blocking is an essential technique for BUMG methods. Among the different blocking techniques the best results were obtained with unrestricted domain blocking in all four groups. Overall, the best result was obtained for the combination with rr and shifting, i.e., sh \u25e6 rr \u25e6 udb, solving 6.0% more problems than the second best method, crr\u25e6udb using the classical range-restriction transformation without shifting, and nearly 11% more problems than the transformations rr \u25e6 udb and sh \u25e6 crr \u25e6 udb. This means shifting had a significant positive effect in combination with the new range-restriction transformation, but less so in combination with classical range-restriction. The positive effect of shifting could also be seen for the number of problems solved without blocking for rr and sh\u25e6rr (34% improvement).\nThe good results for crr \u25e6 udb show the value of classical range-restriction. In the LAT category, crr \u25e6 udb solved 32 problems, whereas sh \u25e6 rr \u25e6 udb solved only 5 problems. This seems to indicate there was a trade-off between using the crr transformation and the rr transformation in combination with shifting, but also showed the virtues of unrestricted domain blocking as a universal technique for BUMG. SPASS in auto mode fared very well in the SWV category, where 79 problems were solved compared to 7\u20138 problems for the best BUMGmethods. Overall SPASS in auto mode solved 9% fewer problems than the best BUMG method sh \u25e6 rr \u25e6 udb.\nLooking at the top half of Table 4 (up to difficulty rating of 0.40), the BUMG method based on sh \u25e6 rr \u25e6 udb fared best, but for problems more difficult (up to a rating of 0.70) the performance deteriorated and the method crr \u25e6 udb solved the highest number of problems. For problems with ratings higher than 0.70 SPASS in auto mode solved significantly more problems than the BUMG methods. One problem with rating 1.00 was solved by the crr \u25e6 udb method (namely, GRP741-1 in 121.86 seconds). Problems in the TPTP library with rating 1.00 have not yet been solved by any other prover.\nTable 5 presents an evaluation of the different blocking techniques, listing the number of problems lost and the number of problems gained against the baseline methods in each group. The results confirm the significant positive effect of unrestricted domain blocking for satisfiable problems.\nAnalysis of the gain and loss of the method based on sh\u25e6 rr\u25e6udb against the other methods gave these results: Against rr\u25e6udb 66 problems were gained and\n26\n2 7\n20 problems lost; against sh \u25e6 crr \u25e6 udb the gain/loss was +90/-45 and against crr \u25e6 udb it was +85/-59. This non-uniformity suggests each variation of rangerestriction had the potential to solve some problems not solvable within the time limit by sh \u25e6 rr with unrestricted blocking. The biggest variation was against SPASS in auto mode, where 169 problems were gained and 130 problems were lost.\nTable 6 displays how many problems were uniquely solved. The first row lists how many problems were uniquely solved over all methods including SPASS in auto mode. Although two of the BUMG methods with unrestricted domain blocking fared better than SPASS in auto mode, the latter solved a significant number of problems that none of the BUMG could solve (namely, 115 problems, or 27.5% of the problems solved by SPASS in auto mode, or 10.2% of all satisfiable problems). This reflected the orthogonality of the underlying methods. Analogously, the relatively low number of problems uniquely solved by the BUMG methods (21 problems, i.e., 1.9% of all satisfiable problems), which is also apparent from the number of problems solved uniquely among the BUMG methods in the second row (25 or 2.2% of all satisfiable problems) can be attributed to the similarity of the underlying methods. An analysis of the number of uniquely solved problems per group of BUMG methods in the third row of the table highlighted the importance of unrestricted domain blocking. While overall no problems were only solved with unary predicate blocking techniques, within the groups there were four problems solved only with unary predicate blocking.\nTable 7 gives an impression of the increase in the size of the input files caused by the transformations. Although the file sizes were measured after all comments and white space were removed, variations is name lengths distort the values slightly (which can be seen in the values for shifting). The results therefore need to be interpreted cautiously. The average increase in file size does show a significant effect on the size of the problem for the new range-restriction transformations and also subterm blocking (both subterm domain blocking and subterm predicate blocking). The largest increase in size was observed for the problem SYO600-1 (13.7 fold increase), which contained 380 predicate symbols with arity up to 64, 2 constants and no non-constant function symbols. The main cause for this increase was the large number of clauses added in Step (4)\n28\n2 9\nof the rr transformation. For each of the 284 predicate symbols with arity 64 in the problem, 64 clauses were added in Step (4). This is a large number. In contrast for the crr transformations the increase in size was negligible, and also, generally, it was significantly lower. Despite its positive virtues this shows a downside of the rr transformation. For problems containing a large number of function symbols with high arity, Step (5) similarly adds many clauses, even though the transformation overall is still effective.\nAnalysis of the problems solved without any form of blocking revealed a large number belonged to the Bernays-Scho\u0308nfinkel class: 131/176 (74%) for rr, 132/236 (56%) for sh \u25e6 rr, 133/140 (95%) for crr, and 134/142 (94%) for sh \u25e6 rr. These results confirmed the expectation that more problems not solvable with the crr transformation can be solved with the rr transformation and the benefits of reducing the number of terms created.\nAlthough the main purpose of BUMG methods is disproving theorems and generating models for satisfiable problems, for completeness we report in Tables 8 and 9 the results for unsatisfiable clausal TPTP problems. The results were not as uniform as for satisfiable problems. However some general observations can be made. SPASS in auto mode fared best overall, and did so in all TPTP categories and each problem rating category. For unsatisfiable problems the drawback of BUMG methods is that clauses need to be exhaustively grounded and each branch in the derivation tree needs to be closed. The dominance of SPASS in auto mode is thus not surprising.\nFor the BUMG methods, a general deterioration in performance could be observed for shifting, when comparing the results for the groups with baselines sh \u25e6 rr and sh \u25e6 crr to the respective groups without shifting. This is plausible because shifting leads to fewer negative literals in clauses and more positive literals thus reducing the constraining effect and leading to more splitting. For problems with higher rating, shifting did seem to have a positive effect; for instance, in the (0.40, 0.50] range, sh \u25e6 rr solved 70 problems whereas rr solved 32 problems.\nWithin the BUMG groups we expected best performance for the baseline transformations, because these do not involve blocking and performing many blocking steps lead to a significant overhead. However only for the first group the rr transformation fared best. In combination with classical range-restriction crr, somewhat surprisingly, the best results were obtained with unrestricted do-\n30\nmain blocking, the most expensive form of blocking, because it is applicable to any terms. Among the blocking techniques in each case the highest gain was obtained for unrestricted domain blocking (see Table 5). However also the greatest loss was observed for this blocking technique. The smallest loss and lowest gain was obtained for upb blocking. The high loss for udb could be a reflection of the high increase in splitting steps preventing quicker detection of contradictions. Analogously the small loss for upb could be attributable to the smallest number of additional splitting steps among the blocking techniques. The high gain for udb blocking suggests the inference process panned out significantly differently leading to solutions not found with the other techniques. This seems to be supported by the results in the third row of Table 6 according to which, with one exception, the largest number of uniquely solved problems in each group was obtained with udb blocking. The exception was the first group, where rr led to the largest number of uniquely solved problems. Among all the BUMG methods, rr solved the largest number of problems not solved by any of the other methods. However, these results pale against the number of uniquely solved problems by SPASS in auto mode. Only one problem was solved by a BUMG method which was not solved by SPASS in auto mode."}, {"heading": "9.2 Findings", "text": "Several findings can be drawn from the results. The results have confirmed our expectation that unrestricted domain blocking is a powerful technique, which helps discover finite models more often than with the other blocking techniques. The results suggest the technique is indispensable for bottom-up model generation. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Overall, the method based on new range-restriction, shifting and unrestricted domain blocking performed best on the sample. On satisfiable problems with higher difficulty rating this method was however gradually edged out by the method based on classical range-restriction and unrestricted domain blocking. This suggests there is a trade-off between the rr transformation, which is based on a non-trivial transformation but does restrict the creation of terms, and the simpler crr transformation, which has to rely on blocking to restrict the creation of terms.\nThe results for subterm domain blocking were good and often not far behind unrestricted domain blocking for satisfiable problems. In contrast, predicate blocking seems not to be effective on many problems. We attribute this to the nature of the problems in the TPTP library.\nAn investigation with SPASS-Yarralumla on translations of modal logic problems has revealed a different picture [Schmidt et al., 2014]. There, the best performance was obtained with subterm domain blocking for both satisfiable and unsatisfiable problems. Better results than for unrestricted domain blocking were also obtained with subterm predicate blocking and unrestricted predicate blocking. Better performances for subterm and predicate blocking are also expected on problems stemming from (cyclic) description logic knowledge bases. Experiments with blocking restricted by excluding a finite subset of the domain have shown better results than for unrestricted domain blocking for consistency testing on a large corpus of ontologies [Khodadadi et al., 2013]. The better performance for restricted forms of blocking on modal and description\n31\n3 3\nlogic problems can be attributed to mainstream modal and description logics having the finite tree model property. This means every satisfiable formula holds in a model based on a finite tree, which is not a property of first-order formulae.\nThe results showed BUMG methods were good for disproving theorems and generating models for satisfiable problems. For unsatisfiable problems BUMG methods were however significantly less efficient than SPASS in auto mode. For theorem proving purposes a limitation of BUMG methods is that they require full grounding. It can be seen already from very small unsatisfiable examples that a complete BUMG derivation tree can be very large, whereas resolution proofs are significantly shorter.\nCompared to resolution, an advantage of BUMG methods for satisfiable problems is the division of the search space into branches which are individually constructed and individually processed. As a consequence, if the right decisions are made at branching points models can be found more quickly. When the branching point decisions are less optimal the performance can deteriorate dramatically, particularly if the search is trapped in a branch with only infinite models. This could be another explanation for the lower success rate of the BUMG methods observed for more difficult satisfiable problems. For problems where only infinite models exist, clearly other methods are better."}, {"heading": "10 Conclusions", "text": "We have presented and tested a number of enhancements for BUMG methods. An important aspect is that our enhancements exploit the strengths of readily available BUMG system with only modest modifications. Our range restriction technique is a refinement of existing transformations to range-restricted clauses in that terms are added to the domain of interpretation on a \u2018by need\u2019 basis. Moreover, we have presented methods that allow us to extend BUMG methods with blocking techniques related to loop checking techniques with a long history in the more specialized setting of modal and description logics.\nThe experimental evaluation has shown blocking techniques are indispensable in BUMG methods for satisfiable problems. In particular, unrestricted domain blocking turned out to be the most powerful technique on problems from the TPTP library. Limiting the creation of terms during the inference process by using the new range restricting transformation paid off, leading to better results. It is particularly advisable together with the shifting transformation. The experimental results however also show that classical range restriction together with unrestricted blocking is a good complementary method. Because model generation methods are not just aimed at showing the existence of models but are built to construct and return models, when no models exists the entire search space must be traversed, which has led to inferior performance compared to saturation-based resolution.\nOur bottom-up model generation approach is especially suitable for generating small models and it is possible to show the approach using unrestricted domain blocking allows us to compute finite models when they exist. The models produced by subterm blocking and predicate blocking are not as small as those produced by unrestricted domain blocking. In particular, the generated models do not need to be Herbrand models. It follows from how the transformations work that the generated models are quasi-Herbrand models, in the following\n34\nsense. Whenever dom(s) and dom(t) hold in the (Herbrand) model constructed by the BUMG method, then (as in Herbrand interpretations) the terms s and t are mapped to themselves in the associated (possibly non-Herbrand) model. Reconsidering the example in the Introduction of the two unit clauses P(a) and Q(b), the associated model maps a and b to themselves, regardless as to which transformations are applied as long as it includes a form of subterm blocking. In this way, more informative models are produced than those computed by, for example, MACE- and SEM-style finite model searchers (and also unrestricted domain blocking). From an applications perspective, this can be an advantage because larger models are more likely to be helpful to a user debugging mistakes in the formal specification of a program or protocol, or an ontology engineer trying to discover why an expected entailment does not follow from an ontology.\nResearch in automated theorem proving on developing decision procedures has concentrated on developing refinements of resolution, mainly ordering refinements, for deciding solvable fragments of first-order logic. Fragments decidable with ordered resolution are complementary to the fragments that can be decided by refinements using the techniques presented in this paper. We have thus extended the set of techniques available for resolution methods to turn them into more effective and efficient (terminating) automated reasoning methods. In particular, we have shown that all procedures based on hyperresolution, or BUMG methods, can decide the Bernays-Scho\u0308nfinkel class and the class of BS clauses with equality.\nStudying how well the ideas and techniques discussed in this paper can be exploited and behave in dedicated BUMG provers, tableau-based provers and other provers (including resolution-based provers) is very important but is beyond the scope of the present paper. Initial results with another prover, Darwin [Baumgartner et al., 2006], are very encouraging. An in-depth comparison and analysis of BUMG approaches with our techniques and MACE-style or SEM-style model generation would also be of interest. Another source for future work is to combine the presented transformations with other BUMG techniques, such as magic sets transformations [Hasegawa et al., 1997, Stickel, 1994], a typed version of range-restriction [Baumgartner et al., 1997], and minimal model computation [Bry and Yahya, 2000, Bry and Torge, 1998, Papacchini and Schmidt, 2011]. Having been designed to be generic, we believe that our transformations carry over to formalisms with default negation, which could provide a possible basis for enhancements to answer-set programming systems.\nAcknowledgements. The second author is grateful to ChristophWeidenbach and Uwe Waldmann for hosting her during 2010 and 2013\u20132014. In this time the implementation of SPASS-yarralumla was completed and the experimental evaluation was undertaken on the cluster of the Max-Planck-Institut fu\u0308r Informatik, Saarbru\u0308cken. We thank Uli Furbach, Dmitry Tishkovsky, Uwe Waldmann and Christoph Weidenbach for useful discussions and comments on this research. This work was supported by the UK Engineering and Physical Sciences Research Council (EPSRC) (grants EP/F068530/1 and EP/H043748/1), NICTA, Canberra, Australia, and the Max-Planck-Institut, Saarbru\u0308cken, Germany.\n35"}], "references": [{"title": "An overview of tableau algorithms for description logics", "author": ["F. Baader", "U. Sattler"], "venue": "Studia Logica,", "citeRegEx": "Baader and Sattler.,? \\Q2001\\E", "shortCiteRegEx": "Baader and Sattler.", "year": 2001}, {"title": "Equational reasoning in saturation-based theorem proving", "author": ["L. Bachmair", "H. Ganzinger"], "venue": "Automated Deduction\u2014 A Basis for Applications,", "citeRegEx": "Bachmair and Ganzinger.,? \\Q1998\\E", "shortCiteRegEx": "Bachmair and Ganzinger.", "year": 1998}, {"title": "Resolution theorem proving", "author": ["L. Bachmair", "H. Ganzinger"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Bachmair and Ganzinger.,? \\Q2001\\E", "shortCiteRegEx": "Bachmair and Ganzinger.", "year": 2001}, {"title": "Blocking and other enhancements for bottom-up model generation methods", "author": ["P. Baumgartner", "R.A. Schmidt"], "venue": "Automated Reasoning: IJCAR 2006,", "citeRegEx": "Baumgartner and Schmidt.,? \\Q2006\\E", "shortCiteRegEx": "Baumgartner and Schmidt.", "year": 2006}, {"title": "Hyper tableaux", "author": ["P. Baumgartner", "U. Furbach", "I. Niemel\u00e4"], "venue": "Logics in Artificial Intelligence: JELIA\u201996,", "citeRegEx": "Baumgartner et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1996}, {"title": "Computing answers with model elimination", "author": ["P. Baumgartner", "U. Furbach", "F. Stolzenburg"], "venue": "Artificial Intelligence,", "citeRegEx": "Baumgartner et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1997}, {"title": "Implementing the model evolution calculus", "author": ["P. Baumgartner", "A. Fuchs", "C. Tinelli"], "venue": "International Journal of Artificial Intelligence Tools,", "citeRegEx": "Baumgartner et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 2006}, {"title": "Hyper tableaux with equality", "author": ["P. Baumgartner", "U. Furbach", "B. Pelzer"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Baumgartner et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 2007}, {"title": "Disproving distributivity in lattices using geometry logic", "author": ["M. Bezem"], "venue": "In Proceedings of CADE-20 Workshop on Disproving,", "citeRegEx": "Bezem.,? \\Q2005\\E", "shortCiteRegEx": "Bezem.", "year": 2005}, {"title": "On deciding satisfiability by theorem proving with speculative inferences", "author": ["M.P. Bonacina", "C. Lynch", "L.M. de Moura"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Bonacina et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bonacina et al\\.", "year": 2011}, {"title": "A deduction method complete for refutation and finite satisfiability", "author": ["F. Bry", "S. Torge"], "venue": "Logics in Artificial Intelligence: JELIA\u201998,", "citeRegEx": "Bry and Torge.,? \\Q1998\\E", "shortCiteRegEx": "Bry and Torge.", "year": 1998}, {"title": "Positive unit hyperresolution tableaux for minimal model generation", "author": ["F. Bry", "A. Yahya"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Bry and Yahya.,? \\Q2000\\E", "shortCiteRegEx": "Bry and Yahya.", "year": 2000}, {"title": "New techniques that improve MACE-style finite model building", "author": ["K. Claessen", "N. S\u00f6rensson"], "venue": "Proceedings of CADE-19 Workshop on Model Computation,", "citeRegEx": "Claessen and S\u00f6rensson.,? \\Q2003\\E", "shortCiteRegEx": "Claessen and S\u00f6rensson.", "year": 2003}, {"title": "Automatic generation of some results in finite algebra", "author": ["M. Fujita", "J. Slaney", "F. Bennett"], "venue": "In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Fujita et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Fujita et al\\.", "year": 1995}, {"title": "Satchmo: The compiling and functional variants", "author": ["T. Geisler", "S. Panne", "H. Sch\u00fctz"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Geisler et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Geisler et al\\.", "year": 1997}, {"title": "Non-horn magic sets to incorporate top-down inference into bottom-up theorem proving", "author": ["R. Hasegawa", "K. Inoue", "Y. Ohta", "M. Koshimura"], "venue": "In Automated Deduction: CADE-14,", "citeRegEx": "Hasegawa et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hasegawa et al\\.", "year": 1997}, {"title": "On the relation of resolution and tableaux proof systems for description logics", "author": ["U. Hustadt", "R.A. Schmidt"], "venue": "Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence:", "citeRegEx": "Hustadt and Schmidt.,? \\Q1999\\E", "shortCiteRegEx": "Hustadt and Schmidt.", "year": 1999}, {"title": "MSPASS: Modal reasoning by translation and first-order resolution", "author": ["U. Hustadt", "R.A. Schmidt"], "venue": "Automated Reasoning with Analytic Tableaux and Related Methods, International Conference: TABLEAUX 2000,", "citeRegEx": "Hustadt and Schmidt.,? \\Q2000\\E", "shortCiteRegEx": "Hustadt and Schmidt.", "year": 2000}, {"title": "MSPASS: Subsumption testing with SPASS", "author": ["U. Hustadt", "R.A. Schmidt", "C. Weidenbach"], "venue": "Proceedings of International Workshop on Description", "citeRegEx": "Hustadt et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 1999}, {"title": "A refined tableau calculus with controlled blocking for the description logic SHOI", "author": ["M. Khodadadi", "R.A. Schmidt", "D. Tishkovsky"], "venue": "Automated Reasoning with Analytic Tableaux and Related Methods: TABLEAUX 2013,", "citeRegEx": "Khodadadi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Khodadadi et al\\.", "year": 2013}, {"title": "Unsound theorem proving", "author": ["C. Lynch"], "venue": "In Computer Science Logic, 18th International Workshop, CSL, volume 3210 of LNCS,", "citeRegEx": "Lynch.,? \\Q2004\\E", "shortCiteRegEx": "Lynch.", "year": 2004}, {"title": "SATCHMO: a theorem prover implemented in Prolog", "author": ["R. Manthey", "F. Bry"], "venue": "Automated Deduction: CADE-9,", "citeRegEx": "Manthey and Bry.,? \\Q1988\\E", "shortCiteRegEx": "Manthey and Bry.", "year": 1988}, {"title": "A Davis-Putnam Program and its Application to Finite FirstOrder Model Search: Quasigroup Existence Problems", "author": ["W. McCune"], "venue": "Technical Report MCS-TM-194,", "citeRegEx": "McCune.,? \\Q1994\\E", "shortCiteRegEx": "McCune.", "year": 1994}, {"title": "Mace4 reference manual and guide", "author": ["W. McCune"], "venue": "Technical Memorandum 264, Argonne National Laboratory,", "citeRegEx": "McCune.,? \\Q2003\\E", "shortCiteRegEx": "McCune.", "year": 2003}, {"title": "Paramodulation-based theorem proving", "author": ["R. Nieuwenhuis", "A. Rubio"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Nieuwenhuis and Rubio.,? \\Q2001\\E", "shortCiteRegEx": "Nieuwenhuis and Rubio.", "year": 2001}, {"title": "A tableau calculus for minimal modal model generation", "author": ["F. Papacchini", "R.A. Schmidt"], "venue": "Electronic Notes in Theoretical Computer Science,", "citeRegEx": "Papacchini and Schmidt.,? \\Q2011\\E", "shortCiteRegEx": "Papacchini and Schmidt.", "year": 2011}, {"title": "System description: E-KRHyper", "author": ["B. Pelzer", "C. Wernhard"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Pelzer and Wernhard.,? \\Q2007\\E", "shortCiteRegEx": "Pelzer and Wernhard.", "year": 2007}, {"title": "The design and implementation of VAMPIRE", "author": ["A. Riazanov", "A. Voronkov"], "venue": "AI Communications,", "citeRegEx": "Riazanov and Voronkov.,? \\Q2002\\E", "shortCiteRegEx": "Riazanov and Voronkov.", "year": 2002}, {"title": "Automatic deduction with hyper-resolution", "author": ["J.A. Robinson"], "venue": "International Journal of Computer Mathematics,", "citeRegEx": "Robinson.,? \\Q1965\\E", "shortCiteRegEx": "Robinson.", "year": 1965}, {"title": "Solvability with resolution of problems in the Bernays-Sch\u00f6nfinkel class", "author": ["R.A. Schmidt", "U. Hustadt"], "venue": "Presented at Dagstuhl Seminar", "citeRegEx": "Schmidt and Hustadt.,? \\Q2006\\E", "shortCiteRegEx": "Schmidt and Hustadt.", "year": 2006}, {"title": "Using tableau to decide expressive description logics with role negation", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "The Semantic Web: ISWC 2007 + ASWC 2007,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2007\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2007}, {"title": "A general tableau method for deciding description logics, modal logics and related first-order fragments", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "Automated Reasoning: IJCAR 2008,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2008\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2008}, {"title": "Automated synthesis of tableau calculi", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2011\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2011}, {"title": "Using tableau to decide description logics with full role negation and identity", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2013\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2013}, {"title": "Axiomatic and tableau-based reasoning for Kt(H,R)", "author": ["R.A. Schmidt", "J.G. Stell", "D. Rydeheard"], "venue": "Advances in Modal Logic, Volume", "citeRegEx": "Schmidt et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Schmidt et al\\.", "year": 2014}, {"title": "FINDER (finite domain enumerator): Notes and guide", "author": ["J. Slaney"], "venue": "Technical Report TR-ARP-1/92, Australian National University,", "citeRegEx": "Slaney.,? \\Q1992\\E", "shortCiteRegEx": "Slaney.", "year": 1992}, {"title": "First Order Logic", "author": ["R.M. Smullyan"], "venue": null, "citeRegEx": "Smullyan.,? \\Q1971\\E", "shortCiteRegEx": "Smullyan.", "year": 1971}, {"title": "Upside-down meta-interpretation of the model elimination theorem-proving procedure for deduction and abduction", "author": ["M.E. Stickel"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Stickel.,? \\Q1994\\E", "shortCiteRegEx": "Stickel.", "year": 1994}, {"title": "System description: SPASS version 3.0", "author": ["C. Weidenbach", "R.A. Schmidt", "T. Hillenbrand", "R. Rusev", "D. Topic"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Weidenbach et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Weidenbach et al\\.", "year": 2007}, {"title": "SPASS version 3.5", "author": ["C. Weidenbach", "D. Dimova", "A. Fietzke", "R. Kumar", "M. Suda", "P. Wischnewski"], "venue": "Automated Deduction: CADE-22,", "citeRegEx": "Weidenbach et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Weidenbach et al\\.", "year": 2009}, {"title": "System description: KRHyper", "author": ["C. Wernhard"], "venue": "In Proceedings of CADE-19 Workshop on Model Computation,", "citeRegEx": "Wernhard.,? \\Q2003\\E", "shortCiteRegEx": "Wernhard.", "year": 2003}, {"title": "SEM: A system for enumerating models", "author": ["H. Zhang"], "venue": "In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Zhang.,? \\Q1995\\E", "shortCiteRegEx": "Zhang.", "year": 1995}], "referenceMentions": [{"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al.", "startOffset": 280, "endOffset": 2072}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases.", "startOffset": 280, "endOffset": 2171}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class.", "startOffset": 280, "endOffset": 2727}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003].", "startOffset": 280, "endOffset": 3083}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003].", "startOffset": 280, "endOffset": 3111}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003]. In contrast, MACEstyle model builders such as, for example, the methods of Claessen and S\u00f6rensson [2003] and McCune [1994] reduce model search to testing of propositional satisfi-", "startOffset": 280, "endOffset": 3293}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003]. In contrast, MACEstyle model builders such as, for example, the methods of Claessen and S\u00f6rensson [2003] and McCune [1994] reduce model search to testing of propositional satisfi-", "startOffset": 280, "endOffset": 3311}, {"referenceID": 3, "context": "This paper is an extended and improved version of Baumgartner and Schmidt [2006].", "startOffset": 50, "endOffset": 81}, {"referenceID": 36, "context": "The family of BUMG approaches includes many familiar calculi and proof procedures such as Smullyan type semantic tableaux [Smullyan, 1971], SATCHMO [Manthey and Bry, 1988, Geisler et al.", "startOffset": 122, "endOffset": 138}, {"referenceID": 13, "context": ", 1997], positive unit hyperresolution (PUHR) tableaux [Bry and Yahya, 2000, Bry and Torge, 1998], the model generation theorem proverMGTP [Fujita et al., 1995] and hypertableaux [Baumgartner et al.", "startOffset": 139, "endOffset": 160}, {"referenceID": 4, "context": ", 1995] and hypertableaux [Baumgartner et al., 1996].", "startOffset": 26, "endOffset": 52}, {"referenceID": 28, "context": "A well-established and widely known method for BUMG is hyperresolution [Robinson, 1965].", "startOffset": 71, "endOffset": 87}, {"referenceID": 21, "context": "Existing transformations to range-restricted form followManthey and Bry [1988] (or are variations of it).", "startOffset": 56, "endOffset": 79}, {"referenceID": 10, "context": "However, the method has been shown to be useful for (domain-)minimal model generation when combined with other techniques [Bry and Yahya, 2000, Bry and Torge, 1998]. In particular, Bry and Torge [1998] use splitting and the \u03b4-rule to generate domain minimal models.", "startOffset": 144, "endOffset": 202}, {"referenceID": 40, "context": "The same behaviour can be achieved, for example, with the KRHyper BUMG prover, a hypertableaux theorem prover [Wernhard, 2003].", "startOffset": 110, "endOffset": 126}, {"referenceID": 27, "context": ", 2007, 2009], but is now also part of VAMPIRE [Riazanov and Voronkov, 2002] and E [Schulz, 2013].", "startOffset": 47, "endOffset": 76}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework.", "startOffset": 68, "endOffset": 223}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework.", "startOffset": 68, "endOffset": 289}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework. Unsound theorem proving has been incorporated later in DPLLT-based theorem proving Bonacina et al. [2011]. In the following we introduce four different, but closely related, blocking transformations, called subterm domain blocking, subterm predicate blocking, unrestricted domain blocking and unrestricted predicate blocking.", "startOffset": 68, "endOffset": 549}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006].", "startOffset": 83, "endOffset": 114}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006]. Subterm predicate blocking is inspired by and related to the blocking technique described in Hustadt and Schmidt [1999]. Unrestricted domain blocking is the first-order version of the unrestricted blocking rule introduced in Schmidt and Tishkovsky [2007] and used for developing terminating tableau calculi for logics with the effective finite model property in Schmidt and Tishkovsky [2008, 2011].", "startOffset": 84, "endOffset": 236}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006]. Subterm predicate blocking is inspired by and related to the blocking technique described in Hustadt and Schmidt [1999]. Unrestricted domain blocking is the first-order version of the unrestricted blocking rule introduced in Schmidt and Tishkovsky [2007] and used for developing terminating tableau calculi for logics with the effective finite model property in Schmidt and Tishkovsky [2008, 2011].", "startOffset": 84, "endOffset": 371}, {"referenceID": 30, "context": "Using the ideas of the termination proof in Schmidt and Tishkovsky [2013] for semantic ground tableau with unrestricted domain blocking for description logics with the expressive power similar to the two-variable fragment of firstorder logic, it can be shown BUMG with unrestricted domain blocking can return finite models, if they exist, even for problems of undecidable fragments.", "startOffset": 44, "endOffset": 74}, {"referenceID": 30, "context": "Using the ideas of the termination proof in Schmidt and Tishkovsky [2013] for semantic ground tableau with unrestricted domain blocking for description logics with the expressive power similar to the two-variable fragment of firstorder logic, it can be shown BUMG with unrestricted domain blocking can return finite models, if they exist, even for problems of undecidable fragments. Carrying over also the results in Schmidt and Tishkovsky [2008] implies unrestricted domain blocking can be used in BUMG methods to return domain minimal models for logics with the effective finite model property.", "startOffset": 44, "endOffset": 447}, {"referenceID": 0, "context": "An advantage of our approach to blocking as opposed to blocking without equality reasoning used in mainstream description logic systems [Baader and Sattler, 2001] is that it applies to any first-order clause set, not only to clauses from the translation of description logic problems.", "startOffset": 136, "endOffset": 162}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al.", "startOffset": 0, "endOffset": 27}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al.", "startOffset": 0, "endOffset": 58}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al. [2013]. Because standard loop checking mechanisms used in description logic systems do not require backtracking, appropriate search strategies and restrictions for performing inferences and applying blocking need to be used.", "startOffset": 0, "endOffset": 86}, {"referenceID": 29, "context": "It is proved in Schmidt and Hustadt [2005] that hyperresolution and any refinements decide the class of range-restricted BS clauses without equality.", "startOffset": 16, "endOffset": 43}, {"referenceID": 29, "context": "In Schmidt and Hustadt [2005] a similar but different transformation is used to prove this result for hyperresolution and BS without equality.", "startOffset": 3, "endOffset": 30}, {"referenceID": 3, "context": "In our initial research [Baumgartner and Schmidt, 2006] we used Yarralumla with the MSPASS theorem prover, Version 2.", "startOffset": 24, "endOffset": 55}, {"referenceID": 17, "context": "4 [Hustadt and Schmidt, 2000].", "startOffset": 2, "endOffset": 29}, {"referenceID": 38, "context": "As the extra features of MSPASS have in the mean time been integrated into the SPASS theorem prover [Weidenbach et al., 2007] and SPASS has significantly evolved since Version 2.", "startOffset": 100, "endOffset": 125}, {"referenceID": 34, "context": "An investigation with SPASS-Yarralumla on translations of modal logic problems has revealed a different picture [Schmidt et al., 2014].", "startOffset": 112, "endOffset": 134}, {"referenceID": 19, "context": "Experiments with blocking restricted by excluding a finite subset of the domain have shown better results than for unrestricted domain blocking for consistency testing on a large corpus of ontologies [Khodadadi et al., 2013].", "startOffset": 200, "endOffset": 224}, {"referenceID": 6, "context": "Initial results with another prover, Darwin [Baumgartner et al., 2006], are very encouraging.", "startOffset": 44, "endOffset": 70}, {"referenceID": 5, "context": ", 1997, Stickel, 1994], a typed version of range-restriction [Baumgartner et al., 1997], and minimal model computation [Bry and Yahya, 2000, Bry and Torge, 1998, Papacchini and Schmidt, 2011].", "startOffset": 61, "endOffset": 87}], "year": 2016, "abstractText": "Model generation is a problem complementary to theorem proving and is important for fault analysis and debugging of formal specifications of, for example, security protocols, programs and terminological definitions. This paper discusses several ways of enhancing the paradigm of bottom-up model generation. The two main contributions are new, generalized blocking techniques and a new range-restriction transformation. The blocking techniques are based on simple transformations of the input set together with standard equality reasoning and redundancy elimination techniques. These provide general methods for finding small, finite models. The range-restriction transformation refines existing transformations to range-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and a classical range-restriction technique were tested on the clausal problems of the TPTP Version 6.0.0 with an implementation based on the SPASS theorem prover using a hyperresolution-like refinement. Unrestricted domain blocking gave best results for satisfiable problems showing it is a powerful technique indispensable for bottom-up model generation methods. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Limiting the creation of terms during the inference process by using the new range restricting transformation has paid off, especially when using it together with a shifting transformation. The experimental results also show that classical range restriction with unrestricted blocking provides a useful complementary method. Overall, the results showed bottom-up model generation methods were good for disproving theorems and generating models for satisfiable problems, but less efficient than SPASS in auto mode for unsatisfiable problems.", "creator": "LaTeX with hyperref package"}}}