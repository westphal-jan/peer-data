{"id": "1701.08190", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jan-2017", "title": "Comparative Study Of Data Mining Query Languages", "abstract": "Since formulation of Inductive Database (IDB) problem, several Data Mining (DM) languages have been proposed, confirming that KDD process could be supported via inductive queries (IQ) answering. This paper reviews the existing DM languages. We are presenting important primitives of the DM language and classifying our languages according to primitives' satisfaction with each approach. We demonstrate that we are able to construct a classifier of IDB and provide the following methods to answer such queries:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Fri, 27 Jan 2017 21:00:19 GMT  (382kb)", "http://arxiv.org/abs/1701.08190v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["mohamed anis bach tobji"], "accepted": false, "id": "1701.08190"}, "pdf": {"name": "1701.08190.pdf", "metadata": {"source": "CRF", "title": "COMPARATIVE STUDY OF DATA MINING QUERY LANGUAGES", "authors": ["Mohamed Anis Bach Tobji"], "emails": [], "sections": [{"heading": null, "text": "Since formulation of Inductive Database (IDB) problem, several Data Mining (DM) languages have been proposed, confirming that KDD process could be supported via inductive queries (IQ) answering. This paper reviews the existing DM languages. We are presenting important primitives of the DM language and classifying our languages according to primitives\u201f satisfaction. In addition, we presented languages\u201f syntaxes and tried to apply each one to a database sample to test a set of KDD operations. This study allows us to highlight languages capabilities and limits, which is very useful for future work and perspectives."}, {"heading": "KEYWORDS", "text": "Knowledge Discovery from Databases, Inductive Database, Data Mining Languages."}, {"heading": "1. INTRODUCTION", "text": "IDB is a new generation of databases introduced in (Imielinski and Mannila, 1996) as a framework of KDD (Fayyad et al, 1996). An inductive database contains data and patterns that are extracted from. Databases are generally supported by SQL language, however, IDBs are supported by a DM Query Language, which allows KDD operations (mainly data selection, data preprocessing, patterns mining and pattern post-processing).\nThe development of theoretical framework is interesting and has been the subject of many researches (Boulicaut et al, 1999), (De Raedt, 2003), (Dan Lee and De Raedt, 2003), (De Raedt et al, 2004). However, there is no clear definition or formalization, such as an algebra language that could be a base for a standard DM query language. In fact, the KDD community would reproduce the success of SQL based on Codd\u201fs algebra (Codd, 1970).\nIn this paper we study existing DM languages to try to find out advantages and limits. The paper is organized as the following: In section 2 we present essential DM query language primitives. In section 3 we compare six existing DM query languages with a taxonomy based on primitives\u201f satisfaction. In section 4, we show the languages in action, i.e., we give a small database and we perform some data mining operations using languages\u201f queries. Finally in section 5, we discuss the study, and we give some perspectives related to the existent languages weaknesses."}, {"heading": "2. INDUCTIVE QUERY LANGUAGE PRIMITIVES", "text": "Data mining query language primitives\u201f definition is a basic problem. Once primitives are defined, conceiving a good DM query language will be easier. In this section we give the primitives as defined in (Han and Kamber,2000), (Botta et al, 2004), and languages papers (Imielinski and Virmani, 1999), (Meo et al, 2002), (Han et al,1996), (Morzy and Zakrzewic, 1997), (Netz et al,2000) and (Elfeky et al, 2000). A data mining query language must offer:\n- Data selection: it\u201fs naturally satisfied if the language nests SQL. The language must provide data selection query. - Pre-processing task: providing pre-processing operations (sampling, discretization, data cleaning etc. ) - Specifying the data mining task: mining several patterns kinds (decision trees, sequential and association rules etc).\n- Specification of background knowledge: background knowledge is information about the application field. This primitive offers to the Data Miner the opportunity to specify his domain knowledge which affects positively the mined knowledge quality. Concept hierarchy is the most used background knowledge (Han and Kamber,2000). - Specification of constraints mining: specification of constraints set that the patterns must satisfy. - Closure property: the result of data mining query could be re-queried such as for SQL. - Post-processing task: the user should be able to query extracted patterns, cross over patterns and data etc."}, {"heading": "3. THE COMPARATIVE TABLE", "text": "In this section, we study six DM query languages. We present these languages according to a set of properties corresponding to the primitives defined in the previous section. Thus, we classify the languages in a table such that rows correspond to properties and columns to languages. Eeach cell (crossing a property Pi and a language Lj) is the satisfaction degree of the property Pi by the language Lj (see table 1).\nTable 1 contains two parts. In the first one, each language is described generally (language authors, design, year etc). In the second part, we present the functionalities provided by each language as explained on the top."}, {"heading": "4. DATA MINING QUERY LANGUAGES IN ACTION", "text": "In this section, we explore DM query languages capabilities and we present the syntax of each language. In addition, we set a database example about supermarket sales (see table 2) and tried to write some queries to perform KDD operations that turn around the DM step, mainly in order to extract association rules since their mining is provided by all the languages."}, {"heading": "4.1. MSQL", "text": "MSQL has four main queries: - Create Encoding: this query allows discretization of continuous attributes. The command creates ranges\nof values, and assigns discrete integers to those ranges. Discretization is done \u201con the fly\u201d and discrete values are not stored anywhere.\n- GetRules: this query allows the generation of association rules, which are stored in a suitable table. - SelectRules: this query allows the selection of association rules. This is very important to post-process the\nmined patterns.\n- Satisfies and Violates: these operators allow cross-over between data and association rules: that is\nselecting data generating a set of association rules (satisfies), or data that contradict (violates) them.\nIllustration\nIn this subsection (repeated for each language section), we tried to mine association rules with bodies about items and head about income customer from sales database example (see table 2). We choose to mine only transactions paid by credit card, thus extracted associations are only about this kind of transactions.\nMSQL needs a special data format to mine association rules; MSQL works in a way that each descriptor is an attribute. The domain of an attribute should be a set of discrete values. Thus, continuous attributes have to be encoded, i.e., discretized. Table3 represents the first row of our input relations (items bought, payment mode and customer income).\nThis transformation is manually done by the user since there is no MSQL transformation query.  Pre-processing First of all, we have to select data we want to mine. In our example, we want to mine only transactions paid by credit cards for associations between items and income. Thus, we create a view named transaction_view using a classical SQL query that extracts data from the relation transactions: CREATE VIEW TRANSACTION_VIEW AS SELECT ID_TRANSAC,INCOME,PAYMENT_MODE, SUM(CASE ITEM WHEN \u2019A\u2019 THEN 1 ELSE 0 END)) AS S /*repeat the SUM(CASE\u2026 expression for each item in the table transactions*/ FROM TRANSACTIONS T, CUSTOMER C WHERE T.ID_CUSTOMER=C.ID_CUSTOMER AND PAYMENT_MODE=\u2019Credit_card\u2019 GROUP BY ID_CUSTOMER,ID_TRANSACTION,INCOME,PAYMENT_MODE;\nIn the second step, we must discretize the attribute income which is continuous. This query allows the\ndiscretization of the attribute income. Discrete values are not materialized: CREATE ENCODING DSCRT_INCOME ON TRANSACTION_VIEW.INCOME AS"}, {"heading": "BEGIN", "text": "(MIN,499,1), (500,599,2), (600,699,3), (700,799,4), (800,MAX,5), 0 END;\n Association Rule Mining In this step, we want to mine association rules with the following form: itemsincome. Association rules\nsupport and confidence are fixed respectively to 2 and 0.5. To achieve this task, we write this MSQL query: GETRULES(TRANSACTION_VIEW) INTO TRANSACTION_RB WHERE BODY HAS {(A=1) OR (B=1) OR (C=1) OR (E=1)} AND\nCONSEQUENT IS{(INCOME=*)} AND SUPPORT>2 AND CONFIDENCE>=0.5"}, {"heading": "USING DSCRT_INCOME FOR INCOME;", "text": "The resulting association rules are stored in the table transaction_rb (see table 4).  Post-processing In this step, we try to cross-over data and patterns mined in the previous step, assuming we want to\nextract data that violate all association rules and whose bodies have the item A; this is the suitable query: INSERT INTO CROSS_OVER AS SELECT * FROM TRANSACTION_VIEW WHERE VIOLATES ALL (SELECTRULES(TRANSACTION_RB) WHERE BODY HAS {(A=1)});\nThe table CROSS_OVER is composed of transactions t2, t4, t5, t9 and t10; these tuples violates every\nrule having A in the body.\nrules with bodies included in no other rule having the same head. SELECTRULES(TRANSACTION_RB) AS R1 WHERE NOT EXISTS(SELECTRULES(TRANSACTION_RB) AS R2\nWHERE R2.BODY HAS R1.BODY AND NOT (R2.BODY IS R1.BODY) AND R2.CONSEQUENT IS R1.CONSEQUENT);\nWe have two rules satisfying our conditions, i.e., having the maximal body (D=1) revenu=[500,599]\nand (A=1)^(B=1) revenu=[500,599]."}, {"heading": "4.2. DMQL", "text": "DMQL defines an association rule as a relationship between two predicates sets. In a predicate P(X,v), P is an attribute, X is a variable and v is a value belonging to the attribute domain. Thus, the association rule ABCD is equivalent to item(X,A)^item(X,B)item(X,C)^item(X,D). The main DMQL query allows mining patterns. Here, we present its syntax: USE DATABASE (DATABASE_NAME) {USE HIERARCHY (HIERARCHY_NAME) FOR (ATTRIBUTE)} FIND ASSOCIATIONS [AS (RULE_NAME)] FROM (RELATION(S)) [WHERE (CONDITION)] [ORDER BY (ORDER_LIST)] {WITH [(KINDS_OF)] THRESHOLD=(THRESHOLD_VALUE)}\nThis query extracts association rules in the table rule_name, under the thresholds of the WITH clause, from\nthe database database_name and especially relations of the FROM clause filtered by the WHERE clause."}, {"heading": "Illustration", "text": "In this section, we try to re-do the same operations performed for MSQL.\n Pre-processing With DMQL, it\u201fs possible to discretize continuous attributes using the concept hierarchy definition query:\nDEFINE HIERARCHY INCOME_HIERARCHY FOR INCOME ON TRANSACTION AS LEVEL1 :{MIN\u2026499}$<$LEVEL0 :ALL LEVEL1 :{500\u2026599}$<$LEVEL0 :ALL LEVEL1 :{600\u2026699}$<$LEVEL0 :ALL LEVEL1 :{700\u2026799}$<$LEVEL0 :ALL LEVEL1 :{800\u2026MAX}$<$LEVEL0 :ALL\n Association Rule Mining DMQL allows syntactic constraints specification using metapaterns. The metapaterns are used to focus the discovery towards patterns that match given templates. Here, we want to mine rules that include in the body different items and in the head the income, with a support fixed to 25% and a confidence fixed to 50%: USE DATABASE SALES USE HIERARCHY INCOME_HIERARCHY FOR INCOME FIND ASSOCIATIONS AS TRANSACTION_RB MATCHING WITH ITEM+(X,{I}) INCOME(X,A) FROM TRANSACTIONS T, CUSTOMER C WHERE T.ID_CUSTOMER=C.ID_CUSTOMER AND PAYMENT_MODE=\u2019credit_card\u2019 GROUP BY ID_TRANSAC"}, {"heading": "WITH SUPPORT THRESHOLD=25% WITH CONFIDENCE THRESHOLD=50%;", "text": "In metapaterns, symbol \u201e+\u201f means that we search rules whose bodies are composed of one or more items. In table 5, we present association rules extracted by the previous query. We distinguish three tables: the right one, the middle one and the left one are used respectively to represent rules heads, rules bodies and relationships between the two rules components tables.\n Post-processing DMQL doesn\u201ft provide a cross-over query. Post-processing operations are feasible via SQL queries on\nrule tables. Theses queries are very complex, it is not explicit for novice SQL users.\nWe tried to write queries (1) that extract data that violates all rules having the item \u201eA\u201f in their bodies and (2) that select all maximal rules. We tried to simplify queries written in [BBM+02] but the result remains complex to novice SQL users. To make queries easier, we create the view RULES which is the natural joint of our three rules tables, and the view SALES which the natural joint of tables TRANSACTIONS and CUSTOMER. SELECT DISTINCT id_transac FROM sales /*We select all data and we*/ MINUS /*subtract from them all data that satisfy at least one rule*/ SELECT DISTINCT id_transac FROM sales S /*with A in the body.*/ WHERE EXISTS(SELECT id_r FROM rules R /*we search data such*/ WHERE item='A\u2019 /*it exists at least one rule which*/ /*is included*/ AND NOT EXISTS(SELECT ITEM,INCOME FROM rules Q /*in these data. A set X is*/ WHERE R.id_r=Q.id_r /*included in another one Y*/ MINUS /*if X minus Y is the empty set.*/SELECT item,income FROM sales T\nwhere T.id_transac=S.id_transac));\nIn order to obtain data that violates all rules having \u201eA\u201f in the body, we subtract data that satisfy at least\none rule having \u201eA\u201f in the body from all the data. Now, we select maximal rules bodies. SELECT * FROM rules /*We select all rules and we subtract from*/ MINUS SELECT * FROM rules R /*them all rules included in at least*/ WHERE EXISTS (SELECT * FROM REGLES M /* another rule. A body of a*/\nWHERE M.id_r!=R.id_r AND EXISTS(SELECT item,income FROM rules S\n/*rule X is included*/ WHERE R.income=S.income AND M.idr=S.idr /*in another one Y if the*/ INTERSECT /*intersection of X.body*/ SELECT item,income FROM rules P /*and Y.body is not empty*/ WHERE R.idr=P.idr) /* and if X is larger*/ AND (SELECT COUNT(*) FROM rules Q /*than Y.*/ WHERE Q.idr=M.idr)>\n(SELECT COUNT(*) FROM rules U\nWHERE U.idr=R.idr));"}, {"heading": "4.3. MINE RULE", "text": "MINE RULE is another DM Query Language. Its main query syntax is the following: MINE RULE <RULETABLENAME> AS SELECT DISTINCT [<CARDSPEC>] <ATTRBLIST> AS BODY,\n[<CARDSPEC>] <ATTRBLIST> AS HEAD [,SUPPORT][,CONFIDENCE]\n[WHERE <WHERECLAUSE>] FROM <FROMLIST> [WHERE <WHERECLAUSE>] GROUP BY <ATTRBLIST> [HAVING <HAVINGCLAUSE>] [CLUSTER BY <ATTRBLIST> [HAVING <HAVINGCLAUSE>]] EXTRACTING RULES WITH SUPPORT:<REAL>, CONFIDENCE:<REAL>; Avec <CARDSPEC> = <NUMBER>..<NUMBER>|N.\nThis query enables association rule mining from data selected in the FROM clause and restricted by the WHERE clause. Rule body schema is defined in the SELECT clause by putting the attributes which corresponds to the rule body and their cardinality before the keyword BODY just as attributes, which correspond to rule\u201fs head and their cardinality before the keyword HEAD. Data are grouped thanks to the GROUP clause. Groups may be restricted by putting group conditions in the HAVING clause. The CLUSTER clause enables clustering data into\ngroups. Then, rules are extracted only from within couples of clusters into the same group, one cluster for the body and the other for the head. For more details, refer to (Meo et al, 2002)."}, {"heading": "Illustration", "text": "We illustrate MINE RULE for the same Data Mining operations performed in the previous languages\nsections.\n Pre-processing Data selection is possible since MINE RULE nests SQL. However, MINE RULE doesn\u201ft provide a discretization operator. Discretization is performed via the SQL function TRUNC(income,2) which rounds down income values. For example, incomes between 500 and 599 correspond to 500.\n Association Rule Mining We formulate the appropriate MINE RULE query that mines association rules exceeding the support\nthreshold 25% and the confidence threshold 50% and with bodies composed of items and heads of income. MINE RULE TRANSACTION_RB AS SELECT DISTINCT 1..N ITEM AS BODY, 1..1 TRUNC(INCOME,2) AS HEAD, SUPPORT, CONFIDENCE FROM TRANSACTIONS T, CUSTOMER C WHERE T.ID_CUSTOMER=C.ID_CUSTOMER AND PAYEMENT_MODE=\u2019credit_card\u2019 GROUP BY ID_TRANSAC EXTRACTING RULES WITH SUPPORT : 0.25, CONFIDENCE : 0.5 ;\nRule representation is lightly different form the DMQL one, but similar to the MSQL one in the way that\nrules are stored in a single table with four attributes; body and head that are vectors, support and confidence.\n Post-processing Like DMQL, MINE RULE doesn\u201ft provide post-processing operations."}, {"heading": "4.4. MineSQL", "text": "MineSQL is a SQL extension for data mining in relational databases. MineSQL queries aim mainly to mine association rules and also extract characteristic rules. The language provides a new data type called RULE, used to store and to manage rules. An attribute of type RULE has four components: set of body elements, set of head elements and support and confidence values.\nThere are several functions on the type RULE, such as the functions support(r), confidence(r), body(r) that return respectively the support, the confidence and the body of the rule r. There are also two operators SATISFIED BY and VIOLATED BY, which allow cross-over between data and patterns. MineSQL makes patterns post-processing easy via its functions and its two operators. The syntax of the main MineSQL query is the following: MINE RULE_EXP [[AS] ALIAS] [FOR {DATA_EXPR [USING TAX_NAME][AS ALIAS]|*}] [TO {DATA_EXPR [USING TAX_NAME][AS ALIAS]|*}] FROM TABLE [,TABLE] [WHERE {DATA_CONDITION|RULE_CONDITIONG} [{AND|OR} {DATA_CONDITION|RULE_CONDITION}] [GROUP BY DATA_EXPR [,DATA_EXPR] [HAVING CONDITION]] [ORDER BY RULE_EXPR [{ASC|DESC}]]\nIn this query, rule_exp denotes the rule expression, i.e., the generated rule representation. data_exp denotes data expression, (attributes, constants, functions etc.). The structure of the rule is defined as a subset of attribute expressions in the FOR clause and the head is defined as a subset of attribute expressions in the TO clause. The clause FROM specifies data to be mined. The selection of extracted data and rules depends on conditions specified in the WHERE clause. The MINE statement inspects records, grouped by attributes indicated in the GROUP BY clause."}, {"heading": "Illustration", "text": "We continue performing the same Data Mining operations via MineSQL queries.\n Pre-processing\nLike DMQL and MINE RULE, MineSQL doesn\u201ft provide discretization query, but discretization may be done by specifying hierarchies (or taxonomy as called by some authors). CREATE TAXONOMY INCOME_HIERARCHY(NODE \u2018AGE_DSCT\u2019, LEAF [MIN\u2026499] REFERENCES 1, LEAF [500\u2026599] REFERENCES 2, LEAF [600\u2026699] REFERENCES 3, LEAF [700\u2026799] REFERENCES 4, LEAF [800\u2026MAX] REFERENCES 5);\n Association Rule Mining We formulate MineSQL statement to extract association rules from transactions done by credit card, under support threshold 25% and confidence threshold 50%. Mined association rules are stored in a table we call transaction_rb. This table contains a column of type RULE and a column of type VARCHAR which is a description of the rule. The table creation statement is the following: CREATE TABLE TRANSACTION_RB(RL RULE, DESCRIPTION VARCHAR(20));\nThe column RL is composed of a support value, a confidence value and of two sets of rule elements (Ai=v), where Ai is an item and v is a value of Ai domain; first set is the rule body, the second one is the head. INSERT INTO TRANSACTION_RB(R) MINE RULE, SUPPORT(RULE), CONFIDENCE(RULE) FOR ITEM TO INCOME USING INCOME_HIERARCHY AS INCOME_H FROM (SELECT SET(ITEM), INCOME FROM TRANSACTIONS T, CUSTOMER C\nThe transaction identifiers selected by the query above are: t2, t4, t5, t9 and t10. The language also allows\nselecting rules with maximal bodies. We use MineSQL functions to extract it: SELECT * FROM TRANSACTION_RB TRB1 WHERE NOT EXISTS(SELECT * FROM TRANSACTION_RB TRB2 WHERE BODY(TRB1.RGL) IN BODY(TRB2.RGL) AND HEAD(TRB1.RGL)=HEAD(TRB2.RGL));\nThe selected association rules are: Item=\u2019D\u2019Income=[500,599] and Item=\u2019A\u2019&item=\u2019B\u2019Income=[500,599]."}, {"heading": "4.5. DMX", "text": "The OLE DB for Data Mining API defines common data mining concepts such as mining models, model training, model content, model prediction and so on. It also defines a query language for data mining. The syntax of this query language is similar to SQL (Tang and MacLennan, 2005). A data mining model or mining model can be thought of as a relational table. It contains key columns, input columns and predictable columns. Each model is associated with a data mining algorithm, on which the model is trained. After training, the data mining model stores the patterns discovered by the data mining algorithm about the dataset. While a relational table is a container of records, a data mining model is a container of patterns.\nSo a model is created; it deals with creating an empty data mining model, similar to the way we create a new table. Then, it\u201fs trained; the model training is used to invoke the data mining algorithm to uncover knowledge about the training dataset. After training, the patterns are stored in the mining model. Finally, we can apply the trained model to the new dataset and predict potential values of predictable columns for each\nnew case: this is called model prediction (Tang and MacLennan, 2005). This is a simplified DMX syntax query to create a model: CREATE MINING MODEL <model> (<comma-separated list of column definitions>) USING <algorithm> [(<parameter list>)]\nAnd this is a simplified DMX syntax query to train a model: INSERT INTO <model> (<mapped model columns>) <source data query> Illustration\n Pre-processing DMX is different from the other languages because data selection is done after model creation. In Model\nCreation step, the data miner has to select only the attributes concerned with the model.\nDiscretization is the second pre-processing operation we do in this phase. DMX provides four statistical and data mining methods to do that: clusters, equal areas, thresholds and automatic (see (Tang and MacLennan, 2005)).\n Association Rule Mining In fact, the two steps (pre-processing and ARM) are not really separated for DMX. For example\ndiscretization is done on the fly, and data selection is done after model definition. CREATE MINING MODEL TRANSACTION_RB (ID_TRANSAC LONG KEY INCOME LONG DISCRETIZED PREDICT_ONLY, ITEMS TABLE(ITEM TEXT KEY)) USING MICROSOFT_ASSOCIATION_RULES (MINIMUM_SUPPORT=2, MIN_PROBABILITY=0.5)\nIn an association model, if a column is used for input, its values can be used only on the left side of association rules. If a column is used to make predictions, the column\u201fs states can be used on the left and right sides of the association rules. If a column is PREDICT_ONLY, it appears on the right side of rules. In the model creation query, our model has two attributes. The first one is INCOME, which must be discretized; it\u201fs a PREDICT_ONLY variable since we want it in the rule head. The second model attribute is a table we call ITEMS which represents the set of items bought by customers. This attribute is used for input (only in rule body).\nWhile defining algorithm parameters and syntactic constraints is called model creation, association rules\ngeneration following our model definition is the model training: INSERT INTO [TRANSACTION_RB] (ID_TRANSAC,INCOME,ITEMS) SHAPE {SELECT [ID_TRANSAC],[INCOME] FROM TRANSACTIONS A,CUSTOMER WHERE A.ID_CUSTOMER=CUSTOMER.ID_CUSTOMER AND A.PAYMENT_MODE=\"credit_card\" APPEND( {SELECT [ITEM] FROM TRANSACTIONS B RELATE A.ID_TRANSAC TO B.ID_TRANSAC ORDER BY [ID_TRANSAC]}) AS [ITEMS]}\nHere, the keyword SHAPE is used to specify target data; in deed we must select each transaction with its basket. The keyword APPEND is used to achieve this aim and to complete the data selection. It is used to add the set of items bought in for each transaction. The keyword RELATE is used to put the convenient basket to each transaction.\n Post-processing The OLE DB for DM model has a representation tree with three levels. The top level has a single node that represents the model. The second level contains nodes representing qualified itemsets with their associated supports. The rowsets of the itemset nodes contain detailed information about the itemsets, with each row representing an individual item. The third level contains nodes that represent qualified rules. The parent of the rule node is the itemset that represents the left side item of a rule. The right side of a rule always has a single item, which is stored in the rowsets.\nTo select all retrieved association rules, we query the node type 8; the node type 7 is about itemsets: SELECT NODE_DESCRIPTION FROM TRANSACTION_RB.CONTENT WHERE NODE_TYPE=8;\nWe note that association rules are stored in PMML format which is XML-based. OLE DB for DM\ndoesn\u201ft provide real operators or functions to post-process association rules like MSQL and MineSQL."}, {"heading": "4.6. ODMQL", "text": "ODMQL allows the user to formulate data mining queries in an OQL-like syntax (Elfeky et al, 2000). The Data Mining language supports specification of four rule types: characteristic rules, discriminant rules,\nclassification rules and association rules. The set of relevant data is specified by the WITH RELEVANCE TO clause. ODMQL also supports the specification of some kinds of threshold according to the mined rule type and allows the user to specify concept hierarchies for the attributes of the schema. Concept hierarchies could be created, modified and dropped. The general syntax of ODMQL queries (mining rules and manipulating concept hierarchies) is the following: MINE FOR <rule_specification> WITH RELEVANCE TO <projection_attributes> FROM <variable_declaration> {,<variable_declaration>} [WHERE <condition>] [WITH THRESHOLD[S](<threshold>,{<threshold>})]\nHere, rule_specification could be ASSOCIATION RULES, CHARACTERISTIC RULES,\nDISCRIMINANT RULES or CLASSIFICATION RULES. Threshold is specified in this form: <threshold>::=<threshold_type>=<numerical_value>\nThe syntax used to define concept hierarchies is: DEFINE HIERARCHY FOR <attribute> ANY -> <concept_set> {,<concept_definition>} <concept_definition>::=<concept>-><concept_set> <concept_set>::={<concept>{,<concept>}}|[numerical_value..numerical_value] <concept>::=ANY|<string_lateral> Illustration\n Pre-processing ODMQL nests OQL, so it allows data selection via the FROM and WITH clauses. Unfortunately, it doesn\u201ft provide a discretization operator, but we can use concept hierarchies to define all possible values for each income interval, i.e., income discretization. DEFINE HIERARCHY FOR INCOME: ANY-> {I4,I5,I6,I7,I8}, I4->[0..499],I5->[500..599],I6->[600..699],I7->[700..799],I8->[800..Int_Limit];\n Association Rule Mining In deed, we didn\u201ft find any track of association rule mining syntax or an example for extracting association rules that are multidimensional (items in the rule correspond to different attributes) for ODMQL language. That\u201fs why we cannot illustrate the mining operator of ODMQL in our example.\n Post-processing ODMQL doesn\u201ft provide any post-processing operator. This primitive remains the most ignored by Data\nMining Languages despite its importance and its definition as a primitive."}, {"heading": "5. DISCUSSION", "text": "In this paper, we studied existent DM Languages extending the work of (Botta et al, 2004). The objective is to get leverage on achievements and limits of the state of the art. We note that generally, SQL is nested in almost all languages enhancing the data selection capabilities. However, the pre-processing and transformation KDD steps are not supported by the whole of the language. MSQL and DMX are the only languages that provide a discretization operator. In these preliminaries KDD steps, there is also a need for sampling techniques, cleaning techniques, errors and missing values handling techniques etc.\nThe step that follows data pre-processing is the DM. The DM step is provided by all languages. All of them focus on mining patterns from a dataset. DMX, DMQL and ODMQL offer to the Data Miner several kinds of patterns, which constitute an important feature for an exhaustive Data Mining language. In addition, background knowledge specification is provided by almost all the languages except MSQL.\nRegarding post-processing, there is a great lack for this KDD step. Only MSQL and MineSQL provide operators and functions allowing the data miner to handle and to manipulate patterns. The same languages also provide operators to cross-over data and patterns. Finally, the whole of the languages satisfy the closure property since all patterns are stored in relational database (except ODMQL). The closure property allows complex manipulation and selection of data and/or patterns enhancing the capabilities of the language.\nA crucial step for a standard DM query language is to define clearly its primitives. A better understanding of Data Miners requirements and DM challenges (Fayyad et al, 2003) is the key feature of a good primitives\u201f definition. Then, a theory of inductive query answering is required to formulate all KDD operations and properties in an algebraic language. Several researchers tried to do so ((Boulicaut et al, 1999), (De Raedt, 2003), (Dan Lee and De Raedt, 2003) and (De Raedt et al, 2004)) and aimed to answer inductive queries. Once primitives are better defined and an inductive query evaluation theory is clearly formulated, computer science techniques of computation and optimization will evolve and advances will be achieved, especially in\nconstraint-based mining and optimization of query evaluation (Jeudy and Boulicaut, 2002), (Pensa et al, 2006). A practical and efficient DM query language should produce an exponential emergence of DM applications and inductive databases. There are surely many inductive databases ((Han et al,1996b), (Kaufman and Michalski, 2002) and (Helma et al, 2002)) and DM applications in the nature, but all of them present isolated functionalities due to the lack of a standard framework and theory of DM.\nREFERENCES\nBotta, M., Boulicaut, J-F., Masson, C., Meo, R, 2004. Query Languages Supporting Descriptive Rule Mining : a\nComparative Study. In Database Technologies for Data Mining - Discovering Knowledge with Inductive Queries, Vol 2682, pages 27\u201354. Springer-Verlag.\nBoulicaut, J-F., Klemettinen, M., Mannila, H. Modeling KDD processes within the inductive database framework, 1999.\nIn M. Mohania et A. Min Tjoa \u00e9ds., Proceedings of the 1st International Conference on Data Warehousing and Knowledge Discovery (DaWaK\u201f99). pp 293-302.\nCodd, E. A Relational Model of Data for Large Shared Data Banks, 1970. ACM. Vol. 13, No 6, pp 377-387.\nDan Lee, S., De Raedt, L, 2003. An Algebra for Inductive Query Evaluation. In Proceedings of the 2nd Workshop on Knowledge Discovery in Inductive Database (KDID\u201f03).\nLuc de Raedt. A Perspective on Inductive Databases, 2003. SIGKDD Explorations, Vol. 4, No 2, pp 69-77.\nRaedt, L., Jaeger, M, Dan Lee, S., Mannila, H, 2002. A Theory of Inductive Query Answering. In Second IEEE International Conference on Data Mining (ICDM'02), pp137.\nElfeky, M-G., Saad, A-A. and Fouad S-A, 2000. ODMQL: Object Data Mining Query Language. Lecture Notes in Computer Science 1944 (LNCS), pp.128-140.\nFayyad, U., Piatetsky-Shapiro, G., and Smyth, P, 1996. From Data Mining to Knowledge Discovery: An Overview. In\nFayyad, U., Piatetsky-Shapiro, G., Amith, Smyth, P., and Uthurnsamy, R. (eds.), Advances in Knowledge Discovery and Data Mining, MIT Press, 1-36, Cambridge.\nFayyad, U., Piatetsky-Shapiro, G., Uthurusamy, R, 2003. Data Mining: The Next 10 Years. SIGKDD Explorations, Vol\n5, No 2, pp 191-196.\nHan, J., Fu, Y., Wang, W., Koperski, K., Zaiane, O, 1996. DMQL : A Data Mining Query Language for Relational\nDatabases. In R. Ng, editor, Proc. ACM SIGMOD Workshop DMKD\u201f96, Montreal, Canada.\nHan, J., Fu, Y., Wang, J., Chiang, W., Gong, K., Koperski, K., Li, D., Lu, Y., Rajan, A., Stefanovic, N., Xia, B., Za\u00efane,\nO, 1996. DBMiner : A System for Data Mining Knowledge in Large Relational Databases. Proceedings of International Conference on Knowledge Discovery in Databases and Data mining (KDD\u201f96), pp 250-255.\nHan, J., Kamber, M, 2000. Data Mining : Concepts and Techniques. Morgan Kaufmann, San Fransisco, CA.\nHelma, C., Kramer, S., De Raedt, L, 2002. The Molecular Feature Miner MOLFEA. Proceedings of the Beilstein Workshop 2002: Molecular Informatics: Confronting Complexity.\nImielinski, T., Mannila, H, 1996. A database perspective on knowledge discovery. Communications of the ACM, Vol, 39, No 11, pp373-408.\nImielinski, T., Virmani, A, 1999. MSQL : A Query Language for Database Mining. Data Mining and Knowledge Discovery, 3, pp 373\u2013408.\nJeudy, B., Boulicaut, J-F, 2002. Constraint-Based Discovery and Inductive Queries: Application to Association Rule\nMining. In Proceedings of the European Science Foundation Exploratory Workshop on Pattern Detection and Discovery in Data Mining, London (UK), pp 16-18.\nKaufman, K., Michalski., R-S, 2003. The Development of the Inductive Database System VINLEN: A Review of Current Research. Intelligent Information Systems, pp 267-276.\nMeo, R., Psaila, G., Ceri, S, 1996. A New SQL-like Operator for Mining Association Rules. In Proc. VLDB\u201f96 (1996), Bombay (India). Morgan Kaufmann. pp. 122\u2013133.\nMorzy, T., Zakrzewicz, M, 1997. SQL-Like Language for Database Mining.In 1st International Conference on Advances in Databases and Information Systems, St. Petersburg.\nNetz, A., Chaudhuri, S., Bernhardt, J., Fayyad, U, 2000. Integration of Data Mining and Relational Databases. In Proc. VLDB\u201f00, pages 719\u2013722, Cairo, Egypt.\nPensa, R., Robardet, C., Boulicaut, J-F, 2006. Towards constrained co-clustering in ordered 0/1 data sets. Proceedings of\nthe 16th International Symposium on Methodologies for Intelligent Systems ISMIS'06, Bari (I), pp 425-434.\nTang, Z-H. and MacLennan, J, 2005. Data Mining with SQL SERVER 2005. Wiley Publishing, Inc, Indianapolis."}], "references": [{"title": "Query Languages Supporting Descriptive Rule Mining : a Comparative Study. In Database Technologies for Data Mining - Discovering Knowledge with", "author": ["M. Botta", "Boulicaut", "J-F", "C. Masson", "R Meo"], "venue": "Inductive Queries,", "citeRegEx": "Botta et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Botta et al\\.", "year": 2004}, {"title": "Modeling KDD processes within the inductive database", "author": ["Boulicaut", "J-F", "M. Klemettinen", "H. Mannila"], "venue": "Proceedings of the 1st International Conference on Data Warehousing and Knowledge Discovery", "citeRegEx": "Boulicaut et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Boulicaut et al\\.", "year": 1999}, {"title": "A Relational Model of Data for Large Shared Data", "author": ["E. Codd"], "venue": "Banks, 1970. ACM", "citeRegEx": "Codd,? \\Q1970\\E", "shortCiteRegEx": "Codd", "year": 1970}, {"title": "An Algebra for Inductive Query Evaluation", "author": ["S. Dan Lee", "L De Raedt"], "venue": "In Proceedings of the 2nd Workshop on Knowledge Discovery in Inductive Database (KDID\u201f03)", "citeRegEx": "Lee and Raedt,? \\Q2003\\E", "shortCiteRegEx": "Lee and Raedt", "year": 2003}, {"title": "A Theory of Inductive Query Answering", "author": ["L. Raedt", "M Jaeger", "S. Dan Lee", "H Mannila"], "venue": "In Second IEEE International Conference on Data Mining (ICDM'02),", "citeRegEx": "Raedt et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Raedt et al\\.", "year": 2002}, {"title": "ODMQL: Object Data Mining Query Language", "author": ["Elfeky", "M-G", "Saad", "A-A", "Fouad S-A"], "venue": "Lecture Notes in Computer Science 1944 (LNCS),", "citeRegEx": "Elfeky et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Elfeky et al\\.", "year": 2000}, {"title": "From Data Mining to Knowledge Discovery: An Overview", "author": ["U. Fayyad", "G. Piatetsky-Shapiro", "P Smyth"], "venue": "Advances in Knowledge Discovery and Data Mining,", "citeRegEx": "Fayyad et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Fayyad et al\\.", "year": 1996}, {"title": "Data Mining: The Next 10 Years", "author": ["U. Fayyad", "G. Piatetsky-Shapiro", "R Uthurusamy"], "venue": "SIGKDD Explorations,", "citeRegEx": "Fayyad et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Fayyad et al\\.", "year": 2003}, {"title": "DMQL : A Data Mining Query Language for Relational Databases", "author": ["J. Han", "Y. Fu", "W. Wang", "K. Koperski", "O Zaiane"], "venue": "Proc. ACM SIGMOD Workshop DMKD\u201f96,", "citeRegEx": "Han et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Han et al\\.", "year": 1996}, {"title": "DBMiner : A System for Data Mining Knowledge in Large Relational Databases", "author": ["J. Han", "Y. Fu", "J. Wang", "W. Chiang", "K. Gong", "K. Koperski", "D. Li", "Y. Lu", "A. Rajan", "N. Stefanovic", "B. Xia", "O Za\u00efane"], "venue": "Proceedings of International Conference on Knowledge Discovery in Databases and Data mining (KDD\u201f96),", "citeRegEx": "Han et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Han et al\\.", "year": 1996}, {"title": "Data Mining : Concepts and Techniques", "author": ["J. Han", "M Kamber"], "venue": null, "citeRegEx": "Han and Kamber,? \\Q2000\\E", "shortCiteRegEx": "Han and Kamber", "year": 2000}, {"title": "The Molecular Feature Miner MOLFEA", "author": ["C. Helma", "S. Kramer", "L De Raedt"], "venue": "Proceedings of the Beilstein Workshop", "citeRegEx": "Helma et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Helma et al\\.", "year": 2002}, {"title": "A database perspective on knowledge discovery", "author": ["T. Imielinski", "H Mannila"], "venue": "Communications of the ACM,", "citeRegEx": "Imielinski and Mannila,? \\Q1996\\E", "shortCiteRegEx": "Imielinski and Mannila", "year": 1996}, {"title": "MSQL : A Query Language for Database Mining", "author": ["T. Imielinski", "A Virmani"], "venue": "Data Mining and Knowledge Discovery,", "citeRegEx": "Imielinski and Virmani,? \\Q1999\\E", "shortCiteRegEx": "Imielinski and Virmani", "year": 1999}, {"title": "Constraint-Based Discovery and Inductive Queries: Application to Association Rule Mining", "author": ["B. Jeudy", "Boulicaut", "J-F"], "venue": "In Proceedings of the European Science Foundation Exploratory Workshop on Pattern Detection and Discovery in Data", "citeRegEx": "Jeudy et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Jeudy et al\\.", "year": 2002}, {"title": "The Development of the Inductive Database System VINLEN: A Review of Current Research", "author": ["K. Kaufman", "Michalski", "R-S"], "venue": "Intelligent Information Systems,", "citeRegEx": "Kaufman et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Kaufman et al\\.", "year": 2003}, {"title": "A New SQL-like Operator for Mining Association Rules", "author": ["R. Meo", "G. Psaila", "S Ceri"], "venue": "In Proc", "citeRegEx": "Meo et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Meo et al\\.", "year": 1996}, {"title": "SQL-Like Language for Database Mining.In 1st International Conference on Advances in Databases and Information Systems, St. Petersburg", "author": ["T. Morzy", "M Zakrzewicz"], "venue": null, "citeRegEx": "Morzy and Zakrzewicz,? \\Q1997\\E", "shortCiteRegEx": "Morzy and Zakrzewicz", "year": 1997}, {"title": "Integration of Data Mining and Relational Databases", "author": ["A. Netz", "S. Chaudhuri", "J. Bernhardt", "U Fayyad"], "venue": "In Proc", "citeRegEx": "Netz et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Netz et al\\.", "year": 2000}, {"title": "Towards constrained co-clustering in ordered 0/1 data sets", "author": ["R. Pensa", "C. Robardet", "Boulicaut", "J-F"], "venue": "Proceedings of the 16th International Symposium on Methodologies for Intelligent Systems ISMIS'06,", "citeRegEx": "Pensa et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Pensa et al\\.", "year": 2006}, {"title": "Data Mining with SQL SERVER 2005. Wiley Publishing, Inc, Indianapolis", "author": ["Tang", "Z-H", "J MacLennan"], "venue": null, "citeRegEx": "Tang et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Tang et al\\.", "year": 2005}], "referenceMentions": [{"referenceID": 12, "context": "IDB is a new generation of databases introduced in (Imielinski and Mannila, 1996) as a framework of KDD (Fayyad et al, 1996).", "startOffset": 51, "endOffset": 81}, {"referenceID": 2, "context": "In fact, the KDD community would reproduce the success of SQL based on Codd\u201fs algebra (Codd, 1970).", "startOffset": 86, "endOffset": 98}, {"referenceID": 13, "context": "In this section we give the primitives as defined in (Han and Kamber,2000), (Botta et al, 2004), and languages papers (Imielinski and Virmani, 1999), (Meo et al, 2002), (Han et al,1996), (Morzy and Zakrzewic, 1997), (Netz et al,2000) and (Elfeky et al, 2000).", "startOffset": 118, "endOffset": 148}], "year": 2017, "abstractText": "Since formulation of Inductive Database (IDB) problem, several Data Mining (DM) languages have been proposed, confirming that KDD process could be supported via inductive queries (IQ) answering. This paper reviews the existing DM languages. We are presenting important primitives of the DM language and classifying our languages according to primitives\u201f satisfaction. In addition, we presented languages\u201f syntaxes and tried to apply each one to a database sample to test a set of KDD operations. This study allows us to highlight languages capabilities and limits, which is very useful for future work and perspectives.", "creator": "Microsoft\u00ae Word 2010"}}}