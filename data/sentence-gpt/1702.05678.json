{"id": "1702.05678", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Feb-2017", "title": "An Adaptivity Hierarchy Theorem for Property Testing", "abstract": "Adaptivity is known to play a crucial role in property testing. In particular, there exist properties for which there is an exponential gap between the power of \\emph{adaptive} testing algorithms, wherein each query may be determined by the answers received to prior queries, and their \\emph{non-adaptive} counterparts, in which all queries are independent of answers obtained from previous queries. For example, when it comes to the following query:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "histories": [["v1", "Sun, 19 Feb 2017 00:03:09 GMT  (35kb)", "http://arxiv.org/abs/1702.05678v1", null]], "reviews": [], "SUBJECTS": "cs.DS cs.LG", "authors": ["clement canonne", "tom gur"], "accepted": false, "id": "1702.05678"}, "pdf": {"name": "1702.05678.pdf", "metadata": {"source": "CRF", "title": "An Adaptivity Hierarchy Theorem for Property Testing\u2217", "authors": ["Cl\u00e9ment L. Canonne", "Tom Gur"], "emails": ["ccanonne@cs.columbia.edu.", "tom.gur@weizmann.ac.il."], "sections": [{"heading": null, "text": "ar X\niv :1\n70 2.\n05 67\n8v 1\n[ cs\n.D S]\n1 9\nFe b\nIn this work, we investigate the role of adaptivity in property testing at a finer level. We first quantify the degree of adaptivity of a testing algorithm by considering the number of \u201crounds of adaptivity\u201d it uses. More accurately, we say that a tester is k-(round) adaptive if it makes queries in k+1 rounds, where the queries in the i\u2019th round may depend on the answers obtained in the previous i\u2212 1 rounds. Then, we ask the following question:\nDoes the power of testing algorithms smoothly grow with the number of rounds of adaptivity?\nWe provide a positive answer to the foregoing question by proving an adaptivity hierarchy theorem for property testing. Specifically, our main result shows that for every n \u2208 N and 0 \u2264 k \u2264 n0.99 there exists a property Pn,k of functions for which (1) there exists a k-adaptive tester for Pn,k with query complexity O\u0303(k), yet (2) any (k \u2212 1)-adaptive tester for Pn,k must make \u2126(n) queries. In addition, we show that such a qualitative adaptivity hierarchy can be witnessed for testing natural properties of graphs.\n\u2217This work previously appeared as \u201cFifty Shades of Adaptivity (in Property Testing).\u201d \u2020Columbia University. Email: ccanonne@cs.columbia.edu. Research supported by NSF grants CCF-1115703\nand NSF CCF-1319788. \u2021Weizmann Institute. Email: tom.gur@weizmann.ac.il. Research partially supported by ISF grant 671/13.\nContents"}, {"heading": "1 Introduction 1", "text": "1.1 Our Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Previous Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3"}, {"heading": "2 Preliminaries 4", "text": ""}, {"heading": "3 The Definition of Testers with Bounded Adaptivity 4", "text": ""}, {"heading": "4 A Strong Adaptivity Hierarchy 5", "text": "4.1 High-Level Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 4.2 Decision Tree Zoo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 4.3 Decision Tree Hierarchy: Some Things Only Adaptivity Can Address . . . . . . . . . 8 4.4 Adaptivity Bounded Testers and Decision Trees: There and Back Again . . . . . . . 10\n4.4.1 Preliminaries: Locally Testable and Decodable Codes . . . . . . . . . . . . . 10 4.4.2 Transference Lemmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11"}, {"heading": "5 An Adaptivity Hierarchy with respect to a Natural Property 13", "text": "5.1 Cycle Freeness in the Bounded Degree Graph Model . . . . . . . . . . . . . . . . . . 14 5.2 Lower Bounds for Round-Adaptive Testers . . . . . . . . . . . . . . . . . . . . . . . . 15"}, {"heading": "6 Some Miscellaneous Remarks 18", "text": "6.1 On Simulating k Rounds With Fewer . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 6.2 On the Connection with Communication Complexity . . . . . . . . . . . . . . . . . . 19 6.3 On the Relative Power of Round- and Tail-Adaptive Testers . . . . . . . . . . . . . . 21"}, {"heading": "1 Introduction", "text": "The study of property testing, initiated by Rubinfeld and Sudan [RS96] and Goldreich, Goldwasser and Ron [GGR98], has attracted significant attention in the last two decades (see, e.g., recent books [Gol10, Gol17, BY17] and surveys [Ron08, Ron09, Can15]). Loosely speaking, property testers are highly efficient randomized algorithms (typically running in sublinear time) that solve approximate decision problems, while only inspecting a tiny fraction of their inputs. More accurately, an \u03b5-tester T for property P is a randomized algorithm that, given query access to an input x, decides whether x \u2208 P or x is \u03b5-far (say, in Hamming distance) from P. The query complexity of T is then the number of queries it makes to x.\nIn general, a testing algorithm may select its queries adaptively such that the i\u2019th query is determined by the answers to the previous i\u2212 1 queries, in which case it is said to be an adaptive tester. However, in many natural cases, testers may actually determine their queries solely based on their randomness (and input length), without any dependency on answers to previous queries; a tester that satisfies this condition is called a non-adaptive tester. A natural question, which commonly arises in query-based models, is whether the ability to make adaptive queries can significantly affect the query complexity.\nAdaptive queries can be easily emulated at the cost of a large blowup in query complexity (exponential in the number of queries). More accurately, any q-query adaptive tester for a property of objects represented by functions f : D \u2192 R can be emulated by an |R|q-query non-adaptive tester (see e.g., [Gol17, Section 1.5]). While for certain types of properties and models \u2013 e.g., linear properties [BHR05] and properties in the dense graph model [GT03] \u2013 one has better emulations which come with little or no overhead, such efficient emulations cannot exist for all properties. As was shown by Raskhodnikova and Smith [RS06], in the bounded-degree graph model [GR00] there is a large chasm between the adaptive and non-adaptive query complexities of testing many natural graph properties. In particular, any property over bounded-degree graphs with n vertices, which is not determined by the vertex degree distribution,1 requires \u2126( \u221a n) queries to test non-adaptively, whereas many such properties (e.g., triangle-freeness and connectivity) have \u03b5-testers with query complexity poly(1/\u03b5).\nIn this work, we investigate the role of adaptivity in property testing at a finer level. Rather than considering the extreme cases of fully adaptive testers versus completely non-adaptive testers, we consider testers with various levels of restricted adaptivity and ask the following question:\nCan the power of testers gradually grow with the \u201camount\u201d of adaptivity they are allowed to use?\nBesides the sheer theoretical interest of understanding the role of adaptivity in property testing, a motivation for this question comes from the constraints that come with adaptive algorithms, which may counterbalance the apparent gain in efficiency. Indeed, non-adaptive algorithms (or at least those which only use a small number of adaptive \u201cstages\u201d) may be preferred in practice to their adaptive counterparts, in spite of the larger number of queries they make. The reason for this preference is the significant gains obtained by being able to make many queries in parallel: when each query is an experiment which, while relatively cheap by itself, may take several hours, assessing the trade-off between rounds of adaptivity and total number of queries becomes crucial.\n1Loosely speaking, a property P of bounded-degree graphs is not determined by the vertex degree distribution if there exist two graphs, G1 \u2208 P and G2 that is \u201cfar\u201d from P , such that the vertices of G1 and G2 have the same degrees.\nAn archetypal example where such considerations prevail is the (different) setting of group testing (see e.g. [DH00, Section 1.2]).\nTo answer the foregoing question, we shall first need to give a precise definition for the \u201camount\u201d of adaptivity that a tester uses. To this end, it is natural to consider the number of \u201crounds of adaptivity\u201d used by a tester.2 More precisely, we say that a tester is k-round-adaptive if it generates and makes queries in k + 1 rounds, where in the i\u2019th round the tester queries a set of locations Qi that may depend on the answers to queries in Q0, . . . , Qi\u22121, obtained in previous rounds. We will quantify the \u201camount\u201d of adaptivity that a tester uses by the number of rounds of adaptivity that it uses. Equipped with the notion of round adaptivity, we can proceed to present our results."}, {"heading": "1.1 Our Results", "text": "Our main result provides a positive answer to the foregoing question by showing an adaptivity hierarchy theorem for property testing; that is, we show a family of properties {Pk}k such that for every k, the property Pk is \u201ceasy\u201d for k-adaptive testers and \u201chard\u201d for (k \u2212 1)-adaptive testers.\nTheorem 1.1 (Informally stated (see Theorem 4.1)). For every n \u2208 N and 0 \u2264 k \u2264 n0.99 there is a property Pn,k of strings over Fn such that:\n1. there exists a k-round-adaptive tester for Pn,k with query complexity O\u0303(k), yet 2. any (k \u2212 1)-round-adaptive tester for Pn,k must make \u2126(n) queries.\nThe above theorem relies on an arguably contrived family of property, which was specifically tailored towards maximizing the separations; hence, one may wonder whether such strong separations also hold for more natural properties. As we show below, this is indeed the case: namely, we establish another adaptivity hierarchy theorem that, albeit weaker than Theorem 1.1, applies to the well-studied natural problem of testing k-cycle freeness in the bounded-degree graph model (see Section 5.1 for definitions).\nTheorem 1.2. Let k \u2208 N be a constant. Then, (i) there exists a k-round-adaptive tester with query complexity O(1/\u03b5) for (2k+1)-cycle freeness\nin the bounded-degree graph model; yet\n(ii) any (k\u22121)-round-adaptive tester for (2k+1)-cycle freeness in the bounded-degree graph model must make \u2126( \u221a n) queries, where n is the number of vertices in the graph.\nWe conclude this section by posing two open problems that naturally arise from our work.\nOpen Problem 1 (One property to rule them all). Does there exist an adaptivity hierarchy with respect to a single property? That is, for any m and all sufficiently large n, is there a property P of elements of size n, and q1 > . . . > qm (m \u201clevels\u201d of hierarchy) such that for every k \u2208 [m] there exists a k-adaptive tester for P with query complexity qk, yet every (k \u2212 1)-adaptive tester must make \u03c9(qk) queries to test P?\nOpen Problem 2 (Au naturel is just as good). Does there exist a family of natural properties which exhibits an adaptivity hierarchy with separations as strong as in Theorem 1.1?\n2We also consider an alternative notion of tail adaptivity, which roughly speaking refers to testers that first make a large number of non-adaptive queries and subsequently make a bounded number of adaptive queries. See Section 3 for details regarding how these two notions relate."}, {"heading": "1.2 Previous Work", "text": "As previously mentioned, the role of adaptivity in property testing has been the focus of several works before. It is well known that for any property of Boolean functions, there exists at most an exponential gap between adaptive and non-adaptive testers: any (adaptive) q-query testing algorithm for a property P of n-variate Boolean functions can be simulated by a non-adaptive tester with query complexity 2q \u2212 1. Further, such gaps are known to exist for some natural properties, such as read-once width-2 OBDDs [RT12, BMW11] and signed majorities [MORS09, RS13] (importantly, there also exist cases where adaptivity is known not to help [BLR93, BHR05]). Another prominent example of a class of Boolean functions where adaptivity is known to help is that of k-juntas [Bla09, Bla08, STW15, CST+17], which can be tested adaptively with O\u0303(k) queries, yet for which the non-adaptive query complexity is \u0398\u0303 ( k3/2 ) .\nOf course, the Boolean function setting is not the only one: in the dense graph model, it is known that while adaptivity can help [GR11], it will be at most by a quadratic factor [AFKS00, GT03]: that is, every graph property testable (adaptively) with q queries has an O ( q2 )\n-query non-adaptive tester. This is no longer the case in the bounded-degree model, however; where Raskhodnikova and Smith showed that there exist many properties which can be tested adaptively with a constant number of queries, but for which any non-adaptive tester must have query complexity \u2126( \u221a n) [RS06].\nHowever, all these results, even when they establish cases where adaptivity does help, leave open the question of how much adaptivity is needed for this to happen. In particular, for the case of properties of Boolean functions, many known adaptive testers which outperforms their non-adaptive counterpart do so, at some level, by conducting a binary search of some sort (see, e.g., [Bla09, RT12, RS13]) and thus comes inherently with a logarithmic numbers of \u201cadaptive rounds.\u201d\nOur proof of Theorem 1.1 relies on a connection between the property testing and linear decision tree models. Although many of the ingredients we use are new, the connection itself is not and was first observed in [Tel14] (see also [BCK14] for a slightly different connection between property testing and parity decision trees).\nAdaptivity in other settings. We remark that the notion of round complexity in communication complexity and interactive proof systems is somewhat analogous to that of round adaptivity, since in those models each round of communication or interaction allows the parties to adapt their strategies. Moreover, a round complexity hierarchy is known for communication complexity [NW93] and interactive proofs of proximity [GR17]. Finally, we also mention that the role of the number of adaptive measurements used by sparse recovery algorithms was shown to be very significant [IPW11].\nOrganization\nIn Section 2 we provide the preliminaries required for the technical sections. In Section 3 we provide a precise definition for testers with bounded adaptivity. In Section 4 we prove our main result, which is a strong adaptivity hierarchy theorem for a property of functions. In Section 5 we prove an adaptivity hierarchy theorem with respect to a natural property of graphs. Finally, in Section 6 we discuss adaptivity round reductions, as well as a connection to communication complexity, and the relation between round and tail adaptivity."}, {"heading": "2 Preliminaries", "text": "We begin with standard notations:\n\u2022 We denote the relative Hamming distance, over alphabet \u03a3, between two vectors x \u2208 \u03a3n and y \u2208 \u03a3n by dist(x, y) := |{xi 6= yi : i \u2208 [n]}| /n. If dist(x, y) \u2264 \u03b5, we say that x is \u03b5-close to y, and otherwise we say that x is \u03b5-far from y. Similarly, we denote the relative distance of x from a non-empty set S \u2286 \u03a3n by dist(x, S) := miny\u2208S dist(x, y). If dist(x, S) \u2264 \u03b5, we say that x is \u03b5-close to S, and otherwise we say that x is \u03b5-far from S. \u2022 We denote by Ax(y) the output of algorithm A given direct access to input y and oracle access to string x. Given two interactive machines A and B, we denote by (Ax, B(y))(z) the output of A when interacting with B, where A (respectively, B) is given oracle access to x (respectively, direct access to y) and both parties have direct access to z. Throughout this work, probabilistic expressions that involve a randomized algorithm A are taken over the inner randomness of A (e.g., when we write Pr[Ax(y) = z], the probability is taken over the coin tosses of A). \u2022 We use the notations O\u0303(f), \u2126\u0303(f) to hide polylogarithmic dependencies on the argument, i.e. for expressions of the form O(f logc f) and \u2126(f logc f) (for some absolute constant c). Finally, all our logarithms are in base 2.\nIntegrality. For simplicity of notation, we hereafter use the convention that all (relevant) integer parameters that are stated as real numbers are implicitly rounded to the closest integer.\nUniformity. To facilitate notation, throughout this work we define all algorithms non-uniformly; that is, we fix an integer n \u2208 N and restrict the algorithms to inputs of length n. Despite fixing n, we view it as a generic parameter and allow ourselves to write asymptotic expressions such as O(n). We remark that while our results are proved in terms of non-uniform algorithms, they can be extended to the uniform setting in a straightforward manner."}, {"heading": "3 The Definition of Testers with Bounded Adaptivity", "text": "In this section, we provide a formal abstraction that captures the notion of bounded adaptivity within the framework of property testing. We define two notions of bounded adaptivity: (1) roundadaptivity, which refers to algorithms that are allowed to make a bounded number of \u201cbatches\u201d of queries, where the queries in each batch may depend on the answers to previous batches; (2) tailadaptivity, which refers to algorithms that first make a large number of non-adaptive queries and subsequently make a bounded number of adaptive queries.\nWe remark that while tail-adaptivity can be easily emulated via round-adaptivity, the converse does not hold. Indeed, in Section 6.3 we show that round-adaptive testers can be much more powerful than tail-adaptive testers. Nonetheless, our lower bounds hold for the stronger roundadaptivity notion, whereas out upper bounds hold for the more restrictive tail-adaptivity.\nDefinition 3.1 (Round-Adaptive Testing Algorithms). Let \u2126 be a domain of cardinality n, and let k, q \u2264 n. A randomized algorithm is said to be a (k, q)-round-adaptive tester for a property P \u2286 2\u2126, if, on proximity parameter \u03b5 \u2208 (0, 1] and granted query access to a function f : \u2126 \u2192 {0, 1}, the following holds.\n(i) Query Generation: The algorithm proceeds in k + 1 rounds, such that at round \u2113 \u2265 0, it produces a set of queries Q\u2113 := {x(\u2113),1, . . . , x(\u2113),|Q\u2113|} \u2286 \u2126 (possibly empty), based on its own internal randomness and the answers to the previous sets of queries Q0, . . . , Q\u2113\u22121, and receives f(Q\u2113) = {f(x(\u2113),1), . . . , f(x(\u2113),|Q\u2113|)}; (ii) Completeness: If f \u2208 P, then the algorithm outputs accept with probability at least 2/3; (iii) Soundness: If dist(f,P) > \u03b5, then the algorithm outputs reject with probability at least 2/3. The query complexity q of the tester is the total number of queries made to f , i.e., q =\n\u2211k \u2113=0 |Q\u2113|. If\nthe algorithm returns accept with probability one whenever f \u2208 P, it is said to have one-sided error (otherwise, it has two-sided error). We will sometimes refer to a tester with respect to proximity parameter \u03b5 as an \u03b5-tester.\nRemark 3.2 (On amplification). We note that, as usual in property testing, the probability of success can be amplified by repetition to any 1 \u2212 \u03b4, at the price of an O(log(1/\u03b4)) factor in the query complexity. Crucially, this can be done with no increase in the number of adaptive rounds: while repetition would na\u00efvely multiply both q and k by this factor, one can avoid the latter by running the O(log(1/\u03b4)) independent copies of the algorithm in parallel, instead of sequentially.\nDefinition 3.3 (Tail-Adaptive Testing Algorithms). Let \u2126 be a domain of cardinality n, and let k, q \u2264 n. A randomized algorithm is said to be a (k, q)-tail-adaptive tester for a property P \u2286 2\u2126, if, on proximity parameter \u03b5 \u2208 (0, 1], error parameter \u03b4 \u2208 (0, 1], and granted query access to a function f : \u2126 \u2192 {0, 1}, the following holds. (i) Query Generation: The algorithm proceeds in k + 1 rounds, such that in the first round, it\nproduces a set of queries Q := {x(0),1, . . . , x(0),|Q|} \u2286 \u2126 (possibly empty), based on its own internal randomness; and receives f(Q) = {f(x(0),1), . . . , f(x(0),|Q|)}; then it makes, over the next k rounds, k adaptive queries to f , denoted x(1), . . . , x(k); (ii) Completeness: If f \u2208 P, then the algorithm outputs accept with probability at least 1\u2212 \u03b4; (iii) Soundness: If dist(f,P) > \u03b5, then the algorithm outputs reject with probability at least 1\u2212 \u03b4. The query complexity q of the tester is the total number of queries made to f , i.e., q = |Q| + k. If the algorithm returns accept with probability one whenever f \u2208 P, it is said to be one-sided (otherwise, it is two-sided).\nRemark 3.4 (On (lack of) amplification). Unlike the round-adaptive algorithms, tail-adaptive testing algorithms do not enjoy a simple success amplification procedure which would leave unchanged the adaptivity parameter, only affecting the query complexity. This is the reason why the success probability \u03b4 is explicitly mentioned in Definition 3.3."}, {"heading": "4 A Strong Adaptivity Hierarchy", "text": "In this section we prove the adaptivity hierarchy theorem, which shows that, loosely speaking, up to a nearly linear threshold, each additional round of adaptivity can significantly augment the power of testing algorithms.\nTheorem 4.1 (Adaptivity Hierarchy Theorem). Fix any \u03b1 \u2208 (0, 1). There exists a constant \u03b2 \u2208 (0, 1) such that, for every n \u2208 N, the following holds. For every integer 0 \u2264 k \u2264 n\u03b2, there exists a property Pk \u2286 Fn 1+\u03b1 n such that, for any constant \u03b5 \u2208 (0, 1],\n(i) there exists a (k, O\u0303(k))-round-adaptive (one-sided) tester for Pk; yet (ii) any (k \u2212 1, q)-round-adaptive (two-sided) tester for Pk must satisfy q = \u2126(n).\nWe remark that, in fact, the algorithm shown in the first item of Theorem 4.1 also gives an upper bound for the more restricted model of tail adaptivity. Specifically, for every k there also exists an (O(k), O\u0303(k))-tail-adaptive (one-sided) tester for Pk. Since a (k \u2212 1, q)-round-adaptive lower bound implies a (k\u22121, q)-tail-adaptive lower bound (see discussion in Section 3), this implies an adaptivity hierarchy (albeit slightly weaker than in Theorem 4.1) with respect to tail-adaptive testers.\nHereafter we assume, without loss of generality,3 that n is a prime number, and consider Fn, the field of order n. We will consider the following sequence of \u201ck-iterated address\u201d functions (fk)k\u22650 from Fnn to {0, 1}, which will in turn lead to the definition of the properties (Pk)k\u22650 that we use to show the hierarchy theorem. Loosely speaking, fk receives a vector x of n pointers (indices in [n]) and indicates whether when jumping from pointer to pointer k times, starting from an arbitrarily predetermined pointer, we reach a location in which x takes an even value.\nTo formally define the foregoing functions, first consider g : Fnn \u00d7 Fn \u2192 Fn given by g(x, a) = xa+1; that is, g returns the coordinate of x \u2208 Fnn \u201cpointed to\u201d by a \u2208 {0, . . . , n\u2212 1}. Based on this, we define the iterated versions of g, g0, . . . , gn, . . . : F n n \u2192 Fn, as\ng0(x) = g(x, 0) gk(x) = g(x, gk\u22121(x)). (k \u2265 1)\nFinally, we define the k-iterated address function fk : F n n \u2192 Fn by\nfk(x) = 1{gk(x) even} =\n{\n1 if gk(x) even\n0 otherwise.\n(For instance, f0(x) = 1 if and only if x1 is even; and f1(x) = 1 if and only if the coordinate of x pointed to by x1, that is xx1+1, is even.) We proceed to describe the outline of the proof of Theorem 4.1."}, {"heading": "4.1 High-Level Overview", "text": "Broadly speaking, our roadmap for proving Theorem 4.1 consists of two main steps:\n1. We first consider the adaptivity hierarchy question in the setting of randomized decision tree (DT) complexity (see Section 4.2). We can view a randomized DT for computing a function f as a probabilisitic algorithm that is given query access to an input x and is required to output f(x) with high probability. Adapting the definition of round adaptivity (Definition 3.1) in the natural way to decision trees, we will prove the randomized DT analogue of our adaptivity hierarchy theorem, using the foregoing family of address functions (fk)k\u22650. Namely, we prove that for any k \u2265 0 with k = o(n), it holds that (i) fk can be computed by an algorithm making k+1 queries, in k adaptive rounds; but (ii) any algorithm using only k\u2212 1 rounds of adaptivity must make \u2126(n) queries.\n2. We then show a bidirectional connection between adaptivity-bounded randomized DT and property testers, which extends the connection observed by Tell [Tel14]. This allows us to \u201clift\u201d the DT adaptivity hierarchy theorem to property testing. Specifically, we provide two\n3If n is not prime, we choose a prime p such that n \u2264 p \u2264 2p, and use standard padding techniques.\nblackbox reductions between the DT problem of computing function f and property testing for a related property Pf , which preserve both the number of adaptive rounds and (roughly) the number of queries. We remark these reductions strongly rely on high-rate codes that exhibit both strong local testability and relaxed local decodability.\nThe caveat with the above is that to \u201clift\u201d DT lower bounds to testing algorithms via our methodology, we actually need to show lower bounds on a stronger model of DT (this stems from the reductions of the second item, in which we will encode the input via linear codes, requiring the DT algorithm to compute coordinates of this encoding).\nHence, we will actually work in the linear decision tree (LDT) model, wherein the algorithm is allowed to query any linear combination (over Fn) of the coordinates, instead of only querying individual coordinates. (We note that in the case of F2, this corresponds to the parity decision tree model.) That is, we will proceed as follows:\n1. (L)DT hierarchy: show that for any k \u2265 0, the function fk (i) can be computed by an efficient (k,O(k))-round-adaptive (deterministic) DT algorithm, but (ii) does not admit any (k \u2212 1, o(n))-round-adaptive (randomized, two-sided) LDT algorithm; 2. Transference lemmas: Show that for any function f : Fnn \u2192 Fn, there exists a property Cf \u2286 F m(n) n such that, for any k \u2265 0, (a) a (k, q)-round-adaptive testing algorithm for Cf implies a (k, q)-round-adaptive LDT\nalgorithm for f (Lemma 4.10).\n(b) a (k, q)-round-adaptive DT algorithm for f implies a (k, O\u0303(q))-round-adaptive testing algorithm for Cf (Lemma 4.11).\nCombining the items above will directly imply our hierarchy theorem for property testing (Theorem 4.1):\nProof of Theorem 4.1. The upper bound (i) follows immediately from Claim 4.3 and Lemma 4.11, while combining Lemma 4.4 and Lemma 4.10 establishes the lower bound (ii).\nOrganization for the rest of the section. In Section 4.2, we define the decision tree models and complexities that we shall need. Then, in Section 4.3, we prove the adaptivity hierarchy theorem for randomized (linear) decision trees. Finally, in Section 4.4 we prove the transference lemmas that allow us to lift the foregoing hierarchy theorem to the property testing framework."}, {"heading": "4.2 Decision Tree Zoo", "text": "We shall need to extend the definitions of several different types of decision tree algorithms (see [BdW02] for an extensive survey of decision tree complexity) to the setting of bounded adaptivity.\nRecall that a deterministic decision tree is a model of computation for computing a function f : \u2126n \u2192 \u2126. The decision tree is a rooted ordered |\u2126|-ary tree. Each internal vertex of the tree is labeled with a value i \u2208 {1, . . . , n} and the leaves of the tree are labeled with the elements in \u2126. Given an input x \u2208 \u2126n, the decision tree is recursively evaluated by choosing to recurse on the i\u2019th subtree in the j\u2019th level if and only if xj = i. Once a leaf is reached, we output the label of that leaf and halt.\nEquivalently, we can view deterministic decision trees as algorithms that get oracle access to an input x \u2208 \u2126n, then adaptively make queries to x, to the end of computing f(x). (Note that the j\u2019th query corresponds to the j\u2019th layer of the corresponding decision tree, and that the different\nvertices in the j\u2019th layer represent the choices of the next queries, with respect to the answers obtained for previous queries). We define the deterministic decision tree complexity of a function f to be the minimal number of queries a deterministic decision tree algorithm needs to make to compute f in the worst case.4\nTaking the algorithmic perspective, we define k-round-adaptive deterministic decision tree algorithms as algorithms that generate their queries in k rounds, where queries in each round may depend on queries from previous rounds. The extension of the foregoing definition to randomized decision tree algorithms is done in the natural way, by allowing the algorithm to toss random coins and succeed with high probability (say, 2/3) in computing f(x). Finally, we shall also extend the definition to linear decision trees, which are decision trees algorithms wherein each query is a linear combination of the elements of the domain. We remark that linear decision trees can be thought of as generalizing both parity decision trees and algebraic query complexity algorithms [AW08].\nMore accurately, the aforementioned notions are defined below. We provide the definition of the most general model and derive the more restricted models as special cases.\nDefinition 4.2 (Round-Adaptive Decision Tree Algorithms). Let F be a finite field of cardinality n, and let k, q \u2264 n. A (randomized) algorithm D is said to be a (k, q)-round-adaptive (linear) decision tree algorithm for computing a function f : Fn \u2192 F if, granted query access to a string x \u2208 Fn, the following holds. (i) Query Generation: The algorithm proceeds in k + 1 rounds, such that at round \u2113 \u2265 0, it\nproduces a set of (linear) queries Q\u2113 := {L\u2113,1, . . . , L\u2113,|Q\u2113|}, where L\u2113,j \u2208 Fn specifies a linear combination, based on its internal randomness and the answers to the previous sets of queries Q0, . . . , Q\u2113\u22121, and receives the answers \u3008L\u2113,1, x\u3009, . . . , \u3008L\u2113,|Q\u2113|, x\u3009. (ii) Computation: The algorithm computes f(x) with high probability using the answers it received in all k rounds; that is, Pr[Dx = f(x)] \u2265 2/3.\nThe query complexity q of the tester is the total number of (linear) queries made to f , i.e., q = \u2211k\n\u2113=0 |Q\u2113|. The randomized (k, q)-round-adaptive linear decision tree complexity of a function f , denoted R\u2295k (f), is the minimal query complexity for a (k, q)-round-adaptive randomized linear decision tree algorithm that computes f .\nIf for all \u2113 \u2208 [k+1] and j \u2208 [|Q\u2113|] the linear combination L\u2113,j only includes a single element (i.e., L\u2113,j only has a single non-zero entry), we say that D is a randomized (k, q)-round-adaptive decision tree algorithm complexity, and denote its corresponding complexity by Rk(f). If, in addition, the algorithm does not toss any random coins and succeeds with probability 1, we say that D is a deterministic (k, q)-round-adaptive decision tree algorithm complexity, and denote its corresponding complexity by Dk(f)."}, {"heading": "4.3 Decision Tree Hierarchy: Some Things Only Adaptivity Can Address", "text": "We first establish the upper bound part of our adaptivity hierarchy theorem for DT, which follows immediately from the construction.\nClaim 4.3. For every k \u2265 0, there exists a (k, k+1)-round-adaptive (deterministic) DT algorithm which computes fk; that is, Dk(fk) \u2264 k + 1.\n4We remark that this definition corresponds to the depth the of decision tree, and not to the number of vertices or edges in the tree.\nProof. The algorithm is straightforward: on input x \u2208 Fnn, it sequentially queries x1 = g0(x), xg0(x)+1 = g1(x), . . . , xgk\u22121(x)+1 = gk(x); and returns 1 if gk(x) is even, and 0 otherwise. By definition of fk, this always correctly computes the function, is deterministic, and clearly satisfies the definition of a (k, k + 1)-round-adaptive DT algorithm.\nWe proceed to show the lower bound part of our adaptivity hierarchy theorem for DT, which is proven via a reduction from communication complexity.\nLemma 4.4. There exists an absolute constant c > 0 such that the following holds. For every 0 \u2264 k \u2264 c (\nn logn\n)1/3 , there is no (k, o(n/(k2 log n)))-round-adaptive (randomized) LDT algorithm\nwhich computes fk+1; that is, R \u2295 k (fk+1) = \u2126 ( n/(k2 log n) ) .\nProof. We will reduce the computation of fk+1 (in k rounds of adaptivity) to a related k-round twoparty randomized communication complexity problem, the \u201cpointer-following\u201d problem introduced by Papadimitriou and Sipser [PS82], and conclude by invoking the lower bound of Nisan and Wigderson [NW93] on this problem.\nThis communication complexity problem between two computationally unbounded players, Alice and Bob, is defined as follows. Let VA and VB be two disjoint sets of cardinality n/2, and let v0 \u2208 VA be a fixed element known to both players. The input is a pair of functions (\u03c7A, \u03c7B), where \u03c7A : VA \u2192 VB and \u03c7B : VB \u2192 VA. Alice and Bob are given \u03c7A and \u03c7B respectively, as well as a common random string, and their goal is to compute \u03c0k(\u03c7A, \u03c7B) := \u03c7\n(k)(v0) with high probability, where \u03c7(\u2113) is the \u2113-iterate of the function \u03c7:\n\u03c7 : VA \u222a VB \u2192 VA \u222a VB\nv 7\u2192 { \u03c7A(v) v \u2208 VA \u03c7B(v) v \u2208 VB.\n(In other terms, one can see the communication problem as Alice and Bob sharing the edges of a bipartite directed graph where each node has out-degree exactly one, and the goal is to find at which vertex the path of length k starting at a prespecified vertex v0, on Alice\u2019s side, ends.)\nWe will rely on the following lower bound on the k-round, randomized (public-coin) version of this problem.\nTheorem 4.5 ([NW93], rephrased). Any k-round randomized communication protocol for the \u201cpointer-following\u201d problem, in which Bob sends the first message, must have total communication complexity \u2126 (\nn k2\n\u2212 k log n )\n, even to only compute a single bit of \u03c0k(\u03c7A, \u03c7B) with probability at\nleast 2/3.\nNote that as long as k \u226a (\nn logn\n)1/3 , this lower bound is \u2126 (\nn k2\n)\n. We remark that the fact that\nthe lower bound still holds even when only a single bit of the answer is to be computed will be crucial for us, as our goal is to reduce the communication complexity problem of \u201cpointer-following\u201d to computing the Boolean function fk+1 in the randomized decision tree model.\nLet A be any (k, q)-round-adaptive (randomized) LDT algorithm computing fk+1. Writing VA = {v0, . . . , vn\n2 \u22121} and VB = {u0, . . . , un 2 \u22121}, fix a bijection between V := VA\u222aVB (of size n) and\nFn mapping v0 to 1, so that we identify V with Fn. On input (\u03c7A, \u03c7B), Alice and Bob implicitly define the element x \u2208 Fnn by x1 = \u03c7A(v0), x2 = \u03c7A(v1), . . . , xn2 = \u03c7A(vn2 \u22121) and xn2 +1 = \u03c7B(u0),\nxn 2 +2 = \u03c7A(u1), . . . , xn = \u03c7A(un 2 \u22121). From this, we get that \u03c0k+2(\u03c7A, \u03c7B) = gk+1(x), recalling that gk(x) = g(x, gk\u22121(x)) is recursively defined for k \u2265 1, and g0(x) = x1. Hence deciding whether \u03c0k+2(\u03c7A, \u03c7B) is even is exactly equivalent to computing fk+1(x).\nAlice and Bob can then simulate the execution of A as follows. Without loss of generality, assume it is Alice\u2019s turn to speak. To answer a query of the form \u03c6S(x) = \u2211\ni\u2208S xi, she computes \u2211\ni\u2208S\u2229VA xi and sends it to Bob; on his side, Bob computes \u2211\ni\u2208S\u2229VB xi, and receiving Alice\u2019s message can then recover the value \u03c6S(x) and feed it to the algorithm. (In the next round, when sending his side of the (new) queries to Alice, Bob will also send this value \u03c6S(x), to make sure that both sides know the answers to all queries so far.) Since all queries of a given adaptive round of A can be prepared and sent in parallel (costing O(log n) bits of communication per query), this simulation can be performed in k+1 rounds (as many as A takes) with communication complexity O(q log). At the end, whichever of Alice and Bob received the latest message holds the answer (to \u201cis \u03c0k+1(\u03c7A, \u03c7B) an even node?\u201d), which by assumption on A is correct with probability at least 2/3. Alice and Bob then use an extra round of communication to broadcast the answer to the other party, bringing the total number of rounds to k + 2.\nBut by Theorem 4.5, computing this bit of \u03c0k+2(\u03c7A, \u03c7B) with only k + 2 rounds of com-\nmunication (Bob speaking first) requires \u2126 (\nn k2\n)\nbits of communication, and so we must have\nq = \u2126 (\nn k2 logn\n)\n."}, {"heading": "4.4 Adaptivity Bounded Testers and Decision Trees: There and Back Again", "text": "In this section we show how to reduce problems in the adaptivity bounded property testing model to problems in the adaptivity bounded (linear) decision tree model, and vice versa. We begin in Section 4.4.1, by presenting the required preliminaries regarding error-correction codes. Then, in Section 4.4.2, we prove the \u201ctransference lemmas\u201d between these models."}, {"heading": "4.4.1 Preliminaries: Locally Testable and Decodable Codes", "text": "Let k, n \u2208 N. A code over alphabet \u03a3 with distance d is a function C : \u03a3k \u2192 \u03a3n that maps messages to codewords such that the distance between any two codewords is at least d = d(n). If d = \u2126(n), C is said to have linear distance. If \u03a3 = {0, 1}, we say that C is a binary code. If C is a linear map, we say that it is a linear code. The relative distance of C, denoted by \u03b4(C), is d/n, and its rate is k/n. When it is clear from the context, we shall sometime abuse notation and refer to the code C as the set of all codewords {C(x)}x\u2208\u03a3k . Following the discussion in the introduction, we define locally testable codes and locally decodable codes as follows.\nDefinition 4.6 (Locally Testable Codes). A code C : \u03a3k \u2192 \u03a3n is a locally testable code (LTC) if there exists a probabilistic algorithm (tester) T that makes O(1) queries to a purported codeword w \u2208 \u03a3n and satisfies:\n1. Completeness: For any codeword w of C it holds that PrT [T w = 1] \u2265 2/3. 2. Strong Soundness: For all w \u2208 \u03a3n,\nPr T [Tw = 0] \u2265 poly (dist(w,C)).\nDefinition 4.7 (Locally Decodable Codes). A code C : \u03a3k \u2192 \u03a3n is a locally decodable code (LDC) if there exists a constant \u03b4radius \u2208 (0, \u03b4(C)/2) and a probabilistic algorithm (decoder) D that, given\noracle access to w \u2208 \u03a3n and direct access to index i \u2208 [k], satisfies the following condition: For any i \u2208 [k] and w \u2208 \u03a3n that is \u03b4radius-close to a codeword C(x) it holds that Pr[Dw(i) = xi] \u2265 2/3. The query complexity of a LDC is the number of queries made by its decoder.\nWe shall also need the notion of relaxed-LDCs (introduced in [BGH+06]). Similarly to LDCs, these codes have decoders that make few queries to an input in attempt to decode a given location in the message. However, unlike LDCs, the relaxed decoders are allowed to output a special symbol that indicates that the decoder detected a corruption in the codeword and is unable to decode this location. Note that the decoder must still avoid errors (with high probability).5\nDefinition 4.8 (Relaxed-LDC). A code C : \u03a3k \u2192 \u03a3n is a relaxed-LDC if there exists a constant \u03b4radius \u2208 (0, \u03b4(C)/2) such that the following holds.\n1. (Perfect) Completeness: For any i \u2208 [k] and x \u2208 \u03a3k it holds that DC(x)(i) = xi. 2. Relaxed Soundness: For any i \u2208 [k] and any w \u2208 \u03a3n that is \u03b4radius-close to a (unique) codeword\nC(x), it holds that Pr[Dw(i) \u2208 {xi,\u22a5}] \u2265 2/3.\nThere are a couple of efficient constructions of codes that are both relaxed-LDCs and LTCs (see [BGH+06, GGK15]). We shall need the construction in [GGK15], which has the best parameters for our setting.6\nTheorem 4.9 (e.g., [GGK15, Theorem 1.1]). For every k \u2208 N, \u03b1 > 0, and finite field F there exists an F-linear code C : Fk \u2192 Fk1+\u03b1 with linear distance, which is both a relaxed-LDC and a (one-sided error) LTC with query complexity poly(1/\u03b5); furthermore, both testing and (relaxed) decoding procedures are non-adaptive."}, {"heading": "4.4.2 Transference Lemmas", "text": "Fix any \u03b1 > 0. Let C : Fnn \u2192 Fmn be a code with constant relative distance \u03b4(C) > 0, with the following properties:\n\u2022 linearity: for all i \u2208 [m], there exists a set Si \u2286 [n] such that C(x)i = \u2211 j\u2208Si xi for all x \u2208 Fnn; \u2022 rate: m \u2264 n1+\u03b1; \u2022 testability: C is a strong-LTC with one-sided error and non-adaptive tester; \u2022 decodability: C is a relaxed-LDC.\nWe will rely on Theorem 4.9 for the existence of such codes. Before delving into the details, we briefly explain the reason for each of the points above. The linearity will be crucial to reduce to and from the LDT model: indeed, any coordinate of a codeword corresponds to a fixed linear combination of the coordinates of the message, which corresponds to a single LDT query on that particular linear combination. The rate bound is required since our lower bounds are in terms of\n5The full definition of relaxed-LDCs, as defined in [BGH+06] includes an additional condition on the success rate of the decoder. Namely, for every w \u2208 {0, 1}n that is \u03b4radius-close to a codeword C(x), and for at least a \u03c1 fraction of the indices i \u2208 [k], with probability at least 2/3 the decoder D outputs the i\u2019th bit of x. That is, there exists a set Iw \u2286 [k] of size at least \u03c1k such that for every i \u2208 Iw it holds that Pr [D\nw(i) = xi] \u2265 2/3. We omit this condition since it is irrelevant to our application, and remark that every relaxed-LDC that satisfies the first two conditions can also be modified to satisfy the third conditions (see [BGH+06, Lemmas 4.9 and 4.10]).\n6Specifically, the codes in [GGK15] are meaningful for every value of the proximity parameter, whereas the codes in [BGH+06] require \u03b5 > 1/ polylog(k).\nthe dimension n and upper bounds in terms of the block-lengh m. Ideally, we would like m = O(n), to have a direct correspondence between the LDT and the property testing query complexities; however, this nearly-linear rate is the best known achievable for constant-query LTCs and relaxedLDCs [GGK15]. The LTC property will be useful to us in the reduction from property testing to DT query complexity (where we will need to first check that our input is close to a codeword, in view of decoding the closest message during the reduction), where the strong testability (i.e., rejection with probability proportional to the distance from a valid codeword) will allow us do deal with arbitrarily small values of the proximity parameter. Similarly, we will rely on the (relaxed) LDC property in that same reduction, in order to obtain individual coordinates of the message, given query access to an input close to a codeword. We proceed to show the framework for reducing property testing to decision tree complexity and vice-versa. For a fixed function f : Fnn \u2192 {0, 1}, consider the subset f\u22121(1) \u2286 Fnn; and define the sets of codewords C := C(Fnn) \u2286 Fmn , Cf := C(f\u22121(1)) = { C(x) : x \u2208 Fnn, f(x) = 1 } \u2286 C.\nConsider now testing the property Cf : we will reduce the LDT computation of f to the testing of Cf . Specifically, we prove the following.\nLemma 4.10 (LDT PT Reduction Lemma). Fix any f : Fnn \u2192 {0, 1}. If there exists an (k, q)round-adaptive tester for Cf , then there is an (k, q)-round-adaptive LDT algorithm for f .\nProof. Suppose there exists a (k, q)-round-adaptive tester T for Cf . On input x \u2208 Fnn, we emulate the invocation of T , with respect to proximity parameter \u03b5 = \u03b4(C), on the encoded input y := C(x) \u2208 Fmn and output 1 if and only if T returns accept. To see why this is correct, observe that by definition, if f(x) = 1 then y \u2208 Cf . However, if f(x) = 0, then for any y\u2032 \u2208 Cf such that y\u2032 = C(x) we must have dist(y, y\u2032) > \u03b5, by the distance of our code.\nIt remains to show that this simulation can be achieved efficiently, as claimed. To do so, we will rely on the fact that C is a linear code: whenever T queries yi, we can compute the set Si \u2286 [n] (which only depends on C, and not on x), and perform the LDT query \u2211\nj\u2208Si xj. The simulation clearly preserves the number of adaptive rounds as well, concluding the proof.\nIn our next lemma, we give a partial converse relating property testing and decision tree complexity, with some logarithmic overhead in the resulting query complexity.\nLemma 4.11 (PT DT Reduction Lemma). Fix any f : Fnn \u2192 {0, 1}. If there exists an (k, q)round-adaptive (randomized) DT algorithm for f , then there is a (k,O(q log q)+ poly(1/\u03b5))-roundadaptive tester for Cf . (Moreover, if the DT algorithm is always correct, then this tester is onesided.)\nProof. Fix k \u2265 0, and suppose there exists such a (k, q)-round-adaptive DT algorithm A for f . On input y \u2208 Fmn and proximity parameter \u03b5 \u2208 (0, 1], we would like to decode y to a message x \u2208 Fnn and invoke the algorithm on x to determine if f(x) = 1; more precisely, we wish to invoke the DT algorithm while simulating each query to x by locally decoding y using O(1) queries. The issue, however, is that the success of the local decodable is only guaranteed for inputs that are sufficiently close to a valid codeword, and we have no such guarantee on y a priori. However, recalling that C is a strong-LTC, we can handle this as follows. Letting \u03b4radius > 0 be the decodability radius of the relaxed-LDC C, we set \u03b4\u2217 := min(\u03b4radius, \u03b5).\n(1) Run independently O(poly(1/\u03b4\u2217)) times the local tester for the strong-LTC C on y, and output reject if any of these rejected. Since every invocation of the local tester makes O(1)\nqueries to y, this has query complexity O(poly(1/\u03b4\u2217)) = O(poly(1/\u03b5)); and if dist(y, C) > \u03b4\u2217 then this step outputs reject with probability at least 9/10. (2) Invoke A on the message x := argmin { dist(C(x), y) : x \u2208 Fnn }, answering each query xi by calling the local decoder for the relaxed-LDC C. This is done so that the decoder is correct with probability at least 1/(10q), by standard repetition (taking the plurality value); with the subtlety that we output reject immediately whenever the decoder returns \u22a5. Since each query can be simulated by O(log(q)) queries (repeating the O(1) queries of the decoder O(log(1/q)) times), this step has query complexity O(q log q); and at the end, we output accept if, and only if, A returns the value 1 for f(x).\nImportantly, Step (1) can be run in parallel to Step (2), and in particular can be executed during the first \u201cbatch\u201d of queries A makes. This guarantees that the whole simulation above uses the same number of adaptive rounds as A, as claimed. It remains to argue correctness.\nCompleteness. Assume y \u2208 Cf . In particular, y is a codeword of C, and the (one-sided) local tester returns accept with probability one in (1). Then, since by definition there is a unique x \u2208 Fnn such that C(x) = y, the local decoder of Step (2) will correctly output the correct answer for each query with probability 1, and therefore A will correctly output f(x) with probability 2/3 \u2013 so that the tester returns accept with probability at least 2/3 overall. (Moreover, if the DT algorithm A always correctly compute f , then the tester returns accept with probability one.)\nSoundness. Assume dist(y, Cf ) > \u03b5. If dist(y, C) > \u03b4\u2217, then the local tester returns reject with probability at least 9/10 in Step (1). Therefore, we can continue assuming that dist(y, C) \u2264 \u03b4\u2217, which satisfies the precondition of the relaxed-LDC decoder in Step (2). By a union bound over all q queries, with probability at least 9/10 we have that the decodings performed in Step (2) are all correct; in which case we answer the queries of the algorithm according to x := argmin { dist(C(x), y) : x \u2208 Fnn } (or possibly answered by \u22a5, in which case the tester immediately outputs reject and we are done). Since dist(y,C(x)) \u2264 \u03b4\u2217 \u2264 \u03b5, we must have C(x) 6\u2208 Cf , which implies that A correctly returns f(x) = 0 with probability at least 2/3, in which case the tester outputs reject. Overall, this happens with probability at least 9/10 \u00b7 9/10 \u00b7 2/3 = 27/50.\nThus, in both cases the tester is correct with probability at least 27/50; repeating a constant number of times (as explained in Remark 3.2) and taking the majority vote allows us to amplify the probability of success to 2/3."}, {"heading": "5 An Adaptivity Hierarchy with respect to a Natural Property", "text": "In this section we show a natural property of graphs for which, broadly speaking, more adaptivity implies more power. More specifically, we prove the following adaptivity hierarchy theorem with respect to the property of k-cycle freeness in the bounded-degree graph model (see definitions in Section 5.1).\nTheorem 5.1. Let k \u2208 N be a constant. Then, (i) there exists a (k,O(1/\u03b5))-round-adaptive (one-sided) tester for (2k + 1)-cycle freeness in the\nbounded-degree graph model; yet\n(ii) any (k\u22121, q)-round-adaptive (two-sided) tester for (2k+1)-cycle freeness in the bounded-degree\ngraph model must satisfy q = \u2126( \u221a n).\nWe stress that although Theorem 4.1 establishes an adaptivity hierarchy with stronger separations, the merit of Theorem 5.1 is in showing that an adaptivity hierarchy also holds for a natural well-studied property. We further observe that the choice of the bounded-degree graph model is not insignificant: one cannot hope to establish such a striking gap in other settings such as the dense graph model or in the Boolean function testing setting. Indeed, as discussed in Section 1.2 it is wellknown that in these two models, any adaptive tester can be made (fully) non-adaptive at the price of only a quadratic and exponential blowup in the query complexity, respectively(see [AFKS00, GT03] for the former; the latter is folklore). We remark that in Section 6.1 we discuss emulating testers with k rounds of adaptivity by testers with k\u2032 < k rounds."}, {"heading": "5.1 Cycle Freeness in the Bounded Degree Graph Model", "text": "In the subsection we provide the necessary definitions and establish a basic upper bound on the complexity of k-adaptive testing of cycle freeness in the bounded degree graph model. We begin with a definition of the model.\nLet G = (V,E) be a graph with constant degree bound d < |V |, represented by its adjacency list; that is, represented by a function g : V \u00d7 d \u2192 V such that g(v, i) = u \u2208 V if u is the ith neighbor of v and g(v, i) = 0 if v has less than i neighbors. A bounded degree graph property P is a subset of graphs (represented by their adjacency list) that is closed under isomorphism; that is, for every permutation \u03c0 it holds that G \u2208 P if and only if G \u2208 \u03c0(G). The distance of graph G from property P is the minimal fraction of entries in g one has to change to reach an element of P.\nWe extend the definition of functional round-adaptive testing algorithms to the bounded degree graph model in the natural way.\nDefinition 5.2 (Round-Adaptive Testing in the Bounded Degree Graph Model). Let G = (V,E) be a graph with constant degree bound d < |V |, represented by its adjacency list g : V \u00d7 d \u2192 V , and let k, q \u2264 n. A randomized algorithm is said to be a (k, q)-round-adaptive tester for a (bounded degree) graph property P, if, on proximity parameter \u03b5 \u2208 (0, 1] and granted query access to g, the following holds.\n(i) Query Generation: The algorithm proceeds in k + 1 rounds, such that at round \u2113 \u2265 0, it produces a set of queries Q\u2113 := {x(\u2113),1, . . . , x(\u2113),|Q\u2113|} \u2286 \u2126 (possibly empty), based on its own internal randomness and the answers to the previous sets of queries Q0, . . . , Q\u2113\u22121, and receives f(Q\u2113) = {g(x(\u2113),1), . . . , g(x(\u2113),|Q\u2113|)}; (ii) Completeness: If G \u2208 P, then the algorithm outputs accept with probability at least 2/3; (iii) Soundness: If dist(G,P) > \u03b5, then the algorithm outputs reject with probability at least 2/3. The query complexity q of the tester is the total number of queries made to f , i.e., q =\n\u2211k \u2113=0 |Q\u2113|.\nIf the algorithm returns accept with probability one whenever f \u2208 P, it is said to have one-sided error (otherwise, it has two-sided error). As before, we will sometimes refer to a tester with respect to proximity parameter \u03b5 as an \u03b5-tester.\nNext, we define the (bounded degree) graph property of k-cycle freeness.\nDefinition 5.3 (Cycle Freeness). Let k \u2208 N. A graph G = (V,E) is said to be k-cycle free if it does not contain any cycle of length less or equal to k; that is, if for every t \u2264 k and v1, . . . , vt \u2208 V either (vt, v1) 6\u2208 E or there exists i \u2208 [t\u2212 1] such that (vi, vi+1) 6\u2208 E.\nFinally, we make the following observation, which roughly speaking implies that when surpassing a certain threshold of round adaptivity, testing cycle freeness in the bounded degree graph model becomes \u201ceasy.\u201d7\nObservation 5.4. For every k \u2208 N there exists a (k, q)-round-adaptive testing algorithm for (2k + 1)-cycle freeness and (2k + 2)-cycle freeness in the bounded-degree graph model with query complexity q = O(dk+1/\u03b5).\nProof. The algorithm explores the graph in the most natural way: starting from O(1/\u03b5) \u201csource vertices\u201d selected uniformly at random, it adaptively explore their neighborhoods by querying at each round the neighbors of the previously reached vertices, in a breadth-first-search fashion. If any (2k + 1)-cycle (resp. (2k + 2)-cycle) is detected, the algorithm rejects, and accepts otherwise. (Clearly, this tester is one-sided.) It is easy to see that if any of the source vertices belongs to a (2k + 1)- or (2k + 2)-cycle, then this bounded-depth BFS will detect it; thus, we only need to argue that if the graph is \u03b5-far from cycle freeness, with constant probability, one of the source vertices will participate in such a cycle. But this is the case, as any such graph must have at least \u03b5n vertices participating in a cycle (indeed, otherwise one could \u201ccorrect\u201d the graph by removing less than \u03b5dn vertices, contradicting the distance).\nFinally, for each source vertex, after k rounds of adaptivity the number of nodes visited is at most O(dk+1), hence the claimed query complexity."}, {"heading": "5.2 Lower Bounds for Round-Adaptive Testers", "text": "In this subsection, we prove the following lemma, which roughly speaking shows that testing (2k+3)cycle freeness is hard for k-round-adaptive testing algorithms.\nLemma 5.5. Let k \u2208 N be constant. Then, any (k, q)-round-adaptive testing algorithm for (2k+3)cycle freeness in the bounded-degree graph model must satisfy q = \u2126( \u221a n).\nIn stark contrast, recall that Observation 5.4 shows that testing (2k + 2)-cycle freeness is easy for k-round-adaptive testing algorithms. Indeed, the proof of Theorem 5.1 follows by combining Observation 5.4 and Lemma 5.5 together.\nProof of Lemma 5.5. We will show a distribution of (2k + 3)-cycle free graphs, denoted Y, and a distribution of graphs that are \u201cfar\u201d from being (2k + 3)-cycle free, denoted N , and prove that no (k, q)-round-adaptive testing algorithm can distinguish, with high probability, between Y and N . Loosely speaking, Y consists of all graphs whose vertices are covered via disjoint (2k + 4)-cycles, and N consists of all graphs whose vertices are covered via disjoint (2k + 3)-cycles.\nMore accurately, denote by Pt,n,d the subset of n-node graphs with maximum degree at most d that are t-cycle-free. Let \u03a3t,s be the 2-regular graph on st vertices made of s disjoint t-cycles, namely (v1, . . . , vt), (vt+1, . . . , v2t), (v(s\u22121)t+1, . . . , vst). Denote also by Isr the independent set on r vertices. For two graphs G,G\u2032 on respectively m and m\u2032 vertices and with e and e\u2032 edges, we write G \u2294G\u2032 for the graph on m+m\u2032 vertices and with e+ e\u2032 edges obtained by concatenating disjoint copies of G,G\u2032.\nFor k = O(1), we let \u2113 := \u230a\nn (2k+4)\n\u230b , \u2113\u2032 := \u230a\nn (2k+3)\n\u230b\n, and define the two distributions over n-node\ngraphs Y and N as follows. 7This is a specific case of a more general algorithm for testing subgraph freeness; see e.g. [Gol17, Section 9.2.1].\n\u2022 Y is the uniform distribution over all isomorphic copies of Gyesk := \u03a3(2k+4),\u2113 \u2294 Isn\u2212(2k+4)\u2113; \u2022 N is the uniform distribution over all isomorphic copies of Gnok := \u03a3(2k+3),\u2113\u2032 \u2294 Isn\u2212(2k+3)\u2113\u2032 .\nThe next claim establishes that indeed Y consists of yes-instances, whereas N consists of noinstances.\nClaim 5.6. Y is supported on P(2k+3),n,d, while every graph in the support of N is \u2126(1)-far from P(2k+3),n,d.\nProof. The first part is obvious, as the only cycles in Gyesk are (2k+4)-cycles. As for the second, it immediately follows from observing that Gnok contains \u2113 \u2032 disjoint (2k + 3)-cycles, and thus at least \u2113\u2032 edges have to be removed to make it (2k + 3)-cycle free. Thus, dist (\nGnok ,P(2k+3),n,d ) \u2265 \u2113\u2032dn/2 = \u2126 (\n1 dk\n)\n= \u2126d(1).\nLet T be a deterministic testing algorithm with k rounds of adaptivity and query complexity q\u2032 = o( \u221a n). The following lemma concludes the proof of Lemma 5.5 by showing that T cannot distinguish, with high probability, between graphs in Y and graphs in N . Denote T \u2019s (disjoint) query sets, per round, by Q0, . . . , Qk \u2286 V , where a query is a vertex v. Denote the corresponding sets of answers by A0, . . . , Ak, where the answer to a query v consists of the labels of all neighbors of v (i.e., either two or zero vertices). Since k = O(1), without loss of generality, we can assume (by padding) that all query sets have the same size q := |Qi| = q \u2032 k+1 = \u0398(q \u2032) for every i \u2208 {0, . . . , k}. Moreover, we can also assume that no vertex is queried twice, i.e. that all Qi\u2019s are disjoint. Lemma 5.7. \u2223 \u2223 \u2223PrG\u223cY [ T G accepts ] \u2212 PrG\u223cN [ T G accepts ]\u2223 \u2223 \u2223 \u2264 110 .\nProof. For j \u2208 {0, . . . , k}, define by Yj and Nj the distribution of (A0, . . . , Aj) when G \u223c Y and when G \u223c N , respectively. We shall prove that dTV(Yk, Nk) \u2264 110 , which by the data processing inequality will imply the claim of Lemma 5.7.\nThe high-level idea is that in each round, the tester can either query \u201cfresh\u201d vertices, of which it has no prior information, or query the boundaries (i.e., the direct neighbors) of previously queried vertices. Then, loosely speaking we can argue that, on the one hand, if the total number of queries is o( \u221a n), then both for graphs in Y and N all queries of \u201cfresh\u201d vertices (obtained during all rounds) with high probability would only fall into previously unattained disjoint cycles, in which case the answer would be a uniform sequence of \u201cfresh\u201d labels. On the other hand, the local view obtained by querying the boundary, using at most k rounds of adaptive queries, of each vertex previously obtained via a \u201cfresh\u201d query (which by the above lies in a cycle wherein the tester has no information of the labels of the other vertices participating in this cycle) is isomorphic to the tail graph over fresh labels, both for instances taken from Y and N (that is, we do not have enough adaptive queries to observe a full cycle). The foregoing intuition is formalized below.\nFor i \u2208 {0, . . . , k}, define\nSfi := Qi \\ \u222ai\u22121j=0Aj Sbi := Qi \u2229 \u222ai\u22121j=0Aj\nto be, respectively, the set of \u201centirely fresh\u201d nodes queried at round i (that is, nodes that are not neighbors of any previously queried node), and the set of \u201cboundary nodes\u201d (which are the not-yet-queried nodes neighbors of a previously queried node).\nFirst, we bound the probability that any of the q\u2032 queries made \u201chits\u201d the set of disconnected nodes:\nClaim 5.8. Let E1(G) denote the event that T queries an isolated vertex of G, that is E1(G) := {\u2203i, v s.t. v \u2208 Qi, deg(v) = 0}. Then PrG\u223cY [E1(G) ] ,PrG\u223cN [E1(G) ] = o(1).\nProof. This follows by induction: at step i, conditioned on no isolated node having been queried yet, the algorithm has degree information about \u2223 \u2223\n\u2223\u222ai\u22121j=0Qj \u22c3\u222ai\u22121j=0Aj\n\u2223 \u2223\n\u2223 \u2264 \u2211i\u22121j=0 |Qj|+ \u2211i\u22121 j=0 |Aj | \u2264 3q \u00b7i nodes, so there remain at least n\u2212 3kq nodes on which the algorithm has no degree information at all. Among these, there are n\u2212 (2k + 4)\u2113 \u2264 (2k + 4) (or n\u2212 (2k + 3)\u2113\u2032 \u2264 (2k + 3), in the no-case) isolated nodes. By symmetry, this means that in the new batch of q queries, the algorithm will query one of these isolated nodes with probability at most 1\u2212 (\n1\u2212 (2k+4)n\u22123kq\u2212(2k+4) )q = 1\u2212 ( 1\u2212 O(1)n )q =\nO ( q n )\n= o(1). Therefore, overall there will be an isolated node queried with probability at most k \u00b7 o(1) = o(1).\nNext, we argue that at each step, with overwhelming probability all the \u201cfresh nodes\u201d queried fall in distinct cycles, which have not been attained yet.\nClaim 5.9. Let E2(G) denote the event that at some round i, one of the queries in S f i belongs to the same cycle (either a (2k+4)- or a (2k+3)-cycle, depending on whether the graph is drawn from Y or N ) as one of the previous queries \u22c3i\u22121j=0Qj. Then PrG\u223cY [E2(G) ] ,PrG\u223cN [E2(G) ] = o(1).\nProof. We will show that PrG\u223cY [E2(G) ] = o(1); the no-case is similar. For i \u2208 {1, . . . , k}, let E\n(i) 2 (G) denote the event that at some round i, one of the queries in S f i belongs to the same cycle\nas a previous query, so that E2(G) = \u22c3k i=1 E (i) 2 (G).\nNote that since |\u22c3i\u22121j=0Qj | = iq, we have | \u22c3i\u22121 j=0Aj | \u2264 2iq (and the number of distinct cycles reached is at most |\u22c3i\u22121j=0Qj |). Therefore, at round i each of the at most q distinct queries in Sfi falls independently in a previously visited cycle with probability upper bounded by\niq \u00b7 (2k + 4) n\u2212 3iq \u2264 kq \u00b7 (2k + 4) n\u2212 3kq \u2264 2k2q n\nrecalling that q = o(n) and k = O(1). A union bound over all at most q queries of Sfi , and then over the k rounds then shows that PrG\u223cY [E2(G) ] \u2264 2k 3q2 n = o(1) (since q = o( \u221a n)).\nTo conclude the proof, note that by the above, with probability 1 \u2212 o(1) neither E1 nor E2 occurs; that is, none of the isolated vertices was queried, and all the \u201cfresh\u201d queries (during all rounds ) fell in previously unattained distinct cycles. In this case, at each round of adaptivity the algorithm can at most discover two new nodes out of every cycle it reached before (by including the one or two end nodes of the current \u201cdiscovered portion\u201d into Sbi ). Therefore, on any cycle ever reached, the (k, q)-round-adaptive testing algorithm can observe at most 2k+2 nodes (which then form a consecutive path). We show that this implies that the algorithm cannot distinguish between a no-instance and a yes-instance, as loosely speaking, in both cases its local view is of a tail graph over uniformly distributed fresh labels, and so it is unable to determine whether it belongs to a cycle of length 2k + 3 or 2k + 4.\nTo make the argument more precise, we will actually show a stronger statement; namely, we show that, conditioning on neither E1 nor E2 occuring, a simulator with no access to the graph\ncan answer the queries of the testing algorithm in a way that is indistinguishable from the tuple of answers obtained from querying a graph distributed according to either Y or N . This simulator operates as follows: at round i,\n1. Order (arbitrarily) all the nodes of Qi: v1, . . . , vq, and initialize the set of available-to-sample\nnodes U \u2190 V \\ ( Qi \u222a \u22c3i\u22121 j=0Qj \u222a \u22c3i\u22121 j=0Aj ) .\n2. Do sequentially the following, for s = 1 . . . q:\n\u2022 if vs \u2208 Sfi (fresh node: no previous neighbors known), pick uniformly at random two distinct nodes u, u\u2032 in Us and return them as answers (i.e., declare them as neighbors of vs); \u2022 otherwise, vs \u2208 Sbi (boundary node: exactly one already known neighbor, call it u): pick uniformly at random one other node u\u2032 in Us, and return (u, u\u2032) as answers;\n\u2022 update U by removing u, u\u2032: U \u2190 U \\ {u, u\u2032} It is straightforward to verify that, since we conditioned on E1 and E2, this simulates exactly the same distribution over nodes (over the choice of G); since this is the same both for Y and N , we get that dTV ( (Yk | E1 \u222a E2)), (Nk | E1 \u222a E2)) ) = 0, which combined with Claim 5.8 and Claim 5.9 finishes the proof.\nThis concludes the proof of Lemma 5.5."}, {"heading": "6 Some Miscellaneous Remarks", "text": ""}, {"heading": "6.1 On Simulating k Rounds With Fewer", "text": "As mentioned in the beginning of Section 5, in the Boolean setting any adaptive property testing algorithm can be simulated non-adaptively with only an exponential blowup in the query complexity. Phrased differently, this implies that any property of Boolean functions which admits a (k, q)-round-adaptive tester also has a (0, 2q \u2212 1)-round-adaptive tester.\nThis begs the following more general question: let P = \u22c3n Pn be a property of Boolean functions, such that there exists a (k, q)-round-adaptive tester for P. For \u2113 < k, what upper bound can we obtain on the query complexity q\u2032 of the best (\u2113, q\u2032)-round-adaptive tester for P?\nDenoting by q\u2113 this query complexity, the above discussion immediately implies:\nFact 6.1. For any 0 \u2264 \u2113 \u2264 k, one has qk \u2264 q\u2113 \u2264 2qk \u2212 1. In what follows, we provide a example of a more fine-grained version of this fact, in the case when \u2113 = k \u2212 1 (that is, one wishes to reduce the number of rounds of adaptivity by one).\nProposition 6.2. For any 0 < k, one has qk \u2264 qk\u22121 \u2264 qk(1 + 2 qk k ).\nProof. Let Tk be a (k, q)-round-adaptive tester for P, which can be viewed as a distribution over deterministic algorithms. Thus, it is sufficient to explain how to simulate any deterministic algorithm with k rounds of adaptivity by one with \u2113 rounds. Fix such a (k, q)-round deterministic algorithm: this can be seen equivalently as a depth-(k+1) binary tree, where each internal node v is labeled by the set of queries Qv made at that stage, and the leaves are either accept or reject. By assumption, we have that on each path (v0, v1, . . . , vk, v \u2217) from the root to a leaf, \u2211k j=0 \u2223 \u2223 \u2223Qvj \u2223 \u2223\n\u2223 \u2264 q; moreover, one can assume without loss of generality that this is an equality.\nThe idea is then to contract, on any path, two consecutive nodes as follows: instead of querying Qvj , receiving the answers, and then querying the (adaptively chosen) set Qvj+1 , one can idea query simultaneously Qvj and the union of all possible sets Qvj+1 : since the latter depends only on the previous queries, and the only unknown answers are those to the queries in Qvj , there are at most 2|Qvj | possibilities for Qvj+1 . As clearly no matter what Qvj+1 would be, its size is at most q, the set Q\u2032i = Qvj \u222a \u22c3\nQ : possible Qvj+1 Q queried has size at most\n\u2223 \u2223 \u2223Qvj \u2223 \u2223 \u2223 + q2|Qvj |. Thus, by contradicting the two rounds i and i+1, one incurs an additional number of queries upper bounded by q2|Qvj | \u2212 \u2223 \u2223\n\u2223Qvj+1\n\u2223 \u2223 \u2223 \u2264 q2|Qvj |\nBy an averaging argument, since on every such path we have \u2211k\nj=0\n\u2223 \u2223 \u2223Qvj \u2223 \u2223 \u2223 = q, there must exist\nan index j\u2217 such that \u2223 \u2223 \u2223Qvj\u2217 \u2223 \u2223 \u2223 \u2264 qk+1 . Since we would like to \u201ccontract\u201d rounds j\u2217 and j\u2217 + 1 into a single round, we additionally want to ensure j\u2217 < k. But similarly, as\n\u2211k\u22121 j=0\n\u2223 \u2223 \u2223Qvj \u2223 \u2223\n\u2223 \u2264 q there exists i\u2217 such that \u2223\n\u2223Qvi\u2217 \u2223 \u2223 \u2264 qk . We then get an index i\u2217 < k (which depends on the path taken down the tree) to which we can apply the above transformation. That is, whenever the deterministic algorithm is executed it will reach an index i\u2217 < k where it should make \u2223\n\u2223Qvi\u2217 \u2223 \u2223 \u2264 qk queries. At that point, it makes instead these queries, along with all queries this should have triggered at the next round, and thus is able to skip round i\u2217+1 at the price of an additional (at most) q2 q k queries.\nRemark 6.3. Note that in the above proof, while one can assume without loss of generality that the algorithm always makes exactly q queries, one cannot however assume that for any two such paths (v0, v1, . . . , vk, v \u2217) and (u0, u1, . . . , uk, u\u2217), \u2223 \u2223 \u2223Qvj \u2223 \u2223 \u2223 = \u2223 \u2223 \u2223Quj \u2223 \u2223\n\u2223 for all 0 \u2264 j \u2264 k. That is, the number of queries made in round j may not be the same depending on the path followed down by the algorithm, but instead depend adaptively on the previous queries made.\nThe above remark shows the difficulty in extending the proof of Proposition 6.2 further than a single round. If one is willing to assume that the number of queries at each round is non-adaptive, it becomes possible to obtain a more general statement for 0 \u2264 \u2113 < k; however, it is unclear how to proceed without this extra assumption, leading to the following question:\nOpen Problem 3. Can one obtain a general round-reduction upper bound for 0 \u2264 \u2113 < k of the form q\u2113 \u2264 \u03c6(qk, \u2113, k), improving on Fact 6.1 for \u2113 > 0?"}, {"heading": "6.2 On the Connection with Communication Complexity", "text": "As exemplified in the proof of Lemma 4.4, there exists a striking parallel between the notion of k-round-adaptive testing algorithms, and that of k-round protocols in communication complexity. In this section, we make this parallel rigorous, and give a blackbox reduction between the two that one can leverage to establish lower bounds on k-round-adaptive testing.\nIn more detail, we build on the communication complexity methodology for proving property testing lower bounds due to [BBM12] (more precisely, to the general formulation of this methodology as laid out in [Gol13]). Although the results stated there hold for non-adaptive lower bounds (in the case of one-way communication or simultaneous message passing) or fully adaptive lower bounds in property testing (in the case of two-way communication), it is easy to obtain their counterpart for k-round-adaptive, given in Theorem 6.4 below. But first, we need to recall some notations.\nIn what follows, for a property P, integer k, and parameters \u03b5, \u03b4 \u2208 [0, 1], we write Q(k)\u03b4 (\u03b5,P) for the minimum query complexity of any k-round-adaptive tester for P with error probability\n\u03b4 and distance parameter \u03b5. Given a communication complexity predicate F , we let CC (k) \u03b4 (F ),\u2212\u2192\nCC\u03b4(F ), and \u2190\u2212 CC\u03b4(F ) denote respectively the minimum communication complexity of a public-coin protocol for F with error \u03b4 in (i) k-rounds, (ii) one-way from Alice to Bob, and (iii) one-way from Bob to Alice, respectively (note that the case \u03b4 = 0 then corresponds to protocols with perfect completeness).\nTheorem 6.4. Let \u03a8 = (P, S) be a promise problem such that P, S \u2286 {0, 1}2n, P \u2286 {0, 1}\u2113 be a property, and \u03b5, \u03b4 > 0. Suppose the mapping F : {0, 1}2n \u2192 {0, 1}\u2113 satisfies the following two conditions:\n(i) for every (x, y) \u2208 P \u2229 S, it holds that F (x, y) \u2208 P; (ii) for every (x, y) \u2208 P \\ S, it holds that F (x, y) is \u03b5-far from P.\nThen Q (k) \u03b4 (\u03b5,P) \u2265 1B+1 CC (k+2) 2\u03b4 (\u03a8), where B := maxi\u2208[\u2113]max(\n\u2212\u2192 CC \u03b4\nn (Fi),\n\u2190\u2212 CC \u03b4\nn (Fi)) (and Fi(x, y)\nis the i\u2019th bit of F (x, y)). Moreover, if B\u2032 := maxi\u2208[\u2113]max( \u2212\u2192 CC0(Fi), \u2190\u2212 CC0(Fi)), then Q (k) \u03b4 (\u03b5,P) \u2265\n1 B\u2032+1 CC (k+2) \u03b4 (\u03a8).\nProof. The proof will be identical to that of [Gol13, Theorem 3.1], where we only need to check that Alice and Bob can each simulate the execution of the property testing algorithm (using their public random coins), answering the queries made to F (x, y) while preserving the number of rounds. Running the testing algorithm, Alice first sends the bits allowing Bob to compute the answers to the first q0 queries, using her input x and the one-way protocols for the relevant Fi\u2019s. Bob then answers with the q0 bits corresponding to the answers he computed, as well as the bits allowing Alice to compute the answers to the next q1 queries made by the tester, using now his input y and the one-way protocols for the relevant Fi\u2019s. They do so for k+1 rounds of communication in total, until the last player to receive a message gets from the other player both the answers to the queries in Qk\u22121 as well as the bits needed to compute (given their own input) the answers to the last qk queries. At that point, it only remains to use a last round of communication (the (k + 2)\u2019nd) to communicate to the other player the answers to these last qk queries, so that both Alice and Bob can finish running their copy of the testing algorithm and know the answer.\nNote that the number of bits communicated at round 1 \u2264 i \u2264 k + 2 is by definition of B (resp. B\u2032) at most B \u00b7 qi\u22121 + qi\u22122 (resp. B\u2032 \u00b7 qi\u22121 + qi\u22122), so that at most (B + 1)q (resp. (B\u2032 + 1)q) bits are communicated in total. This concludes the proof.\nTo illustrate the above methodology, we show how it can be leveraged to prove a hierarchy of lower bounds on the power of k-adaptive testers for testing a very fundamental class of Boolean functions, that of m-linear functions.8\nProposition 6.5. Let PARns \u2286 22 n denote the class of parities of size s (over n variables), and\nfix m := \u221a n 2 . Then, for any 0 \u2264 k \u2264 log\u2217 m\u2212 2, any (k, q)-round-adaptive tester for PARn2m must satisfy q = \u2126 ( m log(k+2)m ) .\nProof. We will rely on a result of Sa\u011flam and Tardos [ST13], which implies the following (tight) lower bound on the communication complexity of sparse set-disjointness (DISJnm, where both inputs x, y \u2208 {0, 1}n are promised to have Hamming weight m):\n8We observe that establishing the upper bound counterpart to this result would provide an answer\nTheorem (Corollary of [ST13, Theorem 4]). For any 1 \u2264 k \u2264 log\u2217 m, any k-round probabilistic protocol for DISJ4m 2 m with error probability at most 1/3 must have communication \u2126 ( m log(k)m ) .\nIt then suffices to provide a reduction from DISJ4m 2 m to testing PAR 4m2 2m . We follow the known reduction, as can be found in [BBM12, BGMdW13]. Namely, on input x \u2208 {0, 1}n (resp. y \u2208 {0, 1}n), Alice (resp. Bob) forms the parity function \u03c7x (resp. \u03c7y). As |x\u2295 y| = |x|+|y|\u22122 |x \u2229 y| = 2m\u22122 |x \u2229 y|, the function \u03c7x\u2295y is a 2(m\u2212|x \u2229 y|)-parity. Moreover, as for any z \u2208 {0, 1}n we have \u03c7x\u2295y(z) = \u03c7x(z)\u2295\u03c7y(z), each query can be answered (with zero error) by one bit of communication in either direction.\nPut in the language of our reduction theorem, \u03a8 = (P, S) with P = { u \u2208 {0, 1}n : |u| = m }2 and S = { (x, y) \u2208 P : |x \u2229 y| 6= 0 }; while \u2113 = 2n, P = PARn2m \u2286 2\u2113; and F : {0, 1}2n \u2192 {0, 1}\u2113 maps (x, y) to the truth table of \u03c7x\u2295y. Since any two distinct parities are at distance 12 , we can take any \u03b5 \u2264 12 . We then have B\u2032 = 1, and by the theorem above we know that CC (k+2) 1/3 (\u03a8) = \u2126 ( m log(k+2)m ) for any 0 \u2264 k \u2264 log\u2217 m\u2212 2. Invoking Theorem 6.4 concludes the proof."}, {"heading": "6.3 On the Relative Power of Round- and Tail-Adaptive Testers", "text": "In this section, we show that the two notions of round- and tail-adaptive testers we introduced are not equivalent. As mentioned in Section 3, while round-adaptive testers are at least as powerful as tail-adaptive ones, there exist properties for which the separation is strict:\nTheorem 6.6. Fix any \u03b1 \u2208 (0, 1). There exists a constant \u03b2 \u2208 (0, 1) such that, for every n \u2208 N, the following holds. For every integer 0 \u2264 k \u2264 n\u03b2, there exists a property Pk \u2286 Fn 1+\u03b1\nn such that, for any constant \u03b5 \u2208 (0, 1], (i) there exists a (k, O\u0303(k))-round-adaptive (one-sided) tester for Pk; yet (ii) any (k, q)-tail-adaptive (two-sided) tester for Pk must satisfy q = \u2126(n).\nProof sketch. The argument is very similar to that of Theorem 4.1, and follows the same overall structure. Namely, we slightly modify the k-iterated function fk of Section 4 (which was computable by a (k, k+1)-tail-adaptive algorithm) to rule out tail-adaptive algorithms but not round-adaptive ones: that is, we define the function f \u2032k : F n n \u2192 Fn by\nf \u2032k(x) =\n{\n1 if xx,gk\u22121(x) = xx,gk\u22121(x)+1 mod n 0 otherwise.\n(Perhaps more clearly, f \u2032k is computed by iterating the pointer function k times, and then checking if the value xi at the final coordinate i \u2208 [n] reached, and the value xi+1 at the adjacent coordinate i+ 1, are equal.) It is not hard to see that the counterparts of Claim 4.3 and Lemma 4.4 still hold for f \u2032k: first, the function is still easy to compute by (k, k+2)-round-adaptive algorithms. However, because the very last round requires 2 queries and not one (to query xi and xi+1, once the value of i = gk\u22121(x) has been obtained), tail-round-adaptive algorithms are no longer able to leverage this, and analogously to Lemma 4.4 we can conclude that there is no (k, o(n/(k2 log n)))-round-adaptive (randomized) LDT algorithm which computes f \u2032k. It then only remains to lift this DT separation\nto Open Problem 1, although one rather weak quantitatively. It also, as a special case, would separate adaptive and non-adaptive testing of m-linearity for m = o(n), a longstanding open question [BK12, BCK14].\nto property testing: we can do this as before (noting, in the case of lifting the lower bound, that the reduction of Lemma 4.10 preserves the number of queries per round, and thus the \u201ctailness\u201d of the algorithm)."}, {"heading": "Acknowledgments", "text": "We are grateful to Oded Goldreich for suggesting cycle freeness as a candidate natural property for proving an adaptivity hierarchy theorem, as well as for enlightening conversations that significantly contributed to this work; and wish to thank Rocco Servedio for helpful comments on an earlier version of this paper."}], "references": [{"title": "Algebrization: a new barrier in complexity theory", "author": ["Scott Aaronson", "Avi Wigderson"], "venue": "In Proceedings of STOC,", "citeRegEx": "Aaronson and Wigderson.,? \\Q2008\\E", "shortCiteRegEx": "Aaronson and Wigderson.", "year": 2008}, {"title": "Property testing lower bounds via communication complexity", "author": ["Eric Blais", "Joshua Brody", "Kevin Matulef"], "venue": "Computational Complexity,", "citeRegEx": "Blais et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Blais et al\\.", "year": 2012}, {"title": "Property testing bounds for linear and quadratic functions via parity decision trees", "author": ["Abhishek Bhrushundi", "Sourav Chakraborty", "Raghav Kulkarni"], "venue": "In CSR,", "citeRegEx": "Bhrushundi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bhrushundi et al\\.", "year": 2014}, {"title": "Complexity measures and decision tree complexity: a survey", "author": ["Harry Buhrman", "Ronald de Wolf"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Buhrman and Wolf.,? \\Q2002\\E", "shortCiteRegEx": "Buhrman and Wolf.", "year": 2002}, {"title": "Robust PCPs of Proximity, Shorter PCPs, and Applications to Coding", "author": ["Eli Ben-Sasson", "Oded Goldreich", "Prahladh Harsha", "Madhu Sudan", "Salil P. Vadhan"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Ben.Sasson et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ben.Sasson et al\\.", "year": 2006}, {"title": "The non-adaptive query complexity of testing k-parities", "author": ["Harry Buhrman", "David Garc\u00eda-Soriano", "Arie Matsliah", "Ronald de Wolf"], "venue": "Chicago J. Theor. Comput. Sci.,", "citeRegEx": "Buhrman et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Buhrman et al\\.", "year": 2013}, {"title": "Some 3CNF properties are hard to test", "author": ["Eli Ben-Sasson", "Prahladh Harsha", "Sofya Raskhodnikova"], "venue": "SIAM J. Comput.,", "citeRegEx": "Ben.Sasson et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Ben.Sasson et al\\.", "year": 2005}, {"title": "Tight bounds for testing k-linearity", "author": ["Eric Blais", "Daniel M. Kane"], "venue": "In Proceedings of APPROX-RANDOM,", "citeRegEx": "Blais and Kane.,? \\Q2012\\E", "shortCiteRegEx": "Blais and Kane.", "year": 2012}, {"title": "Improved bounds for testing juntas", "author": ["Eric Blais"], "venue": null, "citeRegEx": "Blais.,? \\Q2008\\E", "shortCiteRegEx": "Blais.", "year": 2008}, {"title": "Testing juntas nearly optimally", "author": ["Eric Blais"], "venue": "In Proceedings of STOC,", "citeRegEx": "Blais.,? \\Q2009\\E", "shortCiteRegEx": "Blais.", "year": 2009}, {"title": "Self-testing/correcting with applications to numerical problems", "author": ["Manuel Blum", "Michael Luby", "Ronitt Rubinfeld"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "Blum et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Blum et al\\.", "year": 1993}, {"title": "Lower bounds for testing computability by small width OBDDs", "author": ["Joshua Brody", "Kevin Matulef", "Chenggang Wu"], "venue": "In TAMC, volume 6648 of Lecture Notes in Computer Science,", "citeRegEx": "Brody et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Brody et al\\.", "year": 2011}, {"title": "A Survey on Distribution Testing: your data is Big", "author": ["Cl\u00e9ment L. Canonne"], "venue": "But is it Blue? Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "Canonne.,? \\Q2015\\E", "shortCiteRegEx": "Canonne.", "year": 2015}, {"title": "Settling the query complexity of non-adaptive junta testing", "author": ["Xi Chen", "Rocco A. Servedio", "Li-Yang Tan", "Erik Waingarten", "Jinyu Xie"], "venue": "Private communication,", "citeRegEx": "Chen et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2017}, {"title": "Combinatorial Group Testing and Its Applications", "author": ["Dingzhu Du", "Frank K. Hwang"], "venue": "Applied Mathematics. World Scientific,", "citeRegEx": "Du and Hwang.,? \\Q2000\\E", "shortCiteRegEx": "Du and Hwang.", "year": 2000}, {"title": "Strong locally testable codes with relaxed local decoders. In Conference on Computational Complexity, volume 33 of LIPIcs, pages 1\u201341", "author": ["Oded Goldreich", "Tom Gur", "Ilan Komargodski"], "venue": "Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,", "citeRegEx": "Goldreich et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Goldreich et al\\.", "year": 2015}, {"title": "Property testing and its connection to learning and approximation", "author": ["Oded Goldreich", "Shafi Goldwasser", "Dana Ron"], "venue": "Journal of the ACM,", "citeRegEx": "Goldreich et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Goldreich et al\\.", "year": 1998}, {"title": "Property Testing - Current Research and Surveys [outgrow of a workshop at the Institute for Computer Science (ITCS) at Tsinghua University, January 2010], volume 6390 of Lecture", "author": ["Oded Goldreich", "editor"], "venue": "Notes in Computer Science. Springer,", "citeRegEx": "Goldreich and editor.,? \\Q2010\\E", "shortCiteRegEx": "Goldreich and editor.", "year": 2010}, {"title": "On the communication complexity methodology for proving lower bounds on the query complexity of property testing", "author": ["Oded Goldreich"], "venue": "Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "Goldreich.,? \\Q2013\\E", "shortCiteRegEx": "Goldreich.", "year": 2013}, {"title": "Introduction to Property Testing", "author": ["Oded Goldreich"], "venue": "Forthcoming, 2017", "citeRegEx": "Goldreich.,? \\Q2017\\E", "shortCiteRegEx": "Goldreich.", "year": 2017}, {"title": "On testing expansion in bounded-degree graphs", "author": ["Oded Goldreich", "Dana Ron"], "venue": "Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "Goldreich and Ron.,? \\Q2000\\E", "shortCiteRegEx": "Goldreich and Ron.", "year": 2000}, {"title": "Algorithmic aspects of property testing in the dense graphs model", "author": ["Oded Goldreich", "Dana Ron"], "venue": "SIAM J. Comput.,", "citeRegEx": "Goldreich and Ron.,? \\Q2011\\E", "shortCiteRegEx": "Goldreich and Ron.", "year": 2011}, {"title": "The 8th Innovations in Theoretical Computer Science (ITCS 2017) conference (to appear)", "author": ["Tom Gur", "Ron D. Rothblum. A hierarchy theorem for interactive proofs of proximity."], "venue": "1.2", "citeRegEx": "Gur and proximity.,? 2017", "shortCiteRegEx": "Gur and proximity.", "year": 2017}, {"title": "Three theorems regarding testing graph properties", "author": ["Oded Goldreich", "Luca Trevisan"], "venue": "Random Struct. Algorithms,", "citeRegEx": "Goldreich and Trevisan.,? \\Q2003\\E", "shortCiteRegEx": "Goldreich and Trevisan.", "year": 2003}, {"title": "On the power of adaptivity in sparse recovery", "author": ["Piotr Indyk", "Eric Price", "David P. Woodruff"], "venue": "In Proceedings of FOCS,", "citeRegEx": "Indyk et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Indyk et al\\.", "year": 2011}, {"title": "Testing \u00b11-weight halfspace", "author": ["Kevin Matulef", "Ryan O\u2019Donnell", "Ronitt Rubinfeld", "Rocco A. Servedio"], "venue": "In Proceedings of APPROX-RANDOM,", "citeRegEx": "Matulef et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Matulef et al\\.", "year": 2009}, {"title": "Rounds in communication complexity revisited", "author": ["Noam Nisan", "Avi Wigderson"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Nisan and Wigderson.,? \\Q1993\\E", "shortCiteRegEx": "Nisan and Wigderson.", "year": 1993}, {"title": "Property testing: A learning theory perspective", "author": ["Dana Ron"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "Ron.,? \\Q2008\\E", "shortCiteRegEx": "Ron.", "year": 2008}, {"title": "Algorithmic and analysis techniques in property testing", "author": ["Dana Ron"], "venue": "Foundations and Trends in Theoretical Computer Science,", "citeRegEx": "Ron.,? \\Q2009\\E", "shortCiteRegEx": "Ron.", "year": 2009}, {"title": "Robust characterization of polynomials with applications to program testing", "author": ["Ronitt Rubinfeld", "Madhu Sudan"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Rubinfeld and Sudan.,? \\Q1996\\E", "shortCiteRegEx": "Rubinfeld and Sudan.", "year": 1996}, {"title": "A note on adaptivity in testing properties of bounded degree graphs", "author": ["Sofya Raskhodnikova", "Adam D. Smith"], "venue": "Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "Raskhodnikova and Smith.,? \\Q2006\\E", "shortCiteRegEx": "Raskhodnikova and Smith.", "year": 2006}, {"title": "Exponentially improved algorithms and lower bounds for testing signed majorities", "author": ["Dana Ron", "Rocco A. Servedio"], "venue": "In Proceedings of SODA,", "citeRegEx": "Ron and Servedio.,? \\Q2013\\E", "shortCiteRegEx": "Ron and Servedio.", "year": 2013}, {"title": "Testing computability by width-two OBDDs", "author": ["Dana Ron", "Gilad Tsur"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Ron and Tsur.,? \\Q2012\\E", "shortCiteRegEx": "Ron and Tsur.", "year": 2012}, {"title": "On the communication complexity of sparse set disjointness and exists-equal problems", "author": ["Mert Sa\u011flam", "G\u00e1bor Tardos"], "venue": "In Proceedings of FOCS,", "citeRegEx": "Sa\u011flam and Tardos.,? \\Q2013\\E", "shortCiteRegEx": "Sa\u011flam and Tardos.", "year": 2013}, {"title": "Adaptivity helps for testing juntas. In Conference on Computational Complexity, volume 33 of LIPIcs, pages 264\u2013279", "author": ["Rocco A. Servedio", "Li-Yang Tan", "John Wright"], "venue": "Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,", "citeRegEx": "Servedio et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Servedio et al\\.", "year": 2015}, {"title": "Deconstructions of reductions from communication complexity to property testing using generalized parity decision trees", "author": ["Roei Tell"], "venue": "Electronic Colloquium on Computational Complexity (ECCC),", "citeRegEx": "Tell.,? \\Q2014\\E", "shortCiteRegEx": "Tell.", "year": 2014}], "referenceMentions": [], "year": 2017, "abstractText": "Adaptivity is known to play a crucial role in property testing. In particular, there exist properties for which there is an exponential gap between the power of adaptive testing algorithms, wherein each query may be determined by the answers received to prior queries, and their non-adaptive counterparts, in which all queries are independent of answers obtained from previous queries. In this work, we investigate the role of adaptivity in property testing at a finer level. We first quantify the degree of adaptivity of a testing algorithm by considering the number of \u201crounds of adaptivity\u201d it uses. More accurately, we say that a tester is k-(round) adaptive if it makes queries in k+1 rounds, where the queries in the i\u2019th round may depend on the answers obtained in the previous i\u2212 1 rounds. Then, we ask the following question: Does the power of testing algorithms smoothly grow with the number of rounds of adaptivity? We provide a positive answer to the foregoing question by proving an adaptivity hierarchy theorem for property testing. Specifically, our main result shows that for every n \u2208 N and 0 \u2264 k \u2264 n there exists a property Pn,k of functions for which (1) there exists a k-adaptive tester for Pn,k with query complexity \u00d5(k), yet (2) any (k \u2212 1)-adaptive tester for Pn,k must make \u03a9(n) queries. In addition, we show that such a qualitative adaptivity hierarchy can be witnessed for testing natural properties of graphs. This work previously appeared as \u201cFifty Shades of Adaptivity (in Property Testing).\u201d Columbia University. Email: ccanonne@cs.columbia.edu. Research supported by NSF grants CCF-1115703 and NSF CCF-1319788. Weizmann Institute. Email: tom.gur@weizmann.ac.il. Research partially supported by ISF grant 671/13.", "creator": "LaTeX with hyperref package"}}}