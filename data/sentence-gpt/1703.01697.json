{"id": "1703.01697", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Mar-2017", "title": "Principles and Examples of Plausible Reasoning and Propositional Plausible Logic", "abstract": "Plausible reasoning concerns situations whose inherent lack of precision is not quantified; that is, there are no degrees or levels of precision, and hence no use of numbers like probabilities. A hopefully comprehensive set of principles that clarifies what it means for a formal logic to do plausible reasoning is presented. A new propositional logic, called Propositional Plausible Logic (PPL), is defined and applied to some important examples, with a goal to improve the accuracy of the proposed logic.\n\n\nThe first step is a simple proposition. In order to have certainty, you must have no other choice.\nIn this instance, you must have more than one choice of your choice to follow the following logic:\nA proposition (1) is a given proposition (2) . A proposition (3) contains a set of propositions (1) . A proposition (2) contains a set of propositions (1) .\nThis proposition is often referred to as the proposition:\na proposition (3) is a given proposition (4) . A proposition (4) contains a set of propositions (1) .\nThe simplest proposition is a proposition (2) . A proposition (3) contains a set of propositions (1) . A proposition (4) contains a set of propositions (1) . A proposition (4) contains a set of propositions (1) .\nAs such, if a proposition (1) is a given proposition (2) , a proposition (2) , a proposition (3) , a proposition (3) , a proposition (4) , a proposition (5) , a proposition (5) , a proposition (6) , a proposition (7) , a proposition (8) , a proposition (9) , a proposition (10) , a proposition (11) , a proposition (12) , a proposition (13) , a proposition (14) , a proposition (15) , a proposition (16) , a proposition (17) , a proposition (18) , a proposition (19) , a proposition (20) , a proposition (21) , a proposition (22) , a proposition (23) , a proposition (24) , a proposition (25) , a proposition (26) , a proposition (27) , a proposition (28) , a proposition (29) , a proposition (30) , a proposition (31) , a proposition (32) , a proposition (33) , a proposition (34) , a proposition (35) , a proposition", "histories": [["v1", "Mon, 6 Mar 2017 00:53:04 GMT  (65kb)", "https://arxiv.org/abs/1703.01697v1", null], ["v2", "Mon, 3 Apr 2017 23:42:12 GMT  (65kb)", "http://arxiv.org/abs/1703.01697v2", "58 pages. Updated n-die examples to n-lottery examples. Example 3.4 simplified. In Section 4 counter-example to the Or-rule changed and corrected, and a new logic (PTL) considered"]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["david billington"], "accepted": false, "id": "1703.01697"}, "pdf": {"name": "1703.01697.pdf", "metadata": {"source": "CRF", "title": "Principles and Examples of Plausible Reasoning and Propositional Plausible Logic", "authors": ["David Billington"], "emails": ["d.billington@griffith.edu.au"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 3.\n01 69\n7v 2\n[ cs\n.A I]\n3 A\npr 2\n01 7"}, {"heading": "1. Introduction", "text": "We are interested in reasoning about situations that (a) have imprecisely defined parts, and (b) this lack of precision is not quantified. That is, there are no degrees or layers or levels of precision, and in particular there are no numbers like probabilities, that would quantify the lack of precision. These situations are often indicated by the ordinary, rather than technical, use of words such as \u2018mostly\u2019, \u2018usually\u2019, \u2018typically\u2019, \u2018normally\u2019, \u2018probably\u2019, \u2018likely\u2019, \u2018plausible\u2019, \u2018believable\u2019, and \u2018reasonable\u2019. Although these words are not synonymous, they share a common property, which may be expressed by using either frequency of occurrence or weight of evidence. In frequency terms the property is that something is true more often than not; in evidence terms the property is that the evidence for something outweighs the evidence against it. An example is \u2018Mammals usually are non-venomous\u2019.\nWe shall call these situations plausible-reasoning situations because we shall call the reasoning used in such situations plausible reasoning.\nThis article has two aims. The first is to introduce principles that give a much clearer understanding of what it means for a formal logic to do plausible reasoning; that is the kind of reasoning indicated above. The hope is that this set of principles is comprehensive. Whether it is or not, this seems to be the first such set of principles even though plausible reasoning has been used for at least 2500 years (Walton, Tindale, & Gordon, 2014). However on page 114 of (Walton et al., 2014) there is a list of 11 characteristics of plausible reasoning, rather than characteristics of formal logics that do plausible reasoning.\nThe second aim is to define a propositional logic, called Propositional Plausible Logic (PPL), that satisfies all these principles of plausible reasoning. This shows that all the principles together are consistent; that is, there is no principle whose negation is implied by all the other principles. A pruned version of PPL is presented in (Billington, 2015).\nIn this paper we shall be considering only propositional situations; that is, situations that can be fully represented by a propositionally adequate language. That is, by a language\nwhich has an adequate set of propositional connectives. The most common adequate sets of connectives contain negation and at least one of conjunction, or disjunction, or material implication. The connectives we shall use are negation \u00ac, conjunction \u2227 , and disjunction \u2228 . A propositionally adequate logic is a logic based on a propositionally adequate language. Moreover we shall consider only those plausible-reasoning situations that can be specified by a plausible-structure S = (Fact(S),Plaus(S)) where Fact(S) is a set of propositional formulas representing the factual part of S, and Plaus(S) is a set representing the plausible part of S. The elements of Plaus(S) can have a variety of forms; for example: defaults are used in Reiter\u2019s Default Logic (Reiter, 1980), defeasible rules are used in ASPIC (Caminada & Amgoud, 2007) and ASPIC+ (Modgil & Prakken, 2013), and defeasible and warning rules are used in Defeasible Logic (Billington, 2008). The plausible-structure syntax is very general, while being specific enough to permit the definition of concepts needed later.\nThis article is organised into the following sections. The next section defines some ideas and notation from classical propositional logic that are needed in Sections 3 and 5. Section 3 presents the principles of plausible reasoning. Section 4 contains a survey of various nonnumeric non-monotonic logics. The definition of PPL is in Section 5. In Section 6 we apply PPL to some examples. In Section 7 we state and discuss some important properties of PPL, and show that PPL satisfies all the principles in Section 3. Section 8 is the conclusion. All the proofs are in the appendices."}, {"heading": "2. A Classical Propositional Logic using Resolution", "text": "Formulas in classical propositional logics are usually defined using sequences, for example (a \u2228 (b \u2228 a)). Sequences make unwanted distinctions which are often best removed, for example neither order nor repetitions are needed. So the above example is more clearly written as \u2228 {a, b}. We shall define classical propositional formulas that are based on sets rather than sequences. Such set-based formulas simplify the definition of resolution. The classical notions of truth value, valuation, satisfaction, semantic consequence |=, tautology, contradiction, equivalence of formulas, and resolution are as usual.\nLet us start by agreeing on some notation. As usual \u2018iff\u2019 abbreviates \u2018if and only if\u2019. X is a subset of Y is denoted by X\u2286Y ; the notation X\u2282Y means X\u2286Y and X 6=Y , and denotes that X is a strict subset of Y . The empty set is denoted by {}, and the set of all integers by Z. The cardinality of a set S is denoted by |S|. If m and n are integers then we define the integer interval [m..n] by [m..n] = {i\u2208Z : m \u2264 i \u2264 n}.\nOur alphabet is the union of the following pairwise disjoint sets of symbols: a nonempty countable set, Atm, of (propositional) atoms; the set {\u00ac, \u2227 , \u2228 } of connectives with \u00ac, \u2227 , \u2228 denoting negation, conjunction, and disjunction respectively; and the set of punctuation marks consisting of the comma and both braces. We now define a formula.\nDefinition 2.1. 1) If a is an atom then a is a formula. 2) If f is a formula then \u00acf is a formula. 3) If F is a finite set of formulas then \u2227 F is a formula and \u2228 F is a formula. 4) Every formula can be built by a finite number of applications of (1), (2), and (3). The set of all formulas is denoted by Fml .\nIt is convenient to write \u2227 F and \u2228 F even though the set F of formulas may be infinite.\nThe next three definitions define some special formulas, the set of all literals in a clause or dual-clause, and the complement of a literal.\nDefinition 2.2. 1) The set, Lit , of all literals is defined by Lit = Atm \u222a {\u00aca : a\u2208Atm}. 2) A clause is either a literal or the disjunction, \u2228 L, of a finite set, L, of literals. 3) \u2228 {} is the empty clause or falsum. 4) A dual-clause is either a literal or the conjunction, \u2227 L, of a finite set, L, of literals. 5) \u2227 {} is the empty dual-clause or verum. 6) A formula is contingent iff it is not a tautology and it is not a contradiction.\nDefinition 2.3. 1) If l is a literal then Lit(l) = {l}. 2) If L is a finite set of literals then Lit( \u2228 L) = L = Lit( \u2227 L).\nDefinition 2.4. Let a be any atom and L be any set of literals. 1) The complement of a, \u223ca, is defined by \u223ca = \u00aca. 2) The complement of \u00aca, \u223c\u00aca, is defined by \u223c\u00aca = a. 3) The complement of L, \u223cL, is defined by \u223cL = {\u223cl : l\u2208L}.\nLet C be any set of clauses. We want to remove from C all the clauses that, when removed, will not change the truth value of \u2227 C. By Lemma A.1(1) (See Appendix A) this means removing all tautologies and all clauses that have a strict subclause in C. We also want to simplify C by replacing any clause \u2228 {l} in C by l. The result will be the core of C.\nDually, let D be any set of dual-clauses. We want to remove from D all the dualclauses that, when removed, will not change the truth value of \u2228 D. By Lemma A.1(2) (See Appendix A) this means removing all contradictions and all dual-clauses that have a strict sub-dual-clause in D. We also want to simplify D by replacing any dual-clause \u2227 {l} in D by l. The result will be the core of D. The following definition does both of these.\nDefinition 2.5. Let G be either a set of clauses or a set of dual-clauses. 1) The set of elements of G that are contingent or empty, Ctge(G), is defined by\nCtge(G) = {g\u2208G : g is contingent or empty}. 2) The set of minimal elements of G, Min(G), is defined by\nMin(G) = {g\u2208G : if g\u2032\u2208G then Lit(g\u2032) 6\u2282Lit(g)}. 3) The simplification of the formula f , smp(f), is defined as follows.\nIf f \u2208{ \u2227 {g}, \u2228 {g}}, where g is a formula, then smp(f) = smp(g); else smp(f) = f .\n4) The simplification of G, Smp(G), is defined by Smp(G) = {smp(g) : g\u2208G}. 5) The core of G, Cor(G), is defined by Cor (G) = Smp(Min(Ctge(G))).\nLet C be any set of clauses. The set of all clauses derivable by resolution from clauses in C is denoted by Res(C). Also we usually abbreviate Cor (Res(C)) to CorRes(C), and Smp(Res(C)) to SmpRes(C).\nWe shall need to convert a formula f into a set Claus(f) of clauses, such that \u2227 Claus(f) is equivalent to f . Unfortunately there are many such sets of clauses, so we shall follow Sections 2 and 3 of Chapter I of (Nerode & Shore, 1997) to define which set we mean.\nWe shall denote the true truth value by T and the false truth value by F. Let Val denote the set of all valuations, and Atm(f) denote the set of atoms in the formula f .\nDefinition 2.6. If A is a set of atoms then define Val(A), the set of valuations which are false outside A, by Val(A) = {v\u2208Val : for all a in Atm\u2212A, v(a) = F}.\nSo if |A| = n then |Val(A)| = 2n.\nDefinition 2.7. Let f be any formula, F any set of formulas, and v any valuation. 1) Define L(f, v) = {a : a\u2208Atm(f) and v(a) = T} \u222a {\u00aca : a\u2208Atm(f) and v(a) = F}. 2) Define Claus(f) = { \u2228 \u223cL(f, v) : v\u2208Val(Atm(f)) and v(f) = F}. 3) Define Claus(F ) = \u22c3 {Claus(f) : f \u2208F}.\nIf a set F of formulas is unsatisfiable then classical propositional logic can prove any formula from F ; that is, classical propositional logic is explosive. Explosive logics are not ideal because, for unsatisfiable sets of formulas, the idea of \u2018proof\u2019 becomes worthless. For example, let F1 = {a,\u00aca, b}. Then from F1 an explosive logic can prove \u00acb, which does not seem sensible. Logics that are not explosive are called paraconsistent logics. But we want more than mere paraconsistency. In the example above, either a or \u00aca seems to be a mistake, so it would be reasonable that from F1 we can conclude only b, and what follows from b.\nLet F be an unsatisfiable set of formulas. There are several ways of getting a satisfiable subset of F (see the literature on Belief Revision and Paraconsistent Logics). One way is to take the intersection of all the maximal satisfiable subsets of F , (this is the full meet contraction of F by a contradiction). An equivalent way is to remove all the minimal unsatisfiable subsets of F . For example, let F2 = {a,\u00aca, \u2228 {a, b}}. Then the (only) minimal unsatisfiable subset of F2 is {a,\u00aca}. Removing this from F2 leaves { \u2228 {a, b}}. Alternatively the intersection of all the maximal satisfiable subsets of F2 is also { \u2228 {a, b}}.\nHowever, another way to get a satisfiable subset of F is to remove all the formulas of F that are \u2018contaminated\u2019 by potential errors, as follows. First we convert F to the set of clauses Claus(F ). Then F is unsatisfiable iff Claus(F ) is unsatisfiable iff Res(Claus(F )) contains a literal, say l, and its complement, \u223cl. At least one of l and \u223cl is an error. Certainly both l and \u223cl are potential errors. Potential errors contaminate any clause containing them, making the clause unreliable. We then remove all the contaminated clauses from Claus(F ) to get the result Sat(Claus(F )).\nApplying this to F2 we see that Claus(F2) = { \u2228 {a}, \u2228 {\u00aca}, \u2228 {a, b}} and the set, Err(Claus(F2)), of potential error literals of Claus(F2) is Err(Claus(F2)) = {a,\u00aca}. Hence very clause in Claus(F2) is contaminated by a potential error, and so Sat(Claus(F2)) = {}.\nThe formal definition of the functions Err(.) and Sat(.) follows.\nDefinition 2.8. Let C be any set of clauses. Err(C) = {l\u2208Lit : {l,\u223cl}\u2286SmpRes(C)}. Sat(C) = {c\u2208C : c 6= \u2228 {} and Lit(c)\u2229Err (C) = {}}.\nOf course if C is satisfiable then Sat(C) = C. If C is any set of clauses then Sat(C) is satisfiable, and so Sat(Sat(C)) = Sat(C).\nLet C be a set of clauses. It can be shown that every literal in every clause in every minimal unsatisfiable subset of C is a potential error literal and so is in Err(C). But Sat(C)\nremoves all the clauses that contain any potential error literal, not just the clauses that are composed entirely of potential error literals. Hence the clauses in Sat(C) may be regarded as at least as reliable as the clauses in the intersection of all the maximal satisfiable subsets of C, as some of these clauses may contain potential error literals, as happens with F2.\nWe can now define our paraconsistent propositional logic by mimicking the standard definition of proof by resolution, which we shall also define.\nDefinition 2.9. Let F be any set of formulas and f be any formula. As usual, define F proves f (by resolution), denoted by F \u22a2 f , as follows. F \u22a2 f iff \u2228 {} \u2208 Res(Claus({\u00acf}\u222aF )). Define F judiciously proves f , denoted by F f , as follows. F f iff \u2228 {} \u2208 Res(Claus(\u00acf)\u222aSat(Claus(F ))).\nExplosiveness is a symptom of the fact that, from a set F of formulas, classical logic proves formulas that, arguably, do not follow from F . For example, if a and b are different atoms then from the contradiction \u2227 {a,\u00aca} we can prove b. Because b has nothing to do with a or \u00aca, our intuition is that b does not follow from \u2227 {a,\u00aca}. Although \u2018follows from\u2019 is an intuitive concept rather than a formal one, we shall attempt to formally define the concept. To refine our intuition let us consider tautologies.\nLet F be a set of formulas, f and g be formulas, L and M be finite sets of literals, and t be a tautology.\nA) We could argue that tautologies stand on their own, they do not depend on any other formula. So if t /\u2208F then t does not follow from F . B) We would like \u2018follows from\u2019 to be syntax independent. That is, if f follows from F and f is equivalent to g then g follows from F . C) If f \u2208F then it seems reasonable that f follows from F . D) If \u2228 L follows from F and L \u2286M then it seems reasonable that \u2228 M follows from F . E) If a and b are different atoms then it seems reasonable that \u2228 {a,\u00aca} does not follow\nfrom { \u2228 {b,\u00acb}}. By (C), \u2228 {b,\u00acb} follows from { \u2228 {b,\u00acb}}. But this would make \u2018follows from\u2019 syntax dependent, contrary to (B). So tautologies present difficulties for any definition of \u2018follows from\u2019. However, in Section 3 we do not want to force all tautologies to be provable, so we shall declare that tautologies do not follow from any set of formulas. Thus we arrive at the following definition.\nDefinition 2.10. Let F be any set of formulas. Define Taut to be the set of all tautologies. Define the set of formulas that follow from F , From(F ), by From(F ) = {f \u2208Fml : F f} \u2212 Taut .\nSince Sat(Claus(F )) \u2286 Claus(F ) we have From(F ) \u2286 {f \u2208Fml : F f} \u2286 {f \u2208Fml : F \u22a2 f}."}, {"heading": "3. Principles of Plausible Reasoning", "text": "Lists of postulates, properties, or principles that concern special types of reasoning are useful for at least the following reasons. 1) They help characterise the intended special type of reasoning.\n2) They provide a means of evaluating existing reasoning systems to see how well they perform the intended special type of reasoning. 3) They provide guidelines for creating new reasoning systems for the intended special type of reasoning. 4) They explicitly show a difference between the intended special type of reasoning and an existing form of reasoning. Notable examples of such lists are the following. The AGM postulates for belief change (Alchourro\u0300n, Ga\u0308rdenfors, & Makinson, 1985; Ga\u0308rdenfors, 1988), various properties of nonmonotonic consequence relations (Makinson, 1988; Kraus, Lehmann, & Magidor, 1990), and the postulates that a rule-based argumentation system should satisfy (Caminada & Amgoud, 2007).\nWe shall state the principles of this section by referring to the logic or proof algorithm directly; rather than by referring to consequence relations. A consequence relation, say |\u223c, relates a set F of formulas to a formula f ; where F |\u223c f means that f is a consequence of F . Consequence relations are appropriate if the reasoning situations under consideration can be characterised by a set of formulas. But the plausible-reasoning situations we consider are specified by a plausible-structure S = (Fact(S),Plaus(S)) where the elements of Plaus(S) may be very different from the formulas in Fact(S). For these situations consequence relations are much less appropriate. For example consider two fundamental properties that consequences relations may have; namely cut and cautious monotonicity, which together are equivalent to cumulativity, also called lemma addition. If F and G are sets of formulas then let F |\u223c G mean for all g in G, F |\u223c g. Then cumulativity is the following property. If F |\u223c G then for all formulas h, F |\u223c h iff F \u222aG |\u223c h. A straightforward translation of F |\u223c f into our situation is S |\u223c f , where S is a plausible-structure. But then it is really hard to know what F \u222aG might mean. Essentially we are trying to add proved formulas to S. But the only set of formulas in S is Fact(S). So we could try letting F \u222aG be (Fact(S)\u222aG,Plaus(S)). But this is only sensible when the formulas in G have been proved using only Fact(S). When the formulas in G have been proved using Plaus(S) then it is no longer sensible to treat the formulas in G as facts; because they are not facts, they are only plausible conclusions.\nSome of the principles of plausible reasoning are regarded as necessary and so use the word \u2018must\u2019; the other principles are regarded as desirable and so use the word \u2018should\u2019.\nAs well as the principles of plausible reasoning, we shall present several plausiblereasoning examples. Some of these examples are based on an n-lottery, that is, randomly selecting a number from the finite integer interval [1..n]. We shall use si to denote that the number i was selected. Four examples will guide the development of some of the principles, and so we shall call these examples signpost examples. Our first signpost example is the 3-lottery example.\nExample 3.1 (The 3-lottery example). Consider a 3-lottery. Then we have the following. 1) Exactly one element of {s1, s2, s3} is true. 2) Each element of {s1, s2, s3} is probably false. 3) The disjunction of any 2 elements of {s1, s2, s3} is probably true.\nThis example illustrates some important properties of plausible reasoning that will be considered in several of the following subsections.\nThe following notation will be convenient. Let Thm(L, \u03b1,S) denote the set of all formulas derivable from the plausible-structure S by using the proof algorithm \u03b1 of the logic L. If F is a set of propositional formulas then Thm(F ) denotes all the formulas derivable from F by (the proof algorithm of) any classical propositional logic. This simpler notation is unambiguous because Thm(F ) is independent of the logic (for example Hilbert systems, natural deduction, or resolution systems) and its proof algorithm."}, {"heading": "3.1 Representation", "text": "Plausible-reasoning situations may contain facts as well as plausible information; for instance statement (1) of Example 3.1 is a factual statement, unlike the other two statements which are plausible. Hence the first part of our first principle of plausible reasoning.\nAlthough the inherent lack of precision of plausible-reasoning situations is not quantified, a logic could represent this lack of precision with undue accuracy, for instance by using probabilities. Forbidding this is too restrictive, as the logic may deduce a conclusion using the probabilities but then present that conclusion without using probabilities. All we need is that the conclusions are not unduly precise. In particular if a formula is proved by using plausible information then it should not be regard as a fact. Hence the second part of our first principle of plausible reasoning.\nPrinciple 3.1 (The Representation Principle). 1) A logic for plausible reasoning must be able to represent, and distinguish between, factual\nand plausible statements. 2) The formulas proved by a logic for plausible reasoning must not be more precise than\nthe information used to derive them.\nWe note that when a situation is precisely described, perhaps using probabilities, a logic for plausible reasoning should be able to reason with the corresponding imprecisely defined situation; Example 3.1 is such a situation.\nWe infer from Principle 3.1(1) that we should be able to distinguish between conclusions that are factual and those that are merely plausible. One way of making this distinction is to have a factual proof algorithm that only uses facts and deduces only facts, and also a plausible proof algorithm that may use plausible statements and facts and deduces formulas that are only plausible. Of course if a plausible proof algorithm deduces only facts when given just facts then it can be regarded as both a factual and a plausible proof algorithm. The need for multiple proof algorithms is discussed further in Subsection 3.8."}, {"heading": "3.2 Evidence and Non-Monotonicity", "text": "Let us now see if we can establish some general guidelines concerning the provability of a given formula f . A plausible-reasoning situation will have evidence for and against f . So it seems reasonable to determine whether f is provable or not by just comparing these two sets of evidence, and declaring f provable iff the preponderance of evidence is for f .\nA consequence of the evidence criterion needs the following definitions. If S1 and S2 are plausible-structures then S1\u2286S2 means Fact(S1)\u2286Fact(S2) and Plaus(S1)\u2286Plaus(S2). A proof algorithm \u03b1 of a logic L is said to bemonotonic iff for any two plausible-structures, S1 and S2, if S1\u2286S2 then Thm(L, \u03b1,S1)\u2286Thm(L, \u03b1,S2). For example, the proof algorithm\nof a classical propositional logic is monotonic. A proof algorithm is non-monotonic iff it is not monotonic. A plausible proof algorithm is non-monotonic because the addition of evidence against a previously provable formula can cause it to be unprovable, as shown in our second signpost example.\nExample 3.2 (The Non-Monotonicity example). Consider the following two statements. The first is plausible and the second is factual. 1) a is probably true. 2) \u00aca is (definitely) true. From (1) the conclusion is \u2018a is plausible\u2019. From (1) and (2), \u2018a is plausible\u2019 cannot be deduced, but \u2018\u00aca is true\u2019 can be.\nThe discussion above justifies our next principle.\nPrinciple 3.2. 3.2.1) The Evidence Principle. A plausible proof algorithm can prove a formula f iff all the evidence for f sufficiently outweighs all the evidence against f . 3.2.2) The Non-Monotonicity Principle. A plausible proof algorithm must be non-monotonic.\nExactly what constitutes evidence for or against f can only be determined when the particular logic for plausible reasoning is known. Also \u2018sufficiently outweighs\u2019 depends on the intuition that is being modelled, as well as the particular logic.\nA proof algorithm that fails the Evidence Principle seems to be seriously flawed. So the Evidence Principle may be a principle that any sensible proof algorithm should satisfy."}, {"heading": "3.3 Conjunction", "text": "We shall say a proof algorithm \u03b1 of a logic L is conjunctive iff for any plausible-structure, S, and any two formulas f and g, if {f, g} \u2286Thm(L, \u03b1,S) then \u2227 {f, g} \u2208Thm(L, \u03b1,S). For example, the proof algorithm of any classical propositional logic is conjunctive. A proof algorithm is non-conjunctive iff it is not conjunctive.\nConjunctions of plausible formulas behave very differently from conjunctions of formulas that are certain. In Example 3.1, \u2227 {\u00acs1,\u00acs2} is equivalent to s3. So although \u00acs1 is plausible and \u00acs2 is plausible, \u2227 {\u00acs1,\u00acs2} is not plausible. Clearly plausible proof algorithms are not conjunctive.\nAlthough the conjunction of two plausible formulas is not necessarily plausible, the conjunction of two facts is a fact. So what about the conjunction of a fact and a plausible formula? Clearly it cannot be a fact, but is it always plausible? Intuitively, a fact f is always true, and a plausible formula g is true more often that not. So it seems reasonable that their conjunction be true whenever g is true, and hence it is reasonable that the conjunction is plausible. After we account for explosiveness and the problem of tautologies we get the following definition. We shall say a proof algorithm \u03b1 of a logic L is plausibly conjunctive iff for any plausible-structure, S, and any two formulas f and g, if f \u2208From(Fact(S)) and g \u2208 Thm(L, \u03b1,S) then \u2227 {f, g} \u2208 Thm(L, \u03b1,S). For example, the proof algorithm of any classical propositional logic is plausibly conjunctive.\nPrinciple 3.3 (Conjunction). 3.3.1) The Non-Conjunction Principle. A plausible proof algorithm must not be conjunctive. 3.3.2) The Plausible Conjunction Principle.\nA plausible proof algorithm should be plausibly conjunctive.\nThe Non-Conjunction Principle is supported by the fact that the \u2018And\u2019 rule of (Kraus et al., 1990), (If a |\u223c x and a |\u223c y then a |\u223c \u2227 {x, y}.), is not probabilistically sound, see (Makinson & Hawthorne, 2014)(Section 2.1) where they call the \u2018And\u2019 rule the \u2018Right\u2227+\u2019 rule. Also Definition 2.4 of (Hawthorne & Makinson, 2007) defines an \u2018And\u2019 rule that is probabilistically sound and has a similar intuition to our Plausible Conjunction Principle."}, {"heading": "3.4 Disjunction", "text": "We shall say a proof algorithm \u03b1 of a logic L is disjunctive iff for any plausible-structure, S, and any two formulas f and g, if \u2228 {f, g}\u2208Thm(L, \u03b1,S) then either f \u2208Thm(L, \u03b1,S) or g \u2208Thm(L, \u03b1,S). A proof algorithm is non-disjunctive iff it is not disjunctive. The proof algorithm of any classical propositional logic is non-disjunctive.\nThe 3-lottery example (Example 3.1) shows that, although s1 and s2 are both unlikely their disjunction \u2228 {s1, s2} is likely. Hence our next principle is necessary.\nPrinciple 3.4 (The Non-Disjunction Principle). A plausible proof algorithm must not be disjunctive."}, {"heading": "3.5 Supraclassicality", "text": "Consider a plausible-structure S. Let \u03b1 be a plausible proof algorithm of the logic L. Then it is tempting to suggest that Thm(Fact(S)) \u2286 Thm(L, \u03b1,S). This is called supraclassicality, and could be phrased as \u2018what is true is usually true\u2019.\nAs we saw in Section 2 after Definition 2.7, classical propositional logic is explosive and proves all tautologies. But we do not want to force logics for plausible reasoning to be explosive or to prove all tautologies.\nDefinition 3.1. A proof algorithm \u03b1 of a logic L has the plausible supraclassicality property and is said to be plausibly supraclassical iff for any plausible-structure, S, From(Fact(S)) \u2286 Thm(L, \u03b1,S).\nPrinciple 3.5 (The Plausible Supraclassicality Principle). Factual and plausible proof algorithms should be plausibly supraclassical.\nSince From(Fact(S)) \u2286 Thm(Fact(S)), if \u03b1 is supraclassical (that is, Thm(Fact(S)) \u2286 Thm(L, \u03b1,S)) then it is plausibly supraclassical."}, {"heading": "3.6 Right Weakening", "text": "Right Weakening can be thought of as closure under classical inference. More precisely, a proof algorithm \u03b1 has the right weakening property iff for any plausible-structure, S, and any formula f , if f \u2208Thm(L, \u03b1,S) and f |= g then g\u2208Thm(L, \u03b1,S). By replacing g with any tautology, we see that a consequence of the right weakening property is Taut \u2286\nThm(L, \u03b1,S). But we do not want to force logics for plausible reasoning to prove all tautologies. We say a proof algorithm \u03b1 has the weak right weakening property iff for any plausible-structure, S, and any formula f , if f \u2208Thm(L, \u03b1,S) then From({f}) \u2286 Thm(L, \u03b1,S).\nHowever, suppose that whenever the facts of the plausible-structure S and a formula f are true then the formula g is also true; in symbols Fact(S)\u222a{f} |= g. Then in the situation defined by S, g is true at least as often as f . So if f is usually true then g should also be usually true. We say a proof algorithm \u03b1 has the strong right weakening property iff for any plausible-structure, S, and any formula f , if f \u2208Thm(L, \u03b1,S) and Fact(S)\u222a{f} |= g then g\u2208Thm(L, \u03b1,S).\nCombining the ideas in the preceding two paragraphs produces the following definition and corresponding principle. A proof algorithm \u03b1 of a logic L has the plausible right weakening property iff for any plausible-structure, S, and any formula f , if f \u2208Thm(L, \u03b1,S) then From(Fact(S)\u222a{f}) \u2286 Thm(L, \u03b1,S).\nPrinciple 3.6 (The Plausible Right Weakening Principle). A plausible proof algorithm should have the plausible right weakening property.\nWe note that strong right weakening implies all the other right weakening properties, and weak right weakening is implied by all the other right weakening properties."}, {"heading": "3.7 Consistency", "text": "Of the 11 characteristics of plausible reasoning given on page 114 of (Walton et al., 2014), characteristic 8 is \u2018stability\u2019; which seems to mean (bottom of page 97 of (Walton et al., 2014)) that plausible statements are consistent. However, as we shall show, where consistency is concerned the number of plausible statements is important.\nWe say a proof algorithm \u03b1 of a logic L is n-consistent iff for any plausible-structure, S, and any set of formulas, F , if Fact(S) is satisfiable, and F \u2286Thm(L, \u03b1,S), and |F | \u2264 n then F is satisfiable. Also a proof algorithm \u03b1 of a logic L is strongly n-consistent iff for any plausible-structure, S, and any set of formulas, F , if Fact(S) is satisfiable, and F \u2286Thm(L, \u03b1,S), and |F | \u2264 n then Fact(S)\u222aF is satisfiable.\nSo if a proof algorithm is strongly n-consistent then it is n-consistent. If Fact(S) is satisfiable then Thm(Fact(S)) is satisfiable; else Thm(Fact(S)) contains all formulas.\nContradictions are not plausible, so plausible proof algorithms must be 1-consistent. Hence Principle 3.7.1 below.\nSuppose S is a plausible-structure such that Fact(S) is satisfiable. If f \u2208Thm(L, \u03b1,S) then in the situation defined by S, f is more likely to be true than not. Hence we should expect Fact(S)\u222a{f} to be satisfiable. That is, strong 1-consistency should hold.\nNow consider strong 2-consistency. So suppose f and g are formulas such that {f, g}\u2286 Thm(L, \u03b1,S). By strong 1-consistency, both Fact(S)\u222a{f} and Fact(S)\u222a{g} should be satisfiable. If Fact(S)\u222a{f, g} is unsatisfiable then Fact(S)\u222a{g} |= \u00acf . If f and g are contingent then the strong right weakening property is reasonable, and so we should expect that \u00acf \u2208Thm(L, \u03b1,S). Thus we have {f,\u00acf}\u2286Thm(L, \u03b1,S). But, a reasonable property of \u2018likely\u2019 is that for any formula f , at most one of f and \u00acf is likely. Therefore we should not have {f,\u00acf} \u2286 Thm(L, \u03b1,S). This unsatisfactory situation can be avoided if\nFact(S)\u222a{f, g} is satisfiable. So plausible proof algorithms should be strongly 2-consistent. Hence Principle 3.7.2 below.\nConsider the 3-lottery example (Example 3.1) and let U = {\u00acs1,\u00acs2, \u2228 {s1, s2}}. For each x in U , x is likely; and \u00acx is not likely. But U is (classically) unsatisfiable. The set U shows the necessity of Principle 3.7.3 below.\nPrinciple 3.7 (Consistency).\n3.7.1) The 1-Consistency Principle. A plausible proof algorithm must be 1-consistent. 3.7.2) The Strong 2-Consistency Principle. A plausible proof algorithm should be strongly 2-consistent. 3.7.3) The Non-3-Consistency Principle. A plausible proof algorithm that can prove disjunctions must not be 3-consistent."}, {"heading": "3.8 Multiple Intuitions: Ambiguity", "text": "With the possible exception of tautologies, classical propositional logic captures our intuition about what follows from a satisfiable set of facts. But there are different wellinformed intuitions about what follows from a plausible-reasoning situation. For example, as early as 1987 (Section 4.1 of (Touretzky, Horty, & Thomason, 1987)) it was recognised that a plausible-reasoning situation could elicit different sensible conclusions, depending on whether ambiguity was blocked or propagated. The essence of Figure 3 in (Touretzky et al., 1987) is our third signpost example.\nExample 3.3 (The Ambiguity Puzzle).\n1) There is evidence that a is likely. 2) There is evidence that \u00aca is likely. 3) There is evidence that b is likely. 4) If a then \u00acb is likely.\nWhat can be concluded about b? The evidence for b is (3). The evidence against b comes from (1) and (4). If we knew that a was definitely true then the evidence for b and against b would be equal. Ignoring (2), a is only likely by (1), so the evidence against b is weaker than the evidence for b. But (2) means that a is even less likely, and so the evidence against b has been further weakened. Thus b is more likely than \u00acb. Hence many people think that it is reasonable to be able to conclude b. Such reasoning might be called \u2018best bet\u2019 or \u2018most likely\u2019 or \u2018balance of probabilities\u2019 reasoning.\nA formula f is said to be ambiguous iff there is evidence for f and there is evidence against f and neither f nor \u00acf can be proved. Since (1) and (2) give equal evidence for and against a, a is ambiguous.\nIf the evidence against b has been weakened sufficiently to allow b to be concluded, then b is not ambiguous. So the ambiguity of a has been blocked from propagating to b. An algorithm that can prove b (but not \u00acb) is said to be ambiguity blocking. This level of reasoning is appropriate if the benefit of being right outweighs the penalty for being wrong.\nIf the evidence against b has not been weakened sufficiently to allow b to be concluded, then b is ambiguous. So the ambiguity of a has been propagated to b. An algorithm that\ncannot prove b (or \u00acb) is said to be ambiguity propagating. This more cautious level of reasoning is appropriate if the penalty for being wrong outweighs the benefit of being right.\nIt is well-known that the Anglo-American legal system uses a hierarchy of proof levels, two of which are the \u2018balance of probabilities\u2019 or \u2018preponderance of the evidence\u2019 (used in civil cases) which is ambiguity blocking, and \u2018beyond reasonable doubt\u2019 (used in criminal cases) which is ambiguity propagating. So there is a need for a proof algorithm that blocks ambiguity and one that propagates ambiguity.\nTo avoid confusion, one should know which algorithm is used; unless it is irrelevant to the point being made. This, and our observation at the beginning of this section that a logic for plausible reasoning should have a factual proof algorithm, leads to our next principle.\nPrinciple 3.8 (The Many Proof Algorithms Principle). A logic for plausible reasoning should have at least 1) a factual proof algorithm, 2) an ambiguity blocking plausible proof algorithm, and 3) an ambiguity propagating plausible proof algorithm. Also, the proof algorithm used to prove a formula should be explicit or irrelevant.\nClearly the algorithms in (2) and (3) must be different. But, as indicated after Principle 3.1, the factual algorithm could be the same as a plausible algorithm."}, {"heading": "3.9 Decisiveness", "text": "For a formula, f , a proof algorithm, \u03b1, will satisfy exactly one of the following conditions. i) \u03b1 does not terminate. ii) \u03b1 terminates in a state indicating that f is proved, iii) \u03b1 terminates in a state indicating that f is not provable, iv) \u03b1 terminates in some other state. A proof algorithm \u03b1 is said to be decisive iff for every formula f , \u03b1 terminates in either a state indicating that f is proved, or a state indicating that f is not provable.\nOur next principle is clearly desirable.\nPrinciple 3.9 (The Decisiveness Principle). Factual and plausible proof algorithms should be decisive."}, {"heading": "3.10 Truth Values", "text": "Let us change our focus from deduction to the more semantic notion of assigning truth values to statements. For classical propositional logic there are exactly two truth values: T for true and F for false. If v is a valuation (that is a function from the set of formulas to the set of truth values) and f and g are formulas then 1) Either v(f) = T or v(\u00acf) = T but not both, (the Excluded Middle property) and 2) v( \u2227 {f, g}) = T iff v(f) = T = v(g), and 3) v( \u2228 {f, g}) = T iff v(f) = T or v(g) = T.\nThe 3-lottery example (Example 3.1) shows that the closest plausible reasoning can get to (2) and (3) is (4) and (5) below. 4) If v( \u2227 {f, g}) = T then v(f) = T = v(g). 5) If v(f) = T or v(g) = T then v( \u2228 {f, g}) = T.\nMoreover consider our fourth signpost example.\nExample 3.4 (The 4-lottery example). Consider a 4-lottery. Then we have the following.\n1) Exactly one element of {s1, s2, s3, s4} is true. 2) Each element of {s1, s2, s3, s4} is probably false. 3) The disjunction of any 2 of elements of {s1, s2, s3, s4} is not probably true and not\nprobably false. 4) The disjunction of any 3 elements of {s1, s2, s3, s4} is probably true.\nIntuitively some formulas concerning Example 3.4 have different truth values; for example \u2228 {s1, s2, s3, s4} is definitely true, \u00ac \u2228 {s1, s2, s3, s4} is definitely false, \u00acs1 is probably true, s1 is probably false, and \u2228 {s1, s2} is as likely to be true as false. So plausible reasoning appears to need at least 3 truth values: one indicating that a formula is more likely to be true than false, one indicating that a formula is as likely to be true as false, and one indicating that a formula is more likely to be false than true.\nHence our last principle of plausible reasoning.\nPrinciple 3.10 (The Included Middle Principle). A logic for plausible reasoning should have at least 3 truth values.\nBut what happens if we insist on there being exactly two truth values? Suppose a logic L for plausible reasoning has exactly 2 truth values, T and F. Also suppose that for any formulas f , g, and h, the following truth conditions hold.\nTC1) If f is more likely to be true than false then f and \u00acf have different truth values. TC2) If f is as likely to be true as false then f and \u00acf have the same truth value. TC3) The truth value of \u2228 {f, g, h} is T iff the truth value of at least one of f , g, or h is T. TC4) \u00ac \u2228 {f, g, h} and \u2227 {\u00acf,\u00acg,\u00ach} have the same truth value. TC5) The truth value of \u2227 {f, g, h} is T iff the truth value of each one of f , g, and h is T.\nNow apply L to Example 3.4. By TC1, for each i in {1, 2, 3}, si and \u00acsi have different truth values. By TC2, \u2228 {s1, s2, s3} and \u00ac \u2228 {s1, s2, s3} have the same truth value, which by TC4 is the same as \u2227 {\u00acs1,\u00acs2,\u00acs3}.\nIf the truth value of \u2228 {s1, s2, s3} is T then by TC3, for some i, the truth value of si is T; hence the truth value of \u00acsi is F and so by TC5 the truth value of \u2227 {\u00acs1,\u00acs2,\u00acs3} is F. On the other hand if the truth value of \u2228 {s1, s2, s3} is F then by TC3, for each i, the truth value of si is F; hence the truth value of each \u00acsi is T and so by TC5 the truth value of \u2227 {\u00acs1,\u00acs2,\u00acs3} is T.\nSo in both cases \u2228 {s1, s2, s3} and \u2227 {\u00acs1,\u00acs2,\u00acs3} have different truth values which\ncontradicts what we had before.\nThe conditions TC1, TC2, TC3, TC4, and TC5 are so closely related to the meaning of \u2018true\u2019, \u2018false\u2019, \u2018conjunction\u2019, \u2018disjunction\u2019, and \u2018negation\u2019, that it is hard to reject any of them. Therefore it seems that having only two truth values is an over-simplification."}, {"heading": "3.11 Correctness", "text": "A logic that satisfies all the previous principles could nonetheless have a fatal flaw. It could give an unsatisfactory answer to a particular example. Some examples may well have no set of answers that are generally agreed upon. But some examples do have a set of answers that are generally agreed upon. We might call these answers the correct answers. So it is tempting to state a principle of correctness similar to \u201cWhen correct answers exist, a logic must give all the correct answers, and no incorrect answers.\u201d.\nThe problem with such a principle is that it is impossible to show that any logic satisfies it. The most that can be done is to produce an counter-example that shows a logic fails the principle, or demonstrate that for a chosen set of examples the logic gets the correct answers. But there might exist a counter-example that shows the logic fails the principle of correctness.\nThus we shall refrain from trying to formally state a Correctness Principle."}, {"heading": "4. Some Non-Monotonic Logics", "text": "We shall consider the relationship between some (non-numeric) non-monotonic logics and the principles and examples of Section 3.\nThere are three well-known non-monotonic logics, namely Default Logic, Circumscription, and Autoepistemic Logic; see (Antoniou, 1997) for an introduction. Answer Set Programming (ASP) (Baral, 2003) is a well-known Knowledge Representation system.\nEach of the proof algorithms of these four well-known systems is conjunctive and so fails the Non-Conjunction Principle (Principle 3.3.1). Also for each of these four proof algorithms, the set of all provable formulas is either satisfiable or contains all formulas. So all four proof algorithms fail the Non-3-Consistency Principle (Principle 3.7.3). Hence none of these logics reasons correctly about the 3-lottery example (Example 3.1). Finally all four of these proof algorithms are ambiguity propagating but not ambiguity blocking. So each of these logics fails the Many Proof Algorithms Principle (Principle 3.8). Hence when ambiguity blocking is required \u2014 for instance in civil cases \u2014 these logics do not get the right answers.\nLogics that deal with only literals are incapable of the reasoning required by Example 3.1. Logics in this category include inheritance networks (Horty, Thomason, & Touretzky, 1990), the DeLP system of (Garcia & Simari, 2004), the ASPIC system mentioned in (Caminada & Amgoud, 2007), the logic in (Prakken & Sartor, 1997), Ordered logic (Geerts, Vermeir, & Nute, 1994), and most Defeasible Logics (Billington, 2008).\nPropositional Plausible Logic (PPL), which is defined in the next section, is a member of the family of Defeasible Logics. The only Defeasible Logics that deal with conjunction and disjunction, besides PPL, are the logic in (Billington & Rock, 2001), let\u2019s call it DL1, and the logic in (Billington, 2008), let\u2019s call it DL8. But the plausible proof algorithms of both DL1 and DL8 are conjunctive and so do not satisfy the Non-Conjunction Principle (Principle 3.3.1). Also the Decisiveness Principle (Principle 3.9) fails for the plausible proof algorithms that define the Defeasible Logics in: (Billington, 1993), (Billington & Rock, 2001), (Maier & Nute, 2006), (Billington, 2008), and (Billington, 2011). Since all Defeasible Logics apart from PPL are closely related to a Defeasible Logic in these five citations, all Defeasible Logics apart from PPL fail the Decisiveness Principle. So PPL is\nthe only Defeasible Logic that satisfies all the principles in Section 3. Also PPL is more expressive than previous Defeasible Logics because the non-strict rules in PPL use formulas whereas previous Defeasible Logics only used literals and clauses. This is significant because a finite set of clauses is very different to the conjunction of those clauses, see the 3-lottery example (Example 3.1).\nArgumentation systems, (Dung, 1995), are well-known non-monotonic reasoning systems that can use rules, for example ASPIC (Caminada & Amgoud, 2007) and ASPIC+ (Modgil & Prakken, 2013). Let E \u2208{admissible, complete, preferred, grounded, ideal, semi-stable, stable}. Then the semantics of ASPIC+ defined by intersecting all E-extensions is ambiguity propagating and so fails the Many Proof Algorithms Principle (Principle 3.8(2)).\nAn early argumentation system is given in (Simari & Loui, 1992) and it also is ambiguity propagating and so fails the Many Proof Algorithms Principle (Principle 3.8(2)). It also has other problems mentioned in (Geerts, Laenens, & Vermier, 1998).\nThree postulates that a rule-based argumentation system should satisfy are given in (Caminada & Amgoud, 2007). Postulate 1 is closure under strict rules; that is Modus Ponens for strict rules (Theorem 7.3(3)). It is a kind of right weakening property (Subsection 3.6). Postulate 2 requires the set of all proved literals to be consistent. If only literals can be proved, as in (Caminada & Amgoud, 2007), then this is implied by the Strong 2-Consistency Principle (Principle 2). Postulates 1 and 2 jointly imply Postulate 3.\nIt is not surprising that Conditional Logics (Nute & Cross, 2001; Arlo-Costa & Egre\u0301, 2016) have been used to analyse non-monotonic reasoning. Let 99K denote a weak conditional; so that for formulas f and g, f 99K g means \u2018if f then ... g\u2019 where \u2018...\u2019 could be \u2018normally\u2019, \u2018typically\u2019, \u2018probably\u2019, or any other similar word or phrase. A set of such weak conditionals is called a \u2018conditional knowledge base\u2019. The following two rules are particularly important for differentiating our plausible reasoning from other kinds of reasoning. And: If f 99K g and f 99K h then f 99K \u2227 {g, h}. Or: If f 99K h and g 99K h then \u2228 {f, g} 99K h.\nThe And-rule is also called the CC-rule, and the Or-rule is also called the CA-rule.\nLet Ax3 = \u2227 { \u2228 {s1, s2, s3}, \u00ac \u2227 {s1, s2}, \u00ac \u2227 {s1, s3}, \u00ac \u2227 {s2, s3}} be the formula that characterises the 3-lottery example, Example 3.1(1) As noted in Subsection 3.3, we have Ax3 99K \u00acs1 and Ax3 99K \u00acs2 but not Ax3 99K \u2227 {\u00acs1,\u00acs2}. So reasoning systems that satisfy the And-rule do not do plausible reasoning.\nThe formula, Ax7, that characterises a 7-lottery is the conjunction of the following 22 formulas: \u2228 {s1, s2, s3, s4, s5, s6, s7} and \u00ac\n\u2227 {si, sj}, where 1 \u2264 i < j \u2264 7. Let f be\u2227\n{Ax7,\u00acs1,\u00acs2}, let g be \u2227 {Ax7,\u00acs3,\u00acs4}, and let h be \u2228 {s5, s6, s7}. Then f is equivalent to exactly one of s3 or s4 or s5 or s6 or s7, and g is equivalent to exactly one of s1 or s2 or s5 or s6 or s7. So f 99K h and g 99K h. But \u2228 {f, g} does not restrict the selected number at all, and h is not the usual result of a 7-lottery. So we do not have \u2228 {f, g} 99K h. Therefore reasoning systems that satisfy the Or-rule do not do plausible reasoning.\nIn (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).\nGeffner and Pearl (Geffner & Pearl, 1992) define a logic called \u2018conditional entailment\u2019. The second paragraph on page 235 of (Geffner & Pearl, 1992) contains the following sentence. \u201cIn the propositional case, the only difference between conditional entailment and prioritized circumscription is the source of the priorities: while prioritized circumscription relies on the user, conditional entailment extracts the priorities from the knowledge base itself.\u201d As noted near the beginning of this section, circumscription fails the Non-Conjunction Principle (Principle 3.3.1), the Non-3-Consistency Principle (Principle 3.7.3), and the Many Proof Algorithms Principle (Principle 3.8). Hence conditional entailment also fails these principles.\nThe consequence function of (Makinson, 1988) and the cumulative conditional knowledge bases of (Kraus et al., 1990) satisfy both the And-rule and the Or-rule. Preferential conditional knowledge bases (Kraus et al., 1990) are cumulative. Rational conditional knowledge bases (Lehmann & Magidor, 1992) are preferential. Hence both the preferential and rational closure of a conditional knowledge base satisfies both the And-rule and the Or-rule; and so does not do the plausible reasoning we are trying to characterise.\nAs noted in (Delgrande, 2007) the following systems are \u2018essentially the same as\u2019 rational closure and hence do not do our plausible reasoning: System Z (Pearl, 1990), systems based on conditional logic (Crocco & Lamarre, 1992), on modal logic (Boutilier, 1994b), on possibilistic logic (Benferhat, Dubois, & Prade, 1992), and on conditional objects (Dubois & Prade, 1991).\nThe Propositional Typicality Logic (PTL) of (Booth, Meyer, & Varzinczak, 2013) and (Booth, Casini, Meyer, & Varzinczak, 2015) has several semantics. Each semantics is at least preferential and so satisfies both the And-rule and the Or-rule. Hence PTL does not do the plausible reasoning we are trying to characterise.\nThe conditional logic C of (Delgrande, 2007) does not satisfy the Plausible Right Weakening Principle (Principle 3.6). Also C and the extensions of C considered in (Delgrande, 2007) have only one proof algorithm and so fail the Many Proof Algorithms Principle (Principle 3.8).\nApart from the problems mentioned in Section 5 of (Goldszmidt & Pearl, 1991), System Z (Pearl, 1990) and System Z+ (Goldszmidt & Pearl, 1991) are ambiguity propagating but not ambiguity blocking. Hence they fail the Many Proof Algorithms Principle (Principle 3.8). Moreover, although they can represent the 3-lottery example (Example 3.1), they cannot prove anything about the example because the set of rules is not \u2018consistent\u2019 as defined in (Pearl, 1990; Goldszmidt & Pearl, 1991).\nThe logic implemented by theorist (Poole, 1988) and the Preferred Subtheories logic in (Brewka, 1989) both generate consistent extensions and so fail the Non-3-Consistency Principle (Principle 3.7.3).\nEvery logic reviewed above fails at least one of the following principles: the NonConjunction Principle (Principle 3.3.1), the Non-3-Consistency Principle (Principle 3.7.3), the Many Proof Algorithms Principle (Principle 3.8), and the correctness principle as instanced by the 3-lottery example (Example 3.1). So these principles seem to be central to the difference between the plausible reasoning characterised in Section 3 and other kinds of non-numeric non-monotonic reasoning. As far as we know, Propositional Plausible Logic is the only non-numeric non-monotonic propositionally adequate logic that satisfies all the principles in Section 3."}, {"heading": "5. Propositional Plausible Logic (PPL)", "text": "The purpose of this section is to define a propositional logic, called Propositional Plausible Logic (PPL), that satisfies all the principles in Section 3. The plausible-structure used in PPL is defined in Subsection 5.1. The proof algorithms are defined in Subsection 5.2. The notions of \u2018proof\u2019 and \u2018truth\u2019 are developed in Subsection 5.3 and Subsection 5.4, respectively.\nAs well as the notation introduced in Section 2, we shall use the following notation concerning sequences. The empty sequence is denoted by (). Let S be a sequence. If S is finite then S+e denotes the sequence formed by just adding e onto the right end of S. Define e\u2208S to mean e is an element of S, and e /\u2208S to mean e is not an element of S."}, {"heading": "5.1 Plausible Descriptions", "text": "Propositional Plausible Logic (PPL) reasons about plausible-reasoning situations that may contain facts, like definitions and membership of categories. These facts are represented by formulas that are converted into clauses called axioms and these axioms are then converted into strict rules. The plausible information is represented by defeasible rules, warning rules, and a priority relation, >, on rules.\nIntuitively the various kinds of rules have the following meanings. The strict rule A\u2192c means if every formula in A is true then c is true. So strict rules are like material implication except that A is a finite set of formulas rather than a single formula. (We have already seen that A and \u2227 A behave differently.) For example, \u2018nautiluses are cephalopods\u2019 could be written as {n}\u2192c, and \u2018cephalopods are molluscs\u2019 could be written as {c}\u2192m. Roughly, the defeasible rule A\u21d2 c means if every formula in A is true then c is usually true. For example, \u2018molluscs usually have shells\u2019 could be written as {m} \u21d2 s, and \u2018cephalopods usually have no shells\u2019 could be written as {c}\u21d2\u00acs.\nThe warning rule A\u2740 c roughly means if every formula in A is true then c might be true. So A\u2740\u00acc warns against concluding usually c, but does not support usually \u00acc. For example, \u2018objects that look red in red light might not be red\u2019 could be written as {looks-redin-red-light}\u2740\u00acr. Warning rules can be used to prevent unwanted chaining. For example, suppose we have \u2018if a then usually b\u2019 ({a} \u21d2 b) and \u2018if b then usually c\u2019 ({b}\u21d2 c). Then it may be too risky to conclude \u2018usually c\u2019 from a. Without introducing evidence for \u00acc, the conclusion of \u2018usually c\u2019 from a can be prevented by the warning rule {a}\u2740 \u00acc. An instance of this example can be created by letting a be x \u2208 {1, 2, 3, 4}, b be x \u2208 {2, 3, 4}, and c be x\u2208{3, 4, 5}. Warning rules have also been called \u2018defeaters\u2019 and \u2018interfering rules\u2019. The formal definition of a rule and its associated terms follows.\nDefinition 5.1. A rule, r, is any triple (A(r), arrow (r), c(r)) such that A(r), called the set of antecedents of r, is a finite (possibly empty) set of formulas; arrow (r)\u2208{\u2192,\u21d2,\u2740}; and c(r), called the consequent of r, depends on arrow (r). If arrow (r) is the strict arrow, \u2192, then c(r) is either a formula or the conjunction of a countable set of formulas, and r is written A(r) \u2192 c(r) and called a strict rule. If arrow (r) is the defeasible arrow, \u21d2, then c(r) is a formula, and r is written A(r) \u21d2 c(r) and called a defeasible rule. If arrow (r) is the warning arrow, \u2740, then c(r) is a formula, and r is written A(r) \u2740 c(r) and called a warning rule.\nA priority relation, >, on rules is used to indicate the more relevant of two rules. For instance, the specific rule \u2018cephalopods usually have no shells\u2019, ({c}\u21d2\u00acs), is more relevant than the general rule \u2018molluscs usually have shells\u2019, ({m}\u21d2 s), when reasoning about the external appearance of cephalopods. Hence {c}\u21d2\u00acs > {m}\u21d2 s. More generally, some common policies for defining > are the following. Prefer specific rules over general rules; prefer authoritative rules, (for instance national laws override state laws); prefer recent rules (because they are more up-to-date); and prefer more reliable rules. If r and s are rules and r > s then we often say r is superior to s and s is inferior to r.\nAlthough the priority relation does not have to be transitive, it does have to be acyclic.\nDefinition 5.2. Let R be any set of rules. A binary relation, >, on R is cyclic iff there exists a finite sequence, (r1, r2, ..., rn) where n \u2265 1, of elements of R such that r1 > r2 > ... > rn > r1; that is, rn > r1 and for all i in [1 .. n\u22121], ri > ri+1. A binary relation, >, is acyclic iff it is not cyclic.\nLet us now consider the conversion of the facts of a plausible-reasoning situation represented by a set F of formulas into strict rules. First we form Claus(F ) which is the set of clauses formed from F . Next we generate the set of axioms, Ax by defining Ax = CorRes(Sat(Claus(F ))). Finally we convert a contingent clause with n literals into 2n\u22121 strict rules. The conversion is done by the function Rul(.) in the usual way as shown by the following example. Rul( \u2228 {a, b, c}) = { {}\u2192 \u2228 {a, b, c}, { \u2227 {\u00acb,\u00acc}}\u2192a, { \u2227 {\u00aca,\u00acc}}\u2192b, { \u2227 {\u00aca,\u00acb}}\u2192c, {\u00aca}\u2192 \u2228 {b, c}, {\u00acb}\u2192 \u2228 {a, c}, {\u00acc}\u2192 \u2228 {a, b} }.\nThe full definition of Rul(.) and Rul(., .), as well as some useful notation, is given in the next definition.\nDefinition 5.3. Let R be a set of rules, F be a finite set of formulas, and C be a set of contingent clauses. 1) Rs is the set of strict rules in R. That is, Rs = {r\u2208R : r is a strict rule}. 2) Rd is the set of defeasible rules in R. That is, Rd = {r\u2208R : r is a defeasible rule}. 3) c(R) is the set of consequents of the rules in R. That is, c(R) = {c(r) : r\u2208R}. 4) If c\u2208C then Rul(c) = { {}\u2192c} \u222a { { \u2227 \u223c(L\u2212K)} \u2192 \u2228 K : c = \u2228 L and {}\u2282K\u2282L}. 5) Rul(C) = \u22c3 {Rul(c) : c\u2208C}. 6) Rul(C,F ) is the set of rules in Rul(C) whose set of antecedents is F . That is, Rul(C,F ) = {r\u2208Rul(C) : A(r) = F}.\nWe note that the set of antecedents of any strict rule formed by Rul(.) has at most one element.\nAlthough Rul(Ax ) gives us the strict rules that characterise the set F of facts we started with, we can reduce the number of these strict rules by \u2018anding\u2019 all those that have the same antecedent. For example, the \u2018anding\u2019 of {a}\u2192c1, {a}\u2192c2, and {a}\u2192c3 is {a}\u2192\u2227 {c1, c2, c3}. We now have the set of strict rules that we want. This set is formally defined by PD2 below. The formal structure used for describing plausible-reasoning situations is called a plausible description and is defined below.\nDefinition 5.4. If R is a set of rules then (R,>) is a plausible description iff PD1, PD2, PD3, and PD4 all hold.\nPD1) There is a set F of formulas such that Ax (R) = CorRes(Sat(Claus(F ))). Ax(R) is called the set of axioms of R and is usually denoted by Ax . PD2) Rs = {A\u2192 smp( \u2227 c(Rul(Ax , A))) : A\u2208{A(r) : r\u2208Rul(Ax )}}. PD3) If Ax 6={} then r denotes the strict rule {} \u2192 \u2227 Ax . PD4) > is a priority relation on R; that is, > \u2286 R\u00d7(R\u2212{r}) and > is not cyclic.\nSuppose (R,>) is a plausible description. Then Ax is empty iff Rs is empty. If Ax 6={} then r\u2208Rs. If Rs is not empty we can extract Ax from the consequent of r. This shows that Ax (R) is indeed dependent on R. Different strict rules in R have different sets of antecedents, and no rule is superior (>) to r.\nFor PPL the plausible-structure is a plausible description (R,>) and the factual part is Ax (R), which by PD2 is equivalent to the strict rules in R, Rs. The plausible part consists of the non-strict rules in R and the priority relation >.\nBy Lemma A.2(6) (See Appendix A) and PD1, Ax is satisfiable. So in PPL we extend the meaning of \u2018fact\u2019 from just being an element of Ax to a formula that is implied by Ax . Explicitly, a formula f is said to be a fact iff Ax |=f ."}, {"heading": "5.2 The Proof Relation and the Proof Algorithms", "text": "In this subsection we define what it means for a formula to be proved from a plausible description. We shall do this by defining a proof relation, |\u2212 , and various proof algorithms. This complex task will be done by giving the overall strategy, and then progressively refining this general plan until all the terms used have been defined.\nAny method of demonstrating that Ax |= f will do as an algorithm for proving facts; so there is no need to specify a particular one. Let our top level general plan for proving a formula be the following.\nDistinguish between proving facts and proving formulas that are not facts.\nLower case Greek letters will be used to denote the proof algorithms that will eventually be defined. A general proof algorithm will be denoted by \u03b1 (a for alpha and algorithm). We shall use \u03d5 (f for phi and fact) to denote our factual proof algorithm. Until a further refinement is needed we shall use the notation \u03b1 |\u2212f to denote that a formula f is proved by the proof algorithm \u03b1.\nSince facts are always true they are (at least) probably true. So we shall decree that facts are provable by all proof algorithms. Thus we have the following. All algorithms prove all facts. In symbols, if Ax |= f then \u03b1 |\u2212 f . The factual algorithm proves a formula iff it is a fact. In symbols, \u03d5 |\u2212 f iff Ax |= f .\nNow consider formulas f that are not facts, that is, Ax 6|= f . To (plausibly) prove f we need to do two things. First, establish some evidence for f . Second, defeat all the evidence against f . This will satisfy the requirements of the Evidence Principle, Principle 3.2.1. So our first refinement of the general plan is the following.\nRefinement 5.1. Suppose (R,>) is a plausible description, Ax = Ax (R), and f is a formula. 1) If Ax |= f then \u03b1 |\u2212 f . Also \u03d5 |\u2212 f iff Ax |= f . 2) If Ax 6|= f and \u03b1 6= \u03d5 then \u03b1 |\u2212 f iff (2.1) and (2.2) hold.\n2.1) Establish some evidence for f .\n2.2) Defeat all the evidence against f .\nIn accordance with the intuitive meaning of the three kinds of rules given at the beginning of this subsection, the evidence for f consists of strict or defeasible rules that have a consequent that implies f . However since the axioms are always true, we can weaken this to requiring that Ax\u222a{c(r)} implies f , provided that Ax\u222a{c(r)} is satisfiable. So if R\u2032\u2286R it will be convenient to let R\u2032[f ] = {r\u2208R\u2032 : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f}. In the case of Refinement 5.1(2.1) we have Ax 6|= f and so r cannot support f . Hence the following notation is convenient. Rsd = (Rs\u222aRd)\u2212 {r}. So the evidence for f is all the rules in R that support f , that is Rsd[f ]. To establish some evidence for f we must prove the set of antecedents of a rule supporting f . So we need to find a rule r in Rsd[f ] and prove A(r).\nBut A(r) is a set of formulas, not a formula. By proving a finite set F of formulas we shall mean proving every formula in F . In symbols, \u03b1 |\u2212F iff \u2200f \u2208F , \u03b1 |\u2212 f . So if F is empty we have \u03b1 |\u2212 {}.\nCollecting these ideas together gives our next refinement.\nRefinement 5.2. Suppose (R,>) is a plausible description, Ax = Ax (R), and f is a formula. 1) If F is a finite set of formulas then \u03b1 |\u2212F iff \u2200f \u2208F , \u03b1 |\u2212 f . 2) If Ax |= f then \u03b1 |\u2212 f . Also \u03d5 |\u2212 f iff Ax |= f . 3) If Ax 6|= f and \u03b1 6= \u03d5 then \u03b1 |\u2212 f iff \u2203r\u2208Rsd[f ] such that (3.1) and (3.2) hold.\n3.1) \u03b1 |\u2212A(r). 3.2) Defeat all the evidence against f .\nEach rule whose consequent implies \u00acf is evidence against f . The set of such rules is R[\u00acf ]. In Refinement 5.2(3) we have a rule r in Rsd[f ]. So any rule in R[\u00acf ] that is inferior to r has already been defeated by r and hence need not be explicitly considered. This reduces the set of evidence against f that must be considered to the set of rules in R[\u00acf ] that are not inferior to r; in symbols, {s\u2208R[\u00acf ] : s 6< r}.\nA rule s in {s\u2208R[\u00acf ] : s 6< r} is defeated either by team defeat or by disabling s. The team of rules for f is Rsd[f ]. The rule s is defeated by team defeat iff there is a rule t in the team of rules for f , Rsd[f ], such that t is superior to s, t > s, and the set of antecedents of t, A(t), is proved \u03b1 |\u2212A(t). So if R\u2032\u2286R it will be convenient to let R\u2032[f ; s] denote the set of all rules in R\u2032[f ] that are superior to s. In symbols, R\u2032[f ; s] = {t\u2208R\u2032[f ] : t > s}. Alternatively s is disabled iff the set of antecedents of s, A(s), cannot be proved, \u03b1 6|\u2212A(s).\nThree notations for useful sets of rules have been introduced, so their formal definition is appropriate before our third refinement.\nDefinition 5.5. Suppose (R,>) is a plausible description, Ax = Ax (R), R\u2032\u2286R, f is a formula, and s\u2208R. 1) Rsd = (Rs\u222aRd)\u2212 {r}. 2) R\u2032[f ] = {r\u2208R\u2032 : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f}. 3) R\u2032[f ; s] = {t\u2208R\u2032[f ] : t > s}.\nRefinement 5.3. Suppose (R,>) is a plausible description, Ax = Ax (R), and f is a formula. 1) If F is a finite set of formulas then \u03b1 |\u2212F iff \u2200f \u2208F , \u03b1 |\u2212 f . 2) If Ax |= f then \u03b1 |\u2212 f . Also \u03d5 |\u2212 f iff Ax |= f . 3) If Ax 6|= f and \u03b1 6= \u03d5 then \u03b1 |\u2212 f iff \u2203r\u2208Rsd[f ] such that (3.1) and (3.2) hold.\n3.1) \u03b1 |\u2212A(r). 3.2) \u2200s\u2208{s\u2208R[\u00acf ] : s 6< r} either\n3.2.1) \u2203t\u2208Rsd[f ; s] such that \u03b1 |\u2212A(t); or 3.2.2) \u03b1 6|\u2212A(s).\nRefinement 5.3 has no undefined terms, but unfortunately it has two failings. There is only one plausible proof algorithm (denoted by \u03b1), and so the Many Proof Algorithms Principle, Principle 3.8, fails. Also, a proof may get into a loop, and hence the Decisiveness Principle, Principle 3.9, fails.\nBefore we consider looping, let us invent the other proof algorithms. The \u03b1 in Refinement 5.3(3.2.2) evaluates evidence against f ; and this need not be the same \u03b1 as in (3.1) and (3.2.1) which evaluates evidence for f . To avoid confusion let us call the \u03b1 in (3.2.2), \u03b1\u2032. Replacing \u03b1 by \u03b1\u2032 in (3.2.2) creates the need to decide what (\u03b1\u2032)\u2032 is. Let us simplify (\u03b1\u2032)\u2032 to \u03b1\u2032\u2032. Some obvious choices are: \u03b1\u2032\u2032 = \u03b1, or \u03b1\u2032\u2032 = \u03b1\u2032, or \u03b1\u2032\u2032 is some other proof algorithm. The third choice postpones and complicates the choice that must eventually be made. Experimentation shows that the second choice has some properties that we would rather avoid. So we let \u03b1\u2032\u2032 = \u03b1.\nAnother change that can be made is to the set {s \u2208 R[\u00acf ] : s 6< r} of rules that a proof algorithm regards as evidence against f . Let Foe(\u03b1, f, r) denote the set of rules that \u03b1 regards as the evidence against f that is not inferior to r.\nThese ideas gives us our fourth refinement.\nRefinement 5.4. Suppose (R,>) is a plausible description, Ax = Ax (R), and f is a formula. 1) If F is a finite set of formulas then \u03b1 |\u2212F iff \u2200f \u2208F , \u03b1 |\u2212 f . 2) If Ax |= f then \u03b1 |\u2212 f . Also \u03d5 |\u2212 f iff Ax |= f . 3) If Ax 6|= f and \u03b1 6= \u03d5 then \u03b1 |\u2212 f iff \u2203r\u2208Rsd[f ] such that (3.1) and (3.2) hold.\n3.1) \u03b1 |\u2212A(r). 3.2) \u2200s\u2208Foe(\u03b1, f, r) either\n3.2.1) \u2203t\u2208Rsd[f ; s] such that \u03b1 |\u2212A(t); or 3.2.2) \u03b1\u2032 6|\u2212A(s).\nLet us create our first non-factual proof algorithm, \u03b2, by changing Refinement 5.4 as little as possible. So let Foe(\u03b2, f, r) = {s\u2208R[\u00acf ] : s 6< r}. Let \u03b2 be defined by replacing each \u03b1 in Refinement 5.4 with \u03b2. Of course now \u03b2\u2032 must be defined. First let Foe(\u03b2\u2032, f, r) = {s\u2208R[\u00acf ] : s 6< r}. Then let \u03b2\u2032 be defined by replacing each \u03b1 in Refinement 5.4 with \u03b2\u2032. (Recall that \u03b2\u2032\u2032 = \u03b2.) Later we shall show that \u03b2 is ambiguity blocking (b for beta and blocking). We are not really concerned with any primed algorithm as they only assist with the definition of their non-primed co-algorithm. But later we shall show that \u03b2 and \u03b2\u2032 prove exactly the same formulas. So why is \u03b2\u2032 needed? Without \u03b2\u2032 it is exceedingly difficult to prove the relationship between \u03b2 and the other algorithms we are about to define.\nOur next algorithm, \u03c0, will be shown to be ambiguity propagating (p for pi and propagating). We want to make \u03c0 as strong as possible; that is, \u03c0 proves f if there is no evidence against f . This can be done by making its co-algorithm \u03c0\u2032 as weak as possible; that is, \u03c0\u2032 ignores all evidence against f ; hence Foe(\u03c0\u2032, f, r) = {}. This is the only change we make to Refinement 5.4. Explicitly, let Foe(\u03c0, f, r) = {s \u2208 R[\u00acf ] : s 6< r}. Let \u03c0 be defined by replacing each \u03b1 in Refinement 5.4 with \u03c0. Let \u03c0\u2032 be defined by replacing each \u03b1 in Refinement 5.4 with \u03c0\u2032. (Recall that \u03c0\u2032\u2032 = \u03c0.)\nOur last algorithm, \u03c8, will also be shown to be ambiguity propagating (p for psi and propagating). We want to make \u03c8 weaker than \u03c0. This can be done by making its coalgorithm \u03c8\u2032 regard those rules that imply \u00acf and are superior to r as evidence against f ; hence Foe(\u03c8\u2032, f, r) = {s\u2208R[\u00acf ] : s > r}. This is the only change we make to Refinement 5.4. Explicitly, let Foe(\u03c8, f, r) = {s\u2208R[\u00acf ] : s 6< r}. Let \u03c8 be defined by replacing each \u03b1 in Refinement 5.4 with \u03c8. Let \u03c8\u2032 be defined by replacing each \u03b1 in Refinement 5.4 with \u03c8\u2032. (Recall that \u03c8\u2032\u2032 = \u03c8.)\nTo emphasise that we are only interested in the non-primed proof algorithms we note that there are examples in which both \u03c0\u2032 and \u03c8\u2032 can prove both f and \u00acf . This is fine as both \u03c0\u2032 and \u03c8\u2032 only assess the evidence against f , rather than try to defeasibly justify accepting f , as the non-primed algorithms do.\nThe following two formal definitions collect together for easy reference the above notations concerning algorithms and Foe(., ., .).\nDefinition 5.6. Define the set, Alg, of names of the proof algorithms by Alg = {\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032, \u03c8\u2032, \u03c0\u2032}. Define \u03d5\u2032 = \u03d5. If \u03b1\u2208{\u03c0, \u03c8, \u03b2} then define (\u03b1\u2032)\u2032 = \u03b1\u2032\u2032 = \u03b1. If \u03b1\u2208Alg then the co-algorithm of \u03b1 is \u03b1\u2032.\nDefinition 5.7. Suppose (R,>) is a plausible description, f is a formula, and r\u2208R. 1) If \u03b1\u2208{\u03c0, \u03c8, \u03b2, \u03b2\u2032} and r 6= r then Foe(\u03b1, f, r) = {s\u2208R[\u00acf ] : s 6< r}. 2) If \u03b1\u2208{\u03d5, \u03c0\u2032} or r = r then Foe(\u03b1, f, r) = {}. 3) Foe(\u03c8\u2032, f, r) = {s\u2208R[\u00acf ] : s > r} = R[\u00acf ; r].\nFinally, let us consider looping. To prove f we use \u03b1 and a rule r. While proving f we may have to prove other formulas. During a proof of one of these other formulas, if we choose to use \u03b1 and r again then we will be in a loop and so this choice should fail. To prevent such a looping choice we need to record that \u03b1 and r have been used previously. We shall call such a record of used algorithms and rules a history. Its formal definition follows.\nDefinition 5.8. Suppose (R,>) is a plausible description and \u03b1\u2208Alg. Define \u03b1R = {\u03b1r : r\u2208R}. Then H is an \u03b1-history iff H is a finite sequence of elements of \u03b1R \u222a \u03b1\u2032R that has no repeated elements.\nUnfortunately using a history complicates Refinement 5.4 because we now no longer have just an algorithm proving a formula, but an algorithm and a history proving a formula. Therefore in (1), (2), and (3), \u03b1 |\u2212x becomes (\u03b1,H) |\u2212x. In (3.1) \u03b1 and r have now been used so H must be updated to H+\u03b1r and hence \u03b1 |\u2212A(r) becomes (\u03b1,H+\u03b1r) |\u2212A(r). Also in (3.2.1) \u03b1 and t have been used so H must be updated to H+\u03b1t and hence \u03b1 |\u2212A(t) becomes (\u03b1,H+\u03b1t) |\u2212A(t). Similarly in (3.2.2) \u03b1\u2032 and s have been used and so H must be updated to H+\u03b1\u2032s and hence \u03b1\u2032 6|\u2212A(s) becomes (\u03b1\u2032,H+\u03b1\u2032s) 6|\u2212A(s). Finally to prevent looping we must be sure that \u03b1r /\u2208H in (3.1), \u03b1t /\u2208H in (3.2.1), and \u03b1\u2032s /\u2208H in (3.2.2).\nIncorporating these changes into Refinement 5.4 gives our formal definition of the proof algorithms and proof relation |\u2212 . The letter I is attached to these final inference conditions.\nDefinition 5.9. Suppose P = (R,>) is a plausible description, Ax = Ax (R), \u03b1\u2208Alg , H is an \u03b1-history, and f is a formula. The proof relation for P, |\u2212 , and the proof algorithms are defined by I1 to I3. I1) If F is a finite set of formulas then (\u03b1,H) |\u2212F iff \u2200f \u2208F , (\u03b1,H) |\u2212 f . I2) If Ax |= f then (\u03b1,H) |\u2212 f . Also (\u03d5,H) |\u2212 f iff Ax |= f . I3) If Ax 6|= f and \u03b1 6= \u03d5 then (\u03b1,H) |\u2212 f iff \u2203r\u2208Rsd[f ] such that I3.1 and I3.2 hold.\nI3.1) \u03b1r /\u2208H and (\u03b1,H+\u03b1r) |\u2212A(r). I3.2) \u2200s\u2208Foe(\u03b1, f, r) either\nI3.2.1) \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and (\u03b1,H+\u03b1t) |\u2212A(t); or I3.2.2) \u03b1\u2032s /\u2208H and (\u03b1\u2032,H+\u03b1\u2032s) 6|\u2212A(s).\nThe following notation is useful.\nDefinition 5.10. If P is a plausible description, \u03b1\u2208Alg, and x is either a formula or a finite set of formulas then define x is \u03b1-provable iff \u03b1 |\u2212x iff (\u03b1, ()) |\u2212x, and P(\u03b1) = {f \u2208Fml : \u03b1 |\u2212 f} to be the set of all \u03b1-provable formulas."}, {"heading": "A semantic aside", "text": "Subsection 5.2, and its culmination in Definition 5.9, can be given a semantic interpretation. By Theorem 7.3(3), the meaning of the strict rule A\u2192f is that for any proof algorithm \u03b1, if \u03b1 |\u2212A then \u03b1 |\u2212 f . The meaning of the defeasible rule A\u21d2f is that for any non-factual proof algorithm \u03b1, if \u03b1 |\u2212A and the evidence against f is defeated then \u03b1 |\u2212 f . Exactly what the evidence against f is and how it is defeated is given by I3.2. By I3.2 the warning rule s = A\u2740\u00acf can only be used as evidence against f ; and exactly how s can be defeated is also given by I3.2. Thus Definition 5.9 can be seen as giving a meaning to each of the three kinds of rules.\nSimilarly Definition 5.9, and the explanations preceding it, can be seen as giving a meaning to each of the proof algorithms. By I2, we see that \u03d5 |\u2212 f means Ax |= f . Each of the non-factual proof algorithms, \u03b1, regards Rsd[f ] as the set of potential evidence for f ; and how \u03b1 establishes that there is actual evidence for f is given by I3.1. Given some actual evidence r for f , the set that \u03b1 regards as evidence against f is Foe(\u03b1, f, r). Exactly how this evidence can be defeated is given by I3.2."}, {"heading": "5.3 A Proof Theory", "text": "Definition 5.9 is recursive, however it can be iterated to yield a rooted tree \u2014 defined in Definition 5.13 \u2014 that could be regarded as the structure of a proof in PPL. The nodes of this tree will have special labels called tags which we now define.\nDefinition 5.11. Suppose (R,>) is a plausible description, \u03b1\u2208Alg , F is a finite set of formulas, H is an \u03b1-history, f is a formula, r\u2208Rsd[f ], s\u2208R[\u00acf ], and p is a node of a tree. The tag, t(p), of p is a triple t(p) = (Subj (p), op(p), pv (p)). The subject of p, Subj (p), has one of the following forms: (\u03b1,H,F ), \u2212(\u03b1\u2032,H, F ),\n(\u03b1,H, f), (\u03b1,H, f, r), or (\u03b1,H, f, r, s). The operation of p, op(p), is either min (for minimum), max (for maximum), or \u2212. If op(p) is min [resp. max, \u2212] then p is referred to as a min [resp. max, minus] node. The proof value of p, pv(p), is either +1 or \u22121.\nThe arithmetic properties of the proof values are defined below. These are as expected, but note that max{} = \u22121 and min{} = +1.\nDefinition 5.12. Suppose S\u2286{+1,\u22121}. 1) minS = \u22121 iff \u22121\u2208S. (3) maxS = +1 iff +1\u2208S. (5) \u2212\u22121 = +1. 2) minS = +1 iff \u22121 /\u2208S. (4) maxS = \u22121 iff +1 /\u2208S. (6) \u2212+1 = \u22121.\nSo min and max act like quantifiers when applied to a set of proof values. That is, minS = \u22121 iff there exists v in S such that v = \u22121; maxS = +1 iff there exists v in S such that v = +1; minS = +1 iff for all v in S, v = +1; and maxS = \u22121 iff for all v in S, v = \u22121.\nDefinition 5.13. Let P = (R,>) be a plausible description. Then T is an evaluation tree of P iff T is a rooted tree constructed as follows. Each node, p, of T has exactly one tag, t(p). For each node p of T there is exactly one number, #p, in [1..6] such that p satisfies T#p and T7. T1) Subj (p) = (\u03b1,H,F ), \u03b1\u2208Alg , H is an \u03b1-history, and F is a finite set of formulas.\nDefine S(p) = {(\u03b1,H, f) : f \u2208F}. Then op(p) = min, p has |S(p)| children, and each element of S(p) is the subject of exactly one child of p. If S(p) = {} then pv(p) = +1.\nT2) Subj (p) = (\u03b1,H, f), \u03b1\u2208Alg , H is an \u03b1-history, f is a formula, and Ax |= f . Then p has no children and t(p) = ((\u03b1,H, f),min,+1). T3) Subj (p) = (\u03b1,H, f), \u03b1 \u2208 Alg\u2212{\u03d5}, H is an \u03b1-history, f is a formula, and Ax 6|= f . Define S(p) = {(\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]}. Then op(p) = max, p has |S(p)| children, and each element of S(p) is the subject of exactly one child of p. If S(p) = {} then pv(p) = \u22121. T4) Subj (p) = (\u03b1,H, f, r), \u03b1 \u2208 Alg\u2212{\u03d5}, H is an \u03b1-history, f is a formula, Ax 6|= f , \u03b1r /\u2208H, and r\u2208Rsd[f ]. Define S(p) = {(\u03b1,H+\u03b1r,A(r))} \u222a {(\u03b1,H, f, r, s) : s\u2208Foe(\u03b1, f, r)}. Then op(p) = min, p has |S(p)| children, and each element of S(p) is the subject of exactly one child of p. T5) Subj (p) = (\u03b1,H, f, r, s), \u03b1 \u2208 Alg\u2212{\u03d5, \u03c0\u2032}, H is an \u03b1-history, f is a formula, Ax 6|= f , \u03b1r /\u2208H, r\u2208Rsd[f ], and s\u2208Foe(\u03b1, f, r). Define S(p) = {(\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]} \u222a {\u2212(\u03b1\n\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}. Then op(p) = max, p has |S(p)| children, and each element of S(p) is the subject of exactly one child of p. If S(p) = {} then pv(p) = \u22121.\nT6) Subj (p) = \u2212(\u03b1\u2032,H, F ), \u03b1 \u2208 {\u03c0, \u03c8, \u03b2, \u03b2\u2032}\u222a{\u03c8\u2032 : > is not empty}, H is an \u03b1-history, and F is a finite set of formulas. Then op(p) = \u2212; p has exactly one child, say p1; and Subj (p1) = (\u03b1\n\u2032,H, F ). T7) If op(p) = min then pv(p) = min{pv(c) : c is a child of p}.\nIf op(p) = max then pv(p) = max{pv (c) : c is a child of p}. If op(p) = \u2212 and c is the child of p then pv(p) = \u2212pv(c).\nIt is possible for an evaluation tree to be infinite. Although this can be prevented by insisting that the set of rules in a plausible description is finite, it is not necessary.\nDefinition 5.14. A plausible description P is a plausible theory iff every evaluation tree of P is finite. A Propositional Plausible Logic consists of a plausible theory and its proof relation.\nBoth the proof relation |\u2212 and evaluation trees are cumbersome to use for derivations by hand. So we shall define a proof function P , which is easier to use and is a straightforward translation of the proof relation |\u2212 of Definition 5.9 into the function P such that (\u03b1,H) |\u2212x iff P (\u03b1,H, x) = +1 and (\u03b1,H) 6|\u2212x iff P (\u03b1,H, x) = \u22121. The auxiliary functions: For (evidence for), and Dftd (defeated), are used in the definition of P .\nDefinition 5.15. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg , H is an \u03b1-history, and f is a formula. The proof function for P, P , and its auxiliary functions For and Dftd are defined by P1 to P5. P1) If F is a finite set of formulas, then P (\u03b1,H,F ) = min{P (\u03b1,H, f) : f \u2208F}. P2) If Ax |= f then P (\u03b1,H, f) = +1. Also P (\u03d5,H, f) = +1 iff Ax |= f . P3) If Ax 6|= f and \u03b1 6= \u03d5 then P (\u03b1,H, f) = max{For (\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]}. P4) If Ax 6|= f and \u03b1 6= \u03d5 and \u03b1r /\u2208H and r\u2208Rsd[f ] then For (\u03b1,H, f, r) = min[{P (\u03b1,H+\u03b1r,A(r))} \u222a {Dftd(\u03b1,H, f, r, s) : s\u2208Foe(\u03b1, f, r)}]. P5) If Ax 6|= f and \u03b1 \u2208 Alg\u2212{\u03d5, \u03c0\u2032} and \u03b1r /\u2208H and r\u2208Rsd[f ] and s\u2208Foe(\u03b1, f, r) then\nDftd(\u03b1,H, f, r, s) = max[{P (\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]} \u222a {\u2212P (\u03b1\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}].\nWe end this subsection by stating the relationship between proof relations (Definition 5.9), evaluation trees (Definition 5.13), and proof functions (Definition 5.15). But before we can do this we need the following notation.\nDefinition 5.16. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg , H is an \u03b1-history, and x is either a formula or finite set of formulas. Let T [\u03b1,H, x] denote the evaluation tree of P whose root node has the subject (\u03b1,H, x). Let T (\u03b1,H, x) denote the proof value of the root node of T [\u03b1,H, x].\nTheorem 5.17 (Notational Equivalence). Suppose P is a plausible theory, \u03b1\u2208Alg , H is an \u03b1-history, and x is either a formula or a finite set of formulas. Then P (\u03b1,H, x) = +1 iff (\u03b1,H) |\u2212x iff T (\u03b1,H, x) = +1.\nThe idea of \u2018logical consequence\u2019 in PPL is defined and most easily understood by considering the proof relation |\u2212 of Definition 5.9. The evaluation trees of Definition 5.13 are mainly used to prove results about PPL. Proof functions (Definition 5.15) make hand evaluations easier. So the equivalences expressed in Theorem 5.17 are essential."}, {"heading": "5.4 A Truth Theory", "text": "Logics often have a function from the set of all formulas to a set of truth values such that (a) the truth value of a formula is related to its proof value, and\n(b) the truth value of a formula is related to the truth values of its parts. Subsection 3.10 deals with (b), while this subsection is concerned with (a).\nConsider the possibilities that could occur when the proof algorithm \u03b1 evaluates the evidence for and against the formula f . If there is sufficient evidence for both f and \u00acf then, as far as \u03b1 is concerned, f and \u00acf are ambiguous, and so both should be assigned the ambiguous truth value a. If there is sufficient evidence for f but insufficient evidence for \u00acf then, as far as \u03b1 is concerned, f is usually true and \u00acf is usually false, so f should be assigned the usually true truth value t and \u00acf should be assigned the usually false truth value f. If there is insufficient evidence for both f and \u00acf then \u03b1 does not know enough about f or about \u00acf , and so both should be assigned the undetermined truth value u.\nSince the truth value of a formula, f , depends on the proof algorithm, \u03b1, evaluating its evidence, we need a veracity (or truth) function V such that V (\u03b1, f) is in the set of plausible truth values {a, t, f,u}.\nDefinition 5.18. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg , and f is any formula. The truth function for P, V , from Alg\u00d7Fml to the set of plausible truth values {a, t, f,u} is defined by V1 to V4. V1) V (\u03b1, f) = a iff \u03b1 |\u2212 f and \u03b1 |\u2212\u00acf . V2) V (\u03b1, f) = t iff \u03b1 |\u2212 f and \u03b1 6|\u2212 \u00acf . V3) V (\u03b1, f) = f iff \u03b1 6|\u2212 f and \u03b1 |\u2212\u00acf . V4) V (\u03b1, f) = u iff \u03b1 6|\u2212 f and \u03b1 6|\u2212 \u00acf .\nNow that PPL is defined we need to show that it is well-behaved and satisfies all the principles in Section 3. But before we do that it is worthwhile to get a better understanding of the logic by applying it to some examples."}, {"heading": "6. Examples", "text": "We shall show how PPL represents and reasons with the first three signpost examples in Section 3. To save space and effort we shall use some of the theorems in Section 7; this will also illustrate some of the utility of these theorems. In some of the following examples we shall use the following equations denoted by \u2020 and \u2737. \u2020) P (\u03b1,H, {f}) = P (\u03b1,H, f), by P1. \u2737) P (\u03b1,H, {}) = min{} = +1, by P1."}, {"heading": "6.1 The Non-Monotonicity Example", "text": "Recall the following from Example 3.2. 1) a is probably true. 2) \u00aca is (definitely) true. We show that from (1) the conclusion is \u2018a is plausible\u2019; and from (1) and (2), that \u2018a is plausible\u2019 cannot be deduced, but \u2018\u00aca is true\u2019 can be.\nThe plausible theory (R,>) which models (1) is defined as follows. The priority relation > is empty, and R = {ra}, where ra is {}\u21d2a. So Rs = {} = Ax (R) = Ax , R[a] = {ra}, R[\u00aca] = {}. Also if l\u2208{a,\u00aca} and s\u2208R then R[l; s] = {}.\nEvaluation 6.1.1. \u03b1\u2208{\u03c0, \u03c8, \u03b2} and \u03b1 |\u2212 a\n1\u03b1) P (\u03b1, (), a) = For (\u03b1, (), a, ra), by P3 2\u03b1) = P (\u03b1, (\u03b1ra), {}), by P4, and Foe(\u03b1, a, ra) = {} 3\u03b1) = +1, by \u2737\nSome evaluations can be parameterised by the proof algorithm. The range of such a parameter is given after the number of the evaluation. If an evaluation proves or disproves something then this is given after the number of the evaluation.\nEvaluation 6.1.1 and Theorem 5.17(Notational Equivalence), shows that \u03c0, \u03c8, and \u03b2 can prove a using only (1).\nThe plausible theory (R,>) which models (1) and (2) is defined as follows. The priority relation > is empty, and R = {ra, r s na}, where ra is {}\u21d2 a, and r s na is {}\u2192\u00aca. Since Rs = {r s na}, Ax (R) = Ax = {\u00aca}. So by P2, if \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2} then P (\u03b1, (),\u00aca) = +1.\nHence using only (1) and (2), \u00aca is certain, and by Theorem 7.4(1)(Consistency), \u03c0, \u03c8, and \u03b2 cannot prove a."}, {"heading": "6.2 The Ambiguity Puzzle", "text": "We show that the \u03c0 and \u03c8 proof algorithms are ambiguity propagating and that the \u03b2 proof algorithm is ambiguity blocking.\nThe plausible theory (R,>) which models the Ambiguity Puzzle (Example 3.3) is defined as follows. The priority relation > is empty, and R = {ra, rna, rb, ranb}, where ra is {}\u21d2a, rna is {}\u21d2\u00aca, rb is {}\u21d2b, and ranb is {a}\u21d2\u00acb.\nSince Rs = {}, Ax (R) = Ax = {}. So R[a] = {ra}, R[b] = {rb}, R[\u00aca] = {rna}, and R[\u00acb] = {ranb}. If l\u2208{a,\u00aca, b,\u00acb} and s\u2208R then R[l; s] = {}.\nEvaluation 6.2.1. \u03b1\u2208{\u03c0, \u03c8, \u03b2} 1\u03b1) P (\u03b1, (), b) = For (\u03b1, (), b, rb), by P3 2\u03b1) = min{P (\u03b1, (\u03b1rb), {}), Dftd(\u03b1, (), b, rb, ranb)}, by P4 3\u03b1) = Dftd(\u03b1, (), b, rb, ranb), by \u2737 4\u03b1) = \u2212P (\u03b1\u2032, (\u03b1\u2032ranb), a), by P5, \u2020 5\u03b1) = \u2212For(\u03b1\u2032, (\u03b1\u2032ranb), a, ra), by P3\nEvaluation 6.2.2. \u03b1\u2208{\u03c0, \u03c8} and \u03b1 6|\u2212 b 5\u03b1) P (\u03b1, (), b) = \u2212For(\u03b1\u2032, (\u03b1\u2032ranb), a, ra), by Evaluation 6.2.1 6\u03b1) = \u2212P (\u03b1\u2032, (\u03b1\u2032ranb, \u03b1\n\u2032ra), {}), by P4 7\u03b1) = \u22121, by \u2737.\nEvaluation 6.2.3. \u03b2 |\u2212 b 5\u03b2) P (\u03b2, (), b) = \u2212For (\u03b2\u2032, (\u03b2\u2032ranb), a, ra), by Evaluation 6.2.1 6\u03b2) = \u2212min{P (\u03b2\u2032, (\u03b2\u2032ranb, \u03b2 \u2032ra), {}), Dftd(\u03b2 \u2032, (\u03b2\u2032ranb), a, ra, rna)}, by P4 7\u03b2) = \u2212Dftd(\u03b2\u2032, (\u03b2\u2032ranb), a, ra, rna), by \u2737 8\u03b2) = \u2212\u2212 P (\u03b2, (\u03b2\u2032ranb, \u03b2rna), {}), by P5 9\u03b2) = +1, by \u2737.\nBy Evaluation 6.2.2 and Theorems 5.17(Notational Equivalence) and 7.1(Decisiveness), \u03c0 and \u03c8 cannot prove b and so they are ambiguity propagating. By Evaluation 6.2.3 and Theorem 5.17(Notational Equivalence), \u03b2 proves b and so is ambiguity blocking."}, {"heading": "6.3 The 3-lottery Example", "text": "Recall the following from Example 3.1. 1) Exactly one element of {s1, s2, s3} is true. 2) Each element of {\u00acs1,\u00acs2,\u00acs3} is usually true. 3) The disjunction of any pair of elements of {s1, s2, s3} is usually true. From (2) we get r11 to r13 below. From (3) we get r14 to r16 below. From (1) we have\u2228 {s1, s2, s3}, \u00ac \u2227 {s1, s2}, \u00ac \u2227 {s1, s3}, and \u00ac \u2227 {s2, s3}. Converting these facts to clauses gives: Ax = { \u2228 {s1, s2, s3}, \u2228 {\u00acs1,\u00acs2}, \u2228 {\u00acs1,\u00acs3}, \u2228 {\u00acs2,\u00acs3}}.\nThe plausible theory (R,>) which models this situation is defined as follows. The priority relation > is empty, and R = {r1, r2, ..., r16}, where r1: {} \u2192 \u2227 Ax , r2: {\u00acs1} \u2192 \u2228 {s2, s3}, r5: { \u2227 {\u00acs2,\u00acs3}} \u2192 s1, r8: {s1} \u2192 \u2227 {\u00acs2,\u00acs3}, r3: {\u00acs2} \u2192 \u2228 {s1, s3}, r6: { \u2227 {\u00acs1,\u00acs3}} \u2192 s2, r9: {s2} \u2192 \u2227 {\u00acs1,\u00acs3}, r4: {\u00acs3} \u2192 \u2228 {s1, s2}, r7: { \u2227 {\u00acs1,\u00acs2}} \u2192 s3, r10: {s3} \u2192 \u2227 {\u00acs1,\u00acs2}, r11: {} \u21d2 \u00acs1, r14: {} \u21d2 \u2228 {s1, s2}, r12: {} \u21d2 \u00acs2, r15: {} \u21d2 \u2228 {s1, s3}, r13: {} \u21d2 \u00acs3, r16: {} \u21d2 \u2228 {s2, s3}.\nLet U = {\u00acs1,\u00acs2, \u2228 {s1, s2}}. If \u03b1\u2208{\u03c0, \u03c8, \u03b2} then we show \u03b1 proves each element of\nU , \u03b1 cannot prove the negation of each element of U , and \u03b1 cannot prove \u2227 {\u00acs1,\u00acs2}.\nNote Rsd[\u00acs1] = {r2, r6, r7, r9, r10, r11, r16}, and R s d[s1] = {r5, r8} = R s d[ \u2227 {\u00acs2,\u00acs3}].\nEvaluation 6.3.1. \u03c0 |\u2212\u00acs1 1) P (\u03c0, (),\u00acs1) = max{For (\u03c0, (),\u00acs1, ri) : i\u2208{2, 6, 7, 9, 10, 11, 16}}, by P3 2) For (\u03c0, (),\u00acs1, r11) = min{P (\u03c0, (\u03c0r11), {}), Dftd(\u03c0, (),\u00acs1, r11, r5),\nDftd(\u03c0, (),\u00acs1, r11, r8)}, by P4 3) = min{\u2212P (\u03c0\u2032, (\u03c0\u2032r5), \u2227 {\u00acs2,\u00acs3}), \u2212P (\u03c0\n\u2032, (\u03c0\u2032r8), s1)}, by \u2737, P5, \u2020 4) P (\u03c0\u2032, (\u03c0\u2032r5), \u2227 {\u00acs2,\u00acs3}) = For (\u03c0 \u2032, (\u03c0\u2032r5), \u2227 {\u00acs2,\u00acs3}, r8), by P3 5) = P (\u03c0\u2032, (\u03c0\u2032r5, \u03c0 \u2032r8), s1), by P4, \u2020 6) = max{}, by P3 7) = \u22121. 8) \u2234 For (\u03c0, (),\u00acs1, r11) = \u2212P (\u03c0\n\u2032, (\u03c0\u2032r8), s1), by (7) to (2) 9) = \u2212For(\u03c0\u2032, (\u03c0\u2032r8), s1, r5), by P3\n10) = \u2212P (\u03c0\u2032, (\u03c0\u2032r8, \u03c0 \u2032r5), \u2227 {\u00acs2,\u00acs3}), by P4, \u2020 11) = \u2212max{}, by P3 12) = +1. 13) \u2234 P (\u03c0, (),\u00acs1) = +1, by (12) to (8), and (1).\nBecause the 3-lottery example is symmetric in s1, s2, and s3, a very similar evaluation gives P (\u03c0, (),\u00acs2) = +1 and P (\u03c0, (),\u00acs3) = +1. Hence by \u2020, P (\u03c0, (), {\u00acs3}) = +1. By Theorem 5.17(Notational Equivalence), \u03c0 |\u2212\u00acs1, \u03c0 |\u2212\u00acs2, and \u03c0 |\u2212 {\u00acs3}. By Theorem 7.3(3)(Modus Ponens for strict rules), using r4, we get \u03c0 |\u2212 \u2228 {s1, s2}. Thus \u03c0 proves each element in U = {\u00acs1,\u00acs2, \u2228 {s1, s2}}.\nSuppose \u03b1\u2208{\u03c0, \u03c8, \u03b2}. Then by Theorem 7.6(The proof algorithm hierarchy), \u03b1 proves each element of U . By Theorem 7.4(1)(Consistency), the negation of each element of U cannot be proved by \u03b1. Hence by Theorem 7.3(2)(Right Weakening), \u03b1 cannot prove \u2227 {\u00acs1,\u00acs2}."}, {"heading": "7. Properties of Propositional Plausible Logic (PPL)", "text": "We shall show that PPL is well-behaved and satisfies all the principles in Section 3.\nTheorem 7.1 (Decisiveness). Suppose P is a plausible theory, \u03b1\u2208Alg, H is an \u03b1-history, and x is either a formula or a finite set of formulas. Then either T (\u03b1,H, x) = +1 or T (\u03b1,H, x) = \u22121, but not both.\nKnowing that every evaluation will terminate is very comforting. So at the end of each evaluation either we will have a proof or we will not. If we do not have a proof then maybe there is a proof but we missed it. Fortunately decisiveness assures us that an evaluation will always terminate, and when it does we will have either a proof or a disproof \u2014 that is a demonstration that there is no proof.\nTheorem 7.2 (Plausible Conjunction). Suppose (R,>) is a plausible description, Ax = Ax (R), \u03b1\u2208Alg, H is an \u03b1-history, and f and g are both formulas. If Ax |= f and (\u03b1,H) |\u2212 g then (\u03b1,H) |\u2212 \u2227 {f, g}.\nThe Plausible Conjunction theorem shows that each \u03b1 satisfies the Plausible Conjunction Principle (Principle 3.3.2).\nTheorem 7.3 (Right Weakening). Suppose (R,>) is a plausible description, Ax = Ax(R), \u03b1\u2208Alg , H is an \u03b1-history, and f and g are both formulas. 1) If (\u03b1,H) |\u2212 f and Ax\u222a{f} |= g then (\u03b1,H) |\u2212 g. [Strong Right Weakening] 2) If (\u03b1,H) |\u2212 f and f |= g then (\u03b1,H) |\u2212 g. [Right Weakening] 3) If A\u2192g \u2208 Rs and (\u03b1,H) |\u2212A then (\u03b1,H) |\u2212 g. [Modus Ponens for strict rules]\nTheorem 7.3(1) shows that \u03b1 has the strong right weakening property, and hence has all the right weakening properties mentioned in Subsection 3.6.\nTheorem 7.4 (Consistency). Suppose (R,>) is a plausible theory, Ax = Ax (R), \u03b1 \u2208 {\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032}, and both f and g are any formulas. 1) If \u03b1 |\u2212 f and \u03b1 |\u2212 g then Ax\u222a{f, g} is satisfiable. 2) If (\u03c8,H) |\u2212 f then (\u03c8\u2032,H) 6|\u2212 \u00acf . 3) Suppose that whenever s\u2208Rsd[\u00acf ] and (\u03c0\n\u2032,H+\u03c0\u2032s) |\u2212A(s) then Rsd[f ; s] = {}. If (\u03c0,H) |\u2212 f then (\u03c0\u2032,H) 6|\u2212 \u00acf .\nPart 1 of Theorem 7.4 says that PPL is strongly 2-consistent. Theorem 7.4(2) says that if there is sufficient evidence for \u03c8 to prove f then the evidence for \u00acf is too weak for \u03c8\u2032 to register. Theorem 7.4(3) gives conditions under which a similar statement can be said about \u03c0 and \u03c0\u2032. In particular when either Rsd[\u00acf ] or > is empty.\nTheorem 7.5 (Truth Values). Suppose (R,>) is a plausible theory, \u03b1\u2208Alg , F is a finite set of formulas, and f is a formula. 1) V (\u03b1,\u00ac\u00acf) = V (\u03b1, f). 2) V (\u03b1, f) = t iff V (\u03b1,\u00acf) = f. 3) V (\u03b1, f) = f iff V (\u03b1,\u00acf) = t. 4) V (\u03b1, f) = a iff V (\u03b1,\u00acf) = a. 5) V (\u03b1, f) = u iff V (\u03b1,\u00acf) = u.\n6) If V (\u03b1, \u2227 F ) = t then for each f in F , V (\u03b1, f) = t. 7) If f \u2208F and V (\u03b1, f) = t then V (\u03b1, \u2228 F ) = t. 8) If \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032} then V (\u03b1, f)\u2208{t, f,u}. 9) If V (\u03b1, f) = a then \u03b1\u2208{\u03c8\u2032, \u03c0\u2032}.\n10) If V (\u03b1, f) = t then \u03b1 |\u2212 f . (completeness) 11) If \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032} and \u03b1 |\u2212 f then V (\u03b1, f) = t. (soundness)\nParts 1 to 5 of Theorem 7.5 show that negation is truth-functional with desirable properties. In Subsection 3.10 the desired relation between the truth values of a conjunction and its conjuncts is given by statement (4), and the desired relation between the truth values of a disjunction and its disjuncts is given by statement (5). Parts 6 and 7 of Theorem 7.5 show that PPL satisfies these relationships.\nThe primed algorithms \u03b2\u2032, \u03c8\u2032, and \u03c0\u2032, assess the significance of evidence against a formula. Theorem 7.5(9) shows that the threshold of significance for \u03c8\u2032 and \u03c0\u2032 is so low that they can assess the evidence against both f and \u00acf as significant. However Theorem 7.5(8) shows that the other algorithms have a 3-valued truth system. The expected completeness and soundness results are given by parts 10 and 11 of Theorem 7.5.\nThe final result shows the relationships between the various proof algorithms. Recall Definition 5.10 defines P(\u03b1) to be the set of all formulas provable from P using the proof algorithm \u03b1.\nTheorem 7.6 (The proof algorithm hierarchy). Suppose P = (R,>) is a plausible theory. 1) P(\u03d5) \u2286 P(\u03c0) \u2286 P(\u03c8) \u2286 P(\u03b2) = P(\u03b2\u2032) \u2286 P(\u03c8\u2032) \u2286 P(\u03c0\u2032). 2) If > is empty then P(\u03d5) \u2286 P(\u03c0) = P(\u03c8) \u2286 P(\u03b2) = P(\u03b2\u2032) \u2286 P(\u03c8\u2032) = P(\u03c0\u2032).\nSo \u03b2\u2032 proves exactly the same formulas as \u03b2. Also if > is empty then \u03c0 and \u03c8 prove exactly the same formulas, as do \u03c0\u2032 and \u03c8\u2032. The set of formulas proved by \u03c0\u2032 is very similar to the union of all extensions of an extension based logic, like Default Logic.\nThe hierarchy shown in Theorem 7.6 is consistent with the intuition that ambiguity propagating proof algorithms are more cautious than ambiguity blocking algorithms. A similar hierarchy for a Defeasible Logic, also consistent with this intuition, is given in Section 5 of (Billington, Antoniou, Governatori, & Maher, 2010).\nWhen a logic has several proof algorithms it is important to determine how they relate, because this gives a greater theoretical understanding of the logic. Theorem 7.6 shows that the proof algorithms of PPL are totally ordered according to reliability or level of confidence. Suppose that the plausible-reasoning situation gives no information concerning whether ambiguity should be blocked or propagated. If the proof algorithm hierarchy is not totally ordered then we could have two incomparable algorithms only one of which proved the formula of interest. In such circumstances it is not clear what should be concluded. By Theorem 7.6 no such dilemma can occur in PPL.\nWe shall now check that PPL satisfies all the principles in Section 3.\nPPL has strict and defeasible rules, and so can distinguish between factual and plausible statements. Moreover PPL does not use numbers, like probabilities, that could lead to a proved formula being more precise than the information used to derive it. So the Representation Principle (Principle 3.1) is satisfied.\nThe correspondence between the general \u2018plausible-structure\u2019 notation of Sections 1 and 3 and the particular notation of PPL is as follows. The plausible-structure S corresponds to the plausible description P = (R,>). If we let Ax = Ax(R), then Fact(S) corresponds to Ax , Thm(Fact(S)) corresponds to {f : Ax |= f}, and Thm(L, \u03b1,S) corresponds to P(\u03b1). For the rest of this section suppose \u03b1 is in {\u03c0, \u03c8, \u03b2}.\nAs explained in the paragraph above Refinement 5.1, the Evidence Principle (Principle 3.2.1) is satisfied. In Subsection 6.1 we showed that \u03b1 satisfies the Non-Monotonicity Principle (Principle 3.2.2). Hence \u03b1 satisfies Principle 3.2.\nIn Subsection 6.3 we showed that all three elements of U = {\u00acs1,\u00acs2, \u2228 {s1, s2}} were \u03b1-provable; but that the conjunction \u2227 {\u00acs1,\u00acs2} was not \u03b1-provable. Thus \u03b1 satisfies the Non-Conjunction Principle (Principle 3.3.1). Theorem 7.2 shows that \u03b1 satisfies the Plausible Conjunction Principle (Principle 3.3.2). By Theorem 7.4(1), both s1 and s2 are not \u03b1-provable. Thus \u03b1 satisfies the Non-Disjunction Principle (Principle 3.4). Because U is not satisfiable \u03b1 satisfies the Non-3-Consistency Principle (Principle 3.7.3). Theorem 7.4(1) shows that \u03b1 satisfies the Strong 2-Consistency Principle (Principle 3.7.2) and so satisfies the 1-Consistency Principle (Principle 3.7.1).\nBy I2 of Definition 5.9, \u03d5 and \u03b1 are supraclassical. So by the remark after Principle 3.5, they satisfy the Plausible Supraclassicality Principle (Principle 3.5). Theorem 7.3(1) shows that \u03b1 has the Strong Right Weakening property. So by the remark after Principle 3.6, \u03b1 satisfies the Plausible Right Weakening Principle (Principle 3.6).\nBy I2 of Definition 5.9, \u03d5 is a factual proof algorithm. Subsection 6.2 shows that \u03c0 and \u03c8 are ambiguity propagating proof algorithms, and \u03b2 is an ambiguity blocking proof algorithm. Also PPL makes the proof algorithm used explicit. Hence PPL satisfies the Many Proof Algorithms Principle (Principle 3.8). Theorems 7.1 and 5.17 show that \u03d5 and \u03b1 satisfy the Decisiveness Principle (Principle 3.9). The truth-value system given in Subsection 5.4 and Theorem 7.5 shows that \u03b1 satisfies the Included Middle Principle (Principle 3.10).\nThus PPL satisfies all the principles in Section 3."}, {"heading": "8. Conclusion", "text": "We have tried to characterise those propositional logics that do plausible reasoning by suggesting some principles that such logics should satisfy. Four important examples of plausible reasoning are presented, and several principles are derived from these examples.\nPropositional Plausible Logic (PPL) has been defined. It satisfies all the principles, and deals with negation, conjunction, and disjunction. PPL has been applied to the first three examples, and several theorems about PPL are proved in the appendices. PPL has been implemented by George Wilson under the direction of Dr. Andrew Rock, who has implemented other Defeasible Logics. As far as we know, PPL is the only non-numeric non-monotonic logic that satisfies all the principles in Section 3 and also correctly reasons with all the examples in Section 3.\nFuture research could make PPL significantly more useful and powerful by incorporating variables in a similar way to the programming language Prolog.\nAcknowledgments\nThe author thanks Michael J. Maher for comments on an earlier version of this paper. The author also thanks Rene\u0301 Hexel for helpful discussions about the contents of Section 3 Principles of Plausible Reasoning."}, {"heading": "The Appendices", "text": ""}, {"heading": "Appendix A. Proof of Theorems 7.1 and 5.17", "text": "Lemma A.1. Let L and M be any two sets of literals. 1) \u2228 L |= \u2228 M iff either L\u2286M or \u2228 M is a tautology. 2) \u2227 M |= \u2227 L iff either L\u2286M or \u2227 M is a contradiction."}, {"heading": "Proof", "text": "Let L and M be any two sets of literals. (1) If L\u2286M or \u2228 M is a tautology then \u2228 L |= \u2228 M . Conversely suppose \u2228 L |= \u2228 M . If L\u2212M = {} then L \u2286M . So suppose there is a literal l such that l \u2208 L\u2212M . If \u2228 M is not a tautology then there is a valuation v such that v( \u2228 M) = F and v(l) = T. But that contradicts \u2228 L |= \u2228 M , so \u2228 M is must be a tautology.\n(2) If L\u2286M or \u2227 M is a contradiction then \u2227 M |= \u2227 L. Conversely suppose \u2227 M |= \u2227 L. If L\u2212M = {} then L \u2286M . So suppose there is a literal l such that l \u2208 L\u2212M . If \u2227 M is not a contradiction then there is a valuation v such that v( \u2227 M) = T and v(l) = F. But that contradicts \u2227 M |= \u2227 L, so \u2227 M is must be a contradiction."}, {"heading": "EndProofLemA.1", "text": "Lemma A.2. Let C be a set of clauses. 1) l\u2208Err(C) iff \u223cl\u2208Err(C). 2) Sat(C) \u2286 C. 3) \u2228 {} /\u2208 Sat(C). 4) \u2228 {} /\u2208 Res(Sat(C)). 5) C is satisfiable iff \u2228 {} /\u2208Res(C). 6) Sat(C) is satisfiable, Res(Sat(C)) is satisfiable, and CorRes(Sat(C)) is satisfiable."}, {"heading": "Proof", "text": "Let C be a set of clauses. (1, 2, 3) These parts follow immediately from Definition 2.8. (4) Assume \u2228 {} \u2208 Res(Sat(C)). Since \u2228 {} /\u2208 Sat(C), there is a literal l such that\n\u2228 {l}\u2208Res(Sat(C)) and \u2228 {\u223cl}\u2208Res(Sat(C)). Since Sat(C) \u2286 C, Res(Sat(C)) \u2286 Res(C). So \u2228 {l} \u2208 Res(C) and \u2228 {\u223cl} \u2208 Res(C). Hence l \u2208 Err(C) and \u223cl \u2208 Err(C). So by Definition 2.8, for all c in Sat(C), l /\u2208Lit(c). But \u2228 {l}\u2208Res(Sat(C)), so there exists c in Sat(C) such that l\u2208Lit(c). This contradiction shows that \u2228 {} /\u2208 Res(Sat(C)).\n(5) This is well known from classical propositional logic.\n(6) By parts (4) and (5) of this lemma, Sat(C) is satisfiable. Hence Res(Sat(C)) is satisfiable and so CorRes(Sat(C)) is satisfiable."}, {"heading": "EndProofLemA.2", "text": "We say that a set L of literals is contingent iff L is not empty and if a is any atom then {a,\u00aca} 6\u2286L.\nLemma A.3. Suppose (R,>) is a plausible description, Ax = Ax (R), \u03b1 \u2208Alg , H is an \u03b1-history, and f is a formula. 1) Ax is satisfiable. 2) Each axiom in Ax is contingent. 3) Each axiom in Ax is either a literal\nor \u2228 L where L is a finite set of literals such that |L|\u22652.\n4) If R[f ] 6= {} then Ax\u222a{f} is satisfiable and Ax 6|= \u00acf . 5) If (\u03b1,H) |\u2212 f then Ax\u222a{f} is satisfiable and Ax 6|= \u00acf ."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible description, Ax = Ax(R), \u03b1\u2208Alg, H is an \u03b1-history, and f is a formula.\n(1) By Definition 5.4(PD1), Ax = CorRes(Sat(Ax )). By Lemma A.2(6), CorRes(Sat(Ax )) is satisfiable. Hence Ax is satisfiable.\n(2) By the definitions, Ax = CorRes(Sat(Ax )) = SmpMinCtge(Res(Sat(Ax ))); so each axiom is either contingent or empty. But Ax is satisfiable, so each axiom is contingent.\n(3) This follows from part (2) and Ax = Smp(C) where C is a set of clauses. (4) Suppose R[f ] 6= {}. By Definition 5.5(2), there exists r in R such that Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f . Hence Ax\u222a{f} is satisfiable, and so Ax 6|= \u00acf . (5) Suppose (\u03b1,H) |\u2212 f . By Definition 5.9(I2,I3), either Ax |= f or Rsd[f ] 6= {}. If Ax |= f then by part (1), Ax\u222a{f} is satisfiable. If Rsd[f ] 6= {} then by part (4), Ax\u222a{f} is satisfiable. But Ax\u222a{f} is satisfiable implies Ax 6|= \u00acf ."}, {"heading": "EndProofLemA.3", "text": "Lemma A.4. Suppose (R,>) is a plausible description, and Ax = Ax (R). 1) If r\u2208Rs then either A(r) = {}; or A(r) = {l}, where l is a literal; or A(r) = { \u2227 L}, where |L|\u22652 and L is contingent. 2) If r\u2208Rs then Ax\u222aA(r) |= c(r). Proof\nSuppose (R,>) is a plausible description, and Ax = Ax(R). (1) By Lemma A.3(2), if \u2228 L\u2208Ax then \u2228 L is contingent and so L is contingent. Hence, if {}\u2282K\u2282L then L\u2212K is contingent. So \u223c(L\u2212K) is contingent. Therefore the result holds for all r in Rul(Ax ). So by Definition 5.4(PD2), the result holds for all r in Rs.\n(2) Take any r in Rul(Ax ), and suppose v is a valuation such that v(Ax\u222aA(r)) is the true truth value; that is, v |= Ax \u222aA(r). Then either r is {} \u2192 c where c \u2208Ax , or r is {smp( \u2227 \u223c(L\u2212K))}\u2192smp( \u2228 K), where {}\u2282K\u2282L and \u2228 L\u2208Ax . Now v |= c, so in the first case v |= c(r). In the second case v |= \u2228 L, and v |= \u2227 \u223c(L\u2212K). Then for all l \u2208 L\u2212K, v |= \u223cl and so v 6|= l. But L = K \u222a (L\u2212K). So v |= \u2228 (K \u222a (L\u2212K)) and hence v |= \u2228 K. Thus v |= c(r) in the second case too. So the lemma holds for all r in Rul(Ax ). Take any r0 in Rs\u2212Rul(Ax ), and suppose v |= Ax \u222aA(r0). Then r0 is A(r0) \u2192 \u2227 c(Rul(Ax , A(r0))). For each r in Rul(Ax , A(r0)), r is A(r0) \u2192 c(r). By the previous paragraph, v |= c(r). But this is true for every r in Rul(Ax , A(r0)) and so v |=\u2227 c(Rul(Ax , A(r0))). EndProofLemA.4\nLemma A.5. Suppose (R0, >) is a plausible description, Ax is its set of axioms, R\u2286R0, f and g are formulas, \u03b1\u2208Alg , and {r, s}\u2286R0.\n1) R[f ]\u2286R. 2) If R\u2032\u2286R then R\u2032[f ]\u2286R[f ]. 3) If f \u2261 g then R[f ] = R[g]. 4) If Ax |= f then R[ \u2227 {f, g}] = R[g] and Foe(\u03b1, \u2227 {f, g}, r) \u2286 Foe(\u03b1, g, r). 5) If Ax \u222a{f} |= g then (a) Ax \u222a{\u00acg} |= \u00acf , (b) R[f ] \u2286 R[g], (c) R[f ; s] \u2286 R[g; s], (d) R[\u00acg] \u2286 R[\u00acf ], (e) Foe(\u03b1, g, r) \u2286 Foe(\u03b1, f, r). 6) If Ax\u222a{f, g} is unsatisfiable then R[f ] \u2286 R[\u00acg] and R[g] \u2286 R[\u00acf ]."}, {"heading": "Proof", "text": "(1) By Definition 5.5(2), R[f ]\u2286R.\n(2) Suppose R\u2032\u2286R. Then R\u2032[f ] = {r\u2208R\u2032 : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f} \u2286 {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f} = R[f ].\n(3) Suppose f \u2261 g. By Definition 5.5(2), R[f ] = {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f} = {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= g} = R[g].\n(4) Suppose Ax |= f . By Definition 5.5(2), R[g] = {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= g} = {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f and Ax\u222a{c(r)} |= g} = {r\u2208R : Ax\u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= \u2227 {f, g}} = R[ \u2227 {f, g}].\nLet Claim 1 be: Foe(\u03b1, \u2227 {f, g}, r) \u2286 Foe(\u03b1, g, r).\nIf \u03b1\u2208{\u03d5, \u03c0\u2032} or r = r then Foe(\u03b1, \u2227 {f, g}, r) = {}. Hence Claim 1 holds.\nSuppose \u03b1 = \u03c8\u2032. Then Foe(\u03c8\u2032, \u2227 {f, g}, r) = {s\u2208R[\u00ac \u2227 {f, g}] : s > r} and Foe(\u03c8\u2032, g, r) =\n{s\u2208R[\u00acg] : s > r}. Take any s in Foe(\u03c8\u2032, \u2227 {f, g}, r). Then s\u2208R, Ax\u222a{c(s)} is satisfiable, Ax \u222a{c(s)} |= \u00ac \u2227 {f, g}, and s > r. But Ax |= f , so Ax \u222a{c(s)} |= \u00acg and therefore s\u2208Foe(\u03c8\u2032, g, r). Hence Claim 1 holds.\nSo suppose \u03b1 \u2208 {\u03c0, \u03c8, \u03b2, \u03b2\u2032} and r 6= r. Then Foe(\u03b1, \u2227 {f, g}, r) = {s \u2208R[\u00ac \u2227 {f, g}] : s 6< r} and Foe(\u03b1, g, r) = {s \u2208 R[\u00acg] : s 6< r}. Take any s in Foe(\u03b1, \u2227 {f, g}, r). Then s \u2208 R, Ax \u222a{c(s)} is satisfiable, Ax \u222a{c(s)} |= \u00ac \u2227 {f, g}, and s 6< r. But Ax |= f , so Ax\u222a{c(s)} |= \u00acg and therefore s\u2208Foe(\u03b1, g, r). Hence Claim 1 holds.\nThus Claim 1 is proved.\n(5) Suppose Ax \u222a{f} |= g. By Definition 5.5(2,3), R[f ] = {r \u2208 R : Ax \u222a{c(r)} is satisfiable and Ax\u222a{c(r)} |= f} and R[f ; s] = {t\u2208R[f ] : t > s}. (a) Every valuation satisfies exactly one of f or \u00acf . Hence Ax\u222a{\u00acg} |= \u00acf . (b) Take any r in R[f ]. Then Ax \u222a{c(r)} is satisfiable and Ax \u222a{c(r)} |= f . Hence Ax\u222a{c(r)} |= g and so r\u2208R[g]. Thus R[f ] \u2286 R[g]. (c) Take any t in R[f ; s]. Then t\u2208R[f ] and t > s. By part (b), t\u2208R[g] and so t\u2208R[g; s]. Thus R[f ; s] \u2286 R[g; s]. (d) This follows from parts (a) and (b). (e) This follows from parts (a) and (c).\n(6) Suppose Ax \u222a{f, g} is unsatisfiable. Take any r in R[f ]. Then Ax \u222a{c(r)} is satisfiable and Ax \u222a{c(r)} |= f . Hence Ax \u222a{c(r)} |= \u00acg. Therefore r \u2208 R[\u00acg] and so R[f ] \u2286 R[\u00acg]. By swapping f and g we get R[g] \u2286 R[\u00acf ]."}, {"heading": "EndProofLemA.5", "text": "We need to extend the notation introduced in Definition 5.16.\nDefinition A.6. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg, H is an \u03b1-history, F is a finite set of formulas, f is a formula, r\u2208Rsd[f ], and s\u2208R[\u00acf ]. 1) Let T [\u03b1,H,F ] be the evaluation tree of P whose root has the subject (\u03b1,H,F ); and let T (\u03b1,H,F ) be the proof value of the root of T [\u03b1,H,F ]. 2) Let T [\u03b1,H, f ] be the evaluation tree of P whose root has the subject (\u03b1,H, f); and let T (\u03b1,H, f) be the proof value of the root of T [\u03b1,H, f ]. 3) Let T [\u03b1,H, f, r] be the evaluation tree of P whose root has the subject (\u03b1,H, f, r); and let T (\u03b1,H, f, r) be the proof value of the root of T [\u03b1,H, f, r]. 4) Let T [\u03b1,H, f, r, s] be the evaluation tree of P whose root has the subject (\u03b1,H, f, r, s); and let T (\u03b1,H, f, r, s) be the proof value of the root of T [\u03b1,H, f, r, s]. 5) Let T [\u2212(\u03b1,H,F )] be the evaluation tree of P whose root has the subject \u2212(\u03b1,H,F ); and let T (\u2212(\u03b1,H,F )) be the proof value of the root of T [\u2212(\u03b1,H,F )].\nTheorem A.7 (Theorem 7.1 Decisiveness). Suppose P is a plausible theory, \u03b1\u2208Alg , H is an \u03b1-history, and x is either a formula or a finite set of formulas. 1) T [\u03b1,H, x] has finitely many nodes. 2) Either T (\u03b1,H, x) = +1 or T (\u03b1,H, x) = \u22121 but not both."}, {"heading": "Proof", "text": "(1) follows from Definition 5.14. (2) follows from part (1) of this lemma and Definition 5.13."}, {"heading": "EndProofThmA.7", "text": "Theorem A.8 (Theorem 5.17 Notational Equivalence). Suppose (R,>) is a plausible theory, \u03b1\u2208Alg , H is an \u03b1-history, F is a finite set of formulas, and f is a formula. 1) P (\u03b1,H,F ) = +1 iff (\u03b1,H) |\u2212F iff T (\u03b1,H,F ) = +1. 2) P (\u03b1,H, f) = +1 iff (\u03b1,H) |\u2212 f iff T (\u03b1,H, f) = +1. 3) Suppose Ax 6|= f and \u03b1 6= \u03d5 and \u03b1r /\u2208H and r\u2208Rsd[f ] and f is satisfiable.\nThen For (\u03b1,H, f, r) = +1 iff T (\u03b1,H, f, r) = +1 iff (\u03b1,H+\u03b1r) |\u2212A(r) and \u2200s\u2208Foe(\u03b1, f, r), Dftd(\u03b1,H, f, r, s) = +1.\n4) Suppose Ax 6|= f and \u03b1 \u2208 Alg\u2212{\u03d5, \u03c0\u2032} and \u03b1r /\u2208H and r\u2208Rsd[f ] and f is satisfiable and s\u2208Foe(\u03b1, f, r). Then Dftd(\u03b1,H, f, r, s) = +1 iff T (\u03b1,H, f, r, s) = +1 iff either \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and (\u03b1,H+\u03b1t) |\u2212A(t); or \u03b1\u2032s /\u2208H and (\u03b1\u2032,H+\u03b1\u2032s) 6|\u2212A(s)."}, {"heading": "Proof", "text": "Let P = (R,>) be a plausible theory. The proof is by induction on the number of nodes in an evaluation tree of P. Let p be the only node of an evaluation tree of P.\nIf p satisfies T1 then the subject of p is (\u03b1,H, {}) and the proof value of p is +1. So T (\u03b1,H, {}) = +1. By P1, P (\u03b1,H, {}) = min{} = +1. By I1, (\u03b1,H) |\u2212 {}.\nIf p satisfies T2 then the subject of p is (\u03b1,H, f) and the proof value of p is +1. So T (\u03b1,H, f) = +1. By P2, P (\u03b1,H, f) = +1. By I2, (\u03b1,H) |\u2212 f .\nIf p satisfies T3 then the subject of p is (\u03b1,H, f) and the proof value of p is \u22121. So T (\u03b1,H, f) = \u22121. Let S(p) = {(\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]}. By T3, S(p) is empty. By P3, P (\u03b1,H, f) = max{For (\u03b1,H, f, r) : (\u03b1,H, f, r)\u2208S(p)} = max{} = \u22121. Since S(p) is empty, for all r in Rsd[f ], \u03b1r\u2208H. Hence I3.1 fails and so (\u03b1,H) 6|\u2212 f .\nSince p has no children, p does not satisfy T4 or T6. If p satisfies T5 then the subject of p is (\u03b1,H, f, r, s) and the proof value of p is \u22121. So T (\u03b1,H, f, r, s) = \u22121. Let S(p) = {(\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208 H and t \u2208 Rsd[f ; s]} \u222a {\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}. Also let S\u2032 = {P (\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]} \u222a {\u2212P (\u03b1\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}. By T5, S(p) is empty, and so S\u2032 is also empty. By P5, Dftd(\u03b1,H, f, r, s) = maxS\u2032 = max{} = \u22121. Since S(p) = {}, we have for each t in Rsd[f ; s], \u03b1t\u2208H; and \u03b1\n\u2032s\u2208H. Hence the last characterisation of Dftd(\u03b1,H, f, r, s) = +1 in part (4) is false.\nThus the result holds for all evaluation trees of P that have only the root node. Take any positive integer n. We shall denote the following inductive hypothesis by IndHyp. Suppose the result holds for all evaluation trees of P that have less than n+1 nodes. Let T be an evaluation tree of P that has n+1 nodes and let p be the root of T . Then p has at least one child.\nIf p satisfies T1 then the subject of p is (\u03b1,H,F ). By T1, IndHyp, P1, and I1, T (\u03b1,H,F ) = +1 iff for all f in F , T (\u03b1,H, f) = +1\niff for all f in F , P (\u03b1,H, f) = +1 iff P (\u03b1,H,F ) = +1 iff for all f in F , (\u03b1,H) |\u2212 f iff (\u03b1,H) |\u2212F .\nSince p has a child, p does not satisfy T2. If p satisfies T3 then the subject of p is (\u03b1,H, f). Let S(p) = {(\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]}. By T3, IndHyp, P3, and I3, T (\u03b1,H, f) = +1 iff there exists (\u03b1,H, f, r) in S(p) such that T (\u03b1,H, f, r) = +1 iff there exists (\u03b1,H, f, r) in S(p) such that For (\u03b1,H, f, r) = +1 iff P (\u03b1,H, f) = +1. iff there exists (\u03b1,H, f, r) in S(p) such that For (\u03b1,H, f, r) = +1 iff there exists (\u03b1,H, f, r) in S(p) such that (\u03b1,H+\u03b1r) |\u2212A(r) and \u2200s \u2208 Foe(\u03b1, f, r),\nDftd(\u03b1,H, f, r, s) = +1 iff there exists (\u03b1,H, f, r) in S(p) such that (\u03b1,H+\u03b1r) |\u2212A(r) and \u2200s\u2208Foe(\u03b1, f, r),\neither \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and (\u03b1,H+\u03b1t) |\u2212A(t); or \u03b1\u2032s /\u2208H and (\u03b1\u2032,H+\u03b1\u2032s) 6|\u2212A(s)\niff \u2203r\u2208Rsd[f ] such that I3.1 and I3.2 iff (\u03b1,H) |\u2212 f .\nIf p satisfies T4 then the subject of p is (\u03b1,H, f, r). By T4, IndHyp, and P4, T (\u03b1,H, f, r) = +1 iff T (\u03b1,H+\u03b1r,A(r)) = +1 and \u2200s\u2208Foe(\u03b1, f, r), T (\u03b1,H, f, r, s) = +1 iff (\u03b1,H+\u03b1r) |\u2212A(r) and \u2200s\u2208Foe(\u03b1, f, r), Dftd(\u03b1,H, f, r, s) = +1 iff P (\u03b1,H+\u03b1r,A(r)) = +1 and \u2200s\u2208Foe(\u03b1, f, r), Dftd(\u03b1,H, f, r, s) = +1 iff For (\u03b1,H, f, r) = +1.\nIf p satisfies T5 then the subject of p is (\u03b1,H, f, r, s). By T5, IndHyp, T6, T7, and P5, T (\u03b1,H, f, r, s) = +1 iff either \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and T (\u03b1,H+\u03b1t,A(t)) = +1;\nor \u03b1\u2032s /\u2208H and T (\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))) = +1 iff either \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and P (\u03b1,H+\u03b1t,A(t)) = +1;\nor \u03b1\u2032s /\u2208H and T (\u03b1\u2032,H+\u03b1\u2032s,A(s)) = \u22121 iff either \u2203t\u2208Rsd[f ; s] such that \u03b1t /\u2208H and P (\u03b1,H+\u03b1t,A(t)) = +1;\nor \u03b1\u2032s /\u2208H and P (\u03b1\u2032,H+\u03b1\u2032s,A(s)) = \u22121\niff Dftd(\u03b1,H, f, r, s) = +1.\nIf p satisfies T6 then the subject of p is \u2212(\u03b1\u2032,H, F ). By T6, T7, and IndHyp, T (\u2212(\u03b1\u2032,H, F )) = +1 iff T (\u03b1\u2032,H, F ) = \u22121 iff P (\u03b1\u2032,H, F ) = \u22121 iff (\u03b1\u2032,H) 6|\u2212F .\nThus the theorem is proved by induction."}, {"heading": "EndProofThmA.8", "text": ""}, {"heading": "Appendix B. Proof of Theorems 7.2, 7.3, 7.4, and 7.5", "text": "Theorem B.1 (Theorem 7.2 Plausible Conjunction). Suppose (R,>) is a plausible description, Ax = Ax(R), \u03b1\u2208Alg, H is an \u03b1-history, and f and g are both formulas. If Ax |= f and (\u03b1,H) |\u2212 g then (\u03b1,H) |\u2212 \u2227 {f, g}."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible description, Ax = Ax(R), \u03b1\u2208Alg , H is an \u03b1-history, and f and g are both formulas. Further suppose that Ax |= f and (\u03b1,H) |\u2212 g. We shall use Definition 5.9. Since (\u03b1,H) |\u2212 g, by Definition 5.9(I3), there exists r in Rsd[g] such that I3.1 and I3.2 both hold. By Lemma A.5(4), there exists r in Rsd[ \u2227 {f, g}] such that I3.1 and I3.2 both hold. Thus (\u03b1,H) |\u2212 \u2227 {f, g}."}, {"heading": "EndProofTheoremB.1", "text": "Theorem B.2 (Theorem 7.3 Right Weakening). Suppose (R,>) is a plausible description, Ax = Ax (R), \u03b1\u2208Alg, H is an \u03b1-history, and f and g are both formulas. 1) If (\u03b1,H) |\u2212 f and Ax\u222a{f} |= g then (\u03b1,H) |\u2212 g. [Strong Right Weakening] 2) If (\u03b1,H) |\u2212 f and f |= g then (\u03b1,H) |\u2212 g. [Right Weakening] 3) If A\u2192g \u2208 Rs and (\u03b1,H) |\u2212A then (\u03b1,H) |\u2212 g. [Modus Ponens for strict rules] Proof\nSuppose (R,>) is a plausible description, Ax = Ax(R), \u03b1\u2208Alg, H is an \u03b1-history, and f and g are both formulas. Further suppose that (\u03b1,H) |\u2212 f . We shall use Definition 5.9.\n(1) Suppose Ax\u222a{f} |= g. If Ax |= f then Ax |= g and so by I2, (\u03b1,H) |\u2212 g. So suppose Ax 6|= f . Then \u03b1 6= \u03d5.\nSince (\u03b1,H) |\u2212 f , by I3.1 for f , \u2203r0\u2208R s d[f ] such that \u03b1r0 /\u2208H and (\u03b1,H+\u03b1r0) |\u2212A(r0).\nBy Lemma A.5(5)(b), Rsd[f ] \u2286 R s d[g]. Hence r0\u2208R s d[g]. So I3.1 holds for g.\nBy Lemma A.5(5)(d,e), R[\u00acg] \u2286 R[\u00acf ] and Foe(\u03b1, g, r0) \u2286 Foe(\u03b1, f, r0). By Lemma A.5(5)(b,c), Rsd[f ] \u2286 R s d[g] and R s d[f ; s] \u2286 R s d[g; s].\nNow take any s0 in Foe(\u03b1, g, r0). Then s0 \u2208 Foe(\u03b1, f, r0). If I3.2.1 holds for f then \u2203t0 \u2208R s d[f ; s0] such that \u03b1t0 /\u2208H and (\u03b1,H+\u03b1t0) |\u2212A(t0). Hence t0 \u2208R s d[g; s0] and so I3.2.1 holds for g. If I3.2.2 holds for f then \u03b1\u2032s0 /\u2208H and (\u03b1 \u2032,H+\u03b1\u2032s0) 6|\u2212A(s0). Hence I3.2.2 holds for g.\nThus I3.2 holds for g and so (\u03b1,H) |\u2212 g.\n(2) Suppose f |= g. Since f |= g, we have Ax\u222a{f} |= g. So by part (1), (\u03b1,H) |\u2212 g.\n(3) Suppose A\u2192g \u2208 Rs and (\u03b1,H) |\u2212A. By Lemma A.4(1), either A = {}, or A = {a} where a is formula.\nCase 1: A = {}. By Definition 5.4, g = \u2227 Ax and so Ax |= g. By Definition 5.9(I2), (\u03b1,H) |\u2212 g.\nCase 2: A = {a} where a is formula. By Definition 5.9(I1), (\u03b1,H) |\u2212 a. By Lemma A.4(2), Ax\u222a{a} |= g. So by part (1), (\u03b1,H) |\u2212 g."}, {"heading": "EndProofThmB.2", "text": "Definition B.3. Suppose H is an \u03b1-history. If \u03b1 = \u03d5 then define H(\u03d5 :=\u03c0\u2032) to be the sequence formed from H by just replacing each \u03d5 by \u03c0\u2032. If \u03b1\u2208{\u03c0, \u03c0\u2032, \u03c8, \u03c8\u2032, \u03b2, \u03b2\u2032} then define H(\u03b1 :=\u03c0\u2032) to be the sequence formed from H by just replacing each \u03b1 by \u03c0\u2032, and each \u03b1\u2032 by \u03c0.\nIt is clear that H(\u03b1 :=\u03c0\u2032) is a \u03c0\u2032-history.\nLemma B.4. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg, H is an \u03b1-history, and x is either a formula or a finite set of formulas. If (\u03b1,H) |\u2212x then (\u03c0\u2032,H(\u03b1 :=\u03c0\u2032)) |\u2212x. Hence P(\u03b1)\u2286P(\u03c0\u2032)."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory. Let Y (n) denote the following conditional statement. \u201cIf \u03b1\u2208Alg, H is an \u03b1-history, f is a formula, F is a finite set of formulas, x\u2208{F, f}, T (\u03b1,H, x) = +1, and |T [\u03b1,H, x]| \u2264 n then T (\u03c0\u2032,H(\u03b1 :=\u03c0\u2032), x) = +1.\u201d\nBy Theorem A.8(1,2), and Theorem A.7(1), it suffices to prove Y (n) by induction on n. Suppose n = 1. Let the antecedent of Y (1) hold. Let the only node of T [\u03b1,H, x] be p0.\nLet the root of T [\u03c0\u2032,H(\u03b1 :=\u03c0\u2032), x] be q0. If p0 satisfies T1 then x = {} and so q0 satisfies T1. So by T1, T [\u03c0\n\u2032,H(\u03b1 :=\u03c0\u2032), {}] has only one node and T (\u03c0\u2032,H(\u03b1 :=\u03c0\u2032), {}) = +1. If p0 satisfies T2 then x = f and Ax |= f . So q0 satisfies T2 and hence T (\u03c0\n\u2032,H(\u03b1 :=\u03c0\u2032), f) = +1. Since p0 has no children and the proof value of p0 is +1, p0 does not satisfy T3. Since the subject of p0 is (\u03b1,H, x), p0 does not satisfy T4, or T5, or T6. Thus the base case holds.\nTake any positive integer n. Suppose Y (n) is true. We shall prove Y (n+1). Suppose the antecedent of Y (n+1) holds and that |T [\u03b1,H, x]| = n+1. Then\nT (\u03b1,H, x) = +1. Let p0 be the root of T [\u03b1,H, x] and q0 be the root of T [\u03c0 \u2032,H(\u03b1 :=\u03c0\u2032), x].\nIf p0 satisfies T1 then x = F . We see that q0 also satisfies T1. So t(p0) = ((\u03b1,H,F ),min,+1) and t(q0) = ((\u03c0\n\u2032,H(\u03b1 :=\u03c0\u2032), F ),min, w0), where w0 = T (\u03c0\n\u2032,H(\u03b1 :=\u03c0\u2032), F ) \u2208 {+1,\u22121}. Let {pf : f \u2208F} be the set of children of p0 and {qf : f \u2208F} be the set of children of q0. Let f be any formula in F . Then the subject of pf is (\u03b1,H, f), and the subject of qf is (\u03c0\n\u2032,H(\u03b1 :=\u03c0\u2032), f). Also |T [\u03b1,H, f ]| \u2264 n and the proof value of pf is +1 because p0 is a min node with proof value +1. So by Y (n) the proof value of qf is +1. But this is true for each f , so w0 = +1, as required.\nSince p0 has a child, p0 does not satisfy T2. If p0 satisfies T3 then x = f . We see that q0 also satisfies T3. So\nt(p0) = ((\u03b1,H, f),max,+1) and t(q0) = ((\u03c0 \u2032,H(\u03b1 :=\u03c0\u2032), f),max, w0), where w0 = T (\u03c0 \u2032,H(\u03b1 :=\u03c0\u2032), f) \u2208 {+1,\u22121}.\nWe shall adopt the following naming conventions. Each non-root node of T [\u03b1,H, f ] is denoted by pl(#, y) where l is the level of the node, # is the number in [1..6] such that the node satisfies T#, and y is a rule, or a formula, or a set, which distinguishes siblings. The proof value of pl(#, y) will be denoted by vl(#, y). For non-root nodes in T [\u03c0\u2032,H(\u03b1 :=\u03c0\u2032), f ] we shall use ql(#, y), and its proof value will be denoted by wl(#, y).\nLet the set of children of p0 be {p1(4, r) : \u03b1r /\u2208H and r\u2208R s d[f ]}, where the tags of\nthese children are: t(p1(4, r)) = ((\u03b1,H, f, r),min, v1(4, r)). So +1 = max{v1(4, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]}.\nLet the set of children of q0 be {q1(4, r) : \u03c0 \u2032r /\u2208H(\u03b1 :=\u03c0\u2032) and r\u2208Rsd[f ]}, where the\ntags of these children are: t(q1(4, r)) = ((\u03c0 \u2032,H(\u03b1 :=\u03c0\u2032), f, r),min, w1(4, r)). So w0 = max{w1(4, r) : \u03c0 \u2032r /\u2208H(\u03b1 :=\u03c0\u2032) and r\u2208Rsd[f ]}.\nFrom above there exists r0 in R s d[f ] such that \u03b1r0 /\u2208H and v1(4, r0) = +1. By\nDefinition B.3, if \u03c0\u2032r0\u2208H(\u03b1 :=\u03c0 \u2032) then \u03b1r0\u2208H. So if \u03b1r0 /\u2208H then \u03c0 \u2032r0 /\u2208H(\u03b1 :=\u03c0 \u2032). Hence q1(4, r0) exists. We shall show that w1(4, r0) = +1 and hence that w0 = +1, as required.\nBecause p1(4, r0) is a min node whose proof value is +1, the proof value of every child of p1(4, r0) must be +1. p2(1, r0) is a child of p1(4, r0) such that t(p2(1, r0)) = ((\u03b1,H+\u03b1r0, A(r0)),min,+1).\nThe only child of q1(4, r0) is q2(1, r0) where t(q2(1, r0)) = ((\u03c0 \u2032,H(\u03b1 :=\u03c0\u2032)+\u03c0\u2032r0, A(r0)),min, w2(1, r0)). So w1(4, r0) = w2(1, r0).\nSince |T [\u03b1,H+\u03b1r0, A(r0)]| \u2264 n and T (\u03b1,H+\u03b1r0, A(r0)) = +1, by Y (n) we have T (\u03c0\u2032,H(\u03b1 :=\u03c0\u2032)+\u03c0\u2032r0, A(r0)) = w2(1, r0) = +1. Hence w1(4, r0) = +1 and so w0 = +1, as required.\nSince the subject of p0 is (\u03b1,H, x), p0 does not satisfy T4, or T5, or T6. Thus Y (n), and hence the lemma, is proved by induction."}, {"heading": "EndProofLemB.4", "text": "Definition B.5. Suppose Pd = (R,>) is a plausible description, \u03b1\u2208Alg, H is an \u03b1-history, F is a finite set of formulas, f is a formula, r and s are any rules, T is an evaluation tree of Pd, and p is any node of T . If Subj (p) \u2208 {(\u03b1,H,F ), (\u03b1,H, f), (\u03b1,H, f, r), (\u03b1,H, f, r, s),\u2212(\u03b1,H, F )} then the history of p, Hist(p), is defined by Hist(p) = H, and the algorithm of p, alg(p), is defined by alg(p) = \u03b1.\nDefinition B.6. Suppose {\u03b1, \u03bb} \u2286 Alg, H is a \u03bb-history, and T is an evaluation tree of some plausible theory. If \u03bb /\u2208{\u03b1,\u03b1\u2032} then define \u03bb(\u03b1 :\u03b1\u2032) = \u03bb; else define \u03b1(\u03b1 :\u03b1\u2032) = \u03b1\u2032 and \u03b1\u2032(\u03b1 :\u03b1\u2032) = \u03b1. If H = (\u03bb1r1, ..., \u03bbnrn) then define H(\u03b1 :\u03b1 \u2032) = (\u03bb1(\u03b1 :\u03b1 \u2032)r1, ..., \u03bbn(\u03b1 :\u03b1\n\u2032)rn). Define T (\u03b1 : \u03b1\u2032) to be the tree formed from T by only changing the subject of each node as follows. For each node p of T replace alg(p) by alg(p)(\u03b1 : \u03b1\u2032), and replace Hist(p) by Hist(p)(\u03b1 :\u03b1\u2032).\nDefinition B.7. Suppose \u03b1\u2208Alg. \u03b1 is isomorphic to \u03b1\u2032, \u03b1 \u2243 \u03b1\u2032, iff for each plausible theory P, if T is an evaluation tree of P then T (\u03b1 :\u03b1\u2032) is an evaluation tree of P.\nIt should be clear that if \u03b1 \u2243 \u03b1\u2032 then for each plausible theory P, P(\u03b1) = P(\u03b1\u2032).\nLemma B.8. \u03b2 \u2243 \u03b2\u2032. Hence for each plausible theory P, P(\u03b2) = P(\u03b2\u2032)."}, {"heading": "Proof", "text": "Suppose \u03b1\u2208{\u03b2, \u03b2\u2032} and P = (R,>) is a plausible theory. Let Y (n) denote the following conditional statement. \u201cIf T is an evaluation tree of P and |T | \u2264 n then T (\u03b1 : \u03b1\u2032) is an evaluation tree of P.\u201d By Definition 5.14, it suffices to prove Y (n) by induction on n. By Definitions 5.13 and A.6, if T is an evaluation tree of P then either T = T [\u03b1,H, ...] or\nT = T [\u2212(\u03b1\u2032,H, F )]. So if T (\u03b1 : \u03b1\u2032) is an evaluation tree of P then either T (\u03b1 : \u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), ...] or T (\u03b1 :\u03b1\u2032) = T [\u2212(\u03b1,H(\u03b1 :\u03b1\u2032), F )].\nSuppose n = 1 and the antecedent of Y (1) holds. Let the root of T be p0. Since \u03b1\u2208{\u03b2, \u03b2\u2032}, without loss of generality we can suppose alg(p0) = \u03b1. Let the root of T (\u03b1 :\u03b1\n\u2032) be q0. Since p0 has no children, q0 has no children. If p0 satisfies T1 then let Subj (p0) = (\u03b1,H, {}). Hence Subj (q0) = (\u03b1\n\u2032,H(\u03b1 :\u03b1\u2032), {}) and so q0 satisfies T1. Thus T (\u03b1 :\u03b1\n\u2032) is an evaluation tree of P. If p0 satisfies T2 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03b1\n\u2032,H(\u03b1 :\u03b1\u2032), f) and so q0 satisfies T2. Thus T (\u03b1 :\u03b1\n\u2032) is an evaluation tree of P. If p0 satisfies T3 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03b1\n\u2032,H(\u03b1 :\u03b1\u2032), f). Since p0 has no children, S(p0) = {}. So if r\u2208R s d[f ] then \u03b1r\u2208H. Now \u03b1r\u2208H iff \u03b1\n\u2032r\u2208H(\u03b1 :\u03b1\u2032). Hence S(q0) = {} and so q0 satisfies T3. Thus T (\u03b1 :\u03b1\n\u2032) is an evaluation tree of P. Since p0 and q0 have no children, p0 and q0 satisfy neither T4 nor T6. If p0 satisfies T5 then let Subj (p0) = (\u03b1,H, f, r, s). Hence Subj (q0) = (\u03b1\n\u2032,H(\u03b1 :\u03b1\u2032), f, r, s). Since p0 has no children, S(p0) = {} and so S(p0, \u03b1) = {}. Hence if t \u2208 R s d[f ; s] then \u03b1t\u2208H. Now \u03b1t\u2208H iff \u03b1\u2032t\u2208H(\u03b1 :\u03b1\u2032). Also \u03b1\u2032s\u2208H. Hence \u03b1s\u2208H(\u03b1 :\u03b1\u2032). So S(q0, \u03b1\n\u2032) = {} and so S(q0) = {}. Thus q0 satisfies T5 and so T (\u03b1 :\u03b1\u2032) is an evaluation tree of P.\nAll cases have been considered and so Y (1) holds.\nIf T is any tree and p is any node of T for which Subj (p) is defined, then define the set S(p, T ) of subjects of the children of p in T by S(p, T ) = {Subj (c) : c is a child of p in T}.\nTake any integer n such that n \u2265 1. Suppose that Y (n) is true. We shall prove Y (n+1). Suppose the antecedent of Y (n+1) holds and that |T | = n+1. Let p0 be the root of T . If alg(p0) /\u2208{\u03b1,\u03b1\n\u2032} then T (\u03b1 :\u03b1\u2032) is T and so T (\u03b1 :\u03b1\u2032) is an evaluation tree of P. So suppose alg(p0)\u2208{\u03b1,\u03b1 \u2032}. Let q0 be the root of T (\u03b1 :\u03b1 \u2032).\nIf p0 satisfies T1 then let Subj (p0) = (\u03b1,H,F ). Hence Subj (q0) = (\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), F ). So q0 satisfies T1. Recall that S(p0, T [\u03b1,H,F ]) = {(\u03b1,H, f) : f \u2208F}. So S(q0, T [\u03b1,H,F ](\u03b1 : \u03b1\u2032)) = {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f) : f \u2208F} = S(q0, T [\u03b1\n\u2032,H(\u03b1 :\u03b1\u2032), F ]), by T1. But for each (\u03b1,H, f) in S(p0, T [\u03b1,H,F ]), T [\u03b1,H, f ] is an evaluation tree of P and |T [\u03b1,H, f ]| \u2264 n. So by Y (n), T [\u03b1,H, f ](\u03b1 :\u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1,H, f ](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 : \u03b1\u2032), f ]. Thus T (\u03b1 :\u03b1\u2032) = T [\u03b1,H,F ](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), F ] which is an evaluation tree of P.\nSince p0 has a child, p0 does not satisfy T2. If p0 satisfies T3 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f). So q0 satisfies T3. Recall that S(p0, T [\u03b1,H, f ]) = {(\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208R s d[f ]}. Since \u03b1r \u2208H iff \u03b1\u2032r \u2208H(\u03b1 :\u03b1\u2032) we have \u03b1r /\u2208H iff \u03b1\u2032r /\u2208H(\u03b1 :\u03b1\u2032). So S(q0, T [\u03b1,H, f ](\u03b1 :\u03b1 \u2032)) = {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]} = {(\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f, r) : \u03b1\u2032r /\u2208H(\u03b1 :\u03b1\u2032) and r\u2208Rsd[f ]} = S(q0, T [\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f ]), by T3. But for each (\u03b1,H, f, r) in S(p0, T [\u03b1,H, f ]), T [\u03b1,H, f, r] is an evaluation tree of P and |T [\u03b1,H, f, r]| \u2264 n. So by Y (n), T [\u03b1,H, f, r](\u03b1 : \u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1,H, f, r](\u03b1 : \u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 : \u03b1\u2032), f, r]. Thus T (\u03b1 :\u03b1\u2032) = T [\u03b1,H, f ](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f ] which is an evaluation tree of P.\nIf p0 satisfies T4 then let Subj (p0) = (\u03b1,H, f, r). Hence Subj (q0) = (\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f, r). Since \u03b1r \u2208 H iff \u03b1\u2032r \u2208 H(\u03b1 : \u03b1\u2032) we have \u03b1r /\u2208 H iff \u03b1\u2032r /\u2208 H(\u03b1 : \u03b1\u2032). So q0 satisfies T4. Recall that S(p0, T [\u03b1,H, f, r]) = {(\u03b1,H+\u03b1r,A(r))}\u222a{(\u03b1,H, f, r, s) : s\u2208Foe(\u03b1, f, r)}. Since Foe(\u03b1, f, r) = Foe(\u03b1\u2032, f, r), S(q0, T [\u03b1,H, f, r](\u03b1 :\u03b1\n\u2032)) = {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032)+\u03b1\u2032r,A(r))} \u222a {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f, r, s) : s\u2208Foe(\u03b1, f, r)} = S(q0, T [\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f, r]), by T4. But T [\u03b1,H+\n\u03b1r,A(r)] is an evaluation tree of P and |T [\u03b1,H+\u03b1r,A(r)]| \u2264 n. So by Y (n), T [\u03b1,H+ \u03b1r,A(r)](\u03b1 :\u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1,H+\u03b1r,A(r)](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032)+ \u03b1\u2032r,A(r)]. Also for each (\u03b1,H, f, r, s) in S(p0, T [\u03b1,H, f, r]), T [\u03b1,H, f, r, s] is an evaluation tree of P and |T [\u03b1,H, f, r, s]| \u2264 n. So by Y (n), T [\u03b1,H, f, r, s](\u03b1 :\u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1,H, f, r, s](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f, r, s]. Thus T (\u03b1 :\u03b1\u2032) = T [\u03b1,H, f, r](\u03b1 : \u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f, r] which is an evaluation tree of P.\nIf p0 satisfies T5 then let Subj (p0) = (\u03b1,H, f, r, s). Hence Subj (q0) = (\u03b1 \u2032,H(\u03b1 : \u03b1\u2032), f, r, s). Since \u03b1r \u2208H iff \u03b1\u2032r \u2208H(\u03b1 : \u03b1\u2032) we have \u03b1r /\u2208H iff \u03b1\u2032r /\u2208H(\u03b1 : \u03b1\u2032). So q0 satisfies T5. Recall that S(p0, T [\u03b1,H, f, r, s]) = {(\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208H and t\u2208R s d[f ; s]} \u222a {\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}. Also since \u03b1\u2032r\u2208H iff \u03b1r \u2208H(\u03b1 :\u03b1\u2032) we have \u03b1\u2032r /\u2208H iff \u03b1r /\u2208H(\u03b1 :\u03b1\u2032). So S(q0, T [\u03b1,H, f, r, s](\u03b1 :\u03b1\n\u2032)) = {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032)+\u03b1\u2032t, A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]}\u222a{\u2212(\u03b1,H(\u03b1 :\u03b1\n\u2032)+\u03b1s,A(s)) : \u03b1\u2032s /\u2208H} = {(\u03b1\u2032,H(\u03b1 :\u03b1\u2032)+\u03b1\u2032t, A(t)) : \u03b1\u2032t /\u2208H(\u03b1 :\u03b1\u2032) and t\u2208Rsd[f ; s]} \u222a {\u2212(\u03b1,H(\u03b1 :\u03b1\n\u2032)+\u03b1s,A(s)) : \u03b1s /\u2208H(\u03b1 :\u03b1\u2032)} = S(q0, T [\u03b1 \u2032,H(\u03b1 :\u03b1\u2032), f, r, s]), by T5.\nBut for each (\u03b1,H+\u03b1t,A(t)) in S(p0, T [\u03b1,H, f, r, s]), T [\u03b1,H+\u03b1t,A(t)] is an evaluation tree of P and |T [\u03b1,H+\u03b1t,A(t)]| \u2264 n. So by Y (n), T [\u03b1,H+\u03b1t,A(t)](\u03b1 :\u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1,H+\u03b1t,A(t)](\u03b1 : \u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032)+\u03b1t,A(t)]. Also if \u2212(\u03b1\u2032,H+ \u03b1\u2032s,A(s)) \u2208 S(p0, T [\u03b1,H, f, r, s]), then T [\u2212(\u03b1\n\u2032,H+\u03b1\u2032s,A(s))] is an evaluation tree of P and |T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))]| \u2264 n. So by Y (n), T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))](\u03b1 : \u03b1\u2032) is an evaluation tree of P. Hence T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))](\u03b1 :\u03b1\u2032) = T [\u2212(\u03b1,H(\u03b1 :\u03b1\u2032)+\u03b1s,A(s))].\nThus T (\u03b1 :\u03b1\u2032) = T [\u03b1,H, f, r, s](\u03b1 :\u03b1\u2032) = T [\u03b1\u2032,H(\u03b1 :\u03b1\u2032), f, r, s] which is an evaluation tree of P.\nIf p0 satisfies T6 then let Subj (p0) = \u2212(\u03b1 \u2032,H, F ). Hence Subj (q0) = \u2212(\u03b1,H(\u03b1 :\u03b1 \u2032), F ). So q0 satisfies T6. Recall that S(p0, T [\u2212(\u03b1\n\u2032,H, F )]) = {(\u03b1\u2032,H, F )}. So S(q0, T [\u2212(\u03b1 \u2032,H, F )](\u03b1 :\u03b1\u2032)) = {(\u03b1,H(\u03b1 :\u03b1\u2032), F )} = S(q0, T [\u2212(\u03b1,H(\u03b1 :\u03b1 \u2032), F )]), by T6. But T [\u03b1\u2032,H, F ] is an evaluation tree of P and |T [\u03b1\u2032,H, F ]| \u2264 n. So by Y (n), T [\u03b1\u2032,H, F ](\u03b1 :\u03b1\u2032) is an evaluation tree of P. Hence T [\u03b1\u2032,H, F ](\u03b1 :\u03b1\u2032) = T [\u03b1,H(\u03b1 :\u03b1\u2032), F ]. Thus T (\u03b1 :\u03b1\u2032) = T [\u2212(\u03b1\u2032,H, F )](\u03b1 :\u03b1\u2032) = T [\u2212(\u03b1,H(\u03b1 :\u03b1\u2032), F )] which is an evaluation tree of P.\nTherefore Y (n+1), and hence the lemma, is proved by induction."}, {"heading": "EndProofLemB.8", "text": "Lemma B.9. Suppose P = (R,>) is a plausible theory, H is a \u03c8-history, and x is either a formula or a finite set of formulas. If (\u03c8,H) |\u2212x then (\u03c8\u2032,H(\u03c8 :\u03c8\u2032)) |\u2212x. Hence P(\u03c8)\u2286P(\u03c8\u2032)."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory. Let Y (n) denote the following conditional statement. \u201cIf H is a \u03c8-history, F is a finite set of formulas, f is a formula, x \u2208 {F, f}, T (\u03c8,H, x) = +1, and |T [\u03c8,H, x]| \u2264 n then T (\u03c8\u2032,H(\u03c8 :\u03c8\u2032), x) = +1.\u201d\nBy Theorem A.8(1,2), and Theorem 7.1(1), it suffices to prove Y (n) by induction on n.\nSuppose n = 1. Let the antecedent of Y (1) hold. Let the only node of T [\u03c8,H, x] be p0. Let the root of T [\u03c8\u2032,H(\u03c8 :\u03c8\u2032), x] be q0.\nIf p0 satisfies T1 then x = {} and so q0 satisfies T1. So by T1, T [\u03c8 \u2032,H(\u03c8 :\u03c8\u2032), {}] has only one node and T (\u03c8\u2032,H(\u03c8 :\u03c8\u2032), {}) = +1. If p0 satisfies T2 then x = f and Ax |= f . So q0 satisfies T2 and hence T (\u03c8 \u2032,H(\u03c8 : \u03c8\u2032), f) = +1. Since p0 has no children and the\nproof value of p0 is +1, p0 does not satisfy T3. Since the subject of p0 is (\u03c8,H, x), p0 does not satisfy T4, or T5, or T6. Thus the base case holds.\nTake any positive integer n. Suppose Y (n) is true. We shall prove Y (n+1).\nSuppose the antecedent of Y (n+1) holds and that |T [\u03c8,H, x]| = n+1. Then T (\u03c8,H, x) = +1. Let p0 be the root of T [\u03c8,H, x] and q0 be the root of T [\u03c8 \u2032,H(\u03c8 :\u03c8\u2032), x].\nIf p0 satisfies T1 then x = F . We see that q0 also satisfies T1. So t(p0) = ((\u03c8,H,F ),min,+1) and t(q0) = ((\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032), F ),min, w0), where w0 = T (\u03c8\n\u2032,H(\u03c8 : \u03c8\u2032), F ) \u2208 {+1,\u22121}. Let {pf : f \u2208 F} be the set of children of p0 and {qf : f \u2208F} be the set of children of q0. Let f be any formula in F . Then the subject of pf is (\u03c8,H, f), and the subject of qf is (\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032), f). Also |T [\u03c8,H, f ]| \u2264 n and the proof value of pf is +1 because p0 is a min node with proof value +1. So by Y (n) the proof value of qf is +1. But this is true for each f , so w0 = +1, as required.\nSince p0 has a child, p0 does not satisfy T2.\nIf p0 satisfies T3 then x = f . We see that q0 also satisfies T3. So t(p0) = ((\u03c8,H, f),max,+1) and t(q0) = ((\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032), f),max, w0), where w0 = T (\u03c8 \u2032,H(\u03c8 :\u03c8\u2032), f) \u2208 {+1,\u22121}.\nWe shall adopt the following naming conventions. Each non-root node of T is denoted by pl(#, y) where l is the level of the node, # is the number in [1..6] such that the node satisfies T#, and y is a rule, or a formula, or a set, which distinguishes siblings. The proof value of pl(#, y) will be denoted by vl(#, y). For non-root nodes in T [\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032), f ] we shall use ql(#, y), and its proof value will be denoted by wl(#, y).\nLet the set of children of p0 be {p1(4, r) : \u03c8r /\u2208H and r \u2208R s d[f ]}, where the tags of\nthese children are: t(p1(4, r)) = ((\u03c8,H, f, r),min, v1(4, r)). So +1 = max{v1(4, r) : \u03c8r /\u2208H and r\u2208R s d[f ]}.\nLet the set of children of q0 be {q1(4, r) : \u03c8 \u2032r /\u2208 H(\u03c8 : \u03c8\u2032) and r \u2208 Rsd[f ]}, where the tags of these children are: t(q1(4, r)) = ((\u03c8 \u2032,H(\u03c8 : \u03c8\u2032), f, r),min, w1(4, r)). So w0 = max{w1(4, r) : \u03c8 \u2032r /\u2208H(\u03c8 :\u03c8\u2032) and r\u2208Rsd[f ]}.\nFrom above there exists r0 in R s d[f ] such that \u03c8r0 /\u2208H and v1(4, r0) = +1. By Definition\nB.6, if \u03c8\u2032r0\u2208H(\u03c8 :\u03c8 \u2032) then \u03c8r0\u2208H. So if \u03c8r0 /\u2208H then \u03c8 \u2032r0 /\u2208H(\u03c8 :\u03c8 \u2032). Hence q1(4, r0) exists. We shall show that w1(4, r0) = +1 and hence that w0 = +1, as required.\nLet the set of children of p1(4, r0) be {p2(1, r0)} \u222a {p2(5, s) : s\u2208Foe(\u03c8, f, r0)}, where the tags of these children are: t(p2(1, r0)) = ((\u03c8,H+\u03c8r0, A(r0)),min, v2(1, r0)); and t(p2(5, s)) = ((\u03c8,H, f, r0, s),max, v2(5, s)). So +1 = v1(4, r0) = min[{v2(1, r0)} \u222a {v2(5, s) : s\u2208Foe(\u03c8, f, r0)}]. Hence v2(1, r0) = +1; and for each s in Foe(\u03c8, f, r0), v2(5, s) = +1.\nLet the set of children of q1(4, r0) be {q2(1, r0)} \u222a {q2(5, s) : s\u2208R[\u00acf ; r0]}, where the tags of these children are: t(q2(1, r0)) = ((\u03c8\n\u2032,H(\u03c8 : \u03c8\u2032)+\u03c8\u2032r0, A(r0)),min, w2(1, r0)); and t(q2(5, s)) = ((\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032), f, r0, s),max, w2(5, s)). So w1(4, r0) = min[{w2(1, r0)} \u222a {w2(5, s) : s\u2208R[\u00acf ; r0]}].\nSince v2(1, r0) = +1, T (\u03c8,H+\u03c8r0, A(r0)) = +1 and |T [\u03c8,H+\u03c8r0, A(r0)]| \u2264 n. So by Y (n), w2(1, r0) = T (\u03c8\n\u2032,H(\u03c8 :\u03c8\u2032)+\u03c8\u2032r0, A(r0)) = +1. Therefore w1(4, r0) = min{w2(5, s) : s \u2208 R[\u00acf ; r0]}. If R[\u00acf ; r0] = {} then w1(4, r0) = min{} = +1 as desired. So suppose R[\u00acf ; r0] 6= {}.\nSince R[\u00acf ; r0]\u2286Foe(\u03c8, f, r0), if q2(5, s) exists then p2(5, s) exists.\nFor each node, p2(5, s), let the set of children of p2(5, s) be {p3(1, t) : \u03c8t /\u2208 H and t \u2208 Rsd[f ; s]} \u222a {p3(6, s) : \u03c8\n\u2032s /\u2208 H}, where the tags of these children are: t(p3(1, t)) = ((\u03c8,H+\u03c8t,A(t)),min, v3(1, t)); and t(p3(6, s)) = (\u2212(\u03c8\n\u2032,H+\u03c8\u2032s,A(s)),\u2212, v3(6, s)). So +1 = v2(5, s) = max[{v3(1, t) : \u03c8t /\u2208H and t\u2208R s d[f ; s]} \u222a {v3(6, s) : \u03c8\n\u2032s /\u2208H}]. For each node, q2(5, s), let the set of children of q2(5, s) be {q3(1, t) : \u03c8\n\u2032t /\u2208 H(\u03c8 : \u03c8\u2032) and t \u2208 Rsd[f ; s]} \u222a {q3(6, s) : \u03c8s /\u2208 H(\u03c8 : \u03c8\n\u2032)}, where the tags of these children are: t(q3(1, t)) = ((\u03c8\n\u2032,H(\u03c8 : \u03c8\u2032)+\u03c8\u2032t, A(t)),min, w3(1, t)); and t(q3(6, s)) = (\u2212(\u03c8,H(\u03c8 : \u03c8\u2032)+\u03c8s,A(s)),\u2212, w3(6, s)). So w2(5, s) = max[{w3(1, t) : \u03c8\n\u2032t /\u2208H(\u03c8 :\u03c8\u2032) and t\u2208Rsd[f ; s]} \u222a {w3(6, s) : \u03c8s /\u2208H(\u03c8 :\u03c8\n\u2032)}]. By Definition B.6, \u03c8t\u2208H iff \u03c8\u2032t\u2208H(\u03c8 :\u03c8\u2032). So \u03c8t /\u2208H iff \u03c8\u2032t /\u2208H(\u03c8 :\u03c8\u2032). Therefore p3(1, t) exists iff q3(1, t) exists. If there exists t0 \u2208 R s d[f ; s] such that v3(1, t0) = +1 then T (\u03c8,H+\u03c8t0, A(t0)) = +1 and |T [\u03c8,H+\u03c8t0, A(t0)]| \u2264 n so by Y (n), w3(1, t0) = T (\u03c8\u2032,H(\u03c8 :\u03c8\u2032)+\u03c8\u2032t0, A(t0)) = +1. Hence w2(5, s) = +1.\nSo suppose no such t0 \u2208 R s d[f ; s] exists. Then p3(6, s) exists such that \u03c8 \u2032s /\u2208H and v3(6, s) = +1. By Definition B.6, \u03c8\n\u2032s\u2208H iff \u03c8s\u2208H(\u03c8 :\u03c8\u2032). So \u03c8\u2032s /\u2208H iff \u03c8s /\u2208H(\u03c8 :\u03c8\u2032). Hence q3(6, s) exists.\nLet the child of p3(6, s) be p4(1, s) where t(p4(1, s)) = ((\u03c8 \u2032,H+\u03c8\u2032s,A(s)),min, v4(1, s))\nand v3(6, s) = \u2212v4(1, s). So v4(1, s) = \u22121. Let the child of q3(6, s) be q4(1, s) where t(q4(1, s)) = ((\u03c8,H(\u03c8 :\u03c8 \u2032)+\u03c8s,A(s)),min, w4(1, s)) and w3(6, s) = \u2212w4(1, s).\nAssume w4(1, s) = +1. Then T (\u03c8,H(\u03c8 :\u03c8 \u2032)+\u03c8s,A(s)) = +1 and\n|T [\u03c8,H(\u03c8 : \u03c8\u2032)+\u03c8s,A(s)]| \u2264 n so by Y (n), T (\u03c8\u2032,H(\u03c8 : \u03c8\u2032)(\u03c8 : \u03c8\u2032)+\u03c8\u2032s,A(s)) = +1. But H(\u03c8 : \u03c8\u2032)(\u03c8 : \u03c8\u2032) = H. So T (\u03c8\u2032,H+\u03c8\u2032s,A(s)) = +1. From above \u22121 = v4(1, s) = T (\u03c8\u2032,H+\u03c8\u2032s,A(s)) = +1. This contradiction shows that w4(1, s) = \u22121. Hence w3(6, s) = +1 and so w2(5, s) = +1.\nSo in both cases for all s in R[\u00acf ; r0], w2(5, s) = +1 and so w1(4, r0) = +1. Hence w0 = +1, as required.\nSince the subject of p0 is (\u03c8,H, x), p0 does not satisfy T4, or T5, or T6. Thus Y (n), and hence the lemma, is proved by induction."}, {"heading": "EndProofLemB.9", "text": "Lemma B.10. Suppose (R,>) is a plausible theory, Ax = Ax (R), and f is a formula. If f is satisfiable and Ax 6|= f then Rsd[f ] is finite. Proof\nSuppose (R,>) is a plausible theory, Ax = Ax (R), and f is a formula. Also suppose f is satisfiable and Ax 6|= f . Take any \u03b1 in Alg\u2212{\u03d5}. By Definition 5.14, T [\u03b1, (), f ] is finite, and so its root has only finitely many children. The root of T [\u03b1, (), f ] satisfies T3 of Definition 5.13. Therefore Rsd[f ] is finite. EndProofLemB.10\nTheorem B.11 (Theorem 7.4 Consistency). Suppose (R,>) is a plausible theory, Ax = Ax (R), \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032}, and both f and g are any formulas. 1) If \u03b1 |\u2212 f and \u03b1 |\u2212 g then Ax\u222a{f, g} is satisfiable. 2) If (\u03c8,H) |\u2212 f then (\u03c8\u2032,H) 6|\u2212 \u00acf . 3) Suppose that whenever s\u2208Rsd[\u00acf ] and (\u03c0\n\u2032,H+\u03c0\u2032s) |\u2212A(s) then Rsd[f ; s] = {}. If (\u03c0,H) |\u2212 f then (\u03c0\u2032,H) 6|\u2212 \u00acf ."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory, Ax = Ax (R), \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032}, and both f and g are any formulas.\n(1) Suppose \u03b1 |\u2212 f and \u03b1 |\u2212 g. So by Theorem A.8(2), T (\u03b1, (), f) = +1 and T (\u03b1, (), g) = +1.\nLet p0 be the root of T [\u03b1, (), f ] and q0 be the root of T [\u03b1, (), g]. Since the subject of p0 is (\u03b1, (), f), p0 does not satisfy T1, or T4, or T5, or T6. Since the subject of q0 is (\u03b1, (), g), q0 does not satisfy T1, or T4, or T5, or T6. Therefore p0 satisfies T2 or T3, and q0 satisfies T2 or T3. So there are four cases to consider.\nCase 1: p0 satisfies T2 and q0 satisfies T2. Then Ax |= f and Ax |= g. By Lemma A.3(1), Ax is satisfiable. Therefore Ax\u222a{f, g} is satisfiable.\nCase 2: p0 satisfies T2 and q0 satisfies T3. Then Ax |= f , r\u2208R[f ], Ax 6|= g, and \u03b1 6= \u03d5. So \u03b1\u2208{\u03c0, \u03c8, \u03b2, \u03b2\u2032}. Assume Ax\u222a{f, g} is unsatisfiable. By Lemma A.5(6), R[f ] \u2286 R[\u00acg]. So r\u2208R[\u00acg]. By T3, q0 has a child, q1, in T [\u03b1, (), g] such that t(q1) = ((\u03b1, (), g, rg),min,+1) and rg\u2208R s d[g]. By T4, q1 has a child, q2, in T [\u03b1, (), g] such that t(q2) = ((\u03b1, (), g, rg , r),max,+1). By T5, q2 has a child, q3, in T [\u03b1, (), g] such that pv(q3) = +1. By T5, Subj (q3) \u2208 S(q2). By Definition 5.5(3), Rsd[g; r] = {} and so S(q2) = S(q2, \u03b1). However, A(r) = {}. So t(q3) = (\u2212(\u03b1\n\u2032, (\u03b1\u2032r), {}),\u2212,+1). By T6, q3 has a child, q4 in T [\u03b1, (), g] such that Subj (q4) = (\u03b1\n\u2032, (\u03b1\u2032r), {}). So by T1, pv(q4) = +1. But by T7, +1 = pv(q3) = \u2212pv(q4) = \u22121. This contradiction shows that Ax\u222a{f, g} is satisfiable.\nCase 3: p0 satisfies T3 and q0 satisfies T2. This case is the same as Case 2 but with p and q interchanged and with f and g interchanged. So by doing the indicated interchanges the proof for Case 2 becomes a proof for Case 3.\nCase 4: p0 satisfies T3 and q0 satisfies T3. Then Ax 6|= f , Ax 6|= g, and \u03b1 6= \u03d5. So \u03b1\u2208{\u03c0, \u03c8, \u03b2, \u03b2\u2032}. By T3, p0 has a child, p1, in T [\u03b1, (), f ] such that t(p1) = ((\u03b1, (), f, rf ),min,+1) and rf \u2208R s d[f ]. By T3, q0 has a child, q1, in T [\u03b1, (), g] such that t(q1) = ((\u03b1, (), g, rg),min,+1) and rg\u2208R s d[g].\nAssume Ax\u222a{f, g} is unsatisfiable. By Lemma A.5(6), Rsd[f ] \u2286 R[f ] \u2286 R[\u00acg] and Rsd[g] \u2286 R[g] \u2286 R[\u00acf ]. So rf \u2208R[\u00acg] and rg\u2208R[\u00acf ].\nBy T4, either rf>rg; or p1 has a child, p2(rg), in T [\u03b1, (), f ] such that Subj (p2(rg)) = (\u03b1, (), f, rf , rg) and pv(p2(rg)) = +1. By T5, p2(rg) has a child, p3(rg) in T [\u03b1, (), f ] such that pv(p3(rg)) = +1 and Subj (p3(rg)) \u2208 S(p2(rg)).\nSimilarly by T4, either rg>rf ; or q1 has a child, q2(rf ), in T [\u03b1, (), g] such that Subj (q2(rf )) = (\u03b1, (), g, rg , rf ) and pv(q2(rf )) = +1. By T5, q2(rf ) has a child, q3(rf ) in T [\u03b1, (), g] such that pv(q3(rf )) = +1 and Subj (q3(rf )) \u2208 S(q2(rf )).\nCase 4.1: Subj (p3(rg)) = \u2212(\u03b1 \u2032, (\u03b1\u2032rg), A(rg)).\nSince pv(p3(rg)) = +1, T (\u03b1 \u2032, (\u03b1\u2032rg), A(rg)) = \u22121. So by Theorem A.8(1), (\u03b1\u2032, (\u03b1\u2032rg)) 6|\u2212A(rg). But Subj (q2(rg)) = (\u03b1, (\u03b1rg), A(rg)) and pv(q2(rg)) = +1. So T (\u03b1, (\u03b1rg), A(rg)) = +1. By Theorem A.8(1), (\u03b1, (\u03b1rg)) |\u2212A(rg). By Lemmas B.4, B.9, and B.8, (\u03b1\u2032, (\u03b1\u2032rg)) |\u2212A(rg). This contradiction shows that Case 4.1 cannot occur. Thus Subj (p3(rg)) = (\u03b1, (\u03b1t), A(t)) where t\u2208R s d[f ; rg].\nCase 4.2: Subj (q3(rf )) = \u2212(\u03b1 \u2032, (\u03b1\u2032rf ), A(rf )).\nThis case is the same as Case 4.1 but with p and q interchanged and with f and g interchanged. So by doing the indicated interchanges the proof that Case 4.1 cannot occur becomes a proof that Case 4.2 cannot occur. Thus Subj (q3(rf )) = (\u03b1, (\u03b1t), A(t)) where t\u2208Rsd[g; rf ].\nIn summary Cases 4.1 and 4.2 have shown that we have either rf >rg or there is a t in R s d[f ; rg]; and also either rg>rf or there is a t in R s d[g; rf ].\nSo there exists tf (1) in R s d[f ; rg] \u2286 R s d[f ] \u2286 R[f ] \u2286 R[\u00acg]. Hence tf (1) > rg and\ntf (1) \u2208 R[\u00acg]. So q2(rf ) can be replaced by q2(tf (1)), and q3(rf ) can be replaced by q3(tf (1)).\nAlso there exists tg(1) in R s d[g; rf ] \u2286 R s d[g] \u2286 R[g] \u2286 R[\u00acf ]. Hence tg(1) > rf and\ntg(1) \u2208 R[\u00acf ]. So p2(rg) can be replaced by p2(tg(1)), and p3(rg) can be replaced by p3(tg(1)).\nSimilarly, the arguments in Cases 4.1 and 4.2 for these new nodes yield rules tf (2) and tg(2) with the following properties: tf (2) \u2208 R s d[f ; tg(1)] \u2286 R s d[f ] \u2286 R[f ] \u2286 R[\u00acg]; and tg(2) \u2208 R s d[g; tf (1)] \u2286 R s d[g] \u2286 R[g] \u2286 R[\u00acf ]. So tf (2) > tg(1) and tf (2)\u2208R[\u00acg] and tg(2) > tf (1) and tg(2)\u2208R[\u00acf ]. Hence tf (2) > tg(1) > rf and tg(2) > tf (1) > rg.\nThis process can be continued indefinitely to yield the following sequences of rules. rf < tg(1) < tf (2) < tg(3) < tf (4) < ... and rg < tf (1) < tg(2) < tf (3) < tg(4) < ... Now each tf (i)\u2208R s d[f ] and each tg(i)\u2208R s d[g]. Since \u03b1 |\u2212 f and \u03b1 |\u2212 g, by Lemma A.3(5), both f and g are satisfiable. But Ax 6|= f and Ax 6|= g, so by Lemma B.10, both Rsd[f ] and R s d[g] are finite. So for some i and some j>i, tf (2i) = tf (2j). Hence > is cyclic, which contradicts the definition of > as being acyclic. This contradiction shows that Ax\u222a{f, g} is satisfiable.\n(2) If H is a \u03c8-history then H is also a \u03c8\u2032-history. Suppose (\u03c8,H) |\u2212 f . We shall use Definition 5.9. Assume (\u03c8\u2032,H) |\u2212\u00acf .\nBy I3.1 for \u00acf , (*1) \u2203s1\u2208R s d[\u00acf ] such that (\u03c8 \u2032,H+\u03c8\u2032s1) |\u2212A(s1). By I3.2 for f either (\u03c8\u2032,H+\u03c8\u2032s1) 6|\u2212A(s1), which contradicts (*1), or (*2) \u2203r2\u2208R s d[f ; s1] such that (\u03c8,H+\u03c8r2) |\u2212A(r2). By I3.2 for \u00acf either (\u03c8,H+\u03c8r2) 6|\u2212A(r2), which contradicts (*2), or (*3) \u2203s3\u2208R s d[\u00acf ; r2] such that (\u03c8\n\u2032,H+\u03c8\u2032s3) |\u2212A(s3). By I3.2 for f either (\u03c8\u2032,H+\u03c8\u2032s3) 6|\u2212A(s3), which contradicts (*3), or (*4) \u2203r4\u2208R s d[f ; s3] such that (\u03c8,H+\u03c8r4) |\u2212A(r4). So we have r4 > s3 > r2 > s1.\nWe can continue the reasoning in the above paragraph to create two arbitrarily long sequences s1, s3, ..., s2i\u22121, ... and r2, r4, ..., r2i, ... such that each s2i\u22121\u2208R s d[\u00acf ] and each r2i\u2208R s d[f ]. Moreover for each odd i, si+2 > ri+1 > si. Since (\u03c8,H) |\u2212 f , by Lemma A.3(5), f is satisfiable and Ax 6|= \u00acf . Since (\u03c8\u2032,H) |\u2212\u00acf , by Lemma A.3(5), \u00acf is satisfiable and Ax 6|= f . So by Lemma B.10, both Rsd[f ] and R s d[\u00acf ] are finite. So there is an even j and an even k such that j < k and rj = rk. Hence > is cyclic, contradicting its acyclicity. Thus (2) is proved.\n(3) Suppose that (*) whenever s\u2208Rsd[\u00acf ] and (\u03c0 \u2032,H+\u03c0\u2032s) |\u2212A(s) then Rsd[f ; s] = {}.\nIf H is a \u03c0-history then H is also a \u03c0\u2032-history. Suppose (\u03c0,H) |\u2212 f . We shall use Definition 5.9. Assume (\u03c0\u2032,H) |\u2212\u00acf .\nBy I3.1 for \u00acf , (**) \u2203s1\u2208R s d[\u00acf ] such that (\u03c0 \u2032,H+\u03c0\u2032s1) |\u2212A(s1). By I3.2 for f either (\u03c0\u2032,H+\u03c0\u2032s1) 6|\u2212A(s1), which contradicts (**), or \u2203r2\u2208R s d[f ; s1] such that (\u03c0,H+\u03c0r2) |\u2212A(r2), which contradicts (*). Thus (3) is proved. EndProofThmB.11\nTheorem B.12 (Theorem 7.5 Truth values). Suppose (R,>) is a plausible theory, \u03b1\u2208Alg , F is a finite set of formulas, and f is a formula.\n1) V (\u03b1,\u00ac\u00acf) = V (\u03b1, f). 2) V (\u03b1, f) = t iff V (\u03b1,\u00acf) = f. 3) V (\u03b1, f) = f iff V (\u03b1,\u00acf) = t. 4) V (\u03b1, f) = a iff V (\u03b1,\u00acf) = a. 5) V (\u03b1, f) = u iff V (\u03b1,\u00acf) = u. 6) If V (\u03b1, \u2227 F ) = t then for each f in F , V (\u03b1, f) = t. 7) If f \u2208F and V (\u03b1, f) = t then V (\u03b1, \u2228 F ) = t. 8) If \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032} then V (\u03b1, f)\u2208{t, f,u}. 9) If V (\u03b1, f) = a then \u03b1\u2208{\u03c8\u2032, \u03c0\u2032}.\n10) If V (\u03b1, f) = t then \u03b1 |\u2212 f . (completeness) 11) If \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032} and \u03b1 |\u2212 f then V (\u03b1, f) = t. (soundness)"}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory, \u03b1\u2208Alg, F is a finite set of formulas, and f is a formula. By Theorem 7.3(2), \u03b1 |\u2212 f iff \u03b1 |\u2212\u00ac\u00acf ; and so \u03b1 6|\u2212 f iff \u03b1 6|\u2212 \u00ac\u00acf .\n(1) This follows from Definition 5.18 and the equivalences noted above.\n(2) V (\u03b1, f) = t iff \u03b1 |\u2212 f and \u03b1 6|\u2212 \u00acf . V (\u03b1,\u00acf) = f iff \u03b1 6|\u2212 \u00acf and \u03b1 |\u2212\u00ac\u00acf . So (2) holds.\n(3) V (\u03b1, f) = f iff \u03b1 6|\u2212 f and \u03b1 |\u2212\u00acf . V (\u03b1,\u00acf) = t iff \u03b1 |\u2212\u00acf and \u03b1 6|\u2212 \u00ac\u00acf . So (3) holds.\n(4) V (\u03b1, f) = a iff \u03b1 |\u2212 f and \u03b1 |\u2212\u00acf . V (\u03b1,\u00acf) = a iff \u03b1 |\u2212\u00acf and \u03b1 |\u2212\u00ac\u00acf . So (4) holds.\n(5) V (\u03b1, f) = u iff \u03b1 6|\u2212 f and \u03b1 6|\u2212 \u00acf . V (\u03b1,\u00acf) = u iff \u03b1 6|\u2212 \u00acf and \u03b1 6|\u2212 \u00ac\u00acf . So (5) holds.\n(6) Suppose V (\u03b1, \u2227 F ) = t. Then \u03b1 |\u2212 \u2227 F and \u03b1 6|\u2212 \u00ac \u2227 F . By Theorem B.2(2), for\neach f in F , \u03b1 |\u2212 f . Take any f in F and assume \u03b1 |\u2212\u00acf . By Theorem B.2(2), \u03b1 |\u2212 \u2228 \u00acF , where \u00acF = {\u00acf : f \u2208F}. So by Theorem B.2(2), \u03b1 |\u2212\u00ac \u2227 F . This contradiction shows that for each f in F , \u03b1 6|\u2212 \u00acf . Thus for each f in F , V (\u03b1, f) = t.\n(7) Suppose f \u2208F and V (\u03b1, f) = t. Then \u03b1 |\u2212 f and \u03b1 6|\u2212 \u00acf . By Theorem B.2(2), \u03b1 |\u2212 \u2228 F . Assume \u03b1 |\u2212\u00ac \u2228 F . By Theorem B.2(2), \u03b1 |\u2212 \u2227 \u00acF and so \u03b1 |\u2212\u00acf . This contradiction shows that \u03b1 6|\u2212 \u00ac \u2228 F . Thus V (\u03b1, \u2228 F ) = t.\n(8) Suppose \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032}. Recall V (\u03b1, f) = a iff \u03b1 |\u2212 f and \u03b1 |\u2212\u00acf . So by Theorem 7.4(1), V (\u03b1, f) 6= a.\n(9) This is just the contrapositive of part (8).\n(10) Recall V (\u03b1, f) = t iff \u03b1 |\u2212 f and \u03b1 6|\u2212 \u00acf .\n(11) Suppose \u03b1\u2208{\u03d5, \u03c0, \u03c8, \u03b2, \u03b2\u2032} and \u03b1 |\u2212 f . By Definition 5.18 and \u03b1 |\u2212 f we have V (\u03b1, f)\u2208{a, t}. So by part (8), V (\u03b1, f) = t.\nEndProofThmB.12"}, {"heading": "Appendix C. Proof of Theorem 7.6", "text": "Lemma C.1. Suppose P = (R,>) is a plausible theory, \u03b1\u2208Alg , I is a \u03d5-history, H is an \u03b1-history, and x is either a formula or a finite set of formulas. If (\u03d5, I) |\u2212x then (\u03b1,H) |\u2212x. Hence P(\u03d5)\u2286P(\u03b1)."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory, Ax = Ax(R), \u03b1\u2208Alg , H is an \u03b1-history, and x is either a formula or a finite set of formulas. Let (\u03d5, I) |\u2212x. We shall use Definition 5.9.\nCase 1: x is a formula. Let x = f . Then (\u03d5, I) |\u2212 f . By Definition 5.9(I2), Ax |= f and (\u03b1,H) |\u2212 f .\nCase 2: x is a finite set of formulas. Let x = F . Then (\u03d5, I) |\u2212F . By I1, for all f in F , (\u03d5, I) |\u2212 f . By Case 1, (\u03b1,H) |\u2212 f . So by I1, (\u03b1,H) |\u2212F ."}, {"heading": "EndProofLemC.1", "text": "Definition C.2. If H is a \u03c0-history then define H(\u03c0 :=\u03c8) to be the sequence formed from H by just replacing each \u03c0 by \u03c8, and each \u03c0\u2032 by \u03c8\u2032.\nLemma C.3. Suppose P = (R,>) is a plausible theory, H is a \u03c0-history, and x is either a formula or a finite set of formulas. If (\u03c0,H) |\u2212x then (\u03c8,H(\u03c0 :=\u03c8)) |\u2212x. Hence P(\u03c0)\u2286P(\u03c8)."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory and Ax is its set of axioms. Let Y (n) denote the following conditional statement. \u201cIf H is a \u03c0-history, x is either a formula or a finite set of formulas, T (\u03c0,H, x) = +1, and |T [\u03c0,H, x]| \u2264 n then T (\u03c8,H(\u03c0 :=\u03c8), x) = +1.\u201d\nBy Theorem A.8(1,2), and Theorem A.7(1), it suffices to prove Y (n) by induction on n.\nSuppose n = 1. Let the antecedent of Y (1) hold. Let p0 be the root of T [\u03c0,H, x] and q0 be the root of T [\u03c8,H(\u03c0 :=\u03c8), x]. Then p0 has no children. If p0 satisfies T1 then x = {} and so q0 satisfies T1. So by T1, T [\u03c8,H(\u03c0 :=\u03c8), {}] has only one node and T (\u03c8,H(\u03c0 :=\u03c8), {}) = +1. If p0 satisfies T2 then x = f and Ax |= f . So q0 satisfies T2 and hence T (\u03c8,H(\u03c0 :=\u03c8), f) = +1. Since p0 has no children and the proof value of p0 is +1, p0 does not satisfy T3. Since the subject of p0 is (\u03c0,H, x), p0 does not satisfy T4, or T5, or T6. Thus the base case holds.\nTake any positive integer n. Suppose that Y (n) is true. We shall prove Y (n+1).\nSuppose the antecedent of Y (n+1) holds and that |T [\u03c0,H, x]| = n+1. Let p0 be the root of T [\u03c0,H, x] and q0 be the root of T [\u03c8,H(\u03c0 :=\u03c8), x].\nIf p0 satisfies T1 then let x be F . We see that q0 also satisfies T1. So t(p0) = ((\u03c0,H,F ),min,+1) and t(q0) = ((\u03c8,H(\u03c0 :=\u03c8), F ),min, w0), where w0 = T (\u03c8,H(\u03c0 :=\u03c8), F ) \u2208 {+1,\u22121}. Let {pf : f \u2208F} be the set of children of p0 and {qf : f \u2208F} be the set of children of q0. Let f be any formula in F . Then the subject of pf is (\u03c0,H, f), and the subject of qf is (\u03c8,H(\u03c0 :=\u03c8), f). Also |T [\u03c0,H, f ]| \u2264 n and the proof value of pf is +1 because p0 is a min node with proof value +1. So by Y (n) the proof value of qf is +1. But this is true for each f , so w0 = +1, as required.\nSince p0 has a child, p0 does not satisfy T2.\nIf p0 satisfies T3 then let x be f . We see that q0 also satisfies T3. So t(p0) = ((\u03c0,H, f),max,+1) and t(q0) = ((\u03c8,H(\u03c0 :=\u03c8), f),max, w0), where w0 = T (\u03c8,H(\u03c0 :=\u03c8), f) \u2208 {+1,\u22121}.\nWe shall adopt the following naming conventions. Each non-root node of T [\u03c0,H, f ] is denoted by pl(#, y) where l is the level of the node, # is the number in [1..6] such that the node satisfies T#, and y is a rule, or a formula, or a set, which distinguishes siblings. The proof value of pl(#, y) will be denoted by vl(#, y). For non-root nodes in T [\u03c8,H(\u03c0 :=\u03c8), f ] we shall use ql(#, y), and its proof value will be denoted by wl(#, y).\nLet the set of children of p0 be {p1(4, r) : \u03c0r /\u2208H and r\u2208R s d[f ]}, where the tags of\nthese children are: t(p1(4, r)) = ((\u03c0,H, f, r),min, v1(4, r)). So +1 = max{v1(4, r) : \u03c0r /\u2208H and r\u2208R s d[f ]}.\nLet the set of children of q0 be {q1(4, r) : \u03c8r /\u2208H(\u03c0 :=\u03c8) and r\u2208R s d[f ]}, where the\ntags of these children are: t(q1(4, r)) = ((\u03c8,H(\u03c0 :=\u03c8), f, r),min, w1(4, r)). So w0 = max{w1(4, r) : \u03c8r /\u2208H(\u03c0 :=\u03c8) and r\u2208R s d[f ]}.\nFrom above there exists r0 in R s d[f ] such that \u03c0r0 /\u2208H and v1(4, r0) = +1. So\nt(p1(4, r0)) = ((\u03c0,H, f, r0),min,+1).\nLet the set of children of p1(4, r0) be {p2(1, r0)} \u222a {p2(5, s) : s\u2208Foe(\u03c0, f, r0)}, where the tags of these children are: t(p2(1, r0)) = ((\u03c0,H+\u03c0r0, A(r0)),min, v2(1, r0)); and t(p2(5, s)) = ((\u03c0,H, f, r0, s),max, v2(5, s)). So +1 = v1(4, r0) = min[{v2(1, r0)} \u222a {v2(5, s) : s\u2208Foe(\u03c0, f, r0)}]. Hence v2(1, r0) = +1; and for each s in Foe(\u03c0, f, r0), v2(5, s) = +1.\nLet the set of children of q1(4, r0) be {q2(1, r0)} \u222a {q2(5, s) : s\u2208Foe(\u03c8, f, r0)}, where the tags of these children are: t(q2(1, r0)) = ((\u03c8,H(\u03c0 :=\u03c8)+\u03c8r0, A(r0)),min, w2(1, r0)); and t(q2(5, s)) = ((\u03c8,H(\u03c0 :=\u03c8), f, r0, s),max, w2(5, s)). So w1(4, r0) = min[{w2(1, r0)} \u222a {w2(5, s) : s\u2208Foe(\u03c8, f, r0)}].\nSince |T [\u03c0,H+\u03c0r0, A(r0)]| < n and T (\u03c0,H+\u03c0r0, A(r0)) = v2(1, r0) = +1, by Y (n) we have T (\u03c8,H(\u03c0 :=\u03c8)+\u03c8r0, A(r0)) = w2(1, r0) = +1. Hence (*) w1(4, r0) = min{w2(5, s) : s\u2208Foe(\u03c8, f, r0)}.\nFor each s in Foe(\u03c0, f, r0) let the set of children of p2(5, s) be {p3(1, t) : \u03c0t /\u2208H and t\u2208R s d[f ; s]} \u222a {p3(6, s) : \u03c0\n\u2032s /\u2208H}, where the tags of these children are: t(p3(1, t)) = ((\u03c0,H+\u03c0t,A(t)),min, v3(1, t)); and t(p3(6, s)) = (\u2212(\u03c0\n\u2032,H+\u03c0\u2032s,A(s)),\u2212, v3(6, s)). So +1 = v2(5, s) = max[{v3(1, t) : \u03c0t /\u2208H and t\u2208R s d[f ; s]} \u222a {v3(6, s) : \u03c0 \u2032s /\u2208H}.\nFor each s in Foe(\u03c8, f, r0) let the set of children of q2(5, s) be {q3(1, t) : \u03c8t /\u2208H(\u03c0 :=\u03c8) and t\u2208Rsd[f ; s]} \u222a {q3(6, s) : \u03c8\n\u2032s /\u2208H(\u03c0 :=\u03c8)}, where the tags of these children are: t(q3(1, t)) = ((\u03c8,H(\u03c0 :=\u03c8)+\u03c8t,A(t)),min, w3(1, t)); and t(q3(6, s)) = (\u2212(\u03c8\n\u2032,H(\u03c0 :=\u03c8)+\u03c8\u2032s,A(s)),\u2212, w3(6, s)). So w2(5, s) = max[{w3(1, t) : \u03c8t /\u2208H(\u03c0 :=\u03c8) and t\u2208R s d[f ; s]} \u222a {w3(6, s) : \u03c8 \u2032s /\u2208H(\u03c0 :=\u03c8)}].\nTake any s in Foe(\u03c8, f, r0). We shall show that w2(5, s) = +1. Suppose there exists t0 such that \u03c0t0 /\u2208H and t0\u2208R s d[f ; s] and\n+1 = v3(1, t0) = T (\u03c0,H+\u03c0t0, A(t0)). Then p3(1, t0) exists, and \u03c8t0 /\u2208H(\u03c0 :=\u03c8) and so q3(1, t0) exists. Since |T [\u03c0,H+\u03c0t0, A(t0)]| < n, then by Y (n) we have T (\u03c8,H(\u03c0 :=\u03c8)+\u03c8t0, A(t0)) = w3(1, t0) = +1. Hence w2(5, s) = +1.\nSo suppose that such a t0 does not exist. Then v3(6, s) = +1 and so p3(6, s) exists and \u03c0\u2032s /\u2208H. Hence \u03c8\u2032s /\u2208H(\u03c0 :=\u03c8), and so q3(6, s) exists. Let the child of p3(6, s) be p4(1, s) where t(p4(1, s)) = ((\u03c0\n\u2032,H+\u03c0\u2032s,A(s)),min, v4(1, s)). Then +1 = v3(6, s) = \u2212v4(1, s). So v4(1, s) = \u22121 and hence T (\u03c0\n\u2032,H+\u03c0\u2032s,A(s)) = \u22121. By Theorem A.8(1), (\u03c0\u2032,H+\u03c0\u2032s) 6|\u2212A(s). By Definition B.3 with \u03b1 = \u03c8\u2032 and Definition C.2, H(\u03c0 :=\u03c8)(\u03c8\u2032 :=\u03c0\u2032) = H and (\u03c8\u2032s)(\u03c8\u2032 :=\u03c0\u2032) = (\u03c0\u2032s).\nLet the child of q3(6, s) be q4(1, s) where t(q4(1, s)) = ((\u03c8\n\u2032,H(\u03c0 :=\u03c8)+\u03c8\u2032s,A(s)),min, w4(1, s)). Then w3(6, s) = \u2212w4(1, s). Assume w4(1, s) = +1. Then T (\u03c8\n\u2032,H(\u03c0 :=\u03c8)+\u03c8\u2032s,A(s)) = +1 and so by Theorem A.8(1), (\u03c8\u2032,H(\u03c0 :=\u03c8)+\u03c8\u2032s) |\u2212A(s). By Lemma B.4 with \u03b1 = \u03c8\u2032, (\u03c0\u2032,H(\u03c0 :=\u03c8)(\u03c8\u2032 :=\u03c0\u2032)++(\u03c8\u2032s)(\u03c8\u2032 :=\u03c0\u2032)) |\u2212A(s). But from the previous paragraph, this simplifies to (\u03c0\u2032,H+\u03c0\u2032s) |\u2212A(s). This contradiction shows that w4(1, s) = \u22121. Hence w3(6, s) = +1. Therefore w2(5, s) = +1.\nThus for all s in Foe(\u03c8, f, r0), w2(5, s) = +1. So by (*), w1(4, r0) = +1 and hence w0 = +1, as required.\nSince the subject of p0 is (\u03c0,H, x), p0 does not satisfy T4, or T5, or T6. Thus Y (n), and hence the lemma, is proved by induction."}, {"heading": "EndProofLemC.3", "text": "Definition C.4. If H is a \u03c8-history then define H(\u03c8 :=\u03b2) to be the sequence formed from H by just replacing each \u03c8 by \u03b2, and each \u03c8\u2032 by \u03b2\u2032.\nLemma C.5. Suppose P = (R,>) is a plausible theory, H is a \u03c8-history, and x is either a formula or a finite set of formulas.\n1) If (\u03c8,H) |\u2212x then (\u03b2,H(\u03c8 :=\u03b2)) |\u2212x. 2) If (\u03c8\u2032,H) 6|\u2212x then (\u03b2\u2032,H(\u03c8 :=\u03b2)) 6|\u2212x. Hence P(\u03c8)\u2286P(\u03b2) and P(\u03b2\u2032)\u2286P(\u03c8\u2032)."}, {"heading": "Proof", "text": "Suppose (R,>) is a plausible theory, Ax is its set of axioms, H is a \u03c8-history, and x is either a formula or a finite set of formulas. Note that H is a \u03c8-history iff H is a \u03c8\u2032-history. Let Y (k) and Z(k) denote the following conditional statements.\nY (k): If H is a \u03c8-history, x is either a formula or a finite set of formulas, T (\u03c8,H, x) = +1, and |T [\u03c8,H, x]| \u2264 k then T (\u03b2,H(\u03c8 :=\u03b2), x) = +1. Z(k): If H is a \u03c8\u2032-history, x is either a formula or a finite set of formulas, T (\u03c8\u2032,H, x) = \u22121, and |T [\u03c8\u2032,H, x]| \u2264 k then T (\u03b2\u2032,H(\u03c8 :=\u03b2), x) = \u22121.\nBy Theorem A.8(1,2) and Theorem A.7(2) it suffices to prove Y (k) and Z(k) by induction on k.\nSuppose k = 1.\nLet the antecedent of Y (1) hold. Let p0 be the root of T [\u03c8,H, x] and q0 be the root of T [\u03b2,H(\u03c8 :=\u03b2), x]. Then p0 has no children. If p0 satisfies T1 then x = {} and so q0 satisfies T1. So by T1, T [\u03b2,H(\u03c8 :=\u03b2), {}] has only one node and T (\u03b2,H(\u03c8 :=\u03b2), {}) = +1. If p0 satisfies T2 then x = f and Ax |= f . So q0 satisfies T2 and hence T (\u03b2,H(\u03c8 :=\u03b2), f) = +1. Since p0 has no children and the proof value of p0 is +1, p0 does not satisfy T3. Since the subject of p0 is (\u03c8,H, x), p0 does not satisfy T4 or T5 or T6. Thus Y (1) holds.\nLet the antecedent of Z(1) hold. Let m0 be the root of T [\u03c8 \u2032,H, x] and n0 be the root\nof T [\u03b2\u2032,H(\u03c8 :=\u03b2), x]. Then m0 has no children. Since pv(m0) = T (\u03c8 \u2032,H, x) = \u22121, m0 does not satisfy T1 or T2. If m0 satisfies T3 then x = f and for each r\u2208R s d[f ], \u03c8\n\u2032r\u2208H. So n0 satisfies T3 and for each r\u2208R s d[f ], \u03b2\n\u2032r\u2208H(\u03c8 :=\u03b2). Hence by T3, n0 has no children and so \u22121 = pv(n0) = T (\u03b2 \u2032,H(\u03c8 :=\u03b2), f). Since the subject of m0 is (\u03c8 \u2032,H, x), m0 does not satisfy T4 or T5 or T6. Thus Z(1) holds.\nTake any positive integer k. Suppose that both Y (k) and Z(k) are true. We shall prove both Y (k+1) and Z(k+1).\nSuppose the antecedent of Y (k+1) holds and |T [\u03c8,H, x]| = k+1. We must show T (\u03b2,H(\u03c8 :=\u03b2), x) = +1. Let p0 be the root of T [\u03c8,H, x] and q0 be the root of T [\u03b2,H(\u03c8 :=\u03b2), x].\nIf p0 satisfies T1 then let x be F . We see that q0 also satisfies T1. So t(p0) = ((\u03c8,H,F ),min,+1) and t(q0) = ((\u03b2,H(\u03c8 :=\u03b2), F ),min, w0), where w0 = T (\u03b2,H(\u03c8 :=\u03b2), F ) \u2208 {+1,\u22121}. Let {pf : f \u2208F} be the set of children of p0 and {qf : f \u2208F} be the set of children of q0. Let f be any formula in F . Then the subject of pf is (\u03c8,H, f), and the subject of qf is (\u03b2,H(\u03c8 :=\u03b2), f). Also |T [\u03c8,H, f ]| \u2264 k and the proof value of pf is +1 because p0 is a min node with proof value +1. So by Y (k) the proof value of qf is +1. But this is true for each f , so by T1, w0 = +1, as required.\nSince p0 has a child, p0 does not satisfy T2.\nIf p0 satisfies T3 then let x be f . We see that q0 also satisfies T3. So t(p0) = ((\u03c8,H, f),max,+1) and t(q0) = ((\u03b2,H(\u03c8 :=\u03b2), f),max, w0), where w0 = T (\u03b2,H(\u03c8 :=\u03b2), f) \u2208 {+1,\u22121}.\nWe shall adopt the following naming conventions. Each non-root node of T [\u03c8,H, f ] is denoted by pl(#, y) where l is the level of the node, # is the number in [1..6] such that the node satisfies T#, and y is a rule, or a formula, or a set, which distinguishes siblings. The proof value of pl(#, y) will be denoted by vl(#, y). For non-root nodes in T [\u03b2,H(\u03c8 :=\u03b2), f ] we shall use ql(#, y), and its proof value will be denoted by wl(#, y).\nLet the set of children of p0 be {p1(4, r) : \u03c8r /\u2208H and r\u2208R s d[f ]}, where the tags of\nthese children are: t(p1(4, r)) = ((\u03c8,H, f, r),min, v1(4, r)). So +1 = max{v1(4, r) : \u03c8r /\u2208H and r\u2208R s d[f ]}. Hence there exists r0 in R s d[f ] such that \u03c8r0 /\u2208H and v1(4, r0) = +1. So t(p1(4, r0)) = ((\u03c8,H, f, r0),min,+1).\nLet the set of children of q0 be {q1(4, r) : \u03b2r /\u2208H(\u03c8 :=\u03b2) and r\u2208R s d[f ]}, where the\ntags of these children are: t(q1(4, r)) = ((\u03b2,H(\u03c8 :=\u03b2), f, r),min, w1(4, r)). So w0 = max{w1(4, r) : \u03b2r /\u2208H(\u03c8 :=\u03b2) and r\u2208R s d[f ]}.\nLet the set of children of p1(4, r0) be {p2(1, r0)} \u222a {p2(5, s) : s\u2208Foe(\u03c8, f, r0)}, where the tags of these children are: t(p2(1, r0)) = ((\u03c8,H+\u03c8r0, A(r0)),min, v2(1, r0)); and t(p2(5, s)) = ((\u03c8,H, f, r0, s),max, v2(5, s)). So +1 = v1(4, r0) = min[{v2(1, r0)} \u222a {v2(5, s) : s\u2208Foe(\u03c8, f, r0)}]. Hence v2(1, r0) = +1; and for each s in Foe(\u03c8, f, r0), v2(5, s) = +1.\nLet the set of children of q1(4, r0) be {q2(1, r0)} \u222a {q2(5, s) : s\u2208Foe(\u03b2, f, r0)}, where the tags of these children are: t(q2(1, r0)) = ((\u03b2,H(\u03c8 :=\u03b2)+\u03b2r0, A(r0)),min, w2(1, r0)); and t(q2(5, s)) = ((\u03b2,H(\u03c8 :=\u03b2), f, r0, s),max, w2(5, s)). So w1(4, r0) = min[{w2(1, r0)} \u222a {w2(5, s) : s\u2208Foe(\u03b2, f, r0)}].\nSince |T [\u03c8,H+\u03c8r0, A(r0)]| \u2264 k and T (\u03c8,H+\u03c8r0, A(r0)) = v2(1, r0) = +1, by Y (k) we have T (\u03b2,H(\u03c8 :=\u03b2)+\u03b2r0, A(r0)) = w2(1, r0) = +1. Hence (*) w1(4, r0) = min{w2(5, s) : s\u2208Foe(\u03b2, f, r0)}.\nFor each s in Foe(\u03c8, f, r0) let the set of children of p2(5, s) be {p3(1, t) : \u03c8t /\u2208H and t\u2208R s d[f ; s]} \u222a {p3(6, s) : \u03c8\n\u2032s /\u2208H}, where the tags of these children are: t(p3(1, t)) = ((\u03c8,H+\u03c8t,A(t)),min, v3(1, t)); and t(p3(6, s)) = (\u2212(\u03c8\n\u2032,H+\u03c8\u2032s,A(s)),\u2212, v3(6, s)). So +1 = v2(5, s) = max[{v3(1, t) : \u03c8t /\u2208H and t\u2208R s d[f ; s]} \u222a {v3(6, s) : \u03c8 \u2032s /\u2208H}].\nFor each s in Foe(\u03b2, f, r0) let the set of children of q2(5, s) be {q3(1, t) : \u03b2t /\u2208H(\u03c8 :=\u03b2) and t\u2208Rsd[f ; s]} \u222a {q3(6, s) : \u03b2\n\u2032s /\u2208H(\u03c8 :=\u03b2)}, where the tags of these children are: t(q3(1, t)) = ((\u03b2,H(\u03c8 :=\u03b2)+\u03b2t,A(t)),min, w3(1, t)); and t(q3(6, s)) = (\u2212(\u03b2\n\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032s,A(s)),\u2212, w3(6, s)). So w2(5, s) = max[{w3(1, t) : \u03b2t /\u2208H(\u03c8 :=\u03b2) and t\u2208R s d[f ; s]} \u222a {w3(6, s) : \u03b2 \u2032s /\u2208H(\u03c8 :=\u03b2)}].\nTake any s in Foe(\u03b2, f, r0). We shall show that w2(5, s) = +1. Observe that Foe(\u03c8, f, r0) = Foe(\u03b2, f, r0).\nSuppose there exists t0 such that \u03c8t0 /\u2208H and t0\u2208R s d[f ; s] and\n+1 = v3(1, t0) = T (\u03c8,H+\u03c8t0, A(t0)). Then p3(1, t0) exists. Since \u03c8t0\u2208H iff \u03b2t0\u2208H(\u03c8 :=\u03b2), we have \u03b2t0 /\u2208H(\u03c8 :=\u03b2) and so q3(1, t0) exists. Since |T [\u03c8,H+\u03c8t0, A(t0)]| \u2264 k, then by Y (k) we have T (\u03b2,H(\u03c8 :=\u03b2)+\u03b2t0, A(t0)) = w3(1, t0) = +1. Hence w2(5, s) = +1.\nSo suppose that such a t0 does not exist. Then v3(6, s) = +1 and so p3(6, s) exists and \u03c8\u2032s /\u2208H. Since \u03c8\u2032s\u2208H iff \u03b2\u2032s\u2208H(\u03c8 :=\u03b2), we have \u03b2\u2032s /\u2208H(\u03c8 :=\u03b2), and so q3(6, s) exists. Let the child of p3(6, s) be p4(1, s) where t(p4(1, s)) = ((\u03c8\n\u2032,H+\u03c8\u2032s,A(s)),min, v4(1, s)). Then +1 = v3(6, s) = \u2212v4(1, s). So v4(1, s) = \u22121 and hence T (\u03c8\n\u2032,H+\u03c8\u2032s,A(s)) = \u22121. Since |T [\u03c8\u2032,H+\u03c8\u2032s,A(s)]| \u2264 k, then by Z(k), T (\u03b2\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032s,A(s)) = \u22121.\nLet the child of q3(6, s) be q4(1, s) where t(q4(1, s)) = ((\u03b2\n\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032s,A(s)),min, w4(1, s)). Then w3(6, s) = \u2212w4(1, s) = \u2212T (\u03b2\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032s,A(s)) = +1. Therefore w2(5, s) = +1.\nThus for all s in Foe(\u03b2, f, r0), w2(5, s) = +1. So by (*), w1(4, r0) = +1 and hence w0 = +1, as required.\nSince the subject of p0 is (\u03c8,H, x), p0 does not satisfy T4, or T5, or T6. Thus Y (k+1) is proved.\nTo prove Z(k+1) we suppose the antecedent of Z(k+1) holds and |T [\u03c8\u2032,H, x]| = k+1. We must show T (\u03b2\u2032,H(\u03c8 :=\u03b2), x) = \u22121. Let m0 be the root of T [\u03c8\n\u2032,H, x] and n0 be the root of T [\u03b2\u2032,H(\u03c8 :=\u03b2), x]. Then m0 has a child and pv(m0) = T (\u03c8 \u2032,H, x) = \u22121.\nIf m0 satisfies T1 then let x be F . We see that n0 also satisfies T1. So t(m0) = ((\u03c8 \u2032,H, F ),min,\u22121) and t(n0) = ((\u03b2 \u2032,H(\u03c8 :=\u03b2), F ),min, pv(n0)), where pv(n0) = T (\u03b2 \u2032,H(\u03c8 :=\u03b2), F ) \u2208 {+1,\u22121}. Let {mf : f \u2208F} be the set of children of m0 and {nf : f \u2208F} be the set of children of n0. Let f be any formula in F . Then the subject of mf is (\u03c8 \u2032,H, f), and the subject of nf is (\u03b2 \u2032,H(\u03c8 :=\u03b2), f). Also |T [\u03c8\u2032,H, f ]| \u2264 k. There exists f0\u2208F such at pv (mf0) = \u22121 because m0 is a min node with proof value \u22121. So by Z(k), pv(nf0) = T (\u03b2\n\u2032,H(\u03c8 :=\u03b2), f0) = \u22121. But n0 is a min node, so pv(n0) = \u22121, as required.\nSince pv(m0) = T (\u03c8 \u2032,H, x) = \u22121, m0 does not satisfy T2.\nIf m0 satisfies T3 then let x be f . We see that n0 also satisfies T3. So t(m0) = ((\u03c8 \u2032,H, f),max,\u22121) and t(n0) = ((\u03b2 \u2032,H(\u03c8 :=\u03b2), f),max, pv (n0)), where pv(n0) = T (\u03b2 \u2032,H(\u03c8 :=\u03b2), f) \u2208 {+1,\u22121}.\nWe shall adopt the following naming conventions. Each non-root node of T [\u03c8\u2032,H, f ] is denoted by ml(#, y) where l is the level of the node, # is the number in [1..6] such that the node satisfies T#, and y is a rule, or a formula, or a set, which distinguishes siblings. For non-root nodes in T [\u03b2\u2032,H(\u03c8 :=\u03b2), f ] we shall use nl(#, y).\nLet the set of children of m0 be {m1(4, r) : \u03c8 \u2032r /\u2208H and r\u2208Rsd[f ]}, where the tags of\nthese children are: t(m1(4, r)) = ((\u03c8 \u2032,H, f, r),min, pv (m1(4, r))). Recall that m0 has at least one child. So \u22121 = max{pv (m1(4, r)) : \u03c8 \u2032r /\u2208H and r\u2208Rsd[f ]}. Hence if \u03c8\n\u2032r /\u2208H and r\u2208Rsd[f ] then pv(m1(4, r)) = \u22121. Therefore t(m1(4, r)) = ((\u03c8 \u2032,H, f, r),min,\u22121).\nLet the set of children of n0 be {n1(4, r) : \u03b2 \u2032r /\u2208H(\u03c8 :=\u03b2) and r\u2208Rsd[f ]}, where the\ntags of these children are: t(n1(4, r)) = ((\u03b2 \u2032,H(\u03c8 :=\u03b2), f, r),min, pv (n1(4, r))). So pv(n0) = max{pv (n1(4, r)) : \u03b2 \u2032r /\u2208H(\u03c8 :=\u03b2) and r\u2208Rsd[f ]}. If n0 does not have a child then pv(n0) = max{} = \u22121, as required. So suppose that n0 has at least one child.\nIf \u03c8\u2032r /\u2208H and r\u2208Rsd[f ] then let the set of children of m1(4, r) be {m2(1, r)} \u222a {m2(5, s) : s\u2208R[\u00acf ; r]}, where the tags of these children are: t(m2(1, r)) = ((\u03c8\n\u2032,H+\u03c8\u2032r,A(r)),min, pv(m2(1, r))); and t(m2(5, s)) = ((\u03c8\n\u2032,H, f, r, s),max, pv (m2(5, s))). So \u22121 = pv(m1(4, r)) = min[{pv(m2(1, r))} \u222a {pv (m2(5, s)) : s\u2208R[\u00acf ; r]}]. Therefore either pv(m2(1, r)) = \u22121 or there exists s0 in R[\u00acf ; r] such that pv(m2(5, s0)) = \u22121.\nIf \u03b2\u2032r /\u2208H(\u03c8 :=\u03b2) and r\u2208Rsd[f ] then let the set of children of n1(4, r) be {n2(1, r)} \u222a {n2(5, s) : s\u2208Foe(\u03b2\n\u2032, f, r)}, where the tags of these children are: t(n2(1, r)) = ((\u03b2\n\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032r,A(r)),min, pv(n2(1, r))); and t(n2(5, s)) = ((\u03b2\n\u2032,H(\u03c8 :=\u03b2), f, r, s),max, pv(n2(5, s))). So pv(n1(4, r)) = min[{pv (n2(1, r))} \u222a {pv (n2(5, s)) : s\u2208Foe(\u03b2 \u2032, f, r)}].\nWe show that for each r in Rsd[f ] such that \u03b2 \u2032r /\u2208H(\u03c8 :=\u03b2), pv(n1(4, r)) = \u22121. We have |T [\u03c8\u2032,H+\u03c8\u2032r,A(r)]| \u2264 k. If \u22121 = pv(m2(1, r)) = T (\u03c8 \u2032,H+\u03c8\u2032r,A(r)) then\nby Z(k), pv(n2(1, r)) = T (\u03b2 \u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032r,A(r)) = \u22121. Hence pv(n1(4, r)) = \u22121.\nSo suppose there exists s0 in R[\u00acf ; r] such that T (\u03c8 \u2032,H, f, r, s0) = pv(m2(5, s0)) = \u22121.\nThen s0\u2208Foe(\u03b2 \u2032, f, r). We shall show that T (\u03b2\u2032,H(\u03c8 :=\u03b2), f, r, s0) = pv(n2(5, s0)) = \u22121, and hence that pv(n1(4, r)) = \u22121.\nLet the set of children of m2(5, s0) be {m3(1, t) : \u03c8\n\u2032t /\u2208H and t\u2208Rsd[f ; s0]} \u222a {m3(6, s0) : \u03c8s0 /\u2208H}, where the tags of these children are: t(m3(1, t)) = ((\u03c8\n\u2032,H+\u03c8\u2032t, A(t)),min, pv (m3(1, t))), and t(m3(6, s0)) = (\u2212(\u03c8,H+\u03c8s0, A(s0)),\u2212, pv (m3(6, s0))). So \u22121 = pv(m2(5, s0)) = max[{pv (m3(1, t)) : \u03c8\n\u2032t /\u2208H and t\u2208Rsd[f ; s0]} \u222a {pv (m3(6, s0)) : \u03c8s0 /\u2208H}]. Hence for all t in R s d[f ; s0] such that \u03c8\n\u2032t /\u2208H we have \u22121 = pv(m3(1, t)) = T (\u03c8\n\u2032,H+\u03c8\u2032t, A(t)). Also if \u03c8s0 /\u2208H then \u22121 = pv(m3(6, s0)) = T (\u2212(\u03c8,H+\u03c8s0, A(s0))).\nLet the set of children of n2(5, s0) be {n3(1, t) : \u03b2\n\u2032t /\u2208H(\u03c8 :=\u03b2) and t\u2208Rsd[f ; s0]} \u222a {n3(6, s0) : \u03b2s0 /\u2208H(\u03c8 :=\u03b2)}, where the tags of these children are: t(n3(1, t)) = ((\u03b2\n\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032t, A(t)),min, pv(n3(1, t))), and t(n3(6, s0)) = (\u2212(\u03b2,H(\u03c8 :=\u03b2)+\u03b2s0, A(s0)),\u2212, pv (n3(6, s0))). So pv(n2(5, s0)) = max[{pv (n3(1, t)) : \u03b2 \u2032t /\u2208H(\u03c8 :=\u03b2) and t\u2208Rsd[f ; s0]} \u222a\n{pv (n3(6, s0)) : \u03b2s0 /\u2208H(\u03c8 :=\u03b2)}]. If n2(5, s0) has no children then pv(n2(5, s0)) = max{} = \u22121, as required. So suppose that n2(5, s0) has at least one child.\nCase 1: n3(1, t) is a child of n2(5, s0). Then \u03b2\u2032t /\u2208H(\u03c8 :=\u03b2) and t\u2208Rsd[f ; s0]. Hence \u03c8\n\u2032t /\u2208H. So from above, \u22121 = pv(m3(1, t)) = T (\u03c8\n\u2032,H+\u03c8\u2032t, A(t)). Also |T [\u03c8\u2032,H+\u03c8\u2032t, A(t)]| \u2264 k. So by Z(k), \u22121 = T (\u03b2\u2032,H(\u03c8 :=\u03b2)+\u03b2\u2032t, A(t)) = pv(t(n3(1, t))).\nCase 2: n3(6, s0) is a child of n2(5, s0). Then \u03b2s0 /\u2208H(\u03c8 :=\u03b2). Hence \u03c8s0 /\u2208H. So from above, \u22121 = pv(m3(6, s0)) = T (\u2212(\u03c8,H+\u03c8s0, A(s0))). Therefore T (\u03c8,H+\u03c8s0, A(s0)) = +1. Also |T [\u03c8,H+\u03c8s0, A(s0)]| \u2264 k. So by Y (k), T (\u03b2,H(\u03c8 :=\u03b2)+\u03b2s0, A(s0)) = +1. But pv(n3(6, s0)) = \u2212T (\u03b2,H(\u03c8 :=\u03b2)+\u03b2s0, A(s0)) = \u2212+ 1 = \u22121.\nThese two cases show that pv(n2(5, s0)) = \u22121, as required. Hence pv(n1(4, r)) = \u22121. Therefore pv(n0) = \u22121. Thus Z(k+1) is proved.\nTherefore Y (k) and Z(k) are proved by induction, and so the lemma is proved."}, {"heading": "EndProofLemC.5", "text": "Definition C.6. Suppose {\u03b1, \u03b3, \u03bb}\u2286Alg , H is a \u03b1-history, and T is an evaluation tree of some plausible theory. If \u03b1 /\u2208{\u03b3, \u03b3\u2032, \u03bb, \u03bb\u2032} then define \u03b1(\u03b3 :\u03bb) = \u03b1; else define \u03b3(\u03b3 :\u03bb) = \u03bb, \u03b3\u2032(\u03b3 :\u03bb) = \u03bb\u2032, \u03bb(\u03b3 :\u03bb) = \u03b3, and \u03bb\u2032(\u03b3 :\u03bb) = \u03b3\u2032.\nIf H = (\u03b11r1, ..., \u03b1nrn) then define H(\u03b3 :\u03bb) = (\u03b11(\u03b3 :\u03bb)r1, ..., \u03b1n(\u03b3 :\u03bb)rn). Define T (\u03b3 :\u03bb) to be the tree formed from T by only changing the subject of each node as follows. For each node p of T replace alg(p) by alg(p)(\u03b3 : \u03bb), and replace Hist(p) by Hist(p)(\u03b3 :\u03bb).\nLemma C.7. Suppose P = (R,>) is a plausible theory such that > is empty. If T is an evaluation tree of P then T (\u03c0 :\u03c8) is an evaluation tree of P. Hence P(\u03c8) = P(\u03c0) and P(\u03c0\u2032) = P(\u03c8\u2032)."}, {"heading": "Proof", "text": "Let P = (R,>) be a plausible theory such that > is empty. Then Foe(\u03c8\u2032, f, r) = {} = Foe(\u03c0\u2032, f, r) and Foe(\u03c0, f, r) = R[\u00acf ] = Foe(\u03c8, f, r). Let Y (n) denote the following conditional statement. \u201cIf T is an evaluation tree of P and |T | \u2264 n then T (\u03c0 :\u03c8) is an evaluation tree of P.\u201d By Definition 5.14, it suffices to prove Y (n) by induction on n.\nSuppose n = 1 and the antecedent of Y (1) holds. Let the root of T be p0 and alg(p0) = \u03b1. If \u03b1 /\u2208{\u03c0, \u03c8, \u03c8\n\u2032, \u03c0\u2032} then T (\u03c0 :\u03c8) = T and so Y (1) holds. So suppose \u03b1\u2208{\u03c0, \u03c8, \u03c8\u2032, \u03c0\u2032}. Let the root of T (\u03c0 :\u03c8) be q0, and let alg(q0) = \u03bb. So \u03b1(\u03c0 :\u03c8) = \u03bb. Since p0 has no children, q0 has no children. If p0 satisfies T1 then let Subj (p0) = (\u03b1,H, {}). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), {}) and so q0 satisfies T1. Thus T (\u03c0 :\u03c8) is an evaluation tree of P. If p0 satisfies T2 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f) and so q0 satisfies T2. Thus T (\u03c0 :\u03c8) is an evaluation tree of P. If p0 satisfies T3 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f). Since p0 has no children, S(p0) = {}. So if r\u2208R s d[f ] then \u03b1r\u2208H. Now \u03b1r\u2208H iff \u03bbr\u2208H(\u03c0 :\u03c8). Hence S(q0) = {} and so q0 satisfies T3. Thus T (\u03c0 :\u03c8) is an evaluation tree of P. Since p0 and q0 have no children, p0 and q0 satisfy neither T4 nor T6. If p0 satisfies T5 then let Subj (p0) = (\u03b1,H, f, r, s). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f, r, s).\nSince p0 has no children, S(p0) = {}. Hence if t\u2208R s d[f ; s] then \u03b1t\u2208H. Now \u03b1t\u2208H iff \u03bbt\u2208H(\u03c0 :\u03c8). Also \u03b1\u2032s\u2208H. Hence \u03bb\u2032s\u2208H(\u03c0 :\u03c8). So S(q0) = {}. Thus q0 satisfies T5 and so T (\u03c0 :\u03c8) is an evaluation tree of P.\nAll cases have been considered and so Y (1) holds.\nIf T is any tree and p is any node of T for which Subj (p) is defined, then define the set S(p, T ) of subjects of the children of p in T by S(p, T ) = {Subj (c) : c is a child of p in T}.\nTake any integer n such that n \u2265 1. Suppose that Y (n) is true. We shall prove Y (n+1). Suppose the antecedent of Y (n+1) holds and that |T | = n+1. Let the root of T be p0 and alg(p0) = \u03b1. If \u03b1 /\u2208{\u03c0, \u03c8, \u03c8\n\u2032, \u03c0\u2032} then T (\u03c0 :\u03c8) = T and so Y (n+1) holds. So suppose \u03b1\u2208{\u03c0, \u03c8, \u03c8\u2032, \u03c0\u2032}. Let the root of T (\u03c0 :\u03c8) be q0, and let alg(q0) = \u03bb. So \u03b1(\u03c0 :\u03c8) = \u03bb.\nIf p0 satisfies T1 then let Subj (p0) = (\u03b1,H,F ). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), F ). So q0 satisfies T1. Recall that S(p0, T [\u03b1,H,F ]) = {(\u03b1,H, f) : f \u2208F}. So S(q0, T [\u03b1,H,F ](\u03c0 :\u03c8)) = {(\u03bb,H(\u03c0 :\u03c8), f) : f \u2208F} = S(q0, T [\u03bb,H(\u03c0 :\u03c8), F ]), by T1. But for each (\u03b1,H, f) in S(p0, T [\u03b1,H,F ]), T [\u03b1,H, f ] is an evaluation tree of P and |T [\u03b1,H, f ]| \u2264 n. So by Y (n), T [\u03b1,H, f ](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1,H, f ](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f ]. Thus T (\u03c0 :\u03c8) = T [\u03b1,H,F ](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), F ] which is an evaluation tree of P.\nSince p0 has a child, p0 does not satisfy T2.\nIf p0 satisfies T3 then let Subj (p0) = (\u03b1,H, f). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f). So q0 satisfies T3. Recall that S(p0, T [\u03b1,H, f ]) = {(\u03b1,H, f, r) : \u03b1r /\u2208H and r\u2208R s d[f ]}. Since \u03b1r\u2208H iff \u03bbr\u2208H(\u03c0 :\u03c8) we have \u03b1r /\u2208H iff \u03bbr /\u2208H(\u03c0 :\u03c8). So S(q0, T [\u03b1,H, f ](\u03c0 :\u03c8)) = {(\u03bb,H(\u03c0 :\u03c8), f, r) : \u03b1r /\u2208H and r\u2208Rsd[f ]} = {(\u03bb,H(\u03c0 :\u03c8), f, r) : \u03bbr /\u2208H(\u03c0 :\u03c8) and r\u2208Rsd[f ]} = S(q0, T [\u03bb,H(\u03c0 :\u03c8), f ]), by T3. But for each (\u03b1,H, f, r) in S(p0, T [\u03b1,H, f ]), T [\u03b1,H, f, r] is an evaluation tree of P and |T [\u03b1,H, f, r]| \u2264 n. So by Y (n), T [\u03b1,H, f, r](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1,H, f, r](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f, r]. Thus T (\u03c0 :\u03c8) = T [\u03b1,H, f ](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f ] which is an evaluation tree of P.\nIf p0 satisfies T4 then let Subj (p0) = (\u03b1,H, f, r). Hence Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f, r). Since \u03b1r\u2208H iff \u03bbr\u2208H(\u03c0 :\u03c8) we have \u03b1r /\u2208H iff \u03bbr /\u2208H(\u03c0 :\u03c8). So q0 satisfies T4. Recall that S(p0, T [\u03b1,H, f, r]) = {(\u03b1,H+\u03b1r,A(r))} \u222a {(\u03b1,H, f, r, s) : s\u2208Foe(\u03b1, f, r)}. Since Foe(\u03b1, f, r) = Foe(\u03bb, f, r), S(q0, T [\u03b1,H, f, r](\u03c0 :\u03c8)) = {(\u03bb,H(\u03c0 :\u03c8)+\u03bbr,A(r))} \u222a {(\u03bb,H(\u03c0 :\u03c8), f, r, s) : s\u2208Foe(\u03b1, f, r)} = S(q0, T [\u03bb,H(\u03c0 :\u03c8), f, r]), by T4. But T [\u03b1,H+\u03b1r,A(r)] is an evaluation tree of P and |T [\u03b1,H+\u03b1r,A(r)]| \u2264 n. So by Y (n), T [\u03b1,H+\u03b1r,A(r)](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1,H+\u03b1r,A(r)](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8)+\u03bbr,A(r)]. Also for each (\u03b1,H, f, r, s) in S(p0, T [\u03b1,H, f, r]), T [\u03b1,H, f, r, s] is an evaluation tree of P and |T [\u03b1,H, f, r, s]| \u2264 n. So by Y (n), T [\u03b1,H, f, r, s](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1,H, f, r, s](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f, r, s]. Thus T (\u03c0 :\u03c8) = T [\u03b1,H, f, r](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f, r] which is an evaluation tree of P.\nIf p0 satisfies T5 then let Subj (p0) = (\u03b1,H, f, r, s). Then \u03b1 6= \u03c0 \u2032. Since\ns\u2208Foe(\u03b1, f, r), Foe(\u03b1, f, r) 6= {} and so \u03b1 6= \u03c8\u2032. Therefore \u03b1\u2208{\u03c0, \u03c8} and so \u03bb\u2208{\u03c0, \u03c8}. Now Subj (q0) = (\u03bb,H(\u03c0 :\u03c8), f, r, s). Since \u03b1r\u2208H iff \u03bbr\u2208H(\u03c0 :\u03c8) we have \u03b1r /\u2208H iff \u03bbr /\u2208H(\u03c0 :\u03c8). So q0 satisfies T5. Recall that S(p0, T [\u03b1,H, f, r, s]) = {(\u03b1,H+\u03b1t,A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]}\u222a {\u2212(\u03b1\n\u2032,H+\u03b1\u2032s,A(s)) : \u03b1\u2032s /\u2208H}. Also since \u03b1\u2032s\u2208H iff \u03bb\u2032s\u2208H(\u03c0 :\u03c8) we have \u03b1\u2032s /\u2208H iff \u03bb\u2032s /\u2208H(\u03c0 :\u03c8). So S(q0, T [\u03b1,H, f, r, s](\u03c0 :\u03c8))\n= {(\u03bb,H(\u03c0 :\u03c8)+\u03bbt,A(t)) : \u03b1t /\u2208H and t\u2208Rsd[f ; s]}\u222a{\u2212(\u03bb \u2032,H(\u03c0 :\u03c8)+\u03bb\u2032s,A(s)) : \u03b1\u2032s /\u2208H} = {(\u03bb,H(\u03c0 :\u03c8)+\u03bbt,A(t)) : \u03bbt /\u2208H(\u03c0 :\u03c8) and t\u2208Rsd[f ; s]}\u222a {\u2212(\u03bb\u2032,H(\u03c0 :\u03c8)+\u03bb\u2032s,A(s)) : \u03bb\u2032s /\u2208H(\u03c0 :\u03c8)} = S(q0, T [\u03bb,H(\u03c0 :\u03c8), f, r, s]), by T5.\nBut for each (\u03b1,H+\u03b1t,A(t)) in S(p0, T [\u03b1,H, f, r, s]), T [\u03b1,H+\u03b1t,A(t)] is an evaluation tree of P and |T [\u03b1,H+\u03b1t,A(t)]| \u2264 n. So by Y (n), T [\u03b1,H+\u03b1t,A(t)](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1,H+\u03b1t,A(t)](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8)+\u03bbt,A(t)]. Also if \u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s)) \u2208 S(p0, T [\u03b1,H, f, r, s]), then T [\u2212(\u03b1\n\u2032,H+\u03b1\u2032s,A(s))] is an evaluation tree of P and |T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))]| \u2264 n. So by Y (n), T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u2212(\u03b1\u2032,H+\u03b1\u2032s,A(s))](\u03c0 :\u03c8) = T [\u2212(\u03bb\u2032,H(\u03c0 :\u03c8)+\u03bb\u2032s,A(s))].\nThus T (\u03c0 :\u03c8) = T [\u03b1,H, f, r, s](\u03c0 :\u03c8) = T [\u03bb,H(\u03c0 :\u03c8), f, r, s] which is an evaluation tree of P.\nIf p0 satisfies T6 then let Subj (p0) = \u2212(\u03b1 \u2032,H, F ). Then \u03b1\u2208{\u03c0, \u03c8} and so \u03bb\u2208{\u03c8, \u03c0}.\nHence Subj (q0) = \u2212(\u03bb \u2032,H(\u03c0 :\u03c8), F ). So q0 satisfies T6. Recall that S(p0, T [\u2212(\u03b1 \u2032,H, F )]) = {(\u03b1\u2032,H, F )}. So S(q0, T [\u2212(\u03b1\n\u2032,H, F )](\u03c0 :\u03c8)) = {(\u03bb\u2032,H(\u03c0 :\u03c8), F )} = S(q0, T [\u2212(\u03bb\n\u2032,H(\u03c0 :\u03c8), F )]), by T6. But T [\u03b1\u2032,H, F ] is an evaluation tree of P and |T [\u03b1\u2032,H, F ]| \u2264 n. So by Y (n), T [\u03b1\u2032,H, F ](\u03c0 :\u03c8) is an evaluation tree of P. Hence T [\u03b1\u2032,H, F ](\u03c0 :\u03c8) = T [\u03bb\u2032,H(\u03c0 :\u03c8), F ]. Thus T (\u03c0 :\u03c8) = T [\u2212(\u03b1\u2032,H, F )](\u03c0 :\u03c8) = T [\u2212(\u03bb\u2032,H(\u03c0 :\u03c8), F )] which is an evaluation tree of P.\nTherefore Y (n+1), and hence the lemma, is proved by induction."}, {"heading": "EndProofLemC.7", "text": "Theorem C.8 (Theorem 7.6 The proof algorithm hierarchy). Suppose P = (R,>) is a plausible theory. 1) P(\u03d5) \u2286 P(\u03c0) \u2286 P(\u03c8) \u2286 P(\u03b2) = P(\u03b2\u2032) \u2286 P(\u03c8\u2032) \u2286 P(\u03c0\u2032). 2) If > is empty then P(\u03d5) \u2286 P(\u03c0) = P(\u03c8) \u2286 P(\u03b2) = P(\u03b2\u2032) \u2286 P(\u03c8\u2032) = P(\u03c0\u2032)."}, {"heading": "Proof", "text": "Suppose P = (R,>) is a plausible theory. By Lemma C.1, P(\u03d5) \u2286 P(\u03c0). By Lemma C.3, P(\u03c0) \u2286 P(\u03c8). By Lemma C.5(1), P(\u03c8) \u2286 P(\u03b2). By Lemma B.8, P(\u03b2) = P(\u03b2\u2032). By Lemma C.5(2), P(\u03b2\u2032) \u2286 P(\u03c8\u2032). By Lemma B.4, P(\u03c8\u2032) \u2286 P(\u03c0\u2032). So part (1) holds.\nPart (2) holds by part (1) and Lemma C.7."}, {"heading": "EndProofThmC.8", "text": ""}], "references": [{"title": "The Logic of Conditionals: An Application of Probability to Deductive Logic. D", "author": ["E.W. Adams"], "venue": null, "citeRegEx": "Adams,? \\Q1975\\E", "shortCiteRegEx": "Adams", "year": 1975}, {"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourr\u00f2n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "Alchourr\u00f2n et al\\.,? \\Q1985\\E", "shortCiteRegEx": "Alchourr\u00f2n et al\\.", "year": 1985}, {"title": "Nonmonotonic Reasoning", "author": ["G. Antoniou"], "venue": null, "citeRegEx": "Antoniou,? \\Q1997\\E", "shortCiteRegEx": "Antoniou", "year": 1997}, {"title": "The logic of conditionals", "author": ["H. Arlo-Costa", "P. Egr\u00e9"], "venue": "The Stanford Encyclopedia of Philosophy (Winter 2016 edition)", "citeRegEx": "Arlo.Costa and Egr\u00e9,? \\Q2016\\E", "shortCiteRegEx": "Arlo.Costa and Egr\u00e9", "year": 2016}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": null, "citeRegEx": "Baral,? \\Q2003\\E", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Representing default rules in possibilistic logic", "author": ["S. Benferhat", "D. Dubois", "H. Prade"], "venue": "Proceedings of the Third International Conference on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Benferhat et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Benferhat et al\\.", "year": 1992}, {"title": "A defeasible logic for clauses", "author": ["D. Billington"], "venue": "AI 2011: Advances in Artificial Intelligence 24th Australasian Joint Conference Perth, Australia, December 5-8,", "citeRegEx": "Billington,? \\Q2011\\E", "shortCiteRegEx": "Billington", "year": 2011}, {"title": "An inclusion theorem for defeasible logics", "author": ["D. Billington", "G. Antoniou", "G. Governatori", "M.J. Maher"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Billington et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Billington et al\\.", "year": 2010}, {"title": "Propositional plausible logic: Introduction and implementation", "author": ["D. Billington", "A. Rock"], "venue": "Studia Logica,", "citeRegEx": "Billington and Rock,? \\Q2001\\E", "shortCiteRegEx": "Billington and Rock", "year": 2001}, {"title": "Defeasible logic is stable", "author": ["D. Billington"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Billington,? \\Q1993\\E", "shortCiteRegEx": "Billington", "year": 1993}, {"title": "Propositional clausal defeasible logic", "author": ["D. Billington"], "venue": "Logics in Artificial Intelligence,", "citeRegEx": "Billington,? \\Q2008\\E", "shortCiteRegEx": "Billington", "year": 2008}, {"title": "A propositional plausible logic", "author": ["D. Billington"], "venue": "AI 2015: Advances in Artificial Intelligence,", "citeRegEx": "Billington,? \\Q2015\\E", "shortCiteRegEx": "Billington", "year": 2015}, {"title": "On the entailment problem for a logic of typicality", "author": ["R. Booth", "G. Casini", "T. Meyer", "I. Varzinczak"], "venue": "In Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Booth et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Booth et al\\.", "year": 2015}, {"title": "A propositional typicality logic for extending rational consequence", "author": ["R. Booth", "T. Meyer", "I. Varzinczak"], "venue": "Logic and Cognitive Systems,", "citeRegEx": "Booth et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Booth et al\\.", "year": 2013}, {"title": "Conditional logics of normality: A modal approach", "author": ["C. Boutilier"], "venue": "Artificial Intelligence,", "citeRegEx": "Boutilier,? \\Q1994\\E", "shortCiteRegEx": "Boutilier", "year": 1994}, {"title": "Unifying default reasoning and belief revision in a modal framework", "author": ["C. Boutilier"], "venue": "Artificial Intelligence,", "citeRegEx": "Boutilier,? \\Q1994\\E", "shortCiteRegEx": "Boutilier", "year": 1994}, {"title": "Preferred subtheories: An extended logical framework for default reasoning", "author": ["G. Brewka"], "venue": "Proceedings of the Eleventh International Joint Conference on Artificial Intelligence (IJCAI89),", "citeRegEx": "Brewka,? \\Q1989\\E", "shortCiteRegEx": "Brewka", "year": 1989}, {"title": "Quick completeness proofs for some logics of conditionals", "author": ["J.P. Burgess"], "venue": "Notre Dame Journal of Formal Logic,", "citeRegEx": "Burgess,? \\Q1981\\E", "shortCiteRegEx": "Burgess", "year": 1981}, {"title": "On the evaluation of argumentation formalisms", "author": ["M. Caminada", "L. Amgoud"], "venue": "Artificial Intelligence,", "citeRegEx": "Caminada and Amgoud,? \\Q2007\\E", "shortCiteRegEx": "Caminada and Amgoud", "year": 2007}, {"title": "On the connection between non-monotonic inference systems and conditional logics", "author": ["G. Crocco", "P. Lamarre"], "venue": "Proceedings of the Third International Conference on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Crocco and Lamarre,? \\Q1992\\E", "shortCiteRegEx": "Crocco and Lamarre", "year": 1992}, {"title": "On a rule-based interpretation of default conditionals", "author": ["J.P. Delgrande"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Delgrande,? \\Q2007\\E", "shortCiteRegEx": "Delgrande", "year": 2007}, {"title": "Conditional objects and non-monotonic reasoning", "author": ["D. Dubois", "H. Prade"], "venue": "Proceedings of the Second International Conference on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Dubois and Prade,? \\Q1991\\E", "shortCiteRegEx": "Dubois and Prade", "year": 1991}, {"title": "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming, and n-person games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence,", "citeRegEx": "Dung,? \\Q1995\\E", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "Defeasible logic programming: an argumentative approach", "author": ["A.J. Garcia", "G.R. Simari"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Garcia and Simari,? \\Q2004\\E", "shortCiteRegEx": "Garcia and Simari", "year": 2004}, {"title": "Knowledge in Flux. Modeling the Dynamics of Epistemic States", "author": ["P. G\u00e4rdenfors"], "venue": null, "citeRegEx": "G\u00e4rdenfors,? \\Q1988\\E", "shortCiteRegEx": "G\u00e4rdenfors", "year": 1988}, {"title": "Ordered logic: defeasible reasoning for multiple agents", "author": ["P. Geerts", "D. Vermeir", "D. Nute"], "venue": "Decision Support Systems,", "citeRegEx": "Geerts et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Geerts et al\\.", "year": 1994}, {"title": "Conditional entailment: bridging two approaches to default reasoning", "author": ["H. Geffner", "J. Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "Geffner and Pearl,? \\Q1992\\E", "shortCiteRegEx": "Geffner and Pearl", "year": 1992}, {"title": "System-z+: A formalism for reasoning with variablestrength defaults", "author": ["M. Goldszmidt", "J. Pearl"], "venue": "In Proceedings", "citeRegEx": "Goldszmidt and Pearl,? \\Q1991\\E", "shortCiteRegEx": "Goldszmidt and Pearl", "year": 1991}, {"title": "The quantitative/qualitative watershed for rules of uncertain inference", "author": ["J. Hawthorne", "D. Makinson"], "venue": "Studia Logica,", "citeRegEx": "Hawthorne and Makinson,? \\Q2007\\E", "shortCiteRegEx": "Hawthorne and Makinson", "year": 2007}, {"title": "A skeptical theory of inheritance in nonmonotonic semantic networks", "author": ["J.F. Horty", "R.H. Thomason", "D.S. Touretzky"], "venue": "Artificial Intelligence,", "citeRegEx": "Horty et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Horty et al\\.", "year": 1990}, {"title": "Nonmonotonic reasoning, preferential models and cumulative logics", "author": ["S. Kraus", "D. Lehmann", "M. Magidor"], "venue": "Artificial Intelligence,", "citeRegEx": "Kraus et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Kraus et al\\.", "year": 1990}, {"title": "S4 as the conditional logic of nonmonotonicity", "author": ["P. Lamarre"], "venue": "Proceedings of the Second International Conference on the", "citeRegEx": "Lamarre,? \\Q1991\\E", "shortCiteRegEx": "Lamarre", "year": 1991}, {"title": "What does a conditional knowledge base entail", "author": ["D. Lehmann", "M. Magidor"], "venue": "Artificial Intelligence,", "citeRegEx": "Lehmann and Magidor,? \\Q1992\\E", "shortCiteRegEx": "Lehmann and Magidor", "year": 1992}, {"title": "Ambiguity propagating defeasible logic and the wellfounded semantics", "author": ["F. Maier", "D. Nute"], "venue": "European Conference on Logics in Artificial Intelligence (JELIA2006),", "citeRegEx": "Maier and Nute,? \\Q2006\\E", "shortCiteRegEx": "Maier and Nute", "year": 2006}, {"title": "General theory of cumulative inference", "author": ["D. Makinson"], "venue": "In Proceedings of the Second International Workshop on Non-Monotonic Reasoning,", "citeRegEx": "Makinson,? \\Q1988\\E", "shortCiteRegEx": "Makinson", "year": 1988}, {"title": "Lossy inference rules and their bounds: a brief review", "author": ["D. Makinson", "J. Hawthorne"], "venue": "The Road to Universal Logic,", "citeRegEx": "Makinson and Hawthorne,? \\Q2014\\E", "shortCiteRegEx": "Makinson and Hawthorne", "year": 2014}, {"title": "A general account of argumentation with preferences", "author": ["S. Modgil", "H. Prakken"], "venue": "Artificial Intelligence,", "citeRegEx": "Modgil and Prakken,? \\Q2013\\E", "shortCiteRegEx": "Modgil and Prakken", "year": 2013}, {"title": "Logic for Applications (2nd edition). No. ISBN 0-388794893-7 in Graduate Texts in Computer", "author": ["A. Nerode", "R.A. Shore"], "venue": null, "citeRegEx": "Nerode and Shore,? \\Q1997\\E", "shortCiteRegEx": "Nerode and Shore", "year": 1997}, {"title": "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl,? \\Q1988\\E", "shortCiteRegEx": "Pearl", "year": 1988}, {"title": "System z: A natural ordering of defaults with tractable applications to nonmonotonic reasoning", "author": ["J. Pearl"], "venue": "Theoretical Aspects of Reasoning about Knowledge (TARK-III),", "citeRegEx": "Pearl,? \\Q1990\\E", "shortCiteRegEx": "Pearl", "year": 1990}, {"title": "A logical framework for default reasoning", "author": ["D. Poole"], "venue": "Artificial Intelligence,", "citeRegEx": "Poole,? \\Q1988\\E", "shortCiteRegEx": "Poole", "year": 1988}, {"title": "Argument-based extended logic programming with defeasible priorities", "author": ["H. Prakken", "G. Sartor"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Prakken and Sartor,? \\Q1997\\E", "shortCiteRegEx": "Prakken and Sartor", "year": 1997}, {"title": "A logic for default reasoning", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Reiter,? \\Q1980\\E", "shortCiteRegEx": "Reiter", "year": 1980}, {"title": "A mathematical treatment of defeasible reasoning and its implementation", "author": ["G.R. Simari", "R.P. Loui"], "venue": "Artificial Intelligence,", "citeRegEx": "Simari and Loui,? \\Q1992\\E", "shortCiteRegEx": "Simari and Loui", "year": 1992}, {"title": "A clash of intuitions: The current state of nonmonotonic multiple inheritance systems", "author": ["D. Touretzky", "J. Horty", "R. Thomason"], "venue": "Proceedings of the 10th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Touretzky et al\\.,? \\Q1987\\E", "shortCiteRegEx": "Touretzky et al\\.", "year": 1987}, {"title": "Applying recent argumentation methods to some ancient examples of plausible", "author": ["D. Walton", "C. Tindale", "T. Gordon"], "venue": "reasoning. Argumentation,", "citeRegEx": "Walton et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Walton et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 45, "context": "However on page 114 of (Walton et al., 2014) there is a list of 11 characteristics of plausible reasoning, rather than characteristics of formal logics that do plausible reasoning.", "startOffset": 23, "endOffset": 44}, {"referenceID": 11, "context": "A pruned version of PPL is presented in (Billington, 2015).", "startOffset": 40, "endOffset": 58}, {"referenceID": 42, "context": "The elements of Plaus(S) can have a variety of forms; for example: defaults are used in Reiter\u2019s Default Logic (Reiter, 1980), defeasible rules are used in ASPIC (Caminada & Amgoud, 2007) and ASPIC (Modgil & Prakken, 2013), and defeasible and warning rules are used in Defeasible Logic (Billington, 2008).", "startOffset": 111, "endOffset": 125}, {"referenceID": 10, "context": "The elements of Plaus(S) can have a variety of forms; for example: defaults are used in Reiter\u2019s Default Logic (Reiter, 1980), defeasible rules are used in ASPIC (Caminada & Amgoud, 2007) and ASPIC (Modgil & Prakken, 2013), and defeasible and warning rules are used in Defeasible Logic (Billington, 2008).", "startOffset": 286, "endOffset": 304}, {"referenceID": 24, "context": "The AGM postulates for belief change (Alchourr\u00f2n, G\u00e4rdenfors, & Makinson, 1985; G\u00e4rdenfors, 1988), various properties of nonmonotonic consequence relations (Makinson, 1988; Kraus, Lehmann, & Magidor, 1990), and the postulates that a rule-based argumentation system should satisfy (Caminada & Amgoud, 2007).", "startOffset": 37, "endOffset": 97}, {"referenceID": 34, "context": "The AGM postulates for belief change (Alchourr\u00f2n, G\u00e4rdenfors, & Makinson, 1985; G\u00e4rdenfors, 1988), various properties of nonmonotonic consequence relations (Makinson, 1988; Kraus, Lehmann, & Magidor, 1990), and the postulates that a rule-based argumentation system should satisfy (Caminada & Amgoud, 2007).", "startOffset": 156, "endOffset": 205}, {"referenceID": 30, "context": "The Non-Conjunction Principle is supported by the fact that the \u2018And\u2019 rule of (Kraus et al., 1990), (If a |\u223c x and a |\u223c y then a |\u223c \u2227 {x, y}.", "startOffset": 78, "endOffset": 98}, {"referenceID": 45, "context": "Of the 11 characteristics of plausible reasoning given on page 114 of (Walton et al., 2014), characteristic 8 is \u2018stability\u2019; which seems to mean (bottom of page 97 of (Walton et al.", "startOffset": 70, "endOffset": 91}, {"referenceID": 45, "context": ", 2014), characteristic 8 is \u2018stability\u2019; which seems to mean (bottom of page 97 of (Walton et al., 2014)) that plausible statements are consistent.", "startOffset": 84, "endOffset": 105}, {"referenceID": 44, "context": "The essence of Figure 3 in (Touretzky et al., 1987) is our third signpost example.", "startOffset": 27, "endOffset": 51}, {"referenceID": 2, "context": "There are three well-known non-monotonic logics, namely Default Logic, Circumscription, and Autoepistemic Logic; see (Antoniou, 1997) for an introduction.", "startOffset": 117, "endOffset": 133}, {"referenceID": 4, "context": "Answer Set Programming (ASP) (Baral, 2003) is a well-known Knowledge Representation system.", "startOffset": 29, "endOffset": 42}, {"referenceID": 10, "context": "Logics in this category include inheritance networks (Horty, Thomason, & Touretzky, 1990), the DeLP system of (Garcia & Simari, 2004), the ASPIC system mentioned in (Caminada & Amgoud, 2007), the logic in (Prakken & Sartor, 1997), Ordered logic (Geerts, Vermeir, & Nute, 1994), and most Defeasible Logics (Billington, 2008).", "startOffset": 305, "endOffset": 323}, {"referenceID": 10, "context": "The only Defeasible Logics that deal with conjunction and disjunction, besides PPL, are the logic in (Billington & Rock, 2001), let\u2019s call it DL1, and the logic in (Billington, 2008), let\u2019s call it DL8.", "startOffset": 164, "endOffset": 182}, {"referenceID": 9, "context": "9) fails for the plausible proof algorithms that define the Defeasible Logics in: (Billington, 1993), (Billington & Rock, 2001), (Maier & Nute, 2006), (Billington, 2008), and (Billington, 2011).", "startOffset": 82, "endOffset": 100}, {"referenceID": 10, "context": "9) fails for the plausible proof algorithms that define the Defeasible Logics in: (Billington, 1993), (Billington & Rock, 2001), (Maier & Nute, 2006), (Billington, 2008), and (Billington, 2011).", "startOffset": 151, "endOffset": 169}, {"referenceID": 6, "context": "9) fails for the plausible proof algorithms that define the Defeasible Logics in: (Billington, 1993), (Billington & Rock, 2001), (Maier & Nute, 2006), (Billington, 2008), and (Billington, 2011).", "startOffset": 175, "endOffset": 193}, {"referenceID": 22, "context": "Argumentation systems, (Dung, 1995), are well-known non-monotonic reasoning systems that can use rules, for example ASPIC (Caminada & Amgoud, 2007) and ASPIC (Modgil & Prakken, 2013).", "startOffset": 23, "endOffset": 35}, {"referenceID": 20, "context": "In (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).", "startOffset": 3, "endOffset": 20}, {"referenceID": 0, "context": "In (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).", "startOffset": 220, "endOffset": 233}, {"referenceID": 38, "context": "In (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).", "startOffset": 238, "endOffset": 251}, {"referenceID": 31, "context": "In (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).", "startOffset": 343, "endOffset": 358}, {"referenceID": 17, "context": "In (Delgrande, 2007) it is observed that the following reasoning systems satisfy both the And-rule and the Or-rule and hence do not do our plausible reasoning: systems based on intuitions from probability theory such as (Adams, 1975) and (Pearl, 1988), and from qualitative possibilistic logic (Dubois, Lang, & Prade, 1994), those based on C4 (Lamarre, 1991), CT4 (Boutilier, 1994a), and S (Burgess, 1981).", "startOffset": 390, "endOffset": 405}, {"referenceID": 34, "context": "The consequence function of (Makinson, 1988) and the cumulative conditional knowledge bases of (Kraus et al.", "startOffset": 28, "endOffset": 44}, {"referenceID": 30, "context": "The consequence function of (Makinson, 1988) and the cumulative conditional knowledge bases of (Kraus et al., 1990) satisfy both the And-rule and the Or-rule.", "startOffset": 95, "endOffset": 115}, {"referenceID": 30, "context": "Preferential conditional knowledge bases (Kraus et al., 1990) are cumulative.", "startOffset": 41, "endOffset": 61}, {"referenceID": 20, "context": "As noted in (Delgrande, 2007) the following systems are \u2018essentially the same as\u2019 rational closure and hence do not do our plausible reasoning: System Z (Pearl, 1990), systems based on conditional logic (Crocco & Lamarre, 1992), on modal logic (Boutilier, 1994b), on possibilistic logic (Benferhat, Dubois, & Prade, 1992), and on conditional objects (Dubois & Prade, 1991).", "startOffset": 12, "endOffset": 29}, {"referenceID": 39, "context": "As noted in (Delgrande, 2007) the following systems are \u2018essentially the same as\u2019 rational closure and hence do not do our plausible reasoning: System Z (Pearl, 1990), systems based on conditional logic (Crocco & Lamarre, 1992), on modal logic (Boutilier, 1994b), on possibilistic logic (Benferhat, Dubois, & Prade, 1992), and on conditional objects (Dubois & Prade, 1991).", "startOffset": 153, "endOffset": 166}, {"referenceID": 20, "context": "The conditional logic C of (Delgrande, 2007) does not satisfy the Plausible Right Weakening Principle (Principle 3.", "startOffset": 27, "endOffset": 44}, {"referenceID": 20, "context": "Also C and the extensions of C considered in (Delgrande, 2007) have only one proof algorithm and so fail the Many Proof Algorithms Principle (Principle 3.", "startOffset": 45, "endOffset": 62}, {"referenceID": 39, "context": "Apart from the problems mentioned in Section 5 of (Goldszmidt & Pearl, 1991), System Z (Pearl, 1990) and System Z (Goldszmidt & Pearl, 1991) are ambiguity propagating but not ambiguity blocking.", "startOffset": 87, "endOffset": 100}, {"referenceID": 39, "context": "1), they cannot prove anything about the example because the set of rules is not \u2018consistent\u2019 as defined in (Pearl, 1990; Goldszmidt & Pearl, 1991).", "startOffset": 108, "endOffset": 147}, {"referenceID": 40, "context": "The logic implemented by theorist (Poole, 1988) and the Preferred Subtheories logic in (Brewka, 1989) both generate consistent extensions and so fail the Non-3-Consistency Principle (Principle 3.", "startOffset": 34, "endOffset": 47}, {"referenceID": 16, "context": "The logic implemented by theorist (Poole, 1988) and the Preferred Subtheories logic in (Brewka, 1989) both generate consistent extensions and so fail the Non-3-Consistency Principle (Principle 3.", "startOffset": 87, "endOffset": 101}], "year": 2017, "abstractText": "Plausible reasoning concerns situations whose inherent lack of precision is not quantified; that is, there are no degrees or levels of precision, and hence no use of numbers like probabilities. A hopefully comprehensive set of principles that clarifies what it means for a formal logic to do plausible reasoning is presented. A new propositional logic, called Propositional Plausible Logic (PPL), is defined and applied to some important examples. PPL is the only non-numeric non-monotonic logic we know of that satisfies all the principles and correctly reasons with all the examples. Some important results about PPL are proved.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}