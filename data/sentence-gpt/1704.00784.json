{"id": "1704.00784", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Apr-2017", "title": "Online and Linear-Time Attention by Enforcing Monotonic Alignments", "abstract": "Recurrent neural network models with an attention mechanism have proven to be extremely effective on a wide variety of sequence-to-sequence problems. However, the fact that soft attention mechanisms perform a pass over the entire input sequence when producing each element in the output sequence precludes their use in online settings and results in a quadratic time complexity. Based on the insight that the alignment between input and output sequence elements is monotonic in many problems of interest, we propose an end-to-end differentiable method for learning monotonic alignments which, at test time, enables computing attention online and in linear time complexity (T&T) situations. In our study, we conducted a computational simulation of the performance of our model on linear time complexity: a neural network with a focus on the number of input inputs that are distributed across the input sequence and output sequence. Our model was trained using a large number of parallelized networks: the network's average number of input inputs per input was 0.5% (mean value = 3.7 \u00d7 10.7 \u00d7 10.7 \u00d7 10.7 \u00d7 10.6 \u00d7 10.6 \u00d7 10.6 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.5 \u00d7 10.", "histories": [["v1", "Mon, 3 Apr 2017 19:45:27 GMT  (253kb,D)", "https://arxiv.org/abs/1704.00784v1", "19 pages, 5 figures (three full-page), including 4 pages of supplementary material"], ["v2", "Thu, 29 Jun 2017 21:14:58 GMT  (773kb,D)", "http://arxiv.org/abs/1704.00784v2", "ICML camera-ready version; 10 pages + 9 page appendix"]], "COMMENTS": "19 pages, 5 figures (three full-page), including 4 pages of supplementary material", "reviews": [], "SUBJECTS": "cs.LG cs.CL", "authors": ["colin raffel", "minh-thang luong", "peter j liu", "ron j weiss", "douglas eck"], "accepted": true, "id": "1704.00784"}, "pdf": {"name": "1704.00784.pdf", "metadata": {"source": "META", "title": "Online and Linear-Time Attention by Enforcing Monotonic Alignments", "authors": ["Colin Raffel", "Minh-Thang Luong", "Peter J. Liu", "Ron J. Weiss", "Douglas Eck"], "emails": ["<craffel@gmail.com>."], "sections": [{"heading": "1. Introduction", "text": "Recently, the \u201csequence-to-sequence\u201d framework (Sutskever et al., 2014; Cho et al., 2014) has facilitated the use of recurrent neural networks (RNNs) on sequence transduction problems such as machine translation and speech recognition. In this framework, an input sequence is processed with an RNN to produce an \u201cencoding\u201d; this encoding is then used by a second RNN to produce the target sequence. As originally proposed, the encoding is a single fixed-length vector representation of the input sequence. This requires the model to effectively compress all important information about the input sequence into a single vector. In practice, this often results in the model having difficulty generalizing to longer sequences than those seen during training (Bahdanau et al., 2015).\nAn effective solution to these shortcomings are attention\n1Google Brain, Mountain View, California, USA. Correspondence to: Colin Raffel <craffel@gmail.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nmechanisms (Bahdanau et al., 2015). In a sequence-tosequence model with attention, the encoder produces a sequence of hidden states (instead of a single fixed-length vector) which correspond to entries in the input sequence. The decoder is then allowed to refer back to any of the encoder states as it produces its output. Similar mechanisms have been used as soft addressing schemes in memoryaugmented neural network architectures (Graves et al., 2014; Sukhbaatar et al., 2015) and RNNs used for sequence generation (Graves, 2013). Attention-based sequence-tosequence models have proven to be extremely effective on a wide variety of problems, including machine translation (Bahdanau et al., 2015; Luong et al., 2015), image captioning (Xu et al., 2015), speech recognition (Chorowski et al., 2015; Chan et al., 2016), and sentence summarization (Rush et al., 2015). In addition, attention creates an implicit soft alignment between entries in the output sequence and entries in the input sequence, which can give useful insight into the model\u2019s behavior.\nA common criticism of soft attention is that the model must perform a pass over the entire input sequence when producing each element of the output sequence. This results in the decoding process having complexity O(TU), where T and U are the input and output sequence lengths respectively. Furthermore, because the entire sequence must be processed prior to outputting any symbols, soft attention cannot be used in \u201conline\u201d settings where output sequence elements are produced when the input has only been partially observed.\nThe focus of this paper is to propose an alternative attention mechanism which has linear-time complexity and can be used in online settings. To achieve this, we first note that in many problems, the input-output alignment is roughly monotonic. For example, when transcribing an audio recording of someone saying \u201cgood morning\u201d, the region of the speech utterance corresponding to \u201cgood\u201d will always precede the region corresponding to \u201cmorning\u201d. Even when the alignment is not strictly monotonic, it often only contains local input-output reorderings. Separately, despite the fact that soft attention allows for assignment of focus to multiple disparate entries of the input sequence, in many cases the attention is assigned mostly to a single entry. For examples of alignments with these characteristics, we refer to e.g. (Chorowski et al. 2015 Figure ar X\niv :1\n70 4.\n00 78\n4v 2\n[ cs\n.L G\n] 2\n9 Ju\nn 20\n17\n2; Chan et al. 2016 Figure 2; Rush et al. 2015 Figure 1; Bahdanau et al. 2015 Figure 3), etc. Of course, this is not true in all problems; for example, when using soft attention for image captioning, the model will often change focus arbitrarily between output steps and will spread attention across large regions of the input image (Xu et al., 2015).\nMotivated by these observations, we propose using hard monotonic alignments for sequence-to-sequence problems because, as we argue in section 2.2, they enable computing attention online and in linear time. Towards this end, we show that it is possible to train such an attention mechanism with a quadratic-time algorithm which computes its expected output. This allows us to continue using standard backpropagation for training while still facilitating efficient online decoding at test-time. On all problems we studied, we found these added benefits only incur a small decrease in performance compared to softmax-based attention.\nThe rest of this paper is structured as follows: In the following section, we develop an interpretation of soft attention as optimizing a stochastic process in expectation and formulate a corresponding stochastic process which allows for online and linear-time decoding by relying on hard monotonic alignments. In analogy with soft attention, we then show how to compute the expected output of the monotonic attention process and elucidate how the resulting algorithm differs from standard softmax attention. After giving an overview of related work, we apply our approach to the tasks of sentence summarization, machine translation, and online speech recognition, achieving results competitive with existing sequence-to-sequence models. Finally, we present additional derivations, experimental details, and ideas for future research in the appendix."}, {"heading": "2. Online and Linear-Time Attention", "text": "To motivate our approach, we first point out that softmaxbased attention is computing the expected output of a simple stochastic process. We then detail an alternative process which enables online and linear-time decoding. Because this process is nondifferentiable, we derive an algorithm for computing its expected output, allowing us to train a model with standard backpropagation while applying our online and linear-time process at test time. Finally, we propose an alternative energy function motivated by the differences between monotonic attention and softmax-based attention."}, {"heading": "2.1. Soft Attention", "text": "To begin with, we review the commonly-used form of soft attention proposed originally in (Bahdanau et al., 2015). Broadly, a sequence-to-sequence model produces a sequence of outputs based on a processed input sequence. The model consists of two RNNs, referred to\nas the \u201cencoder\u201d and \u201cdecoder\u201d. The encoder RNN processes the input sequence x = {x1, . . . , xT } to produce a sequence of hidden states h = {h1, . . . , hT }. We refer to h as the \u201cmemory\u201d to emphasize its connection to memory-augmented neural networks (Graves et al., 2014; Sukhbaatar et al., 2015). The decoder RNN then produces an output sequence y = {y1, . . . , yU}, conditioned on the memory, until a special end-of-sequence token is produced.\nWhen computing yi, a soft attention-based decoder uses a learnable nonlinear function a(\u00b7) to produce a scalar value ei,j for each entry hj in the memory based on hj and the decoder\u2019s state at the previous timestep si\u22121. Typically, a(\u00b7) is a single-layer neural network using a tanh nonlinearity, but other functions such as a simple dot product between si\u22121 and hj have been used (Luong et al., 2015; Graves et al., 2014). These scalar values are normalized using the softmax function to produce a probability distribution over the memory, which is used to compute a context vector ci as the weighted sum of h. Because items in the memory have a sequential correspondence with items in the input, these attention distributions create a soft alignment between the output and input. Finally, the decoder updates its state to si based on si\u22121 and ci and produces yi. In total, producing yi involves\nei,j = a(si\u22121, hj) (1)\n\u03b1i,j = exp(ei,j) / T\u2211 k=1 exp(ei,k) (2)\nci = T\u2211 j=1 \u03b1i,jhj (3)\nsi = f(si\u22121, yi\u22121, ci) (4) yi = g(si, ci) (5)\nwhere f(\u00b7) is a recurrent neural network (typically one or more LSTM (Hochreiter & Schmidhuber, 1997) or GRU (Chung et al., 2014) layers) and g(\u00b7) is a learnable nonlinear function which maps the decoder state to the output space (e.g. an affine transformation followed by a softmax when the target sequences consist of discrete symbols).\nTo motivate our monotonic alignment scheme, we observe that eqs. (2) and (3) are computing the expected output of a simple stochastic process, which can be formulated as follows: First, a probability \u03b1i,j is computed independently for each entry hj of the memory. Then, a memory index k is sampled by k \u223c Categorical(\u03b1i) and ci is set to hk. We visualize this process in fig. 1. Clearly, eq. (3) shows that soft attention replaces sampling k and assigning ci = hk with direct computation of the expected value of ci."}, {"heading": "2.2. A Hard Monotonic Attention Process", "text": "The discussion above makes clear that softmax-based attention requires a pass over the entire memory to compute the terms \u03b1i,j required to produce each element of the output sequence. This precludes its use in online settings, and results in a complexity of O(TU) for generating the output sequence. In addition, despite the fact that h represents a transformation of a sequence (which ostensibly exhibits dependencies between subsequent elements), the attention probabilities are computed independent of temporal order and the attention distribution at the previous timestep.\nWe address these shortcomings by first formulating a stochastic process which explicitly processes the memory in a left-to-right manner. Specifically, for output timestep i we begin processing memory entries from index ti\u22121, where ti is the index of the memory entry chosen at output timestep i (for convenience, letting t0 = 1). We sequentially compute, for j = ti\u22121, ti\u22121 + 1, ti\u22121 + 2, . . .\nei,j = a(si\u22121, hj) (6) pi,j = \u03c3(ei,j) (7) zi,j \u223c Bernoulli(pi,j) (8)\nwhere a(\u00b7) is a learnable deterministic \u201cenergy function\u201d and \u03c3(\u00b7) is the logistic sigmoid function. As soon as we sample zi,j = 1 for some j, we stop and set ci = hj and ti = j, \u201cchoosing\u201d memory entry j for the context vector. Each zi,j can be seen as representing a discrete choice of whether to ingest a new item from the memory (zi,j = 0) or produce an output (zi,j = 1). For all sub-\nsequent output timesteps, we repeat this process, always starting from ti\u22121 (the memory index chosen at the previous timestep). If for any output timestep i we have zi,j = 0 for j \u2208 {ti\u22121, . . . , T}, we simply set ci to a vector of zeros. This process is visualized in fig. 2 and is presented more explicitly in algorithm 1 (appendix A).\nNote that by construction, in order to compute pi,j , we only need to have computed hk for k \u2208 {1, . . . , j}. It follows that our novel process can be computed in an online manner; i.e. we do not need to wait to observe the entire input sequence before we start producing the output sequence. Furthermore, because we start inspecting memory elements from where we left off at the previous output timestep (i.e. at index ti\u22121), the resulting process only computes at most max(T,U) terms pi,j , giving it a linear runtime. Of course, it also makes the strong assumption that the alignment between the input and output sequence is strictly monotonic."}, {"heading": "2.3. Training in Expectation", "text": "The online alignment process described above involves sampling, which precludes the use of standard backpropagation. In analogy with softmax-based attention, we therefore propose training with respect to the expected value of ci, which can be computed straightforwardly as follows. We first compute ei,j and pi,j exactly as in eqs. (6) and (7), where pi,j are interpreted as the probability of choosing memory element j at output timestep i. The attention distribution over the memory is then given by (see appendix C\nfor a derivation)\n\u03b1i,j = pi,j j\u2211 k=1\n( \u03b1i\u22121,k\nj\u22121\u220f l=k (1\u2212 pi,l)\n) (9)\n= pi,j ( (1\u2212 pi,j\u22121)\n\u03b1i,j\u22121 pi,j\u22121 + \u03b1i\u22121,j\n) (10)\nWe provide a solution to the recurrence relation of eq. (10) which allows computing \u03b1i,j for j \u2208 {1, . . . , T} in parallel with cumulative sum and cumulative product operations in appendix C.1. Defining qi,j = \u03b1i,j/pi,j gives the following procedure for computing \u03b1i,j :\nei,j = a(si\u22121, hj) (11) pi,j = \u03c3(ei,j) (12) qi,j = (1\u2212 pi,j\u22121)qi,j\u22121 + \u03b1i\u22121,j (13) \u03b1i,j = pi,jqi,j (14)\nwhere we define the special cases of qi,0 = 0, pi,0 = 0 to maintain equivalence with eq. (9). As in softmaxbased attention, the \u03b1i,j values produce a weighting over the memory, which are then used to compute the context vector at each timestep as in eq. (3). However, note that \u03b1i may not be a valid probability distribution because\u2211\nj \u03b1i,j \u2264 1. Using \u03b1i as-is, without normalization, effectively associates any additional probability not allocated to memory entries to an additional all-zero memory location. Normalizing \u03b1i so that \u2211T j=1 \u03b1i,j = 1 has two issues: First, we can\u2019t perform this normalization at test time and still achieve online decoding because the normalization depends on \u03b1i,j for j \u2208 {1, . . . , T}, and second, it would result in a mismatch compared to the probability distribution induced by the hard monotonic attention process which sets ci to a vector of zeros when zi,j = 0 for j \u2208 {ti\u22121, . . . , T}.\nNote that computing ci still has a quadratic complexity because we must compute \u03b1i,j for j \u2208 {1, . . . , T} for each output timestep i. However, because we are training directly with respect to the expected value of ci, we will train our decoders using eqs. (11) to (14) and then use the online, linear-time attention process of section 2.2 at test time. Furthermore, if pi,j \u2208 {0, 1} these approaches are equivalent, so in order for the model to exhibit similar behavior at training and test time, we need pi,j \u2248 0 or pi,j \u2248 1. We address this in section 2.5."}, {"heading": "2.4. Modified Energy Function", "text": "While various \u201cenergy functions\u201d a(\u00b7) have been proposed, the most common to our knowledge is the one proposed in (Bahdanau et al., 2015):\na(si\u22121, hj) = v > tanh(Wsi\u22121 + V hj + b) (15)\nwhere W and V are weight matrices, b is a bias vector,1 and v is a weight vector. We make two modifications to eq. (15) for use with our monotonic decoder: First, while the softmax is invariant to offset,2 the logistic sigmoid is not. As a result, we make the simple modification of adding a scalar variable r after the tanh function, allowing the model to learn the appropriate offset for the pre-sigmoid activations. Note that eq. (13) tends to exponentially decay attention over the memory because 1 \u2212 pi,j \u2208 [0, 1]; we therefore initialized r to a negative value prior to training so that 1 \u2212 pi,j tends to be close to 1. Second, the use of the sigmoid nonlinearity in eq. (12) implies that our mechanism is particularly sensitive to the scale of the energy terms ei,j , or correspondingly, the scale of the energy vector v. We found an effective solution to this issue was to apply weight normalization (Salimans & Kingma, 2016) to v, replacing it by gv/\u2016v\u2016 where g is a scalar parameter. Initializing g to the inverse square root of the attention hidden dimension worked well for all problems we studied.\nThe above produces the energy function\na(si\u22121, hj) = g v>\n\u2016v\u2016 tanh(Wsi\u22121 + V hj + b) + r (16)\nThe addition of the two scalar parameters g and r prevented the issues described above in all our experiments while incurring a negligible increase in the number of parameters."}, {"heading": "2.5. Encouraging Discreteness", "text": "As mentioned above, in order for our mechanism to exhibit similar behavior when training in expectation and when using the hard monotonic attention process at test time, we require that pi,j \u2248 0 or pi,j \u2248 1. A straightforward way to encourage this behavior is to add noise before the sigmoid in eq. (12), as was done e.g. in (Frey, 1997; Salakhutdinov & Hinton, 2009; Foerster et al., 2016). We found that simply adding zero-mean, unit-variance Gaussian noise to the pre-sigmoid activations was sufficient in all of our experiments. This approach is similar to the recently proposed Gumbel-Softmax trick (Jang et al., 2016; Maddison et al., 2016), except we did not find it necessary to anneal the temperature as suggested in (Jang et al., 2016).\nNote that once we have a model which produces pi,j which are effectively discrete, we can eschew the sampling involved in the process of section 2.2 and instead simply set zi,j = I(pi,j > \u03c4) where I is the indicator function and \u03c4 is a threshold. We used this approach in all of our experiments, setting \u03c4 = 0.5. Furthermore, at test time we do not add pre-sigmoid noise, making decoding purely deter-\n1b is occasionally omitted, but we found it often improves performance and only incurs a modest increase in parameters, so we include it.\n2That is, softmax(e) = softmax(e+ r) for any r \u2208 R.\nministic. Combining all of the above, we present our differentiable approach to training the monotonic alignment decoder in algorithm 2 (appendix A)."}, {"heading": "3. Related Work", "text": "(Luo et al., 2016) and (Zaremba & Sutskever, 2015) both study a similar framework in which a decoder RNN can decide whether to ingest another entry from the input sequence or emit an entry of the output sequence. Instead of training in expectation, they maintain the discrete nature of this decision while training and use reinforcement learning (RL) techniques. We initially experimented with RL-based training methods but were unable to find an approach which worked reliably on the different tasks we studied. Empirically, we also show superior performance to (Luo et al., 2016) on online speech recognition tasks; we did not attempt any of the tasks from (Zaremba & Sutskever, 2015). (Aharoni & Goldberg, 2016) also study hard monotonic alignments, but their approach requires target alignments computed via a separate statistical alignment algorithm in order to be trained.\nAs an alternative approach to monotonic alignments, Connectionist Temporal Classification (CTC) (Graves et al., 2006) and the RNN Transducer (Graves, 2012) both assume that the output sequences consist of symbols, and add an additional \u201cnull\u201d symbol which corresponds to \u201cproduce no output\u201d. More closely to our model, (Yu et al., 2016b) similarly add \u201cshift\u201d and \u201cemit\u201d operations to an RNN. Finally, the Segmental RNN (Kong et al., 2015) treats a segmentation of the input sequence as a latent random variable. In all cases, the alignment path is marginalized out via a dynamic program in order to obtain a conditional probability distribution over label sequences and train directly with maximum likelihood. These models either require conditional independence assumptions between output symbols or don\u2019t condition the decoder (language model) RNN on the input sequence. We instead follow the framework of attention and marginalize out alignment paths when computing the context vectors ci which are subsequently fed into the decoder RNN, which allows the decoder to condition on its past output as well as the input sequence. Our approach can therefore be seen as a marriage of these CTCstyle techniques and attention. Separately, instead of performing an approximate search for the most probable output sequence at test time, we use hard alignments which facilitates linear-time decoding.\nA related idea is proposed in (Raffel & Lawson, 2017), where \u201csubsampling\u201d probabilities are assigned to each entry in the memory and a stochastic process is formulated which involves keeping or discarding entries from the input sequence according to the subsampling probabilities. A dynamic program similar to the one derived in section 2.3 is\nthen used to compute the expected output which allows for training with standard backpropagation. Our approach differs in that we utilize an RNN decoder to construct the output sequence, and furthermore allows for output sequences which are longer than the input.\nSome similar ideas to those in section 2.3 were proposed in the context of speech recognition in (Chorowski et al., 2015): First, the prior attention distributions are convolved with a bank of one-dimensional filters and then included in the energy function calculation. Second, instead of computing attention over the entire memory they only compute it over a sliding window. This reduces the runtime complexity at the expense of the strong assumption that memory locations attended to at subsequent output timesteps fall within a small window of one another. Finally, they also advocate replacing the softmax function with a sigmoid, but they then normalize by the sum of these sigmoid activations across the memory window instead of interpreting these probabilities in the left-to-right framework we use. While these modifications encourage monotonic attention, they do not explicitly enforce it, and so the authors do not investigate online decoding.\nIn a similar vein, (Luong et al., 2015) explore only computing attention over a small window of the memory. In addition to simply monotonically increasing the window location at each output timestep, they also consider learning a policy for producing the center of the memory window based on the current decoder state.\n(Kim et al., 2017) also make the connection between soft attention and selecting items from memory in expectation. They consider replacing the softmax in standard soft attention with an elementwise sigmoid nonlinearity, but do not formulate the interpretation of addressing memory from left-to-right and the corresponding probability distributions as we do in section 2.3.\n(Jaitly et al., 2015) apply standard softmax attention in online settings by splitting the input sequence into chunks and producing output tokens using the attentive sequence-tosequence framework over each chunk. They then devise a dynamic program for finding the approximate best alignment between the model output and the target sequence. In contrast, our ingest/emit probabilities pi,j can be seen as adaptively chunking the input sequence (rather than providing a fixed setting of the chunk size) and we instead train by exactly computing the expectation over alignment paths."}, {"heading": "4. Experiments", "text": "To validate our proposed approach for learning monotonic alignments, we applied it to a variety of sequenceto-sequence problems: sentence summarization, machine translation, and online speech recognition. In the follow-\ning subsections, we give an overview of the models used and the results we obtained; for more details about hyperparamers and training specifics please see appendix D. Incidentally, all experiments involved predicting discrete symbols (e.g. phonemes, characters, or words); as a result, the output of the decoder in each of our models was fed into an affine transformation followed by a softmax nonlinearity with a dimensionality corresponding to the number of possible symbols. At test time, we performed a beam search over softmax predictions on all problems except machine translation. All networks were trained using standard cross-entropy loss with teacher forcing against target sequences using the Adam optimizer (Kingma & Ba, 2014). All of our decoders used the monotonic attention mechanism of section 2.3 during training to address the hidden states of the encoder. For comparison, we report test-time results using both the hard linear-time decoding method of section 2.2 and the \u201csoft\u201d monotonic attention distribution. We also present the results of a synthetic benchmark we used to measure the potential speedup offered by our linear-time decoding process in appendix F.\nOnline Speech Recognition Online speech recognition involves transcribing the words spoken in a speech utterance in real-time, i.e. as a person is talking. This problem is a natural application for monotonic alignments because online decoding is an explicit requirement. In addition, this precludes the use of bidirectional RNNs, which degrades performance somewhat (Graves et al., 2013). We tested our approach on two datasets: TIMIT (Garofolo et al., 1993) and the Wall Street Journal corpus (Paul & Baker, 1992).\nSpeech recognition on the TIMIT dataset involves transcribing the phoneme sequence underlying a given speech utterance. Speech utterances were represented as sequences of 40-filter (plus energy) mel-filterbank spectra, computed every 10 milliseconds, with delta- and deltadelta-features. Our encoder RNN consisted of three unidirectional LSTM layers. Following (Chan et al., 2016), after the first and second LSTM layer we placed time reduction layers which skip every other sequence element. Our decoder RNN was a single unidirectional LSTM. Our output softmax had 62 dimensions, corresponding to the 60 phonemes from TIMIT plus special start-of-sequence and end-of-sequence tokens. At test time, we utilized a beam search over softmax predictions, with a beam width of 10. We report the phone error rate (PER) after applying the standard mapping to 39 phonemes (Graves et al., 2013). We used the standard train/validation/test split and report results on the test set.\nOur model\u2019s performance, with a comparison to other online approaches, is shown in table 1. We achieve better performance than recently proposed sequence-to-sequence models (Luo et al., 2016; Jaitly et al., 2015), though the\nsmall size of the TIMIT dataset and the resulting variability of results precludes making substantiative claims about one approach being best. We note that (Jaitly et al., 2015) were able to improve performance by precomputing alignments using an HMM system and providing them as a supervised signal to their decoder; we did not experiment with this idea. CTC (Graves et al., 2013) still outperforms all sequence-to-sequence models. In addition, there remains a substantial gap between these online results and offline results using bidirectional LSTMs, e.g. (Chorowski et al., 2015) achieves a 17.6% phone error rate using a softmax-based attention mechanism and (Graves et al., 2013) achieved 17.7% using a pre-trained RNN transducer model. We are interested in investigating ways to close this gap in future work.\nBecause of the size of the dataset, performance on TIMIT is often highly dependent on appropriate regularization. We therefore also evaluated our approach on the Wall Street Journal (WSJ) speech recognition dataset, which is about 10 times larger. For the WSJ corpus, we present speech utterances to the network as 80-filter mel-filterbank spectra with delta- and delta-delta features, and normalized using per-speaker mean and variance computed offline. The model architecture is a variation of that from (Zhang et al., 2016), using an 8 layer encoder including: two convolutional layers which downsample the sequence in time, followed by one unidirectional convolutional LSTM layer, and finally a stack of three unidirectional LSTM layers interleaved with linear projection layers and batch normalization. The encoder output sequence is consumed by the proposed online attention mechanism which is passed into a decoder consisting of a single unidirectional LSTM layer followed by a softmax layer.\nOur output softmax predicted one of 49 symbols, consisting of alphanumeric characters, punctuation marks, and start-of sequence, end-of-sequence, \u201cunknown\u201d, \u201cnoise\u201d, and word delimiter tokens. We utilized label smoothing during training (Chorowski & Jaitly, 2017), replacing the targets at time yt with a convex weighted combination of the surrounding five labels (full details in appendix D.1.2). Performance was measured in terms of word error rate (WER) on the test set after segmenting the model\u2019s predic-\ntions according to the word delimiter tokens. We used the standard dataset split of si284 for training, dev93 for validation, and eval92 for testing. We did not use a language model to improve decoding performance.\nOur results on WSJ are shown in table 2. Our model, with hard monotonic decoding, achieved a significantly lower WER than the other online methods. While these figures show a clear advantage to our approach, our model architecture differed significantly from those of (Luo et al., 2016; Wang et al., 2016). We therefore additionally measured performance against a baseline model which was identical to our model except that it used softmax-based attention (which makes it quadratic-time and offline) instead of a monotonic alignment decoder. This resulted in a small decrease of 1.4% WER, suggesting that our hard monotonic attention approach achieves competitive performance while being substantially more efficient. To get a qualitative picture of our model\u2019s behavior compared to the softmax-attention baseline, we plot each model\u2019s inputoutput alignments for two example speech utterances in fig. 4 (appendix B). Both models learn roughly the same alignment, with some minor differences caused by ours being both hard and strictly monotonic.\nSentence Summarization Speech recognition exhibits a strictly monotonic input-output alignment. We are interested in testing whether our approach is also effective on problems which only exhibit approximately monotonic alignments. We therefore ran a \u201csentence summarization\u201d experiment using the Gigaword corpus, which involves predicting the headline of a news article from its first sentence.\nOverall, we used the model of (Liu & Pan, 2016), modifying it only so that it used our monotonic alignment decoder instead of a soft attention decoder. Because online decoding is not important for sentence summarization, we utilized bidirectional RNNs in the encoder for this task (as is standard). We expect that the bidirectional RNNs will give the model local context which may help allow for strictly monotonic alignments. The model both took as input and produced as output one-hot representations of the word IDs, with a vocabulary of the 200,000 most common words in the training set. Our encoder consisted of\na word embedding matrix (which was initialized randomly and trained as part of the model) followed by four bidirectional LSTM layers. We used a single LSTM layer for the decoder. For data preparation and evaluation, we followed the approach of (Rush et al., 2015), measuring performance using the ROUGE metric.\nOur results, along with the scores achieved by other approaches, are presented in table 3. While the monotonic alignment model outperformed existing models by a substantial margin, it fell slightly behind the model of (Liu & Pan, 2016) which we used as a baseline. The higher performance of our model and the model of (Liu & Pan, 2016) can be partially explained by the fact that their encoders have roughly twice as many layers as most models proposed in the literature.\nFor qualitative evaluation, we plot an example input-output\npair and alignment matrices for our hard monotonic attention model and the softmax-attention baseline of (Liu & Pan, 2016) in fig. 3 (an additional example is shown in fig. 6, appendix B). Most apparent is that a given word in the summary is not always aligned to the most obvious word in the input sentence; the hard monotonic decoder aligns the first four words in the summary reasonably (greek\u2194 greek, government\u2194 finance, approves\u2194 approved, more \u2194 more), but the latter four words have unexpected alignments (funds\u2194 in, to\u2194 for, bird\u2194measures, bird \u2194 flu). We believe this is due to the ability of the multilayer bidirectional RNN encoder to reorder words in the input sequence. This effect is also apparent in fig. 6/ (appendix B), where the monotonic alignment decoder is able to produce the phrase \u201chuman rights criticism\u201d despite the fact that the input sentence has the phrase \u201ccriticism of human rights\u201d. Separately, we note that the softmax attention model\u2019s alignments are extremely \u201csoft\u201d and nonmonotonic; this may be advantageous for this problem and partially explain its slightly superior performance.\nMachine Translation We also evaluated our approach on machine translation, another task which does not exhibit strictly monotonic alignments. In fact, for some language pairs (e.g. English and Japanese, English and Korean), we do not expect monotonicity at all. However, for other pairs (e.g. English and French, English and Vietnamese) only local word reorderings are required. Our translation experiments therefore involved English to Vietnamese translation using the parallel corpus of TED talks (133K sentence pairs) provided by the IWSLT 2015 Evaluation Campaign (Cettolo et al., 2015). Following (Luong & Manning, 2015), we tokenize the corpus with the default Moses tokenizer, preserve casing, and replace words whose frequencies are less than 5 by <unk>. As a result, our vocabulary sizes are 17K and 7.7K for English and Vietnamese respectively. We use the TED tst2012 (1553 sentences) as a validation set for hyperparameter tuning and TED tst2013 (1268 sentences) as a test set. We report results in both perplexity and BLEU.\nOur baseline neural machine translation (NMT) system is the softmax attention-based sequence-to-sequence model described in (Luong et al., 2015). From that baseline, we substitute the softmax-based attention mechanism with our proposed monotonic alignment decoder. The model utilizes two-layer unidirectional LSTM networks for both the encoder and decoder.\nIn (Luong et al., 2015), the authors demonstrated that under their proposed architecture, a dot product-based energy function worked better than eq. (15). Since our architecture is based on that of (Luong et al., 2015), to facilitate comparison we also tested the following variant:\na(si\u22121, hj) = g(s > i\u22121Wh) + r (17)\nwhere g and r are scalars (initialized as in section 2.4) and W is a weight matrix.\nOur results are shown in Table 4. To get a better picture of each model\u2019s behavior, we plot input-output alignments in fig. 5 (appendix B). Most noticeable is that the monotonic alignment model tends to focus attention later in the input sequence than the baseline softmax-attention model. We hypothesize that this is a way to compensate for non-monotonic alignments when a unidirectional encoder is used; i.e. the model has effectively learned to focus on words at the end of phrases which require reordering, at which point the unidirectional encoder has observed the whole phrase. This can be seen most clearly in the example on the right, where translating \u201ca huge famine\u201d to Vietnamese requires reordering (as suggested by the softmax-attention model\u2019s alignment), so the hard monotonic alignment model focuses attention on the final word in the phrase (\u201cfamine\u201d) while producing its translation. We suspect our model\u2019s small decrease in BLEU compared to the baseline model may be due in part to this increased modeling burden."}, {"heading": "5. Discussion", "text": "Our results show that our differentiable approach to enforcing monotonic alignments can produce models which, following the decoding process of section 2.2, provide efficient online decoding at test time without sacrificing substantial performance on a wide variety of tasks. We believe our framework presents a promising environment for future work on online and linear-time sequence-to-sequence models. We are interested in investigating various extensions to this approach, which we outline in appendix E. To facilitate experimentation with our proposed attention mechanism, we have made an example TensorFlow (Abadi et al., 2016) implementation of our approach available online3 and added a reference implementation to TensorFlow\u2019s tf.contrib.seq2seq module. We also provide a \u201cpractitioner\u2019s guide\u201d in appendix G.\n3https://github.com/craffel/mad"}, {"heading": "Acknowledgements", "text": "We thank Jan Chorowski, Mark Daoust, Pietro Kreitlon Carolino, Dieterich Lawson, Navdeep Jaitly, George Tucker, Quoc V. Le, Kelvin Xu, Cinjon Resnick, Melody Guan, Matthew D. Hoffman, Jeffrey Dean, Kevin Swersky, Ashish Vaswani, and members of the Google Brain team for helpful discussions and insight."}, {"heading": "A. Algorithms", "text": "Below are algorithms for the hard monotonic decoding process we used at test time (algorithm 1) and the approach for computing its expected output that we used to train the network (algorithm 2). Terminology matches the main text, except we use ~0 to signify a vector of zeros.\nAlgorithm 1 Hard Monotonic Attention Process Input: memory h of length T State: s0 = ~0, t0 = 1, i = 1, y0 = StartOfSequence while yi\u22121 6= EndOfSequence do // Produce output tokens until end-of-sequence token is produced\nfinished = 0 // Keep track of whether we chose a memory entry or not for j = ti\u22121 to T do // Start inspecting memory entries hj left-to-right from where we left off ei,j = a(si\u22121, hj) // Compute attention energy for hj pi,j = \u03c3(ei,j) // Compute probability of choosing hj zi,j \u223c Bernoulli(pi,j) // Sample whether to ingest another memory entry or output new symbol if zi,j = 1 then // If we sample 1, we stop scanning the memory ci = hj // Set the context vector to the chosen memory entry ti = j // Remember where we left off for the next output timestep finished = 1 // Keep track of the fact that we chose a memory entry break // Stop scanning the memory\nend if end for if finished = 0 then ci = ~0 // If we scanned the entire memory without selecting anything, set ci to a vector of zeros end if si = f(si\u22121, yi\u22121, ci) // Update the state based on the new context vector using the RNN f yi = g(si, ci) // Output a new symbol using the softmax layer g i = i+ 1\nend while\nAlgorithm 2 Soft Monotonic Attention Decoder Input: memory h of length T , target outputs y\u0302 = {StartOfSequence, y\u03021, y\u03022, . . . ,EndOfSequence} State: s0 = ~0, i = 1, \u03b10,j = \u03b4j for j \u2208 {1, . . . , T} while y\u0302i\u22121 6= EndOfSequence do // Produce output tokens until end of the target sequence pi,0 = 0, qi,0 = 0 // Special cases so that the recurrence relation matches eq. (9) for j = 1 to T do // Inspect all memory entries hj ei,j = a(si\u22121, hj) // Compute attention energy for hj using eq. (16) ei,j = ei,j +N (0, 1) // Add pre-sigmoid noise to encourage pi,j \u2248 0 or pi,j \u2248 1 pi,j = \u03c3(ei,j) // Compute probability of choosing hj qi,j = (1\u2212 pi,j\u22121)qi,j\u22121 + \u03b1i\u22121,j // Iterate recurrence relation derived in eq. (10) \u03b1i,j = pi,jqi,j // Compute the probability that ci = hj\nend for ci = \u2211T j=1 \u03b1i,jhj // Compute weighted combination of memory for context vector si = f(si\u22121, yi\u22121, ci) // Update the state based on the new context vector using the RNN f yi = g(si, ci) // Compute predicted output for timestep i using the softmax layer g i = i+ 1\nend while"}, {"heading": "B. Figures", "text": "Below are example hard monotonic and softmax attention alignments for each of the different tasks we included in our experiments. Attention matrices are displayed so that black corresponds to 1 and white corresponds to 0."}, {"heading": "C. Monotonic Attention Distribution", "text": "Recall that our goal is to compute the expected value of ci under the stochastic process defined by eqs. (6) to (8). To achieve this, we will derive an expression for the probability that ci = hj for j \u2208 {1, . . . , T}, which in accordance with eq. (2) we denote \u03b1i,j . For i = 1, \u03b11,j is the probability that memory element j was chosen (p1,j) multiplied by the probability that memory elements k \u2208 {1, 2, . . . , j \u2212 1} were not chosen ((1\u2212 pi,k)), giving\n\u03b11,j = p1,j j\u22121\u220f k=1 (1\u2212 p1,k) (18)\nFor i > 0, in order for ci = hj we must have that ci\u22121 = hk for some k \u2208 {1, . . . , j} (which occurs with probability \u03b1i\u22121,k) and that none of hk, . . . , hj\u22121 were chosen. Summing over possible values of k, we have\n\u03b1i,j = pi,j j\u2211 k=1\n( \u03b1i\u22121,k\nj\u22121\u220f l=k (1\u2212 pi,l)\n) (19)\nwhere for convenience we define \u220fm\nn x = 1 when n > m. We provide a schematic and explanation of eq. (19) in fig. 7. Note that we can recover eq. (18) from eq. (19) by defining the special case \u03b10,j = \u03b4j (i.e. \u03b10,1 = 1 and \u03b10,j = 0 for j \u2208 {2, . . . , T}). Expanding eq. (19) reveals we can compute \u03b1i,j directly given \u03b1i\u22121,j and \u03b1i,j\u22121:\n\u03b1i,j = pi,j ( j\u22121\u2211 k=1 ( \u03b1i\u22121,k j\u22121\u220f l=k (1\u2212pi,l) ) +\u03b1i\u22121,j ) (20)\n= pi,j ( (1\u2212 pi,j\u22121)\nj\u22121\u2211 k=1\n( \u03b1i\u22121,k\nj\u22122\u220f l=k (1\u2212 pi,l)\n) + \u03b1i\u22121,j ) (21)\n= pi,j ( (1\u2212 pi,j\u22121)\n\u03b1i,j\u22121 pi,j\u22121 + \u03b1i\u22121,j\n) (22)\nDefining qi,j = \u03b1i,j/pi,j produces eqs. (13) and (14). Equation (22) also has an intuitive interpretation: The expression (1 \u2212 pi,j\u22121)\u03b1i,j\u22121/pi,j\u22121 represents the probability that the model attended to memory item j \u2212 1 at output timestep i, adjusted for the fact that memory item j \u2212 1 was not chosen by multiplying (1 \u2212 pi,j\u22121) and dividing pi,j\u22121. Adding \u03b1i\u22121,j reflects the additional possibility that the model attended to memory item j at the previous output timestep, and multiplying by pi,j enforces that memory item j was chosen at the current output timestep i.\nC.1. Recurrence Relation Solution\nWhile eqs. (10) and (22) allow us to compute \u03b1i,j directly from \u03b1i\u22121,j and \u03b1i,j\u22121, the dependence on \u03b1i,j\u22121 means that we must compute the terms \u03b1i,1, \u03b1i,2, . . . , \u03b1i,T sequentially. This is in contrast to softmax attention, where these terms can be computed in parallel because they are independent. Fortunately, there is a solution to the recurrence relation of eq. (10) which allows the terms of \u03b1i to be computed directly via parallelizable cumulative sum and cumulative product operations. Using eq. (13) which substitutes qi,j = \u03b1i,j/pi,j , we have\nqi,j = (1\u2212 pi,j\u22121)qi,j\u22121 + \u03b1i\u22121,j (23) qi,j \u2212 (1\u2212 pi,j\u22121)qi,j\u22121 = \u03b1i\u22121,j (24)\nqi,j\u220fj k=1(1\u2212 pi,k\u22121) \u2212 (1\u2212 pi,j\u22121)qi,j\u22121\u220fj k=1(1\u2212 pi,k\u22121) = \u03b1i\u22121,j\u220fj k=1(1\u2212 pi,k\u22121) (25) qi,j\u220fj k=1(1\u2212 pi,k\u22121) \u2212 qi,j\u22121\u220fj\u22121 k=1(1\u2212 pi,k\u22121) = \u03b1i\u22121,j\u220fj k=1(1\u2212 pi,k\u22121) (26)\nj\u2211 l=1 ( qi,l\u220fl k=1(1\u2212 pi,k\u22121) \u2212 qi,l\u22121\u220fl\u22121 k=1(1\u2212 pi,k\u22121) ) = j\u2211 l=1 \u03b1i\u22121,l\u220fl k=1(1\u2212 pi,k\u22121)\n(27)\nqi,j\u220fj k=1(1\u2212 pi,k\u22121)\n\u2212 qi,0 = j\u2211\nl=1 \u03b1i\u22121,l\u220fl k=1(1\u2212 pi,k\u22121)\n(28)\nqi,j =\n( j\u220f\nk=1\n(1\u2212 pi,k\u22121)\n)( j\u2211\nl=1 \u03b1i\u22121,l\u220fl k=1(1\u2212 pi,k\u22121)\n) (29)\n\u21d2 qi = cumprod(1\u2212 pi)cumsum (\n\u03b1i\u22121 cumprod(1\u2212 pi)\n) (30)\nwhere cumprod(x) = [1, x1, x1x2, . . . , \u220f|x|\u22121 i xi] and cumsum(x) = [x1, x1 + x2, . . . , \u2211|x|\ni xi]. Note that we use the \u201cexclusive\u201d variant of cumprod4 in keeping with our defined special case pi,0 = 0. Unlike the recurrence relation of eq. (10), these operations can be computed efficiently in parallel (Ladner & Fischer, 1980). The primary disadvantage of this approach is that the product in the denominator of eq. (29) can cause numerical instabilities; we address this in appendix G.\n4This can be computed e.g. in Tensorflow via tf.cumprod(x, exclusive=True)"}, {"heading": "D. Experiment Details", "text": "In this section, we give further details into the models and training procedures used in section 4. Any further questions about implementation details should be directed to the corresponding author. All models were implemented with TensorFlow (Abadi et al., 2016).\nD.1. Speech Recognition\nD.1.1. TIMIT\nMel filterbank features were standardized to have zero mean and unit variance across feature dimensions according to their training set statistics and were fed directly into an RNN encoder with three unidirectional LSTM layers, each with 512 hidden units. After the first and second LSTM layers, we downsampled hidden state sequences by skipping every other state before feeding into the subsequent layer. For the decoder, we used a single unidirectional LSTM layer with 256 units, fed directly into the output softmax layer. All weight matrices were initialized uniformly from [\u22120.075, 0.075]. The output tokens were embedded via a learned embedding matrix with dimensionality 30, initialized uniformly from [\u2212 \u221a 3/30, \u221a 3/30]. Our decoder attention energy function used a hidden dimensionality of 512, with the scalar bias r initialized to -1. The model was regularized by adding weight noise with a standard deviation of 0.5 after 2,000 training updates. L2 weight regularization was also applied with a weight of 10\u22126.\nWe trained the network using Adam (Kingma & Ba, 2014), with \u03b21 = 0.9, \u03b22 = 0.999, and = 10\u22126. Utterances were fed to the network with a minibatch size of 4. Our initial learning rate was 10\u22124, which we halved after 40,000 training steps. We clipped gradients when their global norm exceeded 2. We used three training replicas. Beam search decoding was used to produce output sequences with a beam width of 10.\nD.1.2. WALL STREET JOURNAL\nThe input 80 mel filterbank / delta / delta-delta features were organized as a T \u00d7 80 \u00d7 3 tensor, i.e. raw features, deltas, and delta-deltas are concatenated along the \u201cdepth\u201d dimension. This was passed into a stack of two convolutional layers with ReLU activations, each consisting of 32 3\u00d73\u00d7 depth kernels in time\u00d7 frequency. These were both strided by 2 \u00d7 2 in order to downsample the sequence in time, minimizing the computation performed in the following layers. Batch normalization (Ioffe & Szegedy, 2015) was applied prior to the ReLU activation in each layer. All encoder weight matrices and filters were initialized via a truncated Gaussian with zero mean and a standard deviation of 0.1.\nThis downsampled feature sequence was then passed into a single unidirectional convolutional LSTM layer using 1x3 filter (i.e. only convolving across the frequency dimension within each timestep). Finally, this was passed into a stack of three unidirectional LSTM layers of size 256, interleaved with a 256 dimensional linear projection, following by batch normalization, and a ReLU activation. Decoder weight matrices were initialized uniformly at random from [\u22120.1, 0.1].\nThe decoder input is created by concatenating a 64 dimensional embedding corresponding to the symbol emitted at the previous timestep, and the 256 dimensional attention context vector. The embedding was initialized uniformly from [\u22121, 1]. This was passed into a single unidirectional LSTM layer with 256 units. We used an attention energy function hidden dimensionality of 128 and initialized the bias scalar r to -4. Finally the concatenation of the attention context and LSTM output is passed into the softmax output layer.\nWe applied label smoothing (Chorowski & Jaitly, 2017), replacing y\u0302t, the target at time t, with (0.015y\u0302t\u22122 + 0.035y\u0302t\u22121 + y\u0302t + 0.035y\u0302t+1 + 0.015y\u0302t+2)/1.1. We used beam search decoding at test time with rank pruning at 8 hypotheses and a pruning threshold of 3.\nThe network was trained using teacher forcing on minibatches of 8 input utterances, optimized using Adam (Kingma & Ba, 2014) with \u03b21 = 0.9, \u03b22 = 0.999, and = 10\u22126. Gradients were clipped to a maximum global norm of 1. We set the initial learning rate to 0.0002 and decayed by a factor of 10 after 700,000, 1,000,000, and 1,300,000 training steps. L2 weight decay is used with a weight of 10\u22126, and, beginning from step 20,000, Gaussian weight noise with standard deviation of 0.075 was added to weights for all LSTM layers and decoder embeddings. We trained using 16 replicas.\nD.2. Sentence Summarization\nFor data preparation, we used the same Gigaword data processing scripts provided in (Rush et al., 2015) and tokenized into words by splitting on spaces. The vocabulary was determined by selecting the most frequent 200,000 tokens. Only the tokens of the first sentence of the article were used as input to the model. An embedding layer was used to embed tokens into a 200 dimensional space; embeddings were initialized using random normal distribution with mean 0 and standard deviation 10\u22124.\nWe used a 4-layer bidirectional LSTM encoder with 4 layers and a single-layer unidirectional LSTM decoder. All LSTMs, and the attention energy function, had a hidden dimensionality of 256. The decoder LSTM was fed directly into the softmax output layer. All weights were initialized\nuniform-randomly between \u22120.1 and 0.1. In our monotonic alignment decoder, we initialized r to -4. At test time, we used a beam search over possible label sequences with a beam width of 4.\nA batch size of 64 was used and the model was trained to minimize the sampled-softmax cross-entropy loss with 4096 negative samples. The Adam optimizer (Kingma & Ba, 2014) was used with \u03b21 = 0.9, \u03b22 = 0.999, and = 10\u22124, and an initial learning rate of 10\u22123; an exponential decay was applied by multiplying the initial learning rate by .98n/30000 where n is the current training step. Gradients were clipped to have a maximum global norm of 2. Early stopping was used with respect to validation loss and took about 300,000 steps for the baseline model, and 180,000 steps for the monotonic model. Training was conducted on 16 machines with 4 GPUs each. We reported ROUGE scores computed over the test set of (Rush et al., 2015).\nD.3. Machine Translation\nOverall, we followed the model of (Luong & Manning, 2015) closely; our hyperparameters are largely the same: Words were mapped to 512-dimensional embeddings, which were learned during training. We passed sentences to the network in minibatches of size 128. As mentioned in the text, we used two unidirectional LSTM layers in both the encoder and decoder. All LSTM layers, and the attention energy function, had a hidden dimensionality of 512. We trained with a single replica for 40 epochs using Adam (Kingma & Ba, 2014) with \u03b21 = 0.9, \u03b22 = 0.999, and = 10\u22128. We performed grid searches over initial learning rate and decay schedules separately for models using each of the two energy functions eq. (16) and eq. (17). For the model using eq. (16), we used an initial learning rate of 0.0005, and after 10 epochs we multiplied the learning rate by 0.8 each epoch; for eq. (17) we started at 0.001 and multiplied by 0.8 each epoch starting at the eighth epoch. Parameters were uniformly initialized in range [\u22120.1, 0.1]. Gradients were scaled whenever their norms exceeded 5. We used dropout with probability 0.3 as described in (Pham et al., 2014). Unlike (Luong & Manning, 2015), we did not reverse source sentences in our monotonic attention experiments. We set r = \u22122 for the attention energy function bias scalar for both eq. (16) and eq. (17). We used greedy decoding (i.e. no beam search) at test time."}, {"heading": "E. Future Work", "text": "We believe there are a variety of promising extensions of our monotonic attention mechanism, which we outline briefly below.\n\u2022 The primary drawback of training in expectation is that it retains the quadratic complexity during training. One idea would be to replace the cumulative product in eq. (9) with the thresholded remainder method of (Graves, 2016) and (Grefenstette et al., 2015), but in preliminary experiments we were unable to successfully learn alignments with this approach. Alternatively, we could further our investigation into gradient estimators for discrete decisions (such as REINFORCE or straightthrough) instead of training in expectation (Bengio et al., 2013).\n\u2022 As we point out in section 2.4, our method can fail when the attention energies ei,j are poorly scaled. This primarily stems from the strict enforcement of monotonicity. One possibility to mitigate this would be to instead regularize the model with a soft penalty which discourages non-monotonic alignments, instead of preventing them outright.\n\u2022 In some problems, the input-output alignment is nonmonotonic only in small regions. A simple modification to our approach which would allow this would be to subtract a constant integer from ti\u22121 between output timesteps. Alternatively, utilizing multiple monotonic attention mechanisms in parallel would allow the model to attend to disparate memory locations at each output timestep (effectively allowing for non-monotonic alignments) while still maintaining linear-time decoding.\n\u2022 To facilitate comparison, we sought to modify the standard softmax-based attention framework as little as possible. As a result, we have thus far not fully taken advantage of the fact that the decoding process is much more efficient. Specifically, the attention energy function of eq. (15) was primarily motivated by the fact that it is trivially parallelizable so that its repeated application is inexpensive. We could instead use a recurrent attention energy function, whose output depends on both the attention energies for prior memory items and those at the previous output timestep."}, {"heading": "F. How much faster is linear-time decoding?", "text": "Throughout this paper, we have emphasized that one advantage of our approach is that it allows for linear-time decoding, i.e. the decoder RNN only makes a single pass over the memory in the course of producing the output sequence. However, we have thus far not attempted to quantify how much of a speedup this incurs in practice. Towards this end, we conducted an additional experiment to measure the speed of efficiently-implemented softmax-based and hard monotonic attention mechanisms. We chose to focus solely on the speed of the attention mechanisms rather than an entire RNN sequence-to-sequence model because models using these attention mechanisms are otherwise equivalent.\nMeasuring the speed of the attention mechanisms alone allows us to isolate the difference in computational cost between the two approaches.\nSpecifically, we implemented both attention mechanisms using the highly-efficient C++ linear algebra package Eigen (Guennebaud et al., 2010). We set entries of the memory h and the decoder hidden states si to random vectors with entries sampled uniformly in the range [\u22121, 1]. We then computed context vectors following eqs. (2) and (3) for the softmax attention mechanism and following algorithm 1 for hard monotonic attention. We varied the input and output sequence lengths and averaged the time to produce all of the corresponding context vectors over 100 trials for each setting.\nThe speedup of the monotonic attention mechanism compared to softmax attention is visualized in fig. 8. We found monotonic attention to be about 4 \u2212 40\u00d7 faster depending on the input and output sequence lengths. The most prominent difference occurred for short input sequences and long output sequences; in these cases the monotonic attention mechanism finishes processing the input sequence before it finishes producing the output sequence and therefore is able to stop computing context vectors. We emphasize that these numbers represent the best-case speedup from our approach; a more general insight is simply that our proposed hard monotonic attention mechanism has the potential to make decoding significantly more efficient for long sequences. Additionally, this advantage is distinct from the fact that our hard monotonic attention mechanism can be used for online sequence-to-sequence problems. We also\nemphasize that at training time, we expect our soft monotonic attention approach to have roughly the computational cost as standard softmax attention, thanks to the fact that we can compute the resulting attention distribution in parallel as described in appendix C.1. The code used for this benchmark is available in the repository for this paper.5"}, {"heading": "G. Practitioner\u2019s Guide", "text": "Because we are proposing a novel attention mechanism, we share here some insights gained from applying it in various settings in order to help practitioners try it on their own problems:\n\u2022 The recursive structure of computing \u03b1i,j in eq. (9) can result in exploding gradients. We found it vital to apply gradient clipping in all of our experiments, as described in appendix D.\n\u2022 Many automatic differentiation packages can produce numerically unstable gradients when using their cumulative product function.67 Our simple solution was to compute the product in log-space, i.e. replacing \u220f n xn =\nexp( \u2211\ni log(xn)).\n\u2022 In addition, the product in the denominator of eq. (29) can become negligibly small because the terms (1 \u2212 pi,k\u22121) all fall in the range [0, 1]. The simplest way to prevent the resulting numerical instabilities is to clip the range of the denominator to be within [ , 1] where is a small constant (we used = 10\u221210). This can result in incorrect values for \u03b1i,j particularly when some pi,j are close to 1, but we encountered no discernible effect on our results.\n\u2022 Alternatively, we found in preliminary experiments that simply setting the denominator to 1 still produced good results. This can be explained by the observation that when all pi,j \u2208 {0, 1} (which we encourage during training), eq. (29) is equivalent to the recurrence relation of eq. (10) even when the denominator is 1.\n\u2022 As we mention in the experiment details of the previous section, we ended up using a small range of values for the initial energy function scalar bias r. In general, performance was not very sensitive to this parameter, but we found small performance gains from using values in {\u22125,\u22124,\u22123,\u22122,\u22121} for different problems.\n\u2022 More broadly, while the attention energy function modifications described in section 2.4 allowed models using our mechanism to be effectively trained on all tasks we\n5https://github.com/craffel/mad 6https://github.com/tensorflow/\ntensorflow/issues/3862 7https://github.com/Theano/Theano/issues/ 5197\ntried, they were not always necessary for convergence. Specifically, in speech recognition experiments the performance of our model was the same using eq. (15) and eq. (16), but for summarization experiments the models were unable to learn to utilize attention when using eq. (15). For ease of implementation, we recommend starting with the standard attention energy function of eq. (15) and then applying the modifications of eq. (16) if the model fails to utilize attention.\n\u2022 It is occasionally recommended to reverse the input sequence prior to feeding it into sequence-to-sequence models (Sutskever et al., 2014). This violates our assumption that the input should be processed in a leftto-right manner when computing attention, so should be avoided.\n\u2022 Finally, we highly recommend visualizing the attention alignments \u03b1i,j over the course of training. Attention provides valuable insight into the model\u2019s behavior, and failure modes can be quickly spotted (e.g. if \u03b1i,j = 0 for all i and j).\nWith the above factors in mind, on all problems we studied, we were able to replace softmax-based attention with our novel attention and immediately achieve competitive performance."}], "references": [{"title": "TensorFlow: A system for large-scale machine learning", "author": ["Tucker", "Paul", "Vasudevan", "Vijay", "Warden", "Pete", "Wicke", "Martin", "Yu", "Yuan", "Zheng", "Xiaoqiang"], "venue": "In Operating Systems Design and Implementation,", "citeRegEx": "Tucker et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Tucker et al\\.", "year": 2016}, {"title": "Estimating or propagating gradients through stochastic neurons for conditional computation", "author": ["Bengio", "Yoshua", "L\u00e9onard", "Nicholas", "Courville", "Aaron"], "venue": "arXiv preprint arXiv:1308.3432,", "citeRegEx": "Bengio et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 2013}, {"title": "Towards better decoding and language model integration in sequence to sequence models", "author": ["Chorowski", "Jan", "Jaitly", "Navdeep"], "venue": "arXiv preprint arXiv:1612.02695,", "citeRegEx": "Chorowski et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Chorowski et al\\.", "year": 2017}, {"title": "Adaptive computation time for recurrent neural networks", "author": ["Graves", "Alex"], "venue": "arXiv preprint arXiv:1603.08983,", "citeRegEx": "Graves and Alex.,? \\Q2016\\E", "shortCiteRegEx": "Graves and Alex.", "year": 2016}, {"title": "Learning to transduce with unbounded memory", "author": ["Grefenstette", "Edward", "Hermann", "Karl Moritz", "Suleyman", "Mustafa", "Blunsom", "Phil"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Grefenstette et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Grefenstette et al\\.", "year": 2015}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["Ioffe", "Sergey", "Szegedy", "Christian"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "Ioffe et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ioffe et al\\.", "year": 2015}, {"title": "Adam: A method for stochastic optimization", "author": ["Kingma", "Diederik", "Ba", "Jimmy"], "venue": "arXiv preprint arXiv:1412.6980,", "citeRegEx": "Kingma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "Parallel prefix computation", "author": ["Ladner", "Richard E", "Fischer", "Michael J"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Ladner et al\\.,? \\Q1980\\E", "shortCiteRegEx": "Ladner et al\\.", "year": 1980}, {"title": "Text summarization with TensorFlow", "author": ["Liu", "Peter J", "Pan", "Xin"], "venue": null, "citeRegEx": "Liu et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2016}, {"title": "Stanford neural machine translation systems for spoken language domain", "author": ["Luong", "Minh-Thang", "Manning", "Christopher D"], "venue": "In International Workshop on Spoken Language Translation,", "citeRegEx": "Luong et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Luong et al\\.", "year": 2015}, {"title": "Dropout improves recurrent neural networks for handwriting recognition", "author": ["Pham", "Vu", "Bluche", "Th\u00e9odore", "Kermorvant", "Christopher", "Louradour", "J\u00e9r\u00f4me"], "venue": "In International Conference on Frontiers in Handwriting Recognition,", "citeRegEx": "Pham et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pham et al\\.", "year": 2014}, {"title": "A neural attention model for abstractive sentence summarization", "author": ["Rush", "Alexander M", "Chopra", "Sumit", "Weston", "Jason"], "venue": "In Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Rush et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Rush et al\\.", "year": 2015}, {"title": "Sequence to sequence learning with neural networks", "author": ["Sutskever", "Ilya", "Vinyals", "Oriol", "Le", "Quoc V"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Sutskever et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 12, "context": "Recently, the \u201csequence-to-sequence\u201d framework (Sutskever et al., 2014; Cho et al., 2014) has facilitated the use of recurrent neural networks (RNNs) on sequence transduction problems such as machine translation and speech recognition.", "startOffset": 47, "endOffset": 89}, {"referenceID": 9, "context": "Attention-based sequence-tosequence models have proven to be extremely effective on a wide variety of problems, including machine translation (Bahdanau et al., 2015; Luong et al., 2015), image captioning (Xu et al.", "startOffset": 142, "endOffset": 185}, {"referenceID": 11, "context": ", 2016), and sentence summarization (Rush et al., 2015).", "startOffset": 36, "endOffset": 55}, {"referenceID": 9, "context": "Typically, a(\u00b7) is a single-layer neural network using a tanh nonlinearity, but other functions such as a simple dot product between si\u22121 and hj have been used (Luong et al., 2015; Graves et al., 2014).", "startOffset": 160, "endOffset": 201}, {"referenceID": 9, "context": "In a similar vein, (Luong et al., 2015) explore only computing attention over a small window of the memory.", "startOffset": 19, "endOffset": 39}, {"referenceID": 11, "context": "ROUGE F-measure scores for sentence summarization on the Gigaword test set of (Rush et al., 2015).", "startOffset": 78, "endOffset": 97}, {"referenceID": 11, "context": "(Rush et al., 2015) reports ROUGE recall scores, so we report the F-1 scores computed for that approach from (Chopra et al.", "startOffset": 0, "endOffset": 19}, {"referenceID": 11, "context": "01 (Rush et al., 2015) 29.", "startOffset": 3, "endOffset": 22}, {"referenceID": 11, "context": "For data preparation and evaluation, we followed the approach of (Rush et al., 2015), measuring performance using the ROUGE metric.", "startOffset": 65, "endOffset": 84}, {"referenceID": 9, "context": "Our baseline neural machine translation (NMT) system is the softmax attention-based sequence-to-sequence model described in (Luong et al., 2015).", "startOffset": 124, "endOffset": 144}, {"referenceID": 9, "context": "In (Luong et al., 2015), the authors demonstrated that under their proposed architecture, a dot product-based energy function worked better than eq.", "startOffset": 3, "endOffset": 23}, {"referenceID": 9, "context": "Since our architecture is based on that of (Luong et al., 2015), to facilitate comparison we also tested the following variant:", "startOffset": 43, "endOffset": 63}], "year": 2017, "abstractText": "Recurrent neural network models with an attention mechanism have proven to be extremely effective on a wide variety of sequence-tosequence problems. However, the fact that soft attention mechanisms perform a pass over the entire input sequence when producing each element in the output sequence precludes their use in online settings and results in a quadratic time complexity. Based on the insight that the alignment between input and output sequence elements is monotonic in many problems of interest, we propose an end-to-end differentiable method for learning monotonic alignments which, at test time, enables computing attention online and in linear time. We validate our approach on sentence summarization, machine translation, and online speech recognition problems and achieve results competitive with existing sequence-tosequence models.", "creator": "LaTeX with hyperref package"}}}