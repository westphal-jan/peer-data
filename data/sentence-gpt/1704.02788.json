{"id": "1704.02788", "review": {"conference": "EMNLP", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Apr-2017", "title": "Entity Linking for Queries by Searching Wikipedia Sentences", "abstract": "We present a simple yet effective approach for linking entities in queries. The key idea is to search sentences similar to a query from Wikipedia articles and directly use the human-annotated entities in the similar sentences as candidate entities for the query. Then, we employ a rich set of features, such as link-probability, context-matching, word embeddings, and relatedness among candidate entities as well as their related entities, to rank the candidates under a regression based framework. The advantages of our approach lie in two aspects, which contribute to the ranking process and final linking result. First, it can greatly reduce the number of candidate entities by filtering out irrelevant entities with the words in the query. Second, we can obtain the query sensitive prior probability in addition to the static link-probability derived from all Wikipedia articles. We conduct experiments on two benchmark datasets on entity linking for queries, namely the ERD14 dataset and the GERDAQ dataset. Experimental results show that our method outperforms state-of-the-art systems and yields 75.0% in F1 on the ERD14 dataset and 56.9% on the GERDAQ dataset. Finally, we also have a significantly better likelihood of ranking all query parameters with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative similarity of the top-level terms with the relative", "histories": [["v1", "Mon, 10 Apr 2017 10:19:53 GMT  (699kb,D)", "http://arxiv.org/abs/1704.02788v1", null], ["v2", "Tue, 18 Apr 2017 06:59:56 GMT  (702kb,D)", "http://arxiv.org/abs/1704.02788v2", null], ["v3", "Thu, 18 May 2017 08:03:49 GMT  (702kb,D)", "http://arxiv.org/abs/1704.02788v3", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["chuanqi tan", "furu wei", "pengjie ren", "weifeng lv", "ming zhou 0001"], "accepted": true, "id": "1704.02788"}, "pdf": {"name": "1704.02788.pdf", "metadata": {"source": "CRF", "title": "Entity Linking for Queries by Searching Wikipedia Sentences", "authors": ["Chuanqi Tan", "Furu Wei", "Pengjie Ren", "Weifeng Lv", "Ming Zhou"], "emails": ["tanchuanqi@nlsde.buaa.edu.cn", "jay.ren@outlook.com", "mingzhou}@microsoft.com", "lwf@buaa.edu.cn"], "sections": [{"heading": "1 Introduction", "text": "Query understanding has been an important research area in information retrieval and natural language processing (Croft et al., 2010). A key part of this problem is entity linking, which aims to annotate the entities in the query and link them to a knowledge base such as Freebase and\n\u2217Contribution during internship at Microsoft Research.\nWikipedia. This problem has been extensively studied over the recent years (Carmel et al., 2014; Usbeck et al., 2015; Cornolti et al., 2016).\nThe mainstream methods of entity linking for queries can be summed up in three steps: mention detection, candidate generation, and entity disambiguation. The first step is to recognize candidate mentions in the query. The most common method to detect mentions is to search a dictionary collected by the entity alias in a knowledge base and the human-maintained information in Wikipedia (such as anchors, titles and redirects) (Laclavik et al., 2014). The second step is to generate candidates by mapping mentions to entities. It usually uses all possible senses of detected mentions as candidates. Hereafter, we refer to these two steps of generating candidate entities as entity search. Finally, they disambiguate and prune candidate entities, which is usually implemented with a ranking framework.\nThere are two main issues in entity search. First, a mention may be linked to many entities. The methods using entity search usually leverage little context information in the query. Therefore it may generate many completely irrelevant entities for the query, which brings challenges to the ranking phase. For example, the mention \u201cAustin\u201d usually represents the capital of Texas in the United States. However, it can also be linked to \u201cAustin, Western Australia\u201d, \u201cAustin, Quebec\u201d, \u201cAustin (name)\u201d, \u201cAustin College\u201d, \u201cAustin (song)\u201d and 31 other entities in the Wikipedia page of \u201cAustin (disambiguation)\u201d. For the query \u201cblake shelton austin lyrics\u201d, Blake Shelton is a singer and made his debut with the song \u201cAustin\u201d. The entity search method detects the mention \u201caustin\u201d using the dictionary. However, while \u201cAustin (song)\u201d is most related to the context \u201cblake shelton\u201d and \u201clyrics\u201d, the mention \u201caustin\u201d may be linked to all the above entities as candidates. Therefore candidate generar X iv :1 70 4.\n02 78\n8v 1\n[ cs\n.C L\n] 1\n0 A\npr 2\n01 7\nation with entity search generates too many candidates especially for a common anchor text with a large number of corresponding entities. Second, it is hard to recognize entities with common surface names. The common methods usually define a feature called \u201clink-probability\u201d as the probability that a mention is annotated in all documents. There is an issue with this probability being static whatever the query is. We show an example with the query \u201cher film\u201d. \u201cHer (film)\u201d is a film while its surface name is usually used as a possessive pronoun. Since the static link-probability of \u201cher\u201d from all Wikipedia articles is very low, \u201cher\u201d is usually not treated as a mention linked to the entity \u201cHer (film)\u201d.\nIn this paper, we propose a novel approach to generating candidates by searching sentences from Wikipedia articles and directly using the humanannotated entities as the candidates. Our approach can greatly reduce the number of candidate entities and obtain the query sensitive prior probability. We take the query \u201cblake shelton austin lyrics\u201d as an example. Below we show a sentence in the Wikipedia page of \u201cAustin (song)\u201d.\nIn the above sentence, the mentions \u201cAustin\u201d and \u201cBlake Shelton\u201d in square brackets are annotated to the entity \u201cAustin (song)\u201d and \u201cBlake Shelton\u201d, respectively. We generate candidates by searching sentences and thus obtain \u201cBlake Shelton\u201d as well as \u201cAustin (song)\u201d from this example. We reduce the number of candidates because many irrelevant entities linked by \u201caustin\u201d do not occur in returned sentences. In addition, as previous methods generate candidates by searching entities without the query information, \u201caustin\u201d can be linked to \u201cAustin, Texas\u201d with much higher static link-probability than all other senses of \u201caustin\u201d. However, the number of returned sentences that contain \u201cAustin, Texas\u201d is close to the number of sentences that contain \u201cAustin (song)\u201d in our system. We show another example with the query \u201cher film\u201d in Table 2. In this sentence, \u201cHer\u201d, \u201cromantic\u201d, \u201cscience fiction\u201d, \u201ccomedy-drama\u201d and \u201cSpike Jonze\u201d are annotated to corresponding en-\ntities. As \u201cHer\u201d is annotated to \u201cHer (film)\u201d by humans in this example, we have strong evidence to annotate it even if it is usually used as a possessive pronoun with very low static link-probability.\nWe obtain the anchors as well as corresponding entities and map them to the query after searching similar sentences. Then we build a regression based framework to rank the candidates. We use a rich set of features, such as link-probability, context-matching, word embeddings, and relatedness among candidate entities as well as their related entities. We evaluate our method on the ERD14 and GERDAQ datasets. Experimental results show that our method outperforms state-ofthe-art systems and yields 75.0% and 56.9% in terms of F1 metric on the ERD14 dataset and the GERDAQ dataset respectively."}, {"heading": "2 Related Work", "text": "Recognizing entity mentions in text and linking them to the corresponding entries helps to understand documents and queries. Most work uses the knowledge base including Freebase (Chiu et al., 2014), YAGO (Yosef et al., 2011) and Dbpedia (Olieman et al., 2014). Wikify (Mihalcea and Csomai, 2007) is the very early work on linking anchor texts to Wikipedia pages. It extracts all ngrams that match Wikipedia concepts such as anchors and titles as candidates. They implement a voting scheme based on the knowledge-based and data-driven method to disambiguate candidates. Cucerzan (2007) uses four recourses to generate candidates, namely entity pages, redirecting pages, disambiguation pages, and list pages. Then they disambiguate candidates by calculating the similarity between the contextual information and the document as well as category tags on Wikipedia pages. Milne and Witten (2008) generate candidates by gathering all n-grams in the document, and retaining those whose probability exceeds a low threshold. Then they define commonness and relatedness on the hyper-link structure of Wikipedia to disambiguate candidates.\nThe work on linking entities in queries has been\nextensively studied in recent years. TagME (Ferragina and Scaiella, 2010) is a very early work on entity linking in queries. It generates candidates by searching Wikipedia page titles, anchors and redirects. Then disambiguation exploits the structure of the Wikipedia graph, according to a voting scheme based on a relatedness measure inspired by Milne and Witten (2008). The improved version of TagME, named WAT (Piccinno and Ferragina, 2014), uses Jaccard-similarity between two pages\u2019 in-links as a measure of relatedness and uses PageRank to rank the candidate entities.\nUnlike the work which revolves around ranking entities for query spans, the Entity Recognition and Disambiguation (ERD) Challenge (Carmel et al., 2014) views entity linking in queries as the problem of finding multiple query interpretations. The SMAPH system (Cornolti et al., 2014) which wins the short-text track works in three phases: fetching, candidate-entity generation and pruning. First, they fetch the snippets returned by a commercial search engine. Next, snippets are parsed to identify candidate entities by looking at the boldfaced parts of the search snippets. Finally, they implement a binary classifier using a set of features such as the coherence and robustness of the annotation process and the ranking as well as composition of snippets. They further extend SMAPH-1 to SMAPH-2 (Cornolti et al., 2016). They use the annotator WAT to annotate the snippets of search results to generate candidates and joint the additionally link-back step as well as the pruning step in the ranking phase, which gets the state-of-theart results on the ERD14 dataset and their released dataset GERDAQ.\nOur work is different from using search engines to generate candidates. We firstly propose to search Wikipedia sentences and take advantage of human annotations to generate candidates. The previous work, such as SMAPH, employs search engine for candidate generation. However, it uses WAT, an entity search based tool, to pre-annotate the snippets for candidate generation, which falls back the issues of entity search."}, {"heading": "3 Our Approach", "text": "As shown in Figure 1, we introduce our approach with the query \u201cblake shelton austin lyrics\u201d. Our approach consists of three main phases: sentence search, candidate generation, and candidate ranking. First, we search the query in all Wikipedia ar-\nticles to obtain the similar sentences. Second, we extract human-annotated entities from these sentences. We keep the entities whose corresponding anchor texts occur in the query as candidates, and treat others as related entities. Specifically, we obtain three candidates in this example, namely \u201cBlake Shelton\u201d, \u201cAustin, Texas\u201d, and \u201cAustin (song)\u201d. Finally, we use a regression based model to rank the candidate entities. We get the final annotations of \u201cBlake Shelton\u201d and \u201cAustin (song)\u201d whose scores are higher than the threshold selected on the development set. In the following sections, we describe these three phases in detail."}, {"heading": "3.1 Sentence Search", "text": "Sentences in Wikipedia articles usually contain anchors linking to entities. We are therefore motivated to generate the candidate entities based on the sentence search instead of the common method using entity search. There are some issues in the original annotations because of the annotation regulation. First, entities in their own pages are usually not annotated. Thus we annotate these entities with matching between the text and the page title. Second, entities are usually annotated only in their first appearance. We annotate these entities if they are annotated in previous sentences in the page. Moreover, pronouns are widely used in Wikipedia sentences and are usually not annotated. We use the Stanford CoreNLP toolkit (Manning et al., 2014) to do the coreference resolution. In addition, we use the content in the disambiguation page and the infobox. Although these two kinds of information may have incomplete grammatical structure, it contains enough context information for the sentence search in our task.\nWe use the Wikipedia snapshot of May 1, 2016, which contains 4.45 million pages and 120 million sentences. We extract sentences that contain at least one anchor in the Wikipedia articles, and extract human-annotated anchors as well as corresponding entities in the sentences. The original annotation contains 82.6 million anchors. We obtain 110 million annotated anchors in 48.4 million sentences after the incrementally annotation. All of above annotations are indexed by Lucene1 by building documents consisting of two fields: the first one contains the sentence and the second one contains all anchors with their corresponding entities. For each query, we search it with Lucene\n1http://lucene.apache.org\nusing its default ranker2 based on the vector space model and tf-idf to obtain the top K sentences (K is selected on the development set). We extract all entities as the related entities and use these sentences as their support sentences."}, {"heading": "3.2 Candidate Generation", "text": "We back-map anchors and corresponding entities extracted in sentences to generate candidates. We use (a, e) to denote the pair of the anchor text and corresponding entity and use w(a, e) to denote the number of sentences containing the pair (a, e). Then, we prune the candidate pairs according to following rules.\nFirst, we only keep the pair whose corresponding anchor text a occurs in the query as a candidate, which has been used in previous work (Ferragina and Scaiella, 2010). Second, we follow the long-string match strategy. If we have two pairs (a1, e1) and (a2, e2) while a1 is a substring of a2, we drop (a1, e1) if w(a1, e1) < w(a2, e2). This is because a2 is typically less ambiguous than a1. For example, for the query \u201cmesa community college football\u201d, we can obtain the anchor \u201cmesa\u201d, \u201ccollege\u201d, \u201ccommunity college\u201d, and \u201cmesa community college\u201d. We only keep \u201cmesa community college\u201d because it is longest and occurs most times in returned sentences. However, if w(a1, e1) > w(a2, e2), we keep both candidate pairs because a1 is more common in the query.\nIn addition, we keep the entity whose surface\n2Details can be found in https://lucene.apache. org/core/2_9_4/api/core/org/apache/ lucene/search/Similarity.html\nform is the same with the anchor text and prune others. If we have two pairs (a, e1) and (a, e2) with the same anchor, and only e2 occurs in the query, we drop the pair (a, e1) if w(a, e1) < w(a, e2). For example, for the query \u201cbusiness day south africa\u201d, the anchor \u201csouth africa\u201d can be linked to \u201csouth africa\u201d, \u201cunion of south africa\u201d, and \u201csouth africa cricket team\u201d. We only keep the entity \u201csouth africa\u201d."}, {"heading": "3.3 Candidate Ranking", "text": "We build a regression based framework to rank the candidate entities. In the training phase, we treat the candidates that are equal to the ground truth as the positive samples and the others as negative samples. The regression object of the positive sample is set to the score 1.0. The negative sample is set to the maximum score of overlapping ratio of tokens between its text and each gold answer. The regression object of the negative sample is not simply set to 0 in order to give a small score if the candidate is very closed to the ground truth. We find it benefits the final results. We use LIBLINEAR (Fan et al., 2008) with L2-regularized L2loss support vector regression to train the regression model. The object function is to minimize\nwTw/2+C \u2211 max(0, |yi\u2212wTxi|\u2212eps)2 (1)\nwhere xi is the feature set, yi is the object score and w is the parameter to be learned. We follow the default setting that C is set to 1 and eps is set to 0.1.\nIn the test phase, each candidate gets a score of wTxi and then we only output the candidate\nwhose score is higher than the threshold selected on the development set.\nWe employ four different feature sets to capture the quality of a candidate from different aspects. All features are shown in Table 3.\nContext-Independent Features This feature set measures each annotation pair (a, e) without context information. Feature 1-4 catch the syntactic properties of the candidate. Feature 5 is the number of returned sentences that contain (a, e). Feature 6 is the maximum search score (returned by Lucene) in its support sentences. Moreover, inspired by TagME (Ferragina and Scaiella, 2010), we denote freq(a) as the number of times the text a occurs in Wikipedia. We use link(a) to denote the number of times the text a occurs as an anchor. We use lp(a) = link(a)/freq(a) to denote the static link-probability that an occurrence of a has been set as an anchor. We use freq(a, e) to denote the number of times that the anchor text a links to the entity e, and use pr(e|a) = freq(a, e)/link(a) to denote the static prior-probability that the anchor text a links to e. Features 7 and 8 are these two probabilities.\nContext-Matching Features We treat the other words except for the anchor text as the context. This feature set measures the context matching to the query. Feature 9 is the context matching score calculated by tokens. We denote c as the set of context words. For each ci in c, the cm sc(ci) is the ratio of times that ci occurs in the support sentences, and cm sc(c) = 1N \u2211 cm sc(ci). Features 10 and 11 are the ratio of context words occurring in the first sentence in the entity page and the description of entity\u2019s disambiguation page (if existed), respectively. Moreover, we train a 300- dimensional word embeddings on all Wikipedia articles by word2vec (Mikolov et al., 2013) and use the average embedding of each word as the sentence representation. Feature 12 is the maximum cosine score between the query and each support sentence. Features 13 and 14 are calculated with the first sentence in the entity\u2019s page and the description in the disambiguation page.\nRelatedness Features of Candidate Entities This set of features measures how much an entity is supported by other candidates. Feature 15 is the number of other candidate entities occurring in the support sentences. Feature 16 is the number of candidate entities occurring in the same Wikipedia page with the current entity.\nRelatedness Features to Related Entities This set of features measures the relatedness between candidates and related entities outside of queries. Related entities can provide useful signals for disambiguating the candidates. Features 17 and 18 are analogous features with features 15 and 16, which are calculated by the related entities."}, {"heading": "4 Experiment", "text": "We conduct experiments on the ERD14 and GERDAQ datasets. We compare with several baseline annotators and experimental results show that our method outperforms the baseline on these two datasets. We also report the parameter selection on each dataset and analyze the quality of the candidates using different methods."}, {"heading": "4.1 Dataset", "text": "ERD143 is a benchmark dataset in the ERD Challenge (Carmel et al., 2014), which contains both\n3http://web-ngram.research.microsoft. com/erd2014/Datasets.aspx\nlong-text track and short-text track. In this paper we only focus on the short-text track. It contains 500 queries as the development set and 500 queries as the test set. Due to the lack of training set, we use the development set to do the model training and tuning. This dataset can be evaluated by both Freebase and Wikipedia as the ERD Challenge Organizers provide the Freebase Wikipedia Mapping with one-to-one correspondence of entities between two knowledge bases. We use Wikipedia to evaluate our results.\nGERDAQ4 is a benchmark dataset to annotate entities to Wikipedia built by Cornolti et al. (2016). It contains 500 queries for training, 250 for development, and 250 for test. The query in this dataset is sampled from the KDD-Cup 2005 and then annotated manually. Both name entities and common concepts are annotated in this dataset."}, {"heading": "4.2 Evaluation Metric", "text": "We use average F1 designed by ERD Challenge (Carmel et al., 2014) as the evaluation metrics. Specifically, given a query q, with labeled entities A\u0302 = {E\u03021, . . . , E\u0302n}. We define the Fmeasure of a set of hypothesized interpretations A = {E1, . . . , Em} as follows:\nPrecision = |A\u0302 \u2229A| |A| , Recall = |A\u0302 \u2229A| |A\u0302| (2) F1 = 2\u00d7 Precision\u00d7Recall Precision+Recall (3)\nThe average F1 of the evaluation set is the average of the F1 for each query:\nAverageF1 = 1\nN N\u2211 i=1 F1(qi) (4)\nFollowing the evaluation guideline in ERD14 and GERDAQ, we define recall to be 1.0 if the gold binding of a query is empty and define precision to be 1.0 if the hypothesized interpretation is empty."}, {"heading": "4.3 Baseline Methods", "text": "We compare with several baselines and use the results reported by the ERD organizer and Cornolti et al. (2016).\n4http://acube.di.unipi.it/datasets\nAIDA (Hoffart et al., 2011) searches the mention using Stanford NER Tagger based on YAGO2. We select AIDA as a representative system aiming to entity linking for documents following the work in Cornolti et al. (2016). WAT (Piccinno and Ferragina, 2014) is the improved version of TagME (Ferragina and Scaiella, 2010). Magnetic IISAS (Laclavik et al., 2014) retrieves the index extracted from Wikipedia, Freebase and Dbpedia. Then it exploits Wikipedia link graph to assess the similarity of candidate entities for disambiguation and filtering. Seznam (Eckhardt et al., 2014) uses Wikipedia and DBpedia to generate candidates. The disambiguation step is based on PageRank over the graph. NTUNLP (Chiu et al., 2014) searches the query to match Freebase surface forms. The disambiguation step is built on top of TagME and Wikipedia. SMAPH-1 (Cornolti et al., 2014) is the winner in the short-text track in the ERD14 Challenge. SMAPH-2 (Cornolti et al., 2016) is the improved version of SMAPH-1. It generates candidates from the snippets of search results returned by the Bing search engine."}, {"heading": "4.4 Result", "text": "We report results on the ERD datset and GERDAQ dataset in Table 4 and Table 5, respectively. On the ERD14 dataset, WAT is superior to AIDA but it is still up to 10% than SMAPH-1 that wins the ERD Challenge. SMAPH-2 improves 2% than SMAPH-1. Our system significantly outperforms the state-of-the-art annotator SMAPH-2 by 4.2%. On the GERDAQ dataset, our system is 2.5% superior to the state-of-the-art annotator SMAPH-2. The F1 score in this dataset is much lower than the ERD dataset because common concepts such as \u201cWeek\u201d and \u201cGame\u201d that are not annotated in the ERD dataset are annotated in the GERDAQ dataset.\nSpell checking has been widely used in the baseline annotators as it is not uncommon in queries (Laclavik et al., 2014). The SMAPH system that generates candidates by search results implicitly leverages the spell-checking embedded in search engines. In our experiments, spell checking improves 1.0% on the ERD dataset and 7.6% on the GERDAQ dataset. Furthermore, only 6.9% of queries in the ERD14 dataset have spelling\nmistakes, whereas the number in the GERDAQ dataset is 23.0%. Thus spell-checking is more important in the GERDAQ dataset.\nThe result decreases 0.6% on the ERD dataset and 1.1% on the GERDAQ dataset without the additional annotation. Furthermore, while the F1 score decreases 2.4% on the ERD dataset and 1.4% on the GERDAQ dataset without the context features, the score only decreases 0.5% on the ERD dataset and 0.2% on the GERDAQ dataset without the relatedness features. Unlike the work on entity linking for documents (Eckhardt et al., 2014; Witten and Milne, 2008) that features derived from entity relations get promising results,\nthe context features play a more important role than the relatedness features on entity linking for queries as search queries are short and contain fewer entities than documents."}, {"heading": "4.5 Parameter Selection", "text": "There are two parameters in our framework, namely the number of search sentences and the threshold for final output. We select these two parameters on the development set. We show the F1 score with different numbers of search sentences and thresholds in Figure 2 and Figure 3. On the ERD development set, better results occur in the search number between 600 and 800 as well as the threshold 0.55 and 0.6. On the GERDAQ development set, better results occur in the search number between 700 and 1000 as well as the threshold between 0.45 and 0.5. In our experiment, we set the number of sentences to 700 and the threshold to 0.56 on the ERD dataset as well as 800 and 0.48 on the GERDAQ dataset according to the F1 scores on the development set."}, {"heading": "4.6 Model Analysis", "text": "The main difference between our method and most previous work is that we generate candidates by searching Wikipedia sentences instead of searching entities. For generating candidates with entity search, we build a dictionary containing all anchors, titles, and redirects in Wikipedia. Then we\nquery the dictionary to get the mention and obtain corresponding entities as candidates. We use the same pruning rules and ranking framework in our experiments, but exclude the features from support sentences because the entity search method does not contain the information. The F1 score is shown in Table 6. We achieve similar results in our implementation of the method using entity search on the ERD dataset as Magnetic IISAS (Laclavik et al., 2014) which uses a similar method and ranks 4th with the F1 of 65.57 in the ERD14 Challenge.\nWe compare the two candidate generation methods in several aspects. First, we show the overall results in Table 6. The average number of candidates from our method is much smaller. It is noted that the anchors from sentence search can also be found in entity search. However, we only extract the entities in the returned sentences while the methods by entity search use all entities linked by the anchors. In addition, features such as the number of sentences containing the entity from sentence search which provide query sensitive prior probability contribute to the ranking process. It improves the F1 score from 73.81 to 75.01 for sentence search and from 66.46 to 69.00 for entity search. More important, the result of \u201cES+RF\u201d is still significantly worse than the result of both small candidate set and Wikipedia related features that prunes irrelevant candidates at the beginning, which proves that the high-quality candidate set is very important since the larger candidate set brings in lots of noise in training a ranking model.\nMoreover, there are 102 queries (20.4%) without labeled entities in the ERD dataset. We only give 7 incorrect annotations in these queries while the number is 13 from entity search. Furthermore, as shown in Table 7, the coverage of our method is lower in queries with at least one entity, but we obtain better results on precision, recall and F1 in the final stage.\nFigure 4 illustrates the F1 score grouped by the number of candidates using entity search. In almost all columns the F1 score of our method is better than the baseline. In left columns (the number of candidates is less than 10), both methods generate few candidates. The F1 score of our method is higher, which proves that we train a better ranking model because of our small but quality candidate set. Moreover, the right columns (the number of candidates is more than 10) show that the F1 score using entity search gradually decreases with the incremental candidates. However, our method based on sentence search takes advantage of context information to keep a small set of candidates, which keeps a consistent result and outperforms the baseline."}, {"heading": "5 Conclusion", "text": "In this paper we address the problem of entity linking for open-domain queries. We introduce a novel approach to generating candidate entities by searching sentences in the Wikipedia to the query, then we extract the human-annotated entities as the candidates. We implement a regression model to rank these candidates for the final output. Two experiments on the ERD dataset and the GERDAQ dataset show that our approach outperforms the baseline systems. In this work we directly use the default ranker in Lucene for similar sentences, which can be improved in future work."}, {"heading": "Acknowledgments", "text": "The first author and the fourth author are supported by the National Natural Science Foundation of China (Grant No. 61421003)."}], "references": [{"title": "Erd\u201914: entity recognition and disambiguation challenge", "author": ["David Carmel", "Ming-Wei Chang", "Evgeniy Gabrilovich", "Bo-June Paul Hsu", "Kuansan Wang."], "venue": "ACM SIGIR Forum. ACM, volume 48, pages 63\u201377.", "citeRegEx": "Carmel et al\\.,? 2014", "shortCiteRegEx": "Carmel et al\\.", "year": 2014}, {"title": "Ntunlp approaches to recognizing and disambiguating entities in long and short text at the erd challenge 2014", "author": ["Yen-Pin Chiu", "Yong-Siang Shih", "Yang-Yin Lee", "ChihChieh Shao", "Ming-Lun Cai", "Sheng-Lun Wei", "Hsin-Hsi Chen."], "venue": "Proceedings of the", "citeRegEx": "Chiu et al\\.,? 2014", "shortCiteRegEx": "Chiu et al\\.", "year": 2014}, {"title": "A piggyback system for joint entity mention detection and linking in web queries", "author": ["Marco Cornolti", "Paolo Ferragina", "Massimiliano Ciaramita", "Stefan R\u00fcd", "Hinrich Sch\u00fctze."], "venue": "Proceedings of the 25th International Conference on World Wide Web.", "citeRegEx": "Cornolti et al\\.,? 2016", "shortCiteRegEx": "Cornolti et al\\.", "year": 2016}, {"title": "The smaph system for query entity recognition and disambiguation", "author": ["Marco Cornolti", "Paolo Ferragina", "Massimiliano Ciaramita", "Hinrich Sch\u00fctze", "Stefan R\u00fcd."], "venue": "Proceedings of the first international workshop on Entity recognition & disam-", "citeRegEx": "Cornolti et al\\.,? 2014", "shortCiteRegEx": "Cornolti et al\\.", "year": 2014}, {"title": "Query representation and understanding workshop", "author": ["W Bruce Croft", "Michael Bendersky", "Hang Li", "Gu Xu."], "venue": "SIGIR Forum. volume 44, pages 48\u201353.", "citeRegEx": "Croft et al\\.,? 2010", "shortCiteRegEx": "Croft et al\\.", "year": 2010}, {"title": "Large-scale named entity disambiguation based on wikipedia data", "author": ["Silviu Cucerzan."], "venue": "EMNLPCoNLL. volume 7, pages 708\u2013716.", "citeRegEx": "Cucerzan.,? 2007", "shortCiteRegEx": "Cucerzan.", "year": 2007}, {"title": "Entity linking based on the cooccurrence graph and entity probability", "author": ["Alan Eckhardt", "Juraj Hre\u0161ko", "Jan Proch\u00e1zka", "Otakar Smrf."], "venue": "Proceedings of the first international workshop on Entity recognition & disambiguation. ACM, pages 37\u201344.", "citeRegEx": "Eckhardt et al\\.,? 2014", "shortCiteRegEx": "Eckhardt et al\\.", "year": 2014}, {"title": "Liblinear: A library for large linear classification", "author": ["Rong-En Fan", "Kai-Wei Chang", "Cho-Jui Hsieh", "XiangRui Wang", "Chih-Jen Lin."], "venue": "Journal of machine learning research 9(Aug):1871\u20131874.", "citeRegEx": "Fan et al\\.,? 2008", "shortCiteRegEx": "Fan et al\\.", "year": 2008}, {"title": "Tagme: on-the-fly annotation of short text fragments (by wikipedia entities)", "author": ["Paolo Ferragina", "Ugo Scaiella."], "venue": "Proceedings of the 19th ACM international conference on Information and knowledge management. ACM, pages 1625\u20131628.", "citeRegEx": "Ferragina and Scaiella.,? 2010", "shortCiteRegEx": "Ferragina and Scaiella.", "year": 2010}, {"title": "Learning to link", "author": ["ICLR . David Milne", "Ian H Witten"], "venue": null, "citeRegEx": "Milne and Witten.,? \\Q2008\\E", "shortCiteRegEx": "Milne and Witten.", "year": 2008}, {"title": "Aida: An online tool for accurate disambiguation of named entities in text and tables", "author": ["Mohamed Amir Yosef", "Johannes Hoffart", "Ilaria Bordino", "Marc Spaniol", "Gerhard Weikum."], "venue": "Proceedings of the VLDB Endowment 4(12):1450\u20131453.", "citeRegEx": "Yosef et al\\.,? 2011", "shortCiteRegEx": "Yosef et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 4, "context": "Query understanding has been an important research area in information retrieval and natural language processing (Croft et al., 2010).", "startOffset": 113, "endOffset": 133}, {"referenceID": 0, "context": "This problem has been extensively studied over the recent years (Carmel et al., 2014; Usbeck et al., 2015; Cornolti et al., 2016).", "startOffset": 64, "endOffset": 129}, {"referenceID": 2, "context": "This problem has been extensively studied over the recent years (Carmel et al., 2014; Usbeck et al., 2015; Cornolti et al., 2016).", "startOffset": 64, "endOffset": 129}, {"referenceID": 1, "context": "Most work uses the knowledge base including Freebase (Chiu et al., 2014), YAGO (Yosef et al.", "startOffset": 53, "endOffset": 72}, {"referenceID": 10, "context": ", 2014), YAGO (Yosef et al., 2011) and Dbpedia (Olieman et al.", "startOffset": 14, "endOffset": 34}, {"referenceID": 1, "context": "Most work uses the knowledge base including Freebase (Chiu et al., 2014), YAGO (Yosef et al., 2011) and Dbpedia (Olieman et al., 2014). Wikify (Mihalcea and Csomai, 2007) is the very early work on linking anchor texts to Wikipedia pages. It extracts all ngrams that match Wikipedia concepts such as anchors and titles as candidates. They implement a voting scheme based on the knowledge-based and data-driven method to disambiguate candidates. Cucerzan (2007) uses four recourses to generate candidates, namely entity pages, redirecting pages, disambiguation pages, and list pages.", "startOffset": 54, "endOffset": 460}, {"referenceID": 1, "context": "Most work uses the knowledge base including Freebase (Chiu et al., 2014), YAGO (Yosef et al., 2011) and Dbpedia (Olieman et al., 2014). Wikify (Mihalcea and Csomai, 2007) is the very early work on linking anchor texts to Wikipedia pages. It extracts all ngrams that match Wikipedia concepts such as anchors and titles as candidates. They implement a voting scheme based on the knowledge-based and data-driven method to disambiguate candidates. Cucerzan (2007) uses four recourses to generate candidates, namely entity pages, redirecting pages, disambiguation pages, and list pages. Then they disambiguate candidates by calculating the similarity between the contextual information and the document as well as category tags on Wikipedia pages. Milne and Witten (2008) generate candidates by gathering all n-grams in the document, and retaining those whose probability exceeds a low threshold.", "startOffset": 54, "endOffset": 767}, {"referenceID": 8, "context": "TagME (Ferragina and Scaiella, 2010) is a very early work on entity linking in queries.", "startOffset": 6, "endOffset": 36}, {"referenceID": 8, "context": "TagME (Ferragina and Scaiella, 2010) is a very early work on entity linking in queries. It generates candidates by searching Wikipedia page titles, anchors and redirects. Then disambiguation exploits the structure of the Wikipedia graph, according to a voting scheme based on a relatedness measure inspired by Milne and Witten (2008). The improved version of TagME, named WAT (Piccinno and Ferragina, 2014), uses Jaccard-similarity between two pages\u2019 in-links as a measure of relatedness and uses PageRank to rank the candidate entities.", "startOffset": 7, "endOffset": 334}, {"referenceID": 0, "context": "Unlike the work which revolves around ranking entities for query spans, the Entity Recognition and Disambiguation (ERD) Challenge (Carmel et al., 2014) views entity linking in queries as the problem of finding multiple query interpretations.", "startOffset": 130, "endOffset": 151}, {"referenceID": 3, "context": "The SMAPH system (Cornolti et al., 2014) which wins the short-text track works in three phases: fetching, candidate-entity generation and pruning.", "startOffset": 17, "endOffset": 40}, {"referenceID": 2, "context": "They further extend SMAPH-1 to SMAPH-2 (Cornolti et al., 2016).", "startOffset": 39, "endOffset": 62}, {"referenceID": 8, "context": "ing anchor text a occurs in the query as a candidate, which has been used in previous work (Ferragina and Scaiella, 2010).", "startOffset": 91, "endOffset": 121}, {"referenceID": 7, "context": "We use LIBLINEAR (Fan et al., 2008) with L2-regularized L2loss support vector regression to train the regression model.", "startOffset": 17, "endOffset": 35}, {"referenceID": 8, "context": "Moreover, inspired by TagME (Ferragina and Scaiella, 2010), we denote freq(a) as the number of times the text a occurs in Wikipedia.", "startOffset": 28, "endOffset": 58}, {"referenceID": 0, "context": "ERD143 is a benchmark dataset in the ERD Challenge (Carmel et al., 2014), which contains both", "startOffset": 51, "endOffset": 72}, {"referenceID": 2, "context": "GERDAQ4 is a benchmark dataset to annotate entities to Wikipedia built by Cornolti et al. (2016). It contains 500 queries for training, 250 for development, and 250 for test.", "startOffset": 74, "endOffset": 97}, {"referenceID": 0, "context": "We use average F1 designed by ERD Challenge (Carmel et al., 2014) as the evaluation metrics.", "startOffset": 44, "endOffset": 65}, {"referenceID": 2, "context": "We compare with several baselines and use the results reported by the ERD organizer and Cornolti et al. (2016).", "startOffset": 88, "endOffset": 111}, {"referenceID": 8, "context": "WAT (Piccinno and Ferragina, 2014) is the improved version of TagME (Ferragina and Scaiella, 2010).", "startOffset": 68, "endOffset": 98}, {"referenceID": 6, "context": "Seznam (Eckhardt et al., 2014) uses Wikipedia and DBpedia to generate candidates.", "startOffset": 7, "endOffset": 30}, {"referenceID": 1, "context": "NTUNLP (Chiu et al., 2014) searches the query to match Freebase surface forms.", "startOffset": 7, "endOffset": 26}, {"referenceID": 3, "context": "SMAPH-1 (Cornolti et al., 2014) is the winner in the short-text track in the ERD14 Challenge.", "startOffset": 8, "endOffset": 31}, {"referenceID": 2, "context": "SMAPH-2 (Cornolti et al., 2016) is the improved version of SMAPH-1.", "startOffset": 8, "endOffset": 31}, {"referenceID": 1, "context": "We select AIDA as a representative system aiming to entity linking for documents following the work in Cornolti et al. (2016). WAT (Piccinno and Ferragina, 2014) is the improved version of TagME (Ferragina and Scaiella, 2010).", "startOffset": 103, "endOffset": 126}, {"referenceID": 0, "context": "(2016) and reported by the ERD organizer (Carmel et al., 2014).", "startOffset": 41, "endOffset": 62}, {"referenceID": 1, "context": "Results of the baseline systems are taken from Table 8 in Cornolti et al. (2016) and reported by the ERD organizer (Carmel et al.", "startOffset": 58, "endOffset": 81}, {"referenceID": 2, "context": "Results of the baseline systems are taken from Table 10 in Cornolti et al. (2016).", "startOffset": 59, "endOffset": 82}, {"referenceID": 6, "context": "Unlike the work on entity linking for documents (Eckhardt et al., 2014; Witten and Milne, 2008) that features derived from entity relations get promising results, Figure 2: F1 scores with different search numbers and thresholds on the ERD development set", "startOffset": 48, "endOffset": 95}], "year": 2017, "abstractText": "We present a simple yet effective approach for linking entities in queries. The key idea is to search sentences similar to a query from Wikipedia articles and directly use the human-annotated entities in the similar sentences as candidate entities for the query. Then, we employ a rich set of features, such as link-probability, contextmatching, word embeddings, and relatedness among candidate entities as well as their related entities, to rank the candidates under a regression based framework. The advantages of our approach lie in two aspects, which contribute to the ranking process and final linking result. First, it can greatly reduce the number of candidate entities by filtering out irrelevant entities with the words in the query. Second, we can obtain the query sensitive prior probability in addition to the static linkprobability derived from all Wikipedia articles. We conduct experiments on two benchmark datasets on entity linking for queries, namely the ERD14 dataset and the GERDAQ dataset. Experimental results show that our method outperforms state-of-the-art systems and yields 75.0% in F1 on the ERD14 dataset and 56.9% on the GERDAQ dataset.", "creator": "LaTeX with hyperref package"}}}