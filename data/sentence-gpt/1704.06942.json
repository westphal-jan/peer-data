{"id": "1704.06942", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Apr-2017", "title": "Population Seeding Techniques for Rolling Horizon Evolution in General Video Game Playing", "abstract": "While Monte Carlo Tree Search and closely related methods have dominated General Video Game Playing, recent research has demonstrated the promise of Rolling Horizon Evolutionary Algorithms as an interesting alternative. However, there is little attention paid to population initialization techniques in the setting of general real-time video games. Therefore, this paper proposes the use of population seeding to improve the performance of Rolling Horizon Evolution and presents the results of two methods, One Step Look Ahead and Monte Carlo Tree Search, tested on 20 games of the General Video Game AI corpus with multiple evolution parameter values (population size and individual length). An in-depth analysis is carried out between the results of the seeding methods and the vanilla Rolling Horizon Evolution. In addition, the paper presents a comparison to a Monte Carlo Tree Search algorithm. The results are promising, with seeding able to boost performance significantly over baseline evolution and even match the high level of play obtained by the Monte Carlo Tree Search.\n\n\n\nResults of a Monte Carlo Tree Search algorithm were analyzed using the Monte Carlo Tree Search algorithm, which was implemented in 2012 as a baseline evolution optimization. In the simulations, the results are significant, as a Monte Carlo Tree Search algorithm with large population size and single set of parameters (population size and single set of parameters). The Monte Carlo Tree Search algorithm also features two different possible paths: A general model that uses this algorithm in order to perform the optimization in order to improve the performance of the original game. The Monte Carlo Tree Search algorithm used in this study is optimized for one main challenge: The simulation is used for many game modes, and is suitable for a single game mode. A Monte Carlo Tree Search algorithm using a Monte Carlo Tree Search algorithm is designed to avoid the possible risk of being unimplemented by a large number of players. Using the Monte Carlo Tree Search algorithm, the results are statistically significant, and are based on real-time machine learning models using a Monte Carlo Tree Search algorithm. This study is supported by the NERC-S-A-C (R&D).\nResults of the Monte Carlo Tree Search algorithm are consistent with previous research by some authors. However, there is a clear problem in the research: The results were not used to produce real-time simulations in the simulation. The Monte Carlo Tree Search algorithm uses the Monte Carlo Tree Search algorithm, which has a unique approach for optimization.\nIn the paper, Monte Carlo Tree Search algorithm uses several strategies in general to perform the optimization in order to improve the performance of the original game. The Monte Carlo Tree Search", "histories": [["v1", "Sun, 23 Apr 2017 15:53:29 GMT  (871kb,D)", "http://arxiv.org/abs/1704.06942v1", "Proceedings of the IEEE Conference on Evolutionary Computation 2017"]], "COMMENTS": "Proceedings of the IEEE Conference on Evolutionary Computation 2017", "reviews": [], "SUBJECTS": "cs.AI cs.NE", "authors": ["rauca d gaina", "simon m lucas", "diego perez-liebana"], "accepted": false, "id": "1704.06942"}, "pdf": {"name": "1704.06942.pdf", "metadata": {"source": "CRF", "title": "Population Seeding Techniques for Rolling Horizon Evolution in General Video Game Playing", "authors": ["Raluca D. Gaina", "Simon M. Lucas"], "emails": ["rdgain@essex.ac.uk", "sml@essex.ac.uk", "dperez@essex.ac.uk"], "sections": [{"heading": null, "text": "I. INTRODUCTION\nRecent literature features General Video Game Playing (GVGP) more and more, with various researchers using different Game AI frameworks for benchmarking general AI agents [1][2][3]. The authors all seem to be in agreement that, although this is a great challenge, its importance is undeniable, exceeding video games.\nGVGP is an area focused on developing Artificial Intelligence agents able to achieve a high performance in any previously unknown environment, therefore striving towards General Artificial Intelligence through video games. Games make an excellent domain for testing AI techniques, due to their varying complexity and wide range of problems presented. Additionally, experiments can easily be run multiple times in a constrained scenario, with minimal costs in case of errors and fast feedback, a stark contrast to other areas such as robotics.\nThis study is carried out using the General Video Game AI [4] corpus of games, which provides a large collection of interesting and diverse real-time challenges. The GVGAI competition1 has been running for 3 years now and it has increased its coverage in 2016 through a Two Player Planning Track [5] and a Level Generation Track [6]. There are several other types of problems in development, such as a Learning\n1www.gvgai.net\nTrack (which strips the agents of the Forward Model), ScreenCapture Learning or Rule Generation.\nAs AI achieves super-human performance in even the most complex of individual games, the more general approach of GVGAI will become increasingly attractive. In 2016, AI became super-human at Go [7], and this is speculation on our part, but we believe StarCraft is likely to be dominated by AI within the next few years.\nThe experiment described in this paper attempts to improve upon a basic Rolling Horizon Evolutionary Algorithm (RHEA) and obtain better performance when tested on a subset of 20 games of the GVGAI corpus. The proposed technique is focused on generating a better than random initial population from which to start the evolution process i.e. by seeding the population. Two different methods are used to this end, a One Step Look Ahead algorithm and Monte Carlo Tree Search, their performance analyzed on multiple RHEA parameter configurations (varying population sizes and individual lengths).\nThe rest of this document follows a typical structure. Section II gives an overview of literature in this domain. Section III covers the basic background information necessary on the framework and algorithms used in this study. Section IV reviews the experimental approach and setup. Section V reports the results obtained and offers a detailed analysis. Finally, Section VI wraps up the paper by drawing conclusions and identifying future work."}, {"heading": "II. RELEVANT RESEARCH", "text": "Evolutionary Algorithms (EAs) provide a simple, robust and generally applicable approach for searching a wide variety of spaces, and have been the subject of intensive research for more than five decades. In terms of their application to Game AI, much of the effort has been focused on evolving AI agents, or on evolving game content (such as level design) [8] [9], game rules or game parameters. Recently, it was shown that Evolutionary Algorithms could be applied as any-time and real-time decision making algorithms for use in Game AI, adopting a similar simulation-driven approach to Monte Carlo Tree Search, while being simpler to implement and offering competitive performance [10]. This was initially done for oneplayer games, but was extended to 2-player games in the form of Rolling Horizon Co-Evolution [11].\n978-1-5090-4601-0/17/$31.00 c\u00a92017 IEEE\nar X\niv :1\n70 4.\n06 94\n2v 1\n[ cs\n.A I]\n2 3\nA pr\n2 01\n7\nVarious enhancements of EAs have been considered, including hybridization. One example is the usage of evolution integrated into the Monte Carlo Tree Search simulation step [12] or in the roll-out phase to evolve a better policy [13]. Recently, work has moved to incorporate tree structures or Upper Confidence Bounds (UCB) into the evolution instead for a guided and more informed process [14].\nOne thing that all Evolutionary Algorithms have in common, regardless of any additional features or the actual evolutionary techniques used, is the initialization of the population. There have been several attempts at exploring this particular improvement. Kazimipour et al. [15] review all the various methods present in literature and categorize them according to various factors: randomness, compositionality and generality. They identified several techniques which would work in a general environment; however, they suggest that these methods are computationally expensive, therefore not translating well to real time games, for example, which is the domain this paper focuses on.\nIn addition, Kim et al. [16] analyze the effects of initializing an EA population using an optimal solution determined by a Temporal Difference Learning algorithm in the game Othello. This addition appears to lead to a significant improvement in performance and future work in the area is encouraged.\nThe issue with initializing the population with pseudorandom numbers is raised by Maaranen et al. [17], who instead propose a quasi-random sequence method meant to obtain more evenly distributed points in a multi-individual population, in order to better explore the search space. This technique is applied to a genetic algorithm and it is tested on 52 global optimization problems. Their results are promising, suggesting a higher level of performance over the traditional initialization method.\nWhen it comes to General Video Game Playing, Monte Carlo Tree Search (MCTS) methods have dominated so far and their variations have been explored in various works, as depicted in a survey by Browne et al. [18]. In the General Video Game AI competition, Open-Loop MCTS emerged as the most powerful method out of the sample controllers provided, standing at the base of multiple participant algorithms and even the winner of the first edition of the competition (ran in 2014), Adrien Coue\u0308toux [4].\nHowever, the Arcade Learning Environment (ALE) [19], still in use by companies such as Google DeepMind [20], was one of the first frameworks to allow testing of general agents on video games, presenting the agents with the game through screen capture and requiring an in-game action at every step. Unlike GVGAI, there are limitations to ALE games definition. While the performance achieved by Mnih et al [20] using Deep Q-Networks (DQN) applied to the ALE environment was impressive, their main goal was to show what could be achieved just be learning to act given the screen capture of the game and a reward function, a process that involves a lengthy training period.\nOur interest in the current paper is in methods which can exploit the Forward Model (FM) of the game to achieve\nintelligent behaviour instantly. Rolling Horizon Evolutionary Algorithms (RHEA) show great promise in this respect. The Forward Model is a game simulator which can be used to rapidly test the consequences of taking a series of actions, given the current game state. As mentioned above, Perez et al. [10] tested RHEA techniques on the Physical Salesman Traveling Problem and their results were competitive with MCTS, encouraging research in the area."}, {"heading": "III. BACKGROUND", "text": ""}, {"heading": "A. General Video Game AI", "text": "GVGAI aims to provide a framework for benchmarking general Artificial Intelligent agents. It currently offers 140 games in total, 100 of which are single player and 40 twoplayer, some of which stochastic and all real-time. The study in this paper is focused on the single player framework. The games are played by the agents in black box mode, without any knowledge of the rules (e.g. different scoring systems, conditions for ending the game or types of objects in the game - NPCs, portals, resources), but being able to query the current game state for information on game objects.\nIn addition, future possible states may be simulated using a Forward Model (FM), which requires an action the agent would wish to perform and returns the game state resulting from that action. However, it is worth noting that any states returned by the FM may not be an accurate representation of the real game due to stochasticity.\nThe agents have only 40ms to make decisions regarding which action to play in the next game tick, except for the initialization step at the start of a game, where they receive 1s thinking time. A legal action must be provided at the end of the allocated budget, which may vary in the games between movement or special actions (such as shooting)."}, {"heading": "B. Evolutionary Algorithms", "text": "The algorithms used in this study are based on the Rolling Horizon Evolutionary Algorithm (RHEA) [10], which encode individuals as sequences of actions. The term \u201cRolling Horizon\u201d refers to the fact that the first action of the plan evolved is executed in one game step, then the plan is reevaluated and adjusted, looking one step further into the future, thus slowly expanding the \u201chorizon\u201d. Each individual in the EA is evaluated in a similar manner: the actions are simulated with the use of a Forward Model (FM) following the sequence; the value associated with the state reached at the end (approximated by a heuristic function) is used as the fitness value of the individual.\nRHEA\u2019s evolution process consists of several iterations (dictated by a fixed number, or a time or memory budget, for example) beginning with population initialization. Subsequently, mutation, tournaments, crossover and other evolutionary methods are used to change individuals and produce new ones. The offspring are evaluated through the steps described above and assigned a fitness value, which leads to the decision of keeping or discarding it in order to move to the next generation with the best individuals found so far. At the end\nof the process, the algorithm returns the first gene of the best individual in the final population as the action to be played in the game. The evolution is then repeated in the next game tick in the new game state received."}, {"heading": "C. Monte Carlo Tree Search", "text": "Monte Carlo Tree Search (MCTS) is a search-based technique which consists of four steps, iterated over repeatedly until a pre-defined budget is reached (a number of iterations, memory or time, for example). The action returned at the end of the process is the child of the root node considered the best by a recommendation policy (e.g. the most visited child).\nIn the first step in the process, MCTS selects a non-terminal and not yet fully expanded leaf of the tree via a tree policy. Secondly, a child of the selected node is added to the tree. Thirdly, it simulates ahead, using the new child as the root of a Monte Carlo simulation, with the help of the FM provided by the system. And finally, a heuristic is used to evaluate the state reached at the end of the simulation step and all of the parents of the selected node, up to the root of the tree, are updated with this value.\nThe algorithm used in this paper implements an Open Loop variant of this technique, concretely the sample controller from the GVGAI competition. Open Loop means that only statistics and not the actual game states are stored in the nodes of the tree, the FM being used when traversing the tree to simulate the game states. More details of Monte Carlo Tree Search, together with its variations and applications can be found in [18]."}, {"heading": "IV. APPROACH AND EXPERIMENTAL SETUP", "text": "The aim of this paper is to explore whether initializing the population of an Evolutionary Algorithm with individuals better than random produces an improvement in performance when applied to General Video Game Playing.\nThis hypothesis was tested by using 2 different initialization techniques to design variants of the vanilla RHEA, the baseline algorithm in this study, A-Vanilla. Algorithm B-1SLA-S is a seeding variant which employs a One Step Look Ahead technique to select a better starting point in the search space. Algorithm C-MCTS-S uses Monte Carlo Tree Search to seed the RHEA for better analysis of the search space. A fourth algorithm\u2019s performance was compared against the RHEA variants, an Open Loop Monte Carlo Tree Search (algorithm D-MCTS), in the simple implementation of the GVGAI competition sample controller.\nThe effect of the initialization techniques was tested on different configurations of the RHEA algorithm, with population sizes (P ) and individual lengths (L) in the subsequent ranges: P = {1, 2, 5, 10, 15, 20}, L = {6, 8, 10, 14, 16, 20}, following the diagonal of the matrix these values would form. In the case of algorithm D-MCTS, its roll-out depth was kept the same as RHEA individual length in order to make the approaches comparable. The largest value tested was 20 due to the fact that, by allowing half of the budget for MCTS computation in algorithm C-MCTS-S, higher values for population size and\nindividual length would result in the algorithm not being able to evaluate even 1 whole population in the initialization step."}, {"heading": "A. Games", "text": "All of the algorithms were tested on the same subset of 20 single-player games of the current GVGAI corpus. As the aim was to observe performance in different game types, two classifications were used in order to determine a set of games fit for this experiment. Mark Nelson presented a large scale analysis of a basic Monte Carlo Tree Search algorithm in 62 games, which were sorted based on the performance of this algorithm [21]. Bontrager et al. used clustering techniques on 49 GVGAI games [22] based on various features to obtain rough groups of similar games. The 20 games selected for this experiment were uniformly sampled from both works for a balanced set of 10 stochastic and 10 deterministic games (see Table I for indices, names and types of these games, as used in the rest of this paper).\nIn order to account for the stochastic aspect of the algorithms used in this study, as well as half of the games included in the set, each algorithm was run 100 times on each game (20 times on each of the 5 levels available). The budget offered for decision-making in each game tick was 900 FM calls, which is the average number of FM calls that A-Vanilla achieves in the 40ms of computational time in the complete 100 games in the GVGAI-1P corpus. The choice of using FM calls instead of CPU time was made in order to ensure that variations on the machine used for running the experiments would not impact the results, together with the fact that simulating the game ticks is the most expensive part of each algorithm under test.\nB. Vanilla RHEA (Algorithm A-Vanilla)\nThe algorithm described in this subsection is the baseline used in the study and follows the same technique described in [23]. It employs a pseudo-random initialization of the population, each gene in the individuals taking on an integer value returned by an RNG (Random Number Generator). Each value is between 0 and N \u2212 1 inclusive, where N is the maximum number of legal actions which can be performed from the current game state, therefore the integers mapping to an in-game action.\nThe evolutionary process continues slightly differently depending on the size of the population. When there is only 1 individual considered, a new one is mutated at each generation and the individual with the highest fitness value is carried forward to the next iteration. Uniform crossover is introduced for population sizes of 2 or more and a tournament with size 2 is used to select the parents of the resulting offspring in the cases where populations contain 3 or more individuals. The mutation operator is random, the 1 gene of the individual selected being changed to a different possible value, chosen uniformly at random.\nThe fitness function consists of a simple heuristic, returning the current game score of the state reached after advancing the Forward Model through all the actions in the individual (or until the end of the game). If an end-game state was reached and it resulted in a loss or a win for the player, the value returned is instead either a large penalty or a large reward, respectively."}, {"heading": "C. One Step Look Ahead Seeding (Algorithm B-1SLA-S)", "text": "The One Step Look Ahead (1SLA) algorithm is a simple technique which exhaustively searches through the actions available from the current state and associates each a Q value, corresponding to the approximated value of the game state reached after performing each action (the value is defined by the same heuristic employed by RHEA). It then selects for execution the action with the highest Q value.\nAlgorithm B-1SLA-S uses the same evolutionary process as A-Vanilla described above, but the first individual in the initial population is the solution recommended by the 1SLA technique. L iterations of the algorithm are performed, one for each gene in the individual: an exhaustive search is carried out through all of the actions available from the current state, the game state is advanced using the Forward Model, through the best action found and the process is repeated until either the end of the individual or the end of the game is reached. In the second case, the rest of the individual is padded with randomly selected actions.\nIf the population size is bigger than 1, the rest of the individuals are obtained by mutating the first individual obtained from the 1SLA algorithm. This method was thought to reduce random bias (the vanilla algorithm potentially not being able to find the current best action because of the random seeding) and to provide a better starting point for evolution."}, {"heading": "D. Monte Carlo Tree Search Seeding (Algorithm C-MCTS-S)", "text": "Algorithm C-MCTS-S splits the budget received and uses half of it to first run a Monte Carlo tree search on the current game state, following the steps described in Section III-C. The roll-out depth is set to the same value as the individual length in A-Vanilla and the UCB1 formula (with constant C taking the value \u221a 2) is applied as tree policy (see Equation 1).\na\u2217 = argmax a\u2208A(s)\n{ Q(s, a) + C \u221a lnN(s)\nN(s, a)\n} (1)\nThe first individual in the initial RHEA population is then seeded using the solution recommended by MCTS. Only the first K relevant nodes are selected, by traversing the tree through the most visited actions (the same method used by algorithm D-MCTS when selecting its final action to play). A node is relevant if it has been visited at least M = 3 times. The rest of the individual (if any genes have not received a value) is padded with randomly chosen legal actions."}, {"heading": "V. RESULTS AND DISCUSSION", "text": "The analysis in this section uses a two-tailed Mann-Whitney non-parametric U test to measure the statistical significance of the results for each game (p-value = 0.05), applied to two performance indicators: win rate and game score achieved.\nIn general, both seeding techniques improve the performance of the vanilla algorithm much more when the population size and individual length are small than when they increase. This is in line with the findings in the study performed by Gaina et. al [23], where Random Search (RS) emerged as the best algorithm in the limited budget offered. Therefore, the more the parameter values increase towards RS, the less the impact of the seeding can be observed.\nTable V presents an overall win rate comparison between the two seeding variants and vanilla RHEA, across all games and configurations. The bottom of the table sums up the number of games in which one algorithm was significantly better than the other two, leading to a total of unique games where a significant improvement was noticed, in all configurations tested. Table IV is a complete results example for the configuration P = 1, L = 6 (see Figure 1 for visualization), the rest of the tables being omitted due to space limitations."}, {"heading": "A. Overall Seeding Comparison", "text": "The general trend observed in this study is that the MCTS seeding variant performs significantly better than both algorithms A-Vanilla and B-1SLA-S in 8 unique games for win rate and 13 unique games for scores across all configurations, while being significantly worse than either of the other two in only 4 games for both win rate and score.\nIt is worth noting that there were a reduced number of games in which A-Vanilla or B-1SLA-S turned out to consistently be significantly better than C-MCTS-S: games with indices 36 and 91 (Escape and Wait for Breakfast, respectively) for both win rate and score and game with index 50 (Intersection) for score only. This is due to the poor performance of MCTS in these games, which is improved in the seeded algorithm over D-MCTS.\nIn addition, the MCTS seeding shows a steady improvement in several games. The win rates in the games with indices 0, 13 and 22 (Aliens, Butterflies and Chopper, respectively) see an increase to very close to 100% in all configurations. The biggest improvement is observed in game 22, where the AVanilla win rate for the smallest configuration (P = 1, L = 6) is only 26% to begin with (p 0.0001).\nThis leads to the conclusion that identifying the type of game being played and applying the correct algorithm seeding\nand parameters through a meta-heuristic would be highly beneficial to a general AI agent. However, there are also games such as 29 (Dig Dug), 58 (Lemmings) and 77 (Sea Quest) in which the win rate for all algorithms remains at 0%, these being particularly difficult games which require greater exploration that neither technique can provide."}, {"heading": "B. Pair-wise Seeding Comparison", "text": "Pair-wise significance comparison between algorithms AVanilla, B-1SLA-S and C-MCTS-S on all the configurations tested can be observed in Table II. The values represent the number of games (out of 20 total) in which one algorithm was significantly better than the other regarding victories, as well as scores, in brackets. The totals sum up the unique games in which one algorithm was significantly better than the other across all configurations (maximum of 20).\n1) A-Vanilla vs B-1SLA-S: The One Step Look Ahead seeding appears to produce the best results where the RHEA parameter values are very small (improvements in 6 games for win rate and 7 games for score), a change being, however, noticed halfway through the table where the seeding variant actually becomes significantly worse than the vanilla version in up to 5 games for win rate and 10 games for score. Overall, across all configurations tested, the 1SLA seeding appears to be worse than the baseline algorithm.\nA study of the complete matrix of small parameter values (P = {1, 2, 5}, L = {6, 8, 10}), where the difference in\nperformance is most observed, reveals that the variance in individual length and population size have different effects. On the one hand, increasing the size of the population results in a decrease in the number of games it is significantly better in when compared to A-Vanilla, which is due to the fact that the seeding variant explores the search space much less, with only one optimal solution mutated for all of its individuals. On the other hand, the performance is proportional to the individual length, suggesting that the directed search provided by 1SLA is more effective in cases with big L values compared to AVanilla\u2019s random sampling.\n2) A-Vanilla vs C-MCTS-S: With parameter values smaller than P = 10, L = 14, the MCTS seeding is significantly better than the vanilla version, the difference being most noticed, again, when the parameter values are small. The decrease in performance is thought to be caused by the roll-out depth of MCTS exceeding the optimal range (10\u221212). Across all configurations, MCTS seeding improves the baseline algorithm in 60% of the games for win rate and 80% for score.\nComparing the complete matrix of small parameter values shows that the population size has a much greater negative effect on the performance than the individual length. The lack of impact of the individual length can be explained by the proportional increase in the roll-out length of MCTS, therefore keeping results comparable. However, the decrease observed with population size increase suggests that the algorithm fails to explore the search space as well as RHEA, therefore balancing of other parameters should be considered.\nFor configuration P = 5, L = 10, there are two interesting games to look in depth at. In the game with index 77 (Sea Quest), C-MCTS-S increases the win rate of the baseline algorithm from 31% to 68% (p 0.0001) and the score from 1225.68 average points to 2485.43 (p 0.0001). Another big effect size is perceived in game 15 (Camel Race), in which, although the win rates remain small, there is an increase from 2% to 8% (p = 0.026). Both games benefit from the balanced exploration and exploitation provided by the MCTS solution which stands at the base of the evolutionary process.\n3) B-1SLA-S vs C-MCTS-S: When the two seeding techniques are compared, C-MCTS-S achieves a consistently better performance in 50% of the games for win rate and 65% for scores, whereas being consistently significantly worse in games with indices 36 and 91 (Escape and Wait for Breakfast, respectively) for both win rate and scores and game 50 (Intersection) for score. In game 22 (Chopper), B-1SLA-S with configuration P = 2, L = 8 achieves a 76% win rate, while C-MCTS-S increases it to 100% (p 0.0001). In addition, significant improvements with large effect sizes can also be noticed in games 60 (Missile Command, p = 0.016) and 84 (Survive Zombies, p = 0.033). However, in the game with index 36 (Escape), in which the MCTS algorithm cannot find a solution, the win rate drops from 30% for B-1SLA-S to 0% for C-MCTS-S (p 0.0001)."}, {"heading": "C. MCTS Comparison", "text": "Although the results indicate algorithm C-MCTS-S to be the best in this setting, an analysis against a pure Monte Carlo Tree Search technique was carried out to validate the findings. This comparison can be seen in Table III, in which the values show the number of games in which one algorithm was significantly better than both the others in win rate (and scores, in brackets), adding up to a total of unique games across all configurations.\nThe bottom line of Table III signifies the amount of games in which, although C-MCTS-S was not the best algorithm, the addition of MCTS seeding to RHEA made it in turn better than the baseline algorithm. This takes into account the cases where C-MCTS-S and D-MCTS were not significantly better than each other, but they still achieved a higher performance than A-Vanilla.\nWhile A-Vanilla consistently obtains significantly more victories and higher scores in its best games (indices 36, 91 and 50), it must be highlighted that the apparent low performance of C-MCTS-S is due to it not being significantly better than D-MCTS. For the direct comparison between C-MCTS-S and A-Vanilla, the reader is referred to Table II. In this case, the MCTS seeding variant shows improvement over a wider range of games, adding up to 50% games in which a larger win rate was observed and 75% games in which the score increased. The conclusion emerging is that MCTS seeding has a highly beneficial effect, especially in low RHEA parameter values, and further exploration of its advantages is encouraged."}, {"heading": "VI. CONCLUSION", "text": "This paper presented an experiment focused on observing how a better than random population initialization technique\naffects the performance of Rolling Horizon Evolutionary Algorithms (RHEA) in General Video Game Playing. Two different seeding techniques were used for testing. First, a One Step Look ahead method, which simply carries out an exhaustive search through all actions available and chooses the best one at each game step. Second, a Monte Carlo Tree Search (MCTS), which took half the budget to process the game from the current state and recommend a solution to serve as a starting point for the evolutionary process. Experiments were carried out in a balanced set of 20 games of the General Video Game AI framework and using various configurations of RHEA parameters (population size (P ) and individual length (L)).\nThe results suggest that both seeding variants offer a significant improvement in performance, considering both win rate and in-game score, in particular when the P and L values are small. However, as the parameter values increase, the benefit of seeding decreases, indicating that the unique solution offered by the initialization methods, which the evolution searches around, loses value compared to the wider search space at the disposal of Vanilla RHEA. A conclusion drawn from this is that the seeding directed evolution should be combined with better exploration of the game space in order to achieve optimal results. Nevertheless, as the aim of these algorithms is to attain a high level of play on all games, a positive result on a relatively small sample of games negates the null hypothesis and recommends deeper investigation.\nAn in-depth comparison between vanilla RHEA, the MCTS seeding algorithm and Open Loop Monte Carlo Tree Search was also performed. The findings of this study pinpoint the fact that, as the evolution parameters increase towards Random Search, so does the performance of RHEA compared to the tree search based methods in several games where the search space is too large for MCTS to traverse efficiently enough. Furthermore, the MCTS seeding does not produce worse results than simply MCTS. Therefore, this seeding technique is shown to have great promise in this environment.\nThe next steps will be focused on developing the algorithm\u2019s exploration of the game space, through further use of tree structures for hybridization, additional roll-outs and circular buffers. Moreover, a wider range of games will be used to ascertain that the difference in performance would indeed be significant in an even more general setting."}, {"heading": "ACKNOWLEDGMENT", "text": "This work was funded by the EPSRC Centre for Doctoral Training in Intelligent Games and Game Intelligence (IGGI) EP/L015846/1."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "While Monte Carlo Tree Search and closely related<lb>methods have dominated General Video Game Playing, recent<lb>research has demonstrated the promise of Rolling Horizon<lb>Evolutionary Algorithms as an interesting alternative. However,<lb>there is little attention paid to population initialization techniques<lb>in the setting of general real-time video games. Therefore, this<lb>paper proposes the use of population seeding to improve the<lb>performance of Rolling Horizon Evolution and presents the<lb>results of two methods, One Step Look Ahead and Monte Carlo<lb>Tree Search, tested on 20 games of the General Video Game<lb>AI corpus with multiple evolution parameter values (population<lb>size and individual length). An in-depth analysis is carried out<lb>between the results of the seeding methods and the vanilla<lb>Rolling Horizon Evolution. In addition, the paper presents a<lb>comparison to a Monte Carlo Tree Search algorithm. The<lb>results are promising, with seeding able to boost performance<lb>significantly over baseline evolution and even match the high<lb>level of play obtained by the Monte Carlo Tree Search.", "creator": "LaTeX with hyperref package"}}}