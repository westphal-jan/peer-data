{"id": "1705.00132", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Apr-2017", "title": "Online Learning with Expert Automata", "abstract": "We consider a general framework of online learning with expert advice where the regret is defined with respect to a competitor class defined by a weighted automaton over sequences of experts. Our framework covers several problems previously studied, in particular that of competing against k-shifting experts. We give a series of algorithms for this problem, including an automata-based algorithm extending weighted- majority and more efficient algorithms based on the notion of failure transitions. We further present efficient algorithms based on a compact approximation of the competitor automaton, in particular efficient n-gram models obtained by minimizing the Renyi divergence, and present an extensive study of the approximation properties of such models. We also extend our algorithms and results to the framework of sleeping experts. Finally, we describe the extension of our approximation methods to online convex optimization and a general mirror descent setting.", "histories": [["v1", "Sat, 29 Apr 2017 05:31:20 GMT  (238kb,D)", "http://arxiv.org/abs/1705.00132v1", null], ["v2", "Sat, 6 May 2017 18:05:25 GMT  (239kb,D)", "http://arxiv.org/abs/1705.00132v2", null], ["v3", "Sat, 13 May 2017 20:08:02 GMT  (239kb,D)", "http://arxiv.org/abs/1705.00132v3", null], ["v4", "Sun, 22 Oct 2017 05:24:43 GMT  (491kb,D)", "http://arxiv.org/abs/1705.00132v4", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["mehryar mohri", "scott yang"], "accepted": false, "id": "1705.00132"}, "pdf": {"name": "1705.00132.pdf", "metadata": {"source": "CRF", "title": "Online Learning against Expert Automata", "authors": ["Mehryar Mohri", "Scott Yang"], "emails": [], "sections": [{"heading": null, "text": "We give a series of algorithms for this problem, including an automata-based algorithm extending weightedmajority and more efficient algorithms based on the notion of failure transitions. We further present efficient algorithms based on a compact approximation of the competitor automaton, in particular efficient n-gram models obtained by minimizing the Re\u0301nyi divergence, and present an extensive study of the approximation properties of such models. We also extend our algorithms and results to the framework of sleeping experts. Finally, we describe the extension of our approximation methods to online convex optimization and a general mirror descent setting."}, {"heading": "1 Introduction", "text": "Online learning is a powerful and flexible model for sequential prediction. Online learning algorithms are typically computationally efficient and benefit from strong guarantees even when the learner has only limited information about her environment.\nWithin the online learning framework, the setting of prediction with expert advice has received widespread attention [Littlestone and Warmuth, 1994, Cesa-Bianchi and Lugosi, 2006, Cesa-Bianchi et al., 2007]. In this setting, the algorithm maintains a distribution over a set of experts, or selects an expert from an implicitly maintained distribution. At each round, the loss assigned to each expert is revealed. The algorithm incurs the expected loss over the experts and then updates her distribution on the set of experts. The objective of the learner is to minimize his expected regret, which is defined as the cumulative loss of the algorithm minus the cumulative loss of the best expert chosen in hindsight.\nHowever, this benchmark is only significant when the best expert is expected to perform well. When this is not the case, then the learner may still play poorly. As an example, it may be that no single baseball team has performed well over all seasons in the past few years. Instead, different teams may have dominated over different time periods. This has led to a definition of regret against the best sequence of experts with k shifts in the seminal work of Herbster and Warmuth [1998] on tracking the best expert. The authors showed that there exists an efficient on-line learning algorithm for this setting with favorable regret guarantees.\nThis work has subsequently been improved to account for broader expert classes [Gyorgy et al., 2012], to deal with unknown parameters [Monteleoni and Jaakkola, 2003], and has been further generalized [Cesa-Bianchi et al., 2012, Vovk, 1999]. Another approach for handling dynamic environments has consisted of designing algorithms that guarantee small regret over any subinterval during the course of play. This notion coined as adaptive regret by Hazan and Seshadhri [2009] has been subsequently strengthened and generalized [Daniely et al., 2015, Adamskiy et al., 2012]. Remarkably, it was shown by Adamskiy et al. [2012] that the algorithm designed by Herbster and Warmuth [1998] is also optimal for adaptive regret. Koolen and de Rooij [2013] described a Bayesian framework for online learning where the learner samples from a distribution of expert sequences and predicts according to the prediction of that expert sequence. They showed how the algorithms designed for k-shifting regret, e.g. [Herbster and Warmuth, 1998, Monteleoni and Jaakkola, 2003], can be interpreted as specific priors in this formulation. There has also been work deriving guarantees in the bandit setting when the losses are stochastic [Besbes et al., 2014, Wei et al., 2016]. \u2217Courant Institute and Google Research \u2020Courant Institute\nar X\niv :1\n70 5.\n00 13\n2v 1\n[ cs\n.L G\n] 2\n9 A\npr 2\n01 7\nThe general problem of online convex optimization in the presence of non-stationary environments has also been studied by many researchers. One perspective has been the design of algorithms that maintain a guarantee against sequences that do not vary too much [Mokhtari et al., 2016, Shahrampour and Jadbabaie, 2016, Jadbabaie et al., 2015, Besbes et al., 2015]. Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013]. Gyo\u0308rgy and Szepesva\u0301ri [2016] reinterpreted the framework of Hall and Willett [2013] to recover and extend the results of Herbster and Warmuth [1998].\nIn this paper, we significantly generalize the framework just described and consider prediction with expert advice in a setting where the learner\u2019s cumulative loss is compared against that of sequences represented by an arbitrary weighted family of sequences. We model this family using a weighted finite automaton (WFA). This strictly generalizes the notion of k-shifting regret and extends it to the notion of regret against a WFA.\nMeasuring regret against an automaton is both natural and flexible. In fact, it may often be sensible to learn the set of competitor sequences using data before competing against it. For instance, the competitor automaton could be a language model trained over best sequences of baseball teams in the past. Moreover, the competitor automaton could be learned and reset incrementally. After each epoch, we could choose to learn a new competitor model and seek to perform well against that.\nWe show that not only it is possible to achieve favorable regret against a WFA but that there exist computationally efficient algorithms to achieve that. We give a series of algorithms for this problem. Our first algorithm (Section 6) is an automata-based algorithm extending weighted-majority and using automata operations such as composition and shortest-distance; its computational cost is exponentially better than that of a na\u0131\u0308ve method.\nWe further present efficient algorithms based on a compact approximation of the competitor automaton (Section 7), in particular efficient n-gram models obtained by minimizing the Re\u0301nyi divergence, and present an extensive study of the approximation properties of such models. We also show how existing algorithms for minimizing k-shifting regret can be recovered by learning a Maximum-Likelihood bigram language model over the k-shifting competitor automaton. To the best of our knowledge, this is the first instance of recovering the algorithms of Herbster and Warmuth [1998] by way of solely focusing on minimizing the k-shifting regret. Since approximating the competitor automaton is subject to a trade-off between computational efficiency and approximation accuracy, we also design a model selection algorithm adapted to this problem.\nWe further improve that algorithm by using the notion of failure transitions (\u03d5-transitions) for a more compact and therefore more efficient automata representation. Here, we design a new algorithm (Section 9) that can convert any weighted finite automaton into a weighted finite automaton with \u03d5-transitions (\u03d5-WFA). We then extend the classical composition and shortest-distance algorithms for WFAs to the setting of \u03d5-WFAs. The shortest-distance algorithm is designed by extending the probability semiring structure of the \u03d5-WFA to that of a ring. We show that if the number of consecutive \u03d5-transitions is not too large, then these algorithms have a computational complexity that is comparable to those for standard WFAs. At the same time, our conversion algorithm can dramatically reduce the size of a WFA.\nWe then extend the results above to the sleeping expert setting [Freund et al., 1997], where the learner may not have access to advice from every expert at each round (Section 11). Finally, we extend the ideas for prediction with expert advice to online convex optimization and a general mirror descent setting (Section 12). Here, we describe a related framework that parallels the previous discussion and also recovers existing algorithms for k-shifting regret."}, {"heading": "2 Preliminaries", "text": "A weighted finite automaton (WFA) is a finite automaton whose transitions, initial, and final states additionally carry some weights. For our purpose, the weights belong to the probability semiring (R+ \u222a {+\u221e},+,\u00d7, 0, 1):1 we use multiplication to compute path weights by taking the product of the transition weights, and use addition to compute the weight of any string x by taking the sum of the weights of all accepted paths labeled with x. We assume that all automata are deterministic, so that for any state q and label a, there exists at most one transition leaving q labeled with a.\nFor a WFA A, we denote by QA its finite set of states, by IA \u2208 QA its initial states, by FA \u2286 QA its final states, and by EA its finite set of transitions, which are elements of QA \u00d7 \u03a3\u00d7 R+ \u00d7QA, where \u03a3 is a finite alphabet. We also denote by \u03bb : IA \u2192 R+ an initial weight function, and by \u03c1 : FA \u2192 R+ a final weight function. This allows us to define a WFA as a 7-tuple: A = (\u03a3, QA, IA, FA, EA, \u03bbA, \u03c1A).\n1For numerical stability, in practice, the computations should be performed in the log-semiring: (R \u222a {\u2212\u221e,+\u221e},\u2295log,+,+\u221e, 0), where \u2295log is defined by x\u2295log y = \u2212 log(e\u2212x + e\u2212y), which is isomorphic to the probability semiring under the mapping w 7\u2192 \u2212 log(w).\nGiven a transition e \u2208 EA, we denote by w[e] \u2208 R+ its weight. A path \u03c0 in A is an element of E\u2217A with consecutive transitions. We denote by src[\u03c0] the source or origin of the path and by dest[\u03c0] its destination. The weight of a path in A is defined to be the product of the weights of its constituent transitions, thus the weight of path \u03c0 = e1 . . . en is w[\u03c0] = \u220fn i=1 w[ei].\nFor any string x \u2208 \u03a3\u2217, let P (IA, x, FA) denote the set of paths accepted by A and labeled with x. A WFA A over an alphabet \u03a3 defines a function, which we abusively also denote by A, mapping a string x \u2208 \u03a3\u2217 to R+ \u222a {+\u221e} and defined as follows:\n\u2200x \u2208 \u03a3\u2217, A(x) = \u2211\n\u03c0\u2208P (IA,x,FA)\nw[\u03c0]\u03bbA(src[\u03c0])\u03c1A(dest[\u03c0]), (1)\nwhere, by convention, A(x) = 0 if P (IA, x, FA) = \u2205. Thus, A(x) is the sum of the weights of all paths accepted by A and labeled with string x, multiplied by the weight of the initial and final states. In the probability semiring, the order of the terms in the sum does not matter, and the quantity is well defined [Mohri, 2009]. The size of a WFA is denoted by |A| and defined as the sum of the number of states and the number of transitions of A: |A| = |QA|+ |EA|.\nFor any state q \u2208 Q, we use E[q] to denote the outgoing transitions of q, and more generally, E[Q\u2032] = \u222aq\u2208Q\u2032E[q] to denote the set of transitions leaving states in Q\u2032 \u2286 Q. Given a label a \u2208 \u03a3, we also denote by E[q, a] the set of outgoing transitions of q with label a, and by E[Q\u2032, a] the set of transitions leaving states in Q\u2032 with label a. Similarly, we let ER[q] denote the incoming transitions of q and define, ER[Q\u2032] = \u222aq\u2208Q\u2032ER[q], ER[q, a], and ER[Q\u2032, a] analogously.\nFor any state q \u2208 Q and any symbol a \u2208 \u03a3, we denote by \u03b4[q, a] the set of states reachable from q by reading label a. By overloading notation, this implies that \u03b4[q, a] = dest[E[q, a]]. We also define \u03b4[Q\u2032, a] = \u222aq\u2208Q\u2032\u03b4[q, a], \u03b4[q] = \u222aa\u2208\u03a3\u03b4[q, a] and \u03b4[Q\u2032] = \u222aq\u2208Q\u2032\u03b4[q]. Similar to E[\u00b7] and ER[\u00b7], we also denote by \u03b4R[q, a] the set of states with transitions labeled by a that lead into state q, along with \u03b4R[Q\u2032, a], \u03b4R[q], and \u03b4R[Q\u2032] by analogy.\nGiven any automaton A, we denote by AR its reversal, that is the automaton derived from A by reverting the direction of each transition and by swapping initial and final state sets. Thus, the strings accepted by AR are the mirror images of those accepted by A. Moreover, the corresponding paths share the same weight."}, {"heading": "3 Learning problem", "text": "We consider the setting of prediction with expert advice, which can be seen as a sequential game over T rounds. Let \u03a3 = {a1, a2, . . . , aN} be a set of N experts. At each round t, the learner specifies a probability distribution pt over the set of experts \u03a3, samples an expert it \u223c pt from the distribution, receives the loss vector lt \u2208 [0, 1]N , and incurs the specific loss lt[it]. The learner\u2019s goal is to minimize her regret, that is the difference between the cumulative expected loss of the learner\u2019s algorithm and the best loss corresponding to some benchmark competitor class. The standard benchmark in this setting is that of static experts, leading to the following notion of (expected) regret:\nRegT (A,\u03a3) = max a\u2208\u03a3 T\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[a]. (2)\nHowever, static experts may be too weak a benchmark in many settings where the data is potentially non-stationary and where no single expert is accurate or effective during all time segments of the game. Thus, instead, we consider the regret of the learner against a set of sequences of experts represented by an automaton. Specifically, let C be a weighted finite automaton (WFA) over the semiring (R+,+,\u00d7, 0, 1) with the alphabet \u03a3. C accepts a (potentially infinite) set of sequences of experts of arbitrary length. For instance, C may be the set of expert sequences that use each expert once, or the set of sequences that use at most two experts. Let ST be the weighted finite automaton that accepts all sequences of length T and assigns a weight of one to every transition. Specifically, we define QST = {t}t\u2208[0,T ], IST = {0}, FST = {T}, and EST = {(t\u2212 1, k, 1, t)}t\u2208[1,T ],k\u2208\u03a3. This automaton is illustrated in Figure 1. Notice that ST is acyclic.\nThen, CT = C \u2229 ST , where \u2229 denotes the intersection operation between automata, will define the set of expert sequences that our learning algorithm will compare against. Since CT accepts only a finite number of sequences, we can normalize the automaton CT so that the total weight over all expert sequences of length T is one. Let pCT be the probability distribution over sequences accepted by CT defined by: pCT (z T 1 ) =\nw(zT1 )\u2211 z\u0303T1 \u2208CT w(z\u0303T1 ) . We now define the\nweighted regret of algorithm A against automaton C up to time T as:\nRegT (A,C) = max zT1 \u2208CT T\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt]\u2212 log ( pCT (z T 1 )|CT | ) , (3)\nwhere |CT | is the number of paths accepted by CT . This notion of regret uses sequences in CT = C \u2229 ST as a benchmark, and penalizes the performance of an algorithm against different expert sequences based on the learner\u2019s prior characterization of the importance of each sequence. |CT | is a normalization factor added so that if the automaton\u2019s weight is uniform over all sequences, then the weighted regret is consistent with the standard notion of regret. To the best of our knowledge, previous work has not considered prediction with expert advice with a benchmark loss that differs over competitors.\nTo compare our work with previous results, we also define the unweighted regret of algorithm A against automaton C up to time T as:\nReg0T (A,C) = max zT1 \u2208CT T\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt]. (4)\nNote that the automaton C can still have arbitrary weights, although they play no role in this notion of regret. When C has uniform weights, then the unweighted regret and weighted regret are identical.\nNotice that if we associate with \u03a3 the automaton accepting constant sequences and with uniform weights over all sequences, then this definition of regret is consistent with the expression RegT (A,\u03a3) in equation 2.\nAs a running example, the k-shifting expert problem can be cast as the automaton Ck-shift with uniform weights given by Figure 2. Then, the (weighted or unweighted) regret of an algorithm A against Ck-shift coincides with the definition of k-shifting regret studied by Herbster and Warmuth [1998]:\nCk-shift =\n{ z \u2208 \u03a3\u2217 :\n\u221e\u2211 t=0 1zt+1 6=zt = k\n} ."}, {"heading": "4 Na\u0131\u0308ve algorithm", "text": "A well-known algorithm for minimizing static regret in the prediction with expert advice setting is the weighted majority algorithm [Littlestone and Warmuth, 1994]. The algorithm maintains a distribution over experts that is proportional to the exponential weight of the cumulative loss of the experts: pt[i] \u221d e\u2212\u03b7 \u2211t s=1 lt[i] for some \u03b7 > 0.\nWe can extend this idea to path experts and design an algorithm that minimizes the unweighted and weighted regret. Specifically, suppose we enumerate the paths accepted by CT by {\u03c0j}Kj=1. At each round t, each path chooses an expert \u03c0j,t \u2208 \u03a3, and can be attributed the loss lt[\u03c0j,t]. Thus, we can define a weight distribution over the experts using the formula: p\u0303t[j] \u221d e\u2212\u03b7 \u2211t s=1 ls[\u03c0j,s]. We can then convert this into a distribution over experts using the formula:\npt[i] \u221d \u2211K j=1 p\u0303t[j]1\u03c0j,t=i. We call this algorithm PATH-BASED WEIGHTED MAJORITY (PBWM). Its pseudocode is presented in Algorithm 1. The following guarantee holds for the regret of PBWM, which is proven in Appendix 14.\nTheorem 1 (Regret Bounds for Path-Based Weighted Majority). Let v\u03031,j = 1 for every j \u2208 [K] be the initial path weights in the PBWM algorithm. Then, the unweighted regret of PBWM is bounded as follows:\nReg0T (PBWM,C) \u2264 \u03b7T + 1\n\u03b7 log(|C \u2229 ST |).\nAlternatively, let v\u03031,j = w[\u03c0j ]\u03b7 for every j \u2208 [K] be the initial path weights in the PBWM algorithm. Then, the weighted regret of PBWM is bounded as follows:\nRegT (PBWM,C) \u2264 \u03b7T + 1\n\u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7|C \u2229 ST |\u03b7  . If we further assume that \u2211K j=1 w[\u03c0j ] = 1, then the weighted regret is bounded as follows:\nRegT (PBWM,C) \u2264 \u03b7T + 1\n\u03b7 log(|C \u2229 ST |).\nIf we additionally assume that w is supported on more than a single path (i.e. | supp(w)| > 1), then there exists \u03b7\u2217 > 0 (decreasing as a function of T ) such that:\nRegT (PBWM,C) \u2264 2 \u221a TH\u03b7\u2217(w)\u2212H\u03b7\u2217(w) + log(K).\nwhere H\u03b7(w) = 11\u2212\u03b7 log (\u2211K j=1 w[\u03c0j ] \u03b7 ) is the \u03b7-Re\u0301nyi entropy.\nFor the weighted regret, note that since the \u03b7-Re\u0301nyi entropy is non-negative and increasing in \u03b7 [Van Erven and Harremos, 2014], the latter bound is at most\n2 \u221a TH0(w) + log(K) = 2 \u221a T log(| supp(w)|) + log(K).\nMoreover, if T is sufficiently large such that \u03b7\u2217 < 1 (e.g. T \u2265 log(| supp(w)|), based on the proof of the theorem), and our path weights w are concentrated on only a subset of the paths A \u2282 [K] such that\u2211\nj\u2208AC w[\u03c0j ]\u2211 j\u2208A w[\u03c0j ] < (1\u2212 \u03b7\u2217),\nAlgorithm 1: PATH-BASED WEIGHTED MAJORITY(PBWM). Algorithm: PBWM(C \u2229 ST , v\u03031), where v\u03031 \u2208 RK+ is a vector of initial path weights. \u03c0 \u2190 C \u2229 ST K \u2190 |C \u2229 ST | N \u2190 |\u03a3| for j = 1 to K do\np\u03031,j \u2190 v\u03031,j\u2211K i=1 v\u03031,i\nfor j = 1 to N do p1,j \u2190 \u2211 i\u2208[1,K] : \u03c0i,1=j p\u03031,i for t = 1 to T do it \u2190SAMPLE(pt) PLAY(it) RECEIVE(lt) for j = 1 to K do\nv\u0303t+1,j \u2190 v\u0303t,je\u2212\u03b7lt[\u03c0j,t] p\u0303t+1,j \u2190 v\u0303t+1,j\u2211K i=1 v\u0303t+1,i\nfor j = 1 to N do pt+1,j \u2190 \u2211 i\u2208[1,K] : \u03c0i,t=j p\u0303t+1,i\nthen\nH\u2217\u03b7 (w) = 1\n1\u2212 \u03b7\u2217 log  K\u2211 j=1 w[\u03c0j ] \u03b7\u2217  = 1 1\u2212 \u03b7\u2217 log \u2211 j\u2208A w[\u03c0j ] \u03b7\u2217 + \u2211 j\u2208Ac w[\u03c0j ] \u03b7\u2217  \u2264 1\n1\u2212 \u03b7\u2217 log \u2211 j\u2208A w[\u03c0j ] \u03b7\u2217 + \u2211j\u2208Ac w[\u03c0j ]\u03b7\u2217\u2211 j\u2208A w[\u03c0j ] \u03b7\u2217  \u2264 1\n1\u2212 \u03b7\u2217 log \u2211 j\u2208A w[\u03c0j ] \u03b7\u2217 + \u2264 1 1\u2212 \u03b7\u2217 log(|A|) + .\nThus, the latter bound can be substantially tighter than the bound in terms of log(|C \u2229 ST |)."}, {"heading": "5 Automata operations", "text": "While PBWM achieves a sublinear regret bound for both the weighted and unweighted regret, it can be computationally prohibitive. This is because the update at each iteration requires a summation over the number of paths in the competitor set, which can be exponential in the number of total rounds T . For instance, the total number of k-shifting experts is O (( T\u22121 k ) N(N \u2212 1)k ) .\nTo design computationally efficient algorithms, we will exploit the properties of the competitor class automaton C. Note that any finite set of competitor paths can be represented by an automaton. But, different automata accepting the same set may lead to vastly different computational costs.\nOur algorithms make use of several common operations for weighted automata: composition, shortest-distance, and connection. In particular, we design an incremental version of the shortest-distance algorithm, which we call IncrementalShortestDistance (IncrSD)."}, {"heading": "5.1 Composition/intersection", "text": "Composition (or intersection) is an operation that combines two weighted automata into a new weighted automaton. The resulting automaton accepts the set of strings accepted by both input automata. The weight assigned to any string\nby the resulting composition is the product of the weights assigned by the input automata: A1 \u25e6A2(x) = A1(x)A2(x). A standard and efficient method for composing two weighted automata is to pair up matching transitions [Mohri, 2009]. States of A1 \u25e6A2 are identified with pairs of states of A1 and A2: Q \u2286 Q1 \u00d7Q2, as are the set of initial and final states. Transitions are obtained by matching pairs of transitions from each weighted automaton and multiplying their weights following the result:(\nq1 a/w1\u2212\u2192 q\u20321, q2 a/w2\u2212\u2192 q\u20322 ) \u21d2 (q1, q2) a/(w1w2)\u2212\u2192 (q\u20321, q\u20322).\nIn general, the space and time complexity of this composition is O(|A1||A2|), since in the worst case all transitions in A1 could be matched with transitions leaving A2. In our case, this would result in a complexity of O(|C||ST |) = O(|C|NT ). However, composition only actually constructs states and transitions that are reachable from the initial states I1 \u00d7 I2. More generally, for an efficient implementation (in terms of data structure), the complexity is linear in the size of the output (disregarding data structure preprocessing).\nNow consider the incremental cost of creating states corresponding to q = (\u00b7, t+ 1) and the transitions reaching these states given that all states q = (\u00b7, s) with s \u2264 t and their incoming transitions have been already created. The maximum number of transitions in this step is bounded by the total number of states reachable at time t multiplied by the maximum out-degree of any of these states: |QC,t|maxq\u2208QC,t |E[q]|, where QC,t = {q \u2208 QC \u00d7QST : q = (\u00b7, t)}. Thus, the total computational complexity of the composition of C with ST is in O (\u2211T t=1 |QC,t|maxq\u2208QC,t |E[q]| ) , where |E[q]| \u2264 N and |QC,t| \u2264 |C|. In general, we can expect both quantities to be much smaller."}, {"heading": "5.2 Shortest-distance", "text": "The second operation that we need is a single-source \u2018shortest-distance\u2019 computation over the semiring (R+ \u222a {+\u221e},+,\u00d7, 0, 1), that is, we wish to compute for any state q, \u03b1[q] defined by:\n\u03b1[q] = \u2211\n\u03c0\u2208P (IA,q)\nwA[\u03c0],\nwhere P (IA, q) is the set of paths from the initial states IA to q. For any acyclic automaton A, \u03b1 can be computed in linear time using a general relaxation-based shortest-distance algorithm with a topological queue discipline [Mohri, 2009]. \u03b1 can also be computed using other algorithms such as the Viterbi algorithm. In our context, this shortest-distance algorithm can be naturally modified to run in an incremental fashion and extended to the case of automata with failure transitions (Section 9). We provide the pseudocode of this subroutine as Algorithm 2, IncrementalShortestDistance (IncrSD). This will be a key ingredient for our computationally efficient learning algorithm."}, {"heading": "5.3 Connection", "text": "It is possible that some of the states created by composition will be non-accessible or non-coaccessible. A state q \u2208 Q is non-accessible if there is no path from I to q. A state q \u2208 Q is non-coaccessible if there is no path from q to F . Such states are called useless because they do not lie on accepting paths. Connection (or trimming) is a linear-time algorithm that removes these non-accessible states [Mohri, 2009]."}, {"heading": "6 Automata-based algorithm", "text": "We now have the tools to present Algorithm 3, AUTOMATAWEIGHTEDMAJORITY (AWM), an automata-based online learning algorithm. At the start of the algorithm, we compose the competitor class automaton C with ST . For computational efficiency, we apply a connection (or trimming) algorithm to prune useless states from the composed automaton. We then perform a shortest-distance computation backwards to compute \u03b2[q] the sum of the weights of all paths from q to the final states. At each time t, we use the current distribution pt to sample an expert it, receive the loss vector lt and incur loss lt[it]. We update the weights of the edges in C \u2229 ST whose destination states have form (\u00b7, t) using these losses.\nWe then compute the flow of each edge e, flow[e], that is the sum of the weights of all paths that pass through e. In the semiring (R+,+,\u00d7, 0, 1) that we operate in, this flow can be computed as the product of three components:\nAlgorithm 2: INCREMENTALSHORTESTDISTANCE(IncrSD). Algorithm: INCRSD(C \u2229 ST , t, \u03b1) CT \u2190 C \u2229 ST for each q \u2208 QCT with q = (\u00b7, t) do\n\u03b1[q]\u2190 r[q]\u2190 0 if t = 1 then\nfor each q \u2208 ICT do \u03b1[q]\u2190 r[q]\u2190 1\nQ \u2190 ICT . else Q \u2190 {q \u2208 QCT : q = (\u00b7, t\u2212 1)} while Q 6= \u2205 do q \u2190 HEAD(Q) DEQUEUE(Q) r\u0303 \u2190 r[q] r[q]\u2190 0 for each e \u2208 ECT [q] do\nif \u03b1[dest[e]] 6= \u03b1[dest[e]] + (r\u0303w[e]) then \u03b1[dest[e]]\u2190 \u03b1[dest[e]] + (r\u0303w[e]) r[dest[e]]\u2190 r[dest[e]] + (r\u0303w[e]) if dest[e] /\u2208 Q then\nENQUEUE(Q,dest[e]) return \u03b1\nthe shortest-distance from the initial state to the source of e, \u03b1[src[e]], the weight of edge e, w[e], and the shortest distance from the destination state of e to the set of final states in C \u2229 ST , \u03b2[dest[e]]. We then aggregate these flows by label (i.e. experts) and normalize them to get a distribution over the set of experts. Finally, since the weights of the transitions leading to states (\u00b7, t) have been modified, we update the shortest distances to their destination states using our incremental shortest-distance algorithm. The computational cost of this algorithm is linear in the number of these transitions. Note that other shortest-distances need not be modified.\nTheorem 2 guarantees that AWM performs the same update as PBWM and quantifies its computational cost.\nTheorem 2 (AUTOMATAWEIGHTEDMAJORITY Guarantee). The update made by AWM, pt+1 at round t, coincides with the update made by PBWM for unweighted regret when run with a normalized input C \u2229 ST . Moreover, the computational complexity of AWM at each round t is O ( |E[QCT ,t]| ) and the total computational cost is\nO (\u2211T t=1 |E[QCT ,t]| ) .\nIf, after normalization, we multiplied the weight of every edge by \u03b7, then we would also recover the update as in PBWM for weighted regret.\nProof. If C \u2229 ST is normalized as input to PBWM, then it coincides with the result of the normalization of wCT at the start of AWM. At any time t \u2208 [T ], Flowt[ai] is maintained as \u2211 e : dest[e]=(\u00b7,t),\u03c3[e]=ai flow(e) that is the sum of the weights of all paths taking action ai \u2208 \u03a3 at time t. The weight of path \u03c0 = e1e2 . . . eT is then:\nw[\u03c0] t\u220f s=1 e\u2212\u03b7ls[\u03c3[es]] = w[\u03c0]e\u2212\u03b7 \u2211t s=1 ls[\u03c3[es]] = v\u0303t+1,j .\nAt the start of the algorithm, the normalization and shortest-distance computations take timeO (\u2211T t=1 |E[QCT ,t]| )\n. Computing the initial probability p1 takes time O(|Q1|). From time t = 1 to T , the loss update, flow computation, and flow normalization each take time O(|Qt|), and the incremental shortest-distance update takes time O (|E[QCT ,t]|). Thus, the per-iteration complexity is O (|E[QCT ,t]|), and the total computational complexity is O (\u2211T t=1 |E[QCT ,t]| ) .\nAlgorithm 3: AUTOMATAWEIGHTEDMAJORITY(AWM). Algorithm: AWM(C) CT \u2190 C \u2229 ST CT \u2190 CONNECT(CT ) \u03b2 \u2190 SHORTESTDISTANCE((CT )R, F ) wCT [ICT ]\u2190 wCT [ICT ]/\u03b2[ICT ] \u03b1\u2190 0 Flow0 \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, 1) do\nflow[e]\u2190 \u03b2[dest[e]] Flow0[\u03c3[e]]\u2190 Flow0[\u03c3[e]] + flow[e] Z0 \u2190 Z0 + flow[e]\np1 \u2190 Flow0/Z0 for t\u2190 1 to T do\nit \u2190SAMPLE(pt) PLAY(it) RECEIVE(lt) Flowt \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, t) do\nw[e]\u2190 w[e]e\u2212\u03b7lt,\u03c3[e] flow[e]\u2190 \u03b1[src[e]]w[e]\u03b2[dest[e]] Flowt[\u03c3[e]]\u2190 Flowt[\u03c3[e]] + flow[e] Zt \u2190 Zt + flow[e].\npt+1 \u2190 Flowt/Zt \u03b1\u2190 INCRSD(CT , t,\u03b1)\nNotice that the composition of the k-shifting experts competitor class with C given by Figure 2 results in Figure 3, so that the per-iteration complexity of AWM for the k-shifting automaton is O(N2k). This is substantially more efficient than the na\u0131\u0308ve update, which was O (( T\u22121 k ) N(N \u2212 1)k ) .\nIn general, the performance of AWM depends not only on the properties of the competitor class automaton but also on those of the resulting automaton after composition with ST . For instance, we could have also represented the k-shifting experts competitor class using the inefficient representation of Figure 3 (b), which would lead to a significantly higher per-iteration computational cost.\nIt should be noted that AWM can be seen as a generalization of the Expert Hidden Markov Model in [Koolen and de Rooij, 2013] to arbitrary losses. One major difference between their work and ours is the matter of framework and perspective. [Koolen and de Rooij, 2013] assume a Bayesian setting where the prior distribution over expert sequences is given and must be used. In our work, we assume the existence of a competitor automaton, but don\u2019t necessarily need to sample from it to make a prediction. This will be crucial in the next section, where we design and use other automata to improve computational efficiency while preserving regret performance."}, {"heading": "7 Approximation algorithms", "text": "The algorithm described in Sections 6 was based on exploiting the properties of the competitor class automaton C. AWM was exact in that it performed the same computations as the na\u0131\u0308ve algorithm, PBWM. If the resulting automaton after composition is still large, then the computational cost can still be prohibitive.\nIn this section, we take a different approach and no longer constrain ourselves to algorithms that perform precisely the same update as PBWM. Instead, we design algorithms to efficiently approximate the competitor set CT . An automaton that is compact and tightly approximates CT can lead to an algorithm that is efficient and achieves a favorable regret."}, {"heading": "7.1 The effect of automata approximation on regret", "text": "We first analyze the approximation cost of such an algorithm. For this, we will need to introduce the notion of\u221e-Re\u0301nyi divergence [Re\u0301nyi et al., 1961]. The\u221e-Re\u0301nyi divergence between two distributions p and q over some set X is defined to be\nD\u221e(p||q) = sup x\u2208X log\n[ p(x)\nq(x)\n] . (5)\nTheorem 3 (Automata approximation cost). Assume that CT is normalized so that \u2211 \u03c0\u2208CT wCT [\u03c0] = 1. If AWM is run with a weighted automaton C\u0302, then its unweighted regret is bounded as follows:\nReg0T (A,C) \u2264 max \u03c0\u2208CT\n\u03b7T + 1\n\u03b7 log\n( 1\nwCT [\u03c0]\n) + 1\n\u03b7 D\u221e(pCT ||pC\u0302T ),\nand its weighted regret is bounded as follows:\nRegT (A,C) \u2264 \u03b7T + 1\n\u03b7 log \u2211 \u03c0\u2208C\u0302T w C\u0302T [\u03c0]\u03b7|CT |\u03b7 +D\u221e(pCT ||pC\u0302T )\n\u2264 \u03b7T + 1 \u03b7 log(|CT |) + log ( |CT | |C\u0302T | ) .\nProof. The regret guarantee of AWM is based on the fact that it performs the same update as PBWM. By the proof of Theorem 1, the unweighted regret of the algorithm against \u03c0 \u2208 CT is bounded by:\nT\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt] \u2264 \u03b7T + 1 \u03b7 log\n( 1\nw C\u0302T [\u03c0]\n) .\nBy comparing the weight of the automaton used in the algorithm, C\u0302T , with the automaton used in the benchmark, CT , we obtain the bound:\nT\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt] \u2264 \u03b7T + 1 \u03b7 log ( 1 wCT [\u03c0] ) + 1 \u03b7 log ( wCT [\u03c0] w C\u0302T [\u03c0] ) .\nThis allows us to bound the unweighted regret by:\nReg0T (A,C) \u2264 max \u03c0\u2208CT\n\u03b7T + 1\n\u03b7 log\n( 1\nwCT [\u03c0]\n) + 1\n\u03b7 log\n( wCT [\u03c0]\nw C\u0302T [\u03c0]\n) .\nSimilarly, for any \u03c0 \u2208 CT , the weighted regret of the algorithm against \u03c0 is bounded by:\nT\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt]\u2212 log ( w C\u0302T (\u03c0)|CT | ) \u2264 \u03b7T + 1 \u03b7 log \u2211 \u03c0\u2208C\u0302T w C\u0302T [\u03c0]\u03b7|CT |\u03b7  ,\nso that\nT\u2211 t=1 pt \u00b7 lt \u2212 T\u2211 t=1 lt[zt]\u2212 log ( wCT (\u03c0)|CT | ) \u2264 \u03b7T + 1\n\u03b7 log \u2211 \u03c0\u2208C\u0302T w C\u0302T [\u03c0]\u03b7|CT |\u03b7 + log(wCT [\u03c0] w C\u0302T [\u03c0] ) .\nThis then implies that:\nRegT (A,C) \u2264 \u03b7T + 1\n\u03b7 log \u2211 \u03c0\u2208C\u0302T w C\u0302T [\u03c0]\u03b7|CT |\u03b7 + log( sup \u03c0\u2208CT wCT [\u03c0] w C\u0302T [\u03c0] ) .\nFurthermore, as in the proof of Theorem 1, we can further bound the above quantity by:\n\u03b7T + 1\n\u03b7 log \u2211 \u03c0\u2208C\u0302T |CT |\u03b7 |C\u0302T |\u03b7 + log( sup \u03c0\u2208CT wCT [\u03c0] w C\u0302T [\u03c0] ) .\nTheorem 3 quantifies the extra cost of using a surrogate automaton during learning as 1\u03b7D\u221e(pCT ||pC\u0302T ) for unweighted regret and as D\u221e(pCT ||pC\u0302T ) for weighted regret. This is tight, since it is always possible that the best path in hindsight in the regret definition may also be the one maximizing the log-ratio.\nThis suggests that using an approximate automaton C\u0302 for which the size of C\u0302T is favorable and D\u221e(wCT ||wC\u0302T ) is small would both lead to an efficient algorithm and a favorable regret guarantee.\nA consequence of this bound is a general algorithm. Given a family of automata C with a relatively small number of states and transitions, the algorithm can be formulated as solving the problem:\nmin C\u0302T\u2208C D\u221e(pCT ||pC\u0302T ). (6)\nWhen the set of distributions associated to C is convex, this is a convex optimization problem, since q 7\u2192 log(p/q) is a convex function and the supremum of convex functions is convex. The choice of the set C is subject to a trade-off: approximation accuracy versus computational efficiency of using elements in C. This raises a model selection question for which we discuss in detail a solution in Section 7.5: given a sequence of families (Cn)n\u2208N with growing complexity and computational cost, the problem consists of selecting the best n.\nFor general choices of C, this problem can be complex and relates to other standard automata learning problems [Pitt and Warmuth, 1993, Balle and Mohri, 2012, Hsu et al., 2012, Balle and Mohri, 2015]. In the following, we will consider the case where the family C of weighted automata is that of n-gram models, for which we can upper bound the computational complexity.\n7.2 n-gram models An n-gram language model is a Markovian model of order (n\u2212 1) defined over \u03a3\u2217. By the chain rule of probability, pA[x] = \u220fT t=1 pA[xt|x t\u22121 1 ]. For an n-gram model, conditioning is done only on a history of length (n \u2212 1), thus\npA[x] = \u220fT t=1 p[xt|x t\u22121 t\u2212n+1]. An n-gram model can be compactly represented by a weighted automaton with states Q = \u03a3n\u22121 encoding each possible history, and with one transition corresponding to each n-gram x1 \u00b7 \u00b7 \u00b7xn \u2208 \u03a3n from state xn\u221211 to state x n 2 and labeled with xn. The natural automata representation for n-gram models are stochastic\nautomata, where the weights of the outgoing transitions for any state are non-negative and sum up to one. Any probabilistic weighted automaton can be converted into a stochastic automaton using the weight-pushing algorithm [Mohri, 2009], which takes linear time and consists of a shortest-distance computation combined with a reweighting of the transition weights, initial weights, and final weights in a way that pushes the weights towards the initial states.\nEach state in an n-gram model encodes a particular history, so that for stochastic automata, the outgoing transition weights are the conditional probabilities given that history. Since these probabilities define an n-gram model, an n-gram model can be interpreted as a product of simplices.\nSee Figure 4 for an example of an n-gram language model. Language models of this form are commonly used in language and speech processing [Jelinek and Mercer, 1980, Katz, 1987, Ney et al., 1994, Chen and Goodman, 1998, Allauzen et al., 2003]. In these applications, the models are typically smoothed since they are trained on a finite sample. In our case, smoothing will not be needed since we can train directly on CT , which we interpret as the full language.\nOne key advantage of n-gram models in this context is that the per-iteration complexity can be bounded in terms of the number of symbols. Since an n-gram model has at most |\u03a3|n\u22121 states, its per-iteration computational cost is in O ( |\u03a3|n ) as each state can take one of |\u03a3| possible transitions. For n small, this can be very advantageous compared to the original CT , since the maximum out-degree of states reached by strings of length t in the latter may be very large. In what follows, we denote by Pn the family of n-gram language models. Since Pn can be written as the product of simplices, it is therefore a convex set. If we denote by pCT the target distribution of sequences, then we can apply well-known techniques to learn a language model over the language CT .\n7.3 Maximum likelihood n-gram models A standard method for learning n-gram models is via maximum likelihood, which is equivalent to minimizing the relatively entropy between the target distribution pCT and the language model. This is defined by the optimization problem:\nmin pAn\u2208Pn D(pCT ||pAn), (7)\nwhere, for any two distributions p and q, D(p||q) = \u2211 x p[x] log ( p[x] q[x] ) . Observe that, in general, the solution of this optimization problem is not guaranteed to provide an upper bound on the\u221e-Re\u0301nyi divergence since the\u221e-Re\u0301nyi divergence is an upper bound on the relative entropy2. However, as we shall see later (e.g., Theorem 4), in some cases, maximum likelihood solutions do benefit from favorable guarantees.\nMaximum likelihood n-gram solutions in particular are simple. For standard text, the weight of each transition is the frequency of appearance of the corresponding n-gram in the text. For a probabilistic CT , the weight can be similarly\n2The relative entropy also coincides with the 1-Re\u0301nyi divergence\nobtained from the expected count of the n-gram in the paths of CT , where the expectation is taken over the probability distribution defined by CT and can be computed efficiently [Allauzen et al., 2003].\nMaximum likelihood n-gram models can further benefit from \u03d5-conversion using the algorithms presented in Section 9. This can reduce the size of An and improve its computational efficiency without affecting its accuracy.\nAs an example, we can compute the bigram approximation to the k-shifting automaton. Remarkably, this will coincide with the FIXED-SHARE algorithm of Herbster and Warmuth [1998]. Thus, we can view and motivate the design of FIXED-SHARE as a bigram approximation of the desired competitor automaton, that is the family of k-shifting sequences.\nTheorem 4 (Bigram approximation of k-shifting automaton). Let CT be the k-shifting automaton for some k. Then, the bigram model A2 obtained using relative entropy satisfies:\npA2 [a1a2] = 1\nN\n( 1\u2212 k\n(T \u2212 1)\n) 1a1=a2 +\nk\n(T \u2212 1)(N \u2212 1)N 1a1 6=a2 .\nMoreover, the approximation error is bounded as follows:\nsup \u03c0\u2208CT log\n( pCT [\u03c0]\npA2 [\u03c0]\n) \u2264 \u2212 log ( 1\u2212 2e\u2212 112k ) .\nProof. Let a1, a2 \u2208 \u03a3. Then\npA2 [a2|a1] = pA2 [a2|a1, a2 = a1] pA2 [a2 = a1] + pA2 [a2|a1, a2 6= a1] pA2 [a2 6= a1]\nConsider first the case where a2 = a1. Then pA2 [a2|a1, a2 = a1] = 1, and pA2 [a2 = a1] is the expected number of times that we see label a2 agreeing with label a1. Since pCT is uniform for the k-shifting automaton, the expected counts are pure counts, and the probability that we see two consecutive labels agreeing is 1 \u2212 kT\u22121 . Now, consider the case where a2 6= a1. By symmetry, pA2 [a2|a1, a2 6= a1] = 1N\u22121 , since a2 is equally likely to be any of the other N \u2212 1 labels. Moreover, pA2 [a2 6= a1] = kT\u22121 .\nThus, the following holds:\npA2 [a2|a1] = 1 N \u2212 1 k T \u2212 1 1a1 6=a2 +\n( 1\u2212 k\nT \u2212 1\n) 1a1=a2 .\nMoreover, by symmetry, we can write pA2 [a1] = 1 N , and therefore,\npA2 [a1a2] = pA2 [a2|a1]pA2 [a1] = k\nN(N \u2212 1)(T \u2212 1) 1a1 6=a2 + ( T \u2212 1\u2212 k N(T \u2212 1) ) 1a1=a2 .\nTo bound the approximation error in the regret, notice that for any string x accepted by CT :\nlog\n( pCT [x]\npA2 [x] ) = log ( 1\npA2 [x]\n) \u2212 log(|CT |\n(since the k-shifting automaton has uniform weights)\n= log\n( 1\npA2 [z = x|z \u2208 CT ]pA2 [z \u2208 CT ] + pA2 [z = x|z /\u2208 CT ]pA2 [z /\u2208 CT ] ) \u2212 log(|CT |)\n= log\n( 1\n1 |CT |pA2 [z \u2208 CT ] + pA2 [z = x|z /\u2208 CT ]pA2 [z /\u2208 CT ]\n) \u2212 log(|CT |)\n(since pA2 is uniform on CT ) \u2264 log (\n|CT | pA2 [z \u2208 CT ]\n) \u2212 log(|CT |)\n= log\n( 1\npA2 [z \u2208 CT ]\n) .\nThe probability that a string z is accepted by CT (under the distribution pA2) is equal to the probability that it admits exactly k shifts. Let \u03bet = 1{z shifts from t\u2212 1 to t} be a random variable indicating whether there is a shift at the t-th symbol in sequence z. This is a Bernoulli random variable bounded by 1 with mean kT\u22121 and variance k T\u22121 (1\u2212 k T\u22121 ). Since each shift occurs with probability kT\u22121 , we can use Sanov\u2019s theorem [Sanov, 1957] to write the following bound:\npA2 [z /\u2208 CT ] = pA2 [\u2223\u2223\u2223\u2223\u2223 T\u2211 t=2 \u03bet \u2212 k \u2223\u2223\u2223\u2223\u2223 > 12 ] \u2264 2e\u2212(T\u22121)u,\nwhere\nu = (T \u2212 1) min { D ( k + (1/2)\nT \u2212 1 || k T \u2212 1\n) , D ( k \u2212 (1/2) T \u2212 1 || k T \u2212 1 )} ,\nand where D(p||q) is the binary entropy. We will now use the following technical lemma, which we prove in Appendix 14.\nLemma 1 (Binary entropy bound). The following inequalities hold for the binary entropy: \u2212D ( k + (1/2)\nT \u2212 1 || k T \u2212 1\n) \u2264 \u2212 1\n12k(T \u2212 1)\n\u2212D ((\n1\u2212 1 2k\n) k\nT \u2212 1 || k T \u2212 1\n) \u2264 \u2212 1 4k2\nk T\u22121 2 = \u2212 1 8k(T \u2212 1) .\nUsing this result, we can further bound the approximation error in the regret bound by:\nlog\n( 1\npA2 [z \u2208 CT ]\n) \u2264 log ( 1\n1\u2212 2e\u2212 112k\n) = \u2212 log ( 1\u2212 2e\u2212 112k ) .\nTo the best of our knowledge, this is the first framework that motivates the design of FIXED-SHARE with a focus on minimizing tracking regret. Other works that have recovered FIXED-SHARE (e.g. [Cesa-Bianchi et al., 2012, Koolen and de Rooij, 2013, Gyo\u0308rgy and Szepesva\u0301ri, 2016]) have generally viewed the algorithm itself as the main focus.\nAs already pointed out, the bigram approximation of the k-shifting automaton has a per-iteration computational cost of O(|\u03a3|2) transitions. At each time t, every state of the form (\u00b7, t) corresponds to one of the labels in \u03a3, and admits a transition to a state in (\u00b7, t+ 1) corresponding to the same label as well as |\u03a3| \u2212 1 transitions to states corresponding to\nAlgorithm 4: PROD-EG. Algorithm: PROD-EG(p1 \u2208 (\u2206N )m, \u03b7) for t = 1, 2, . . . , T do\nPLAY(pt) RECEIVE(\u2207f(pt)) for j = 1, 2, . . . ,m do\nfor i = 1, 2, . . . , N do\npt+1,j(i) = pt,je \u2212\u03b7 \u2202f \u2202pj(i) (pt,j)\nother labels. In Section 9, we introduce the notion of \u03d5-transition and design algorithms that can reduce the size of an automaton while preserving its language and weights. Using our new algorithm \u03d5-CONVERT on A2 \u2229 ST , we can significantly reduce the number of transitions so that there are only O(|\u03a3|) states and transitions reachable at every time. See Figure 5 for an illustration. The computational cost of using \u03d5-AWM with this new \u03d5-automaton coincides with the one described originally in [Herbster and Warmuth, 1998].\nOur derivation of FIXED-SHARE also allows us to naturally generalize the setting of standard k-shifting experts to k-shifting experts with non-uniform weights. Specifically, consider the case where CT is an automaton accepting up to k-shifts but where the shifts now occur with probability pCT [a2|a1, a1 6= a2] 6= 1N\u221211{a2 6=a1}. Since the bigram approximation will remain exact on CT , we recover the exact same guarantee as in Theorem 4.\nThe proof technique of Theorem 4 is illustrative because it reveals that the maximum likelihood n-gram model has low approximation error whenever (1) the model\u2019s distribution is proportional to the distribution of CT on CT \u2019s support and (2) most of the model\u2019s mass lies on the support of CT . When the automaton CT has uniform weights, then condition (1) is satisfied when the n-gram model is uniform on CT . This is true whenever all sequences in CT have the same set of n-gram counts, and every permutation of symbols over these counts is a sequence that lies in CT , which is the case for the k-shifting automaton. Condition (2) is satisfied when n is large enough, which necessarily exists since the distribution is exact for n = T . On the other hand, note that a unigram approximation would have satisfied condition (1) but not condition (2) for the k-shifting automaton.\n7.4 Minimum Re\u0301nyi divergence n-gram models Unlike maximum likelihood n-gram models, which in general do not benefit from an approximation guarantee, in this section we discuss minimum Re\u0301nyi divergence (or\u221e-Re\u0301nyi divergence) n-gram models, which are directly obtained by solving Problem 6 over the family of n-grams models. This corresponds to the following optimization problem:\nmin pAn\u2208Pn D\u221e(pCT ||pAn) = min pAn\u2208Pn sup x\u2208CT log\n( pCT (x)\npAn(x)\n) . (8)\nThis is a convex optimization problem over a product of \u2211n j=1 |\u03a3|n\u2212j simplices. The problem can be solved using as an optimization algorithm an extension of the Exponentiated Gradient algorithm developed by Kivinen and Warmuth [1997], which we call PROD-EG. The pseudocode of the algorithm, which is based on a simple multiplicative update, is given in Algorithm 4. The following provides a general guarantee for the convergence of the algorithm. Its proof is provided in Appendix 14.\nTheorem 5 (PRODUCT-EXPONENTIATED GRADIENT (PROD-EG)). Let (\u2206N )m be the product of m (N \u2212 1)-dimensional simplices, and let f : (\u2206N ) m \u2192 R be a loss function whose partial subgradients have absolute values all bounded by L. Let p1,j = 1N for j = 1, 2, . . . ,m. Then, PROD-EG benefits from the following guarantee:\nf\n( 1\nT T\u2211 t=1 pt\n) \u2212 f(p\u2217) \u2264 1\n\u03b7T m log(N) + \u03b72L.\nFor the minimum Re\u0301nyi divergence optimization problem (8), we can apply PROD-EG to the product of m =\u2211n j=1 |\u03a3|n\u2212j simplices, each one corresponding to a conditional probability with a specific history. First, we remark that the subgradient of the maximum of a family of convex functions at a point can always be chosen from the\nsubgradient of the maximizing function at that point. Specifically, let {f\u03b1}\u03b1\u2208A be a family of convex functions, and let \u03b1(x) = argmax\u03b1 f(x). Then, it follows that\nmax \u03b1 f\u03b1(x)\u2212max \u03b1 f\u03b1(y) \u2265 f\u03b1(y)(x)\u2212 f\u03b1(y)(y) \u2265 \u3008\u2207f\u03b1(y)(y), x\u2212 y\u3009.\nLet \u03c0 be the maximizing path of the minimum Re\u0301nyi divergence objective. We will use the \u2228 symbol to denote the maximum between two values, and the \u2227 symbol the denote the minimum. We can then write\nlog\n( pCT (\u03c0)\np(\u03c0)\n) = pCT (\u03c0)\u2212 T\u2211 t=1 log ( 1 p(\u03c0t|\u03c0t\u22121t\u2212n+1\u22281) )\n= pCT (\u03c0)\u2212 T\u2211 t=1 \u2211 zn\u2227t1 \u2208\u03a3n\u2227t 1\u03c0tt\u2212n+1\u22281=zn\u2227t1 log\n( 1\np(\u03c0t|\u03c0t\u22121t\u2212n+1\u22281)\n)\n= pCT (\u03c0)\u2212 T\u2211 t=1 \u2211 zn\u2227t1 \u2208\u03a3n\u2227t 1\u03c0tt\u2212n+1\u22281=zn\u2227t1 log\n( 1\np(zn\u2227t|z(n\u2227t)\u221211 )\n)\n= pCT (\u03c0)\u2212 T\u2211 t=1 n\u2211 j=1 1j=n\u2227t \u2211 zj1\u2208\u03a3j 1\u03c0tt\u2212n+1\u22281=z j 1 log\n( 1\np(zj |zj\u221211 )\n)\n= pCT (\u03c0)\u2212 n\u2211 j=1 \u2211 zj1\u2208\u03a3j T\u2211 t=1 1j=n\u2227t1\u03c0tt\u2212n+1\u22281=z j 1 log\n( 1\np(zj |zj\u221211 )\n) ,\nso that its partial derivative with respect to p(zj |zj\u221211 ) is:\n\u2202d\n\u2202dp(zj |zj\u221211 ) log\n( pCT (\u03c0)\np(\u03c0)\n) = T\u2211 t=1 1j=n\u2227t1\u03c0tt\u2212n+1\u22281=z j 1 \u22121 p(zj |zj\u221211 ) .\nThus, by tuning PROD-EG with an adaptive learning rate\n\u03b7t \u221d 1\u221a\u2211t\ns=1 \u2225\u2225\u2225\u2207 log ( pCT (\u03c0(t))p(\u03c0(t))) )\u2225\u2225\u22252\u221e ,\nwhere \u03c0(t) = argmax\u03c0\u2208CT log ( pCT [\u03c0]\npt[\u03c0]\n) , we can derive the following guarantee for PROD-EG applied to the n-gram\napproximation problem.\nCorollary 1 (n-gram approximation guarantee). There exists an optimization algorithm outputting a sequence of conditional probabilities (pt)\u221et=1 such that ( 1 T \u2211T t=1 pt ) approximates the\u221e-Re\u0301nyi optimal n-gram solution with the following guarantee:\nF\n( 1\nT T\u2211 t=1 pt\n) \u2212 F (p\u2217)\n\u2264\n\u221a\u221a\u221a\u221a\u221a\u221a\u221a2Nn log(N) \u2211T t=1 max j\u2208{1,...,n}\nzj1\u2208\u03a3j\n\u2223\u2223\u2223\u2223 T\u2211 t=1 1j=n\u2227t1\u03c0tt\u2212n+1\u22281=z j 1\n1\npt(zj |zj\u221211 ) \u2223\u2223\u2223\u2223 (N \u2212 1)T 2 .\nEach iteration of PROD-EG admits a computational complexity that is linear in the dimension of the feature space. Since we have specified an n-gram model as the product of N\nn\u22121 N\u22121 simplices, the total per-iteration cost of solving the convex optimization problem is in O ( N(Nn\u22121) N\u22121 ) = O(Nn). Since the minimum Re\u0301nyi divergence is not Lipschitz,\nthe maximizing ratio in the convergence guarantee may also become large when the choice of n is too small. In all cases, observe that this approximation problem can be solved offline.\nIf we restrict ourselves to CT with uniform weights and |\u03a3| = 2, then we can also provide an explicit solution for unigram automata. The solution is obtained from the paths with the smallest number of occurrences of each symbol, which can be straightforwardly found via a shortest-path algorithm in linear time.\nTheorem 6 (\u221e-Re\u0301nyi divergence unigram solution for uniform weight competitors and |\u03a3| = 2). Assume that CT admits uniform weights over all paths and |\u03a3| = 2. For j \u2208 {1, 2}, let n(aj) be the smallest number of occurrences of aj in a path in CT . For j 6= k, define\npk(aj) = max\n{ 1,\nn(aj) T\u2212n(aj) } 1 + max { 1,\nn(aj) T\u2212n(aj) } . Let k\u2217 be the solution of the following optimization problem:\nmax k\u2208{1,2} max j\u2208{1,2}\\{k}\nn(aj) log pk(aj) + [T \u2212 n(aj)] log (1\u2212 pk(aj)) .\nThen, pk\u2217 is the solution of the unigram\u221e-Re\u0301nyi divergence optimization problem.\nProof. We seek a unigram distribution pA1,T that is a solution of:\nmin pA1\u2208P1 sup \u03c0\u2208CT log\n( pCT [\u03c0]\npA1 [\u03c0]\n) .\nSince CT admits uniform weights, pCT [\u03c0] = 1 |CT | , and since A1,T is a unigram automaton, log pA1 [\u03c0] can be expressed as follows: log pA1 [\u03c0] = n\u03c0(a1) log p(a1) + [T \u2212 n\u03c0(a1)] log (1\u2212 p(a1)) ,\nwhere p(aj) is the automaton\u2019s weight on transitions labeled with aj and n\u03c0(aj) is the count of aj in path \u03c0. Thus, the optimization problem is equivalent to the following problem:\n\u2212 max p(a1)\u2208[0,1] min \u03c0\u2208CT n\u03c0(a1) log p(a1) + [T \u2212 n\u03c0(a1)] log (1\u2212 p(a1)) .\nDenote the objective by F (p(a1), n\u03c0(a1)). Then, the partial derivatives with respect to the label counts are given by\n\u2202F\n\u2202n\u03c0(a1) = log p(a1)\u2212 log\n( 1\u2212 p(a1) ) .\nThus, \u2202F\u2202n\u03c0(a1) \u2265 0 if and only if p(a1) \u2265 1\u2212 p(a1). Furthermore, if p(a1) \u2265 1\u2212 p(a1), then the path \u03c0 chosen in the optimization problem is the path with the minimal count of symbol a1. Similarly, if p(a2) \u2265 1\u2212 p(a2), then the path \u03c0 chosen in the optimization problem is the path with minimal count of a2.\nSince we have either p(a1) \u2265 p(a2) or vice versa (potentially both), we can write the optimization problem as:\n\u2212 max k\u2208{1,2} max p(aj)\u22651\u2212p(aj)\nj 6=k\nmin {n\u03c0(aj)}j 6=k : \u03c0\u2208CT\nn\u03c0(aj) log p(aj) + [T \u2212 n\u03c0(aj)] log (1\u2212 p(aj)) .\nGiven k \u2208 {1, 2}, let \u03c0(k) be the path that minimizes n\u03c0(aj) over all \u03c0 for j 6= k. Denote these counts n\u03c0(k)(aj) by n(aj). Then we can rewrite the objective as:\n\u2212 max k=1,2,...,N max p(aj)\u22651\u2212p(aj)\nj 6=k\nn(aj) log p(aj) + [T \u2212 n(aj)] log (1\u2212 p(aj)) .\nDenote the objective for this new term by F\u0303k, which is a function of p(aj). The partial derivative of F\u0303k with respect to p(aj) is:\n\u2202F\u0303k \u2202p(aj) = n(aj) p(aj) \u2212 T \u2212 n(aj) 1\u2212 p(aj) ,\nwhich is equal to 0 if and only if\np(aj) = n(aj)\nT \u2212 n(aj) (1\u2212 p(aj)) = max\n{ 1, n(aj)\nT \u2212 n(aj)\n} (1\u2212 p(aj)) .\nThe last equality follows from our assumption that p(aj) \u2265 1\u2212 p(aj). Now, let pk(aj) denote the probabilities that we have just computed. Then, we can write the optimization problem of F\u0303k as:\n\u2212 max k\u2208{1,2},j\u2208{1,2}\\{k} n(aj) log pk(aj) + [T \u2212 n(aj)] log (1\u2212 pk(aj)) .\nTheorem 6 shows that the solutions of the\u221e-Re\u0301nyi divergence optimization are based on the n-gram counts of sequences in CT with \u201chigh entropy\u201d. This can be very different from the maximum likelihood solutions, which are based on the average n-gram counts. For instance, suppose we are under the assumptions of Theorem 6, and specifically, assume that there are T sequences in CT . Assume that one of the sequences has ( 1 2 + \u03b3 ) T occurrences of a1 for some\nsmall \u03b3 > 0 and that the other T \u2212 1 sequences have T \u2212 1 occurrences of a1. Then, n(a1) = ( 1 2 + \u03b3 ) T , and the solution of the\u221e-Re\u0301nyi divergence optimization problem is given by p\u221e(a1) = 1+2\u03b32 and p\u221e(a2) = 1\u22122\u03b3\n2 . On the other hand, the maximum-likelihood solution would be p1(a1) = 1+ \u03b3T \u2212 3 2T + 1 T 2 \u2248 1 and p1(a2) = 3 2T \u2212 \u03b3 T \u2212 1 T 2 \u2248 0 for large T ."}, {"heading": "7.5 Model selection", "text": "The previous section introduced a method to learn a single n-gram model based on the competitor automaton CT . In practice, one seeks an n-gram model that balances the tradeoff between approximation error and computational cost.\nAssume that we have a maximum per-iteration computational budget B. We thus seek the most computationally efficient n-gram model within our budget that does not contribute to an increase in regret. Let pn be an n-gram model returned by PROD-EG. By Corollary 1, we can write F (pn)\u2212 GapTopt,n \u2264 F (p \u2217 n), where p \u2217 n is the optimal n-gram model minimizing the objective and GapTopt,n is the expression quantifying the gap between PROD-EG and the optimal solution after running the algorithm for Topt iterations. Thus, if F (pn)\u2212 GapTopt,n > \u221a T for some n, then even the optimal n-gram model for this n will cause an increase in the regret. Let n\u2217 be the smallest n such that F (pn)\u2212GapTopt,n \u2264 \u221a T (or the smallest value that exceeds our budget). We can find this value in log(n\u2217) time using a two-stage process. In the first stage, we double n after every violation until we find an upper bound on n\u2217, which we denote by nmax. In the second stage, we perform a binary search within [1, nmax] to determine n\u2217. Each stage takes log(n\u2217) iterations, and each iteration is the cost of running PROD-EG for that specific value of n. Thus, the overall complexity of the algorithm is O (log(n\u2217)Cost(PROD-EG)), where Cost(PROD-EG) is the cost of running PROD-EG once. Algorithm 5 presents the pseudocode for this algorithm, n-GRAMSELECT."}, {"heading": "8 Time-independent approximation of competitor automata", "text": "In the previous section, we introduced the technique of approximating the automaton accepting competitor sequences of length T , CT . Intersecting C with ST for different T typically results in different approximation automata. Since each approximation requires solving a convex optimization problem, this can become computationally expensive.\nIn this section, we show how one can approximate the competitor set for different T using a single approximation. The key is to approximate the original automaton C directly. Specifically, assume first that C is a stochastic automaton (so that its outgoing transition weights at each state sum to 1). Let pC denote the distribution defined by C, and let P be a family of distributions over \u03a3\u2217 that we will use to approximate pC. Given, pA \u2208 P , define for every x \u2208 \u03a3\u2217\np\u0303A[x] =\n{ pA[x] pC[S|x|]\npA[S|x|] if pA[S|x|] > 0\n0 otherwise\nThus, p\u0303A[x] is a rescaling of pA based on the mass assigned by C to sequences of length equal to |x|. Note that p\u0303A may not necessarily be a distribution. Our algorithm consists of determining the best approximation to the competitor\nAlgorithm 5: n-GRAMSELECT. Algorithm: n-GRAMSELECT(CT , Topt, B) n\u2190 1 pn \u2190 1|\u03a3| t\u2190 0 while t \u2264 Topt do\npn \u2190 PROD-EG-UPDATE(pn) t\u2190 t+ 1 if F (pn)\u2212Gapt,n > \u221a T and |\u03a3|n \u2264 B then\nn\u2190 2n t\u2190 0 pn \u2190 1|\u03a3|\nnmax \u2190 n. pn \u2190 BINARYSEARCH([1, nmax], F (pn)\u2212GapTopt,n \u2264 \u221a T ) return pn\ndistribution pC within the family of rescaled distributions:\nmin pA\u2208P\nD\u221e(pC||p\u0303A). (9)\nNote that this is an implicit extension of the definition of\u221e-Re\u0301nyi divergence, since p\u0303A is not a distribution. The design of this optimization problem is motivated by the following result, which guarantees that if p\u0303A is a good approximation of pC, then pA\u2229ST will be a good approximation of pCT for any T .\nTheorem 7. For any stochastic automata S and A, and for any T \u2265 1,\nD\u221e(pCT ||pA\u2229ST ) \u2264 D\u221e(pC||p\u0303A).\nProof. Let x \u2208 CT = C \u2229 ST such that pCT [x] > 0. Since pCT [x] = pC[x] pC(ST ) , this implies that pC(ST ) \u2265 pC[x] > 0. Thus, if pA(ST ) > 0, then\nlog\n( pCT [x]\npA\u2229ST [x]\n) = log ( pC[x]pA(ST )\npC(ST )pA[x]\n) = log ( pC[x]\np\u0303A[x]\n) .\nOn the other hand, if pA(ST ) = 0, then, by definition, p\u0303A[x] = 0, therefore the following inequality holds\nlog\n( pCT [x]\npA\u2229ST [x]\n) \u2264 \u221e = log ( pC[x]\np\u0303A[x]\n) .\nThe result now follows by taking the maximum over x \u2208 ST on the left-hand side and the maximum over x \u2208 \u03a3\u2217 on the right-hand side.\nNote that, for n-gram approximations, pAn \u2208 Pn, the condition pAn(ST ) = 1 always holds. Thus, the approximation optimization problem can be written as:\nmin pAn\u2208Pn D\u221e(pC||p\u0303A) = min pAn\u2208Pn sup x\u2208C log\n( pC[x]\npAn [x]pC[S|x|]\n) .\nAs in Section 7, this problem is the minimization of the supremum of a family of convex functions over the product of simplices. Thus, it is a convex optimization problem and can be solved using the PROD-EG algorithm.\nWe have thus far assumed that C is a stochastic automaton in this section. If the sum of the weights of all paths accepted by C is finite, we can apply weight-pushing to normalize the automaton to make it stochastic and then solve the approximation problem above.\nHowever, this property may not always hold. For example, the original k-shifting automaton shown in Figure 2 accepts an infinite number of paths (sequences of arbitrary length with k shifts). Since each transition has unit weight, each path also has unit weight, and the sum of the weight of all paths is infinite.\nHowever, we can still apply the approximation method in this section to the k-shifting automaton by rescaling the transitions weights of self-loops to be less than 1. Specifically, consider the automaton Ck-shift, whose states and transitions are exactly the same as those of the original automaton Ck-shift, except that transitions from taj to (t+1)ak for aj 6= ak now have weight N+1 , and self-loops now have weight 1\u2212 . To make the automaton stochastic, we also assign\nweight 1N to every initial state. Then, the weight of a path of length T accepted by Ck-shift, is (1\u2212 ) T\u2212k\u22121\n(\nN\u22121 )k 1 N ,\nand the weight of all paths is equal to the following:\u2211 \u03c0\u2208Ck-shift, wCk-shift, [\u03c0] = \u2211 T\u2265k+1 N ( T \u2212 1 k ) (N \u2212 1)k(1\u2212 )T\u2212k\u22121 ( N \u2212 1 )k 1 N\n= \u2211\nT\u2265k+1\n( T \u2212 1 k ) (1\u2212 )T\u2212k\u22121 k\n\u2264 \u2211\nT\u2265k+1\n( (T \u2212 1)e\nk\n)k (1\u2212 )T\u2212k\u22121 k\n< +\u221e.\nBy normalizing the weights of this automaton, we can convert it into a stochastic automaton, where pCk-shift, [\u03c0] \u221d (1\u2212 )|\u03c0|\u2212k\u22121 (\nN \u2212 1\n)k 1\nN .\nFigure 6 shows the weighted automaton Ck-shift, . To compare with the results in Section 7, we will now analyze the approximation error of a maximum-likelihoodbased bigram approximation.\nTheorem 8 (Bigram approximation of Ck-shift, ). The maximum-likelihood based bigram model for Ck-shift, is defined by\npA2 [z2|z1] =\n\u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 ( 1z1 6=z2 k T\u0303\u22121 1 N\u22121 + 1z1=z2 ( 1\u2212 k T\u0303\u22121 )) \u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 .\nMoreover, for every T > k + 1, there exists \u2208 (0, 1) such that D\u221e(pCT ||pA2) \u2264 \u2212 log ( 1\u2212 2e\u2212 112k ) .\nProof. The maximum-likelihood n-gram automaton is derived from the expected counts of the original automaton. Thus, for any z1, z2 \u2208 \u03a3,\npA2 [z2|z1] =\n\u2211 x\u2208Ck-shift(1\u2212 ) |x|\u2212k\u22121 ( N\u22121 )k 1 N \u2211|x| t=2 1z21=xtt\u22121\u2211\nx\u2208\u03a3\u2217(1\u2212 )|x|\u2212k\u22121 ( N\u22121 )k 1 N \u2211|x| t=2 1z1=xt\u22121\n=\n\u2211 x\u2208Ck-shift(1\u2212 ) |x|\u2212k\u22121\u2211|x| t=2 1z21=xtt\u22121\u2211\nx\u2208\u03a3\u2217(1\u2212 )|x|\u2212k\u22121 \u2211|x| t=2 1z1=xt\u22121\n=\n\u2211 T\u0303\u2265k+1 \u2211 x\u2208Ck-shift,T\u0303 (1\u2212 )T\u0303\u2212k\u22121 \u2211T\u0303 t=2 1z21=xtt\u22121\u2211\nT\u0303\u2265k+1 \u2211 x\u2208Ck-shift,T\u0303 (1\u2212 )T\u0303\u2212k\u22121 \u2211T\u0303 t=2 1z1=xt\u22121\nNow, notice that for any T\u0303 ,\n\u2211 x\u2208Ck-shift,T\u0303 T\u0303\u2211 t=2 1z21=xtt\u22121\n= \u2211\nx\u2208Ck-shift,T\u0303\nT\u0303\u2211 t=2 1z1=xt\u22121 ( 1z1 6=z2 k T\u0303 \u2212 1 1 N \u2212 1 + 1z1=z2 ( 1\u2212 k T\u0303 \u2212 1 )) .\nThis allows us to rewrite the probability above as:\npA2 [z2|z1]\n=\n\u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 ( 1z1 6=z2 k T\u0303\u22121 1 N\u22121 )\u2211 x\u2208Ck-shift,T\u0303 \u2211T\u0303 t=2 1z1=xt\u22121\u2211\nT\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 \u2211 x\u2208Ck-shift,T\u0303 \u2211T\u0303 t=2 1z1=xt\u22121\n+\n\u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 ( 1z1=z2 ( 1\u2212 k\nT\u0303\u22121 ))\u2211 x\u2208Ck-shift,T\u0303 \u2211T\u0303 t=2 1z1=xt\u22121\u2211\nT\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 \u2211 x\u2208Ck-shift,T\u0303 \u2211T\u0303 t=2 1z1=xt\u22121\n=\n\u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 ( 1z1 6=z2 k T\u0303\u22121 1 N\u22121 + 1z1=z2 ( 1\u2212 k T\u0303\u22121 )) \u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 .\nThus, pA2 [z2|z1] depends only on the condition z1 6= z2. Now, fix T > k + 1. Since for every x \u2208 CT , x has k shifts and length T , pA2 is uniform over all sequences in CT . This allows us to bound the\u221e-Renyi divergence between pCT and pA2 by:\nsup x\u2208Ck-shift,T log\n( pCk-shift,T [x]\npA2 [x] ) = sup x\u2208Ck-shift,T log ( pCk-shift,T [x] pA2 [\u03be = x|\u03be \u2208 CT ]pA2 [\u03be \u2208 CT ] + pA2 [\u03be = x|\u03be /\u2208 CT ]pA[\u03be /\u2208 CT ] )\n\u2264 sup x\u2208Ck-shift,T log\n( 1 |CT |\n1 |CT |pA2 [\u03be \u2208 CT ]\n)\n= sup x\u2208Ck-shift,T log\n( 1\npA2 [\u03be \u2208 CT ]\n) .\nIf we now let (\u03bet)Tt=2 denote i.i.d. Bernoulli random variables with mean\np\u0304( ) =\n\u2211 T\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121\nk T\u0303\u22121\u2211\nT\u0303\u2265k+1(1\u2212 )T\u0303\u2212k\u22121 ,\nthen\npA2 [\u03be /\u2208 CT ] = P [\u2223\u2223\u2223\u2223\u2223 T\u2211 t=2 \u03bet \u2212 k \u2223\u2223\u2223\u2223\u2223 \u2265 1 ]\n\u2264 P [\u2223\u2223\u2223\u2223\u2223 T\u2211 t=2 \u03bet \u2212 p\u0304( )(T \u2212 1) \u2223\u2223\u2223\u2223\u2223 \u2265 12 ] + P [ |p\u0304( )(T \u2212 1)\u2212 k| \u2265 1 2 ] .\nThus, if |p\u0304( )(T \u2212 1) \u2212 k| < 12 , then pA2 [\u03be /\u2208 CT ] can be bounded using the same concentration argument as in Theorem 4.\np\u0304( ) can be interpreted as the weighted average of k T\u0303\u22121 for T\u0303 \u2265 k + 1, where the weight of k T\u0303\u22121 is (1\u2212 ) T\u0303\u2212k\u22121. We want this average to be close to kT\u22121 for the specific choice of T > k + 1, which we obtain by appropriately tuning \u2208 (0, 1).\nSince lim \u21920+ p\u0304( ) = 1, lim \u21921\u2212 p\u0304( ) = 0 and p\u0304( ) is continuous in on (0, 1), it follows by the intermediate value theorem that for any T > k + 1, there exists an \u2217 such that p\u0304( \u2217) = kT\u22121 .\nNote that in the proof of the above theorem, p\u0304( ) is monotonic in . Thus, one can find \u2032 such that \u2223\u2223\u2223p\u0304( \u2032)\u2212 kT\u22121 \u2223\u2223\u2223 \u2264\n1 2(T\u22121) using binary search."}, {"heading": "9 Failure transition algorithm", "text": "The computational complexity of the AWM algorithm presented in Section 4 is based on the size of the composed automaton C \u2229 ST , which itself is related to the original size of C. Similarly, if we were to apply AWM to an n-gram approximation, the computational complexity of the algorithm depends on the size of the approximating automaton. In this section, we introduce a technique to improve the computational cost of AWM by reducing the size of the automaton. To do this, we will use the notion of failure transition (or \u03d5-transition). Failure transitions play a key role in the design of many efficient string-matching and automata algorithms, including egrep under UNIX [Aho and Corasick, 1975, Knuth et al., 1977, Crochemore, 1986, Mohri, 1997].\nLet \u03d5 be a symbol not in \u03a3. A \u03d5-automaton is an automaton A with transition set EA \u2286 QA\u00d7\u03a3\u222a{\u03d5}\u222aR+\u222aQA. Transitions of the forms e = (q, \u03d5, w, q\u2032) are called failure transitions and characterized by the semantic of \u201cother\u201d. If at state q there is no outgoing transition labeled with a given label a \u2208 \u03a3 and there is a \u03d5-transition e leaving q, then the failure transition is taken instead without consuming the label, and the next state is determined using the transitions leaving q\u2032. We assume that there is no \u03d5-cycle in any of our \u03d5-automata, and that there is at most one failure transition leaving any state. This implies that the number of consecutive failure transitions taken is bounded.\nMore formally, the transition function \u03b4 is defined as follows in the presence of \u03d5-transitions. Recall that for state q \u2208 QA and label a \u2208 \u03a3, \u03b4[q, a] is the set of states reachable from q by reading label a, and E[q, a] is the set of outgoing transitions from q with label a. For a \u03d5-automaton, the set of states reachable from any state by reading label a is defined as follows:\n\u03b4[q, a] =  {dest[e] : e \u2208 E[q, a]} if E[q, a] 6= \u2205 \u03b4[\u03b4[q, \u03d5], a] if E[q, a] = \u2205, E[q, \u03d5] 6= \u2205 \u2205 otherwise.\nA failure transition can often replicate the role of multiple standard transitions when there is \u201csymmetry\u201d within an automaton, that is when there are many transitions leading to the same state from different states that consume the same set of labels. Figure 7 illustrates such cases.\nGiven any non-initial state q in an automaton, we would like to determine a set of parent states within ER[q] from which it is beneficial to introduce a \u03d5-transition. We design a greedy solution in Algorithm 6, \u03d5-SOURCESUBSET. For every q \u2208 Q \\ I , having already computed Qk\u22121, \u03d5-SOURCESUBSET greedily determines a candidate set Qk of k parent states based on which available parent state has the most label-weight overlap with the subset already chosen. It then selects the best candidate set from {Qk}|E R[q]| k=1 . \u03d5-SOURCESUBSET is able to recover the \u03d5-transition structure\nin Figure 7, and while it does not always produce the optimal subset of parent states, its computational cost is only O ( |\u03b4R[q]|2|ER[q]| ) for input state q.\n0 4 a b c 1 a b c\n2\na b c\n3\na b c\n0\n4\n\u03c6\n1\n\u03c6\n2\n\u03c6\n3\n\u03c6\n5\na b c\n(a) (b)\nWe now present an algorithm, \u03d5-CONVERT, that converts a weighted automaton to a weighted \u03d5-automaton without ever increasing the size of the automaton. Its pseudocode is provided in Algorithm 7, and it uses \u03d5-SOURCESUBSET as a subroutine to select a candidate set of parent states for each state q. The algorithm then determines whether it should introduce a failure transition between these parent states and q based on whether the \u03d5-transition will reduce the total number of transitions in the automaton. Theorem 9 provides an accompanying guarantee on efficiency.\nTheorem 9 (Correctness and performance of \u03d5-CONVERT). \u03d5-CONVERT returns a \u03d5-automaton equivalent to the input automaton. The number of transitions in the \u03d5-automaton output by the algorithm is never larger than the number of transitions in the input automaton. The running-time complexity of \u03d5-CONVERT is O ( |QC| max\nq\u2208QC |\u03b4R[q]|2|ER[q]|\n) .\nProof. Let q be any state in C \\ IC, q\u2032 \u2208 \u03b4R[q], and e = (q\u2032, a, w, q) \u2208 ER[q] be such that we introduce a failure transition from q\u2032 to q that replaces e. Then, any path that used to contain transition e will now contain the consecutive pair of transitions (q\u2032, \u03d5, 1, q\u0303) and (q\u0303, a, w, q), which is taken where a was previously taken (since the automaton is deterministic). The contributed weight of this pair is w and the substring consumed is a, which is the same as it was for e. Since q was arbitrary, the new automaton assigns the same weight to every string as the old automaton.\nMoreover, notice that whenever we consider introducing a failure transition, we remove |S\u2217| transitions from |Q\u2217| parent states while introducing |Q\u2217| \u03d5-transitions from each of the parent states to a new state q\u0303, and |S\u2217| transitions from q\u0303 to q. Thus, the change in number of transitions is |S\u2217|+ |Q\u2217| \u2212 |S\u2217||Q\u2217|. This is precisely the condition that we check before introducing a failure transition.\nThe running-time complexity of \u03d5-CONVERT is dominated by the subroutine \u03d5-SOURCESUBSET. Since we must run it for every state in QC \\ IC, the total computational cost is O ( |QC|maxq\u2208QC |\u03b4R[q]|2|ER[q]| ) .\nFigure 8 shows the result of applying \u03d5-CONVERT to the k-shifting automaton. Recall that the two main automata operations required for AWM are composition and shortest-distance. While these two algorithms are standard for weighted automata, it is not as clear how one can perform them over weighted \u03d5-automata. We now extend both to \u03d5-automata.\nFirst, we consider the composition of a weighted \u03d5-automaton with ST . Algorithm 8 presents the pseudocode for our algorithm, \u03d5-COMPOSITION.3 As with standard composition the output automaton is based on matching transitions of C and ST . However, when the algorithm considers a \u03d5-transition in C, it checks if the label of the current transition considered in ST matches that of a transition leaving the source state of the \u03d5-transition. In that case, the algorithm skips this pair of transitions, as the \u03d5-transition is not taken in the presence of transitions with a desired label. If there is no such label, then the algorithm creates a new transition for the composed automaton, where the destination state in the ST component remains unchanged (since the automaton has not successfully \u201cread\u201d the label yet). Theorem 10 presents consistency guarantees that \u03d5-composition behaves in an analogous way to standard composition.\nTheorem 10 (\u03d5-COMPOSITION consistency guarantee). \u03d5-COMPOSITION outputs a \u03d5-automaton equivalent to C\u2229ST (or C \u25e6 ST ). The maximum number of transitions created by the algorithm is O (\u2211T t=1 |QC,t| maxq\u2208QC,t |E[q]| ) , where QC,t = {q \u2208 QC \u00d7QST : q = (\u00b7, t)}.\nProof. Given an automaton A, state q \u2208 QA, and string x \u2208 \u03a3\u2217, let \u03b4A[q, w] be the set of states reachable from q by reading string x.\nLet q \u2208 CT . By construction, q = (q1, q2), where q1 \u2208 C and q2 \u2208 ST . We first show that for any string x \u2208 \u03a3\u2217, \u03b4CT [q, x] = (\u03b4C[q1, x], \u03b4ST [q2, x]).\nBy induction, suppose that |x| = 1. Let (q\u20321, q\u20322) \u2208 (\u03b4C[q1, x], \u03b4ST [q2, x]). Then \u2203e2 \u2208 EST such that e2 = (q2, x, w2, q \u2032 2). Since C admits failure transitions, it is possible that \u2203e1 \u2208 EC such that e1 = (q1, x, w1, q\u20321) or not. If such an e1 does exist, then \u03d5-COMPOSITION constructs the edge e = ((q1, q2), x, w1w2, (q\u20321, q \u2032 2)) so that (q\u20321, q \u2032 2) \u2208 ECT . If such an e1 does not exist, then there must exist a sequence of failure transitions {e\u0303j}nj=1 leading\n3In the pseudocode, ] denotes the multiset union.\nAlgorithm 8: \u03d5-COMPOSITION. Algorithm: \u03d5-COMPOSITION(C, ST ) QCT \u2190 IC \u00d7 IST . Q \u2190 IC \u00d7 IST . while Q 6= \u2205 do\nq = (q1, q2)\u2190 HEAD(Q) DEQUEUE(Q) if q \u2208 IC \u00d7 IST then\nICT \u2190 ICT \u222a {q} \u03bbCT \u2190 \u03bbC(q1)\u03bbST (q2) if q \u2208 FC \u00d7 FST then FCT \u2190 FCT \u222a {q} \u03c1CT \u2190 \u03c1C(q1)\u03c1ST (q2) for each (e1, e2) \u2208 EC \u00d7 EST do if \u03c3(e1) = \u03c3(e2) then\nif q\u0303 = (dest[e1],dest[e2]) /\u2208 QCT then QCT \u2190 QCT \u222a {q\u0303} ENQUEUE(Q, q\u0303)\nECT \u2190 ECT ] {(q, \u03c3(e1), w[e1]w[e2], q\u0303)} else if \u03c3[e1] = \u03d5 then\nif @e \u2208 EC[q1] such that \u03c3[e] = \u03c3[e2] then if q\u0303 = (dest[e1], q2) /\u2208 QCT then\nQCT \u2190 QCT \u222a {q\u0303} ENQUEUE(Q, q\u0303)\nECT \u2190 ECT ] {(q, \u03d5,w[e1], q\u0303)} CT \u2190 (\u03a3, QCT , ICT , FCT , ECT , \u03bbCT , \u03c1CT ) return CT\nto a state with a transition e\u0303n+1 labeled with x with destination q\u20321. Moreover, there cannot be any transition leaving {q1} \u222a {dest[e\u0303j ]}n\u22121j=1 labeled with x. In this case, \u03d5-COMPOSITION would have constructed the transitions:\n{((q1, q2), \u03d5, w[e\u03031], (dest[e\u03031], q2))} \u222a {((dest[e\u0303j ], q2), \u03d5, w[e\u03031], (dest[e\u0303j+1], q2))}n\u22121j=1 \u222a {((dest[e\u0303n], q2), x, w[e\u0303n+1]w2, (q\u20321, q\u20322))},\nand there also would be no transitions labeled with x leaving {(q1, q2)} \u222a {dest[e\u0303j ], q2}nj=1. Thus, we would have (q\u20321, q\u20322) \u2208 \u03b4CT [q, x]. Since (q1, q2), (q\u20321, q\u20322) and x are arbitrary, this implies that \u03b4CT [q, x] \u2287 (\u03b4C[q1, x], \u03b4ST [q2, x]).\nTo show the other inclusion, assume that (q\u20321, q \u2032 2) \u2208 \u03b4CT [q, x]. Then, either there exists a transition of the form ((q1, q2), x, w, (q \u2032 1, q \u2032 2)) or not. If there does exist such a transition, then it must have been constructed from the transitions (q1, x, w1, q\u20321) and (q2, x, w2, q \u2032 2) in EC and EST . Otherwise, the algorithm would have constructed failure transitions. Thus, if such a transition exists, then q\u20321 \u2208 EC[q1, x] and q\u20322 \u2208 EST [q2, x]. If such a transition does not exist, then (q\u20321, q \u2032 2) is reached through a series of failure transitions. Thus, there must be a sequence of transitions:\n{((q1, q2), \u03d5, w\u03031, q\u03031)} \u222a {(q\u0303j , \u03d5, w\u0303j , q\u0303j+1)}nj=2 \u222a {(q\u0303n+1, x, w\u0303n+1, (q\u20321, q\u20322))},\nin which none of the states {(q1, q2)} \u222a {q\u0303j}nj=1 have outgoing transitions labeled with x. By construction, each of the states q\u0303j = (q\u0303j,1, q\u0303j,2) \u2208 QC \u00d7QST , and any failure transition in the output: \u2200j \u2208 [2, n], (q\u0303j , \u03d5, w\u0303j , q\u0303j+1) must have been constructed from the transition (q\u0303j,1, \u03d5, w\u0303j , q\u0303j+1,1) \u2208 EC, and satisfy q\u0303j,2 = q\u0303j+1,2. Similarly, there must exist (q1, \u03d5, w\u03031, q\u03031,1) \u2208 EC and q\u03031,2 = q2. Finally, the existence of (q\u0303n+1, x, w\u0303n+1, (q\u20321, q\u20322)) implies the existence of both (q\u0303n+1,1, x, w\u0303n+1,1, q \u2032 1) \u2208 EC and (q\u0303n+1,2, xw\u0303n+1,2, q\u20322) \u2208 EST , where w\u0303n+1,1w\u0303n+1,2 = w\u0303n+1. In other words, EST contains a transition (q2, x, w\u0303n+1,2, q\u20322) andEC contains a sequence of failure transitions whose source states do not have outgoing edges labeled with x. But this means that the destination of this sequence of transitions (q\u20321, q \u2032 2) is reachable from (q1, q2) by reading x, and so \u03b4CT [q, x] \u2286 (\u03b4C[q1, x], \u03b4ST [q2, x]). Thus, \u03b4CT [q, x] = (\u03b4C[q1, x], \u03b4ST [q2, x]) when |x| = 1.\nBy induction, assume that the statement is true for |x| = n \u2212 1 and that now |x| = n. Then x = yz where |y| = n\u2212 1 and |z| = 1. Thus, we have that\n\u03b4CT [q, x] = \u03b4CT [q, yz]\n= \u03b4CT [\u03b4CT [q, y], z]\n= (\u03b4C[\u03b4C[q1, y], z], \u03b4ST [\u03b4ST [q2, y], z])\n= (\u03b4C[q1, yz], \u03b4ST [q2, yz])\n= (\u03b4C[q1, x], \u03b4ST [q2, x]).\nThus, \u03b4CT [q, x] = (\u03b4C[q1, x], \u03b4ST [q2, x]) for all x \u2208 \u03a3\u2217. Notice that in the course of the proof above, we have constructed a one-to-one correspondence between the paths in ECT and the paths in EC and EST , where the weights of the paths in the former are exactly the product of the weights of the paths in the latter. Since the weight of any string is simply the sum of the weights of all accepting paths, the weight of any string in the output is equal to the sum of the products of the weights of matching paths in C and ST in the input.\nThe bound on the number of transitions in the output of composition follows from the same reasoning as for standard composition. Since the algorithm only constructs states and transitions that are reachable by paths in C \u2229 ST , we may again consider the incremental cost of composing states corresponding to q = (\u00b7, t+ 1) given that we have composed all states of the form q = (\u00b7, t). The existence of failure states and transitions is accounted for in the definition of QC,t.\nThe second automaton operation that we need to extend to \u03d5-automata is the shortest-distance computation. Specifically, in AWM, we applied Algorithm 2, INCRSD, as a subroutine, which was a shortest-distance computation for weighted automata defined over the probability semiring. In general, IncrSD cannot be directly applied to \u03d5automata because it might sum over potentially \u2018obsolete \u03d5-transitions\u2019. For example, if at a given state q, there is a transition labeled with a to q\u2032 and a \u03d5-transition whose destination state has a single outgoing transition also labeled with a to q\u2032, the second path should not be considered.\nTo account for these types of situations and extend INCRSD in a computationally efficient way, we use the fact that the probability semiring (R+,+,\u00d7, 0, 1) admits a natural extension to a ring structure under the standard additive inverse \u22121. Specifically, upon encountering a transition e labeled with a leaving state q, we will check for \u03d5-transitions with destination states that admit further transitions e\u2032 labeled with a. Any such transition should not contribute any weight to the distance to dest[e\u2032], since under the semantic of the \u03d5-transition, this path should never be taken. To correctly account for these paths, we will preemptively subtract the weight of e\u2032 from its destination state. When the algorithm processes the \u03d5-transition directly, it will add this weight back so that the total contribution of this path is zero. The overhead of this extra computation is O(N\u03d5(QCT ) max\nq\u2208QCT |E[q]|), where N\u03d5(QCT ) is the maximum number\nof consecutive \u03d5-transitions leaving states in QCT . The precise pseudocode is presented in Algorithm 9, \u03d5-INCRSD. Theorem 11 provides a theoretical guarantee for the algorithm.\nTheorem 11 (\u03d5-INCRSD guarantee). If \u03d5-INCRSD is run with the topological order queue discipline and the shortest distances from source ICT to the set of states QC,t\u22121 = {q \u2208 QCT : q = (\u00b7, t\u2212 1)} are stored in \u03b1, then \u03d5-INCRSD\nAlgorithm 9: \u03d5-INCREMENTALSHORTESTDISTANCE (\u03d5-IncrSD). Algorithm: \u03d5-INCRSD(C \u2229 ST , t, \u03b1) CT \u2190 C \u2229 ST for each q \u2208 QCT with q = (\u00b7, t) do\n\u03b1[q]\u2190 r[q]\u2190 0 if t = 1 then\nfor each q \u2208 ICT do \u03b1[q]\u2190 r[q]\u2190 1\nQ \u2190 ICT . else Q \u2190 {q \u2208 QCT : q = (\u00b7, t\u2212 1)} while Q 6= \u2205 do q \u2190 HEAD(Q) DEQUEUE(Q) r\u0303 \u2190 r[q] r[q]\u2190 0 for each e \u2208 ECT [q] do\nif \u03b1[dest[e]] 6= \u03b1[dest[e]] + (r\u0303w[e]) then \u03b1[dest[e]]\u2190 \u03b1[dest[e]] + (r\u0303w[e]) r[dest[e]]\u2190 r[dest[e]] + (r\u0303w[e]) if dest[e] /\u2208 Q then ENQUEUE(Q,dest[e]) if \u03c3[e] 6= \u03d5 then\nq\u0303 \u2190 q w\u03d5 \u2190 1 while \u2203e\u03d5 \u2208 E[q\u0303] with \u03c3[e\u03d5] = \u03d5 do\nw\u03d5 \u2190 w\u03d5w[e\u03d5] if \u2203e\u2032 \u2208 E[dest[e\u03d5]] with \u03c3[e\u2032] = \u03c3[e] then\n\u03b1[dest[e\u2032]]\u2190 \u03b1[dest[e\u2032]]\u2212 (r\u0303w\u03d5w[e\u2032]) BREAK\nelse q\u0303 \u2190 dest[e\u03d5]\nreturn \u03b1\ncomputes the shortest distances from source ICT to the set of states QC,t. The computational complexity of \u03d5-INCRSD is O ( N\u03d5(QC,t\u22121)|E[QC,t\u22121]| ) .\nProof. Assume that \u03b1 stores the shortest distances from ICT to QC,t\u22121, and let q \u2208 QC,t. Since we assume that \u03b1 is correct up to QC,t\u22121 and every path from ICT to QC,t must pass through some state in QC,t\u22121, it follows that\n\u03b1[q] = \u2211\n\u03c0\u2208P [QC,t\u22121,q] \u03c0 valid\n\u03b1[src[\u03c0]]w[\u03c0]\n= \u2211\n\u03c0\u2208P [QC,t\u22121]\n\u03b1[src[\u03c0]]w[\u03c0]\u2212 \u2211\n\u03c0\u2208P [QC,t\u22121,q] \u03c0 invalid\n\u03b1[src[\u03c0]]w[\u03c0],\nwhere a valid \u03c0 refers to a path that respects the semantic of the \u03d5-transition. The first sum in the last expression is the value computed by the standard shortest-distance algorithm, INCRSD, ignoring the semantic of the \u03d5-transition. It is also the value computed by the algorithm in the first \u201cif\u201d clause within the loop over ECT [q]. The second sum is the value computed and subtracted out from \u03b1[q] by the second \u201cif\u201d clause within the same loop, when we encounter a transition e such that \u03c3[e] 6= \u03d5. Thus, \u03b1[q] is computed correctly, and since q \u2208 QC,t is arbitrary, \u03d5-INCRSD returns \u03b1 with the correct path weights for all states in QC,t.\nNotice that the algorithm loops over every state in QC,t\u22121, including states that are the destination of \u03d5-transitions. For every state q, the algorithm loops over every transition e \u2208 E[q] and possibly looks into N\u03d5(q) consecutive\n\u03d5-transitions. If q\u2032 is the destination of a \u03d5-transition, then this will cost O(E[q\u2032]). Thus, the total computational cost is O (N\u03d5(QC,t\u22121)|E[QC,t\u22121]|).\nNotice that \u03d5-INCRSD can be straightforwardly extended to a non-incremental form that computes the shortest path to every state given a source state. We call this algorithm \u03d5-SHORTESTDISTANCE, which we will use to compute the analogue of \u03b2 in AUTOMATAWEIGHTEDMAJORITY.\nWith these two new operations, \u03d5-COMPOSITION and \u03d5-INCREMENTALSHORTESTDISTANCE, we are now ready to present \u03d5-AUTOMATAWEIGHTEDMAJORITY (\u03d5-AWM), an extension to AWM that applies to \u03d5-automata. Given an input automaton (not necessarily with \u03d5-transitions), the algorithm first calls \u03d5-CONVERT to determine whether it is beneficial to introduce \u03d5-transitions. The algorithm then composes the output with ST to compute the set of sequences of length T that are accepted by C. The algorithm then uses the new shortest-distance algorithm to perform the same weighted majority update as before. Algorithm 10 presents the pseudocode for \u03d5-AWM.\nAlgorithm 10: \u03d5-AUTOMATAWEIGHTEDMAJORITY (\u03d5-AWM). Algorithm: \u03d5-AWM(C) C\u2190 \u03d5-CONVERT(C) CT \u2190 \u03d5-COMPOSITION(C, ST ) CT \u2190 CONNECT(CT ) \u03b2 \u2190 \u03d5-SHORTESTDISTANCE((CT )R, F ) wCT [ICT ]\u2190 wCT [ICT ]/\u03b2[ICT ] \u03b1\u2190 0 Flow0 \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, 1) do\nflow[e]\u2190 \u03b2[dest[e]] Flow0[\u03c3[e]]\u2190 Flow0[\u03c3[e]] + flow[e] Z0 \u2190 Z0 + flow[e]\np1 \u2190 Flow0/Z0 for t\u2190 1 to T do\nit \u2190SAMPLE(pt) PLAY(it) RECEIVE(lt) Flowt \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, t) do\nw[e]\u2190 w[e] \u00b7 e\u2212\u03b7lt[\u03c3[e]] flow[e]\u2190 \u03b1[src[e]]w[e]\u03b2[dest[e]] Flowt[\u03c3[e]]\u2190 Flowt[\u03c3[e]] + flow[e] Zt \u2190 Zt + flow[e].\npt+1 \u2190 Flowt/Zt \u03b1\u2190 \u03d5-INCRSD(CT , t,\u03b1)\nSince the update in \u03d5-AWM is identical to the update in AWM, we immediately obtain the following guarantee for \u03d5-AWM.\nTheorem 12 (\u03d5-AUTOMATAWEIGHTEDMAJORITY Guarantee). If C\u2229 ST is normalized in the input to PBWM, then at each round t, \u03d5-AWM performs the same weighted majority update as in PBWM for unweighted regret. Moreover, the computational complexity of \u03d5-AWM at each round t is O (|N\u03d5(QCT ,t\u22121)E[QCT ,t]|), so that the total computational cost is O (\u2211T t=1N\u03d5(QCT ,t\u22121)|E[QCT ,t]| ) .\nFor the k-shifting automaton, the per-iteration computational complexity of \u03d5-AWM is now O(Nk), since there is at most one consecutive \u03d5-transition in the output of \u03d5-Convert, and we now aggregate transitions at each time using failure transitions. This is a factor of N better than that of AWM, and only a factor of k worse than the specific algorithm of Herbster and Warmuth [1998]. Using a bigram approximation of the k-shifting automaton composed with ST and then introducing converting it into a \u03d5-automaton, we obtain an algorithm that runs in O(N)."}, {"heading": "10 Composition of multiple \u03d5-automata", "text": "In many cases, it may be more convenient and, in some instances, more efficient to define C as the composition (intersection) of multiple automata, each represented with failure transitions. While the composition algorithms discussed above are correct for composing an automaton with failure transitions with an automaton without failure transitions, they are not guaranteed to be accurate when composing two \u03d5-automata. Specifically, in the process of matching transitions, the composition algorithm may produce multiple \u03d5-paths between two states. See Figure 10 for an example.\nHaving redundant \u03d5-paths is problematic because it can lead to incorrect weight computations. Specifically, we may associate extra paths to a given string due to multiple \u03d5-paths. As a consequence, we may also assign extra weight to this string.\nTo avoid this situation, we introduce the concept of a \u03d5-filter, which is a mechanism that can filter out all but one \u03d5-path between any two states. As we shall see, this \u03d5-filter can be implemented as composition with a particular finite-state transducer (FST).\nRecall that a finite-state transducer is a finite automaton in which each transition is augmented with an output label. We denote the input label of a transition e as i[e], the output label as o[e], and the label pair as (i[e] : o[e]). The output labels are concatenated along a path to form an output sequence, so that any accepting path has an associated output string. A finite automaton can be interpreted as a finite-state transducer whose input and output labels coincide for each transition. As with finite automata, finite-state transducers can also be augmented with weights, and as with weighted finite automata, weighted finite-state transducers can be composed efficiently and on-demand [Mohri, 2009].\nThe reason why redundant \u03d5-paths are generated by standard composition algorithms is similar to the reason why redundant -paths are generated during composition of automata without failure transitions [Allauzen and Mohri, 2008].\nWhen the algorithm is in state q in WFA C and state q\u0303 in C\u0303, both of which contain outgoing \u03d5-transitions, the algorithm may take any of the following steps: (1) move forward on a \u03d5-transition in C while staying at q\u0303; (2) move forward on a \u03d5-transition in C\u0303 while staying in C; or (3) move forward in both C and C\u0303.\nTo design a \u03d5-filter, we first modify the two input automata C1 and C2 to distinguish between these two cases. In C1, for every \u03d5-transition, we rename the label \u03d5 as \u03d52. Moreover, at the source and destination states of every \u03d5-transition, we introduce new self-loop transitions labeled with \u03d51 and with weight 1. Thus, a transition labeled with \u03d52 will indicate a \u201cmove forward,\u201d while a transition labeled with \u03d51 will indicate a \u201cstay.\u201d Similarly, in C2, we rename the \u03d5 labels as \u03d51, and we introduce self-loops labeled with \u03d52 and weight 1 at the source and destination states of every \u03d5-transition. With these modifications, any \u03d5-path resulting from the composition algorithm will include transitions of the form: (1) (\u03d52 : \u03d52); (2) (\u03d51 : \u03d51); or (3) (\u03d52 : \u03d51). This observation guides us in designing a \u03d5-filter that will eliminate redundant paths.\nTheorem 13 (Correctness of \u03d5-filter F). Let F be the finite-state transducer illustrated in Figure 12. Then, C1 \u25e6 F \u25e6 C2 is weighted transducer equivalent to C\u03031 \u25e6 C\u03032, where C\u0303i is the weighted transducer obtained from Ci by \u201cremoving\u201d \u03d5-transitions.\nProof. Notice first that there is at most one shortest \u03d5-path that takes (\u03d52 : \u03d51) transitions first. Now, we claim that if a filter disallows the following subpaths:\n{(\u03d52 : \u03d52)(\u03d51 : \u03d51), (\u03d51 : \u03d51)(\u03d52 : \u03d52), (\u03d51 : \u03d51)(\u03d52 : \u03d51), (\u03d52 : \u03d52)(\u03d52 : \u03d51)},\nthen the filter will only contain \u03d5-paths between states that are the shortest and contain (\u03d52 : \u03d51) transitions first. To see this, suppose that the filter allowed a path that wasn\u2019t the shortest path or didn\u2019t contain (\u03d52 : \u03d51) transitions first. If this path wasn\u2019t the shortest path but contained all (\u03d52 : \u03d51) transitions first, then it must contain both transitions of the form (\u03d52 : \u03d52) and (\u03d51 : \u03d51) after (\u03d52 : \u03d51) transitions. But this implies that this path also contains consecutive transitions of the form (\u03d52 : \u03d52)(\u03d51 : \u03d51) or (\u03d51 : \u03d51)(\u03d52 : \u03d52), which are two of the disallowed subpaths. If the path didn\u2019t contain (\u03d52 : \u03d51) transitions first, then it must begin with a transition labeled with (\u03d51 : \u03d51) or (\u03d52 : \u03d52). At some point, the path must include (\u03d52 : \u03d51), which would constitute one of the disallowed subpaths.\nFinally, we now show that a filter carrying the above properties can be represented as a finite-state transducer. Notice that the set of forbidden sequences can be represented by the transducer shown in Figure 11, and by the language:\nL = \u03c3\u2217 ( (\u03d52 : \u03d52)(\u03d51 : \u03d51) + (\u03d51 : \u03d51)(\u03d52 : \u03d52)\n+ (\u03d51 : \u03d51)(\u03d52 : \u03d51) + (\u03d52 : \u03d52)(\u03d52 : \u03d51)\n) \u03c3\u2217,\nwhere \u03c3 = {(a, a)}a\u2208\u03a3 \u222a {(\u03d52 : \u03d51), (\u03d51 : \u03d51), (\u03d52 : \u03d52)}. Since L is a regular language, its complement, L\u0304, is also a regular language and can be represented as an automaton that is the result of determinimization and complementation of an automaton accepting L. This automaton is shown in Figure 12.\nFigure 11 illustrates the automaton accepting the language L in the proof of Theorem 13. We define our \u03d5-filter F as the finite state transducer induced by the automaton obtained after determinization and complementation of the automaton in Figure 11. This new FST is illustrated in Figure 12.\nNotice that the composition of any two \u03d5-automata and the \u03d5-filter F, C1 \u25e6 F \u25e6 C2, will result in a finite-state transducer whose transitions have labels in {(a : a)}a\u2208\u03a3 \u222a {(\u03d52 : \u03d52), (\u03d51 : \u03d51), (\u03d52 : \u03d51)}. Moreover, we identify all label pairs in {(\u03d52 : \u03d52), (\u03d51 : \u03d51), (\u03d52 : \u03d51)} using the same semantic of \u201cother\u201d as we did with \u03d5. Thus, we can identify all label pairs in {(\u03d52 : \u03d52), (\u03d51 : \u03d51), (\u03d52 : \u03d51)} with the single pair (\u03d5 : \u03d5) and treat the result of composition as simply a weighted finite automaton.\nWe are now ready to present a general \u03d5-composition algorithm that is able to compose two \u03d5-automata correctly. This composition algorithm will take as input three weighted finite-state transducers, two corresponding to the \u03d5-automata, C1 and C2 and one corresponding to the \u03d5-filter, F, and it will output C1 \u25e6 FC2. A straightforward implementation would be to recursively compose two transducers at a time (e.g. C1 \u25e6 FC2 = (C1 \u25e6 F) \u25e6 C2)). However, we can improve upon this by extending the 3-way composition technique presented in [Allauzen and Mohri, 2008] to our \u03d5-automata setting. This algorithm, GENERAL-\u03d5-COMPOSITION, is given as Algorithm 11. Instead of composing\ntwo automata at a time by matching transitions, this algorithm uses a lateral strategy to compose all three automata at once. Specifically, it first considers pairs of transitions in C1 \u00d7 C2, and then it searches for matching transitions in F.\nAs in the original 3-way composition algorithm, we can pre-process the \u03d5-filter F using perfect hashing in expected linear time O(|EF|) so that candidate transition sets E can be found in worst-case linear time O(|E|). In this way, the worst-case running-time of GENERAL-\u03d5-COMPOSITION is in\nO ( |QC|max\nq\u2208C1 |EC1 [q]|max q\u2208C2 |EC2 [q]|+ |EC|\n) .\nThe algorithms described above are general. While the k-shifting automaton was used as a running example, the algorithms \u03d5-Convert, \u03d5-AWM, and n-GRAMSELECT can be applied to any weighted finite automaton. In practice, this automaton can even be learned from data and on-demand over a series of epochs. Given a set of experts, we can learn a language model over the sequences to determine which ones have performed well in the past. We can represent this language model using a WFA. We can then convert it into a \u03d5-WFA or first an n-gram model and then a \u03d5-WFA to learn against it in a computationally efficient way. As we learn using this \u03d5-WFA, we can also simultaneously learn another language model over sequences that we can use in the next epoch."}, {"heading": "11 Extension to sleeping experts", "text": "In many real-world applications, it may be natural for some experts to abstain from making predictions on some of the rounds. For instance, in a bag-of-words model for document classification, the presence of a feature or subset of features in a document can be interpreted as an expert that is awake. This extension of standard prediction with expert advice is also known as the sleeping experts framework [Freund et al., 1997]. The experts are said to be asleep when they are inactive and awake when they are active and available to be selected. This framework is distinct from the\nAlgorithm 11: GENERAL-\u03d5-COMPOSITION. Algorithm: GENERAL-\u03d5-COMPOSITION(C1, C2, F) Q\u2190 IC1 \u00d7 IF \u00d7 IC2 Q \u2190 IC1 \u00d7 IF \u00d7 IC2 while Q 6= \u2205 do\nq = (q1, qF, q2)\u2190 HEAD(Q) DEQUEUE(Q) if q \u2208 IC1 \u00d7 IF \u00d7 IC2 then\nI \u2190 I \u222a {q} \u03bb(q)\u2190 \u03bbC1(q1)\u03bbC2(q2)\nif q \u2208 FC1 \u00d7 FF \u00d7 FC2 then F \u2190 FCT \u222a {q} \u03c1[q]\u2190 \u03c1C1 [q1]\u03c1C2 [q2] for each (e1, e2) \u2208 EC1 \u00d7 EC2 do if \u03c3[e1] = \u03d5 then\n\u03c3[e1]\u2190 \u03d52. EC1 \u2190 EC1 \u222a (q1, \u03d51, 1, q1) if (dest[e1], \u03d51, 1,dest[e1]) /\u2208 EC1 then\nEC1 \u2190 EC1 \u222a (dest[e1], \u03d51, 1,dest[e1]) if \u03c3[e2] = \u03d5 then\n\u03c3[e2]\u2190 \u03d51 EC2 \u2190 EC2 \u222a (q2, \u03d52, 1, q2) if (dest[e2], \u03d52, 1,dest[e2]) /\u2208 EC2 then\nEC2 \u2190 EC2 \u222a (dest[e2], \u03d52, 1,dest[e2]) E \u2190 {e \u2208 EF : i[e] = \u03c3[e1] \u2227 o[e] = \u03c3[e2]}. for each eF \u2208 E do\nif q\u0303 = (dest[e1],dest[eF],dest[e2]) /\u2208 Q then Q\u2190 Q \u222a {q\u0303} ENQUEUE(Q, q\u0303) if \u03c3[e1] \u2208 {\u03d51, \u03d52} then s\u2190 \u03d5 else s\u2190 \u03c3[e1]\nE \u2190 E ] {(q, s, w[e1]w[e2], q\u0303)} C\u2190 (\u03a3, Q, I, F,E, \u03bb, \u03c1) return C\npermutation-based definitions adopted in the studies in [Kleinberg et al., 2010, Kanade et al., 2009, Kanade and Steinke, 2014].\nFormally, at each round t, the adversary chooses an awake set At \u2286 \u03a3 from which the learner is allowed to query an expert. The algorithm then (randomly) chooses an expert it from At, receives a loss vector lt \u2208 [0, 1]|\u03a3| supported on At and incurs loss lt[it]. Since some experts may not be available in some rounds, it is not reasonable to compare the loss against that of the best static expert or sequence of experts. In [Freund et al., 1997], the comparison is made\nagainst the best fixed mixture of experts normalized at each round over the awake set: minu\u2208\u2206N \u2211T t=1 \u2211 i\u2208At uilt[i]\u2211 j\u2208At uj .\nWe extend the notion of sleeping experts to the path setting, so that instead of comparing against fixed mixtures over experts, we compare against fixed mixtures over the family of expert sequences. With some abuse of notation, let At also represent the automaton accepting all paths of length T whose t-th transition has label in At. Thus, we want to design an algorithm that performs well with respect to the following quantity:\nmin u\u2208\u2206|CT | T\u2211 t=1 \u2211 \u03c0\u2208CT\u2229At u\u03c0lt[\u03c3t[\u03c0]]\u2211 \u03c0\u2208CT\u2229At uj .\nThis motivates the design of AWAKEPBWM, a path-based weighted majority algorithm that generalizes the algorithms in [Freund et al., 1997] to arbitrary families of expert sequences. Like PBWM, AWAKEPBWM maintains\na set of weights over all the paths in the input automaton. At each round t, the algorithm performs a weighted majority-type update. However, it normalizes the weights so that the total weight of the awake set remains unchanged. This prevents the algorithm from \u201coverfitting\u201d to experts that have been asleep for many rounds. The pseudocode of this algorithm is presented as Algorithm 12, and its accompanying guarantee is given in Theorem 14, whose proof is in Appendix 14.\nAlgorithm 12: AWAKEPATH-BASEDWEIGHTEDMAJORITY(AWAKEPBWM). Algorithm: AWAKEPBWM(C \u2229 ST , v\u03031), where v\u03031 \u2208 RK+ is a vector of initial path weights. \u03c0 \u2190 C \u2229 ST K \u2190 |C \u2229 ST | N \u2190 |\u03a3| for j = 1 to K do\np\u03031,j \u2190 v\u03031,j\u2211K i=1 v\u03031,i\nfor j = 1 to N do p1,j \u2190 \u2211 i\u2208[1,K] : \u03c0i,1=j p\u03031,i for t = 1 to T do RECEIVE(At) for j = 1 to N do\npAtt,j \u2190 pt,j\u2211 i\u2208At pt,i .\nit \u2190SAMPLE(pAtt ) PLAY(it) RECEIVE(lt) for j = 1 to K do\nv\u0303t+1,j \u2190 v\u0303t,je\u2212\u03b7lt[\u03c0j,t] p\u0303t+1,j \u2190 v\u0303t+1,j\u2211K i=1 v\u0303t+1,i\nfor j = 1 to N do p\u2020t+1,j \u2190 \u2211 i\u2208[1,K] : \u03c0i,t=j p\u0303t+1,i for j = 1 to N do pt+1,j \u2190 p\u2020t+1,j \u2211 i\u2208At\npt,i\u2211 i\u2208At p\u2020t+1,i\nTheorem 14 (Regret Bound for AWAKEPBWM). Let v\u03031,j = 1 for every j \u2208 [K] be the initial path weights in the AWAKEPBWM algorithm. For each t \u2208 [T ], let At \u2282 \u03a3 denote the set of experts that are awake at time t. Then for any distribution u on \u03a3, AWAKEPBWM admits the following unweighted regret guarantee:\nT\u2211 t=1 u(At) E i\u223cpAtt [lt[i]]\u2212 \u2211 i\u2208At uilt[\u03c0i,t] \u2264 \u03b7 8 T\u2211 t=1 u(At) + 1 \u03b7 log(K).\nAs with PBWM, the per-iteration computational complexity of AWAKEPBWM is in O(|CT |), the number of paths in consideration. We improve upon this by extending AWM to the sleeping expert setting and designing a new algorithm called AWAKEAWM. The key modification in AWAKEAWM is that during the flow computations, we intersect the set of available edges with At before performing the weight update. This intersection can be performed while preserving the favorable computational complexity of AWM, which depends on the states in CT reachable at times t times the maximum out-degree of any state. Algorithm 13 provides the pseudocode for AWAKEAWM. As in the non-sleeping expert setting, we can further improve the computational complexity by applying \u03d5-conversion to arrive at a or n-gram approximation and then \u03d5-conversion. All other improvements in the sleeping expert setting will similarly mirror those in the non-sleeping expert algorithms.\nAlgorithm 13: AWAKEAUTOMATAWEIGHTEDMAJORITY(AwakeAWM). Algorithm: AWAKEAWM(C) CT \u2190 C \u2229 ST CT \u2190 CONNECT(CT ) \u03b2 \u2190 SHORTESTDISTANCE((CT )R, F ) wCT [ICT ]\u2190 wCT [ICT ]/\u03b2[ICT ] \u03b1\u2190 0 Flow0 \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, 1) do\nflow[e]\u2190 \u03b2[dest[e]] Flow0[\u03c3[e]]\u2190 Flow0[\u03c3[e]] + flow[e] Z0 \u2190 Z0 + flow[e]\np1 \u2190 Flow0/Z0 for t\u2190 1 to T do\nRECEIVE(At) PAtt \u2190 \u2211 j\u2208At pt[j] for each i \u2208 At do pAtt [i]\u2190 pt[i]/P At t it \u2190SAMPLE(pAtt ) PLAY(it) RECEIVE(lt) Flowt \u2190 0 for each e \u2208 ECT with dest[e] = (\u00b7, t) do\nif \u03c3[e] \u2208 At then w[e]\u2190 w[e] \u00b7 e\u2212\u03b7lt[\u03c3[e]] flow[e]\u2190 \u03b1[src[e]]w[e]\u03b2[dest[e]] Flowt[\u03c3[e]]\u2190 Flowt[\u03c3[e]] + flow[e] ZAtt \u2190 0 if \u03c3[e] \u2208 At then\nZAtt \u2190 Z At t + flow[e]\npt+1 \u2190 Flowt P At t\nZ At t\n\u03b1\u2190 INCRSD(CT , t,\u03b1)"}, {"heading": "12 Extension to online convex optimization", "text": "We now illustrate how the framework described in this paper can be extended to the general online convex optimization (OCO) setting. Online convex optimization is a sequential prediction game over a compact convex action space K. At each round t, the learner plays an action xt \u2208 K and receives a convex loss function ft. The goal of the learner is to minimize the regret against the best static loss:\nT\u2211 t=1 ft(xt)\u2212min z\u2208K T\u2211 t=1 ft(z).\nAs in the framework introduced above, we can generalize this notion of regret to one against families of sequences. Specifically, let CT \u2286 KT be a closed subset, let pCT be a distribution over CT , and and let uCT be the uniform distribution over CT . The uniform distribution is well-defined, since K being a compact set implies that KT is compact. Then we would like to compete against the following regret against pCT :\nRegT (A,CT ) = max zT1 \u2208CT T\u2211 t=1 ft(xt)\u2212 ft(zt) + log ( pCT (z T 1 ) uCT ) . (10)\nIf pCT is uniform, then the last term vanishes.\nWhen CT = KT is the family of all sequences of length T and pCT is the uniform distribution, this problem has been studied in [Hall and Willett, 2013, Gyo\u0308rgy and Szepesva\u0301ri, 2016]. In both works, the authors introduce a variant of mirror descent which applies a mapping after the standard mirror descent update, which is called DYNAMICMIRRORDESCENT in the first algorithm.\nSpecifically, if gt \u2208 \u2202ft(xt) is an element of the subgradient, and D\u03c8 is the Bregman divergence induced by a mirror map \u03c8, then DYNAMICMIRRORDESCENT consists of the update rule:\nx\u0303t+1 \u2190 argmin x\u2208K \u3008gt, x\u3009+D\u03c8(x, xt)\nxt+1 \u2190 \u03a6t(x\u0303t+1).\nIn this algorithm, \u03a6t is an arbitrary mapping that is specified by the learner at time t. Under certain assumptions on the loss functions, \u03a8, and \u03a6t, DYNAMICMIRRORDESCENT achieves the following regret guarantee against the competitor distribution pCT :\nTheorem 15 (DYNAMICMIRRORDESCENT regret against CT ). Suppose that the \u03a6ts chosen in DYNAMICMIRRORDESCENT are non-expansive under the Bregman divergence D\u03c8:\nD\u03c8(\u03a6t(x),\u03a6t(y)) \u2264 D\u03c8(x, y), \u2200x, y \u2208 K.\nFurthermore, assume that ft is uniformly L-Lipschitz in the norm \u2016 \u00b7 \u2016 and that \u03a8 is 1-strongly convex in the same norm. Let x1 \u2208 K be given and define Dmax = supz\u2208KD\u03c8(z, x1). Then, DYNAMICMIRRORDESCENT achieves the following regret guarantee:\nRegT (A,CT ) \u2264 Dmax \u03b7 + \u03b7 2 T\u2211 t=1 \u2016gt\u20162 + max zT1 \u2208CT { log ( pCT (z T 1 ) uCT )\n+ 2\n\u03b7 T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u2207\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009 } .\nThe proof of this result follows along similar lines as the original result by [Hall and Willett, 2013]. The major difference is that the authors in that work assume \u03a8 to be Lipschitz. This allows them to derive a slightly weaker but more interpretable bound. However, it is also an assumption that we specifically choose to avoid, since mirror descent algorithms including the EXPONENTIATED GRADIENT use mirror maps that are not Lipschitz. Hall and Willett [2013] also derive a bound for standard regret as opposed to regret against a distribution of sequences.\nThe first two terms in the regret bound are standard in online convex optimization, and the last term is the price of competing against arbitrary sequences. Note that Gyo\u0308rgy and Szepesva\u0301ri [2016] present the same algorithm but with a different analysis and upper bound.\nProof. By standard properties of the Bregman divergence and convexity, we can compute\nT\u2211 t=1 ft(xt)\u2212 ft(zt) = T\u2211 t=1 ft(xt)\u2212 ft(zt) + ft(x\u0303t+1)\u2212 ft(x\u0303t+1)\n\u2264 1 \u03b7 \u3008\u2207\u03c8(xt)\u2212\u2207\u03c8(x\u0303t+1), x\u0303t+1 \u2212 zt\u3009+ ft(xt)\u2212 ft(x\u0303t+1)\n= 1\n\u03b7 [D\u03c8(zt, xt)\u2212D\u03c8(zt, x\u0303t+1)\u2212D\u03c8(x\u0303t+1, xt)] + ft(xt)\u2212 ft(x\u0303t+1)\n= 1\n\u03b7\n[ D\u03c8(zt, xt)\u2212D\u03c8(zt+1, xt+1) +D\u03c8(zt+1, xt+1 \u2212D\u03c8(\u03a6t(zt), xt+1)\n\u2212D\u03c8(zt, x\u0303t+1) +D\u03c8(\u03a6t(zt), xt+1)\u2212D\u03c8(x\u0303t+1, xt) ]\n+ ft(xt)\u2212 ft(x\u0303t+1).\nSince \u03a6t is assumed to be non-expansive and xt+1 = \u03a6t(xt+1), it follows that\u2212D\u03c8(zt, x\u0303t+1)+D\u03c8(\u03a6t(zt), xt+1 \u2264 0.\nSince \u03a8 is 1-strongly convex with respect to \u2016 \u00b7 \u2016, it follows that D\u03c8(x\u0303t+1, xt) \u2265 12\u2016x\u0303t+1 \u2212 xt\u2016 2. Thus, we can\ncompute\n\u2212 1 \u03b7 D\u03c8(x\u0303t+1, xt) + ft(xt)\u2212 ft(x\u0303t+1)\n\u2264 \u2212 1 2\u03b7 \u2016x\u0303t+1 \u2212 xt\u20162 + ft(xt)\u2212 ft(x\u0303t+1)\n\u2264 \u2212 1 2\u03b7 \u2016x\u0303t+1 \u2212 xt\u20162 + \u2016gt\u2016\u2217\u2016xt \u2212 x\u0303t+1\u2016\n\u2264 \u2212 1 2\u03b7 \u2016x\u0303t+1 \u2212 xt\u20162 + \u03b7 2 \u2016gt\u20162\u2217 + 1 2\u03b7 \u2016xt \u2212 x\u0303t+1\u20162 = \u03b7\n2 \u2016gt\u20162\u2217.\nMoreover, we can also write\nD\u03c8(zt+1, xt+1 \u2212D\u03c8(\u03a6t(zt), xt+1) = \u03c8(zt+1)\u2212 \u03c8(xt+1)\u2212 \u3008\u2207\u03c8(xt+1), zt+1 \u2212 xt+1\u3009\n[\u03c8(\u03a6t(zt))\u2212 \u03c8(xt+1)\u2212 \u3008\u2207\u03c8(xt+1),\u03a6t(zt)\u2212 xt+1\u3009] = \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009.\nCombining this inequality with the inequality above yields\nT\u2211 t=1 ft(xt)\u2212 ft(zt)\n\u2264 1 \u03b7 T\u2211 t=1 D\u03c8(zt, xt)\u2212D\u03c8(zt+1, xt+1)\n+ T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009+ 1 \u03b7 T\u2211 t=1 \u03b7 2 \u2016gt\u20162\u2217\n\u2264 1 \u03b7 D\u03c8(z1, x1) + T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009\n+ 1\n\u03b7 T\u2211 t=1 \u03b7 2 \u2016gt\u20162\u2217.\nAdding in log ( pCT (z T 1 )\nuCT\n) to both sides and taking the max over zT1 \u2208 CT completes the proof.\nBy restricting our competitor set to CT and adding the penalization term, it follows that DYNAMICMIRRORDESCENT achieves the following guarantee:\nmax zT1 \u2208CT T\u2211 t=1 ft(xt)\u2212 ft(zt) + log ( pCT (z T 1 ) uCT )\n\u2264 Dmax \u03b7 + \u03b7 2 T\u2211 t=1 \u2016gt\u20162 + max zT1 \u2208CT\n{ log ( pCT (z T 1 )\nuCT\n)\n+ 2\n\u03b7 T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u2207\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009\n} .\nThis bound suggests that if we are able to find a sequence (\u03a6t)Tt=1 that minimizes the last quantity, then we can tightly bound our regret. Now let F be a family of dynamic maps \u03a6 that are non-expansive with respect to D\u03c8 . Then we want\nto solve the following optimization problem:\nmin \u03a6T1 \u2208FT max zT1 \u2208CT\n{ log ( pCT (z T 1 )\nuCT\n)\n+ 2\n\u03b7 T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8(\u03a6t(zt))\u2212 \u3008\u2207\u03c8(xt+1), zt+1 \u2212 \u03a6t(zt)\u3009\n} . (11)\nWe can view this as the online convex optimization analogue of the automata approximation problem in Section 7, and we can use it in the same way to derive concrete online convex optimization algorithms that achieve good regret against more complex families of sequences.\nAs an illustrative example, we apply this to the k-shifting experts setting and show how a candidate solution to this problem recovers the FIXED-SHARE algorithm."}, {"heading": "12.1 OCO derivation of FIXED-SHARE", "text": "Suppose that we are again in the prediction with expert advice setting so thatK = \u2206N and ft(x) = \u3008lt, x\u3009. Assume that CT is the set of k-shifting experts and that pCT is the uniform distribution on CT . As for the weighted majority algorithm, let \u03a8 = \u2211N i=1 xi log(xi) be the negative entropy so that D\u03c8(x, y) = \u2211N i=1 xi log ( xi yi ) is the relative entropy. One way of ensuring that \u03a6t is non-expansive is to define it to be a mixture with a fixed vector: \u03a6t(x) = (1\u2212 \u03b1t)x+ \u03b1twt for some wt \u2208 \u2206N and \u03b1t \u2208 [0, 1]. By convexity of the relative entropy, it follows that for any x, y \u2208 \u2206N , D\u03c8(\u03a6t(x),\u03a6t(y)) \u2264 D\u03c8(x, y).\nFor simplicity, we can assume that \u03a6t = \u03a6. Then Problem 11 can be written as:\nmin w\u2208\u2206N ,\u03b1\u2208[0,1] max zT1 \u2208CT\n{ 2\n\u03b7 T\u2211 t=1 \u03c8(zt+1)\u2212 \u03c8((1\u2212 \u03b1)zt + \u03b1w)\n\u2212 \u3008\u2207\u03c8((1\u2212 \u03b1)x\u0303t+1 + \u03b1w), zt+1 \u2212 (1\u2212 \u03b1)zt \u2212 \u03b1w\u3009 } .\nSince CT is symmetric across coordinates and we do not have a priori knowledge of of x\u0303t+1, a reasonable choice of w is the uniform distribution wi = 1N . We can also use the fact that the entropy function is convex to obtain the upper bound: \u2212\u03c8((1 \u2212 \u03b1)zt + \u03b1w) \u2264 \u2212(1 \u2212 \u03b1)\u03c8(z) \u2212 \u03b1\u03c8(w). Moreover, since zt is always only supported on a single coordinate, \u03c8(zt) = 0 for every t.\nThis reduces to the following optimization problem:\nmin \u03b1\u2208[0,1] max zT1 \u2208CT\n{ 2\n\u03b7 T\u2211 t=1 \u03b1 log(N)\n\u2212 N\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N )[ zt+1,i \u2212 (1\u2212 \u03b1)zt,i \u2212 \u03b1 1 N ]} .\nWe can break the objective into three separate terms:\nA1 : 2\n\u03b7 T\u2211 t=1 \u03b1 log(N)\nA2 : \u2212 T\u2211 t=1 N\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N ) [zt+1,i \u2212 zt,i]\nA3 : \u2212 T\u2211 t=1 N\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N ) \u03b1 [ zt,i \u2212 1 N ]\nIt is straightforward to see that A1 = 2\u03b7T\u03b1 log(N). To bound A2, let it \u2208 [N ] be the index such that zt,it = 1 and zt,i = 0 for all i 6= it. Then,\n\u2212 T\u2211 t=1 N\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N ) [zt+1,i \u2212 zt,i]\n= \u2212 \u2211\nt:it+1 6=it\nN\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N ) [zt+1,i \u2212 zt,i]\n\u2264 \u2212 \u2211\nt:it+1 6=it\nN\u2211 i=1 log ( \u03b1 1 N ) zt+1,i\n\u2264 \u2212k log ( \u03b1 N ) .\nTo bound A3, we can write\n\u2212 \u03b1 T\u2211 t=1 N\u2211 i=1 log ( (1\u2212 \u03b1)x\u0303t+1,i + \u03b1 1 N )[ zt,i \u2212 1 N ]\n= \u2212\u03b1 T\u2211 t=1 log ( (1\u2212 \u03b1)x\u0303t+1,it + \u03b1 1 N )[ 1\u2212 1 N ] \u2264 \u2212\u03b1T log ( \u03b1 1\nN\n) .\nPutting the pieces together, the objective is bounded by\n2\n\u03b7\n( T\u03b1 log(N)\u2212 k log ( \u03b1 N ) \u2212 \u03b1T log ( \u03b1 N )) ,\nleading to the new optimization problem:\nmin \u03b1\u2208[0,1]\n2\n\u03b7\n( T\u03b1 log(N)\u2212 k log ( \u03b1 N ) \u2212 \u03b1T log ( \u03b1 N )) .\nNotice that \u03b1 \u221d kT is a reasonable solution, as it bounds the regret by O ( k log ( NT k )) .\nMoreover, this choice of \u03b1 approximately corresponds to FIXED-SHARE. Thus, we have again derived the FIXEDSHARE algorithm from first principles in consideration of only the k-shifting expert sequences. This is in contrast to previous work for DYNAMICMIRRORDESCENT (e.g. [Gyo\u0308rgy and Szepesva\u0301ri, 2016]) which only showed that one could define \u03a6t in a way that mimics the FIXED-SHARE algorithm."}, {"heading": "13 Conclusion", "text": "We studied a general framework of online learning against a competitor class represented by a weighted automaton and showed that sublinear regret guarantees can be achieved in this scenario.\nWe gave a series of algorithms for this problem, including an automata-based algorithm extending weighted-majority whose computational cost at round t depends on the total number of transitions leaving the states of the competitor automaton reachable at time t, which substantially improves upon a na\u0131\u0308ve algorithm based on path updates. We used the notion of failure transitions to provide a compact representation of the competitor automaton or its intersection with the set of strings of length t, thereby resulting in significant efficiency improvements. This required the introduction of new failure-transition-based composition and shortest-distance algorithms that could be of independent interest.\nWe further gave an extensive study of algorithms based on a compact approximation of the competitor automata. We showed that the key quantity arising when using an approximate weighted automaton is the Re\u0301nyi divergence of the original and approximate automata. We presented a specific study of approximations based on n-gram models by minimizing the Re\u0301nyi divergence and studied the properties of maximum likelihood n-gram models. We pointed out\nthe efficiency benefits of such approximations and provides guarantees on the approximations and the regret. We also extended our algorithms and results to the framework of sleeping experts. We further described the extension of the approximation methods to online convex optimization and a general mirror descent setting.\nOur description of this general (weighted) regret minimization framework and the design of algorithms based on automata provides a unifying view of many similar problems and leads to general algorithmic solutions applicable to a wide variety of problems with different competitor class automata. In general, automata lead to a more general and cleaner analysis. An alternative approximation method consists of directly minimizing the competitor class automaton before intersection with the set of strings of length t. We have also studied that method, presented guarantees for its success, and illustrated the approach in a special case.\nNote that, instead of automata and regular languages, we could have considered more complex formal language families such as (probabilistic) context-free languages over expert sequences. However, more complex languages can be handled in a similar way since the intersection with ST would be a finite language. The method based on a direct approximation would require approximating a probabilistic context-free language using weighted automata, a problem that has been extensively studied in the past [Pereira and Wright, 1991, Nederhof, 2000, Mohri and Nederhof, 2001].\nFinally, all our results can be straightforwardly extended to the adversarial bandit scenario using standard surrogate losses based on importance weighting techniques."}, {"heading": "14 Additional proofs", "text": ""}, {"heading": "14.1 Proof of Theorem 1", "text": "Proof. We will use a standard potential function-based argument. Let \u03a6t be the potential defined by: \u03a6t = log (\u2211K\nj=1 v\u0303t,j\n) . Then\n\u03a6t \u2212 \u03a6t\u22121 = log\n(\u2211K j=1 e\n\u2212\u03b7lt[\u03c0j,t]v\u0303t\u22121,j\u2211K j=1 v\u0303t\u22121,j\n) = log ( E\nj\u223cp\u0303t\n[ e\u2212\u03b7lt[\u03c0j,t] ]) \u2264 E j\u223cp\u0303t [(\u2212\u03b7)lt[\u03c0j,t]] + \u03b72 = E i\u223cpt [(\u2212\u03b7)lt[i]] + \u03b72.\nSumming over t results in the following upper bound:\n\u03a6T \u2212 \u03a61 \u2264 T\u2211 t=1 E i\u223cpt [(\u2212\u03b7)lt[i]] + \u03b72T.\nWe can also straightforwardly derive a lower bound for the same quantity:\n\u03a6T \u2212 \u03a61 = log  K\u2211 j=1 v\u0303T,j \u2212 log  K\u2211 j=1 v\u03031,j  \u2265 log (v\u0303T,j)\u2212 log  K\u2211 j=1 v\u03031,j  = \u2212\u03b7\nT\u2211 t=1 lt[\u03c0j,t] + \u03b7 log(v\u03031,j)\u2212 log  K\u2211 j=1 v\u03031,j  . Combining the two statements above yields\n\u2212\u03b7 T\u2211 t=1 lt[\u03c0j,t] + \u03b7 log(v\u03031,j)\u2212 log  K\u2211 j=1 v\u03031,j  \u2264 E i\u223cpt [(\u2212\u03b7)lt[i]] + \u03b72T,\nwhich can be rearranged as\nT\u2211 t=1 E i\u223cpt [lt[i]]\u2212 T\u2211 t=1 lt[\u03c0j,t] \u2264 \u03b7T + 1 \u03b7 log ( 1 v\u03031,j ) + 1 \u03b7 log  K\u2211 j=1 v\u03031,j  . If v\u03031,j = 1 for all j \u2208 [1,K], then the first result can be computed in a straightforward manner. If v\u03031,j = w[\u03c0j ]\u03b7 , then it follows that\nT\u2211 t=1 E i\u223cpt [lt[i]]\u2212 T\u2211 t=1 lt[\u03c0j,t] \u2264 \u03b7T + log ( 1 w[\u03c0j ] ) + 1 \u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7  , which implies that\nT\u2211 t=1 E i\u223cpt [lt[i]]\u2212 T\u2211 t=1 lt[\u03c0j,t] + log (w[\u03c0j ]|C \u2229 ST |) \u2264 \u03b7T + 1 \u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7|C \u2229 ST |\u03b7  . When \u2211K j=1 w[\u03c0j ] = 1, the maximization of the last term can be written as follows in terms of the Lagrange function:\nmax w\n1 \u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7 + \u03bb K\u2211 j=1 w[\u03c0j ].\nThe partial derivatives of the objective with respect to wj must satisfy 1\u03b7 1\u2211K\nj=1 w \u03b7 j\n\u03b7w\u03b7\u22121j + \u03bb = 0, thus the solution\nverifies that wj = ( \u2212\u03bb\u03b7 \u2211K j=1 w \u03b7 j ) 1 \u03b7\u22121 , which is uniform in j. Thus, the maximizing value is wj = 1K , yielding the bound: \u03b7T + 1\u03b7 log(|C \u2229 ST |). By interpreting w as a distribution, we can consider the H\u03b7(w), the \u03b7-Re\u0301nyi entropy of w. Recall that H\u03b7(w) =\n1 1\u2212\u03b7 log (\u2211K j=1 w[\u03c0j ] ) . Thus, we can write that\n\u03b7T + 1\n\u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7|C \u2229 ST |\u03b7  = \u03b7T + 1\u2212 \u03b7 \u03b7 H\u03b7(w) + log(|C \u2229 ST |)\n= \u03b7T + 1\n\u03b7 H\u03b7(w)\u2212H\u03b7(w) + log(K).\nSince \u03b7 7\u2192 H\u03b7(w) is a decreasing function (see e.g. [Van Erven and Harremos, 2014]), it follows that \u03b7 7\u2192 \u03b7\u221a H\u03b7(w) is an increasing function that increases at least linearly. Since we assume that w is supported on more than a single point, H0(w) > 0. Thus, for any T , there exists a unique \u03b7\u2217 such that \u03b7 7\u2192 \u03b7\n\u2217\u221a H\u03b7\u2217 (w) = 1\u221a T . Moreover, it is also the case that\nfor every \u03b7 \u2264 \u03b7\u2217, \u03b7\u221a H\u03b7(w) \u2264 1\u221a T . Thus, we have that:\n\u03b7T + 1\n\u03b7 log  K\u2211 j=1 w[\u03c0j ] \u03b7|C \u2229 ST |\u03b7  \u2264 inf \u03b7\u2264\u03b7\u2217 \u03b7T + 1 \u03b7 H\u03b7(w)\u2212H\u03b7(w) + log(K)\n\u2264 2 \u221a TH\u03b7\u2217(w)\u2212H\u03b7\u2217(w) + log(K)."}, {"heading": "14.2 Proof of Lemma 1", "text": "Proof. We can compute that:\n\u2212D ( k + (1/2)\nT \u2212 1 || k T \u2212 1 ) = \u2212D ( k\nT \u2212 1\n( 1 + 1\n2k ) || k T \u2212 1 ) = ( 1 + 1\n2k\n) k\nT \u2212 1 log\nk T\u22121( 1 + 12k ) k T\u22121 +\n( 1\u2212 ( 1 + 1\n2k\n) k\nT \u2212 1\n) log\n1\u2212 kT\u22121 1\u2212 ( 1 + 12k ) k T\u22121\n= ( 1 + 1\n2k\n) k\nT \u2212 1 log\n1\n1 + 12k +\n( 1\u2212 k\nT \u2212 1 \u2212 1 2k k T \u2212 1\n) log ( 1 +\n1 2k k T\u22121\n1\u2212 kT\u22121 \u2212 1 2k k T\u22121\n)\n\u2264 ( 1 + 1\n2k\n) k\nT \u2212 1 \u2212 12k\n1 + 14k +\n( 1\u2212 k\nT \u2212 1 \u2212 1 2k k T \u2212 1\n) 1 2k k T\u22121\n1\u2212 kT\u22121 \u2212 1 2k k T\u22121\n(using log(1 + x) \u2265 x 1 + x2 and log(1 + x) < x)\n= 1\n2k\nk\nT \u2212 1\n( 1\u2212\n1 + 12k 1 + 14k\n) = \u2212 18k2 k T\u22121\n1 + 14k = \u2212 14k2 k T\u22121 2 + 14k \u2264 \u2212 1 12k(T \u2212 1) .\nSimilarly, we can also write: \u2212D ((\n1\u2212 1 2k\n) k\nT \u2212 1 || k T \u2212 1 ) = ( 1\u2212 1\n2k\n) k\nT \u2212 1 log\nk T\u22121( 1\u2212 12k ) k T\u22121 +\n( 1\u2212 ( 1\u2212 1\n2k\n) k\nT \u2212 1\n) log\n1\u2212 kT\u22121 1\u2212 ( 1\u2212 12k ) k T\u22121\n= ( 1\u2212 1\n2k\n) k\nT \u2212 1 log\n1\n1\u2212 12k +\n( 1\u2212 k\nT \u2212 1 +\n1\n2k\nk\nT \u2212 1\n) log ( 1\u2212\n1 2k k T\u22121\n1\u2212 kT\u22121 + 1 2k k T\u22121\n)\n\u2264 ( 1\n2k \u2212 1 8k2\n) k\nT \u2212 1 +\n( 1\u2212 k\nT \u2212 1 +\n1\n2k\nk\nT \u2212 1 ) \u2212 12k kT\u22121 1\u2212 kT\u22121 + 1 2k k T\u22121\n= \u2212 1 4k2 k\nT\u22121 2 = \u2212 1 8k(T \u2212 1) ."}, {"heading": "14.3 Proof of Theorem 5", "text": "Proof. Consider the mirror map \u03c8 : (\u2206N )m \u2192 R defined by \u03c8(p) = \u2211m j=1 \u2211N i=1 pj(i) log pj(i). This induces the Bregman divergence:\nB\u03c8(p,q) = m\u2211 j=1 N\u2211 i=1 pj(i) log ( pj(i) qj(i) ) .\nSince each relative entropy is 1-strongly convex with respect to the l1 norm over a single simplex, the additivity of strong convexity implies that B\u03c8 is 1-strongly convex with respect to the l1 norm defined over(\u2206N )m.\nThe update described in the theorem statement corresponds to the mirror descent update based on B\u03c8:\npt+1 = argmin p\u2208(\u2206N )m\n\u3008gt,p\u3009+B\u03c8(p,pt).\nwhere gt \u2208 \u2202(f(pt)) is an element of the subgradient of f at pt. Thus, the standard mirror descent regret bound (e.g. [Bubeck et al., 2015]) implies that\nT\u2211 t=1 f(pt)\u2212 f(p\u2217) \u2264 1 \u03b7T sup p\u2208(\u2206N )m \u03c8(p)\u2212 \u03c8(p1) + \u03b7 \u221a 2L.\nThe result now follows from the fact that \u03c8(p) \u2264 0 and \u03c8(p1) = m log(N)."}, {"heading": "14.4 Proof of Theorem 14", "text": "Proof. Given any p, q \u2208 \u2206K , let D(p||q) denote the relative entropy between p and q. Given At \u2286 \u03a3, let p(At) =\u2211 i\u2208{1,...,K} : \u03c0i,t\u2208At . We first claim that if for any path \u03c0j , \u03c0j,t /\u2208 At, then p\u0303t+1,j = p\u0303t,j . This is because \u03c0j,t /\u2208 At implies that\nwt+1,j = wt,j . Moreover, the normalization step guarantees that \u2211 i/\u2208At p\u0303t+1,i = \u2211 i/\u2208At p\u0303t,i.\nThen, for any distribution u \u2208 \u2206K , we can compute that\nD(u||p\u0303t)\u2212D(u||p\u0303t+1) = K\u2211 i=1 ui log p\u0303t+1,i p\u0303t,i\n= \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui log p\u0303t+1,i p\u0303t,i\n= \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui log p\u0303Att+1,i\np\u0303Att,i\n= \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui log p\u0303Att,i e \u2212\u03b7lt[\u03c0i,t] p\u0303Att,i \u2211K j=1 p\u0303 At t,je \u2212\u03b7lt[\u03c0j,t]\n= \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui(\u2212\u03b7lt[\u03c0i,t])\u2212 \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui log K\u2211 j=1 p\u0303Att,je \u2212\u03b7lt[\u03c0j,t]\n= \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\n\u2212\u03b7uilt[\u03c0i,t])\u2212 \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nui log E j\u223cp\u0303Att\n[ e\u2212\u03b7lt[\u03c0j,t] ] .\nBy Hoeffding\u2019s inequality, we can bound the last term by:\n\u2264 \u2211 i\u2208At \u2212\u03b7uilt[\u03c0i,t])\u2212 \u2211 i\u2208At ui\n[ E\nj\u223cp\u0303Att [\u2212\u03b7lt[\u03c0j,t]] + \u03b72 ] = \u2212\u03b7\n\u2211 i\u2208{1,...,K} : \u03c0i,t\u2208At uilt[\u03c0i,t] + \u03b7u(At) E j\u223cp\u0303Att [lt[\u03c0j,t]]\u2212 u(At)\u03b72\n= \u2212\u03b7 \u2211\ni\u2208{1,...,K} : \u03c0i,t\u2208At\nuilt[\u03c0i,t] + \u03b7u(At) E i\u223cpAtt [lt[i]]\u2212 u(At)\u03b72.\nAfter rearranging terms and summing over t, it follows that\nT\u2211 t=1 u(At) E i\u223cpAtt [lt[i]]\u2212 \u2211\ni\u2208\u2208{1,...,K} : \u03c0i,t\u2208At\nuilt[\u03c0i,t] \u2264 \u03b7 T\u2211 t=1 u(At) + 1 \u03b7 D(u||p\u03031).\nFor the unweighted regret, initializing v\u03031 = 1K implies that D(u||p\u03031) \u2264 log(K), which completes the argument."}], "references": [{"title": "A closer look at adaptive regret", "author": ["Dmitry Adamskiy", "Wouter M Koolen", "Alexey Chernov", "Vladimir Vovk"], "venue": "In International Conference on Algorithmic Learning Theory,", "citeRegEx": "Adamskiy et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Adamskiy et al\\.", "year": 2012}, {"title": "Efficient string matching: An aid to bibliographic search", "author": ["A.V. Aho", "M.J. Corasick"], "venue": "Communication of the Association for Computing Machinery,", "citeRegEx": "Aho and Corasick.,? \\Q1975\\E", "shortCiteRegEx": "Aho and Corasick.", "year": 1975}, {"title": "3-way composition of weighted finite-state transducers", "author": ["Cyril Allauzen", "Mehryar Mohri"], "venue": "In International Conference on Implementation and Application of Automata,", "citeRegEx": "Allauzen and Mohri.,? \\Q2008\\E", "shortCiteRegEx": "Allauzen and Mohri.", "year": 2008}, {"title": "Generalized algorithms for constructing statistical language models", "author": ["Cyril Allauzen", "Mehryar Mohri", "Brian Roark"], "venue": "In Proceedings of the 41st Annual Meeting on Association for Computational Linguistics-Volume", "citeRegEx": "Allauzen et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Allauzen et al\\.", "year": 2003}, {"title": "Spectral learning of general weighted automata via constrained matrix completion", "author": ["Borja Balle", "Mehryar Mohri"], "venue": "In 26th Annual Conference on Neural Information Processing Systems", "citeRegEx": "Balle and Mohri.,? \\Q2012\\E", "shortCiteRegEx": "Balle and Mohri.", "year": 2012}, {"title": "On the Rademacher complexity of weighted automata", "author": ["Borja Balle", "Mehryar Mohri"], "venue": "In International Conference on Algorithmic Learning Theory,", "citeRegEx": "Balle and Mohri.,? \\Q2015\\E", "shortCiteRegEx": "Balle and Mohri.", "year": 2015}, {"title": "Stochastic multi-armed-bandit problem with non-stationary rewards", "author": ["Omar Besbes", "Yonatan Gur", "Assaf Zeevi"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Besbes et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Besbes et al\\.", "year": 2014}, {"title": "Non-stationary stochastic optimization", "author": ["Omar Besbes", "Yonatan Gur", "Assaf Zeevi"], "venue": "Operations Research,", "citeRegEx": "Besbes et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Besbes et al\\.", "year": 2015}, {"title": "Prediction, Learning, and Games", "author": ["Nicol\u00f2 Cesa-Bianchi", "G\u00e1bor Lugosi"], "venue": null, "citeRegEx": "Cesa.Bianchi and Lugosi.,? \\Q2006\\E", "shortCiteRegEx": "Cesa.Bianchi and Lugosi.", "year": 2006}, {"title": "Improved second-order bounds for prediction with expert advice", "author": ["Nicol\u00f2 Cesa-Bianchi", "Yishay Mansour", "Gilles Stoltz"], "venue": "Machine Learning,", "citeRegEx": "Cesa.Bianchi et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Cesa.Bianchi et al\\.", "year": 2007}, {"title": "Mirror descent meets fixed share (and feels no regret)", "author": ["Nicol\u00f2 Cesa-Bianchi", "Pierre Gaillard", "G\u00e1bor Lugosi", "Gilles Stoltz"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Cesa.Bianchi et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Cesa.Bianchi et al\\.", "year": 2012}, {"title": "An empirical study of smoothing techniques for language modeling", "author": ["Stanley Chen", "Joshua Goodman"], "venue": "Technical Report,", "citeRegEx": "Chen and Goodman.,? \\Q1998\\E", "shortCiteRegEx": "Chen and Goodman.", "year": 1998}, {"title": "Transductions and repetitions", "author": ["Maxime Crochemore"], "venue": "Theoretical Computer Science,", "citeRegEx": "Crochemore.,? \\Q1986\\E", "shortCiteRegEx": "Crochemore.", "year": 1986}, {"title": "Strongly adaptive online learning", "author": ["Amit Daniely", "Alon Gonen", "Shai Shalev-Shwartz"], "venue": "In Proceedings of The 32nd International Conference on Machine Learning,", "citeRegEx": "Daniely et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Daniely et al\\.", "year": 2015}, {"title": "Using and combining predictors that specialize", "author": ["Yoav Freund", "Robert E Schapire", "Yoram Singer", "Manfred K Warmuth"], "venue": "In Proceedings of the twenty-ninth annual ACM symposium on Theory of computing,", "citeRegEx": "Freund et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Freund et al\\.", "year": 1997}, {"title": "Shifting regret, mirror descent, and matrices", "author": ["Andr\u00e1s Gy\u00f6rgy", "Csaba Szepesv\u00e1ri"], "venue": "In ICML,", "citeRegEx": "Gy\u00f6rgy and Szepesv\u00e1ri.,? \\Q2016\\E", "shortCiteRegEx": "Gy\u00f6rgy and Szepesv\u00e1ri.", "year": 2016}, {"title": "Efficient tracking of large classes of experts", "author": ["Andr\u00e1s Gyorgy", "Tam\u00e1s Linder", "G\u00e1bor Lugosi"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Gyorgy et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gyorgy et al\\.", "year": 2012}, {"title": "Online optimization in dynamic environments", "author": ["Eric C Hall", "Rebecca M Willett"], "venue": "arXiv preprint arXiv:1307.5944,", "citeRegEx": "Hall and Willett.,? \\Q2013\\E", "shortCiteRegEx": "Hall and Willett.", "year": 2013}, {"title": "Efficient learning algorithms for changing environments", "author": ["Elad Hazan", "Comandur Seshadhri"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "Hazan and Seshadhri.,? \\Q2009\\E", "shortCiteRegEx": "Hazan and Seshadhri.", "year": 2009}, {"title": "Tracking the best expert", "author": ["Mark Herbster", "Manfred K Warmuth"], "venue": "Machine Learning,", "citeRegEx": "Herbster and Warmuth.,? \\Q1998\\E", "shortCiteRegEx": "Herbster and Warmuth.", "year": 1998}, {"title": "A spectral algorithm for learning hidden markov models", "author": ["Daniel Hsu", "Sham M Kakade", "Tong Zhang"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Hsu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hsu et al\\.", "year": 2012}, {"title": "Online optimization: Competing with dynamic comparators", "author": ["Ali Jadbabaie", "Alexander Rakhlin", "Shahin Shahrampour", "Karthik Sridharan"], "venue": "In AISTATS,", "citeRegEx": "Jadbabaie et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Jadbabaie et al\\.", "year": 2015}, {"title": "Interpolated estimation of markov source parameters from sparse data", "author": ["Frederick Jelinek", "Robert L. Mercer"], "venue": "In Proceedings of the Workshop on Pattern Recognition in Practice,", "citeRegEx": "Jelinek and Mercer.,? \\Q1980\\E", "shortCiteRegEx": "Jelinek and Mercer.", "year": 1980}, {"title": "Learning hurdles for sleeping experts", "author": ["Varun Kanade", "Thomas Steinke"], "venue": "ACM Transactions on Computation Theory (TOCT),", "citeRegEx": "Kanade and Steinke.,? \\Q2014\\E", "shortCiteRegEx": "Kanade and Steinke.", "year": 2014}, {"title": "Sleeping experts and bandits with stochastic action availability and adversarial rewards", "author": ["Varun Kanade", "HB McMahan", "Brent Bryan"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Kanade et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kanade et al\\.", "year": 2009}, {"title": "Estimation of probabilities from sparse data for the language model component of a speech recogniser", "author": ["Slava M. Katz"], "venue": "IEEE Transactions on Acoustic, Speech, and Signal Processing,", "citeRegEx": "Katz.,? \\Q1987\\E", "shortCiteRegEx": "Katz.", "year": 1987}, {"title": "Exponentiated gradient versus gradient descent for linear predictors", "author": ["Jyrki Kivinen", "Manfred K Warmuth"], "venue": "Information and Computation,", "citeRegEx": "Kivinen and Warmuth.,? \\Q1997\\E", "shortCiteRegEx": "Kivinen and Warmuth.", "year": 1997}, {"title": "Regret bounds for sleeping experts and bandits", "author": ["Robert Kleinberg", "Alexandru Niculescu-Mizil", "Yogeshwer Sharma"], "venue": "Machine learning,", "citeRegEx": "Kleinberg et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kleinberg et al\\.", "year": 2010}, {"title": "Fast pattern matching in strings", "author": ["D.E. Knuth", "J.H. Morris Jr.", "V.R. Pratt"], "venue": "SIAM Journal of Comput. Syst. Sci.,", "citeRegEx": "Knuth et al\\.,? \\Q1977\\E", "shortCiteRegEx": "Knuth et al\\.", "year": 1977}, {"title": "Universal codes from switching strategies", "author": ["Wouter M Koolen", "Steven de Rooij"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Koolen and Rooij.,? \\Q2013\\E", "shortCiteRegEx": "Koolen and Rooij.", "year": 2013}, {"title": "The weighted majority algorithm", "author": ["Nick Littlestone", "Manfred K Warmuth"], "venue": "Information and computation,", "citeRegEx": "Littlestone and Warmuth.,? \\Q1994\\E", "shortCiteRegEx": "Littlestone and Warmuth.", "year": 1994}, {"title": "String-Matching with Automata", "author": ["Mehryar Mohri"], "venue": "Nordic Journal of Computing,", "citeRegEx": "Mohri.,? \\Q1997\\E", "shortCiteRegEx": "Mohri.", "year": 1997}, {"title": "Weighted automata algorithms. In Handbook of weighted automata, pages 213\u2013254", "author": ["Mehryar Mohri"], "venue": null, "citeRegEx": "Mohri.,? \\Q2009\\E", "shortCiteRegEx": "Mohri.", "year": 2009}, {"title": "Regular approximation of context-free grammars through transformation", "author": ["Mehryar Mohri", "Mark-Jan Nederhof"], "venue": "In Robustness in language and speech technology,", "citeRegEx": "Mohri and Nederhof.,? \\Q2001\\E", "shortCiteRegEx": "Mohri and Nederhof.", "year": 2001}, {"title": "Online optimization in dynamic environments: Improved regret rates for strongly convex problems", "author": ["Aryan Mokhtari", "Shahin Shahrampour", "Ali Jadbabaie", "Alejandro Ribeiro"], "venue": "In Decision and Control (CDC),", "citeRegEx": "Mokhtari et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Mokhtari et al\\.", "year": 2016}, {"title": "Online learning of non-stationary sequences", "author": ["Claire Monteleoni", "Tommi S Jaakkola"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Monteleoni and Jaakkola.,? \\Q2003\\E", "shortCiteRegEx": "Monteleoni and Jaakkola.", "year": 2003}, {"title": "Practical experiments with regular approximation of context-free languages", "author": ["Mark-Jan Nederhof"], "venue": "Computational Linguistics,", "citeRegEx": "Nederhof.,? \\Q2000\\E", "shortCiteRegEx": "Nederhof.", "year": 2000}, {"title": "On structuring probabilistic dependences in stochastic language modeling", "author": ["Hermann Ney", "Ute Essen", "Reinhard Kneser"], "venue": "Computer Speech and Language,", "citeRegEx": "Ney et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Ney et al\\.", "year": 1994}, {"title": "Finite-state approximation of phrase structure grammars", "author": ["Fernando CN Pereira", "Rebecca N Wright"], "venue": "In Proceedings of the 29th annual meeting on Association for Computational Linguistics,", "citeRegEx": "Pereira and Wright.,? \\Q1991\\E", "shortCiteRegEx": "Pereira and Wright.", "year": 1991}, {"title": "The minimum consistent DFA problem cannot be approximated within any polynomial", "author": ["Leonard Pitt", "Manfred K Warmuth"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Pitt and Warmuth.,? \\Q1993\\E", "shortCiteRegEx": "Pitt and Warmuth.", "year": 1993}, {"title": "On measures of entropy and information", "author": ["Alfr\u00e9d R\u00e9nyi"], "venue": "In Proceedings of the Fourth Berkeley Symposium on Mathematical Statistics and Probability, Volume 1: Contributions to the Theory of Statistics. The Regents of the University of California,", "citeRegEx": "R\u00e9nyi,? \\Q1961\\E", "shortCiteRegEx": "R\u00e9nyi", "year": 1961}, {"title": "On the probability of large deviations of random magnitudes", "author": ["Ivan Nikolaevich Sanov"], "venue": "Matematicheskii Sbornik,", "citeRegEx": "Sanov.,? \\Q1957\\E", "shortCiteRegEx": "Sanov.", "year": 1957}, {"title": "Distributed online optimization in dynamic environments using mirror descent", "author": ["Shahin Shahrampour", "Ali Jadbabaie"], "venue": "arXiv preprint arXiv:1609.02845,", "citeRegEx": "Shahrampour and Jadbabaie.,? \\Q2016\\E", "shortCiteRegEx": "Shahrampour and Jadbabaie.", "year": 2016}, {"title": "R\u00e9nyi divergence and kullback-leibler divergence", "author": ["Tim Van Erven", "Peter Harremos"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Erven and Harremos.,? \\Q2014\\E", "shortCiteRegEx": "Erven and Harremos.", "year": 2014}, {"title": "Derandomizing stochastic prediction strategies", "author": ["Vladimir Vovk"], "venue": "Machine Learning,", "citeRegEx": "Vovk.,? \\Q1999\\E", "shortCiteRegEx": "Vovk.", "year": 1999}, {"title": "Tracking the best expert in non-stationary stochastic environments", "author": ["Chen-Yu Wei", "Yi-Te Hong", "Chi-Jen Lu"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Wei et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Wei et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 16, "context": "This work has subsequently been improved to account for broader expert classes [Gyorgy et al., 2012], to deal with unknown parameters [Monteleoni and Jaakkola, 2003], and has been further generalized [Cesa-Bianchi et al.", "startOffset": 79, "endOffset": 100}, {"referenceID": 35, "context": ", 2012], to deal with unknown parameters [Monteleoni and Jaakkola, 2003], and has been further generalized [Cesa-Bianchi et al.", "startOffset": 41, "endOffset": 72}, {"referenceID": 5, "context": "Within the online learning framework, the setting of prediction with expert advice has received widespread attention [Littlestone and Warmuth, 1994, Cesa-Bianchi and Lugosi, 2006, Cesa-Bianchi et al., 2007]. In this setting, the algorithm maintains a distribution over a set of experts, or selects an expert from an implicitly maintained distribution. At each round, the loss assigned to each expert is revealed. The algorithm incurs the expected loss over the experts and then updates her distribution on the set of experts. The objective of the learner is to minimize his expected regret, which is defined as the cumulative loss of the algorithm minus the cumulative loss of the best expert chosen in hindsight. However, this benchmark is only significant when the best expert is expected to perform well. When this is not the case, then the learner may still play poorly. As an example, it may be that no single baseball team has performed well over all seasons in the past few years. Instead, different teams may have dominated over different time periods. This has led to a definition of regret against the best sequence of experts with k shifts in the seminal work of Herbster and Warmuth [1998] on tracking the best expert.", "startOffset": 149, "endOffset": 1202}, {"referenceID": 5, "context": "Within the online learning framework, the setting of prediction with expert advice has received widespread attention [Littlestone and Warmuth, 1994, Cesa-Bianchi and Lugosi, 2006, Cesa-Bianchi et al., 2007]. In this setting, the algorithm maintains a distribution over a set of experts, or selects an expert from an implicitly maintained distribution. At each round, the loss assigned to each expert is revealed. The algorithm incurs the expected loss over the experts and then updates her distribution on the set of experts. The objective of the learner is to minimize his expected regret, which is defined as the cumulative loss of the algorithm minus the cumulative loss of the best expert chosen in hindsight. However, this benchmark is only significant when the best expert is expected to perform well. When this is not the case, then the learner may still play poorly. As an example, it may be that no single baseball team has performed well over all seasons in the past few years. Instead, different teams may have dominated over different time periods. This has led to a definition of regret against the best sequence of experts with k shifts in the seminal work of Herbster and Warmuth [1998] on tracking the best expert. The authors showed that there exists an efficient on-line learning algorithm for this setting with favorable regret guarantees. This work has subsequently been improved to account for broader expert classes [Gyorgy et al., 2012], to deal with unknown parameters [Monteleoni and Jaakkola, 2003], and has been further generalized [Cesa-Bianchi et al., 2012, Vovk, 1999]. Another approach for handling dynamic environments has consisted of designing algorithms that guarantee small regret over any subinterval during the course of play. This notion coined as adaptive regret by Hazan and Seshadhri [2009] has been subsequently strengthened and generalized [Daniely et al.", "startOffset": 149, "endOffset": 1833}, {"referenceID": 0, "context": ", 2015, Adamskiy et al., 2012]. Remarkably, it was shown by Adamskiy et al. [2012] that the algorithm designed by Herbster and Warmuth [1998] is also optimal for adaptive regret.", "startOffset": 8, "endOffset": 83}, {"referenceID": 0, "context": ", 2015, Adamskiy et al., 2012]. Remarkably, it was shown by Adamskiy et al. [2012] that the algorithm designed by Herbster and Warmuth [1998] is also optimal for adaptive regret.", "startOffset": 8, "endOffset": 142}, {"referenceID": 0, "context": ", 2015, Adamskiy et al., 2012]. Remarkably, it was shown by Adamskiy et al. [2012] that the algorithm designed by Herbster and Warmuth [1998] is also optimal for adaptive regret. Koolen and de Rooij [2013] described a Bayesian framework for online learning where the learner samples from a distribution of expert sequences and predicts according to the prediction of that expert sequence.", "startOffset": 8, "endOffset": 206}, {"referenceID": 17, "context": "Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013].", "startOffset": 112, "endOffset": 136}, {"referenceID": 14, "context": "We then extend the results above to the sleeping expert setting [Freund et al., 1997], where the learner may not have access to advice from every expert at each round (Section 11).", "startOffset": 64, "endOffset": 85}, {"referenceID": 6, "context": ", 2015, Besbes et al., 2015]. Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013]. Gy\u00f6rgy and Szepesv\u00e1ri [2016] reinterpreted the framework of Hall and Willett [2013] to recover and extend the results of Herbster and Warmuth [1998].", "startOffset": 8, "endOffset": 197}, {"referenceID": 6, "context": ", 2015, Besbes et al., 2015]. Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013]. Gy\u00f6rgy and Szepesv\u00e1ri [2016] reinterpreted the framework of Hall and Willett [2013] to recover and extend the results of Herbster and Warmuth [1998].", "startOffset": 8, "endOffset": 252}, {"referenceID": 6, "context": ", 2015, Besbes et al., 2015]. Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013]. Gy\u00f6rgy and Szepesv\u00e1ri [2016] reinterpreted the framework of Hall and Willett [2013] to recover and extend the results of Herbster and Warmuth [1998]. In this paper, we significantly generalize the framework just described and consider prediction with expert advice in a setting where the learner\u2019s cumulative loss is compared against that of sequences represented by an arbitrary weighted family of sequences.", "startOffset": 8, "endOffset": 317}, {"referenceID": 6, "context": ", 2015, Besbes et al., 2015]. Another assumes that the learner has access to a dynamical model that is able to capture the benchmark sequence [Hall and Willett, 2013]. Gy\u00f6rgy and Szepesv\u00e1ri [2016] reinterpreted the framework of Hall and Willett [2013] to recover and extend the results of Herbster and Warmuth [1998]. In this paper, we significantly generalize the framework just described and consider prediction with expert advice in a setting where the learner\u2019s cumulative loss is compared against that of sequences represented by an arbitrary weighted family of sequences. We model this family using a weighted finite automaton (WFA). This strictly generalizes the notion of k-shifting regret and extends it to the notion of regret against a WFA. Measuring regret against an automaton is both natural and flexible. In fact, it may often be sensible to learn the set of competitor sequences using data before competing against it. For instance, the competitor automaton could be a language model trained over best sequences of baseball teams in the past. Moreover, the competitor automaton could be learned and reset incrementally. After each epoch, we could choose to learn a new competitor model and seek to perform well against that. We show that not only it is possible to achieve favorable regret against a WFA but that there exist computationally efficient algorithms to achieve that. We give a series of algorithms for this problem. Our first algorithm (Section 6) is an automata-based algorithm extending weighted-majority and using automata operations such as composition and shortest-distance; its computational cost is exponentially better than that of a na\u0131\u0308ve method. We further present efficient algorithms based on a compact approximation of the competitor automaton (Section 7), in particular efficient n-gram models obtained by minimizing the R\u00e9nyi divergence, and present an extensive study of the approximation properties of such models. We also show how existing algorithms for minimizing k-shifting regret can be recovered by learning a Maximum-Likelihood bigram language model over the k-shifting competitor automaton. To the best of our knowledge, this is the first instance of recovering the algorithms of Herbster and Warmuth [1998] by way of solely focusing on minimizing the k-shifting regret.", "startOffset": 8, "endOffset": 2262}, {"referenceID": 32, "context": "In the probability semiring, the order of the terms in the sum does not matter, and the quantity is well defined [Mohri, 2009].", "startOffset": 113, "endOffset": 126}, {"referenceID": 19, "context": "Then, the (weighted or unweighted) regret of an algorithm A against Ck-shift coincides with the definition of k-shifting regret studied by Herbster and Warmuth [1998]:", "startOffset": 139, "endOffset": 167}, {"referenceID": 30, "context": "4 Na\u0131\u0308ve algorithm A well-known algorithm for minimizing static regret in the prediction with expert advice setting is the weighted majority algorithm [Littlestone and Warmuth, 1994].", "startOffset": 151, "endOffset": 182}, {"referenceID": 32, "context": "A standard and efficient method for composing two weighted automata is to pair up matching transitions [Mohri, 2009].", "startOffset": 103, "endOffset": 116}, {"referenceID": 32, "context": "For any acyclic automaton A, \u03b1 can be computed in linear time using a general relaxation-based shortest-distance algorithm with a topological queue discipline [Mohri, 2009].", "startOffset": 159, "endOffset": 172}, {"referenceID": 32, "context": "Connection (or trimming) is a linear-time algorithm that removes these non-accessible states [Mohri, 2009].", "startOffset": 93, "endOffset": 106}, {"referenceID": 32, "context": "Any probabilistic weighted automaton can be converted into a stochastic automaton using the weight-pushing algorithm [Mohri, 2009], which takes linear time and consists of a shortest-distance computation combined with a reweighting of the transition weights, initial weights, and final weights in a way that pushes the weights towards the initial states.", "startOffset": 117, "endOffset": 130}, {"referenceID": 3, "context": "obtained from the expected count of the n-gram in the paths of CT , where the expectation is taken over the probability distribution defined by CT and can be computed efficiently [Allauzen et al., 2003].", "startOffset": 179, "endOffset": 202}, {"referenceID": 3, "context": "obtained from the expected count of the n-gram in the paths of CT , where the expectation is taken over the probability distribution defined by CT and can be computed efficiently [Allauzen et al., 2003]. Maximum likelihood n-gram models can further benefit from \u03c6-conversion using the algorithms presented in Section 9. This can reduce the size of An and improve its computational efficiency without affecting its accuracy. As an example, we can compute the bigram approximation to the k-shifting automaton. Remarkably, this will coincide with the FIXED-SHARE algorithm of Herbster and Warmuth [1998]. Thus, we can view and motivate the design of FIXED-SHARE as a bigram approximation of the desired competitor automaton, that is the family of k-shifting sequences.", "startOffset": 180, "endOffset": 601}, {"referenceID": 41, "context": "Since each shift occurs with probability k T\u22121 , we can use Sanov\u2019s theorem [Sanov, 1957] to write the following bound:", "startOffset": 76, "endOffset": 89}, {"referenceID": 19, "context": "The computational cost of using \u03c6-AWM with this new \u03c6-automaton coincides with the one described originally in [Herbster and Warmuth, 1998].", "startOffset": 111, "endOffset": 139}, {"referenceID": 26, "context": "The problem can be solved using as an optimization algorithm an extension of the Exponentiated Gradient algorithm developed by Kivinen and Warmuth [1997], which we call PROD-EG.", "startOffset": 127, "endOffset": 154}, {"referenceID": 19, "context": "This is a factor of N better than that of AWM, and only a factor of k worse than the specific algorithm of Herbster and Warmuth [1998]. Using a bigram approximation of the k-shifting automaton composed with ST and then introducing converting it into a \u03c6-automaton, we obtain an algorithm that runs in O(N).", "startOffset": 107, "endOffset": 135}, {"referenceID": 32, "context": "As with finite automata, finite-state transducers can also be augmented with weights, and as with weighted finite automata, weighted finite-state transducers can be composed efficiently and on-demand [Mohri, 2009].", "startOffset": 200, "endOffset": 213}, {"referenceID": 2, "context": "The reason why redundant \u03c6-paths are generated by standard composition algorithms is similar to the reason why redundant -paths are generated during composition of automata without failure transitions [Allauzen and Mohri, 2008].", "startOffset": 201, "endOffset": 227}, {"referenceID": 2, "context": "However, we can improve upon this by extending the 3-way composition technique presented in [Allauzen and Mohri, 2008] to our \u03c6-automata setting.", "startOffset": 92, "endOffset": 118}, {"referenceID": 14, "context": "This extension of standard prediction with expert advice is also known as the sleeping experts framework [Freund et al., 1997].", "startOffset": 105, "endOffset": 126}, {"referenceID": 14, "context": "In [Freund et al., 1997], the comparison is made against the best fixed mixture of experts normalized at each round over the awake set: minu\u2208\u2206N \u2211T t=1 \u2211 i\u2208At uilt[i] \u2211 j\u2208At uj .", "startOffset": 3, "endOffset": 24}, {"referenceID": 14, "context": "This motivates the design of AWAKEPBWM, a path-based weighted majority algorithm that generalizes the algorithms in [Freund et al., 1997] to arbitrary families of expert sequences.", "startOffset": 116, "endOffset": 137}, {"referenceID": 17, "context": "The proof of this result follows along similar lines as the original result by [Hall and Willett, 2013].", "startOffset": 79, "endOffset": 103}, {"referenceID": 16, "context": "The proof of this result follows along similar lines as the original result by [Hall and Willett, 2013]. The major difference is that the authors in that work assume \u03a8 to be Lipschitz. This allows them to derive a slightly weaker but more interpretable bound. However, it is also an assumption that we specifically choose to avoid, since mirror descent algorithms including the EXPONENTIATED GRADIENT use mirror maps that are not Lipschitz. Hall and Willett [2013] also derive a bound for standard regret as opposed to regret against a distribution of sequences.", "startOffset": 80, "endOffset": 465}, {"referenceID": 15, "context": "Note that Gy\u00f6rgy and Szepesv\u00e1ri [2016] present the same algorithm but with a different analysis and upper bound.", "startOffset": 10, "endOffset": 39}, {"referenceID": 15, "context": "[Gy\u00f6rgy and Szepesv\u00e1ri, 2016]) which only showed that one could define \u03a6t in a way that mimics the FIXED-SHARE algorithm.", "startOffset": 0, "endOffset": 29}], "year": 2017, "abstractText": "We consider a general framework of online learning with expert advice where the regret is defined with respect to a competitor class defined by a weighted automaton over sequences of experts. Our framework covers several problems previously studied, in particular that of competing against k-shifting experts. We give a series of algorithms for this problem, including an automata-based algorithm extending weightedmajority and more efficient algorithms based on the notion of failure transitions. We further present efficient algorithms based on a compact approximation of the competitor automaton, in particular efficient n-gram models obtained by minimizing the R\u00e9nyi divergence, and present an extensive study of the approximation properties of such models. We also extend our algorithms and results to the framework of sleeping experts. Finally, we describe the extension of our approximation methods to online convex optimization and a general mirror descent setting.", "creator": "LaTeX with hyperref package"}}}