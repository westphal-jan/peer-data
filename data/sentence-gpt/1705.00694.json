{"id": "1705.00694", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-May-2017", "title": "A polynomial time algorithm for the Lambek calculus with brackets of bounded order", "abstract": "Lambek calculus is a logical foundation of categorial grammar, a linguistic paradigm of grammar as logic and parsing as deduction. Pentus (2010) gave a polynomial-time algorithm for determ- ining provability of bounded depth formulas in the Lambek calculus with empty antecedents allowed. Pentus' algorithm is based on tabularisation of proof nets (QT) and a method for defining priming (QT) (e.g. a set of parameters), i.e. for non-matrix proof vectors (QT). The idea of priming and deduction for matrices was recently discussed in this article.\n\n\nFor proof-based priming systems [ edit ]\nThe Bayesian system [ edit ]\nThe Bayesian system consists of a set of four matrices. A set of three matrices consists of two matrices. A set of four matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices consists of two matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices.\n\nThe Bayesian system\nThe Bayesian system consists of a set of four matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices.\nA set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set of three matrices. A set", "histories": [["v1", "Mon, 1 May 2017 20:12:11 GMT  (78kb,D)", "http://arxiv.org/abs/1705.00694v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.CL cs.DS cs.FL", "authors": ["max kanovich", "stepan kuznetsov", "glyn morrill", "re scedrov"], "accepted": false, "id": "1705.00694"}, "pdf": {"name": "1705.00694.pdf", "metadata": {"source": "CRF", "title": "A Polynomial-Time Algorithm for the Lambek Calculus with Brackets of Bounded Order", "authors": ["Max Kanovich", "Stepan Kuznetsov", "Glyn Morrill", "Andre Scedrov"], "emails": ["m.kanovich@qmul.ac.uk", "sk@mi.ras.ru", "morrill@cs.upc.edu", "scedrov@math.upenn.edu"], "sections": [{"heading": null, "text": "Digital Object Identifier 10.4230/LIPIcs...\n1 Introduction\nThe calculus L of Lambek [20] is a logic of strings. It is retrospectively recognisable as the multiplicative fragment of non-commutative intuitionistic linear logic without empty antecedents; the calculus L\u2217 is like L except that it admits empty antecedents. The Lambek calculus is the foundation of categorial grammar, a linguistic paradigm of grammar as logic and parsing as deduction; see for instance Buszkowski [4], Carpenter [5], J\u00e4ger [14], Morrill [24], Moot and Retor\u00e9 [22]. For example, the sentence \u201cJohn knows Mary likes Bill\u201d can be analysed as grammatical because N, (N \\S) / S,N, (N \\S) /N,N \u2192 S is a theorem of Lambek calculus. Here N stands for noun phrase, S stands for sentence, and syntactic categories for other words are built from these two primitive ones using division operations. For example, (N \\S) /N takes noun phrases on both sides and yields a sentence, thus being the category of transitive verb.\nCategorial grammar, that started from works of Ajdukiewicz [2] and Bar-Hillel [3], aspires to practice linguistics to the standards of mathematical logic; for example, Lambek [20] proves cut-elimination, that yields the subformula property, decidability, the finite reading property, and the focalisation property. In a remarkable series of works Mati Pentus has proved the main metatheoretical results for Lambek calculus: equivalence to context-free grammars [27], completeness w.r.t. language models [28][29], NP-completeness [30]; a polynomial-time algorithm for checking provability of formulae of bounded order in L\u2217 [31]. The Lambek\nlicensed under Creative Commons License CC-BY Leibniz International Proceedings in Informatics Schloss Dagstuhl \u2013 Leibniz-Zentrum f\u00fcr Informatik, Dagstuhl Publishing, Germany\nar X\niv :1\n70 5.\n00 69\n4v 1\n[ cs\n.L O\n] 1\nM ay\ncalculus with only one division operation (and without product) is decidable in polynomial time (Savateev [32]).\nThe Lambek calculus with brackets Lb (Morrill 1992 [23]; Moortgat 1995 [21]) is a logic of bracketed strings which is a conservative extension of Lambek calculus with bracket modalities the rules for which are conditioned on metasyntactic brackets. In this paper we consider a variant of Lb that allows empty antecedents, denoted by Lb\u2217.\nThe syntax of Lb\u2217 is more involved than the syntax of the original Lambek calculus. In L, the antecedent (left-hand side) of a sequent is just a linearly ordered sequence of formulae. In Lb\u2217, it is a structure called configuration, or meta-formula. Meta-formulae are built from formulae, or types, as they are called in categorial grammar, using two metasyntactic constructors: comma and brackets. The succedent (right-hand side) of a sequent is one type. Types, in their turn, are built from variables, or primitive types, p1, p2, . . . , using three binary connectives of Lambek, \\, /, and \u00b7, and two unary ones, \u3008\u3009 and []\u22121, that operate brackets. Axioms of Lb\u2217 are pi \u2192 pi, and the rules are as follows:\n\u03a0\u2192 A \u2206(B)\u2192 C \u2206(\u03a0, A \\B)\u2192 C (\\ \u2192) A,\u03a0\u2192 B \u03a0\u2192 A \\B (\u2192 \\) \u0393(A,B)\u2192 C \u0393(A \u00b7B)\u2192 C (\u00b7 \u2192)\n\u03a0\u2192 A \u2206(B)\u2192 C \u2206(B /A,\u03a0)\u2192 C (/\u2192) \u03a0, A\u2192 B \u03a0\u2192 B /A (\u2192 /) \u0393\u2192 A \u2206\u2192 B \u0393,\u2206\u2192 A \u00b7B (\u2192 \u00b7)\n\u2206([A])\u2192 C \u2206(\u3008\u3009A)\u2192 C (\u3008\u3009 \u2192) \u03a0\u2192 A [\u03a0]\u2192 \u3008\u3009A (\u2192 \u3008\u3009) \u2206(A)\u2192 C \u2206([[]\u22121A])\u2192 C ([]\u22121 \u2192) [\u03a0]\u2192 A \u03a0\u2192 []\u22121A (\u2192 []\u22121)\nCut-elimination is proved in Moortgat [21]. The Lambek calculus with brackets permits the characterisation of syntactic domains in addition to word order. By way of linguistic example, consider how a relative pronoun type assignment (CN \\CN ) /(S /N) (here CN is one primitive type, corresponding to common noun: e.g., \u201cbook\u201d, as opposed to noun phrase \u201cthe book\u201d) allows unbounded relativisation by associative assembly of the body of relative clauses:\n(a) man who Mary likes (b) man who John knows Mary likes (c) man who Mary knows John knows Mary likes . . .\nThus, (b) is generated because the following is a theorem in the pure Lambek calculus:\nCN , (CN \\CN ) /(S /N), N, (N \\S) / S,N, (N \\S) /N \u2192 CN\nConsider, however, the following example: *book which John laughed without reading, where * indicates that this example is not grammatical. In the original Lambek calculus this ungrammatical example is generated, but in Lambek calculus with brackets its ungrammaticality can be characterised by assigning the adverbial preposition a type []\u22121((N \\S) \\(N \\S)) /(N \\S) blocking this phrase because the following is not a theorem in Lambek calculus with brackets:\nCN , (CN \\CN ) /(S /N), N,N \\S, [[]\u22121((N \\S) \\(N \\S)) /(N \\S), (N \\S) /N ]\u2192 CN\nwhere the []\u22121 engenders brackets which block the associative assembly of the body of the relative clause. Another example of islands is provided by the \u201cand\u201d (\u201cor\u201d) construction: *girl whom John loves Mary and Pete loves. Also, non-associative Lambek calculus can be embedded into the Lambek calculus with brackets (Kurtonina [16]).\nJ\u00e4ger [13] claims to prove the context free equivalence of Lb grammar on the basis of a translation from Lb to L due to Michael Moortgat\u2019s student Koen Versmissen [33]. However, contrary to Versmissen the translation is not an embedding translation (Fadda and Morrill [8],\np. 124). We present the counter-example in the end of Section 3. Consequently the result of J\u00e4ger is in doubt: the context free equivalence theorem might be correct, but the proof of J\u00e4ger, resting on the Versmissen translation, is not correct.\nPentus [31] presents an algorithm for provability in L\u2217 based on tabularisation (memoisation) of proof nets. This algorithm runs in polynomial time, if the order of the sequent is bounded. An algorithm of the same kind was also developed by Fowler [9][10]. For the unbounded case, derivability problem for L\u2217 is in the NP class and is NP-complete [30]. In this paper we provide a Pentus-style algorithm for Lb\u2217 provability using (1) the proof nets for Lambek calculus with brackets of Fadda and Morrill [8] which are based on a correction of the Versmissen translation, and (2) an automata-theoretic argument. Again, for the unbounded case, Lb\u2217 is NP-hard (since it contains L\u2217 as a conservative fragment), and also belongs to the NP class, since the size of a cut-free derivation in Lb\u2217 is linearly bounded by the size of the goal sequent.\nThe rest of this paper is organised as follows. In Section 2 we define complexity parameters and formulate the main result. Section 3 contains the formulation and proof of a graphtheoretic provability criterion for Lb\u2217, known as proof nets. In Section 4 we introduce some more convenient complexity parameters and show their polynomial equivalence to the old ones. Section 5 is the central one, containing the description of our algorithm. In order to make this paper self-contained, in Section 6 we give a detailed explanation of Pentus\u2019 construction [31], since it is crucial for our algorithm to work. Finally, in Section 7 we discuss directions of future research in this field.\n2 The Main Result\nFor a sequent \u0393\u2192 C we consider the following three complexity parameters. The first one is the size of the sequent, ||\u0393 \u2192 C||, counted as the total number of variables and logical symbols in it, including brackets.\nI Definition 1. The size of a formula, meta-formula, or sequent in Lb\u2217 is defined recursively as follows: ||pi|| = 0; ||A \u00b7B|| = ||A \\B|| = ||B /A|| = ||A||+ ||B||+ 1; ||\u3008\u3009A|| = ||[]\u22121A|| = ||A||+ 1; ||\u039b|| = 0; ||\u0393,\u2206|| = ||\u0393||+ ||\u2206||; ||[\u0393]|| = ||\u0393||+ 2; ||\u0393\u2192 C|| = ||\u0393||+ ||C||.\nThe second parameter is the order.\nI Definition 2. For any formula A let prod(A) be 1 if A is of the form A1 \u00b7A2 or \u3008\u3009A1, and 0 if not. The order of a formula, meta-formula, or sequent in Lb\u2217 is defined recursively as follows: ord(pi) = 0; ord(A \u00b7 B) = max{ord(A), ord(B)}; ord(A \\B) = ord(B /A) = max{ord(A) + 1, ord(B)+prod(B)}; ord(\u3008\u3009A) = ord(A); ord([]\u22121A) = max{ord(A)+prod(A), 1}; ord(\u039b) = 0; ord(\u0393,\u2206) = max{ord(\u0393), ord(\u2206)}; ord([\u0393]) = ord(\u0393); ord(\u0393 \u2192 C) = max{ord(\u0393) + 1, ord(C) + prod(C)}.\nFor sequents without \u00b7 and []\u22121, this definition is quite intuitive: the order is the nesting depth of implications (\\, /, and finally \u2192) and \u3008\u3009 modalities. With \u00b7, we also count alternations between divisions and multiplications: for example, in p1 \\(p2\u00b7(p3 \\(p4\u00b7. . . pk) . . .)) implications are not nested, but the order grows linearly. On the other hand, the order is always bounded by a simpler complexity parameter, the maximal height of the syntactic tree. Also, linguistic applications make use of syntactic types of small, constantly bounded order.\nThe third parameter is the bracket nesting depth.\nI Definition 3. The bracket nesting depth of a formula, meta-formula, or a sequent in Lb\u2217 is defined recursively as follows: b(pi) = 0; b(A/B) = b(B \\A) = b(A \u00b7B) = max{b(A), b(B)};\nb(\u3008\u3009A) = b([]\u22121A) = b(A) + 1; b(\u039b) = 0; b(\u0393,\u2206) = max{b(\u0393),b(\u2206)}; b([\u0393]) = b(\u0393) + 1; b(\u0393\u2192 C) = max{b(\u0393),b(C)}.\nBy poly(x1, x2, . . .) we denote a value that is bounded by a polynomial of x1, x2, . . .\nI Theorem 4. There exists an algorithm that decides whether a sequent \u0393\u2192 C is derivable in Lb\u2217 in poly(N, 2R, NB) time, where N = ||\u0393\u2192 C||, R = ord(\u0393\u2192 C), B = b(\u0393\u2192 C).\nIf the depth parameters, R and B, are fixed, the working time of the algorithm is polynomial w.r.t. N . However, the dependence on the depth parameters is exponential.\n3 Proof Nets\nIn this section we formulate and prove a graph-theoretic criterion for derivability in Lb\u2217. A sequent is derivable if and only if there exists a proof net, that is, a graph satisfying certain correctness conditions.\nFor each variable pi we introduce two literals, pi and p\u0304i, and also four literals, [, ], [\u0304, and ]\u0304 for brackets. Next we define two translations (positive, A+, and negative, A\u2212) of Lb\u2217-formulae into expressions built from literals using two connectives, O and \u2297. I Definition 5. p+i = pi, (A \u00b7B)+ = A+ \u2297B+, (A \\B)+ = A\u2212OB+, (B /A)+ = B+ OA\u2212, (\u3008\u3009A)+ = ] \u2297 A+ \u2297 [, ([]\u22121A)+ = ]\u0304 OA+ O [\u0304; p\u2212i = p\u0304i, (A \u00b7 B)\u2212 = B\u2212OA\u2212, (A \\B)\u2212 = B\u2212 \u2297A+, (B /A)\u2212 = A+ \u2297B\u2212, (\u3008\u3009A)\u2212 = [\u0304 OA\u2212O ]\u0304, ([]\u22121A)\u2212 = [\u2297A\u2212 \u2297 ].\nFor meta-formulae, we need only the negative translation. In this translation we use an extra connective, , which serves as a metasyntactic version of O (just as the comma is a metasyntactic product in the sequent calculus for Lb\u2217)."}, {"heading": "I Definition 6. (\u0393,\u2206)\u2212 = \u2206\u2212 \u0393\u2212; [\u0393]\u2212 = [\u0304 \u0393\u2212 ]\u0304.", "text": "Finally, a sequent \u0393\u2192 C is translated as \u0393\u2212 C+ (or as C+ if \u0393 is empty). Essentially, this in an extension of Pentus\u2019 translation of L\u2217 into cyclic multiplicative linear logic (CMLL) [29][31]. In this paper, for the sake of simpicity, we don\u2019t introduce an intermediate calculus that extends CMLL with brackets, and formulate the proof net criterion directly for Lb\u2217.\nDenote the set of all literal and connective occurrences in this translation by \u2126\u0393\u2192C . These occurrences are linearly ordered; connectives and literals alternate. The total number of occurrences is 2n. Denote the literal occurrences (in their order) by `1, . . . , `n and the connective occurrences by c1, . . . , cn.\nI Definition 7. The dominance relation on the occurrences of O and \u2297, denoted by \u227a, is defined as follows: for a subexpression of the form AOB or A\u2297B if the occurrence of the central connective is ci, then for any cj inside A or B we declare cj \u227a ci.\nWe assume that O\u2019s that come from translations of bracket modalities associate to the left and \u2297\u2019s associate to the right (this choice is arbitrary). Thus, in a pair of such O\u2019s the right one dominates the left one in the syntactic tree, and the left one dominates the principal connective of A; symmetrically for \u2297.\nThe other two relations are the sisterhood relation on bracket literals and connectives, Sb and Sc respectively. Both relations are symmetric.\nI Definition 8. The bracket sisterhood relation, Sb, connects pairs of occurrences of [ and ] or [\u0304 and ]\u0304 that come from the same \u3008\u3009A, []\u22121A, or [\u0393]. The connective sisterhood relation, Sc, connects pairs of occurrences of \u2297, O, or that come from the same \u3008\u3009A, []\u22121A, or [\u0393]. Occurrences connected by one of the sisterhood relations will be called sister occurrences.\nI Definition 9. A proof structure E is a symmetric relation on the set of literal occurrences ({`1, . . . , `n}) such that each occurrence is connected by E to exactly one occurrence, and each occurrence of a literal q, where q is a variable, [, or ], is connected to an occurrence of q\u0304.\nI Definition 10. A proof structure E is planar, if its edges can be drawn in a semiplane without intersection while the literal occurrences are located on the border of this semiplane in their order (`1, . . . , `n).\nEdges of a planar proof structure divide the upper semiplane into regions. The number of regions is n2 + 1 (the outermost, infinite region also counts).\nI Definition 11. A planar proof structure E is a proof net, if it satisfies two conditions. 1. On the border of each region there should be exactly one occurrence of O or . 2. Define an oriented graph A that connects each occurrence of \u2297 to the unique occurrence\nof O or located in the same region. The graph A \u222a\u227a should be acyclic.\nBy definition, edges of E and A in a proof net do not intersect, in other words, the graph E \u222a A is also planar. We can also consider proof structures and proof nets on expressions that are not translations of Lb\u2217 sequents. For example, proof nets allow cyclic permutations: a proof net for \u03b31 \u03b32 can be transformed into a proof net for \u03b32 \u03b31 (the \u227a relation in \u03b31 and \u03b32 is preserved).\nI Lemma 12. For an expression of the form A\u22121 . . . A\u2212m (which is not a translation of an Lb\u2217 sequent, since there is no B+ in the end) there couldn\u2019t exist a proof net.\nProof. Following Pentus [29], for any string \u03b3 of literals, O\u2019s, \u2297\u2019s, and \u2019s we define \\(\u03b3) as the number of negative literals (i.e., of the form q\u0304, where q is a variable or a bracket) minus the number of O\u2019s and \u2019s. Then we establish the following: (1) \\(A+) = 0 and \\(A\u2212) = 1 for any formula A; (2) if there exists a proof net for \u03b3, then \\(\u03b3) = \u22121. The first statement is proved by joint induction on A. The second one follows from the fact that the number of regions is greater than the number of E links exactly by one; links are in one-to-one correspondence with negative literal occurrences and each region holds a unique occurrence of O or . Since \\( A\u22121 . . . A\u2212m) = m\u2212m = 0 6= \u22121, there is no proof net. J\nI Definition 13. A proof structure E respects sisterhood, if the following condition holds: if \u3008`i, `i\u2032\u3009 \u2208 E , \u3008`i, `j\u3009 \u2208 Sb, and \u3008`i\u2032 , `j\u2032\u3009 \u2208 Sb, then \u3008`j , `j\u2032\u3009 \u2208 E (i.e., sister brackets are connected to sister brackets).\nI Theorem 14. The sequent \u0393\u2192 C is derivable in Lb\u2217 if and only if there exists a proof net E over \u2126\u0393\u2192C that respects sisterhood.\nProof. The direction from Lb\u2217-derivation to proof net is routine: we construct the proof net by induction, maintaining the correctness criterion. For the other direction, we proceed by induction on the number of O and \u2297 occurrences.\nIf there are no occurrences of O or \u2297, then the total number of occurrences is, on one hand, equal to n; on the other hand, it is equal to the number of regions, n2 + 1. Therefore,\nn = 2, and the only possible proof net is p\u0304 p , that corresponds to the p\u2192 p axiom. Otherwise consider the set of all occurrences of O and \u2297 with the relation A \u222a\u227a. Since this relation is acyclic (and the set is not empty), there exists a maximal element, ci. Case 1.1: ci is a O occurrence that came from (A \u00b7B)\u2212 = B\u2212OA\u2212. Replacing this O by corresponds to applying (\u00b7 \u2192).\nCase 1.2: ci is a O occurrence that came from (A \\B)+ = A\u2212OB+. Replacing this O by changes \u0393\u2212 A\u2212OB+ to \u0393\u2212 A\u2212 B+, which corresponds to applying (\u2192 \\). (In the negative translation, formulae in the left-hand side appear in the inverse order.)\nCase 1.3: ci is a O occurrence that came from (B /A)+ = B+ OA\u2212. Again, replace O with and cyclically transform the net, yielding A\u2212 \u0393\u2212 B+. Then apply (\u2192 /).\nCase 2.1: ci is a \u2297 occurrence that came from (A \u00b7B)+ = A+ \u2297B+. Then A(ci) is a occurrence, and the A link splits the proof net for \u0393\u2192 A \u00b7B into two separate proof nets for \u03931 \u2192 A and \u03932 \u2192 B (\u03931 and/or \u03932 could be empty, then two or three \u2019s shrink into one):\n\u0393\u22122 \u0393 \u2212 1 A+ \u2297 B+\nNote that here the fragments before the occurrence A(ci) and between A(ci) and A are negative translations of whole metaformulae (\u03931 and \u03932), not just substrings with possibly disbalanced brackets. Indeed, suppose that a pair of sister brackets, [\u0304 and ]\u0304, is split between these two fragments. Then, since E links cannot intersect A, the corresponding pair of [ and ], connected to the original pair by E , will also be split and therefore belong to translations of different formulae. However, they also form a sister pair (our proof net respects sisterhood), and therefore should belong to one formula (by definition of the translation). Contradiction.\nSince for the sequents \u03931 \u2192 A and \u03932 \u2192 B the induction parameter is smaller, they are derivable, and therefore \u03931,\u03932 \u2192 A \u00b7B is derivable by application of the (\u2192 \u00b7) rule.\nCase 2.2: ci is a \u2297 occurrence from (A \\B)\u2212 = B\u2212\u2297A+. Again, the proof net gets split:\n. . . B\u2212 \u2297 A+ \u03a0\u2212 . . . C+\ufe38 \ufe37\ufe37 \ufe38 \u2206\u2212\n(As in the previous case, no pair of sister brackets could be split by A here, and \u03a0\u2212 is a translation of a whole metaformula.) The outer fragment provides a proof net for \u2206\u3008B\u3009 \u2192 C; applying a cyclic permutation to the inner fragment yields a proof net for \u03a0\u2192 A. The goal sequent, \u2206\u3008\u03a0, A \\B\u3009 \u2192 C, is obtained by applying the (/\u2192) rule.\nThe other situation,\n. . . \u03a0\u2212 B\u2212 \u2297 A+ . . . C+\ufe38 \ufe37\ufe37 \ufe38 \u2206\u2212\nis impossible by Lemma 12, applied to the inner net. Case 2.3: ci is a \u2297 occurrence that came from (B /A)\u2212 = A+ \u2297B\u2212. Symmetric. Case 3.1: ci is a O occurrence that came from ([]\u22121A)+ = ]\u0304 OA+ O [\u0304. Then we replace two O\u2019s by \u2019s and cyclically relocate the rightmost [\u0304 with its E link, obtaining [\u0304 \u0393\u2212 ]\u0304 A+ from \u0393\u2212 ]\u0304 OA+ O [\u0304. This corresponds to an application of (\u2192 []\u22121).\nCase 3.2: ci is a O occurrence that came from (\u3008\u3009A)\u2212 = [\u0304 OA\u2212O ]\u0304. By replacing O\u2019s with \u2019s, we change \u3008\u3009A into [A]. This corresponds to an application of (\u3008\u3009 \u2192).\nCase 4.1: ci is a \u2297 occurrence that came from (\u3008\u3009A)+ = ]\u2297A+ \u2297 [. Consider the E links that go from these ] and [. Since (\u3008\u3009A)+ is the rightmost formula, they both either go to the left or into A+. The second situation is impossible, because then A(ci) should also be a O occurrence in A+, that violates the maximality of ci (and also the acyclicity condition).\nIn the first situation, the picture is as follows:\n\u03b31 [\u0304 \u0393\u2212 ]\u0304 \u03b32 ] \u2297 A+ \u2297 [\n(Due to maximality of ci, A(ci) and its sister are \u2019s, not O\u2019s.) Clearly, \u03b31 and \u03b32 are empty: otherwise we have two \u2019s in one region. Then we can remove brackets and transform this proof net into a proof net for \u0393\u2212 A+, i.e., \u0393\u2192 A. Applying (\u2192 \u3008\u3009) yields [\u0393]\u2192 \u3008\u3009A.\nCase 4.2: ci is a \u2297 occurrence that came from ([]\u22121A)\u2212 = [\u2297A\u2212 \u2297 ]. As in the previous case, consider the E links going from these bracket occurrences. The good situation is when they go to different sides:\n. . . [\u0304 \u03b31 [ \u2297 A\u2212 \u2297 ] \u03b32 ]\u0304 . . . C+\ufe38 \ufe37\ufe37 \ufe38 \u2206\u2212\n(The connectives surrounding [\u2297A\u2212 \u2297 ] are \u2019s due to the maximality of ci.) Again, \u03b31 and \u03b32 should be empty (the connective after [\u0304 or before ]\u0304 here cannot be a \u2297, and we get more than one O or in a region), and removing the bracket corresponds to applying ([]\u22121 \u2192): replace [[]\u22121A] with A in the context \u2206.\nPotentially, the E links from the brackets could also go to one side, but then they end at a pair of sister brackets ]\u0304 and [\u0304 (in this order), which can occur only in ]\u0304 OBO [\u0304. Then one of these O\u2019s is A(ci), which contradicts the maximality of ci. J\nThe idea of proof nets as a representation of derivation in a parallel way comes from the original Girard\u2019s paper on linear logic [12]. For the non-commutative case, including the Lambek calculus, proof nets were studied by many researchers including Abrusci [1], de Groote [7], Nagayama and Okada [25], Penn [26], Pentus [29], Yetter [34], and others. In our definition of proof nets form Lb\u2217 we follow Fadda and Morrill [8], but with the correctness (acyclicity) conditions of Pentus [29][31] rather than Danos and Regnier [6].\nThe idea of handling brackets similarly to variables is due to Versmissen [33]. If we take a sequent that is derivable in Lb\u2217, replace brackets with fresh variables, say, r and s, and respectively substitute r \u00b7 A \u00b7 s for \u3008\u3009A and r \\A/ s for []\u22121A, we obtain a sequent that is derivable in L\u2217 (this follows from our proof net criterion and can also be shown directly). Versmissen, however, claims that the converse is also true. This would make our Theorem 4 a trivial corollary of Pentus\u2019 result [31], but Fadda and Morrill [8] present a counter-example for Versmissen\u2019s claim. Namely, the sequent [[]\u22121p], [[]\u22121q] \u2192 \u3008\u3009[]\u22121(p \u00b7 q) is not derivable in Lb\u2217, but its translation, r, r \\ p / s, s, r, r \\ q / s, s\u2192 r \u00b7 (r \\(p \u00b7 q) / s) \u00b7 s, is derivable in L\u2217. This example shows the importance of the sisterhood condition in Theorem 14: the only possible proof net for this sequent, shown below, doesn\u2019t respect sisterhood.\n[\u0304 [ \u2297 q\u0304 \u2297 ] ]\u0304 [\u0304 [ \u2297 p\u0304 \u2297 ] ]\u0304 ] \u2297 ]\u0304 O p \u2297 q O [\u0304 \u2297 [\n4 Complexity Parameters for Proof Nets\nIn this section we introduce new complexity parameters that operate with \u2126\u0393\u2192C rather than with the original sequent \u0393\u2192 C, and therefore are more handy for complexity estimations. We show that a value is polynomial in terms of the old parameters if it is polynomial in terms of the new ones.\nThe first parameter, denoted by n, is the number of literals in \u2126\u0393\u2192C . It is connected to the size of the original sequent by the following inequation: n \u2264 2||\u0393\u2192 C||. (We have to multiply by 2, since a modality, \u3008\u3009 or []\u22121, being counted as one symbol in \u0393\u2192 C, introduces two literals.)\nThe second parameter, denoted by d = d(\u2126\u0393\u2192C), is the connective alternation depth, and informally it is the maximal number of alternations between O and \u2297 on the \u227a-path from any literal to the root of the parse tree. Formally it is defined by recursion.\nI Definition 15. For an expression \u03b3 constructed from literals using O, \u2297, and , let prod(\u03b3) be 1 if \u03b3 is of the form \u03b31\u2297\u03b32, and 0 otherwise. Define d(\u03b3) by recursion: d(q) = d(q\u0304) = 0 for any literal q; d(\u03b31 O \u03b32) = d(\u03b31 \u03b32) = max{d(\u03b31)+prod(\u03b31), d(\u03b32)+prod(\u03b32)}; d(\u03b31\u2297\u03b32) = max{d(\u03b31), d(\u03b32)}.\nThe d parameter is connected to the order of the original sequent:\nI Lemma 16. For any sequent \u0393\u2192 C, the following holds: d(\u2126\u0393\u2192C) \u2264 ord(\u0393\u2192 C).\nProof. We prove the following two inequations for any formula A by simultaneous induction on the construction of A: d(A+) \u2264 ord(A) and d(A\u2212) + prod(A\u2212) \u2264 ord(A). The induction is straightforward, the only interesting cases are the negative ones for A2 \\A1, A1 /A2, and ([]\u22121A1)\u2212. In those three cases, we need to branch further into two subcases: whether A1 is a variable or a complex type. Finally, d(\u2126\u0393\u2192C) = d( A\u22121 . . . A \u2212 k C+) = max{d(A \u2212 1 ) + prod(A\u22121 ), . . . , d(A \u2212 k ) + prod(A \u2212 k ), d(C+) + prod(C+)} \u2264 max{ord(\u0393), ord(C) + prod(C)} \u2264 max{ord(\u0393) + 1, ord(C) + prod(C)} = ord(\u0393\u2192 C). J\nThe third parameter is b, the maximal nesting depth of pairs of sister brackets. Clearly, b = b(\u0393\u2192 C).\nIn the view of the inequations established in this section, if a value is poly(n, 2d, nb), it is also poly(||\u0393 \u2192 C||, 2ord(\u0393\u2192C), ||\u0393 \u2192 C||b(\u0393\u2192C)), and for our algorithm we\u2019ll establish complexity bounds in terms of n, d, and b.\n5 The Algorithm\nOur goal is to obtain an efficient algorithm that seeks for proof nets that respect sisterhood. We are going to split this task: first find all possible proof nets satisfying Pentus\u2019 correctness conditions, and then distill out those which respect sisterhood. One cannot, however, simply yield all the proof nets. The reason is that there exist derivable sequents, even without brackets and of order 2, that have exponentially many proof nets, for example, p / p, . . . , p / p, p, p \\ p, . . . , p \\ p\u2192 p. Therefore, instead of generating all the proof nets for a given sequent, Pentus in an addition to his provability verification algorithm produces a context-free grammar that generates a set of words encodings of all these proof nets. We filter this set by intersecting it with the set of codes of all proof structures that respect sisterhood. For the latter, we build a finite automaton of polynomial size.\nNote that this context-free grammar construction is different from the translation of Lambek categorial grammars into context-free grammars (Pentus [27]). The grammar from\nPentus\u2019 algorithm that we consider here generates all proof nets for a fixed sequent, while in [27] a context-free grammar is generated for all words that have corresponding derivable Lambek sequents. The latter (global) grammar is of exponential size (though for the case of only one division there also exists a polynomial construction [18]), while the former (local) one is polynomial. For the bracket extension, we present a construction of the local grammar. The context-freeness for the global case is claimed by J\u00e4ger [13], but his proof uses an incorrect lemma by Versmissen (see above).\nFollowing Pentus [31], for a given sequent \u0393\u2192 C we encode proof structures as words of length n over alphabet {e1, . . . , en}.\nI Definition 17. The code c(E) of proof structure E is constructed as follows: if `i and `j are connected by E , then the i-th letter of c(E) is ej and the j-th letter is ei.\nThe code of a proof structure is always an involutive permutation of e1, . . . , en. We are going to define two languages, P1 and P2, with the following properties:\n1. P1 = {c(E) | E is a proof net}; 2. c(E) \u2208 P2 iff E respects sisterhood.\nNote that in the condition for P2 we say nothing about words that are not of the form c(E). Some of these words could also belong to P2. Nevertheless, w \u2208 P1 \u2229 P2 iff w = c(E) for some pairing E that is a proof net and respects sisterhood. Therefore, the sequent is derivable in Lb\u2217 iff P1 \u2229 P2 6= \u2205.\nNow the algorithm that checks derivability in Lb\u2217 works as follows: it constructs a contextfree grammar for P1 \u2229 P2 and checks whether the language generated by this grammar is non-empty. Notice that the existence of such a grammar is trivial, since the language is finite. However, it could be of exponential size, and we\u2019re going to construct a grammar of size poly(n, 2d, nb), and do it in polynomial time.\nFor P1, we use the construction from [31]. As the complexity measure (size) of a context-free grammar, |G1|, we use the summary length of its rules.\nI Theorem 18 (M. Pentus 2010). There exists a context-free grammar G1 of size poly(n, 2d) that generates P1. Moreover, this grammar can be obtained from the original sequent by an algorithm with working time also bounded by poly(n, 2d).\nThis theorem is stated as a remark in [31]. We give a full proof of it in Section 6. Next, we construct a finite automaton for a language that satisfies the condition for P2.\nI Lemma 19. There exists a deterministic finite automaton with poly(n, nb) states that generates a language P2 over alphabet {e1, . . . , en} such that c(E) \u2208 P2 iff E respects sisterhood. Moreover, this finite automaton can be obtained from the original sequent by an algorithm with working time poly(n, nb).\nProof. First we describe this automaton informally. Its memory is organised as follows: it includes a pointer i to the current letter of the word (a number from 1 to n+ 1) and a stack that can be filled with letters of {e1, . . . , en}. In the beginning, i = 1 and the stack is empty. At each step (while i \u2264 n), the automaton looks at `i. If it is not a bracket, the automaton increases the pointer and proceeds to the next letter in the word. If it is a bracket, let its sister bracket be `j . Denote the i-th (currently being read) letter of the word by ei\u2032 . If `i\u2032 is not a bracket, yield \u201cno\u201d (bracket is connected to non-bracket). Otherwise let `j\u2032 be the sister of `i\u2032 and consider two cases. 1. j > i. Then push ej\u2032 on top of the stack, increase the pointer and continue.\n2. j < i. Then pop the letter from the top of the stack and compare it with ei\u2032 . If they do not coincide, yield \u201cno\u201d. Otherwise increase the pointer and continue. If i = n+ 1 and the stack is empty, yield \u201cyes\u201d. Since sister brackets are well-nested, on the i-th step we pop from the stack the symbol that was pushed there on the j-th step (if `i and `j are sister brackets and j < i). Thus, the symbol popped from the stack contains exactly the information that, if the bracket `j is connected to `j\u2032 , then the bracket `i should be connected to the sister bracket `i\u2032 , and we verify the fact that E satisfies this condition by checking that the i-th letter is actually ei\u2032 .\nNote that here we do not check the fact the word really encodes some proof structure E , since malformed codes will be ruled out by the intersection with P1.\nIf the bracket nesting depth is b, we\u2019ll never have more than b symbols on the stack. For each symbol we have n possibilities (e1, . . . , en). Therefore, the total number of possible states of the stack is 1 + n+ n2 + . . .+ nb \u2264 (b+ 1) \u00b7 nb. The pointer has (n+ 1) possible values. Thus, the whole number of possible memory states is (n+ 1) \u00b7 (b+ 1) \u00b7 nb + 1 (the last \u201c+1\u201d is for the \u201cfailure\u201d state, in which the automaton stops to yield \u201cno\u201d).\nFormally, our automaton is a tuple A2 = \u3008Q,\u03a3, \u03b4, q0, {qF }\u3009, where \u03a3 = {e1, . . . , en} is the alphabet, Q = {1, . . . , n+ 1} \u00d7 \u03a3\u2264b \u222a {\u22a5}, where \u03a3\u2264b is the set of all words over \u03a3 of length not greater than b, is the set of possible states (\u22a5 is the \u201cfailure\u201d state), q0 = \u30081, \u03b5\u3009 is the initial state, qF = \u3008n+ 1, \u03b5\u3009 is the final (acception) state, and \u03b4 \u2282 Q\u00d7 \u03a3\u00d7Q is a set of transitions defined as follows:\n\u03b4 = {\u3008i, \u03be\u3009 ei\u2032\u2212\u2212\u2192 \u3008i+ 1, \u03be\u3009 | `i is not a bracket}\n\u222a {\u3008i, \u03be\u3009 ei\u2032\u2212\u2212\u2192 \u22a5 | `i is a bracket and `i\u2032 is not a bracket}\n\u222a {\u3008i, \u03be\u3009 ei\u2032\u2212\u2212\u2192 \u3008i+ 1, \u03beej\u2032\u3009 | `i is a bracket, its sister bracket is `j , j > i; `i\u2032 is a bracket, its sister bracket is `j\u2032}\n\u222a {\u3008i, \u03beei\u2032\u3009 ei\u2032\u2212\u2212\u2192 \u3008i+ 1, \u03be\u3009 | `i is a bracket, its sister bracket is `j , j < i}\n\u222a {\u3008i, \u03beei\u2032\u2032\u3009 ei\u2032\u2212\u2212\u2192 \u22a5 | `i is a bracket, its sister bracket is `j , j < i, and i\u2032 6= i\u2032\u2032}.\nA2 is a deterministic finite automaton with not more than (n+1) \u00b7 (b+1) \u00b7nb +1 = poly(n, nb) states, and it generates a language P2 such that c(E) \u2208 P2 iff E respects sisterhood.\nIn the RAM model, each transition is computed in constant time, and the total number of transitions is not more than |Q|2 \u00b7 n \u2264 ((n + 1) \u00b7 (b + 1) \u00b7 nb + 1)2 \u00b7 n, which is also poly(n, nb). J\nNow we combine Theorem 18 and Lemma 19 to obtain a context-free grammar G for P1 \u2229 P2 of size poly(|G1|, |A2|, |\u03a3|), where |A2| is the number of states of A2. For this we use the following well-known result:\nI Theorem 20. If a context-free grammar G1 defines a language P1 over an alphabet \u03a3 and a deterministic finite automaton A2 defines a language P2 over the same alphabet, then there exists a context-free grammar G that defines P1 \u2229 P2, the size of this grammar is poly(|G1|, |A2|, |\u03a3|), and, finally, this grammar can be obtained from G1 and A2 by an algorithm with working time also poly(|G1|, |A2|, |\u03a3|).\nFor this theorem we use the construction from [11, Theorem 3.2.1] that works directly with the context-free formalism and this makes the complexity estimation straightforward. Since |G1| = poly(n, 2d), |A2| = poly(n, nb), and |\u03a3| = n, |G2| is poly(n, 2d, nb). Finally, checking derivability of the sequent is equivalent to checking the non-emptiness of the language P1\u2229P2, which is done using the following theorem [11, Lemma 1.4.3a and Theorem 4.1.2a]:\nI Theorem 21. There exists an algorithm that checks whether the language generated by a context-free grammar G is non-empty, with poly(|G|) working time.\nThe whole algorithm described in this section works in poly(n, 2d, nb) = poly(||\u0393 \u2192 C||, 2ord(\u0393\u2192C), ||\u0393\u2192 C||b(\u0393\u2192C)) time, as required in Theorem 4.\n6 Proof of Theorem 18 (Pentus\u2019 Construction Revisited)\nIn our algorithm, described in Section 5, we use Pentus\u2019 polynomial-size context-free grammar, that generates all proof nets, as a black box: we need only Theorem 18 itself, not the details of the construction in its proof. However, Pentus [31] doesn\u2019t explicitly formulate this theorem, but rather gives it as side-effect of the construction for checking existence of a proof net (e.g., non-emptiness of the context-free language). The latter is, unfortunately, not sufficient for our needs. Moreover, we use slightly different complexity parameters. Therefore, and also in order to make our paper logically self-contained, in this section we redisplay Pentus\u2019 construction in more detail, in other words, prove Theorem 18.\nPentus\u2019 idea for seeking proof nets is based on dynamic programming. In \u2126\u0393\u2192C , connective and literal occurrences alternate: c1, `1, c2, `2, . . . , cn, `n. Consider triples of the form (i, j, k), where 1 \u2264 i \u2264 j \u2264 k \u2264 n.\nI Definition 22. An (i, j, k)-segment E\u0303 is a planar pairing of literals from {`i, . . . , `k\u22121} such that in every region created by E\u0303 there exists a unique O or occurrence from {ci, . . . , ck} that belongs to this region, and, in particular, this occurrence for the outer (infinite) region is cj , called the open par. If k = j = i, then E\u0303 is empty, and ci should be a O or occurrence.\nFor each E\u0303 we construct the corresponding A\u0303 that connects each \u2297 occurrence to the only O or in the same region; for the outer region, it uses the open par.\nI Definition 23. An (i, j, k)-segment E\u0303 is correct, if the graph A\u0303 \u222a \u227a is acyclic.\nFor each (i, j, k)-segment, in the non-terminals of the grammar we keep a small amount of information, which we call the \u201cghost\u201d of the segment and that is sufficient to construct bigger segments (and, finally, the whole proof net) from smaller ones.\nI Definition 24. A \u2297 occurrence is called dominant, if it is not immediately dominated (in the \u227a preorder) by another \u2297 occurrence. For each \u2297 occurrence c there exists a unique dominant \u2297 occurrence \u03c4(c) such that \u03c4(c) c and on the \u227a path from c to \u03c4(c) all occurrences are \u2297 occurrences.\nLet\u2019s call two \u2297 occurrences equivalent, c \u2248 c\u2032, if \u03c4(c) = \u03c4(c\u2032). Equivalent \u2297 occurrences form clusters; from each cluster we pick a unique representative, the \u227a-maximal occurrence \u03c4(c). By - we denote the transitive closure of \u227a\u222a\u2248: c - c\u2032 means that there is a path from c to c\u2032 that goes along \u227a and also could go in the inverse direction, but only from \u2297 to \u2297 with no O or in between.\nI Lemma 25. For an (i, j, k)-segment E\u0303, the graph A\u0303 \u222a \u227a is acyclic iff the graph A\u0303 \u222a- is acyclic. For a proof structure E, the graph A\u0303 \u222a \u227a is acyclic iff any cycle in A\u0303 \u222a- is a trivial \u2248-cycle in a cluster. [31, Lemma 6.2]\nProof. Pentus proves this lemma by a topological argument. If A\u0303 \u222a- has non-trivial cycles, take a simple cycle (i.e. a cycle where no vertex appears twice) that embraces the smallest area. If this cycle includes a link from c to d where c \u2248 d and c d, then consider the A\u0303 link\nthat goes from c. This link should go inside the cycle, and, continuing by this link, one could construct a new cycle with a smaller area embraced. Contradiction. The other direction is trivial, since every cycle in A\u0303 \u222a \u227a is a non-trivial cycle in A\u0303 \u222a-. J\nIn view of this lemma we can now use - instead of \u227a in the correctness (acyclicity) criteria for proof nets and (i, j, k)-segments.\nI Definition 26. For a connective occurrence ci let Vi be the set of all dominant \u2297 occurrences on the \u227a path from ci to the root of the parse tree.\nSince each dominant \u2297 marks a point of alternation between \u2297 and O (or , on the top level), and the number of such alternations is bounded by d, we have |Vi| \u2264 d for any i.\nI Definition 27. The ghost of an (i, j, k)-segment E\u0303 , denoted by R, is the restriction of the transitive closure of A\u0303 \u222a- to the set Vi \u222a Vj \u222a Vk that is forced to be irreflexive (in other words, we remove trivial \u2248-cycles). An (i, j, k)-ghost is an arbitrary transitive irreflexive relation on Vi \u222a Vj \u222a Vk.\nI Lemma 28. The number of different (i, j, k)-ghosts is poly(2d).\nProof. Let |Vi| = d1, |Vj | = d2, |Vk| = d3 (these three numbers are not greater than d). Each ghost includes three chains, Qi, Qj , and Qk, and it remains to count the number of possible connections between them. Due to transitivity, if a vertex in Vi is connected to a vertex in Vj , then it is also connected to all greater vertices. Now we represent elements of Vj as d2 white balls, and put d1 black balls between them. The i-th black ball is located in such a place that the i-th vertex of Vi is connected to all vertices of Vj that are greater than the position of the i-th ball, and only to them. Due to transitivity, the order of black balls is the same as Qi. The number of possible distributions of white and black balls is(\nd1+d2 d1\n) < 2d1+d2 \u2264 22d. Doing the same for all 6 pairs of 3 chains, we get the estimation\n(22d)6 = (2d)12 = poly(2d) for the number of (i, j, k)-ghosts. J\nNow we define the context-free grammar G1. Non-terminal symbols of this grammar include the starting symbol S and symbols Fi,j,k,R for any triple (i, j, k) (1 \u2264 i \u2264 j \u2264 k \u2264 n) and any (i, j, k)-ghost R. The meaning of these non-terminals is in the following statement, which will be proved by induction after we present the rules of G1: a word w is derivable from Fi,j,k,R iff w = c(E\u0303) for a correct (i, j, k)-segment E\u0303 with ghost R; a word w is derivable from S iff w = c(E) for some proof net E . (Codes of (i, j, k)-segments are defined in the same way as codes of proof structures, as involutive permutations of ei, . . . , ek\u22121.)\nFor the induction base case, i = j = k, we take only those values of i such that ci is a O or occurrence, and denote by Qi the \u227a relation restricted to Vi (this is the trivial ghost of an empty (i, i, i)-segment); Qi is always acyclic, and an isolated O or occurrence ci is always a correct (i, i, i)-segment (with an empty E\u0303), and ci is its open par. Now for each O or occurrence ci we add the following rule to the grammar (this is a \u03b5-rule, the right-hand side is empty):\nFi,i,i,Qi \u21d2 .\nNext, consider the non-trivial situation, where i < k. The difference k\u2212 i should be even, otherwise there couldn\u2019t exist a literal pairing E\u0303 . Moreover, if both ci and ck are O or occurrences, a correct (i, j, k)-segment also couldn\u2019t exist, since in the outer region we have at least two O or occurrences, namely, ci and ck. Therefore, we include rules for Fi,j,k,R only if k\u2212 i is even and at least one of ci and ck should be \u2297. Let it be ci (Pentus\u2019 situation of the first kind). The ck case (Pentus\u2019 situation of the second kind) is handled symmetrically.\nWe take the leftmost literal occurrence, `i, and find all possible occurrences among `i+1, . . . , `k\u22121 that could be connected to `i (i.e., if `i is an occurrence of q, we seek for q\u0304, and vice versa). For each such occurrence, `h\u22121, we consider two triples, (i + 1, j\u2032, h \u2212 1) and (h, j, k), and all possible (i+ 1, j\u2032, h\u2212 1)- and (h, j, k)-ghosts, R1 and R2, respectively. For each such pair, R1 and R2, we consider the transitive closure of the following relation: R1 \u222aR2 \u222aQi \u222a {\u3008\u03c4(ci), d\u3009 | d \u2208 Vj}. If it is irreflexive (acyclic), its restriction to Vi \u222a Vj \u222a Vk, denoted by R, will become a ghost of an (i, j, k)-segment. For this, we add the following rule to the grammar:\nFi,j,k,R \u21d2 eh\u22121 Fi+1,j\u2032,h\u22121,R1 ei Fh,j,k,R2 .\nI Lemma 29. In this grammar, a word w can be derived from Fi,j,k,R iff w = c(E\u0303) for some (i, j, k)-segment E with ghost R.\nProof. Proceed by induction on k \u2212 i. The base case (i = j = k) was considered above. For the \u201conly if\u201d part, let w be derived by a rule for the first kind (the second kind is symmetric). Then w = eh\u22121w1eiw2, and by induction hypothesis w1 and w2 encode (i + 1, j\u2032, h \u2212 1)- and (h, j, k)-segments with ghosts R1 and R2 respectively. The word w encodes an (i, j, k)-segment, and it remains to show that this segment is correct and its ghost is R. For this new segment, A\u0303 = A\u03031 \u222a A\u03032 \u222a \u3008ci, cj\u3009. Suppose there is a non-trivial cycle in A\u0303 \u222a -. Since all cycles in A\u03031 \u222a - and A\u03032 \u222a - are trivial, this cycle should either include links from both A\u03031 and A\u03032 or use the new \u3008ci, cj\u3009 connection (or both). The cycle, however, cannot cross E\u0303 links, therefore the only way of \u201clegally crossing the border\u201d between segments is by going through \u2297 occurrences that dominate ci, ci+1, ch\u22121, ch, or ck. We can assume that these \u201cborder crossing points\u201d are dominant \u2297 occurrences (otherwise we can add a \u2248-detour to the cycle). Then the cycle is actually a concatenation of parts of the following three kinds: (1) connecting vertices of Vi+1 \u222a Vh\u22121; (2) connecting vertices of Vh \u222a Vk; (3) connecting \u03c4(ci), via cj , to a vertex d of Vj . In this case, our cycle induces a cycle in R1 \u222aR2 \u222aQi \u222a {\u3008\u03c4(ci), d\u3009 | d \u2208 Vj}, which is impossible by definition.\nIt remains to show that R is the ghost of the newly constructed segment. Indeed, R is a binary relation on Vi \u222a Vj \u222a Vk and is included into the transitive closure of A\u0303 \u222a-, therefore R is a subrelation of the ghost. On the other hand, if there is a pair \u3008c, d\u3009 in the ghost, then there is a path from c to d and, as shown above, it can be split into parts of kinds (1), (2), and (3). Thus, \u3008c, d\u3009 \u2208 R, and therefore R coincides with the ghost.\nFor the \u201cif\u201d part, if ci in an (i, j, k)-segment is a \u2297 occurrence, consider the E\u0303 link from the literal occurrence `i. It splits the segment into two ones. For each of them, by induction hypothesis, we generate their codes from Fi+1,j\u2032,h\u22121,R1 and Fh,j,k,R2 respectively, and then apply the rule to generate the code of the original segment. Situations of the second kind, where ck is a \u2297 occurrence, are handled symmetrically. J\nFinally, we add rules for the starting symbol. These rules are analogous to the rules for situations of the second kind. Take `n and find all possible occurrences among `1, . . . , `n\u22121 that could be connected to it. For each such occurrence `h and any pair of (0, 0, h)- and (h+ 1, j\u2032, n)-ghosts, R1 and R2, respectively (in the first segment j = 0, since in the whole proof net the open par should be the leftmost occurrence of ), consider the transitive closure of R1 \u222aR2. If it is irreflexive, then we add the following rule to the grammar:\nS \u21d2 F0,0,h,R1 en Fh+1,j\u2032,n,R2 eh.\nI Lemma 30. A word w can be derived from S iff w = c(E\u0303) for some proof net E.\nProof. Analogous to the previous lemma. J\nThis lemma shows that we\u2019ve constructed a grammar that generates P1. Now to finish the proof of Theorem 18 it remains to establish complexity bounds. The number of non-terminal symbols is bounded by n3 \u00b7K + 1, where K is the maximal number of (i, j, k)-ghosts. Since each rule has length at most 5 (1 non-terminal on the left and 4 symbols on the right), |G1| is bounded by 5(n3 \u00b7K + 1), and, since K is poly(2d) (Lemma 28), |G1| is poly(2d, n). Clearly, the procedure that generates G1 from the original sequent is also polynomial in running time: acyclicity checks for each rule are performed in poly(n) time, and the number of rules is poly(2d, n).\n7 Conclusions and Future Work\nIn this paper, we\u2019ve presented an algorithm for provability in the Lambek calculus with brackets. Our algorithm runs in polynomial time w.r.t. the size of the input sequent, if its order and bracket nesting depth are bounded.\nWe summarize some questions raised for future research. First, Pentus [31] also presents a parsing procedure for Lambek categorial grammars. Our intention is to develop an efficient parsing procedure for grammars with brackets. Second, the problem whether Lb\u2217grammars define exactly context-free languages is still open (the counter-example by Fadda and Morrill [8] jeopardises J\u00e4ger\u2019s claim). Third, in our calculus we allow empty antecedents. We are going to modify our algorithm for the bracketed extension of the original Lambek calculus, using a modified notion of proof nets (see for example [19][17]). A more general question is to extend the algorithm to other enrichments of the Lambek calculus (see, for example, [24]), keeping polynomiality, if possible. Notice that some of these enrichments are generally undecidable [15], so it is interesting to find feasible bounded fragments.\nAcknowledgements. The authors are grateful to Mati Pentus for in-depth comments on his algorithm [31].\nReferences 1 V. M. Abrusci. Non-commutative proof nets. In J.-Y. Girard, Y. Lafont, and L. Regnier,\neditors, Advances in Linear Logic. Cambridge University Press, 1995. 2 K. Ajdukiewicz. Die syntaktische Konnexit\u00e4t. Studia Philosophica, 1:1\u201327, 1935. 3 Y. Bar-Hillel. A quasi-arithmetical notation for syntactic description. Language, 29:47\u201358,\n1953. 4 W. Buszkowski. Type logics in grammar. In Trends in Logic: 50 Years of Studia Logica,\npages 337\u2013382. Springer, 2003. 5 B. Carpenter. Type-Logical Semantics. MIT Press, Cambridge, MA, 1997. 6 V. Danos and L. Regnier. The structure of multiplicatives. Arch. Math. Log., 28:181\u2013203,\n1989. 7 Ph. de Groote. A dynamic programming approach to categorial deduction. In Harald\nGanzinger, editor, Proc. CADE 1999, volume 1632 of Lect. Notes Comput. Sci., pages 1\u201315, Trento, 1999. Springer. 8 M. Fadda and G. Morrill. The Lambek calculus with brackets. In Language and Grammar: Studies in Mathematical Linguistics and Natural Language, pages 113\u2013128. CSLI, Jan 2005. 9 T. Fowler. Efficient parsing with the product-free Lambek calculus. In Proc. COLING 2008, 2008. 10 T. Fowler. A polynomial time algorithm for parsing with the bounded order Lambek calculus. In Proc. MoL 2009, 2009. 11 S. Ginsburg. The mathematical theory of context-free languages. McGraw-Hill, 1966.\n12 J.-Y. Girard. Linear logic. Theor. Comput. Sci., 50:1\u2013102, 1987. 13 G. J\u00e4ger. On the generative capacity of multi-modal categorial grammars. Research on Language and Computation, 1(1\u20132):105\u2013125, 2003. 14 G. J\u00e4ger. Anaphora and Type Logical Grammar, volume 24 of Trends in Logic \u2013 Studia Logica Library. Springer, Dordrecht, 2005. 15 M. Kanovich, S. Kuznetsov, and A. Scedrov. Undecidability of the Lambek calculus with a relevant modality. ArXiv e-prints, 2016. arXiv:1601.06303. 16 N. Kurtonina. Frames and labels. A modal analysis of categorial inference. PhD thesis, Universiteit Utrecht, ILLC, Amsterdam, 1995. 17 S. Kuznetsov. Lambek grammars with one division and one primitive type. Log. J. IGPL, 20(1):207\u2013221, 2012. 18 S. L. Kuznetsov. On translating Lambek grammars with one division into context-free grammars. Proc. Steklov Inst. Math., 294:129\u2013138, 2016. 19 F. Lamarche and C. Retor\u00e9. Proof nets for the Lambek calculus\u2014an overview. In V. M.\nAbrusci and C. Casadio, editors, Proofs and Linguistic Categories, Proc. 1996 Roma Workshop, pages 241\u2013262. CLUEB, 1996.\n20 J. Lambek. The mathematics of sentence structure. Amer. Math. Mon., 65:154\u2013170, 1958. 21 M. Moortgat. Multimodal linguistic inference. J. Log. Lang. Inform., 5(3, 4):349\u2013385, 1996. 22 R. Moot and C. Retor\u00e9. The Logic of Categorial Grammars: A Deductive Account of Natural Language Syntax and Semantics. Springer, Heidelberg, 2012. 23 G. Morrill. Categorial formalisation of relativisation: pied piping, islands, and extraction sites. Technical Report LSI-92-23-R, Universitat Polit\u00e8cnica de Catalunya, 1992. 24 G. V. Morrill. Categorial Grammar: Logical Syntax, Semantics, and Processing. Oxford University Press, 2011. 25 M. Nagayama and M. Okada. A graph-theoretic characterization theorem for multiplicative fragment of non-commutative linear logic. Theor. Comput. Sci., 294:551\u2013573, 2003. 26 G. Penn. A graph-theoretic approach to sequent derivability in the Lambek calculus. Electr. Notes Theor. Comput. Sci., 53, 2002. 27 M. Pentus. Lambek grammars are context-free. In Proc. LICS 1993, pages 430\u2013433, Montreal, 1993. 28 M. Pentus. Models for the Lambek calculus. Ann. Pure Appl. Log., 75(1\u20132):179\u2013213, 1995. 29 M. Pentus. Free monoid completeness of the Lambek calculus allowing empty premises, volume 12 of Lecture Notes in Logic, pages 171\u2013209. Springer-Verlag, Berlin, 1998. 30 M. Pentus. Lambek calculus is NP-complete. Theor. Comput. Sci., 357(1):186\u2013201, 2006. 31 M. Pentus. A polynomial-time algorithm for Lambek grammars of bounded order. Linguistic Analysis, 36(1\u20134):441\u2013471, 2010. 32 Yu. Savateev. Unidirectional Lambek grammars in polynomial time. Theory Comput. Syst., 46(4):662\u2013672, 2010. 33 K. Versmissen. Grammatical composition: modes, models, modalities. PhD thesis, OTS Utrecht, 1996. 34 D. N. Yetter. Quantales and (noncommutative) linear logic. J. Symb. Log., 55(1):41\u201364,\n1990."}], "references": [{"title": "Non-commutative proof nets", "author": ["V.M. Abrusci"], "venue": "Advances in Linear Logic", "citeRegEx": "Abrusci.,? \\Q1995\\E", "shortCiteRegEx": "Abrusci.", "year": 1995}, {"title": "Die syntaktische Konnexit\u00e4t", "author": ["K. Ajdukiewicz"], "venue": "Studia Philosophica,", "citeRegEx": "Ajdukiewicz.,? \\Q1935\\E", "shortCiteRegEx": "Ajdukiewicz.", "year": 1935}, {"title": "A quasi-arithmetical notation for syntactic description", "author": ["Y. Bar-Hillel"], "venue": "Language, 29:47\u201358,", "citeRegEx": "Bar.Hillel.,? \\Q1953\\E", "shortCiteRegEx": "Bar.Hillel.", "year": 1953}, {"title": "Type logics in grammar. In Trends in Logic: 50 Years of Studia Logica, pages 337\u2013382", "author": ["W. Buszkowski"], "venue": null, "citeRegEx": "Buszkowski.,? \\Q2003\\E", "shortCiteRegEx": "Buszkowski.", "year": 2003}, {"title": "Type-Logical Semantics", "author": ["B. Carpenter"], "venue": null, "citeRegEx": "Carpenter.,? \\Q1997\\E", "shortCiteRegEx": "Carpenter.", "year": 1997}, {"title": "The structure of multiplicatives", "author": ["V. Danos", "L. Regnier"], "venue": "Arch. Math. Log.,", "citeRegEx": "Danos and Regnier.,? \\Q1989\\E", "shortCiteRegEx": "Danos and Regnier.", "year": 1989}, {"title": "A dynamic programming approach to categorial deduction", "author": ["Ph. de Groote"], "venue": "Proc. CADE 1999,", "citeRegEx": "Groote.,? \\Q1999\\E", "shortCiteRegEx": "Groote.", "year": 1999}, {"title": "The Lambek calculus with brackets. In Language and Grammar: Studies in Mathematical Linguistics and Natural Language, pages 113\u2013128", "author": ["M. Fadda", "G. Morrill"], "venue": null, "citeRegEx": "Fadda and Morrill.,? \\Q2005\\E", "shortCiteRegEx": "Fadda and Morrill.", "year": 2005}, {"title": "Efficient parsing with the product-free Lambek calculus", "author": ["T. Fowler"], "venue": "In Proc. COLING 2008,", "citeRegEx": "Fowler.,? \\Q2008\\E", "shortCiteRegEx": "Fowler.", "year": 2008}, {"title": "The mathematical theory of context-free languages", "author": ["S. Ginsburg"], "venue": null, "citeRegEx": "Ginsburg.,? \\Q1966\\E", "shortCiteRegEx": "Ginsburg.", "year": 1966}, {"title": "On the generative capacity of multi-modal categorial grammars", "author": ["J.-Y. Girard"], "venue": "Linear logic. Theor. Comput. Sci.,", "citeRegEx": "Girard.,? \\Q1987\\E", "shortCiteRegEx": "Girard.", "year": 1987}, {"title": "Anaphora and Type Logical Grammar, volume 24 of Trends in Logic", "author": ["G. J\u00e4ger"], "venue": "Language and Computation,", "citeRegEx": "J\u00e4ger.,? \\Q2003\\E", "shortCiteRegEx": "J\u00e4ger.", "year": 2003}, {"title": "Undecidability of the Lambek calculus with", "author": ["M. Kanovich", "S. Kuznetsov", "A. Scedrov"], "venue": "Logica Library. Springer, Dordrecht,", "citeRegEx": "Kanovich et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kanovich et al\\.", "year": 2005}, {"title": "Frames and labels. A modal analysis of categorial inference", "author": ["N. Kurtonina"], "venue": "a relevant modality. ArXiv e-prints,", "citeRegEx": "Kurtonina.,? \\Q2016\\E", "shortCiteRegEx": "Kurtonina.", "year": 2016}, {"title": "Lambek grammars with one division and one primitive type", "author": ["S. Kuznetsov"], "venue": "Log. J. IGPL,", "citeRegEx": "Kuznetsov.,? \\Q1995\\E", "shortCiteRegEx": "Kuznetsov.", "year": 1995}, {"title": "On translating Lambek grammars with one division into context-free", "author": ["S.L. Kuznetsov"], "venue": null, "citeRegEx": "Kuznetsov.,? \\Q2012\\E", "shortCiteRegEx": "Kuznetsov.", "year": 2012}, {"title": "Proof nets for the Lambek calculus\u2014an overview", "author": ["M. V"], "venue": "grammars. Proc. Steklov Inst. Math.,", "citeRegEx": "V.,? \\Q2016\\E", "shortCiteRegEx": "V.", "year": 2016}, {"title": "Multimodal linguistic inference", "author": ["M. Moortgat"], "venue": "CLUEB,", "citeRegEx": "Moortgat.,? \\Q1996\\E", "shortCiteRegEx": "Moortgat.", "year": 1996}, {"title": "Natural Language Syntax and Semantics", "author": ["G. Morrill"], "venue": null, "citeRegEx": "Morrill.,? \\Q2012\\E", "shortCiteRegEx": "Morrill.", "year": 2012}, {"title": "A graph-theoretic characterization theorem for multiplicative", "author": ["M. Nagayama", "M. Okada"], "venue": null, "citeRegEx": "Nagayama and Okada.,? \\Q2011\\E", "shortCiteRegEx": "Nagayama and Okada.", "year": 2011}, {"title": "A graph-theoretic approach to sequent derivability in the Lambek calculus", "author": ["G. Penn"], "venue": "non-commutative linear logic. Theor. Comput. Sci.,", "citeRegEx": "Penn.,? \\Q2003\\E", "shortCiteRegEx": "Penn.", "year": 2003}, {"title": "Lambek grammars are context-free", "author": ["M. Pentus"], "venue": "Notes Theor. Comput. Sci.,", "citeRegEx": "Pentus.,? \\Q2002\\E", "shortCiteRegEx": "Pentus.", "year": 2002}, {"title": "Models for the Lambek calculus", "author": ["M. Pentus"], "venue": "Montreal,", "citeRegEx": "Pentus.,? \\Q1993\\E", "shortCiteRegEx": "Pentus.", "year": 1993}, {"title": "Logic, pages 171\u2013209", "author": ["M. Pentus"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Pentus.,? \\Q1998\\E", "shortCiteRegEx": "Pentus.", "year": 1998}, {"title": "Grammatical composition: modes, models, modalities", "author": ["K. Versmissen"], "venue": "PhD thesis,", "citeRegEx": "Versmissen.,? \\Q2010\\E", "shortCiteRegEx": "Versmissen.", "year": 2010}], "referenceMentions": [{"referenceID": 21, "context": "Pentus (2010) gave a polynomial-time algorithm for determining provability of bounded depth formulas in L\u2217, the Lambek calculus with empty antecedents allowed.", "startOffset": 0, "endOffset": 14}], "year": 2017, "abstractText": "Lambek calculus is a logical foundation of categorial grammar, a linguistic paradigm of grammar as logic and parsing as deduction. Pentus (2010) gave a polynomial-time algorithm for determining provability of bounded depth formulas in L\u2217, the Lambek calculus with empty antecedents allowed. Pentus\u2019 algorithm is based on tabularisation of proof nets. Lambek calculus with brackets is a conservative extension of Lambek calculus with bracket modalities, suitable for the modeling of syntactical domains. In this paper we give an algorithm for provability in Lb\u2217, the Lambek calculus with brackets allowing empty antecedents. Our algorithm runs in polynomial time when both the formula depth and the bracket nesting depth are bounded. It combines a Pentus-style tabularisation of proof nets with an automata-theoretic treatment of bracketing. Digital Object Identifier 10.4230/LIPIcs...", "creator": "LaTeX with hyperref package"}}}