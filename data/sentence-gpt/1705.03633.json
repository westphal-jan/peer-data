{"id": "1705.03633", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-May-2017", "title": "Inferring and Executing Programs for Visual Reasoning", "abstract": "Existing methods for visual reasoning attempt to directly map inputs to outputs using black-box architectures without explicitly modeling the underlying reasoning processes. As a result, these black-box models often learn to exploit biases in the data rather than learning to perform visual reasoning. Inspired by module networks, this paper proposes a model for visual reasoning that consists of a program generator that constructs an explicit representation of the reasoning process to be performed, and an execution engine that executes the resulting program to produce an answer. Both the program generator and the execution engine are implemented by neural networks, and are trained using a combination of backpropagation and REINFORCE. Using the CLEVR benchmark for visual reasoning, we show that our model significantly outperforms strong baselines and generalizes better in a variety of settings.\n\n\n\nThe paper explores the use of two common backpropagation and re-propagation approaches that allow visual reasoning to be performed more efficiently. As described above, there are several other ways for the generation of neural networks in which we perform visual reasoning.\nWe present two methods for visual reasoning:\n1. Convolutional Neural Networks (CNN), using neural networks for multiple inputs\n2. Neural networks that use the same features as the image processing models\n3. Neural networks that use the same visual reasoning systems\n4. Neural networks that use the same algorithms as the image processing models\n5. Neural networks that use the same algorithms as the image processing models\n6. Neural networks that use the same algorithms as the image processing models\n7. Neural networks that use the same algorithms as the image processing models\n8. Neural networks that use the same algorithm as the image processing models\n9. Neural networks that use the same algorithms as the image processing models\n10. Neural networks that use the same algorithms as the image processing models\n11. Neural networks that use the same algorithms as the image processing models\n12. Neural networks that use the same algorithms as the image processing models\n13. Neural networks that use the same algorithms as the image processing models\n14. Neural networks that use the same algorithms as the image processing models\n15. Neural networks that use the same algorithms as the image processing models\n16. Neural networks that use the same algorithms as the image processing models\n17. Neural networks that use the same algorithms as the image processing models\n18. Neural networks that use the same algorithms as the image processing models\n19. Neural networks that use the same algorithms as the image processing models\n20. Neural networks that", "histories": [["v1", "Wed, 10 May 2017 07:08:23 GMT  (3905kb,D)", "http://arxiv.org/abs/1705.03633v1", null]], "reviews": [], "SUBJECTS": "cs.CV cs.CL cs.LG", "authors": ["justin johnson", "bharath hariharan", "laurens van der maaten", "judy hoffman", "li fei-fei", "c lawrence zitnick", "ross girshick"], "accepted": false, "id": "1705.03633"}, "pdf": {"name": "1705.03633.pdf", "metadata": {"source": "CRF", "title": "Inferring and Executing Programs for Visual Reasoning", "authors": ["Justin Johnson", "Bharath Hariharan", "Laurens van der Maaten", "Judy Hoffman", "Li Fei-Fei", "C. Lawrence Zitnick", "Ross Girshick"], "emails": [], "sections": [{"heading": "1. Introduction", "text": "In many applications, computer-vision systems need to answer sophisticated queries by reasoning about the visual world (Figure 1). To deal with novel object interactions or object-attribute combinations, visual reasoning needs to be compositional: without ever having seen a \u201cperson touching a bike\u201d, the model should be able to understand the phrase by putting together its understanding of \u201cperson\u201d, \u201cbike\u201d and \u201ctouching\u201d. Such compositional reasoning is a hallmark of human intelligence, and allows people to solve a plethora of problems using a limited set of basic skills [28].\nIn contrast, modern approaches to visual recognition learn a mapping directly from inputs to outputs; they do not explicitly formulate and execute compositional plans. Direct input-output mapping works well for classifying images [26] and detecting objects [10] for a small, fixed set of categories. However, it fails to outperform strong baselines on tasks that require the model to understand an exponentially large space of objects, attributes, actions, and interactions, such as visual question answering (VQA) [3, 51]. Instead, models that learn direct input-output mappings tend\nto learn dataset biases but not reasoning [7, 18, 19]. In this paper, we argue that to successfully perform complex reasoning tasks, it might be necessary to explicitly incorporate compositional reasoning in the model structure. Specifically, we investigate a new model for visual question answering that consists of two parts: a program generator and an execution engine. The program generator reads the question and produces a plan or program for answering the question by composing functions from a function dictionary. The execution engine implements each function using a small neural module, and executes the resulting module network on the image to produce an answer. Both the program generator and the modules in the execution engine are neural networks with generic architectures; they can be trained separately when ground-truth programs are available, or jointly in an end-to-end fashion.\nOur model builds on prior work on neural module networks that incorporate compositional reasoning [1, 2]. Prior module networks do not generalize well to new problems,\n1\nar X\niv :1\n70 5.\n03 63\n3v 1\n[ cs\n.C V\n] 1\n0 M\nay 2\n01 7\nbecause they rely on a hand-tuned program generator based on syntactic parsing, and on hand-engineered modules. By contrast, our model does not rely on such heuristics: we only define the function vocabulary and the \u201cuniversal\u201d module architecture by hand, learning everything else.\nWe evaluate our model on the recently released CLEVR dataset [19], which has proven to be challenging for stateof-the-art VQA models. The CLEVR dataset contains ground-truth programs that describe the compositional reasoning required to answer the given questions. We find that with only a small amount of reasoning supervision (9000 ground truth programs which is 2% of those available), our model outperforms state-of-the-art non-compositional VQA models by \u223c20 percentage points on CLEVR. We also show that our model\u2019s compositional nature allows it to generalize to novel questions by composing modules in ways that are not seen during training.\nThough our model works well on the algorithmically generated questions in CLEVR, the true test is whether it can answer questions asked by humans in the wild. We collect a new dataset of human-posed free-form natural language questions about CLEVR images. Many of these questions have out-of-vocabulary words and require reasoning skills that are absent from our model\u2019s repertoire. Nevertheless, when finetuned on this dataset without additional program supervision, our model learns to compose its modules in novel but intuitive ways to best answer new types of questions. The result is an interpretable mapping of freeform natural language to programs, and a \u223c9 point improvement in accuracy over the best competing models."}, {"heading": "2. Related Work", "text": "Our work is related to to prior research on visual question answering, reasoning-augmented models, semantic parsers, and (neural) program-induction methods.\nVisual question answering (VQA) is a popular proxy task for gauging the quality of visual reasoning systems [21, 44]. Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language. Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers. Recent work has questioned whether such systems are capable of developing visual reasoning capabilities: (1) very simple baseline models were found to perform competitively on VQA benchmarks by exploiting biases in the data [18, 50, 11] and (2) experiments on CLEVR, which was designed to control such biases, revealed that current systems do not learn to reason about spatial relationships or to learn disentangled representations [19].\nOur model aims to address these problems by explicitly constructing an intermediate program that defines the reasoning process required to answer the question. We show that our model succeeds on several kinds of reasoning where other VQA models fail.\nReasoning-augmented models add components to neural network models to facilitate the development of reasoning processes in such models. For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory. While long-term memory is likely to be a crucial component of intelligence, it is not a prerequisite for reasoning, especially the kind of reasoning that is required for answering questions about images.1 Therefore, we do not consider memory-augmented models in this study.\nModule networks are an example of reasoningaugmented models that use a syntactic parse of a question to determine the architecture of the network [1, 2, 16]. The final network is composed of trained neural modules that execute the \u201cprogram\u201d produced by the parser. The main difference between our models and existing module networks is that we replace hand-designed off-the-shelf syntactic parsers [24], which perform very poorly on complex questions such as those in CLEVR [19], by a learnt program generator that can adapt to the task at hand.\nSemantic parsers attempt to map natural language sentences to logical forms. Often, the goal is to answer natural language questions using a knowledge base [30]. Recent approaches to semantic parsing involve a learnt programmer [29]. However, the semantics of the program and the execution engine are fixed and known a priori, while we learn both the program generator and the execution engine.\nProgram-induction methods learn programs from input-output pairs by fitting the parameters of a neural network to predict the output that corresponds to a particular input value. Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49]. The recurrent networks may incorporate compositional structure that allows them to learn new programs by combining previously learned sub-programs [36].\nOur approach differs from prior work on program induction in (1) the type of input-output pairs that are used and (2) the way the domain-specific language is implemented. Prior work on neural program interpreters considers simple algorithms such as sorting of a list of integers; by contrast, we consider inputs that comprise an image and an associ-\n1Memory is likely indispensable in more complex settings such as visual dialogues or SHRDLU [6, 43].\nated question (in natural language). Program induction approaches also assume knowledge of the low-level operators such as arithmetic operations. In contrast, we use a learnt execution engine and assume minimal prior knowledge."}, {"heading": "3. Method", "text": "We develop a learnable compositional model for visual question answering. Our model takes as input an image x and a visual question q about the image. The model selects an answer a \u2208 A to the question from a fixed set A of possible answers. Internally, the model predicts a program z representing the reasoning steps required to answer the question. The model then executes the predicted program on the image, producing a distribution over answers.\nTo this end, we organize our system into two components: a program generator, z = \u03c0(q), which predicts programs from questions, and an execution engine, a = \u03c6(x, z), which executes a program z on an image x to predict an answer a. Both the program generator and the execution engine are neural networks that are learned from data. In contrast to prior work [1, 2], we do not manually design heuristics for generating or executing the programs.\nWe present learning procedures both for settings where (some) ground-truth programs are available during training, and for settings without ground-truth programs. In practice, our models need some program supervision during training, but we find that the program generator requires very few of such programs in order to learn to generalize (see Figure 4)."}, {"heading": "3.1. Programs", "text": "Like all programming languages, our programs are defined by syntax giving rules for building valid programs, and semantics defining the behavior of valid programs. We focus on learning semantics for a fixed syntax. Concretely, we fix the syntax by pre-specifying a set F of functions f , each of which has a fixed arity nf \u2208 {1, 2}. Because we are interested in visual question answering, we include in the vocabulary a special constant Scene, which represents the visual features of the image. We represent valid programs z as syntax trees in which each node contains a function f \u2208 F , and in which each node has as many children as the arity of the function f ."}, {"heading": "3.2. Program generator", "text": "The program generator z = \u03c0(q) predicts programs z from natural-language questions q that are represented as a sequence of words. We use a prefix traversal to serialize the syntax tree, which is a non-sequential discrete structure, into a sequence of functions. This allows us to implement the program generator using a standard LSTM sequence-tosequence model; see [39] for details.\nWhen decoding at test time, we simply take the argmax function at each time step. The resulting sequence of func-\ntions is converted to a syntax tree; this is straightforward since the arity of each function is known. Some generated sequences do not correspond to prefix traversals of a tree. If the sequence is too short (some functions do not have enough children) then we pad the sequence with Scene constants. If the sequence is too long (some functions have no parents) then unused functions are discarded."}, {"heading": "3.3. Execution engine", "text": "Given a predicted program z and and an input image x, the execution engine executes the program on the image, a = \u03c6(x, z), to predict an answer a. The execution engine is implemented using a neural module network [2]: the program z is used to assemble a question-specific neural network that is composed from a set of modules. For each function f \u2208 F , the execution engine maintains a neural network module mf . Given a program z, the execution engine creates a neural network m(z) by mapping each function f to its corresponding module mf in the order defined by the program: the outputs of the \u201cchild modules\u201d are used as input into their corresponding \u201cparent module\u201d.\nOur modules use a generic architecture, in contrast to [2]. A module of arity n receives n features maps of shape C\u00d7H\u00d7W and produces a feature map of shapeC\u00d7H\u00d7W . Each unary module is a standard residual block [14] with two 3\u00d73 convolutional layers. Binary modules concatenate their inputs along the channel dimension, project from 2C to C channels using a 1\u00d7 1 convolution, and feed the result to a residual block. The Scene module takes visual features as input (conv4 features from ResNet-101 [14] pretrained on ImageNet [37]) and passes these features through four\nconvolutional layers to output a C\u00d7H\u00d7W feature map. Using the same architecture for all modules ensures that every valid program z corresponds to a valid neural network which inputs the visual features of the image and outputs a feature map of shape C\u00d7H\u00d7W . This final feature map is flattened and passed into a multilayer perceptron classifier that outputs a distribution over possible answers."}, {"heading": "3.4. Training", "text": "Given a VQA dataset containing (x, q, z, a) tuples with ground truth programs z, we can train both the program generator and execution engine in a supervised manner. Specifically, we can (1) use pairs (q, z) of questions and corresponding programs to train the program generator, which amounts to training a standard sequence-to-sequence model; and (2) use triplets (x, z, a) of the image, program, and answer to train the execution engine, using backpropagation to compute the required gradients (as in [2]).\nAnnotating ground-truth programs for free-form natural language questions is expensive, so in practice we may have few or no ground-truth programs. To address this problem, we opt to train the program generator and execution engine jointly on (x, q, a) triples without ground-truth programs. However, we cannot backpropagate through the argmax operations in the program generator. Instead we replace the argmaxes with sampling and use REINFORCE [42] to estimate gradients on the outputs of the program generator; the reward for each of its outputs is the negative zero-one loss of the execution engine, with a moving-average baseline.\nIn practice, joint training using REINFORCE is difficult: the program generator needs to produce the right program without understanding what the functions mean, and the execution engine has to produce the right answer from programs that may not accurately implement the question asked. We propose a more practical semi-supervised learning approach. We first use a small set of ground-truth programs to train the program generator, then fix the program\ngenerator and train the execution engine using predicted programs on a large dataset of (x, q, a) triples. Finally, we use REINFORCE to jointly finetune the program generator and execution engine. Crucially, ground-truth programs are only used to train the initial program generator."}, {"heading": "4. Experiments", "text": "We evaluate our model on the recent CLEVR dataset [19]. Standard VQA methods perform poorly on this dataset, showing that it is a challenging benchmark. All questions are equipped with ground-truth programs, allowing for experiments with varying amounts of supervision.\nWe first perform experiments using strong supervision in the form of ground-truth programs. We show that in this strongly supervised setting, the combination of program generator and execution engine works much better on CLEVR than alternative methods. Next, we show that this strong performance is maintained when a small number of ground-truth programs, which capture only a fraction of question diversity, is used for training. Finally, we evaluate the ability of our models to perform compositional generalization, as well as generalization to free-form questions posed by humans. Code reproducing the results of our experiments is available from https://github.com/ facebookresearch/clevr-iep."}, {"heading": "4.1. Baselines", "text": "Johnson et al. [19] tested several VQA models on CLEVR. We reproduce these models as baselines here.\nQ-type mode: This baseline predicts the most frequent answer for each of the question types in CLEVR.\nLSTM: Similar to [3, 33], questions are processed with learned word embeddings followed by a word-level LSTM [15]. The final LSTM hidden state is passed to a multi-layer perceptron (MLP) that predicts a distribution over answers. This method uses no image information, so it\ncan only model question-conditional biases. CNN+LSTM: Images and questions are encoded using convolutional network (CNN) features and final LSTM hidden states, respectively. These features are concatenated and passed to a MLP that predicts an answer distribution.\nCNN+LSTM+SA [46]: Questions and images are encoded using a CNN and LSTM as above, then combined using two rounds of soft spatial attention; a linear transform of the attention output predicts the answer.\nCNN+LSTM+SA+MLP: Replaces the linear transform with an MLP for better comparison with the other methods.\nThe models that are most similar to ours are neural module networks [1, 2]. Unfortunately, neural module networks use a hand-engineered, off-the-shelf parser to produce programs, and this parser fails2 on the complex questions in CLEVR [19]. Therefore, we were unable to include module networks in our experiments."}, {"heading": "4.2. Strongly and semi-supervised learning", "text": "We first experiment with a model trained using full supervision: we use the ground-truth programs for all ques-\n2See supplemental material for example parses of CLEVR questions.\ntions in CLEVR to train both the program generator and the execution engine separately. The question answering accuracy of the resulting model on CLEVR is shown in Table 1 (Ours-strong). The results show that using strong supervision, our model can achieve near-perfect accuracy on CLEVR (even outperforming Mechanical Turk workers).\nIn practical scenarios, ground-truth programs are not available for all questions. We use the semi-supervised training process described in Section 3.4 to determine how many ground-truth programs are needed to match fully su-\npervised models. First, the program generator is trained in a supervised manner using a small number of questions and ground-truth programs; next, the execution engine is trained on all CLEVR questions, using predicted rather than ground-truth programs. Finally, both components are jointly finetuned without ground-truth programs. Table 1 shows the accuracy of semi-supervised models trained with 9K and 18K ground-truth programs (Ours-semi).\nThe results show that 18K ground-truth programs are sufficient to train a model that performs almost on par with a fully supervised model (that used all 700K programs for training). This strong performance is not due to the program generator simply remembering all programs: the total number of unique programs in CLEVR is approximately 450K. This implies that after observing only a small fraction (\u22644%) of all possible programs, the model is able to understand the underlying structure of CLEVR questions and use that understanding to generalize to new questions.\nFigure 4 analyzes how the accuracy of the predicted programs and the final answer vary with the number of groundtruth programs used. We measure the accuracy of the program generator by deserializing the function sequence produced by the program generator, and marking it as correct if it matches the ground-truth program exactly.3 Our results show that with about 20K ground-truth programs, the program generator achieves near perfect accuracy, and the final answer accuracy is almost as good as strongly-supervised training. Training the execution engine using the predicted programs from the program generator instead of groundtruth programs leads to a loss of about 3 points in accuracy, but some of that loss is mitigated after joint finetuning."}, {"heading": "4.3. What do the modules learn?", "text": "To obtain additional insight into what the modules in the execution engine have learned, we visualized the parts of the image that are being used to answer different questions; see Figure 3. Specifically, the figure displays the norm of the gradient of the sum of the predicted answer scores (softmax inputs) with respect to the final feature map. This visualization reveals several important aspects of our model.\nFirst, it clearly attends to the correct objects even for complicated referring expressions involving spatial relationships, intersection and union of constraints, etc.\nSecond, the examples show that changing a single module (swapping purple/blue, left/right, and/or) results in drastic changes in both the predicted answer and model attention, demonstrating that the individual modules do in fact perform their intended functions. Modules learn specialized functions such as localization and set operations without explicit supervision of their outputs.\n3Note that this may underestimate the true accuracy, since two different programs can be functionally equivalent."}, {"heading": "4.4. Generalizing to new attribute combinations", "text": "Johnson et al. [19] proposed the CLEVR-CoGenT dataset for investigating the ability of VQA models to perform compositional generalization. The dataset contains data in two different conditions: in Condition A, all cubes are gray, blue, brown, or yellow and all cylinders are red, green, purple, or cyan; in Condition B, cubes and cylinders swap color palettes. Johnson et al. [19] found that VQA models trained on data from Condition A performed poorly on data from Condition B, suggesting the models are not well capable of generalizing to new conditions.\nWe performed experiments with our model on CLEVRCoGenT: in Figure 5, we report accuracy of the semisupervised variant of our model trained on data from Condition A and evaluated on data from Condition B. Although the resulting model performs better than all baseline meth-\nods in Condition B, it still appears to suffer from the problems identified by [19]. A more detailed analysis of the results revealed that our model does not outperform the CNN+LSTM+SA baseline for questions about an object\u2019s shape or color. This is not surprising: if the model never sees red cubes, it has no incentive to learn that the attribute \u201cred\u201d refers to the color and not to the shape.\nWe also performed experiments in which we used a small amount of training data without ground-truth programs from condition B for finetuning. We varied the amount of data from condition B that is available for finetuning. As shown in Figure 5, our model learns the new attribute combinations from only \u223c10K questions (\u223c1K images), and outperforms similarly trained baselines across the board.4 We believe that this is because the model\u2019s compositional nature allows it to quickly learn new semantics of attributes such as \u201cred\u201d from little training data."}, {"heading": "4.5. Generalizing to new question types", "text": "Our experiments in Section 4.2 showed that relatively few ground-truth programs are required to train our model effectively. Due to the large number of unique programs in CLEVR, it is impossible to capture all possible programs with a small set of ground-truth programs; however, due to the synthetic nature of CLEVR questions, it is possible that a small number of programs could cover all possible program structures. In real-world scenarios, models should be able to generalize to questions with novel program structures without observing associated ground-truth programs.\nTo test this, we divide CLEVR questions into two categories based on their ground-truth programs: short and long. CLEVR questions are divided into question families, where all questions in the same family share the same program structure. A question is short if its question family has a mean program length less than 16; otherwise it is long.5\nWe train the program generator and execution engine on short questions in a semi-supervised manner using 18K ground-truth short programs, and test the resulting model on both short and long questions. This experiment tests the ability of our model to generalize from short to long chains of reasoning. Results are shown in Table 2.\nThe results show that when evaluated on long questions, our model trained on short questions underperforms the CNN+LSTM+SA model trained on the same set. Presumably, this result is due to the program generator learning a bias towards short programs. Indeed, Figure 6 shows that the program generator produces programs that refer to the right objects but that are too short.\nWe can undo this short-program bias through joint fine-\n4Note that this finetuning hurts performance on condition A. Joint finetuning on both conditions will likely alleviate this issue.\n5Partitioning at the family level rather than the question level allows for better separation of program structure between short and long questions.\ntuning of the program generator and execution engine on the combined set of short and long questions, without groundtruth programs. To pinpoint the problem of short-program bias in the program generator, we leave the execution engine fixed during finetuning; it is only used to compute REINFORCE rewards for the program generator. After finetuning, our model substantially outperforms baseline models that were trained on the entire dataset; see Table 2."}, {"heading": "4.6. Generalizing to human-posed questions", "text": "The fact that questions in the CLEVR benchmark were generated algorithmically may favor some approaches over others. In particular, natural language tends to be more ambiguous than algorithmically generated questions. We performed an experiment to assess the extent to which models trained on CLEVR can be finetuned to answer human questions. To this end, we collected a new dataset of naturallanguage questions and answers for CLEVR images.\nThe CLEVR-Humans Dataset. Inspired by VQA [3], workers on Amazon Mechanical Turk were asked to write questions about CLEVR images that would be hard for a smart robot to answer; workers were primed with questions from CLEVR and restricted to answers in CLEVR. We filtered questions by asking three workers to answer each question, and removed questions that a majority of workers could not correctly answer. We collected one question per image; after filtering, we obtained 17,817 training, 7,202 validation, and 7,145 test questions on CLEVR images. The data is available from the first author\u2019s website.\nThe human questions are more challenging than synthetic CLEVR questions because they exhibit more linguistic variety. Unlike existing VQA datasets, however, the CLEVR-Humans questions do not require common-sense knowledge: they focus entirely on visual reasoning abilities, which makes them a good testbed for evaluating reasoning.\nFigure 7 shows some example human questions. Some questions are rewordings of synthetic CLEVR questions; others are answerable using the same basic functions as CLEVR but potentially with altered semantics for those skills. For example, people use spatial relationships \u201cleft\u201d, \u201cright\u201d, etc. differently than their meanings in CLEVR questions. Finally, some questions require skills not needed for answering synthetic questions.\nResults. We train our model on CLEVR, and then finetune only the program generator on the CLEVR-Humans training set to adapt it to the additional linguistic variety; we do not adapt the execution engine due to the limited quantity of data. No ground-truth programs are available during finetuning. The embeddings in the sequence-to-sequence model of question words that do not appear in CLEVR synthetic questions are initialized randomly before finetuning.\nDuring finetuning, our model learns to reuse the reasoning skills it has already mastered in order to answer the linguistically more diverse natural-language questions. As shown in Figure 7, it learns to map novel words (\u201cbox\u201d) to known modules. When human questions are not expressible using CLEVR functions, our model still learns to produce reasonable programs closely approximating the question\u2019s intent. Our model often fails on questions that cannot be reasonably approximated using our model\u2019s module inventory, such as the rightmost example in Figure 7. Quantitatively, the results in Table 3 show that our model outperforms all baselines on the CLEVR-Humans test set both with and without finetuning."}, {"heading": "5. Discussion and Future Work", "text": "Our results show that our model is able to generalize to novel scenes and questions and can even infer programs for free-form human questions using its learned modules. Whilst these results are encouraging, there still are many questions that cannot be reasonably approximated using our fixed set of modules. For example, the question \u201cWhat\ncolor is the object with a unique shape?\u201d requires a model to identify unique shapes, for which no module is currently available. Adding new modules to our model is straightforward due to our generic module design, but automatically identifying and learning new modules without program supervision is still an open problem. One path forward is to design a Turing-complete set of modules; this would allow for all programs to be expressed without learning new modules. For example, by adding ternary operators (if/then/else) and loops (for/do), the question \u201cWhat color is the object with a unique shape?\u201d can be answered by looping over all shapes, counting the objects with that shape, and returning it if the count is one. These control-flow operators could be incorporated into our framework: for example, a loop could apply the same module to an input set and aggregate the results. We emphasize that learning such programs with limited supervision is an open research challenge, which we leave to future work."}, {"heading": "6. Conclusion", "text": "This paper fits into a long line of work on incorporating symbolic representations into (neural) machine learning models [4, 5, 29, 36]. We have shown that explicit program representations can make it easier to compose programs to answer novel questions about images. Our generic program representation, learnable program generator and universal design for modules makes our model much more flexible than neural module networks [1, 2] and thus more easily extensible to new problems and domains.\nSupplementary Material\nA. Implementation Details We will release code to reproduce our experiments. We also detail some key implementation details here.\nA.1. Program Generator\nIn all experiments our program generator is an LSTM sequence-to-sequence model [39]. It comprises two learned recurrent neural networks: the encoder receives the naturallanguage question as a sequence of words, and summarizes the question as a fixed-length vector; the decoder receives this fixed-length vector as input and produces the predicted program as a sequence of functions. The encoder and decoder do not share weights.\nThe encoder converts the discrete words of the input question to vectors of dimension 300 using a learned word embedding layer; the resulting sequence of vectors is then processed with a two-layer LSTM using 256 hidden units per layer. The hidden state of the second LSTM layer at the final timestep is used as the input to the decoder network.\nAt each timestep the decoder network receives both the function from the previous timestep (or a special <START> token at the first timestep) and the output from the encoder network. The function is converted to a 300-dimensional vector with a learned embedding layer and concatenated with the decoder output; the resulting sequence of vectors is processed by a two-layer LSTM with 256 hidden units per layer. At each timestep the hidden state of the second LSTM layer is used to compute a distribution over all possible functions using a linear projection.\nDuring supervised training of the program generator, we use Adam [23] with a learning rate of 5\u00d7 10\u22124 and a batch size of 64; we train for a maximum of 32,000 iterations, employing early stopping based on validation set accuracy.\nA.2. Execution Engine\nThe execution engine uses a Neural Module Network [2] to compile a custom neural network architecture based on the predicted program from the program generator. The input image is first resized to 224 \u00d7 224 pixels, then passed through a convolutional network to extract image features; the architecture of this network is shown in Table 4.\nThe predicted program takes the form of a syntax tree; the leaves of the tree are Scene functions which receive visual input from the convolutional network. For ground-truth programs, the root of the tree is a function corresponding to one of the question types from the CLEVR dataset [19], such as count or query shape. For predicted programs the root of the program tree could in principle be any function, but in practice we find that trained models tend only to\npredict as roots those function types that appear as roots of ground-truth programs.\nEach function in the predicted program is associated with a module which receives either one or two inputs; this association gives rise to a custom neural network architecture corresponding to each program. Previous implementations of Neural Module networks [1, 2] used different architectures for each module type, customizing the module architecture to the function the module was to perform. In contrast we use a generic design for our modules: each module is a small residual block [14]; the exact architectures used for our unary and binary modules are shown in Tables 5 and 6 respectively.\nIn initial experiments we used Batch Normalization [17] after each convolution in the modules, but we found that this prevented the model from converging. Since each image in a minibatch may have a different program, our implementation of the execution engine iterates over each program in the minibatch one by one; as a result each module is only run with a batch size of one during training, leading to poor convergence when modules contain Batch Normalization.\nThe output from the final module is passed to a classifier which predicts a distribution over answers; the exact architecture of the classifier is shown in Table 7.\nWhen training the execution engine alone (using either ground-truth programs or predicted programs from a fixed program generator), we train using Adam [23] with a learning rate of 1 \u00d7 10\u22124 and a batch size of 64; we train for a maximum of 200,000 iterations and employ early stopping based on validation set accuracy.\nA.3. Joint Training\nWhen jointly training the program generator and execution engine, we train using Adam with a learning rate of 5 \u00d7 10\u22125 and a batch size of 64; we train for a maximum of 100,000 iterations, again employing early stopping based on validation set accuracy.\nWe use a moving average baseline to reduce the variance of gradients estimated using REINFORCE; in particular our baseline is an exponentially decaying moving average of past rewards, with a decay factor of 0.99.\nA.4. Baselines\nWe reimplement the baselines used in [19]: LSTM. Our LSTM baseline receives the input question as a sequence of words, converts the words to 300- dimensional vectors using a learned word embedding layer, and processes the resulting sequence with a two-layer LSTM with 512 hidden units per layer. The LSTM hidden state from the second layer at the final timestep is passed to an MLP with two hidden layers of 1024 units each, with ReLU nonlinearities after each layer.\nCNN+LSTM. Like the LSTM baseline, the CNN+LSTM model encodes the question using learned 300-dimensional word embeddings followed by a twolayer LSTM with 512 hidden units per layer. The image is encoded using the same CNN architecture as the execution engine, shown in Table 4. The encoded question and (flattened) image features are concatenated and passed to a two-layer MLP with two hidden layers of 1024 units each, with ReLU nonlinearities after each layer.\nCNN+LSTM+SA. The question and image are encoded in exactly the same manner as the CNN+LSTM baseline. However rather than concatenating these representations, they are fed to two consecutive Stacked Attention layers [46] with a hidden dimension of 512 units; this results in a 512-dimensional vector which is fed to a linear layer to predict answer scores.\nThis matches the CNN+LSTM+SA model as originally described by Yang et al. [46]; this also matches the CNN+LSTM+SA model used in [19].\nCNN+LSTM+SA+MLP. Identical to CNN+LSTM+ SA; however the output of the final stacked attention module is fed to a two-layer MLP with two hidden layers of 1024 units each, with ReLU nonlinearities after each layer.\nSince all other other models (LSTM, CNN+LSTM, and ours) terminate in an MLP to predict the final answer distribution, the CNN+LSTM+SA+MLP gives a more fair comparison with the other methods.\nSurprisingly, the minor architectural change of replacing the linear transform with an MLP significantly improves performance on the CLEVR dataset: CNN+LSTM+SA achieves an overall accuracy of 69.8, while CNN+LSTM+SA+MLP achieves 73.2. Much of this gain comes from improved performance on comparison questions; for example on shape comparison questions CNN+LSTM+SA achieves an accuracy of 50.9 and CNN+LSTM+SA+MLP achieves 69.7.\nTraining. All baselines are trained using Adam with a learning rate of 5\u00d710\u22124 with a batch size of 64 for a maximum of 360,000 iterations, employing early stopping based on validation set accuracy."}, {"heading": "B. Neural Module Network parses", "text": "The closest method to our own is that of Andreas et al. [1]. Their dynamic neural module networks first perform a dependency parse of the sentence; heuristics are then used to generate a set of layout fragments from the dependency parse. These fragments are heuristically combined, giving a set of candidate layouts; the final network layout is selected from these candidates through a learned reranking step.\nUnfortunately we found that the parser used in [1] for VQA questions did not perform well on the longer questions in CLEVR. In Table 8 we show random questions from the CLEVR training set together with the layout frag-\nments computed using the parser from [1]. For many questions the parser fails, falling back to the fragment ( what thing); when this happens then the resulting module network will not respect the structure of the question at all. For questions where the parser does not fall back to the default layout, the resulting layout fragments often fail to capture key elements from the question; for example, after parsing the question What material is the big purple cylinder?, none of the resulting fragments mention the cylinder.\nAcknowledgements. We thank Ranjay Krishna, Yuke Zhu, Kevin Chen, and Dhruv Batra for helpful comments and discussion. J. Johnson is partially supported by an ONR MURI grant."}], "references": [{"title": "Learning to compose neural networks for question answering", "author": ["J. Andreas", "M. Rohrbach", "T. Darrell", "D. Klein"], "venue": "NAACL", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2016}, {"title": "Neural module networks", "author": ["J. Andreas", "M. Rohrbach", "T. Darrell", "D. Klein"], "venue": "CVPR", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2016}, {"title": "VQA: Visual question answering", "author": ["S. Antol", "A. Agrawal", "J. Lu", "M. Mitchell", "D. Batra", "C. Zitnick", "D. Parikh"], "venue": "ICCV", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Deepcoder: Learning to write programs", "author": ["M. Balog", "A. Gaunt", "M. Brockschmidt", "S. Nowozin", "D. Tarlow"], "venue": "ICLR", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2017}, {"title": "Making neural programming architectures generalize via recursion", "author": ["J. Cai", "R. Shin", "D. Song"], "venue": "ICLR", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2017}, {"title": "Visual dialog", "author": ["A. Das", "S. Kottur", "K. Gupta", "A. Singh", "D. Yadav", "J. Moura", "D. Parikh", "D. Batra"], "venue": "CVPR", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2017}, {"title": "Exploring nearest neighbor approaches for image captioning", "author": ["J. Devlin", "S. Gupta", "R. Girshick", "M. Mitchell", "C.L. Zitnick"], "venue": "arXiv preprint arXiv:1505.04467", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2015}, {"title": "Multimodal compact bilinear pooling for visual question answering and visual grounding", "author": ["A. Fukui", "D.H. Park", "D. Yang", "A. Rohrbach", "T. Darrell", "M. Rohrbach"], "venue": "arXiv:1606.01847", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2016}, {"title": "Compact bilinear pooling", "author": ["Y. Gao", "O. Beijbom", "N. Zhang", "T. Darrell"], "venue": "CVPR", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2016}, {"title": "Fast R-CNN", "author": ["R. Girshick"], "venue": "ICCV", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2015}, {"title": "Making the V in VQA matter: Elevating the role of image understanding in visual question answering", "author": ["Y. Goyal", "T. Khot", "D. Summers-Stay", "D. Batra", "D. Parikh"], "venue": "CVPR", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2017}, {"title": "Neural turing machines", "author": ["A. Graves", "G. Wayne", "I. Danihelka"], "venue": "arXiv preprint arXiv:1410.5401", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2014}, {"title": "K", "author": ["A. Graves", "G. Wayne", "M. Reynolds", "T. Harley", "I. Danihelka", "A. Grabska-Barwinska", "S. Colmenarejo", "E. Grefenstette", "T. Ramalho", "J. Agapiou", "A. Badia", "K. Hermann", "Y. Zwols", "G. Ostrovski", "A. Cain", "H. King", "C. Summerfield", "P. Blunsom"], "venue": ". Kavukcuoglu, and D. Hassabis. Hybrid computing using a neural network with dynamic external memory. Nature", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2016}, {"title": "Deep residual learning for image recognition", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": "CVPR", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "Long short-term memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural Computation, 9(8):1735\u20131780", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1997}, {"title": "Modeling relationships in referential expressions with compositional modular networks", "author": ["R. Hu", "M. Rohrbach", "J. Andreas", "T. Darrell", "K. Saenko"], "venue": "CVPR", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2017}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["S. Ioffe", "C. Szegedy"], "venue": "ICML", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "and L", "author": ["A. Jabri", "A. Joulin"], "venue": "van der Maaten. Revisiting visual question answering baselines. In ECCV", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2016}, {"title": "L", "author": ["J. Johnson", "B. Hariharan"], "venue": "van der Maaten, L. Fei-Fei, C. L. Zitnick, and R. Girshick. CLEVR: A diagnostic dataset for compositional language and elementary visual reasoning. In CVPR", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2017}, {"title": "Inferring algorithmic patterns with stack-augmented recurrent nets", "author": ["A. Joulin", "T. Mikolov"], "venue": "NIPS", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Visual question answering: Datasets", "author": ["K. Kafle", "C. Kanan"], "venue": "algorithms, and future challenges. In arXiv preprint arXiv:1610.01465", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2016}, {"title": "Neural GPUs learn algorithms", "author": ["\u0141. Kaiser", "I. Sutskever"], "venue": "ICLR", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2016}, {"title": "Adam: A method for stochastic optimization", "author": ["D. Kingma", "J. Ba"], "venue": "ICLR", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2015}, {"title": "Accurate unlexicalized parsing", "author": ["D. Klein", "C.D. Manning"], "venue": "ACL, pages 423\u2013430", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "et al", "author": ["R. Krishna", "Y. Zhu", "O. Groth", "J. Johnson", "K. Hata", "J. Kravitz", "S. Chen", "Y. Kalantidis", "L.-J. Li", "D.A. Shamma"], "venue": "Visual genome: Connecting language and vision using crowdsourced dense image annotations. IJCV", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2017}, {"title": "ImageNet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "In NIPS", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2012}, {"title": "Neural random-access machines", "author": ["K. Kurach", "M. Andrychowicz", "I. Sutskever"], "venue": "ICLR", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2016}, {"title": "Building machines that learn and think like people", "author": ["B.M. Lake", "T.D. Ullman", "J.B. Tenenbaum", "S.J. Gershman"], "venue": "Behavioral and Brain Sciences", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2016}, {"title": "Neural symbolic machines: Learning semantic parsers on freebase with weak supervision", "author": ["C. Liang", "J. Berant", "Q. Le", "K.D. Forbus", "N. Lao"], "venue": "arXiv preprint arXiv:1611.00020", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning dependencybased compositional semantics", "author": ["P. Liang", "M.I. Jordan", "D. Klein"], "venue": "ACL", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2011}, {"title": "Hierarchical question-image co-attention for visual question answering", "author": ["J. Lu", "J. Yang", "D. Batra", "D. Parikh"], "venue": "NIPS", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2016}, {"title": "A multi-world approach to question answering about real-world scenes based on uncertain input", "author": ["M. Malinowski", "M. Fritz"], "venue": "NIPS", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2014}, {"title": "Ask your neurons: A neural-based approach to answering questions about images", "author": ["M. Malinowski", "M. Rohrbach", "M. Fritz"], "venue": "ICCV", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2015}, {"title": "Learning models for actions and person-object interactions with transfer to question answering", "author": ["A. Mallya", "S. Lazebnik"], "venue": "ECCV", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2016}, {"title": "Neural programmer: Inducing latent programs with gradient descent", "author": ["A. Neelakantan", "Q.V. Le", "I. Sutskever"], "venue": "ICLR", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2016}, {"title": "Neural programmer-interpreters", "author": ["S. Reed", "N. De Freitas"], "venue": "ICLR", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2016}, {"title": "et al", "author": ["O. Russakovsky", "J. Deng", "H. Su", "J. Krause", "S. Satheesh", "S. Ma", "Z. Huang", "A. Karpathy", "A. Khosla", "M. Bernstein"], "venue": "ImageNet large scale visual recognition challenge. IJCV", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2015}, {"title": "End-toend memory networks", "author": ["S. Sukhbaatar", "A. Szlam", "J. Weston", "R. Fergus"], "venue": "NIPS", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2015}, {"title": "Sequence to sequence learning with neural networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V. Le"], "venue": "NIPS", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2014}, {"title": "Movieqa: Understanding stories in movies through question-answering", "author": ["M. Tapaswi", "Y. Zhu", "R. Stiefelhagen", "A. Torralba", "R. Urtasun", "S. Fidler"], "venue": "CVPR", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2016}, {"title": "Memory networks", "author": ["J. Weston", "S. Chopra", "A. Bordes"], "venue": "ICLR", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2015}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Machine Learning, 8(23)", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1992}, {"title": "Understanding Natural Language", "author": ["T. Winograd"], "venue": "Academic Press", "citeRegEx": "43", "shortCiteRegEx": null, "year": 1972}, {"title": "and A", "author": ["Q. Wu", "D. Teney", "P. Wang", "C. Shen", "A. Dick"], "venue": "van den Hengel. Visual question answering: A survey of methods and datasets. In arXiv preprint arXiv:1607.05910", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2016}, {"title": "Dynamic memory networks for visual and textual question answering", "author": ["C. Xiong", "S. Merity", "R. Socher"], "venue": "ICML", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2016}, {"title": "Stacked attention networks for image question answering", "author": ["Z. Yang", "X. He", "J. Gao", "L. Deng", "A. Smola"], "venue": "CVPR", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning simple algorithms from examples", "author": ["W. Zaremba", "T. Mikolov", "A. Joulin", "R. Fergus"], "venue": "ICML", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning to execute", "author": ["W. Zaremba", "I. Sutskever"], "venue": "arXiv preprint arXiv:1410.4615", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2014}, {"title": "Reinforcement learning neural turing machines", "author": ["W. Zaremba", "I. Sutskever"], "venue": "arXiv preprint arXiv:1505.00521", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2015}, {"title": "Yin and yang: Balancing and answering binary visual questions", "author": ["P. Zhang", "Y. Goyal", "D. Summers-Stay", "D. Batra", "D. Parikh"], "venue": "CVPR", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2016}, {"title": "Visual7W: Grounded question answering in images", "author": ["Y. Zhu", "O. Groth", "M. Bernstein", "L. Fei-Fei"], "venue": "CVPR", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2016}], "referenceMentions": [{"referenceID": 27, "context": "Such compositional reasoning is a hallmark of human intelligence, and allows people to solve a plethora of problems using a limited set of basic skills [28].", "startOffset": 152, "endOffset": 156}, {"referenceID": 25, "context": "Direct input-output mapping works well for classifying images [26] and detecting objects [10] for a small, fixed set of categories.", "startOffset": 62, "endOffset": 66}, {"referenceID": 9, "context": "Direct input-output mapping works well for classifying images [26] and detecting objects [10] for a small, fixed set of categories.", "startOffset": 89, "endOffset": 93}, {"referenceID": 2, "context": "However, it fails to outperform strong baselines on tasks that require the model to understand an exponentially large space of objects, attributes, actions, and interactions, such as visual question answering (VQA) [3, 51].", "startOffset": 215, "endOffset": 222}, {"referenceID": 50, "context": "However, it fails to outperform strong baselines on tasks that require the model to understand an exponentially large space of objects, attributes, actions, and interactions, such as visual question answering (VQA) [3, 51].", "startOffset": 215, "endOffset": 222}, {"referenceID": 18, "context": "Current models fail to do such reasoning [19].", "startOffset": 41, "endOffset": 45}, {"referenceID": 6, "context": "to learn dataset biases but not reasoning [7, 18, 19].", "startOffset": 42, "endOffset": 53}, {"referenceID": 17, "context": "to learn dataset biases but not reasoning [7, 18, 19].", "startOffset": 42, "endOffset": 53}, {"referenceID": 18, "context": "to learn dataset biases but not reasoning [7, 18, 19].", "startOffset": 42, "endOffset": 53}, {"referenceID": 0, "context": "Our model builds on prior work on neural module networks that incorporate compositional reasoning [1, 2].", "startOffset": 98, "endOffset": 104}, {"referenceID": 1, "context": "Our model builds on prior work on neural module networks that incorporate compositional reasoning [1, 2].", "startOffset": 98, "endOffset": 104}, {"referenceID": 18, "context": "We evaluate our model on the recently released CLEVR dataset [19], which has proven to be challenging for stateof-the-art VQA models.", "startOffset": 61, "endOffset": 65}, {"referenceID": 20, "context": "Visual question answering (VQA) is a popular proxy task for gauging the quality of visual reasoning systems [21, 44].", "startOffset": 108, "endOffset": 116}, {"referenceID": 43, "context": "Visual question answering (VQA) is a popular proxy task for gauging the quality of visual reasoning systems [21, 44].", "startOffset": 108, "endOffset": 116}, {"referenceID": 2, "context": "Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language.", "startOffset": 123, "endOffset": 142}, {"referenceID": 31, "context": "Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language.", "startOffset": 123, "endOffset": 142}, {"referenceID": 39, "context": "Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language.", "startOffset": 123, "endOffset": 142}, {"referenceID": 24, "context": "Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language.", "startOffset": 123, "endOffset": 142}, {"referenceID": 50, "context": "Like the CLEVR dataset, benchmark datasets for VQA typically comprise a set of questions on images with associated answers [3, 32, 40, 25, 51]; both questions and answers are generally posed in natural language.", "startOffset": 123, "endOffset": 142}, {"referenceID": 2, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 7, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 8, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 30, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 32, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 33, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 44, "context": "Many systems for VQA employ a very similar architecture [3, 8, 9, 31, 33, 34, 45]: they combine an RNN-based embedding of the question with a convolutional network-based embedding of an image in a classification model over possible answers.", "startOffset": 56, "endOffset": 81}, {"referenceID": 17, "context": "Recent work has questioned whether such systems are capable of developing visual reasoning capabilities: (1) very simple baseline models were found to perform competitively on VQA benchmarks by exploiting biases in the data [18, 50, 11] and (2) experiments on CLEVR, which was designed to control such biases, revealed that current systems do not learn to reason about spatial relationships or to learn disentangled representations [19].", "startOffset": 224, "endOffset": 236}, {"referenceID": 49, "context": "Recent work has questioned whether such systems are capable of developing visual reasoning capabilities: (1) very simple baseline models were found to perform competitively on VQA benchmarks by exploiting biases in the data [18, 50, 11] and (2) experiments on CLEVR, which was designed to control such biases, revealed that current systems do not learn to reason about spatial relationships or to learn disentangled representations [19].", "startOffset": 224, "endOffset": 236}, {"referenceID": 10, "context": "Recent work has questioned whether such systems are capable of developing visual reasoning capabilities: (1) very simple baseline models were found to perform competitively on VQA benchmarks by exploiting biases in the data [18, 50, 11] and (2) experiments on CLEVR, which was designed to control such biases, revealed that current systems do not learn to reason about spatial relationships or to learn disentangled representations [19].", "startOffset": 224, "endOffset": 236}, {"referenceID": 18, "context": "Recent work has questioned whether such systems are capable of developing visual reasoning capabilities: (1) very simple baseline models were found to perform competitively on VQA benchmarks by exploiting biases in the data [18, 50, 11] and (2) experiments on CLEVR, which was designed to control such biases, revealed that current systems do not learn to reason about spatial relationships or to learn disentangled representations [19].", "startOffset": 432, "endOffset": 436}, {"referenceID": 11, "context": "For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory.", "startOffset": 51, "endOffset": 59}, {"referenceID": 12, "context": "For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory.", "startOffset": 51, "endOffset": 59}, {"referenceID": 40, "context": "For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory.", "startOffset": 77, "endOffset": 85}, {"referenceID": 37, "context": "For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory.", "startOffset": 77, "endOffset": 85}, {"referenceID": 19, "context": "For example, models such as neural Turing machines [12, 13], memory networks [41, 38], and stack-augmented recurrent networks [20] add explicit memory components to neural networks to facilitate learning of reasoning processes that involve long-term memory.", "startOffset": 126, "endOffset": 130}, {"referenceID": 0, "context": "Module networks are an example of reasoningaugmented models that use a syntactic parse of a question to determine the architecture of the network [1, 2, 16].", "startOffset": 146, "endOffset": 156}, {"referenceID": 1, "context": "Module networks are an example of reasoningaugmented models that use a syntactic parse of a question to determine the architecture of the network [1, 2, 16].", "startOffset": 146, "endOffset": 156}, {"referenceID": 15, "context": "Module networks are an example of reasoningaugmented models that use a syntactic parse of a question to determine the architecture of the network [1, 2, 16].", "startOffset": 146, "endOffset": 156}, {"referenceID": 23, "context": "The main difference between our models and existing module networks is that we replace hand-designed off-the-shelf syntactic parsers [24], which perform very poorly on complex questions such as those in CLEVR [19], by a learnt program generator that can adapt to the task at hand.", "startOffset": 133, "endOffset": 137}, {"referenceID": 18, "context": "The main difference between our models and existing module networks is that we replace hand-designed off-the-shelf syntactic parsers [24], which perform very poorly on complex questions such as those in CLEVR [19], by a learnt program generator that can adapt to the task at hand.", "startOffset": 209, "endOffset": 213}, {"referenceID": 29, "context": "Often, the goal is to answer natural language questions using a knowledge base [30].", "startOffset": 79, "endOffset": 83}, {"referenceID": 28, "context": "Recent approaches to semantic parsing involve a learnt programmer [29].", "startOffset": 66, "endOffset": 70}, {"referenceID": 3, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 150, "endOffset": 153}, {"referenceID": 21, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 26, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 34, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 46, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 47, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 48, "context": "Such models can take the form of a feedforward scoring function over operators in a domain-specific language that can be used to guide program search [4], or of a recurrent network that decodes a vectorial program representation into the actual program [22, 27, 35, 47, 48, 49].", "startOffset": 253, "endOffset": 277}, {"referenceID": 35, "context": "The recurrent networks may incorporate compositional structure that allows them to learn new programs by combining previously learned sub-programs [36].", "startOffset": 147, "endOffset": 151}, {"referenceID": 5, "context": "1Memory is likely indispensable in more complex settings such as visual dialogues or SHRDLU [6, 43].", "startOffset": 92, "endOffset": 99}, {"referenceID": 42, "context": "1Memory is likely indispensable in more complex settings such as visual dialogues or SHRDLU [6, 43].", "startOffset": 92, "endOffset": 99}, {"referenceID": 0, "context": "In contrast to prior work [1, 2], we do not manually design heuristics for generating or executing the programs.", "startOffset": 26, "endOffset": 32}, {"referenceID": 1, "context": "In contrast to prior work [1, 2], we do not manually design heuristics for generating or executing the programs.", "startOffset": 26, "endOffset": 32}, {"referenceID": 38, "context": "This allows us to implement the program generator using a standard LSTM sequence-tosequence model; see [39] for details.", "startOffset": 103, "endOffset": 107}, {"referenceID": 1, "context": "The execution engine executes the program on the image by assembling a neural module network [2] mirroring the structure of the predicted program.", "startOffset": 93, "endOffset": 96}, {"referenceID": 1, "context": "The execution engine is implemented using a neural module network [2]: the program z is used to assemble a question-specific neural network that is composed from a set of modules.", "startOffset": 66, "endOffset": 69}, {"referenceID": 1, "context": "Our modules use a generic architecture, in contrast to [2].", "startOffset": 55, "endOffset": 58}, {"referenceID": 13, "context": "Each unary module is a standard residual block [14] with two 3\u00d73 convolutional layers.", "startOffset": 47, "endOffset": 51}, {"referenceID": 13, "context": "The Scene module takes visual features as input (conv4 features from ResNet-101 [14] pretrained on ImageNet [37]) and passes these features through four", "startOffset": 80, "endOffset": 84}, {"referenceID": 36, "context": "The Scene module takes visual features as input (conv4 features from ResNet-101 [14] pretrained on ImageNet [37]) and passes these features through four", "startOffset": 108, "endOffset": 112}, {"referenceID": 45, "context": "CNN+LSTM+SA [46] 68.", "startOffset": 12, "endOffset": 16}, {"referenceID": 18, "context": "2 Human\u2020 [19] 96.", "startOffset": 9, "endOffset": 13}, {"referenceID": 1, "context": "Specifically, we can (1) use pairs (q, z) of questions and corresponding programs to train the program generator, which amounts to training a standard sequence-to-sequence model; and (2) use triplets (x, z, a) of the image, program, and answer to train the execution engine, using backpropagation to compute the required gradients (as in [2]).", "startOffset": 338, "endOffset": 341}, {"referenceID": 41, "context": "Instead we replace the argmaxes with sampling and use REINFORCE [42] to estimate gradients on the outputs of the program generator; the reward for each of its outputs is the negative zero-one loss of the execution engine, with a moving-average baseline.", "startOffset": 64, "endOffset": 68}, {"referenceID": 18, "context": "We evaluate our model on the recent CLEVR dataset [19].", "startOffset": 50, "endOffset": 54}, {"referenceID": 18, "context": "[19] tested several VQA models on CLEVR.", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "LSTM: Similar to [3, 33], questions are processed with learned word embeddings followed by a word-level LSTM [15].", "startOffset": 17, "endOffset": 24}, {"referenceID": 32, "context": "LSTM: Similar to [3, 33], questions are processed with learned word embeddings followed by a word-level LSTM [15].", "startOffset": 17, "endOffset": 24}, {"referenceID": 14, "context": "LSTM: Similar to [3, 33], questions are processed with learned word embeddings followed by a word-level LSTM [15].", "startOffset": 109, "endOffset": 113}, {"referenceID": 45, "context": "CNN+LSTM+SA [46]: Questions and images are encoded using a CNN and LSTM as above, then combined using two rounds of soft spatial attention; a linear transform of the attention output predicts the answer.", "startOffset": 12, "endOffset": 16}, {"referenceID": 0, "context": "The models that are most similar to ours are neural module networks [1, 2].", "startOffset": 68, "endOffset": 74}, {"referenceID": 1, "context": "The models that are most similar to ours are neural module networks [1, 2].", "startOffset": 68, "endOffset": 74}, {"referenceID": 18, "context": "Unfortunately, neural module networks use a hand-engineered, off-the-shelf parser to produce programs, and this parser fails2 on the complex questions in CLEVR [19].", "startOffset": 160, "endOffset": 164}, {"referenceID": 18, "context": "[19] proposed the CLEVR-CoGenT dataset for investigating the ability of VQA models to perform compositional generalization.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19] found that VQA models trained on data from Condition A performed poorly on data from Condition B, suggesting the models are not well capable of generalizing to new conditions.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "ods in Condition B, it still appears to suffer from the problems identified by [19].", "startOffset": 79, "endOffset": 83}, {"referenceID": 2, "context": "Inspired by VQA [3], workers on Amazon Mechanical Turk were asked to write questions about CLEVR images that would be hard for a smart robot to answer; workers were primed with questions from CLEVR and restricted to answers in CLEVR.", "startOffset": 16, "endOffset": 19}, {"referenceID": 3, "context": "This paper fits into a long line of work on incorporating symbolic representations into (neural) machine learning models [4, 5, 29, 36].", "startOffset": 121, "endOffset": 135}, {"referenceID": 4, "context": "This paper fits into a long line of work on incorporating symbolic representations into (neural) machine learning models [4, 5, 29, 36].", "startOffset": 121, "endOffset": 135}, {"referenceID": 28, "context": "This paper fits into a long line of work on incorporating symbolic representations into (neural) machine learning models [4, 5, 29, 36].", "startOffset": 121, "endOffset": 135}, {"referenceID": 35, "context": "This paper fits into a long line of work on incorporating symbolic representations into (neural) machine learning models [4, 5, 29, 36].", "startOffset": 121, "endOffset": 135}, {"referenceID": 0, "context": "Our generic program representation, learnable program generator and universal design for modules makes our model much more flexible than neural module networks [1, 2] and thus more easily extensible to new problems and domains.", "startOffset": 160, "endOffset": 166}, {"referenceID": 1, "context": "Our generic program representation, learnable program generator and universal design for modules makes our model much more flexible than neural module networks [1, 2] and thus more easily extensible to new problems and domains.", "startOffset": 160, "endOffset": 166}, {"referenceID": 38, "context": "In all experiments our program generator is an LSTM sequence-to-sequence model [39].", "startOffset": 79, "endOffset": 83}, {"referenceID": 22, "context": "During supervised training of the program generator, we use Adam [23] with a learning rate of 5\u00d7 10\u22124 and a batch size of 64; we train for a maximum of 32,000 iterations, employing early stopping based on validation set accuracy.", "startOffset": 65, "endOffset": 69}, {"referenceID": 1, "context": "The execution engine uses a Neural Module Network [2] to compile a custom neural network architecture based on the predicted program from the program generator.", "startOffset": 50, "endOffset": 53}, {"referenceID": 18, "context": "For ground-truth programs, the root of the tree is a function corresponding to one of the question types from the CLEVR dataset [19], such as count or query shape.", "startOffset": 128, "endOffset": 132}, {"referenceID": 13, "context": "For predicted programs the root of the program tree could in principle be any function, but in practice we find that trained models tend only to Layer Output size Input image 3\u00d7 224\u00d7 224 ResNet-101 [14] conv4 6 1024\u00d7 14\u00d7 14 Conv(3\u00d7 3, 1024\u2192 128) 128\u00d7 14\u00d7 14 ReLU 128\u00d7 14\u00d7 14 Conv(3\u00d7 3, 128\u2192 128) 128\u00d7 14\u00d7 14 ReLU 128\u00d7 14\u00d7 14", "startOffset": 198, "endOffset": 202}, {"referenceID": 36, "context": "The ResNet-101 model is pretrained on ImageNet [37] and remains fixed while the execution engine is trained.", "startOffset": 47, "endOffset": 51}, {"referenceID": 0, "context": "Previous implementations of Neural Module networks [1, 2] used different architectures for each module type, customizing the module architecture to the function the module was to perform.", "startOffset": 51, "endOffset": 57}, {"referenceID": 1, "context": "Previous implementations of Neural Module networks [1, 2] used different architectures for each module type, customizing the module architecture to the function the module was to perform.", "startOffset": 51, "endOffset": 57}, {"referenceID": 13, "context": "In contrast we use a generic design for our modules: each module is a small residual block [14]; the exact architectures used for our unary and binary modules are shown in Tables 5 and 6 respectively.", "startOffset": 91, "endOffset": 95}, {"referenceID": 16, "context": "In initial experiments we used Batch Normalization [17] after each convolution in the modules, but we found that this prevented the model from converging.", "startOffset": 51, "endOffset": 55}, {"referenceID": 22, "context": "When training the execution engine alone (using either ground-truth programs or predicted programs from a fixed program generator), we train using Adam [23] with a learning rate of 1 \u00d7 10\u22124 and a batch size of 64; we train for a maximum of 200,000 iterations and employ early stopping based on validation set accuracy.", "startOffset": 152, "endOffset": 156}, {"referenceID": 18, "context": "We reimplement the baselines used in [19]: LSTM.", "startOffset": 37, "endOffset": 41}, {"referenceID": 45, "context": "However rather than concatenating these representations, they are fed to two consecutive Stacked Attention layers [46] with a hidden dimension of 512 units; this results in a 512-dimensional vector which is fed to a linear layer to predict answer scores.", "startOffset": 114, "endOffset": 118}, {"referenceID": 45, "context": "[46]; this also matches the CNN+LSTM+SA model used in [19].", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[46]; this also matches the CNN+LSTM+SA model used in [19].", "startOffset": 54, "endOffset": 58}, {"referenceID": 0, "context": "[1].", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "Unfortunately we found that the parser used in [1] for VQA questions did not perform well on the longer questions in CLEVR.", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "[1] for parsing questions from the VQA dataset [3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[1] for parsing questions from the VQA dataset [3].", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "Each parse gives a set of layout fragments separated by semicolons; in [1] these fragments are combined to produce candidate layouts for the module network.", "startOffset": 71, "endOffset": 74}, {"referenceID": 0, "context": "ments computed using the parser from [1].", "startOffset": 37, "endOffset": 40}], "year": 2017, "abstractText": "Existing methods for visual reasoning attempt to directly map inputs to outputs using black-box architectures without explicitly modeling the underlying reasoning processes. As a result, these black-box models often learn to exploit biases in the data rather than learning to perform visual reasoning. Inspired by module networks, this paper proposes a model for visual reasoning that consists of a program generator that constructs an explicit representation of the reasoning process to be performed, and an execution engine that executes the resulting program to produce an answer. Both the program generator and the execution engine are implemented by neural networks, and are trained using a combination of backpropagation and REINFORCE. Using the CLEVR benchmark for visual reasoning, we show that our model significantly outperforms strong baselines and generalizes better in a variety of settings.", "creator": "LaTeX with hyperref package"}}}