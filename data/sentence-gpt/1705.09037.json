{"id": "1705.09037", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-May-2017", "title": "Deriving Neural Architectures from Sequence and Graph Kernels", "abstract": "The design of neural architectures for structured objects is typically guided by experimental insights rather than a formal process. In this work, we appeal to kernels over combinatorial structures, such as sequences and graphs, to derive appropriate neural operations. We introduce a class of deep recurrent neural operations and formally characterize their associated kernel spaces. For example, a complex sequence consists of 10, 10, 10, and 10-dimensional sequences, with an order of magnitude less than a point in the list. We illustrate the relationship between such neural operators and recurrent learning on a single sequence, as discussed in this section. We also explore an approach to embedding an invariant feature of the model to one of our neural architectures.", "histories": [["v1", "Thu, 25 May 2017 03:58:10 GMT  (539kb,D)", "https://arxiv.org/abs/1705.09037v1", "to appear at ICML 2017; includes additional discussions"], ["v2", "Wed, 14 Jun 2017 14:34:24 GMT  (1618kb,D)", "http://arxiv.org/abs/1705.09037v2", "extended version of ICML 2017 camera ready"], ["v3", "Mon, 30 Oct 2017 13:56:23 GMT  (1618kb,D)", "http://arxiv.org/abs/1705.09037v3", "extended version of ICML 2017 camera ready"]], "COMMENTS": "to appear at ICML 2017; includes additional discussions", "reviews": [], "SUBJECTS": "cs.NE cs.CL cs.LG", "authors": ["tao lei", "wengong jin", "regina barzilay", "tommi s jaakkola"], "accepted": true, "id": "1705.09037"}, "pdf": {"name": "1705.09037.pdf", "metadata": {"source": "META", "title": "Deriving Neural Architectures from Sequence and Graph Kernels", "authors": ["Tao Lei", "Wengong Jin", "Regina Barzilay", "Tommi Jaakkola"], "emails": ["<taolei@csail.mit.edu>,", "gong@csail.mit.edu>."], "sections": [{"heading": "1. Introduction", "text": "Many recent studies focus on designing novel neural architectures for structured data such as sequences or annotated graphs. For instance, LSTM (Hochreiter & Schmidhuber, 1997), GRU (Chung et al., 2014) and other complex recurrent units (Zoph & Le, 2016) can be easily adapted to embed structured objects such as sentences (Tai et al., 2015) or molecules (Li et al., 2015; Dai et al., 2016) into vector spaces suitable for later processing by standard predictive methods. The embedding algorithms are typically integrated into an end-to-end trainable architecture so as to tailor the learnable embeddings directly to the task at hand.\nThe embedding process itself is characterized by a sequence operations summarized in a structure known as the computational graph. Each node in the computational\n*Equal contribution 1MIT Computer Science & Artificial Intelligence Laboratory. Correspondence to: Tao Lei <taolei@csail.mit.edu>, Wengong Jin <wengong@csail.mit.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\ngraph identifies the unit/mapping applied while the arcs specify the relative arrangement/order of operations. The process of designing such computational graphs or associated operations for classes of objects is often guided by insights and expertise rather than a formal process.\nRecent work has substantially narrowed the gap between desirable computational operations associated with objects and how their representations are acquired. For example, value iteration calculations can be folded into convolutional architectures so as to optimize the representations to facilitate planning (Tamar et al., 2016). Similarly, inference calculations in graphical models about latent states of variables such as atom characteristics can be directly associated with embedding operations (Dai et al., 2016).\nWe appeal to kernels over combinatorial structures to define the appropriate computational operations. Kernels give rise to well-defined function spaces and possess rules of composition that guide how they can be built from simpler ones. The comparison of objects inherent in kernels is often broken down to elementary relations such as counting of common sub-structures as in\nK(\u03c7, \u03c7\u2032) = \u2211 s\u2208S 1[s \u2208 \u03c7]1[s \u2208 \u03c7\u2032] (1)\nwhere S is the set of possible substructures. For example, in a string kernel (Lodhi et al., 2002), S may refer to all possible subsequences while a graph kernel (Vishwanathan et al., 2010) would deal with possible paths in the graph. Several studies have highlighted the relation between feed-forward neural architectures and kernels (Hazan & Jaakkola, 2015; Zhang et al., 2016) but we are unaware of any prior work pertaining to kernels associated with neural architectures for structured objects.\nIn this paper, we introduce a class of deep recurrent neural embedding operations and formally characterize their associated kernel spaces. The resulting kernels are parameterized in the sense that the neural operations relate objects of interest to virtual reference objects through kernels. These reference objects are parameterized and readily optimized for end-to-end performance.\nTo summarize, the proposed neural architectures, or Kernel Neural Networks 1 , enjoy the following advantages:\n1Code available at https://github.com/taolei87/icml17 knn\nar X\niv :1\n70 5.\n09 03\n7v 3\n[ cs\n.N E\n] 3\n0 O\nct 2\n01 7\nDeriving Neural Architectures from Sequence and Graph Kernels\n\u2022 The architecture design is grounded in kernel computations.\n\u2022 Our neural models remain end-to-end trainable to the task at hand.\n\u2022 Resulting architectures demonstrate state-of-the-art performance against strong baselines.\nIn the following sections, we will introduce these neural components derived from string and graph kernels, as well as their deep versions. Due to space limitations, we defer proofs to supplementary material."}, {"heading": "2. From String Kernels to Sequence NNs", "text": "Notations We define a sequence (or a string) of tokens (e.g. a sentence) as x1:L = {xi}Li=1 where xi \u2208 Rd represents its ith element and |x| = L denotes the length. Whenever it is clear from the context, we will omit the subscript and directly use x (and y) to denote a sequence. For a pair of vectors (or matrices) u,v, we denote \u3008u,v\u3009 = \u2211 k ukvk as their inner product. For a kernel function Ki(\u00b7, \u00b7) with subscript i, we use \u03c6i(\u00b7) to denote its underlying mapping, i.e. Ki(x,y) = \u3008\u03c6i(x), \u03c6i(y)\u3009 = \u03c6i(x)>\u03c6i(y).\nString Kernel String kernel measures the similarity between two sequences by counting shared subsequences (see Lodhi et al. (2002)). For example, let x and y be two strings, a bi-gram string kernel K2(x,y) counts the number of bi-grams (xi,xj) and (yk,yl) such that (xi,xj) = (yk,yl) 2,\nK2(x,y) = \u2211\n1\u2264i<j\u2264|x| 1\u2264k<l\u2264|y|\n\u03bbx,i,j \u03bby,k,l \u03b4(xi,yk) \u00b7 \u03b4(xj ,yl)\n(2) where \u03bbx,i,j , \u03bby,k,l \u2208 [0, 1) are context-dependent weights and \u03b4(x, y) is an indicator that returns 1 only when x = y. The weight factors can be realized in various ways. For instance, in temporal predictions such as language modeling, substrings (i.e. patterns) which appear later may have higher impact for prediction. Thus a realization \u03bbx,i,j = \u03bb|x|\u2212i\u22121 and \u03bby,k,l = \u03bb|y|\u2212k\u22121 (penalizing substrings far from the end) can be used to determine weights given a constant decay factor \u03bb \u2208 (0, 1).\nIn our case, each token in the sequence is a vector (such as one-hot encoding of a word or a feature vector). We shall replace the exact match \u03b4(u,v) by the inner product \u3008u,v\u3009. To this end, the kernel function (2) can be rewritten as,\u2211 1\u2264i<j\u2264|x| \u2211 1\u2264k<l\u2264|y| \u03bbx,i,j \u03bby,k,l \u3008xi,yk\u3009 \u00b7 \u3008xj ,yl\u3009\n2We define n-gram as a subsequence of original string (not necessarily consecutive).\n= \u2211\n1\u2264i<j\u2264|x| \u2211 1\u2264k<l\u2264|y| \u03bbx,i,j \u03bby,k,l \u3008xi \u2297 xj ,yk \u2297 yl\u3009\n= \u2329\u2211 i<j \u03bb|x|\u2212i\u22121 xi \u2297 xj , \u2211 k<l \u03bb|y|\u2212k\u22121 yk \u2297 yl \u232a (3)\nwhere xi\u2297xj \u2208 Rd\u00d7d (and similarly yk\u2297yl) is the outerproduct. In other words, the underlying mapping of kernel K2() defined above is \u03c62(x) = \u2211 1\u2264i<j\u2264|x| \u03bb\n|x|\u2212i\u22121xi \u2297 xj . Note we could alternatively use a partial additive scoring \u3008xi,yk\u3009+ \u3008xj ,yl\u3009, and the kernel function can be generalized to n-grams when n 6= 2. Again, we commit to one realization in this section.\nString Kernel NNs We introduce a class of recurrent modules whose internal feature states embed the computation of string kernels. The modules project kernel mapping \u03c6(x) into multi-dimensional vector space (i.e. internal states of recurrent nets). Owing to the combinatorial structure of \u03c6(x), such projection can be realized and factorized via efficient computation. For the example kernel discussed above, the corresponding neural component is realized as,\nc1[t] = \u03bb \u00b7 c1[t\u2212 1] + ( W(1)xt ) cj [t] = \u03bb \u00b7 cj [t\u2212 1] + ( cj\u22121[t\u2212 1] W(j)xt\n) h[t] = \u03c3(cn[t]), 1 < j \u2264 n (4)\nwhere cj [t] are the pre-activation cell states at word xt, and h[t] is the (post-activation) hidden vector. cj [0] is initialized with a zero vector. W(1), ..,W(n) are weight matrices to be learned from training examples.\nThe network operates like other RNNs by processing each input token and updating the internal states. The elementwise multiplication can be replaced by addition + (corresponding to the partial additive scoring above). As a special case, the additive variant becomes a word-level convolutional neural net (Kim, 2014) when \u03bb = 0.3\n3h[t] = \u03c3(W(1)xt\u2212n+1 + \u00b7 \u00b7 \u00b7+W(n)xt) when \u03bb = 0.\nDeriving Neural Architectures from Sequence and Graph Kernels"}, {"heading": "2.1. Single Layer as Kernel Computation", "text": "Now we state how the proposed class embeds string kernel computation. For j \u2208 {1, .., n}, let cj [t][i] be the i-th entry of state vector cj [t], w (j) i represents the i-th row of matrix W(j). Define wi,j = {w(1)i ,w (2) i , ...,w (j) i } as a \u201creference sequence\u201d constructed by taking the i-th row from each matrix W(1), ..,W(j).\nTheorem 1. Let x1:t be the prefix of x consisting of first t tokens, and Kj be the string kernel of j-gram shown in Eq.(3). Then cj [t][i] evaluates kernel function,\ncj [t][i] = Kj (x1:t,wi,j) = \u3008\u03c6j(x1:t), \u03c6j(wi,j)\u3009\nfor any j \u2208 {1, .., n}, t \u2208 {1, .., |x|}.\nIn other words, the network embeds sequence similarity computation by assessing the similarity between the input sequence x1:t and the reference sequence wi,j . This interpretation is similar to that of CNNs, where each filter is a \u201creference pattern\u201d to search in the input. String kernel NN further takes non-consecutive n-gram patterns into consideration (seen from the summation over all n-grams in Eq.(3)).\nApplying Non-linear Activation In practice, a non-linear activation function such as polynomial or sigmoid-like activation is added to the internal states to produce the final output state h[t]. It turns out that many activations are also functions in the reproducing kernel Hilbert space (RKHS) of certain kernel functions (see Shalev-Shwartz et al. (2011); Zhang et al. (2016)). When this is true, the underlying kernel of h[t] is the composition of string kernel and the kernel containing the activation. We give the formal statements below.\nLemma 1. Let x and w be multi-dimensional vectors with finite norm. Consider the function f(x) := \u03c3(w>x) with non-linear activation \u03c3(\u00b7). For functions such as polynomials and sigmoid function, there exists kernel functions K\u03c3(\u00b7, \u00b7) and the underlying mapping \u03c6\u03c3(\u00b7) such that f(x) is in the reproducing kernel Hilbert space of K\u03c3(\u00b7, \u00b7), i.e.,\nf(x) = \u03c3(w>x) = \u3008\u03c6\u03c3(x), \u03c8(w)\u3009\nfor some mapping \u03c8(w) constructed from w. In particular, K\u03c3(x,y) can be the inverse-polynomial kernel 12\u2212\u3008x,y\u3009 for the above activations.\nProposition 1. For one layer string kernel NN with nonlinear activation \u03c3(\u00b7) discussed in Lemma 1, h[t][i] as a function of input x belongs to the RKHS introduced by the composition of K\u03c3(\u00b7, \u00b7) and string kernel Kn(\u00b7, \u00b7). Here a kernel composition K\u03c3,n(x,y) is defined with the underlying mapping x 7\u2192 \u03c6\u03c3(\u03c6n(x)), and hence K\u03c3,n(x,y) = \u03c6\u03c3(\u03c6n(x))>\u03c6\u03c3(\u03c6n(y)).\nProposition 1 is the corollary of Lemma 1 and Theorem 1, since h[t][i] = \u03c3(cn[t][i]) = \u03c3(Kn(x1:t,wi,j)) = \u3008\u03c6\u03c3(\u03c6n(x1:t)), w\u0303i,j\u3009 and \u03c6\u03c3(\u03c6n(\u00b7)) is the mapping for the composed kernel. The same proof applies when h[t] is a linear combination of all ci[t] since kernel functions are closed under addition."}, {"heading": "2.2. Deep Networks as Deep Kernel Construction", "text": "We now address the case when multiple layers of the same module are stacked to construct deeper networks. That is, the output states h(l)[t] of the l-th layer are fed to the (l+1)th layer as the input sequence. We show that layer stacking corresponds to recursive kernel construction (i.e. (l + 1)- th kernel is defined on top of l-th kernel), which has been proven for feed-forward networks (Zhang et al., 2016).\nWe first generalize the sequence kernel definition to enable recursive construction. Notice that the definition in Eq.(3) uses the linear kernel (inner product) \u3008xi,yk\u3009 as a \u201csubroutine\u201d to measure the similarity between substructures (e.g. tokens) within the sequences. We can therefore replace it with other similarity measures introduced by other \u201cbase kernels\u201d. In particular, let K(1)(\u00b7, \u00b7) be the string kernel (associated with a single layer). The generalized sequence kernel K(l+1)(x,y) can be recursively defined as,\u2211 i<j k<l \u03bbx,i,j \u03bby,k,l K(l)\u03c3 (x1:i,y1:k) K(l)\u03c3 (x1:j ,y1:l) =\n\u2329\u2211 i<j \u03c6(l)\u03c3 (x1:i)\u2297 \u03c6(l)\u03c3 (x1:j), \u2211 k<l \u03c6(l)\u03c3 (y1:k)\u2297 \u03c6(l)\u03c3 (y1:l) \u232a\nwhere \u03c6(l)(\u00b7) denotes the pre-activation mapping of the lth kernel, \u03c6(l)\u03c3 (\u00b7) = \u03c6\u03c3(\u03c6(l)(\u00b7)) denotes the underlying (post-activation) mapping for non-linear activation \u03c3(\u00b7), and K(l)\u03c3 (\u00b7, \u00b7) is the l-th post-activation kernel. Based on this definition, a deeper model can also be interpreted as a kernel computation.\nTheorem 2. Consider a deep string kernel NN with L layers and activation function \u03c3(\u00b7). Let the final output state h(L)[t] = \u03c3(c(L)n [t]) (or any linear combination of {c(l)i [t]}, i = 1, .., n). For l = 1, \u00b7 \u00b7 \u00b7 , L,\n(i) c(l)n [t][i] as a function of input x belongs to the RKHS of kernel K(l)(\u00b7, \u00b7);\n(ii) h(l)[t][i] belongs to the RKHS of kernel K(l)\u03c3 (\u00b7, \u00b7)."}, {"heading": "3. From Graph Kernels to Graph NNs", "text": "In the previous section, we encode sequence kernel computation into neural modules and demonstrate possible extensions using different base kernels. The same ideas apply\nDeriving Neural Architectures from Sequence and Graph Kernels\nto other types of kernels and data. Specifically, we derive neural components for graphs in this section.\nNotations A graph is defined as G = (V,E), with each vertex v \u2208 V associated with feature vector fv . The neighbor of node v is denoted as N(v). Following previous notations, for any kernel function K\u2217(\u00b7, \u00b7) with underlying mapping \u03c6\u2217(\u00b7), we use K\u2217,\u03c3(\u00b7, \u00b7) to denote the postactivation kernel induced from the composed underlying mapping \u03c6\u2217,\u03c3 = \u03c6\u03c3(\u03c6\u2217(\u00b7))."}, {"heading": "3.1. Random Walk Kernel NNs", "text": "We start from random walk graph kernels (Ga\u0308rtner et al., 2003), which count common walks in two graphs. Formally, let Pn(G) be the set of walks x = x1 \u00b7 \u00b7 \u00b7xn, where \u2200i : (xi, xi+1) \u2208 E.4 Given two graphs G and G\u2032, an n-th order random walk graph kernel is defined as:\nKnW (G,G\u2032) = \u03bbn\u22121 \u2211\nx\u2208Pn(G) \u2211 y\u2208Pn(G\u2032) n\u220f i=1 \u3008fxi , fyi\u3009 (5)\nwhere fxi \u2208 Rd is the feature vector of node xi in the walk.\nNow we show how to realize the above graph kernel with a neural module. Given a graph G, the proposed neural module is:\nc1[v] = W (1)fv cj [v] = \u03bb \u2211\nu\u2208N(v)\ncj\u22121[u] W(j)fv (6)\nhG = \u03c3( \u2211 v cn[v]) 1 < j \u2264 n\nwhere again c\u2217[v] is the cell state vector of node v, and hG is the representation of graph G aggregated from node vectors. hG could then be used for classification or regression.\nNow we show the proposed model embeds the random walk kernel. To show this, construct Ln,k as a \u201creference walk\u201d consisting of the row vectors {w(1)k , \u00b7 \u00b7 \u00b7 ,w (n) k } from the parameter matrices. Here Ln,k = (LV , LE), where LV = {v0, v1, \u00b7 \u00b7 \u00b7 , vn}, LE = {(vi, vi+1)} and vi\u2019s feature vector is w(i)k . We have the following theorem:\nTheorem 3. For any n \u2265 1, the state value cn[v][k] (the k-th coordinate of cn[v]) satisfies:\u2211\nv\ncn[v][k] = KnW (G,Ln,k)\nthus \u2211 v cn[v] lies in the RKHS of kernel KnW . As a corollary, hG lies in the RKHS of kernel KnW,\u03c3(). 4A single node could appear multiple times in a walk."}, {"heading": "3.2. Unified View of Graph Kernels", "text": "The derivation of the above neural module could be extended to other classes of graph kernels, such as subtree kernels (cf. (Ramon & Ga\u0308rtner, 2003; Vishwanathan et al., 2010)). Generally speaking, most of these kernel functions factorize graphs into local sub-structures, i.e.\nK(G,G\u2032) = \u2211 v \u2211 v\u2032 Kloc(v, v\u2032) (7)\nwhere Kloc(v, v\u2032) measures the similarity between local sub-structures centered at node v and v\u2032.\nFor example, the random walk kernel KnW can be equivalently defined with Knloc(v, v\u2032) = \u3008fv, fv \u2032\u3009 if n = 1 \u3008fv, fv\u2032\u3009 \u00b7 \u03bb\n\u2211 u\u2208N(v) \u2211 u\u2032\u2208N(v\u2032) Kn\u22121loc (u, u\u2032) if n > 1\nOther kernels like subtree kernels could be recursively defined similarly. Therefore, we adopt this unified view of graph kernels for the rest of this paper.\nIn addition, this definition of random walk kernel could be further generalized and enhanced by aggregating neighbor features non-linearly:\nKnloc(v, v\u2032) = \u3008fv, fv\u2032\u3009 \u25e6 \u03bb \u2211\nu\u2208N(v) \u2211 u\u2032\u2208N(v\u2032) Kn\u22121loc,\u03c3(u, u \u2032)\nwhere \u25e6 could be either multiplication or addition. \u03c3(\u00b7) denotes a non-linear activation and Kn\u22121loc,\u03c3(\u00b7, \u00b7) denotes the post-activation kernel when \u03c3(\u00b7) is involved. The generalized kernel could be realized by modifying Eq.(6) into:\ncj [v] = W (j)fv \u25e6 \u03bb \u2211 u\u2208N(v) \u03c3(cj\u22121[u]) (8)\nwhere \u25e6 could be either + or operation."}, {"heading": "3.3. Deep Graph Kernels and NNs", "text": "Following Section 2, we could stack multiple graph kernel NNs to form a deep network. That is:\nc (l) 1 [v] = W (l,1)h(l\u22121)[v]\nc (l) j [v] = W\n(l,j)h(l\u22121)[v] \u25e6 \u03bb \u2211\nu\u2208N(v)\n\u03c3 ( c (l) j\u22121[u] ) h(l)[v] = \u03c3(U(l)c(l)n [v]) 1 \u2264 l \u2264 L, 1 < j \u2264 n\nThe local kernel function is recursively defined in two dimensions: depth (term h(l)) and width (term cj). Let the pre-activation kernel in the l-th layer be K(l)loc(v, v\u2032) = K (l,n) loc (v, v\n\u2032), and the post-activation kernel be K(l)loc,\u03c3(v, v\u2032) = K (l,n) loc,\u03c3(v, v \u2032). We recursively define\nDeriving Neural Architectures from Sequence and Graph Kernels\nK(l,j)loc (v, v\u2032) = K (l\u22121) loc,\u03c3 (v, v \u2032) if j = 1 K(l\u22121)loc,\u03c3 (v, v\u2032) \u25e6 \u03bb \u2211\nu\u2208N(v) \u2211 u\u2032\u2208N(v\u2032) K(l,j\u22121)loc,\u03c3 (u, u\u2032) if j > 1\nfor j = 1, \u00b7 \u00b7 \u00b7 , n. Finally, the graph kernel is K(L,n)(G,G\u2032) = \u2211 v,v\u2032 K (L,n) loc (v, v\n\u2032). Similar to Theorem 2, we have Theorem 4. Consider a deep graph kernel NN with L layers and activation function \u03c3(\u00b7). Let the final output state hG = \u2211 v h (L)[v]. For l = 1, \u00b7 \u00b7 \u00b7 , L; j = 1, \u00b7 \u00b7 \u00b7 , n:\n(i) c(l)j [v][i] as a function of input v and graph G belongs\nto the RKHS of kernel K(l,j)loc (\u00b7, \u00b7);\n(ii) h(l)[v][i] belongs to the RKHS of kernel K(l,n)loc,\u03c3(\u00b7, \u00b7).\n(iii) hG[i] belongs to the RKHS of kernel K(L,n)(\u00b7, \u00b7)."}, {"heading": "3.4. Connection to Weisfeiler-Lehman Kernel", "text": "We derived the above deep kernel NN for the purpose of generality. This model could be simplified by setting n = 2, without losing representational power (as non-linearity is already involved in depth dimension). In this case, we rewrite the network by reparametrization:\nh(l)v = \u03c3 U(l)1 h(l\u22121)v \u25e6U(l)2 \u2211 u\u2208N(v) \u03c3 ( V(l)h(l\u22121)u ) (9) In this section, we further show that this model could be enhanced by sharing weight matrices U and V across layers. This parameter tying mechanism allows our model to embed Weisfeiler-Lehman kernel (Shervashidze et al., 2011). For clarity, we briefly review basic concepts of WeisfeilerLehman kernel below.\nWeisfeiler-Lehman Graph Relabeling WeisfeilerLehman kernel borrows concepts from the WeisfeilerLehman isomorphism test for labeled graphs. The key idea of the algorithm is to augment the node labels by the sorted set of node labels of neighbor nodes, and compress these augmented labels into new, short labels (Figure 2). Such relabeling process is repeated T times. In the i-th iteration, it generates a new labeling li(v) for all nodes v in graph G, with initial labeling l0.\nGeneralized Graph Relabeling The key observation here is that graph relabeling operation could be viewed as neighbor feature aggregation. As a result, the relabeling process naturally generalizes to the case where nodes are associated with continuous feature vectors. In particular, let r be the relabeling function. For a node v \u2208 G:\nr(v) = \u03c3(U1fv +U2 \u2211\nu\u2208N(v)\n\u03c3(Vfu)) (10)\nFigure 2. Node relabeling in Weisfeiler-Lehman isomorphism test. Figure taken from Shervashidze et al. (2011)\nNote that our definition of r(v) is exactly the same as hv in Equation 9, with \u25e6 being additive composition.\nWeisfeiler-Lehman Kernel Let K be any graph kernel (called base kernel). Given a relabeling function r, Weisfeiler-Lehman kernel with base kernel K and depth L is defined as\nK(L)WL(G,G \u2032) = L\u2211 i=0 K(ri(G), ri(G\u2032)) (11)\nwhere r0(G) = G and ri(G), ri(G\u2032) are the i-th relabeled graph of G and G\u2032 respectively.\nWeisfeiler-Lehman Kernel NN Now with the above kernel definition, and random walk kernel as the base kernel, we propose the following recurrent module:\nc (l) 0 [v] = W (l,0)h(l\u22121)v c (l) j [v] = \u03bb \u2211 u\u2208N(v) c (l) j\u22121[u] W (l,j)h(l\u22121)v\nh(l)v = \u03c3 U1h(l\u22121)v +U2 \u2211 u\u2208N(v) \u03c3(Vh(l\u22121)u )  h (l) G =\n\u2211 v c(l)n [v] 1 \u2264 l \u2264 L, 1 < j \u2264 n\nwhere h(0)v = fv and U1,U2,V are shared across layers. The final output of this network is hG = \u2211L l=1 h (l) G .\nThe above recurrent module is still an instance of deep kernel, even though some parameters are shared. A minor difference here is that there is an additional random walk kernel NN that connects i-th layer and the output layer. But this is just a linear combination of L deep random walk kernels (of different depth). Therefore, as an corollary of Theorem 4, we have: Proposition 2. For a Weisfeiler-Lehman Kernel NN with L iterations and random walk kernel KnW as base kernel, the final output state hG = \u2211 l h (l) G belongs to the RKHS of kernel K(L)WL(\u00b7, \u00b7).\nDeriving Neural Architectures from Sequence and Graph Kernels"}, {"heading": "4. Adaptive Decay with Neural Gates", "text": "The sequence and graph kernel (and their neural components) discussed so far use a constant decay value \u03bb regardless of the current input. However, this is often not the case since the importance of the input can vary across the context or the applications. One extension is to make use of neural gates that adaptively control the decay factor. Here we give two illustrative examples:\nGated String Kernel NN By replacing constant decay \u03bb with a sigmoid gate, we modify our single-layer sequence module as:\n\u03bbt = \u03c3(U[xt,ht\u22121] + b) c1[t] = \u03bbt c1[t\u2212 1] + ( W(1)xt ) cj [t] = \u03bbt cj [t\u2212 1] + ( cj\u22121[t\u2212 1] W(j)xt\n) h[t] = \u03c3(cn[t]) 1 < j \u2264 n\nAs compared with the original string kernel, now the decay factor \u03bbx,i,j is no longer \u03bb|x|\u2212i\u22121, but rather an adaptive value based on current context.\nGated Random Walk Kernel NN Similarly, we could introduce gates so that different walks have different weights:\n\u03bbu,v = \u03c3(U[fu, fv] + b)\nc0[v] = W (0)fv cj [v] = \u2211\nu\u2208N(v)\n\u03bbu,v cj\u22121[u] W(j)fv\nhG = \u03c3( \u2211 v cn[v]) 1 < j \u2264 n\nThe underlying kernel of the above gated network becomes\nKnW (G,G\u2032) = \u2211\nx\u2208Pn(G) \u2211 y\u2208Pn(G\u2032) n\u220f i=1 \u03bbxi,yi \u3008fxi , fyi\u3009\nwhere each path is weighted by different decay weights, determined by network itself."}, {"heading": "5. Related Work", "text": "Sequence Networks Considerable effort has gone into designing effective networks for sequence processing. This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm to further optimize the design of such recurrent architectures. Our proposed neural networks offer similar state\nevolution and feature aggregation functionalities but derive the motivation for the operations involved from wellestablished kernel computations over sequences.\nRecursive neural networks are alternative architectures to model hierarchical structures such as syntax trees and logic forms. For instance, Socher et al. (2013) employs recursive networks for sentence classification, where each node in the dependency tree of the sentence is transformed into a vector representation. Tai et al. (2015) further proposed tree-LSTM, which incorporates LSTM-style architectures as the transformation unit. Dyer et al. (2015; 2016) recently introduced a recursive neural model for transitionbased language modeling and parsing. While not specifically discussed in the paper, our ideas do extend to similar neural components for hierarchical objects (e.g. trees).\nGraph Networks Most of the current graph neural architectures perform either convolutional or recurrent operations on graphs. Duvenaud et al. (2015) developed Neural Fingerprint for chemical compounds, where each convolution operation is a sum of neighbor node features, followed by a linear transformation. Our model differs from theirs in that our generalized kernels and networks can aggregate neighboring features in a non-linear way. Other approaches, e.g., Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform.\nFor recurrent architectures, Li et al. (2015) proposed gated graph neural networks, where neighbor features are aggregated by GRU function. Dai et al. (2016) considers a different architecture where a graph is viewed as a latent variable graphical model. Their recurrent model is derived from Belief Propagation-like algorithms. Our approach is most closely related to Dai et al. (2016), in terms of neighbor feature aggregation and resulting recurrent architecture. Nonetheless, the focus of this paper is on providing a framework for how such recurrent networks could be derived from deep graph kernels.\nKernels and Neural Nets Our work follows recent work demonstrating the connection between neural networks and kernels (Cho & Saul, 2009; Hazan & Jaakkola, 2015). For example, Zhang et al. (2016) showed that standard feedforward neural nets belong to a larger space of recursively constructed kernels (given certain activation functions). Similar results have been made for convolutional neural nets (Anselmi et al., 2015), and general computational graphs (Daniely et al., 2016). We extend prior work to kernels and neural architectures over structured inputs, in particular, sequences and graphs. Another difference is how we train the model. While some prior work appeals to convex optimization through improper learning (Zhang et al., 2016; Heinemann et al., 2016) (since kernel space is larger), we use the proposed networks as building blocks in typical non-convex but flexible neural network training.\nDeriving Neural Architectures from Sequence and Graph Kernels"}, {"heading": "6. Experiments", "text": "The left-over question is whether the proposed class of operations, despite its formal characteristics, leads to more effective architecture exploration and hence improved performance. In this section, we apply the proposed sequence and graph modules to various tasks and empirically evaluate their performance against other neural network models. These tasks include language modeling, sentiment classification and molecule regression."}, {"heading": "6.1. Language Modeling on PTB", "text": "Dataset and Setup We use the Penn Tree Bank (PTB) corpus as the benchmark. The dataset contains about 1 million tokens in total. We use the standard train/development/test split of this dataset with vocabulary of size 10,000.\nModel Configuration Following standard practice, we use SGD with an initial learning rate of 1.0 and decrease the learning rate by a constant factor after a certain epoch. We back-propagate the gradient with an unroll size of 35 and use dropout (Hinton et al., 2012) as the regularization. Unless otherwise specified, we train 3-layer networks with n = 1 and normalized adaptive decay.5 Following (Zilly et al., 2016), we add highway connections (Srivastava et al., 2015) within each layer:\nc(l)[t] = \u03bbt c(l)[t\u2212 1] + (1\u2212 \u03bbt) (W(l)h(l\u22121)[t]) h(l)[t] = ft c(l)[t] + (1\u2212 ft) h(l\u22121)[t]\nwhere h(0)[t] = xt, \u03bbt is the gated decay factor and ft is the transformation gate of highway connections.6\nResults Table 1 compares our model with various state-ofthe-art models. Our small model with 5 million parameters achieves a test perplexity of 73.6, already outperforming many results achieved using much larger network. By increasing the network size to 20 million, we obtain a test perplexity of 69.2, with standard dropout. Adding variational dropout (Gal & Ghahramani, 2016) within the recurrent cells further improves the perplexity to 65.5. Finally, the model achieves 63.8 perplexity when the recurrence depth is increased to 4, being state-of-the-art and on par with the results reported in (Zilly et al., 2016; Zoph & Le, 2016). Note that Zilly et al. (2016) uses 10 neural layers and Zoph & Le (2016) adopts a complex recurrent cell found by reinforcement learning based search. Our network is architecturally much simpler.\nFigure 3 analyzes several variants of our model. Wordlevel CNNs are degraded cases (\u03bb = 0) that ignore non-\n5See the supplementary sections for a discussion of network variants.\n6We found non-linear activation is no longer necessary when the highway connection is added.\ncontiguous n-gram patterns. Clearly, this variant performs worse compared to other recurrent variants with \u03bb > 0. Moreover, the test perplexity improves from 84.3 to 76.8 when we train the constant decay vector as part of the model parameters. Finally, the last two variants utilize neural gates (depending on input xt only or both input xt and previous state h[t\u22121]), further improving the performance."}, {"heading": "6.2. Sentiment Classification", "text": "Dataset and Setup We evaluate our model on the sentence classification task. We use the Stanford Sentiment Treebank benchmark (Socher et al., 2013). The dataset consists of 11855 parsed English sentences annotated at both the root (i.e. sentence) level and the phrase level using 5- class fine-grained labels. We use the standard split for training, development and testing. Following previous work, we also evaluate our model on the binary classification variant of this benchmark, ignoring all neutral sentences.\nDeriving Neural Architectures from Sequence and Graph Kernels\nFollowing the recent work of DAN (Iyyer et al., 2015) and RLSTM (Tai et al., 2015), we use the publicly available 300-dimensional GloVe word vectors (Pennington et al., 2014). Unlike prior work which fine tunes the word vectors, we normalize the vectors (i.e. \u2016w\u201622 = 1) and fixed them for simplicity.\nModel Configuration Our best model is a 3-layer network with n = 2 and hidden dimension d = 200. We average the hidden states h[t] across t, and concatenate the averaged vectors from the 3 layers as the input of the final softmax layer. The model is optimized with Adam (Kingma & Ba, 2015), and dropout probability of 0.35.\nResults Table 2 presents the performance of our model and other networks. We report the best results achieved across 5 independent runs. Our best model obtains 53.2% and 89.9% test accuracies on fine-grained and binary tasks respectively. Our model with only a constant decay factor also obtains quite high accuracy, outperforming other baseline methods shown in the table."}, {"heading": "6.3. Molecular Graph Regression", "text": "Dataset and Setup We further evaluate our graph NN models on the Harvard Clean Energy Project benchmark, which has been used in Dai et al. (2016); Duvenaud et al. (2015) as their evaluation dataset. This dataset contains 2.3 million candidate molecules, with each molecule labeled with its power conversion efficiency (PCE) value.\nWe follow exactly the same train-test split as Dai et al. (2016), and the same re-sampling procedure on the training data (but not the test data) to make the algorithm put more\nemphasis on molecules with higher PCE values, since the data is distributed unevenly.\nWe use the same feature set as in Duvenaud et al. (2015) for atoms and bonds. Initial atom features include the atoms element, its degree, the number of attached hydrogens, its implicit valence, and an aromaticity indicator. The bond feature is a concatenation of bond type indicator, whether the bond is conjugated, and whether the bond is in a ring.\nModel Configuration Our model is a Weisfeiler-Lehman NN, with 4 recurrent iterations and n = 2. All models (including baseline) are optimized with Adam (Kingma & Ba, 2015), with learning rate decay factor 0.9.\nResults In Table 3, we report the performance of our model against other baseline methods. Neural Fingerprint (Duvenaud et al., 2015) is a 4-layer convolutional neural network. Convolution is applied to each atom, which sums over its neighbors\u2019 hidden state, followed by a linear transformation and non-linear activation. Embedded Loopy BP (Dai et al., 2016) is a recurrent architecture, with 4 recurrent iterations. It maintains message vectors for each atom and bond, and propagates those vectors in a message passing fashion. Table 3 shows our model achieves stateof-the-art against various baselines."}, {"heading": "7. Conclusion", "text": "We proposed a class of deep recurrent neural architectures and formally characterized its underlying computation using kernels. By linking kernel and neural operations, we have a \u201ctemplate\u201d for deriving new families of neural architectures for sequences and graphs. We hope the theoretical view of kernel neural networks can be helpful for future model exploration.\nDeriving Neural Architectures from Sequence and Graph Kernels"}, {"heading": "Acknowledgement", "text": "We thank Prof. Le Song for sharing Harvard Clean Energy Project dataset. We also thank Yu Zhang, Vikas Garg, David Alvarez, Tianxiao Shen, Karthik Narasimhan and the reviewers for their helpful comments. This work was supported by the DARPA Make-It program under contract ARO W911NF-16-2-0023."}, {"heading": "A. Examples of kernel / neural variants", "text": "Our theoretical results apply to some other variants of sequence kernels and the associated neural components. We give some examples in the this section. Table 4 shows three network variants, corresponding to three realizations of string kernels provided in Table 5.\nConnection to LSTMs Interestingly, many recent work has reached similar RNN architectures through empirical exploration. For example, Greff et al. (2015) found that simplifying LSTMs, by removing the input gate or coupling it with the forget gate does not significantly change the performance. However, the forget gate (corresponding to the decay factor \u03bb in our notation) is crucial for performance. This is consistent with our theoretical analysis and the empirical results in Figure 3. Moreover, Balduzzi & Ghifary (2016) and Lee et al. (2017) both suggest that a linear additive state computation suffices to provide competitive performance compared to LSTMs: 7\nc[t] = \u03bbf c1[t\u2212 1] + \u03bbi (Wxt) h[t] = \u03c3(c[t])\nIn fact, this variant becomes an instance of the kernel NN presented in this work (with n = 1 and adaptive gating), when \u03bbf = \u03bbt and \u03bbi = 1\u2212 \u03bbt or 1.\n7Balduzzi & Ghifary (2016) also includes the previous token , i.e. Wxt + W\u2032xt\u22121, which doesn\u2019t affect the discussion here."}, {"heading": "B. Proof of Theorem 1", "text": "We first generalize the kernel definition in Eq.(3) to the case of any n-gram. For any integer n > 0, the underlying mapping of the n-th order string kernel is defined as,\n\u03c6n(x) = \u2211\n1\u2264i1<\u00b7\u00b7\u00b7<in\u2264|x|\n\u03bb|x|\u2212i1\u2212n+1 xi1 \u2297 xi2 \u2297 \u00b7 \u00b7 \u00b7 \u2297 xin\nWe now show that String Kernel NN states cn[t] defined in (4),\nn = 1 : c1[t] = \u03bb \u00b7 c1[t\u2212 1] +W(1)xt n > 1 : cn[t] = \u03bb \u00b7 cn[t\u2212 1] + ( cn\u22121[t\u2212 1] W(n)xt ) is equivalent to summing over all n-grams within the first t tokens x1:t = {x1, \u00b7 \u00b7 \u00b7 ,xt},\ncn[t] = \u2211\n1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t\n( W(1)xi1 \u00b7 \u00b7 \u00b7 W(n)xin ) \u00b7 \u03bbt\u2212i1\u2212n+1\nProof: We prove the equivalence by induction. When n = 1, for c1[t] we have,\nc1[t] = \u2211\n1\u2264i1\u2264t\n( W(1)xi1 ) \u00b7 \u03bbt\u2212i1\n=  \u2211 1\u2264i1\u2264t\u22121 ( W(1)xi1 ) \u00b7 \u03bbt\u22121\u2212i1  \ufe38 \ufe37\ufe37 \ufe38\nc1[t\u22121]\n\u00b7\u03bb + W(1)xt\n= c1[t\u2212 1] \u00b7 \u03bb + W(1)xt\nWhen n = k > 1, suppose the state iteration holds for 1, \u00b7 \u00b7 \u00b7 , k \u2212 1, we have,\ncn[t] = \u2211\n1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t\n( W(1)xi1 \u00b7 \u00b7 \u00b7 W(n)xin ) \u00b7 \u03bbt\u2212i1\u2212n+1\n=  \u2211 1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t\u22121 ( W(1)xi1 \u00b7 \u00b7 \u00b7 W(n)xin ) \u00b7 \u03bbt\u22121\u2212i1\u2212n+1  \ufe38 \ufe37\ufe37 \ufe38\nwhen in<t: cn[t\u22121]\n\u00b7\u03bb\n+  \u2211 1\u2264i1<i2<\u00b7\u00b7\u00b7<in=t ( W(1)xi1 \u00b7 \u00b7 \u00b7 W(n)xin ) \u00b7 \u03bbt\u22121\u2212i1\u2212n+1  \ufe38 \ufe37\ufe37 \ufe38\nwhen in=t = cn[t\u2212 1] \u00b7 \u03bb + ( cn\u22121[t\u2212 1] W(n)xt ) Now we proceed to prove Theorem 1.\nProof: From the above results, we know that for cn[t],\ncn[t] = \u2211\n1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t\n( W(1)xi1 \u00b7 \u00b7 \u00b7 W(n)xin ) \u00b7 \u03bbt\u2212i1\u2212n+1\nIn particular, the value of the i-th entry, cn[t][i], is equal to,\ncn[t][i] = \u2211\n1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t\n\u2329 w\n(1) i ,xi1\n\u232a \u00b7 \u00b7 \u00b7 \u2329 w\n(n) i ,xin \u232a \ufe38 \ufe37\ufe37 \ufe38\u2329\nxi1\u2297\u00b7\u00b7\u00b7\u2297xin ,w (1) i \u2297\u00b7\u00b7\u00b7\u2297w (n) i\n\u232a \u00b7 \u03bbt\u2212i1\u2212n+1\n= \u2329 \u2211 1\u2264i1<i2<\u00b7\u00b7\u00b7<in\u2264t \u03bbt\u2212i1\u2212n+1 xi1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 xin , w (1) i \u2297 \u00b7 \u00b7 \u00b7 \u2297w (n) i \u232a\n= \u3008\u03c6n(x1:t), \u03c6n(wi,n)\u3009\nwhere w(k)i represents the i-th row of matrix W (k) and wi,n = {w(1)i , \u00b7 \u00b7 \u00b7 ,w (n) i }. This completes the proof since Kn(x1:t,wi,n) = \u3008\u03c6n(x1:t), \u03c6n(wi,n)\u3009 by definition.\nRemarks This theorem demonstrates that the NN state vectors cn can be seen as projecting the kernel mapping \u03c6n(x) into a low-dimensional space using the parameterized matrices {W(i)}i = 1n. This is similar to word embeddings and CNNs, where the input (a single word or an n-gram) is projected to obtain a low-dimensional representation."}, {"heading": "C. Proof of Theorem 2", "text": "We first review necessary concepts and notations for the ease of reading. Similar to the proof in Appendix B, the generalized string kernel K(l) and K(l)\u03c3 in Eq.(??) can be defined with the underlying mappings,\n\u03c6(l)(x) = \u2211\n1\u2264i1<\u00b7\u00b7\u00b7<in\u2264|x|\n\u03bb|x|\u2212i1\u2212n+1 \u03c6(l\u22121)\u03c3 (x1:i1)\u2297 \u03c6(l\u22121)\u03c3 (x1:i2)\u2297 \u00b7 \u00b7 \u00b7 \u2297 \u03c6(l\u22121)\u03c3 (x1:i1)\n\u03c6(l)\u03c3 (x) = \u03c6\u03c3(\u03c6 (l)(x))\nwhere \u03c6\u03c3() is the underlying mapping of a kernel function whose reproducing kernel Hilbert space (RKHS) contains the non-linear activation \u03c3() used in the String Kernel NN layer. Here K(l)() is the \u201cpre-activation kernel\u201d and K(l)\u03c3 () is the \u201cpost-activation kernel\u201d. To show that the values of String Kernel NN states c(l)[t] is contained in the RKHS of K(l)() and that of h(l)[t] is contained in the RKHS of K(l)\u03c3 (), we re-state the claim in the following way, Theorem 5. Given a deep n-gram String Kernel NN with non-linear activation \u03c3(). Assuming \u03c3() lies in the RKHS of a kernel function with underlying mapping \u03c6\u03c3(), then\n(i) c(l)[t] lies in the RKHS of kernel K(l)() in the sense that\nc (l) j [t][i] = \u2329 \u03c6(l)(x1:t), \u03c8 (l) i,j \u232a for any internal state c(l)j [t] (1 \u2264 j \u2264 n) of the l-th layer, where \u03c8 (l) i,j is a mapping constructed from model parameters;\n(ii) h(l)[t] lies in the RKHS of kernel K(l)\u03c3 () as a corollary in the sense that\nh(l)[t][i] = \u03c3(c(l)n [t][i]) = \u03c3 (\u2329 \u03c6(l)(x1:t), \u03c8 (l) i,n \u232a) (based on (i))\n= \u2329 \u03c6\u03c3(\u03c6 (l)(x1:t)), \u03c8\u03c3(\u03c8 (l) i,n) \u232a\n(Lemma 1)\nand we denote \u03c8\u03c3(\u03c8 (l) i,n) as \u03c8 (l) \u03c3,i,n for short.\nProof: We prove by induction on l. When l = 1, the proof of Theorem 1 already shows that c(1)j [t][i] =\u2329 \u03c6 (1) j (x1:t), \u03c6 (1) j (wi,j) \u232a in a one-layer String Kernel NN. Simply let \u03c8(1)i,j = \u03c6 (1) j (wi,j) completes the proof for the case of l = 1.\nSuppose the lemma holds for l = 1, \u00b7 \u00b7 \u00b7 , k, we now prove the case of l = k + 1. Similar to the proof of Theorem 1, the value of c(k+1)j [t][i] equals to\nc (k+1) j [t][i] = \u2211 1\u2264i1<\u00b7\u00b7\u00b7<ij\u2264t \u2329 w (1) i ,h (k)[i1] \u232a \u00b7 \u00b7 \u00b7 \u2329 w (j) i ,h (k)[ij ] \u232a \u00b7 \u03bbt\u2212i1\u2212j+1 (12)\nwhere w(j)i is the i-th row of the parameter matrix W (j) of the l-th layer. Note h(k)[t][i] =\u2329\n\u03c6 (k) \u03c3 (x1:t), \u03c8 (k) \u03c3,i,n \u232a , we construct a matrix M by stacking all {\u03c8(k)\u03c3,i,n}i as the row vectors.8 We then\ncan rewrite h(k)[t] = M\u03c6(k)\u03c3 (x1:t). Plugging this into Eq (12), we get\nc (k+1) j [t][i] = \u2211 1\u2264i1<\u00b7\u00b7\u00b7<ij\u2264t \u2329 w (1) i ,M\u03c6 (k) \u03c3 (x1:i1) \u232a \u00b7 \u00b7 \u00b7 \u2329 w (j) i ,M\u03c6 (k) \u03c3 (x1:ij ) \u232a \u00b7 \u03bbt\u2212i1\u2212j+1\n= \u2211\n1\u2264i1<\u00b7\u00b7\u00b7<ij\u2264t\n\u2329 M>w\n(1) i\ufe38 \ufe37\ufe37 \ufe38\nui,1\n, \u03c6(k)\u03c3 (x1:i1)\n\u232a \u00b7 \u00b7 \u00b7 \u2329 M>w\n(j) i\ufe38 \ufe37\ufe37 \ufe38\nui,j\n, \u03c6(k)\u03c3 (x1:ij )\n\u232a \u00b7 \u03bbt\u2212i1\u2212j+1\n= \u2211\n1\u2264i1<\u00b7\u00b7\u00b7<ij\u2264t\n\u2329 ui,1, \u03c6 (k) \u03c3 (x1:i1) \u232a \u00b7 \u00b7 \u00b7 \u2329 ui,j , \u03c6 (k) \u03c3 (x1:ij ) \u232a \u00b7 \u03bbt\u2212i1\u2212j+1\n= \u2329 \u2211 1\u2264i1<\u00b7\u00b7\u00b7<ij\u2264t\n\u03bbt\u2212i1\u2212j+1 \u03c6(k)\u03c3 (xi1)\u2297 \u00b7 \u00b7 \u00b7 \u2297 \u03c6(k)\u03c3 (xij )\ufe38 \ufe37\ufe37 \ufe38 \u03c6(k+1)(x1:t) , ui,1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 ui,j\n\u232a\n= \u2329 \u03c6(k+1)(x1:t), ui,1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 ui,j \u232a Define \u03c8(k+1)i,j = ui,1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 ui,j completes the proof for the case of l = k + 1.\n8Note in practice the mappings \u03c6(k)\u03c3 and \u03c8 (k) \u03c3 may have infinite dimension because the underlying mapping for the non-linear activation \u03c6\u03c3() can have infinite dimension. The proof still apply since the dimensions are still countable and the vectors have finite norm (easy to show this by assuming the input xi and parameter W are bounded."}, {"heading": "D. Proof for Theorem 3", "text": "Recall that random walk graph kernel is defined as:\nKn(G,G\u2032) = \u03bbn \u2211\nx\u2208Pn(G) \u2211 y\u2208Pn(G\u2032) n\u220f i=1 \u3008fxi , fyi\u3009\n\u03c6n(G) = \u03bb n \u2211 x\u2208Pn(G) fx0 \u2297 fx1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 fxn\nand single-layer graph NN computes its states as:\ncn[v] = \u03bb \u2211\nu\u2208N(v)\ncn\u22121[u] W(n)fv\n= \u03bbn \u2211\nun\u22121\u2208N(v) \u2211 un\u22122\u2208N(un\u22121) \u00b7 \u00b7 \u00b7 \u2211 u0\u2208N(u1) W(0)fu0 W(1)fu1 \u00b7 \u00b7 \u00b7 W(n)fun\n= \u03bbn \u2211\nu=u0\u00b7\u00b7\u00b7un\u2208Pn(G,v)\nW(0)fu0 W(1)fu1 \u00b7 \u00b7 \u00b7 W(n)fun\nwhere we define Pn(G, v) be the set of walks that end with node v. For the i-th coordinate of cn[v], we have\ncn[v][i] = \u03bb n \u2211 u\u2208Pn(G,v) \u220f i \u2329 w (i) i , fui \u232a \u2211 v cn[v][i] = \u03bb n \u2211 u\u2208Pn(G) \u220f i \u2329 w (i) i , fui\n\u232a = Kn(G,Ln,k)\nThe last step relies on the fact that Pn(Ln,k) has only one element {w(0)i ,w (1) i , \u00b7 \u00b7 \u00b7 ,w (n) i }."}, {"heading": "E. Proof for Theorem 4", "text": "For clarity, we re-state the kernel definition and theorem in the following:\nK(L,n)(G,G\u2032) = \u2211 v \u2211 v\u2032 K(L,n)loc,\u03c3 (v, v \u2032)\nWhen l = 1:\nK(l,j)loc (v, v \u2032) =  \u3008fv, fv\u2032\u3009 if j = 1 \u3008fv, fv\u2032\u3009+ \u03bb \u2211 u\u2208N(v) \u2211 u\u2032\u2208N(v\u2032) K(l,j\u22121)loc,\u03c3 (u, u\u2032) if j > 1\n0 if Pj(G, v) = \u2205 or Pj(G\u2032, v\u2032) = \u2205\nWhen l > 1:\nK(l,j)loc (v, v \u2032) =  K(l\u22121)loc,\u03c3 (v, v \u2032) if j = 1 K(l\u22121)loc,\u03c3 (v, v\u2032) + \u03bb \u2211 u\u2208N(v) \u2211 u\u2032\u2208N(v\u2032) K(l,j\u22121)loc,\u03c3 (u, u\u2032) if j > 1\n0 if Pj(G, v) = \u2205 or Pj(G\u2032, v\u2032) = \u2205\nwhere Pj(G, v) is the set of walks of length j starting from v. Note that we force K(l,j)loc = 0 when there is no valid walk starting from v or v\u2032, so that it only considers walks of length j. We use additive version just for illustration (multiplicative version follows the same argument).\nTheorem 6. For a deep random walk kernel NN with L layers and activation function \u03c3(\u00b7), assuming the final output state hG = \u2211 v h (l)[v], for l = 1, \u00b7 \u00b7 \u00b7 , L; j = 1, \u00b7 \u00b7 \u00b7 , n:\n(i) c(l)j [v][i] as a function of input v and graph G belongs to the RKHS of kernel K (l,j) loc (\u00b7, \u00b7) in that\nc (l) j [v][i] = \u2329 \u03c6 (l,j) G (v), \u03c8 (l) i,j \u232a where \u03c6(l)G (v) is the mapping of node v in graph G, and \u03c8 (l) i,j is a mapping constructed from model parameters.\n(ii) h(l)[v][i] belongs to the RKHS of kernel K(l,n)loc,\u03c3(\u00b7, \u00b7) as a corollary:\nh(l)[v][i] = \u03c3 (\u2211 k uikc (l) n [v][k] ) = \u03c3 (\u2211 k uik \u2329 \u03c6 (l,n) G (v), \u03c8 (l) k,n \u232a)\n= \u03c3 (\u2329 \u03c6 (l,n) G (v), \u2211 k uik\u03c8 (l) k,n \u232a)\n= \u2329 \u03c6\u03c3(\u03c6 (l,n) G (v)), \u03c8\u03c3 (\u2211 k uik\u03c8 (l) k,n )\u232a\nWe denote \u03c8\u03c3 (\u2211 k uik\u03c8 (l) k,n ) as \u03c8(l)\u03c3,i,n, and \u03c6\u03c3(\u03c6 (l,n) G (v)) as \u03c6 (l) G,\u03c3(v) for short.\n(iii) hG[i] belongs to the RKHS of kernel K(L,n)(\u00b7, \u00b7).\nProof of (i), (ii): We prove by induction on l. When l = 1, from kernel definition, the kernel mapping is recursively defined as:\n\u03c6 (1,j) G (v) =  fv if j = 1[ fv, \u221a \u03bb \u2211 u\u2208N(v) \u03c6\u03c3(\u03c6 (1,j\u22121) G (u)) ] if j > 1\n0 if Pj(G, v) = \u2205 or Pj(G\u2032, v\u2032) = \u2205\nWe prove c(1)j [v][i] = \u2329 \u03c6 (1,j) G (v), \u03c8 (1) i,j \u232a by induction on j. When j = 1, c(1)1 [v][i] = \u2329 w (1,1) i , fv \u232a . Our hypothesis holds by \u03c8(1)i,1 = w (1,1) i . Suppose induction hypothesis holds for 1, 2, \u00b7 \u00b7 \u00b7 , j \u2212 1. If Pj(G, v) = \u2205, we could always set c(1)j [v][i] = 0 in neural network computation. Otherwise:\nc (1) j [v][i] =\n\u2329 w\n(1,j) i , fv\n\u232a + \u03bb \u2211 u\u2208N(v) \u03c3 ( c (1) j\u22121[u][i] ) = \u2329 w\n(1,j) i , fv\n\u232a + \u03bb \u2211 u\u2208N(v) \u03c3 (\u2329 \u03c6 (1,j\u22121) G (u), \u03c8 (1) i,j\u22121 \u232a) = \u2329 w\n(1,j) i , fv\n\u232a + \u221a \u03bb \u2211\nu\u2208N(v)\n\u2329 \u03c6\u03c3(\u03c6 (1,j\u22121) G (u)), \u221a \u03bb\u03c8\u03c3(\u03c8 (1) i,j\u22121) \u232a\n= \u2329fv,\u221a\u03bb \u2211 u\u2208N(v) \u03c6\u03c3(\u03c6 (1,j\u22121) G (u))  , [w(1,j)i ,\u221a\u03bb\u03c8\u03c3(\u03c8(1)i,j\u22121)] \u232a\nLet \u03c8(1)i,j = [ w (1,j) i , \u221a \u03bb\u03c8\u03c3(\u03c8 (1) i,j\u22121) ] concludes the base case l = 1. Suppose induction hypothesis holds for 1, 2, \u00b7 \u00b7 \u00b7 , l \u2212 1. Note that when l > 1:\n\u03c6 (l,j) G (v) =  \u03c6\u03c3(\u03c6 (l\u22121) G (v)) if j = 1[ \u03c6\u03c3(\u03c6 (l\u22121) G (v)), \u221a \u03bb \u2211 u\u2208N(v) \u03c6\u03c3(\u03c6 (l,j\u22121) G (u)) ] if j > 1\n0 if Pj(G, v) = \u2205 or Pj(G\u2032, v\u2032) = \u2205\nNow we prove c(l)j [v][i] = \u2329 \u03c6 (l,j) G (v), \u03c8 (l) i,j \u232a by induction on j. When j = 1,\nc (l) 1 [v][i] =\n\u2329 w\n(l,1) i ,h\n(l\u22121)[v] \u232a\n= \u2211 k w (l,1) ik \u2329 \u03c6 (l\u22121) G,\u03c3 (v), \u03c8 (l\u22121) \u03c3,k,n \u232a = \u2329 \u03c6 (l,1) G (v),\n\u2211 k w (l,1) ik \u03c8 (l\u22121) \u03c3,k,n\n\u232a\nLet \u03c8(l)i,j = \u2211 kw (l,1) ik \u03c8 (l\u22121) \u03c3,k,n completes the proof for j = 1. Now suppose this holds for 1, 2, \u00b7 \u00b7 \u00b7 , j \u2212 1. Same as before, we only consider the case when Pj(G, v) 6= \u2205:\nc (l) j [v][i] =\n\u2329 w\n(l,j) i ,h\n(l\u22121)[v] \u232a + \u03bb \u2211 u\u2208N(v) \u03c3 ( c (l) j\u22121[u][i] ) =\n\u2211 k w (l,j) ik \u2329 \u03c6 (l\u22121) G,\u03c3 (v), \u03c8 (l\u22121) \u03c3,k,n \u232a + \u03bb \u2211 u\u2208N(v) \u03c3 (\u2329 \u03c6 (l,j\u22121) G (u), \u03c8 (l) i,j\u22121 \u232a)\n= \u2329 \u03c6 (l\u22121) G,\u03c3 (v), \u2211 k w (l,j) ik \u03c8 (l\u22121) \u03c3,k,n \u232a + \u03bb \u2211 u\u2208N(v) \u2329 \u03c6 (l,j\u22121) G,\u03c3 (u), \u03c8\u03c3(\u03c8 (l) i,j\u22121) \u232a\n= \u2329 \u03c6 (l\u22121) G,\u03c3 (v), \u2211 k w (l,j) ik \u03c8 (l\u22121) \u03c3,k,n \u232a + \u2329 \u221a \u03bb \u2211 u\u2208N(v) \u03c6 (l,j\u22121) G,\u03c3 (u), \u221a \u03bb\u03c8\u03c3(\u03c8 (l) i,j\u22121) \u232a\n= \u2329\u03c6(l\u22121)G,\u03c3 (v),\u221a\u03bb \u2211 u\u2208N(v) \u03c6 (l,j\u22121) G,\u03c3 (u)  ,[\u2211 k w (l,j) ik \u03c8 (l\u22121) \u03c3,k,n , \u221a \u03bb\u03c8\u03c3(\u03c8 (l) i,j\u22121) ]\u232a\n= \u2329 \u03c6 (l,j) G (v), \u03c8 (l) i,j \u232a Let \u03c8(l)i,j = [\u2211 kw (l,j) ik \u03c8 (l\u22121) \u03c3,k,n , \u221a \u03bb\u03c8\u03c3(\u03c8 (l) i,j\u22121) ] concludes the proof.\nProof for (iii): We construct a directed chain Ln,k = (V,E) from model parameters, with nodes V = {ln, ln\u22121, \u00b7 \u00b7 \u00b7 , l0} and E = {(vi+1, vi)}. lj\u2019s underlying mapping is \u03c8(L)\u03c3,i,j . Now we have\nhG[i] = \u2211 v h(L)[v][i] = \u2211 v\u2208G \u2329 \u03c6\u03c3(\u03c6 (L) G (v)), \u03c8 (L) \u03c3,i,n \u232a = \u2211 v\u2208G \u2211 v\u2208Ln,k K(L,n)loc (v, ln) = K (L,n)(G,Ln,k)\nNote that we are utilizing the fact that K(L,n)loc (v, lj) = 0 for all j 6= n (because Pn(Ln,j , lj) = \u2205)."}], "references": [{"title": "Deep convolutional networks are hierarchical kernel machines", "author": ["Anselmi", "Fabio", "Rosasco", "Lorenzo", "Tan", "Cheston", "Poggio", "Tomaso"], "venue": null, "citeRegEx": "Anselmi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Anselmi et al\\.", "year": 2015}, {"title": "Strongly-typed recurrent neural networks", "author": ["Balduzzi", "David", "Ghifary", "Muhammad"], "venue": "In Proceedings of 33th International Conference on Machine Learning (ICML),", "citeRegEx": "Balduzzi et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Balduzzi et al\\.", "year": 2016}, {"title": "Spectral networks and locally connected networks on graphs", "author": ["Bruna", "Joan", "Zaremba", "Wojciech", "Szlam", "Arthur", "LeCun", "Yann"], "venue": "arXiv preprint arXiv:1312.6203,", "citeRegEx": "Bruna et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bruna et al\\.", "year": 2013}, {"title": "Long short-term memory networks for machine reading", "author": ["Cheng", "Jianpeng", "Dong", "Li", "Lapata", "Mirella"], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Cheng et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Cheng et al\\.", "year": 2016}, {"title": "Kernel methods for deep learning", "author": ["Cho", "Youngmin", "Saul", "Lawrence K"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Cho et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Cho et al\\.", "year": 2009}, {"title": "Empirical evaluation of gated recurrent neural networks on sequence modeling", "author": ["Chung", "Junyoung", "Gulcehre", "Caglar", "Cho", "KyungHyun", "Bengio", "Yoshua"], "venue": "arXiv preprint arXiv:1412.3555,", "citeRegEx": "Chung et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Chung et al\\.", "year": 2014}, {"title": "Discriminative embeddings of latent variable models for structured data", "author": ["Dai", "Hanjun", "Bo", "Song", "Le"], "venue": "arXiv preprint arXiv:1603.05629,", "citeRegEx": "Dai et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Dai et al\\.", "year": 2016}, {"title": "Toward deeper understanding of neural networks: The power of initialization and a dual view on expressivity", "author": ["Daniely", "Amit", "Frostig", "Roy", "Singer", "Yoram"], "venue": null, "citeRegEx": "Daniely et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Daniely et al\\.", "year": 2016}, {"title": "Recurrent neural network grammars", "author": ["Dyer", "Chris", "Kuncoro", "Adhiguna", "Ballesteros", "Miguel", "Smith", "Noah A"], "venue": "In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics,", "citeRegEx": "Dyer et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Dyer et al\\.", "year": 2016}, {"title": "A theoretically grounded application of dropout in recurrent neural networks", "author": ["Gal", "Yarin", "Ghahramani", "Zoubin"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Gal et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Gal et al\\.", "year": 2016}, {"title": "On graph kernels: Hardness results and efficient alternatives", "author": ["G\u00e4rtner", "Thomas", "Flach", "Peter", "Wrobel", "Stefan"], "venue": "In Learning Theory and Kernel Machines,", "citeRegEx": "G\u00e4rtner et al\\.,? \\Q2003\\E", "shortCiteRegEx": "G\u00e4rtner et al\\.", "year": 2003}, {"title": "Lstm: A search space odyssey", "author": ["Greff", "Klaus", "Srivastava", "Rupesh Kumar", "Koutn\u0131\u0301k", "Jan", "Steunebrink", "Bas R", "Schmidhuber", "J\u00fcrgen"], "venue": "arXiv preprint arXiv:1503.04069,", "citeRegEx": "Greff et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Greff et al\\.", "year": 2015}, {"title": "Steps toward deep kernel methods from infinite neural networks", "author": ["Hazan", "Tamir", "Jaakkola", "Tommi"], "venue": "arXiv preprint arXiv:1508.05133,", "citeRegEx": "Hazan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hazan et al\\.", "year": 2015}, {"title": "Improper deep kernels", "author": ["Heinemann", "Uri", "Livni", "Roi", "Eban", "Elad", "Elidan", "Gal", "Globerson", "Amir"], "venue": "In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Heinemann et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Heinemann et al\\.", "year": 2016}, {"title": "Deep convolutional networks on graph-structured data", "author": ["Henaff", "Mikael", "Bruna", "Joan", "LeCun", "Yann"], "venue": "arXiv preprint arXiv:1506.05163,", "citeRegEx": "Henaff et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Henaff et al\\.", "year": 2015}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["Hinton", "Geoffrey E", "Srivastava", "Nitish", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan R"], "venue": "arXiv preprint arXiv:1207.0580,", "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "Long shortterm memory", "author": ["Hochreiter", "Sepp", "Schmidhuber", "J\u00fcrgen"], "venue": "Neural computation,", "citeRegEx": "Hochreiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 1997}, {"title": "Deep recursive neural networks for compositionality in language", "author": ["Irsoy", "Ozan", "Cardie", "Claire"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Irsoy et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Irsoy et al\\.", "year": 2014}, {"title": "Deep unordered composition rivals syntactic methods for text classification", "author": ["Iyyer", "Mohit", "Manjunatha", "Varun", "Boyd-Graber", "Jordan", "Daum\u00e9 III", "Hal"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Iyyer et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Iyyer et al\\.", "year": 2015}, {"title": "A convolutional neural network for modelling sentences", "author": ["Kalchbrenner", "Nal", "Grefenstette", "Edward", "Blunsom", "Phil"], "venue": "In Proceedings of the 52th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Kalchbrenner et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kalchbrenner et al\\.", "year": 2014}, {"title": "Convolutional neural networks for sentence classification", "author": ["Kim", "Yoon"], "venue": "In Proceedings of the Empiricial Methods in Natural Language Processing (EMNLP", "citeRegEx": "Kim and Yoon.,? \\Q2014\\E", "shortCiteRegEx": "Kim and Yoon.", "year": 2014}, {"title": "Character-aware neural language models", "author": ["Kim", "Yoon", "Jernite", "Yacine", "Sontag", "David", "Rush", "Alexander M"], "venue": "Twenty-Ninth AAAI Conference on Artificial Intelligence,", "citeRegEx": "Kim et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2015}, {"title": "Adam: A method for stochastic optimization", "author": ["Kingma", "Diederik P", "Ba", "Jimmy Lei"], "venue": "In International Conference on Learning Representation,", "citeRegEx": "Kingma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2015}, {"title": "Ask me anything: Dynamic memory networks for natural language processing", "author": ["Kumar", "Ankit", "Irsoy", "Ozan", "Ondruska", "Peter", "Iyyer", "Mohit", "James Bradbury", "Ishaan Gulrajani", "Zhong", "Victor", "Paulus", "Romain", "Socher", "Richard"], "venue": null, "citeRegEx": "Kumar et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Kumar et al\\.", "year": 2016}, {"title": "Distributed representations of sentences and documents", "author": ["Le", "Quoc", "Mikolov", "Tomas"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "Le et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Le et al\\.", "year": 2014}, {"title": "Recurrent additive networks", "author": ["Lee", "Kenton", "Levy", "Omer", "Zettlemoyer", "Luke"], "venue": null, "citeRegEx": "Lee et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2017}, {"title": "Semi-supervised question retrieval with gated convolutions", "author": ["Lei", "Tao", "Joshi", "Hrishikesh", "Barzilay", "Regina", "Jaakkola", "Tommi", "Tymoshenko", "Katerina", "Moschitti", "Alessandro", "Marquez", "Lluis"], "venue": "arXiv preprint arXiv:1512.05726,", "citeRegEx": "Lei et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lei et al\\.", "year": 2015}, {"title": "Gated graph sequence neural networks", "author": ["Li", "Yujia", "Tarlow", "Daniel", "Brockschmidt", "Marc", "Zemel", "Richard"], "venue": "arXiv preprint arXiv:1511.05493,", "citeRegEx": "Li et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Li et al\\.", "year": 2015}, {"title": "Text classification using string kernels", "author": ["Lodhi", "Huma", "Saunders", "Craig", "Shawe-Taylor", "John", "Cristianini", "Nello", "Watkins", "Chris"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Lodhi et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Lodhi et al\\.", "year": 2002}, {"title": "Pointer sentinel mixture models", "author": ["Merity", "Stephen", "Xiong", "Caiming", "Bradbury", "James", "Socher", "Richard"], "venue": "arXiv preprint arXiv:1609.07843,", "citeRegEx": "Merity et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Merity et al\\.", "year": 2016}, {"title": "Glove: Global vectors for word representation. volume", "author": ["Pennington", "Jeffrey", "Socher", "Richard", "Manning", "Christopher D"], "venue": null, "citeRegEx": "Pennington et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pennington et al\\.", "year": 2014}, {"title": "Using the output embedding to improve language models", "author": ["Press", "Ofir", "Wolf", "Lior"], "venue": "arXiv preprint arXiv:1608.05859,", "citeRegEx": "Press et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Press et al\\.", "year": 2016}, {"title": "Expressivity versus efficiency of graph kernels", "author": ["Ramon", "Jan", "G\u00e4rtner", "Thomas"], "venue": "In First international workshop on mining graphs, trees and sequences,", "citeRegEx": "Ramon et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Ramon et al\\.", "year": 2003}, {"title": "Learning kernel-based halfspaces with the 01 loss", "author": ["Shalev-Shwartz", "Shai", "Shamir", "Ohad", "Sridharan", "Karthik"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2011}, {"title": "Weisfeiler-lehman graph kernels", "author": ["Shervashidze", "Nino", "Schweitzer", "Pascal", "Leeuwen", "Erik Jan van", "Mehlhorn", "Kurt", "Borgwardt", "Karsten M"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Shervashidze et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Shervashidze et al\\.", "year": 2011}, {"title": "Recursive deep models for semantic compositionality over a sentiment treebank", "author": ["Socher", "Richard", "Perelygin", "Alex", "Wu", "Jean", "Chuang", "Jason", "Manning", "Christopher D", "Ng", "Andrew Y", "Potts", "Christopher"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural", "citeRegEx": "Socher et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2013}, {"title": "Training very deep networks", "author": ["Srivastava", "Rupesh K", "Greff", "Klaus", "Schmidhuber", "J\u00fcrgen"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Srivastava et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Srivastava et al\\.", "year": 2015}, {"title": "Improved semantic representations from treestructured long short-term memory networks", "author": ["Tai", "Kai Sheng", "Socher", "Richard", "Manning", "Christopher D"], "venue": "In Proceedings of the 53th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Tai et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Tai et al\\.", "year": 2015}, {"title": "Value iteration networks", "author": ["Tamar", "Aviv", "Levine", "Sergey", "Abbeel", "Pieter", "Wu", "Yi", "Thomas", "Garrett"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Tamar et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Tamar et al\\.", "year": 2016}, {"title": "Recurrent neural network regularization", "author": ["Zaremba", "Wojciech", "Sutskever", "Ilya", "Vinyals", "Oriol"], "venue": "arXiv preprint arXiv:1409.2329,", "citeRegEx": "Zaremba et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zaremba et al\\.", "year": 2014}, {"title": "`1regularized neural networks are improperly learnable in polynomial time", "author": ["Zhang", "Yuchen", "Lee", "Jason D", "Jordan", "Michael I"], "venue": "In Proceedings of the 33nd International Conference on Machine Learning,", "citeRegEx": "Zhang et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2016}, {"title": "Recurrent Highway Networks", "author": ["Zilly", "Julian Georg", "Srivastava", "Rupesh Kumar", "Koutn\u0131\u0301k", "Jan", "Schmidhuber", "J\u00fcrgen"], "venue": "arXiv preprint arXiv:1607.03474,", "citeRegEx": "Zilly et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zilly et al\\.", "year": 2016}, {"title": "Neural architecture search with reinforcement learning", "author": ["Zoph", "Barret", "Le", "Quoc V"], "venue": "arXiv preprint arXiv:1611.01578,", "citeRegEx": "Zoph et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zoph et al\\.", "year": 2016}, {"title": "2017) both suggest that a linear additive state computation suffices to provide competitive performance compared to LSTMs", "author": ["Lee"], "venue": "Ghifary", "citeRegEx": "Lee,? \\Q2017\\E", "shortCiteRegEx": "Lee", "year": 2017}], "referenceMentions": [{"referenceID": 5, "context": "For instance, LSTM (Hochreiter & Schmidhuber, 1997), GRU (Chung et al., 2014) and other complex recurrent units (Zoph & Le, 2016) can be easily adapted to embed structured objects such as sentences (Tai et al.", "startOffset": 57, "endOffset": 77}, {"referenceID": 37, "context": ", 2014) and other complex recurrent units (Zoph & Le, 2016) can be easily adapted to embed structured objects such as sentences (Tai et al., 2015) or molecules (Li et al.", "startOffset": 128, "endOffset": 146}, {"referenceID": 27, "context": ", 2015) or molecules (Li et al., 2015; Dai et al., 2016) into vector spaces suitable for later processing by standard predictive methods.", "startOffset": 21, "endOffset": 56}, {"referenceID": 6, "context": ", 2015) or molecules (Li et al., 2015; Dai et al., 2016) into vector spaces suitable for later processing by standard predictive methods.", "startOffset": 21, "endOffset": 56}, {"referenceID": 38, "context": "For example, value iteration calculations can be folded into convolutional architectures so as to optimize the representations to facilitate planning (Tamar et al., 2016).", "startOffset": 150, "endOffset": 170}, {"referenceID": 6, "context": "Similarly, inference calculations in graphical models about latent states of variables such as atom characteristics can be directly associated with embedding operations (Dai et al., 2016).", "startOffset": 169, "endOffset": 187}, {"referenceID": 28, "context": "For example, in a string kernel (Lodhi et al., 2002), S may refer to all possible subsequences while a graph kernel (Vishwanathan et al.", "startOffset": 32, "endOffset": 52}, {"referenceID": 40, "context": "Several studies have highlighted the relation between feed-forward neural architectures and kernels (Hazan & Jaakkola, 2015; Zhang et al., 2016) but we are unaware of any prior work pertaining to kernels associated with neural architectures for structured objects.", "startOffset": 100, "endOffset": 144}, {"referenceID": 28, "context": "String Kernel String kernel measures the similarity between two sequences by counting shared subsequences (see Lodhi et al. (2002)).", "startOffset": 111, "endOffset": 131}, {"referenceID": 33, "context": "It turns out that many activations are also functions in the reproducing kernel Hilbert space (RKHS) of certain kernel functions (see Shalev-Shwartz et al. (2011); Zhang et al.", "startOffset": 134, "endOffset": 163}, {"referenceID": 33, "context": "It turns out that many activations are also functions in the reproducing kernel Hilbert space (RKHS) of certain kernel functions (see Shalev-Shwartz et al. (2011); Zhang et al. (2016)).", "startOffset": 134, "endOffset": 184}, {"referenceID": 40, "context": "(l + 1)th kernel is defined on top of l-th kernel), which has been proven for feed-forward networks (Zhang et al., 2016).", "startOffset": 100, "endOffset": 120}, {"referenceID": 10, "context": "Random Walk Kernel NNs We start from random walk graph kernels (G\u00e4rtner et al., 2003), which count common walks in two graphs.", "startOffset": 63, "endOffset": 85}, {"referenceID": 34, "context": "This parameter tying mechanism allows our model to embed Weisfeiler-Lehman kernel (Shervashidze et al., 2011).", "startOffset": 82, "endOffset": 109}, {"referenceID": 34, "context": "Figure taken from Shervashidze et al. (2011) Note that our definition of r(v) is exactly the same as hv in Equation 9, with \u25e6 being additive composition.", "startOffset": 18, "endOffset": 45}, {"referenceID": 5, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al.", "startOffset": 132, "endOffset": 152}, {"referenceID": 0, "context": "Similar results have been made for convolutional neural nets (Anselmi et al., 2015), and general computational graphs (Daniely et al.", "startOffset": 61, "endOffset": 83}, {"referenceID": 7, "context": ", 2015), and general computational graphs (Daniely et al., 2016).", "startOffset": 42, "endOffset": 64}, {"referenceID": 40, "context": "While some prior work appeals to convex optimization through improper learning (Zhang et al., 2016; Heinemann et al., 2016) (since kernel space is larger), we use the proposed networks as building blocks in typical non-convex but flexible neural network training.", "startOffset": 79, "endOffset": 123}, {"referenceID": 13, "context": "While some prior work appeals to convex optimization through improper learning (Zhang et al., 2016; Heinemann et al., 2016) (since kernel space is larger), we use the proposed networks as building blocks in typical non-convex but flexible neural network training.", "startOffset": 79, "endOffset": 123}, {"referenceID": 3, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others.", "startOffset": 133, "endOffset": 229}, {"referenceID": 3, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm to further optimize the design of such recurrent architectures.", "startOffset": 133, "endOffset": 275}, {"referenceID": 3, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm to further optimize the design of such recurrent architectures. Our proposed neural networks offer similar state evolution and feature aggregation functionalities but derive the motivation for the operations involved from wellestablished kernel computations over sequences. Recursive neural networks are alternative architectures to model hierarchical structures such as syntax trees and logic forms. For instance, Socher et al. (2013) employs recursive networks for sentence classification, where each node in the dependency tree of the sentence is transformed into a vector representation.", "startOffset": 133, "endOffset": 771}, {"referenceID": 3, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm to further optimize the design of such recurrent architectures. Our proposed neural networks offer similar state evolution and feature aggregation functionalities but derive the motivation for the operations involved from wellestablished kernel computations over sequences. Recursive neural networks are alternative architectures to model hierarchical structures such as syntax trees and logic forms. For instance, Socher et al. (2013) employs recursive networks for sentence classification, where each node in the dependency tree of the sentence is transformed into a vector representation. Tai et al. (2015) further proposed tree-LSTM, which incorporates LSTM-style architectures as the transformation unit.", "startOffset": 133, "endOffset": 945}, {"referenceID": 3, "context": "This includes recurrent modules with the ability to carry persistent memories such as LSTM (Hochreiter & Schmidhuber, 1997) and GRU (Chung et al., 2014), as well as non-consecutive convolutional modules (RCNNs, Lei et al. (2015)), and others. More recently, Zoph & Le (2016) exemplified a reinforcement learning-based search algorithm to further optimize the design of such recurrent architectures. Our proposed neural networks offer similar state evolution and feature aggregation functionalities but derive the motivation for the operations involved from wellestablished kernel computations over sequences. Recursive neural networks are alternative architectures to model hierarchical structures such as syntax trees and logic forms. For instance, Socher et al. (2013) employs recursive networks for sentence classification, where each node in the dependency tree of the sentence is transformed into a vector representation. Tai et al. (2015) further proposed tree-LSTM, which incorporates LSTM-style architectures as the transformation unit. Dyer et al. (2015; 2016) recently introduced a recursive neural model for transitionbased language modeling and parsing. While not specifically discussed in the paper, our ideas do extend to similar neural components for hierarchical objects (e.g. trees). Graph Networks Most of the current graph neural architectures perform either convolutional or recurrent operations on graphs. Duvenaud et al. (2015) developed Neural Fingerprint for chemical compounds, where each convolution operation is a sum of neighbor node features, followed by a linear transformation.", "startOffset": 133, "endOffset": 1450}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al.", "startOffset": 2, "endOffset": 22}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform.", "startOffset": 2, "endOffset": 47}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform. For recurrent architectures, Li et al. (2015) proposed gated graph neural networks, where neighbor features are aggregated by GRU function.", "startOffset": 2, "endOffset": 140}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform. For recurrent architectures, Li et al. (2015) proposed gated graph neural networks, where neighbor features are aggregated by GRU function. Dai et al. (2016) considers a different architecture where a graph is viewed as a latent variable graphical model.", "startOffset": 2, "endOffset": 252}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform. For recurrent architectures, Li et al. (2015) proposed gated graph neural networks, where neighbor features are aggregated by GRU function. Dai et al. (2016) considers a different architecture where a graph is viewed as a latent variable graphical model. Their recurrent model is derived from Belief Propagation-like algorithms. Our approach is most closely related to Dai et al. (2016), in terms of neighbor feature aggregation and resulting recurrent architecture.", "startOffset": 2, "endOffset": 481}, {"referenceID": 1, "context": ", Bruna et al. (2013) and Henaff et al. (2015), rely on graph Laplacian or Fourier transform. For recurrent architectures, Li et al. (2015) proposed gated graph neural networks, where neighbor features are aggregated by GRU function. Dai et al. (2016) considers a different architecture where a graph is viewed as a latent variable graphical model. Their recurrent model is derived from Belief Propagation-like algorithms. Our approach is most closely related to Dai et al. (2016), in terms of neighbor feature aggregation and resulting recurrent architecture. Nonetheless, the focus of this paper is on providing a framework for how such recurrent networks could be derived from deep graph kernels. Kernels and Neural Nets Our work follows recent work demonstrating the connection between neural networks and kernels (Cho & Saul, 2009; Hazan & Jaakkola, 2015). For example, Zhang et al. (2016) showed that standard feedforward neural nets belong to a larger space of recursively constructed kernels (given certain activation functions).", "startOffset": 2, "endOffset": 895}, {"referenceID": 15, "context": "We back-propagate the gradient with an unroll size of 35 and use dropout (Hinton et al., 2012) as the regularization.", "startOffset": 73, "endOffset": 94}, {"referenceID": 41, "context": "5 Following (Zilly et al., 2016), we add highway connections (Srivastava et al.", "startOffset": 12, "endOffset": 32}, {"referenceID": 36, "context": ", 2016), we add highway connections (Srivastava et al., 2015) within each layer: c[t] = \u03bbt c[t\u2212 1] + (1\u2212 \u03bbt) (W(l)h(l\u22121)[t]) h[t] = ft c[t] + (1\u2212 ft) h(l\u22121)[t] where h[t] = xt, \u03bbt is the gated decay factor and ft is the transformation gate of highway connections.", "startOffset": 36, "endOffset": 61}, {"referenceID": 41, "context": "8 perplexity when the recurrence depth is increased to 4, being state-of-the-art and on par with the results reported in (Zilly et al., 2016; Zoph & Le, 2016).", "startOffset": 121, "endOffset": 158}, {"referenceID": 15, "context": "We back-propagate the gradient with an unroll size of 35 and use dropout (Hinton et al., 2012) as the regularization. Unless otherwise specified, we train 3-layer networks with n = 1 and normalized adaptive decay.5 Following (Zilly et al., 2016), we add highway connections (Srivastava et al., 2015) within each layer: c[t] = \u03bbt c[t\u2212 1] + (1\u2212 \u03bbt) (W(l)h(l\u22121)[t]) h[t] = ft c[t] + (1\u2212 ft) h(l\u22121)[t] where h[t] = xt, \u03bbt is the gated decay factor and ft is the transformation gate of highway connections.6 Results Table 1 compares our model with various state-ofthe-art models. Our small model with 5 million parameters achieves a test perplexity of 73.6, already outperforming many results achieved using much larger network. By increasing the network size to 20 million, we obtain a test perplexity of 69.2, with standard dropout. Adding variational dropout (Gal & Ghahramani, 2016) within the recurrent cells further improves the perplexity to 65.5. Finally, the model achieves 63.8 perplexity when the recurrence depth is increased to 4, being state-of-the-art and on par with the results reported in (Zilly et al., 2016; Zoph & Le, 2016). Note that Zilly et al. (2016) uses 10 neural layers and Zoph & Le (2016) adopts a complex recurrent cell found by reinforcement learning based search.", "startOffset": 74, "endOffset": 1171}, {"referenceID": 15, "context": "We back-propagate the gradient with an unroll size of 35 and use dropout (Hinton et al., 2012) as the regularization. Unless otherwise specified, we train 3-layer networks with n = 1 and normalized adaptive decay.5 Following (Zilly et al., 2016), we add highway connections (Srivastava et al., 2015) within each layer: c[t] = \u03bbt c[t\u2212 1] + (1\u2212 \u03bbt) (W(l)h(l\u22121)[t]) h[t] = ft c[t] + (1\u2212 ft) h(l\u22121)[t] where h[t] = xt, \u03bbt is the gated decay factor and ft is the transformation gate of highway connections.6 Results Table 1 compares our model with various state-ofthe-art models. Our small model with 5 million parameters achieves a test perplexity of 73.6, already outperforming many results achieved using much larger network. By increasing the network size to 20 million, we obtain a test perplexity of 69.2, with standard dropout. Adding variational dropout (Gal & Ghahramani, 2016) within the recurrent cells further improves the perplexity to 65.5. Finally, the model achieves 63.8 perplexity when the recurrence depth is increased to 4, being state-of-the-art and on par with the results reported in (Zilly et al., 2016; Zoph & Le, 2016). Note that Zilly et al. (2016) uses 10 neural layers and Zoph & Le (2016) adopts a complex recurrent cell found by reinforcement learning based search.", "startOffset": 74, "endOffset": 1214}, {"referenceID": 39, "context": "Model |\u03b8| PPL LSTM (large) (Zaremba et al., 2014) 66m 78.", "startOffset": 27, "endOffset": 49}, {"referenceID": 21, "context": "4 Character CNN (Kim et al., 2015) 19m 78.", "startOffset": 16, "endOffset": 34}, {"referenceID": 41, "context": "9 Variational RHN (Zilly et al., 2016) 23m 65.", "startOffset": 18, "endOffset": 38}, {"referenceID": 35, "context": "We use the Stanford Sentiment Treebank benchmark (Socher et al., 2013).", "startOffset": 49, "endOffset": 70}, {"referenceID": 31, "context": "Model Fine Binary RNN (Socher et al. (2011)) 43.", "startOffset": 23, "endOffset": 44}, {"referenceID": 31, "context": "Model Fine Binary RNN (Socher et al. (2011)) 43.2 82.4 RNTN (Socher et al. (2013)) 45.", "startOffset": 23, "endOffset": 82}, {"referenceID": 31, "context": "Model Fine Binary RNN (Socher et al. (2011)) 43.2 82.4 RNTN (Socher et al. (2013)) 45.7 85.4 DRNN (Irsoy & Cardie (2014)) 49.", "startOffset": 23, "endOffset": 121}, {"referenceID": 31, "context": "Model Fine Binary RNN (Socher et al. (2011)) 43.2 82.4 RNTN (Socher et al. (2013)) 45.7 85.4 DRNN (Irsoy & Cardie (2014)) 49.8 86.8 RLSTM (Tai et al. (2015)) 51.", "startOffset": 23, "endOffset": 157}, {"referenceID": 17, "context": "0 DCNN (Kalchbrenner et al. (2014)) 48.", "startOffset": 8, "endOffset": 35}, {"referenceID": 17, "context": "0 DCNN (Kalchbrenner et al. (2014)) 48.5 86.9 CNN-MC (Kim (2014)) 47.", "startOffset": 8, "endOffset": 65}, {"referenceID": 17, "context": "0 DCNN (Kalchbrenner et al. (2014)) 48.5 86.9 CNN-MC (Kim (2014)) 47.4 88.1 Bi-LSTM (Tai et al. (2015)) 49.", "startOffset": 8, "endOffset": 103}, {"referenceID": 3, "context": "5 LSTMN (Cheng et al. (2016)) 47.", "startOffset": 9, "endOffset": 29}, {"referenceID": 3, "context": "5 LSTMN (Cheng et al. (2016)) 47.9 87.0 PVEC (Le & Mikolov (2014)) 48.", "startOffset": 9, "endOffset": 66}, {"referenceID": 3, "context": "5 LSTMN (Cheng et al. (2016)) 47.9 87.0 PVEC (Le & Mikolov (2014)) 48.7 87.8 DAN (Iyyer et al. (2014)) 48.", "startOffset": 9, "endOffset": 102}, {"referenceID": 3, "context": "5 LSTMN (Cheng et al. (2016)) 47.9 87.0 PVEC (Le & Mikolov (2014)) 48.7 87.8 DAN (Iyyer et al. (2014)) 48.2 86.8 DMN (Kumar et al. (2016)) 52.", "startOffset": 9, "endOffset": 138}, {"referenceID": 18, "context": "Following the recent work of DAN (Iyyer et al., 2015) and RLSTM (Tai et al.", "startOffset": 33, "endOffset": 53}, {"referenceID": 37, "context": ", 2015) and RLSTM (Tai et al., 2015), we use the publicly available 300-dimensional GloVe word vectors (Pennington et al.", "startOffset": 18, "endOffset": 36}, {"referenceID": 30, "context": ", 2015), we use the publicly available 300-dimensional GloVe word vectors (Pennington et al., 2014).", "startOffset": 74, "endOffset": 99}, {"referenceID": 6, "context": "Model (Dai et al., 2016) |\u03b8| RMSE Mean Predicator 1 2.", "startOffset": 6, "endOffset": 24}, {"referenceID": 6, "context": "Molecular Graph Regression Dataset and Setup We further evaluate our graph NN models on the Harvard Clean Energy Project benchmark, which has been used in Dai et al. (2016); Duvenaud et al.", "startOffset": 155, "endOffset": 173}, {"referenceID": 6, "context": "Molecular Graph Regression Dataset and Setup We further evaluate our graph NN models on the Harvard Clean Energy Project benchmark, which has been used in Dai et al. (2016); Duvenaud et al. (2015) as their evaluation dataset.", "startOffset": 155, "endOffset": 197}, {"referenceID": 6, "context": "Molecular Graph Regression Dataset and Setup We further evaluate our graph NN models on the Harvard Clean Energy Project benchmark, which has been used in Dai et al. (2016); Duvenaud et al. (2015) as their evaluation dataset. This dataset contains 2.3 million candidate molecules, with each molecule labeled with its power conversion efficiency (PCE) value. We follow exactly the same train-test split as Dai et al. (2016), and the same re-sampling procedure on the training data (but not the test data) to make the algorithm put more Table 3: Experiments on Harvard Clean Energy Project.", "startOffset": 155, "endOffset": 423}, {"referenceID": 6, "context": "Molecular Graph Regression Dataset and Setup We further evaluate our graph NN models on the Harvard Clean Energy Project benchmark, which has been used in Dai et al. (2016); Duvenaud et al. (2015) as their evaluation dataset. This dataset contains 2.3 million candidate molecules, with each molecule labeled with its power conversion efficiency (PCE) value. We follow exactly the same train-test split as Dai et al. (2016), and the same re-sampling procedure on the training data (but not the test data) to make the algorithm put more Table 3: Experiments on Harvard Clean Energy Project. We report Root Mean Square Error(RMSE) on test set. The first block lists the results reported in Dai et al. (2016) for reference.", "startOffset": 155, "endOffset": 705}, {"referenceID": 6, "context": "Embedded Loopy BP (Dai et al., 2016) is a recurrent architecture, with 4 recurrent iterations.", "startOffset": 18, "endOffset": 36}], "year": 2017, "abstractText": "The design of neural architectures for structured objects is typically guided by experimental insights rather than a formal process. In this work, we appeal to kernels over combinatorial structures, such as sequences and graphs, to derive appropriate neural operations. We introduce a class of deep recurrent neural operations and formally characterize their associated kernel spaces. Our recurrent modules compare the input to virtual reference objects (cf. filters in CNN) via the kernels. Similar to traditional neural operations, these reference objects are parameterized and directly optimized in end-to-end training. We empirically evaluate the proposed class of neural architectures on standard applications such as language modeling and molecular graph regression, achieving state-of-the-art results across these applications.", "creator": "LaTeX with hyperref package"}}}