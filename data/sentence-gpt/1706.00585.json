{"id": "1706.00585", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Jun-2017", "title": "Exception-Based Knowledge Updates", "abstract": "Existing methods for dealing with knowledge updates differ greatly depending on the underlying knowledge representation formalism. When Classical Logic is used, updates are typically performed by manipulating the knowledge base on the model-theoretic level. On the opposite side of the spectrum stand the semantics for updating Answer-Set Programs that need to rely on rule syntax. Yet, a unifying perspective that could embrace both these branches of research is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their cross-fertilisation, ripening and further development.\n\n\n\nFor an in-depth look into the latest developments in the science of knowledge and practice of knowledge processing, a book on the use and control of knowledge systems and technologies is published by Simon & Schuster (2006). The books provide a comprehensive overview of the techniques used to handle knowledge updates and, particularly on the topics of research, understanding systems and technologies. The books offer an interesting overview of how knowledge processing works and how it could help a new generation of knowledge researchers with new ideas, tools and knowledge knowledge approaches. The books also provide a comprehensive look at the evolution of knowledge processing using the current research methods and techniques. The first book, the Advanced Techniques for Knowledge Management, covers the evolution and control of knowledge processing for information processing systems in a wide variety of fields. The book will provide a comprehensive discussion of the science of knowledge processing with topics of research, understanding systems and technologies.\nFurther reading\nThe book covers the evolution and control of knowledge processing for information processing systems in a wide variety of fields. The book will provide a comprehensive overview of the techniques used to handle knowledge updates and, particularly on the topics of research, understanding systems and technologies. The books also provide a comprehensive overview of the techniques used to handle knowledge updates and, particularly on the topics of research, understanding systems and technologies. The books also provide a comprehensive look at the evolution and control of knowledge processing with topics of research, understanding systems and technologies. The books also provide a comprehensive look at the evolution and control of knowledge processing with topics of research, understanding systems and technologies. The books also provide a comprehensive look at the evolution and control of knowledge processing with topics of research, understanding systems and technologies. The books also provide a comprehensive look at the evolution and control of knowledge processing with topics of research, understanding systems and technologies. The books also provide a comprehensive look at the evolution and control of knowledge processing with topics of research, understanding systems and technologies. The books also provide a comprehensive look at", "histories": [["v1", "Fri, 2 Jun 2017 08:31:10 GMT  (104kb,D)", "http://arxiv.org/abs/1706.00585v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["martin slota", "joao leite"], "accepted": false, "id": "1706.00585"}, "pdf": {"name": "1706.00585.pdf", "metadata": {"source": "CRF", "title": "Exception-Based Knowledge Updates", "authors": ["Martin Slota", "Jo\u00e3o Leite"], "emails": ["martin.slota@gmail.com", "jleite@fct.unl.pt"], "sections": [{"heading": null, "text": "Existing methods for dealing with knowledge updates differ greatly depending on the underlying knowledge representation formalism. When Classical Logic is used, updates are typically performed by manipulating the knowledge base on the model-theoretic level. On the opposite side of the spectrum stand the semantics for updating Answer-Set Programs that need to rely on rule syntax. Yet, a unifying perspective that could embrace both these branches of research is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their cross-fertilisation, ripening and further development. Furthermore, from a more pragmatic viewpoint, such a unification is a necessary step in addressing updates of hybrid knowledge bases consisting of both a classical and a rule component.\nThis paper bridges the seemingly irreconcilable approaches to updates. It introduces a novel monotonic characterisation of rules, dubbed RE-models, and shows it to be a more suitable semantic foundation for rule updates than SE-models. Then it proposes a generic scheme for specifying semantic rule update operators, based on the idea of viewing a program as the set of sets of RE-models of its rules; updates are performed by introducing additional interpretations \u2013 exceptions \u2013 to the sets of RE-models of rules in the original program. The introduced scheme is then used to define particular rule update operators that are closely related to both classical update principles and traditional approaches to rules updates, enjoying a range of plausible syntactic as well as semantic properties. In addition, these operators serve as a basis for a solution to the long-standing problem of state condensing for two of the foundational rule update semantics, showing how they can be equivalently defined as binary operators on some class of logic programs.\nFinally, the essence of these ideas is extracted to define an abstract framework for exception-based update operators, viewing a knowledge base as the set of sets of models of its elements. It is shown that the framework can capture a wide range of both model- and formula-based classical update operators, and thus serves as the first firm formal ground connecting classical and rule updates."}, {"heading": "1. Introduction", "text": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively. This has fostered a large number of ontologies and\nIThis is a revised and extended version of the material presented in [66\u201368]. \u2217Corresponding author. Email addresses: martin.slota@gmail.com (Martin Slota), jleite@fct.unl.pt (Joa\u0303o Leite) 1http://www.w3.org/TR/owl-overview/ 2http://www.w3.org/2005/rules/wiki/RIF_Working_Group\nPreprint submitted to Elsevier June 5, 2017\nar X\niv :1\n70 6.\n00 58\n5v 1\n[ cs\n.A I]\n2 J\nun 2\n01 7\nrule bases with different levels of complexity and scale. Whereas ontologies provide the logical underpinning of intelligent access and information integration, rules are widely used to represent business policies, regulations and declarative guidelines about information.\nSince both ontologies and rules offer important features for knowledge representation, considerable effort has been invested in identifying a unified hybrid knowledge framework where expressivity of both formalisms could be seamlessly combined. Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54]. While such formalisms make it possible to seamlessly combine rules and ontologies in a single unified framework, they do not take into account the dynamic character of application areas where they are to be used. More particularly, the essential support for keeping a hybrid knowledge base up to date, by incorporating new and possibly conflicting information, is still missing. Nonetheless, this topic has been extensively addressed in the context of both Description Logics and Logic Programs, when taken separately.\nOntology Updates The area of research called ontology change encompasses a number of strongly related though distin-\nguishable subareas, such as ontology matching, ontology integration and merging, or ontology translation [26]. The purest type of change, concerned with modifications to a single ontology, is generally referred to as ontology evolution. Approaches to ontology evolution with a firm semantic underpinning, thus amenable to a formal analysis of their behaviour and properties, are based on research in the area of belief change, initiated by the seminal work of Alchourro\u0301n, Ga\u0308rdenfors and Makinson (AGM) [1] who proposed a set of desirable properties of change operators on monotonic logics, now referred to as the AGM postulates.\nSubsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73]. While revision deals with incorporating new information about a static world into a knowledge base, update takes place when a knowledge base needs to be brought up to date when the modelled world changes. While AGM postulates were deemed appropriate for describing revision, Katsuno and Mendelzon suggested a different set of postulates for updates: the KM postulates for belief update [41].\nUpdate operators respecting the KM postulates, usually referred to as model-based, are based on the idea that the models of a knowledge base correspond to possible states of the represented world. When a change in the world needs to be recorded, inertia is applied to each of these possible states, making only the smallest necessary modifications to reflect the change, and arriving at a new collection of possible states that represent the world after the update. Since the updates are specified on the semantic level, they are naturally syntax-independent. These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).\nOn the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64]. Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].\nRule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to\nadapt belief update principles and operators to this purpose [2, 53]. However, such approaches proved insufficiently expressive, principally because the model-based approach fails to capture the essential relationships between literals encoded in rules [48], and the formula-based approach is too crude as it does not\nallow rules to be reactivated when reasons for their suppression disappear [75]. Although state-of-the-art approaches to rule updates are guided by the same basic intuitions and aspirations as belief updates, they build upon fundamentally different principles and methods.\nMany of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule. This essentially means that inertia and minimal change is applied to rules instead of to the state, as with model-based belief updates. Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable. Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].\nDespite the variety of techniques used in these approaches, certain properties are common to all of them. First, the stable models assigned to a program after one or more updates are always supported: for each true atom p there exists a rule in either the original program or its updates that has p in the head and whose body is satisfied. Second, all mentioned rule update semantics coincide when it comes to updating sets of facts by newer facts. We conjecture that any reasonable rule update semantics should indeed be in line with the basic intuitions regarding support and fact update. Another common characteristic of all these approaches is that they need to refer to the syntactic structure of a logic program: the individual rules and, in most cases, also the literals in their heads and bodies. This renders them seemingly irreconcilable with ontology updates since ontology axioms simply have no heads and bodies.\nTowards Hybrid Updates\nA unifying framework that could embrace both belief and rule updates is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their crossfertilisation, ripening and further development. It is also important for the development of update semantics for hybrid knowledge bases \u2013 in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.\nMoreover, we argue that syntax-independence, central to model-based belief updates, is essential and should be pursued at large in order to encourage a logical underpinning of all update operators and so facilitate analysis of their semantic properties. When equivalence with respect to classical models is inappropriate, as is the case with rules, syntax-independence should be retained by finding an appropriate notion of equivalence, specific to the underlying formalism and its use.\nWith these standpoints in mind, we proceed with our previous work addressing the logical foundations of rule updates. In [69] we have shown that strong equivalence is not a suitable basis for syntax-independent rule update operators because such operators cannot respect both support and fact update. This can be demonstrated on programs P = { p., q. } and Q = { p., q \u2190 p. } which are strongly equivalent, so, due to syntax independence, an update asserting that p is now false ought to lead in both cases to the same stable models. Due to fact update, such an update on P should naturally lead to a stable model where q is true. But in case of Q such a stable model would be unsupported.\nThis led us to the study of stronger notions of program equivalence. In [65] we proposed to view a program as the set of sets of models of its rules in order to acknowledge rules as the atomic pieces of knowledge and, at the same time, abstract away from unimportant differences between their syntactic forms, focusing on their semantic content. In this paper we develop these ideas further and arrive at a unifying perspective on both classical and rule updates. More particularly, our main contributions are as follows:\n\u2022 We introduce a novel monotonic characterisation of rules, RE-models, and show that they form a more suitable semantic foundation for rule updates than SE-models;\n\u2022 We propose a generic scheme for defining semantic rule update operators: a program, viewed as the set of sets of RE-models of its rules, is updated by introducing additional interpretations to those sets of RE-models;\n\u2022 We identify instances of the framework that bridge classical update principles with traditional rule update semantics: they combine syntax-independence with support and fact update and have other desirable syntactic as well as semantic properties.\n\u2022 We solve the enduring problem of state condensing for two foundational rule update semantics by showing how they can be equivalently defined as binary operators on some class of logic programs;\n\u2022 We define abstract exception-based operators for any knowledge representation formalism with a model-theoretic semantics;\n\u2022 We show that exception-based operators capture a wide range of model- and formula-based belief update operators.\nThis paper is organised as follows: We introduce the necessary theoretical background in Section 2 and in Section 3 we define RE-models and associated notions of equivalence. Section 4 introduces the generic scheme for specifying exception-based rule update operators as well as its particular instances and analyses their theoretical properties. Section 5 is devoted to the problem of state condensing and introduces operators for condensing an update sequence into a single program for foundational rule update semantics. Sections 6 and 7 introduce abstract exception-based operators and show how they are able to characterise belief updates. We discuss our findings in a broader context and conclude in Section 8. Proofs of all formal results can be found in the appendices.\n2. Background\n2.1. Propositional Logic We consider a propositional language over a finite set of propositional variables A and the usual set of\npropositional connectives to form propositional formulas. A knowledge base is a finite set of formulas. A (two-valued) interpretation is any I \u2286 A and the set of all interpretations is denoted by I. The set of models of a knowledge base B is defined in the standard way and denoted by [[B ]]. Given an interpretation I , we sometimes write I |= B or I(B) = T if I is a model of B, and I 6|= B or I(B) = F if I is not a model of B. A knowledge base B is consistent if [[B ]] is non-empty; complete if [[B ]] is a singleton set. Given two knowledge bases B, C, we say that B entails C, denoted by B |= C, if [[B ]] \u2286 [[C ]], and that B is equivalent to C, denoted by B \u2261 C, if [[B ]] = [[C ]]. The models, set of models, consistency, completeness, entailment and equivalence are generalised to formulas by treating every formula \u03c6 as the knowledge base {\u03c6 }.\n2.2. Logic Programs The basic syntactic building blocks of rules are also propositional atoms from A. A default literal is an atom preceded by \u223c denoting default negation. The set of all literals L consists of all atoms and default literals. The complementary literal to a literal L is denoted by L and defined as follows: for any atom p, p = \u223c p and \u223c p = p. Given a set of literals S, we introduce the following notation: S+ = { p \u2208 A | p \u2208 S }, S\u2212 = { p \u2208 A | \u223c p \u2208 S }, S = { L \u2223\u2223 L \u2208 S }.\nA rule is a pair of sets of literals \u03c0 = (H\u03c0,B\u03c0). We say that H\u03c0 is the head of \u03c0 and B\u03c0 is the body of \u03c0. Usually, for convenience, we write \u03c0 as ( H+\u03c0 ; H \u2212 \u03c0 \u2190 B+\u03c0 ,B\u2212\u03c0 . ) . A rule is called non-disjunctive if its head contains at most one literal; a fact if its head contains exactly one literal and its body is empty. A program is any set of rules. A program is non-disjunctive if all its rules are; acyclic if it satisfies the conditions set out in [6]. We also introduce the following non-standard notion that is needed throughout the rest of the paper:\nDefinition 1 (Canonical Tautology). Let p\u03c4 \u2208 A be fixed. The canonical tautology \u03c4 is the rule (p\u03c4 \u2190 p\u03c4 .).\nTurning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program. We start by generalizing the set of (classical) models to literals, rules and programs. Given an atom p, a set of literals S, a rule \u03c0 and a program P, we define the following:\n[[\u223c p ]] = I \\ [[p ]] , [[S ]] = \u22c2 L\u2208S [[L ]] ,\n[[\u03c0 ]] = { J \u2208 I | J /\u2208 [[B\u03c0 ]] \u2228 \u2203L \u2208 H\u03c0 : J \u2208 [[L ]] } , [[P ]] = \u22c2 \u03c0\u2208P[[\u03c0 ]] .\nFor a set of literals S, we also write J |= S whenever J \u2208 [[S ]]. A program P is consistent if [[P ]] 6= \u2205. The stable and SE-models are defined in terms of reducts. Given a rule \u03c0 and an interpretation J , the reduct of \u03c0 w.r.t. J , denoted by \u03c0J , is the rule (H+\u03c0 \u2190 B+\u03c0 .) if J |= B\u2212\u03c0 and J |= H\u2212\u03c0 ; otherwise it is the canonical tautology \u03c4 .3 The reduct of a program P w.r.t. J is defined as PJ = { \u03c0J \u2223\u2223 \u03c0 \u2208 P }.\nAn interpretation J is a stable model of a program P if J is a subset-minimal model of PJ . The set of all stable models of P is denoted by [[P ]]SM.\nSE-models are semantic structures that can be seen as three-valued interpretations. In particular, we call a pair of interpretations X = (I, J) such that I \u2286 J a three-valued interpretation. Each atom p is assigned one of three truth values in X: X(p) = T if p \u2208 I; X(p) = U if p \u2208 J \\ I; X(p) = F if p \u2208 A \\ J . The set of all three-valued interpretations is denoted by X. A three-valued interpretation (I, J) is an SE-model of a rule \u03c0 if J is a model of \u03c0 and I is a model of \u03c0J . The set of all SE-models of a rule \u03c0 is denoted by [[\u03c0 ]]SE and for any program P, [[P ]]SE = \u22c2 \u03c0\u2208P[[\u03c0 ]]SE. Note that J is a stable model of P if and only if (J, J) \u2208 [[P ]]SE and for all I ( J , (I, J) /\u2208 [[P ]]SE. Also, J \u2208 [[P ]] if and only if (J, J) \u2208 [[P ]]SE. We say that a rule \u03c0 is (SE-)tautological if [[\u03c0 ]]SE = X. Note that the canonical tautology (c.f. Definition 1) is tautological.\n2.3. Belief Updates\nIn this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].\nWe liberally define a belief update operator as any function that takes the original knowledge base and its update as inputs and returns the updated knowledge base.\nDefinition 2 (Update Operator). A belief update operator is a binary function over the set of all knowledge bases. Any belief update operator is inductively generalised to finite sequences of knowledge bases \u3008Bi\u3009i<n as follows: 3\u3008\u3009 = \u2205 and 3\u3008Bi\u3009i<n+1 = (3\u3008Bi\u3009i<n) Bn.\n3In other words, if J satisfies all default literals in the body of the rule and none of the default literals in its head, then the reduct is obtained from the original rule by removing all default literals from its head and body. In other cases, J is certainly a model of the rule, so the reduct is defined as the canonical tautology.\nThe fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state. Given this perspective, it is natural to perform an update with U by modifying each of the possible states independently of the others, making it consistent with U , and thus obtaining a new set of interpretations \u2013 the models of the updated knowledge base. Formally this is captured by the equation\n[[B U ]] = \u22c3\nI\u2208[[B ]]\nincorporate([[U ]], I) , (1)\nwhere incorporate(M, I) returns the members of M closer to I so that the original information in I is preserved as much as possible. For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I . From a more general perspective, Katsuno and Mendelzon have shown [41] that if each knowledge base is represented by a single formula and incorporate(M, I) is bound to return those members ofM that are minimal w.r.t. a closeness relation \u2264I assigned to I ,4 then the class of operators which satisfy (1) coincides with the class of operators which satisfy the declarative postulates (B1) \u2013 (B8) listed in Table 1. Note that (B1) \u2013 (B6) can be immediately generalised to deal with arbitrary knowledge bases but (B7) and (B8) require disjunction of knowledge bases to be defined.\nSome of these postulates, and especially (B4) which guarantees syntax-independence of an update operator, continue to be seen as fundamental cornerstones of belief updates [34]. The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34]. Note also that (B2) entails the weaker\n4Technically, the closeness relation is simply a partial order on I such that I is the least interpretation w.r.t. \u2264I .\nprinciples (B2.>), (B2.1) and (B2.2). The first two are uncontroversial as they are satisfied by all update operators. In addition, in the presence of (B4), the latter two are together powerful enough to entail (B2), so the controversial part of (B2) is (B2.2) [34].\nEarlier approaches to updates, dubbed formula-based [73], operate on the syntax of a knowledge base and, as a consequence, are not syntax-independent. Nevertheless, they have recently been considered for performing ontology updates [13, 49]. Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30]. We define only the latter two as the Set-Of-Theories operator produces a collection of knowledge bases as its result instead of a single knowledge base, and is equivalent to the Cross-Product operator which compiles these knowledge bases into one.\nThe central notion in these operators is that of a possible remainder which is a maximal set of formulas from the original knowledge base that is consistent with the update. Formally, given knowledge bases B and U , the set of possible remainders rem(B,U) is the set of maximal subsets B\u2032 of B such that B\u2032 \u222a U is consistent. The distinct formula-based operators differ in how they deal with the case when there is more than one possible remainder. While Cross-Product compiles the different remainders into a single formula, WIDTIO takes the safer path \u2013 it keeps exactly those formulas that belong to the intersection of all remainders and throws away the rest. Additionally, in [13] the new formula-based operator Bold was suggested for performing TBox updates. The Bold operator solves the problem of multiple remainders by using a selection function to choose one and commit to it. Formally, a remainder selection function is a function s that assigns to every set of remainders R a remainder s(R) \u2208 R. Given such a selection function s, the Cross-Product operator \u25e6cp, WIDTIO operator \u25e6widtio and Bold operator \u25e6sbold are defined for all knowledge bases B, U as follows:\nB \u25e6cp U = U \u222a {\u2228 B\u2032\u2208rem(B,U) \u2227 B\u2032 } , B \u25e6widtio U = U \u222a \u22c2 rem(B,U), B \u25e6sbold U = U \u222a s(rem(B,U)).\n2.4. Rule Updates Rule update semantics assign stable models to pairs or sequences of programs where each component\nrepresents an update of the preceding ones. In the following, we formalise some of the intuitions behind these semantics and define two foundational rule update semantics.\nWe start with the basic concepts. A dynamic logic program (DLP) is a finite sequence of non-disjunctive programs. Given a DLP P , we use all(P ) to denote the set of all rules belonging to the programs in P .5\nWe say that P is acyclic if all(P ) is acyclic. A rule update semantics S assigns a set of S-stable models [[P ]]S to every DLP P .\nAs indicated in the introduction, rule update semantics implicitly follow certain basic intuitions. Particularly, they produce supported models and their behaviour coincides when it comes to updating sets of facts by newer facts. We formalise these two properties w.r.t. rule update semantics for DLPs, calling them syntactic because their formulation requires that we refer to the syntax of the respective DLP.\nIn the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy. Its generalisation to the dynamic case is straightforward.\nSyntactic Property 1 (Support). Let P be a program, p an atom and J an interpretation. We say that P supports p in J if p \u2208 H\u03c0 and J |= B\u03c0 for some rule \u03c0 \u2208 P.\n5In order to avoid issues with rules that are repeated in multiple components of a DLP, we assume throughout this paper that every rule is uniquely identified in all set-theoretic operations. This can be formalised by assigning a unique name to each rule and performing operations on names instead of the rules themselves. However, for the sake of simplicity, we leave the technical realisation to the reader.\nA rule update semantics S respects support if for every DLP P and every S-stable model J of P the following condition is satisfied: Every atom p \u2208 J is supported by all(P ) in J .\nThus, if a rule update semantics S respects support, then there is at least some justification for every atom in an assigned S-stable model.\nThe second syntactic property that is generally adhered to is the usual expectation regarding how facts are to be updated by newer facts. It enforces a limited notion of state inertia but only for the case when both the initial program and its updates are consistent sets of facts.\nSyntactic Property 2 (Fact Update). A rule update semantics S respects fact update if for every finite sequence of consistent sets of facts P = \u3008Pi\u3009i<n, the unique S-stable model of P is the interpretation\n{ p | \u2203i < n : (p.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (\u223c p.) /\u2208 Pj) } .\nWe also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55]. The first one states the principle itself, under the assumption that a conflict between rules occurs if and only if the rules have complementary heads.\nSyntactic Property 3 (Causal Rejection). A rule update semantics S respects causal rejection if for every DLP P = \u3008Pi\u3009i<n, every S-stable model J of P , all i < n and all rules \u03c0 \u2208 Pi, if J is not a model of \u03c0, then there exists a rule \u03c3 \u2208 Pj with j > i such that H\u03c3 = H\u03c0 and J |= B\u03c3.\nIntuitively, the principle requires that all rejected rules, i.e. rules that are not satisfied in an S-stable model J , must be in conflict with a more recent rule whose body is satisfied in J . This rule then provides a cause for the rejection.\nThe final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36]. Thus, the behaviour of any rule update semantics on acyclic DLPs can be used as a way to compare it to all these semantics simultaneously. Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].\nDefinition 3 (JU-Semantics [48] and UA-Semantics [24]). Let P = \u3008Pi\u3009i<n be a DLP and J an interpretation. The sets of rejected rules rejJU(P , J) and rejUA(P , J) are defined as follows:\nrejJU(P , J) = { \u03c0 \u2208 Pi \u2223\u2223 \u2203j \u2203\u03c3 \u2208 Pj : i < j < n \u2227 H\u03c3 = H\u03c0 \u2227 J |= B\u03c3 } , rejUA(P , J) = { \u03c0 \u2208 Pi\n\u2223\u2223 \u2203j \u2203\u03c3 \u2208 Pj \\ rejUA(P , J) : i < j < n \u2227 H\u03c3 = H\u03c0 \u2227 J |= B\u03c3 } .6 The set [[P ]]JU of JU-models of a DLP P consists of all interpretations J such that J is a stable model of the program all(P ) \\ rejJU(P , J). Similarly, the set [[P ]]UA of UA-models of a DLP P consists of all interpretations J such that J is a stable model of the program all(P ) \\ rejUA(P , J).\nUnder the JU-semantics, a rule \u03c0 is rejected if a more recent rule \u03c3 is in conflict with \u03c0 and the body of \u03c3 is satisfied in the stable model candidate J . The only difference in the UA-semantics [24] is that rejected rules are prevented from rejecting other rules. Perhaps surprisingly, this renders the UA-semantics more sensitive to tautological updates, which cannot indicate any change in the modelled world, than the JU-semantics. For example, the DLP\nP 1 = \u3008{ p. } , {\u223c p. } , { p\u2190 p. }\u3009 (2)\nhas only one JU-model, \u2205, but the UA-semantics admits the additional undesired model { p }. Nevertheless, there are also situations in which the JU-semantics assigns additional models only due to the presence of tautological rules. This is discussed in more detail in Section 8.\nThe final syntactic property can now be stated as follows:\nSyntactic Property 4 (Acyclic Justified Update). A rule update semantics S respects acyclic justified update if for every acyclic DLP P , the set of S-stable models of P is [[P ]]JU.\n2.5. Program Equivalence While in propositional logic equivalence under classical models is the equivalence, there is no such\nsingle notion of program equivalence. When considering Answer-Set Programs, the first choice is stable equivalence (or SM-equivalence) that compares programs based on their sets of stable models.\nIn many cases, however, SM-equivalence is not strong enough because programs with the same stable models, when augmented with the same additional rules, may end up having completely different stable models. This gives rise to the notion of strong equivalence [50] which requires that stable models stay the same even in the presence of additional rules. It is a well-known fact that programs are strongly equivalent if and only if they have the same set of SE-models [71]. Thus, we refer to strong equivalence as SE-equivalence.\nBut even SE-equivalence is not satisfactory when used as a basis for syntax-independent rule update operators because such operators cannot respect both support and fact update [69]. So in order to arrive at syntax-independent rule update operators that satisfy the basic intuitions underlying rule updates, we need to search for a notion of program equivalence that is stronger than SE-equivalence. One candidate is the strong update equivalence (or SU-equivalence) [39], which requires that under both additions and removals of rules, stable models of the two programs in question remain the same. It has been shown in [39] that this notion of equivalence is very strong \u2013 programs are SU-equivalent only if they contain exactly the same non-tautological rules, and in addition, each of them may contain some tautological ones. Thus, this notion of program equivalence seems perhaps too strong as it is not difficult to find rules such as (\u223c p \u2190 p.) and (\u2190 p.) that are syntactically different but carry the same meaning.\nThis observation resulted in the definition of strong rule equivalence (or SR-equivalence) and strong minimal rule equivalence (or SMR-equivalence) in [65] that, in terms of strength, fall between SE-equivalence and SU-equivalence. It is based on the idea of viewing a program P as the set of sets of SE-models of its rules \u3008\u3008P\u3009\u3009SE = { [[\u03c0 ]]SE | \u03c0 \u2208 P }.\nThe five mentioned notions of program equivalence are defined as follows:\nDefinition 4 (Program Equivalence). Let P,Q be programs, P\u03c4 = P \u222a { \u03c4 }, Q\u03c4 = Q \u222a { \u03c4 }, let minS denote the subset-minimal elements of any set of sets S and \u00f7 denote set-theoretic symmetric difference. We write\nP \u2261SM Q whenever [[P ]]SM = [[Q ]]SM ; P \u2261SMR Q whenever min\u3008\u3008P\u03c4 \u3009\u3009SE = min\u3008\u3008Q\u03c4 \u3009\u3009SE ; P \u2261SE Q whenever [[P ]]SE = [[Q ]]SE ; P \u2261SR Q whenever \u3008\u3008P\u03c4 \u3009\u3009SE = \u3008\u3008Q\u03c4 \u3009\u3009SE ; P \u2261SU Q whenever [[P \u00f7Q ]]SE = X .\nWe say that P is X-equivalent to Q if P \u2261X Q.\nSo two programs are SR-equivalent if they contain the same rules, modulo SE-models; \u03c4 is added to both programs so that presence or absence of tautological rules in a program does not influence program equivalence. In the case of SMR-equivalence, only the subset-minimal sets of SE-models are compared,\nthe motivation being that programs such as P = { p\u2190 q. } and Q = { p., p\u2190 q. }, when updated, should behave the same way since the extra rule inQ is just a weakened version of the rule in P. Though P andQ are not SR-equivalent, they are SMR-equivalent.\nTo formally capture the comparison of strength between these notions of program equivalence, we write \u2261X \u2261Y if P \u2261Y Q implies P \u2261X Q and \u2261X\u227a\u2261Y if \u2261X \u2261Y but not \u2261Y \u2261X. Then:\nProposition 5 ([65]). \u2261SM\u227a\u2261SE\u227a\u2261SMR\u227a\u2261SR\u227a\u2261SU."}, {"heading": "3. Robust Equivalence Models", "text": "In [65] we studied the expressivity of SE-models with respect to a single rule. On the one hand, SE-models turned out to be a useful means of stripping away irrelevant syntactic details. On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40]. For example, the rules\n\u2190 p, q. \u223c p\u2190 q. \u223c q \u2190 p. (3)\nhave the same set of SE-models. In a static setting, these rules indeed carry essentially the same meaning: \u201cit must not be the case that p and q are both true\u201d. But in a dynamic context, the latter two rules may, in addition, express that the truth of one atom gives a reason for the other atom to cease being true. For example, an update of the program { p., q. } by {\u223c p\u2190 q. } leads to the stable model { q } while an update by {\u223c q \u2190 p. } to the stable model { p }. This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.\nIn order to be able to semantically characterise causal rejection-based rule update semantics, we need to distinguish between constraints and rules with default literals in their heads. These classes can be formally captured as follows:\nDefinition 6 (Constraint and Abolishing Rule). A rule \u03c0 is a constraint if H\u03c0 = \u2205 and B+\u03c0 is disjoint with B\u2212\u03c0 . 7 A rule \u03c0 is abolishing if H+\u03c0 = \u2205, H\u2212\u03c0 6= \u2205 and the sets H\u2212\u03c0 , B+\u03c0 and B\u2212\u03c0 are pairwise disjoint.\nSo what we are looking for is a semantic characterisation of rules that\n1) can distinguish constraints from related abolishing rules;\n2) discards irrelevant syntactic details (akin to SE-models);\n3) has a clear link to stable models (akin to SE-models).\nIn the following we introduce a novel monotonic semantics that exactly meets these criteria. We show that it possesses the desired properties and use it to introduce a notion of program equivalence that is strong enough as a basis for syntax-independent rule update operators.\nWithout further ado, robust equivalence models, or RE-models for short, are defined as follows:\nDefinition 7 (RE-Model). Let \u03c0 be a rule. A three-valued interpretation (I, J) \u2208 X is an RE-model of \u03c0 if I |= \u03c0J . The set of all RE-models of a rule \u03c0 is denoted by [[\u03c0 ]]RE and for any program P, [[P ]]RE =\u22c2 \u03c0\u2208P[[\u03c0 ]]RE.\nWe say that a rule \u03c0 is RE-tautological if [[\u03c0 ]]RE = X. Rules \u03c0, \u03c3 are RE-equivalent if [[\u03c0 ]]RE = [[\u03c3 ]]RE.\n7The latter condition guarantees that a constraint is not tautological.\nThus, unlike with SE-models, it is not required that J |= \u03c0 in order for (I, J) to be an RE-model of \u03c0. As a consequence, RE-models can distinguish between rules in (3): while both ({ q } , { p, q }) and ({ p } , { p, q }) are RE-models of the constraint, the former is not an RE-model of the first abolishing rule and the latter is not an RE-model of the second abolishing rule. This property holds in general, establishing requirement 1):\nProposition 8. If \u03c0, \u03c3 are two different abolishing rules or an abolishing rule and a constraint, then \u03c0, \u03c3 are not RE-equivalent.\nProof. See Appendix A, page 34.\nAs for requirement 2), we first note that RE-equivalence is a refinement of SE-equivalence \u2013 there are no rules that are RE-equivalent but not SE-equivalent. The following result also shows that it is only the ability to distinguish between constraints and abolishing rules that is introduced by RE-models \u2013 rules that are not RE-equivalent to abolishing rules are distinguishable by RE-models if and only if they are distinguishable by SE-models. Furthermore, the classes of SE-tautological and RE-tautological rules coincide, so we can simply use the word tautological without ambiguity.\nProposition 9 (RE-Equivalence vs. SE-Equivalence). \u2022 If two rules are RE-equivalent, then they are SE-equivalent. \u2022 If two rules, neither of which is RE-equivalent to an abolishing rule, are SE-equivalent, then they are\nRE-equivalent.\n\u2022 A rule is RE-tautological if and only if it is SE-tautological.\nProof. See Appendix A, page 35.\nThe affinity between SE-models and stable models is fully retained by RE-models, which establishes requirement 3).\nProposition 10 (RE-Models vs. Stable Models). An interpretation J is a stable model of a program P if and only if (J, J) \u2208 [[P ]]RE and for all I ( J , (I, J) /\u2208 [[P ]]RE.\nProof. See Appendix A, page 35.\nAlso worth noting is that any set of three-valued interpretations can be expressed by a program using RE-models. This is not the case with SE-models since only well-defined sets of three-valued interpretations have corresponding programs.\nProposition 11. For anyM\u2286 X there exists a program P such that [[P ]]RE =M.\nProof. See Appendix A, page 35.\nFurther properties of RE-models, analogous to those established in [65] for SE-models, can be found in Appendix A starting on page 31.\nSince RE-models are able to distinguish constraints from abolishing rules while keeping the essential properties of SE-models, we henceforth adopt them as the basis for defining syntax-independent rule update operators. We denote the set of sets of RE-models of rules inside a program P by \u3008\u3008P\u3009\u3009RE = { [[\u03c0 ]]RE | \u03c0 \u2208 P }. We also introduce three additional notions of program equivalence: RE-, RR- and RMR-equivalence that are analogous to SE-, SR- and SMR-equivalence.\nDefinition 12 (Program Equivalence Using RE-Models). Let P,Q be programs, P\u03c4 = P \u222a { \u03c4 }, Q\u03c4 = Q\u222a { \u03c4 }. We write\nP \u2261RE Q whenever [[P ]]RE = [[Q ]]RE ; P \u2261RMR Q whenever min\u3008\u3008P\u03c4 \u3009\u3009RE = min\u3008\u3008Q\u03c4 \u3009\u3009RE ; P \u2261RR Q whenever \u3008\u3008P\u03c4 \u3009\u3009RE = \u3008\u3008Q\u03c4 \u3009\u3009RE .\nIn order to consider belief update principles in the context of rule updates, we also need to establish notions of program entailment which are in line with the above defined program equivalence relations. This task is troublesome in case of SM-equivalence because the usage of entailment in belief update postulates is clearly a monotonic one while stable models are non-monotonic. For instance, a reformulation of (B1) would require that P \u2295 U |= U , though there is no reason for P \u2295 U to have less stable models than (or the same as) U . Due to these issues, we refrain from defining SM-entailment. The remaining entailment relations are defined as follows:\nDefinition 13 (Program Entailment). Let P,Q be programs, P\u03c4 = P\u222a{ \u03c4 } andQ\u03c4 = Q\u222a{ \u03c4 }. We write\nP |=SE Q whenever [[P ]]SE \u2286 [[Q ]]SE ; P |=SMR Q whenever \u2200\u03c3 \u2208 Q\u03c4 \u2203\u03c0 \u2208 P\u03c4 : [[\u03c0 ]]SE \u2286 [[\u03c3 ]]SE ; P |=RE Q whenever [[P ]]RE \u2286 [[Q ]]RE ; P |=RMR Q whenever \u2200\u03c3 \u2208 Q\u03c4 \u2203\u03c0 \u2208 P\u03c4 : [[\u03c0 ]]RE \u2286 [[\u03c3 ]]RE ; P |=SU Q whenever [[Q \\ P ]]SE = X ; P |=SR Q whenever \u2200\u03c3 \u2208 Q\u03c4 \u2203\u03c0 \u2208 P\u03c4 : [[\u03c0 ]]SE = [[\u03c3 ]]SE ;\nP |=RR Q whenever \u2200\u03c3 \u2208 Q\u03c4 \u2203\u03c0 \u2208 P\u03c4 : [[\u03c0 ]]RE = [[\u03c3 ]]RE .\nWe say that P X-entails Q if P |=X Q.\nAs the following proposition shows, the defined entailment relations are fully in line with the corresponding equivalence relations.\nProposition 14. Let X be one of SE, RE, SMR, RMR, SR, RR, SU and P, Q be programs. Then, P \u2261X Q if and only if P |=X Q and Q |=X P.\nProof. See Appendix A, page 35.\nNote that it follows directly from the previous considerations that RR-equivalence is stronger than SR-equivalence, RMR-equivalence is stronger than SMR-equivalence and RE-equivalence is stronger than SE-equivalence. Figure 1 illustrates the strength comparison of all eight notions of program equivalence which are formally stated in Proposition 5 and in the following result:\nProposition 15. The following holds:\n(1) \u2261SM\u227a\u2261SE\u227a\u2261RE\u227a\u2261RMR\u227a\u2261RR\u227a\u2261SU and |=SE\u227a |=RE\u227a |=RMR\u227a |=RR\u227a |=SU ; (2) \u2261SE\u227a\u2261SMR\u227a\u2261SR\u227a\u2261RR and |=SE\u227a |=SMR\u227a |=SR\u227a |=RR ; (3) \u2261SMR\u227a\u2261RMR and |=SMR\u227a |=RMR ; (4) \u2261RE \u2261SMR and \u2261SMR \u2261RE and |=RE |=SMR and |=SMR |=RE ; (5) \u2261RE \u2261SR and \u2261SR \u2261RE and |=RE |=SR and |=SR |=RE ; (6) \u2261RMR \u2261SR and \u2261SR \u2261RMR and |=RMR |=SR and |=SR |=RMR .\nProof. See Appendix A, page 36."}, {"heading": "4. Exception-Based Rule Update Operators", "text": "In this section we propose a generic scheme for specifying semantic rule update operators. We define instances of the scheme and show that they enjoy a number of plausible properties, ranging from the respect for support and fact update to syntax-independence and other semantic properties.\nAs suggested already, a program is semantically characterised by the set of sets of RE-models of its rules. Our update framework is based on a simple yet novel idea of introducing additional interpretations \u2013 exceptions \u2013 to the sets of RE-models of rules in the original program. The formalisation of this idea is straightforward: an exception-based update operator is characterised by an exception function \u03b5 that takes three inputs: the set of RE-models [[\u03c0 ]]RE of a rule \u03c0 \u2208 P and the semantic characterisations \u3008\u3008P\u3009\u3009RE, \u3008\u3008U\u3009\u3009RE of the original and updating programs. Then it returns the interpretations that are to be introduced as exceptions to \u03c0, so the characterisation of the updated program contains the augmented set of RE-models\n[[\u03c0 ]]RE \u222a \u03b5 ([[\u03c0 ]]RE, \u3008\u3008P\u3009\u3009RE, \u3008\u3008U\u3009\u3009RE) . (4)\nHence, the semantic characterisation of P updated by U is\n{ [[\u03c0 ]]RE \u222a \u03b5 ([[\u03c0 ]]RE, \u3008\u3008P\u3009\u3009RE, \u3008\u3008U\u3009\u3009RE) | \u03c0 \u2208 P } \u222a \u3008\u3008U\u3009\u3009RE . (5)\nIn other words, rules from P are augmented with the respective exceptions and rules in U remain untouched. From the syntactic viewpoint, we want a rule update operator \u2295 to return a program P \u2295 U with the\nsemantic characterisation (5). This brings us to the following issue: What if no rule exists whose set of RE-models is equal to (4)? In that case, no rule corresponds to the augmented set of RE-models of a rule \u03c0 \u2208 P, so the program P \u2295 U cannot be constructed. Moreover, such situations may occur quite frequently since a single rule has very limited expressivity. For instance, updating the fact (p.) by the rule (\u223c p \u2190 q, r.) may easily result in a set of RE-models expressible by the program { p\u2190 \u223c q., p\u2190 \u223c r. } but not expressible by any single rule. To keep a firm link to operations on syntactic objects, we henceforth deal with this problem by allowing the inputs and output of rule update operators to be sets of rules and programs, which we dub rule bases.8 In other words, the result of updating a rule, i.e. introducing exceptions to it, may be a set of rules, so the result of updating a program may be a rule base. Technically, a rule base can capture any possible result of an exception-based update due to Proposition 11.\nFormally, a rule base is any set of rules and programs. Given a rule baseR, an interpretation J is a model of R, denoted by J |= R, if J |= \u03a0 for all \u03a0 \u2208 R; RJ = { \u03a0J \u2223\u2223 \u03a0 \u2208 R }; the set of stable models of R\n8We allow for individual rules in a rule base out of convenience only. A single rule \u03c0 in a rule base R is treated exactly the same way as ifR contained the singleton program {\u03c0 }.\nconsists of all interpretations J such that J is a subset-minimal model ofRJ ; \u3008\u3008R\u3009\u3009SE = { [[\u03a0]]SE | \u03a0 \u2208 R } and [[R ]]SE = \u22c2 \u3008\u3008R\u3009\u3009SE; \u3008\u3008R\u3009\u3009RE = { [[\u03a0]]RE | \u03a0 \u2208 R } and [[R ]]RE = \u22c2 \u3008\u3008R\u3009\u3009RE. All notions of program equivalence and entailment are naturally extended to rule bases and any rule update operator\u2295 is generalised to sequences of rule bases \u3008Ri\u3009i<n as follows: \u2295 \u3008\u3009 = \u2205 and \u2295 \u3008Ri\u3009i<n+1 = ( \u2295 \u3008Ri\u3009i<n)\u2295Rn.\nNote that a program is a special case of a rule base. Each element \u03a0 of a rule base, be it a rule or a program, represents an atomic piece of information and exception-based update operators view and manipulate \u03a0 only through its set of RE-models [[\u03a0]]RE. Due to this, we refer to all such elements \u03a0 as rules, even if formally they may actually be programs.\nHaving resolved this issue, we can proceed to the definition of an exception-based rule update operator.\nDefinition 16 (Exception-Based Rule Update Operator). Given an exception function \u03b5, a rule update operator \u2295 is \u03b5-based if for all rule basesR, U , \u3008\u3008R \u2295 U\u3009\u3009RE is equal to (5). Also, \u2295 is exception-based if it is \u03b5-based for some exception function \u03b5.\nNote that for each exception function \u03b5 there is a whole class of \u03b5-based rule update operators that differ in the syntactic representations of the sets of RE-models in (5). For instance, when working over the set of propositional symbols A = { p, q } and considering some exception-based operator \u2295, the exception function may specify that for some programs P, U , the program P \u2295 U contains a rule or program representing the set of RE-modelsM = { (\u2205, \u2205), (\u2205, p), (p, p), (\u2205, q), (\u2205, pq), (p, pq), (pq, pq) }.9 This set can be represented by the rule \u03c0 = (p \u2190 q.) or, alternatively, by the rule \u03c3 = (p;\u223c q \u2190 q.), or even by the program Q = { (p\u2190 q.), (p\u2190 p,\u223c q.) }, and the exception function does not specify which syntactic representation of the set should be used in P \u2295 U .\n4.1. Simple Exception Functions and Their Syntactic Properties\nGeneral exception functions, as introduced above, have as inputs the entire semantic characterisations of the original as well as updating programs (\u3008\u3008P\u3009\u3009RE and \u3008\u3008U\u3009\u3009RE, respectively) when determining exceptions to any single rule. As it turns out, all this information is not strictly necessary in order to capture rule update operators enjoying a range of plausible syntactic as well as semantic properties.\nThus, further study of general exception functions is left for future research and in this paper we concentrate on a simpler, constrained class of exception functions that is nevertheless powerful enough to serve as a basis for well-behaved semantic rule update operators. Not only does this lead to simpler definitions, but the study of restricted classes of exception functions is essential in order to understand their expressivity, i.e. the types of update operators they are able to capture.\nMore particularly, we study exception functions that produce exceptions based on conflicts between pairs of rules, one from the original and one from the updating program, while ignoring the context in which these rules are situated. Formally, an exception function \u03b5 is simple if for allM\u2286 X and S, T \u2286 2X,\n\u03b5(M,S, T ) = \u22c3 N\u2208T \u03b4(M,N )\nwhere \u03b4 : 2X \u00d7 2X \u2192 2X is a local exception function. If \u2295 is an \u03b5-based rule update operator, then we also say that \u2295 is \u03b4-based and that \u2295 is simple.\nAs we shall see, in spite of their local nature, particular simple exception functions generate rule update operators that satisfy the syntactic properties laid out in Section 2 and are closely related to the JU- and UA-semantics for DLPs.\n9Sometimes we omit the usual set notation when we write interpretations, e.g. instead of { p, q } we may simply write pq.\nThe inspiration for defining concrete local exception functions \u03b4 comes from rule update semantics based on causal rejection. But since the relevant concepts, such as that of a conflict or rule rejection, rely on rule syntax to which an exception function has no direct access, our first objective is to find similar concepts on the semantic level. In particular, we need to define conditions under which two sets of RE-models are in conflict. But first we introduce two preparatory concepts.\nWe define a truth value substitution as follows: Given an interpretation J , an atom p and a truth value V \u2208 {T,U,F }, by J [V/p] we denote the three-valued interpretation X such that X(p) = V and X(q) = J(q) for all atoms q 6= p.\nThis enables us to introduce the main concept needed for defining a conflict between two sets of threevalued interpretations. Given a set of three-valued interpretations M, an atom p, a truth value V0 and a two-valued interpretation J , we say that M forces p to have the truth value V0 w.r.t. J , denoted by MJ(p) = V0, if\nJ [V/p] \u2208M if and only if V = V0 .\nIn other words, the three-valued interpretation J [V0/p] must be the unique member ofM that either coincides with J or differs from it only in the truth value of p. Note thatMJ(p) stays undefined in case no V0 with the above property exists.\nTwo sets of three-valued interpretationsM, N are in conflict on atom p w.r.t. J , denoted byM 1Jp N , if bothMJ(p) and N J(p) are defined andMJ(p) 6= N J(p). The following example illustrates all these concepts.\nExample 17. Consider rules \u03c0 = (p.), \u03c3 = (\u223c p\u2190 \u223c q.) with the respective sets of RE-models\nM = { (p, p), (p, pq), (pq, pq) } and N = { (\u2205, \u2205), (\u2205, q), (q, q), (\u2205, pq), (p, pq), (q, pq), (pq, pq) } .\nIntuitively, M forces p to T w.r.t. all interpretations and N forces p to F w.r.t. interpretations in which q is false. Formally it follows that M\u2205(p) = T because (p, p) belongs to M and neither (\u2205, p) nor (\u2205, \u2205) belongs toM. Similarly, it follows that N \u2205(p) = F. HenceM 1\u2205p N . Using similar arguments we can conclude thatM 1pp N . However, it does not hold thatM 1pqp N because N pq(p) is undefined.\nIn order to define a particular local exception function based on causal rejection, it only remains to decide which three-valued interpretations become exceptions when a conflict w.r.t. an interpretation J occurs. One intuition we can draw on is the relationship between RE-models and stable models (c.f. Proposition 10): J is a stable model of a program if and only if (J, J) is the unique RE-model of the program whose second component is J . So given an original rule \u03c0 with M = [[\u03c0 ]]RE and an updating rule \u03c3 with N = [[\u03c3 ]]RE where a conflict occurs between M and N w.r.t. J , \u03c0 needs to be weakened so that it cannot influence whether J becomes a stable model of the updated program or not. In other words, we need to introduce all three-valued interpretations whose second component is J as exceptions to that rule. Formally:\nDefinition 18 (Exception Function \u03b4a). The local exception function \u03b4a is for allM,N \u2286 X defined by:\n\u03b4a(M,N ) = { (I, J) \u2208 X \u2223\u2223 \u2203p :M 1Jp N } .\nTheorem 19 (Syntactic Properties of \u03b4a). Every \u03b4a-based rule update operator respects support and fact update and it also respects causal rejection and acyclic justified update w.r.t. DLPs of length at most two.\nProof. See Appendix B, page 43.\nThis means that \u03b4a-based rule update operators enjoy a combination of desirable syntactic properties that operators based on SE-models cannot [69]. However, these operators diverge from causal rejection, even on acyclic DLPs, when more than one update is performed.\nExample 20. Consider again the rules \u03c0, \u03c3 and their sets of RE-modelsM,N from Example 17 and some \u03b4a-based rule update operator \u2295. Then \u3008\u3008{\u03c0 } \u2295 {\u03c3 }\u3009\u3009RE will contain two elements, M\u2032 and N , where M\u2032 =M\u222a \u03b4a(M,N ) =M\u222a{ (\u2205, \u2205), (\u2205, p), (p, p) }. An additional update by the fact { q. } then leads to the characterisation \u3008\u3008 \u2295 \u3008{\u03c0 } , {\u03c3 } , { q. }\u3009\u3009\u3009RE which contains three elements: M\u2032\u2032, N and [[q. ]]RE where M\u2032\u2032 = M\u2032 \u222a { (\u2205, q), (q, q) }. Furthermore, due to Proposition 10, J = { q } is a stable model of the program \u2295 \u3008{\u03c0 } , {\u03c3 } , { q. }\u3009 because (q, q) belongs to [[ \u2295 \u3008{\u03c0 } , {\u03c3 } , { q. }\u3009 ]]RE and (\u2205, q) does not. However, J does not respect causal rejection and it is neither a JU- nor a UA-model of \u3008{\u03c0 } , {\u03c3 } , { q. }\u3009.\nThis shortcoming of \u03b4a largely stems from the asymmetry of its definition \u2013 when a conflict occurs w.r.t. J , atoms that are true in J may become undefined in an exception (I, J) but atoms that are false must remain false. Eliminating this asymmetry, by allowing for exceptions (I,K) with I \u2286 J \u2286 K, and choosing the introduced exceptions more carefully, leads to more well-behaved exception functions, defined as follows:\nDefinition 21 (Exception Functions \u03b4b, \u03b4c, \u03b4d and \u03b4e). The local exception functions \u03b4b, \u03b4c, \u03b4d and \u03b4e are for allM,N \u2286 X defined by:\n\u03b4b(M,N ) = { (I,K) \u2208 X | \u2203J \u2203p :M 1Jp N \u2227 I \u2286 J \u2286 K \u2227 (p \u2208 K \\ I \u21d2 K = J) } ,\n\u03b4c(M,N ) = { (I,K) \u2208 X | \u2203J \u2203p :M 1Jp N \u2227 I \u2286 J \u2286 K \u2227 (p \u2208 K \\ I \u21d2 K = J \u2227 (J, J) /\u2208M) } ,\n\u03b4d(M,N ) = { X ifM = N ; \u03b4b(M,N ) otherwise ,\n\u03b4e(M,N ) = { X ifM = N ; \u03b4c(M,N ) otherwise .\nThe functions \u03b4b and \u03b4d introduce more exceptions than \u03b4a while \u03b4c and \u03b4e eliminate some of those returned by \u03b4a and add some additional ones. The difference between \u03b4b and \u03b4d, and similarly also between \u03b4c and \u03b4e, is in that \u03b4d additionally \u201cwipes out\u201d rules from the original program that are repeated in the update by introducing all interpretations as exceptions to them, rendering them tautological. This will turn out to be significant later when we examine semantic properties of simple exception-based rule update operators. In all four functions, a conflict on p w.r.t. J leads to the introduction of interpretations in which atoms either maintain the truth value they had in J , or they become undefined. Additionally, extra conditions are imposed on the case when p becomes undefined. Interestingly, this leads to operators that satisfy all syntactic properties.\nTheorem 22 (Syntactic Properties of \u03b4b, \u03b4c, \u03b4d and \u03b4e). Let \u2295 be a \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based rule update operator. Then \u2295 respects support, fact update, causal rejection and acyclic justified update.\nProof. See Appendix B, page 47.\nFurthermore, it is worth noting that even on programs with cycles, \u03b4b- and \u03b4d-based operators are very closely related to the JU-semantics and, similarly, \u03b4c- and \u03b4e-based operators to the UA-semantics. They diverge from the syntax-based semantics only on rules with an appearance of the same atom in both the head and body. Formally, we say that a rule is a local cycle if (H+\u03c0 \u222a H\u2212\u03c0 ) \u2229 (B+\u03c0 \u222a B\u2212\u03c0 ) 6= \u2205.\nTheorem 23 (Characterisation of JU- and UA-Semantics Using Exception Functions). Let P be a DLP, J an interpretation,\u22951 a \u03b4b- or \u03b4d-based rule update operator and\u22952 a \u03b4c- or \u03b4e-based rule update operator. Then,\n\u2022 [[ \u2295 1 P ]]SM \u2286 [[P ]]JU and [[ \u2295 2 P ]]SM \u2286 [[P ]]UA;\n\u2022 if all(P ) contains no local cycles, then [[P ]]JU \u2286 [[ \u2295 1 P ]]SM and [[P ]]UA \u2286 [[ \u2295 2 P ]]SM.\nProof. See Appendix B, page 47.\nThis means that up to the marginal case of local cycles, \u03b4b and \u03b4d can be seen as semantic characterisations of the JU-semantics and, similarly, \u03b4c and \u03b4e characterise the UA-semantics. The exceptional cases when less stable models are found than using the traditional semantics occur when the DLP contains tautological rules or rules with the negation of their head in the body. The former can be seen as a strict improvement as it introduces immunity to tautologies. The latter is an unavoidable consequence of the fact that exception-based operators only manipulate RE-models which are unable to distinguish between a constraint (\u2190 p.) and a rule (\u223c p\u2190 p.) The traditional approaches do distinguish between them in that the former rule can never be rejected while the latter can.\nThis tight relationship also sheds new light on the problem of state condensing, discussed in more detail in Section 5.\n4.2. Semantic Properties We proceed by examining further properties of rule update operators \u2013 of those based on simple excep-\ntion functions in general, and of the \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based ones in particular. The properties we consider in this section are semantic in that they put conditions on the models of a result of an update and do not need to refer to the syntax of the original and updating programs. Our results are summarised in Table 2 and in the following we explain and discuss them. The interested reader may find all the proofs in Appendix B.5 starting on page 48.\nTraditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24]. We formalise all of them for rule basesR, S, U , V and a rule update operator \u2295 and each can actually be seen as a meta-property that is instantiated once we adopt a particular notion of program equivalence. Therefore, each row of Table 2 has eight cells that stand for particular instantiations of the property. This provides a more complete picture of how simple rule update operators, properties and program equivalence are interrelated.\nUnless stated otherwise (in a footnote), each tick (3) signifies that the property in question holds for all simple rule update operators. A missing tick signifies that the property does not generally hold for simple rule update operators, and in particular there are \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based operators for which it is violated. A tick is smaller if it is a direct consequence of a preceding larger tick in the same row and of the interrelations between the program equivalence and entailment relations (c.f. Figure 1).\nAt a first glance, it is obvious that none of the semantic properties is satisfied under SU-equivalence. This is because the conditions placed on a rule update operator by an exception function are at the semantic level, while SU-equivalence effectively compares programs syntactically. For instance, an exception-based operator \u2295, for any exception function \u03b5, may behave as follows: \u2205 \u2295 {\u223c p\u2190 p. } = {\u2190 p. }. This is because the rules before and after update are RE-equivalent. However, due to the fact that the programs {\u223c p\u2190 p. } and {\u2190 p. } are considered different under SU-equivalence, \u2295 cannot satisfy (Initialisation) w.r.t. SU-equivalence. The situation with all other properties is analogous.\nAs for the other notions of equivalence, we separately discuss each group of related properties:\n(Initialisation) and (Disjointness): These properties are satisfied \u201cby construction\u201d, regardless of which simple rule update operator we consider and of which notion of equivalence we pick.\n18\n(Tautology) and (Immunity to Tautologies): These are naturally satisfied by all simple update operators that do not introduce exceptions merely due to the presence of a tautological rule in the updating program. In particular, both properties are satisfied by \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based operators. Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].\n(Non-interference): This property is satisfied by \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based rule update operators. However, this is only the case when non-disjunctive programs are considered, pointing towards one of the important open problems faced by state-of-the-art research on rule updates: examples, desirable properties and methods for updating disjunctive programs. Insights in this direction should shed light on whether (Non-interference) is desirable in the disjunctive case.\n(Idempotence), (Absorption) and (Augmentation): These are the only properties that reveal differences amongst the different exception functions. They are not satisfied by \u03b4a-, \u03b4b- and \u03b4c-based operators under SR- and RR-equivalence because a program updated by its subset may contain weakened versions of the original rules. Since such rules are not part of the original program, the programs before and after update are considered to be different under SR- and RR-equivalence. This problem is dodged in \u03b4d and \u03b4e by completely obliterating original rules that appear in the update.\nThis also indicates that SR- and RR-equivalence are slightly too strong for characterising updates because programs such as { p. } and { p., p\u2190 q. } are not considered equivalent even though we expect the same behaviour from them when they are updated. We speculated in Section 3 that it might be possible to address this issue by adopting the weaker SMR- or RMR-equivalence. However, it turns out that due to the monotonic nature of SE- and RE-models, these equivalence relations are too weak: programs such as { p. } and { p., q \u2190 \u223c p. } are SMR- and RMR-equivalent but, when updated by {\u223c p. }, any rule update operator respecting fact update and causal rejection must provide the stable model \u2205 in the former case, which violates causal rejection in the latter case. Moreover, \u03b4a-based operators fail to satisfy (Absorption) and (Augmentation). Along with Example 20, this indicates that \u03b4a does not correctly handle iterated updates.\n(Associativity): This is one of the few properties that is not satisfied by any of the defined classes of operators. It is closely related to the question of whether rejected rules are allowed to reject. (Associativity) can be seen as postulating that an update operator must behave the same way regardless of whether rejected rules are allowed to reject or not. As witnessed by the JU- and UA-semantics (c.f. equation 2), rule update semantics tend to generate unwanted models when rejected rules are not allowed to reject.\nBelief Update Postulates Reformulated The lower part of Table 2 contains a reformulation of the belief update postulates (B1) \u2013 (B6) for rule\nbases. We omit the last two postulates as they require program disjunction and it is not clear how to obtain it appropriately. Note also that (B7) has been heavily criticised in the literature as being mainly a means to achieve formal results instead of an intuitive principle [34] and though (B8) reflects the basic intuition behind belief update \u2013 that of updating each model independently of the others \u2013 such a point of view is hardly transferable to knowledge represented using rules because a single model, be it a classical, stable, SE- or RE-model, fails to encode the interdependencies between literals expressed in rules that are necessary for properties such as support.\nSince we did not define SM-entailment, postulates that refer to it have the SM column marked as \u201cn/a\u201d. Now we turn to the individual postulates.\n(P1) and (P2.>): Similarly as (Initialisation) and (Disjointness), these postulates are satisfied by any simple rule update operator and under all notions of equivalence.\n(P2.1) and (P5): Postulate (P2.1) is not satisfied under SR- and RR-equivalence for the same reasons, described above, that prevent \u03b4a- and \u03b4b-based operators from satisfying (Idempotence). The situation with (P5) is the same since it implies (P2.1) in the presence of (P2.>) [34].\n(P2.2) and (P6): Postulate (P2.2) requires that { p.,\u223c p. } \u2295 {\u223c p. } |= p which, in the presence of (P1), amounts to postulating that one can never recover from an inconsistent state, contrary to most existing rule update semantics which do allow for recovery from such states. The case of (P6) is the same since it implies (P2.2) in the presence of (P1) and (P2.>) [34].\n(P3): This postulate relies on a function that returns the set of models of a rule base. Thus, [[ \u00b7 ]]SM, [[ \u00b7 ]]SE and [[ \u00b7 ]]RE can be used for this purpose and the other columns in the corresponding row in Table 2 make little sense, so they are marked as \u201cn/a\u201d. Furthermore, this postulate is not satisfied by any of the defined classes of exception-based operators. It is also one of the principles that most existing approaches to rule update chronically fail to satisfy. In order to satisfy it, a context-aware exception function would have to be used because conflicts may arise in a set of more than two rules that are pairwise consistent. For instance, when updating { p. } by { q \u2190 p.,\u223c q \u2190 p. }, one would somehow need to detect and resolve the joint conflict between these three rules. This is however impossible with a simple exception function because it only considers conflicts between pairs of rules, one from the original program and one from the update.\n(P4): This postulate requires update operators to be syntax-independent. In this context it is useful to consider the following weaker principles:\n(P4.1) If P \u2261 Q, then P U \u2261 Q U . (P4.2) If U \u2261 V , then P U \u2261 P V .\nThe failure to satisfy (P4.1) under SM-, SE-, RE-, SMR- and RMR-equivalence is inevitable if properties such as support, fact update and causal rejection are to be respected (c.f. [69] and the above discussion of (Idempotence), (Absorption) and (Augmentation)). Furthermore, (P4.1) is also violated under SR-equivalence due to the fact that a constraint such as (\u2190 p.) cannot be weakened by the introduced exception functions while the fact (\u223c p.) can, although it is strongly equivalent to the constraint.\nSimilar arguments can be used to show that the principle (P4.2) is not satisfied under SM-, SE-, RE, SMR- and RMR-equivalence. We only need to observe that any \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based operator \u2295 satisfies \u2205 \u2295 P \u2261RR P, so each example used to show that (P4.1) is not desirable, involving two updates P1 \u2295 U and P2 \u2295 U , can be reused to show the same for (P4.2) by instead considering the updates \u2205\u2295P1\u2295U and \u2205\u2295P1\u2295U . Additionally, (P4.2) is not satisfied under SR-equivalence due to the fact that updates such as {\u223c p\u2190 q. }, {\u223c q \u2190 p. } and {\u2190 p, q. } have different effects on the program { p., q. }. These observations indicate that (P4.1) and (P4.2), and thus also (P4), are too strong under SM-, SE-, RE-, SMR- and RMR-equivalence. Under SR-equivalence, they are incompatible with operators that solve conflicts based on the heads of rules. On the other hand, due to the semantic underpinning of simple rule update operators, (P4) is satisfied by most of them, including all \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based ones, under RR-equivalence.\nSummary The results in Table 2 indicate that simple rule update operators satisfy a number of essential semantic\nproperties by design. This is especially important for properties such as (Tautology), (Immunity to Tautolo-\ngies) and (P2.>), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].\nSome of the semantic properties, namely (Idempotence), (Absorption) and (Augmentation), outline the main differences between the particular local exception functions that we have defined. Although \u03b4ais the function with the simplest definition, it does not satisfy any of these properties, indicating that it cannot deal well with iterated updates.\nOur results also show that a number of KM postulates are not satisfied by the defined rule update operators. Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].\nPerhaps most importantly, Table 2 introduces a novel way of viewing the various semantic properties, where each property is parametrised by a particular notion of program equivalence and/or entailment. This richer view should prove useful in further research on rule update operators and their semantic properties."}, {"heading": "5. State Condensing", "text": "Our results about semantic rule update operators bring along a new point of view on traditional approaches to rule updates. Particularly interesting is the fact that a semantic rule update operator, following the belief update tradition, is a binary function on the set of programs over the same alphabet. This guarantees that after an update, the original program is replaced by a new program which continues to be used in its place, and the process can be easily iterated if the need arises. Even though this perspective is very natural, even fundamental, it has been largely neglected in the ample body of work on rule updates. Existing semantics typically proceed by characterising the models of the update and, at most, either describe a set of answer-set programs that could represent the update, instead of only one, or produce an answer-set program written in a language extended with a considerable amount of new atoms, making it difficult to understand and to further update.\nFor instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture. Consequently, they must resort to the introduction of additional meta-level atoms in order to construct a single program whose stable models correspond to the models assigned to the sequence, leading to difficulties with iterating the update process. Producing a program from a more expressive class of logic programs would result in the inability to perform another update as well because the update semantics are not defined for such programs.\nA different approach in [60] deals with program updates by borrowing ideas from literature on belief revision and utilising an abductive framework to accomplish such updates. In this case, multiple alternative programs can be the result of an update and no mechanism is provided to choose among them.\nA somewhat similar situation occurs with the approach of [75] where intricate syntactic transformations are combined with a semantics for prioritised logic programs that ultimately leads to a set of logic programs. Since all of these programs together represent the result of the update, it is once again unclear how to construct a single program that combines all of them.\nThe rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof). Thus, although an actual syntactic object is constructed that represents the update, it needs to be interpreted in a richer formalism to take into account preferences among rules.\nFinally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and\nother theoretical properties of the stable models assigned to a pair or sequence of programs. They do not consider representing the result of an update by a single program.\nIn this section, we unravel the true potential of specifying updates as binary operators on some class of programs. Despite the fact that existing program update semantics do not seem compatible with this point of view, we show that at least the foundational JU- and UA-semantics can be viewed in this manner.\nTheorem 23 already provides part of the solution as it shows that any DLP can be condensed into a single rule base over the same alphabet that behaves just as the original DLP when further updates are performed on it. Formally, this can be stated as follows:\nCorollary 24 (State Condensing into a Rule Base). There exist rule update operators \u22951 and \u22952 such that for every DLP P = \u3008Pi\u3009i<n without local cycles and all j < n there exist rule basesR1 andR2 with\n[[P ]]JU = [[ \u2295 1\u3008R1,Pj+1, . . . ,Pn\u22121\u3009 ]]SM and [[P ]]UA = [[ \u2295 2\u3008R2,Pj+1, . . . ,Pn\u22121\u3009 ]]SM .\nProof. See Appendix B, page 47.\nHowever, this result is not completely satisfactory since it relies on rule bases instead of standard classes of logic programs, does not provide explicit definitions of operators\u22951 and\u22952, and does not apply to DLPs with local cycles.\nIn the following, we address all these issues by defining specific rule update operators that faithfully characterise the JU- and UA-semantics \u2013 when applied to an arbitrary DLP P , they produce a program whose stable models coincide with JU- and UA-models of P , respectively. In this way, the new operators provide a way to condense any DLP into a single program that includes all relevant information about the DLP, not only to identify its stable models, but also for the purpose of performing further updates. Thereby, we solve the long-standing problem known as state condensing from the literature on causal rejection semantics for rule updates.\nTo achieve this, our operators must deal with a more general class of programs than non-disjunctive ones. First we define simple and elegant operators on subclasses of nested logic programs [71] with the required property. Subsequently, we show that the full expressivity of nested programs is not necessary for this purpose by defining an additional pair of operators that produce disjunctive logic programs and still maintain the same properties w.r.t. JU- and UA-semantics.\nThroughout this section we assume that all programs are finite. We also assume that all non-disjunctive rules \u03c0, originating in some DLP, have exactly one literal L in their heads. This latter assumption does not remove any significant expressivity from DLPs under the JU- and UA-semantics since each constraint (\u2190 B\u03c0.) can be equivalently encoded as the rule (p\u22a5 \u2190 \u223c p\u22a5,B\u03c0.) where p\u22a5 is a fresh atom designated for this purpose.\n5.1. Programs with Nested Expressions\nWe adopt the syntax and stable model semantics of logic programs with nested expressions [71]. A nested rule is an expression \u03c0 of the form (H\u03c0 \u2190 B\u03c0.) where H\u03c0 and B\u03c0, called the head and body of \u03c0, are expressions built inductively from the propositional atoms in A and the 0-place connectives \u22a5 and > using the unary connective \u223c (default negation) and the binary connectives \u2227 and \u2228.10 A nested rule of the form (H\u03c0 \u2190 >.) is usually identified with the formula H\u03c0. A nested program is a finite set of nested rules.\n10Within this section, we refer to such expressions simply as formulas even though they are different from the propositional formulas introduced in Section 2.\nEach disjunctive program P and DLP P = \u3008Pi\u3009i<n, as defined in Section 2, is translated, respectively, to a nested program and a sequence thereof as follows:\nP} = {\u2228 H\u03c0 \u2190 \u2227 B\u03c0. \u2223\u2223\u2223 \u03c0 \u2208 P } and P} = \u3008P}i \u3009i<n .\nSatisfaction of a formula \u03c6 in an interpretation J , denoted by J |= \u03c6, is defined in the usual way. Furthermore, J satisfies a nested rule \u03c0, denoted by J |= \u03c0, if J |= B\u03c0 implies J |= H\u03c0, and J satisfies a nested program P, denoted by J |= P, if J |= \u03c0 for all \u03c0 \u2208 P. The reduct of a formula \u03c6 relative to J , denoted by \u03c6J , is obtained by replacing, in \u03c6, every maximal occurrence of a formula of the form \u223c\u03c8 with \u22a5 if J |= \u03c8 and with > otherwise. The reducts of a nested rule \u03c0 and of a nested program P are, respectively, \u03c0J = (HJ\u03c0 \u2190 BJ\u03c0 .) and PJ = {\u03c0J | \u03c0 \u2208 P }. Finally, an interpretation J is a stable model of a nested program P if it is subset-minimal among the interpretations that satisfy PJ .\n5.2. Condensing into a Nested Program\nNow we can proceed with the definition of condensing operators \u2295JU and \u2295UA for the JU- and UA-semantics. The property that these operators must fulfill is that for any DLP P , the stable models of the nested program resulting from applying the operators to P are exactly the JU- and UA-models of P , respectively.\nBoth \u2295JU and \u2295UA are defined by utilising the concept of an activation formula which captures the condition under which a literal L is derived by some rule in a nested program U . Formally, the activation formula for L in U is defined as follows:\n\u03b1U (L) = \u2228{\u2227 B\u03c0 \u2223\u2223\u2223 \u03c0 \u2208 U \u2227 H\u03c0 = L } .11\nThe operator \u2295JU is based on the following simple idea: When updating a program P by a program U , each rule \u03c0 from P with literal L in its head must be disabled when some rule from U for the literal complementary to L is activated. This can be achieved by augmenting the body of \u03c0 with the additional condition \u223c\u03b1U ( L ) . Formally:\nDefinition 25 (Condensing Operator \u2295JU). A JU-rule is a nested rule with a single literal in its head and a JU-program is a nested program that consists of JU-rules.\nThe binary operator \u2295JU on the set of all JU-programs is defined as follows: Given two JU-programs P and U , the JU-program P \u2295JU U consists of the following rules:\n1. for all \u03c0 \u2208 P, the nested rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u223c\u03b1U ( H\u03c0 ) . ) ;\n2. all nested rules from U .\nIn case of the UA-semantics, additional choice rules are needed. Particularly, for every nested rule \u03c0 \u2208 all(P )} whose head is an atom, the update operator needs to include the nested rule (H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0.) in the resulting program. Intuitively, these additional rules account for the differences in the definition of rejJU(P , J) and rejUA(P , J) by making sure that no rule is ever completely eliminated, but stays partially in effect by generating alternative worlds for the atom in its head: one where it is satisfied and one where it is not. Essentially, this means that whenever the original body of the rule is satisfied, its head atom cannot be assumed false by default and is interpreted \u201cclassically\u201d instead.\n11Note that \u2228 \u2205 is simply \u22a5.\nDefinition 26 (Condensing Operator \u2295UA). A UA-rule is a nested rule with either a single literal or a disjunction of two literals L and L in its head, and a UA-program is a nested program that consists of UA-rules.\nThe binary operator \u2295UA on the set of all UA-programs is defined as follows: Given two UA-programs P and U , the UA-program P \u2295UA U consists of the following rules:\n1. for all \u03c0 \u2208 P with H\u03c0 \u2208 L, the nested rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u223c\u03b1U ( H\u03c0 ) . ) ;\n2. all \u03c0 \u2208 P such that H\u03c0 is of the form L \u2228 L; 3. for all \u03c0 \u2208 U with H\u03c0 \u2208 A, the nested rule ( H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0. ) ;\n4. all nested rules from U .\nThe following example illustrates the relationship between the JU- and UA-semantics and the condensing operators \u2295JU and \u2295UA, while the subsequent theorem establishes it in general.\nExample 27. Suppose that programs P, U and V , written as nested programs, are as follows:\nP} : p\u2190 >. U} : \u223c p\u2190 \u223c q \u2227 \u223c r. V} : p\u2190 s. q \u2190 p. \u223c p\u2190 s. r \u2190 r. r \u2190 >. \u223c r \u2190 >. s\u2190 >.\nIn addition to the rules from U}, the program \u2295\nJU \u3008P},U}\u3009 contains the following three nested rules:\np\u2190 >\u2227\u223c((\u223c q \u2227 \u223c r) \u2228 s). q \u2190 p \u2227 \u223c\u22a5. r \u2190 >\u2227\u223c>. (6) Also, the program \u2295\nUA \u3008P},U}\u3009 consists of the rules in \u2295 JU \u3008P},U}\u3009 and of three additional choice rules.\nNote that these rules are not part of the program P} \u2295UA U}. They belong to the program \u2205 \u2295UA P}, and, consequently, also to (\u2205 \u2295UA P})\u2295UA U} = \u2295 UA \u3008P},U}\u3009. They are as follows:\np \u2228 \u223c p\u2190 >. q \u2228 \u223c q \u2190 p. r \u2228 \u223c r \u2190 >. (7) Furthermore, both \u2295\nJU \u3008P},U}\u3009 and \u2295 UA \u3008P},U}\u3009 have the stable models \u2205 and { p, q } which coincide\nwith the JU- and UA-models of the DLP \u3008P,U\u3009. The situation is more interesting after V} is added to the update sequence. In addition to the rules from\nV}, the program \u2295\nJU \u3008P},U},V}\u3009 contains the following rules:\np\u2190 >\u2227\u223c((\u223c q \u2227 \u223c r) \u2228 s) \u2227 \u223c\u22a5. q \u2190 p \u2227 \u223c\u22a5 \u2227 \u223c\u22a5. r \u2190 >\u2227\u223c> \u2227\u223c\u22a5. \u223c p\u2190 \u223c q \u2227 \u223c r \u2227 \u223c s. \u223c p\u2190 s \u2227 \u223c s. \u223c r \u2190 >\u2227\u223c r.\nAlso, the program \u2295\nUA \u3008P},U},V}\u3009 consists of the rules in \u2295 JU \u3008P},U},V}\u3009, the three choice rules\nlisted in (7) and, additionally, the following three choice rules rules originating in V}:\np \u2228 \u223c p\u2190 s. r \u2228 \u223c r \u2190 r. s \u2228 \u223c s\u2190 >.\nNote that some body conjuncts, such as \u223c\u22a5, and even whole rules, for instance (\u223c p \u2190 s \u2227 \u223c s.), can can be eliminated from the resulting programs without affecting their stable models or the stable models resulting from further updates. Slightly less elegant definitions of \u2295JU and \u2295UA could be used to perform such simplifications automatically. For illustration, Figure 2 lists the simplified versions of the nested programs \u2295 JU \u3008P},U},V}\u3009 and \u2295 UA \u3008P},U},V}\u3009. It is also not difficult to verify that the unique stable model of the former program is { p, q, s }, which coincides with the unique JU-model of \u3008P,U ,V\u3009. On the other hand, due to the rule (r \u2228 \u223c r \u2190 >.), the latter program has the additional stable model { p, q, r, s }, which coincides with the additional UA-model of the DLP \u3008P,U ,V\u3009.\np\u2190 \u223c((\u223c q \u2227 \u223c r) \u2228 s). q \u2190 p. \u223c p\u2190 \u223c q \u2227 \u223c r \u2227 \u223c s. p\u2190 s. s\u2190 >.\np\u2190 \u223c((\u223c q \u2227 \u223c r) \u2228 s). q \u2190 p. \u223c p\u2190 \u223c q \u2227 \u223c r \u2227 \u223c s. p\u2190 s. s\u2190 >.\np \u2228 \u223c p\u2190 >. q \u2228 \u223c q \u2190 p. r \u2228 \u223c r \u2190 >. s \u2228 \u223c s\u2190 >.\nFigure 2: Nested programs\n\u2295\nJU \u3008P},U},V}\u3009 (left) and \u2295 UA \u3008P},U},V}\u3009 (right) without irrelevant rules and body conjuncts.\nTheorem 28 (State Condensing Using \u2295JU and \u2295UA). Let P be a DLP. An interpretation J is a (i) JU-model of P if and only if it is a stable model of \u2295 JU P};\n(ii) UA-model of P if and only if it is a stable model of \u2295\nUA P}.\nProof. See Appendix C, page 55.\nThe significance of this theorem is in that it demonstrates that the operators \u2295JU and \u2295UA provide a full characterisation of the JU- and UA-semantics: They condense any DLP P into a single nested program P such that the stable models of P coincide with the JU- and UA-models of P , respectively, and any further updates of P can be equivalently performed directly on P using the operators.\nNote that since the operators manipulate rules on the syntactic level, they are completely faithful to JU- and UA-semantics, even when the DLP contains local cycles (see also Theorem 23 where local cycles form a special case due to the fact that exception functions manipulate rules on the semantic level).\nInterestingly, an operator very similar to \u2295JU has been studied by Osorio and Cuevas [55]. They have proven that it characterises the UA-semantics for the case of a single update but did not consider the possibility of performing iterated updates. Their result is also a consequence of Theorem 28 and of the fact that the JU- and UA-semantics provide the same result when only a single update is performed.\n5.3. Condensing into a Disjunctive Program The condensing operators defined in the previous section can be further refined in order to produce a\nprogram that meets additional requirements. In the present section we show that nested expressions can be completely eliminated from the resulting program while still preserving the same tight relationship with the original rule update semantics. Thus, we introduce an additional pair of operators, \u2295\u2228JU and \u2295\u2228UA, that operate on disjunctive programs with default negation in heads of rules. Note that due to the non-minimality of JU- and UA-models for certain DLPs, disjunctive programs without default negation in heads of rules would already be insufficient for this purpose.\nThe ideas underlying the new operators are fairly straightforward. Essentially, nested expressions are introduced into the resulting programs only by the negations of activation formulas in their bodies, so these are the parts of rules that need to be translated into conjunctions in bodies and disjunctions in heads of rules. In particular, by utilising De Morgan\u2019s law and distributivity of conjunction over disjunction, we can obtain a new formula, a disjunction of conjunctions of default literals and double-negated atoms, that is strongly equivalent to the original formula. For instance, in case of the first rule in (6), we can equivalently write the condition \u223c((\u223c q \u2227 \u223c r) \u2228 s) as (\u223c\u223c q \u2227 \u223c s) \u2228 (\u223c\u223c r \u2227 \u223c s). Then it suffices to break up the resulting rule into multiple rules, each with one of the disjuncts of this formula in the body, and remove one of the negations from each double-negated literals and \u201cmove\u201d it into the head of the newly constructed rule. In case of the first rule in (6), the result would be the disjunctive rules\np \u2228 \u223c q \u2190 \u223c s. and p \u2228 \u223c r \u2190 \u223c s. (8)\nWe call each set of literals, without double negation, within each of the disjuncts described above a blocking set. Formally, if the activation formula \u03b1U}(L) contains > as one of its disjuncts, then there is no blocking set for L in U . Otherwise, suppose that \u03b1U}(L) = (L11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 L1k1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (L n 1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Lnkn). A\nblocking set for L in U is any set of literals { L1i1 , . . . , L n in } where 1 \u2264 ij \u2264 kj for every j with 1 \u2264 j \u2264 n. We denote the set of all blocking sets for L in U by \u03b2U (L). Each nested rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u223c\u03b1U} ( H\u03c0 ) . )\ncan thus be replaced by the set of disjunctive rules{ H\u03c0;S+ \u2190 B\u03c0, S\u2212. \u2223\u2223\u2223 S \u2208 \u03b2U(H\u03c0) } . Furthermore, when H\u03c0 is a default literal, it is more convenient to move the new default literals from the head into the body since this operation preserves stable models [38] and makes it easier to pinpoint the original head literal in the rule. This leads us to the following definition of \u2295\u2228JU:\nDefinition 29 (Condensing Operator \u2295\u2228JU). Given a disjunctive rule \u03c0, a literal L is the original head of \u03c0 if either L \u2208 A and H\u03c0 \u2229A = {L }, or L /\u2208 A and H\u03c0 = {L }.\nThe binary operator \u2295\u2228JU on the set of all disjunctive programs is defined as follows: Given two disjunctive programs P and U , the disjunctive program P \u2295\u2228JU U consists of the following rules:\n1. for all \u03c0 \u2208 P with original head L \u2208 A and all S \u2208 \u03b2U (L), the rule ( H\u03c0;S+ \u2190 B\u03c0, S\u2212. ) ;\n2. for all \u03c0 \u2208 P with original head L /\u2208 A and all S \u2208 \u03b2U (L), the rule ( H\u03c0 \u2190 B\u03c0, S+, S\u2212. ) ;\n3. all rules from U .\nAs for the UA-semantics, similar modifications can be applied in the definition of \u2295UA to obtain an operator that produces a disjunctive program. Furthermore, due to the additional choice rules included in the result, the rules can be further simplified, when compared to the rules produced by \u2295\u2228JU. In particular, the first group of rules can be treated the same way as the second, leading to the following definition of\u2295\u2228UA:\nDefinition 30 (Condensing Operator \u2295\u2228UA). The binary operator \u2295\u2228UA on the set of all disjunctive programs is defined as follows: Given two disjunctive programs P and U , the disjunctive program P \u2295\u2228UA U consists of the following rules:\n1. for all \u03c0 \u2208 P with H\u03c0 = {L } and all S \u2208 \u03b2U ( L ) , the rule ( H\u03c0 \u2190 B\u03c0, S+, S\u2212. ) ;\n2. all \u03c0 \u2208 P such that H\u03c0 is of the form { p,\u223c p } for some p \u2208 A; 3. for all \u03c0 \u2208 U with H\u03c0 = { p } for some p \u2208 A, the rule (p;\u223c p\u2190 B\u03c0.); 4. all rules from U .\nIf we consider the programs P, U and V from Example 27, the two main differences between the disjunctive program \u2295\u2228 JU \u3008P,U ,V\u3009 and its nested counterpart \u2295 JU \u3008P,U ,V\u3009, besides their different syntax, are as follows: 1) the nested rule is turned into the two disjunctive rules listed in (8), and 2) the rule r \u2190 > \u2227 \u223c> \u2227 \u223c\u22a5 has no counterpart in the disjunctive program as there is no blocking set for \u223c r in U . The differences between \u2295\u2228 UA \u3008P,U ,V\u3009 and \u2295 UA \u3008P,U ,V\u3009 are analogical and in Figure 3 we list the disjunctive programs simplified in the same way as their nested counterparts in Figure 2. From a general perspective, the operators \u2295\u2228JU and \u2295\u2228UA preserve the main property of \u2295JU and \u2295UA.\nTheorem 31 (State Condensing Using \u2295\u2228JU and \u2295\u2228UA). Let P be a DLP. An interpretation J is a (i) JU-model of P if and only if it is a stable model of \u2295\u2228 JU P ;\np;\u223c q \u2190 \u223c s. q \u2190 p. p;\u223c r \u2190 \u223c s. \u223c p\u2190 \u223c q,\u223c r,\u223c s. p\u2190 s. s.\np\u2190 q,\u223c s. q \u2190 p. p\u2190 r,\u223c s. \u223c p\u2190 \u223c q,\u223c r,\u223c s. p\u2190 s. s.\np;\u223c p. q;\u223c q \u2190 p. r;\u223c r. s;\u223c s.\nFigure 3: Disjunctive programs\n\u2295\u2228\nJU \u3008P,U ,V\u3009 (left) and \u2295\u2228 UA \u3008P,U ,V\u3009 (right) without irrelevant rules.\n(ii) UA-model of P if and only if it is a stable model of \u2295\u2228\nUA P .\nProof. See Appendix C, page 58.\nAlthough operators \u2295\u2228JU and \u2295\u2228UA eliminate the necessity for using nested rules to condense a DLP into a single program, this comes at a cost. Namely, the size of the nested program resulting from applying operators \u2295JU and \u2295UA is always linear in size of the argument programs, while in case of \u2295\u2228JU and \u2295\u2228UA, the resulting program can be exponentially larger. Furthermore, Figures 2 and 3 suggest that the representations produced by\u2295\u2228JU and\u2295\u2228UA will be less faithful to the form of the rules in the original programs, and thus less readable. This indicates that the nested program is more suitable as a way to store the condensed program, both in terms of space and readability. Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details). However, such a translation will no longer be equivalent to the original program sequence w.r.t. performing further updates."}, {"heading": "6. Abstract Exception-Based Operators", "text": "In this section we generalise exception-based operators to arbitrary knowledge representation formalisms with monotonic model-theoretic semantics.\nThus, we assume to be using some knowledge representation formalism in which a knowledge base is a subset of the set of all knowledge atoms \u2126 and Z denotes the set of all semantic structures among which the models of knowledge atoms are chosen. The set of models of a knowledge atom \u03b1 is denoted by [[\u03b1 ]]. The semantic characterisation of a knowledge base K is the set of sets of models of its knowledge atoms: \u3008\u3008K\u3009\u3009 = { [[\u03b1 ]] | \u03b1 \u2208 K }. The models of K are the models of all its elements, i.e. [[K ]] = \u22c2 \u3008\u3008K\u3009\u3009.\nAn abstract exception-based update operator is characterised by an exception function that, given the set of models of a knowledge atom \u03b1 and the semantic characterisations of the original and updating knowledge base, returns the semantic structures that are to be introduced as exceptions to \u03b1.\nDefinition 32 (Exception Function). An exception function is any function \u03b5 : 2Z \u00d7 22Z \u00d7 22Z \u2192 2Z .\nGiven such an exception function and knowledge bases K and U , it naturally follows that the semantic characterisation resulting from updating K by U should consist of sets of models of each knowledge atom \u03b1 from K, each augmented with the respective exceptions, and also the unmodified sets of models of knowledge atoms from U . In other words, we obtain the set of sets of models\n{ [[\u03b1 ]] \u222a \u03b5([[\u03b1 ]], \u3008\u3008K\u3009\u3009, \u3008\u3008U\u3009\u3009) | \u03b1 \u2208 K } \u222a \u3008\u3008U\u3009\u3009 . (9)\nTurning to the syntactic side, an update operator is binary function over 2\u2126 that takes the original knowledge base and its update as inputs and returns the updated knowledge base. An exception-based update operator is then formalised as follows:\nDefinition 33 (Abstract Exception-Based Update Operator). Given an exception function \u03b5, an update operator \u2295 is \u03b5-based if for all K, U \u2286 \u2126, \u3008\u3008K \u2295 U\u3009\u3009RE is equal to (9). Also, \u2295 is exception-based if it is \u03b5-based for some exception function \u03b5."}, {"heading": "7. Belief Updates Using Exception-Based Operators", "text": "Concrete exception-based operators for propositional knowledge bases are obtained from the abstract framework presented in the previous section by identifying the set of knowledge atoms \u2126 with the set of all propositional formulas and the set of semantic structures Z with propositional interpretations.\nThis setup allows us to immediately prove that most conceivable model-based operators can be faithfully modelled as exception-based ones. Particularly, this is possible for any update operator satisfying the uncontroversial postulates (B1), (B2.1) and (B4) [34].\nTheorem 34 (Model-Based Updates Using Exception-Based Operators). If is a belief update operator that satisfies (B1), (B2.1) and (B4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator \u2295 and all finite sequences of knowledge bases D, [[3D ]] = [[ \u2295 D ]].\nProof. See Appendix E, page 59.\nAn interesting point regarding this result is that the principles (B1), (B2.1) and (B4) are not specific to update operators, they are also satisfied by AGM revision operators. These operators are developed for the case of revising a belief set which is a set of formulas closed w.r.t. a logical consequence operator Cn . A revision operator ? takes an original belief set T and a formula \u00b5 representing its revision and produces the revised belief set T ? \u00b5. The typical properties satisfied by AGM revision operators include success, inclusion and extensionality [33], formalised, respectively, as\n\u00b5 \u2208 T ? \u00b5 , T ? \u00b5 \u2286 Cn(T \u222a {\u00b5 }) , If \u00b5 \u2261 \u03bd, then T ? \u00b5 = T ? \u03bd.\nThese three properties directly imply that (B1), (B2.1) and (B4) are satisfied by AGM revision operators. Hence, Theorem 34 directly applies to AGM revision operators as well. Note also that the operator adopted for ABox updates in [49], inspired by WIDTIO, performs a deductive closure of the ABox before updating it, so it corresponds to the standard full meet AGM revision operator.\nTurning to formula-based belief update operators, we can achieve similar results by introducing the following principles satisfied by many formula-based operators. Here, for any knowledge base B, \u3008\u3008B\u3009\u3009I denotes the set \u3008\u3008B\u3009\u3009 \u222a { I }. The principles are as follows:\n(F1) \u3008\u3008B \u25e6 U\u3009\u3009 \u2287 \u3008\u3008U\u3009\u3009. (F2.1) \u3008\u3008B \u222a U\u3009\u3009 \u2287 \u3008\u3008B \u25e6 U\u3009\u3009. (F4) If \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I, then \u3008\u3008B \u25e6 U\u3009\u3009I = \u3008\u3008C \u25e6 V\u3009\u3009I.\nWe can see that (F1) and (F2.1) are stronger versions of (B1), and (B2.1), respectively. While (F1) requires that the sets of models of formulas in U be retained in the semantic characterisation of B \u25e6 U , (F2.1) states that every formula in B \u25e6 U be equivalent to some formula in B \u222a U . Intuitively, this means that B \u25e6 U is obtained from B \u222aU by deleting some of its elements, modulo equivalence. Finally, (F4) is a reformulation of (B4) that is satisfied by formula-based operators \u2013 it can be seen as syntax-independence w.r.t. the set of\nsets of models of a knowledge base, modulo the presence of tautologies, instead of the overall set of models as in (B4). In some ways it is weaker than (B4) as its antecedent is much stronger.\nThe WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations. More formally:\nDefinition 35 (Regular Bold Operator). For any set of remaindersR we define ((R))I = { \u3008\u3008B\u3009\u3009I | B \u2208 R}. We say that the Bold operator \u25e6sbold is regular if for all sets of remaindersR1,R2 such that ((R1))I = ((R2))I it holds that \u3008\u3008s(R1)\u3009\u3009I = \u3008\u3008s(R2)\u3009\u3009I.\nThe regularity condition guarantees a certain degree of independence of syntax, e.g. given the sets of remainders R1 = { { p } , { q } } and R2 = { { p \u2227 p } , { q \u2228 q } }, a regular Bold operator either selects { p } from R1 and { p \u2227 p } from R2, or it selects { q } from R1 and { q \u2228 q } from R2. A non-regular one might select, say, { p } from R1 and { q \u2228 q } from R2. Thus the regularity condition ensures that the operator is independent of the syntax of individual formulas in the knowledge base.\nThe Cross-Product operator [30] satisfies (F1) (thus also (B1)), (B2.1) and (F4), but not (F2.1).\nProposition 36 (Properties of Formula-Based Updates). The WIDTIO and regular Bold operators satisfy (F1), (F2.1) and (F4). The Cross-Product operator satisfies (F1), (B2.1) and (F4) but does not satisfy (F2.1).\nProof. See Appendix E, page 62.\nThe following result establishes that formula-based operators such as WIDTIO and regular Bold can be fully captured by exception-based operators. In addition, operators such as Cross-Product can be captured for the case of a single update.\nTheorem 37 (Formula-Based Updates Using Exception-Based Operators). If \u25e6 is an update operator that satisfies (F1), (F2.1) and (F4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator \u2295 and all finite sequences of knowledge bases D, [[\u00a9D ]] = [[ \u2295 D ]].\nIf \u25e6 is an update operator that satisfies (B1), (B2.1) and (F4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator \u2295 and all knowledge bases B, U , [[B \u25e6 U ]] = [[B \u2295 U ]].\nProof. See Appendix E, page 63.\nSimilarly as with principles of model-based update operators, principles (F1), (F2.1) and (F4) are closely related with the properties of base revision operators [27, 33]. In particular, two types of base revision are identified in [33], the internal and external base revision. Both of them satisfy base revision counterparts of success and inclusion and, in addition, internal revision operators satisfy a property called uniformity. These three principles together entail that internal revision operators satisfy (F1), (F2.1) and one half of (F4); the other half can be achieved by putting additional constraints on the two-place selection function that generates the revision operator, similar to the regularity condition we imposed on the Bold operator above. Such regular internal revision operators are thus directly subject to Theorem 37. The same however does not hold for regular external revision operators as they need not satisfy uniformity. Note also that the WIDTIO and Bold operators coincide with internal full meet base revision and internal maxichoice base revision operators, respectively."}, {"heading": "8. Conclusion", "text": "Throughout this paper we developed a novel perspective on knowledge updates and demonstrated that it offers the first unifying ground for characterising rule update semantics as well as both model- and formulabased classical update operators.\nMore particularly, we defined a new monotonic characterisation of rules, the RE-models, and introduced a generic method for specifying semantic rule update operators in which a logic program is viewed as the set of sets of RE-models of its rules and updates are performed by introducing additional interpretations to the sets of RE-models of rules in the original program. This framework allowed us to define concrete semantic rule update operators that enjoy an interesting combination of syntactic as well as semantic properties that had never been reconciled before. Furthermore, it turned out that these operators can faithfully characterise the foundational JU- and UA-semantics for rule updates.\nThese insights also allowed us to address the long enduring problem of state condensing, i.e. transforming a sequence of answer-set programs \u2013 interpreted as updates \u2013 into a single answer-set program written in the same alphabet. Partly, this problem emerges because some rule update semantics employ complex mechanisms such as preferences or other minimality criteria that make it impossible to encode the result in a single answer-set program. Others have model-theoretic characterisations that assign non-minimal models to certain update sequences, and it is well known that stable models of non-disjunctive answer-set programs are minimal. By resorting to more expressive classes of answer-set programs, namely nested and disjunctive, we solved this problem for both JU- and UA-semantics. In all four cases, two for each semantics using both classes of answer-set programs, the resulting program is written with the same alphabet and is ready to be further updated. We have illustrated with some examples that the resulting programs written using nested answer-set programming are perhaps more readable than those written using disjunctive answer-set programs, in the sense that they more closely match the intuitions underlying the semantics for updates that we consider.\nFurthermore, we defined abstract exception-based operators that can be used in any knowledge representation formalism with a monotonic model-theoretic semantics. Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett\u2019s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51]. The Cross-Product operator can be captured when a single update is performed and the same can be said about the Set-Of-Theories operator since for a single update it is equivalent to the Cross-Product operator [73]. Nevertheless, neither of these two operators offers a viable alternative for updating ontologies \u2013 Cross-Product requires that disjunctions of ontology axioms be performed, which is typically not supported in DLs, and Set-Of-Theories produces a disjunctive ontology which is impractical and deviates from mainstream DL research.\nOverall, exception functions and exception-based operators can capture both traditional syntax-based approaches to rule updates as well as a wide range of model- and formula-based belief update operators. Thus, they offer a uniform framework that bridges two very distinct approaches to updates, previously considered irreconcilable. These findings are essential to better understand their interrelations. In addition, they open up new possibilities for addressing updates of Hybrid Knowledge Bases consisting of both an ontology and a rule component since the different methods used for dealing with ABox, TBox and rule updates can be viewed uniformly by looking at their associated exception functions. When coupled with a counterpart of SE- or RE-models in the context of hybrid knowledge bases, this can lead to universal hybrid update semantics which, in turn, can further improve our understanding of the distinct update paradigms.\nOur investigation also directly points to challenges that need to be tackled next. First, semantic characterisations of additional rule update semantics need to be investigated. This poses a number of challenges\ndue to the need to detect non-tautological irrelevant updates [5, 61, 62]. For instance, the simple functions examined in this paper, as well as the original JU- and UA-semantics, cannot distinguish an update of { p. } by U = {\u223c p\u2190 \u223c q.,\u223c q \u2190 \u223c p. }, where it is plausible to introduce the exception (\u2205, \u2205) (and the stable model \u2205 along with it), from an update of { p., q. } by U , where such an exception should not be introduced due to the cyclic dependency of justifications to reject (p.) and (q.). In such situations, context-aware functions need to be used. Such functions have the potential of satisfying properties such as (P3) and (Associativity). They would facilitate the search for condensing operators for other rule update semantics and perhaps shed some light on the problem of updating disjunctive programs which has received very little attention up until now.\nAnother challenge is to find additional logical characterisations of rules, namely a notion of program equivalence that is weaker than RR-equivalence but stronger than RE-equivalence so that both (P4) and properties such as (P2.1) can be achieved under a single notion of program equivalence. In this context, the close relationship between RE-models and T-models [74], used in the context of forgetting in logic programs, asks for more attention as well.\nComputational properties of different classes of exception-based update operators should also be investigated and it might be interesting to look for constrained classes of exception functions that satisfy syntax-independence w.r.t. SR-equivalence. Such functions, however, will not be able to respect causal rejection because SE-models cannot distinguish abolishing rules.\nOur discussion of the expressivity of exception-based operators w.r.t. revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58]. This seems relevant even in the context of ontology updates since it has been argued in the literature that the strict distinction between revision and update is not suitable in the context of ontologies [13]."}, {"heading": "Acknowledgements", "text": "J. Leite was partially supported by Fundac\u0327a\u0303o para a Cie\u0302ncia e a Tecnologia (FCT) under project NOVA LINCS (UID/CEC/04516/2013)."}, {"heading": "Appendix A. Proofs: Robust Equivalence Models", "text": "In this section we prove formal properties of RE-models (c.f. Definition 7). We begin by defining a set of representatives of rule equivalence classes induced by SE-models, as it was introduced in [65] since it is needed in our proofs.\nDefinition 38 (Transformation into an SE-Canonical Rule [65]). Given a rule \u03c0, we define the SE-canonical rule canSE(\u03c0) as follows:\n(i) If any of the sets H+\u03c0 \u2229 B+\u03c0 , H\u2212\u03c0 \u2229 B\u2212\u03c0 and B+\u03c0 \u2229 B\u2212\u03c0 is non-empty, then canSE(\u03c0) = \u03c4 . (ii) If (i) does not apply and H+\u03c0 \\ B\u2212\u03c0 6= \u2205, then canSE(\u03c0) = ( (H+\u03c0 \\ B\u2212\u03c0 ); (H\u2212\u03c0 \\ B+\u03c0 )\u2190 B+\u03c0 ,B\u2212\u03c0 . ) .\n(iii) If (i) does not apply and H+\u03c0 \\ B\u2212\u03c0 = \u2205, then canSE(\u03c0) is the constraint ( \u2190 (B+\u03c0 \u222a H\u2212\u03c0 ),B\u2212\u03c0 . ) .\nProposition 39 ([65]). Every rule \u03c0 is SE-equivalent to the SE-canonical rule canSE(\u03c0).\nCorollary 40 ([65]). No two different SE-canonical rules are SE-equivalent.\nThe following presentation follows a similar pattern as the one used in [65] for SE-models. In particular, we introduce a set of representatives of rule equivalence classes induced by RE-models and show how to reconstruct a representative from the set of its RE-models. Then we prove the properties of RE-models that have been formulated in Section 3.\nRemark 41. We use the following additional notation: For any rule \u03c0, \u03c0+ denotes the rule (H+\u03c0 \u2190 B+\u03c0 .) and \u03c0\u2212 denotes the rule ( H\u2212\u03c0 \u2190 B\u2212\u03c0 . ) . Note that the definition of an RE-model (c.f. Definition 7) implies that (I, J) \u2208 [[\u03c0 ]]RE if and only if I |= \u03c0+ or J |= \u03c0\u2212. This fact is used implicitly in the following proofs.\nLemma 42. Rules of the following forms are RE-tautological:\np;H \u2190 p,B. H;\u223c p\u2190 B,\u223c p. H \u2190 B, p,\u223c p.\nProof. First assume that a rule \u03c0 is of the first form and take some (I, J) \u2208 X. We need to show that (I, J) is an RE-model of \u03c0, so it suffices to show that I |= \u03c0+. This follows from the fact that p belongs to both H+\u03c0 and B + \u03c0 .\nNow suppose that \u03c0 is of the second form. Given some (I, J) \u2208 X, we see that the atom p belongs to both H\u2212\u03c0 and B \u2212 \u03c0 , so J |= \u03c0\u2212. Hence, (I, J) is an RE-model of \u03c0.\nFinally, suppose that \u03c0 takes the third form and take some (I, J) \u2208 X. If J |= \u03c0\u2212, then (I, J) is an RE-model of \u03c0. On the other hand, if J 6|= \u03c0\u2212, then J |= \u223c p and, consequently, I 6|= p because I is a subset of J . This implies that I |= \u03c0+, so we can once again conclude that (I, J) is an RE-model of \u03c0.\nLemma 43. The following pairs of rules are RE-equivalent: (1) (p;H \u2190 B,\u223c p.) and (H \u2190 B,\u223c p.); (2) (H;\u223c p\u2190 p,B.) and (H \u2190 p,B.).\nProof.\n(1) Let the first rule be denoted by \u03c01, the second by \u03c02 and take some (I, J) \u2208 X. We need to show that (I, J) is an RE-model of \u03c01 if and only if it is an RE-model of \u03c02. Thus, it suffices to prove the following:\nI |= \u03c0+1 \u2228 J |= \u03c0 \u2212 1 if and only if I |= \u03c0 + 2 \u2228 J |= \u03c0 \u2212 2 . (A.1)\nFirst note that \u03c0\u22121 = \u03c0 \u2212 2 , so J |= \u03c0 \u2212 1 holds if and only if J |= \u03c0 \u2212 2 . So if J |= \u03c0 \u2212 1 , then J |= \u03c0 \u2212 2 and we can conclude that (A.1) holds. On the other hand, if J 6|= \u03c0\u22121 , then J 6|= \u03c0 \u2212 2 and (A.1) reduces to proving that I |= \u03c0+1 holds if and only if I |= \u03c0 + 2 . Now it suffices to observe that J 6|= \u03c0 \u2212 1 implies J |= \u223c p and since I is a subset of J , we can conclude that I 6|= p. Since \u03c0+1 differs from \u03c0 + 2 only in the head atom p, our claim follows.\n(2) Let the first rule be denoted by \u03c01, the second by \u03c02 and take some (I, J) \u2208 X. We need to show that (I, J) is an RE-model of \u03c01 if and only if it is an RE-model of \u03c02. Thus, it suffices to prove the following:\nI |= \u03c0+1 \u2228 J |= \u03c0 \u2212 1 if and only if I |= \u03c0 + 2 \u2228 J |= \u03c0 \u2212 2 . (A.2)\nFirst note that \u03c0+1 = \u03c0 + 2 , so I |= \u03c0 + 1 holds if and only if I |= \u03c0 + 2 . So if I |= \u03c0 + 1 , then I |= \u03c0 + 2 and we can conclude that (A.2) holds. On the other hand, if I 6|= \u03c0+1 , then I 6|= \u03c0 + 2 and (A.2) reduces to proving that J |= \u03c0\u22121 holds if and only if J |= \u03c0 \u2212 2 . Now it suffices to observe that I 6|= \u03c0 + 1 implies I |= p and since I is a subset of J , we can conclude that J 6|= \u223c p. Since \u03c0\u22121 differs from \u03c0 \u2212 2 only in the head literal \u223c p, our claim follows.\nDefinition 44 (RE-Canonical Rule). We say that a rule \u03c0 is RE-canonical if either it is \u03c4 , or the sets H+\u03c0 \u222aH\u2212\u03c0 , B+\u03c0 and B \u2212 \u03c0 are pairwise disjoint.\nDefinition 45 (Transformation into an RE-Canonical Rule). Given a rule \u03c0, we define the RE-canonical rule canRE(\u03c0) as follows:\n(i) If any of the sets H+\u03c0 \u2229 B+\u03c0 , H\u2212\u03c0 \u2229 B\u2212\u03c0 and B+\u03c0 \u2229 B\u2212\u03c0 is non-empty, then canRE(\u03c0) = \u03c4 . (ii) If (i) does not apply, then canRE(\u03c0) is the rule ( (H+\u03c0 \\ B\u2212\u03c0 ); (H\u2212\u03c0 \\ B+\u03c0 )\u2190 B+\u03c0 ,B\u2212\u03c0 . ) .\nProposition 46. For every rule \u03c0, [[\u03c0 ]]RE = [[canRE(\u03c0)]]RE.\nProof. This can be shown by a careful iterative application of Lemmas 42 and 43. First observe that if canRE(\u03c0) = \u03c4 , then Lemma 42 implies that \u03c0 is RE-tautological, thus indeed RE-equivalent to \u03c4 .\nIn the principal case we can use Lemma 43(1) on all atoms from H+\u03c0 \u2229 B\u2212\u03c0 and remove them one by one from H+\u03c0 while preserving RE-models. A similar situation occurs with atoms from H \u2212 \u03c0 \u2229 B+\u03c0 which can be, according to Lemma 43(2), removed from H\u2212\u03c0 without affecting RE-models. After these steps are performed, the resulting rule coincides with canRE(\u03c0).\nLemma 47. For any rule \u03c0 and (I, J) \u2208 X, (I, J) /\u2208 [[\u03c0 ]]RE if and only if B+\u03c0 \u2286 I \u2286 A \\ H+\u03c0 and H\u2212\u03c0 \u2286 J \u2286 A \\ B\u2212\u03c0 .\nProof. Note that (I, J) /\u2208 [[\u03c0 ]]RE if and only if both I 6|= \u03c0+ and J 6|= \u03c0\u2212. It can be easily verified that the former is equivalent to B+\u03c0 \u2286 I \u2286 A \\ H+\u03c0 and the latter to H\u2212\u03c0 \u2286 J \u2286 A \\ B\u2212\u03c0 .\nCorollary 48. Let \u03c0 be an RE-canonical rule different from \u03c4 , put I = B+\u03c0 , J = H\u2212\u03c0 \u222aB+\u03c0 and J \u2032 = A\\B\u2212\u03c0 , and let p be an atom. Then the following holds:\n(1) (I, J \u222a { p }) \u2208 [[\u03c0 ]]RE if and only if p \u2208 B\u2212\u03c0 . (2) (I \u222a { p } , J \u222a { p }) \u2208 [[\u03c0 ]]RE if and only if p \u2208 H+\u03c0 \u222a B\u2212\u03c0 . (3) (I \\ { p } , J \u2032) \u2208 [[\u03c0 ]]RE if and only if p \u2208 B+\u03c0 . (4) (I, J) /\u2208 [[\u03c0 ]]RE.\nProof. Follows from Lemma 47 and the disjointness properties satisfied by RE-canonical rules.\nLemma 49. Let \u03c0 be an RE-canonical rule different from \u03c4 and p an atom. Then the following holds: (1) p \u2208 B\u2212\u03c0 if and only if for all (I, J) \u2208 X, p \u2208 J implies (I, J) \u2208 [[\u03c0 ]]RE; (2) p \u2208 H+\u03c0 if and only if p /\u2208 B\u2212\u03c0 and for all (I, J) \u2208 X, p \u2208 I implies (I, J) \u2208 [[\u03c0 ]]RE; (3) p \u2208 B+\u03c0 if and only if for all (I, J) \u2208 X, p /\u2208 I implies (I, J) \u2208 [[\u03c0 ]]RE; (4) p \u2208 H\u2212\u03c0 if and only if p /\u2208 B+\u03c0 and for all (I, J) \u2208 X, p /\u2208 J implies (I, J) \u2208 [[\u03c0 ]]RE.\nProof.\n(1) Suppose that p \u2208 B\u2212\u03c0 and take some (I, J) \u2208 X with p \u2208 J . Then J 6|= \u223c p, so it follows that J |= \u03c0\u2212. Consequently (I, J) \u2208 [[\u03c0 ]]RE. To prove the converse implication, let I = B+\u03c0 and J = H \u2212 \u03c0 \u222aB+\u03c0 . It follows that (I, J\u222a{ p }) \u2208 [[\u03c0 ]]RE,\nso by Corollary 48(1) we conclude that p \u2208 B\u2212\u03c0 .\n(2) Suppose that p \u2208 H+\u03c0 and take some (I, J) \u2208 X with p \u2208 I . Then I |= p, so it follows that I |= \u03c0+. Consequently (I, J) \u2208 [[\u03c0 ]]RE. To prove the converse implication, let I = B+\u03c0 and J = H \u2212 \u03c0 \u222aB+\u03c0 . It follows that (I\u222a{ p } , J\u222a{ p }) \u2208\n[[\u03c0 ]]RE, so by Corollary 48(2) we conclude that p belongs to H+\u03c0 \u222a B\u2212\u03c0 . Moreover, by the assumption we know that p /\u2208 B\u2212\u03c0 , so p \u2208 H+\u03c0 . (3) Suppose that p \u2208 B+\u03c0 and take some (I, J) \u2208 X with p /\u2208 I . Then I 6|= p, so it follows that I |= \u03c0+. Consequently, (I, J) \u2208 [[\u03c0 ]]RE. To prove the converse implication, let I = B+\u03c0 and J\n\u2032 = A\\B\u2212\u03c0 . It follows that (I\\{ p } , J \u2032) \u2208 [[\u03c0 ]]RE, so by Corollary 48(3) we conclude that p \u2208 B+\u03c0 . (4) Suppose that p \u2208 H\u2212\u03c0 and take some (I, J) \u2208 X with p /\u2208 J . Then J |= \u223c p, so it follows that J |= \u03c0\u2212. Consequently, (I, J) \u2208 [[\u03c0 ]]RE. To prove the converse implication, let I = B+\u03c0 and J = H \u2212 \u03c0 \u222a B+\u03c0 . Corollary 48(4) guarantees\nthat (I, J) /\u2208 [[\u03c0 ]]RE. Furthermore, by the assumption it follows that (I \\ { p } , J \\ { p }) \u2208 [[\u03c0 ]]RE. Consequently, J must differ from J\\{ p }, which implies that p \u2208 J . Furthermore, since J = H\u2212\u03c0 \u222aB+\u03c0 and p /\u2208 B+\u03c0 by assumption, we conclude that p \u2208 H\u2212\u03c0 .\nDefinition 50 (Rule RE-Induced by a Set of Interpretations). Let M \u2286 X. The rule RE-induced by M, denoted by \u2016M\u2016RE, is defined as follows: IfM = X, then \u2016M\u2016RE = \u03c4 ; otherwise, \u2016M\u2016RE is of the form (HRE(M)+;HRE(M)\u2212 \u2190 BRE(M)+, BRE(M)\u2212.) where\nBRE(M)\u2212 = { p \u2208 A | \u2200(I, J) \u2208 X : p \u2208 J \u21d2 (I, J) \u2208M } , HRE(M)+ = { p \u2208 A | \u2200(I, J) \u2208 X : p \u2208 I \u21d2 (I, J) \u2208M } \\BRE(M)\u2212 , BRE(M)+ = { p \u2208 A | \u2200(I, J) \u2208 X : p /\u2208 I \u21d2 (I, J) \u2208M } , HRE(M)\u2212 = { p \u2208 A | \u2200(I, J) \u2208 X : p /\u2208 J \u21d2 (I, J) \u2208M } \\BRE(M)+ .\nProposition 51. For every RE-canonical rule \u03c0, \u2016[[\u03c0 ]]RE\u2016RE = \u03c0.\nProof. If \u03c0 = \u03c4 , then [[\u03c0 ]]RE = X and, by Definition 50, \u2016X\u2016RE = \u03c4 = \u03c0, so the identity is satisfied. In the principal case, \u03c0 is an RE-canonical rule different from \u03c4 . LetM = [[\u03c0 ]]RE. It follows from Definition 50 and Lemma 49 that \u03c0 = \u2016M\u2016RE.\nCorollary 52. No two different RE-canonical rules are RE-equivalent.\nProof. Follows directly from Proposition 51.\nProof of Proposition 8. Follows from Corollary 52 since every abolishing rule and every constraint is RE-canonical.\nLemma 53. For every rule \u03c0, canSE(\u03c0) = canSE(canRE(\u03c0)).\nProof. Follows directly from Definitions 38 and 45.\nLemma 54. If \u03c0 is not RE-equivalent to any abolishing rule, then canRE(\u03c0) = canSE(\u03c0).\nProof. Follows directly from Definitions 38 and 45.\nProof of Proposition 9. Suppose that \u03c0 and \u03c3 are RE-equivalent. Then canRE(\u03c0) = canRE(\u03c3) by Proposition 46 and Corollary 52. By Lemma 53 it follows that canSE(\u03c0) = canSE(canRE(\u03c0)) = canSE(canRE(\u03c3)) = canSE(\u03c3), so by Proposition 39 we can conclude that \u03c0, \u03c3 are SE-equivalent.\nNow suppose that neither \u03c0 nor \u03c3 is RE-equivalent to an abolishing rule and \u03c0 is RE-equivalent to \u03c3. Then, by Proposition 46, canRE(\u03c0) is RE-equivalent to canRE(\u03c3) and by Corollary 52, canRE(\u03c0) = canRE(\u03c3). It follows from Lemma 54 that canSE(\u03c0) = canSE(\u03c3) and by Proposition 39, \u03c0 is SE-equivalent to \u03c3.\nFinally, by Corollary 52, a rule \u03c0 is RE-tautological if and only if canRE(\u03c0) = \u03c4 which holds if and only if canSE(\u03c0) = \u03c4 which, by Corollary 40, holds if and only if \u03c0 is SE-tautological.\nProof of Proposition 10. Suppose that J is a stable model of P. Then J is a subset-minimal model of PJ . Thus, (J, J) is an RE-model of P. Now suppose that (I, J) is an RE-model of P for some I \u2286 J . Then I |= PJ and by the minimality of J we obtain I = J .\nSuppose that (J, J) is an RE-model of P and for all I ( J , (I, J) is not an RE-model of P. Then J |= PJ and J is also a subset-minimal model of PJ . Consequently, J is a stable model of P.\nProof of Proposition 11. Let P contain the rule \u03c0(I,J) = ( (A \\ I); J \u2190 I, (A \\ J). )\nfor each (I, J) \u2208 X \\M. It is an immediate consequence of Lemma 47 that [[\u03c0(I,J) ]]RE = X \\ { (I, J) }. Thus,\n[[P ]]RE = \u22c2\n(I,J)\u2208X\\M\nX \\ { (I, J) } = X \\ \u22c3\n(I,J)\u2208X\\M\n{ (I, J) } = X \\ (X \\M) =M .\nDefinition 55. A program entailment relation is a preorder on the set of all programs. A program equivalence relation is an equivalence relation on the set of all programs.\nGiven a program entailment relation |= and a program equivalence relation \u2261, we say that |= is associated with \u2261 if for all programs P, Q, P \u2261 Q holds if and only if P |= Q and Q |= P.\nProof of Proposition 14. If X is SE, RE or SU, then the property follows immediately from the definitions of |=X and \u2261X.\nIf X is either SR or RR, then it follows from the definition of |=X that P |=X Q is equivalent to \u3008\u3008P\u03c4 \u3009\u3009X \u2287 \u3008\u3008Q\u03c4 \u3009\u3009X. Thus, P |=X Q together with Q |=X P is equivalent to \u3008\u3008P\u03c4 \u3009\u3009X = \u3008\u3008Q\u03c4 \u3009\u3009X, which is the definition of P \u2261X Q.\nIt remains to consider the case when X is SMR or RMR. Let Y be SE or RE, respectively. First suppose that P \u2261X Q. By the definition of \u2261X we obtain that min\u3008\u3008P\u03c4 \u3009\u3009Y = min\u3008\u3008Q\u03c4 \u3009\u3009Y. Our goal is to prove that P |=X Q and Q |=X P. We only show the former; the proof of the latter is analogous. Take some \u03c3 \u2208 Q. Our goal is find some \u03c0 \u2208 P\u03c4 such that [[\u03c0 ]]Y \u2286 [[\u03c3 ]]Y. Take some subset-minimalM \u2208 \u3008\u3008Q\u03c4 \u3009\u3009Y such that M \u2286 [[\u03c3 ]]Y. It follows from our assumption thatM belongs to \u3008\u3008P\u03c4 \u3009\u3009Y. In other words, there exists some \u03c0 \u2208 P\u03c4 such that [[\u03c0 ]]Y =M\u2286 [[\u03c3 ]]Y.\nNow suppose that both P |=X Q and Q |=X P. We need to prove that P \u2261X Q, i.e. that min\u3008\u3008P\u03c4 \u3009\u3009Y = min\u3008\u3008Q\u03c4 \u3009\u3009Y. We only show that min\u3008\u3008P\u03c4 \u3009\u3009Y \u2286 min\u3008\u3008Q\u03c4 \u3009\u3009Y; the proof of the other inclusion is analogical. Take some \u03c0 \u2208 P\u03c4 such that\n[[\u03c0 ]]Y \u2208 min\u3008\u3008P\u03c4 \u3009\u3009Y . (A.3)\nSince Q |=X P, there exists some \u03c3 \u2208 Q\u03c4 such that [[\u03c3 ]]Y \u2286 [[\u03c0 ]]Y Let \u03c3\u2032 \u2208 Q\u03c4 be such that [[\u03c3\u2032 ]]Y \u2208 min\u3008\u3008Q\u03c4 \u3009\u3009Y and [[\u03c3\u2032 ]]Y \u2286 [[\u03c3 ]]Y. Since P |=X Q, there exists some \u03c0\u2032 \u2208 P\u03c4 such that [[\u03c0\u2032 ]]Y \u2286 [[\u03c3\u2032 ]]Y. In other words, we know that [[\u03c0\u2032 ]]Y \u2286 [[\u03c3\u2032 ]]Y \u2286 [[\u03c3 ]]Y \u2286 [[\u03c0 ]]Y. Thus, due to (A.3) we can conclude that [[\u03c0\u2032 ]]Y = [[\u03c3 \u2032 ]]Y = [[\u03c3 ]]Y = [[\u03c0 ]]Y, and it follows from the choice of \u03c3\u2032 that [[\u03c0 ]]Y \u2208 min\u3008\u3008Q\u03c4 \u3009\u3009Y.\nLemma 56. Let |=X, |=Y be program entailment relations and \u2261X, \u2261Y program equivalence relations such that |=X is associated with \u2261X and |=Y is associated with \u2261Y. Then |=X |=Y implies \u2261X \u2261Y.\nProof. Suppose that |=X |=Y and take some programs P, Q such that P \u2261Y Q. We need to show that P \u2261X Q. Since |=Y is associated with \u2261Y, we can conclude that P |=Y Q and Q |=Y P. Furthermore, from |=X |=Y it follows that P |=X Q and Q |=X P, and the assumption that |=X is associated with \u2261X implies P \u2261X Q.\nCorollary 57. Let |=X, |=Y be program entailment relations and \u2261X, \u2261Y program equivalence relations such that |=X is associated with \u2261X and |=Y is associated with \u2261Y. Then:\n\u2261X\u227a\u2261Y and |=X\u227a |=Y if and only if |=X |=Y and \u2261Y \u2261X .\nProof. By the definition, \u2261X\u227a\u2261Y and |=X\u227a |=Y hold if and only if \u2261X \u2261Y, \u2261Y \u2261X, |=X |=Y and |=Y |=X. By Lemma 56, |=X |=Y implies \u2261X \u2261Y and \u2261Y \u2261X implies |=Y \u2261X, so the condition can be simplified as desired.\nLemma 58. Let \u03c0 be a rule and J an interpretation. Then:\nJ |= \u03c0 if and only if J |= \u03c0J if and only if (J, J) \u2208 [[\u03c0 ]]RE .\nProof. Follows by the definition of \u03c0J and of RE-models.\nLemma 59. Let \u03a0, \u03a3 be rules or programs. Then [[\u03a0]]RE \u2286 [[\u03a3]]RE implies [[\u03a0]]SE \u2286 [[\u03a3]]SE.\nProof. Assume that [[\u03a0]]RE \u2286 [[\u03a3]]RE. Then for all (I, J) \u2208 X, I |= \u03a0J implies I |= \u03a3J and together with Lemma 58 this implies that for all interpretations J ,\nJ |= \u03a0 implies J |= \u03a0J implies J |= \u03a3J implies J |= \u03a3 . (A.4)\nIn order to show that [[\u03a0]]SE \u2286 [[\u03a3]]SE, take some (I, J) \u2208 [[\u03a0]]SE. By the definition of SE-models, J |= \u03a0 and I |= \u03a0J , so by (A.4) and our assumption we can conclude that J |= \u03a3 and I |= \u03a3J . Thus, by the definition of SE-models, (I, J) \u2208 [[\u03a3]]SE.\nProof of Proposition 15. (1) First we show that \u2261SM\u227a\u2261SE, i.e. that \u2261SM \u2261SE and \u2261SE \u2261SM. To verify the former, suppose\nthat P, Q are programs with P \u2261SE Q. Then P \u222a \u2205 has the same stable models as Q \u222a \u2205. Consequently, P \u2261SM Q. To see that \u2261SE \u2261SM, observe that the programs P = \u2205, Q = { p\u2190 q. } are SM-equivalent but not SE-equivalent. Turning to the remaining relationships, it follows from Corollary 57 that we can instead prove that\n|=SE |=RE |=RMR |=RR |=SU and \u2261SU \u2261RR \u2261RMR \u2261RE \u2261SE . (A.5)\nWe first concentrate on the left-hand side of (A.5). In order to show that |=SE |=RE, suppose that P, Q are programs such that P |=RE Q. Then [[P ]]RE \u2286 [[Q ]]RE and it follows from Lemma 59 that [[P ]]SE \u2286 [[Q ]]SE. Consequently, P |=SE Q. We also need to prove that |=RE |=RMR. Take some programs P, Q with P |=RMR Q and put P\u03c4 = P \u222a { \u03c4 }. It follows that\n\u2200\u03c3 \u2208 Q\u2203\u03c0\u03c3 \u2208 P\u03c4 : [[\u03c0\u03c3 ]]RE \u2286 [[\u03c3 ]]RE . (A.6)\nWe need to prove that [[P ]]RE \u2286 [[Q ]]RE. Suppose that X \u2208 [[P ]]RE and take some \u03c3 \u2208 Q, our goal is to show that X \u2208 [[\u03c3 ]]RE. By (A.6) there exists some \u03c0\u03c3 \u2208 P\u03c4 such that [[\u03c0\u03c3 ]]RE \u2286 [[\u03c3 ]]RE. If \u03c0\u03c3 = \u03c4 , then it immediately follows that X \u2208 X = [[\u03c4 ]]RE \u2286 [[\u03c3 ]]RE. If \u03c0\u03c3 \u2208 P, then X \u2208 [[\u03c0\u03c3 ]]RE by the choice of X , so X \u2208 [[\u03c3 ]]RE. Our next goal is to show that |=RMR |=RR. This follows directly by the definitions of |=RMR and |=RR. To prove the final part of the left-hand side of (A.5), suppose that P |=SU Q. Then [[Q\\P ]]SE = X. We need to prove that P |=RR Q, i.e. that for every \u03c3 \u2208 Q there is some \u03c0 \u2208 P\u03c4 such that [[\u03c0 ]]RE = [[\u03c3 ]]RE. Pick some \u03c3 \u2208 Q and note that Q = (Q \u2229 P) \u222a (Q \\ P). If \u03c3 \u2208 Q \u2229 P, then \u03c3 \u2208 P and we can put \u03c0 = \u03c3 to finish the proof. In the remaining case, \u03c3 \u2208 Q \\ P and it follows from our assumption that [[\u03c3 ]]SE = X. Thus, putting \u03c0 = \u03c4 finishes the proof. As for the right-hand side of (A.5), we can see that\u2261SU \u2261RR because the programsP = {\u223c p\u2190 p. } and Q = {\u2190 p. } are RR-equivalent but not SU-equivalent. Similarly, programs P = { p. } and Q = { p., p\u2190 q. } are RMR-equivalent but not RR-equivalent, so it follows that \u2261RR \u2261RMR. Next, to verify that \u2261RMR \u2261RE it suffices to observe that the programs P = { p., q. } and Q = { p., q \u2190 p. } are RE-equivalent but not RMR-equivalent. Finally, programs P = {\u223c p. } and Q = {\u2190 p. } are SE-equivalent but not RE-equivalent, proving that \u2261RE \u2261SE.\n(2) It follows from Corollary 57 that we can instead prove that\n|=SE |=SMR |=SR |=RR and \u2261RR \u2261SR \u2261SMR \u2261SE . (A.7)\nWe first concentrate on the left-hand side of (A.7). To prove that |=SE |=SMR, take some programs P, Q with P |=SMR Q and put P\u03c4 = P \u222a { \u03c4 }. It follows that\n\u2200\u03c3 \u2208 Q\u2203\u03c0\u03c3 \u2208 P\u03c4 : [[\u03c0\u03c3 ]]SE \u2286 [[\u03c3 ]]SE . (A.8)\nWe need to prove that [[P ]]SE \u2286 [[Q ]]SE. Suppose that X \u2208 [[P ]]SE and take some \u03c3 \u2208 Q, our goal is to show that X \u2208 [[\u03c3 ]]SE. By (A.8) there exists some \u03c0\u03c3 \u2208 P\u03c4 such that [[\u03c0\u03c3 ]]SE \u2286 [[\u03c3 ]]SE. If \u03c0\u03c3 = \u03c4 , then it immediately follows that X \u2208 X = [[\u03c4 ]]SE \u2286 [[\u03c3 ]]SE. If \u03c0\u03c3 \u2208 P, then X \u2208 [[\u03c0\u03c3 ]]SE by the choice of X , so X \u2208 [[\u03c3 ]]SE. Our next goal is to show that |=SMR |=SR. This follows directly by the definitions of |=SMR and |=SR. To finish the proof of the left-hand side of (A.5), suppose that P |=RR Q. Then \u2200\u03c3 \u2208 Q\u2203\u03c0 \u2208 P : [[\u03c0 ]]RE = [[\u03c3 ]]RE and, due to Lemma 59, \u2200\u03c3 \u2208 Q\u2203\u03c0 \u2208 P : [[\u03c0 ]]SE = [[\u03c3 ]]SE. Consequently, P |=SR Q. As for the right-hand side of (A.5), we can see that \u2261RR \u2261SR because the programs P = {\u223c p. } and Q = {\u2190 p. } are SR-equivalent but not RR-equivalent. Similarly, programs P = { p. } andQ = { p., p\u2190 q. } are SMR-equivalent but not SR-equivalent, so it follows that \u2261SR \u2261SMR. Finally, to verify that \u2261SMR \u2261SE it suffices to observe that the programs P = { p., q. } and Q = { p., q \u2190 p. } are SE-equivalent but not SMR-equivalent.\n(3) It follows from Corollary 57 that we can instead prove that |=SMR |=RMR and \u2261RMR \u2261SMR. To show the former, take some programs P,Q such that P |=RMR Q. It follows that \u2200\u03c3 \u2208 Q\u2203\u03c0 \u2208 P : [[\u03c0 ]]RE \u2286 [[\u03c3 ]]RE and, due to Lemma 59, \u2200\u03c3 \u2208 Q\u2203\u03c0 \u2208 P : [[\u03c0 ]]SE \u2286 [[\u03c3 ]]SE. Consequently, P |=SMR Q. As for the latter, it suffices to observe that the programs P = {\u223c p. } and Q = {\u2190 p. } are SMR-equivalent but not RMR-equivalent.\n(4) According to Lemma 56, it suffices to show that \u2261RE \u2261SMR and \u2261SMR \u2261RE. The former follows from the fact that the programs P = {\u223c p. } and Q = {\u2190 p. } are SMR-equivalent but not\nRE-equivalent. The latter can be verified by observing that though the programs P = { p., q. } and Q = { p., q \u2190 p. } are RE-equivalent, they are not SMR-equivalent.\n(5) According to Lemma 56, it suffices to show that \u2261RE \u2261SR and \u2261SR \u2261RE. The former follows from the fact that the programs P = {\u223c p. } and Q = {\u2190 p. } are SR-equivalent but not RE-equivalent. The latter can be verified by observing that though the programsP = { p., q. } andQ = { p., q \u2190 p. } are RE-equivalent, they are not SR-equivalent.\n(6) According to Lemma 56, it suffices to show that \u2261RMR \u2261SR and \u2261SR \u2261RMR. The former follows from the fact that the programs P = {\u223c p. } and Q = {\u2190 p. } are SR-equivalent but not RMR-equivalent. The latter can be verified by observing that though the programs P = { p. } and Q = { p., p\u2190 q. } are RMR-equivalent, they are not SR-equivalent."}, {"heading": "Appendix B. Proofs: Exception-Based Rule Update Operators", "text": "Appendix B.1. Conflicts Between Sets of RE-Models\nDefinition 60 (Additional Notation). Let X \u2208 X. Given an atom p, we say that X is an RE-model of p if X(p) = T. We say that X is an RE-model of \u223c p if X(p) = F. We denote the set of all RE-models of a literal L by [[L ]]RE. Given a set of literals S, we say that X is an RE-model of S if X is an RE-model of all literals in S. We denote the set of all RE-models of S by [[S ]]RE. Given a sequence of rule bases R = \u3008Ri\u3009i<n, we define \u3008\u3008R\u3009\u3009RE = \u3008\u3008\u3008Ri\u3009\u3009RE\u3009i<n.\nProposition 61. Let \u03c0 be a rule, p an atom and X = (I, J) \u2208 X. Then (I \\ { p } , J \u222a { p }) is not an RE-model of \u03c0 if and only if the following holds:\n1. Neither p nor \u223c p belongs to B\u03c0; 2. X is an RE-model of B\u03c0;\n3. X is not an RE-model of any literal from H\u03c0 \\ { p,\u223c p }.\nProof. We prove the direct implication first. From the assumption it follows that \u03c0J\u222a{ p } is different from \u03c4 . This has two consequences. First, H\u2212\u03c0 is included in J \u222a { p }, so all atoms from H\u2212\u03c0 , except possibly p, belong to J , and thusX is not an RE-model of any default literal from H\u03c0\\{\u223c p }. The second consequence is that B\u2212\u03c0 \u2229 (J \u222a { p }) is empty. Hence, \u223c p does not belong to B\u03c0. Furthermore, B\u2212\u03c0 \u2229 J must also be empty, so we can conclude that X is an RE-model of all default literals from B\u03c0. It also follows from the assumption that I \\ { p } contains B+\u03c0 but does not contain any atom from H+\u03c0 . As a consequence, p does not belong to B\u03c0 and we can also conclude that X is an RE-model of all atoms from B\u03c0 and X is not an RE-model of any atom from H\u03c0 \\ { p }. Thus, X is an RE-model of B\u03c0 and it is not an RE-model of any literal from H\u03c0 \\ { p,\u223c p }.\nAs for the converse implication, we need to prove that I \\ { p } is not a model of \u03c0J\u222a{ p }. We first need to show that \u03c0J\u222a{ p } is equal to the rule H+\u03c0 \u2190 B+\u03c0 . This holds if H\u2212\u03c0 is included in J \u222a { p } and B\u2212\u03c0 is disjoint with J \u222a { p }. Since X is an RE-model of B\u03c0, we can conclude that the set B\u2212\u03c0 is disjoint with J which, together with the assumption that \u223c p does not belong to B\u03c0, implies that B\u2212\u03c0 is disjoint with J \u222a { p }. We also know that X is not an RE-model of any literal from H\u03c0 \\ { p,\u223c p }, so we can conclude that H\u2212\u03c0 \\ { p } is included in J . Thus, H\u2212\u03c0 is included in J \u222a { p } and we proved that \u03c0J\u222a{ p } is equal to the rule H+\u03c0 \u2190 B+\u03c0 . It remains to show that I \\ { p } includes B+\u03c0 and that it does not contain any atom from H+\u03c0 . We know that X is an RE-model of B\u03c0, so I includes B + \u03c0 . Also, since p does not belong to B\u03c0, I \\ { p } also includes B+\u03c0 . Finally, we know that X is not an RE-model of any atom from H + \u03c0 \\ { p }, so I does not contain any atom from H+\u03c0 \\ { p }. This implies that I \\ { p } does not contain any atom from H+\u03c0 .\nCorollary 62. Let \u03c0 be a rule, p an atom and J an interpretation with p \u2208 J . If (J, J) is an RE-model of \u03c0 but (J \\ { p } , J) is not, then p \u2208 H\u03c0 and J |= B\u03c0.\nProof. It follows immediately from Proposition 61 that J |= B\u03c0. Furthermore, by the definition of RE-model, J is a model of \u03c0J while J \\ { p } is not. Hence, J contains some atom from H\u03c0 that is not contained in J \\ { p }. This atom can only be p.\nProposition 63. Let \u03c0 be a rule,M = [[\u03c0 ]]RE, p an atom, J an interpretation and V a truth value. Then MJ(p) = V if and only if the following holds:\n1. Neither p nor \u223c p belongs to B\u03c0; 2. J is a model of B\u03c0;\n3. J is not a model of any literal from H\u03c0 \\ { p,\u223c p }; 4. One of the following conditions holds:\n(a) V is T and H\u03c0 \u2229 { p,\u223c p } = { p }, or (b) V is F and H\u03c0 \u2229 { p,\u223c p } = {\u223c p }.\nProof. We focus on the direct implication first. Assume that V = T. Then (J \u222a { p } , J \u222a { p }) is an RE-model of \u03c0 although both (J \\ { p } , J \u222a { p }) and (J \\ { p } , J \\ { p }) are not. By Proposition 61 and Lemma 58 we can conclude that the first three of the properties that we need to prove are satisfied. It remains to show that H\u03c0 \u2229 { p,\u223c p } = { p }, i.e. that p belongs to H+\u03c0 but it does not belong to H\u2212\u03c0 . To see that the former holds, note that J \\ { p } is not a model of \u03c0J\u222a{ p }, so J \\ { p } includes B+\u03c0 and it does not contain any atom from H+\u03c0 . Since we know that J \u222a { p } is a model of \u03c0J\u222a{ p }, it must be the case that J \u222a { p } contains an atom from H+\u03c0 . This atom can only be p. Finally, if p were a member of H\u2212\u03c0 , then \u03c0J\\{ p } would coincide with \u03c4 , so (J \\ { p } , J \\ { p }) would be an RE-model of \u03c0, contrary to the assumption.\nNow assume that V = F. Then (J\\{ p } , J\\{ p }) is an RE-model of \u03c0 although both (J\\{ p } , J\u222a{ p }) and (J \u222a { p } , J \u222a { p }) are not. By Proposition 61 and Lemma 58 we can conclude that the first three of the properties that we need to prove are satisfied. It remains to show that H\u03c0 \u2229 { p,\u223c p } = {\u223c p }, i.e. that p belongs to H\u2212\u03c0 but it does not belong to H + \u03c0 . To see that the former holds, note that by the assumption J \\ { p } is a model of \u03c0J\\{ p } while it is not a model of \u03c0J\u222a{ p }. Hence, \u03c0J\\{ p } must be equal to \u03c4 . We know that B\u2212\u03c0 is disjoint with J \u222a{ p }, so it must also be disjoint with J \\{ p }. Thus, there must exist some atom from H\u2212\u03c0 that is not contained in J \\ { p } while it was contained in J \u222a{ p }. This atom can only be p. Finally, if p were a member of H+\u03c0 , then J \u222a { p } would contain an atom from H+\u03c0 , so (J \u222a { p } , J \u222a { p }) would be an RE-model of \u03c0, contrary to the assumption.\nFinally, we show by contradiction that V cannot be equal to U. Suppose that V = U. It follows that (J \u222a { p }) 6|= \u03c0J\u222a{ p }, (J \\ { p }) |= \u03c0J\u222a{ p } and (J \\ { p }) 6|= \u03c0J\\{ p }. Thus, since both \u03c0J\\{ p } and \u03c0J\u222a{ p } are different from \u03c4 , they must be identical and this is in conflict with our latter two conclusions.\nAs for the converse implication, let XT = (J \u222a { p } , J \u222a { p }), XU = (J \\ { p } , J \u222a { p }) and XF = (J \\ { p } , J \\ { p }) First suppose that V is T and H\u03c0 \u2229 { p,\u223c p } = { p }. We need to show that XT is an RE-model of \u03c0 while both XU and XF are not. The first property follows directly from the fact that p belongs to H+\u03c0 and X\nT is an RE-model of p. The second property follows from Proposition 61 and Lemma 58. To show that the third is also satisfied, note that since XU is not an RE-model of \u03c0, the rule \u03c0J\u222a{ p } coincides with the rule H+\u03c0 \u2190 B+\u03c0 . This implies that B\u2212\u03c0 is disjoint with J \u222a{ p } and H\u2212\u03c0 is included in J \u222a{ p }. As a consequence, B\u2212\u03c0 is also disjoint with J \\{ p }. Moreover, from our assumptions we know that H\u03c0 \u2229 { p,\u223c p } = { p }, which means that p does not belong to H\u2212\u03c0 . Thus, H\u2212\u03c0 is included in J \\ { p }.\nAs a consequence, the rule \u03c0J\\{ p } also coincides with the rule H+\u03c0 \u2190 B+\u03c0 . Furthermore, since XU is not an RE-model of \u03c0, J \\ { p } is not a model of \u03c0J\u222a{ p }. Since \u03c0J\u222a{ p } = \u03c0J\\{ p }, we obtain that J \\ { p } is not a model of \u03c0J\\{ p }. Hence XF is not an RE-model of \u03c0.\nNext, suppose that V is F and H\u03c0 \u2229 { p,\u223c p } = {\u223c p }. We need to show that XF is an RE-model of \u03c0 while both XU and XT are not. The first property follows directly from the fact that p belongs to H\u2212\u03c0 but does not belong to J \\ { p } because in this case \u03c0J\\{ p } coincides with \u03c4 . The second property follows from Proposition 61 and Lemma 58. To show that the third is also satisfied, note that since XU is not an RE-model of \u03c0, the rule \u03c0J\u222a{ p } coincides with the rule H+\u03c0 \u2190 B+\u03c0 and J \\ { p } is not a model of \u03c0J\u222a{ p }, i.e. J \\ { p } includes B+\u03c0 but does not contain any atom from H+\u03c0 . Thus, J \u222a { p } also includes B+\u03c0 and from our assumption that H\u03c0 \u2229 { p,\u223c p } = {\u223c p } we can conclude that p does not belong to H+\u03c0 . Thus, J \u222a { p } does not contain any atom from H+\u03c0 and, consequently, XT is not an RE-model of \u03c0.\nProposition 64. Let \u03c0 and \u03c3 be non-disjunctive rules,M = [[\u03c0 ]]RE, N = [[\u03c3 ]]RE, and J an interpretation. ThenM 1Jp N if and only if for some L \u2208 { p,\u223c p }, H\u03c0 = {L }, H\u03c3 = {L }, J is a model of both B\u03c0 and B\u03c3, and B\u03c0, B\u03c3 do not contain p nor \u223c p.\nProof. Follows directly from Proposition 63.\nAppendix B.2. Syntactic Properties of \u03b4a-Based Operators\nDefinition 65. Let \u03b4 be a local exception function, M \u2286 X and S \u2286 2X. We define aug\u03b4(M,S) = M\u222a \u22c3 N\u2208S \u03b4(M,N ) and extend this definition to sequences of sets of sets of three-valued interpretations inductively as follows: aug\u03b4(M, \u3008\u3009) =M and aug\u03b4(M, \u3008Si\u3009i<n+1) = aug\u03b4(aug\u03b4(M, \u3008Si\u3009i<n),Sn).\nProposition 66. Let R = \u3008Ri\u3009i<n be a sequence of rule bases, Si = \u3008\u3008Ri\u3009\u3009RE for all i < n, and\u2295 a \u03b4-based rule update operator. Then, \u3008\u3008 \u2295 R\u3009\u3009RE = { aug\u03b4(M, \u3008Sj\u3009i<j<n) | i < n \u2227M \u2208 Si }.\nProof. Follows by induction on n.\nLemma 67. LetM\u2286 X, S = \u3008Si\u3009i<n where Si \u2286 2X for all i < n, J an interpretation and p an atom. If (J, J) belongs to aug\u03b4a(M,S), but (J \\ { p } , J) does not, then (J, J) belongs toM.\nProof. Follows by induction on n.\nProposition 68. Every \u03b4a-based rule update operator respects support.\nProof. Let \u2295 be some \u03b4a-based rule update operator, pick some DLP P = \u3008Pi\u3009i<n, suppose that J is a stable model of \u2295 P and take some p \u2208 J . We need to show that for some rule \u03c0 \u2208 all(P ), p \u2208 H\u03c0 and\nJ |= B\u03c0. Since J is a stable model of \u2295 P , we know that (J, J) belongs to [[ \u2295\nP ]]RE and for all I ( J , (I, J) does not belong to [[ \u2295 P ]]RE. In particular, (J\\{ p } , J) does not belong to [[ \u2295 P ]]RE. Consequently,\nthere is someN \u2208 \u3008\u3008 \u2295\nP \u3009\u3009RE such that (J \\{ p } , J) does not belong toN although (J, J) does. According to Proposition 66, N = aug\u03b4 (M, \u3008\u3008\u3008Pj\u3009\u3009RE\u3009i<j<n) whereM \u2208 \u3008\u3008Pi\u3009\u3009RE for some i < n. Let \u03c0 be a rule from Pi such that [[\u03c0 ]]RE =M. Since (J \\ { p } , J) does not belong to N , it cannot belong toM sinceM is a subset ofN . Also, by Lemma 67, (J, J) belongs toM. Thus, it follows from Corollary 62 that p \u2208 H\u03c0 and J |= B\u03c0.\nLemma 69. Let P be a finite sequence of sets of facts and L a literal. Then,\naug\u03b4a([[L. ]]RE, \u3008\u3008P \u3009\u3009RE) = { X (L.) \u2208 all(P ) ; [[L. ]]RE otherwise .\nProof. Follows using Proposition 64 by induction on the length of P .\nCorollary 70. Let P = \u3008Pi\u3009i<n be a finite sequence of sets of facts and\u2295 a \u03b4a-based rule update operator. Then, \u3008\u3008 \u2295 P \u3009\u3009RE \u222a {X } = { [[L. ]]RE | \u2203i < n : (L.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (L.) /\u2208 Pj) } \u222a {X }.\nProof. By Proposition 66, \u3008\u3008P \u3009\u3009RE = { aug\u03b4([[\u03c0 ]]RE, \u3008\u3008\u3008Pj\u3009\u3009RE\u3009i<j<n) | i < n \u2227 \u03c0 \u2208 Pi }, which can also be written as { aug\u03b4([[L. ]]RE, \u3008\u3008\u3008Pj\u3009\u3009RE\u3009i<j<n) | i < n \u2227 (L.) \u2208 Pi }. Furthermore, due to Lemma 69, we can equivalently write this as{\nX \u2223\u2223 \u2203i, j, L : i < j < n \u2227 (L.) \u2208 Pi \u2227 (L.) \u2208 Pj }\n\u222a { [[L. ]]RE \u2223\u2223 \u2203i < n : (L.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (L.) /\u2208 Pj) } .\nThis directly implies the desired conclusion.\nProposition 71. Every \u03b4a-based rule update operator respects fact update.\nProof. Let P = \u3008Pi\u3009i<n be a finite sequence of consistent sets of facts, J the interpretation\n{ p | \u2203i < n : (p.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (\u223c p.) /\u2208 Pj) }\nand \u2295 a \u03b4a-based rule update operator. We need to show that J is the unique stable model of \u2295\nP . We start by proving that (J, J) belongs to [[ \u2295 P ]]RE. Pick someM \u2208 \u3008\u3008 \u2295 P \u3009\u3009RE. By Corollary 70 we\nknow thatM is either X, or it is equal to [[L. ]]RE where\n\u2203i < n : (L.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (L.) /\u2208 Pj) .\nIn the former case it trivially holds that (J, J) belongs toM = X. Now suppose that L is an atom p. Then, by its definition, J contains p, so (J, J) belongs to [[p. ]]RE =M. On the other hand, if L is a default literal \u223c p, then the fact (p.) does not belong to Pi because Pi is consistent, and it also does not belong to Pj for any j with i < j < n. So p does not belong to J and, hence, (J, J) belongs to [[\u223c p. ]]RE =M.\nNow suppose that (I, J) belongs to [[ \u2295 P ]]RE and take some p \u2208 J . Then,\n\u2203i < n : (p.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (\u223c p.) /\u2208 Pj) ,\nso, by Corollary 70, [[p. ]]RE belongs to \u3008\u3008 \u2295 P \u3009\u3009RE. Since (I, J) belongs to [[ \u2295\nP ]]RE, it must also belong to [[p. ]]RE. Thus, p belongs to I and as the choice of p \u2208 J was arbitrary, we can conclude that I = J . As a consequence, J is indeed a stable model of \u2295 P .\nIt remains to prove that J is the only stable model of \u2295 P . Suppose that J \u2032 is a stable model of \u2295\nP and take some p \u2208 J . We will show that p belongs to J \u2032. We know that\n\u2203i < n : (p.) \u2208 Pi \u2227 (\u2200j : i < j < n\u21d2 (\u223c p.) /\u2208 Pj) ,\nso, by Corollary 70, [[p. ]]RE belongs to \u3008\u3008 \u2295 P \u3009\u3009RE. Since J \u2032 is a stable model of \u2295\nP , (J \u2032, J \u2032) belongs to [[ \u2295\nP ]]RE and, consequently, also to [[p. ]]RE. Thus, p must belong to J \u2032. Now take some atom p that does not belong to J . We will show that p does not belong to J \u2032 either. There are two cases to consider:\na) If (p.) does not belong to Pi for all i < n, then it can be seen that (J \u2032 \\ { p } , J \u2032) belongs to all elements of \u3008\u3008 \u2295 P \u3009\u3009RE. Thus, since J \u2032 is a stable model of \u2295 P , J \u2032 \\ { p } = J \u2032 and, consequently,\np does not belong to J \u2032.\nb) If (p.) belongs to Pi0 for some i0 < n and whenever (p.) belongs to Pi for some i, there is some j with i < j < n such that (\u223c p.) belongs to Pj , then there must exist some i1 such that (\u223c p.) belongs to Pi1 and for all j with i1 < j < n, (p.) does not belong to Pj . Consequently, [[\u223c p. ]]RE belongs to \u3008\u3008 \u2295 P \u3009\u3009RE. Thus, since (J \u2032, J \u2032) belongs to [[ \u2295 P ]]RE, it follows that p cannot belong to J \u2032.\nProposition 72. Let P = \u3008P,U\u3009 be a dynamic logic program, \u2295 a \u03b4a-based rule update operator and J an interpretation. If J is a stable model of \u2295 P , then J is a JU-model of P .\nProof. From the assumption we can conclude that (J, J) is an RE-model of P \u2295 U and for every I ( J , (I, J) is not an RE-model of P \u2295 U .\nWe need to show that J is a minimal model of the program Q = [all(P ) \\ rej(P , J)]J . First we prove that J is a model of Q. Take some rule \u03c0\u2032 \u2208 Q and let \u03c0 be a rule from [all(P ) \\ rej(P , J)] such that \u03c0\u2032 = \u03c0J . We consider two cases:\na) If \u03c0 belongs to U , then since (J, J) belongs to [[P\u2295U ]]RE and \u3008\u3008P\u2295U\u3009\u3009RE contains [[\u03c0 ]]RE, (J, J) must also belong to [[\u03c0 ]]RE. Thus, J is a model of \u03c0 and consequently also a model of \u03c0\u2032 = \u03c0J .\nb) If \u03c0 belongs to P \\ rej(P , J), then since (J, J) belongs to [[P \u2295 U ]]RE and \u3008\u3008P \u2295 U\u3009\u3009RE contains [[\u03c0 ]]RE\u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE), (J, J) must also belong to [[\u03c0 ]]RE\u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). Suppose\nfirst that for some rule \u03c3 \u2208 U , (J, J) belongs to the set \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). This implies that [[\u03c0 ]]RE 1Jp [[\u03c3 ]]RE for some atom p and by Proposition 64 we can conclude that \u03c0 belongs to rej(P , J), contrary to the assumption. Thus, (J, J) does not belong to the set \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE) and, consequently, it belongs to [[\u03c0 ]]RE. Hence, J is a model of \u03c0 and, consequently, it is also a model of \u03c0\u2032 = \u03c0J .\nIt remains to prove that J is a minimal model of Q. Take some model I of Q such that I is a subset of J . We need to show that I = J . In the following we will show that (I, J) is a member of the set [[P\u2295U ]]RE which, together with the assumption that J is a stable model of P \u2295 U , implies that I = J .\nSo in order to finish the proof, take some setM from \u3008\u3008P \u2295 U\u3009\u3009RE. We need to show that (I, J) belongs toM. Recall that \u3008\u3008P \u2295 U\u3009\u3009RE = { [[\u03c0 ]]RE \u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE) | \u03c0 \u2208 P } \u222a \u3008\u3008U\u3009\u3009RE. IfM belongs to \u3008\u3008U\u3009\u3009RE, then there is some rule \u03c0 \u2208 U such thatM = [[\u03c0 ]]RE. Moreover, \u03c0J belongs to Q, so I is a model of \u03c0J . It then follows that (I, J) is an RE-model of \u03c0, i.e. that (I, J) belongs toM, as we wanted to show.\nThe remaining case is when for some \u03c0 \u2208 P, M = [[\u03c0 ]]RE \u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). Suppose that (I, J) does not belong to [[\u03c0 ]]RE. Then I is not a model of \u03c0J . Since I is a subset of J , we can conclude from this that\nJ |= B\u03c0 . (B.1)\nFurthermore, from our assumption that I is a model of Q it then follows that \u03c0J does not belong to Q and, consequently, \u03c0 belongs to rej(P , J). So there must be some rule \u03c3 \u2208 U such that H\u03c3 = H\u03c0 and J |= B\u03c3. Since we know from the previous part of the proof that J is a model of Q, we can conclude that J |= H\u03c3, so J 6|= H\u03c0.\nThus, it follows from (B.1) that J is not a model of \u03c0, so (J, J) is not an RE-model of \u03c0. But since J is a stable model of P\u2295U , (J, J) must belong to \u03b4a([[\u03c0 ]]RE, [[\u03c3\u2032 ]]RE) for some \u03c3\u2032 \u2208 U and from the definition of \u03b4a(\u00b7, \u00b7) we obtain that (I, J) also belongs to \u03b4a([[\u03c0 ]]RE, [[\u03c3\u2032 ]]RE). This implies that (I, J) belongs toM.\nProposition 73. Let P = \u3008P,U\u3009 be a DLP free of local cycles, \u2295 a \u03b4a-based rule update operator and J an interpretation. If J is a JU-model of P , then J is a stable model of \u2295 P.\nProof. Suppose that J is a justified update model of \u3008P,U\u3009. Then it is a minimal model of the program Q = [all(P ) \\ rej(P , J)]J . We need to prove that (J, J) is an RE-model of P \u2295 U and for every I ( J , (I, J) is not an RE-model of P \u2295 U . In order to show that (J, J) is an RE-model of P \u2295 U , recall that\n\u3008\u3008P\u2295U\u3009\u3009RE = { [[\u03c0 ]]RE \u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE) \u2223\u2223 \u03c0 \u2208 P }\u222a\u3008\u3008U\u3009\u3009RE and take some setM from \u3008\u3008P\u2295U\u3009\u3009RE. IfM belongs to \u3008\u3008U\u3009\u3009RE, then there is a rule \u03c0 \u2208 U such thatM = [[\u03c0 ]]RE. Also, \u03c0J belongs to Q, so J is a model of \u03c0J . Consequently, (J, J) belongs toM.\nNow suppose that for some \u03c0 from P,M = [[\u03c0 ]]RE \u222a \u22c3 \u03c3\u2208Q \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). If (J, J) does not belong to [[\u03c0 ]]RE, then J is not a model of \u03c0J , so \u03c0 belongs to rej(P , J). So there exists a rule \u03c3 from U such that H\u03c3 = H\u03c0 and J |= B\u03c3. The previous conclusions, together with the fact that \u03c0 and \u03c3 are not local cycles, allow us to use Proposition 64 and conclude that [[\u03c0 ]]RE 1Jp [[\u03c3 ]]RE holds for some atom p. Hence, (J, J) belongs to \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE), and consequently also toM.\nNow suppose that (I, J) belongs to [[\u03c0 ]]RE. We will show that I is a model of Q, which implies that I = J because J is by assumption a minimal model of Q. Take some rule \u03c0\u2032 from Q and suppose that \u03c0\u2032 = \u03c0J for some \u03c0 \u2208 [all(P ) \\ rej(P , J)]. If \u03c0 belongs to U , then [[\u03c0 ]]RE belongs to \u3008\u3008P \u2295 U\u3009\u3009RE. Consequently, (I, J) belongs to [[\u03c0 ]]RE, so I is a model of \u03c0\u2032.\nThe final case to consider is when \u03c0 belongs to P. We will prove by contradiction that I is a model of \u03c0\u2032. So suppose that I is not a model of \u03c0\u2032. Then (I, J) is not an RE-model of \u03c0. However, since by assumption (I, J) belongs to [[P \u2295 U ]]RE, it must also belong to the set [[\u03c0 ]]RE \u222a \u22c3 \u03c3\u2208U \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). We have already shown that it is not a member of [[\u03c0 ]]RE, so there must exist some \u03c3 \u2208 U such that (I, J) belongs to \u03b4a([[\u03c0 ]]RE, [[\u03c3 ]]RE). Thus, [[\u03c0 ]]RE 1Jp [[\u03c3 ]]RE holds for some atom p. We can use Proposition 64 to conclude that H\u03c3 = H\u03c0 and J |= B\u03c3. Hence, \u03c0 belongs to rej(P , J), contrary to our assumption.\nProof of Theorem 19. Follows from Propositions 68, 71, 72, 73 and the fact that the JU-semantics has these properties.\nAppendix B.3. Syntactic Properties of \u03b4b- and \u03b4c-Based Operators\nDefinition 74. We say thatM\u2286 X is RE-rule-expressible if there exists a rule \u03c0 such thatM = [[\u03c0 ]]RE.\nLemma 75. LetM \u2286 X be RE-rule-expressible, S a set of RE-rule-expressible sets of three-valued interpretations, J an interpretation, p an atom, V0 a truth value and \u03b4 \u2208 { \u03b4b, \u03b4c }. If aug\u03b4(M,S)J(p) = V0, thenMJ(p) = V0.\nProof. Suppose that aug\u03b4(M,S)J(p) = V0. By the definition we then obtain that for all truth values V,\nJ [V/p] \u2208 aug\u03b4(M,S) if and only if V = V0 . (B.2)\nIf the interpretation J [V0/p] belongs toM, then we can use (B.2) together with the fact thatM is a subset of aug\u03b4(M,S) to conclude thatMJ(p) = V0 and our proof ends.\nSo suppose that J [V0/p] does not belong toM. Then it follows from (B.2) and from the fact thatM is a subset of aug\u03b4(M,S) that the interpretations J [T/p], J [U/p] and J [F/p] do not belong toM. Thus, since J [V0/p] belongs to aug\u03b4(M,S), there must exist some N \u2208 S such that J [V0/p] = (I,K) belongs to \u03b4(M,N ). In other words, there exists an atom q and an interpretation J \u2032 such that I \u2286 J \u2032 \u2286 K and MJ \u2032(q) 6= N J \u2032(q). Note that J \\ { p } \u2286 I \u2286 J \u2032 \u2286 K \u2286 J \u222a { p }. Thus, (J \u2032, J \u2032) = J [V1/p] for some V1 \u2208 {T,F }. We distinguish two cases:\na) If p 6= q, then by the definition of \u03b4b and \u03b4c we obtain that J [V1/p], J [U/p] \u2208 \u03b4(M,N ). b) If p = q, let V2 = T is V1 = F and V2 = F if V1 = T. It follows thatMJ [V2/p](p) 6= N J [V2/p](p)\nand by the definition of \u03b4b and \u03b4c we obtain that J [V1/p], J [V2/p] \u2208 \u03b4(M,N ). In either case, it is not possible fo aug\u03b4(M,S)J(p) to be defined, a conflict with our assumption.\nProposition 76 (Exception Independence for Rules). LetM\u2286 X be RE-rule-expressible by a non-disjunctive rule, S , T be sets of RE-rule-expressible sets of three-valued interpretations and \u03b4 \u2208 { \u03b4b, \u03b4c }. Then, aug\u03b4(aug\u03b4(M,S), T ) = aug\u03b4(M,S \u222a T ).\nProof. By applying the definition of aug\u03b4(\u00b7, \u00b7) we can see that our goal is to show that the set aug\u03b4(M,S) \u222a \u22c3 N\u2208T \u03b4(aug\u03b4(M,S),N ) (B.3)\nis equal to the setM\u222a \u22c3 N\u2208S\u222aT \u03b4(M,N ) which can also be written as\naug\u03b4(M,S) \u222a \u22c3 N\u2208T \u03b4(M,N ) . (B.4)\nFirst suppose that some X \u2208 X belongs to (B.3). If X belongs to aug\u03b4(M,S), then it directly follows that X also belongs to (B.4). So suppose that X belongs to \u03b4(aug\u03b4(M,S),N ) for some N \u2208 T . By the definition of \u03b4b and \u03b4c we obtain that there exists some atom p and some interpretation J with certain properties relative to X such that aug\u03b4(M,S)J(p) 6= N J(p). By Lemma 75 we then conclude that aug\u03b4(M,S)J(p) =MJ(p). Thus, X also belongs to \u03b4(M,N ) and, consequently, also to the set (B.4).\nNow suppose that someX = (I,K) \u2208 X belongs to (B.4). The case whenX belongs to aug\u03b4(M,S) is trivial, so we assume that X belongs to \u03b4(M,N ) for some N \u2208 T . This implies that there exists an atom p and some interpretation J such that I \u2286 J \u2286 K andMJ(p) 6= N J(p). Suppose thatMJ(p) = V0. If it also holds that aug\u03b4(M,S)J(p) = V0, then it can be seen that X belongs to (B.3). Otherwise it follows from the fact that M is a subset of aug\u03b4(M,S) that aug\u03b4(M,S)J(p) is undefined and it contains both J [V0/p] and J [V1/p] = (I \u2032,K \u2032) for some V1 6= V0. Thus, for some N \u2032 \u2208 S it holds that (I \u2032,K \u2032) belongs to \u03b4(M,N \u2032). In other words, there exists an atom q and an interpretation J \u2032 such that I \u2032 \u2286 J \u2032 \u2286 K \u2032 andMJ \u2032(q) 6= N \u2032J \u2032(q). SinceM is expressible by a non-disjunctive rule, it follows from Proposition 63 that q = p. Also, J and J \u2032 may only differ in the valuation of p, so we obtain that MJ(p) 6= N \u2032J(p). Consequently, X belongs to \u03b4(M,N \u2032), so it also belongs to (B.3).\nDefinition 77. Let P = \u3008Pi\u3009i<n be a DLP. We define afteri(P ) = \u22c3 i<j<n Pj .\nProposition 78 (Exception Independence for Programs). Let P = \u3008Pi\u3009i<n be a DLP, \u03b4 \u2208 { \u03b4b, \u03b4c } and \u2295 a \u03b4-based rule update operator. Then, \u3008\u3008 \u2295 P \u3009\u3009RE = { aug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE) | i < n \u2227M \u2208 \u3008\u3008Pi\u3009\u3009RE }.\nProof. By Proposition 66, \u3008\u3008 \u2295\nP \u3009\u3009RE = { aug\u03b4(M, \u3008\u3008\u3008Pj\u3009\u3009RE\u3009i<j<n) | i < n \u2227M \u2208 \u3008\u3008Pi\u3009\u3009RE }. The claim follows by induction on n using Proposition 76.\nProposition 79. Let P be a DLP and J an interpretation. The following holds: (i) If \u2295 is a \u03b4b-based rule update operator and J is a stable model of \u2295 P , then J is a JU-model of P .\n(ii) If \u2295 is a \u03b4c-based rule update operator and J is a stable model of \u2295 P , then J is a UA-model of P .\nProof. Let P = \u3008Pi\u3009i<n. Also, put rej(\u00b7, \u00b7) = rejJU(\u00b7, \u00b7) if \u03b4 = \u03b4b and rej(\u00b7, \u00b7) = rejUA(\u00b7, \u00b7) if \u03b4 = \u03b4c. From the assumption we can conclude that (J, J) belongs to [[ \u2295 P ]]RE and for every I ( J , (I, J) does not\nbelong to [[ \u2295\nP ]]RE. We need to show that J is a minimal model of the program P\u2032 = [all(P )\\ rej(P , J)]J . First we prove that J is a model ofP\u2032. Take some rule \u03c0\u2032 \u2208 P\u2032 and let \u03c0 be a rule from all(P )\\rej(P , J) such that \u03c0\u2032 = \u03c0J . Then there is some i < n such that \u03c0 belongs to Pi. LetM = [[\u03c0 ]]RE. Since \u03c0 belongs to Pi, we can use Proposition 78 to conclude that \u3008\u3008 \u2295 P \u3009\u3009RE contains the set\naug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE) =M\u222a \u22c3\nN\u2208\u3008\u3008afteri(P )\u3009\u3009RE\n\u03b4(M,N ) . (B.5)\nFurthermore, since (J, J) belongs to [[ \u2295\nP ]]RE, it must also belong to (B.5). If (J, J) \u2208 M, then J |= \u03c0 and thus also J |= \u03c0\u2032 as desired. So suppose that (J, J) /\u2208M. Then for some j with i < j < n there exists some N \u2208 \u3008\u3008Pj\u3009\u3009RE such that (J, J) \u2208 \u03b4(M,N ). Thus, for some atom p,M 1Jp N , and by Proposition 64 we conclude that there is a rule \u03c3 \u2208 Pj with [[\u03c3 ]]RE = N , H\u03c3 = H\u03c0 and J |= B\u03c3. We consider two cases:\na) If \u03b4 = \u03b4b, then the assumption \u03c0 /\u2208 rejJU(P , J) is in direct conflict with the existence of \u03c3. b) If \u03b4 = \u03b4c, then it follows from \u03c0 /\u2208 rejUA(P , J) that \u03c3 \u2208 rejUA(P , J). Thus, there is some rule\n\u03c1 \u2208 (Pk \\ rejUA(P , J)) with j < k < n such that H\u03c1 = H\u03c3 = H\u03c0 and J |= B\u03c1. It follows from \u03c1 /\u2208 rejUA(P , J) that no rule from afterk(P ) has the head H\u03c1 and a body satisfied in J . Thus, the definition of \u03b4c and Proposition 64 imply that the set \u03b4c([[\u03c1 ]]RE,N ) is empty for all N \u2208 \u3008\u3008afterk(P )\u3009\u3009RE. But since (J, J) belongs to [[ \u2295 P ]]RE by assumption, it must also belong to\nthe set [[\u03c1 ]]RE \u222a \u22c3 N\u2208\u3008afterk(P )\u3009RE \u03b4c([[\u03c1 ]]RE,N ) and we conclude that (J, J) \u2208 [[\u03c1 ]]RE. Consequently, J |= \u03c1 and from J |= B\u03c1 we conclude J |= H\u03c1. Since H\u03c0 = H\u03c1, we have shown that J |= \u03c0 and thus also J |= \u03c0\u2032, as desired.\nIt remains to prove that J is a minimal model of P\u2032. Take some I \u2286 J such that I |= P\u2032, we need to show that I = J . In the following we will show that (I, J) \u2208 [[ \u2295 P ]]RE which, together with the\nassumption that J is a stable model of \u2295 P , implies that I = J . So take some set\naug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE) =M\u222a \u22c3\nN\u2208\u3008\u3008afteri(P )\u3009\u3009RE\n\u03b4(M,N ) . (B.6)\nfrom \u3008\u3008 \u2295\nP \u3009\u3009RE with M = [[\u03c0 ]]RE and \u03c0 \u2208 Pi. We need to show that (I, J) belongs to (B.6). This obviously holds if (I, J) \u2208 M, so suppose that (I, J) /\u2208 M. Then, I 6|= \u03c0J . Thus, \u03c0J is different from \u03c4 and, consequently, J |= B\u2212\u03c0 . Also, B+\u03c0 \u2286 I but H+\u03c0 \u2229 I = \u2205 and since I \u2286 J , this implies that\nJ |= B\u03c0 . (B.7)\nMoreover, since I |= P\u2032, it follows that \u03c0J /\u2208 P\u2032, so \u03c0 \u2208 rej(P , J). Thus, there exists a rule \u03c3 \u2208 Pj for some j with i < j < n such that for some atom p and literal L \u2208 { p,\u223c p },\nH\u03c0 = {L } and H\u03c3 = {L } and J |= B\u03c3 . (B.8)\nLet N = [[\u03c3 ]]RE. We consider the following five cases: a) If L \u2208 B\u03c0, then \u03c0 is tautological and we arrive at a conflict with the assumption (I, J) /\u2208 [[\u03c0 ]]RE. b) If L \u2208 B\u03c0, then it follows from (B.7) and (B.8) that (J, J) /\u2208 [[\u03c0 ]]RE. At the same time, \u03b4(M,N )\nis empty for all N because for all interpretations J \u2032 and atoms q, it is impossible forMJ \u2032(q) to be defined. Thus, we obtain a conflict with the assumption that (J, J) \u2208 [[ \u2295 P ]]RE. c) If L \u2208 B\u03c3, then it follows from (B.8) that (J, J) /\u2208 [[\u03c3 ]]RE. At the same time, \u03b4(N ,N \u2032) is empty for all N \u2032 because for all interpretations J \u2032 and atoms q, it is impossible for N J \u2032(q) to be defined. Thus, we obtain a conflict with the assumption that (J, J) \u2208 [[ \u2295 P ]]RE.\nd) If L \u2208 B\u03c3, then it follows from (B.8) that J |= L and together with (B.7) we obtain that J 6|= \u03c0. Thus, (J, J) /\u2208 [[\u03c0 ]]RE and since (J, J) \u2208 [[ \u2295 P ]]RE, there must exist some N \u2032 \u2208 \u3008\u3008afteri(P )\u3009\u3009RE such\nthat (J, J) \u2208 \u03b4(M,N \u2032). It follows from the definitions of \u03b4b and \u03b4c that (I, J) \u2208 \u03b4(M,N \u2032), and thus also (I, J) \u2208 aug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE).\ne) In the remaining case, B\u03c0 and B\u03c3 do not contain L nor L. Thus, we can use Proposition 64 to conclude that M 1Jp N . Note that if \u03b4 = \u03b4c, then the definition of rejUA(\u00b7, \u00b7) implies that \u03c3 /\u2208\nrejUA(P , J), so J |= \u03c3. Using (B.8) and (B.7) we can conclude that J 6|= \u03c0, so (J, J) /\u2208 M. Consequently, by the definitions of \u03b4b and \u03b4c it follows that (I, J) \u2208 \u03b4(M,N ), and thus also (I, J) \u2208 aug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE).\nProposition 80. Let P be a DLP free of local cycles and J an interpretation. The following holds: (i) If \u2295 is a \u03b4b-based rule update operator and J is a JU-model of P , then J is a stable model of \u2295 P .\n(ii) If \u2295 is a \u03b4c-based rule update operator and J is a UA-model of P , then J is a stable model of \u2295 P .\nProof. Let P = \u3008Pi\u3009i<n. Also, put rej(\u00b7, \u00b7) = rejJU(\u00b7, \u00b7) if \u03b4 = \u03b4b and rej(\u00b7, \u00b7) = rejUA(\u00b7, \u00b7) if \u03b4 = \u03b4c. From the assumption we can conclude that J is a minimal model of the program P\u2032 = [all(P ) \\ rej(P , J)]J . We need to prove that (J, J) \u2208 [[ \u2295 P ]]RE and for every I ( J , (I, J) /\u2208 [[ \u2295 P ]]RE.\nIn order to show that (J, J) \u2208 [[ \u2295 P ]]RE, take some set\naug\u03b4(M, \u3008\u3008afteri(P )\u3009\u3009RE) =M\u222a \u22c3\nN\u2208\u3008\u3008afteri(P )\u3009\u3009RE\n\u03b4(M,N ) (B.9)\nfrom \u3008\u3008 \u2295\nP \u3009\u3009RE whereM = [[\u03c0 ]]RE for some \u03c0 \u2208 Pi. If (J, J) belongs toM, then it obviously belongs to (B.9). So assume that (J, J) /\u2208M. Then J 6|= \u03c0, so\nJ |= B\u03c0 , (B.10)\nand we can also conclude that \u03c0 belongs to rej(P , J). As a consequence, there exists a rule \u03c3 from Pj for some j with i < j < n such that for some atom p and literal L \u2208 { p,\u223c p },\nH\u03c0 = {L } and H\u03c3 = {L } and J |= B\u03c3 . (B.11)\nLet N = [[\u03c3 ]]RE. It can be verified that (B.10) and (B.11), together with the assumption that \u03c0 and \u03c3 are not local cycles, allow us to use Proposition 64 and conclude that for some atom p,M 1Jp N . Thus, (J, J) belongs to \u03b4(M,N ), and consequently also to (B.9).\nNow suppose that (I, J) \u2208 [[ \u2295\nP ]]RE. We will show that I |= P\u2032, which implies that I = J because J is by assumption a minimal model of P\u2032. Take some \u03c0\u2032 \u2208 P\u2032. Then there is a rule \u03c0 from all(P )\\ rej(P , J) such that \u03c0\u2032 = \u03c0J . Suppose that \u03c0 \u2208 Pi. We will prove by contradiction that I |= \u03c0\u2032. So suppose that I 6|= \u03c0\u2032. Then \u03c0J is different from \u03c4 and, consequently, J |= B\u2212\u03c0 . Also, B+\u03c0 is included in I , so since I is a subset of J , B+\u03c0 is included in J as well. Hence,\nJ |= B\u03c0 . (B.12) Also, (I, J) /\u2208 [[\u03c0 ]]RE. By our assumption, (I, J) \u2208 M \u222a \u22c3 N\u2208\u3008\u3008afteri(P )\u3009\u3009RE \u03b4(M,N ) whereM = [[\u03c0 ]]RE. We have already shown that (I, J) /\u2208 M, so there must be a rule \u03c3 \u2208 Pj for some j with i < j < n such that (I, J) \u2208 \u03b4(M,N ) where N = [[\u03c3 ]]RE. Thus, there exists some interpretation K and an atom p such that I \u2286 K \u2286 J , M 1Kp N and if p \u2208 J \\ I , then J = K. By Proposition 64, there is a literal L \u2208 { p,\u223c p } such that H\u03c0 = {L } and H\u03c3 = {L }. We consider three cases:\na) If p /\u2208 J \\ I , then I(p) = J(p). Furthermore, J |= \u03c0 because J |= P\u2032 and from (B.12) we obtain that J |= H\u03c0. Thus, I |= \u03c0J , a conflict with the assumption that I 6|= \u03c0\u2032.\nb) If p \u2208 J \\ I and \u03b4 = \u03b4b, then it follows from the definition of \u03b4b that J = K, soM 1Jp N . Thus, by Proposition 64 we conclude that \u03c0 \u2208 rej(P , J), contrary to the way \u03c0 was picked.\nc) If p \u2208 J \\ I and \u03b4 = \u03b4c, then the definition of \u03b4c implies that (J, J) /\u2208 [[\u03c0 ]]RE, contrary to the assumption that J |= P\u2032.\nAppendix B.4. Syntactic Properties of \u03b4d- and \u03b4e-Based Operators\nLemma 81. Let P be a DLP, \u2295b, \u2295c, \u2295d and \u2295e be \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based rule update operators, respectively. Then the following holds:\n(i) IfM\u2208 \u3008\u3008 \u2295 dP \u3009\u3009RE, then eitherM = X orM\u2208 \u3008\u3008 \u2295\nbP \u3009\u3009RE; (ii) IfM\u2208 \u3008\u3008 \u2295 eP \u3009\u3009RE, then eitherM = X orM\u2208 \u3008\u3008 \u2295 cP \u3009\u3009RE.\nProof. Follows by induction on the length of P .\nLemma 82. Let P be a DLP, \u2295b, \u2295c, \u2295d and \u2295e be \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based rule update operators, respectively. Then the following holds:\n(i) IfM\u2208 \u3008\u3008 \u2295 bP \u3009\u3009RE, then for some N \u2208 \u3008\u3008 \u2295\ndP \u3009\u3009RE, N \u2286M; (ii) IfM\u2208 \u3008\u3008 \u2295 cP \u3009\u3009RE, then for some N \u2208 \u3008\u3008 \u2295 eP \u3009\u3009RE, N \u2286M.\nProof. The following two stronger statements follow by induction on the length of P using Proposition 76: (i) IfM \u2208 \u3008\u3008 \u2295\nbP \u3009\u3009RE, then for some set of RE-rule-expressible sets of three-valued interpretations S and some N \u2208 \u3008\u3008 \u2295 dP \u3009\u3009RE,M = aug\u03b4b(N ,S).\n(ii) IfM \u2208 \u3008\u3008 \u2295\ncP \u3009\u3009RE, then for some set of RE-rule-expressible sets of three-valued interpretations S and some N \u2208 \u3008\u3008 \u2295 eP \u3009\u3009RE,M = aug\u03b4b(N ,S).\nProposition 83. Let P be a DLP, \u2295b, \u2295c, \u2295d and \u2295e be \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based rule update operators, respectively. Then [[ \u2295 bP ]]SM = [[ \u2295 dP ]]SM and [[ \u2295 cP ]]SM = [[ \u2295 eP ]]SM.\nProof. By Lemma 81, \u3008\u3008 \u2295 bP \u3009\u3009RE \u222a {X } \u2287 \u3008\u3008 \u2295 dP \u3009\u3009RE and \u3008\u3008 \u2295 cP \u3009\u3009RE \u222a {X } \u2287 \u3008\u3008 \u2295 eP \u3009\u3009RE, so\n[[ \u2295 bP ]]RE = \u22c2 \u3008\u3008 \u2295 bP \u3009\u3009RE = \u22c2 (\u3008\u3008 \u2295 bP \u3009\u3009RE \u222a {X }) \u2286 \u22c2 \u3008\u3008 \u2295 dP \u3009\u3009RE = [[ \u2295 dP ]]RE ,\n[[ \u2295 cP ]]RE = \u22c2 \u3008\u3008 \u2295 cP \u3009\u3009RE = \u22c2 (\u3008\u3008 \u2295 cP \u3009\u3009RE \u222a {X }) \u2286 \u22c2 \u3008\u3008 \u2295 eP \u3009\u3009RE = [[ \u2295 eP ]]RE .\nFurthermore, by Lemma 82,\n[[ \u2295 bP ]]RE = \u22c2 \u3008\u3008 \u2295 bP \u3009\u3009RE = \u22c2\nM\u2208\u3008\u2295bP \u3009RE\nM\u2287 \u22c2\nN\u2208\u3008\u2295dP \u3009RE\nN = \u22c2 \u3008\u3008 \u2295 dP \u3009\u3009RE = [[ \u2295 dP ]]RE ,\n[[ \u2295 cP ]]RE = \u22c2 \u3008\u3008 \u2295 cP \u3009\u3009RE = \u22c2\nM\u2208\u3008\u2295cP \u3009RE\nM\u2287 \u22c2\nN\u2208\u3008\u2295eP \u3009RE\nN = \u22c2 \u3008\u3008 \u2295 eP \u3009\u3009RE = [[ \u2295 eP ]]RE .\nThus, [[ \u2295 bP ]]RE = [[ \u2295 dP ]]RE and [[ \u2295 cP ]]RE = [[ \u2295 eP ]]RE, and the rest follows from Proposition 15.\nProof of Theorem 23. Follows from Propositions 79, 80 and 83.\nProof of Theorem 22. Follows from Theorem 23 and from the fact that the JU- and UA-models satisfy all of these properties.\nProof of Corollary 24. It suffices to putR = \u2295 \u3008Pi\u3009i\u2264j and apply Theorem 23.\nAppendix B.5. Semantic Properties\nProposition 84. Let \u2295 be a \u03b4-based rule update operator. Then \u2295 satisfies (Initialisation), (Disjointness), (P1) and (P2.>) with respect to RR, SR, RMR, SMR, RE, SE and SM (where applicable).\nProof. We prove these properties with respect to RR-equivalence; their satisfaction with respect to the other notions of program equivalence follows from Proposition 15. To verify that (Initialisation) holds, it suffices to observe that\n\u3008\u3008\u2205 \u2295 U\u3009\u3009RE = { aug\u03b4(M, \u3008\u3008U\u3009\u3009RE) | M \u2208 \u2205 } \u222a \u3008\u3008U\u3009\u3009RE = \u3008\u3008U\u3009\u3009RE .\nThus, \u2205 \u2295 U is RR-equivalent to U . As for (Disjointness), it suffices to observe that \u3008\u3008(R \u222a S) \u2295 U\u3009\u3009RE coincides with\n{ aug\u03b4 (M, \u3008\u3008U\u3009\u3009RE) | M \u2208 R \u222a S } \u222a \u3008\u3008U\u3009\u3009RE = ({ aug\u03b4 (M, \u3008\u3008U\u3009\u3009RE) | M \u2208 R } \u222a \u3008\u3008U\u3009\u3009RE) \u222a ({ aug\u03b4 (M, \u3008\u3008U\u3009\u3009RE) | M \u2208 S } \u222a \u3008\u3008U\u3009\u3009RE) = \u3008\u3008R \u2295 U\u3009\u3009RE \u222a \u3008\u3008S \u2295 U\u3009\u3009RE = \u3008\u3008(R\u2295 U) \u222a (S \u2295 U)\u3009\u3009RE .\nIn order to prove that (P1) holds, consider that \u3008\u3008U\u3009\u3009RE is a subset of \u3008\u3008R\u2295U\u3009\u3009RE. Consequently,R\u2295U |=RR U . Finally, (P2.>) follows from the fact that aug\u03b4(M, \u2205) =M for allM\u2286 X.\nLemma 85. Let P, Q be programs over disjoint alphabets and \u03b4 \u2208 { \u03b4a, \u03b4b, \u03b4c, \u03b4d, \u03b4e }. Then for all M\u2208 \u3008\u3008P\u3009\u3009RE, either aug\u03b4(M, \u3008\u3008Q\u3009\u3009RE) =M or aug\u03b4(M, \u3008\u3008Q\u3009\u3009RE) = X.\nProof. Follows from Proposition 63 and the definitions of \u03b4a, \u03b4b, \u03b4c, \u03b4d, and \u03b4e.\nLemma 86. Let M \u2286 X be RE-rule-expressible, U a program, p an atom and V0 a truth value. If aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) J(p) = V0, then eitherMJ(p) = V0, or p occurs in U .\nProof. Suppose that aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) J(p) = V0 and MJ(p) 6= V0. Thus, aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) contains J [V/p] if and only if V = V0. SinceM is a subset of aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE), it follows thatM does not contain J [T/p], J [U/p] nor J [F/p]. Let \u03c0 be some rule such that [[\u03c0 ]]RE = M. We can conclude that p does not occur in \u03c0. Furthermore, if V0 = T, then by the definition of \u03b4a we obtain a conflict with the fact that J [U/p] does not belong to aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE). Consequently, V0 = F. Furthermore, since J [T/p] does not belong to aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) but J [F/p] does, there exists some N \u2208 \u3008\u3008U\u3009\u3009RE and some atom q such that M 1J [F/p]q N but it is not the case thatM 1J [T/p]q N . Since p does not occur in \u03c0, this is only possible if p occurs in U .\nProposition 87. Let \u2295 be a \u03b4a-, \u03b4b-, \u03b4c, \u03b4dor \u03b4e-based rule update operator. Then \u2295 satisfies (Noninterference) for non-disjunctive programs with respect to RR, SR, RMR, SMR, RE, SE and SM.\nProof. We prove this property with respect to RR-equivalence; its satisfaction with respect to the other notions of program equivalence follows from Proposition 15. Suppose that P, U and V are non-disjunctive programs, \u03b4 \u2208 { \u03b4a, \u03b4b, \u03b4c, \u03b4d, \u03b4e } and \u2295 is a \u03b4-based rule update operator. Take someM0 \u2208 \u3008\u3008(P \u2295 U) \u2295 V\u3009\u3009RE. We will show thatM0 either belongs to \u3008\u3008(P \u2295 V)\u2295 U\u3009\u3009RE orM0 = X. Note that \u3008\u3008(P \u2295 U)\u2295 V\u3009\u3009RE coincides with { aug\u03b4 (M, \u3008\u3008V\u3009\u3009RE) | M \u2208 \u3008\u3008P \u2295 U\u3009\u3009RE } \u222a \u3008\u3008V\u3009\u3009RE. We consider three cases:\na) Suppose that M0 \u2208 \u3008\u3008V\u3009\u3009RE. Then M0 \u2208 \u3008\u3008P \u2295 V\u3009\u3009RE and since \u3008\u3008(P \u2295 V) \u2295 U\u3009\u3009RE coincides with { aug\u03b4(M, \u3008\u3008U\u3009\u3009RE) | M \u2208 \u3008\u3008P \u2295 V\u3009\u3009RE }\u222a\u3008\u3008U\u3009\u3009RE, it must contain the set aug\u03b4(M0, \u3008\u3008U\u3009\u3009RE). Furthermore, since U and V are over disjoint alphabets, it follows from Lemma 85 that aug\u03b4(M0, \u3008\u3008U\u3009\u3009RE) is eitherM0 or X, as desired.\nb) Suppose that M0 = aug\u03b4(M, \u3008\u3008V\u3009\u3009RE) and M \u2208 \u3008\u3008U\u3009\u3009RE. As in the previous case, since U and V are over disjoint alphabets, it follows from Lemma 85 that aug\u03b4(M, \u3008\u3008V\u3009\u3009RE) is eitherM or X. If the former is true, thenM0 \u2208 \u3008\u3008U\u3009\u3009RE, soM0 \u2208 \u3008\u3008(P \u2295 V)\u2295 U\u3009\u3009RE.\nc) Suppose thatM0 = aug\u03b4 (aug\u03b4 (M, \u3008\u3008U\u3009\u3009RE) , \u3008\u3008V\u3009\u3009RE) for someM\u2208 \u3008\u3008P\u3009\u3009RE. If \u03b4 \u2208 { \u03b4b, \u03b4c }, then it follows directly from Proposition 76 that\nM0 = aug\u03b4 (M, \u3008\u3008U\u3009\u3009RE \u222a \u3008\u3008V\u3009\u3009RE) = aug\u03b4 (aug\u03b4 (M, \u3008\u3008V\u3009\u3009RE) , \u3008\u3008U\u3009\u3009RE) .\nConsequently,M0 \u2208 \u3008\u3008(P \u2295 V)\u2295 U\u3009\u3009RE. If \u03b4 \u2208 { \u03b4d, \u03b4e }, then eitherM0 = X orM0 = aug\u03b4b ( aug\u03b4b (M, \u3008\u3008U\u3009\u3009RE) , \u3008\u3008V\u3009\u3009RE ) . The rest follows by the previous paragraph. Finally, if \u03b4 = \u03b4a, then we consider two subcases:\n(i) If aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) =M, thenM0 = aug\u03b4a(M, \u3008\u3008V\u3009\u3009RE), soM0 belongs to \u3008\u3008P\u2295V\u3009\u3009RE. Take some N \u2208 \u3008\u3008U\u3009\u3009RE and suppose that M0 1pJ N . Then, by Lemma 86, either MJ(p) = V0 for some truth value V0, or p occurs in V . In the former case we obtain a conflict with the assumption that aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) =M while the latter case is in conflict with the assumption that U and V are over disjoint alphabets. Thus, no suchN exists and aug\u03b4a(M0, \u3008\u3008U\u3009\u3009RE) =M0. Consequently,M0 belongs to \u3008\u3008(P \u2295 V)\u2295 U\u3009\u3009RE. (ii) If aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) 6= M, then there is some N \u2208 \u3008\u3008U\u3009\u3009RE such that M 1 p J N for some\natom p and interpretation J . Thus since U and V are over disjoint alphabets, it follows from Proposition 64 that aug\u03b4a(M, \u3008\u3008V\u3009\u3009RE) =M, so aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) belongs to \u3008\u3008(P\u2295V)\u2295U\u3009\u3009RE. It remains to show thatM0 = aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE). PutM1 = aug\u03b4a(M, \u3008\u3008U\u3009\u3009RE) and suppose that for some N \u2032 \u2208 \u3008\u3008V\u3009\u3009RE, some atom q and some interpretation K, M1 1Kq N \u2032. Then, by Lemma 86, eitherMK(q) = V0 for some truth value V0, or q occurs in U . In the former case, p = q by Proposition 64 and we obtain a conflict with the fact that U and V are over disjoint alphabets. In the latter case, q occurs in both U and V , so the same conflict follows. Consequently, no such N \u2032 exists and M0 = aug\u03b4a ( aug\u03b4a (M, \u3008\u3008U\u3009\u3009RE) , \u3008\u3008V\u3009\u3009RE ) = aug\u03b4a (M1, \u3008\u3008V\u3009\u3009RE) =\naug\u03b4a (M, \u3008\u3008U\u3009\u3009RE). The proof of the other inclusion is symmetric.\nRemark 88 ((Non-interference) for Disjunctive Programs). The following programs form a counterexample to (Non-interference) for \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based operators under SM-equivalence (and thus under all stronger notions of equivalence as well):\nP : p; q; r. U : \u223c p\u2190 \u223c r. V : \u223c q. p\u2190 r. r \u2190 p.\nAs for \u03b4a-based operators, the singleton programsP\u2032 = { p; q. }, U \u2032 = {\u223c p\u2190 \u223c r. } and V \u2032 = {\u223c q \u2190 s. } form a counterexample to (Non-interference) under SE-equivalence and all stronger notions of equivalence.\nProposition 89. Let \u2295 be a \u03b4-based rule update operator where \u03b4(M,X) \u2286 M for allM \u2286 X. Then \u2295 satisfies (Tautology) and (Immunity to Tautologies) with respect to RR, SR, RMR, SMR, RE, SE and SM.\nProof. For RR-equivalence this can be verified in a straight-forward manner. For the remaining notions of program equivalence this follows from Proposition 15.\nProposition 90. Let \u2295 be a \u03b4-based rule update operator. Then \u2295 satisfies (Idempotence) with respect to RMR, SMR, RE, SE and SM. Moreover, if \u2295 is \u03b4d- or \u03b4e-based, then it also satisfies (Idempotence) with respect to RR and SR.\nProof. (Idempotence) states the following: R\u2295R \u2261 R. We will show that this is true under RMR-equivalence which, together with Proposition 15, implies that it holds under SMR-, RE-, SE- and SM-equivalence.\nFirst take some M \u2208 min\u3008\u3008(R \u2295 R) \u222a { \u03c4 }\u3009\u3009RE. If M = X, then R \u2295 R is tautological and since \u3008\u3008R\u3009\u3009RE is a subset of \u3008\u3008R \u2295 R\u3009\u3009RE, R is itself tautological. Thus, X also belongs to min\u3008\u3008R \u222a { \u03c4 }\u3009\u3009RE. In the principal case, eitherM \u2208 \u3008\u3008R\u3009\u3009RE, orM = aug\u03b4(M0, \u3008\u3008R\u3009\u3009RE) for someM0 \u2208 \u3008\u3008R\u3009\u3009RE. In the latter case we have thatM0 is a subset ofM and sinceM0 belongs to \u3008\u3008R \u2295R\u3009\u3009RE, by the minimality ofM we obtain thatM =M0, soM belongs to \u3008\u3008R\u3009\u3009RE. Now it follows thatM is minimal \u3008\u3008R\u3009\u3009RE because \u3008\u3008R\u3009\u3009RE is a subset of \u3008\u3008R \u2295R\u3009\u3009RE andM is minimal in the latter set.\nNow take some M \u2208 min\u3008\u3008R \u222a { \u03c4 }\u3009\u3009RE. If M = X, then R is tautological and it follows by the properties of\u2295 thatR\u2295R is also tautological. Thus, X also belongs to \u3008\u3008(R\u2295R)\u222a{ \u03c4 }\u3009\u3009RE. In the principal case,M \u2208 \u3008\u3008R\u3009\u3009RE. Take some N \u2208 \u3008\u3008R \u2295 R\u3009\u3009RE such that N is a subset ofM. If N belongs to \u3008\u3008R\u3009\u3009RE, then it follows by minimality ofM thatM = N . On the other hand, if N is of the form aug\u03b4(N0, \u3008\u3008R\u3009\u3009RE) for someN0 from \u3008\u3008R\u3009\u3009RE, thenN0 \u2286 N \u2286M, so by the minimality ofM,N0 = N =M. Thus, in either case,M = N , which proves that it is minimal within \u3008\u3008R \u2295R\u3009\u3009RE.\nNow consider some \u03b4d- or \u03b4e-based rule update operator \u2295. Then, \u3008\u3008R \u2295 R\u3009\u3009RE \u2286 \u3008\u3008R\u3009\u3009RE \u222a {X }, so obviously \u3008\u3008(R\u2295R) \u222a { \u03c4 }\u3009\u3009RE = \u3008\u3008R \u222a { \u03c4 }\u3009\u3009RE.\nRemark 91 ((Idempotence) under \u2261SR and \u2261RR). The rule base R = { (p\u2190 \u223c q.), (\u223c p\u2190 r.) } forms a counterexample to (Idempotence) for \u03b4a-, \u03b4b- and \u03b4c-based operators with respect to SR and RR.\nLemma 92. LetM \u2286 X be RE-rule-expressible, S a set of RE-rule-expressible sets of three-valued interpretations. The following holds:\n(i) If \u03b4 \u2208 { \u03b4b, \u03b4c }, then aug\u03b4(aug\u03b4(M,S),S) = aug\u03b4(M,S). (ii) If \u03b4 \u2208 { \u03b4d, \u03b4e }, then either aug\u03b4(aug\u03b4(M,S),S) = aug\u03b4(M,S), or both aug\u03b4(aug\u03b4(M,S),S) =\nX and aug\u03b4(M,S) \u2208 S.\nProof. Let \u03b4 \u2208 { \u03b4b, \u03b4c }, putM\u2032 = aug\u03b4(M,S) and take someN \u2208 S such thatM\u2032 1 p J N for some atom p and some interpretation J . ThenM\u2032J(p) = V0 for some truth value V0, so it follows from Lemma 75 that MJ(p) = V0. But this impliesM 1pJ N , so both (J \\ { p } , J \\ { p }) and (J \u222a { p } , J \u222a { p }) belong toM\u2032, a conflict with the assumption thatM\u2032J(p) is defined. As a consequence, no such N \u2208 S exists, so aug\u03b4(M\u2032,S) =M\u2032 = aug\u03b4(M,S).\nOn the other hand, if \u03b4 \u2208 { \u03b4d, \u03b4e }, then we can observe that either the previous case applies, or both aug\u03b4(aug\u03b4(M,S),S) = X and aug\u03b4(M,S) \u2208 S.\nProposition 93. Let \u2295 be a \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based rule update operator. Then \u2295 satisfies (Absorption) with respect to RMR, SMR, RE, SE and SM. Moreover, if \u2295 is \u03b4d- or \u03b4e-based, then it satisfies (Absorption) with respect to RR and SR.\nProof. (Absorption) states the following: (R \u2295 U) \u2295 U \u2261 R \u2295 U . We will show that this is true under RMR-equivalence which, together with Proposition 15, implies that it holds under SMR-, RE-, SE- and SM-equivalence.\nSo suppose that \u2295 is \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based. By Lemma 92, \u3008\u3008((R\u2295 U)\u2295 U) \u222a { \u03c4 }\u3009\u3009RE is a superset of \u3008\u3008(R\u2295U)\u222a { \u03c4 }\u3009\u3009RE. Thus, wheneverM is minimal in \u3008\u3008((R\u2295U)\u2295U)\u222a { \u03c4 }\u3009\u3009RE, it is also minimal in\n\u3008\u3008(R\u2295U)\u222a{ \u03c4 }\u3009\u3009RE. Furthermore, the extra elements of \u3008\u3008((R\u2295U)\u2295U)\u222a{ \u03c4 }\u3009\u3009RE are never smaller than the elements of \u3008\u3008(R\u2295U)\u222a{ \u03c4 }\u3009\u3009RE because they are of the form aug\u03b4(N , \u3008\u3008U\u3009\u3009RE) for someN \u2208 \u3008\u3008U\u3009\u3009RE \u2286 \u3008\u3008(R \u2295 U) \u222a { \u03c4 }\u3009\u3009RE. Thus, wheneverM is minimal in \u3008\u3008(R \u2295 U) \u222a { \u03c4 }\u3009\u3009RE, it must also be minimal in \u3008\u3008((R\u2295 U)\u2295 U) \u222a { \u03c4 }\u3009\u3009RE.\nFurthermore, if \u2295 is \u03b4d- or \u03b4e-based, then it additionally holds that \u3008\u3008((R \u2295 U) \u2295 U) \u222a { \u03c4 }\u3009\u3009RE = \u3008\u3008(R\u2295 U) \u222a { \u03c4 }\u3009\u3009RE.\nProposition 94. Let \u2295 be a \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based rule update operator. Then \u2295 satisfies (Augmentation) for non-disjunctive programs with respect to RMR, SMR, RE, SE and SM. Moreover, if\u2295 is \u03b4d- or \u03b4e-based, then it satisfies (Augmentation) for non-disjunctive programs with respect to RR and SR.\nProof. The proof for RMR-equivalence follows from Proposition 76 and Lemma 81 and from the fact that the extra elements of \u3008\u3008((R\u2295U)\u2295V)\u222a{ \u03c4 }\u3009\u3009RE, as compared to \u3008\u3008(R\u2295V)\u222a{ \u03c4 }\u3009\u3009RE, are non-minimal in the latter set. If \u2295 is \u03b4d- or \u03b4e-based, then there are no extra elements and the rest follows from Proposition 76 and Lemma 81.\nRemark 95 ((Absorption) and (Augmentation) violated by \u03b4a). The rule bases R = { p. } and U = V = {\u223c p\u2190 \u223c q., q. } form counterexamples to (Absorption) and (Augmentation) for \u03b4a-based operators with respect SM-equivalence and any stronger notion of equivalence.\nRemark 96 ((Augmentation) for Disjunctive Programs). The following programs form a counterexample to (Augmentation) for \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based operators under SM-equivalence (and thus under all stronger notions of equivalence as well):\nP : p; q; r. U : \u223c p\u2190 \u223c r. V : \u223c p\u2190 \u223c r. p\u2190 r. p\u2190 r. r \u2190 p. r \u2190 p.\n\u223c q.\nRemark 97 ((Associativity) and \u03b4a, \u03b4b, \u03b4c, \u03b4d, \u03b4e). The rule \u03c0 = (\u223c p.), when updated by \u03c3 = (p \u2190 q.), must be weakened, anticipating the potential conflict. In the case of \u03b4a-, \u03b4b-, \u03b4c, \u03b4d and \u03b4e-based operators, the resulting rule is \u03c0\u2032 = (\u223c p\u2190 \u223c q.) (or another RE-equivalent rule). Consider the following rule bases:"}, {"heading": "R = { p. } , U = {\u223c p. } , V = { p\u2190 q., q \u2190 p. } .", "text": "Note that (Associativity) states the following: R\u2295 (U \u2295V) \u2261 (R\u2295U)\u2295V . However, while in (R\u2295U)\u2295V the fact from R is completely annihilated (i.e. transformed into a tautological rule) due to the negative fact \u03c0 in U , this does not happen in R \u2295 (U \u2295 V) because the \u03c0 is first weakened into \u03c0\u2032. As a consequence, R\u2295(U\u2295V) has one extra stable model comparing to (R\u2295U)\u2295V: { p, q }. This implies that (Associativity) does not hold for \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- and \u03b4e-based rule update operators under SM-equivalence, nor under any stronger equivalence.\nProposition 98. Let \u2295 be a \u03b4-based rule update operator. Then \u2295 satisfies (P2.1) and (P5) with respect to RMR, SMR, RE and SE.\nProof. Under RMR-entailment (P2.1) follows from the fact that M is a subset of aug\u03b4(M,S) and (P5) follows from the fact that aug\u03b4(M,S) is a subset of aug\u03b4(M,S \u222a T ). For the remaining notions of program entailment this follows from Proposition 15.\nRemark 99 ((P2.1) under |=SR and |=RR). Consider again the rules \u03c0, \u03c3 from Remark 97 and rule bases R = {\u03c0 }, U = {\u03c3 }. Note that (P2.1) states the following: R \u222a U |= R\u2295 U . However, if \u2295 is \u03b4a-, \u03b4b-, \u03b4c-, \u03b4d- or \u03b4e-based, R\u2295 U will contain \u03c0\u2032 (or another RE-equivalent rule or program) which results from weakening of \u03c0 by \u03c3. Consequently, when SR- or RR-entailment is used,R\u222aU cannot entailR\u2295U simply because \u03c0\u2032 (or another RE-equivalent rule or program) does not belong toR\u222a U .\nRemark 100 ((P2.2) and Rule Updates). Consider R = { p. } and U = {\u223c p. } and note that (P2.2) states the following: (R\u222a U)\u2295 U |= R. In other words, it requires that\n{ p.,\u223c p. } \u2295 {\u223c p. } |= p .\nIn the presence of (P1) this amounts to postulating that one can never recover from an inconsistent state. Such a requirement is out of line with the way these situations are treated in state-of-the-art approaches to rule updates which allow for recovery from an inconsistent state if all involved conflicts are resolved by the update. Note that, though for different reasons, (B2.2) has also been subject of harsh criticism in belief update literature [34].\nProposition 101. Let \u2295 be a \u03b4-based rule update operator where \u03b4(M,X) \u2286 M for allM \u2286 X. Then \u2295 satisfies (P4), (P4.1) and (P4.2) with respect to RR.\nProof. Principle (P4) can be verified straightforwardly and (P4.1) as well as (P4.2) are its consequences. The condition on \u03b4 is necessary to ensure that aug\u03b4(M, \u3008\u3008U\u3009\u3009RE) =M whenever U is tautological, to keep it in line with the case when U = \u2205."}, {"heading": "Appendix C. Proofs: Condensing into a Nested Program", "text": "Lemma 102. For any DLP P = \u3008Pi\u3009i<n, \u2295 JU P} consists of the following rules:\n1. for all \u03c0 \u2208 P}i with i < n\u2212 1, the nested rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . ) ; 2. all nested rules in P}n\u22121.\nProof. Follows by induction on n.\nProposition 103. Let I , J be interpretations and P a DLP. Then,\nI |= (all(P ) \\ rejJU(P , J)) J if and only if I |= (\u2295 JU P} )J .\nProof. First suppose that I |= (all(P ) \\ rejJU(P , J))J and take some rule \u03c3J \u2208 ( \u2295 JU P})J . We need to prove that I |= \u03c3J . It follows from Lemma 102 that one of the following cases occurs: a) If \u03c3 \u2208 P}n\u22121, then it immediately follows that \u03c3 \u2208 (all(P ) \\ rejJU(P , J))}. Consequently, since I |= (all(P ) \\ rejJU(P , J)) J , it follows that I |= \u03c3J .\nb) Otherwise, \u03c3 = ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . )\nfor some \u03c0 \u2208 P}i with i < n\u2212 1. Suppose that I |= BJ\u03c3 . Then I |= BJ\u03c0 and it also follows that for all j with i < j < n, J 6|= \u03b1P}j (H\u03c0). Consequently, \u03c0 \u2208 (all(P ) \\ rejJU(P , J))} and by the assumption we conclude that I |= \u03c0J . Hence, from I |= BJ\u03c0 it follows that I |= HJ\u03c0 , implying that I |= \u03c3J .\nFor the converse implication, suppose that I |= ( \u2295\nJU P})J and take some \u03c0 \u2208 (all(P ) \\ rejJU(P , J)) }. We need to show that I |= \u03c0J . If \u03c0 \u2208 P}n\u22121, then it follows by Lemma 102 that \u03c0 \u2208 ( \u2295 JU P}) and since\nI |= (\u2295 JU P} )J by assumption, we can immediately conclude that I |= \u03c0J .\nIn the principal case, \u03c0 \u2208 P}i for some i < n \u2212 1. Consequently, by Lemma 102, \u2295 JU P} contains\na rule \u03c3 = ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . ) . Since \u03c0 is not part of the set of rejected rules, we can conclude that for all j with i < j < n, J 6|= \u03b1P}j (H\u03c0). Hence, B J \u03c3 = B J \u03c0 \u2227 \u2227 i<j<n>. It follows that if I |= BJ\u03c0 , then I |= BJ\u03c3 and using our assumption we conclude that I |= HJ\u03c3 . Since H\u03c0 = H\u03c3, we demonstrated that I |= \u03c0J .\nLemma 104. For any DLP P = \u3008Pi\u3009i<n, \u2295 UA P} consists of the following rules:\n1. for all \u03c0 \u2208 P}i with i < n\u2212 1, the nested rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . ) ;\n2. for all \u03c0 \u2208 P}i with H\u03c0 \u2208 A and i < n, the nested rule ( H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0. ) ; 3. all nested rules in P}n\u22121.\nProof. Follows by induction on n.\nProposition 105. Let P be a DLP and J an interpretation. If J is a UA-model of P , then it is a stable model of \u2295 UA P}.\nProof. In order to show that J is a stable model of \u2295\nUA P}, we first establish that J satisfies ( \u2295 UA\nP})J . Take some rule \u03c3 from \u2295 UA P}. We need to prove that J |= \u03c3J . Due to Lemma 104, we need to consider the following cases:\n1) In the first case, \u03c3 = ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . )\nwhere \u03c0 \u2208 P}i and i < n \u2212 1. Suppose that J |= BJ\u03c3 . Then J |= BJ\u03c0 and for all j such that i < j < n, J 6|= \u03b1P}j (H\u03c0). Thus, we can conclude that \u03c0 \u2208 (all(P ) \\ rejUA(P , J))}, by the assumption, J |= \u03c0J . So since J |= BJ\u03c0 , it also holds that J |= HJ\u03c0 and since H\u03c0 = H\u03c3, we conclude that J |= \u03c3J .\n2) In the second case, \u03c3 = ( H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0. ) for some \u03c0 \u2208 P}i with H\u03c0 \u2208 A and i < n. If J |= H\u03c0,\nthen it easily follows that J |= \u03c3J . On the other hand, if J 6|= H\u03c0, then the head of \u03c3J contains > as the second disjunct and, once again, it follows that J |= \u03c3J .\n3) In the third case, \u03c3 \u2208 P}n\u22121. It immediately follows that \u03c3 \u2208 (all(P ) \\ rejUA(P , J)) }. Thus, our\nassumption implies that J |= \u03c3J . It remains to verify that J is also subset-minimal among interpretations that satisfy ( \u2295 UA P})J . To\nshow that this is the case, take an interpretation I with I \u2286 J that satisfies ( \u2295\nUA P})J . In the following we\nwill prove that I |= (all(P ) \\ rejUA(P , J)) J . Since J is subset-minimal among interpretations satisfying this program, it will follow that I = J as desired. Take some rule \u03c0 \u2208 (all(P ) \\ rejUA(P , J))\n}, our goal is to prove that I |= \u03c0J . We consider the following cases:\n1) In case \u03c0 \u2208 P}i with i < n \u2212 1 and there is no rule \u03c0\u2032 \u2208 Pj with i < j < n such that \u03c0\u2032 1 \u03c0 and J |= B\u03c0\u2032 , we can use Lemma 104 to conclude that \u2295 UA P} contains a rule \u03c3 =(\nH\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . )\n. It also follows that for all j with i < j < n, J 6|= \u03b1P}j (H\u03c0), so that BJ\u03c3 = B J \u03c0\u2227 \u2227 i<j<n>. Thus, if I |= BJ\u03c0 , then I |= BJ\u03c3 and by the assumption that I |= ( \u2295 UA P})J we obtain I |= HJ\u03c3 , so it also follows that I |= \u03c0J .\n2) In case \u03c0 \u2208 P}i with i < n \u2212 1 and there is a rule \u03c0\u2032 \u2208 Pj with i < j < n such that \u03c0\u2032 1 \u03c0 and J |= B\u03c0\u2032 , it follows that since \u03c0 is unrejected, \u03c0\u2032 is itself rejected. Consequently, there is also an unrejected rule \u03c0\u2032\u2032 \u2208 Pk with j < k < n such that \u03c0\u2032\u2032 1 \u03c0\u2032 and J |= B\u03c0\u2032\u2032 . Furthermore, H\u03c0\u2032\u2032 = H\u03c0 and by the assumption we know that J satisfies the rule \u03c0\u2032\u2032, so we can conclude that J |= H\u03c0. If H\u03c0 is a default literal, then it follows that (H\u03c0)J = >, so trivially I |= \u03c0J . If H\u03c0 is an atom, then, by Lemma 104, \u2295 UA P} contains a rule \u03c3 = ( H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0. ) . Note that\nHJ\u03c3 = H\u03c0 \u2228 \u22a5. Thus, if I |= BJ\u03c0 , then I |= BJ\u03c3 and it follows from our assumption that I |= HJ\u03c3 , so that I |= HJ\u03c0 . Hence, I |= \u03c0J .\n3) In case \u03c0 \u2208 P}n\u22121, it immediately follows from Lemma 104 that \u03c0 \u2208 (\u2295 UA P} ) . Thus, by the\nassumption that I |= ( \u2295\nUA P})J we obtain I |= \u03c0J .\nProposition 106. Let P be a DLP and J an interpretation. If J is a stable model of \u2295\nUA P}, then it is a\nUA-model of P .\nProof. To show that J is a UA-model of P , we first establish that J satisfies P = (all(P ) \\ rejUA(P , J)) J . Take some rule \u03c0 \u2208 (all(P ) \\ rejUA(P , J)) }, our goal is to prove that J |= \u03c0J . We consider the following cases:\n1) In case \u03c0 \u2208 P}i with i < n \u2212 1 and there is no rule \u03c0\u2032 \u2208 Pj with i < j < n such that \u03c0\u2032 1 \u03c0 and J |= B\u03c0\u2032 , we can use Lemma 104 to conclude that \u2295 UA P} contains a rule \u03c3 =(\nH\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . )\n. It also follows that for all j with i < j < n, J 6|= \u03b1P}j (H\u03c0), so that BJ\u03c3 = B J \u03c0 \u2227 \u2227 i<j<n>. Thus, if J |= BJ\u03c0 , then J |= BJ\u03c3 and by the assumption that\nJ |= ( \u2295\nUA P})J we obtain J |= HJ\u03c3 , so it follows that J |= \u03c0J .\n2) In case \u03c0 \u2208 P}i with i < n \u2212 1 and there is a rule \u03c0\u2032 \u2208 Pj with i < j < n such that \u03c0\u2032 1 \u03c0 and J |= B\u03c0\u2032 , it follows that since \u03c0 is unrejected, \u03c0\u2032 is itself rejected. Take the maximal index k such that Pk contains a rule \u03c0\u2032\u2032 with \u03c0\u2032\u2032 1 \u03c0\u2032 and J |= H\u03c0\u2032\u2032 . It follows that \u03c0\u2032\u2032 satisfies the condition of the previous case, and thus J |= HJ\u03c0\u2032\u2032 . Since H\u03c0 = H\u03c0\u2032\u2032 , we conclude that J |= \u03c0J .\n3) In case \u03c0 \u2208 P}n\u22121, it immediately follows from Lemma 104 that \u03c0 \u2208 (\u2295 UA P} ) . Thus, by the\nassumption that J |= ( \u2295\nUA P})J we obtain that J |= \u03c0J .\nIt remains to verify that J is also subset-minimal among interpretations that satisfy P. To show that this is the case, take an interpretation I with I \u2286 J that satisfies P. In the following we will prove that I also satisfies the program ( \u2295 UA P})J . Since J is subset-minimal among interpretations satisfying this program, it will follow that I = J as desired. So take some \u03c3 \u2208 ( \u2295 UA P}), our goal is to prove that I |= \u03c3J . Due to Lemma 104, we need to consider the following cases:\n1) In the first case, \u03c3 = ( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j ( H\u03c0 ) . )\nwhere \u03c0 \u2208 P}i and i < n \u2212 1. Suppose that I |= BJ\u03c3 . Then I |= BJ\u03c0 and for all j such that i < j < n, J 6|= \u03b1P}j (H\u03c0). Thus, we can conclude that \u03c0 \u2208 (all(P ) \\ rejUA(P , J))\n}. Furthermore, from I |= BJ\u03c0 and the assumption that I |= P, it follows that I |= HJ\u03c0 . Consequently, since H\u03c0 = H\u03c3, I |= \u03c3J . 2) In the second case, \u03c3 = (H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0.) for some \u03c0 \u2208 P}i with H\u03c0 \u2208 A and i < n. If \u03c0 is not rejected, then it follows from our assumption that I |= \u03c0J . In the principal case, there exists a rule \u03c0\u2032 \u2208 Pj with i < j < n such that \u03c0\u2032 1 \u03c0 and J |= B\u03c0\u2032 . Furthermore, \u03c0\u2032 itself is not rejected, so due to our previous considerations we can conclude that J |= H\u03c0\u2032 . Note that since H\u03c0 is an atom, H\u03c0\u2032 is a default literal, so the rule \u03c3J has > as one of the disjuncts in its head. Thus, I trivially satisfies \u03c3J .\n3) In the third case, \u03c3 \u2208 P}n\u22121. It immediately follows that \u03c3 \u2208 (all(P ) \\ rejUA(P , J)) }. Thus, our\nassumption implies that I |= \u03c3J .\nProof of Theorem 28. Follows from Propositions 103, 105 and 106."}, {"heading": "Appendix D. Proofs: Condensing into a Disjunctive Program", "text": "Remark 107. Throughout the following proofs we abuse notation by ignoring differences between formulas that can be eliminated by regrouping and reordering conjuncts and disjuncts within them. That is, when a formula can be obtained from another formula only by using the commutative and associative laws for conjunction and disjunction, we consider the two formulas identical. We can afford to do this because the order and grouping of conjuncts and disjuncts has no effect on the resulting semantics.\nDefinition 108 (Strong Equivalence [50]). Let P, Q be programs. We say that P is strongly equivalent to Q if for every program R, the stable models of P \u222a R coincide with the stable models of Q \u222a R. Strong equivalence is extended to rules by treating each rule \u03c0 as the program {\u03c0 }.\nProposition 109 ([50, 71]). Let P, Q be programs and \u03c0 a rule. If for all interpretations I , J with I \u2286 J , J |= P \u2227 I |= PJ if and only if J |= Q\u2227 I |= QJ , then P is strongly equivalent to Q.\nProof. Take some program R and some interpretation J . J is a stable model of P \u222a R if and only if J |= (P \u222a R)J and \u2200I ( J : I 6|= (P \u222a R)J . Due to the definition of reduct and the assumption, this is equivalent to J |= (Q\u222aR)J and \u2200I ( J : I 6|= (Q\u222aR)J . In other words, J is a stable model of P \u222aR if and only if it is a stable model of Q\u222aR.\nCorollary 110. Let P, Q be programs and \u03c0 a rule. If for all interpretations I , J , I |= PJ if and only if I |= QJ , then P is strongly equivalent to Q.\nProof. Follows from Proposition 109 and the fact that for every interpretation K and program R, K |= R if and only if K |= RK .\nCorollary 111. Let \u03c6, \u03c8 be formulas and \u03c0 a rule. If for all interpretations I , J , I |= \u03c6J if and only if I |= \u03c8J , then the rules (H\u03c0 \u2190 B\u03c0 \u2227 \u03c6.) and (H\u03c0 \u2190 B\u03c0 \u2227 \u03c8.) are strongly equivalent.\nProof. Follows from the definition of rule reduct and from Corollary 110.\nDefinition 112. Given a set of formulas S, we define \u223cS = { \u223c\u03c6 | \u03c6 \u2208 S }.\nLemma 113. Let P be a program, L a literal, S be a set of formulas and I , J interpretations. Then, (i) I |= ( \u2227 \u223cS)J if and only if I |= (\u223c \u2228 S)J ;\n(ii) I |= (\u223c\u03b1P}(L))J if and only if I |= (\u2228 S\u2208\u03b2P(L) \u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212 )J .\nProof. (i) By the definition of reduct, I |= ( \u2227 \u223cS)J if and only if for all \u03c6 \u2208 S it holds that J 6|= \u03c6. This in\nturn holds if and only if J 6|= \u2228 S, which is the case if and only if I |= (\u223c \u2228 S)J .\n(ii) Suppose that \u03b1P}(L) is the formula (L11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 L1k1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (L n 1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Lnkn). By the definition\nof reduct, I |= (\u223c\u03b1P}(L))J if and only if J 6|= \u03b1P}(L). Equivalently, for every j with 1 \u2264 j \u2264 n there exists some ij with 1 \u2264 ij \u2264 kj such that J 6|= Ljij . By the definition of blocking sets, this is equivalent to J |= S for some S \u2208 \u03b2P(L). Equivalently, for some S \u2208 \u03b2P(L),\n\u2200L \u2208 \u223cS+ : J 6|= L and \u2200L \u2208 S\u2212 : J 6|= L ,\nor in other words, ( \u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212)J = \u2227 L\u2208S >. Equivalently, we can also write I |=(\u2228\nS\u2208\u03b2P(L) \u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212 )J .\nLemma 114. Let \u03c0 be a rule and S a set of formulas. Then the rule (H\u03c0 \u2190 B\u03c0\u2227 \u2228 S.) is strongly equivalent to the program { H\u03c0 \u2190 B\u03c0 \u2227 \u03c6 | \u03c6 \u2208 S }.\nProof. Let \u03c3 denote the rule and P the program. According to Corollary 110, it suffices to prove that for all interpretations I , J , it holds that I |= \u03c3J if and only if it holds that I |= PJ . This easily follows from the fact that I |= \u03c3J if and only if I |= BJ\u03c3 implies I |= HJ\u03c3 , or, equivalently, for all \u03c6 \u2208 S, I |= BJ\u03c0 \u2227 \u03c6J implies I |= HJ\u03c0 , which is another way of writing I |= PJ .\nLemma 115. Let \u03c0 be a rule and \u03c6 a formula. Then the rules (H\u03c0 \u2190 B\u03c0 \u2227\u223c\u223c\u03c6.) and (H\u03c0 \u2228\u223c\u03c6\u2190 B\u03c0.) are strongly equivalent.\nProof. Let \u03c31 denote the first rule and \u03c32 the second. By Corollary 110, it suffices to prove that for all interpretations I , J , it holds that I |= \u03c3J1 if and only if it holds that I |= \u03c3J2 . If J |= \u03c6, then \u03c3J1 = (HJ\u03c0 \u2190 BJ\u03c0 \u2227 >) and \u03c3J2 = (HJ\u03c0 \u2228 \u22a5 \u2190 BJ\u03c0), so it follows that I |= \u03c3J1 holds if and only if I |= \u03c3J2 .\nOn the other hand, if J 6|= \u03c6, then \u03c3J1 = (H\u03c0 \u2190 B\u03c0 \u2227 \u22a5) \u03c3J2 = (H\u03c0 \u2228 > \u2190 B\u03c0) and trivially both I |= \u03c3J1 and I |= \u03c3J2 hold.\nLemma 116. Let \u03c0 be a rule such that H\u03c0 is a default literal and B\u03c0 is a conjunction of literals and doublenegated atoms. For any atom p, the rules (H\u03c0 \u2190 B\u03c0 \u2227 \u223c\u223c p.) and (H\u03c0 \u2190 B\u03c0 \u2227 p.) are are strongly equivalent.\nProof. Let H\u03c0 = \u223c q, where q is an atom. Also, let \u03c31 denote the first rule and \u03c32 the second. By Proposition 109, it suffices to prove that for all interpretations I , J with I \u2286 J ,"}, {"heading": "J |= \u03c31 \u2227 I |= \u03c3J1 if and only if J |= \u03c32 \u2227 I |= \u03c3J2 ,", "text": "First suppose that J |= \u03c31 and I |= \u03c3J1 . Then clearly J |= \u03c32 and it remains to prove that I |= \u03c3J2 . Suppose that I |= BJ\u03c32 . Then I |= B J \u03c0 and from I \u2286 J we conclude that J |= p, so I |= (\u223c\u223c p)J . Consequently, I |= BJ\u03c31 and from the assumption that I |= \u03c3 J 1 we conclude that I |= HJ\u03c0 as desired.\nNow suppose that J |= \u03c32 and I |= \u03c3J2 . Then clearly J |= \u03c31 and it remains to prove that I |= \u03c3J1 . Suppose that I |= BJ\u03c31 . Then I |= B J \u03c0 , so it follows from I \u2286 J that J |= B\u03c0. Furthermore, from I |= (\u223c\u223c p)J it follows that J |= p. Thus, J |= B\u03c32 and from J |= \u03c32 we conclude that J |= H\u03c0. This implies that HJ\u03c0 = (\u223c q)J = > and, thus, I |= HJ\u03c0 as desired.\nLemma 117. Let \u03c0 be a rule and \u03c6 a formula such that H\u03c0 is an atom and both B\u03c0 and \u03c6 are conjunctions of literals and double-negated atoms. For any atom p, the programs { H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0; H\u03c0 \u2190 B\u03c0 \u2227 \u03c6 \u2227 \u223c\u223c p } and { H\u03c0 \u2228 H\u03c0 \u2190 B\u03c0; H\u03c0 \u2190 B\u03c0 \u2227 \u03c6 \u2227 p } are strongly equivalent.\nProof. Let P1 denote the first program and P2 the second one. Also, let \u03c3 denote the rule (H\u03c0 \u2228H\u03c0 \u2190 B\u03c0), \u03c31 the rule (H\u03c0 \u2190 B\u03c0 \u2227 \u03c6 \u2227 \u223c\u223c p) and \u03c32 the rule (H\u03c0 \u2190 B\u03c0 \u2227 \u03c6 \u2227 p). Thus, P1 = {\u03c3, \u03c31 } and P2 = {\u03c3, \u03c32 }.\nAccording to Proposition 109, it suffices to prove that for all interpretations I , J with I \u2286 J ,\nJ |= P1 \u2227 I |= PJ1 if and only if J |= P2 \u2227 I |= PJ2 ,\nFirst assume that J |= P1 and I |= PJ1 . Clearly, it follows that J |= P2 and I |= \u03c3J , so it remains to verify that I |= \u03c3J2 . Suppose that I |= BJ\u03c32 . Then, since I \u2286 J , it follows that J |= p and so (\u223c\u223c p)\nJ = >. Consequently, I |= BJ\u03c31 and from the assumption that I |= P J 1 we can conclude that I |= HJ\u03c0 as desired.\nFor the converse implication, assume that J |= P2 and I |= PJ2 . It immediately follows that J |= P1 and I |= \u03c3J , so it remains to verify that I |= \u03c3J1 . Suppose that I |= BJ\u03c31 . From I \u2286 J and the assumption that both B\u03c0 and \u03c6 are conjunctions of literals and double-negated atoms, we conclude that J |= B\u03c31 , so it follows that J |= H\u03c0. Consequently, (H\u03c0)J = \u22a5 and since I |= \u03c3J , I |= BJ\u03c0 implies that I |= HJ\u03c0 as desired.\nLemma 118. Let P, Q be programs and L a literal. Then,\n\u03b2P\u222aQ(L) = { S \u222a T | S \u2208 \u03b2P(L) \u2227 T \u2208 \u03b2Q(L) } .\nProof. Suppose that \u03b1P}(L), \u03b1Q}(L) and \u03b1(P\u222aQ)}(L) are, respectively, of the forms\n(L11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 L1k1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (L m 1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Lmkm) ,\n(Lm+11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 L m+1 km+1 ) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (Ln1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Lnkn) ,\n(L11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 L1k1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (L n 1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Lnkn) .\nBy the definition, S \u2208 \u03b2P(L) and T \u2208 \u03b2Q(L) if and only if S = { L1i1 , . . . , L m im } and T = { Lm+1im+1 , . . . , L n in } where 1 \u2264 ij \u2264 kj for every j with 1 \u2264 j \u2264 n. This is equivalent to S\u222aT being a member of \u03b2P\u222aQ(L).\nLemma 119. Let P = \u3008Pi\u3009i<n be a DLP. Then \u2295\u2228 JU P consists of the following rules:\n1. for all \u03c0 \u2208 Pi with i < n\u2212 1 such that H\u03c0 = { p } for some p \u2208 A, and all S \u2208 \u03b2\u22c3 i<j<n Pj (\u223c p), the\nrule ( H\u03c0;S+ \u2190 B\u03c0, S\u2212. ) ;\n2. for all \u03c0 \u2208 Pi with i < n\u2212 1 such that H\u03c0 = {\u223c p } for some p \u2208 A, and all S \u2208 \u03b2\u22c3 i<j<n Pj (p), the\nrule ( H\u03c0 \u2190 B\u03c0, S+, S\u2212. ) ;;\n3. all rules in Pn\u22121.\nProof. Follows by induction on n using Lemma 118. Lemma 120. Let P = \u3008Pi\u3009i<n be a DLP. Then \u2295\u2228 UA P consists of the following rules:\n1. for all \u03c0 \u2208 Pi with i < n\u2212 1 and all S \u2208 \u03b2\u22c3 i<j<n Pj ( H\u03c0 ) , the rule ( H\u03c0 \u2190 B\u03c0, S+, S\u2212. ) ;\n2. for all \u03c0 \u2208 Pi with i < n such that H\u03c0 = { p } for some p \u2208 A, the rule (p;\u223c p\u2190 B\u03c0.); 3. all rules in Pn\u22121.\nProof. Follows by induction on n using Lemma 118.\nProof of Theorem 31. (i) Due to Theorem 28, it suffices to show that the programs \u2295 JU P} and \u2295\u2228 JU P have the same sta-\nble models. To see that this is indeed the case, consider the contents of these programs, as established in Lemmas 102 and 119. For all \u03c0 \u2208 P}i with i < n \u2212 1, \u2295 JU P} contains the nested rule(\nH\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j (H\u03c0). ) . By Lemma 113(i) and Corollary 111, this rule is strongly equiv-\nalent to the rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u223c \u2228 i<j<n \u03b1P}j (H\u03c0). ) which, by the definition of activation condition,\ncan also be written as (\nH\u03c0 \u2190 B\u03c0 \u2227 \u223c\u03b1\u22c3 i<j<n P } j (H\u03c0). )\n. Furthermore, due to Lemma 113(ii) and Corollary 111, the latter rule is strongly equivalent to the rule\nH\u03c0 \u2190 B\u03c0 \u2227 \u2228\nS\u2208\u03b2\u22c3 i<j<n Pj (H\u03c0)\n\u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212.\nand by using Lemma 114 we obtain the strongly equivalent program that contains, for each S \u2208 \u03b2\u22c3\ni<j<n Pj (H\u03c0), the rule\nH\u03c0 \u2190 B\u03c0 \u2227 \u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212.\nDouble-negated atoms from the bodies of these rules can be eliminated using Lemmas 115 and 116, obtaining (H\u03c0 \u2228 \u2228 \u223cS+ \u2190 B\u03c0 \u2227 \u2227 \u223cS\u2212.) if H\u03c0 is an atom and (H\u03c0 \u2190 B\u03c0 \u2227 \u2227 S+ \u2227 \u2227 \u223cS\u2212.) if H\u03c0 is a default literal. In this way, the original nested rules can be converted, one at a time, into a strongly equivalent disjunctive program. After this process is finished, the nested syntax can be converted to the syntax of disjunctive programs and the result coincides with the disjunctive program\u2295\u2228\nJU P . (ii) Due to Theorem 28, it suffices to show that the programs \u2295\nUA P} and \u2295\u2228 UA P have the same sta-\nble models. To see that this is indeed the case, consider the contents of these programs, as established in Lemmas 104 and 120. For all \u03c0 \u2208 P}i with i < n \u2212 1, \u2295 UA\nP contains the nested rule( H\u03c0 \u2190 B\u03c0 \u2227 \u2227 i<j<n\u223c\u03b1P}j (H\u03c0). ) . By Lemma 113(i) and Corollary 111, this rule is strongly equiv-\nalent to the rule ( H\u03c0 \u2190 B\u03c0 \u2227 \u223c \u2228 i<j<n \u03b1P}j (H\u03c0). ) which, by the definition of activation condition,\ncan also be written as (\nH\u03c0 \u2190 B\u03c0 \u2227 \u223c\u03b1\u22c3 i<j<n P } j (H\u03c0). )\n. Furthermore, due to Lemma 113(ii) and Corollary 111, the latter rule is strongly equivalent to the rule\nH\u03c0 \u2190 B\u03c0 \u2227 \u2228\nS\u2208\u03b2\u22c3 i<j<n Pj (H\u03c0)\n\u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212.\nand by using Lemma 114 we obtain the strongly equivalent program that contains, for each S \u2208 \u03b2\u22c3\ni<j<n Pj (H\u03c0), the rule\nH\u03c0 \u2190 B\u03c0 \u2227 \u2227 \u223c\u223cS+ \u2227 \u2227 \u223cS\u2212.\nFinally, double-negated atoms from the bodies of these rules can be eliminated using Lemmas 117 and 116, obtaining (H\u03c0 \u2190 B\u03c0 \u2227 \u2227 S+ \u2227 \u2227 \u223cS\u2212.) In this way, the original nested rules can be converted, one at a time, into a strongly equivalent disjunctive program. After this process is finished, the nested syntax can be converted to the syntax of disjunctive programs and the result coincides with the disjunctive program \u2295\u2228 UA P ."}, {"heading": "Appendix E. Proofs: Belief Updates Using Exception-Based Operators", "text": "Appendix E.1. Model-Based Update Operators\nTheorem 34. If is an update operator that satisfies (B1), (B2.1) and (B4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator \u2295 and all finite sequences of knowledge bases D, [[3D ]] = [[ \u2295 D ]].\nProof. Let the exception function \u03b5 be defined for all sets of interpretationsM \u2286 I and all sets of sets of interpretations S, T \u2286 2I as\n\u03b5(M,S, T ) = [[B U ]] (E.1) where B, U are some knowledge bases such that [[B ]] = \u22c2 S and [[U ]] = \u22c2 T . Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that satisfies (B4). Take some \u03b5-based operator \u2295. We proceed by induction on the length n of D = \u3008Bi\u3009i<n.\n1\u25e6 If n = 0, then it immediately follows that [[3D ]] = [[3\u3008B0\u3009 ]] = [[B0 ]] = [[ \u2295 \u3008B0\u3009 ]] = [[ \u2295 D ]].\n2\u25e6 Suppose that the claim holds for n, i.e. for D = \u3008Bi\u3009i<n we have [[3D ]] = [[ \u2295 D ]]. Our goal is to\nshow that it also holds for n+ 1, i.e. for D\u2032 = \u3008Bi\u3009i<n+1. It follows that\n\u3008\u3008 \u2295 D\u2032\u3009\u3009 = \u3008\u3008 \u2295 D \u2295 Bn\u3009\u3009 = { [[\u03c6 ]] \u222a \u03b5([[\u03c6 ]], \u3008\u3008 \u2295 D\u3009\u3009, \u3008\u3008Bn\u3009\u3009) | \u03c6 \u2208 \u2295 D } \u222a \u3008\u3008Bn\u3009\u3009 .\nBy (E.1) and the inductive assumption, \u03b5([[\u03c6 ]], \u3008\u3008 \u2295 D\u3009\u3009, \u3008\u3008Bn\u3009\u3009) = [[3D Bn ]] = [[3D\u2032 ]]. Consequently, [[ \u2295 D\u2032 ]] = \u22c2 \u3008\u3008 \u2295 D\u2032\u3009\u3009 = \u22c2({ [[\u03c6 ]] \u222a [[3D\u2032 ]]\n\u2223\u2223 \u03c6 \u2208\u2295D } \u222a \u3008\u3008Bn\u3009\u3009) . This can also be written as ([[3D\u2032 ]] \u222a \u22c2 \u3008\u3008 \u2295 D\u3009\u3009) \u2229 \u22c2 \u3008\u3008Bn\u3009\u3009. Substituting [[3D ]] for \u22c2 \u3008\u3008 \u2295 D\u3009\u3009 and distributing \u2229 over \u222a yields ([[3D\u2032 ]] \u2229 [[Bn ]]) \u222a ([[3D ]] \u2229 [[Bn ]]). Finally, using (B1) and (B2.1) we can write this as\n([[3D Bn ]] \u2229 [[Bn ]]) \u222a [[(3D) \u222a Bn ]] = [[3D Bn ]] \u222a [[(3D) \u222a Bn ]] = [[3D Bn ]] = [[3D\u2032 ]] .\nAppendix E.2. Formula-Based Update Operators\nThe set of possible remainders has a number of important properties from which properties of specific formula-based operators follow. We start with two auxiliary results which make it possible to construct a subset of a knowledge base with important properties on the semantic level.\nLemma 121. Let B, U be knowledge bases. Then U is consistent if and only if rem(B,U) is non-empty.\nProof. First suppose that U is consistent and let R be the set of all subsets B\u2032 of B such that B\u2032 \u222a U is consistent. R must be non-empty because \u2205 clearly belongs to R. So take some subset-maximal element B\u2217 ofR. It is easy to see that B\u2217 belongs to rem(B,U).\nOn the other hand, if rem(B,U) is non-empty, then it contains some set B\u2032 such that B\u2032\u222aU is consistent. Thus it follows directly that U is also consistent.\nLemma 122. Let B, C be knowledge bases with \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I, B\u2032 \u2286 B and C\u2032 = { \u03c6 \u2208 C \u2223\u2223 [[\u03c6 ]] \u2208 \u3008\u3008B\u2032\u3009\u3009I }. Then \u3008\u3008B\u2032\u3009\u3009I = \u3008\u3008C\u2032\u3009\u3009I.\nProof. Suppose first thatM belongs to \u3008\u3008B\u2032\u3009\u3009I. Then it also belongs to \u3008\u3008B\u3009\u3009I, so by our assumption either M = I orM belongs to \u3008\u3008C\u3009\u3009. In the former caseM belongs to \u3008\u3008C\u2032\u3009\u3009I and we are finished. In the latter case there is a formula \u03c6 \u2208 C such that [[\u03c6 ]] =M and \u03c6 belongs to C\u2032 by its definition. Consequently,M belongs to \u3008\u3008C\u2032\u3009\u3009I.\nAs for the other inclusion, ifM belongs to \u3008\u3008C\u2032\u3009\u3009I, then eitherM = I or for some formula \u03c6 \u2208 C\u2032 we haveM = [[\u03c6 ]]. Therefore,M belongs to \u3008\u3008B\u2032\u3009\u3009I by the definition of C\u2032.\nLemma 123. Let B, C, U , V be knowledge bases such that \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I, B\u2032 \u2286 B such that B\u2032 \u222a U is consistent and C\u2032 = { \u03c6 \u2208 C \u2223\u2223 [[\u03c6 ]] \u2208 \u3008\u3008B\u2032\u3009\u3009I }. Then C\u2032 \u222a V is consistent. Proof. To verify that C\u2032 \u222a V is consistent, we only need to use Lemma 122 and observe that\n[[C\u2032 \u222a V ]] = \u22c2 \u3008\u3008C\u2032 \u222a V\u3009\u3009 = \u22c2 (\u3008\u3008C\u2032\u3009\u3009 \u222a \u3008\u3008V\u3009\u3009) = \u22c2 (\u3008\u3008C\u2032\u3009\u3009I \u222a \u3008\u3008V\u3009\u3009)\n= \u22c2 (\u3008\u3008B\u2032\u3009\u3009I \u222a \u3008\u3008U\u3009\u3009) = \u22c2 (\u3008\u3008B\u2032\u3009\u3009 \u222a \u3008\u3008U\u3009\u3009) = \u22c2 \u3008\u3008B\u2032 \u222a U\u3009\u3009 = [[B\u2032 \u222a U ]] .\nProposition 124 (Syntax-Independence of Remainders). Let B, C, U , V be knowledge bases such that \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I. Then ((rem(B,U)))I = ((rem(C,V)))I.\nProof. We prove that ((rem(B,U)))I \u2286 ((rem(C,V)))I, the other inclusion follows by the same arguments since the formulation of the proposition is symmetric.\nTake some B\u2032 from rem(B,U) and put C\u2032 = { \u03c6 \u2208 C \u2223\u2223 [[\u03c6 ]] \u2208 \u3008\u3008B\u2032\u3009\u3009I }. We need to show that \u3008\u3008B\u2032\u3009\u3009I belongs to ((rem(C,V)))I. Due to Lemma 122, \u3008\u3008B\u2032\u3009\u3009I = \u3008\u3008C\u2032\u3009\u3009I, so it suffices to prove that C\u2032 belongs to rem(C,V). First, note that C\u2032 is clearly a subset of C and, by Lemma 123, C\u2032 \u222a V is consistent. We prove that C\u2032 is subset-maximal with these properties by contradiction. Suppose that C\u2217 is such that C\u2032 ( C\u2217 \u2286 C and C\u2217 \u222a V is consistent and let B\u2217 = { \u03c6 \u2208 B\n\u2223\u2223 [[\u03c6 ]] \u2208 \u3008\u3008C\u2217\u3009\u3009I }. Clearly, B\u2217 is a subset of B and, by Lemma 123, B\u2217 \u222a U is consistent. To reach a conflict, we need to show that B\u2032 is a proper subset of B\u2217. First note that \u3008\u3008C\u2032\u3009\u3009I cannot be equal to \u3008\u3008C\u2217\u3009\u3009I \u2013 if it were, then for every formula \u03c6 \u2208 C\u2217 it would hold that \u03c6 belongs to C and [[\u03c6 ]] belongs to \u3008\u3008B\u2032\u3009\u3009I, so \u03c6 belongs to C\u2032 by its definition, contrary to the assumption that C\u2032 is a proper subset of C\u2217. This, together with Lemma 122, implies that\n\u3008\u3008B\u2032\u3009\u3009I = \u3008\u3008C\u2032\u3009\u3009I ( \u3008\u3008C\u2217\u3009\u3009I = \u3008\u3008B\u2217\u3009\u3009I . (E.2)\nIt immediately follows that B\u2032 6= B\u2217. Furthermore, for any formula \u03c6 from B\u2032, \u03c6 belongs to B and it follows from (E.2) that [[\u03c6 ]] belongs to \u3008\u3008C\u2217\u3009\u3009I, so \u03c6 belongs to B\u2217 by its definition. This means that B\u2032 is a proper subset of B\u2217, contrary to the assumption that B\u2032 belongs to rem(B,U).\nLemma 125 (Equivalent Formulas in Remainders). Let B, U be knowledge bases, \u03c6, \u03c8 \u2208 B formulas such that [[\u03c6 ]] = [[\u03c8 ]] and B\u2032 \u2208 rem(B,U) a possible remainder. Then \u03c6 \u2208 B\u2032 if and only if \u03c8 \u2208 B\u2032.\nProof. Without loss of generality, assume that \u03c6 belongs to B\u2032 but \u03c8 does not. Then B\u2032 \u222a {\u03c8 } is a subset of B that is consistent with U . This is in conflict with the maximality of B\u2032. Corollary 126. Let B, U be knowledge bases and R \u2286 rem(B,U) a set of possible remainders. Then\u22c2 ((R)) = \u3008\u3008 \u22c2 R\u3009\u3009.\nProof. First suppose thatM belongs to \u22c2\n((R)) and take some B\u2032 \u2208 R and some formula \u03c6 \u2208 B\u2032 such that [[\u03c6 ]] =M. Now take an arbitrary B\u2217 \u2208 R. SinceM belongs to \u3008\u3008B\u2217\u3009\u3009, there must exist a formula \u03c8 \u2208 B\u2217 such that [[\u03c8 ]] = M. Consequently, [[\u03c6 ]] = [[\u03c8 ]] and by Lemma 125 we obtain that \u03c6 also belongs to B\u2217. Thus, \u03c6 belongs to \u22c2 R andM belongs to \u3008\u3008 \u22c2 R\u3009\u3009.\nOn the other hand, if M belongs to \u3008\u3008 \u22c2 R\u3009\u3009, then there is a formula \u03c6 \u2208 \u22c2 R such that [[\u03c6 ]] = M.\nConsequently,M belongs to all members of ((R)), thus also belongs to their intersection.\nCorollary 127. Let B, U be knowledge bases, R \u2286 rem(B,U) a set of possible remainders. Then,\u22c2 ((R))I = \u3008\u3008 \u22c2 R\u3009\u3009I.\nProof. Follows from Corollary 126 and from the fact that I belongs to both sides of the equation.\nProposition 128 (Properties of the WIDTIO Operator). The WIDTIO operator satisfies (F1), (F2.1) and (F4).\nProof. By definition U \u2286 B \u25e6widtio U and (F1) is obtained by applying \u3008\u3008\u00b7\u3009\u3009 to both sides of this inclusion. In order to verify that (F2.1) holds, suppose thatM belongs to \u3008\u3008B \u25e6widtioU\u3009\u3009. Then there is some formula\n\u03c6 from U \u222a \u22c2 rem(B,U) such that [[\u03c6 ]] = M. If \u03c6 belongs to U , then it immediately follows that M belongs to \u3008\u3008U\u3009\u3009, and consequently also to \u3008\u3008B \u222a U\u3009\u3009. If \u03c6 belongs to B\u2032 for all B\u2032 \u2208 rem(B,U), then \u03c6 also belongs to B. Thus,M is a member of \u3008\u3008B\u3009\u3009, and consequently also of \u3008\u3008B \u222a U\u3009\u3009.\nFinally, to verify (F4), suppose that \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I. The following follows from the definition of the WIDTIO operator, Corollary 127 and Proposition 124.\n\u3008\u3008B \u25e6widtio U\u3009\u3009I = \u2329\u2329 U \u222a \u22c2 rem(B,U) \u232a\u232aI = \u3008\u3008U\u3009\u3009I \u222a \u2329\u2329\u22c2 rem(B,U) \u232a\u232aI = \u3008\u3008U\u3009\u3009I \u222a \u22c2 ((rem(B,U)))I = \u3008\u3008V\u3009\u3009I \u222a \u22c2 ((rem(C,V)))I\n= \u3008\u3008V\u3009\u3009I \u222a \u2329\u2329\u22c2 rem(C,V) \u232a\u232aI = \u2329\u2329 V \u222a \u22c2 rem(C,V) \u232a\u232aI = \u3008\u3008C \u25e6widtio V\u3009\u3009I .\nProposition 129 (Properties of Regular Bold Operators). Regular Bold operators satisfy (F1), (F2.1) and (F4).\nProof. By definition U \u2286 B \u25e6sbold U and (F1) is obtained by applying \u3008\u3008\u00b7\u3009\u3009 to both sides of this inclusion. In order to verify that (F2.1) holds, suppose thatM belongs to \u3008\u3008B \u25e6sbold U\u3009\u3009. Then there is some formula \u03c6 from U \u222a s(rem(B,U)) such that [[\u03c6 ]] = M. If \u03c6 belongs to U , then it immediately follows that M belongs to \u3008\u3008U\u3009\u3009, and consequently also to \u3008\u3008B\u222aU\u3009\u3009. If \u03c6 belongs to B\u2032 = s(rem(B,U)), then \u03c6 also belongs to B. Thus,M is a member of \u3008\u3008B\u3009\u3009, and consequently also of \u3008\u3008B \u222a U\u3009\u3009.\nFinally, to verify (F4), suppose that \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I. The following follows from the definition of the WIDTIO operator, Proposition 124 and the regularity property of \u25e6sbold.\n\u3008\u3008B \u25e6sbold U\u3009\u3009I = \u3008\u3008U \u222a s(rem(B,U))\u3009\u3009I = \u3008\u3008U\u3009\u3009I \u222a \u3008\u3008s(rem(B,U))\u3009\u3009I\n= \u3008\u3008V\u3009\u3009I \u222a \u3008\u3008s(rem(C,V))\u3009\u3009I = \u3008\u3008V \u222a s(rem(C,V))\u3009\u3009I = \u3008\u3008C \u25e6sbold V\u3009\u3009I .\nProposition 130 (Properties of the Cross-Product Operator). The Cross-Product operator satisfies (F1), (B2.1) and (F4) but does not satisfy (F2.1).\nProof. By definition U \u2286 B \u25e6cp U and (F1) is obtained by applying \u3008\u3008\u00b7\u3009\u3009 to both sides of this inclusion. To see that \u25e6cp does not satisfy (F2.1), note that { p, q }\u25e6cp {\u00acp \u2228 \u00acq } = { p \u2228 q,\u00acp \u2228 \u00acq } and [[p\u2228 q ]] does not belong to \u3008\u3008{ p, q,\u00acp \u2228 \u00acq }\u3009\u3009. In order to verify (B2.1), take some I from [[B \u222a U ]]. We need to show that I is a model of B \u25e6cp U . Obviously, I is a model of U , so it remains to prove that I is a model of the formula\n\u03c8 = \u2228\nB\u2032\u2208rem(B,U) \u2227 \u03c6\u2208B\u2032 \u03c6 .\nSince I is a model of U , we conclude that U is consistent, so according to Lemma 121, rem(B,U) is nonempty. Take some B\u2217 from rem(B,U). We obtain the following: [[\u03c8 ]] = \u22c3 B\u2032\u2208rem(B,U)[[B\u2032 ]] \u2287 [[B\u2217 ]] \u2287 [[B ]]. Hence, since I belongs to [[B ]], it also belongs to [[\u03c8 ]]. Finally, to verify (F4), suppose that \u3008\u3008B\u3009\u3009I = \u3008\u3008C\u3009\u3009I and \u3008\u3008U\u3009\u3009I = \u3008\u3008V\u3009\u3009I and take someM from \u3008\u3008B\u25e6cpU\u3009\u3009I. In the trivial case when M = I it immediately follows that M belongs to \u3008\u3008C \u25e6cp V\u3009\u3009I. Otherwise, there is a formula \u03c6 from U \u222a {\u03c8 } such that [[\u03c6 ]] = M. If \u03c6 belongs to U , then M belongs to \u3008\u3008U\u3009\u3009 and by assumption also to \u3008\u3008V\u3009\u3009I. By (F1) we then obtain thatM belongs to \u3008\u3008C \u25e6cp V\u3009\u3009I. On the other hand, if \u03c6 is \u03c8, then due to Proposition 124, ((rem(B,U)))I = ((rem(C,V)))I, so\n[[\u03c6 ]] = [[\u03c8 ]] = \u22c3\nB\u2032\u2208rem(B,U)\n[[B\u2032 ]] = \u22c3\nC\u2032\u2208rem(C,V)\n[[C\u2032 ]] = [[\u03c8\u2032 ]]\nwhere C \u25e6cp V = V \u222a {\u03c8\u2032 }. Therefore, [[\u03c6 ]] belongs to \u3008\u3008C \u25e6cp V\u3009\u3009I. The proof of the other inclusion is symmetric.\nProof of Proposition 36. Follows from Propositions 128, 129 and 130.\nProposition 131. If \u25e6 is an update operator that satisfies (F1), (F2.1) and (F4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator \u2295 and all finite sequences of knowledge bases D, \u3008\u3008\u00a9D\u3009\u3009I = \u3008\u3008 \u2295 D\u3009\u3009I.\nProof. Let the exception function \u03b5 be defined for all sets of interpretations M and all sets of sets of interpretations S, T as\n\u03b5(M,S, T ) = { \u2205 M \u2208 \u3008\u3008B \u25e6 U\u3009\u3009I ; I M /\u2208 \u3008\u3008B \u25e6 U\u3009\u3009I ,\nwhere B, U are some knowledge bases such that \u3008\u3008B\u3009\u3009I = S \u222a { I } and \u3008\u3008U\u3009\u3009I = T \u222a { I }. Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that \u25e6 satisfies (F4). Take some \u03b5-based operator \u2295. We proceed by induction on the length n of D = \u3008Bi\u3009i<n.\n1\u25e6 If n = 0, then it immediately follows that \u3008\u30083D\u3009\u3009 = \u3008\u30083\u3008B0\u3009\u3009\u3009 = \u3008\u3008B0\u3009\u3009 = \u3008\u3008 \u2295 \u3008B0\u3009\u3009\u3009 = \u3008\u3008 \u2295 D\u3009\u3009.\n2\u25e6 Suppose that the claim holds for n, i.e. for D = \u3008Bi\u3009i<n we have \u3008\u30083D\u3009\u3009I = \u3008\u3008 \u2295 D\u3009\u3009I. Our goal is to\nshow that it also holds for n+ 1, i.e. for D\u2032 = \u3008Bi\u3009i<n+1. It follows that \u3008\u3008 \u2295 D\u2032\u3009\u3009 = \u3008\u3008 \u2295 D \u2295 Bn\u3009\u3009 = { [[\u03c6 ]] \u222a \u03b5([[\u03c6 ]], \u3008\u3008 \u2295 D\u3009\u3009, \u3008\u3008Bn\u3009\u3009) | \u03c6 \u2208 \u2295 D } \u222a \u3008\u3008Bn\u3009\u3009 .\nThus, \u3008\u3008 \u2295 D\u2032\u3009\u3009I = { [[\u03c6 ]] \u222a \u03b5([[\u03c6 ]], \u3008\u3008 \u2295 D\u3009\u3009, \u3008\u3008Bn\u3009\u3009) | \u03c6 \u2208 \u2295 D }\u222a \u3008\u3008Bn\u3009\u3009 \u222a { I } which in turn can be written as{ M \u2223\u2223\u2223M\u2208 \u3008\u3008\u2295D\u3009\u3009 \u2229 \u3008\u3008\u2295D \u25e6 Bn\u3009\u3009I } \u222a { I \u2223\u2223\u2223M\u2208 \u3008\u3008\u2295D\u3009\u3009 \\ \u3008\u3008\u2295D \u25e6 Bn\u3009\u3009I } \u222a \u3008\u3008Bn\u3009\u3009 \u222a { I }\nand simplified into ( \u3008\u3008 \u2295 D\u3009\u3009I \u2229 \u3008\u3008 \u2295 D \u25e6 Bn\u3009\u3009I ) \u222a \u3008\u3008Bn\u3009\u3009I. Since \u25e6 satisfies (F4), it follows from the\ninductive assumption that \u3008\u3008 \u2295 D \u25e6 Bn\u3009\u3009I = \u3008\u3008\u00a9D \u25e6 Bn\u3009\u3009I. Thus, we obtain the set( \u3008\u3008\u00a9D\u3009\u3009I \u2229 \u3008\u3008\u00a9D \u25e6 Bn\u3009\u3009I ) \u222a \u3008\u3008Bn\u3009\u3009I\nand by distributing \u222a over \u2229 and using (F1) and (F2.1) we obtain( \u3008\u3008\u00a9D\u3009\u3009I \u222a \u3008\u3008Bn\u3009\u3009I ) \u2229 ( \u3008\u3008\u00a9D \u25e6 Bn\u3009\u3009I \u222a \u3008\u3008Bn\u3009\u3009I ) = \u3008\u3008\u00a9D \u222a Bn\u3009\u3009I \u2229 \u3008\u3008\u00a9D \u25e6 Bn\u3009\u3009I\n= \u3008\u3008\u00a9D \u25e6 Bn\u3009\u3009I = \u3008\u3008\u00a9D\u2032\u3009\u3009I .\nProposition 132. If \u25e6 an update operator that satisfies (F1), (B2.1) and (F4), then there exists an exception function \u03b5 such that for every \u03b5-based update operator\u2295 and all knowledge bases B, U , [[B\u25e6U ]] = [[B\u2295U ]].\nProof. Let the exception function \u03b5 be defined for all sets of interpretations M and all sets of sets of interpretations S, T as\n\u03b5(M,S, T ) = [[B \u25e6 U ]] ,\nwhere B, U are some knowledge bases such that \u3008\u3008B\u3009\u3009I = S \u222a { I } and \u3008\u3008U\u3009\u3009I = T \u222a { I }. Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that \u25e6 satisfies (F4).\nTake some \u03b5-based operator \u2295. Then [[B \u2295 U ]] = \u22c2\n({ [[\u03c6 ]] \u222a \u03b5([[\u03c6 ]], \u3008\u3008B\u3009\u3009, \u3008\u3008U\u3009\u3009) | \u03c6 \u2208 B } \u222a \u3008\u3008U\u3009\u3009), which can be written as \u22c2 { [[\u03c6 ]] \u222a [[B \u25e6 U ]] | \u03c6 \u2208 B }\u2229 \u22c2 \u3008\u3008U\u3009\u3009 and simplified into ([[B \u25e6U ]]\u222a [[B ]])\u2229 [[U ]].\nFurthermore, due to (B1) and (B2.1),\n([[B \u25e6 U ]] \u222a [[B ]]) \u2229 [[U ]] = ([[B \u25e6 U ]] \u2229 [[U ]]) \u222a ([[B ]] \u2229 [[U ]]) = [[B \u25e6 U ]] \u222a [[B \u222a U ]] = [[B \u25e6 U ]] .\nProof of Theorem 37. Follows from Propositions 131 and 132."}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourr\u00f3n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "Journal of Symbolic Logic, 50(2):510\u2013530", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1985}, {"title": "Update-programs can update programs", "author": ["J.J. Alferes", "L.M. Pereira"], "venue": "Selected Papers,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1996}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["J.J. Alferes", "J.A. Leite", "L.M. Pereira", "H. Przymusinska", "T.C. Przymusinski"], "venue": "The Journal of Logic Programming,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2000}, {"title": "An evolvable rule-based e-mail agent", "author": ["J.J. Alferes", "A. Brogi", "J.A. Leite", "L.M. Pereira"], "venue": "F. Moura-Pires and S. Abreu, editors, Proceedings of the 11th Portuguese Conference Artificial Intelligence ", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "The refined extension principle for semantics of dynamic logic programming", "author": ["J.J. Alferes", "F. Banti", "A. Brogi", "J.A. Leite"], "venue": "Studia Logica, 79(1):7\u201332", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2005}, {"title": "Acyclic programs", "author": ["K.R. Apt", "M. Bezem"], "venue": "New Generation Computing, 9(3/4):335\u2013364", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1991}, {"title": "Towards a theory of declarative knowledge", "author": ["K.R. Apt", "H.A. Blair", "A. Walker"], "venue": "J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 89\u2013148. Morgan Kaufmann, San Francisco, CA, USA", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1988}, {"title": "editors", "author": ["F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press, 2nd edition", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "The description logic ABox update problem revisited", "author": ["Y. Bong"], "venue": "Master\u2019s thesis, Dresden University of Technology,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Generalized update: Belief change in dynamic settings", "author": ["C. Boutilier"], "venue": "In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1995}, {"title": "How to do things with worlds: On formalizing actions and plans", "author": ["G. Brewka", "J. Hertzberg"], "venue": "Journal of Logic and Computation, 3(5):517\u2013532", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1993}, {"title": "Minimal logic programs", "author": ["P. Cabalar", "D. Pearce", "A. Valverde"], "venue": "V. Dahl and I. Niemel\u00e4, editors, Proceedings of the 23rd International Conference on Logic Programming ", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2007}, {"title": "Evolution of DL-Lite knowledge bases", "author": ["D. Calvanese", "E. Kharlamov", "W. Nutt", "D. Zheleznyakov"], "venue": "editors, International Semantic Web Conference (1),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Un syst\u00e9me de communication homme-machine en fran\u00e7ais", "author": ["A. Colmerauer", "H. Kanoui", "P. Roussel", "R. Pasero"], "venue": "Technical report, Groupe de Recherche en Intelligence Artificielle, Universit\u00e9 d\u2019Aix-Marseille II", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1973}, {"title": "A semantical framework for hybrid knowledge bases", "author": ["J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde"], "venue": "Journal of Knowledge and Information Systems,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "Embedding nonground logic programs into autoepistemic logic for knowledge-base combination", "author": ["J. de Bruijn", "T. Eiter", "A. Polleres", "H. Tompits"], "venue": "ACM Transactions on Computational Logic (TOCL),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2011}, {"title": "On the update of description logic ontologies at the instance level", "author": ["G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati"], "venue": "In Proceedings of the 21st National Conference on Artificial Intelligence and the 18th Innovative Applications of Artificial Intelligence Conference,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "On the approximation of instance level update and erasure in description logics", "author": ["G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati"], "venue": "Proceedings of the 22nd AAAI Conference on Artificial Intelligence ", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "On instance-level update and erasure in description logic ontologies", "author": ["G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati"], "venue": "Journal of Logic and Computation, 19(5):745\u2013770", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "A preference-based framework for updating logic programs", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits"], "venue": "C. Baral, G. Brewka, and J. S. Schlipf, editors, Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning ", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "A classification theory of semantics of normal logic programs: II", "author": ["J. Dix"], "venue": "Weak properties. Fundamenta Informaticae, 22(3): 257\u2013288", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1995}, {"title": "The PMA and relativizing minimal change for action update", "author": ["P. Doherty", "W. Lukaszewicz", "E. Madalinska-Bugaj"], "venue": "Proceedings of the 6th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1998}, {"title": "Putting ABox updates into action", "author": ["C. Drescher", "H. Liu", "F. Baader", "P. Steinke", "M. Thielscher"], "venue": "Proceedings of the 8th IJCAI International Workshop on Nonmontonic Reasoning, Action and Change (NRAC-09)", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2009}, {"title": "On properties of update sequences based on causal rejection", "author": ["T. Eiter", "M. Fink", "G. Sabbatini", "H. Tompits"], "venue": "Theory and Practice of Logic Programming (TPLP), 2(6):721\u2013777", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2002}, {"title": "On the semantics of updates in databases", "author": ["R. Fagin", "J.D. Ullman", "M.Y. Vardi"], "venue": "Proceedings of the 2nd ACM SIGACT- SIGMOD Symposium on Principles of Database Systems ", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1986}, {"title": "Ontology change: classification and survey", "author": ["G. Flouris", "D. Makanatas", "H. Kondylakis", "D. Plexousakis", "G. Antoniou"], "venue": "The Knowledge Engineering Review, 23(2):117\u2013152", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2008}, {"title": "Belief Revision", "author": ["P. G\u00e4rdenfors"], "venue": "chapter Belief Revision: An Introduction, pages 1\u201328. Cambridge University Press", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1992}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "R. A. Kowalski and K. A. Bowen, editors, Proceedings of the 5th International Conference and Symposium on Logic Programming ", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing, 9 (3-4):365\u2013385", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1991}, {"title": "Counterfactuals", "author": ["M.L. Ginsberg"], "venue": "Artificial Intelligence, 30(1):35\u201379", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1986}, {"title": "Reasoning about action i: A possible worlds approach", "author": ["M.L. Ginsberg", "D.E. Smith"], "venue": "Artificial Intelligence, 35(2): 165\u2013195", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1988}, {"title": "Belief base revision for expressive description logics", "author": ["C. Halaschek-Wiener", "Y. Katz"], "venue": "Proceedings of the OWLED*06 Workshop on OWL: Experiences and Directions,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2006}, {"title": "Reversing the Levi identity", "author": ["S.O. Hansson"], "venue": "Journal of Philosophical Logic,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1993}, {"title": "Propositional belief base update and minimal change", "author": ["A. Herzig", "O. Rifi"], "venue": "Artificial Intelligence, 115(1):107\u2013138", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1999}, {"title": "Ontologies and rules", "author": ["P. Hitzler", "B. Parsia"], "venue": "S. Staab and R. Studer, editors, Handbook on Ontologies, International Handbooks on Information Systems, pages 111\u2013132. Springer, Berlin, second edition", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2009}, {"title": "Dynamic logic programming: Various semantics are equal on acyclic programs", "author": ["M. Homola"], "venue": "Proceedings of the 5th International Workshop on Computational Logic in Multi-Agent Systems (CLIMA V),", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2004}, {"title": "Explicit dynamic user profiles for a collaborative filtering recommender system", "author": ["M. Ilic", "J. Leite", "M. Slota"], "venue": "H. Geffner, R. Prada, I. M. Alexandre, and N. David, editors, Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA\u201908), volume LNAI 5290, pages 352\u2013361. Springer-Verlag", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2008}, {"title": "Negation as failure in the head", "author": ["K. Inoue", "C. Sakama"], "venue": "Journal of Logic Programming, 35(1):39\u201378", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1998}, {"title": "Equivalence of logic programs under updates", "author": ["K. Inoue", "C. Sakama"], "venue": "J. J. Alferes and J. A. Leite, editors, Proceedings of the 9th European Conference on Logics in Artificial Intelligence ", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2004}, {"title": "On the effect of default negation on the expressiveness of disjunctive rules", "author": ["T. Janhunen"], "venue": "T. Eiter, W. Faber, and M. Truszczynski, editors, Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning ", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2001}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1991}, {"title": "On the use of an extended relational model to handle changing incomplete information", "author": ["A.M. Keller", "M. Winslett"], "venue": "IEEE Transactions on Software Engineering, 11(7):620\u2013633", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1985}, {"title": "Capturing model-based ontology evolution at the instance level: The case of dl-lite", "author": ["E. Kharlamov", "D. Zheleznyakov", "D. Calvanese"], "venue": "Journal of Computer and System Sciences, 79(6):835\u2013872", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2013}, {"title": "Local closed world reasoning with description logics under the well-founded semantics", "author": ["M. Knorr", "J.J. Alferes", "P. Hitzler"], "venue": "Artificial Intelligence, 175(9-10):1528\u20131554", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2011}, {"title": "Predicate logic as programming language", "author": ["R.A. Kowalski"], "venue": "IFIP Congress, pages 569\u2013574", "citeRegEx": "45", "shortCiteRegEx": null, "year": 1974}, {"title": "Dependency semantics for sequences of extended logic programs", "author": ["P. Kr\u00fcmpelmann"], "venue": "Logic Journal of the IGPL, 20(5): 943\u2013966", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2012}, {"title": "On belief dynamics of dependency relations for extended logic programs", "author": ["P. Kr\u00fcmpelmann", "G. Kern-Isberner"], "venue": "In Proceedings of the 13th International Workshop on Non-Monotonic Reasoning,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2010}, {"title": "Generalizing updates: From models to programs", "author": ["J.A. Leite", "L.M. Pereira"], "venue": "J. Dix, L. M. Pereira, and T. C. Przymusinski, editors, Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR \u201997), October 17", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1997}, {"title": "On the evolution of the instance level of DL-Lite knowledge bases", "author": ["M. Lenzerini", "D.F. Savo"], "venue": "R. Rosati, S. Rudolph, and M. Zakharyaschev, editors, Proceedings of the 24th International Workshop on Description Logics ", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2011}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic (TOCL), 2(4):526\u2013541", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2001}, {"title": "Updating description logic ABoxes", "author": ["H. Liu", "C. Lutz", "M. Mili\u010di\u0107", "F. Wolter"], "venue": "Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201906),", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2006}, {"title": "Foundations of Logic Programming", "author": ["J.W. Lloyd"], "venue": "Springer, 2nd edition", "citeRegEx": "52", "shortCiteRegEx": null, "year": 1987}, {"title": "Revision programming", "author": ["V.W. Marek", "M. Truszczynski"], "venue": "Theoretical Computer Science, 190(2):241\u2013277", "citeRegEx": "53", "shortCiteRegEx": null, "year": 1998}, {"title": "Reconciling description logics and rules", "author": ["B. Motik", "R. Rosati"], "venue": "Journal of the ACM, 57(5):93\u2013154", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2010}, {"title": "Updates in answer set programming: An approach based on basic structural properties", "author": ["M. Osorio", "V. Cuevas"], "venue": "Theory and Practice of Logic Programming, 7(4):451\u2013479", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2007}, {"title": "A new logical characterisation of stable models and answer sets", "author": ["D. Pearce"], "venue": "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP \u201996),", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 1997}, {"title": "A survey of revision approaches in description logics", "author": ["G. Qi", "F. Yang"], "venue": "Proceedings of the 2nd International Conference on Web Reasoning and Rule Systems (RR\u201908),", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2008}, {"title": "Base revision in description logics - preliminary results", "author": ["M.M. Ribeiro", "R. Wassermann"], "venue": "Proceedings of the International Workshop on Ontology Dynamics (IWOD-07), pages 69\u201382", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2007}, {"title": "A methodology to create legal ontologies in a logic programming based web information retrieval system", "author": ["J. Saias", "P. Quaresma"], "venue": "Artificial Intelligence and Law, 12(4):397\u2013417", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2004}, {"title": "An abductive framework for computing knowledge base updates", "author": ["C. Sakama", "K. Inoue"], "venue": "Theory and Practice of Logic Programming (TPLP), 3(6):671\u2013713", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2003}, {"title": "Irrelevant updates and nonmonotonic assumptions", "author": ["J. \u0160efr\u00e1nek"], "venue": "M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, editors, Proceedings of the 10th European Conference on Logics in Artificial Intelligence ", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2006}, {"title": "Static and dynamic semantics: Preliminary report", "author": ["J. \u0160efr\u00e1nek"], "venue": "Mexican International Conference on Artificial Intelligence, 65  pages 36\u201342", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2011}, {"title": "Dynamic logic programming and world state evaluation in computer games", "author": ["J. Siska"], "venue": "Proceedings of the 20th Workshop on Logic Programming,", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 2006}, {"title": "Towards Closed World Reasoning in Dynamic Open Worlds. Theory and Practice of Logic Programming, 26th Int\u2019l", "author": ["M. Slota", "J. Leite"], "venue": "Conference on Logic Programming (ICLP\u201910) Special Issue,", "citeRegEx": "64", "shortCiteRegEx": "64", "year": 2010}, {"title": "Back and forth between rules and SE-models", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-11),", "citeRegEx": "65", "shortCiteRegEx": "65", "year": 2011}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "G. Brewka, T. Eiter, and S. A. McIlraith, editors, Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning ", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2012}, {"title": "A unifying perspective on knowledge updates", "author": ["M. Slota", "J. Leite"], "venue": "L. F. del Cerro, A. Herzig, and J. Mengin, editors, Proceedings of the 13th European Conference on Logics in Artificial Intelligence ", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2012}, {"title": "On condensing a sequence of updates in answer-set programming", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI\u201913). AAAI Press", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2013}, {"title": "The rise and fall of semantic rule updates based on SE-models", "author": ["M. Slota", "J. Leite"], "venue": "Theory and Practice of Logic Programming (TPLP)", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2013}, {"title": "Splitting and updating hybrid knowledge bases", "author": ["M. Slota", "J. Leite", "T. Swift"], "venue": "Theory and Practice of Logic Programming, 27th Int\u2019l. Conference on Logic Programming (ICLP\u201911) Special Issue, 11(4-5):801\u2013819", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2011}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["H. Turner"], "venue": "Theory and Practice of Logic Programming (TPLP), 3(4-5):609\u2013622", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2003}, {"title": "Reasoning about action using a possible models approach", "author": ["M. Winslett"], "venue": "Proceedings of the 7th National Conference on Artificial Intelligence ", "citeRegEx": "72", "shortCiteRegEx": null, "year": 1988}, {"title": "Updating Logical Databases", "author": ["M. Winslett"], "venue": "Cambridge University Press, New York, USA", "citeRegEx": "73", "shortCiteRegEx": null, "year": 1990}, {"title": "A stronger notion of equivalence for logic programs", "author": ["K.-S. Wong"], "venue": "V. Dahl and I. Niemel\u00e4, editors, Proceedings of the 23rd International Conference on Logic Programming ", "citeRegEx": "74", "shortCiteRegEx": null, "year": 2007}, {"title": "Logic program-based updates", "author": ["Y. Zhang"], "venue": "ACM Transactions on Computational Logic, 7(3):421\u2013472", "citeRegEx": "75", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 7, "context": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.", "startOffset": 200, "endOffset": 203}, {"referenceID": 13, "context": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.", "startOffset": 226, "endOffset": 242}, {"referenceID": 27, "context": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.", "startOffset": 226, "endOffset": 242}, {"referenceID": 44, "context": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.", "startOffset": 226, "endOffset": 242}, {"referenceID": 51, "context": "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.", "startOffset": 226, "endOffset": 242}, {"referenceID": 65, "context": "This is a revised and extended version of the material presented in [66\u201368].", "startOffset": 68, "endOffset": 75}, {"referenceID": 66, "context": "This is a revised and extended version of the material presented in [66\u201368].", "startOffset": 68, "endOffset": 75}, {"referenceID": 67, "context": "This is a revised and extended version of the material presented in [66\u201368].", "startOffset": 68, "endOffset": 75}, {"referenceID": 14, "context": "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].", "startOffset": 160, "endOffset": 180}, {"referenceID": 15, "context": "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].", "startOffset": 160, "endOffset": 180}, {"referenceID": 34, "context": "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].", "startOffset": 160, "endOffset": 180}, {"referenceID": 43, "context": "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].", "startOffset": 160, "endOffset": 180}, {"referenceID": 53, "context": "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].", "startOffset": 160, "endOffset": 180}, {"referenceID": 25, "context": "Ontology Updates The area of research called ontology change encompasses a number of strongly related though distinguishable subareas, such as ontology matching, ontology integration and merging, or ontology translation [26].", "startOffset": 220, "endOffset": 224}, {"referenceID": 0, "context": "Approaches to ontology evolution with a firm semantic underpinning, thus amenable to a formal analysis of their behaviour and properties, are based on research in the area of belief change, initiated by the seminal work of Alchourr\u00f3n, G\u00e4rdenfors and Makinson (AGM) [1] who proposed a set of desirable properties of change operators on monotonic logics, now referred to as the AGM postulates.", "startOffset": 265, "endOffset": 268}, {"referenceID": 40, "context": "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].", "startOffset": 123, "endOffset": 135}, {"referenceID": 41, "context": "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].", "startOffset": 123, "endOffset": 135}, {"referenceID": 72, "context": "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].", "startOffset": 123, "endOffset": 135}, {"referenceID": 40, "context": "While AGM postulates were deemed appropriate for describing revision, Katsuno and Mendelzon suggested a different set of postulates for updates: the KM postulates for belief update [41].", "startOffset": 181, "endOffset": 185}, {"referenceID": 41, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 57, "endOffset": 65}, {"referenceID": 71, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 57, "endOffset": 65}, {"referenceID": 8, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 16, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 17, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 18, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 22, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 42, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 50, "context": "These ideas, and particularly Winslett\u2019s update operator [42, 72], were later used to partially address ontology updates [9, 17\u201319, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).", "startOffset": 121, "endOffset": 143}, {"referenceID": 12, "context": "On the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64].", "startOffset": 141, "endOffset": 149}, {"referenceID": 63, "context": "On the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64].", "startOffset": 141, "endOffset": 149}, {"referenceID": 12, "context": "Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].", "startOffset": 200, "endOffset": 204}, {"referenceID": 48, "context": "Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].", "startOffset": 263, "endOffset": 267}, {"referenceID": 1, "context": "Rule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to adapt belief update principles and operators to this purpose [2, 53].", "startOffset": 174, "endOffset": 181}, {"referenceID": 52, "context": "Rule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to adapt belief update principles and operators to this purpose [2, 53].", "startOffset": 174, "endOffset": 181}, {"referenceID": 47, "context": "However, such approaches proved insufficiently expressive, principally because the model-based approach fails to capture the essential relationships between literals encoded in rules [48], and the formula-based approach is too crude as it does not", "startOffset": 183, "endOffset": 187}, {"referenceID": 74, "context": "allow rules to be reactivated when reasons for their suppression disappear [75].", "startOffset": 75, "endOffset": 79}, {"referenceID": 2, "context": "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.", "startOffset": 57, "endOffset": 75}, {"referenceID": 4, "context": "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.", "startOffset": 57, "endOffset": 75}, {"referenceID": 23, "context": "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.", "startOffset": 57, "endOffset": 75}, {"referenceID": 47, "context": "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.", "startOffset": 57, "endOffset": 75}, {"referenceID": 54, "context": "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.", "startOffset": 57, "endOffset": 75}, {"referenceID": 3, "context": "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.", "startOffset": 73, "endOffset": 88}, {"referenceID": 36, "context": "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.", "startOffset": 73, "endOffset": 88}, {"referenceID": 58, "context": "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.", "startOffset": 73, "endOffset": 88}, {"referenceID": 62, "context": "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.", "startOffset": 73, "endOffset": 88}, {"referenceID": 59, "context": "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].", "startOffset": 109, "endOffset": 113}, {"referenceID": 19, "context": "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].", "startOffset": 146, "endOffset": 154}, {"referenceID": 74, "context": "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].", "startOffset": 146, "endOffset": 154}, {"referenceID": 46, "context": "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].", "startOffset": 195, "endOffset": 203}, {"referenceID": 61, "context": "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].", "startOffset": 195, "endOffset": 203}, {"referenceID": 63, "context": "It is also important for the development of update semantics for hybrid knowledge bases \u2013 in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.", "startOffset": 93, "endOffset": 101}, {"referenceID": 69, "context": "It is also important for the development of update semantics for hybrid knowledge bases \u2013 in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.", "startOffset": 93, "endOffset": 101}, {"referenceID": 68, "context": "In [69] we have shown that strong equivalence is not a suitable basis for syntax-independent rule update operators because such operators cannot respect both support and fact update.", "startOffset": 3, "endOffset": 7}, {"referenceID": 64, "context": "In [65] we proposed to view a program as the set of sets of models of its rules in order to acknowledge rules as the atomic pieces of knowledge and, at the same time, abstract away from unimportant differences between their syntactic forms, focusing on their semantic content.", "startOffset": 3, "endOffset": 7}, {"referenceID": 5, "context": "A program is non-disjunctive if all its rules are; acyclic if it satisfies the conditions set out in [6].", "startOffset": 101, "endOffset": 104}, {"referenceID": 27, "context": "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.", "startOffset": 58, "endOffset": 66}, {"referenceID": 28, "context": "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.", "startOffset": 58, "endOffset": 66}, {"referenceID": 55, "context": "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.", "startOffset": 81, "endOffset": 89}, {"referenceID": 70, "context": "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.", "startOffset": 81, "endOffset": 89}, {"referenceID": 8, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 12, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 16, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 17, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 18, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 22, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 42, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 48, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 50, "context": "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17\u201319, 23, 43, 49, 51].", "startOffset": 160, "endOffset": 190}, {"referenceID": 40, "context": "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.", "startOffset": 61, "endOffset": 77}, {"referenceID": 41, "context": "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.", "startOffset": 61, "endOffset": 77}, {"referenceID": 71, "context": "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.", "startOffset": 61, "endOffset": 77}, {"referenceID": 72, "context": "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.", "startOffset": 61, "endOffset": 77}, {"referenceID": 41, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 144, "endOffset": 152}, {"referenceID": 71, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 144, "endOffset": 152}, {"referenceID": 8, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 16, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 17, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 18, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 22, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 42, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 50, "context": "For instance, Winslett\u2019s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17\u201319, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .", "startOffset": 201, "endOffset": 223}, {"referenceID": 40, "context": "From a more general perspective, Katsuno and Mendelzon have shown [41] that if each knowledge base is represented by a single formula and incorporate(M, I) is bound to return those members ofM that are minimal w.", "startOffset": 66, "endOffset": 70}, {"referenceID": 33, "context": "Some of these postulates, and especially (B4) which guarantees syntax-independence of an update operator, continue to be seen as fundamental cornerstones of belief updates [34].", "startOffset": 172, "endOffset": 176}, {"referenceID": 9, "context": "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].", "startOffset": 55, "endOffset": 71}, {"referenceID": 10, "context": "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].", "startOffset": 55, "endOffset": 71}, {"referenceID": 21, "context": "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].", "startOffset": 55, "endOffset": 71}, {"referenceID": 33, "context": "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].", "startOffset": 55, "endOffset": 71}, {"referenceID": 33, "context": "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].", "startOffset": 313, "endOffset": 317}, {"referenceID": 33, "context": "2) [34].", "startOffset": 3, "endOffset": 7}, {"referenceID": 72, "context": "Earlier approaches to updates, dubbed formula-based [73], operate on the syntax of a knowledge base and, as a consequence, are not syntax-independent.", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "Nevertheless, they have recently been considered for performing ontology updates [13, 49].", "startOffset": 81, "endOffset": 89}, {"referenceID": 48, "context": "Nevertheless, they have recently been considered for performing ontology updates [13, 49].", "startOffset": 81, "endOffset": 89}, {"referenceID": 24, "context": "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].", "startOffset": 63, "endOffset": 67}, {"referenceID": 29, "context": "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].", "startOffset": 106, "endOffset": 118}, {"referenceID": 30, "context": "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].", "startOffset": 106, "endOffset": 118}, {"referenceID": 72, "context": "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].", "startOffset": 106, "endOffset": 118}, {"referenceID": 29, "context": "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].", "startOffset": 137, "endOffset": 141}, {"referenceID": 12, "context": "Additionally, in [13] the new formula-based operator Bold was suggested for performing TBox updates.", "startOffset": 17, "endOffset": 21}, {"referenceID": 6, "context": "In the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.", "startOffset": 31, "endOffset": 38}, {"referenceID": 20, "context": "In the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.", "startOffset": 31, "endOffset": 38}, {"referenceID": 2, "context": "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].", "startOffset": 133, "endOffset": 151}, {"referenceID": 4, "context": "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].", "startOffset": 133, "endOffset": 151}, {"referenceID": 23, "context": "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].", "startOffset": 133, "endOffset": 151}, {"referenceID": 47, "context": "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].", "startOffset": 133, "endOffset": 151}, {"referenceID": 54, "context": "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].", "startOffset": 133, "endOffset": 151}, {"referenceID": 4, "context": "The final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36].", "startOffset": 131, "endOffset": 138}, {"referenceID": 35, "context": "The final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36].", "startOffset": 131, "endOffset": 138}, {"referenceID": 47, "context": "Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].", "startOffset": 126, "endOffset": 130}, {"referenceID": 23, "context": "Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].", "startOffset": 152, "endOffset": 156}, {"referenceID": 47, "context": "Definition 3 (JU-Semantics [48] and UA-Semantics [24]).", "startOffset": 27, "endOffset": 31}, {"referenceID": 23, "context": "Definition 3 (JU-Semantics [48] and UA-Semantics [24]).", "startOffset": 49, "endOffset": 53}, {"referenceID": 23, "context": "The only difference in the UA-semantics [24] is that rejected rules are prevented from rejecting other rules.", "startOffset": 40, "endOffset": 44}, {"referenceID": 49, "context": "This gives rise to the notion of strong equivalence [50] which requires that stable models stay the same even in the presence of additional rules.", "startOffset": 52, "endOffset": 56}, {"referenceID": 70, "context": "It is a well-known fact that programs are strongly equivalent if and only if they have the same set of SE-models [71].", "startOffset": 113, "endOffset": 117}, {"referenceID": 68, "context": "But even SE-equivalence is not satisfactory when used as a basis for syntax-independent rule update operators because such operators cannot respect both support and fact update [69].", "startOffset": 177, "endOffset": 181}, {"referenceID": 38, "context": "One candidate is the strong update equivalence (or SU-equivalence) [39], which requires that under both additions and removals of rules, stable models of the two programs in question remain the same.", "startOffset": 67, "endOffset": 71}, {"referenceID": 38, "context": "It has been shown in [39] that this notion of equivalence is very strong \u2013 programs are SU-equivalent only if they contain exactly the same non-tautological rules, and in addition, each of them may contain some tautological ones.", "startOffset": 21, "endOffset": 25}, {"referenceID": 64, "context": "This observation resulted in the definition of strong rule equivalence (or SR-equivalence) and strong minimal rule equivalence (or SMR-equivalence) in [65] that, in terms of strength, fall between SE-equivalence and SU-equivalence.", "startOffset": 151, "endOffset": 155}, {"referenceID": 64, "context": "Proposition 5 ([65]).", "startOffset": 15, "endOffset": 19}, {"referenceID": 64, "context": "In [65] we studied the expressivity of SE-models with respect to a single rule.", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].", "startOffset": 111, "endOffset": 123}, {"referenceID": 37, "context": "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].", "startOffset": 111, "endOffset": 123}, {"referenceID": 39, "context": "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].", "startOffset": 111, "endOffset": 123}, {"referenceID": 2, "context": "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.", "startOffset": 75, "endOffset": 93}, {"referenceID": 4, "context": "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.", "startOffset": 75, "endOffset": 93}, {"referenceID": 23, "context": "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.", "startOffset": 75, "endOffset": 93}, {"referenceID": 47, "context": "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.", "startOffset": 75, "endOffset": 93}, {"referenceID": 54, "context": "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.", "startOffset": 75, "endOffset": 93}, {"referenceID": 64, "context": "Further properties of RE-models, analogous to those established in [65] for SE-models, can be found in Appendix A starting on page 31.", "startOffset": 67, "endOffset": 71}, {"referenceID": 68, "context": "This means that \u03b4a-based rule update operators enjoy a combination of desirable syntactic properties that operators based on SE-models cannot [69].", "startOffset": 142, "endOffset": 146}, {"referenceID": 4, "context": "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].", "startOffset": 111, "endOffset": 122}, {"referenceID": 19, "context": "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].", "startOffset": 111, "endOffset": 122}, {"referenceID": 23, "context": "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].", "startOffset": 111, "endOffset": 122}, {"referenceID": 2, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 19, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 23, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 47, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 54, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 59, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 74, "context": "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 142, "endOffset": 169}, {"referenceID": 33, "context": "Note also that (B7) has been heavily criticised in the literature as being mainly a means to achieve formal results instead of an intuitive principle [34] and though (B8) reflects the basic intuition behind belief update \u2013 that of updating each model independently of the others \u2013 such a point of view is hardly transferable to knowledge represented using rules because a single model, be it a classical, stable, SE- or RE-model, fails to encode the interdependencies between literals expressed in rules that are necessary for properties such as support.", "startOffset": 150, "endOffset": 154}, {"referenceID": 33, "context": ">) [34].", "startOffset": 3, "endOffset": 7}, {"referenceID": 33, "context": ">) [34].", "startOffset": 3, "endOffset": 7}, {"referenceID": 68, "context": "[69] and the above discussion of (Idempotence), (Absorption) and (Augmentation)).", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 19, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 23, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 47, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 54, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 59, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 74, "context": ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].", "startOffset": 115, "endOffset": 142}, {"referenceID": 9, "context": "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].", "startOffset": 142, "endOffset": 158}, {"referenceID": 10, "context": "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].", "startOffset": 142, "endOffset": 158}, {"referenceID": 21, "context": "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].", "startOffset": 142, "endOffset": 158}, {"referenceID": 33, "context": "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].", "startOffset": 142, "endOffset": 158}, {"referenceID": 2, "context": "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.", "startOffset": 50, "endOffset": 68}, {"referenceID": 4, "context": "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.", "startOffset": 50, "endOffset": 68}, {"referenceID": 23, "context": "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.", "startOffset": 50, "endOffset": 68}, {"referenceID": 47, "context": "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.", "startOffset": 50, "endOffset": 68}, {"referenceID": 54, "context": "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.", "startOffset": 50, "endOffset": 68}, {"referenceID": 59, "context": "A different approach in [60] deals with program updates by borrowing ideas from literature on belief revision and utilising an abductive framework to accomplish such updates.", "startOffset": 24, "endOffset": 28}, {"referenceID": 74, "context": "A somewhat similar situation occurs with the approach of [75] where intricate syntactic transformations are combined with a semantics for prioritised logic programs that ultimately leads to a set of logic programs.", "startOffset": 57, "endOffset": 61}, {"referenceID": 19, "context": "The rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof).", "startOffset": 39, "endOffset": 43}, {"referenceID": 74, "context": "The rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof).", "startOffset": 160, "endOffset": 164}, {"referenceID": 45, "context": "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and", "startOffset": 118, "endOffset": 130}, {"referenceID": 60, "context": "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and", "startOffset": 118, "endOffset": 130}, {"referenceID": 61, "context": "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and", "startOffset": 118, "endOffset": 130}, {"referenceID": 70, "context": "First we define simple and elegant operators on subclasses of nested logic programs [71] with the required property.", "startOffset": 84, "endOffset": 88}, {"referenceID": 70, "context": "We adopt the syntax and stable model semantics of logic programs with nested expressions [71].", "startOffset": 89, "endOffset": 93}, {"referenceID": 54, "context": "Interestingly, an operator very similar to \u2295JU has been studied by Osorio and Cuevas [55].", "startOffset": 85, "endOffset": 89}, {"referenceID": 37, "context": "Furthermore, when H\u03c0 is a default literal, it is more convenient to move the new default literals from the head into the body since this operation preserves stable models [38] and makes it easier to pinpoint the original head literal in the rule.", "startOffset": 171, "endOffset": 175}, {"referenceID": 23, "context": "Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details).", "startOffset": 175, "endOffset": 183}, {"referenceID": 47, "context": "Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details).", "startOffset": 175, "endOffset": 183}, {"referenceID": 33, "context": "1) and (B4) [34].", "startOffset": 12, "endOffset": 16}, {"referenceID": 32, "context": "The typical properties satisfied by AGM revision operators include success, inclusion and extensionality [33], formalised, respectively, as", "startOffset": 105, "endOffset": 109}, {"referenceID": 48, "context": "Note also that the operator adopted for ABox updates in [49], inspired by WIDTIO, performs a deductive closure of the ABox before updating it, so it corresponds to the standard full meet AGM revision operator.", "startOffset": 56, "endOffset": 60}, {"referenceID": 29, "context": "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.", "startOffset": 20, "endOffset": 32}, {"referenceID": 30, "context": "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.", "startOffset": 20, "endOffset": 32}, {"referenceID": 72, "context": "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.", "startOffset": 20, "endOffset": 32}, {"referenceID": 12, "context": "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.", "startOffset": 98, "endOffset": 102}, {"referenceID": 29, "context": "The Cross-Product operator [30] satisfies (F1) (thus also (B1)), (B2.", "startOffset": 27, "endOffset": 31}, {"referenceID": 26, "context": "1) and (F4) are closely related with the properties of base revision operators [27, 33].", "startOffset": 79, "endOffset": 87}, {"referenceID": 32, "context": "1) and (F4) are closely related with the properties of base revision operators [27, 33].", "startOffset": 79, "endOffset": 87}, {"referenceID": 32, "context": "In particular, two types of base revision are identified in [33], the internal and external base revision.", "startOffset": 60, "endOffset": 64}, {"referenceID": 12, "context": "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett\u2019s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].", "startOffset": 248, "endOffset": 264}, {"referenceID": 18, "context": "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett\u2019s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].", "startOffset": 248, "endOffset": 264}, {"referenceID": 48, "context": "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett\u2019s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].", "startOffset": 248, "endOffset": 264}, {"referenceID": 50, "context": "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett\u2019s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].", "startOffset": 248, "endOffset": 264}, {"referenceID": 72, "context": "The Cross-Product operator can be captured when a single update is performed and the same can be said about the Set-Of-Theories operator since for a single update it is equivalent to the Cross-Product operator [73].", "startOffset": 210, "endOffset": 214}, {"referenceID": 4, "context": "due to the need to detect non-tautological irrelevant updates [5, 61, 62].", "startOffset": 62, "endOffset": 73}, {"referenceID": 60, "context": "due to the need to detect non-tautological irrelevant updates [5, 61, 62].", "startOffset": 62, "endOffset": 73}, {"referenceID": 61, "context": "due to the need to detect non-tautological irrelevant updates [5, 61, 62].", "startOffset": 62, "endOffset": 73}, {"referenceID": 73, "context": "In this context, the close relationship between RE-models and T-models [74], used in the context of forgetting in logic programs, asks for more attention as well.", "startOffset": 71, "endOffset": 75}, {"referenceID": 31, "context": "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].", "startOffset": 122, "endOffset": 134}, {"referenceID": 56, "context": "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].", "startOffset": 122, "endOffset": 134}, {"referenceID": 57, "context": "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].", "startOffset": 122, "endOffset": 134}, {"referenceID": 12, "context": "This seems relevant even in the context of ontology updates since it has been argued in the literature that the strict distinction between revision and update is not suitable in the context of ontologies [13].", "startOffset": 204, "endOffset": 208}, {"referenceID": 64, "context": "We begin by defining a set of representatives of rule equivalence classes induced by SE-models, as it was introduced in [65] since it is needed in our proofs.", "startOffset": 120, "endOffset": 124}, {"referenceID": 64, "context": "Definition 38 (Transformation into an SE-Canonical Rule [65]).", "startOffset": 56, "endOffset": 60}, {"referenceID": 64, "context": "Proposition 39 ([65]).", "startOffset": 16, "endOffset": 20}, {"referenceID": 64, "context": "Corollary 40 ([65]).", "startOffset": 14, "endOffset": 18}, {"referenceID": 64, "context": "The following presentation follows a similar pattern as the one used in [65] for SE-models.", "startOffset": 72, "endOffset": 76}, {"referenceID": 33, "context": "2) has also been subject of harsh criticism in belief update literature [34].", "startOffset": 72, "endOffset": 76}, {"referenceID": 49, "context": "Definition 108 (Strong Equivalence [50]).", "startOffset": 35, "endOffset": 39}, {"referenceID": 49, "context": "Proposition 109 ([50, 71]).", "startOffset": 17, "endOffset": 25}, {"referenceID": 70, "context": "Proposition 109 ([50, 71]).", "startOffset": 17, "endOffset": 25}], "year": 2017, "abstractText": "Existing methods for dealing with knowledge updates differ greatly depending on the underlying knowledge representation formalism. When Classical Logic is used, updates are typically performed by manipulating the knowledge base on the model-theoretic level. On the opposite side of the spectrum stand the semantics for updating Answer-Set Programs that need to rely on rule syntax. Yet, a unifying perspective that could embrace both these branches of research is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their cross-fertilisation, ripening and further development. Furthermore, from a more pragmatic viewpoint, such a unification is a necessary step in addressing updates of hybrid knowledge bases consisting of both a classical and a rule component. This paper bridges the seemingly irreconcilable approaches to updates. It introduces a novel monotonic characterisation of rules, dubbed RE-models, and shows it to be a more suitable semantic foundation for rule updates than SE-models. Then it proposes a generic scheme for specifying semantic rule update operators, based on the idea of viewing a program as the set of sets of RE-models of its rules; updates are performed by introducing additional interpretations \u2013 exceptions \u2013 to the sets of RE-models of rules in the original program. The introduced scheme is then used to define particular rule update operators that are closely related to both classical update principles and traditional approaches to rules updates, enjoying a range of plausible syntactic as well as semantic properties. In addition, these operators serve as a basis for a solution to the long-standing problem of state condensing for two of the foundational rule update semantics, showing how they can be equivalently defined as binary operators on some class of logic programs. Finally, the essence of these ideas is extracted to define an abstract framework for exception-based update operators, viewing a knowledge base as the set of sets of models of its elements. It is shown that the framework can capture a wide range of both modeland formula-based classical update operators, and thus serves as the first firm formal ground connecting classical and rule updates.", "creator": "LaTeX with hyperref package"}}}