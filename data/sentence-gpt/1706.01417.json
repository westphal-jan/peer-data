{"id": "1706.01417", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Jun-2017", "title": "A method for the online construction of the set of states of a Markov Decision Process using Answer Set Programming", "abstract": "Non-stationary domains, that change in unpredicted ways, are a challenge for agents searching for optimal policies in sequential decision-making problems. This paper presents a combination of Markov Decision Processes (MDP) with Answer Set Programming (ASP), named {\\em Online ASP for MDP} (oASP(MDP)), which is a method capable of constructing the set of domain states while the agent interacts with a changing environment. oASP(MDP) updates previously obtained policies, learnt by means of Reinforcement Learning (RL), using rules that represent the domain changes observed by the agent. These rules represent a set of domain constraints that are processed as ASP programs reducing the search space. Results show that oASP(MDP) is capable of finding solutions for problems in non-stationary domains without interfering with the action-value function approximation process. However, the observed problems can be resolved through an optimization procedure known as ML. It is thought that ML is well-known for solving some problems by implementing simple ML algorithms.\n\n\n\nThe study shows that the number of issues that a human agent can solve in ML is determined by a given number of possible problems. This means that it is possible to efficiently perform the evaluation of the target domain conditions, thereby avoiding the problem of the agent being affected by these problems. This is known to be an especially helpful way to determine the effectiveness of an agent's performance by solving the target domain conditions in relation to its behavior. This is known to be an especially helpful way to determine the effectiveness of an agent's performance by solving the target domain conditions in relation to its behavior.\n\nSince ML can be used in many areas as well as in many other domains as a part of the AI world, it is essential to ensure that the agent performs most of the tasks that are involved. The objective of the model is to show that the agent performs most of the tasks that are involved in the AI world (e.g., avoiding the problem of the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by the agent being affected by", "histories": [["v1", "Mon, 5 Jun 2017 16:48:23 GMT  (612kb,D)", "http://arxiv.org/abs/1706.01417v1", "Submitted to IJCAI 17"]], "COMMENTS": "Submitted to IJCAI 17", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["leonardo a ferreira", "reinaldo a c bianchi", "paulo e santos", "ramon lopez de mantaras"], "accepted": false, "id": "1706.01417"}, "pdf": {"name": "1706.01417.pdf", "metadata": {"source": "CRF", "title": "A method for the online construction of the set of states of a Markov Decision Process using Answer Set Programming", "authors": ["Leonardo A. Ferreira", "Reinaldo A. C. Bianchi", "Paulo E. Santos", "Ramon Lopez de Mantaras", "Bernardo do Campo"], "emails": ["leonardo.ferreira@metodista.br,", "rbianchi@fei.edu.br,", "psantos@fei.edu.br,", "mantaras@iiia.csic.es"], "sections": [{"heading": "1 Introduction", "text": "A key issue in Artificial Intelligence (AI) is to equip autonomous agents with the ability to operate in changing domains by adapting the agents\u2019 processes at a cost that is equivalent to the complexity of the domain changes. This ability is called elaboration tolerance [McCarthy, 1987; McCarthy, 1998]. Consider, for instance, an autonomous robot learning to navigate in an unknown environment. Unforeseen events may happen that could block passages (or open previously unavailable ones). The autonomous agent should be able to find new solutions in this changed domain using the knowledge previously acquired plus the knowledge acquired from the observed changes in the environment, without having to operate a complete code-rewriting, or start a new cycle of domain-exploration from scratch.\nReinforcement Learning (RL) is an AI framework in which an agent interacts with its environment in order to find a sequence of actions (a policy) to perform a given task [Sutton and Barto, 2015]. RL is capable of finding optimal solutions to Markov Decision Processes (MDP) without assuming total information about the problem\u2019s domain. However, in spite of having the optimal solution to a particu-\nlar task, a RL agent may still perform poorly on a new task, even if the latter is similar to the former [Garnelo et al., 2016]. Therefore, Reinforcement Learning alone does not provide elaboration-tolerant solutions. Non-monotonic reasoning can be used as a tool to increase the generality of domain representations [McCarthy, 1987] and may provide the appropriate element to build agents more adaptable to changing situations. In this work we consider Answer Set Programming (ASP) [Gelfond and Lifschitz, 1988; Lifschitz, 2002], which is a declarative non-monotonic logic programming language, to bridge the gap between RL and elaboration tolerant solutions. The present paper tackles this problem by introducing a novel algorithm: Online ASP for MDP (oASP(MDP)), that updates previously obtained policies, learned by means of Reinforcement Learning (RL), using rules that represent the domain changes as observed by the agent. These rules are constructed by the agent in an online fashion (i.e., as the agent perceives the changes) and they impose constraints on the domain states that are further processed by an ASP engine, reducing the search space. Tests performed in non-stationary non-deterministic grid worlds show that, not only oASP(MDP) is capable of finding the action-value function for an RL agent and, consequently, the optimal solution, but also that using ASP does not hinder the performance of a learning agent and can improve the overall agent\u2019s performance.\nTo model an oASP(MDP) learning agent (Section 3), we propose the combination of Markov Decision Processes and Reinforcement Learning (Section 2.1) with ASP (Section 2.2). Tests were performed in two different nonstationary non-deterministic grid worlds (Section 4), whose results show a considerable increase in the agent\u2019s performances when compared with a RL base algorithm, as presented in Sections 4.1 and 4.2."}, {"heading": "2 Background", "text": "This section introduces Markov Decision Processes (MDP), Reinforcement Learning (RL) and Answer Set Programming (ASP) that are the foundations of the work reported in this paper."}, {"heading": "2.1 MDP and Reinforcement Learning", "text": "In a sequential decision making problem, an agent is required to execute a series of actions in an environment in order to\nar X\niv :1\n70 6.\n01 41\n7v 1\n[ cs\n.A I]\n5 J\nun 2\n01 7\nfind the solution of a given problem. Such sequence of actions, that forms a feasible solution, is known as a policy (\u03c0) which leads the agent from an initial state to a goal state [Bellman, 1957; Bellman and Dreyfus, 1971]. Given a set of feasible solutions, an optimal policy \u03c0\u2217 can be found by using Bellman\u2019s Principle of Optimality [Bellman and Dreyfus, 1971], which states that \u201can optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision\u201d; \u03c0\u2217 can be defined as the policy that maximises/minimises a desired reward/cost function.\nA formalisation that can be used to describe sequential decision making problems is a Markov Decision Process (MDP) that is defined as a tuple \u3008S,A, T ,R\u3009, where: \u2022 S is the set of states that can be observed in the domain; \u2022 A is the set of actions that the agent can execute; \u2022 T : S \u00d7 A \u00d7 S 7\u2192 [0, 1] is the transition function that\nprovides the probability of, being in s \u2208 S and executing a \u2208 A, reaching the future state s\u2032 \u2208 S; \u2022 R : S\u00d7A\u00d7S 7\u2192 R is the reward function that provides\na real number when executing a \u2208 A in the state s \u2208 S and observing s\u2032 \u2208 S as the future state.\nOne method that can be used to find an optimal policy for MDPs, which does not need a priori knowledge of the transition and reward functions, is the reinforcement learning model-free off-policy method known as QLearning [Watkins, 1989; Sutton and Barto, 2015].\nGiven an MDP M, Q-Learning learns while an agent interacts with its environment by executing an action at in the current state st and observing both the future state st+1 and the reward rt+1. With these observations, Q-Learning updates an action-value function Q(s, a) using\nQ(st, at)\u2190 Q(st, at)+\u03b1.(rt+1+\u03b3.max a Q(st+1, a)\u2212Q(st, at)),\nwhere \u03b1 is the learning rate and \u03b3 is a discount factor. By using these reward values to approximate aQ(s, a) function that maps a real value to pairs of states and actions, Q-Learning is capable of finding \u03c0\u2217 which maximises the reward function. Since Q-Learning is a well-known and largely used RL method, we omit its detailed description here, which can be found in [Watkins, 1989; Sutton and Barto, 2015].\nAlthough Q-Learning does not need information about T andR, it still needs to know the set S of states before starting the interaction with the environment. For finding this set, this work uses Answer Set Programming."}, {"heading": "2.2 Answer Set Programming", "text": "Answer Set Programming (ASP) is a declarative nonmonotonic logic programming language that has been successfully used for NP-complete problems such as planning [Lifschitz, 2002; Zhang et al., 2015; Yang et al., 2014].\nAn ASP rule is represented as\nA\u2190 L1, L2, . . . , Ln (1)\nwhere A is an atom (the head of the rule) and the conjunction of literals L1, L2, . . . , Ln is the rule\u2019s body.\nAn ASP program \u03a0 is a set of rules in the form of Formula 1. ASP is based on the stable model semantics of logic programs [Gelfond, 2008]. A stable model of \u03a0 is an interpretation that makes every rule in \u03a0 true, and is a minimal model of \u03a0. ASP programs are executed by computing stable models, which is usually accomplished by inference engines called answer set solvers [Gelfond, 2008].\nTwo important aspects of ASP are its third truth value for unkown, along with true and false, and its two types of negation: strong (or classical) negation and weak negation, representing negation as failure. As it is defined over stable models semantics, ASP respects the rationality that one shall not believe anything one is not forced to believe [Gelfond and Lifschitz, 1988].\nAlthough ASP does not allow explicit reasoning with or about probabilities, ASP\u2019s choice rules are capable of generating distinct outcomes for the same input. I.e., given a current state s and an action a, it is possible to describe in an ASP logic program states s1, s2 and s3 as possible outcomes of executing a in s as \u201c1{ s1, s2, s3 }1 :- a, s.\u201d. Such choice rules can be read as \u201cgiven that s and a are true, choose at least one and at maximum of one state from s1, s2 and s3\u201d. Thus, the answer sets [s, a, s1], [s, a, s2] and [s, a, s3] represent the possible transitions that are the effects of executing action a on state s.\nThis work assumes that for each state s \u2208 S there is an ASP logic program with choice rules describing the consequences of each action a \u2208 As (where As \u2286 A is the set of actions for the state s). ASP programs can also be used to represent domain constraints: the allowed or forbidden states or actions. In this context, to find a set S of an MDP and its Q(s, a) function is to find every answer set for every state that the agent is allowed to visit, i.e. every allowed transition for each state-action pair. In this paper ASP is used to find the set of states S of an MDP and Q-Learning is used to approximate Q(s, a) without assuming prior knowledge of T and R. The next section describes this idea in more details."}, {"heading": "3 Online ASP for MDP: oASP(MDP)", "text": "Given sets S and A of an MDP, a RL method M can approximate an action-value function Q(s, a). If S is constructed state by state while the agent is interacting with the world, M is still able to approximate Q(s, a), as it only uses the current and past states for that. By using choice rules in ASP, it is possible to describe a transition t(s, a, s\u2032) in the form 1{s\u2019}1 :- a for each action a \u2208 As and each state s \u2208 S. By describing possible transitions for each action in each state as a logic program, an ASP engine can be used to provide a set of observed states So, a set of actions As for each state and, finally, an action-value function defined from the interaction with the environment, that can be used to further operate in this environment. This is the essence of the oASP(MDP) method, represented in Algorithm 1.\nIn order to illustrate oASP(MDP) (Algorithm 1), let\u2019s consider the grid world in Figure 1, and an oASP(MDP) agent, initially located at the state \u201cS\u201d (blue cell in the grid), that is capable of executing any action in the following set: A ={\n1 Algorithm: oASP(MDP)\nInput: The set of actions A, an action-value function approximation method M and a number of episodes n.\nOutput: The approximated Q(s, a) function. 2 Initialize the set of observed states So = \u2205 3 while number of episodes performed is less than n do 4 repeat 5 Observe the current state s 6 if s 6\u2208 So then 7 Add s to the set of states So. 8 Choose and execute a random action a \u2208 A. 9 Observe the future state s\u2032.\n10 Update state s logic program with observed transition adding a choice rule. 11 Update Q(s, a)\u2019s description by finding every answer set for each state s added to So in this episode. 12 else 13 Choose an action a \u2208 A as defined by M . 14 Execute the chosen action a. 15 Observe the future state s\u2032."}, {"heading": "16 end", "text": "17 Update Q(s, a)\u2019s value as defined by M . 18 Update the current state s\u2190 s\u2032. 19 until the end of the episode"}, {"heading": "20 end", "text": "Algorithm 1: The oASP(MDP) Algorithm.\ngo up, go down, go left, go right}. This grid world has walls (represented by the letter \u201cW\u201d), that are cells where the agent cannot occupy and through which it is unable to pass. If an agent moves toward a wall (or toward an external border of the grid) it stays at its original location. When the interaction with the environment starts, the agent has only information about the set of actions A. The set of observed states So is initially empty.\nAt the beginning of the agent\u2019s interactions with the environment, the agent observes the initial state s0 and verifies if it is in So. Since s0 6\u2208 So, the agent adds s0 to So (line 7 of Algorithm 1) and executes a random action, let this action be go up. As a consequence of this choice, the agent moves to a new state s1 (the cell above S) and receives a reward r0. At this moment, the agent has information about the previous state, allowing it to write the choice rule \u201c1{s1}1 : \u2212 s0, go up\u201d as an ASP logic program. In this first interaction, the only answer set that can be found for this choice rule is \u201c[s0, go up, s1]\u201d. With this information the agent can initialize a Q(s0, go up) and update this value using the reward r0 (line 17).\nAfter this first interaction, the agent is in the state s1 (the cell above S). Again, this is an unknown state (s1 6\u2208 So), thus, as with the previous state, the agent adds s1 to So, chooses a random action, let it be go up again, and executes this action in the environment. By performing go up in this state, the agent hits a wall and stays in the same state. With\nthis observation, the agent writes the choice rule \u201c1{s1}1 : \u2212 s1, go up\u201d and updates the value of Q(s1, go up) using the received reward r1.\nSince the agent is in the same state as in the previous interaction, it knows the consequence of the action go up in this state, but has no information about any other actions for this state. At this moment, the agent selects an action using the action-selection function defined by the learning method M and executes it in the environment. For example, let it choose go down, returning to the blue cell (S). The state s1 has now two choice rules: \u201c1{s1}1 : \u2212 s1, go up\u201d and \u201c1{s0}1 : \u2212 s1, go down\u201d which lead to the answer sets \u201c[s1, go up]\u201d and \u201c[s1, go down, s0]\u201d respectively. Once again, the agent updates the Q(s1, go up) function using the method described in M with the reward r2 received. After this transition, the agent finds itself once again in the initial state and continues the domain exploration just described. If, for example, the agent chooses to execute the action go up again, but due to the non-deterministic nature of the environment, the agent goes to the state on the right of the blue square, then a new state s2 is observed and the choice rule for the previous state is updated to \u201c1{s1, s2}1 : \u2212 s0, go up\u201d. The answer sets that can be found considering this choice rule are \u201c[s0, go up, s1]\u201d and \u201c[s0, go up, s2]\u201d. With the reward r3 received, the agent updates the value of Q(s0, go up).\nThe learning process of oASP(MDP) continues according to the chosen action-value function approximation method (from line 12 onwards). After a number of interactions with the environment, the oASP(MDP) agent has executed every possible action in every state that is possible to be visited and has the complete environment description. Note that this method excludes states of the MDP that are unreachable by the agent, which improves the efficiency of a RL agent in cases that the environment imposes state constrains (as we shall see in the next section).\nThe next section presents the tests applied to evaluate oASP(MDP) implemented with Q-Learning as the actionvalue function approximation method M ."}, {"heading": "4 Tests and Results", "text": "The oASP(MDP) algorithm was evaluated with tests performed in non-deterministic, non-stationary, grid-world domains. Two test sets were considered where, in each set, one\nof the following domain variables was randomly changed: the number and location of walls in the grid (first test, Section 4.1), and the transition probabilities (second test, Section 4.2).\nFour actions were allowed in the test domains considered in this work: go up, go down, go left and go right. Each action has a predefined probability of conducting the agent in the desired direction and also for moving the agent to an orthogonal (undesired) location. The transition probability for each action depends on the grid world and will be defined for each test, as described below. In all tests, the initial state was fixed at the lower-leftmost square (e.g., cell \u2018S\u2019 in Fig. 1) and the goal state fixed in the upper-rightmost square (e.g., cell \u2018G\u2019 in Fig. 1).\nIn the test domains, walls were distributed randomly in the grid as obstacles. For each grid, the ratio of walls per grid size is defined. The initial and goal states are the only cells that do not accept obstacles. Wall\u2019s placement in the grid changed at the 1000th and 2000th episodes during each test trial. An example of a grid used in this work is shown in Figure 1.\nResults show the data obtained from executing Q-Learning and oASP(MDP) (with Q-Learning as the action-value function approximation method) in the same environment configuration. The values used for the learning variables were: learning rate \u03b1 = 0.2, discount factor \u03b3 = 0.9, exploration/exploitation rate for the -greedy action selection method: = 0.1 and the maximum number of steps before an episode is finished was 1000.\nIn each test, three variables were used to compare QLearning and oASP(MDP). First, the root-mean-square deviation (RMSD), that provides information related to the convergence of the methods by comparing values of the Q(s, a) function in the current episode with respect to that obtained in the previous episode. Second, we considered the return (sum of the rewards) received in an episode. Third, the number of steps needed to go from the initial state to the goal state was evaluated. The results obtained were also compared with that of an agent using the optimal policy in a deterministic grid world (the best performance possible, shown as a red-dashed line in the results below).\nFor oASP(MDP), the number of state-action pairs known by the agent was also measured and compared with the size of Q-Learing\u2019s fixed Q(s, a) tabular implementation. This variable provides information of how far an oASP(MDP) agent is from knowing the complete environment along with how much the Q(s, a) function could be reduced.\nThe test domains and related results are described in details in the next sections."}, {"heading": "4.1 First test: changes in the wall\u2013free-space ratio", "text": "In the first test, the size of the grid was fixed to 10\u00d710 and the transition probabilities were assigned at 90% for moving on the desired direction and 5% for moving in each of the two directions that are orthogonal to the desired. In this test, changes in the environment occurred in the number and location of walls in the grid. Initially the domain starts with no walls (0%), then it changes to a world where 10% of the grid is occupied by walls placed at random locations and, finally,\nthe grid world changes to a situation where 25% of the grid is occupied by walls. Each change occurs after 1000 episodes.\nThe results obtained in the first test are represented in Figure 2. Figure 2a shows that the RMSD values of oASP(MDP) decrease faster than those of Q-Learning, thus converging to the optimal policy ahead of Q-Learning. It is worth observing that when a change occurs in the environment (at episodes 1000 and at 2000) there is no increase in oASP(MDP) RMSD values, contrasting with the significant increase in Q-Learning\u2019s values. A similar behaviour is shown in Figure 2c, where there is no change in the number of steps of oASP(MDP) after a change occurs, at the same time that Qlearning number of steps increase considerably at that point.\nThe return values obtained in this test are shown in Figure 2b, where it can be observed that both oASP(MDP) and Q-learning reach the maximum value together during the initial episodes, but there is no reduction in the return values of oASP(MDP) when the environment changes, whereas Qlearning returns drop to the initial figures.\nFigure 2d shows the number of state-action pairs that oASP(MDP) has found for the grid world. Values obtained after the 15th episode were omitted since they presented no variation. This figure shows that oASP(MDP) has explored every state of the grid world and performed every action allowed in each state, resulting in a complete description of the environment. Since oASP(MDP) has provided the complete description of the environment, the agent that uses oASP(MDP) optimizes the same action-value function as the agent that uses Q-Learning, thus the optimal policy found by both agents is the same. Due to the exploration of the environment performed in the beginning of the interaction, before the 10th episode the agent has executed every action in every possible state at least once and, as can be seen in line 7 of Algorithm 1, the agent then uses the underlying RL procedure to find the action-value function."}, {"heading": "4.2 Second test: changes in the transition probabilities", "text": "In this test, the grid was fixed at a 10\u00d710 size, with wall\u2013 free-space ratio fixed at 25%. Changes in the environment occurred with respect to the transition probabilities. Initially, the agent\u2019s actions had 50% of probability for moving the agent in the desired direction and 25% for moving it in each of the two orthogonal directions. The first change set the probabilities at 75% (assigned to the desired action effect) and 12.5% (for the directions orthogonal to the desired). The final change assigned 90% for moving in the desired direction and 5% for moving in each of the orthogonal directions.\nThe RMSD values for oASP(MDP), in this case, decreased faster than those of Q-Learning, reaching zero before the first change occurred, while Q-Learning at that point had not yet converged, as shown in Figure 3a. Analogously to the first test, there is no change in RMSD values of oASP(MDP) when the environment changes, whereas Q-learning presents re-initializations. In the results on return and the number of steps, shown in Figures 3b and 3c respectively, the performance of oASP(MDP) improves faster than the Q-Learning performance when there is a change in the environment. This is explained by the fact that, after oASP(MDP) approxi-\nmates the action-value function (in the periods between the changes), when a change occurs, the information about it, acquired by the agent, is used to find solutions in the new world situation. In this case, the current action-value function is simply updated. Q-Learning, on the other hand, is restarted at each time a change occurs, resulting in the application of an inefficient policy in the new environment.\nThe number of state-action pairs that oASP(MDP) was able to describe is shown in Figure 3d. Once more, values obtained after the 15th episode were omitted, as they present no variation after this point. Analogous to the results obtained in the first experiment, oASP(MDP) was capable of executing at least once every allowed action in every state possible to be visited. As before, by exploring the environment oASP(MDP) could efficiently find the set of allowed states, defining the complete Q(s, a).\nIn summary, the tests performed in the domains considered show that the information previously obtained is beneficial to an agent that learns by interacting with a changing environment. The action-value function obtained by oASP(MDP) before a change occurs accelerates the approximation of this function in a new version of the environment, avoiding the various re-initializations observed in Q-learning alone (as shown in Figures 2 and 3). However, as the action-value function approximation method used in oASP(MDP) (in this work) was Q-Learning, the policies learnt by oASP(MDP) and Q-Learning alone were analogous. This can be observed when comparing the curves for oASP(MDP) and Q-Learning in Figures 2 and 3 after convergence, noticing also that they keep the same distance with respect to the best performance possible (red-dashed lines in the graphs).\nTests were performed in virtual machines in AWS EC2 with t2.micro configuration, which provides one virtual core of an Intel Xeon at 2.4GHz, 1GB of RAM and 8GB of SSD with standard Debian 8 (Jessie). oASP(MDP) was implemented in Python 3.4 using ZeroMQ for providing messages exchanges between agent and environment and Clingo [Gebser et al., 2013] was used as the ASP Engine. The source code for the tests can be found in the following (anonymous) URL: http://bit.ly/2k03lkl."}, {"heading": "5 Related Work", "text": "Previous attempts at combining RL with ASP include [Zhang et al., 2015], which proposes the use of ASP to find a predefined plan for a RL agent. This plan is described as a hierarchical MDP and RL is used to find the optimal policy for this MDP. However, changes in the environment, as used in the present work, were not considered in [Zhang et al., 2015].\nAnalogous methods were proposed by [Khandelwal et al., 2014; Yang et al., 2014], in which an agent interacts with an environment and updates an action\u2019s cost function. While [Khandelwal et al., 2014] uses the action language BC, [Yang et al., 2014] uses ASP to find a description of the environment. Although both methods consider action costs, none of them uses Reinforcement Learning and they do not deal with changes in the action-value function description during the agent\u2019s interaction with the environment.\nAn approach to non-deterministic answer set programs\nis P-Log [Baral et al., 2009; Gelfond and Rushton, 2010]. While P-Log is capable of calculating transition probabilities from sampling, it is not capable of using this information to generate policies. Also P-Log does not consider action costs. Thus, although P-Log can be used to find the transition function, it cannot find the optimal solution, as proposed here.\nWorks related to non-stationary MDPs such as [Even-Dar et al., 2009; Yu et al., 2009], which deal only with changes in reward function, are more associated with RL alone than with a hybrid method such as oASP(MDP), since RL methods are already capable of handling changes in the reward and transition functions. The advantage of ASP is to find the set of states so that it is possible to search for an optimal solution regardless of the agent\u2019s transition and reward functions.\nA proposal that closely resembles oASP(MDP) is [Garnelo et al., 2016]. This method proposes the combination of deep learning to find a description to a set of states, which are then described as rules to a probabilistic logic program and, finally, a RL agent interacts with the environment using the results and learns the optimal policy."}, {"heading": "6 Conclusion", "text": "This paper presented the method oASP(MDP) for approximating action-value functions of Markov Decision Processes, in non-stationary domains, with unknown set of states and unknown transition and reward functions. This method is defined on a combination of Reinforcement Learning (RL) and Answer Set Programming (ASP). The main advantage of RL is that it does not need a priori knowledge of transition and reward functions, but it relies on having a complete knowledge to the set of domain states. In oASP(MDP), ASP is used to construct the set of states of an MDP to be used by a RL algorithm. ASP programs representing domain states and transitions are obtained as the agent interacts with the environment. This provides an efficient solution to finding optimal policies in changing environments.\nTests were performed in two non-stationary nondeterministic grid-world domains, where each domain had one property of the grid world changed over time. In the first domain, the ratio of obstacles and free space in the grid was changed, whereas in the second domain changes occurred in the transition probabilities. The changes happened in intervals of 1000 episodes in both domains. Results show that, when a change occurs, oASP(MDP) (with Q-learning as the action-value function) is capable of approximating the Q(s, a) function faster than Q-learning alone. Therefore, the combination of ASP with RL was effective in the definition of a method that provides more general (or more elaboration tolerant) solutions to changing domains than RL methods alone.\nFuture work will be directed toward the development of an interface to facilitate the use of oASP(MDP) with distinct domains, such as those provided by the DeepMind Lab [Beattie et al., 2016]. Also, a comparison of oASP(MDP) with the framework proposed in [Garnelo et al., 2016] is an interesting subject for future research."}], "references": [{"title": "Theory and Practice of Logic Programming", "author": ["Chitta Baral", "Michael Gelfond", "Nelson Rushton. Probabilistic reasoning with answer sets"], "venue": "9(1):57,", "citeRegEx": "Baral et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Press", "author": ["Richard Ernest Bellman", "Stuart E. Dreyfus. Applied dynamic programming. Princeton Univ"], "venue": "4 edition,", "citeRegEx": "Bellman and Dreyfus. 1971", "shortCiteRegEx": null, "year": 1971}, {"title": "Indiana University Mathematics Journal", "author": ["Richard Bellman. A Markovian decision process"], "venue": "6(4):679\u2013684,", "citeRegEx": "Bellman. 1957", "shortCiteRegEx": null, "year": 1957}, {"title": "Mathematics of Operations Research", "author": ["Eyal Even-Dar", "Sham. M. Kakade", "Yishay Mansour. Online markov decision processes"], "venue": "34(3):726\u2013 736,", "citeRegEx": "Even.Dar et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Towards deep symbolic reinforcement learning", "author": ["Marta Garnelo", "Kai Arulkumaran", "Murray Shanahan"], "venue": "arXiv preprint arXiv:1609.05518 [cs], September", "citeRegEx": "Garnelo et al.. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Answer set solving in practice", "author": ["Martin Gebser", "Roland Kaminski", "Benjamin Kaufmann"], "venue": "Morgan & Claypool Publishers,", "citeRegEx": "Gebser et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "The stable model semantics for logic programming", "author": ["Gelfond", "Lifschitz", "1988] Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "Gelfond et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1988}, {"title": "A tribute to Judea Pearl", "author": ["Michael Gelfond", "Nelson Rushton. Causal", "probabilistic reasoning in P-log. Heuristics", "Probabilities", "Causality"], "venue": "pages 337\u2013359,", "citeRegEx": "Gelfond and Rushton. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "chapter Answer sets", "author": ["Frank Michael Gelfond. van Harmelen", "Vladimir Lifschitz", "Bruce. Handbook of Knowledge Representation Porter"], "venue": "page 285\u2013316. Elsevier,", "citeRegEx": "Gelfond. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "Planning in action language BC while learning action costs for mobile robots", "author": ["Khandelwal et al", "2014] Piyush Khandelwal", "Fangkai Yang", "Matteo Leonetti", "Vladimir Lifschitz", "Peter Stone"], "venue": "In Proceedings of the Twenty-Fourth International Conference on Automated", "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "Artificial Intelligence", "author": ["Vladimir Lifschitz. Answer set programming", "plan generation"], "venue": "138(1):39\u201354,", "citeRegEx": "Lifschitz. 2002", "shortCiteRegEx": null, "year": 2002}, {"title": "Communications of the ACM", "author": ["John McCarthy. Generality in artificial intelligence"], "venue": "30(12):1030\u2013 1035,", "citeRegEx": "McCarthy. 1987", "shortCiteRegEx": null, "year": 1987}, {"title": "of the Fourth Symposium on Logical Formalizations of Commonsense Reasoning (Common Sense 98)", "author": ["John McCarthy. Elaboration tolerance. In Proc"], "venue": "volume 98, London, UK,", "citeRegEx": "McCarthy. 1998", "shortCiteRegEx": null, "year": 1998}, {"title": "Reinforcement learning an introduction \u2013 Second edition", "author": ["Richard S Sutton", "Andrew G Barto"], "venue": "progress (Draft). MIT Press,", "citeRegEx": "Sutton and Barto. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "PhD thesis", "author": ["Christopher J.C.H. Watkins. Learning from deSuttonlayed rewards"], "venue": "University of Cambridge England,", "citeRegEx": "Watkins. 1989", "shortCiteRegEx": null, "year": 1989}, {"title": "Planning in answer set programming while learning action costs for mobile robots", "author": ["Fangkai Yang", "Piyush Khandelwal", "Matteo Leonetti", "Peter Stone"], "venue": "AAAI Spring 2014 Symposium on Knowledge Representation and Reasoning in Robotics (AAAI-SSS),", "citeRegEx": "Yang et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Mathematics of Operations Research", "author": ["Jia Yuan Yu", "Shie Mannor", "Nahum Shimkin. Markov decision processes with arbitrary reward processes"], "venue": "34(3):737\u2013757,", "citeRegEx": "Yu et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "IEEE Transactions on Robotics", "author": ["Shiqi Zhang", "Mohan Sridharan", "Jeremy L. Wyatt. Mixed logical inference", "probabilistic planning for robots in unreliable worlds"], "venue": "31(3):699\u2013713,", "citeRegEx": "Zhang et al.. 2015", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 11, "context": "This ability is called elaboration tolerance [McCarthy, 1987; McCarthy, 1998].", "startOffset": 45, "endOffset": 77}, {"referenceID": 12, "context": "This ability is called elaboration tolerance [McCarthy, 1987; McCarthy, 1998].", "startOffset": 45, "endOffset": 77}, {"referenceID": 13, "context": "Reinforcement Learning (RL) is an AI framework in which an agent interacts with its environment in order to find a sequence of actions (a policy) to perform a given task [Sutton and Barto, 2015].", "startOffset": 170, "endOffset": 194}, {"referenceID": 4, "context": "However, in spite of having the optimal solution to a particular task, a RL agent may still perform poorly on a new task, even if the latter is similar to the former [Garnelo et al., 2016].", "startOffset": 166, "endOffset": 188}, {"referenceID": 11, "context": "Non-monotonic reasoning can be used as a tool to increase the generality of domain representations [McCarthy, 1987] and may provide the appropriate element to build agents more adaptable to changing situations.", "startOffset": 99, "endOffset": 115}, {"referenceID": 10, "context": "In this work we consider Answer Set Programming (ASP) [Gelfond and Lifschitz, 1988; Lifschitz, 2002], which is a declarative non-monotonic logic programming language, to bridge the gap between RL and elaboration tolerant solutions.", "startOffset": 54, "endOffset": 100}, {"referenceID": 2, "context": "Such sequence of actions, that forms a feasible solution, is known as a policy (\u03c0) which leads the agent from an initial state to a goal state [Bellman, 1957; Bellman and Dreyfus, 1971].", "startOffset": 143, "endOffset": 185}, {"referenceID": 1, "context": "Such sequence of actions, that forms a feasible solution, is known as a policy (\u03c0) which leads the agent from an initial state to a goal state [Bellman, 1957; Bellman and Dreyfus, 1971].", "startOffset": 143, "endOffset": 185}, {"referenceID": 1, "context": "Given a set of feasible solutions, an optimal policy \u03c0\u2217 can be found by using Bellman\u2019s Principle of Optimality [Bellman and Dreyfus, 1971], which states that \u201can optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision\u201d; \u03c0\u2217 can be defined as the policy that maximises/minimises a desired reward/cost function.", "startOffset": 112, "endOffset": 139}, {"referenceID": 14, "context": "One method that can be used to find an optimal policy for MDPs, which does not need a priori knowledge of the transition and reward functions, is the reinforcement learning model-free off-policy method known as QLearning [Watkins, 1989; Sutton and Barto, 2015].", "startOffset": 221, "endOffset": 260}, {"referenceID": 13, "context": "One method that can be used to find an optimal policy for MDPs, which does not need a priori knowledge of the transition and reward functions, is the reinforcement learning model-free off-policy method known as QLearning [Watkins, 1989; Sutton and Barto, 2015].", "startOffset": 221, "endOffset": 260}, {"referenceID": 14, "context": "Since Q-Learning is a well-known and largely used RL method, we omit its detailed description here, which can be found in [Watkins, 1989; Sutton and Barto, 2015].", "startOffset": 122, "endOffset": 161}, {"referenceID": 13, "context": "Since Q-Learning is a well-known and largely used RL method, we omit its detailed description here, which can be found in [Watkins, 1989; Sutton and Barto, 2015].", "startOffset": 122, "endOffset": 161}, {"referenceID": 10, "context": "Answer Set Programming (ASP) is a declarative nonmonotonic logic programming language that has been successfully used for NP-complete problems such as planning [Lifschitz, 2002; Zhang et al., 2015; Yang et al., 2014].", "startOffset": 160, "endOffset": 216}, {"referenceID": 17, "context": "Answer Set Programming (ASP) is a declarative nonmonotonic logic programming language that has been successfully used for NP-complete problems such as planning [Lifschitz, 2002; Zhang et al., 2015; Yang et al., 2014].", "startOffset": 160, "endOffset": 216}, {"referenceID": 15, "context": "Answer Set Programming (ASP) is a declarative nonmonotonic logic programming language that has been successfully used for NP-complete problems such as planning [Lifschitz, 2002; Zhang et al., 2015; Yang et al., 2014].", "startOffset": 160, "endOffset": 216}, {"referenceID": 8, "context": "ASP is based on the stable model semantics of logic programs [Gelfond, 2008].", "startOffset": 61, "endOffset": 76}, {"referenceID": 8, "context": "ASP programs are executed by computing stable models, which is usually accomplished by inference engines called answer set solvers [Gelfond, 2008].", "startOffset": 131, "endOffset": 146}, {"referenceID": 5, "context": "4 using ZeroMQ for providing messages exchanges between agent and environment and Clingo [Gebser et al., 2013] was used as the ASP Engine.", "startOffset": 89, "endOffset": 110}, {"referenceID": 17, "context": "Previous attempts at combining RL with ASP include [Zhang et al., 2015], which proposes the use of ASP to find a predefined plan for a RL agent.", "startOffset": 51, "endOffset": 71}, {"referenceID": 17, "context": "However, changes in the environment, as used in the present work, were not considered in [Zhang et al., 2015].", "startOffset": 89, "endOffset": 109}, {"referenceID": 15, "context": "Analogous methods were proposed by [Khandelwal et al., 2014; Yang et al., 2014], in which an agent interacts with an environment and updates an action\u2019s cost function.", "startOffset": 35, "endOffset": 79}, {"referenceID": 15, "context": ", 2014] uses the action language BC, [Yang et al., 2014] uses ASP to find a description of the environment.", "startOffset": 37, "endOffset": 56}, {"referenceID": 0, "context": "An approach to non-deterministic answer set programs is P-Log [Baral et al., 2009; Gelfond and Rushton, 2010].", "startOffset": 62, "endOffset": 109}, {"referenceID": 7, "context": "An approach to non-deterministic answer set programs is P-Log [Baral et al., 2009; Gelfond and Rushton, 2010].", "startOffset": 62, "endOffset": 109}, {"referenceID": 3, "context": "Works related to non-stationary MDPs such as [Even-Dar et al., 2009; Yu et al., 2009], which deal only with changes in reward function, are more associated with RL alone than with a hybrid method such as oASP(MDP), since RL methods are already capable of handling changes in the reward and transition functions.", "startOffset": 45, "endOffset": 85}, {"referenceID": 16, "context": "Works related to non-stationary MDPs such as [Even-Dar et al., 2009; Yu et al., 2009], which deal only with changes in reward function, are more associated with RL alone than with a hybrid method such as oASP(MDP), since RL methods are already capable of handling changes in the reward and transition functions.", "startOffset": 45, "endOffset": 85}, {"referenceID": 4, "context": "A proposal that closely resembles oASP(MDP) is [Garnelo et al., 2016].", "startOffset": 47, "endOffset": 69}, {"referenceID": 4, "context": "Also, a comparison of oASP(MDP) with the framework proposed in [Garnelo et al., 2016] is an interesting subject for future research.", "startOffset": 63, "endOffset": 85}], "year": 2017, "abstractText": "Non-stationary domains, that change in unpredicted ways, are a challenge for agents searching for optimal policies in sequential decision-making problems. This paper presents a combination of Markov Decision Processes (MDP) with Answer Set Programming (ASP), named Online ASP for MDP (oASP(MDP)), which is a method capable of constructing the set of domain states while the agent interacts with a changing environment. oASP(MDP) updates previously obtained policies, learnt by means of Reinforcement Learning (RL), using rules that represent the domain changes observed by the agent. These rules represent a set of domain constraints that are processed as ASP programs reducing the search space. Results show that oASP(MDP) is capable of finding solutions for problems in non-stationary domains without interfering with the action-value function approximation process.", "creator": "LaTeX with hyperref package"}}}