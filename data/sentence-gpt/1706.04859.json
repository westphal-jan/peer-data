{"id": "1706.04859", "review": {"conference": "nips", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jun-2017", "title": "Sobolev Training for Neural Networks", "abstract": "At the heart of deep learning we aim to use neural networks as function approximators - training them to produce outputs from inputs in emulation of a ground truth function or data creation process. In many cases we only have access to input-output pairs from the ground truth, however it is becoming more common to have access to derivatives of the target output with respect to the input - for example when the ground truth function is itself a neural network such as in network compression or distillation. Generally these target derivatives are not computed, or are ignored. This paper introduces Sobolev Training for neural networks, which is a method for incorporating these target derivatives in addition the to target values while training. By optimising neural networks to not only approximate the function's outputs but also the function's derivatives we encode additional information about the target function within the parameters of the neural network. Thereby we can improve the quality of our predictors, as well as the data-efficiency and generalization capabilities of our learned function approximation. We provide theoretical justifications for such an approach as well as examples of empirical evidence on three distinct domains: regression on classical optimisation datasets, distilling policies of an agent playing Atari, and on large-scale applications of synthetic gradients. In all three domains the use of Sobolev Training, employing target derivatives in addition to target values, results in models with higher accuracy and stronger generalisation. Our aim is to investigate whether this practice is an optimal practice as long as we have a very specific dataset with a strong generalisation. The present paper explains the advantages and disadvantages of using these techniques, in particular using the same approach in the model of the target derivatives as described earlier, but with the same approach in the model of the target derivatives as described earlier. The results of our paper will also be compared to previous methods, and may be useful for understanding which particular techniques are used in this study, and will be useful for further research.\n\n\n\n\n\nIn this paper we attempt to assess the effect of using these target derivatives in combination with existing models of the target-weighted estimators such as the Monte Carlo Monte Carlo models, and which of the main approaches are not directly related to the methods discussed earlier. In particular, we recommend further studies as well as in the future. In particular, this paper also explores some of the more general implications of using these target derivatives in combination with existing models of the target derivatives, which of the main approaches are not directly related to the methods discussed earlier.\n\n\nThe main results are", "histories": [["v1", "Thu, 15 Jun 2017 13:25:25 GMT  (8346kb,D)", "http://arxiv.org/abs/1706.04859v1", null], ["v2", "Tue, 4 Jul 2017 12:41:55 GMT  (9199kb,D)", "http://arxiv.org/abs/1706.04859v2", null], ["v3", "Wed, 26 Jul 2017 16:18:52 GMT  (9199kb,D)", "http://arxiv.org/abs/1706.04859v3", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["wojciech marian czarnecki", "simon osindero", "max jaderberg", "grzegorz \\'swirszcz", "razvan pascanu"], "accepted": true, "id": "1706.04859"}, "pdf": {"name": "1706.04859.pdf", "metadata": {"source": "CRF", "title": "Sobolev Training for Neural Networks", "authors": ["Wojciech Marian Czarnecki", "Simon Osindero", "Max Jaderberg", "Grzegorz Swirszcz"], "emails": ["lejlot@google.com", "osindero@google.com", "jaderberg@google.com", "swirszcz@google.com", "razp@google.com"], "sections": [{"heading": "1 Introduction", "text": "Deep Neural Networks (DNNs) are one of the main tools of modern machine learning. They are consistently proven to be powerful function approximators, able to model a wide variety of functional forms \u2013 from image recognition [6, 23], through audio synthesis [24], to human-beating policies in the ancient game of GO [21]. In many applications the process of training a neural network consists of receiving a dataset of input-output pairs from a ground truth function, and minimising some loss with respect to the network\u2019s parameters. This loss is usually designed to encourage the network to produce the same output, for a given input, as that from the target ground truth function. Many of the ground truth functions we care about in practice have an unknown analytic form, e.g. because they are the result of a natural physical process, and therefore we only have the observed input-output pairs for supervision. However, there are scenarios where we do know the analytic form and so are able to compute the ground truth gradients (or higher order derivatives), alternatively sometimes these quantities may be simply observable. A common example is when the ground truth function is itself a neural network; for instance this is the case for distillation [7, 19], compressing neural networks [5], and the prediction of synthetic gradients [10]. Additionally, if we are dealing with an environment/data-generation process (vs. a pre-determined set of data points), then even though we may be dealing with a black box we can still approximate derivatives using finite differences. In this work, we consider how this additional information can be incorporated in the learning process, and what advantages it can provide in terms of data efficiency and performance. We propose Sobolev Training (ST) for neural networks as a simple and efficient technique for leveraging ar X\niv :1\n70 6.\n04 85\n9v 1\n[ cs\n.L G\n] 1\n5 Ju\nn 20\nfi fi+1 fi+2\n\u2026\n\u2026 \u2026 \u2026\nfi\nfi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026\nMi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(c)\nLL Forward connection, differentiable Forward connection, non-differentiable Error gradient, non-differentiable Synthetic error gradient, differentiable Legend: Synthetic error gradient, nondifferentiable\nD_{\\mathbf{x}} f\nD_{\\mathbf{x}} \\langle D_{\\mathbf{x}} \\langle m, v_1 \\rangle, v_2 \\rangle\nderivative information about the desired function in a way that can easily be incorporated into any training pipeline using modern machine learning libraries.\nThe approach is inspired by the work of Hornik [8] which proved the universal approximation theorems for neural networks in Sobolev spaces \u2013 metric spaces where distances between functions are defined both in terms of their differences in values and differences in values of their derivatives.\nIn particular, it was shown that a sigmoid network can not only approximate a function\u2019s value arbitrarily well, but that the network\u2019s derivatives with respect to its inputs can approximate the corresponding derivatives of the ground truth function arbitrarily well too. Sobolev Training exploits this property, and tries to match not only the output of the function being trained but also its derivatives.\nThere are several related works which have also exploited derivative information for function approximation. For instance Wu et al. [27] and antecedents propose a technique for Bayesian optimisation with Gaussian Processess (GP), where it was demonstrated that the use of information about gradients and Hessians can improve the predictive power of GPs. In previous work on neural networks, derivatives of predictors have usually been used either to penalise model complexity (e.g. by pushing Jacobian norm to 0 [18]), or to encode additional, hand crafted invariances to some transformations (for instance, as in Tangentprop [22]), or estimated derivatives for dynamical systems [4]. Similar techniques have also been used in critic based Reinforcement Learning (RL), where a critic\u2019s derivatives are trained to match its target\u2019s derivatives [26, 13] using shallow, sigmoid based models. Finally, Hyv\u00e4rinen proposed Score Matching Networks [9], which are based on the somewhat surprising observation that one can model unknown derivatives of the function without actual access to its values \u2013 all that is needed is a sampling based strategy and specific penalty. However, such an estimator has a high variance [25], thus it is not really useful when true derivatives are given.\nTo the best of our knowledge and despite its simplicity, the proposal to directly match network derivatives to the true derivatives of the target function has been minimally explored for deep networks. In our method, we show that by using the additional knowledge of derivatives with Sobolev Training we are able to train better models \u2013 models which achieve lower approximation errors and generalise to test data better \u2013 and reduce the sample complexity of learning. The contributions of our paper are therefore threefold: (1): We introduce Sobolev Training \u2013 a new paradigm for training neural networks. (2): We look formally at the implications of matching derivatives, extending previous results of Hornik [8] and showing that modern architectures are well suited for such training regimes. (3): Empirical evidence demonstrating that Sobolev Training leads to improved performance and generalisation, particularly in low data regimes. Example domains are: regression on classical\noptimisation problems; policy distillation from RL agents trained on the Atari domain; and training deep, complex models using synthetic gradients \u2013 we report the first successful attempt to train a large-scale ImageNet model using synthetic gradients."}, {"heading": "2 Sobolev Training", "text": "We begin by introducing the idea of training using Sobolev spaces. When learning a function f , we may have access to not only the output values f(xi) for training points xi, but also the values of its j-th order derivatives with respect to the input, Djxf(xi). In other words, instead of the typical training set consisting of pairs {(xi, f(xi))}Ni=1 we have access to (K + 2)-tuples {(xi, f(xi), D1xf(xi), ..., DKx f(xi))}Ni=1. In this situation, the derivative information can easily be incorporated into training a neural network model of f by making derivatives of the neural network match the ones given by f .\nConsidering a neural network model m parameterised with \u03b8, one typically seeks to minimise the empirical error in relation to f according to some loss function `\nN\u2211 i=1 `(m(xi|\u03b8), f(xi)).\nWhen learning in Sobolev spaces, this is replaced with:\nN\u2211 i=1 `(m(xi|\u03b8), f(xi)) + K\u2211 j=1 `j ( Djxm(xi|\u03b8), Djxf(xi) ) , (1) where `j are loss functions measuring error on j-th order derivatives. This causes the neural network to encode derivatives of the target function in its own derivatives. Such a model can still be trained using backpropagation and off-the-shelf optimisers.\nA potential concern is that this optimisation might be expensive when either the output dimensionality of f or the order K are high, however one can reduce this cost through stochastic approximations. Specifically, if f is a multivariate function, instead of a vector gradient, one ends up with a full Jacobian matrix which can be large. To avoid adding computational complexity to the training process, one can use an efficient, stochastic version of Sobolev Training: instead of computing a full Jacobian/Hessian, one just computes its projection onto a random vector (a direct application of a known estimation trick [18]). In practice, this means that during training we have a random variable v sampled uniformly from the unit sphere, and we match these random projections instead:\nN\u2211 i=1 `(m(xi|\u03b8), f(xi)) + K\u2211 j=1 Evj [ `j (\u2329 Djxm(xi|\u03b8), vj \u232a , \u2329 Djxf(xi), v j \u232a)] . (2)\nFigure 1 illustrates compute graphs for non-stochastic and stochastic Sobolev Training of order 2."}, {"heading": "3 Theory and motivation", "text": "While in the previous section we defined Sobolev Training, it is not obvious that modeling the derivatives of the target function f is beneficial to function approximation, or that optimising such an objective is even feasible. In this section we motivate and explore these questions theoretically, showing that the Sobolev Training objective is a well posed one, and that incorporating derivative information has the potential to drastically reduce the sample complexity of learning.\nHornik showed [8] that neural networks with non-constant, bounded, continuous activation functions, with continuous derivatives up to order K are universal approximators in the Sobolev spaces of order K, thus showing that sigmoid-networks are indeed capable of approximating elements of these spaces arbitrarily well. However, nowadays we often use activation functions such as ReLU which are neither bounded nor have continuous derivatives. The following theorem shows that for K = 1 we can use ReLU function (or a similar one, like leaky ReLU) to create neural networks that are universal approximators in Sobolev spaces. We will use a standard symbol C1(S) (or simply C1) to denote a space of functions which are continuous, differentiable, and have a continuous derivative on a space S [12]. All proofs are given in the Supplementary Materials (SM).\nTheorem 1. Let f be a C1 function on a compact set. Then, for every positive \u03b5 there exists a single hidden layer neural network with a ReLU (or a leaky ReLU) activation which approximates f in Sobolev space S1 up to error. This suggests that the Sobolev Training objective is achievable, and that we can seek to encode the values and derivatives of the target function in the values and derivatives of a ReLU neural network model. Interestingly, we can show that if we seek to encode an arbitrary function in the derivatives of the model then this is impossible not only for neural networks but also for any arbitrary differentiable predictor on compact sets.\nTheorem 2. Let f be a C1 function. Let g be a continuous function satisfying \u2016g\u2212 \u2202f\u2202x\u2016\u221e > 0. Then, there exists an \u03b7 > 0 such that for any C1 function h either \u2016f \u2212 h\u2016\u221e \u2265 \u03b7 or \u2225\u2225g \u2212 \u2202h\u2202x\u2225\u2225\u221e \u2265 \u03b7. However, when we move to the regime of finite training data, we can encode any arbitrary function in the derivatives (as well as higher order signals if the resulting Sobolev spaces are not degenerate), as shown in the following Proposition. Proposition 1. Given any two functions f : S \u2192 R and g : S \u2192 Rd on S \u2286 Rd and a finite set \u03a3 \u2282 S, there exists neural network h with a ReLU (or a leaky ReLU) activation such that \u2200x \u2208 \u03a3 : f(x) = h(x) and g(x) = \u2202h\u2202x (x) (it has 0 training loss). Having shown that it is possible to train neural networks to encode both the values and derivatives of a target function, we now formalise one possible way of showing that Sobolev Training has lower sample complexity than regular training.\nLet F denote the family of functions parametrised by \u03c9. We define Kreg = Kreg(F) to be a measure of the amount of data needed to learn some target function f . That is Kreg is the smallest number for which there holds: for every f\u03c9 \u2208 F and every set of distinct Kreg points (x1, ..., xKreg ) such that \u2200i=1,...,Kregf(xi) = f\u03c9(xi)\u21d2 f = f\u03c9. Ksob is defined analogously, but the final implication is of form f(xi) = f\u03c9(xi) \u2227 \u2202f\u2202x (xi) = \u2202f\u03c9 \u2202x (xi)\u21d2 f = f\u03c9 . Straight from the definition there follows: Proposition 2. For any F , there holds Ksob(F) \u2264 Kreg(F). For many families, the above inequality becomes sharp. For example, to determine the coefficients of a polynomial of degree n one needs to compute its values in at least n+ 1 distinct points. If we know values and the derivatives at k points, it is a well-known fact that only dn2 e points suffice to determine all the coefficients. We present two more examples in a slightly more formal way. Let FG denote a family of Gaussian PDF-s (parametrised by \u00b5, \u03c3). Let Rd \u2283 D = D1 \u222a . . . \u222aDn and let FPL be family of continuous piecewise-linear functions from D to R which are linear on each the elements Di of the (fixed) decomposition of the domain D (Figure 2 Left). Proposition 3. There holds Ksob (FG) < Kreg(FG) and Ksob(FPL) < Kreg(FPL). This result relates to Deep ReLU networks as they build a hyperplanes-based model of the target function. If those were parametrised independently one could expect a reduction of sample complexity by d+1 times, where d is the dimension of the function domain. In practice parameters of hyperplanes in such networks are not independent, furthermore the hinges positions change so the Proposition\ncannot be directly applied, but it can be seen as an intuitive way to see why the sample complexity drops significantly for Deep ReLU networks too."}, {"heading": "4 Experimental Results", "text": "We consider three domains where information about derivatives is available during training1."}, {"heading": "4.1 Artificial Data", "text": "First, we consider the task of regression on a set of well known low-dimensional functions used for benchmarking optimisation methods.\nWe train two hidden layer neural networks with 256 hidden units per layer with ReLU activations to regress towards function values, and verify generalisation capabilities by evaluating the mean squared error on a hold-out test set. Since the task is standard regression, we choose all the losses of Sobolev Training to be L2 errors, and use a first order Sobolev method (second order derivatives of ReLU networks with a linear output layer are constant, zero). The optimisation is therefore:\nmin \u03b8\n1 N N\u2211 i=1 \u2016f(xi)\u2212m(xi|\u03b8)\u201622 + \u2016\u2207xf(xi)\u2212\u2207xm(xi|\u03b8)\u201622.\nFigure 2 right shows the results for the optimisation benchmarks. As expected, Sobolev trained networks perform extremely well \u2013 for six out of seven benchmark problems they significantly reduce the testing error with the obtained errors orders of magnitude smaller than the corresponding errors of the regularly trained networks. The stark difference in approximation error is highlighted in Figure 3, where we show the Styblinski-Tang function and its approximations with both regular and Sobolev Training. It is clear that even in very low data regimes, the Sobolev trained networks can capture the functional shape.\nLooking at the results, we make two important observations. First, the effect of Sobolev Training is stronger in low-data regimes, however it does not disappear even in the high data regime, when one has 10,000 training examples for training a two-dimensional function. Second, the only case where regular regression performed better is the regression towards Ackley\u2019s function. This particular example was chosen to show that one possible weak point of our approach might be approximating functions with a very high frequency signal component in the relatively low data regime. Ackley\u2019s function is composed of exponents of high frequency cosine waves, thus creating an extremely bumpy surface, consequently a method that tries to match the derivatives can behave badly during testing if one does not have enough data to capture this complexity. However, once we have enough training data points, Sobolev trained networks are able to approximate this function better.\n1All experiments were performed using TensorFlow [1] and the Sonnet neural network library [2]."}, {"heading": "4.2 Distillation", "text": "Another possible application of Sobolev Training is to perform model distillation. This technique has many applications, such as network compression [20], ensemble merging [7], or more recently policy distillation in reinforcement learning [19].\nWe focus here on a task of distilling a policy. We aim to distill a target policy \u03c0\u2217(s) \u2013 a trained neural network which outputs a probability distribution over actions \u2013 into a smaller neural network \u03c0(s|\u03b8), such that the two policies \u03c0\u2217 and \u03c0 have the same behaviour. In practice this is often done by minimising an expected divergence measure between \u03c0\u2217 and \u03c0, for example, the Kullback\u2013Leibler divergence DKL(\u03c0(s)\u2016\u03c0\u2217(s)), over states gathered while following \u03c0\u2217. Since policies are multivariate functions, direct application of Sobolev Training would mean producing full Jacobian matrices with respect to the s, which for large actions spaces is computationally expensive. To avoid this issue we employ a stochastic approximation described in Section 2, thus resulting in the objective\nmin \u03b8 DKL(\u03c0(s|\u03b8)\u2016\u03c0\u2217(s)) + \u03b1Ev [\u2016\u2207s\u3008log \u03c0\u2217(s), v\u3009 \u2212 \u2207s\u3008log \u03c0(s|\u03b8), v\u3009\u2016] ,\nwhere the expectation is taken with respect to v coming from a uniform distribution over the unit sphere, and Monte Carlo sampling is used to approximate it.\nAs target policies \u03c0\u2217, we use agents playing Atari games [16] that have been trained with A3C [15] on three well known games: Pong, Breakout and Space Invaders. The agent\u2019s policy is a neural network consisting of 3 layers of convolutions followed by two fully-connected layers, which we distill to a smaller network with 2 convolutional layers and a single smaller fully-connected layer (see SM for details). Distillation is treated here as a purely supervised learning problem, as our aim is not to re-evaluate known distillation techniques, but rather to show that if the aim is to minimise a given divergence measure, we can improve distillation using Sobolev Training. Figure 4 shows test error during training with and without Sobolev Training2. The introduction of Sobolev Training leads to similar effects as in the previous section \u2013 the network generalises much more effectively, and this is especially true in low data regimes. Note the performance gap on Pong is small due to the fact that optimal policy is quite degenerate for this game3. In all remaining games one can see a significant performance increase from using our proposed method, and as well as minor to no overfitting.\nDespite looking like a regularisation effect, we stress that Sobolev Training is not trying to find the simplest models for data or suppress the expressivity of the model. This training method aims at\n2Testing is performed on a held out set of episodes, thus there are no temporal nor causal relations between training and testing\n3For majority of the time the policy in Pong is uniform, since actions taken when the ball is far away from the player do not matter at all. Only in crucial situations it peaks so the ball hits the paddle.\nTable 1: Various techniques for producing synthetic gradients. Green shaded nodes denote nodes that get supervision from the corresponding object from the main network (gradient or loss value). We report accuracy on the test set \u00b1 standard deviation. Backpropagation results are given in parenthesis.\nfi fi+1 fi+2 \u2026 \u2026 \u2026 \u2026\nfi fi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026\nMi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(a) (b) (c)\nDifferentiable Legend:\nx y\nL h SG LSG\nx y\nL h Forward connection, differentiable Forward connection, non-differentiable Error gradient, non-differentiable Synthetic error gradient, differentiable Legend: Synthetic error gradient, nondifferentiable\nNon-differentiable Forward connection Error gradient Synthetic error gradient\nx\nfm\nD2xfD 2 xm\nDxm Dxf\nD_{\\mathbf{x}} f\nl\nl2\nl1\n@\n@x\n@\n@x\n@\n@x\n@\n@x L\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nSG(h, y)\nh y\nf(h, y|\u2713)\nhy\n0\nfi fi+1 fi+2 \u2026 \u2026 \u2026 \u2026\nfi fi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026\nMi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(a) (b) (c)\nDifferentiable L gend:\nx y\nL h SG LSG\nx y\nL h Forward connection, differentiable Forward connection, on-differentiable Erro gradient, on-differentiable Synthetic error gradient, differentiable L gend: Synthetic error gradient, ondifferentiable\nNon-differentiable Forward connection Erro gradient Synthetic erro gradient\nx\nfm\nD2xfD 2 xm\nDxm Dxf\nD_{\\mathbf{x}} f\nl\nl2\nl1\n@\n@x\n@\n@x\n@\n@x\n@\n@x L\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nSG(h, y)\nh y\nf(h, y|\u2713)\nhy\n0\nfi fi+1 fi+2 \u2026 \u2026 \u2026 \u2026\nfi fi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026 Mi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(a) (b) (c)\nDifferentiable Legend:\nx y\nL h SG LSG\nx y\nL h Forward connection, differentiable Forward connection, non-differentiable Error gradient, non-differentiable Synthetic error gradient, differentiable Legend: Synthetic error gradient, nondifferentiable\nNon-differentiable Forward c nection Error gradient Synthetic error gradient\nx\nfm\nD2xfD 2 xm\nDxm Dxf\nD_{\\mathbf{x}} f\nl\nl2\nl1\n@\n@x\n@\n@x\n@\n@x\n@\n@x L\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nSG(h, y)\nh y\nf(h, y|\u2713)\nhy\n0\nfi fi+1 fi+2 \u2026 \u2026 \u2026 \u2026\nfi fi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026 Mi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(a) (b) (c)\nDifferentiable Legend:\nx y\nL h SG LSG\nx y\nL h Forward connection, differentiable Forward connection, non-differentiable Error gradient, non-differentiable Syn hetic error gradient, differentiable Legend: Syn hetic error gradie t, nondifferentiable\nNon-differentiable Forward connection Error gradient Syn hetic rror gradient\nx\nfm\nD2xfD 2 xm\nDxm Dxf\nD_{\\mathbf{x}} f\nl\nl2\nl1\n@\n@x\n@\n@x\n@\n@x\n@\n@x L\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nL\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nSG(h, y)\nh y\nf(h, y|\u2713)\nhy\n0\nfi fi+1 fi+2 \u2026 \u2026 \u2026 \u2026\nfi fi+1 fi+2\n\u2026\n\u2026\n\u2026 \u2026 Mi+1 i \u0302i Mi+2 \u0302i+1 i+1\n(a) (b) (c)\nD fferentiable Legend:\nx y\nL h SG LSG\nx y\nL h Forward c nection, d fferentiable Forward c nection, non-d fferentiable Error gradient, non-d fferentiable Synth tic error gradient, d fferentiable Legend: Synth tic error gradient, nond fferentiable\nNon-d fferentiable Forward c nection Error gradient Synth tic error gradient\nx\nfm\nD2xfD 2 xm\nDxm Dxf\nD_{\\mathbf{x}} f\nl\nl2\nl1\n@\n@x\n@\n@x\n@\n@x\n@\n@x L\u0302\np(h|\u2713)\n@\n@h\nSG(h, y)\nh y\nSG(h, y)\nh y\nf(h, y|\u2713)\n0\nNoprop Direct SG [10] VFBN [14] Critic Sobolev\nCIFAR-10 with 3 synthetic gradient modules Top 1 (94.3%) 54.5% \u00b11.15 79.2% \u00b10.01 88.5% \u00b12.70 93.2% \u00b10.02 93.5% \u00b10.01\nImageNet with 1 synthetic gradient module Top 1 (75.0%) 54.0% \u00b10.29 - 57.9% \u00b12.03 71.7% \u00b10.23 72.0% \u00b10.05 Top 5 (92.3%) 77.3% \u00b10.06 - 81.5% \u00b11.20 90.5% \u00b10.15 90.8% \u00b10.01\nImageNet with 3 synthetic gradient modules Top 1 (75.0%) 18.7% \u00b10.18 - 28.3% \u00b15.24 65.7% \u00b10.56 66.5% \u00b10.22 Top 5 (92.3%) 38.0% \u00b10.34 - 52.9% \u00b16.62 86.9% \u00b10.33 87.4% \u00b10.11\nmatching the original function\u2019s smoothness/complexity and so reduces overfitting by effectively extending the information content of the training set, rather than by imposing a data-independent prior as with regularisation."}, {"heading": "4.3 Synthetic Gradients", "text": "The previous experiments have shown how information about the derivatives can boost approximating function values. However, the core idea of Sobolev Training is broader than that, and can be employed in both directions. Namely, if one ultimately cares about approximating derivatives, then additionally approximating values can help this process too. One recent technique, which requires a model of gradients is Synthetic Gradients (SG) [10] \u2013 a method for training complex neural networks in a decoupled, asynchronous fashion. In this section we show how we can use Sobolev Training for SG.\nThe principle behind SG is that instead of doing full backpropagation using the chain-rule, one splits a network into two (or more) parts, and approximates partial derivatives of the loss L with respect to some hidden layer activations h with a trainable function SG(h, y|\u03b8). In other words, given that network parameters up to h are denoted by \u0398\n\u2202L \u2202\u0398 = \u2202L \u2202h \u2202h \u2202\u0398 \u2248 SG(h, y|\u03b8) \u2202h \u2202\u0398 .\nIn the original SG paper, this module is trained to minimise LSG(\u03b8) = \u2225\u2225\u2225SG(h, y|\u03b8)\u2212 \u2202L(ph,y)\u2202h \u2225\u2225\u22252\n2 ,\nwhere ph is the final prediction of the main network for hidden activations h. For the case of learning a classifier, in order to apply Sobolev Training in this context we construct a loss predictor, composed of a class predictor p(\u00b7|\u03b8) followed by the log loss, which gets supervision from the true loss, and the gradient of the prediction gets supervision from the true gradient:\nm(h, y|\u03b8) := L(p(h|\u03b8), y), SG(h, y|\u03b8) := \u2202m(h, y|\u03b8)/\u2202h, LsobSG(\u03b8) = `(m(h, y|\u03b8), L(ph, y))) + `1 ( \u2202m(h,y|\u03b8) \u2202h , \u2202L(ph,y) \u2202h ) .\nIn the Sobolev Training framework, the target function is the loss of the main network L(ph, y) for which we train a model m(h, y|\u03b8) to approximate, and in addition ensure that the model\u2019s\nderivatives \u2202m(h, y|\u03b8)/\u2202h are matched to the true derivatives \u2202L(ph, y)/\u2202h. The model\u2019s derivatives \u2202m(h, y|\u03b8)/\u2202h are used as the synthetic gradient to decouple the main network. This setting closely resembles what is known in reinforcement learning as critic methods [11]. In particular, if we do not provide supervision on the gradient part, we end up with a loss critic. Similarly if we do not provide supervision at the loss level, but only on the gradient component, we end up in a method that resembles VFBN [14]. In light of these connections, our approach in this application setting can be seen as a generalisation and unification of several existing ones (see Table 1 for illustrations of these approaches).\nWe perform experiments on decoupling deep convolutional neural network image classifiers using synthetic gradients produced by loss critics that are trained with Sobolev Training, and compare to regular loss critic training, and regular synthetic gradient training. We report results on CIFAR-10 for three network splits (and therefore three synthetic gradient modules) and on ImageNet with one and three network splits 4.\nThe results are shown in Table 1. With a naive SG model, we obtain 79.2% test accuracy on CIFAR-10. Using an SG architecture which resembles a small version of the rest of the model makes learning much easier and led to 88.5% accuracy, while Sobolev Training achieves 93.5% final performance. The regular critic also trains well, achieving 93.2%, as the critic forces the lower part of the network to provide a representation which it can use to reduce the classification (and not just prediction) error. Consequently it provides a learning signal which is well aligned with the main optimisation. However, this can lead to building representations which are suboptimal for the rest of the network. Adding additional gradient supervision by constructing our Sobolev SG module avoids this issue by making sure that synthetic gradients are truly aligned and gives an additional boost to the final accuracy.\nFor ImageNet [3] experiments based on ResNet50 [6], we obtain qualitatively similar results. Due to the complexity of the model and an almost 40% gap between no backpropagation and full backpropagation results, the difference between methods with vs without loss supervision grows significantly. This suggests that at least for ResNet-like architectures, loss supervision is a crucial component of a SG module. After splitting ResNet50 into four parts the Sobolev SG achieves 87.4% top 5 accuracy, while the regular critic SG achieves 86.9%, confirming our claim about suboptimal representation being enforced by gradients from a regular critic. Sobolev Training results were also much more reliable in all experiments (significantly smaller standard deviation of the results)."}, {"heading": "5 Discussion and Conclusion", "text": "In this paper we have introduced Sobolev Training for neural networks \u2013 a simple and effective way of incorporating knowledge about derivatives of a target function into the training of a neural network function approximator. We provided theoretical justification that encoding both a target function\u2019s value as well as its derivatives within a ReLU neural network is possible, and that this results in more data efficient learning. Additionally, we show that our proposal can be efficiently trained using stochastic approximations if computationally expensive Jacobians or Hessians are encountered.\nIn addition to toy experiments which validate our theoretical claims, we performed experiments to highlight two very promising areas of applications for such models: one being distillation/compression of models; the other being the application to various meta-optimisation techniques that build models of other models dynamics (such as synthetic gradients, learning-to-learn, etc.). In both cases we obtain significant improvement over classical techniques, and we believe there are many other application domains in which our proposal should give a solid performance boost.\nIn this work we focused on encoding true derivatives in the corresponding ones of the neural network. Another possibility for future work is to encode information which one believes to be highly correlated with derivatives. For example curvature [17] is believed to be connected to uncertainty. Therefore, given a problem with known uncertainty at training points, one could use Sobolev Training to match the second order signal to the provided uncertainty signal. Finite differences can also be used to approximate gradients for black box target functions, which could help when, for example, learning a generative temporal model. Another unexplored path would be to apply Sobolev Training to internal derivatives rather than just derivatives with respect to the inputs.\n4N.b. the experiments presented use learning rates, annealing schedule, etc. optimised to maximise the backpropagation baseline, rather than the synthetic gradient decoupled result (details in the SM)."}, {"heading": "1 Proofs", "text": "Theorem 1. Let f be a C1 function on a compact set. Then, for every positive \u03b5 there exists a single hidden layer neural network with a ReLU (or a leaky ReLU) activation which approximates f in Sobolev space S1 up to error.\nWe start with a definition. We will say that a function p on a set D is piecewise-linear, if there exist D1, . . . , Dn such that D = D1 \u222a . . . \u222aDn = D and p|Di is linear for every i = 1, . . . , n (note, that we assume finiteness in the definition).\nLemma 1. Let D be a compact subset of R and let \u03d5 \u2208 C1(D). Then, for every \u03b5 > 0 there exists a piecewiselinear, continuous function p : D \u2192 R such that |\u03d5(x)\u2212 p(x)| < \u03b5 for every x \u2208 D and |\u03d5\u2032(x)\u2212 p\u2032(x)| < \u03b5 for every x \u2208 D \\ P , where P is the set of points of non-differentiability of p.\nProof. By assumption, the function \u03d5\u2032 is continuous on D. Every continuous function on a compact set has to be uniformly continuous. Therefore, there exists \u03b41 such that for every x1, x2, with |x1 \u2212 x2| < \u03b41 there holds |\u03d5\u2032(x1) \u2212 \u03d5\u2032(x2)| < \u03b5. Moreover, \u03d5\u2032 has to be bounded. Let M denote sup\nx |\u03d5\u2032(x)|. By Mean Value\nTheorem, if |x1 \u2212 x2| < \u03b52M then |\u03d5(x1)\u2212 \u03d5(x2)| < \u03b5 2\n. Let \u03b4 = min { \u03b41,\n\u03b5 2M\n} . Let \u03bei, i = 0, . . . , N be a\nsequence satisfying: \u03bei < \u03bej for i < j, |\u03bei \u2212 \u03bei\u22121| < \u03b4 for i = 1, . . . , N and \u03be0 < x < \u03beN for all x \u2208 D. Such sequence obviously exists, because D is a compact (and thus bounded) subset of R. We define\np(x) = \u03d5(\u03bei\u22121) + \u03d5(\u03bei)\u2212 \u03d5(\u03bei\u22121)\n\u03bei \u2212 \u03bei\u22121 (x\u2212 \u03bei\u22121) for x \u2208 [\u03bei\u22121, \u03bei] \u2229D.\nIt can be easily verified, that it has all the desired properties. Indeed, let x \u2208 D. Let i be such that \u03bei\u22121 \u2264 x \u2264 \u03bei. Then |\u03d5(x)\u2212p(x)| = |\u03d5(x)\u2212\u03d5(\u03bei)+p(\u03bei)\u2212p(x)| \u2264 |\u03d5(x)\u2212\u03d5(\u03bei)|+ |p(\u03bei)\u2212p(x)| \u2264 \u03b5, as \u03d5(\u03bei) = p(\u03bei) and |\u03bei \u2212 x| \u2264 |\u03bei \u2212 \u03bei\u22121| < \u03b4 by definitions. Moreover, applying Mean Value Theorem we get that there exists \u03b6 \u2208 [\u03bei\u22121, \u03bei] such that \u03d5\u2032(\u03b6) = \u03d5(\u03bei)\u2212\u03d5(\u03bei\u22121)\u03bei\u2212\u03bei\u22121 = p\n\u2032(\u03b6). Thus, |\u03d5\u2032(x)\u2212 p\u2032(x)| = |\u03d5\u2032(x)\u2212 \u03d5\u2032(\u03b6) + p\u2032(\u03b6)\u2212 p\u2032(x)| \u2264 |\u03d5\u2032(x)\u2212 \u03d5(\u03b6)|+ |p\u2032(\u03b6)\u2212 p\u2032(x)| \u2264 \u03b5 as p\u2032(\u03b6) = p\u2032(x) and |\u03b6 \u2212 x| < \u03b4.\nLemma 2. Let \u03d5 \u2208 C1(R) have finite limits lim x\u2192\u2212\u221e \u03d5(x) = \u03d5\u2212 and lim x\u2192\u221e \u03d5(x) = \u03d5+. Then, for every \u03b5 > 0 there exists a piecewise-linear, continuous function p : R\u2192 R such that |\u03d5(x)\u2212 p(x)| < \u03b5 for every x \u2208 R and |\u03d5\u2032(x)\u2212 p\u2032(x)| < \u03b5 for every x \u2208 R \\ P , where P is the set of points of non-differentiability of p.\nProof. By definition of a limit there exist numbers K\u2212 < K+ such that x < K\u2212 \u21d2 |\u03d5(x) \u2212 \u03d5\u2212| \u2264 \u03b52 and x > K+ \u21d2 |\u03d5(x)\u2212 \u03d5+| \u2264 \u03b52 . We apply Lemma 1 to the function \u03d5 and the set D = [K,K+]. We define p\u0303 on [K\u2212,K+] according to Lemma 1. We define p as\np(x) =  \u03d5\u2212 for x \u2208 [\u2212\u221e,K\u2212]p\u0303(x) for x \u2208 [K\u2212,K+]\u03d5+ for x \u2208 [K+,\u221e] . It can be easily verified, that it has all the desired properties.\nCorollary 1. For every \u03b5 > 0 there exists a combination of ReLU functions which approximates a sigmoid function with accurracy \u03b5 in the Sobolev space.\nProof. It follows immediately from Lemma 2 and the fact, that any piecewise-continuous function on R can be expressed as a finite sum of ReLU activations.\nRemark 1. The authors decided, for the sake of clarity and better readability of the paper, to not treat the issue of non-differentiabilities of the piecewise-linear function at the junction points. It can be approached in various ways, either by noticing they form a finite, and thus a zero-Lebesgue measure set and invoking the formal definition f Sobolev spaces, or by extending the definition of a derivative, but it leads only to non-interesting technical complications.\nProof of Theorem 1. By Hornik\u2019s result (Hornik [8]) there exists a combination of N sigmoids approximating the function f in the Sobolev space with \u03b5\n2 accuracy. Each of those sigmoids can, in turn, be approximated up\nto \u03b5 2N accuracy by a finite combination of ReLU (or leaky ReLU) functions (Corollary 1), and the theorem follows.\nTheorem 2. Let f be a C1(S). Let g be a continuous function satisfying \u2016g \u2212 \u2202f \u2202x \u2016 > 0. Then, there exists an \u03b5 = \u03b5(f, g) such that for any C1 function h there holds either \u2016f \u2212 h\u2016 \u2265 \u03b5 or \u2225\u2225g \u2212 \u2202h\n\u2202x \u2225\u2225 \u2265 \u03b5. Proof. Assume that the converse holds. This would imply, that there exists a sequence of functions hn such that lim n\u2192\u221e \u2202hn \u2202x = g and lim n\u2192\u221e hn = f . But the convergence of hn at any point implies that \u2202\u2202x ( lim n\u2192\u221e hn ) = \u2202f \u2202x .\nHowever, \u2202 \u2202x ( lim n\u2192\u221e hn ) = lim n\u2192\u221e \u2202hn \u2202x = g, contradicting \u2016g \u2212 \u2202f \u2202x \u2016 > 0.\nProposition 1. Given any two functions f : S \u2192 R and g : S \u2192 Rd on S \u2286 Rd and a finite set \u03a3 \u2282 S, there exists neural network h with a ReLU (or a leaky ReLU) activation such that \u2200x \u2208 \u03a3 : f(x) = h(x) and g(x) = \u2202h\n\u2202x (x) (it has 0 training loss).\nProof. We first prove the theorem in a special, 1-dimensional case (when S is a subset of R). Form now it will be assumed that S is a subset of R and \u03a3 = {\u03c31 < . . . < \u03c3n} is a finite subset of S. Let \u03b5 be smaller than 1 5 min(si \u2212 si\u22121), i = 2, . . . , n. We define a function pi as follows\npi(x) =  f(\u03c3i)\u2212g(\u03c3i)\u03b5 \u03b5 (x\u2212 \u03c3i + 2\u03b5) for x \u2208 [\u03c3i \u2212 2\u03b5, \u03c3i \u2212 \u03b5] f(\u03c3i) + g(\u03c3i)(x\u2212 \u03c3i) for x \u2208 [\u03c3i \u2212 \u03b5, \u03c3i + \u03b5] \u2212 f(\u03c3i)+g(\u03c3i)\u03b5 \u03b5 (x\u2212 \u03c3i \u2212 2\u03b5) for x \u2208 [\u03c3i + \u03b5, \u03c3i + 2\u03b5]\n0 otherwise\n.\nNote that the functions pi have disjoint supports for i 6= j. We define h(x) = \u2211n i=1 pi(x). By construction, it has all the desired properties.\nNow let us move to the general case, when S is a subset of Rd. We will denote by \u03c0k a projection of a d-dimensional point \u03c3 onto the k-th coordinate. The obstacle to repeating the 1-dimensional proof in a straightforward matter (coordinate-by-coordinate) is that two or more of the points \u03c3i can have one or more coordinates equal. We will use a linear change of coordinates to get past this technical obstacle. Let A \u2208 GL(d,R) be matrix such that there holds \u03c0k(A\u03c3i) 6= \u03c0k(A\u03c3j) for any i 6= j and any K = 1, . . . , d. Such A exists, as every condition \u03c0k(A\u03c3i) = \u03c0k(A\u03c3j) defines a codimension-one submanifold in the space GL(d,R), thus the complement of the union of all such submanifolds is a full dimension (and thus nonempty) subset of GL(d,R). Using the one-dimensional construction we define functions pk(x), k = 1, . . . , d, such that pk(\u03c0k(A\u03c3i)) = 1df(\u03c3i) and (p\nk)\u2032(\u03c0k(A\u03c3i)) = 0. Similarly, we construct qk(x) in such manner qk(\u03c0k(A\u03c3i)) = 0 and (qk)\u2032(\u03c0k(A\u03c3i)) = A\u22121g(\u03c3i). Note that those definitions a are valid because \u03c0k(A\u03c3i) 6= \u03c0k(A\u03c3j) for i 6= j, so the right sides are well-defined unique numbers.\nIt remains to put all the elements together. This is done as follows. First we extend pk, qk to the whole space R \u201ctrivially\u201d, i.e. for any x \u2208 R, x = (x1, . . . , xd) we define P k(x) := pk(xk). Similarly, Qki (x) := qki (xk). Finally, h(x) := \u2211d k=1 P k(Ax) + \u2211d k=1Q\nk(Ax). This function has the desired properties. Indeed for every \u03c3i we have\nh(\u03c3i) = d\u2211 k=1 P k(A\u03c3i) + d\u2211 k=1 Qk(A\u03c3i) = d\u2211 k=1 pk(\u03c0k(A\u03c3i)) + d\u2211 k=1 0 = f(A\u03c3i)\nand \u2202h\n\u2202x (\u03c3i) = d\u2211 k=1 (P k)\u2032(A\u03c3i) + d\u2211 k=1 (Qk)\u2032(A\u03c3i) = d\u2211 k=1 0 + d\u2211 k=1 \u2202Qk \u2202x (\u03c0k(A\u03c3i)) =\nA d\u2211 k=1 (0, . . . , (qk)\u2032(\u03c0k(A\u03c3i))\nk\n, . . . , 0)T = A \u00b7A\u22121g(\u03c3i) = g(\u03c3i).\nThis completes the proof.\nProposition 3. There holds Ksob(FG) < Kreg(FG) and Ksob(FPL) < Kreg(FPL).\nProof. Gaussian PDF functions form a 2-parameter family 1\u221a 2\u03c0\u03c32\ne \u2212 (x\u2212\u00b5)\n2\n2\u03c32 . Therefore, determining f\nin that family is equivalent to determining the values of \u00b5 and \u03c32. Given \u03b1 = 1\u221a 2\u03c0\u03c32\ne \u2212 (x\u2212\u00b5)\n2\n2\u03c32 , \u03b2 =\n\u2212 x\u2212\u00b5 \u03c32 \u221a 2\u03c0\u03c32 e \u2212 (x\u2212\u00b5)\n2\n2\u03c32 , we get \u03b2 \u03b1 = \u2212x\u2212\u00b5 \u03c32\nand 2 ln( \u221a 2\u03c0\u03b1) = \u2212 ln(\u03c32) \u2212 (x\u2212\u00b5) 2\n\u03c32 . Thus 2 ln(\n\u221a 2\u03c0\u03b1) =\n\u2212 ln(\u03c32)\u2212 \u03b2 2\n\u03b12 \u03c32. The right hand side is a strictly decreasing function of \u03c32. Substituting its unique solution to\n\u03b2 \u03b1 = \u2212x\u2212\u00b5 \u03c32 we determine \u00b5. Thus Ksob is equal to 1 for the family of Gaussian PDF functions.\nOn the other hand, there holds Kreg > 2 for the family of Gaussian PDF functions. For example, N(2, 1) and N(2.847..., 1.641...) have the same values at x = 0 and x = 3 (existence of a \u201creal\u201d solution near this approximate solution is an immediate consequence of the Implicit Function Theorem). This ends the proof for the FG family\nWe will discuss the family FPL now. Every linear function is uniquely determined by its value at a single point and its derivative. Thus, for any function f \u2208 FPL, as the partition D = D1 \u222a . . . \u222aDn is fixed, it is sufficient to know the values and the values of the derivative of f in \u03c31 \u2208 Dn, . . . , \u03c31 \u2208 Dn to determine it uniquely. On the other hand, we need at least d+ 1 (recall that d is the dimension of the domain of f ) in each of the domains Di to determine f uniquely, if we are allowed to look only at the values."}, {"heading": "2 Artificial Datasets", "text": "Functions used (visualised at Figures 5-11):\n\u2022 Ackley\u2019s f(x, y) = \u221220 exp ( \u22120.2 \u221a 0.5(x2 + y2) ) \u2212 exp (0.5(cos(2\u03c0x) + cos(2\u03c0y))) + e+ 20,\nfor x, y \u2208 [\u22125, 5]\u00d7 [\u22125, 5] \u2022 Beale\u2019s\nf(x, y) = (1.5\u2212 x+ xy)2 + (2.25\u2212 x+ xy2)2 + (2.625\u2212 x+ xy3)2, for x, y \u2208 [\u22124.5, 4.5]\u00d7 [\u22124.5, 4.5]\n\u2022 Booth f(x, y) = (x+ 2y \u2212 7)2 + (2x+ y \u2212 5)2,\nfor x, y \u2208 [\u221210, 10]\u00d7 [\u221210, 10] \u2022 Bukin\nf(x, y) = 100 \u221a |y = 0.01x2|+ 0.01|x+ 10|,\nfor x, y \u2208 [\u221215,\u22125]\u00d7 [\u22123, 3] \u2022 McCormick\nf(x, y) = sin(x+ y) + (x\u2212 y)2 \u2212 1.5x+ 2.5y + 1, for x, y \u2208 [\u22121.5, 4]\u00d7 [\u22123, 4]\n\u2022 Rosenbrock f(x, y) = 100(y \u2212 x2)2 + (x\u2212 1)2,\nfor x, y \u2208 [\u22122, 2]\u00d7 [\u22122, 2] \u2022 Styblinski-Tang\nf(x, y) = 0.5(x4 \u2212 16x2 + 5x+ y4 \u2212 16y2 + 5y), for x, y \u2208 [\u22125, 5]\u00d7 [\u22125, 5]\nNetworks were trained using the Adam optimiser with learning rate 3e \u2212 5. Training set has been sampled uniformly from the domain provided. Test set consists always of 10,000 points sampled uniformly from the same domain."}, {"heading": "3 Policy Distillation", "text": "Agents policies are feed forward networks consisting of:\n\u2022 32 8x8 kernels with stride 4 \u2022 ReLU nonlinearity\n\u2022 64 4x4 kernels with stride 2\n\u2022 ReLU nonlinearity\n\u2022 64 3x3 kernels with stride 1\n\u2022 ReLU nonlinearity\n\u2022 Linear layer with 512 units\n\u2022 ReLU nonlinearity\n\u2022 Linear layer with 3 (Pong), 4 (Breakout) or 6 outputs (Space Invaders)\n\u2022 Softmax\nThey were trained with A3C [15] over 80e6 steps, using history of length 4, greyscaled input, and action repeat 4. Observations were scaled down to 84x84 pixels.\nData has been gathered by running trained policy to gather 100K frames (thus for 400K actual steps). Split into train and test sets has been done time-wise, ensuring that test frames come from different episodes than the training ones.\nDistillation network consists of:\n\u2022 16 8x8 kernels with stride 4\n\u2022 ReLU nonlinearity\n\u2022 32 4x4 kernels with stride 2\n\u2022 ReLU nonlinearity\n\u2022 Linear layer with 256 units\n\u2022 ReLU nonlinearity\n\u2022 Linear layer with 3 (Pong), 4 (Breakout) or 6 outputs (Space Invaders)\n\u2022 Softmax\nand was trained using Adam optimiser with learning rate fitted independently per game and per approach between 1e\u2212 3 and 1e\u2212 5. Batch size is 200 frames, randomly selected from the training set."}, {"heading": "4 Synthetic Gradients", "text": "All models were trained using multi-GPU optimisation, with Sync main network updates and Hogwild SG module updates."}, {"heading": "4.1 Meaning of Sobolev losses for synthetic gradients", "text": "In the setting considered, the true label y is used only as a conditioning, however one could also provide supervision for \u2202m(h, y|\u03b8)/\u2202y. So what is the actual effect this Sobolev losses have on SG estimator? For L being log loss, it is easy to show, that they are additional penalties on matching log p(h, y) to log ph, namely:\n\u2016\u2202m(h, y|\u03b8)/\u2202y \u2212 \u2202L(h, y)/\u2202y\u20162 = \u2016 log p(h|\u03b8)\u2212 log ph\u20162\n\u2016m(h, y|\u03b8)\u2212 L(h, y)\u20162 = (log p(h|\u03b8)y\u0302 \u2212 log phy\u0302) 2,\nwhere y\u0302 is the index of \u201c1\u201d in the one-hot encoded label vector y. Consequently loss supervision makes sure that the internal prediction log p(h|\u03b8) for the true label y\u0302 is close to the current prediction of the whole model log ph. On the other hand matching partial derivatives wrt. to label makes sure that predictions for all the classes are close to each other. Finally if we use both \u2013 we get a weighted sum, where penalty for deviating from the prediction on the true label is more expensive, than on all remaining ones5."}, {"heading": "4.2 Cifar10", "text": "All Cifar10 experiments use a deep convolutional network of following structure:\n\u2022 64 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 64 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 128 3x3 kernels with stride 2 \u2022 BatchNorm and ReLU nonlinearity \u2022 128 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 128 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 256 3x3 kernels with stride 2 \u2022 BatchNorm and ReLU nonlinearity \u2022 256 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 256 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 512 3x3 kernels with stride 2 \u2022 BatchNorm and ReLU nonlinearity \u2022 512 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 512 3x3 kernels with stride 1 \u2022 BatchNorm and ReLU nonlinearity \u2022 Linear layer with 10 outputs \u2022 Softmax\nwith L2 regularisation of 1e\u2212 4. The network is trained in an asynchronous manner, using 10 GPUs in parallel. Each worker uses batch size of 32. The main optimiser is Stochastic Gradient Descent with momentm of 0.9. The learning rate is initialised to 0.1 and then dropped by an order of magniture after 40K, 60K and finally after 80K updates.\nEach of the three SG modules is a convolutional network consisting of:\n\u2022 128 3x3 kernels with stride 1 5Adding \u2202L/\u2202y supervision on toy MNIST experiments increased convergence speed and stability, however due to TensorFlow currently not supporting differentiating cross entropy wrt. to labels, it was omitted in our large-scale experiments.\n\u2022 ReLU nonlinearity \u2022 Linear layer with 10 outputs \u2022 Softmax\nIt is trained using the Adam optimiser with learning rate 1e\u2212 4, no learning rate schedule is applied. Updates of the synthetic gradient module are performed in a Hogwild manner. Losses used for both loss prediction and gradient estimation are L1.\nFor direct SG model we used architecture described in the original paper \u2013 3 resolution preserving layers of 128 kernels of 3x3 convolutions with ReLU activations in between. The only difference is that we use L1 penalty instead of L2 as empirically we found it working better for the tasks considered."}, {"heading": "4.3 Imagenet", "text": "All ImageNet experiments use ResNet50 network with L2 regularisation of 1e\u2212 4. The network is trained in an asynchronous manner, using 34 GPUs in parallel. Each worker uses batch size of 32. The main optimiser is Stochastic Gradient Descent with momentum of 0.9. The learning rate is initialised to 0.1 and then dropped by an order of magnitude after 100K, 150K and finally after 175K updates.\nThe SG module is a convolutional network, attached after second ResNet block, consisting of:\n\u2022 64 3x3 kernels with stride 1 \u2022 ReLU nonlinearity \u2022 64 3x3 kernels with stride 2 \u2022 ReLU nonlinearity \u2022 Global averaging \u2022 1000 1x1 kernels \u2022 Softmax\nIt is trained using the Adam optimiser with learning rate 1e\u2212 4, no learning rate schedule is applied. Updates of the synthetic gradient module are performed in a Hogwild manner. Sobolev losses are set to L1.\nRegular data augmentation has been applied during training, taken from the original Inception V1 paper."}], "references": [{"title": "Tensorflow: Large-scale machine learning on heterogeneous distributed systems", "author": ["Mart\u00edn Abadi", "Ashish Agarwal", "Paul Barham", "Eugene Brevdo", "Zhifeng Chen", "Craig Citro", "Greg S Corrado", "Andy Davis", "Jeffrey Dean", "Matthieu Devin"], "venue": "arXiv preprint arXiv:1603.04467,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2016}, {"title": "Imagenet: A large-scale hierarchical image database", "author": ["Jia Deng", "Wei Dong", "Richard Socher", "Li-Jia Li", "Kai Li", "Li Fei-Fei"], "venue": "In Computer Vision and Pattern Recognition,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "On learning the derivatives of an unknown mapping with multilayer feedforward networks", "author": ["A Ronald Gallant", "Halbert White"], "venue": "Neural Networks,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1992}, {"title": "Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding", "author": ["Song Han", "Huizi Mao", "William J Dally"], "venue": "arXiv preprint arXiv:1510.00149,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "Deep residual learning for image recognition", "author": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun"], "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2016}, {"title": "Distilling the knowledge in a neural network", "author": ["Geoffrey Hinton", "Oriol Vinyals", "Jeff Dean"], "venue": "arXiv preprint arXiv:1503.02531,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Approximation capabilities of multilayer feedforward networks", "author": ["Kurt Hornik"], "venue": "Neural networks,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1991}, {"title": "Estimation of non-normalized statistical models using score matching", "author": ["Aapo Hyv\u00e4rinen"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2005}, {"title": "Decoupled neural interfaces using synthetic gradients", "author": ["Max Jaderberg", "Wojciech Marian Czarnecki", "Simon Osindero", "Oriol Vinyals", "Alex Graves", "Koray Kavukcuoglu"], "venue": "arXiv preprint arXiv:1608.05343,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2016}, {"title": "Actor-critic algorithms", "author": ["Vijay R Konda", "John N Tsitsiklis"], "venue": "In NIPS,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "Handbook of complex variables", "author": ["Steven G Krantz"], "venue": "Springer Science & Business Media,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Neural networks for control", "author": ["W Thomas Miller", "Paul J Werbos", "Richard S Sutton"], "venue": "MIT press,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1995}, {"title": "Synthetic gradient methods with virtual forward-backward networks", "author": ["Takeru Miyato", "Daisuke Okanohara", "Shin-ichi Maeda", "Koyama Masanori"], "venue": "ICLR workshop proceedings,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2017}, {"title": "Asynchronous methods for deep reinforcement learning", "author": ["Volodymyr Mnih", "Adria Puigdomenech Badia", "Mehdi Mirza", "Alex Graves", "Timothy Lillicrap", "Tim Harley", "David Silver", "Koray Kavukcuoglu"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2016}, {"title": "Playing atari with deep reinforcement learning", "author": ["Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Alex Graves", "Ioannis Antonoglou", "Daan Wierstra", "Martin Riedmiller"], "venue": "arXiv preprint arXiv:1312.5602,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "Revisiting natural gradient for deep networks", "author": ["Razvan Pascanu", "Yoshua Bengio"], "venue": "arXiv preprint arXiv:1301.3584,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2013}, {"title": "Higher order contractive auto-encoder", "author": ["Salah Rifai", "Gr\u00e9goire Mesnil", "Pascal Vincent", "Xavier Muller", "Yoshua Bengio", "Yann Dauphin", "Xavier Glorot"], "venue": "Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Policy distillation", "author": ["Andrei A Rusu", "Sergio Gomez Colmenarejo", "Caglar Gulcehre", "Guillaume Desjardins", "James Kirkpatrick", "Razvan Pascanu", "Volodymyr Mnih", "Koray Kavukcuoglu", "Raia Hadsell"], "venue": "arXiv preprint arXiv:1511.06295,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Deep model compression: Distilling knowledge from noisy teachers", "author": ["Bharat Bhusan Sau", "Vineeth N Balasubramanian"], "venue": "arXiv preprint arXiv:1610.09650,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2016}, {"title": "Mastering the game of go with deep neural networks and tree", "author": ["David Silver", "Aja Huang", "Chris J Maddison", "Arthur Guez", "Laurent Sifre", "George Van Den Driessche", "Julian Schrittwieser", "Ioannis Antonoglou", "Veda Panneershelvam", "Marc Lanctot"], "venue": "search. Nature,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2016}, {"title": "Tangent prop-a formalism for specifying selected invariances in an adaptive network", "author": ["Patrice Simard", "Bernard Victorri", "Yann LeCun", "John S Denker"], "venue": "In NIPS,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1991}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["Karen Simonyan", "Andrew Zisserman"], "venue": "arXiv preprint arXiv:1409.1556,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2014}, {"title": "Wavenet: A generative model for raw audio", "author": ["A\u00e4ron van den Oord", "Sander Dieleman", "Heiga Zen", "Karen Simonyan", "Oriol Vinyals", "Alex Graves", "Nal Kalchbrenner", "Andrew Senior", "Koray Kavukcuoglu"], "venue": "CoRR abs/1609.03499,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2016}, {"title": "A connection between score matching and denoising autoencoders", "author": ["Pascal Vincent"], "venue": "Neural computation,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2011}, {"title": "Approximate dynamic programming for real-time control and neural modeling", "author": ["Paul J Werbos"], "venue": "Handbook of intelligent control,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1992}], "referenceMentions": [{"referenceID": 4, "context": "They are consistently proven to be powerful function approximators, able to model a wide variety of functional forms \u2013 from image recognition [6, 23], through audio synthesis [24], to human-beating policies in the ancient game of GO [21].", "startOffset": 142, "endOffset": 149}, {"referenceID": 21, "context": "They are consistently proven to be powerful function approximators, able to model a wide variety of functional forms \u2013 from image recognition [6, 23], through audio synthesis [24], to human-beating policies in the ancient game of GO [21].", "startOffset": 142, "endOffset": 149}, {"referenceID": 22, "context": "They are consistently proven to be powerful function approximators, able to model a wide variety of functional forms \u2013 from image recognition [6, 23], through audio synthesis [24], to human-beating policies in the ancient game of GO [21].", "startOffset": 175, "endOffset": 179}, {"referenceID": 19, "context": "They are consistently proven to be powerful function approximators, able to model a wide variety of functional forms \u2013 from image recognition [6, 23], through audio synthesis [24], to human-beating policies in the ancient game of GO [21].", "startOffset": 233, "endOffset": 237}, {"referenceID": 5, "context": "A common example is when the ground truth function is itself a neural network; for instance this is the case for distillation [7, 19], compressing neural networks [5], and the prediction of synthetic gradients [10].", "startOffset": 126, "endOffset": 133}, {"referenceID": 17, "context": "A common example is when the ground truth function is itself a neural network; for instance this is the case for distillation [7, 19], compressing neural networks [5], and the prediction of synthetic gradients [10].", "startOffset": 126, "endOffset": 133}, {"referenceID": 3, "context": "A common example is when the ground truth function is itself a neural network; for instance this is the case for distillation [7, 19], compressing neural networks [5], and the prediction of synthetic gradients [10].", "startOffset": 163, "endOffset": 166}, {"referenceID": 8, "context": "A common example is when the ground truth function is itself a neural network; for instance this is the case for distillation [7, 19], compressing neural networks [5], and the prediction of synthetic gradients [10].", "startOffset": 210, "endOffset": 214}, {"referenceID": 6, "context": "The approach is inspired by the work of Hornik [8] which proved the universal approximation theorems for neural networks in Sobolev spaces \u2013 metric spaces where distances between functions are defined both in terms of their differences in values and differences in values of their derivatives.", "startOffset": 47, "endOffset": 50}, {"referenceID": 16, "context": "by pushing Jacobian norm to 0 [18]), or to encode additional, hand crafted invariances to some transformations (for instance, as in Tangentprop [22]), or estimated derivatives for dynamical systems [4].", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "by pushing Jacobian norm to 0 [18]), or to encode additional, hand crafted invariances to some transformations (for instance, as in Tangentprop [22]), or estimated derivatives for dynamical systems [4].", "startOffset": 144, "endOffset": 148}, {"referenceID": 2, "context": "by pushing Jacobian norm to 0 [18]), or to encode additional, hand crafted invariances to some transformations (for instance, as in Tangentprop [22]), or estimated derivatives for dynamical systems [4].", "startOffset": 198, "endOffset": 201}, {"referenceID": 24, "context": "Similar techniques have also been used in critic based Reinforcement Learning (RL), where a critic\u2019s derivatives are trained to match its target\u2019s derivatives [26, 13] using shallow, sigmoid based models.", "startOffset": 159, "endOffset": 167}, {"referenceID": 11, "context": "Similar techniques have also been used in critic based Reinforcement Learning (RL), where a critic\u2019s derivatives are trained to match its target\u2019s derivatives [26, 13] using shallow, sigmoid based models.", "startOffset": 159, "endOffset": 167}, {"referenceID": 7, "context": "Finally, Hyv\u00e4rinen proposed Score Matching Networks [9], which are based on the somewhat surprising observation that one can model unknown derivatives of the function without actual access to its values \u2013 all that is needed is a sampling based strategy and specific penalty.", "startOffset": 52, "endOffset": 55}, {"referenceID": 23, "context": "However, such an estimator has a high variance [25], thus it is not really useful when true derivatives are given.", "startOffset": 47, "endOffset": 51}, {"referenceID": 6, "context": "(2): We look formally at the implications of matching derivatives, extending previous results of Hornik [8] and showing that modern architectures are well suited for such training regimes.", "startOffset": 104, "endOffset": 107}, {"referenceID": 16, "context": "To avoid adding computational complexity to the training process, one can use an efficient, stochastic version of Sobolev Training: instead of computing a full Jacobian/Hessian, one just computes its projection onto a random vector (a direct application of a known estimation trick [18]).", "startOffset": 282, "endOffset": 286}, {"referenceID": 6, "context": "Hornik showed [8] that neural networks with non-constant, bounded, continuous activation functions, with continuous derivatives up to order K are universal approximators in the Sobolev spaces of order K, thus showing that sigmoid-networks are indeed capable of approximating elements of these spaces arbitrarily well.", "startOffset": 14, "endOffset": 17}, {"referenceID": 10, "context": "We will use a standard symbol C1(S) (or simply C1) to denote a space of functions which are continuous, differentiable, and have a continuous derivative on a space S [12].", "startOffset": 166, "endOffset": 170}, {"referenceID": 0, "context": "All experiments were performed using TensorFlow [1] and the Sonnet neural network library [2].", "startOffset": 48, "endOffset": 51}, {"referenceID": 18, "context": "This technique has many applications, such as network compression [20], ensemble merging [7], or more recently policy distillation in reinforcement learning [19].", "startOffset": 66, "endOffset": 70}, {"referenceID": 5, "context": "This technique has many applications, such as network compression [20], ensemble merging [7], or more recently policy distillation in reinforcement learning [19].", "startOffset": 89, "endOffset": 92}, {"referenceID": 17, "context": "This technique has many applications, such as network compression [20], ensemble merging [7], or more recently policy distillation in reinforcement learning [19].", "startOffset": 157, "endOffset": 161}, {"referenceID": 14, "context": "As target policies \u03c0\u2217, we use agents playing Atari games [16] that have been trained with A3C [15] on three well known games: Pong, Breakout and Space Invaders.", "startOffset": 57, "endOffset": 61}, {"referenceID": 13, "context": "As target policies \u03c0\u2217, we use agents playing Atari games [16] that have been trained with A3C [15] on three well known games: Pong, Breakout and Space Invaders.", "startOffset": 94, "endOffset": 98}, {"referenceID": 8, "context": "Noprop Direct SG [10] VFBN [14] Critic Sobolev CIFAR-10 with 3 synthetic gradient modules Top 1 (94.", "startOffset": 17, "endOffset": 21}, {"referenceID": 12, "context": "Noprop Direct SG [10] VFBN [14] Critic Sobolev CIFAR-10 with 3 synthetic gradient modules Top 1 (94.", "startOffset": 27, "endOffset": 31}, {"referenceID": 8, "context": "One recent technique, which requires a model of gradients is Synthetic Gradients (SG) [10] \u2013 a method for training complex neural networks in a decoupled, asynchronous fashion.", "startOffset": 86, "endOffset": 90}, {"referenceID": 9, "context": "This setting closely resembles what is known in reinforcement learning as critic methods [11].", "startOffset": 89, "endOffset": 93}, {"referenceID": 12, "context": "Similarly if we do not provide supervision at the loss level, but only on the gradient component, we end up in a method that resembles VFBN [14].", "startOffset": 140, "endOffset": 144}, {"referenceID": 1, "context": "For ImageNet [3] experiments based on ResNet50 [6], we obtain qualitatively similar results.", "startOffset": 13, "endOffset": 16}, {"referenceID": 4, "context": "For ImageNet [3] experiments based on ResNet50 [6], we obtain qualitatively similar results.", "startOffset": 47, "endOffset": 50}, {"referenceID": 15, "context": "For example curvature [17] is believed to be connected to uncertainty.", "startOffset": 22, "endOffset": 26}], "year": 2017, "abstractText": "At the heart of deep learning we aim to use neural networks as function approximators \u2013 training them to produce outputs from inputs in emulation of a ground truth function or data creation process. In many cases we only have access to input-output pairs from the ground truth, however it is becoming more common to have access to derivatives of the target output with respect to the input \u2013 for example when the ground truth function is itself a neural network such as in network compression or distillation. Generally these target derivatives are not computed, or are ignored. This paper introduces Sobolev Training for neural networks, which is a method for incorporating these target derivatives in addition the to target values while training. By optimising neural networks to not only approximate the function\u2019s outputs but also the function\u2019s derivatives we encode additional information about the target function within the parameters of the neural network. Thereby we can improve the quality of our predictors, as well as the data-efficiency and generalization capabilities of our learned function approximation. We provide theoretical justifications for such an approach as well as examples of empirical evidence on three distinct domains: regression on classical optimisation datasets, distilling policies of an agent playing Atari, and on large-scale applications of synthetic gradients. In all three domains the use of Sobolev Training, employing target derivatives in addition to target values, results in models with higher accuracy and stronger generalisation.", "creator": "LaTeX with hyperref package"}}}