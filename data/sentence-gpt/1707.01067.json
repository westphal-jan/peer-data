{"id": "1707.01067", "review": {"conference": "nips", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Jul-2017", "title": "ELF: An Extensive, Lightweight and Flexible Research Platform for Real-time Strategy Games", "abstract": "In this paper, we propose ELF, an Extensive, Lightweight and Flexible platform for fundamental reinforcement learning research. Using ELF, we implement a highly customizable real-time strategy (RTS) engine with three game environments (Mini-RTS, Capture the Flag and Tower Defense). Mini-RTS, as a miniature version of StarCraft, captures key game dynamics and runs at 40K frame-per-second (FPS) per core on a Macbook Pro notebook. When coupled with modern reinforcement learning methods, the system can train a full-game bot against built-in AIs end-to-end in one day with 6 CPUs and 1 GPU. In addition, our platform is flexible in terms of environment-agent communication topologies, choices of RL methods, changes in game parameters, and can host existing C/C++-based game environments like Arcade Learning Environment. Using ELF, we thoroughly explore training parameters and show that a network with Leaky ReLU and Batch Normalization coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than $70\\%$ of the time in the full game of Mini-RTS. Strong performance is also achieved on the other two games. In game replays, we show our agents learn interesting strategies. ELF, along with its RL platform, will be open-sourced.", "histories": [["v1", "Tue, 4 Jul 2017 16:48:56 GMT  (2309kb,D)", "http://arxiv.org/abs/1707.01067v1", "Submission to NIPS 2017"]], "COMMENTS": "Submission to NIPS 2017", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yuandong tian", "qucheng gong", "wenling shang", "yuxin wu", "larry zitnick"], "accepted": true, "id": "1707.01067"}, "pdf": {"name": "1707.01067.pdf", "metadata": {"source": "CRF", "title": "ELF: An Extensive, Lightweight and Flexible Research Platform for Real-time Strategy Games", "authors": ["Yuandong Tian", "Qucheng Gong", "Wenling Shang", "Yuxin Wu", "Larry Zitnick"], "emails": ["yuandong@fb.com", "qucheng@fb.com", "wendy.shang@oculus.com", "yuxinwu@fb.com", "zitnick@fb.com"], "sections": [{"heading": "1 Introduction", "text": "Game environments are commonly used for research in Reinforcement Learning (RL), i.e. how to train intelligent agents to behave properly from sparse rewards [4, 6, 5, 13, 27]. Compared to the real world, game environments offer an infinite amount of highly controllable, fully reproducible, and automatically labeled data. Ideally, a game environment for fundamental RL research is:\n\u2022 Extensive: The environment should capture many diverse aspects of the real world, such as rich dynamics, partial information, delayed/long-term rewards, concurrent actions with different granularity, etc. Having an extensive set of features and properties increases the potential for trained agents to generalize to diverse real-world scenarios.\n\u2022 Lightweight: A platform should be fast and capable of generating samples hundreds or thousands of times faster than real-time with minimal compute resources (e.g., a single machine). Lightweight and efficient platforms help accelerate academic research of RL algorithms, particularly for methods which are heavily data-dependent.\n\u2022 Flexible: A platform that is easily customizable at different levels, including rich choices of environment content, easy manipulation of game parameters, accessibility of internal\nar X\niv :1\n70 7.\n01 06\n7v 1\n[ cs\n.A I]\n4 J\nvariables, and flexibility of training architectures. All are important for fast exploration of different algorithms. For example, changing environment parameters [33], as well as using internal data [14, 18] have been shown to lead to a substantial acceleration in training.\nNo current game platforms satisfy these criteria. Modern commercial games (e.g., StarCraft I/II, GTA V) are extremely realistic, but are not customizable and require significant compute resources for complex graphics and for costs related to platform-shifting (e.g., a virtual machine to host Windows-only SC I on Linux). Old games and their wrappers [4, 6, 5, 13]) are substantially faster, but are less realistic with limited customizability. On the other hand, games designed for research purpose (e.g., MazeBase [27], \u00b5RTS [21]) are efficient and highly customizable, but are not very extensive in their capabilities. Furthermore, none of the environments consider simulation concurrency, and thus have limited flexibility with different training architectures. For instance, the interplay between RL methods and environments during training is often limited to providing simplistic interfaces (e.g., one interface for one game) in scripting languages like Python.\nIn this paper, we propose ELF, a research-oriented platform that offers games with diverse properties, efficient simulation, and highly customizable environment settings. The platform allows for both game parameter changes and new game additions. The training of RL methods is deeply and flexibly integrated into the environment, with an emphasis on concurrent simulations. On ELF, we build a real-time strategy (RTS) game engine that includes three initial environments including Mini-RTS, Capture the Flag and Tower Defense. Mini-RTS is a miniature custom-made RTS game that captures all the basic dynamics of StarCraft (fog-of-war, resource gathering, troop building, defense/attack with troops, etc). Mini-RTS runs at 165K FPS on a 4 core MacBook Pro, which is faster than existing environments by an order of magnitude. This enables us for the first time to train end-to-end a full-game bot against built-in AIs. Moreover, training is accomplished in only one day using 6 CPUs and 1 GPU. The other two games can be trained with similar (or higher) efficiency.\nMany real-world scenarios and complex games (e.g. StarCraft) are hierarchical in nature. Our RTS engine has full access to the game data and has a built-in hierarchical command system, which allows training at any level of the command hierarchy. As we demonstrate, this allows us to train a full-game bot that acts on the top-level strategy in the hierarchy while lower-level commands are handled using build-in tactics. Previously, most research on RTS games focused only on lower-level scenarios such as tactical battles [32, 23]. The full access to the game data also allows for supervised training with small-scale internal data.\nELF is resilient to changes in the topology of the environment-actor communication used for training, thanks to its hybrid C++/Python framework. These include one-to-one, many-to-one and oneto-many mappings. In contrast, existing environments (e.g., OpenAI Gym [6] and Universe [31]) wrap one game in one Python interface, which makes it cumbersome to change topologies. Parallelism is implemented in C++, which is essential for simulation acceleration. Finally, ELF is capable of hosting any existing game written in C/C++, including Atari games (e.g., ALE [4]), board games (e.g. Chess and Go [30]), and physics engines, by writing a simple adaptor.\nEquipped with a flexible RL backend powered by PyTorch, we experiment with numerous baselines, and highlight effective techniques used in training. We show the first demonstration of end-toend trained AIs for real-time strategy games with partial information. We use the Asynchronous Advantagous Actor-Critic (A3C) model [19] and explore extensive design choices including frameskip, temporal horizon, network structure, curriculum training, etc. We show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in full-game Mini-RTS. We also show stronger performance in others games. ELF and its RL platform, will be open-sourced."}, {"heading": "2 Architecture", "text": "Fig. 1 shows the simple architecture of ELF, which follows a canonical producer-consumer model. The producer plays N games, each in a single C thread. When a batch of M current game states are ready (M < N ), the corresponding games are blocked and the batch are sent to the Python side via the daemon. The consumers (e.g., actor, optimizer or others) get batched experience with history information via a Python/C++ interface and send back the replies to the blocked batch of the games, which are waiting for the next action and/or values, so that they can proceed. For simplicity, the producer and consumers are in the same process. However, they can also live in different processes,\nor even on different machines. Before the training (or evaluation) starts, different consumers register themselves for batches with different history length. For example, an actor might need a batch with short history, while an optimizer (e.g., T -step actor-critic) needs a batch with longer history. During training, the consumers use the batch in various ways. For example, the actor takes the batch and returns the probabilties of actions (and values), then the actions are sampled and sent back. The batch received by the optimizer already contains the sampled actions from the previous steps, and can be used to drive reinforcement learning algorithms such as A3C. Here is a sample usage of ELF:\n1 # We run 1024 games concurrently . 2 num games = 1024 3 4 # Wait for a batch of 256 games. 5 batchsize = 256 6 7 # The return states contain key \u2019s \u2019, \u2019 r \u2019 and \u2019 terminal \u2019 8 # The reply contains key \u2019a\u2019 to be filled from the Python side . 9 # The definitions of the keys are in the wrapper of the game.\n10 input spec = dict (s=\u2019\u2019 , r=\u2019\u2019 , terminal =\u2019\u2019 ) 11 reply spec = dict (a=\u2019\u2019 ) 12 13 context = Init (num games, batchsize , input spec , reply spec )\nInitialization of ELF\n1 # Start all game threads and enter main loop . 2 context . Start () 3 while True: 4 # Wait for a batch of game states to be ready 5 # These games will be blocked, waiting for replies . 6 batch = context .Wait() 7 8 # Apply a model to the game state . The output has key \u2019pi \u2019 9 output = model(batch)\n10 11 # Sample from the output to get the actions of this batch . 12 reply [ \u2019a\u2019 ][:] = SampleFromDistribution(output ) 13 14 # Resume games. 15 context . Steps () 16 17 # Stop all game threads . 18 context .Stop()\nMain loop of ELF\nParallelism using C threads. Modern reinforcement learning methods often require heavy parallelism to obtain diverse experiences [19, 20]. Most existing RL environments (OpenAI Gym [6] and Universe [31], RLE [5], Atari [4], Doom [13]) provide Python interfaces which wrap only single game instances. As a result, parallelism needs to be built in Python when applying modern RL methods. However, thread-level parallelism in Python can only poorly utilize multi-core processors, due to the Global Interpreter Lock1. Process-level parallelism will also introduce extra data exchange overhead between processes and increase complexity to framework design. In contrast, our parallelism is achieved with C threads for better scaling on multi-core CPUs.\nFlexible Environment-Model Configurations. In ELF, one or multiple consumers can be used. Each consumer knows the game environment identity from received batches, and typically contains one neural network model. The models of different consumers may or may not share parameters, might update the weights, might reside in different processes or even on different machines. This architecture offers flexibility for switching topologies between game environments and models. We can assign one model to each game environment, or one-to-one (e.g, vanilla A3C [19]), in which each agent follows and updates its own copy of the model. Similarly, multiple environments can be assigned to a single model, or many-to-one (e.g., BatchA3C [33] or GA3C [1]), where the model can perform batched forward prediction to better utilize GPUs. We can also incorporate forwardplanning methods (e.g., Monte-Carlo Tree Search (MCTS) [7, 30, 25]) and Self-Play, in which at one time step, a single environment might emit multiple states processed by multiple models, or one-to-many. Using ELF, these training configurations can be tested with minimal changes.\nHighly customizable and unified interface. Games implemented with our RTS engine can be trained using raw pixel data or lower-dimensional internal game data. Internal game data is impor-\n1Global Interpreter Lock (GIL) in Python forbids the interpretation of multiple statements simultaneously, even on multi-core CPUs.\ntant for research focusing on reasoning tasks rather than perceptual ones. Note that web-based visual renderings is also supported (e.g., Fig. 3(a)) for case-by-case debugging.\nELF allows for a unified interface capable of hosting any existing game written in C/C++, including Atari games (e.g., ALE [4]), board games (e.g. Chess and Go [30]), and a customized RTS engine, with a simple adaptor. This enables the easy multi-threading of existing games and their training using existing RL methods. Besides, we also provide three concrete game environments based on RTS engine, as described in Sec. 3. Fig. 2 summarizes the hierarchical structure of ELF.\nReinforcement Learning backend. We propose a Python-based RL backend. It has a flexible design that decouples RL methods from models. Multiple baseline methods (e.g., A3C [19], Policy Gradient [28], Q-learning, Trust Region Policy Optimization [24], etc) are implemented, mostly with very few lines of Python codes."}, {"heading": "3 Real-time strategy Games", "text": "Real-time strategy (RTS) games are considered to be one of the next grand AI challenges after Chess and Go [25]. In RTS games, players commonly gather resources, build units (facilities, troops, etc), and explore the environment in the fog-of-war (i.e., regions outside the sight of units are invisible) to invade/defend the enemy, until one player wins. RTS games are known for their exponential and changing action space (e.g., 510 possible actions for 10 units with 5 choices each), subtle game situations, and long-delayed rewards. Typically professional players take 200-300 actions per minute, and the game lasts for 20-30 minutes.\nVery few existing RTS engines can be used directly for research. Commercial RTS games (e.g., StarCraft I/II) have sophisticated dynamics, interactions and graphics. The game play strategies have been long proven to be complex. Moreover, they are close-source with unknown internal states, and cannot be easily utilized for research. Open-source RTS games like Spring [11], OpenRA [22] and Warzone 2100 [26] focus on complex graphics and effects, convenient user interface, stable network play, flexible map editors and plug-and-play mods (i.e., game extensions). Most of them use rule-based AIs, do not intend to run faster than real-time, and offer no straightforward interface with modern machine learning architectures. ORTS [8], BattleCode [2] and RoboCup Simulation League [15] are designed for coding competitions and focused on rule-based AIs. Research-oriented platforms (e.g., \u00b5RTS [21], MazeBase [27]) are fast and simple, often coming with various baselines,\nbut often with much simpler dynamics than RTS games. Recently, TorchCraft [29] provides APIs for StarCraft I to access its internal game states. However, one docker is used to host one StarCraft engine, and is resource-consuming. Tbl. 1 summarizes the difference."}, {"heading": "3.1 Our approach", "text": "Many popular RTS games and its variants (e.g., StarCraft, DoTA, Leagues of Legends, Tower Defense) share the same structure: a few units are controlled by a player, to move, attack, gather or cast special spells, to influence their own or an enemy\u2019s army. With our command hierarchy, a new game can be created by changing (1) available commands (2) available units, and (3) how each unit emits commands triggered by certain scenarios. For this, we offer simple yet effective tools. Researchers can change these variables either by adding commands in C++, or by writing game scripts (e.g., Lua). All derived games share the mechanism of hierarchical commands, replay, etc. Rule-based AIs can also be extended similarly. We provide the following three games: Mini-RTS, Capture the Flag and Tower Defense (Fig. 3(b)). These games share the following properties:\nGameplay. Units in each game move with real coordinates, have dimensions and collision checks, and perform durative actions. The RTS engine is tick-driven. At each tick, AIs make decisions by sending commands to units based on observed information. Then commands are executed, the game\u2019s state changes, and the game continues. Despite a fair complicated game mechanism, MiniRTS is able to run 40K frames-per-second per core on a MacBook Pro laptop, an order of magnitude faster than most existing environments. Therefore, bots can be trained in a day on a single machine.\nBuilt-in hierarchical command levels. An agent could issue strategic commands (e.g., more aggressive expansion), tactical commands (e.g., hit and run), or micro-command (e.g., move a particular unit backward to avoid damage). Ideally strong agents master all levels; in practice, they may focus on a certain level of command hierarchy, and leave others to be covered by hard-coded rules. For this, our RTS engine uses a hierarchical command system that offers different levels of controls over the game. A high-level command may affect all units, by issuing low-level commands. A low-level, unit-specific durative command lasts a few ticks until completion during which per-tick immediate commands are issued.\nBuilt-in rule-based AIs. We have designed rule-based AIs along with the environment. These AIs have access to all the information of the map and follow fixed strategies (e.g., build 5 tanks and attack the opponent base). These AIs act by sending high-level commands which are then translated to low-level ones and then executed.\nWith ELF, for the first time, we are able to train full-game bots for real-time strategy games and achieve stronger performance than built-in rule-based AIs. In contrast, existing RTS AIs are either rule-based or focused on tactics (e.g., 5 units vs. 5 units). We run experiments on the three games to justify the usability of our platform."}, {"heading": "4 Experiments", "text": ""}, {"heading": "4.1 Benchmarking ELF", "text": "We run ELF on a single server with a different number of CPU cores to test the efficiency of parallelism. Fig. 4(a) shows the results when running Mini-RTS. We can see that ELF scales well with the number of CPU cores used to run the environments. We also embed Atari emulator [4] into our platform and check the speed difference between a single-threaded ALE and paralleled ALE per core (Fig. 4(b)). While a single-threaded engine gives around 5.8K FPS on Pong, our paralleled ALE runs comparable speed (5.1K FPS per core) with up to 16 cores, while OpenAI Gym (with Python threads) runs 3x slower (1.7K FPS per core) with 16 cores 1024 threads, and degrades with more cores. Number of threads matters for training since they determine how diverse the experiences could be, given the same number of CPUs. Apart from this, we observed that Python multiprocessing with Gym is even slower, due to heavy communication of game frames among processes. Note that we used no hyperthreading for all experiments."}, {"heading": "4.2 Baselines on Real-time Strategy Games", "text": "We focus on 1-vs-1 full games between trained AIs and built-in AIs. Built-in AIs have access to full information (e.g., number of opponent\u2019s tanks), while trained AIs know partial information in the fog of war, i.e., game environment within the sight of its own units. There are exceptions: in Mini-RTS, the location of the opponent\u2019s base is known so that the trained AI can attack; in Capture the Flag, the flag location is known to all; Tower Defense is a game of complete information.\nDetails of Built-in AI. For Mini-RTS there are two rule-based AIs: SIMPLE gathers, builds five tanks and then attacks the opponent base. HIT N RUN often harasses, builds and attacks. For Capture the Flag, we have one built-in AI. For Tower Defense (TD), no AI is needed. We tested our built-in AIs against a human player and find they are strong in combat but exploitable. For example, SIMPLE is vulnerable to hit-and-run style harass. As a result, a human player has a win rate of 90% and 50% against SIMPLE and HIT N RUN, respectively, in 20 games.\nAction Space. For simplicity, we use 9 strategic (and thus global) actions with hard-coded execution details. For example, AI may issue BUILD BARRACKS, which automatically picks a worker to build barracks at an empty location, if the player can afford. Although this setting is simple, detailed commands (e.g., command per unit) can be easily set up, which bear more resemblance to StarCraft. Similar setting applies to Capture the Flag and Tower Defense. Please check Appendix for detailed descriptions.\nRewards. For Mini-RTS, the agent only receives a reward when the game ends (\u00b11 for win/loss). An average game of Mini-RTS lasts for around 4000 ticks, which results in 80 decisions for a frame skip of 50, showing that the game is indeed delayed in reward. For Capturing the Flag, we give intermediate rewards when the flag moves towards player\u2019s own base (one score when the flag \u201ctouches down\u201d). In Tower Defense, intermediate penalty is given if enemy units are leaked."}, {"heading": "4.2.1 A3C baseline", "text": "Next, we describe our baselines and their variants. Note that while we refer to these as baseline, we are the first to demonstrate end-to-end trained AIs for real-time strategy (RTS) games with partial information. For all games, we randomize the initial game states for more diverse experience and use A3C [19] to train AIs to play the full game. We run all experiments 5 times and report mean\nand standard deviation. We use simple convolutional networks with two heads, one for actions and the other for values. The input features are composed of spatially structured (20-by-20) abstractions of the current game environment with multiple channels. At each (rounded) 2D location, the type and hit point of the unit at that location is quantized and written to their corresponding channels. For Mini-RTS, we also add an additional constant channel filled with current resource of the player. The input feature only contains the units within the sight of one player, respecting the properties of fog-of-war. For Capture the Flag, immediate action is required at specific situations (e.g., when the opponent just gets the flag) and A3C does not give good performance. Therefore we use frame skip 10 for trained AI and 50 for the opponent to give trained AI a bit advantage. All models are trained from scratch with curriculum training (Sec. 4.2.2). Note there are several factors affecting the AI performance.\nFrame-skip. A frame skip of 50 means that the AI acts every 50 ticks, etc. Against an opponent with low frame skip (fast-acting), A3C\u2019s performance is generally lower (Fig. 3). When the opponent has high frame skip (e.g., 50 ticks), the trained agent is able to find a strategy that exploits the longdelayed nature of the opponent. For example, in Mini-RTS it will send two tanks to the opponent\u2019s base. When one tank is destroyed, the opponent does not attack the other tank until the next 50- divisible tick comes. Interestingly, the trained model could be adaptive to different frame-rates and learn to develop different strategies for faster acting opponents. For Capture the Flag, the trained bot learns to win 60% over built-in AI, with an advantage in frame skip. For even frame skip, trained AI performance is low.\nNetwork Architectures. Since the input is sparse and heterogeneous, we experiment on CNN architectures with Batch Normalization [10] and Leaky ReLU [17]. BatchNorm stabilizes the gradient flow by normalizing the outputs of each filter. Leaky ReLU preserves the signal of negative linear responses, which is important in scenarios when the input features are sparse. Tbl. 4 shows that these two modifications both improve and stabilize the performance. Furthermore, they are complimentary to each other when combined.\nHistory length. History length T affects the convergence speed, as well as the final performance of A3C (Fig. 5). While Vanilla A3C [19] uses T = 5 for Atari games, the reward in Mini-RTS is more delayed (\u223c 80 actions before a reward). In this case, the T -step estimation of reward R1 = \u2211T t=1 \u03b3 t\u22121rt + \u03b3 TV (sT ) used in A3C does not yield a good estimation of the true reward if V (sT ) is inaccurate, in particular for small T . For other experiments we use T = 6.\nInteresting behaviors The trained AI learns to act promptly and use sophisticated strategies (Fig. 6). Multiple videos will be released soon."}, {"heading": "4.2.2 Curriculum Training", "text": "We find that curriculum training plays an important role in training AIs. All AIs shown in Tbl. 3 and Tbl. 4 are trained with curriculum training. For Mini-RTS, we let the built-in AI play the first\nk ticks, where k \u223c Uniform(0, 1000), then switch to the AI to be trained. This (1) reduces the difficulty of the game initially and (2) gives diverse situations for training to avoid local minima. During training, the aid of the built-in AIs is gradually reduced until no aid is given. All reported win rates are obtained by the trained agents alone.\nWe list the comparison with and without curriculum training in Tbl. 6. It is clear that the performance improves with curriculum training. Similarly, when fine-tuning models pre-trained with one type of opponent towards a mixture of opponents (e.g., 50%SIMPLE + 50%HIT N RUN), curriculum training is critical for better performance (Tbl. 5). Tbl. 5 shows that AIs trained with one built-in AI cannot do very well against another built-in AI in the same game. This demonstrates that training with diverse agents is important for training AIs with low-exploitability."}, {"heading": "4.2.3 Monte-Carlo Tree Search", "text": "Monte-Carlo Tree Search (MCTS) can be used for planning when complete information about the game is known. This includes the complete state s without fog-of-war, and the precise forward model s\u2032 = s\u2032(s, a). Rooted at the current game state, MCTS builds a game tree that is biased towards paths with high win rate. Leaves are expanded with all candidate moves and the win rate estimation is computed by random self-play until the game ends. We use 8 threads, each with 100 rollouts. We use root parallelization [9] in which each thread independently expands a tree, and are combined to get the most visited action. As shown in Tbl. 7, MCTS achieves a comparable win rate to models trained with RL. Note that the win rates of the two methods are not directly comparable, since RL methods have no knowledge of game dynamics, and its state knowledge is reduced by\nthe limits introduced by the fog-of-war. Also, MCTS runs much slower (2-3sec per move) than the trained RL AI (\u2264 1msec per move)."}, {"heading": "5 Conclusion and Future Work", "text": "In this paper, we propose ELF, a research-oriented platform for concurrent game simulation which offers an extensive set of game play options, a lightweight game simulator, and a flexible environment. On ELF, we build a RTS game engine and three initial environments (Mini-RTS, Capture the Flag and Tower Defense) that run 40KFPS per core on a MacBook Pro laptop. As a result, a fullgame bot in these games can be trained end-to-end in one day using a single machine. In addition to the platform, we provide throughput benchmarks of ELF, and extensive baseline results using state-of-the-art RL methods (e.g, A3C [19]) on Mini-RTS and show interesting learnt behaviors.\nELF opens up many possibilities for future research. With this lightweight and flexible platform, RL methods on RTS games can be explored in an efficient way, including forward modeling, hierarchical RL, planning under uncertainty, RL with complicated action space, and so on. Furthermore, the exploration can be done with an affordable amount of resources. As future work, we will continue improving the platform and build a library of maps and bots to compete with."}, {"heading": "6 Appendix: Detailed descriptions of RTS engine and games", "text": ""}, {"heading": "6.1 Overview", "text": "On ELF, we thus build three different environments, Mini-RTS, Capture the Flag and Tower Defense. Tbl. 8 shows their characteristics."}, {"heading": "6.2 Hierarchical Commands", "text": "The command level in our RTS engine is hierarchical (Fig. 8). A high-level command can issue other commands at the same tick during execution, which are then executed and can potential issues other commands as well. A command can also issue subsequent commands for future ticks. Two kinds of commands exist, durative and immediate. Durative commands (e.g., Move, Attack) last for many ticks until completion (e.g., enemy down), while immediate commands take effect within one tick."}, {"heading": "6.3 Units", "text": "Tbl. 9 shows available units for Mini-RTS, which captures all basic dynamics of RTS Games: Gathering, Building facilities, Building different kinds of troops, Defending opponent\u2019s attacks and/or\nInvading opponent\u2019s base. For troops, there are melee units with high hit point, high attack points but low moving speed, and agile units with low hit point, long attack range but fast moving speed. Tbl. 10 shows available units for Capture the Flag.\nNote that our framework is extensive and adding more units is easy."}, {"heading": "6.4 Game dynamics for Capture the Flag", "text": "During Capture the flag, the player will try to bring the flag back to his own base. The flag will appear in the middle of the map. The athlete can carry a flag or fight each other. When carrying a flag, an athlete has reduced movement speed. Upon death, it will drop the flag if it is carrying one, and will respawn automatically at base after a certain period of time. Once a flag is brought to a player\u2019s base, the player scores a point and the flag is returned to the middle of the map. The first player to score 5 points wins."}, {"heading": "6.5 Game dynamics for Tower Defense", "text": "During tower defense, the player will defend his base at top-left corner. Every 200 ticks, increasing number of enemy attackers will spawn at lower-right corner of the map, and travel towards player\u2019s base through a maze. The player can build towers along the way to prevent enemy from reaching the target. For every 5 enemies killed, the player can build a new tower. The player will lose if 10 enemies reach his base, and will win if he can survive 10 waves of attacks."}, {"heading": "6.6 Game Balance", "text": "We test the game balance of Mini-RTS and Capture the Flag. We put the same AI to combat each other. In Mini-RTS the win rate for player 0 is 50.0(\u00b13.0) and In Capture the Flag the win rate for player 0 is 49.9(\u00b11.1)."}, {"heading": "6.7 Replay", "text": "We offer serialization of replay and state snapshot at arbitrary ticks, which is more flexible than many commercial games."}, {"heading": "7 Detailed explanation of the experiments", "text": "Tbl. 11 shows the discrete action space for Mini-RTS and Capture the Flag used in the experiments."}, {"heading": "7.1 Randomness", "text": "All games based on RTS engine are deterministic. However, modern RL methods require the experience to be diverse to explore the game state space more efficiently. When we train AIs for Mini-RTS, we add randomness by randomly placing resources and bases, and by randomly adding units and buildings to start with a small probability. For Capture the Flag, all athletes have random starting position, and the flag appears in a random place with equal distances to both player\u2019s bases."}, {"heading": "7.2 Rule based AIs for Mini-RTS", "text": "Simple AI This AI builds 3 workers and ask them to gather resources, then builds a barrack if resource permits, and then starts to build melee attackers. Once he has 5 melee attackers, all 5 attackers will attack opponent\u2019s base.\nHit & Run AI This AI builds 3 workers and ask them to gather resources, then builds a barrack if resource permits, and then starts to build range attackers. Once he has 2 range attackers, the range attackers will move towards opponent\u2019s base and attack enemy troops in range. If enemy counterattacks, the range attackers will hit and run."}, {"heading": "7.3 Rule based AIs for Capture the Flag", "text": "Simple AI This AI will try to get flag if flag is not occupied. If one of the athlete gets the flag, he will escort the flag back to base, while other athletes defend opponent\u2019s attack. If an opponent athlete carries the flag, all athletes will attack the flag carrier."}], "references": [{"title": "Reinforcement learning through asynchronous advantage actor-critic on a gpu", "author": ["Mohammad Babaeizadeh", "Iuri Frosio", "Stephen Tyree", "Jason Clemons", "Jan Kautz"], "venue": "International Conference on Learning Representations (ICLR),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2017}, {"title": "The arcade learning environment: An evaluation platform for general agents", "author": ["Marc G. Bellemare", "Yavar Naddaf", "Joel Veness", "Michael Bowling"], "venue": "CoRR, abs/1207.4708,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "Playing SNES in the retro learning environment", "author": ["Nadav Bhonker", "Shai Rozenberg", "Itay Hubara"], "venue": "CoRR, abs/1611.02205,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2016}, {"title": "Samothrakis, and Simon 9  Colton. A survey of monte carlo tree search methods", "author": ["Cameron B Browne", "Edward Powley", "Daniel Whitehouse", "Simon M Lucas", "Peter I Cowling", "Philipp Rohlfshagen", "Stephen Tavener", "Diego Perez", "Spyridon"], "venue": "IEEE Transactions on Computational Intelligence and AI in games,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "On the development of a free rts game engine", "author": ["Michael Buro", "Timothy Furtak"], "venue": "In Game- OnNA Conference,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "Parallel monte-carlo tree search", "author": ["Guillaume MJ-B Chaslot", "Mark HM Winands", "H Jaap van Den Herik"], "venue": "In International Conference on Computers and Games,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["Sergey Ioffe", "Christian Szegedy"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "Spring: https://springrts.com", "author": ["Stefan Johansson", "Robin Westberg"], "venue": "URL https: //springrts.com/", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "The malmo platform for artificial intelligence experimentation", "author": ["Matthew Johnson", "Katja Hofmann", "Tim Hutton", "David Bignell"], "venue": "In International joint conference on artificial intelligence (IJCAI),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2016}, {"title": "Vizdoom: A doom-based ai research platform for visual reinforcement learning", "author": ["Micha\u0142 Kempka", "Marek Wydmuch", "Grzegorz Runc", "Jakub Toczek", "Wojciech Ja\u015bkowski"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2016}, {"title": "Playing fps games with deep reinforcement learning", "author": ["Guillaume Lample", "Devendra Singh Chaplot"], "venue": "arXiv preprint arXiv:1609.05521,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2016}, {"title": "Rectifier nonlinearities improve neural network acoustic models", "author": ["Andrew L Maas", "Awni Y Hannun", "Andrew Y Ng"], "venue": "In Proc. ICML,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "Rectifier nonlinearities improve neural network acoustic models", "author": ["Andrew L Maas", "Awni Y Hannun", "Andrew Y Ng"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2013}, {"title": "Learning to navigate in complex environments", "author": ["Piotr Mirowski", "Razvan Pascanu", "Fabio Viola", "Hubert Soyer", "Andrew J. Ballard", "Andrea Banino", "Misha Denil", "Ross Goroshin", "Laurent Sifre", "Koray Kavukcuoglu", "Dharshan Kumaran", "Raia Hadsell"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2017}, {"title": "Asynchronous methods for deep reinforcement learning", "author": ["Volodymyr Mnih", "Adria Puigdomenech Badia", "Mehdi Mirza", "Alex Graves", "Timothy P Lillicrap", "Tim Harley", "David Silver", "Koray Kavukcuoglu"], "venue": "arXiv preprint arXiv:1602.01783,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2016}, {"title": "Massively parallel methods for deep reinforcement learning", "author": ["Arun Nair", "Praveen Srinivasan", "Sam Blackwell", "Cagdas Alcicek", "Rory Fearon", "Alessandro De Maria", "Vedavyas Panneershelvam", "Mustafa Suleyman", "Charles Beattie", "Stig Petersen", "Shane Legg", "Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver"], "venue": "CoRR, abs/1507.04296,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2015}, {"title": "The combinatorial multi-armed bandit problem and its application to realtime strategy games", "author": ["Santiago Ontan\u00f3n"], "venue": "In Proceedings of the Ninth AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2013}, {"title": "Multiagent bidirectionally-coordinated nets for learning to play starcraft combat", "author": ["Peng Peng", "Quan Yuan", "Ying Wen", "Yaodong Yang", "Zhenkun Tang", "Haitao Long", "Jun Wang"], "venue": "games. CoRR,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2017}, {"title": "Trust region policy optimization", "author": ["John Schulman", "Sergey Levine", "Pieter Abbeel", "Michael I Jordan", "Philipp Moritz"], "venue": "In ICML,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2015}, {"title": "Mastering the game of go with deep neural networks and tree", "author": ["David Silver", "Aja Huang", "Chris J Maddison", "Arthur Guez", "Laurent Sifre", "George Van Den Driessche", "Julian Schrittwieser", "Ioannis Antonoglou", "Veda Panneershelvam", "Marc Lanctot"], "venue": "search. Nature,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2016}, {"title": "Mazebase: A sandbox for learning from games", "author": ["Sainbayar Sukhbaatar", "Arthur Szlam", "Gabriel Synnaeve", "Soumith Chintala", "Rob Fergus"], "venue": "CoRR, abs/1511.07401,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}, {"title": "Policy gradient methods for reinforcement learning with function approximation", "author": ["Richard S Sutton", "David A McAllester", "Satinder P Singh", "Yishay Mansour"], "venue": "In NIPS,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1999}, {"title": "Torchcraft: a library for machine learning research on real-time strategy", "author": ["Gabriel Synnaeve", "Nantas Nardelli", "Alex Auvolat", "Soumith Chintala", "Timoth\u00e9e Lacroix", "Zeming Lin", "Florian Richoux", "Nicolas Usunier"], "venue": "games. CoRR,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2016}, {"title": "Better computer go player with neural network and long-term prediction", "author": ["Yuandong Tian", "Yan Zhu"], "venue": "arXiv preprint arXiv:1511.06410,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2015}, {"title": "Episodic exploration for deep deterministic policies: An application to starcraft micromanagement", "author": ["Nicolas Usunier", "Gabriel Synnaeve", "Zeming Lin", "Soumith Chintala"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2017}], "referenceMentions": [{"referenceID": 1, "context": "In addition, our platform is flexible in terms of environment-agent communication topologies, choices of RL methods, changes in game parameters, and can host existing C/C++-based game environments like ALE [4].", "startOffset": 206, "endOffset": 209}, {"referenceID": 11, "context": "Using ELF, we thoroughly explore training parameters and show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in the full game of Mini-RTS.", "startOffset": 93, "endOffset": 97}, {"referenceID": 6, "context": "Using ELF, we thoroughly explore training parameters and show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in the full game of Mini-RTS.", "startOffset": 122, "endOffset": 126}, {"referenceID": 1, "context": "how to train intelligent agents to behave properly from sparse rewards [4, 6, 5, 13, 27].", "startOffset": 71, "endOffset": 88}, {"referenceID": 2, "context": "how to train intelligent agents to behave properly from sparse rewards [4, 6, 5, 13, 27].", "startOffset": 71, "endOffset": 88}, {"referenceID": 9, "context": "how to train intelligent agents to behave properly from sparse rewards [4, 6, 5, 13, 27].", "startOffset": 71, "endOffset": 88}, {"referenceID": 20, "context": "how to train intelligent agents to behave properly from sparse rewards [4, 6, 5, 13, 27].", "startOffset": 71, "endOffset": 88}, {"referenceID": 10, "context": "For example, changing environment parameters [33], as well as using internal data [14, 18] have been shown to lead to a substantial acceleration in training.", "startOffset": 82, "endOffset": 90}, {"referenceID": 13, "context": "For example, changing environment parameters [33], as well as using internal data [14, 18] have been shown to lead to a substantial acceleration in training.", "startOffset": 82, "endOffset": 90}, {"referenceID": 1, "context": "Old games and their wrappers [4, 6, 5, 13]) are substantially faster, but are less realistic with limited customizability.", "startOffset": 29, "endOffset": 42}, {"referenceID": 2, "context": "Old games and their wrappers [4, 6, 5, 13]) are substantially faster, but are less realistic with limited customizability.", "startOffset": 29, "endOffset": 42}, {"referenceID": 9, "context": "Old games and their wrappers [4, 6, 5, 13]) are substantially faster, but are less realistic with limited customizability.", "startOffset": 29, "endOffset": 42}, {"referenceID": 20, "context": ", MazeBase [27], \u03bcRTS [21]) are efficient and highly customizable, but are not very extensive in their capabilities.", "startOffset": 11, "endOffset": 15}, {"referenceID": 16, "context": ", MazeBase [27], \u03bcRTS [21]) are efficient and highly customizable, but are not very extensive in their capabilities.", "startOffset": 22, "endOffset": 26}, {"referenceID": 24, "context": "Previously, most research on RTS games focused only on lower-level scenarios such as tactical battles [32, 23].", "startOffset": 102, "endOffset": 110}, {"referenceID": 17, "context": "Previously, most research on RTS games focused only on lower-level scenarios such as tactical battles [32, 23].", "startOffset": 102, "endOffset": 110}, {"referenceID": 1, "context": ", ALE [4]), board games (e.", "startOffset": 6, "endOffset": 9}, {"referenceID": 23, "context": "Chess and Go [30]), and physics engines, by writing a simple adaptor.", "startOffset": 13, "endOffset": 17}, {"referenceID": 14, "context": "We use the Asynchronous Advantagous Actor-Critic (A3C) model [19] and explore extensive design choices including frameskip, temporal horizon, network structure, curriculum training, etc.", "startOffset": 61, "endOffset": 65}, {"referenceID": 11, "context": "We show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in full-game Mini-RTS.", "startOffset": 39, "endOffset": 43}, {"referenceID": 6, "context": "We show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in full-game Mini-RTS.", "startOffset": 68, "endOffset": 72}, {"referenceID": 14, "context": "Modern reinforcement learning methods often require heavy parallelism to obtain diverse experiences [19, 20].", "startOffset": 100, "endOffset": 108}, {"referenceID": 15, "context": "Modern reinforcement learning methods often require heavy parallelism to obtain diverse experiences [19, 20].", "startOffset": 100, "endOffset": 108}, {"referenceID": 2, "context": "Most existing RL environments (OpenAI Gym [6] and Universe [31], RLE [5], Atari [4], Doom [13]) provide Python interfaces which wrap only single game instances.", "startOffset": 69, "endOffset": 72}, {"referenceID": 1, "context": "Most existing RL environments (OpenAI Gym [6] and Universe [31], RLE [5], Atari [4], Doom [13]) provide Python interfaces which wrap only single game instances.", "startOffset": 80, "endOffset": 83}, {"referenceID": 9, "context": "Most existing RL environments (OpenAI Gym [6] and Universe [31], RLE [5], Atari [4], Doom [13]) provide Python interfaces which wrap only single game instances.", "startOffset": 90, "endOffset": 94}, {"referenceID": 14, "context": "g, vanilla A3C [19]), in which each agent follows and updates its own copy of the model.", "startOffset": 15, "endOffset": 19}, {"referenceID": 0, "context": ", BatchA3C [33] or GA3C [1]), where the model can perform batched forward prediction to better utilize GPUs.", "startOffset": 24, "endOffset": 27}, {"referenceID": 3, "context": ", Monte-Carlo Tree Search (MCTS) [7, 30, 25]) and Self-Play, in which at one time step, a single environment might emit multiple states processed by multiple models, or one-to-many.", "startOffset": 33, "endOffset": 44}, {"referenceID": 23, "context": ", Monte-Carlo Tree Search (MCTS) [7, 30, 25]) and Self-Play, in which at one time step, a single environment might emit multiple states processed by multiple models, or one-to-many.", "startOffset": 33, "endOffset": 44}, {"referenceID": 19, "context": ", Monte-Carlo Tree Search (MCTS) [7, 30, 25]) and Self-Play, in which at one time step, a single environment might emit multiple states processed by multiple models, or one-to-many.", "startOffset": 33, "endOffset": 44}, {"referenceID": 1, "context": ", ALE [4]), board games (e.", "startOffset": 6, "endOffset": 9}, {"referenceID": 23, "context": "Chess and Go [30]), and a customized RTS engine, with a simple adaptor.", "startOffset": 13, "endOffset": 17}, {"referenceID": 14, "context": ", A3C [19], Policy Gradient [28], Q-learning, Trust Region Policy Optimization [24], etc) are implemented, mostly with very few lines of Python codes.", "startOffset": 6, "endOffset": 10}, {"referenceID": 21, "context": ", A3C [19], Policy Gradient [28], Q-learning, Trust Region Policy Optimization [24], etc) are implemented, mostly with very few lines of Python codes.", "startOffset": 28, "endOffset": 32}, {"referenceID": 18, "context": ", A3C [19], Policy Gradient [28], Q-learning, Trust Region Policy Optimization [24], etc) are implemented, mostly with very few lines of Python codes.", "startOffset": 79, "endOffset": 83}, {"referenceID": 19, "context": "Real-time strategy (RTS) games are considered to be one of the next grand AI challenges after Chess and Go [25].", "startOffset": 107, "endOffset": 111}, {"referenceID": 7, "context": "Open-source RTS games like Spring [11], OpenRA [22] and Warzone 2100 [26] focus on complex graphics and effects, convenient user interface, stable network play, flexible map editors and plug-and-play mods (i.", "startOffset": 34, "endOffset": 38}, {"referenceID": 4, "context": "ORTS [8], BattleCode [2] and RoboCup Simulation League [15] are designed for coding competitions and focused on rule-based AIs.", "startOffset": 5, "endOffset": 8}, {"referenceID": 16, "context": ", \u03bcRTS [21], MazeBase [27]) are fast and simple, often coming with various baselines,", "startOffset": 7, "endOffset": 11}, {"referenceID": 20, "context": ", \u03bcRTS [21], MazeBase [27]) are fast and simple, often coming with various baselines,", "startOffset": 22, "endOffset": 26}, {"referenceID": 1, "context": "Platform ALE [4] RLE [5] Universe [31] Malmo [12] Frame per second 6000 530 60 120 Platform DeepMind Lab [3] VizDoom [13] TorchCraft [29] Mini-RTS Frame per second 287(C)/866(G) \u223c 7,000 2,000 (frameskip=50) 40,000 Table 2: Frame rate comparison.", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "Platform ALE [4] RLE [5] Universe [31] Malmo [12] Frame per second 6000 530 60 120 Platform DeepMind Lab [3] VizDoom [13] TorchCraft [29] Mini-RTS Frame per second 287(C)/866(G) \u223c 7,000 2,000 (frameskip=50) 40,000 Table 2: Frame rate comparison.", "startOffset": 21, "endOffset": 24}, {"referenceID": 8, "context": "Platform ALE [4] RLE [5] Universe [31] Malmo [12] Frame per second 6000 530 60 120 Platform DeepMind Lab [3] VizDoom [13] TorchCraft [29] Mini-RTS Frame per second 287(C)/866(G) \u223c 7,000 2,000 (frameskip=50) 40,000 Table 2: Frame rate comparison.", "startOffset": 45, "endOffset": 49}, {"referenceID": 9, "context": "Platform ALE [4] RLE [5] Universe [31] Malmo [12] Frame per second 6000 530 60 120 Platform DeepMind Lab [3] VizDoom [13] TorchCraft [29] Mini-RTS Frame per second 287(C)/866(G) \u223c 7,000 2,000 (frameskip=50) 40,000 Table 2: Frame rate comparison.", "startOffset": 117, "endOffset": 121}, {"referenceID": 22, "context": "Platform ALE [4] RLE [5] Universe [31] Malmo [12] Frame per second 6000 530 60 120 Platform DeepMind Lab [3] VizDoom [13] TorchCraft [29] Mini-RTS Frame per second 287(C)/866(G) \u223c 7,000 2,000 (frameskip=50) 40,000 Table 2: Frame rate comparison.", "startOffset": 133, "endOffset": 137}, {"referenceID": 22, "context": "Recently, TorchCraft [29] provides APIs for StarCraft I to access its internal game states.", "startOffset": 21, "endOffset": 25}, {"referenceID": 1, "context": "We also embed Atari emulator [4] into our platform and check the speed difference between a single-threaded ALE and paralleled ALE per core (Fig.", "startOffset": 29, "endOffset": 32}, {"referenceID": 14, "context": "For all games, we randomize the initial game states for more diverse experience and use A3C [19] to train AIs to play the full game.", "startOffset": 92, "endOffset": 96}, {"referenceID": 6, "context": "Since the input is sparse and heterogeneous, we experiment on CNN architectures with Batch Normalization [10] and Leaky ReLU [17].", "startOffset": 105, "endOffset": 109}, {"referenceID": 12, "context": "Since the input is sparse and heterogeneous, we experiment on CNN architectures with Batch Normalization [10] and Leaky ReLU [17].", "startOffset": 125, "endOffset": 129}, {"referenceID": 14, "context": "While Vanilla A3C [19] uses T = 5 for Atari games, the reward in Mini-RTS is more delayed (\u223c 80 actions before a reward).", "startOffset": 18, "endOffset": 22}, {"referenceID": 5, "context": "We use root parallelization [9] in which each thread independently expands a tree, and are combined to get the most visited action.", "startOffset": 28, "endOffset": 31}], "year": 2017, "abstractText": "In this paper, we propose ELF, an Extensive, Lightweight and Flexible platform for fundamental reinforcement learning research. Using ELF, we implement a highly customizable real-time strategy (RTS) engine with three game environments (Mini-RTS, Capture the Flag and Tower Defense). Mini-RTS, as a miniature version of StarCraft, captures key game dynamics and runs at 40K frame-persecond (FPS) per core on a Macbook Pro notebook. When coupled with modern reinforcement learning methods, the system can train a full-game bot against builtin AIs end-to-end in one day with 6 CPUs and 1 GPU. In addition, our platform is flexible in terms of environment-agent communication topologies, choices of RL methods, changes in game parameters, and can host existing C/C++-based game environments like ALE [4]. Using ELF, we thoroughly explore training parameters and show that a network with Leaky ReLU [16] and Batch Normalization [10] coupled with long-horizon training and progressive curriculum beats the rule-based built-in AI more than 70% of the time in the full game of Mini-RTS. Strong performance is also achieved on the other two games. In game replays, we show our agents learn interesting strategies. ELF, along with its RL platform, will be open-sourced.", "creator": "LaTeX with hyperref package"}}}