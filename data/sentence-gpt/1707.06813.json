{"id": "1707.06813", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Jul-2017", "title": "On the Computation of Paracoherent Answer Sets", "abstract": "Answer Set Programming (ASP) is a well-established formalism for nonmonotonic reasoning. An ASP program can have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended to be true or meaningful. A simple ASP program can be constructed by combining the two elements as a way to make an example of the problem of a monotonic situation.\n\nThe following diagram gives you an example of the problem in which an ASP programmer creates a problem set. The first part is a simple ASP program. You have a simple ASP program. You will have a good understanding of how to make a problem set.\nIf you don't already know what this problem can be, there are a number of approaches to solving it, especially in the short term. The most common ones include the basic ASP program (as demonstrated above), an ASP programmer's solution (as demonstrated above), and a set of basic ASP programs.\nTo simplify the problem, you have to understand some key features of a problem set:\nTo create an example of how to implement an ASP programming language, you have to understand some basic programming language basics.\nTo define an ASP programming language, you have to understand some basic programming language basics.\nTo define an ASP programming language, you have to understand some basic programming language basics. The only way to start is to get a basic basic programming language understanding.\nThe only way to start is to get a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic program understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic programming language understanding.\nTo start a basic program understanding.\nTo start a basic programming language understanding.\nTo start a basic program understanding.\nTo start a basic program understanding.\nTo start a basic program understanding.\nTo", "histories": [["v1", "Fri, 21 Jul 2017 09:45:06 GMT  (49kb)", "http://arxiv.org/abs/1707.06813v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["giovanni amendola", "carmine dodaro", "wolfgang faber", "nicola leone", "francesco ricca"], "accepted": true, "id": "1707.06813"}, "pdf": {"name": "1707.06813.pdf", "metadata": {"source": "CRF", "title": "On the Computation of Paracoherent Answer Sets", "authors": ["Giovanni Amendola", "Carmine Dodaro", "Wolfgang Faber", "Nicola Leone", "Francesco Ricca"], "emails": ["amendola@mat.unical.it", "dodaro@mat.unical.it", "leone@mat.unical.it", "ricca@mat.unical.it", "w.faber@hud.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 7.\n06 81\n3v 1\n[ cs\n.L O\n] 2\n1 Ju\nAnswer Set Programming (ASP) is a well-established formalism for nonmonotonic reasoning. An ASP program can have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. Recently, several paracoherent semantics have been proposed that address this issue, and several potential applications for these semantics have been identified. However, paracoherent semantics have essentially been inapplicable in practice, due to the lack of efficient algorithms and implementations. In this paper, this lack is addressed, and several different algorithms to compute semi-stable and semi-equilibrium models are proposed and implemented into an answer set solving framework. An empirical performance comparison among the new algorithms on benchmarks from ASP competitions is given as well."}, {"heading": "1 Introduction", "text": "In the past decades, many advances in Artificial Intelligence research has been done thanks to studies in the field of knowledge representation and reasoning. Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]). It is a declarative programming paradigm oriented towards difficult, primarily NP-hard, search problems, which are encoded into a logic program, whose models (answer sets) encode solutions. ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].\nHowever, a logic program could have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. For this reason, theoretical studies have been developed to extend answer set semantics to keep a system responsive in these exceptional cases. To distinguish this situation from reasoning under classical logical contradiction due to strong negation, called paraconsistent reasoning, it has been referred to it as paracoherent reasoning [4].\n\u2217The original version is published in the Proceedings of the ThirtyFirst AAAI Conference on Artificial Intelligence (AAAI-17), see aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14358/13877.\nIn order to deal with this, [34] introduced the semi-stable model semantics that coincides with answer set semantics whenever a program has some answer set, but admits paracoherent models for each classically consistent program. Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31]. Thus, this paracoherent semantics is called semi-equilibrium model semantics.1\nDifferent possible applications of these paracoherent semantics have been identified, such as debugging, model building, inconsistency-tolerant query answering, diagnosis, planning and reasoning about actions; and computational complexity aspects have been studied [4]. However, to the best of our knowledge, there are no efficient algorithms to compute paracoherent answer sets, obstructing the concrete use of these reasoning approaches. The goal of the paper is to fill this gap, by developing efficient algorithms and their implementation.\nIn the paper, we consider different algorithms to compute semi-stable and semiequilibrium models, implementing and integrating them into an answer set building framework. Finally, we report the results of an experimental activity conducted on benchmarks from ASP competitions [11], identifying the more efficient algorithm."}, {"heading": "2 Preliminaries", "text": "We start with recalling answer set semantics, and then present the paracoherent semantics of semi-stable and semi-equilibrium models."}, {"heading": "2.1 Answer Set Programming", "text": "We concentrate on programs over a propositional signature \u03a3. A disjunctive rule r is of the form\na1\u2228\u00b7\u00b7 \u00b7\u2228al \u2190 b1, ...,bm,not bm+1, ...,not bn, (1)\nwhere all ai and b j are atoms (from \u03a3) and l \u2265 0, n \u2265 m \u2265 0 and l + n > 0; not represents negation-as-failure. The set H(r) = {a1, ...,al} is the head of r, while B+(r) = {b1, ...,bm} and B\n\u2212(r) = {bm+1, . . . ,bn} are the positive body and the negative body of r, respectively; the body of r is B(r) = B+(r) \u222a B\u2212(r). We denote by At(r) = H(r) \u222a B(r) the set of all atoms occurring in r. A rule r is a fact, if B(r) = /0 (we then omit \u2190); a constraint, if H(r) = /0; normal, if |H(r)| \u2264 1 and positive, if B\u2212(r) = /0. A (disjunctive logic) program P is a finite set of disjunctive rules. P is called normal [resp. positive] if each r \u2208 P is normal [resp. positive]. We let At(P) = \u22c3\nr\u2208PAt(r). Any set I \u2286 \u03a3 is an interpretation; it is a model of a program P (denoted I |= P) iff for each rule r \u2208 P, I \u2229H(r) 6= /0 if B+(r) \u2286 I and B\u2212(r)\u2229 I = /0 (denoted I |= r). A model M of P is minimal, iff no model M\u2032 \u2282M of P exists. We denote by MM(P) the set of all minimal models of P and by AS(P) the set of all answer sets (or stable models) of P, i.e., the set of all interpretations I such that I \u2208MM(PI), where PI is the well-known Gelfond-Lifschitz reduct [21] of P with respect to I, i.e., the set of rules a1\u2228 ...\u2228al \u2190 b1, ...,bm, obtained from rules r \u2208 P of form (1), such that B \u2212(r)\u2229 I = /0. A program is said to be coherent if AS(P) 6= /0, incoherent otherwise. Now, we recall a useful extension of the answer set semantics by the notion of weak constraint [10]. A weak constraint \u03c9 is of the form:\n1The relationship with other semantics is discussed in the Related Work section.\nb1, . . . , bm, not bm+1, . . . , not bn.\nGiven a program P and a set of weak constraintsW , the semantics of P\u222aW extends from the basic case defined above. A constraint \u03c9 \u2208W is violated by an interpretation I if all positive atoms in \u03c9 are true, and all negated atoms are false with respect to I. An optimum answer set for P\u222aW is an answer set of P that minimizes the number of the violated weak constraints. We denote by ASO(P\u222aW ) the set of all optimum answer sets of P\u222aW ."}, {"heading": "2.2 Paracoherent ASP", "text": "Here, we introduce two paracoherent semantics that allow for keeping a system responsive when a logic program has no answer set due to cyclic default negation. These semantics satisfy three desiderata properties identified by [4].\nSemi-StableModels. Inoue and Sakama ([34]) introduced semi-stable model semantics. We consider an extended signature \u03a3\u03ba = \u03a3\u222a{Ka | a \u2208 \u03a3}. Intuitively, Ka can be read as a is believed to hold. Semantically, we resort to subsets of \u03a3\u03ba as interpretations I\u03ba and the truth values false \u22a5, believed true bt, and true t. The truth value assigned by I\u03ba to a propositional variable a is defined by\nI\u03ba(a) =\n\n \n \nt if a \u2208 I\u03ba , bt if Ka \u2208 I\u03ba and a 6\u2208 I\u03ba ,\n\u22a5 otherwise.\nThe semi-stable models of a programP are obtained from its epistemic \u03ba-transformation P\u03ba .\nDefinition 1 (Epistemic \u03ba-transformation P\u03ba ) Let P be a program. Then its epistemic \u03ba-transformation is defined as the program P\u03ba obtained from P by replacing each rule r of the form (1) in P, such that B\u2212(r) 6= /0, with:\n\u03bbr,1\u2228 . . .\u2228\u03bbr,l \u2228Kbm+1\u2228 . . .\u2228Kbn \u2190 b1, . . . ,bm, (2)\nai \u2190 \u03bbr,i, (3)\n\u2190 \u03bbr,i,b j, (4)\n\u03bbr,i \u2190 ai,\u03bbr,k, (5)\nfor 1\u2264 i,k \u2264 l and m+ 1\u2264 j \u2264 n, where the \u03bbr,i, \u03bbr,k are fresh atoms.\nNote that for any program P, its epistemic \u03ba-transformation P\u03ba is positive. For every interpretation I\u03ba over \u03a3\u2032 \u2287 \u03a3\u03ba , let G (I\u03ba ) = {Ka \u2208 I\u03ba | a 6\u2208 I\u03ba} denote the atoms believed true but not assigned true, also referred to as the gap of I\u03ba . Given a set F of interpretations over \u03a3\u2032, an interpretation I\u03ba \u2208 F is maximal canonical in F , if no J\u03ba \u2208 F exists such that G (I\u03ba)\u2283 G (J\u03ba). By mc(F ) we denote the set of maximal canonical interpretations inF . Semi-stable models are then defined asmaximal canonical interpretations among the answer sets of P\u03ba . Then we can equivalently paraphrase the definition of semi-stable models in [34] as follows.\nDefinition 2 (Semi-stable models) Let P be a program over \u03a3. An interpretation I\u03ba over \u03a3\u03ba is a semi-stable model of P, if I\u03ba = S\u2229\u03a3\u03ba for some maximal canonical answer set S of P\u03ba . The set of all semi-stable models of P is denoted by SST(P), i.e., SST(P) = {S\u2229\u03a3\u03ba | S \u2208mc(AS(P\u03ba))}.\nExample 1 Consider the program P = {b \u2190 not a; c \u2190 not b; a \u2190 c; d \u2190 not d}. Its epistemic \u03ba-transformation is P\u03ba = {\u03bb1\u2228Ka; b\u2190 \u03bb1; \u2190 a,\u03bb1; \u03bb1 \u2190 b,\u03bb1; \u03bb2\u2228 Kb; c \u2190 \u03bb2; \u2190 b,\u03bb2; \u03bb2 \u2190 c,\u03bb2; a\u2190 c; \u03bb3 \u2228Kd; d \u2190 \u03bb3; \u2190 d,\u03bb3; \u03bb3 \u2190 d,\u03bb3;}, which has the answer sets M1 = {Ka,Kb,Kd}, M2 = {\u03bb1,b,Kb,Kd}, andM3 = {Ka,\u03bb2,a,c,Kd}; as G (M1) = {Ka,Kb,Kd}, G (M2) = {Kd}, and G (M3) = {Kd}. Therefore, among them M2 and M3 are maximal canonicals, and hence M2 \u2229 \u03a3\n\u03ba = {b,Kb,Kd} and M3\u2229\u03a3\n\u03ba = {a,c,Ka,Kd} are semi-stable models of P, that also correspond to answer sets of P.\nSemi-EquilibriumModels. Semi-equilibriummodelswere introduced by [4] to avoid some anomalies in semi-stable model semantics. Like semi-stable models, semi-equilibrium models may be computed as maximal canonical answer sets, of an extension of the epistemic \u03ba-transformation.\nDefinition 3 (Epistemic HT -transformation PHT ) Let P be a program over \u03a3. Then its epistemic HT-transformation PHT is defined as the union of P\u03ba with the set of rules:\nKa\u2190 a, (6)\nKa1\u2228 . . .\u2228Kal \u2228Kbm+1\u2228 . . .\u2228Kbn \u2190 Kb1, . . . ,Kbm, (7)\nfor a \u2208 \u03a3, respectively for every rule r \u2208 P of the form (1).\nDefinition 4 (Semi-equilibrium models) Let P be a program over \u03a3, and let I\u03ba be an interpretation over \u03a3\u03ba . Then, I\u03ba \u2208 SEQ(P) if, and only if, I\u03ba \u2208 {M \u2229\u03a3\u03ba | M \u2208 mc(AS(PHT ))}, where SEQ(P) is the set of semi-equilibrium models of P.\nExample 2 Consider the program P of Example 1. Its epistemic HT-transformation PHT is P\u03ba \u222a{Ka\u2190 a; Kb\u2190 b; Kc\u2190 c; Kd\u2190 d; Kb\u2228Ka; Kc\u2228Kb; Ka\u2190Kc; Kd\u2190 Kd}, which has the answer sets {Ka,Kb,Kd}, {\u03bb1,b,Kb,Kd}, and {Ka,\u03bb2,a,c,Kc,Kd}. Therefore, the semi-equilibrium models of P are {b,Kb,Kd} and {a,c,Ka,Kc,Kd}.\nIn the following, we refer to semi-stable models or semi-equilibrium models as\nparacoherent answer sets.\nComplexity Considerations. The complexity of various reasoning tasks with paracoherent answer sets has been analyzed in [4]: while determining the existence of paracoherent answer sets is NP-complete (it is sufficient to test for existence of classical models), paracoherent answer set checking is \u03a0P2 -complete, leading to \u03a3 P 3 -completeness for brave, and \u03a0P3 -completeness for cautious reasoning. In this paper, we consider the computation of one paracoherent answer set, which is a functional problem. From previous work it is clear that this task is in F\u03a3P3 , and actually in F\u0398 P 3 (functional polynomial time with a logarithmic number of calls to a \u03a3P2 -complete oracle), because for computing one paracoherent answer set it is sufficient to solve a cardinality-optimization problem."}, {"heading": "3 Computation of a Paracoherent Answer Set", "text": "In this section we propose different algorithms to compute one paracoherent answer set. The algorithms take as input a program \u03a0 = P\u03c7 \u222aPg, where P \u03c7 is a generic epistemic\nAlgorithm 1: Filtering\n1 M := nextAnswerSet(\u03a0,\u22a5); Mw :=M; 2 Mw := nextAnswerSet(\u03a0,Mw); 3 ifMw =\u22a5 then returnM; 4 if gap(Mw)\u2282 gap(M) thenM :=Mw; 5 goto 2;\nAlgorithm 2: Guess&Check\n1 M =\u22a5; 2 M = nextAnswerSet(\u03a0,M); 3 Mw = nextAnswerSet(\u03a0\u222a\u03a0M,\u22a5); 4 ifMw =\u22a5 then returnM; else goto 2;\ntransformation of the ASP program P and Pg is the following set of rules capturing the notion of gap:\ngap(Ka)\u2190 Ka, not a; \u2200a \u2208 At(P) (8)\nProposition 1 Let gap(I) = {gap(Ka) | gap(Ka)\u2208 I}, for a set I of atoms. An answer set M of \u03a0 is a paracoherent answer set if, and only if, there exists no answer set M1 of \u03a0 such that gap(M1)\u2282 gap(M).\nExample 3 Consider again the program P\u03ba of Example 1, then \u03a0 is the union of P\u03ba with the following set of rules:\ngap(Ka)\u2190 Ka, not a; gap(Kb)\u2190 Kb, not b; gap(Kc)\u2190 Kc, not c; gap(Kd)\u2190 Kd, not d;\nwhich admits the answer sets M\u20321 =M1 \u222a{gap(Ka),gap(Kb),gap(Kd)}, M \u2032 2 =M2 \u222a {gap(Kd)}, andM\u20323 =M3\u222a{gap(Kd)}. Then, gap(M \u2032 1)= {gap(Ka),gap(Kb),gap(Kd)}, gap(M\u20322) = gap(M \u2032 3) = {gap(Kd)}, thus M \u2032 2 and M \u2032 3 are paracoherent answer sets.\nThe output of the algorithms is one semi-stable model of P (if \u03c7 = \u03ba) or one semiequilibrium model of P (if \u03c7 = HT ). In the following, without loss of generality we assume that \u03a0 admits at least one paracoherent answer set. In fact, by properties of semi-stable and semi-equilibrium models, this kind of programs admit always a paracoherent answer set [4].\nMoreover, in order to ease the description of the algorithms presented in this section, we introduce the enumeration function nextAnswerSet, that takes as input the program \u03a0 and an answer set M of \u03a0, and returns as output the next one according to some internal criteria or\u22a5 if no other answer set exists. We abuse of the notation using M =\u22a5 to indicate that the function computes the first answer set.\nFiltering. An immediate algorithm for finding a paracoherent answer set is Filtering, Algorithm 1. The underlying idea is to enumerate all answer sets of \u03a0 and to store the one that is subset-minimal with respect to gap atoms. The algorithm first finds an\nAlgorithm 3:Minimize\n1 M := nextAnswerSet(\u03a0,\u22a5); 2 \u03a0 := \u03a0\u222a\u03a0M; 3 Mw := nextAnswerSet(\u03a0,\u22a5); 4 ifMw =\u22a5 then returnM; else M :=Mw; goto 2;\nAlgorithm 4: Split\n1 M := nextAnswerSet(\u03a0,\u22a5); C := gap(M); 2 ifC = /0 then returnM; 3 \u03a0 := \u03a0\u222a\u03a0M; a := OneO f (C); 4 Mw := nextAnswerSet(\u03a0\u222a{\u2190 a},\u22a5); 5 ifMw =\u22a5 then {\u03a0 := \u03a0\u222a{\u2190 not a};C :=C \\ {a};} else {M :=Mw; C := gap(Mw);} goto 2;\nanswer set M of \u03a0. Then, another answer set Mw is searched (line 2). If gap(Mw) is a subset of gap(M) then M is replaced with Mw. Subsequently, the algorithm continues the search until all answer sets have been enumerated. Intuitively, at each step of the computationM is a subset-minimal answer set with respect to the answer sets enumerated so far. Thus, when all answer sets have been enumerated thenM is a paracoherent answer set.\nExample 4 Consider again program \u03a0 of Example 3. The first call to nextAnswerSet returns M\u20321 that is stored in M. The second call to nextAnswerSet returns M \u2032 2, gap(M \u2032 2) is a subset of gap(M\u20321) therefore M is replaced by M \u2032 2. The third call of nextAnswerSet returns M\u20323 and M is not modified since gap(M \u2032 3)\n\u2032 is not a subset of gap(M). No other answer sets can be enumerated, thus the algorithm terminates returning M.\nThe main drawback of Algorithm 1 is that it always computes all answer sets of \u03a0,\na potentially exponential number in the size of the atoms of the original program.\nIn the following we present different algorithms for addressing this inefficiency.\nGuess&Check. This algorithm, Algorithm 2, improves Algorithm 1 by reducing the number of computed answer sets. In order to ease the description of the remaining algorithms we introduce the following.\nDefinition 5 Given a program \u03a0 defined as above. Let M be a model of \u03a0, then \u03a0M is the following set of constraints:\n\u2190 gap(M); (9)\n\u2190 gap(Ka); \u2200gap(Ka) \u2208 At(\u03a0)\\M. (10)\nNote that (9) contains all atoms in gap(M).\nTheorem 1 Let P be a logic program, let \u03a0 be defined as above, and let M \u2208 AS(\u03a0). Then, AS(\u03a0\u222a\u03a0M) 6= /0 if, and only if, M is not a paracoherent answer set of P.\nExample 5 Consider again program \u03a0 of Example 3. \u03a0M\u20321 is composed by the following set of constraints:\n\u2190 gap(Ka),gap(Kb),gap(Kd); \u2190 gap(Kc);\nwhereas \u03a0M\u20322 is composed by the following set of constraints:\n\u2190 gap(Kd); \u2190 gap(Ka); \u2190 gap(Kb); \u2190 gap(Kc).\nNote that AS(\u03a0\u222a\u03a0M\u20321 ) = {M\u20322,M \u2032 3} and AS(\u03a0\u222a\u03a0M\u20322 ) = /0.\nThe Guess&Check algorithm finds an answer setM of \u03a0. Subsequently, an answer set of the program \u03a0\u222a\u03a0M is sought. If such an answer set does not exist then M is a paracoherent answer set and the algorithm terminates returning M. Otherwise, the algorithm iterates the computation until a paracoherent answer set is found.\nExample 6 Consider again program \u03a0 of Example 3. The first answer set computed by nextAnswerSet is M\u20321. The subsequent check is performed on the program \u03a0\u222a\u03a0M\u20321 , that is coherent. Thus, M\u20321 is not a paracoherent answer set. Then, nextAnswerSet is called again and it returns M\u20322. At this point, \u03a0\u222a\u03a0M\u20322 is incoherent, therefore the algorithm terminates returning M\u20322.\nAlgorithm 2 terminates as soon as a paracoherent answer set of P is found. How-\never, in the worst case, it still needs to enumerate all answer sets.\nMinimize. The next algorithm is called Minimize and it is reported as Algorithm 3. The idea is to compute an answer setM of \u03a0 and then to search for another answer set Mw such that gap(Mw)\u2282 gap(M). This property is enforced by the constraints of \u03a0M that are added to the program \u03a0 (line 2). If \u03a0 admits an answer set, say Mw, then M is replaced byMw and the algorithm iterates minimizingM. Otherwise, if \u03a0 admits no answer set, M is a paracoherent answer set and the algorithm terminates returningM.\nExample 7 Consider again program \u03a0 of Example 3. The first answer set computed by nextAnswerSet is M\u20321. Thus, the constraints of \u03a0M\u20321 are added to \u03a0. The subsequent check on \u03a0 returns an answer set, say M\u20322, and then \u03a0 is modified by adding the constraints of \u03a0M\u20322 . At this point, \u03a0 is incoherent, therefore the algorithm terminates returning M\u20322.\nAlgorithm 3 computes at most |At(P)| answer sets.\nSplit. Another algorithm for computing a paracoherent answer set is called Split, Algorithm 4. The algorithm first computes an answer set M of \u03a0 and creates a set C of gap atoms that are included in M. Then, the program \u03a0 is modified by adding the constraints of \u03a0M. Moreover, one of the atoms in C is selected by the procedure OneO f , say a. Subsequently, an answer set of \u03a0\u222a {\u2190 a} is searched. If such an answer set does not exist then a must be included in the paracoherent answer set and thus \u03a0 is modified by adding the constraint \u2190 not a and a is removed from the set C. Otherwise, if \u03a0\u222a{\u2190 a} admits an answer set, say Mw, thenM is replaced byMw and the set C is replaced by the gap atoms that are true in Mw. The algorithm then iterates until the set C is empty, returningM that corresponds to the paracoherent answer set.\nExample 8 Consider again program \u03a0 of Example 3. The first answer set computed by nextAnswerSet is M\u20321. Thus, C is set to {gap(Ka),gap(Kb),gap(Kc)} and the constraints of \u03a0M\u20321 are added to \u03a0. Then, function OneO f selects one of the atoms in C, say gap(Ka). The subsequent check on \u03a0\u222a{\u2190 gap(Ka)} returns an answer set, say M\u20322. Therefore, C is set to gap(Kd) and \u03a0 is modified by adding the constraints of \u03a0M\u20322 . Then, the function OneO f selects gap(Kd) and the subsequent check on \u03a0\u222a{\u2190 gap(Kd)} returns \u22a5. Subsequently, \u03a0 is modified by adding the constraint \u2190 not gap(Kd) and C is updated by removing gap(Kd). At this point, C is empty, therefore the algorithm terminates returning the latest computed answer set, i.e. M\u20322.\nNote that Algorithm 4 requires to compute at most |At(P)| answer sets.\nWeak constraints. All the algorithms presented above require the modification of an ASP solver to be implemented. An alternative approach is based on the observation that the gap minimality can be obtained adding to \u03a0 the following set of weak constraints, sayW :\ngap(Ka); \u2200a \u2208 At(P). (11)\nThe answer set of the extended program is then an answer set of \u03a0 such that a minimal number of weak constraints in W is violated. This means that this answer set that is cardinality minimal with respect to the gap atoms. Therefore, it is also subset minimal with respect to the gap atoms, and so, it is a paracoherent answer set of P.\nTheorem 2 Let P be a program, let \u03a0 andW be defined as above. If M \u2208 ASO(\u03a0\u222aW), then M \\ gap(M) is a paracoherent answer set of P.\nNote that, the reverse statement does not hold in general. For example, consider the program P = {b\u2190 not a; c \u2190 a; d \u2190 b,not d}. Its semi-equilibrium models are {b,Kd} and {Ka,Kc}. However, {Ka,Kc,gap(Ka),gap(Kc)} is not an optimum answer set of \u03a0\u222aW ."}, {"heading": "4 Implementation and Experiments", "text": "We implemented the algorithms presented in this paper, and we report on an experiment comparing their performance.\nImplementation. The computation of a paracoherent answer set is obtained in two steps. First a Java rewriter computes the epistemic transformations P\u03ba and PHT of a propositional ASP program. Then the output of the rewriter is fed in input to a variant of the state-of-the-art ASP solver WASP [2]. WASP is an open-source ASP solver, winner of the latest ASP competition [20], that we modified by implementing the algorithms presented in the previous section (the source can be downloaded at https://github.com/alviano/wasp).\nBenchmarks settings. Experimentswere run on a Debian Linux systemwith 2.30GHz Intel Xeon E5-4610 v2 CPUs and 128GB of RAM. Execution time and memory were limited to 1200 seconds and 3 GB, respectively. We use benchmark instances from the latest ASP competition [20] collection. We consider all the incoherent instances that do not feature in the encoding neither aggregates, nor choice rules, nor weak constraints, since such features are not currently supported by the paracoherent semantics [4]. This resulted in instances from the following domains: Knight Tour, Minimal Diagnosis, Qualitative Spatial Reasoning, Stable Marriage and Visit All. Instances were grounded with GRINGO (from http://potassco.sourceforge.net/ ). Grounding times, the same for all compared methods, are not reported.\nResults of the experiments. A summary of the result is reported in Table 5, where the number of solved instances for each considered semantics is reported. In the table, Filt is WASP running Algorithm 1, G&C is WASP running Algorithm 2, Minim is WASP running Algorithm 3, Split is WASP running Algorithm 4, and Weak is WASP running the algorithm based on weak constraints.\nAs a general comment, the algorithm based on the enumeration of answer sets is highly inefficient solving no instances at all. The Guess&Check algorithm outperforms the Filtering algorithm demonstrating that in many cases the enumeration of all answer sets is not needed. The best performing algorithms are Minimize and Split solving both the same number of instances. The performance of the two algorithms are similar also considering the running times. In fact, this is evident by looking at the instance-wise comparison reported in the scatter plot of Figure 1. A point (x,y) in the scatter plot is reported for each instance, where x is the solving time of the algorithm Minimize whereas y is the solving time of the algorithm Split. Concerning the algorithm based on weak constraints, it can be observed that its performance is better than the one of algorithm Filtering. However, it does not reach the efficiency of the algorithms Guess&Check, Minimize and Split.\nConcerning the semi-equilibrium semantics, it can be observed that the performance of all algorithms deteriorates. This can be explained by looking at the number of rules introduced by the epistemic HT-transformation, reported in Table 2. In fact, the epistemic HT-transformation introduces approximately twice the number of rules introduced by the epistemic \u03ba-transformation. Moreover, we observe that also in this case the best performing algorithms are Minimize and Split. The latter is slightly more efficient than the former.\nFocusing on the performance of the algorithms on the different benchmarks, it can be observed that none of the algorithms was effective on the problems KnightTour and StableMarriage. Concerning KnightTour, we observed that WASP is not able to find any answer set of the epistemic transformations for 12 out of 26 instances. Basically, no algorithm can be effective on such 12 instances, and the remaining ones are hard due to the subsequent checks. Concerning StableMarriage, we observed that java rewriter\ncould not produce the epistemic transformation within the allotted time, because the unique instance of this domain features more than 100 millions rules. The presented algorithms (but Filtering) are able to solve all the considered instances of VisitAll problem, where the epistemic transformations results in a very limited number of atoms and rules (see Table 2)."}, {"heading": "5 Related Work", "text": "Paracoherent Semantics. Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30]. However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).\nComputational aspects. Our approach to the computation of paracoherent answer sets is related to the computation of minimal models of propositional theories. The first approaches were proposed for implementing circumscriptive reasoning (cfr. [16]). Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23]. [29] proposed a tableaux-based method where candidate models are generated and then tested for minimality. [23] proposed a method able to reduce minimality tests on candidate models. The usage of hyperresolution for minimal models of first-order clauses was presented in [9] and implemented in Prolog. As observed in [26] these approaches do not take profit of modern non-chronological-backtracking-based solving technology. This limit was overcome in [26] by an algorithm for computing minimal models of SAT formulas that is based on the same principle as the Minimize algorithm. The computation of minimal models of SAT formulae can be reduced to computing a Minimal Set over a Monotone Predicate (MSMP) [25]. Thus algorithms for MSMP such as those described in [28] could be adapted (by properly taking into account the jump in computational complexity) for computing paracoherent answer sets. Efficient\npolynomial algorithms for a subclass of positive CNF theories was proposed in [6]. That method cannot be applied directly to find a model of \u03a0 that is minimal on the extension of gap predicate. The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models."}, {"heading": "6 Conclusion", "text": "In this paper, we have tackled the problem of computing paracoherent answer sets, namely semi-stable and stable-equilibrium models, which has not been addressed so far. We have proposed a number of algorithms relying on a program transformation with subsequent calls to an answer set solver. We have conducted an experimental analysis of these algorithms using incoherent programs of the ASP competition, the analysis of incoherent answer set programs being the prime application that we envision for paracoherent answer sets. The experiments show that algorithms Minimize and Split outperform other tested algorithms. The results also show that the computation of a paracoherent answer set is a difficult problem not just theoretically, but also in practice."}, {"heading": "Acknowledgements", "text": "This work was partially supported by the EU H2020 Marie Sk\u0142odowska-Curie grant agreement No 690974 \u201cMIREL\u201d, MIUR within project \u201cSI-LAB BA2KNOW\u201d, by MISE under project \u201cPIUCultura\u201d, N. F/020016/01-02/X27, and by GNCS-INDAM."}], "references": [{"title": "An encompassing framework for paraconsistent logic programs", "author": ["J. Alc\u00e2ntara", "C.V. Dam\u00e1sio", "L.M. Pereira"], "venue": "J. Applied Logic, 3(1):67\u201395", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Advances in WASP", "author": ["M. Alviano", "C. Dodaro", "N. Leone", "F. Ricca"], "venue": "LPNMR 2015, pages 40\u201354", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "Anytime computation of cautious consequences in answer set programming", "author": ["M. Alviano", "C. Dodaro", "F. Ricca"], "venue": "TPLP, 14(4-5):755\u2013770", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Semi-equilibriummodels for paracoherent answer set programs", "author": ["G. Amendola", "T. Eiter", "M. Fink", "N. Leone", "J. Moura"], "venue": "Artif. Intell., 234:219\u2013271", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2016}, {"title": "Modeling and reasoning about NTU games via answer set programming", "author": ["G. Amendola", "G. Greco", "N. Leone", "P. Veltri"], "venue": "IJCAI 2016, pages 38\u201345", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2016}, {"title": "On the tractability of minimal model computation for some CNF theories", "author": ["F. Angiulli", "R. Ben-Eliyahu", "F. Fassetti", "L. Palopoli"], "venue": "Artif. Intell., 210:56\u201377", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Logic programs with consistency-restoring rules", "author": ["M. Balduccini", "M. Gelfond"], "venue": "ISLFCR, AAAI 2003 Spring Symposium Series, pages 9\u201318", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2003}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczynski"], "venue": "Com. ACM, 54(12):92\u2013103", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Positive unit hyperresolution tableaux and their application to minimal model generation", "author": ["F. Bry", "A.H. Yahya"], "venue": "J. Autom. Reasoning, 25(1):35\u201382", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2000}, {"title": "Enhancing disjunctive datalog by constraints", "author": ["F. Buccafurri", "N. Leone", "P. Rullo"], "venue": "IEEE Trans. Knowl. Data Eng., 12(5):845\u2013860", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2000}, {"title": "Design and results of the fifth answer set programming competition", "author": ["F. Calimeri", "M. Gebser", "M. Maratea", "F. Ricca"], "venue": "Artif. Intell., 231:151\u2013181", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "A declarative concurrent system for protein structure prediction on GPU", "author": ["F. Campeotto", "A. Dovier", "E. Pontelli"], "venue": "J. Exp. Theor. Artif. Intell., 27(5):503\u2013541", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "Combining Answer Set Programming and domain heuristics for solving hard industrial problems (Application Paper)", "author": ["C. Dodaro", "P. Gasteiger", "N. Leone", "B. Musitsch", "F. Ricca", "K. Shchekotykhin"], "venue": "TPLP, 16(5-6):653\u2013669", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2016}, {"title": "Allotment problem in travel industry: A solution based on ASP", "author": ["C. Dodaro", "N. Leone", "B. Nardi", "F. Ricca"], "venue": "B. ten Cate and A. Mileo, editors, RR 2015, volume 9209 of LNCS, pages 77\u201392. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2015}, {"title": "On the partial semantics for disjunctive deductive databases", "author": ["T. Eiter", "N. Leone", "D. Sacc\u00e0"], "venue": "Ann. Math. Artif. Intell., 19(1-2):59\u201396", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1997}, {"title": "editors", "author": ["D.M. Gabbay", "C.J. Hogger", "J.A. Robinson", "J.H. Siekmann"], "venue": "Handbook of Logic in Artificial Intelligence and Logic Programming, Volume2, Deduction Methodologies. Oxford University Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1994}, {"title": "Improved answerset programming encodings for abstract argumentation", "author": ["S. Gaggl", "N. Manthey", "A. Ronca", "J. Wallner", "S. Woltran"], "venue": "TPLP, 15(4-5):434\u2013448", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "J", "author": ["M.J.O. Galindo"], "venue": "R. A. Ram\u0131\u0301rez, and J. L. Carballido. Logical weak completions of paraconsistent logics. J. Log. Comput., 18(6):913\u2013940", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Morgan & Claypool Publishers", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "The design of the sixth answer set programming competition - report ", "author": ["M. Gebser", "M. Maratea", "F. Ricca"], "venue": "LPNMR 2015, pages 531\u2013544", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Comput., 9(3/4):365\u2013386", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1991}, {"title": "ASP at work: Spin-off and applications of the DLV system", "author": ["G. Grasso", "N. Leone", "M. Manna", "F. Ricca"], "venue": "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, LNCS 6565, pages 432\u2013451", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Efficient minimal model generation using branching lemmas", "author": ["R. Hasegawa", "H. Fujita", "M. Koshimura"], "venue": "CADE-17, 2000, pages 184\u2013199", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2000}, {"title": "Algorithms for computing backbones of propositional formulae", "author": ["M. Janota", "I. Lynce", "J. Marques-Silva"], "venue": "AI Commun., 28(2):161\u2013177", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2015}, {"title": "On the query complexity of selecting minimal sets for monotone predicates", "author": ["M. Janota", "J. Marques-Silva"], "venue": "Artif. Intell., 233:73\u201383", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2016}, {"title": "Minimal model generation with respect to an atom set", "author": ["M. Koshimura", "H. Nabeshima", "H. Fujita", "R. Hasegawa"], "venue": "FTP 2009, CEUR 556", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2009}, {"title": "Taming primary key violations to query large inconsistent data via ASP", "author": ["M. Manna", "F. Ricca", "G. Terracina"], "venue": "TPLP, 15(4-5):696\u2013710", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2015}, {"title": "Minimal sets over monotone predicates in boolean formulae", "author": ["J. Marques-Silva", "M. Janota", "A. Belov"], "venue": "CAV 2013, pages 592\u2013607", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2013}, {"title": "A tableau calculus for minimal model reasoning", "author": ["I. Niemel\u00e4"], "venue": "TABLEAUX 1996, pages 278\u2013294", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1996}, {"title": "J", "author": ["M. Osorio"], "venue": "R. A. Ram\u0131\u0301rez, and J. L. Carballido. Logical weak completions of paraconsistent logics. J. Log. Comput., 18(6):913\u2013940", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2008}, {"title": "Equilibrium logic", "author": ["D. Pearce"], "venue": "Ann. Math. Artif. Intell., 47(1-2):3\u201341", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2006}, {"title": "Revised stable models - a semantics for logic programs", "author": ["L.M. Pereira", "A.M. Pinto"], "venue": "EPIA, pages 29\u201342", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2005}, {"title": "Stable semantics for disjunctive programs", "author": ["T.C. Przymusinski"], "venue": "New Generation Comput., 9(3/4):401\u2013424", "citeRegEx": "33", "shortCiteRegEx": null, "year": 1991}, {"title": "Paraconsistent stable semantics for extended disjunctive programs", "author": ["C. Sakama", "K. Inoue"], "venue": "J. Log. Comput., 5(3):265\u2013285", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1995}, {"title": "Partial evidential stable models for disjunctive deductive databases", "author": ["D. Seipel"], "venue": "LPKR, pages 66\u201384", "citeRegEx": "35", "shortCiteRegEx": null, "year": 1997}, {"title": "The well-founded semantics for general logic programs", "author": ["A. van Gelder", "K. Ross", "J. Schlipf"], "venue": "J. ACM,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 1991}], "referenceMentions": [{"referenceID": 7, "context": "Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]).", "startOffset": 85, "endOffset": 92}, {"referenceID": 18, "context": "Answer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning (see, [8, 19]).", "startOffset": 85, "endOffset": 92}, {"referenceID": 20, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 73, "endOffset": 77}, {"referenceID": 16, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 143, "endOffset": 147}, {"referenceID": 11, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 164, "endOffset": 168}, {"referenceID": 26, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 180, "endOffset": 184}, {"referenceID": 4, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 198, "endOffset": 201}, {"referenceID": 13, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 271, "endOffset": 283}, {"referenceID": 21, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 271, "endOffset": 283}, {"referenceID": 12, "context": "ASP is based on the stable model (or answer set) semantics introduced by [21] and is used to solve complex problems in Artificial Intelligence [17], Bioinformatics [12], Databases [27]; Game Theory [5]; more recently ASP has been applied to solve industrial applications [14, 22, 13].", "startOffset": 271, "endOffset": 283}, {"referenceID": 3, "context": "To distinguish this situation from reasoning under classical logical contradiction due to strong negation, called paraconsistent reasoning, it has been referred to it as paracoherent reasoning [4].", "startOffset": 193, "endOffset": 196}, {"referenceID": 33, "context": "In order to deal with this, [34] introduced the semi-stable model semantics that coincides with answer set semantics whenever a program has some answer set, but admits paracoherent models for each classically consistent program.", "startOffset": 28, "endOffset": 32}, {"referenceID": 3, "context": "Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31].", "startOffset": 10, "endOffset": 13}, {"referenceID": 30, "context": "Recently, [4] have improved this kind of semantics avoiding some anomalies with respect to basic modal logic properties, resorting to the equilibrium logic [31].", "startOffset": 156, "endOffset": 160}, {"referenceID": 3, "context": "Different possible applications of these paracoherent semantics have been identified, such as debugging, model building, inconsistency-tolerant query answering, diagnosis, planning and reasoning about actions; and computational complexity aspects have been studied [4].", "startOffset": 265, "endOffset": 268}, {"referenceID": 10, "context": "Finally, we report the results of an experimental activity conducted on benchmarks from ASP competitions [11], identifying the more efficient algorithm.", "startOffset": 105, "endOffset": 109}, {"referenceID": 20, "context": ", the set of all interpretations I such that I \u2208MM(P), where P is the well-known Gelfond-Lifschitz reduct [21] of P with respect to I, i.", "startOffset": 106, "endOffset": 110}, {"referenceID": 9, "context": "Now, we recall a useful extension of the answer set semantics by the notion of weak constraint [10].", "startOffset": 95, "endOffset": 99}, {"referenceID": 3, "context": "These semantics satisfy three desiderata properties identified by [4].", "startOffset": 66, "endOffset": 69}, {"referenceID": 33, "context": "Inoue and Sakama ([34]) introduced semi-stable model semantics.", "startOffset": 18, "endOffset": 22}, {"referenceID": 33, "context": "Then we can equivalently paraphrase the definition of semi-stable models in [34] as follows.", "startOffset": 76, "endOffset": 80}, {"referenceID": 3, "context": "Semi-equilibriummodelswere introduced by [4] to avoid some anomalies in semi-stable model semantics.", "startOffset": 41, "endOffset": 44}, {"referenceID": 3, "context": "The complexity of various reasoning tasks with paracoherent answer sets has been analyzed in [4]: while determining the existence of paracoherent answer sets is NP-complete (it is sufficient to test for existence of classical models), paracoherent answer set checking is \u03a0P2 -complete, leading to \u03a3 P 3 -completeness for brave, and \u03a03 -completeness for cautious reasoning.", "startOffset": 93, "endOffset": 96}, {"referenceID": 3, "context": "In fact, by properties of semi-stable and semi-equilibrium models, this kind of programs admit always a paracoherent answer set [4].", "startOffset": 128, "endOffset": 131}, {"referenceID": 1, "context": "Then the output of the rewriter is fed in input to a variant of the state-of-the-art ASP solver WASP [2].", "startOffset": 101, "endOffset": 104}, {"referenceID": 19, "context": "WASP is an open-source ASP solver, winner of the latest ASP competition [20], that we modified by implementing the algorithms presented in the previous section (the source can be downloaded at https://github.", "startOffset": 72, "endOffset": 76}, {"referenceID": 19, "context": "We use benchmark instances from the latest ASP competition [20] collection.", "startOffset": 59, "endOffset": 63}, {"referenceID": 3, "context": "We consider all the incoherent instances that do not feature in the encoding neither aggregates, nor choice rules, nor weak constraints, since such features are not currently supported by the paracoherent semantics [4].", "startOffset": 215, "endOffset": 218}, {"referenceID": 32, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 35, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 14, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 34, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 6, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 31, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 0, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 17, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 29, "context": "Many non-monotonic semantics for logic programs with negation have been proposed that can be considered as paracoherent semantics [33, 36, 15, 35, 7, 32, 1, 18, 30].", "startOffset": 130, "endOffset": 164}, {"referenceID": 3, "context": "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).", "startOffset": 9, "endOffset": 12}, {"referenceID": 33, "context": "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).", "startOffset": 56, "endOffset": 60}, {"referenceID": 3, "context": "However, [4] have shown that only semi-stable semantics [34] and semi-equilibrium semantics [4] satisfy the following desiderata properties: (i) every consistent answer set of a program corresponds to a paracoherent answer set (answer set coverage); (ii) if a program has some (consistent) answer set, then its paracoherent answer sets correspond to answer sets (congruence); (iii) if a program has a classical model, then it has a paracoherent answer set (classical coherence); (iv) a minimal set of atoms should be undefined (minimal undefinedness); (v) every true atom must be derived from the program (justifiability).", "startOffset": 92, "endOffset": 95}, {"referenceID": 15, "context": "[16]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23].", "startOffset": 87, "endOffset": 95}, {"referenceID": 22, "context": "Later the attention shifted to the computation of minimalmodels of first-order clauses [29, 23].", "startOffset": 87, "endOffset": 95}, {"referenceID": 28, "context": "[29] proposed a tableaux-based method where candidate models are generated and then tested for minimality.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[23] proposed a method able to reduce minimality tests on candidate models.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "The usage of hyperresolution for minimal models of first-order clauses was presented in [9] and implemented in Prolog.", "startOffset": 88, "endOffset": 91}, {"referenceID": 25, "context": "As observed in [26] these approaches do not take profit of modern non-chronological-backtracking-based solving technology.", "startOffset": 15, "endOffset": 19}, {"referenceID": 25, "context": "This limit was overcome in [26] by an algorithm for computing minimal models of SAT formulas that is based on the same principle as the Minimize algorithm.", "startOffset": 27, "endOffset": 31}, {"referenceID": 24, "context": "The computation of minimal models of SAT formulae can be reduced to computing a Minimal Set over a Monotone Predicate (MSMP) [25].", "startOffset": 125, "endOffset": 129}, {"referenceID": 27, "context": "Thus algorithms for MSMP such as those described in [28] could be adapted (by properly taking into account the jump in computational complexity) for computing paracoherent answer sets.", "startOffset": 52, "endOffset": 56}, {"referenceID": 5, "context": "polynomial algorithms for a subclass of positive CNF theories was proposed in [6].", "startOffset": 78, "endOffset": 81}, {"referenceID": 2, "context": "The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models.", "startOffset": 110, "endOffset": 113}, {"referenceID": 23, "context": "The Split algorithm is similar to the algorithms employed for computing cautious consequences of ASP programs [3] and backbones of SAT formulas [24]; nonetheless, to the best of our knowledge, it has no related counterpart in the literature concerning the computation of minimal models.", "startOffset": 144, "endOffset": 148}], "year": 2017, "abstractText": "Answer Set Programming (ASP) is a well-established formalism for nonmonotonic reasoning. An ASP program can have no answer set due to cyclic default negation. In this case, it is not possible to draw any conclusion, even if this is not intended. Recently, several paracoherent semantics have been proposed that address this issue, and several potential applications for these semantics have been identified. However, paracoherent semantics have essentially been inapplicable in practice, due to the lack of efficient algorithms and implementations. In this paper, this lack is addressed, and several different algorithms to compute semi-stable and semi-equilibrium models are proposed and implemented into an answer set solving framework. An empirical performance comparison among the new algorithms on benchmarks from ASP competitions is given as well.", "creator": "LaTeX with hyperref package"}}}