{"id": "1708.07403", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Aug-2017", "title": "CloudScan - A configuration-free invoice analysis system using recurrent neural networks", "abstract": "We present CloudScan; an invoice analysis system that requires zero configuration or upfront annotation. In contrast to previous work, CloudScan does not rely on templates of invoice layout, instead it learns a single global model of invoices that naturally generalizes to unseen invoice layouts. The model is trained using data automatically extracted from end-user provided feedback from customers using the CloudScan backend.\n\n\n\n\n\n\nFor detailed documentation, see CloudScan . CloudScan.\n\n\n\nIn practice, the project was based on the JSDK and JSS data, but it is often associated with an issue with the current project that was running on Windows 7 (and the older version that was running on Windows Vista).\nYou can check out CloudScan . The JSDK is the latest version of the Java runtime.\nIf you want to learn more about CloudScan, please visit the Java IDE's Developer Center.\nSee the Java-Reference Database and the JSDK for more information.", "histories": [["v1", "Thu, 24 Aug 2017 13:40:06 GMT  (467kb,D)", "http://arxiv.org/abs/1708.07403v1", "Presented at ICDAR 2017"]], "COMMENTS": "Presented at ICDAR 2017", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["rasmus berg palm", "ole winther", "florian laws"], "accepted": false, "id": "1708.07403"}, "pdf": {"name": "1708.07403.pdf", "metadata": {"source": "CRF", "title": "CloudScan - A configuration-free invoice analysis system using recurrent neural networks", "authors": ["Rasmus Berg Palm", "Ole Winther"], "emails": ["rapal@dtu.dk", "olwi@dtu.dk", "fla@tradeshift.com"], "sections": [{"heading": null, "text": "In contrast to previous work, CloudScan does not rely on templates of invoice layout, instead it learns a single global model of invoices that naturally generalizes to unseen invoice layouts.\nThe model is trained using data automatically extracted from end-user provided feedback. This automatic training data extraction removes the requirement for users to annotate the data precisely.\nWe describe a recurrent neural network model that can capture long range context and compare it to a baseline logistic regression model corresponding to the current CloudScan production system.\nWe train and evaluate the system on 8 important fields using a dataset of 326,471 invoices. The recurrent neural network and baseline model achieve 0.891 and 0.887 average F1 scores respectively on seen invoice layouts. For the harder task of unseen invoice layouts, the recurrent neural network model outperforms the baseline with 0.840 average F1 compared to 0.788.\nI. INTRODUCTION\nInvoices, orders, credit notes and similar business documents carry the information needed for trade to occur between companies and much of it is on paper or in semi-structured formats such as PDFs [1]. In order to manage this information effectively, companies use IT systems to extract and digitize the relevant information contained in these documents. Traditionally this has been achieved using humans that manually extract the relevant information and input it into an IT system. This is a labor intensive and expensive process [2].\nThe field of information extraction addresses the challenge of automatically extracting such information and several commercial solutions exists that assist in this. Here we present CloudScan, a commercial solution by Tradeshift, free for small businesses, for extracting structured information from unstructured invoices.\nPowerful information extraction techniques exists given that we can observe invoices from the same template beforehand, e.g. rule, keyword or layout based techniques. A template is a distinct invoice layout, typically unique to each sender. A number of systems have been proposed that rely on first classifying the template, e.g. Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8]. As these systems rely on having seen the template beforehand, they cannot accurately handle documents from unseen templates. Instead they focus on requiring as few examples from a template as possible.\nWhat is harder, and more useful, is a system that can accurately handle invoices from completely unseen templates, with no prior annotation, configuration or setup. This is the goal of CloudScan: to be a simple, configuration and maintenance free invoice analysis system that can convert documents from both previously seen and unseen templates with high levels of accuracy.\nCloudScan was built from the ground up with this goal in mind. There is no notion of template in the system. Instead every invoice is processed by the same system built around a single machine learning model. CloudScan does not rely on any system integration or prior knowledge, e.g. databases of orders or customer names, meaning there is no setup required in order to use it.\nCloudScan automatically extracts the training data from end-user provided feedback. The end-user provided feedback required is the correct value for each field, rather than the map from words on the page to fields. It is a subtle difference, but this separates the concerns of reviewing and correcting values using a graphical user interface from concerns related to acquiring training data. Automatically extracting the training data this way also results in a very large dataset which allows us to use methods that require such large datasets.\nIn this paper we describe how CloudScan works, and investigate how well it accomplishes the goal it aims to achieve. We evaluate CloudScan using a large dataset of 326,471 invoices and report competitive results on both seen and unseen templates. We establish two classification baselines using logistic regression and recurrent neural networks, respectively."}, {"heading": "II. RELATED WORK", "text": "The most directly related works are Intellix [3] by DocuWare and the work by ITESOFT [4]. Both systems require that relevant fields are annotated for a template manually beforehand, which creates a database of templates, fields and automatically extracted keywords and positions for each field. When new documents are received, both systems classify the template automatically using address lookups or machine learning classifiers. Once the template is classified the keywords and positions for each field are used to propose field candidates which are then scored using heuristics such as proximity and uniqueness of the keywords. Having scored the candidates the best one for each field is chosen.\nar X\niv :1\n70 8.\n07 40\n3v 1\n[ cs\n.C L\n] 2\n4 A\nug 2\n01 7\nsmartFIX [5] uses manually configured rules for each template. Cesarini et al. [6] learns a database of keywords for each template and fall back to a global database of keywords. Esser et al. [7] uses a database of absolute positions of fields for each template. Medvet et al. [8] uses a database of manually created (field, pattern, parser) triplets for each template, designs a probabilistic model for finding the most similar pattern in a template, and extracts the value with the associated parser.\nUnfortunately we cannot compare ourselves directly to the works described as the datasets used are not publicly available\nand the evaluation methods are substantially different. However, the described systems all rely on having an annotated example from the same template in order to accurately extract information.\nTo the best of our knowledge CloudScan is the first invoice analysis system that is built for and capable of accurately converting invoices from unseen templates.\nThe previous works described can be configured to handle arbitrary document classes, not just invoices, as is the case for CloudScan. Additionally, they allow the user to define which\nset of fields are to be extracted per class or template, whereas CloudScan assumes a single fixed set of fields to be extracted from all invoices.\nOur automatic training data extraction is closely related to the idea of distant supervision [9] where relations are extracted from unstructured text automatically using heuristics.\nThe field of Natural Language Processing (NLP) offers a wealth of related work. Named Entity Recognition (NER) is the task of extracting named entities, usually persons or locations, from unstructured text. See Nadeau and Sekine [10] for a survey of NER approaches. Our system can be seen as a NER system in which we have 8 different entities. In recent years, neural architectures have been demonstrated to achieve state-of-the-art performance on NER tasks, e.g. Lample et al. [11], who combine word and character level RNNs, and Conditional Random Fields (CRFs).\nSlot Filling is another related NLP task in which pre-defined slots must be filled from natural text. Our system can be seen as a slot filling task with 8 slots, and the text of a single invoice as input. Neural architectures are also used here, e.g. [12] uses bi-directional RNNs and word embedding to achieve competitive results on the ATIS (Airline Travel Information Systems) benchmark dataset.\nIn both NER and Slot Filling tasks, a commonly used approach is to classify individual tokens with the entities or slots of interest, an approach that we adopt in our proposed RNN model."}, {"heading": "III. CLOUDSCAN", "text": ""}, {"heading": "A. Overview", "text": "CloudScan is a cloud based software as a service invoice analysis system offered by Tradeshift. Users can upload their unstructured PDF invoices and the CloudScan engine converts them into structured XML invoices. The CloudScan engine contains 6 steps. See Figure 2.\n1) Text Extractor. Input is a PDF invoice. Extracts words and their positions from the PDF. If the PDF has embedded text, the text is extracted, otherwise a commercial OCR engine is used. The output of this step is a structured representation of words and lines in hOCR format [13]. 2) N-grammer. Creates N-grams of words on the same line. Output is a list of N-grams up to length 4. 3) Feature Calculator. Calculates features for every Ngram. Features fall in three categories: text, numeric and boolean. Examples of text features are the raw text of the N-gram, and the text after replacing all letters with \u201dx\u201d, all numbers with \u201d0\u201d and all other characters with \u201d.\u201d. Examples of numeric features are the normalized position on the page, the width and height and number of words to the left. Boolean features include whether the N-gram parses as a date or an amount or whether it matches a known country, city or zip code. These parsers and small databases of countries, cities and zip codes are built into the system, and does not require\nany configuration on the part of the user. The output is a feature vector for every N-gram. For a complete list of features see table V. 4) Classifier. Classifies each N-gram feature vector into 32 fields of interest, e.g. invoice number, total, date, etc. and one additional field \u2019undefined\u2019. The undefined field is used for all N-grams that does not have a corresponding field in the output document, e.g. terms and conditions. The output is a vector of 33 probabilities for each Ngram. 5) Post Processor. Decides which N-grams are to be used for the fields in the output document. For all fields, we first filter out N-gram candidates that does not fit the syntax of the field after parsing with the associated parser. E.g. the N-gram \u201dFoo Bar\u201d would not fit the Total field after parsing with the associated parser since no amount could be extracted. The parsers can handle simple OCR errors and various formats, e.g. \u201d100,0o\u201d would be parsed to \u201d100.00\u201d. The parsers are based on regular expressions. For fields with no semantic connection to other fields, e.g. the invoice number, date, etc. we use the Hungarian algorithm [14]. The Hungarian algorithm solves the assignment problem, in which N agents are to be assigned to M tasks, such that each task has exactly one agent assigned and no agent is assigned to more than one task. Given that each assignment has a cost, the Hungarian algorithm finds the assignments that minimizes the total cost. We use 1 minus the probability of an N-gram being a field as the cost. For the assignment of the Total, Line Total, Tax Total and Tax Percentage we define and minimize a cost function based on the field probabilities and whether the candidate totals adds up. The output is a mapping from the fields of interest to the chosen N-grams. 6) Document Builder. Builds a Universal Business Language (UBL) [15] invoice with the fields having the values of the found N-grams. UBL is a XML based invoice file format. Output is a UBL invoice."}, {"heading": "B. Extracting training data from end-user provided feedback", "text": "The UBL invoice produced by the engine is presented to the user along with the original PDF invoice in a graphical user interface (GUI). The user can correct any field in the UBL invoice, either by copy and pasting from the PDF, or by directly typing in the correction. See figure 1.\nOnce the user has corrected any mistakes and accepted the invoice we add the resulting UBL to our data collection. We will extract training data from these validated UBL documents, even though they might deviate from the PDF content due to OCR error, user error or the user intentionally deviating from the PDF content. We discuss these issues later.\nThe classifier is trained on N-grams and their labels, which are automatically extracted from the validated UBL invoices and the corresponding PDFs. For each field in the validated\nUBL document we consider all N-grams in the PDF and check whether the text content, after parsing, matches the field value. If it does, we extract it as a single training example of N-gram and label equal to the field. If an N-gram does not match any fields we assign the \u2019undefined\u2019 label. For N-grams that match multiple fields, we assign all matched fields as labels. This ambiguity turns the multi-class problem into a multi-label problem. See Algorithm 1 for details.\ninput : UBL and PDF document output: All labeled N-grams result \u2190 {}; foreach field \u2208 fields do\nparser \u2190 GetParser(field); value \u2190 GetValue(UBL, field); maxN \u2190 Length(value) + 2; nGrams \u2190 CreateNgrams(PDF, maxN); foreach nGram \u2208 nGrams do\nif value = Parse(nGram, parser) then Add(result, nGram, field);\nend end\nend nGrams \u2190 CreateNgrams(PDF, 4); foreach nGram \u2208 nGrams do\nif nGram /\u2208 result then Add(result, nGram, undefined);\nend end return result\nAlgorithm 1: Automatic training data extraction\nUsing automatically extracted pairs like this results in a noisy, but big data set of millions of pairs. Most importantly, however, it introduces no limitations on how users correct potential errors, and requires no training. For instance, we could have required users to select the word matching a field, which would result in much higher quality training data. However in a high volume enterprise setup, this could reduce throughput significantly. Our automatic training data generation decouples the concerns of reviewing and correcting fields from creating training data, allowing the GUI to focus solely on reviewing and correcting fields. The user would need to review the field values and correct potential errors regardless, so as long as we do not limit how the user does it, we are not imposing any additional burdens. In short, the machine learning demands have lower priority than the user experience in this regard.\nAs long as we get a PDF and a corresponding UBL invoice we can extract training data, and the system should learn and improve for the next invoice."}, {"heading": "IV. EXPERIMENTS", "text": "We perform two experiments meant to test 1) the expected performance on the next invoice, and 2) the harder task of\nexpected performance on the next invoice from an unseen template. These are two different measures of generalization performance.\nThe data set consists of 326,471 pairs of validated UBL invoices and corresponding PDFs from 8911 senders to 1013 receivers obtained from use of CloudScan. We assume each sender corresponds to a distinct template.\nFor the first experiment we split the invoices into a training, validation and test set randomly, using 70%, 10% and 20% respectively. For the second experiment we split the senders into a training, validation and test set randomly, using 70%, 10% and 20% respectively. All the invoices from the senders in a set then comprise the documents of that set. This split ensures that there are no invoices sharing templates between the three sets for the second experiment.\nWhile the system captures 32 fields we only report on eight of them: Invoice number, Issue Date, Currency, Order ID, Total, Line Total, Tax Total and Tax Percent. We only report on these eight fields as they are the ones we have primarily designed the system for. A large part of the remaining fields are related to the sender and receiver of the invoice and used for identifying these. We plan to remove these fields entirely and approach the problem of sender and receiver identification as a document classification problem instead. Preliminary experiments based on a simple bag-of-words model show promising results. The last remaining fields are related to the line items and used for extracting these. Table extraction is a challenging research question in itself, and we are not yet ready to discuss our solution. Also, while not directly comparable, related work [3], [4], [6] also restricts evaluation to header fields.\nPerformance is measured by comparing the fields of the generated and validated UBL. Note we are not only measuring the classifier performance, but rather the performance of the entire system. The end-to-end performance is what is interesting to the user after all. Furthermore, this is the strictest possible way to measure performance, as it will penalize errors from any source, e.g. OCR errors and inconsistencies between the validated UBL and the PDF. For instance, the date in the validated UBL might not correspond to the date on the PDF. In this case, even if the date on the PDF is found, it will be counted as an error, as it does not match the date in the validated UBL.\nIn order to show the upper limit of the system under this measure we include a ceiling analysis where we replace the classifier output with the correct labels directly. This corresponds to using an oracle classifier. We use the MUC-5 definitions of recall, precision and F1, without partial matches [16].\nWe perform experiments with two classifiers 1) The produc-\ntion baseline system using a logistic regression classifier, and 2) a Recurrent Neural Network (RNN) model. We hypothesize the RNN model can capture context better."}, {"heading": "A. Baseline", "text": "The baseline is the current production system, which uses a logistic regression classifier to classify each N-gram individually.\nIn order to capture some context, we concatenate the feature vectors for the closest N-grams in the top, bottom, left and right directions to the normal feature vectors. So if the feature vector for an N-gram had M entries, after this it would have 5M entries.\nAll 5M features are then mapped to a binary vector of size 222 using the hashing trick [17]. To be specific, for each feature we concatenate the feature name and value, hash it, take the remainder with respect to the binary vector size and set that index in the binary vector to 1.\nThe logistic regression classifier is trained using stochastic gradient descent for 10 epochs after which we see little improvement. This baseline system is derived from the heavily optimized winning solution of a competition Tradeshift held1."}, {"heading": "B. LSTM model", "text": "In order to accurately classify N-grams the context is critical, however when classifying each N-gram in isolation, as in the baseline model, we have to engineer features to capture this context, and deciding how much and which context to capture is not trivial.\nA Recurrent Neural Network (RNN) can model the entire invoice and we hypothesize that this ability to take the entire invoice into account in a principled manner will improve the performance significantly. Further, it frees us from having to explicitly engineer features that capture context. As such we only use the original M features, not the 5M features of the baseline model. In general terms, a RNN can be described as follows.\nht = f(ht\u22121, xt)\nyt = g(ht)\nWhere ht is the hidden state at step t, f is a neural network that maps the previous hidden state ht\u22121, and the input xt to ht and g is a neural network that maps the hidden state ht to the output of the model yt. Several variants have been proposed, most notably the Long Short Term Memory (LSTM) [18] which is good at modeling long term dependencies.\nA RNN models a sequence, i.e. x and y are ordered and as such we need to impose an ordering on the invoice. We chose to model the words instead of N-grams, as they fit the RNN sequence model more naturally and we use the standard leftto-right reading order as the ordering. Since the labels can span multiple words we re-label the words using the IOB labeling\n1https://www.kaggle.com/c/tradeshift-text-classification\nscheme [19]. The sequence of words \u201dTotal Amount: 12 200 USD\u201d would be labeled \u201dO O B-Total I-Total B-Currency\u201d.\nWe hash the text of the word into a binary vector of size 218 which is embedded in a trainable 500 dimensional distributed representation using an embedding layer [20]. Using hashing instead of a fixed size dictionary is somewhat unorthodox but we did not observe any difference from using a dictionary, and hashing was easier to implement. It is possible we could have gotten better results using more advanced techniques like byte pair encoding [21].\nWe normalize the numerical and boolean features to have zero mean and unit variance and form the final feature vector for each word by concatenating the word embedding and the normalized numerical features.\nFrom input to output, the model has: two dense layers with 600 rectified linear units each, a single bidirectional LSTM layer with 400 units, and two more dense layers with 600 rectified linear units each, and a final dense output layer with 65 logistic units (32 classes that can each be \u2019beginning\u2019 or \u2019inside\u2019 plus the \u2019outside\u2019 class).\nFollowing Gal [22], we apply dropout on the recurrent units and on the word embedding using a dropout fraction of 0.5 for both. Without this dropout the model severely overfits.\nThe model is trained with the Adam optimizer [23] using minibatches of size 96 until the validation performance has not improved on the validation set for 5 epochs. Model architecture and hyper-parameters were chosen based on the performance on the validation set. For computational reasons we do not train on invoices with more than 1000 words, which constitutes approximately 5% of the training set, although we do test on them. The LSTM model was implemented in Theano [24] and Lasagne [25].\nAfter classification we assign each word the IOB label with highest classification probability, and chunk the IOB labeled words back into labeled N-grams. During chunking, words with I labels without matching B labels are ignored. For example, the sequence of IOB labels [B-Currency, O, BTotal, I-Total, O, I-Total, O] would be chunked into [Currency, O, Total, O, O]. The labeled N-grams are used as input for the Post Processor and further processing is identical to the baseline system."}, {"heading": "V. RESULTS", "text": "The results of the ceiling analysis seen in Table I show that we can achieve very competitive results with CloudScan using an oracle classifier. This validates the overall system design,\nincluding the use of automatically generated training data, and leaves us with the challenge of constructing a good classifier.\nThe attentive reader might wonder why the precision is not 1 exactly for all fields, when using the oracle classifier. For the \u2019Number\u2019 and \u2019Order ID\u2019 fields this is due to the automatic training data generation algorithm disregarding spaces when finding matching N-grams, whereas the comparison during evaluation is strict. For instance the automatic training data generator might generate the N-gram (\u201d16 2054\u201d: Invoice Number) from (Invoice Number: \u201d162054\u201d) in the validated UBL. When the oracle classifier classifies the N-gram \u201d16 2054\u201d as Invoice Number the produced UBL will be (Invoice Number: \u201d16 2054\u201d). When this is compared to the expected UBL of (Invoice Number: \u201d162054\u201d) it is counted as incorrect. This is an annoying artifact of the evaluation method and training data generation. We could disregard spaces when comparing strings during evaluation, but we would risk regarding some actual errors as correct then. For the total fields and the tax percent, the post processor will attempt to calculate missing numbers from found numbers, which might result in errors.\nAs it stands the recall rate is the limiting factor of the system. The low recall rate can have two explanations: 1) The information is present in the PDF but we cannot read or parse it, e.g. it might be an OCR error or a strange date format, in which case the OCR engine or parsing should be improved, or 2) the information is legitimately not present in the PDF, in which case there is nothing to do, except change the validated UBL to match the PDF.\nTable II shows the results of experiment 1 measuring the expected performance on the next received invoice for the baseline and LSTM model. The LSTM model is slightly better than the baseline system with an average F1 of 0.891 compared to 0.887. In general the performance of the models is very similar, and close to the theoretical maximum performance given by the ceiling analysis. This means the classifiers both perform close to optimally for this experiment. The gains that can be had from improving upon the LSTM model further are just 0.034 average F1.\nMore interesting are the results in Table III which measures\nthe expected performance on the next invoice from an unseen template. This measures the generalization performance of the system across templates which is a much harder task due to the plurality of invoice layouts and reflects the experience a new user will have the first time they use the system. On this harder task the LSTM model clearly outperform the baseline system with an average F1 of 0.840 compared to 0.788. Notably the 0.840 average F1 of the LSTM model is getting close to the 0.891 average F1 of experiment 1, indicating that the LSTM model is largely learning a template invariant model of invoices, i.e. it is picking up on general patterns rather than just memorizing specific templates.\nWe hypothesized that it is the ability of LSTMs to model context directly that leads to increased performance, although there are several other possibilities given the differences between the two models. For instance, it could simply be that the LSTM model has more parameters, the non-linear feature combinations, or the word embedding.\nTo test our hypothesis we trained a third model that is identical to the LSTM model, except that the bidirectional LSTM layer was replaced with a feedforward layer with an equivalent number of parameters. We trained the network\nwith and without dropout, with all other hyper parameters kept equal. The best model got an average F1 of 0.702 on the experiment 2 split, which is markedly worse than both the LSTM and baseline model. Given that the only difference between this model and the LSTM model is the lack of recurrent connections we feel fairly confident that our hypothesis is true. The feedforward model is likely worse than the baseline model because it does not have the additional context features of the baseline model.\nTable IV shows examples of words and the two closest words in the learned word embedding. It shows that the learned embeddings are language agnostic, e.g. the closest word to \u201dTotal\u201d is \u201dBetrag\u201d which is German for \u201dSum\u201d or \u201dAmount\u201d. The embedding also captures common abbreviations, capitalization, currency symbols and even semantic similarities such as cities. Learning these similarities versus encoding them by hand is a major advantage as it happens automatically as it is needed. If a new abbreviation, language, currency, etc. is encountered it will automatically be learned."}, {"heading": "VI. DISCUSSION", "text": "We have presented our goals for CloudScan and described how it works. We hypothesized that the ability of a LSTM to model context directly would improve performance. We carried out experiments to test our hypothesis and evaluated CloudScan\u2019s performance on a large realistic dataset. We validated our hypothesis and showed competitive results of 0.891 average F1 on documents from seen templates, and 0.840 on documents from unseen templates using a single LSTM model. These numbers should be compared to a ceiling of F1=0.925 for an ideal system baseline where an oracle classifier is used.\nUnfortunately it is hard to compare to other vendors directly as no large publicly available datasets exists due to the sensitive nature of invoices. We sincerely wish such a dataset existed and believe it would drive the field forward significantly, as seen in other fields, e.g. the large effect ImageNet [26] had on the computer vision field. Unfortunately we are not able to release our own dataset due to privacy restrictions.\nA drawback of the LSTM model is that we have to decide upon an ordering of the words, when there is none naturally. We chose the left to right reading order which worked well, but\nin line with the general theme of CloudScan we would prefer a model which could learn this ordering or did not require one.\nCloudScan works only on the word level, meaning it does not take any image features into account, e.g. the lines, logos, background, etc. We could likely improve the performance if we included these image features in the model.\nWith the improved results from the LSTM model we are getting close to the theoretical maximum given by the ceiling analysis. For unseen templates we can at maximum improve the average F1 by 0.085 by improving the classifier. This corresponds roughly to the 0.075 average F1 that can at maximum be gained from fixing the errors made under the ceiling analysis. An informal review of the errors made by the system under the ceiling analysis indicates the greatest source of errors are OCR errors and discrepancies between the validated UBL and the PDF.\nAs such, in order to substantially improve CloudScan we believe a two pronged strategy is required: 1) improve the classifier and 2) correct discrepancies between the validated UBL and PDF. Importantly, the second does not delay the turnaround time for the users, can be done at our own pace and only needs to be done for the cases where the automatic training data generation fails. As for the OCR errors we will rely on further advances in OCR technology."}, {"heading": "ACKNOWLEDGMENT", "text": "We would like to thank A\u0301ngel Diego Cun\u0303ado Alonso and Johannes Ule\u0301n for our fruitful discussions, and their great work on CloudScan. This research was supported by the NVIDIA Corporation with the donation of TITAN X GPUs. This work is partly funded by the Innovation Fund Denmark (IFD) under File No. 5016-00101B."}], "references": [{"title": "The Myth of the Paperless Office", "author": ["A.J. Sellen", "R.H. Harper"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "Results of a Study on Invoice- Reading Systems in Germany", "author": ["B. Klein", "S. Agne", "A. Dengel"], "venue": "Document Analysis Systems VI, ser. Lecture Notes in Computer Science, S. Marinai and A. R. Dengel, Eds. Springer Berlin Heidelberg, Sep. 2004, no. 3163, pp. 451\u2013462.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "Intellix \u2013 End-User Trained Information Extraction for Document Archiving", "author": ["D. Schuster", "K. Muthmann", "D. Esser", "A. Schill", "M. Berger", "C. Weidling", "K. Aliyev", "A. Hofmeier"], "venue": "2013 12th International Conference on Document Analysis and Recognition, Aug. 2013, pp. 101\u2013105.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "Field Extraction from Administrative Documents by Incremental Structural Templates", "author": ["M. Rusi\u00f1ol", "T. Benkhelfallah", "V.P. dAndecy"], "venue": "2013 12th International Conference on Document Analysis and Recognition, Aug. 2013, pp. 1100\u20131104.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "smartFIX: A Requirements-Driven System for Document Analysis and Understanding", "author": ["A. Dengel", "B. Klein"], "venue": "Proceedings of the 5th International Workshop on Document Analysis Systems V, ser. DAS \u201902. London, UK, UK: Springer-Verlag, 2002, pp. 433\u2013444.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "Analysis and understanding of multi-class invoices", "author": ["F. Cesarini", "E. Francesconi", "M. Gori", "G. Soda"], "venue": "Document Analysis and Recognition, vol. 6, no. 2, pp. 102\u2013114, Oct. 2003. [Online]. Available: http://link.springer.com/article/10.1007/s10032-002-0084-6", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Automatic Indexing of Scanned Documents - a Layout-based Approach", "author": ["D. Esser", "D. Schuster", "K. Muthmann", "M. Berger", "A. Schill"], "venue": "Document Recognition and Retrieval XIX (DRR), San Francisco, CA, USA, 2012. [Online]. Available: http://proceedings. spiedigitallibrary.org/proceeding.aspx?articleid=1284003", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "A probabilistic approach to printed document understanding", "author": ["E. Medvet", "A. Bartoli", "G. Davanzo"], "venue": "International Journal on Document Analysis and Recognition (IJDAR), vol. 14, no. 4, pp. 335\u2013347, Nov. 2010. [Online]. Available: http://link.springer.com/article/10.1007/ s10032-010-0137-1", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Distant supervision for relation extraction without labeled data", "author": ["M. Mintz", "S. Bills", "R. Snow", "D. Jurafsky"], "venue": "Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP: Volume 2-Volume 2. Association for Computational Linguistics, 2009, pp. 1003\u20131011.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "A survey of named entity recognition and classification", "author": ["D. Nadeau", "S. Sekine"], "venue": "Lingvisticae Investigationes, vol. 30, no. 1, pp. 3\u201326, 2007.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Neural Architectures for Named Entity Recognition", "author": ["G. Lample", "M. Ballesteros", "S. Subramanian", "K. Kawakami", "C. Dyer"], "venue": "2016.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2016}, {"title": "Investigation of recurrentneural-network architectures and learning methods for spoken language understanding.", "author": ["G. Mesnil", "X. He", "L. Deng", "Y. Bengio"], "venue": "INTERSPEECH,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "The hOCR Microformat for OCR Workflow and Results", "author": ["T. Breuel"], "venue": "Ninth International Conference on Document Analysis and Recognition (ICDAR 2007), vol. 2, Sep. 2007, pp. 1063\u20131067.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2007}, {"title": "The Hungarian method for the assignment problem", "author": ["H.W. Kuhn"], "venue": "Naval Research Logistics Quarterly, vol. 2, no. 1-2, pp. 83\u201397, Mar. 1955. [Online]. Available: http://onlinelibrary.wiley.com/doi/10.1002/ nav.3800020109/abstract", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1955}, {"title": "Universal business language v2.0", "author": ["G.K. Holman"], "venue": "2006.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2006}, {"title": "MUC-5 Evaluation Metrics", "author": ["N. Chinchor", "B. Sundheim"], "venue": "Proceedings of the 5th Conference on Message Understanding, ser. MUC5 \u201993. Association for Computational Linguistics, 1993, pp. 69\u201378.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1993}, {"title": "Feature Hashing for Large Scale Multitask Learning", "author": ["K. Weinberger", "A. Dasgupta", "J. Langford", "A. Smola", "J. Attenberg"], "venue": "Proceedings of the 26th Annual International Conference on Machine Learning, ser. ICML \u201909. New York, NY, USA: ACM, 2009, pp. 1113\u20131120. [Online]. Available: http://doi.acm.org/10.1145/1553374.1553516", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2009}, {"title": "Long Short-Term Memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural Comput., vol. 9, no. 8, pp. 1735\u20131780, Nov. 1997. [Online]. Available: http://dx.doi.org/10.1162/neco.1997.9.8.1735", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1997}, {"title": "Text Chunking Using Transformation-Based Learning", "author": ["L.A. Ramshaw", "M.P. Marcus"], "venue": "Proceedings of the Third ACL Workshop on Very Large Corpora, pp. 82\u201394, 1995.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1995}, {"title": "A Neural Probabilistic Language Model", "author": ["Y. Bengio", "R. Ducharme", "P. Vincent", "C. Jauvin"], "venue": "Journal of Machine Learning Research, vol. 3, no. Feb, pp. 1137\u20131155, 2003. [Online]. Available: http: //www.jmlr.org/papers/v3/bengio03a.html", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2003}, {"title": "Neural machine translation of rare words with subword units", "author": ["R. Sennrich", "B. Haddow", "A. Birch"], "venue": "arXiv preprint arXiv:1508.07909, 2015.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2015}, {"title": "A Theoretically Grounded Application of Dropout in Recurrent Neural Networks", "author": ["Y. Gal"], "venue": "arXiv:1512.05287 [stat], Dec. 2015, arXiv: 1512.05287. [Online]. Available: http://arxiv.org/abs/1512.05287", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Adam: A Method for Stochastic Optimization", "author": ["D. Kingma", "J. Ba"], "venue": "arXiv:1412.6980 [cs], Dec. 2014, arXiv: 1412.6980. [Online]. Available: http://arxiv.org/abs/1412.6980", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "Theano: A Python framework for fast computation of mathematical expressions", "author": ["Theano Development Team"], "venue": "arXiv e-prints, vol. abs/1605.02688, May 2016. [Online]. Available: http://arxiv.org/abs/ 1605.02688", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2016}, {"title": "Lasagne: First release.", "author": ["S. Dieleman", "J. Schl\u00fcter", "C. Raffel", "E. Olson", "S.K. S\u00f8nderby", "D. Nouri", "D. Maturana", "M. Thoma", "E. Battenberg", "J. Kelly", "J.D. Fauw", "M. Heilman", "D.M. d. Almeida", "B. McFee", "H. Weideman", "G. Tak\u00e1cs", "P. d. Rivaz", "J. Crall", "G. Sanders", "K. Rasul", "C. Liu", "G. French", "J. Degrave"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "Invoices, orders, credit notes and similar business documents carry the information needed for trade to occur between companies and much of it is on paper or in semi-structured formats such as PDFs [1].", "startOffset": 198, "endOffset": 201}, {"referenceID": 1, "context": "This is a labor intensive and expensive process [2].", "startOffset": 48, "endOffset": 51}, {"referenceID": 2, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 9, "endOffset": 12}, {"referenceID": 3, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 22, "endOffset": 25}, {"referenceID": 4, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 36, "endOffset": 39}, {"referenceID": 5, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 51, "endOffset": 54}, {"referenceID": 6, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 56, "endOffset": 59}, {"referenceID": 7, "context": "Intellix [3], ITESOFT [4], smartFIX [5] and others [6], [7], [8].", "startOffset": 61, "endOffset": 64}, {"referenceID": 2, "context": "The most directly related works are Intellix [3] by DocuWare and the work by ITESOFT [4].", "startOffset": 45, "endOffset": 48}, {"referenceID": 3, "context": "The most directly related works are Intellix [3] by DocuWare and the work by ITESOFT [4].", "startOffset": 85, "endOffset": 88}, {"referenceID": 4, "context": "smartFIX [5] uses manually configured rules for each template.", "startOffset": 9, "endOffset": 12}, {"referenceID": 5, "context": "[6] learns a database of keywords for each template and fall back to a global database of keywords.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7] uses a database of absolute positions of fields for each template.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] uses a database of manually created (field, pattern, parser) triplets for each template, designs a probabilistic model for finding the most similar pattern in a template, and extracts the value with the associated parser.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "Our automatic training data extraction is closely related to the idea of distant supervision [9] where relations are extracted from unstructured text automatically using heuristics.", "startOffset": 93, "endOffset": 96}, {"referenceID": 9, "context": "See Nadeau and Sekine [10] for a survey of NER approaches.", "startOffset": 22, "endOffset": 26}, {"referenceID": 10, "context": "[11], who combine word and character level RNNs, and Conditional Random Fields (CRFs).", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] uses bi-directional RNNs and word embedding to achieve competitive results on the ATIS (Airline Travel Information Systems) benchmark dataset.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "The output of this step is a structured representation of words and lines in hOCR format [13].", "startOffset": 89, "endOffset": 93}, {"referenceID": 13, "context": "we use the Hungarian algorithm [14].", "startOffset": 31, "endOffset": 35}, {"referenceID": 14, "context": "Builds a Universal Business Language (UBL) [15] invoice with the fields having the values of the found N-grams.", "startOffset": 43, "endOffset": 47}, {"referenceID": 2, "context": "Also, while not directly comparable, related work [3], [4], [6] also restricts evaluation to header fields.", "startOffset": 50, "endOffset": 53}, {"referenceID": 3, "context": "Also, while not directly comparable, related work [3], [4], [6] also restricts evaluation to header fields.", "startOffset": 55, "endOffset": 58}, {"referenceID": 5, "context": "Also, while not directly comparable, related work [3], [4], [6] also restricts evaluation to header fields.", "startOffset": 60, "endOffset": 63}, {"referenceID": 15, "context": "We use the MUC-5 definitions of recall, precision and F1, without partial matches [16].", "startOffset": 82, "endOffset": 86}, {"referenceID": 16, "context": "All 5M features are then mapped to a binary vector of size 2 using the hashing trick [17].", "startOffset": 85, "endOffset": 89}, {"referenceID": 17, "context": "[18] which is good at modeling long term dependencies.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "com/c/tradeshift-text-classification scheme [19].", "startOffset": 44, "endOffset": 48}, {"referenceID": 19, "context": "We hash the text of the word into a binary vector of size 2 which is embedded in a trainable 500 dimensional distributed representation using an embedding layer [20].", "startOffset": 161, "endOffset": 165}, {"referenceID": 20, "context": "It is possible we could have gotten better results using more advanced techniques like byte pair encoding [21].", "startOffset": 106, "endOffset": 110}, {"referenceID": 21, "context": "Following Gal [22], we apply dropout on the recurrent units and on the word embedding using a dropout fraction of 0.", "startOffset": 14, "endOffset": 18}, {"referenceID": 22, "context": "The model is trained with the Adam optimizer [23] using minibatches of size 96 until the validation performance has not improved on the validation set for 5 epochs.", "startOffset": 45, "endOffset": 49}, {"referenceID": 23, "context": "The LSTM model was implemented in Theano [24] and Lasagne [25].", "startOffset": 41, "endOffset": 45}, {"referenceID": 24, "context": "The LSTM model was implemented in Theano [24] and Lasagne [25].", "startOffset": 58, "endOffset": 62}], "year": 2017, "abstractText": "We present CloudScan; an invoice analysis system that requires zero configuration or upfront annotation. In contrast to previous work, CloudScan does not rely on templates of invoice layout, instead it learns a single global model of invoices that naturally generalizes to unseen invoice layouts. The model is trained using data automatically extracted from end-user provided feedback. This automatic training data extraction removes the requirement for users to annotate the data precisely. We describe a recurrent neural network model that can capture long range context and compare it to a baseline logistic regression model corresponding to the current CloudScan production system. We train and evaluate the system on 8 important fields using a dataset of 326,471 invoices. The recurrent neural network and baseline model achieve 0.891 and 0.887 average F1 scores respectively on seen invoice layouts. For the harder task of unseen invoice layouts, the recurrent neural network model outperforms the baseline with 0.840 average F1 compared to 0.788.", "creator": "LaTeX with hyperref package"}}}