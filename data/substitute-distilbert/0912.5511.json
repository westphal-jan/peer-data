{"id": "0912.5511", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Dec-2009", "title": "A general approach to belief change in answer set programming", "abstract": "we address the problem of belief change in ( nonmonotonic ) logic functions under answer swap transformation. unlike previous approaches to belief change in logic programming, our formal techniques are suited to those of distance - based belief movements since propositional logic. in both our results, we build upon the model theory of quantum programs furnished by se models. since se models provide a formal, monotonic characterisation of logic complexity, we can adapt techniques from the area of belief revision to belief change in logic programs. we assign formulas for revising and merging some programs, respectively. for the former, we study both subset - based revision as well distinct cardinality - based revision, and we show that they satisfy the majority of cache agm postulates for revision. for merging, we consider operators following arbitration merging and ic merging, respectively. we also present encodings for computing the cache as well knowing the merging of logic programs follows the same standard programming boundary, giving rise to a direct implementation of unification approach in terms of pinch - the - shelf answer set solvers. these encodings reflect in turn the fact that hypothesis change operators don't denote the complexity of the base formalism.", "histories": [["v1", "Wed, 30 Dec 2009 18:33:43 GMT  (190kb,S)", "http://arxiv.org/abs/0912.5511v1", "44 pages"]], "COMMENTS": "44 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["james delgrande", "torsten schaub", "hans tompits", "stefan woltran"], "accepted": false, "id": "0912.5511"}, "pdf": {"name": "0912.5511.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["jim@cs.sfu.ca.", "torsten@cs.uni-potsdam.de."], "sections": [{"heading": null, "text": "ar X\niv :0\n91 2.\n55 11\nv1 [\ncs .A\nI] 3\n0 D\nec 2\n00 9\nA General Approach to Belief Change in Answer Set Programming\nJAMES DELGRANDE Simon Fraser University TORSTEN SCHAUB Universita\u0308t Potsdam and HANS TOMPITS and STEFAN WOLTRAN Technische Universita\u0308t Wien\nWe address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs.\nWe first consider belief revision: given logic programs P and Q, the goal is to determine a program R that corresponds to the revision of P by Q, denoted P \u2217 Q. We investigate several specific operators, including (logic program) expansion and two revision operators based on the distance between the SE models of logic programs. It proves to be the case that expansion is an interesting operator in its own right, unlike in classical AGM-style belief revision where it is relatively uninteresting. Expansion and revision are shown to satisfy a suite of interesting properties; in particular, our revision operators satisfy the majority of the AGM postulates for revision.\nSecond, we consider approaches for merging logic programs. Given logic programs P1, . . . , Pn, the goal is to provide characterisations of the merging of these programs. Again, our formal techniques are based on notions of relative distance between the underlying SE models of the logic programs. Two approaches are examined. The first informally selects those models of the programs that vary the least from the models of the other programs. The second approach informally selects those models of a program P0 that are closest to the models of programs P1, . . . , Pn. In this case, P0 can be thought of as analogous to a set of database integrity constraints. We examine properties of these operators with regards to how they satisfy relevant postulate sets.\nWe also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.\nThe first author was supported by a Canadian NSERC Discovery Grant. The second author was supported by the German Science Foundation (DFG) under grant SCHA 550/8-1. The third author was supported by the Austrian Science Fund (FWF) under project P21698. Authors\u2019 address: J. Delgrande, Simon Fraser University, Burnaby, B.C., Canada, V5A 1S6, e-mail: jim@cs.sfu.ca. T. Schaub, Universita\u0308t Potsdam, August-Bebel-Stra\u00dfe 89, D-14482 Potsdam, Germany, e-mail: torsten@cs.uni-potsdam.de. H. Tompits and S. Woltran, Technische Universita\u0308t Wien, Favoritenstra\u00dfe 9-11, A-1040 Vienna, Austria, e-mail: tompits@kr.tuwien.ac.at, woltran@dbai.tuwien.ac.at. Permission to make digital/hard copy of all or part of this material without fee for personal or classroom use provided that the copies are not made or distributed for profit or commercial advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists requires prior specific permission and/or a fee. c\u00a9 20YY ACM 1529-3785/20YY/0700-0001 $5.00\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY, Pages 1\u201344.\nCategories and Subject Descriptors: I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving\u2014logic programming; nonmonotonic reasoning and belief revision; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods\u2014representation languages; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic\u2014logic and constraint programming\nGeneral Terms: Theory\nAdditional Key Words and Phrases: Answer set programming, belief revision, belief merging, strong equivalence"}, {"heading": "1. INTRODUCTION", "text": "Answer set programming (ASP) [Gelfond and Lifschitz 1988; Baral 2003] has emerged as a major area of research in knowledge representation and reasoning (KRR). On the one hand, ASP has an elegant and conceptually simple theoretical foundation, while on the other hand efficient implementations of ASP solvers exist which have been finding applications to practical problems. However, as is the case with any large program or body of knowledge, a logic program is not a static object in general, but rather it will evolve and be subject to change, whether as a result of correcting information in the program, adding to the information already present, or in some other fashion modifying the knowledge represented in the program.\nSince knowledge is continually evolving and subject to change, there is a need to be able to revise logic programs as new information is received. In KRR, the area of belief revision [Alchourro\u0301n et al. 1985; Ga\u0308rdenfors 1988] addresses just such change to a knowledge base. In AGM belief revision (named after the aforecited developers of the approach) one has a knowledge baseK and a formula\u03b1, and the issue is how to consistently incorporate\u03b1 inK to obtain a new knowledge base K \u2032. The interesting case is whenK \u222a {\u03b1} is inconsistent, since beliefs have to be dropped from K before \u03b1 can be consistently added. Hence, a fundamental issue concerns how such change should be managed.\nIn classical propositional logic, specific belief revision operators have been proposed based on the distance between models of a knowledge base and a formula for revision. That is, a characterisation of the revision of a knowledge base K by formula \u03b1 is to set the models of the revised knowledge base K \u2032 to be the models of \u03b1 that are \u201cclosest\u201d to those of K . Of course the notion of \u201cclosest\u201d needs to be pinned down, but natural definitions based on the Hamming distance [Dalal 1988] and set containment with regards to propositional letters [Satoh 1988] are well known.\nIn addition to belief revision (along with the dual notion of belief contraction), a second major class of belief change operators addresses the merging of knowledge bases. The problem of merging multiple, potentially conflicting bodies of information arises in various different contexts. For example, an agent may receive reports from differing sources of knowledge, or from sets of sensors that need to be reconciled. As well, an increasingly common phenomenon is that collections of data may need to be combined into a coherent whole. In these cases, the problem is that of combining knowledge sets that may be jointly inconsistent in order to get a consistent set of merged beliefs. Again, as in belief revision, specific operators for merging knowledge bases have been developed based on the distance between models of the underlying knowledge bases [Baral et al. 1992; Revesz 1993; Liberatore and Schaerf 1998; Meyer 2001; Konieczny and Pino Pe\u0301rez 2002; Konieczny et al. 2002].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nIt is natural then to consider belief change in the context of logic programs. Indeed, there has been substantial effort in developing approaches to so-called logic program updating under answer set semantics (we discuss previous work in the next section). Unfortunately, given the nonmonotonic nature of answer set programs, the problem of change in logic programs has appeared to be intrinsically more difficult than in a monotonic setting. In this paper, our goal is to reformulate belief change in logic programs in a manner analogous to belief change in classical propositional logic, and to investigate specific belief revision and merging operators for extended logic programs. Central for our approach are SE models [Turner 2003], which are semantic structures characterising strong equivalence between programs [Lifschitz et al. 2001]. This particular kind of equivalence plays a major role for different problems in logic programming\u2014in particular, in program simplifications and modularisation. This is due to the fact that strong equivalence gives rise to a substitution principle in the sense that, for all programs P,Q, the programsP \u222aR andQ\u222aR have the same answer sets, for any programR. As is well known, ordinary equivalence between programs (which holds if two programs have the same answer sets) does not yield a substitution principle. Hence, strong equivalence can be seen as the logic programming analogue of ordinary equivalence in classical logic. The important aspect of strong equivalence is that it coincides with equivalence in a specific monotonic logic, the logic of here and there (HT), which is intermediate between intuitionistic logic and classical logic. As shown by Turner [2003], equivalence between programs in HT corresponds in turn to equality between sets of SE models. Details on these concepts are given in the next section; the key point is that logic programs can be expressed in terms of a non-classical but monotonic logic, and it is this point that we exploit here.\nMore specifically, given this monotonic characterisation (via sets of SE models) of strong equivalence, we adapt techniques for belief change in propositional logic to belief change in logic programs. Hence we come up with specific operators for belief change in ASP analogous to operators in propositional logic. We first consider an expansion operator. In classical logic, the expansion of knowledge base K by formula \u03b1 amounts to the deductive closure of K \u222a {\u03b1}. Hence it is not a very interesting operator, serving mainly as a tool for expressing concepts in belief revision and its dual, contraction. In logic programs however, expansion appears to be a more useful operator, perhaps due to the apparent \u201clooser\u201d notion of satisfiability provided by SE models. As well, it has appealing properties. We next develop revision operators based on notions of distance between SE models, and, following this, merging operators.\nIn characterising the merging of logic programs, the central idea is that the SE models of the merged program are again those that are in some sense \u201cclosest\u201d to the SE models of the programs to be merged. However, as with merging knowledge bases expressed in classical logic, there is no single preferred notion of distance nor closeness, and consequently different approaches have been defined for combining sources of information. We introduce two merging operators for logic programs under answer set semantics. Both operators take an arbitrary (multi)set of logic programs as argument. The first operator can be regarded an instance of what Liberatore and Schaerf [1998] call arbitration. Basically (SE) models are selected from among the SE models of the programs to be merged; in a sense this operator is a natural extension of our belief revision operator. The second merging operator can be regarded as an instance of the one discussed by Konieczny and Pino Pe\u0301rez [2002]. Here, models of a designated program (representing information analogous\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nto database integrity constraints) are selected that are closest to (or perhaps, informally, represent the best compromise among) the models of the programs to be merged.\nNotably, in our approaches there is effectively no mention of answer sets; rather definitions of expansion and revision are given entirely with respect to logic programs. Notably too, our operators are syntax independent, which is to say, they are independent of how a logic program is expressed; hence, our operators deal with the logical content of a logic program.\nFollowing an introductory background section, we show that there is a ready mapping between concepts in belief revision in classical logic and in ASP; this serves to place belief revision in ASP firmly in the \u201cstandard\u201d belief revision camp. After this we describe in Section 3 our approaches to belief expansion and revision in ASP. We then employ these techniques in the following section to address the merging of logic programs. In either case, we discuss central properties and give complexity results. Then, in Section 5, we show how we can in fact express the process of belief change in ASP itself, giving a direct way to compute our introduced belief change operators. We conclude with a discussion. Proofs of results are contained in an appendix."}, {"heading": "2. BACKGROUND AND FORMAL PRELIMINARIES", "text": ""}, {"heading": "2.1 Answer Set Programming", "text": "2.1.1 Syntax and Semantics. A (generalised) logic program1 (GLP) over an alphabet A is a finite set of rules of the form\na1; . . . ; am;\u223cbm+1; . . . ;\u223cbn \u2190 cn+1, . . . , co,\u223cdo+1, . . . ,\u223cdp, (1)\nwhere ai, bj , ck, dl \u2208 A are atoms, for 1 \u2264 i \u2264 m < j \u2264 n < k \u2264 o < l \u2264 p. Operators \u2018;\u2019 and \u2018,\u2019 express disjunctive and conjunctive connectives. A default literal is an atom a or its (default) negation \u223ca. A rule r as in (1) is called a fact if p = 1, normal if n = 1, positive if m = n and o = p, disjunctive if m = n, and an integrity constraint if n = 0, yielding an empty disjunction, sometimes denoted by \u22a5 for convenience. Accordingly, a program is called disjunctive (or a DLP) if it consists of disjunctive rules only. Likewise, a program is normal (resp., positive) iff all rules in it are normal (resp., positive). We furthermore define the head and body of a rule, H(r) and B(r), by:\nH(r) = {a1, . . . , am,\u223cbm+1, . . . ,\u223cbn} and\nB(r) = {cn+1, . . . , co,\u223cdo+1, . . . ,\u223cdp}.\nMoreover, given a set X of literals, we define\nX+ = {a \u2208 A | a \u2208 X},\nX\u2212 = {a \u2208 A | \u223ca \u2208 X}, and\n\u223cX = {\u223ca | a \u2208 X \u2229 A}.\nFor simplicity, we sometimes use a set-based notation, expressing a rule as in (1) as H(r)+;\u223cH(r)\u2212\u2190 B(r)+,\u223cB(r)\u2212.\nIn what follows, we restrict ourselves to a finite alphabet A. An interpretation is represented by the subset of atoms in A that are true in the interpretation. A (classical) model\n1Such programs were first considered by Lifschitz and Woo [1992] and called generalised disjunctive logic programs by Inoue and Sakama [1998].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nof a program P is an interpretation in which all of the rules in P are true according to the standard definition of truth in propositional logic, and where default negation is treated as classical negation. By Mod(P ) we denote the set of all classical models of P . An answer set Y of a program P is a subset-minimal model of\n{H(r)+\u2190 B(r)+ | r \u2208 P, H(r)\u2212 \u2286 Y, B(r)\u2212 \u2229 Y = \u2205}.\nThe set of all answer sets of a program P is denoted by AS(P ). For example, the program P = {a\u2190, c; d\u2190 a,\u223cb} has answer sets AS(P ) = {{a, c}, {a, d}}.\n2.1.2 SE Models. As defined by Turner [2003], an SE interpretation is a pair (X,Y ) of interpretations such thatX \u2286 Y \u2286 A. An SE interpretation is an SE model of a program P if Y |= P andX |= PY . The set of all SE models of a programP is denoted by SE (P ). Note that Y is an answer set of P iff (Y, Y ) \u2208 SE (P ) and no (X,Y ) \u2208 SE (P ) with X \u2282 Y exists. Also, we have (Y, Y ) \u2208 SE (P ) iff Y \u2208 Mod(P ).\nA program P is satisfiable just if SE (P ) 6= \u2205. Two programs P and Q are strongly equivalent, symbolically P \u2261s Q, iff SE (P ) = SE (Q). Alternatively, P \u2261s Q holds iff AS(P \u222a R) = AS (Q \u222a R), for every program R [Lifschitz et al. 2001]. We also write P |=s Q iff SE (P ) \u2286 SE (Q). For simplicity, we often drop set-notation within SE interpretations and simply write, e.g., (a, ab) instead of ({a}, {a, b}).\nOne feature of SE models is that they contain \u201cmore information\u201d than answer sets, which makes them an appealing candidate for problems where programs are examined with respect to further extension (in fact, this is what strong equivalence is about). We illustrate this issue with the following well-known example, involving programs\nP = {p; q \u2190} and Q =\n{\np\u2190 \u223cq q \u2190 \u223cp\n}\n.\nHere, we have AS(P ) = AS(Q) = {{p}, {q}}. However, the SE models (we list them for A = {p, q}) differ:\nSE (P ) = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq)}; SE (Q) = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq), (\u2205, pq)}.\nThis is to be expected, since P andQ behave differently with respect to program extension (and thus are not strongly equivalent). ConsiderR = {p\u2190 q, q \u2190 p}. ThenAS(P\u222aR) = {{p, q}}, while AS (Q \u222aR) has no answer set.\nA set S of SE interpretations is well-defined if, for each (X,Y ) \u2208 S, also (Y, Y ) \u2208 S. A well-defined set S of SE interpretations is complete if, for each (X,Y ) \u2208 S, also (X,Z) \u2208 S, for any Y \u2286 Z with (Z,Z) \u2208 S. We have the following properties:\n\u2014For each GLP P , SE (P ) is well-defined.\n\u2014For each DLP P , SE (P ) is complete.\nFurthermore, for each well-defined set S of SE interpretations, there exists a GLP P such that SE(P ) = S, and for each complete set S of SE interpretations, there exists a DLP P such that SE (P ) = S. Programs meeting these conditions can be constructed thus [Eiter et al. 2005; Cabalar and Ferraris 2007]: In case S is a well-defined set of SE interpretations over a (finite) alphabet A, define P by adding\n(1) the rule rY : \u22a5 \u2190 Y,\u223c(A \\ Y ), for each (Y, Y ) /\u2208 S, and\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(2) the rule rX,Y : (Y \\X);\u223cY \u2190 X,\u223c(A \\ Y ), for eachX \u2286 Y such that (X,Y ) /\u2208 S and (Y, Y ) \u2208 S.\nIn case S is complete, define P by adding\n(1) the rule rY , for each (Y, Y ) /\u2208 S, as above, and (2) the rule r\u2032X,Y : (Y \\X) \u2190 X,\u223c(A \\ Y ), for each X \u2286 Y such that (X,Y ) /\u2208 S and\n(Y, Y ) \u2208 S.\nWe call the resulting programs canonical. For illustration, consider\nS = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq), (\u2205, p)}\nover A = {p, q}. Note that S is not complete. The canonical GLP is as follows:\nr\u2205 : \u22a5 \u2190 \u223cp,\u223cq; r\u2205,q : q;\u223cq \u2190 \u223cp; r\u2205,pq : p; q;\u223cp;\u223cq \u2190 .\nFor obtaining a complete set, we have to add (\u2205, pq) to S. Then, the canonical DLP is as follows:\nr\u2205 : \u22a5 \u2190 \u223cp,\u223cq; r\u2205,q : q \u2190 \u223cp.\nWe conclude this subsection by introducing definitions for ordering SE models that will be needed when we come to define our belief change operators. Let \u2296 denote the symmetric difference operator between sets, i.e., X \u2296Y = (X \\ Y )\u222a (Y \\X) for every set X,Y . We extend \u2296 so that it is defined for ordered pairs, as follows:\nDEFINITION 1. For every pair (X1, X2), (Y1, Y2),\n(X1, X2)\u2296 (Y1, Y2) = (X1 \u2296 Y1, X2 \u2296 Y2).\nSimilarly, we define a notion of set containment, suitable for ordered pairs, as follows:\nDEFINITION 2. For every pair (X1, X2), (Y1, Y2),\n(X1, X2) \u2286 (Y1, Y2) iff X2 \u2286 Y2, and if X2 = Y2 then X1 \u2286 Y1.\nFurthermore, (X1, X2) \u2282 (Y1, Y2) iff (X1, X2) \u2286 (Y1, Y2) and not (Y1, Y2) \u2286 (X1, X2).\nAs will be seen, these definitions are appropriate for SE interpretations, as they give preference to the second element of a SE interpretation.\nSet cardinality is denoted as usual by | \u00b7 |. We define a cardinality-based ordering over ordered pairs of sets as follows:\nDEFINITION 3. For every pair (X1, X2), (Y1, Y2),\n|(X1, X2)| \u2264 |(Y1, Y2)| iff |X2| \u2264 |Y2| and if |X2| = |Y2| then |X1| \u2264 |Y1|.\nFurthermore, |(X1, X2)| < |(Y1, Y2)| iff |(X1, X2)| \u2264 |(Y1, Y2)| and not |(Y1, Y2)| \u2264 |(X1, X2)|.\nAs with Definition 2, this definition gives preference to the second element of an ordered pair. It can be observed that the definition yields a total preorder over ordered pairs. In the next section we return to the suitability of this definition, once our revision operators have been presented.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."}, {"heading": "2.2 Belief Change", "text": "2.2.1 Belief Revision. The best known and, indeed, seminal work in belief revision is the AGM approach [Alchourro\u0301n et al. 1985; Ga\u0308rdenfors 1988], in which standards for belief revision and contraction functions are given. In the revision of a knowledge base K by a formula \u03c6, the intent is that the resulting knowledge contains \u03c6, be consistent (unless \u03c6 is not), while keeping whatever information from K can be \u201creasonably\u201d retained. Belief contraction is a dual notion, in which information is removed from a knowledge base; given that it is of limited interest with respect to our approach, we do not consider it further. Moreover, it is generally accepted that a contraction function can be obtained from a revision function by the so-called Harper identity, and the reverse obtained via the Levi identity; see Ga\u0308rdenfors [1988] for details. In the AGM approach it is assumed that a knowledge base is receiving information concerning a static2 domain. Belief states are modelled by logically closed sets of sentences, called belief sets. A belief set is a set K of sentences which satisfies the constraint\nif K logically entails \u03b2, then \u03b2 \u2208 K.\nK can be seen as a partial theory of the world. For belief set K and formula \u03b1, K + \u03b1 is the deductive closure of K \u222a {\u03b1}, called the expansion of K by \u03b1. K\u22a5 is the inconsistent belief set (i.e., K\u22a5 is the set of all formulas).\nSubsequently, Katsuno and Mendelzon [1992] reformulated the AGM approach so that a knowledge base was represented by a formula in some language L. The following postulates comprise Katsuno and Mendelzon\u2019s reformulation of the AGM revision postulates, where \u2217 is a function from L \u00d7 L to L:\n(R1). \u03c8 \u2217 \u00b5 \u22a2 \u00b5.\n(R2). If \u03c8 \u2227 \u00b5 is satisfiable, then \u03c8 \u2217 \u00b5\u2194 \u03c8 \u2227 \u00b5.\n(R3). If \u00b5 is satisfiable, then \u03c8 \u2217 \u00b5 is also satisfiable.\n(R4). If \u03c81 \u2194 \u03c82 and \u00b51 \u2194 \u00b52, then \u03c81 \u2217 \u00b51 \u2194 \u03c82 \u2217 \u00b52.\n(R5). (\u03c8 \u2217 \u00b5) \u2227 \u03c6 \u22a2 \u03c8 \u2217 (\u00b5 \u2227 \u03c6).\n(R6). If (\u03c8 \u2217 \u00b5) \u2227 \u03c6 is satisfiable, then \u03c8 \u2217 (\u00b5 \u2227 \u03c6) \u22a2 (\u03c8 \u2217 \u00b5) \u2227 \u03c6.\nThus, revision is successful (R1), and corresponds to conjunction when the knowledge base and formula for revision are jointly consistent (R2). Revision leads to inconsistency only when the formula for revision is unsatisfiable (R3). Revision is also independent of syntactic representation (R4). Last, (R5) and (R6) express that revision by a conjunction is the same as revision by a conjunct conjoined with the other conjunct, when the result is satisfiable.\n2.2.2 Specific Belief Revision Operators. In classical belief change, the revision of a knowledge base represented by formula \u03c8 by a formula \u00b5, \u03c8 \u2217 \u00b5, is a formula \u03c6 such that the models of \u03c6 are just those models of \u00b5 that are \u201cclosest\u201d to those of \u03c8. There are two main specific approaches to distance-based revision. Both are related to the Hamming distance between two interpretations, that is on the set of atoms on which the interpretations\n2 Note that \u201cstatic\u201d does not imply \u201cwith no mention of time\u201d. For example, one could have information in a knowledge base about the state of the world at different points in time, and revise information at these points in time.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\ndisagree. The first, by Satoh [1988], is based on set containment. The second, due to Dalal [1988], uses a distance measure based on the number of atoms with differing truth values in two interpretations. A set containment-based approach seems more appropriate in the context of ASP, since answer sets are defined in terms of subset-minimal interpretations. Hence, we focus on the method of Satoh [1988], although we also consider Dalal-style revision, since it has some technical interest with respect to ASP revision.\nThe Satoh revision operator, \u03c8 \u2217s \u00b5, is defined as follows. For formulas \u03b1 and \u03b2, define \u2296min(\u03b1, \u03b2) as\nmin\u2286({w \u2296 w \u2032 | w \u2208 Mod(\u03b1), w\u2032 \u2208 Mod(\u03b2)}).\nFurthermore, define Mod(\u03c8 \u2217s \u00b5) as\n{w \u2208 Mod(\u00b5) | \u2203w\u2032\u2208Mod(\u03c8) s.t. w \u2296 w\u2032 \u2208 \u2296min(\u03c8, \u00b5)}.\nThe cardinality-based or Dalal revision operator, \u03c8 \u2217d \u00b5, is defined as follows. For formulas \u03b1 and \u03b2, define |\u2296|min(\u03b1, \u03b2) as\nmin\u2264({|w \u2296 w \u2032| | w \u2208 Mod(\u03b1), w\u2032 \u2208 Mod(\u03b2)}).\nThen, Mod(\u03c8 \u2217d \u00b5) is given as\n{w \u2208 Mod(\u00b5) | \u2203w\u2032\u2208Mod(\u03c8) s.t. |w \u2296 w\u2032| = |\u2296|min(\u03c8, \u00b5)}.\n2.2.3 Belief Merging. Earlier work on merging operators includes approaches by Baral et al. [1992] and Revesz [1993]. The former authors propose various theory merging operators based on the selection of maximum consistent subsets in the union of the belief bases. The latter proposes an \u201carbitration\u201d operator (see below) that, intuitively, selects from among the models of the belief sets being merged. Lin and Mendelzon [1999] examine majority merging, in which, if a plurality of knowledge bases hold \u03c6 to be true, then \u03c6 is true in the merging. Liberatore and Schaerf [1998] address arbitration in general, while Konieczny and Pino Pe\u0301rez [2002] consider a general approach in which merging takes place with respect to a set of global constraints, or formulas that must hold in the merging. We examine these latter two approaches in detail below.\nKonieczny et al. [2002] describe a very general framework in which a family of merging operators is parametrised by a distance between interpretations and aggregating functions. More or less concurrently, Meyer [2001] proposed a general approach to formulating merging functions based on ordinal conditional functions [Spohn 1988]. Booth [2002] also considers the problem of an agent merging information from different sources, via what is called social contraction. Last, much work has been carried out in merging possibilistic knowledge bases; we mention here, e.g., the method by Benferhat et al. [2003].\nWe next describe the approaches by Liberatore and Schaerf [1998] and by Konieczny and Pino Pe\u0301rez [2002], since we use the intuitions underlying these approaches as the basis for our merging technique. First, Liberatore and Schaerf [1998] consider merging two belief bases built on the intuition that models of the merged bases should be taken from those of each belief base closest to the other. This is called an arbitration operator (Konieczny and Pino Pe\u0301rez [2002] call it a commutative revision operator). They consider a propositional language over a finite set of atoms; consequently their merging operator can be expressed as a binary operator on formulas. The following postulates characterise this operator:\nDEFINITION 4. \u22c4 is an arbitration operator if \u22c4 satisfies the following postulates.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(LS1). \u03b1 \u22c4 \u03b2 \u2261 \u03b2 \u22c4 \u03b1.\n(LS2). \u03b1 \u2227 \u03b2 implies \u03b1 \u22c4 \u03b2.\n(LS3). If \u03b1 \u2227 \u03b2 is satisfiable then \u03b1 \u22c4 \u03b2 implies \u03b1 \u2227 \u03b2.\n(LS4). \u03b1 \u22c4 \u03b2 is unsatisfiable iff \u03b1 is unsatisfiable and \u03b2 is unsatisfiable.\n(LS5). If \u03b11 \u2261 \u03b12 and \u03b21 \u2261 \u03b22 then \u03b11 \u22c4 \u03b21 \u2261 \u03b12 \u22c4 \u03b22.\n(LS6). \u03b1 \u22c4 (\u03b21 \u2228 \u03b22) =\n\n\n \u03b1 \u22c4 \u03b21 or \u03b1 \u22c4 \u03b22 or (\u03b1 \u22c4 \u03b21) \u2228 (\u03b1 \u22c4 \u03b22).\n(LS7). (\u03b1 \u22c4 \u03b2) implies (\u03b1 \u2228 \u03b2).\n(LS8). If \u03b1 is satisfiable then \u03b1 \u2227 (\u03b1 \u22c4 \u03b2) is satisfiable.\nThe first postulate asserts that merging is commutative, while the next two assert that, for mutually consistent formulas, merging corresponds to their conjunction. (LS5) ensures that the operator is independent of syntax, while (LS6) provides a \u201cfactoring\u201d postulate, analogous to a similar factoring result in (AGM-style) belief revision and contraction. Postulate (LS7) can be taken as distinguishing \u22c4 from other such operators; it asserts that the result of merging implies the disjunction of the original formulas. The last postulate informally constrains the result of merging so that each operator \u201ccontributes to\u201d (i.e., is consistent with) the final result.\nNext, Konieczny and Pino Pe\u0301rez [2002] consider the problem of merging possibly contradictory belief bases. To this end, they consider finite multisets of the form \u03a8 = {K1, . . . ,Kn}. They assume that the belief sets Ki are consistent and finitely representable, and so representable by a formula. Kn is the multiset consisting of n copies of K . Following Konieczny and Pino Pe\u0301rez [2002], let \u2206\u00b5(\u03a8) denote the result of merging the multiset \u03a8 of belief bases given the entailment-based integrity constraint expressed by \u00b5. The intent is that \u2206\u00b5(\u03a8) is the belief base closest to the belief multiset \u03a8. They provide the following set of postulates (multiset union is denoted by \u222a):\nDEFINITION 5. Let \u03a8 be a multiset of sets of formulas, and \u03c6, \u00b5 formulas (all possibly subscripted or primed). Then, \u2206 is an IC merging operator if it satisfies the following postulates.\n(IC0). \u2206\u00b5(\u03a8) \u22a2 \u00b5.\n(IC1). If \u00b5 6\u22a2 \u22a5 then \u2206\u00b5(\u03a8) 6\u22a2 \u22a5. (IC2). If \u2227 \u03a8 6\u22a2 \u00ac\u00b5 then \u2206\u00b5(\u03a8) \u2261 \u2227 \u03a8 \u2227 \u00b5.\n(IC3). If \u03a81 \u2261 \u03a82 and \u00b51 \u2261 \u00b52 then \u2206\u00b51(\u03a81) \u2261 \u2206\u00b52 (\u03a82). (IC4). If \u03c6 \u22a2 \u00b5 and \u03c6\u2032 \u22a2 \u00b5 then \u2206\u00b5(\u03c6 \u222a \u03c6\u2032) \u2227 \u03c6 6\u22a2 \u22a5 implies \u2206\u00b5(\u03c6 \u222a \u03c6\u2032) \u2227 \u03c6\u2032 6\u22a2 \u22a5.\n(IC5). \u2206\u00b5(\u03a81) \u2227\u2206\u00b5(\u03a82) \u22a2 \u2206\u00b5(\u03a81 \u222a\u03a82). (IC6). If \u2206\u00b5(\u03a81) \u2227\u2206\u00b5(\u03a82) 6\u22a2 \u22a5 then \u2206\u00b5(\u03a81 \u222a\u03a82) \u22a2 \u2206\u00b5(\u03a81) \u2227\u2206\u00b5(\u03a82). (IC7). \u2206\u00b51(\u03a8) \u2227 \u00b52 \u22a2 \u2206\u00b51\u2227\u00b52(\u03a8). (IC8). If \u2206\u00b51(\u03a8) \u2227 \u00b52 6\u22a2 \u22a5 then \u2206\u00b51\u2227\u00b52(\u03a8) \u22a2 \u2206\u00b51 (\u03a8) \u2227 \u00b52.\n(IC2) states that, when consistent, the result of merging is simply the conjunction of the belief bases and integrity constraints. (IC4) asserts that when two belief bases disagree, merging does not give preference to one of them. (IC5) states that a model of two mergings is in the union of their merging. With (IC5) we get that if two mergings are consistent\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nthen their merging is implied by their conjunction. Note that merging operators are trivially commutative. (IC7) and (IC8) correspond to the extended AGM postulates (K \u2217 7) and (K \u2217 8) for revision (cf. [Alchourro\u0301n et al. 1985; Ga\u0308rdenfors 1988]), but with respect to the integrity constraints."}, {"heading": "2.3 Belief Change in Logic Programming", "text": "Most previous work on belief change for logic programs goes under the title of update [Foo and Zhang 1997; Przymusinski and Turner 1997; Zhang and Foo 1998; Alferes et al. 1998; 2000; Leite 2003; Inoue and Sakama 1999; Eiter et al. 2002; Zacar\u0131\u0301as et al. 2005; Delgrande et al. 2007]. Strictly speaking, however, such approaches generally do not address \u201cupdate,\u201d at least insofar as the term is understood in the belief revision community. There, update refers to a belief change in response to a change in the world being modelled [Katsuno and Mendelzon 1992]; this notion of change is not taken into account in the abovecited work. A common feature of most update approaches is to consider a sequence P1, P2, . . . , Pn of programs where each Pi is a logic program. For Pi, Pj , and i > j, the intuition is that Pi has higher priority or precedence. Given such a sequence, a set of answer sets is determined that in some sense respects the ordering. This may be done by translating the sequence into a single logic program that contains an encoding of the priorities, or by treating the sequence as a prioritised logic program, or by some other appropriate method. The net result, one way or another, is to obtain a set of answer sets from such a program sequence, and not a single new program expressed in the language of the original logic programs. Hence, these approaches fall outside the general AGM belief revision paradigm.\nHowever, various principles have been proposed for such approaches to logic program update. In particular, Eiter et al. [2002] consider the question of what principles the update of logic programs should satisfy. This is done by re-interpreting different AGM-style postulates for revising or updating classic knowledge bases, as well as introducing new principles. Among the latter, let us note the following:"}, {"heading": "Initialisation. \u2205 \u2217 P \u2261 P .", "text": ""}, {"heading": "Idempotency. (P \u2217 P ) \u2261 P .", "text": "Tautology. If Q is tautologous, then P \u2217Q \u2261 P .\nAbsorption. If Q = R, then ((P \u2217Q) \u2217R) \u2261 (P \u2217Q).\nAugmentation. If Q \u2286 R, then ((P \u2217Q) \u2217R) \u2261 (P \u2217R).\nIn view of the failure of several of the discussed postulates in the approach of Eiter et al. [2002] (as well as in others), Osorio and Cuevas [2007] noted that for re-interpreting the standard AGM postulates in the context of logic programs, the logic underlying strong equivalence should be adopted. Since Osorio and Cuevas [2007] studied programs with strong negation, this led them to consider the logic N2, an extension of HT by allowing strong negation.3 They also introduced a new principle, which they called weak independence of syntax (WIS), which they proposed any update operator should satisfy:\nWIS. If Q \u2261s R, then (P \u2217Q) \u2261 (P \u2217R).\n3 N2 itself traces back to an extension of intuitionistic logic with strong negation, first studied by Nelson [1949].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nIndeed, following this spirit, the above absorption and augmentation principles can be accordingly changed by replacing their antecedents by \u201cQ \u2261s R\u201d and \u201cQ |=s R\u201d, respectively. We note that the WIS principle was also discussed in an update approach based on abductive programs [Zacar\u0131\u0301as et al. 2005].\nTurning our attention to the few works on revision of logic programs, early work in this direction includes a series of investigations dealing with restoring consistency for programs possessing no answer sets (cf., e.g., Witteveen et al. [1994]). Other work uses logic programs under a variant of the stable semantics to specify database revision, i.e., the revision of knowledge bases given as sets of atomic facts [Marek and Truszczyn\u0301ski 1998]. Finally, an approach following the spirit of AGM revision is discussed by Kudo and Murai [2004]. In their work, they deal with the question of constructing revisions of form P \u2217 A, where P is an extended logic program and A is a conjunction of literals. They give a procedural algorithm to construct the revised programs; however no properties are analysed.\nWith respect to merging logic programs, we have already mentioned updating logic programs, which can also be considered as prioritised logic program merging. With respect to combining logic programs, Baral et al. [1991] describe an algorithm for combining a set of normal, stratified logic programs in which the union of the programs is also stratified. In their approach the combination is carried out so that a set of global integrity constraints, which is satisfied by individual programs, is also satisfied by the combination. Buccafurri and Gottlob [2002] present an interesting approach whereby rules in a given program encode desires for a corresponding agent. A predicate okay indicates that an atom is acceptable to an agent. Answer sets of these compromise logic programs represent acceptable compromises between agents. While it is shown that the joint fixpoints of such logic programs can be computed as answer sets, and complexity results are presented, the approach is not analysed from the standpoint of properties of merging. Sakama and Inoue [2008] address what they call the generous and rigorous coordination of logic programs in which, given a pair of programs P1 and P2, a program Q is found whose answer sets are equal to the union of the answer sets of P1 and P2 in the first case, and their intersection in the second. As the authors note, this approach and its goals are distinct from program merging."}, {"heading": "3. BELIEF CHANGE IN ASP BASED ON SE MODELS", "text": "In AGM belief change, an agent\u2019s beliefs may be abstractly characterised in various different ways. In the classical AGM approach an agent\u2019s beliefs are given by a belief set, i.e., a deductively-closed set of sentences. As well, an agent\u2019s beliefs may also be characterised abstractly by a set of interpretations or possible worlds; these would correspond to models of the agent\u2019s beliefs. Last, as proposed in the Katsuno-Mendelzon formulation, and given the assumption of a finite language, an agent\u2019s beliefs can be specified by a formula. Given a finite language, it is straightforward to translate between these representations.\nIn ASP, there are notions analogous to the above for specifying an agent\u2019s beliefs. Though we do not get into it here, the notion of strong equivalence of logic programs can be employed to define a (logic program) belief set. Indeed, a set of well-defined SE models characterises a class of equivalent logic programs. Hence, the set of SE models of a program can be considered as the proposition expressed by the program. Continuing this analogy, a specific logic program can be considered to correspond to a formula or set of formulas in classical logic.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."}, {"heading": "3.1 Expanding Logic Programs", "text": "Belief expansion is a belief change operator that is much more basic than revision or contraction, and in a certain sense is prior to revision and contraction (since in the AGM approach revision and contraction postulates make reference to expansion). Hence, it is of interest to examine expansion from the point of view of logic programs. As well, it proves to be the case that expansion in logic programs is of interest in its own right.\nThe next definition corresponds model-theoretically with the usual definition of expansion in AGM belief change.\nDEFINITION 6. For logic programs P andQ, define the expansion of P andQ, P +Q, to be a logic program R such that SE (R) = SE (P ) \u2229 SE (Q).\nFor illustration, consider the following examples:4\n(1) {p\u2190}+ {\u22a5 \u2190 p} has no SE models.\n(2) {p\u2190 q}+ {\u22a5 \u2190 p} has SE model (\u2205, \u2205).\n(3) {p\u2190}+ {q \u2190 p} \u2261s {p\u2190}+ {q \u2190} \u2261s {p\u2190, q \u2190}.\n(4) {p\u2190 \u223cq}+ {q \u2190 \u223cp} \u2261s\n{\np\u2190 \u223cq q \u2190 \u223cp\n}\n.\n(5)\n{\np\u2190 \u223cq q \u2190 \u223cp\n}\n+ {p\u2190 q} \u2261s\n{\np\u2190 q p\u2190 \u223cq\n}\n.\n(6)\n{\np\u2190 \u223cq q \u2190 \u223cp\n}\n+ {p; q \u2190} \u2261s {p; q \u2190}.\n(7) {p; q \u2190}+ {\u22a5 \u2190 q} \u2261s\n{\np\u2190 \u22a5\u2190 q\n}\n.\n(8) {p; q \u2190}+ {\u22a5 \u2190 p, q} \u2261s\n{\np; q\u2190 \u22a5\u2190 p, q\n}\n.\nBelief expansion has desirable properties. The following all follow straightforwardly from the definition of expansion with respect to SE models.\nTHEOREM 1. Let P and Q be logic programs. Then:\n(1) P +Q is a logic program.\n(2) P +Q |=s P . (3) If P |=s Q, then P +Q \u2261s P . (4) If P |=s Q, then P +R |=s Q+R. (5) If SE (P ) and SE(Q) are well-defined, then so is SE(P +Q). (6) If SE (P ) and SE(Q) are complete, then so is SE (P +Q).\n(7) If Q \u2261s \u2205, then P +Q \u2261s P .\nWhile these results are indeed elementary, following as they do from the monotonicity of the SE interpretations framework, they are still of interest. Notably, virtually every previous approach to updating logic programs has trouble with the last property, expressing a tautology postulate. Here, expansion by a tautologous program presents no problem,\n4Unless otherwise noted, we assume that the language of discourse in each example consists of just the atoms mentioned.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nas it corresponds to an intersection with the set of all SE interpretations. We note also that the other principles mentioned earlier\u2014initialisation, idempotency, absorption, and augmentation\u2014are trivially satisfied by expansion.\nIn classical logic, the expansion of two formulas can be given in terms of the intersection of their models. It should be clear from the preceding that the appropriate notion of the set of \u201cmodels\u201d of a logic program is given by a set of SE models, and not by a set of answer sets. Hence, there is no natural notion of expansion that is given in terms of answer sets. For instance, in Example 3, we have AS({p \u2190}) = {{p}} and AS({q \u2190 p}) = {\u2205} while AS({p \u2190, q \u2190 p}) = {{p, q}}. Likewise, in Example 4, the intersection of AS ({{p \u2190 \u223cq}}) = {{p}} and AS ({{q \u2190 \u223cp}}) = {{q}} is empty, whereas AS({p\u2190 \u223cq, q \u2190 \u223cp}) = {{p}, {q}}."}, {"heading": "3.2 Revising Logic Programs", "text": "We next turn to specific operators for belief revision. As discussed earlier, for a revision P \u2217Q, we suggest that the most natural distance-based notion of revision for logic programs uses set containment as the appropriate means of relating SE interpretations. Hence, we begin by considering set-containment based revision. Thus, P \u2217Q will be a logic program whose SE models are a subset of the SE models of Q, comprising just those models of Q that are closest to those of P . Following the development of this operator we also consider cardinality-based revision, as a point of contrast. While these two approaches correspond to the two best-known ways of incorporating distance based revision, they are not exhaustive and any other reasonable notion of distance could also be employed.\n3.2.1 Set-Containment Based Revision. The following definition gives, for sets of interpretations E1, E2, the subset of E1 that is closest to E2, where the notion of \u201cclosest\u201d is given in terms of symmetric difference.\nDEFINITION 7. Let E1, E2 be two sets of either classical or SE interpretations. Then:\n\u03c3(E1, E2) = {A \u2208 E1 | \u2203B \u2208 E2 such that\n\u2200A\u2032 \u2208 E1, \u2200B\u2032 \u2208 E2, A\u2032 \u2296B\u2032 6\u2282 A\u2296B}.\nIt might seem that we could now define the SE models of P \u2217 Q to be given by \u03c3(SE (Q),SE (P )). However, for our revision operator to be meaningful, it must also produce a well-defined set of SE models. Unfortunately, Definition 7 does not preserve well-definedness. For an example, consider P = {\u22a5 \u2190 p} and Q = {p \u2190 \u223cp}. Then, SE (P ) = {(\u2205, \u2205)} and SE (Q) = {(\u2205, p), (p, p)}, and so \u03c3(SE (Q),SE (P )) = {(\u2205, p)}. However {(\u2205, p)} is not well-defined.\nThe problem is that for programs P and Q, there may be an SE model (X,Y ) of Q with X \u2282 Y such that (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) but (Y, Y ) 6\u2208 \u03c3(SE (Q),SE (P )). Hence, in defining P \u2217 Q in terms of \u03c3(SE (Q),SE (P )), we must elaborate the set \u03c3(SE (Q),SE (P )) in some fashion to obtain a well-defined set of SE models.\nIn view of this, our approach is based on the following idea to obtain a well-defined set of models of P \u2217Q based on the notion of distance given in \u03c3:\n(1) Determine the \u201cclosest\u201d models of Q to P of form (Y, Y ).\n(2) Determine the \u201cclosest\u201d models ofQ to P limited to models (X,Y ) ofQwhere (Y, Y ) was found in the first step.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThus, we give preference to potential answer sets, in the form of models (Y, Y ), and then to general models.\nDEFINITION 8. For logic programs P and Q, define the revision of P by Q, P \u2217Q, to be a logic program such that:\nif SE (P ) = \u2205, then SE (P \u2217Q) = SE (Q);\notherwise\nSE (P \u2217Q) = {(X,Y ) | Y \u2208 \u03c3(Mod (Q),Mod(P )), X \u2286 Y,\nand if X \u2282 Y then (X,Y ) \u2208 \u03c3(SE (Q),SE (P ))}.\nAs is apparent, SE (P \u2217 Q) is well-defined, and thus is representable through a canonical logic program. Furthermore, over classical models, the definition of revision reduces to that of containment-based revision in propositional logic [Satoh 1988]. As we show below, the result of revising P by Q is identical to that of expanding P by Q whenever P and Q possess common SE models. Hence, all previous examples of non-empty expansions are also valid program revisions. We have the following examples of revision that do not reduce to expansion.5\n(1) {p\u2190 \u223cp} \u2217 {\u22a5 \u2190 p} \u2261s {\u22a5 \u2190 p}. Over the language {p, q}, \u22a5 \u2190 p has SE models (\u2205, \u2205), (\u2205, q), and (q, q).\n(2)\n{\np\u2190 q\u2190\n}\n\u2217 {\u22a5 \u2190 q} \u2261s\n{\np\u2190 \u22a5\u2190 q\n}\n.\nThe first program has a single SE model, (pq, pq), while the second has three, (\u2205, \u2205), (\u2205, p), and (p, p). Among the latter, (p, p) has the least pairwise symmetric difference to (pq, pq). The program induced by the singleton set {(p, p)} of SE models is\n{p\u2190, \u22a5 \u2190 q}.\n(3)\n{\np\u2190 q\u2190\n}\n\u2217 {\u22a5 \u2190 p, q} \u2261s\n{\np; q\u2190 \u22a5\u2190 p, q\n}\n.\nThus, if one originally believes that p and q are true, and revises by the fact that one is false, then the result is that precisely one of p, q is true.\n(4)\n{\n\u22a5\u2190 \u223cp \u22a5\u2190 \u223cq\n}\n\u2217 {\u22a5 \u2190 p, q} \u2261s\n{\n\u22a5\u2190\u223cp,\u223cq \u22a5\u2190 p, q\n}\n.\nObserve that the classical models in the programs here are exactly the same as above. This example shows that the use of SE models provides finer \u201cgranularity\u201d compared to using classical models of programs together with known revision techniques.\n(5)\n{\n\u22a5\u2190 p \u22a5\u2190 q\n}\n\u2217 {p; q \u2190} \u2261s\n{\np; q\u2190 \u22a5\u2190 p, q\n}\n.\nWe next rephrase the Katsuno-Mendelzon postulates for belief revision. Here, \u2217 is a function from ordered pairs of logic programs to logic programs.\n(RA1). P \u2217Q |=s Q. (RA2). If P +Q is satisfiable, then P \u2217Q \u2261s P +Q.\n(RA3). If Q is satisfiable, then P \u2217Q is satisfiable.\n5Note that {p \u2190 \u223cp} has SE models but no answer sets.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(RA4). If P1 \u2261s P2 and Q1 \u2261s Q2, then P1 \u2217Q1 \u2261s P2 \u2217Q2. (RA5). (P \u2217Q) +R |=s P \u2217 (Q+R). (RA6). If (P \u2217Q) +R is satisfiable, then P \u2217 (Q+R) |=s (P \u2217Q) +R.\nWe obtain that logic program revision as given in Definition 8 satisfies the first five of the revision postulates. Unsurprisingly, this is analogous to set-containment based revision in propositional logic.\nTHEOREM 2. The logic program revision operator \u2217 from Definition 8 satisfies postulates (RA1)-(RA5).\nThe fact that our revision operator does not satisfy (RA6) can be seen by the following example: Consider\nP = {p;\u223cp, q \u2190 p, r \u2190 p, s\u2190 p, \u22a5 \u2190 \u223cp, q,\n\u22a5 \u2190 \u223cp, r, \u22a5 \u2190 \u223cp, s},\nQ = {p; r, \u22a5 \u2190 q, \u22a5 \u2190 p, r, \u22a5 \u2190 p, s, s;\u223cs\u2190 r},\nR = {p; r, \u22a5 \u2190 q, \u22a5 \u2190 p, r, \u22a5 \u2190 p, s, s\u2190 r}.\nStraightforward computations show that\nSE (P \u2217 (Q+R)) = {(rs, rs), (p, p)} while\nSE ((P \u2217Q) +R) = {(p, p)}.\nSo, P \u2217 (Q+R) 6|=s (P \u2217Q) + R. Since SE ((P \u2217Q) +R) 6= \u2205, this shows that (RA6) indeed fails.\nLast, we have the following result concerning other principles for updating logic programs listed earlier:\nTHEOREM 3. Let P and Q be logic programs. Then, P \u2217 Q satisfies initialisation, idempotency, tautology, and absorption with respect to strong equivalence.\nAugmentation, however, does not hold, nor would one expect it to hold in a distancebased approach. For example, consider the case where P , Q, and R are characterised by models SE (P ) = {(a, a), (ab, ab)}, SE (Q) = {(ab, ab), (ac, ac), (b, b)}, and SE (R) = {(ac, ac), (b, b)}. Thus SE (R) \u2286 SE (Q). We obtain that SE (P \u2217 Q) = SE (P + Q) = {(ab, ab)}, and thus SE ((P \u2217Q)\u2217R) = {(b, b)}. However, SE (P \u2217R) = {(ac, ac), (b, b)}, contradicting augmentation.\nDefinition 8 seems to be the most natural possibility for constructing a set-containment based revision operator. However, it is not the only such possibility. We next briefly discuss an alternative definition for revision. The idea here is that for the revision of P by Q, we select the closest models of Q to P , and then add interpretations to make the result well-defined.\nDEFINITION 9. For logic programs P andQ, define the weak revision of P by Q to be a logic program P \u2217w Q such that:\nif SE (P ) = \u2205, then SE (P \u2217w Q) = SE (Q);\notherwise\nSE(P \u2217w Q) = \u03c3(SE (Q),SE (P )) \u222a\n{(Y, Y ) | (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) for some X}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe drawback to this approach is that it introduces possibly irrelevant interpretations in order to obtain well-definedness. As well, Definition 8 appears to be the more natural. Consider the following example, which also serves to distinguish Definition 8 from Definition 9. Let\nP = {\u22a5 \u2190 p, \u22a5 \u2190 q, \u22a5 \u2190 r},\nQ = { r, p\u2190 q, p\u2190 \u223cq }.\nThen, we get the following SE models:\nSE (P ) = {(\u2205, \u2205)},\nSE (Q) = {(r, pqr), (pr, pr), (pr, pqr), (pqr, pqr)},\nand\nSE (P \u2217Q) = {(pr, pr)},\nSE (P \u2217w Q) = SE (Q) \\ {(pr, pqr)}.\nConsequently, P \u2217Q is given by the program {p, \u22a5 \u2190 q, r}. Thus, in this example, P \u2217Q gives the desired result, preserving the falsity of q from P , while incorporating the truth of r and p fromQ. This then reflects the assumption of minimal change to the program being revised, in this case P . P \u2217w Q on the other hand represents a very cautious approach to program revision.\nFinally, we have that our definition of revision is strictly stronger than the alternative given by \u2217w:\nTHEOREM 4. Let P and Q be programs. Then, P \u2217Q |=s P \u2217w Q.\nFor completeness, let us mention that enforcing well-definedness by simply determining the \u201cclosest\u201d models of Q to P of form (Y, Y ) is inadequate. For our motivating example, we would obtain SE ({p\u2190 \u223cp} \u2217 {\u22a5 \u2190 p}) = \u2205, violating the key postulate (RA3), that the result of revising by a satisfiable program results in a satisfiable revision.\n3.2.2 Cardinality-Based Revision. We next briefly recapitulate the previous development but in terms of cardinality-based revision. Define, for two sets E1, E2 of interpretations, the subset of E1 that is closest to E2, where the notion of \u201cclosest\u201d is now given in terms of cardinality:\nDEFINITION 10. LetE1,E2 be two sets of either classical or SE interpretations. Then:\n\u03c3||(E1, E2) = {A \u2208 E1 | \u2203B \u2208 E2 such that\n\u2200A\u2032 \u2208 E1, \u2200B\u2032 \u2208 E2, |A\u2032 \u2296B\u2032| 6< |A\u2296B|}.\nAs with set containment-based revision, we must ensure that our operator results in a well-defined set of SE models. Again, we first give preference to potential answer sets, in the form of models (Y, Y ), and then to general models.\nDEFINITION 11. For logic programs P and Q, define the (cardinality-based) revision of P by Q, P \u2217c Q, to be a logic program such that:\nif SE (P ) = \u2205, then SE (P \u2217c Q) = SE (Q);\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\notherwise\nSE (P \u2217c Q) = {(X,Y ) | Y \u2208 \u03c3||(Mod(Q),Mod(P )), X \u2286 Y,\nand if X \u2282 Y then (X,Y ) \u2208 \u03c3||(SE (Q),SE (P ))}.\nP \u2217cQ can be seen to be well-defined, and so can be represented through a canonical logic program. As well, over classical, propositional models the definition reduces to cardinalitybased revision in propositional logic [Dalal 1988].\nWe observe from the respective definitions that\nSE (P \u2217c Q) \u2286 SE (P \u2217Q).\nThat the two revision operators differ is easily shown: For example, if\nP =\n\n\n p \u2190 q \u2190 r \u2190\n\n\n\nand Q =\n\n\n p ; q \u2190 r \u2190 q \u2190 p, r\n\n\n\nwe get SE (P ) = {(pqr, pqr)} and SE (Q) = {(p, p), (qr, qr)}. This yields SE (P \u2217Q) = {(p, p), (qr, qr)} while SE (P \u2217c Q) = {(qr, qr)}.\nIt can be observed that P \u2217c Q yields the same results as P \u2217 Q for the five examples given in the previous subsection. However, cardinality-based revision fully aligns with the AGM postulates:\nTHEOREM 5. Let P andQ be logic programs. Then, P \u2217cQ satisfies postulates (RA1) \u2013 (RA6).\nAs well, the following result is straightforward:\nTHEOREM 6. Let P and Q be logic programs. Then, P \u2217c Q satisfies initialisation, idempotency, tautology, and absorption with respect to strong equivalence.\n3.2.3 Remarks. Both of our proposed approaches to revising logic programs are based on a notion of distance between SE models. In the first, a partial preorder was induced between SE models, while in the second a total preorder resulted. We note that any definition of distance that results in a partial (resp., total) preorder among SE models could have been used, with the same technical results obtaining (but not, of course, the same examples). Hence, these approaches are exemplars of the two most common types of revision, expressed in terms of differences among truth values of atoms in models. As such, our specific approaches can be seen as natural generalisations of the approaches of Satoh [1988] and Dalal [1988].\nWe have suggested earlier that the approach based on set containment is the more natural or plausible approach, even though it does not satisfy all of the AGM postulates. This is because the cardinality-based approach may make somewhat arbitrary distinctions in arriving at a total preorder over SE interpretations. Recall the example we used to illustrate the difference between the approaches:\nSE (P ) = {(pqr, pqr)} and SE (Q) = {(p, p), (qr, qr)},\nyielding\nSE (P \u2217Q) = {(p, p), (qr, qr)} and SE (P \u2217c Q) = {(qr, qr)}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nGiven that we have no information concerning the ontological import of the atoms involved, it seems somewhat arbitrary to decide (in the case of \u2217c) that qr should take priority over p. As an alternative argument, consider where for some large n we have\nSE (P ) = {(p1 . . . p2n, p1 . . . p2n)} and SE (Q) = {(p1 . . . pn+1, p1 . . . pn+1), (p1 . . . pn, p1 . . . pn)}.\nSo, in this example it is quite arbitrary to select (as the cardinality-based approach does) (p1 . . . pn+1, p1 . . . pn+1) over (p1 . . . pn, p1 . . . pn).\nLet us finally remark that another plausible definition of an ordering underlying cardinality-based revision would be the following:\n|(X1, X2)| \u2264\u2032 |(Y1, Y2)| iff |X1| \u2264 |Y1| and |X2| \u2264 |Y2|.\nHowever, this ordering yields a partial preorder, and a revision operator based on this notion of distance would be very similar to P \u2217Q; in particular the postulate (RA6) would not be satisfied. Since this operator is of at best marginal interest, we do not explore it further."}, {"heading": "3.3 Complexity of Revision", "text": "We now turn to the complexity of our approach to revision. First, we recapitulate the complexity classes relevant in what follows. As usual, for any complexity class C, by co-C we understand the class of all problems which are complementary to the problems in C. Furthermore, for C as before and complexity class A, the notation CA stands for the relativised version of C, consisting of all problems which can be decided by Turing machines of the same sort and time bound as in C, only that the machines have access to an oracle for problems in A.\nFour complexity classes are relevant here, viz. NP, \u03a3P2 , \u03a0 P 2 , and \u0398 P 2 , which are defined\nthus:\n\u2014NP consists of all decision problems which can be solved with a nondeterministic Turing machine working in polynomial time; \u2014\u03a3P2 = NP NP; \u2014\u03a0P2 = co-\u03a3 P 2 ; and \u2014\u0398P2 is the class of all problems solvable on a deterministic Turing machine in polynomial time asking on input x a total of O(log |x|) many oracle calls to NP (thus, \u0398P2 is also denoted by PNP[logn]).\nObserve that NP, \u03a3P2 , and \u03a0 P 2 are part of the polynomial hierarchy, which is given by\nthe following sequence of objects: the initial elements are\n\u2206P0 = \u03a3 P 0 = \u03a0 P 0 = P;\nand, for i > 0,\n\u2206Pi = P \u03a3P i\u22121 ; \u03a3Pi = NP \u03a3P i\u22121 ; \u03a0Pi = co-NP \u03a3P i\u22121 .\nHere, P is the class of all problems solvable on a deterministic Turing machine in polynomial time. It holds that \u03a3P1 = NP, \u03a3 P 2 = NP NP, and \u03a0P2 = co-NP NP. A problem is said to be at the k-th level of the polynomial hierarchy iff it is in \u2206Pk+1 and either \u03a3 P k -hard or \u03a0Pk -hard.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nWe first consider the worst-case complexity of our approach to set-containment based revision. The standard decision problem for revision in classical logic is:\nGiven formulas P , Q, and R, does P \u2217Q entail R?\nEiter and Gottlob [1992] showed that approaches to classical propositional revision are \u03a0P2 -complete. The next result shows that this property carries over to our approach for program revision.\nTHEOREM 7. Deciding whether P \u2217 Q |=s R holds, for given GLPs P , Q, and R, is \u03a0P2 -complete. Moreover, hardness holds already for P being a set of facts, Q being positive or normal, and R being a single fact.\nAlthough we do not show it here, we mention that the same results holds for the cautious revision operator \u2217w as well.\nFor cardinality-based revision, we obtain the following result, again mirroring a similar behaviour for the classical case and being a consequence of the construction given in Section 5:\nTHEOREM 8. Deciding whether P \u2217c Q |=s R holds, for given GLPs P , Q, and R, is in \u0398P2 ."}, {"heading": "4. MERGING LOGIC PROGRAMS", "text": "We denote (generalised) logic programs by P1, P2, . . . , reserving P0 for a program representing global constraints, as described later. For logic programs P1, P2, we define P1 \u2293 P2 to be a program with SE models equal to SE (P1) \u2229 SE (P2) and P1 \u2294 P2 to be a program with SE models equal to SE (P1) \u222a SE (P2). By a belief profile, \u03a8, we understand a sequence6 \u3008P1, . . . , Pn\u3009 of (generalised) logic programs. For \u03a8 = \u3008P1, . . . , Pn\u3009 we write \u2293\u03a8 for P1 \u2293 \u00b7 \u00b7 \u00b7 \u2293 Pn. We write \u03a81 \u25e6 \u03a82 for the (sequence) concatenation of belief profiles \u03a81, \u03a82; and for logic program P0 and \u03a8 = \u3008P1, . . . , Pn\u3009 we abuse notation by writing \u3008P0,\u03a8\u3009 for \u3008P0, P1, . . . , Pn\u3009. A belief profile \u03a8 is satisfiable just if each component logic program is satisfiable. The set of SE models of \u03a8 is given by SE (\u03a8) = SE (P1)\u00d7 \u00b7 \u00b7 \u00b7 \u00d7 SE (Pn). For S \u2208 SE (\u03a8) such that S = \u3008S1, . . . , Sn\u3009, we use Si to denote the ith component of S. Thus, Si \u2208 SE (Pi). Analogously, the set of classical propositional models of \u03a8 is given by Mod(\u03a8) = Mod(P1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Mod(Pn); also we use Xi to denote the ith component of X \u2208 Mod(\u03a8)."}, {"heading": "4.1 Arbitration Merging", "text": "For the first approach to merging, called arbitration, we consider models of \u03a8 and select those models in which, in a global sense, the constituent models vary minimally. The result of arbitration is a logic program made up of SE models from each of these minimallyvarying tuples. Note that, in particular, if a set of programs is jointly consistent, then there are models of \u03a8 in which all constituent SE models are the same. That is, the models that vary minimally are those S \u2208 SE (\u03a8) in which Si = Sj for every 1 \u2264 i, j \u2264 n; and merging is the same as simply taking the union of the programs.\nThe first definition provides a notion of distance between models of \u03a8, while the second then defines merging in terms of this distance.\n6This departs from usual practise, where a belief profile is usually taken to be a multiset.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nDEFINITION 12. Let \u03a8 = \u3008P1, . . . , Pn\u3009 be a satisfiable belief profile and let S, T be two SE models of \u03a8 (or two classical models of \u03a8).\nThen, define S \u2264a T , if Si \u2296 Sj \u2286 Ti \u2296 Tj for every 1 \u2264 i < j \u2264 n.\nClearly, \u2264a is a partial preorder. In what follows, let Mina(N) denote the set of all minimal elements of a set N of tuples relative to \u2264a, i.e.,\nMina(N) = {S \u2208 N | T \u2264a S implies S \u2264a T for all T \u2208 N} .\nPreparatory for our central definition to arbitration merging, we furthermore define, for a set N of n-tuples,\n\u222aN = {Si | for S \u2208 N,S = \u3008S1, . . . , Sn\u3009 and i \u2208 {1, . . . , n}}.\nDEFINITION 13. Let \u03a8 = \u3008P1, . . . , Pn\u3009 be a belief profile. Then, the arbitration merging, or simply arbitration, of \u03a8, is a logic program \u2207(\u03a8) such that\nSE (\u2207(\u03a8)) = {(X,Y ) | Y \u2208 \u222aMina(Mod(\u03a8)), X \u2286 Y,\nand if X \u2282 Y then (X,Y ) \u2208 \u222aMina(SE (\u03a8))} ,\nproviding \u03a8 is satisfiable, otherwise, if Pi is unsatisfiable for some 1 \u2264 i \u2264 n, define \u2207(\u03a8) = \u2207(\u3008P1, . . . , Pi\u22121, Pi+1, . . . , Pn\u3009).\nFor illustration, consider the belief profile\n\u3008P1, P2\u3009 = \u3008{p\u2190 , u\u2190}, {\u2190 p , v \u2190}\u3009 . (2)\nSince SE (P1) = {(pu, pu), (pu, puv), (puv, puv)} and SE (P2) = {(v, v), (v, uv), (uv, uv)}, we obtain nine SE models for SE (\u3008P1, P2\u3009). Among them, we find a unique \u2264a-minimal one, yielding Mina(SE (\u3008P1, P2\u3009)) = {\u3008(puv, puv), (uv, uv)\u3009}. Similarly, \u3008P1, P2\u3009 has a single \u2264a-minimal collection of pairs of classical models, viz. Mina(Mod(\u3008P1, P2\u3009)) = {\u3008puv, uv\u3009}. Accordingly, we get\n\u222aMina(Mod(\u3008P1, P2\u3009)) = {puv, uv},\n\u222aMina(SE (\u3008P1, P2\u3009)) = {(puv, puv), (uv, uv)}, and\nSE (\u2207((P1, P2))) = \u222aMina(SE (\u3008P1, P2\u3009)) .\nWe thus obtain the program \u2207(\u3008P1, P2\u3009) = {p;\u223cp \u2190 , u \u2190 , v \u2190} as the resultant arbitration of P1 and P2.\nFor further illustration, consider the technical examples given in Table I. We note that merging normal programs often leads to disjunctive or generalised programs. Although plausible, this is also unavoidable because merging does not preserve the model intersection property of the reduced program satisfied by normal programs.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nMoreover, we have the following general result.\nTHEOREM 9. Let \u03a8 = \u3008P1, P2\u3009 be a belief profile, and define P1 \u22c4 P2 = \u2207(\u03a8). Then, \u22c4 satisfies the following versions of the postulates of Definition 4.\n(LS1\u2032). P1 \u22c4 P2 \u2261s P2 \u22c4 P1. (LS2\u2032). P1 \u2293 P2 |=s P1 \u22c4 P2. (LS3\u2032). If P1 \u2293 P2 is satisfiable then P1 \u22c4 P2 |=s P1 \u2293 P2. (LS4\u2032). P1 \u22c4 P2 is satisfiable iff P1 is satisfiable and P2 is satisfiable. (LS5\u2032). If P1 \u2261s P2 and P \u20321 \u2261s P \u2032 2 then P1 \u22c4 P2 \u2261s P \u2032 1 \u22c4 P \u2032 2. (LS7\u2032). P1 \u22c4 P2 |=s P1 \u2294 P2. (LS8\u2032). If P1 and P2 are satisfiable then P1 \u2293 (P1 \u22c4 P2) is satisfiable."}, {"heading": "4.2 Basic Merging", "text": "For the second approach to merging, programs P1, . . . , Pn are merged with a target logic program P0 so that the SE models in the merging will be drawn from models of P0. This operator will be referred to as the (basic) merging of P1, . . . , Pn with respect to P0. The information in P0 must hold in the merging, and so can be taken as necessarily holding. Konieczny and Pino Pe\u0301rez [2002] call P0 a set of integrity constraints, though this usage of the term differs from its usage in logic programs. Note that in the case where SE (P0) is the set of all SE models, the two approaches (of this section and the previous section) do not coincide, and that merging is generally a weaker operator than arbitration.\nDEFINITION 14. Let \u03a8 = \u3008P0, . . . , Pn\u3009 be a belief profile and let S, T be two SE models of \u03a8 (or two classical models of \u03a8)."}, {"heading": "Then, define S \u2264b T , if S0 \u2296 Sj \u2286 T0 \u2296 Tj for every 1 \u2264 j \u2264 n.", "text": "As in the case of arbitration merging,\u2264b is a partial preorder. Accordingly, let Minb(N) be the set of all minimal elements of a setN of tuples relative to \u2264b. In extending our notation for referring to components of tuples, we furthermore define N0 = {S0 | S \u2208 N}. We thus can state our definition for basic merging as follows:\nDEFINITION 15. Let \u03a8 = \u3008P1, . . . , Pn\u3009 be a belief profile. Then, the basic merging, or simply merging, of \u03a8, is a logic program \u2206(\u03a8) such that\nSE (\u2206(\u03a8)) = {(X,Y ) | Y \u2208 Minb(Mod(\u03a8))0, X \u2286 Y, and if X \u2282 Y then (X,Y ) \u2208 Minb(SE (\u03a8))0} ,\nproviding \u03a8 is satisfiable, otherwise, if Pi is unsatisfiable for some 1 \u2264 i \u2264 n, define \u2206(\u03a8) = \u2206(\u3008P0, . . . , Pi\u22121, Pi+1, . . . , Pn\u3009).\nLet us reconsider Programs P1 and P2 from (2) in the context of basic merging. To this end, we consider the belief profile \u3008\u2205, {p \u2190 , u \u2190}, {\u2190 p , v \u2190}\u3009. We are now faced with 27 SE models for SE (\u3008\u2205, P1, P2\u3009). Among them, we get the following \u2264b-minimal SE models\nMinb(SE (\u3008\u2205, P1, P2\u3009)) = {\u3008(uv, uv), (puv, puv), (uv, uv)\u3009,\n\u3008(uv, puv), (puv, puv), (uv, uv)\u3009, \u3008(puv, puv), (puv, puv), (uv, uv)\u3009}\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nalong with Minb(Mod(\u3008\u2205, P1, P2\u3009)) = {\u3008uv, puv, uv\u3009, \u3008puv, puv, uv\u3009}. We get:\nMinb(Mod(\u3008\u2205, P1, P2\u3009))0 = {puv, uv},\nMinb(SE (\u3008\u2205, P1, P2\u3009))0 = {(uv, uv), (uv, puv), (puv, puv)}, and\nSE (\u2206(\u3008\u2205, P1, P2\u3009)) = Minb(SE (\u3008\u2205, P1, P2\u3009))0 .\nWhile arbitration resulted in \u2207(\u3008P1, P2\u3009) = {p;\u223cp \u2190 , u \u2190 , v \u2190}, the more conservative approach of basic merging yields \u2206(\u3008\u2205, P1, P2\u3009) = {u\u2190 , v \u2190}.\nWe have just seen that basic merging adds \u201cintermediate\u201d SE models, viz. (uv, puv), to the ones obtained in arbitration merging. This can also be observed on the examples given in Table I, where every second merging is weakened by the addition of such intermediate SE models. This is made precise in Theorem 11 below. We summarise the results in Table II but omit the programs \u2206(\u3008\u2205, P1, P2\u3009) because they are obtained from \u2207(\u3008P1, P2\u3009) in Table I by simply dropping all rules of form p;\u223cp\u2190 and q;\u223cq \u2190, respectively.\nThe next example further illustrates the difference between arbitration and basic merging. Take P1 = {p \u2190 , q \u2190} and P2 = {\u223cp \u2190 ,\u223cq \u2190}. Then, we have that SE (\u2207(\u3008P1, P2\u3009)) = {(pq, pq), (\u2205, \u2205)} and SE (\u2206(\u3008\u2205, P1, P2\u3009)) = SE (\u2205). That is, in terms of programs, we obtain\n\u2207(\u3008P1, P2\u3009) = {p;\u223cp\u2190, q;\u223cq \u2190, \u2190 p,\u223cq, \u2190 \u223cp, q} and \u2206(\u3008\u2205, P1, P2\u3009) = \u2205 .\nTHEOREM 10. Let \u03a8 be a belief profile, P0 a program representing global constraints, and \u2206 as given in Definition 15. Then, \u2206 satisfies the following versions of the postulates of Definition 5:\n(IC0\u2032). \u2206(\u3008P0,\u03a8\u3009) |=s P0. (IC1\u2032). If P0 and \u03a8 are satisfiable then \u2206(\u3008P0,\u03a8\u3009) is satisfiable. (IC2\u2032). If \u2293(P0,\u03a8) is satisfiable then \u2206(\u3008P0,\u03a8\u3009) \u2261s P0 \u2293 (\u2293(\u03a8)). (IC3\u2032). If P0 \u2261s P \u20320 and \u03a8 \u2261s \u03a8 \u2032 then \u2206(\u3008P0,\u03a8\u3009) \u2261s \u2206(\u3008P \u20320,\u03a8 \u2032\u3009). (IC4\u2032). If P1 |=s P0 and P2 |=s P0 then: if \u2206(\u3008P0, P1, P2\u3009) \u2293 P1 is satisfiable, then \u2206(\u3008P0, P1, P2\u3009) \u2293 P2 is satisfiable. (IC5\u2032). \u2206(\u3008P0,\u03a8\u3009) \u2293\u2206(\u3008P0,\u03a8\u2032\u3009) |=s \u2206(\u3008P0,\u03a8 \u25e6\u03a8\u2032\u3009). (IC7\u2032). \u2206(\u3008P0,\u03a8\u3009) \u2293 P1 |=s \u2206(\u3008P0 \u2293 P1,\u03a8\u3009). (IC9\u2032). Let \u03a8\u2032 be a permutation of \u03a8. Then, \u2206(\u3008P0,\u03a8\u3009) \u2261s \u2206(\u3008P0,\u03a8\u2032\u3009).\nWe also obtain that arbitration merging is stronger than (basic) merging in the case of tautologous constraints in P0.\nTHEOREM 11. Let \u03a8 be a belief profile. Then \u2207(\u03a8) |=s \u2206(\u3008\u2205,\u03a8\u3009).\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nAs well, for belief profile \u03a8 = \u3008P1, P2\u3009, we can express our merging operators in terms of the revision operator defined in Section 3.2.\nTHEOREM 12. Let \u3008P1, P2\u3009 be a belief profile.\n(1) \u2207(\u3008P1, P2\u3009) = (P1 \u2217 P2) \u2294 (P2 \u2217 P1).\n(2) \u2206(\u3008P1, P2\u3009) = P2 \u2217 P1.\nNote that in the second part of the preceding result, P1 is regarded as a set of constraints (usually with name P0) according to our convention for basic merging."}, {"heading": "4.3 Complexity Analysis", "text": "In the previous section, the following decision problem was studied with respect to the revision operator \u2217: Given GLPs P , Q, R, does P \u2217 Q |=s R hold? This problem was shown to be \u03a0P2 -complete. Accordingly, we give here results for the following problems:\n(1) Given a belief profile \u03a8 and a programR, does \u2207(\u03a8) |=s R hold?\n(2) Given a belief profile \u03a8 and a programR, does \u2206(\u03a8) |=s R hold?\nBy Theorem 12, it can be shown that the hardness result for the revision problem also applies to the respective problems in terms of merging. On the other hand,\u03a0P2 -membership can be obtained by a slight extension of the encodings given in the next section such that these extensions possess an answer set iff the respective problem (1) or (2) does not hold. Since checking whether a program has at least one answer set is a problem on the second of layer of the polynomial hierarchy, and our (extended) encodings are polynomial in the size of the encoded problems, the desired membership results follow.\nTHEOREM 13. Given a belief profile \u03a8 and a programR, deciding\u2207(\u03a8) |=s R (resp., \u2206(\u03a8) |=s R) is \u03a0P2 -complete."}, {"heading": "5. COMPUTING BELIEF CHANGE VIA ANSWER SET PROGRAMMING", "text": "In this section, we provide encodings for our belief change operators in terms of fixed nonground ASP programs. We recall that non-ground programs are defined over predicates of arbitrary arity which have either variables or constants as arguments. Such non-ground programs can be seen as a compact representation of large programs without variables (and thus as propositional programs), by considering the grounding of a program (recall that the grounding of a program P is given by the union of the groundings of its rules, and the grounding of a rule r \u2208 P is the set obtained by all possible substitutions of variables in r by constants occurring in P ; cf. Dantsin et al. [2001] for a more thorough exposition). The non-ground programs we define in this section can be seen as queries which take the (propositional) programs subject to revision or merging as an input database. Thus, we follow here the tradition of meta-programming (see, e.g., the works of Delgrande et al. [2003], Eiter et al. [2003], and Gebser et al. [2008]).\nOur encodings are given via certain language fragments of non-ground ASP such that their respective data complexity matches the complexity of the encoded task. Recall that data complexity addresses problems over programsP \u222aD where a non-ground program P is fixed, while the input databaseD (a set of ground atoms) is the input of the decision problem. As is well known, the data complexity of the problem whether a is contained in all answer sets of P \u222aD is \u03a0P2 -complete for disjunctive programs (without weak constraints)\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n[Dantsin et al. 2001] and \u0398P2 -complete for normal programs with certain optimisation constructs (for instance, weak constraints over a single level; we introduce weak constraints later) [Buccafurri et al. 2000]. We use weak constraints for the encoding of the cardinalitybased revision operator (although similar optimisation constructs could be used likewise) while for the set-based revision operator and the merging operators we require disjunctive programs. However, instead of coming up with encodings for the decisions problems discussed in the previous section, our ultimate goal here is to provide programs such that their answer sets characterise the SE models of the result of the encoded revision or merging problem.\nBefore we start with the ASP encodings, we have to fix how the programs subject to revision and merging are represented in our approach. To have a uniform setting in what follows, we use belief profiles \u03a8 = \u3008P\u03b1, . . . , Pn\u3009 where, for revision problems we have \u03b1 = 1 and n = 2 (and so \u3008P1, P2\u3009 here represents revision problemP1\u2217P2), for arbitration problems \u03b1 = 1 and n \u2265 2, and for basic merging, we use \u03b1 = 0 and n \u2265 2.\nGiven such a belief profile \u03a8 = \u3008P\u03b1, . . . , Pn\u3009, we use four ternary predicates, phead , nhead , pbody , and nbody to represent \u03a8. For each predicate, the first argument i indices the program (i.e., i is a number between \u03b1 and n), the second argument contains the rule identifier #r of a rule r \u2208 Pi, and the third argument is an atom, indicating that this atom occurs in the positive or negative head or the positive or negative body of rule r \u2208 Pi, respectively. For example, let \u03a8 = \u3008P1, P2\u3009 with P1 = {\u2190 \u223cp, \u2190 \u223cq} and P2 = {p; q \u2190, \u2190 p, q}. We obtain the relational representation of \u03a8 by7\n[\u03a8] = {nbody(1, 1, p), nbody(1, 2, q),\nphead(2, 1, p), phead(2, 1, q), pbody(2, 2, p), pbody(2, 2, q)}.\nHere, we just use numbers as rule identifiers, i.e. #(\u2190 \u223cp) = #(p; q \u2190) = 1 and #(\u2190 \u223cq) = #(\u2190 p, q) = 2. The only necessary requirement is that different rules are assigned to different identifiers, i.e., r 6= r\u2032 implies #r 6= #r\u2032.\nIn general, we define the relational representation of a belief profile as follows.\nDEFINITION 16. Let \u03a8 = \u3008P\u03b1, . . . , Pn\u3009 be a belief profile. Then, the relational representation of \u03a8 is given by\n[\u03a8] = n \u22c3\ni=\u03b1\n\u22c3\nr\u2208Pi\n(\n{phead(i,#r, a) | a \u2208 H(r)+} \u222a {nhead(i,#r, a) | a \u2208 H(r)\u2212} \u222a\n{pbody(i,#r, a) | a \u2208 B(r)+} \u222a {nbody(i,#r, a) | a \u2208 B(r)\u2212} ) .\nWe assume here that all i and #r are given as numbers. Note that some ASP solvers then require to define the domain of integers (for instance, via #maxint in the solver DLV [Leone et al. 2006]). Following datalog notation, we write, for a program \u03a0 and a belief profile \u03a8, \u03a0[\u03a8] instead of \u03a0 \u222a [\u03a8].\nWe provide our encodings in a modular way. That is, we introduce various sets of rules which implement different aspects required to solve the respective problem. We start with some basic modules, which are used in most of the encodings. Then, we provide our results for revision and conclude with the encodings for merging.\n7Since we have here rules which are all simple facts, we omit the \u201c\u2190\u201d-symbol for rules.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."}, {"heading": "5.1 Basic Modules", "text": "We start with a simple fragment which contains some domain predicates and fixes some designated identifiers.\nDEFINITION 17.\n\u03c0domain = {prog rule(P,R) \u2190 \u03b1(P,R,A), dom(A) \u2190 \u03b1(P,R,A) |\n\u03b1 \u2208 {phead , pbody ,nhead ,nbody} } \u222a\n{prog(P ) \u2190 prog rule(P,R),\nmodel(c) \u2190, model (t) \u2190, model (h) \u2190,\nprog model(c) \u2190, prog model (t) \u2190, prog model(h) \u2190}.\nPredicates prog rule(\u00b7, \u00b7), dom(\u00b7), and prog(\u00b7) are just used to gather some information from a conjoined input [\u03a8]; the designated constants c, t, h are used later on to distinguish between different guesses for models. In fact, c refers to classical models while h and t refer to the first and second part of SE models, respectively.\nThe following code guesses such models for each programP in the belief profile \u03a8. The guess is accomplished in Rules (3) and (4) below which assign each atom A in the domain to be in(\u00b7) or out(\u00b7).\nDEFINITION 18.\n\u03c0models = {in(P,A,M) \u2190 \u223cout(P,A,M), prog(P ), dom(A),model (M), (3)\nout(P,A,M) \u2190 \u223cin(P,A,M), prog(P ), dom(A),model (M), (4)\n\u2190 in(P,A, h), out(P,A, t), (5)\ndiff (P,Q,A,M) \u2190 in(P,A,M), out(Q,A,M), (6)\ndiff (P,Q,A,M) \u2190 out(P,A,M), in(Q,A,M), (7)\nsame(P,Q,A,M) \u2190 in(P,A,M), in(Q,A,M), (8)\nsame(P,Q,A,M) \u2190 out(P,A,M), out(Q,A,M), (9)\nok(P,R,M) \u2190 in(P,A,M), phead (P,R,A),model (M), (10)\nok(P,R,M) \u2190 out(P,A,M), pbody(P,R,A),model (M), (11)\nok(P,R,M) \u2190 in(P,A,M),nbody(P,R,A), prog model (M), (12)\nok(P,R,M) \u2190 out(P,A,M),nhead(P,R,A), prog model(M), (13)\nok(P,R, h) \u2190 in(P,A, t),nbody(P,R,A), (14)\nok(P,R, h) \u2190 out(P,A, t),nhead (P,R,A), (15)\n\u2190 \u223cok (P,R,M), prog rule(P,R),model (M)}. (16)\nThis allows us to draw a one-to-one correspondence between answer sets S and models (resp., SE models) of the programs Pi in the belief profile. Note that Rule (5) excludes such guesses where the corresponding SE model (X,Y ) would not satisfy X \u2286 Y . To make this intuition a bit more precise, let us define the following operator for a set S of ground atoms and a number i:\n\u03a0iMod(S) = {a | in(i, a, c) \u2208 S};\n\u03a0iSE (S) = ( {a | in(i, a, h) \u2208 S}, {b | in(i, b, t) \u2208 S} ) .\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe next Rules (6) \u2013 (9) indicate whether atom A is assigned differently (via predicate diff (\u00b7, \u00b7, \u00b7, \u00b7)) or equally (via predicate same(\u00b7, \u00b7, \u00b7, \u00b7)) for two programs. These predicates are useful later.\nThe remaining Rules (10) \u2013 (15) tell us which rules (in which programs) are satisfied by the respective guess. Observe that (10) and (11) are applied to any forms of models (i.e., h, t, and c) while (12) and (13) are only applied to t and c. Rules (14) and (15) finally take care of the fact that the first argument of an SE model has to be a model of the reduct. Therefore, we check whether the model given by the t-guess already eliminates rules. Note that such rules are satisfied by the h-guess in a trivial way. The last Rule (16) finally ensures that all rules of all programs are satisfied by our guesses.\nWe observe that the answer sets of the program P [\u03a8] where P = \u03c0domain \u222a\u03c0models are in a one-to-one correspondence to the models and SE models of belief profile \u03a8. Formally we have that, given \u03a8 = \u3008P\u03b1, . . . , Pn\u3009,\n{(M,N) |M \u2208 Mod(\u03a8), N \u2208 SE (\u03a8)} =\n{(\u3008\u03a0\u03b1Mod(S), . . . ,\u03a0 n Mod(S)\u3009, \u3008\u03a0 \u03b1 SE (S), . . . ,\u03a0 n SE (S)\u3009) | S \u2208 AS (P [\u03a8])}.\nWe define one further module, which just orders the domain elements (i.e., the atoms in the given belief profile) using the standard ordering < provided by the employed ASP solver. In particular, we define infimum, supremum, and successor with respect to this order. This is a standard technique used quite frequently in ASP; we require this later in order to \u201cloop\u201d over the domain elements. We also note that we could add such rules also for the program indices, as well as for the rule identifiers. However, since we assume them to be given by successive numbers, we omit such rules here. In fact, we use N = M + 1 instead of a designated successor predicate for program indices and rule identifiers. We add only rules which provide the minimal number \u03b1 and resp. the maximal number n of programs in the given profile \u03a8 = \u3008P\u03b1, . . . , Pn\u3009. The module thus looks as follows:\nDEFINITION 19.\n\u03c0order = {lt(X,Y ) \u2190 dom(X), dom(Y ), X < Y,\nnsucc(X,Z) \u2190 lt(X,Y ), lt(Y, Z),\nsucc(X,Y ) \u2190 lt(X,Y ),\u223cnsucc(X,Y ),\nninf (X) \u2190 lt(Y,X),\nnsup(X) \u2190 lt(X,Y ),\ninf (X) \u2190 \u223cninf (X), dom(X),\nsup(X) \u2190 \u223cnsup(X), dom(X),\nminprog(P ) \u2190 prog(P ), P = Q+ 1,\u223cprog(Q),\nmaxprog(P ) \u2190 prog(P ), Q = P + 1,\u223cprog(Q)}."}, {"heading": "5.2 Encodings for Revision", "text": "5.2.1 Cardinality-based Revision. We are now prepared to encode the cardinalitybased revision, following Definition 11. For our forthcoming encoding, we require optimisation constructs which are available in most ASP solvers. We shall use here the concept of weak constraints [Buccafurri et al. 2000] as used by DLV. A weak constraint (without\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nweights and levels) is a rule of the form\n\u21d0 c1, . . . , cm,\u223cdm+1, . . . ,\u223cdp. (17)\nThe semantics of a program P with such weak constraints is as follows: First, compute the answer sets of the program P \u2032 given as P without the weak constraints. Then, count for each answer set S of P the number of the grounded weak constraints which apply to S. By \u201capply to S\u201d, we mean that given a ground weak constraint of the form (17) {c1, . . . , cm} \u2286 S and {dm+1, . . . , dp} \u2229 S jointly hold. The answer sets of P are then given by those answer sets P \u2032 which have a minimal number of applied weak constraints.\nRecall that for representing revision problems, we use belief profiles of the form \u3008P1, P2\u3009. We already have computed all models and SE models of both programs. We now have to (i) find those pairs (M1,M2) of models M1 \u2208 Mod(P1), M2 \u2208 Mod(P2) which have a minimum number of differences, and (ii) find those pairs (S1, S2) of SE models S1 \u2208 Mod(S1), S2 \u2208 Mod(P2) which are minimal with respect to the order < defined in Definition 3. After isolating the respective answer sets we then can find the SE models of P1 \u2217c P2 (following Definition 11) quite straightforwardly. Indeed, Task (i) can easily be achieved by making use of weak constraints which penalise each mismatch, and a similar method is possible for Task (ii). However, Definition 3 requires a certain two-phased comparison of SE models. We thus count a mismatch in the h-models as many times as we have differences in the t and c-models, respectively. Finally, if there was no difference in the t- or c-models, we still have to count the number of mismatches in the h-models. This is done by the third rule in the following program.\nDEFINITION 20.\n\u03c0card = {\u21d0 diff (1, 2, A,M), prog model(M),\n\u21d0 diff (1, 2, A, h), diff (1, 2, B,M),\n\u21d0 diff (1, 2, A, h),\u223cdiff (1, 2, B,M), dom(B), prog model(M),\nselector (2) \u2190}.\nWe finally put things together. To this end, we first define a module which takes the models and SE models, respectively, of some selected program (in the case of revision, it is program P2, thus selector (2) is specified in \u03c0card ) and copies them into a designated predicate.\nDEFINITION 21.\n\u03c0result = {total \u2190 \u223cnontotal ,\nnontotal \u2190 \u223ctotal ,\n\u2190 nontotal , selector(S), in(S,A, t), out(S,A, c),\n\u2190 nontotal , selector(S), out(S,A, t), in(S,A, c),\nresultH (A) \u2190 selector (S), in(S,A, h),nontotal ,\nresultH (A) \u2190 selector (S), in(S,A, c), total ,\nresultT (A) \u2190 selector(S), in(S,A, c)}.\nThe intuition for the module is as follows: we either generate a total SE model (Y, Y ) or a non-total SE model (X,Y ) with X \u2286 Y . Thus, the guess between predicates total and nontotal . In case we want to derive a non-total SE model (X,Y ), we have to make sure\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nthat Y coincides with the classical model we guessed.8 This is done by the two constraints. The remaining lines fill the predicates resultH and resultT accordingly, where atoms in resultH yield the X of the SE model and atoms in resultT yield the Y of the SE model.\nWe formulate our first main result.\nTHEOREM 14. For any set S of non-ground atoms, let\n\u03c1(S) = ({a | resultH (a) \u2208 S}, {b | resultT (b) \u2208 S})."}, {"heading": "Moreover, let", "text": "Pcard = \u03c0domain \u222a \u03c0models \u222a \u03c0result \u222a \u03c0card\nand \u03a8 = \u3008P1, P2\u3009 a belief profile. Then,\nSE (P1 \u2217c P2) = {\u03c1(S) | S \u2208 AS (Pcard [\u03a8])}.\n5.2.2 Set-based Revision. We continue with set-based revision. Unfortunately, the encodings now become more cumbersome, since we cannot make use of weak constraints anymore (which implicitly compared different models and SE models). Instead, we have to use a certain saturation technique (also called spoiling), which is quite common to encode problems from the second level of the polynomial hierarchy [Eiter and Gottlob 1995; Eiter and Polleres 2006]. Let us first look at the two main modules for revision \u03c0witness and \u03c0incl : \u03c0witness guesses a witness and contains the so-called \u201cspoiling rules\u201d (explained below); this module is also used later in the encodings for merging. \u03c0incl contains the specific conditions for spoiling in terms the revision operator. Two predicates used in \u03c0incl , violated and samediff all , will be explained in detail later.\nIntuitively, the module \u03c0witness works as follows. For each interpretation guessed in \u03c0models we now guess possible witnesses via predicates win and wout . Note that this guess (see Rule (18) below) is done via disjunction. This allows us to treat wrong guesses for witnesses via saturation (rather than via constraints as we did in \u03c0models). In fact, such wrong guesses will be indicated via the predicate spoil (\u03c0incl will provide us with rules which derive spoil ). Finally, if all such guesses for witnesses are violating some properties, we know that our initial guess (via in and out ) meets the expected criteria, and the constraint \u2190 \u223cspoil guarantees that only those initial guesses are contained in the answer sets of our encodings. Let us look at this concept in more detail.\nDEFINITION 22.\n\u03c0witness = {win(P,A,M) ; wout(P,A,M) \u2190 prog(P ), dom(A),model (M), (18)\nwdiff (P,Q,A,M) \u2190 win(P,A,M),wout(Q,A,M), (19)\nwdiff (P,Q,A,M) \u2190 wout(P,A,M),win(Q,A,M), (20)\nwsame(P,Q,A,M) \u2190 win(P,A,M),win(Q,A,M), (21)\nwsame(P,Q,A,M) \u2190 wout(P,A,M),wout(Q,A,M), (22)\nnotsubseteq(M, I, J) \u2190 same(P,Q,A,M),wdiff (P,Q,A,M), (23)\nwin(P,A,M) \u2190 spoil , prog(P ), dom(A),model (M), (24)\n8One might ask why we use the different concepts of t- and c-models. The reason is that there might be a minimal difference between (X1, Y1) and (X2, Y2) although there is no minimal difference between Y1 and Y2. But then we still need those interpretations Y in order to compute the corresponding interpretations X. On the other hand, there might be a minimal distance between Y1 and Y2 but not between any (X1, Y1) and (X2, Y2). Still, we then want (Y2, Y2) in the result.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nwout(P,A,M) \u2190 spoil , prog(P ), dom(A),model (M), (25)\n\u2190 \u223cspoil}. (26)\nAs mentioned before, Rule (18) formulates the disjunctive guess for witnesses (referred to as \u201cwguess\u201d in the following) and Rules (19)\u2013(22) provide us with some auxiliary predicates in exactly the same spirit as Rules (6)\u2013(9) from \u03c0models . Rule (23) indicates that the wguess cannot be in a certain subset relation to the initial guess.\nLet us illustrate this for the case of revision and suppose the initial guess (via in and out) talks about models M1 of P1 and M2 of P2 and the wguess (via win and wout ) talks about models N1 of P1 and N2 of P2. In case N1 \u2296 N2 6\u2286 M1 \u2296M2, we derive here notsubseteq(1, 2, c).\nBefore discussing Rules (24)\u2013(26), let us now turn to the specific conditions under which predicate spoil is derived:\nDEFINITION 23.\n\u03c0incl = {spoil \u2190 win(P,A, h),wout(P,A, t), (27)\nspoil \u2190 violated(P,R,M), (28)\nspoilcond(M) \u2190 notsubseteq(M, 1, 2), prog model(M), (29)\nspoilcond(c) \u2190 samediff all (c), (30)\nspoilcond(t) \u2190 notsubseteq(h, 1, 2), samediff all (t), (31)\nspoilcond(t) \u2190 samediff all (h), samediff all(t), (32)\nspoil \u2190 spoilcond(c), spoilcond (t), (33)\nselector(2) \u2190}. (34)\nRule (27) mirrors Rule (5) from \u03c0models in order to obtain valid SE interpretations. Rule (28) checks whether some wguess does not satisfy some rule (predicate violated is defined in program \u03c0violation below). Both rules derive predicate spoil .\nLet us for the moment return to Rules (24) and (25), which derive all possible win and wout predicates in case spoil was derived. Thus, in other words, a wguess which violates some property has to carry to predicate spoil , but in case spoil is derived all possible win and wout predicates have to be derived, hence all these wguesses lead to a single answer-set candidate I containing all win and wout predicates (the in and out predicates remain unchanged, however, and thus still characterise an initial guess G). In the end, we want that to check whether each wguess violates some property (i.e., carries the spoil predicate). To guarantee that this is the case, Rule (26) finally kills such interpretations, where a wguess would have been valid. Now, due to the minimality of the answer set semantics, if such a wguess existed (for an initial guess G), then the set I (containing the same initial guess) cannot become an answer set, and this initial guess has to be withdrawn. In turn, if no wguess without the spoil predicate is left (for an initial guess G), then the saturated interpretation I for this initial guess becomes an answer set.\nSo far, we just have eliminated wguesses which violate the concept of being models and SE models of the given belief profile, respectively. We now have to take the conditions of Definition 8 into account. To this end, we derive spoil for wguesses which are not in the desired relation to the initial guess. Let us first look into the classical models and suppose the initial guess (via in and out) makes reference about models M1 of P1 and M2 of P2 and the wguess (via win and wout ) refers to models N1 of P1 and N2 of P2. In case\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nN1\u2296N2 6\u2286M1\u2296M2, we already observed that we obtain notsubseteq(1, 2, c) and we have one reason to spoil this wguess (cf. Rule (29)). The same holds for N1 \u2296N2 =M1 \u2296M2 (this is done by Rule (30); for the definition of predicate samediff all , see below). A second reason to spoil is if also the initial guess for the SE models S1 = (X1, Y1) of P1 and S2 = (X2, Y2) of P2 is in a certain relation to the SE model S\u20321 = (X \u2032 1, Y \u2032 1) of P1 and S\u20322 = (X \u2032 2, Y \u2032 2) of P2 which are given by the wguess. In accordance to Definition 2, we first have to compare the there-parts. Thus, if Y \u20321 \u2296Y \u2032 2 6\u2286 Y1\u2296Y2, we already have a reason to spoil (again, taken care of by Rule (29)). If Y \u20321 \u2296 Y \u2032 2 = Y1 \u2296 Y2, we are not allowed to spoil yet, but have to look into the here-parts. Now, we spoil if X \u20321 \u2296X \u2032 2 6\u2286 X1 \u2296X2 (Rule (31)) or if X \u20321 \u2296X \u2032 2 = X1 \u2296X2 (Rule (32)). If both reasons for spoil are fulfilled, we finally derive spoil by Rule (33). Finally, rule selector(2) \u2190 plays the same role as in \u03c0card and triggers the \u03c0result module.\nIt remains to define the predicates violated and samediff all . One particular problem is that the employed saturation technique allows only for a restricted use of negation. Therefore, we have to re-implement concepts in a different way. In fact, predicates samediff all and violated are obtained via additional predicates which loop over all atoms (we now require the concepts defined in module \u03c0order ).\nLet us have a closer look on the definition of the violated predicate, which derives violated(P,R,M) if the rule R of program P is violated by the current wguess (either in terms of c-, t-, or h-models, as explained earlier). The main idea is to loop over all domain elements. To this end, we first check whether the current guess potentially violates the rule R if we just look at an atom A. For instance, if we consider a rule a \u2190 b, and a is in the guess, then this guess cannot violate the rule; the same holds if b is not in the guess. In general, these conditions are formulated by the unsat predicate defined below. Next, we loop over all atoms, and in case we can violate the rule if we take all domain elements B into account (violupto(P,R,B,M)), and A is the next element and also allows for violation, we derive violupto(P,R,A,M). rule R is violated by the wguess.\nDEFINITION 24.\n\u03c0violation = {unsat(P,R,A,M) \u2190 win(P,A,M),\u223cphead (P,R,A),\n\u223cnbody(P,R,A), prog rule(P,R),\nprog model(M),\nunsat(P,R,A,M) \u2190 wout(P,A,M),\u223cpbody(P,R,A),\n\u223cnhead(P,R,A), prog rule(P,R),\nprog model(M),\nunsat(P,R,A, h) \u2190 wout(P,A, h),win(P,A, t),\u223cpbody(P,R,A),\n\u223cnbody(P,R,A), prog rule(P,R),\nunsat(P,R,A, h) \u2190 wout(P,A, h),wout(P,A, t),\u223cpbody(P,R,A),\n\u223cnhead(P,R,A), prog rule(P,R),\nviolupto(P,R,A,M) \u2190 inf (A), unsat(P,R,A,M),\nviolupto(P,R,A,M) \u2190 succ(B,A), violupto(P,R,B,M),\nunsat(P,R,A,M),\nviolated(P,R,M) \u2190 sup(A), violupto(P,R,A,M)}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe test for equality follows a similar idea. In fact, what we want to do here is, given two sequences of models, \u3008M\u03b1, . . . ,Mn\u3009 and \u3008N\u03b1, . . . , Nn\u3009, to check whether Mi \u2296Mj = Ni \u2296 Nj for all \u03b1 \u2264 i < j \u2264 n. The first five rules in the module below do this for any pair of indices i, j. By transitivity of =, it is then sufficient to simply loop over all indices and check whether the above test holds for all i, j such that \u03b1 \u2264 i < n and j = i+ 1.\nDEFINITION 25.\n\u03c0eq = {samediff atom(I, J, A,M) \u2190 same(I, J, A,M),wsame(I, J, A,M),\nsamediff atom(I, J, A,M) \u2190 diff (I, J, A,M),wdiff (I, J, A,M),\nsamediff upto atom(I, J, A,M) \u2190 inf (A), samediff atom(I, J, A,M),\nsamediff upto atom(I, J, A,M) \u2190 succ(B,A), samediff atom(I, J, A,M),\nsamediff upto atom(I, J,B,M),\nsamediff (I, J,M) \u2190 sup(A), samediff upto atom(I, J, A,M),\nsamediff upto prog(I,M) \u2190 minprog(I),\nsamediff upto prog(I,M) \u2190 I = J + 1, samediff (I, J,M),\nsamediff upto prog(J,M),\nsamediff all (M) \u2190 samediff upto prog(I,M),maxprog(I)}.\nWe have the following result.\nTHEOREM 15. Let \u03a8 = \u3008P1, P2\u3009 a belief profile and define\nPincl = \u03c0domain \u222a \u03c0models \u222a \u03c0order \u222a \u03c0result \u222a \u03c0witness \u222a \u03c0incl \u222a \u03c0violation \u222a \u03c0eq .\nThen,\nSE (P1 \u2217 P2) = {\u03c1(S) | S \u2208 AS(Pincl [\u03a8])},\nwhere \u03c1 is defined as in Theorem 14."}, {"heading": "5.3 Encodings for Merging", "text": "5.3.1 Basic Merging. We continue with the problem of basic merging. We now suppose that belief profiles \u03a8 = \u3008P0, . . . , Pn\u3009 with an arbitrary number of programs are given. Also recall that P0 plays a special role in basic merging. In particular, the SE models of the result of the merging are taken from the SE models of P0.\nIn view of the general definition of the previous modules, we do not need to add any further concepts and just define the spoiling conditions:\nDEFINITION 26.\n\u03c0basic = {spoil \u2190 win(P,A, h),wout(P,A, t),\nspoil \u2190 violated(P,R,M),\nspoilcond(M) \u2190 notsubseteq(M, 0, J), prog model(M),\nspoilcond(c) \u2190 samediff all (c),\nspoilcond(t) \u2190 notsubseteq(h, 0, J), samediff all (t),\nspoilcond(t) \u2190 samediff all (h), samediff all(t),\nspoil \u2190 spoilcond(c), spoilcond (t),\nselector(0) \u2190, prog(0) \u2190}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nNote that we specified selector(0) to select the program from which \u03c0result takes the models and SE models to define the results, respectively. Also note the fact prog(0) which is necessary in case P0 is the empty program.\nWe have the following result:\nTHEOREM 16. Let \u03a8 = \u3008P0, . . . , Pn\u3009 a belief profile and define\nPbasic = \u03c0domain \u222a \u03c0models \u222a \u03c0order \u222a \u03c0result \u222a \u03c0witness \u222a \u03c0violation \u222a \u03c0eq \u222a \u03c0basic .\nThen,\nSE (\u2206(\u03a8)) = {\u03c1(S) | S \u2208 AS(Pbasic [\u03a8])},\nwhere \u03c1 is defined as in Theorem 14.\n5.3.2 Arbitration Merging. Our final encoding is the one for arbitration merging. The spoiling module \u03c0arbitration given next is very much in the style of \u03c0basic and \u03c0incl . However, we need a somewhat more complicated module to prepare the resultH and resultT predicates, since arbitration merging collects SE models from all programs of the belief profile rather than from a single program (which was the case in the approaches we encoded so far). We thus do not use a selector predicate here but instead provide a new result module below. Also recall that belief profiles for arbitration merging are of the form \u3008P1, . . . , Pn\u3009. In fact, the only main difference between \u03c0basic and \u03c0arbitration is to check that our guess is minimal in a global sense (i.e., the models vary in a minimal way among each other, cf. Definition 12) while in the case of basic merging the minimality has been guaranteed between the designated program P0 and the other programs (cf. Definition 14). This particular difference is reflected by the usage of predicate notsubseteq(\u00b7, I, J) compared to notsubseteq(\u00b7, 0, J) as used in \u03c0basic .\nDEFINITION 27.\n\u03c0arbitration = {spoil \u2190 win(P,A, h),wout(P,A, t),\nspoil \u2190 violated (P,R,A,M),\nspoilcond (M) \u2190 notsubseteq(M, I, J), prog model(M),\nspoilcond (c) \u2190 samediff all(c),\nspoilcond (t) \u2190 notsubseteq(h, I, J), samediff all(t),\nspoilcond (t) \u2190 samediff all(h), samediff all (t),\nspoil \u2190 spoilcond (c), spoilcond(t),\nwin(P,A,M) \u2190 spoil , prog(P ), dom(A),model (M),\nwout(P,A,M) \u2190 spoil , prog(P ), dom(A),model (M),\n\u2190 \u223cspoil}.\nHere is the new result module:\nDEFINITION 28.\n\u03c0\u2032result = {tout(I); tout(J) \u2190 prog(I), prog(J), I 6= J,\ntselect(I) \u2190 \u223ctout(I), prog(I),\ntotal \u2190 \u223cnontotal ,\nnontotal \u2190 \u223ctotal ,\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nresultT (A) \u2190 in(M,A, c), tselect(M),\nresultH (A) \u2190 in(M,A, c), total , tselect(M),\nhout(I); hout(J) \u2190 prog(I), prog(J), I 6= J,nontotal ,\nhselect(I) \u2190 \u223chout(I), prog(I),nontotal ,\n\u2190 nontotal , in(I, A, t), out(J,A, c), tselect(J), hselect(I),nontotal ,\n\u2190 nontotal , out(I, A, t), in(J,A, c), tselect(J), hselect(I),nontotal ,\nresultH (A) \u2190 in(I, A, h), hselect(I),nontotal}.\nRoughly speaking, the first two rules select exactly one program Pi from the belief profile. We then guess whether we build a total or a non-total SE model (as we did in \u03c0result ). Then, we copy the model from the guessed program into the there-part of the result, and in case we are constructing a total SE model, also in the here-part. If we construct a non-total SE model, we guess a second program Pj from the belief profile and check whether the there-part of the current SE model of Pj coincides with the classical model of Pi (this is done by the two constraints). If this check is passed, we copy the here-part of the SE model of Pj into the here-part of the resulting SE model.\nWe arrive at our final result:\nTHEOREM 17. Let \u03a8 = \u3008P1, . . . , Pn\u3009 a belief profile and define\nParbitration = \u03c0domain \u222a \u03c0models \u222a \u03c0order \u222a \u03c0 \u2032 result \u222a\n\u03c0witness \u222a \u03c0violation \u222a \u03c0eq \u222a \u03c0arbitration .\nThen,\nSE (\u2207(\u03a8)) = {\u03c1(S) | S \u2208 AS(Pincl [\u03a8])},\nwhere \u03c1 is defined as in Theorem 14.\nAll encodings presented here can be downloaded under the following URL:\nhttp://www.cs.uni-potsdam.de/\u02dctorsten/"}, {"heading": "6. DISCUSSION", "text": "We have addressed the problem of belief change in logic programming under the answer set semantics. Our overall approach is based on a monotonic characterisation of logic programs, given in terms of the set of SE models of a program. Based on the latter, we first defined and examined operators for logic program expansion and revision. Both subsetbased revision and cardinality-based revision were considered. As well as giving properties of these operators, we also considered their complexity. This work is novel, in that it addresses belief change in terms familiar to researchers in belief revision: expansion is characterised in terms of intersections of models, and revision is characterised in terms of minimal distance between models.\nWe also addressed the problem of merging logic programs under the answer set semantics. Again, the approaches are based on a monotonic characterisation of logic programs, given in terms of the set of SE models of a sequence of programs. We defined and examined two operators for logic program merging, the first following intuitions from arbitration [Liberatore and Schaerf 1998], the second being closer to IC merging [Konieczny and Pino Pe\u0301rez 2002]. Notably, since these merging operators are defined via a semantic\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\ncharacterisation, the results of merging are independent of the particular syntactic expression of a logic program. As well as giving properties of these operators, we also considered complexity questions. Last, we provided encodings for both program revision and program merging.\nWe note that previous work on logic program belief change was formulated at the level of the individual program, and not in terms of an abstract characterisation (via strong equivalence or sets of SE interpretations). The net result is that such previous work is generally difficult to work with: properties are difficult to come by, and often desirable properties (such as the tautology property) are lacking. The main point of departure for the current approach then is to lift the problem of logic program revision or merging from the program (or syntactic) level to an abstract (or semantic) level."}, {"heading": "A. APPENDIX", "text": ""}, {"heading": "A.1 Proof of Theorem 1", "text": "Most of the parts follow immediately from the fact that SE (P +Q) = SE (P ) \u2229 SE (Q).\n(1) We need to show that Definition 6 results in a well-defined set of SE models. For SE (P ) \u2229 SE (Q) = \u2205 we have that \u2205 is trivially well-defined (and R can be given by \u22a5 \u2190). Otherwise, for SE (P ) \u2229 SE (Q) 6= \u2205, we have the following: If (X,Y ) \u2208 SE (P ) \u2229 SE (Q), then (X,Y ) \u2208 SE (P ) and (X,Y ) \u2208 SE (Q); whence (Y, Y ) \u2208 SE (P ) and (Y, Y ) \u2208 SE (Q) since SE (P ) and SE (Q) are well-defined by virtue of P and Q being logic programs. Hence, (Y, Y ) \u2208 SE (P ) \u2229 SE (Q). Since this holds for arbitrary (X,Y ) \u2208 SE (P ) \u2229 SE (Q), we have that SE (P ) \u2229 SE (Q) is well-defined.\n(2) Immediate from the definition of +. (3) If P |=s Q, then SE (P ) \u2286 SE (Q). Hence, SE (P )\u2229SE (Q) = SE (P ), or P +Q \u2261s\nP . (4) Similar to the previous part. (5) This was established in the first part. (6) To show completeness, we need to show that for any (X,Y ) \u2208 SE (P + Q) and\n(Y \u222a Y \u2032, Y \u222a Y \u2032) \u2208 SE (P +Q) that (X,Y \u222a Y \u2032) \u2208 SE (P +Q). If (X,Y ) \u2208 SE (P + Q) and (Y \u222a Y \u2032, Y \u222a Y \u2032) \u2208 SE (P + Q), then (X,Y ) \u2208 SE (P )\u2229SE (Q) and (Y \u222aY \u2032, Y \u222aY \u2032) \u2208 SE (P )\u2229SE (Q). Hence, (X,Y ) \u2208 SE (P ) and (Y \u222a Y \u2032, Y \u222a Y \u2032) \u2208 SE (P ), and so, since SE (P ) is complete by assumption, we have (X,Y \u222a Y \u2032) \u2208 SE (P ). The same argument gives that (X,Y \u222aY \u2032) \u2208 SE (Q), whence (X,Y \u222aY \u2032) \u2208 SE (P )\u2229 SE (Q) and (X,Y \u222a Y \u2032) \u2208 SE (P +Q).\n(7) If Q \u2261s \u2205, then SE (Q) = {(X,Y ) | X \u2286 Y \u2286 A} from which the result follows immediately. 2"}, {"heading": "A.2 Proof of Theorem 2", "text": "(RA1). This postulate follows immediately from Definition 8. Note that (X,Y ) \u2208 SE (P \u2217Q) only if Y \u2208 \u03c3(Mod(Q),Mod(P )), and therefore (Y, Y ) \u2208 \u03c3(SE (Q),SE (P )). So, SE (P \u2217Q) is well-defined. (RA2). If P + Q is satisfiable, then we have that both \u03c3(Mod(Q),Mod(P )) 6= \u2205 and \u03c3(SE (Q),SE (P )) 6= \u2205. Further, for Y \u2208 Mod(Q) (or (X,Y ) \u2208 SE (Q)), there is\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nsome Y \u2032 \u2208 Mod(P ) (resp., (X \u2032, Y \u2032) \u2208 SE (P )) such that Y \u2296 Y \u2032 = \u2205 (resp., (X,Y ) \u2296 (X \u2032, Y \u2032) = \u2205), from which our result follows.\n(RA3). From Definition 8 we have that, if P is unsatisfiable, then Q is satisfiable iff P \u2217Q is satisfiable.\nOtherwise, if P is satisfiable and Q is satisfiable, then there is some (Y, Y ) \u2208 \u03c3(Mod(Q),Mod(P )) (since SE (Q) is well-defined and given Definition 7). Hence, SE (P \u2217Q) 6= \u2205.\n(RA4). Immediate from Definition 8.\n(RA5). If SE (P ) = \u2205, then the result follows immediately from the first part of Definition 8.\nOtherwise, we show that, if (X,Y ) is an SE model of (P \u2217 Q) + R, then (X,Y ) is an SE model of P \u2217 (Q+R).\nLet (X,Y ) \u2208 SE ((P \u2217 Q) + R). Then, (X,Y ) \u2208 SE (P \u2217 Q) and (X,Y ) \u2208 SE (R). Since (X,Y ) \u2208 SE (P \u2217 Q), by (RA1) we have that (X,Y ) \u2208 SE (Q), and so (X,Y ) \u2208 SE (Q) \u2229 SE (R), or (X,Y ) \u2208 SE (Q+R).\nThere are two cases to consider: X = Y : Since then (X,Y ) = (Y, Y ), and (Y, Y ) \u2208 SE (P \u2217 Q), we have that Y \u2208 \u03c3(Mod(Q),Mod(P )). Hence, from Definition 7, Y \u2208 Mod(Q) and there is some Y \u2032 \u2208 Mod(P ) such that there is no Y1 \u2208 Mod(Q) and no Y2 \u2208 Mod(P ) such that Y1 \u2296 Y2 \u2282 Y \u2296 Y \u2032. We established at the outset that (X,Y ) \u2208 SE (Q+R). Hence, Y \u2208 Mod(Q+R). This gives us that Y \u2208 Mod(Q + R) and there is some Y \u2032 \u2208 Mod(P ) such that no Y1, Y2 exist with Y1 \u2208 Mod(Q), Y2 \u2208 Mod(P ), and Y1 \u2296 Y2 \u2282 Y \u2296 Y \u2032. Clearly, in the above, if there is no Y1 \u2208 Mod(Q) such that the above condition holds, then there is no Y1 \u2208 Mod(Q+R) such that the above condition holds. Thus, we have Y \u2208 Mod(Q + R) and there is some Y \u2032 \u2208 Mod(P ) for which no Y1 \u2208 Mod(Q+R) and no Y2 \u2208 Mod(P ) exists such that Y1 \u2296 Y2 \u2282 Y \u2296 Y \u2032. Thus, from Definition 7, we get Y \u2208 \u03c3(Mod(Q+R),Mod(P )), hence (Y, Y ) \u2208 SE (P \u2217 (Q+R)). X \u2282 Y : We have Y \u2208 \u03c3(Mod(Q),Mod(P )) by virtue of (X,Y ) \u2208 SE (P \u2217 Q). In the previous part we established that Y \u2208 \u03c3(Mod(Q+R),Mod(P )). As well, (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) since (X,Y ) \u2208 SE(P \u2217Q). Thus, from Definition 7, we have that there is some (X \u2032, Y \u2032) \u2208 SE (P ) such that noU, V, U \u2032, V \u2032 exist such that (U, V ) \u2208 SE (Q), (U \u2032, V \u2032) \u2208 SE (P ), and (U, V )\u2296 (U \u2032, V \u2032) \u2282 (X,Y )\u2296 (X \u2032, Y \u2032). Therefore, there is no (U, V ) \u2208 SE (Q+R) and no (U \u2032, V \u2032) \u2208 SE (P ) such that (U, V )\u2296 (U \u2032, V \u2032) \u2282 (X,Y )\u2296 (X \u2032, Y \u2032). We previously showed that (X,Y ) \u2208 SE (Q+R). Consequently, from Definition 8, we obtain that (X,Y ) \u2208 \u03c3(SE (Q+R),SE (P )). Hence, (X,Y ) \u2208 SE (P \u2217 (Q+R)). Thus, in either case, we get (X,Y ) \u2208 SE (P \u2217 (Q+R)), which was to be shown. 2"}, {"heading": "A.3 Proof of Theorem 3", "text": "For initialisation, idempotency, and tautology, in the left-hand side of the given equivalence, revision corresponds with expansion via (RA2), from which the result is immediate.\nFor absorption, we have Q = R, and so ((P \u2217 Q) \u2217 R) = ((P \u2217 Q) \u2217 Q). Since SE (P \u2217Q) \u2286 SE (Q), then from Theorem 1, Part 3, we have that (P \u2217Q) +Q \u2261s P \u2217Q. As well, ((P \u2217Q) \u2217Q) = ((P \u2217Q) +Q), from which our result follows. 2\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."}, {"heading": "A.4 Proof of Theorem 4", "text": "We need to show that SE (P \u2217 Q) \u2286 SE (P \u2217w Q). If SE (P ) = \u2205, then SE (P \u2217 Q) = SE (Q) = SE (P \u2217w Q).\nOtherwise, there are two cases to consider:\n(1) (X,Y ) \u2208 SE (P \u2217Q) where X \u2282 Y . Then, (X,Y ) \u2208 \u03c3(SE (P ),SE (Q)) by Definition 8, and (X,Y ) \u2208 SE (P \u2217w Q) by Definition 9. (2) (Y, Y ) \u2208 SE (P \u2217 Q). From Definition 8, we have that Y \u2208 \u03c3(Mod (Q),Mod(P )). Y \u2208 \u03c3(Mod(Q),Mod(P )) implies that (Y, Y ) \u2208 \u03c3(SE (Q),SE (P )). Hence, according to Definition 9, (Y, Y ) \u2208 SE (P \u2217w Q).\nTherefore, (X,Y ) \u2208 SE (P \u2217Q) implies that (X,Y ) \u2208 SE (P \u2217w Q), whence SE (P \u2217 Q) \u2286 SE (P \u2217w Q). 2"}, {"heading": "A.5 Proof of Theorem 5", "text": "Before giving the proof, we first present a lemma that is key for postulates (RA5) and (RA6).\nLEMMA 1. Let E1, E2, and E3 be SE interpretations. If \u03c3||(E1, E2) \u2229 E3 6= \u2205, then \u03c3||(E1, E2) \u2229 E3 = \u03c3||(E1 \u2229 E3, E2).\nPROOF. Assume that \u03c3||(E1, E2) \u2229 E3 6= \u2205. For showing \u2286 in the equality, let (X,Y ) \u2208 \u03c3||(E1, E2) \u2229 E3 and, toward a contradiction, assume that (X,Y ) 6\u2208 \u03c3||(E1 \u2229 E3, E2). Since (X,Y ) \u2208 \u03c3||(E1, E2), so (X,Y ) \u2208 E1; as well, (X,Y ) \u2208 E3, so (X,Y ) \u2208 E1 \u2229 E3. Since (X,Y ) 6\u2208 \u03c3||(E1 \u2229 E3, E2) we have that there is some (X \u2032, Y \u2032) \u2208 E1\u2229E3 and some (U \u2032, V \u2032) \u2208 E2 such that for every (U, V ) \u2208 E2, |(X \u2032, Y \u2032)\u2296(U \u2032, V \u2032)| < |(X,Y )\u2296 (U, V )|. But this contradicts the assumption that (X,Y ) \u2208 \u03c3||(E1, E2). Hence, the assumption that (X,Y ) 6\u2208 \u03c3||(E1 \u2229 E3, E2) cannot hold, i.e., (X,Y ) \u2208 \u03c3||(E1 \u2229 E3, E2), establishing that \u03c3||(E1, E2) \u2229 E3 \u2286 \u03c3||(E1 \u2229 E3, E2).\nTo show \u2287 in the equality, let (X,Y ) \u2208 \u03c3||(E1 \u2229 E3, E2) and, toward a contradiction, assume that (X,Y ) 6\u2208 \u03c3||(E1, E2) \u2229 E3.\nSince (X,Y ) \u2208 \u03c3||(E1 \u2229 E3, E2), we get that (X,Y ) \u2208 E3. Hence, (X,Y ) 6\u2208 \u03c3||(E1, E2) (via the assumption that (X,Y ) 6\u2208 \u03c3||(E1, E2) \u2229 E3).\nWe also have by assumption that \u03c3||(E1, E2) \u2229 E3 6= \u2205, and so let (X \u2032, Y \u2032) \u2208 \u03c3||(E1, E2)\u2229E3. Then, from the first part above, we have that (X,Y ) \u2208 \u03c3||(E1\u2229E3, E2). Thus, we have both that (X,Y ) \u2208 \u03c3||(E1 \u2229 E3, E2) and (X \u2032, Y \u2032) \u2208 \u03c3||(E1 \u2229 E3, E2). Consequently, we obtain that\nmin({|(X,Y )\u2296 (U, V )| | (U, V ) \u2208 E2}) = min({|(X \u2032, Y \u2032)\u2296 (U, V )|(U, V ) \u2208 E2}).\nTherefore, since (X \u2032, Y \u2032) \u2208 \u03c3||(E1, E2), so also (X,Y ) \u2208 \u03c3||(E1, E2). But this together with (X,Y ) \u2208 E3 contradicts our assumption that (X,Y ) 6\u2208 \u03c3||(E1, E2)\u2229E3; i.e., we have (X,Y ) \u2208 \u03c3||(E1, E2) \u2229 E3, establishing that \u03c3||(E1, E2) \u2229 E3 \u2287 \u03c3||(E1 \u2229 E3, E2).\nWe now move on to the proof of Theorem 5:\n(RA1). This follows immediately from Definition 11. Note that (X,Y ) \u2208 SE (P \u2217cQ) only if Y \u2208 \u03c3||(Mod(Q),Mod(P )), and therefore (Y, Y ) \u2208 \u03c3||(SE (Q),SE (P )). So, SE (P \u2217c Q) is well-defined.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(RA2). If P + Q is satisfiable, then we have that both \u03c3||(Mod(Q),Mod(P )) 6= \u2205 and \u03c3||(SE (Q),SE (P )) 6= \u2205. Further, for Y \u2208 Mod(Q) (or (X,Y ) \u2208 SE (Q)) we have that there is some Y \u2032 \u2208 Mod(P ) (resp., (X \u2032, Y \u2032) \u2208 SE (P )) such that Y \u2296 Y \u2032 = \u2205 ((X,Y )\u2296 (X \u2032, Y \u2032) = \u2205), from which our result follows.\n(RA3). From Definition 11 we have that, if P is unsatisfiable, then Q is satisfiable iff P \u2217 Q is satisfiable. Otherwise, if P is satisfiable and Q is satisfiable, then there is some (Y, Y ) \u2208 \u03c3||(Mod(Q),Mod(P )) (since SE (Q) is well-defined and given Definition 10). Hence, SE (P \u2217Q) 6= \u2205.\n(RA4). This is immediate from Definition 11.\n(RA5), (RA6). For P \u2217c Q, if SE (P ) = \u2205, we have that (P \u2217c Q) + R = Q + R = (P \u2217c (Q+R)).\nSo, assume that SE (P ) 6= \u2205. We show that SE (P \u2217cQ)+SE (R) = SE (P \u2217c (Q+R)), thus establishing both postulates.\nFor \u2286, assume that (X,Y ) \u2208 SE (P \u2217c Q) + R. Thus, (X,Y ) \u2208 SE (P \u2217c Q) and (X,Y ) \u2208 R.\nFor X \u2286 Y , we have that Y \u2208 \u03c3||(Mod(Q),Mod(P )) and as well Y \u2208 Mod(R). We get that Y \u2208 \u03c3||(Mod(Q+R),Mod(P )) by the analogous proof in propositional logic for cardinality-based revision.\nFor X \u2282 Y , we have that (X,Y ) \u2208 \u03c3||(SE (Q),SE (P )) and as well (X,Y ) \u2208 SE (R). By Lemma 1 we get that (X,Y ) \u2208 \u03c3||(SE (Q+R),SE (P )).\nThis establishes one direction of the set equality. For \u2287, the argument is essentially the same, though in the reverse direction, and again appealing to Lemma 1."}, {"heading": "A.6 Proof of Theorem 6", "text": "The proof is the same as for Theorem 3."}, {"heading": "A.7 Proof of Theorem 7", "text": "Since we deal with a globally fixed language, we first need a few lemmata.\nLEMMA 2. Let P,Q be programs, Y an interpretation, and x \u2208 Y \\var(P \u222aQ). Then, Y \u2208 \u03c3(Mod(Q),Mod(P )) implies Y \\ {x} \u2208 \u03c3(Mod (Q),Mod(P )).\nPROOF. Since Y \u2208 \u03c3(Mod(Q),Mod(P )), so Y \u2208 Mod(Q) and there exists some Z \u2208 Mod(P ) such that for each Y \u2032 \u2208 Mod(Q) and Z \u2032 \u2208 Mod(P ), Y \u2032 \u2296 Z \u2032 6\u2282 Y \u2296 Z . We show that x \u2208 Z holds. Suppose this is not the case: Then, we have x \u2208 Y \u2296 Z , since x \u2208 Y . Now, since x /\u2208 var (P ), also Z \u222a {x} \u2208 Mod(P ). But then x /\u2208 Y \u2296 (Z \u222a {x}) which yields Y \u2296 (Z \u222a {x}) \u2282 Y \u2296 Z , a contradiction to our assumption. Hence, we can suppose x \u2208 Z . Now, since Y \u2208 Mod(Q), obviously Y \\ {x} \u2208 Mod(Q) as well. We obtain Y \u2296Z = (Y \\ {x})\u2296 (Z \\ {x}), thus Y \\ {x} \u2208 \u03c3(Mod (Q),Mod(P )) holds.\nLEMMA 3. Let P,Q be programs, (X,Y ) an SE interpretation, and x \u2208 Y \\ var (P \u222a Q). Then, (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) implies (X \\{x}, Y \\{x}) \u2208 \u03c3(SE (Q),SE (P )).\nPROOF. Since (X,Y ) \u2208 \u03c3(SE (Q),SE (P )), (X,Y ) \u2208 SE (Q) and there exists a (U,Z) \u2208 SE (P ) such that for each (X \u2032, Y \u2032) \u2208 SE (Q) and each (U \u2032, Z \u2032) \u2208 SE (P ), (X \u2032, Y \u2032) \u2296 (U \u2032, Z \u2032) 6\u2282 (X,Y ) \u2296 (U,Z). We show that the following relations hold: (i) x \u2208 Z; and (ii) x \u2208 U iff x \u2208 X . Towards a contradiction, first suppose x /\u2208 Z . Then, we have x \u2208 Y \u2296 Z , since x \u2208 Y . Now, since x /\u2208 var (P ), also (U,Z \u222a {x}) \u2208 SE (P )\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nand (U \u222a {x}, Z \u222a {x}) \u2208 SE (P ). We have x /\u2208 Y \u2296 (Z \u222a {x}) which yields Y \u2296(Z\u222a{x}) \u2282 Y \u2296Z . Thus, (X,Y )\u2296(U,Z\u222a{x}) \u2282 (X,Y )\u2296(U,Z), which is a contradiction to the assumption. Hence, x \u2208 Z holds. If (ii) does not hold, we get x \u2208 X\u2296U . Now, in case x \u2208 X and x /\u2208 U , we have (X,Y ) \u2296 (U \u222a {x}, Z) \u2282 (X,Y ) \u2296 (U,Z). In case x \u2208 U and x /\u2208 X , we have (X,Y ) \u2296 (U \\ {x}, Z) \u2282 (X,Y ) \u2296 (U,Z). Again, both cases yield a contradiction. Clearly, (X,Y ) \u2208 SE (Q) implies (X \\ {x}, Y \\ {x}) \u2208 SE (Q) and we obtain (X,Y ) \u2296 (U,Z) = (X \\ {x}, Y \\ {x}) \u2296 (U \\ {x}, Z \\ {x}). (X \\ {x}, Y \\ {x}) \u2208 \u03c3(SE (Q),SE (P )) thus follows.\nLEMMA 4. For any programs P , Q, and R, P \u2217 Q 6|=s R iff there exist X \u2286 Y \u2286 var (P \u222aQ \u222aR) such that (X,Y ) \u2208 SE (P \u2217Q) and (X,Y ) /\u2208 SE (R).\nPROOF. The if-direction is by definition. As for the only-if direction, assume P \u2217 Q 6|=s R. Then, there exists a pair (X,Y ) such that (X,Y ) \u2208 SE (P \u2217 Q) and (X,Y ) /\u2208 SE (R). Let V = var (P \u222a Q \u222a R). We first show that (X \u2229 V, Y \u2229 Y ) \u2208 SE (P \u2217 Q). By definition, (X,Y ) \u2208 SE (Q). If SE (P ) = \u2205, SE (P \u2217 Q) = SE (Q), and since (X,Y ) \u2208 SE (Q) obviously implies (X\u2229V, Y \u2229Y ) \u2208 SE (Q), (X\u2229V, Y \u2229Y ) \u2208 SE (P\u2217Q) thus follows in this case. So suppose SE (P ) 6= \u2205. Then, Y \u2208 \u03c3(Mod (Q),Mod(P )). By iteratively applying Lemma 2, we obtain that also Y \u2229 V \u2208 \u03c3(Mod(Q),Mod(P )). Analogously using Lemma 3, (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) yields (X \u2229 V, Y \u2229 V ) \u2208 \u03c3(SE (Q),SE (P )). By Definition 8, we get (X \u2229 V, Y \u2229 V ) \u2208 SE (P \u2217 Q). Finally, it is clear that (X,Y ) /\u2208 SE (R), implies that (X \u2229 V, Y \u2229 V ) /\u2208 SE (R).\nWe now proceed with the proof of Theorem 7. We first show membership in \u03a3P2 for the complementary problem. From Lemma 4, the complementary problem holds iff there exist X,Y \u2286 var (P \u222aQ\u222aR) such that (X,Y ) \u2208 SE (P \u2217 Q) and (X,Y ) /\u2208 SE (R). In what follows, let V = var(P \u222a Q \u222a R). We first state the following observation: Recall that Y \u2208 \u03c3(Mod(Q),Mod(P )) iff Y \u2208 Mod(Q) and there exists a W \u2208 Mod(P ) such that W \u2286 V and for each Y \u2032 \u2208 Mod(Q) and W \u2032 \u2208 Mod(P ), Y \u2032 \u2296 W \u2032 6\u2282 Y \u2296 W . Now, if Y \u2286 V , then there is also a W \u2286 V satisfying above test (this is seen by the arguments used in the proof of Lemma 2). A similar observation holds for (X,Y ) \u2208 \u03c3(SE (Q),SE (P )).\nThus an algorithm to decide P \u2217 Q 6|=s R is as follows. We guess interpretations X,Y,W,U, Z \u2286 V and start with checking (X,Y ) \u2208 SE (Q) and (X,Y ) /\u2208 SE (R). Then, we check whether SE (P ) = \u2205 which can be done via a single call to an NPoracle. If the answer is yes, we already have found an SE interpretation (X,Y ) such that (X,Y ) \u2208 SE (P \u2217Q) and (X,Y ) /\u2208 SE (R) and thus the complementary problem holds. If the answer is no, we next check whether (U,Z) \u2208 SE (P ) and W \u2208 Mod(P ). Then, (i) given Y and W , we check whether for each Y \u2032 \u2286 V and each W \u2032 \u2286 V such that Y \u2032 \u2208 Mod(Q) and W \u2032 \u2208 Mod(P ), Y \u2032 \u2296 W \u2032 6\u2282 Y \u2296 W holds. It is easy to see that then the same relation holds for arbitrary models Y \u2032 and W \u2032. From that we can conclude that Y \u2208 \u03c3(Mod (Q),Mod(P )). Next, (ii) given (X,Y ) and (U,Z), we check whether for each X \u2032 \u2286 Y \u2032 \u2286 V and each U \u2032 \u2286 Z \u2032 \u2286 V such that (X \u2032, Y \u2032) \u2208 SE (Q) and (U \u2032,W \u2032) \u2208 SE (P ), (X \u2032, Y \u2032)\u2296 (U \u2032,W \u2032) 6\u2282 (X,Y )\u2296 (U,W ). Again, it is easy to see that in this case (X,Y ) \u2208 \u03c3(SE (Q),SE (P )) follows. But then we obtain (X,Y ) \u2208 SE (P \u2217Q) by Definition 8 which together with (X,Y ) /\u2208 SE (R) solves the complementary problem in view of Lemma 4.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nWe recall that model checking as well as SE model checking are in P. So most of the checks used above are in P (expect the already mentioned call to an NP-oracle) and it remains to settle the complexity of the checks (i) and (ii). As well, they can be done by an NP-oracle. This can be seen by considering the respective complementary problems, where one guesses the sets Y \u2032,W \u2032 (resp., X \u2032, Y \u2032, U \u2032, Z \u2032) and then performs model checking or SE model checking together with some other simple tests which are all in P. Thus, the overall algorithm runs in nondeterministic polynomial time with access to an NP-oracle. This shows the \u03a3P2 -membership as desired.\nAs for the hardness-part, we use a reduction from the problem of checking whether a given quantified Boolean formula of form \u03a6 = \u2200Y \u2203X\u03d5, where \u03d5 is a propositional formula in conjunctive normal form over atoms X \u222a Y , evaluates to true, which is \u03a0P2 - complete. For \u03a6 as described, let, for each z \u2208 X \u222a Y , z\u2032 be a new atom. Additionally, for each clause c = z1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 zk \u2228 \u00aczk+1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00aczm in \u03d5, let c\u0302 be the sequence z\u20321, . . . , z \u2032 k, zk+1, . . . , zm. Finally, let w be a further new atom and V = X \u222aY \u222a{z\n\u2032 | z \u2208 X \u222a Y } \u222a {w}. We define the following programs: P\u03a6 = {v \u2190| v \u2208 V }, R\u03a6 = {w \u2190}, and\nQ\u03a6 = {y \u2190 \u223cy \u2032; y\u2032 \u2190 \u223cy; \u22a5 \u2190 y, y\u2032 | y \u2208 Y } \u222a\n{x\u2190 \u223cx\u2032, w; x\u2032 \u2190 \u223cx,w; w \u2190 x; w \u2190 x\u2032;\n\u22a5 \u2190 x, x\u2032 | x \u2208 X} \u222a\n{\u22a5 \u2190 c\u0302, w | c a clause in \u03d5}.\nThe SE models over V of these programs are as follows (for a set Z of atoms, Z \u2032 stands for {z\u2032 | z \u2208 Z}):\nSE (P\u03a6) = {(V, V )}; SE (Q\u03a6) = {(S, S) | S = I \u222a (Y \\ I) \u2032, I \u2286 Y } \u222a\n{(S, T ), (T, T ) | S = I \u222a (Y \\ I)\u2032,\nT = {w} \u222a S \u222a J \u222a (X \\ J)\u2032,\nI \u2286 Y, J \u2286 X, I \u222a J |= \u03d5};\nSE (R\u03a6) = {(W1,W2) | {w} \u2286W1 \u2286W2 \u2286 V }.\nWe show that \u03a6 is true iff P\u03a6 \u2217Q\u03a6 |=s R\u03a6 holds.\nOnly-if direction: Suppose P\u03a6\u2217Q\u03a6 |=s R\u03a6 does not hold. By Lemma 4, there exist S \u2286 T \u2286 var (P\u03a6 \u222aQ\u03a6 \u222aR\u03a6) = V such that (S, T ) \u2208 SE (P\u03a6 \u2217Q\u03a6) and (S, T ) /\u2208 SE (R\u03a6). Inspecting the SE models of R\u03a6, we obtain that w /\u2208 S. From (S, T ) \u2208 SE (P\u03a6 \u2217 Q\u03a6), (S, T ) \u2208 SE(Q\u03a6), and thus S has to be of the form I \u222a (Y \\ I)\u2032 for some I \u2286 Y . Recall that (V, V ) is the only SE model of P\u03a6 over V . Hence, S = T holds, since otherwise (T, T )\u2296 (V, V ) \u2282 (S, T )\u2296 (V, V ), which is in contradiction to (S, T ) \u2208 SE (P\u03a6 \u2217Q\u03a6). Now we observe that for each U with S = T \u2282 U \u2286 V , (U,U) /\u2208 SE (Q\u03a6) has to hold, (otherwise (U,U) \u2296 (V, V ) \u2282 (S, S) \u2296 (V, V )). Inspecting the SE models of SE (Q\u03a6), this only holds if, for each J \u2286 X , I \u222a J 6|= \u03d5. But then \u03a6 is false.\nIf direction: Suppose \u03a6 is false. Then, there exists an I \u2286 Y such that for all J \u2286 X , I \u222a J 6|= \u03d5. We know that (S, S) = (I \u222a (Y \\ I)\u2032, I \u222a (Y \\ I)\u2032) \u2208 SE (Q\u03a6) and (V, V ) \u2208 SE (P\u03a6). Next, to obtain (S, S) \u2208 SE (P\u03a6 \u2217Q\u03a6), we show S \u2208 \u03c3(Mod(Q\u03a6),Mod(P\u03a6)). Suppose this is not the case. Since S \u2282 V and V is the minimal model of P\u03a6, there has\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nto exist an U with S \u2282 U \u2286 V such that U \u2208 Mod(Q\u03a6). Recall that S = I \u222a (Y \\ I)\u2032 and, by assumption, for all J \u2286 X , I \u222a J 6|= \u03d5. By inspecting the SE models of Q\u03a6, it is clear that no such U \u2208 Mod(Q\u03a6) exists. By essentially the same arguments, (S, S) \u2208 \u03c3(SE (Q\u03a6),SE (P\u03a6)) can be shown. Therefore, (S, S) \u2208 SE (P\u03a6 \u2217Q\u03a6) and since w /\u2208 S, P\u03a6 \u2217Q\u03a6 |=s R\u03a6 does not hold.\nThis shows \u03a0P2 -hardness for normal programs Q. The result for positive programs Q is obtained by replacing in Q\u03a6 rules y \u2190 \u223cy\u2032, y\u2032 \u2190 \u223cy by y; y\u2032 \u2190, and likewise rules x \u2190 \u223cx\u2032, w and x\u2032 \u2190 \u223cx,w by x;x\u2032 \u2190 w. Due to the presence of the constraints \u22a5 \u2190 y, y\u2032 and \u22a5 \u2190 x, x\u2032, this modification does not change the SE models of these programs."}, {"heading": "A.8 Proof of Theorem 9", "text": "The definitions for arbitration and basic merging (Definitions 13 and 15) are essentially composed of two parts (as are the definitions for revision): there is a phrase to deal with classical propositional models (or SE models of form (Y, Y )) and then general SE models. For brevity, and because the case for propositional models follows immediately from the case of general SE models, we consider general SE models in the proofs here.\n(LS1\u2032) \u2013 (LS7\u2032). These all follow trivially or straightforwardly from the definition of P1 \u22c4 P2. (LS8\u2032). Assume that P1 and P2 are satisfiable. It follows that SE (\u3008P1, P2\u3009) 6= \u2205 and so Mina(SE (\u3008P1, P2\u3009)) 6= \u2205. Let \u3008S1, S2\u3009 \u2208 Mina(SE (\u3008P1, P2\u3009)), and so S1, S2 \u2208 SE (P1 \u22c4 P2). Since S1 \u2208 SE (P1) we get that S1 \u2208 SE (P1) \u2229 SE (P1 \u22c4 P2) and so S1 \u2208 SE (P1 \u2293 (P1 \u22c4 P2)). Thus, P1 \u2293 (P1 \u22c4 P2) is satisfiable."}, {"heading": "A.9 Proof of Theorem 10", "text": "Let \u03a8 be a belief profile, P0 a program representing global constraints, and \u2206 as given in Definition 15. Then, \u2206 satisfies the following versions of the postulates of Definition 5:\n(IC0\u2032) \u2013 (IC3\u2032), (IC9\u2032). These follow trivially or straightforwardly from the definition of \u2206(\u3008P0,\u03a8\u3009). (IC4\u2032). Assume that P1 |=s P0 and P2 |=s P0. If SE (P1) \u2229 SE (P2) 6= \u2205 then by (IC2\u2032) we have that \u2206(\u3008P0, P1, P2\u3009) = P0 \u2293 P1 \u2293 P2 from which our result follows immediately.\nConsequently, assume that SE (P1) \u2229 SE (P2) = \u2205. As well, assume the antecedent condition of the postulate that \u2206(\u3008P0, P1, P2\u3009) \u2293 P1 is satisfiable. Let \u03a8 = \u3008P0, P1, P2\u3009. Thus, we have for some (X,Y ) that (X,Y ) \u2208 SE (\u2206(\u03a8)\u2293P1), and so (X,Y ) \u2208 SE (P0)\u2229 SE (P1), where (X,Y ) \u2208 Minb(SE (\u03a8))0. (X,Y ) \u2208 Minb(SE (\u03a8))0 implies that there is some (X \u2032, Y \u2032) \u2208 SE (P2) such that S = \u3008(X,Y ), (X,Y ), (X \u2032, Y \u2032)\u3009 \u2208 Minb(SE (\u03a8)).\nWe claim that S \u2032 = \u3008(X \u2032, Y \u2032), (X,Y ), (X \u2032, Y \u2032)\u3009 \u2208 Minb(SE (\u03a8)). This is sufficient to prove our result, since S \u2032 \u2208 Minb(SE (\u03a8)) yields that (X \u2032, Y \u2032) \u2208 \u2206(\u03a8) and (X \u2032, Y \u2032) \u2208 SE (P2), that is to say, \u2206(\u03a8) \u2293 P2 is satisfiable. Proof of claim: Since S \u2208 Minb(SE (\u03a8)), this means that for every T \u2208 SE (\u03a8) we have that T \u2264b S implies that S \u2264b T . Consider T = \u3008(U0, V0), (U1, V1), (U2, V2)\u3009. If T \u2264b S then we have that (U0, V0) \u2296 (U1, V1) \u2286 (X,Y ) \u2296 (X,Y ) = (\u2205, \u2205). That is, U0 = U1 and V0 = V1, and so T =\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n\u3008(U0, V0), (U0, V0), (U2, V2)\u3009. As well, from T \u2264b S, we get that (U0, V0) \u2296 (U2, V2) \u2286 (X,Y )\u2296 (X \u2032, Y \u2032). Since T \u2264b S implies S \u2264b T , this means that (X,Y )\u2296 (X \u2032, Y \u2032) \u2286 (U0, V0)\u2296 (U2, V2).\nWe will use this later, and so summarise the result here: (\u03b1) (X,Y ) and (X \u2032, Y \u2032) are such that for every (U0, V0) \u2208 SE (P1) and (U2, V2) \u2208\nSE (P2) if (U0, V0) \u2296 (U2, V2) \u2286 (X,Y ) \u2296 (X \u2032, Y \u2032) then (X,Y ) \u2296 (X \u2032, Y \u2032) \u2286 (U0, V0)\u2296 (U2, V2).\nWe must show for S \u2032 = \u3008(X \u2032, Y \u2032), (X,Y ), (X \u2032, Y \u2032)\u3009, that T \u2264b S \u2032 implies S \u2032 \u2264b T . Let T = \u3008(U \u20320, V \u2032 0), (U \u2032 1, V \u2032 1), (U \u2032 2, V \u2032 2)\u3009 and assume that T \u2264b S \u2032 . Then, by definition of \u2264b, we have that (U \u20320, V \u2032 0) \u2296 (U \u2032 1, V \u2032 1) \u2286 (X\n\u2032, Y \u2032) \u2296 (X,Y ). As well, we have that (U \u20320, V \u2032 0) \u2296 (U \u2032 2, V \u2032 2) \u2286 (X \u2032, Y \u2032) \u2296 (X \u2032, Y \u2032) = (\u2205, \u2205). Hence, we must have that U \u20320 = U \u2032 2 and V \u20320 = V \u2032 2 . Thus, we can write T = \u3008(U \u2032 0, V \u2032 0), (U \u2032 1, V \u2032 1), (U \u2032 0, V \u2032 0)\u3009.\nNow, we will have S \u2032 \u2264b T just if (X \u2032, Y \u2032) \u2296 (X,Y ) \u2286 (U \u20320, V \u2032 0) \u2296 (U \u2032 1, V \u2032 1) and\n(X \u2032, Y \u2032) \u2296 (X \u2032, Y \u2032) \u2286 (U \u20320, V \u2032 0) \u2296 (U \u2032 2, V \u2032 2). The second condition is vacuously true. As for the first condition, we have that (U \u20320, V \u2032 0) \u2208 SE (P2) and (U \u2032 1, V \u2032 1) \u2208 SE (P1). Thus, via (\u03b1), we obtain that (X \u2032, Y \u2032)\u2296 (X,Y ) \u2286 (U \u20321, V \u2032 1)\u2296 (U \u2032 0, V \u2032 0). We conclude that S \u2032 \u2264b T .\nThis shows that S \u2032 \u2208 Minb(SE (\u03a8)), where (X \u2032, Y \u2032) \u2208 SE (P0) and (X \u2032, Y \u2032) \u2208\nSE (P2). Consequently, SE (\u2206(\u3008P0, P1, P2\u3009) \u2293 P2) is satisfiable.\n(IC5\u2032). Consider (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8\u3009) \u2293 \u2206(\u3008P0,\u03a8\u2032\u3009)), and so (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8\u3009)) and (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8\u2032\u3009)). Thus, (X,Y ) \u2208 Minb(SE (\u3008P0,\u03a8\u3009)) and (X,Y ) \u2208 Minb(SE (\u3008P0,\u03a8\u2032\u3009)). Hence, there is some \u3008(X,Y ), S\u3009 \u2208 SE (\u3008P0,\u03a8\u3009) and some \u3008(X,Y ), S \u2032 \u3009 \u2208 SE (\u3008P0,\u03a8\u2032\u3009) such that \u3008(X,Y ), S\u3009 \u2264b T for every T \u2208 SE (\u3008P0,\u03a8\u3009) and \u3008(X,Y ), S \u2032 \u3009 \u2264b T \u2032 for every T \u2032 \u2208 SE (\u3008P0,\u03a8\u2032\u3009). But this implies that \u3008(X,Y ), S, S \u2032 \u3009 \u2264b \u3008(X,Y ), T \u2032\u2032 \u3009 for every T \u2032\u2032 \u2208 SE (\u3008P0,\u03a8,\u03a8\u2032\u3009). Consequently, (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8 \u25e6\u03a8\u2032\u3009)).\n(IC7\u2032). If \u2206(\u3008P0,\u03a8\u3009) \u2293 P1 is unsatisfiable then the result is immediate. So, assume that \u2206(\u3008P0,\u03a8\u3009)\u2293P1 is satisfiable, and let (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8\u3009)\u2293P1). That is, (X,Y ) \u2208 SE (\u2206(\u3008P0,\u03a8\u3009)) and (X,Y ) \u2208 SE (P1). By definition we have that (X,Y ) \u2208 Minb(SE (\u3008P0,\u03a8\u3009))0. Clearly, since (X,Y ) \u2208 SE (P1) we also obtain that (X,Y ) \u2208 Minb(SE (\u3008P0\u2229P1,\u03a8\u3009))0, from which we get (X,Y ) \u2208 SE (\u2206(\u3008P0\u2293P1,\u03a8\u3009))."}, {"heading": "A.10 Proof of Theorem 11", "text": "We first prove a helpful lemma.\nLEMMA 5. Let \u03a8 be a belief profile. If X \u2208 Mina(SE (\u03a8)) then for Xi \u2208 X we have \u3008Xi, X\u3009 \u2208 Minb(SE (\u3008\u2205,\u03a8\u3009)).\nPROOF. Let \u03a8 be a belief profile, and let X \u2208 Mina(SE (\u03a8)). Hence, for every Y \u2208 SE (\u03a8) we have that Y \u2264a X implies X \u2264a Y . Now, Y \u2264a X means that Yi \u2296 Yj \u2286 Xi \u2296Xj for every 1 \u2264 i, j \u2264 |\u03a8|.\nSo, for fixed i we have that Yi \u2296 Yj \u2286 Xi \u2296 Xj implies that Xi \u2296 Xj \u2286 Yi \u2296 Yj . Let X0 = Xi for that i. Thus, substituting we get that Yi \u2296 Yj \u2286 X0 \u2296 Xj implies that X0 \u2296Xj \u2286 Yi \u2296 Yj .\nBut this means that \u3008X0, X\u3009 \u2208 Minb(SE (\u3008\u2205,\u03a8\u3009)).\nFor the proof of the theorem, we have:\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nLet X \u2208 SE (\u2207(\u03a8)). Then, X \u2208 \u22c3\nMina(SE (\u03a8)); that is, there is some X such that X \u2208 X and X \u2208 Mina(SE (\u03a8)). But by Lemma 5 we then have that \u3008X,X\u3009 \u2208 Minb(SE (\u3008\u2205,\u03a8\u3009)). Hence, X \u2208 Minb(SE (\u3008\u2205,\u03a8\u3009)0) and so X \u2208 SE (\u2206(\u3008\u2205,\u03a8\u3009))."}, {"heading": "A.11 Proof of Theorem 12", "text": "These results follow directly from the appropriate definitions."}], "references": [], "referenceMentions": [], "year": 2009, "abstractText": "We address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs. We first consider belief revision: given logic programs P and Q, the goal is to determine a program R that corresponds to the revision of P by Q, denoted P \u2217 Q. We investigate several specific operators, including (logic program) expansion and two revision operators based on the distance between the SE models of logic programs. It proves to be the case that expansion is an interesting operator in its own right, unlike in classical AGM-style belief revision where it is relatively uninteresting. Expansion and revision are shown to satisfy a suite of interesting properties; in particular, our revision operators satisfy the majority of the AGM postulates for revision. Second, we consider approaches for merging logic programs. Given logic programs P1, . . . , Pn, the goal is to provide characterisations of the merging of these programs. Again, our formal techniques are based on notions of relative distance between the underlying SE models of the logic programs. Two approaches are examined. The first informally selects those models of the programs that vary the least from the models of the other programs. The second approach informally selects those models of a program P0 that are closest to the models of programs P1, . . . , Pn. In this case, P0 can be thought of as analogous to a set of database integrity constraints. We examine properties of these operators with regards to how they satisfy relevant postulate sets. We also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.", "creator": "dvips(k) 5.95a Copyright 2005 Radical Eye Software"}}}