{"id": "1007.2049", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Jul-2010", "title": "Reinforcement Learning via AIXI Approximation", "abstract": "this paper introduces a principled approach for the knowledge of a scalable general weighted learning agent. this treatment is based on a direct approximation of aixi, a bayesian optimality notion for general reinforcement learning activity. previously, it has been unclear whether the theory of complexity could motivate the complexity of practical algorithms. we answer this hitherto open question in the area, by providing these first computationally feasible approximation to the aixi agent. to demonstrate our reasoning, we introduce a via carlo tree search algorithm along with an agent - specific extension of the context tree weighting algorithm. systematically, we present a set of random results on a number of stochastic, unknown, and partly observable domains.", "histories": [["v1", "Tue, 13 Jul 2010 08:48:18 GMT  (34kb)", "http://arxiv.org/abs/1007.2049v1", "8 LaTeX pages, 1 figure"]], "COMMENTS": "8 LaTeX pages, 1 figure", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["joel veness", "kee siong ng", "marcus hutter", "david silver"], "accepted": true, "id": "1007.2049"}, "pdf": {"name": "1007.2049.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["joelv@cse.unsw.edu.au", "keesiong.ng@gmail.com", "marcus.hutter@anu.edu.au", "davidstarsilver@googlemail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n00 7.\n20 49\nv1 [\ncs .L\nG ]\n1 3\nJu l 2\n01 0\nContents"}, {"heading": "1 Introduction 1", "text": ""}, {"heading": "2 The Agent Setting 1", "text": ""}, {"heading": "3 Bayesian Agents 2", "text": ""}, {"heading": "4 Monte Carlo Expectimax Approximation 3", "text": ""}, {"heading": "5 Action-Conditional CTW 4", "text": ""}, {"heading": "6 Theoretical Results 6", "text": ""}, {"heading": "7 Experimental Results 6", "text": ""}, {"heading": "8 Related Work 7", "text": ""}, {"heading": "9 Limitations 8", "text": ""}, {"heading": "10 Conclusion 8", "text": ""}, {"heading": "11 Acknowledgements 8", "text": "Keywords: Reinforcement Learning (RL); Context Tree Weighting (CTW); Monte Carlo Tree Search (MCTS); Upper Confidence bounds applied to Trees (UCT); Partially Observable Markov Decision Process (POMDP); Prediction Suffix Trees (PST)."}, {"heading": "1 Introduction", "text": "Consider an agent that exists within some unknown environment. The agent interacts with the environment in cycles. At each cycle, the agent executes an action and receives in turn an observation and a reward. The general reinforcement learning problem is to construct an agent that, over time, collects as much reward as possible from an initially unknown environment.\nThe AIXI agent [Hut05] is a formal, mathematical solution to the general reinforcement learning problem. It can be decomposed into two main components: planning and prediction. Planning amounts to performing an expectimax operation to determine each action. Prediction uses Bayesian model averaging, over the largest possible model class expressible on a Turing Machine, to predict future observations and rewards based on past experience. AIXI is shown in [Hut05] to be optimal in the sense that it will rapidly learn an accurate model of the unknown environment and exploit it to maximise its expected future reward.\nAs AIXI is only asymptotically computable, it is by no means an algorithmic solution to the general reinforcement learning problem. Rather it is best understood as a Bayesian optimality notion for decision making in general unknown environments. This paper demonstrates, for the first time, how a practical agent can be built from the AIXI theory. Our solution directly approximates the planning and prediction components of AIXI. In particular, we use a generalisation of UCT [KS06] to approximate the expectimax operation, and an agent-specific extension of CTW [WST95], a Bayesian model averaging algorithm for prediction suffix trees, for prediction and learning. Perhaps surprisingly, this kind of direct approximation is possible, practical and theoretically appealing. Importantly, the essential characteristic of AIXI, its generality, can be largely preserved."}, {"heading": "2 The Agent Setting", "text": "This section introduces the notation and terminology we will use to describe strings of agent experience, the true underlying environment and the agent\u2019s model of the environment.\nThe (finite) action, observation, and reward spaces are denoted by A,O, and R respectively. An observationreward pair or is called a percept. We use X to denote the percept space O \u00d7 R.\nDefinition 1 A history h is an element of (A \u00d7 X)\u2217 \u222a (A \u00d7 X)\u2217 \u00d7A.\nNotation: A string x1x2 . . . xn of length n is denoted by x1:n. The empty string is denoted by \u01eb. The concatenation of two\nstrings s and r is denoted by sr. The prefix x1: j of x1:n, j \u2264 n, is denoted by x\u2264 j or x< j+1. The notation generalises for blocks of symbols: e.g. ax1:n denotes a1x1a2x2 . . .anxn and ax< j denotes a1x1a2x2 . . . a j\u22121x j\u22121.\nThe following definition states that the environment takes the form of a probability distribution over possible percept sequences conditioned on actions taken by the agent.\nDefinition 2 An environment \u03c1 is a sequence of conditional probability functions {\u03c10, \u03c11, \u03c12, . . . }, where \u03c1n : An \u2192 Density (Xn), that satisfies\n\u2200a1:n\u2200x<n : \u03c1n\u22121(x<n | a<n) = \u2211\nxn\u2208X\n\u03c1n(x1:n | a1:n). (1)\nIn the base case, we have \u03c10(\u01eb | \u01eb) = 1.\nEquation 1, called the chronological condition in [Hut05], captures the natural constraint that action an has no effect on observations made before it. For convenience, we drop the index n in \u03c1n from here onwards.\nGiven an environment \u03c1,\n\u03c1(xn | ax<nan) := \u03c1(x1:n | a1:n) \u03c1(x<n | a<n)\n(2)\nis the \u03c1-probability of observing xn in cycle n given history h = ax<nan, provided \u03c1(x<n | a<n) > 0. It now follows that\n\u03c1(x1:n | a1:n) = \u03c1(x1 | a1)\u03c1(x2 | ax1a2) \u00b7 \u00b7 \u00b7\u03c1(xn | ax<nan). (3)\nDefinition 2 is used to describe both the true (but unknown) underlying environment and the agent\u2019s subjective model of the environment. The latter is called the agent\u2019s environment model and is typically learnt from data. Definition 2 is extremely general. It captures a wide variety of environments, including standard reinforcement learning setups such as MDPs and POMDPs.\nThe agent\u2019s goal is to accumulate as much reward as it can during its lifetime. More precisely, the agent seeks a policy that will allow it to maximise its expected future reward up to a fixed, finite, but arbitrarily large horizon m \u2208 N. Formally, a policy is a function that maps a history to an action. The expected future value of an agent acting under a particular policy is defined as follows.\nDefinition 3 Given history ax1:t, the m-horizon expected future reward of an agent acting under policy \u03c0 : (A \u00d7 X)\u2217 \u2192 A with respect to an environment \u03c1 is\nvm\u03c1 (\u03c0, ax1:t) := Ext+1:t+m\u223c\u03c1\n       t+m \u2211\ni=t+1\nRi(ax\u2264t+m)\n       , (4)\nwhere for t + 1 \u2264 k \u2264 t + m, ak := \u03c0(ax<k), and Rk(aor\u2264t+m) := rk. The quantity vm\u03c1 (\u03c0, ax1:tat+1) is defined similarly, except that at+1 is now no longer defined by \u03c0.\nThe optimal policy \u03c0\u2217 is the policy that maximises the expected future reward. The maximal achievable expected future reward of an agent with history h in environment \u03c1 looking m steps ahead is Vm\u03c1 (h) := v m \u03c1 (\u03c0\n\u2217, h). It is easy to see that if h \u2261 ax1:t \u2208 (A\u00d7 X)t, then\nVm\u03c1 (h) = maxat+1\n\u2211\nxt+1\n\u03c1(xt+1 | hat+1) \u00b7 \u00b7 \u00b7max at+m\n\u2211\nxt+m\n\u03c1(xt+m | haxt+1:t+m\u22121at+m)\n       t+m \u2211\ni=t+1\nri\n       . (5)\nWe will refer to Equation 5 as the expectimax operation. The m-horizon optimal action a\u2217t+1 at time t + 1 is related to the expectimax operation by\na\u2217t+1 = arg maxat+1 Vm\u03c1 (ax1:tat+1) (6)\nEqs 4 and 5 can be modified to handle discounted reward, however we focus on the finite-horizon case since it both aligns with AIXI and allows for a simplified presentation."}, {"heading": "3 Bayesian Agents", "text": "In the general reinforcement learning setting, the environment \u03c1 is unknown to the agent. One way to learn an environment model is to take a Bayesian approach. Instead of committing to any single environment model, the agent uses a mixture of environment models. This requires committing to a class of possible environments (the model class), assigning an initial weight to each possible environment (the prior), and subsequently updating the weight for each model using Bayes rule (computing the posterior) whenever more experience is obtained.\nThe above procedure is similar to Bayesian methods for predicting sequences of (singly typed) observations. The key difference in the agent setup is that each prediction is now also dependent on previous agent actions. We incorporate this by using the action-conditional definitions and identities of Section 2.\nDefinition 4 Given a model class M := {\u03c11, \u03c12, . . . } and a prior weight w\u03c10 > 0 for each \u03c1 \u2208 M such that \u2211\n\u03c1\u2208M w \u03c1\n0 = 1, the mixture environment model is \u03be(x1:n | a1:n) := \u2211\n\u03c1\u2208M\nw\u03c10\u03c1(x1:n | a1:n).\nThe next result follows immediately.\nProposition 1 A mixture environment model is an environment model.\nProposition 1 allows us to use a mixture environment model whenever we can use an environment model. Its importance will become clear shortly.\nTo make predictions using a mixture environment model \u03be, we use\n\u03be(xn | ax<nan) = \u03be(x1:n | a1:n) \u03be(x<n | a<n) , (7)\nwhich follows from Proposition 1 and Eq. 2. The RHS of Eq. 7 can be written out as a convex combination of model predictions to give\n\u03be(xn | ax<nan) = \u2211\n\u03c1\u2208M\nw\u03c1n\u22121\u03c1(xn | ax<nan), (8)\nwhere the posterior weight w\u03c1n\u22121 for \u03c1 is given by\nw\u03c1n\u22121 := w\u03c10\u03c1(x<n | a<n) \u2211\n\u00b5\u2208M\nw\u00b50\u00b5(x<n | a<n) = Pr(\u03c1 | ax<n). (9)\nBayesian agents enjoy a number of strong theoretical performance guarantees; these are explored in Section 6. In practice, the main difficulty in using a mixture environment model is computational. A rich model class is required if the mixture environment model is to possess general prediction capabilities, however naively using (8) for online prediction requires at least O(|M|) time to process each new piece of experience. One of our main contributions, introduced in Section 5, is a large, efficiently computable mixture environment model that runs in time O(log(log |M|)). Before looking at that, we will examine in the next section a Monte Carlo Tree Search algorithm for approximating the expectimax operation."}, {"heading": "4 Monte Carlo Expectimax Approximation", "text": "Full-width computation of the expectimax operation (5) takes O(|A\u00d7X|m) time, which is unacceptable for all but tiny values of m. This section introduces \u03c1UCT, a generalisation of the popular UCT algorithm [KS06] that can be used to approximate a finite horizon expectimax operation given an environment model \u03c1. The key idea of Monte Carlo search is to sample observations from the environment, rather than exhaustively considering all possible observations. This allows for effective planning in environments with large observation spaces. Note that since an environment model subsumes both MDPs and POMDPs, \u03c1UCT effectively extends the UCT algorithm to a wider class of problem domains.\nThe UCT algorithm has proven effective in solving large discounted or finite horizon MDPs. It assumes a generative model of the MDP that when given a state-action pair (s, a) produces a subsequent state-reward pair (s\u2032, r) distributed according to Pr(s\u2032, r | s, a). By successively sampling trajectories through the state space, the UCT algorithm incrementally constructs a search tree, with each node containing an estimate of the value of each state. Given enough time, these estimates converge to the true values.\nThe \u03c1UCT algorithm can be realised by replacing the notion of state in UCT by an agent history h (which is always a sufficient statistic) and using an environment model \u03c1(or | h)\nto predict the next percept. The main subtlety with this extension is that the history used to determine the conditional probabilities must be updated during the search to reflect the extra information an agent will have at a hypothetical future point in time.\nWe will use \u03a8 to represent all the nodes in the search tree, \u03a8(h) to represent the node corresponding to a particular history h, V\u0302m\u03c1 (h) to represent the sample-based estimate of the expected future reward, and T (h) to denote the number of times a node \u03a8(h) has been sampled. Nodes corresponding to histories that end or do not end with an action are called chance and decision nodes respectively.\nAlgorithm 1 describes the top-level algorithm, which the agent calls at the beginning of each cycle. It is initialised with the agent\u2019s total experience h (up to time t) and the planning horizon m. It repeatedly invokes the Sample routine until out of time. Importantly, \u03c1UCT is an anytime algorithm; an approximate best action, whose quality improves with time, is always available. This is retrieved by BestAction, which computes a\u2217t = arg maxat V\u0302m\u03c1 (ax<tat).\nAlgorithm 1 \u03c1UCT(h,m) Require: A history h Require: A search horizon m \u2208 N\n1: Initialise(\u03a8) 2: repeat 3: Sample(\u03a8, h,m) 4: until out of time 5: return BestAction(\u03a8, h)\nAlgorithm 2 describes the recursive routine used to sample a single future trajectory. It uses the SelectAction routine to choose moves at interior nodes, and invokes the Rollout routine at unexplored leaf nodes. The Rollout routine picks actions uniformly at random until the (remaining) horizon is reached, returning the accumulated reward. After a complete trajectory of length m is simulated, the value estimates are updated for each node traversed. Notice that the recursive calls on Lines 6 and 11 append the most recent percept or action to the history argument.\nAlgorithm 3 describes the UCB [Aue02] policy used to select actions at decision nodes. The \u03b1 and \u03b2 constants denote the smallest and largest elements of R respectively. The parameter C varies the selectivity of the search; larger values grow bushier trees. UCB automatically focuses attention on the best looking action in such a way that the sample estimate V\u0302\u03c1(h) converges to V\u03c1(h), whilst still exploring alternate actions sufficiently often to guarantee that the best action will be found.\nThe ramifications of the \u03c1UCT extension are particularly significant to Bayesian agents described in Section 3. Proposition 1 allows \u03c1UCT to be instantiated with a mixture environment model, which directly incorporates\nAlgorithm 2 Sample(\u03a8, h,m) Require: A search tree \u03a8 Require: A history h Require: A remaining search horizon m \u2208 N\n1: if m = 0 then 2: return 0 3: else if \u03a8(h) is a chance node then 4: Generate (o, r) from \u03c1(or | h) 5: Create node \u03a8(hor) if T (hor) = 0 6: reward \u2190 r + Sample(\u03a8, hor,m \u2212 1) 7: else if T (h) = 0 then 8: reward \u2190 Rollout(h,m) 9: else\n10: a \u2190 SelectAction(\u03a8, h,m) 11: reward \u2190 Sample(\u03a8, ha,m) 12: end if 13: V\u0302(h) \u2190 1T (h)+1 [reward + T (h)V\u0302(h)] 14: T (h) \u2190 T (h) + 1 15: return reward\nmodel uncertainty into the planning process. This gives (in principle, provided that the model class contains the true environment and ignoring issues of limited computation) the well known Bayes-optimal solution to the exploration/exploitation dilemma; namely, if a reduction in model uncertainty would lead to higher expected future reward, \u03c1UCT would recommend an information gathering action.\nAlgorithm 3 SelectAction(\u03a8, h,m) Require: A search tree \u03a8 Require: A history h Require: A remaining search horizon m \u2208 N Require: An exploration/exploitation constant C > 0\n1: U = {a \u2208 A : T (ha) = 0} 2: if U , {} then 3: Pick a \u2208 U uniformly at random 4: Create node \u03a8(ha) 5: return a 6: else 7: return arg max\na\u2208A\n{\n1 m(\u03b2\u2212\u03b1) V\u0302(ha) + C\n\u221a\nlog(T (h)) T (ha)\n}\n8: end if"}, {"heading": "5 Action-Conditional CTW", "text": "We now introduce a large mixture environment model for use with \u03c1UCT. Context Tree Weighting (CTW) [WST95] is an efficient and theoretically well-studied binary sequence prediction algorithm that works well in practice. It is an online Bayesian model averaging algorithm that com-\nputes, at each time point t, the probability\nPr(y1:t) = \u2211\nM\nPr(M) Pr(y1:t | M), (10)\nwhere y1:t is the binary sequence seen so far, M is a prediction suffix tree [RST96], Pr(M) is the prior probability of M, and the summation is over all prediction suffix trees of bounded depth D. A naive computation of (10) takes time O(22 D ); using CTW, this computation requires only O(D) time. In this section, we outline how CTW can be extended to compute probabilities of the form\nPr(x1:t | a1:t) = \u2211\nM\nPr(M) Pr(x1:t | M, a1:t), (11)\nwhere x1:t is a percept sequence, a1:t is an action sequence, and M is a prediction suffix tree as in (10). This extension allows CTW to be used as a mixture environment model (Definition 4) in the \u03c1UCT algorithm, where we combine (11) and (2) to predict the next percept given a history.\nKrichevsky-Trofimov Estimator. We start with a brief review of the KT estimator for Bernoulli distributions. Given a binary string y1:t with a zeroes and b ones, the KT estimate of the probability of the next symbol is given by\nPrkt(Yt+1 = 1 | y1:t) := b + 1/2\na + b + 1 . (12)\nThe KT estimator can be obtained via a Bayesian analysis by putting an uninformative (Jeffreys Beta(1/2,1/2)) prior Pr(\u03b8) \u221d \u03b8\u22121/2(1 \u2212 \u03b8)\u22121/2 on the parameter \u03b8 \u2208 [0, 1] of the Bernoulli distribution. The probability of a string y1:t is given by\nPrkt(y1:t) = Prkt(y1 | \u01eb)Prkt(y2 | y1) \u00b7 \u00b7 \u00b7Prkt(yt | y<t)\n= \u222b \u03b8b(1 \u2212 \u03b8)a Pr(\u03b8) d\u03b8.\nPrediction Suffix Trees. We next describe prediction suffix trees. We consider a binary tree where all the left edges are labelled 1 and all the right edges are labelled 0. The depth of a binary tree M is denoted by d(M). Each node in M can be identified by a string in {0, 1}\u2217 as usual: \u01eb represents the root node of M; and if n \u2208 {0, 1}\u2217 is a node in M, then n1 and n0 represent respectively the left and right children of node n. The set of M\u2019s leaf nodes is denoted by L(M) \u2282 {0, 1}\u2217. Given a binary string y1:t where t \u2265 d(M), we define M(y1:t) := ytyt\u22121 . . . yt\u2032 , where t\u2032 \u2264 t is the (unique) positive integer such that ytyt\u22121 . . . yt\u2032 \u2208 L(M).\nDefinition 5 A prediction suffix tree (PST) is a pair (M,\u0398), where M is a binary tree and associated with each l \u2208 L(M) is a distribution over {0, 1} parameterised by \u03b8l \u2208 \u0398. We call M the model of the PST and \u0398 the parameter of the PST.\nA PST (M,\u0398) maps each binary string y1:t, t \u2265 d(M), to \u03b8M(y1:t); the intended meaning is that \u03b8M(y1:t) is the probability that the next bit following y1:t is 1. For example, the PST in Figure 1 maps the string 1110 to \u03b8M(1110) = \u03b801 = 0.3, which means the next bit after 1110 is 1 with probability 0.3.\nAction-Conditional PST. In the agent setting, we reduce the problem of predicting history sequences with general non-binary alphabets to that of predicting the bit representations of those sequences. Further, we only ever condition on actions; this is achieved by appending bit representations of actions to the input sequence without updating the PST parameters.\nAssume |X| = 2lX for some lX > 0. Denote by ~x = x[1, lX] = x[1]x[2] . . . x[lX] the bit representation of x \u2208 X. Denote by ~x1:t = ~x1 ~x2 . . . ~xt the bit representation of a sequence x1:t. Action symbols are treated similarly.\nTo do action-conditional sequence prediction using a PST with a given model M but unknown parameter, we start with \u03b8l := Prkt(1 | \u01eb) = 1/2 at each l \u2208 L(M). We set aside an initial portion of the binary history sequence to initialise the variable h and then repeat the following steps as long as needed:\n1. set h := h~a , where a is the current selected action;\n2. for i := 1 to lX do\n(a) predict the next bit using the distribution \u03b8M(h);\n(b) observe the next bit x[i], update \u03b8M(h) using (12) according to the value of x[i], and then set h := hx[i].\nLet M be the model of a prediction suffix tree, a1:t an action sequence, x1:t a percept sequence, and h := ~ax1:t . For each node n in M, define hM,n by\nhM,n := hi1 hi2 \u00b7 \u00b7 \u00b7 hik (13)\nwhere 1 \u2264 i1 < i2 < \u00b7 \u00b7 \u00b7 < ik \u2264 t and, for each i, i \u2208 {i1, i2, . . . ik} iff hi is a percept bit and n is a prefix of M(h1:i\u22121). We have the following expression for the probability of x1:t given M and a1:t:\nPr(x1:t | M, a1:t) = t \u220f\ni=1\nlX \u220f\nj=1\nPr(xi[ j] | M, ~ax<iai xi[1, j \u2212 1])\n= \u220f\nn\u2208L(M)\nPrkt(hM,n). (14)\nContext Tree Weighting. The above deals with actionconditional prediction using a single PST. We now show how we can efficiently perform action-conditional prediction using a Bayesian mixture of PSTs. There are two main computational tricks: the use of a data structure to represent all PSTs of a certain maximum depth and the use of probabilities of sequences in place of conditional probabilities.\nDefinition 6 A context tree of depth D is a perfect binary tree of depth D such that attached to each node (both internal and leaf) is a probability on {0, 1}\u2217.\nThe weighted probability Pnw of each node n in the context tree T after seeing h := ~ax1:t is defined as follows:\nPnw :=\n      \nPrkt(hT,n) if n is a leaf node; 1 2 Prkt(hT,n) + 1 2 P n0 w \u00d7 P n1 w otherwise.\nThe following is a straightforward extension of a result due to [WST95].\nLemma 1 Let T be the depth-D context tree after seeing h := ~ax1:t . For each node n in T at depth d, we have\nPnw = \u2211\nM\u2208CD\u2212d\n2\u2212\u0393D\u2212d (M) \u220f\nl\u2208L(M)\nPrkt(hT,nl), (15)\nwhere Cd is the set of all models of PSTs with depth \u2264 d, and \u0393d(M) is the code-length for M given by the number of nodes in M minus the number of leaf nodes in M of depth d.\nA corollary of Lemma 1 is that at the root node \u01eb of the context tree T after seeing h := ~ax1:t , we have\nP\u01ebw(x1:t|a1:t) = \u2211\nM\u2208CD\n2\u2212\u0393D(M) \u220f\nl\u2208L(M)\nPrkt(hT,l) (16)\n= \u2211\nM\u2208CD\n2\u2212\u0393D(M) \u220f\nl\u2208L(M)\nPrkt(hM,l) (17)\n= \u2211\nM\u2208CD\n2\u2212\u0393D(M) Pr(x1:t | M, a1:t), (18)\nwhere the last step follows from (14). Notice that the prior 2\u2212\u0393D(\u00b7) penalises PSTs with large tree structures. The conditional probability of xt given ax<tat can be obtained from (2). We can also efficiently sample the individual bits of xt one by one.\nComputational Complexity. The Action-Conditional CTW algorithm grows the context tree dynamically. Using a context tree with depth D, there are at most O(tD log(|O||R|)) nodes in the context tree after t cycles. In practice, this is a lot less than 2D, the number of nodes in a fully grown context tree. The time complexity of Action-Conditional CTW is also impressive, requiring O(D log(|O||R|)) time to process each new piece of agent experience and O(mD log(|O||R|)) to sample a single trajectory when combined with \u03c1UCT. Importantly, this is independent of t, which means that the computational overhead does not increase as the agent gathers more experience."}, {"heading": "6 Theoretical Results", "text": "Putting the \u03c1UCT and Action-Conditional CTW algorithms together yields our approximate AIXI agent. We now investigate some of its properties.\nModel Class Approximation. By instantiating (5) with the mixture environment model (18), one can show that the optimal action for an agent at time t, having experienced ax<t, is given by\narg max at\n\u2211\nxt\n\u00b7 \u00b7 \u00b7max at+m\n\u2211\nxt+m\n       t+m \u2211\ni=t\nri\n       \u2211\nM\u2208CD\n2\u2212\u0393D(\u03c1) Pr(x1:t+m | M, a1:t+m).\nCompare this to the action chosen by the AIXI agent\narg max at\n\u2211\nxt\n. . .max at+m\n\u2211\nxt+m\n       t+m \u2211\ni=t\nri\n       \u2211\n\u03c1\u2208M\n2\u2212K(\u03c1)\u03c1(x1:t+m | a1:t+m),\nwhere class M consists of all computable environments \u03c1 and K(\u03c1) denotes the Kolmogorov complexity of \u03c1. Both use a prior that favours simplicity. The main difference is in the subexpression describing the mixture over the model class. AIXI uses a mixture over all enumerable chronological semimeasures, which is completely general but incomputable. Our approximation uses a mixture of all prediction suffix trees of a certain maximum depth, which is still a rather general class, but one that is efficiently computable.\nConsistency of \u03c1UCT. [KS06] shows that the UCT algorithm is consistent in finite horizon MDPs and derive finite sample bounds on the estimation error due to sampling. By interpreting histories as Markov states, the general reinforcement learning problem reduces to a finite horizon MDP and the results of [KS06] are now directly applicable. Restating the main consistency result in our notation, we have\n\u2200\u01eb\u2200h lim T (h)\u2192\u221e\nPr ( |Vm\u03c1 (h) \u2212 V\u0302 m \u03c1 (h)| \u2264 \u01eb ) = 1. (19)\nFurthermore, the probability that a suboptimal action (with respect to Vm\u03c1 (\u00b7)) is chosen by \u03c1UCT goes to zero in the limit.\nConvergence to True Environment. The next result, adapted from [Hut05], shows that if there is a good model of the (unknown) environment in CD, then Action-Conditional CTW will predict well.\nTheorem 1 Let \u00b5 be the true environment, and \u03a5 \u2261 P\u01ebw the mixture environment model formed from (18). The \u00b5expected squared difference of \u00b5 and \u03a5 is bounded as fol-\nlows. For all n \u2208 N, for all a1:n,\nn \u2211\nk=1\n\u2211\nx<k\n\u00b5(x<k | a<k) \u2211\nxk\n( \u00b5(xk | ax<kak) \u2212 \u03a5(xk | ax<kak) )2\n\u2264 min M\u2208CD\n{ \u0393D(M) ln 2 + KL(\u00b5(\u00b7 | a1:n) \u2016 Pr(\u00b7 | M, a1:n)) } ,\n(20)\nwhere KL(\u00b7 \u2016 \u00b7) is the KL divergence of two distributions.\nIf the RHS of (20) is finite over all n, then the sum on the LHS can only be finite if \u03a5 converges sufficiently fast to \u00b5. If KL grows sublinear in n, then \u03a5 still converges to \u00b5 (in a weaker Cesaro sense), which is for instance the case for all k-order Markov and all stationary processes \u00b5.\nOverall Result. Theorem 1 above in conjunction with [Hut05, Thm.5.36] imply Vm\n\u03a5 (h) converges to Vm\u00b5 (h) as long\nas there exists a model in the model class that approximates the unknown environment \u00b5 well. This, and the consistency (19) of the \u03c1UCT algorithm, imply that V\u0302m\n\u03a5 (h) converges to\nVm\u00b5 (h). More detail can be found in [VNHS09]."}, {"heading": "7 Experimental Results", "text": "This section evaluates our approximate AIXI agent on a variety of test domains. The Cheese Maze, 4x4 Grid and Extended Tiger domains are taken from the POMDP literature. The TicTacToe domain comprises a repeated series of games against an opponent who moves randomly. The Biased RockPaperScissor domain is described in [FMWR07], which involves the agent repeatedly playing RockPaperScissor against an exploitable opponent. Two more challenging domains are included: Kuhn Poker [HSHB05], where the agent plays second against a Nash optimal player and a partially observable version of Pacman described in [VNHS09]. With the exception of Pacman, each domain has a known optimal solution. Although our domains are modest, requiring the agent to learn the environment from scratch significantly increases the difficulty of each of these problems.\nTable 1 outlines the parameters used in each experiment. The sizes of the action and observation spaces are given,\nalong with the number of bits used to encode each space. The context depth parameter D specifies the maximal number of recent bits used by the Action-Conditional CTW prediction scheme. The search horizon is given by the parameter m. Larger D and m increase the capabilities of our agent, at the expense of linearly increasing computation time; our values represent an appropriate compromise between these two competing dimensions for each problem domain.\nFigure 2 shows how the performance of the agent scales with experience, measured in terms of number of interaction cycles. Experience was gathered by a decaying \u01ebgreedy policy, which chose randomly or used \u03c1UCT. The results are normalised with respect to the optimal average reward per time step, except in Pacman, where we normalised to an estimate. Each data point was obtained by starting the agent with an amount of experience given by the x-axis and running it greedily for 2000 cycles. The amount of search used for each problem domain, measured by the number of \u03c1UCT simulations per cycle, is given in Table 2. (The average search time per cycle is also given.) The agent converges to optimality on all the test domains with known optimal values, and exhibits good scaling properties on our challenging Pacman variant. Visual inspection1 of Pacman shows that the agent, whilst not playing perfectly, has already learnt a number of important concepts.\nTable 2 summarises the resources required for approximately optimal performance on our test domains. Timing statistics were collected on an Intel dual 2.53Ghz Xeon. Domains that included a planning component such as Tiger required more search. Convergence was somewhat slower in TicTacToe; the main difficulty for the agent was learning not to lose the game immediately by playing an illegal move. Most impressive was that the agent learnt to play an approximate best response strategy for Kuhn Poker, without knowing the rules of the game or the opponent\u2019s strategy.\n1http://www.youtube.com/watch?v=RhQTWidQQ8U"}, {"heading": "8 Related Work", "text": "The BLHT algorithm [SH99] is closely related to our work. It uses symbol level PSTs for learning and an (unspecified) dynamic programming based algorithm for control. BLHT uses the most probable model for prediction, whereas we use a mixture model, which admits a much stronger convergence result. A further distinction is our usage of an Ockham prior instead of a uniform prior over PST models.\nThe Active-LZ [FMWR07] algorithm combines a Lempel-Ziv based prediction scheme with dynamic programming for control to produce an agent that is provably asymptotically optimal if the environment is n-Markov. We implemented the Active-LZ test domain, Biased RPS, and compared against their published results. Our agent was able to achieve optimal levels of performance within 106 cycles; in contrast, Active-LZ was still suboptimal after 108 cycles. U-Tree [McC96] is an online agent algorithm that attempts to discover a compact state representation from a raw stream of experience. Each state is represented as the leaf of a suffix tree that maps history sequences to states. As more experience is gathered, the state representation is refined according to a heuristic built around the KolmogorovSmirnov test. This heuristic tries to limit the growth of the suffix tree to places that would allow for better prediction of future reward. Value Iteration is used at each time step to update the value function for the learned state representation, which is then used by the agent for action selection.\nIt is instructive to compare and contrast our AIXI approximation with the Active-LZ and U-Tree algorithms. The small state space induced by U-Tree has the benefit of limiting the number of parameters that need to be estimated from data. This has the potential to dramatically speed up the model-learning process. In contrast, both Active-LZ and our approach require a number of parameters proportional to the number of distinct contexts. This is one of the reasons why Active-LZ exhibits slow convergence in practice. This problem is much less pronounced in our approach for two reasons. First, the Ockham prior in CTW ensures that future predictions are dominated by PST structures that have seen enough data to be trustworthy. Secondly, value function estimation is decoupled from the process of context estimation. Thus it is reasonable to expect \u03c1UCT to make good local decisions provided ActionConditional CTW can predict well. The downside however\nis that our approach requires search for action selection. Although \u03c1UCT is an anytime algorithm, in practice more computation is required per cycle compared to approaches like Active-LZ and U-Tree that act greedily with respect to an estimated global value function.\nThe U-Tree algorithm is well motivated, but unlike Active-LZ and our approach, it lacks theoretical performance guarantees. It is possible for U-Tree to prematurely converge to a locally optimal state representation from which the heuristic splitting criterion can never recover. Furthermore, the splitting heuristic contains a number of configuration options that can dramatically influence its performance [McC96]. This parameter sensitivity somewhat limits the algorithm\u2019s applicability to the general reinforcement learning problem.\nOur work is also related to Bayesian Reinforcement Learning. In model-based Bayesian RL [PV08, Str00], a distribution over (PO)MDP parameters is maintained. In contrast, we maintain an exact Bayesian mixture of PSTs. The \u03c1UCT algorithm shares similarities with Bayesian Sparse Sampling [WLBS05]; the key differences are estimating the leaf node values with a rollout function and guiding the search with the UCB policy.\nA more comprehensive discussion of related work can be found in [VNHS09]."}, {"heading": "9 Limitations", "text": "The main limitation of our current AIXI approximation is the restricted model class. Our agent will perform poorly if the underlying environment cannot be predicted well by a PST of bounded depth. Prohibitive amounts of experience will be required if a large PST model is needed for accurate prediction. For example, it would be unrealistic to think that our current AIXI approximation could cope with real-world image or audio data.\nThe identification of efficient and general model classes that better approximate the AIXI ideal is an important area for future work. Some preliminary ideas are explored in [VNHS09]."}, {"heading": "10 Conclusion", "text": "We have introduced the first computationally tractable approximation to the AIXI agent and shown that it provides a promising approach to the general reinforcement learning problem. Investigating multi-alphabet CTW for prediction, parallelisation of \u03c1UCT, further expansion of the model class (ideally, beyond variable-order Markov models) or more sophisticated rollout policies for \u03c1UCT are exciting areas for future investigation."}, {"heading": "11 Acknowledgements", "text": "This work received support from the Australian Research Council under grant DP0988049. NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program."}], "references": [{"title": "JMLR", "author": ["Peter Auer. Using confidence bounds for exploitation-exploration trade-offs"], "venue": "3:397\u2013422,", "citeRegEx": "Aue02", "shortCiteRegEx": null, "year": 2002}, {"title": "Universal Reinforcement Learning", "author": ["V. Farias", "C. Moallemi", "T. Weissman", "B. Van Roy"], "venue": "CoRR, abs/0707.3087", "citeRegEx": "FMWR07", "shortCiteRegEx": null, "year": 2007}, {"title": "In AAAI\u201905", "author": ["Bret Hoehn", "Finnegan Southey", "Robert C. Holte", "Valeriy Bulitko. Effective short-term opponent exploitation in simplified poker"], "venue": "pages 783\u2013788,", "citeRegEx": "HSHB05", "shortCiteRegEx": null, "year": 2005}, {"title": "Universal Artificial Intelligence: Sequential Decisions Based on Algorithmic Probability", "author": ["Marcus Hutter"], "venue": "Springer,", "citeRegEx": "Hut05", "shortCiteRegEx": null, "year": 2005}, {"title": "In ECML", "author": ["Levente Kocsis", "Csaba Szepesv\u00e1ri. Bandit based Monte-Carlo planning"], "venue": "pages 282\u2013293,", "citeRegEx": "KS06", "shortCiteRegEx": null, "year": 2006}, {"title": "PhD thesis", "author": ["Andrew Kachites McCallum. Reinforcement Learning with Selective Perception", "Hidden State"], "venue": "University of Rochester,", "citeRegEx": "McC96", "shortCiteRegEx": null, "year": 1996}, {"title": "Model-based Bayesian Reinforcement Learning in Partially Observable Domains", "author": ["Pascal Poupart", "Nikos Vlassis"], "venue": "ISAIM,", "citeRegEx": "PV08", "shortCiteRegEx": null, "year": 2008}, {"title": "The power of amnesia: Learning probabilistic automata with variable memory length", "author": ["D. Ron", "Y. Singer", "N. Tishby"], "venue": "Machine Learning, 25(2):117\u2013150", "citeRegEx": "RST96", "shortCiteRegEx": null, "year": 1996}, {"title": "In NIPS", "author": ["Nobuo Suematsu", "Akira Hayashi. A reinforcement learning algorithm in partially observable environments using short-term memory"], "venue": "pages 1059\u2013 1065,", "citeRegEx": "SH99", "shortCiteRegEx": null, "year": 1999}, {"title": "A Bayesian framework for reinforcement learning", "author": ["M. Strens"], "venue": "ICML, pages 943\u2013950", "citeRegEx": "Str00", "shortCiteRegEx": null, "year": 2000}, {"title": "CoRR", "author": ["Joel Veness", "Kee Siong Ng", "Marcus Hutter", "David Silver. A Monte Carlo AIXI Approximation"], "venue": "abs/0909.0801,", "citeRegEx": "VNHS09", "shortCiteRegEx": null, "year": 2009}, {"title": "Bayesian sparse sampling for on-line reward optimization", "author": ["T. Wang", "D.J. Lizotte", "M.H. Bowling", "D. Schuurmans"], "venue": "ICML, pages 956\u2013963", "citeRegEx": "WLBS05", "shortCiteRegEx": null, "year": 2005}, {"title": "The Context Tree Weighting Method: Basic Properties", "author": ["Frans M.J. Willems", "Yuri M. Shtarkov", "Tjalling J. Tjalkens"], "venue": "IEEE Transactions on Information Theory, 41:653\u2013664,", "citeRegEx": "WST95", "shortCiteRegEx": null, "year": 1995}], "referenceMentions": [{"referenceID": 3, "context": "The AIXI agent [Hut05] is a formal, mathematical solution to the general reinforcement learning problem.", "startOffset": 15, "endOffset": 22}, {"referenceID": 3, "context": "AIXI is shown in [Hut05] to be optimal in the sense that it will rapidly learn an accurate model of the unknown environment and exploit it to maximise its expected future reward.", "startOffset": 17, "endOffset": 24}, {"referenceID": 4, "context": "In particular, we use a generalisation of UCT [KS06] to approximate the expectimax operation, and an agent-specific extension of CTW [WST95], a Bayesian model averaging algorithm for prediction suffix trees, for prediction and learning.", "startOffset": 46, "endOffset": 52}, {"referenceID": 12, "context": "In particular, we use a generalisation of UCT [KS06] to approximate the expectimax operation, and an agent-specific extension of CTW [WST95], a Bayesian model averaging algorithm for prediction suffix trees, for prediction and learning.", "startOffset": 133, "endOffset": 140}, {"referenceID": 3, "context": "Equation 1, called the chronological condition in [Hut05], captures the natural constraint that action an has no effect on observations made before it.", "startOffset": 50, "endOffset": 57}, {"referenceID": 4, "context": "This section introduces \u03c1UCT, a generalisation of the popular UCT algorithm [KS06] that can be used to approximate a finite horizon expectimax operation given an environment model \u03c1.", "startOffset": 76, "endOffset": 82}, {"referenceID": 0, "context": "Algorithm 3 describes the UCB [Aue02] policy used to select actions at decision nodes.", "startOffset": 30, "endOffset": 37}, {"referenceID": 12, "context": "Context Tree Weighting (CTW) [WST95] is an efficient and theoretically well-studied binary sequence prediction algorithm that works well in practice.", "startOffset": 29, "endOffset": 36}, {"referenceID": 7, "context": "where y1:t is the binary sequence seen so far, M is a prediction suffix tree [RST96], Pr(M) is the prior probability of M, and the summation is over all prediction suffix trees of bounded depth D.", "startOffset": 77, "endOffset": 84}, {"referenceID": 12, "context": "The following is a straightforward extension of a result due to [WST95].", "startOffset": 64, "endOffset": 71}, {"referenceID": 4, "context": "[KS06] shows that the UCT algorithm is consistent in finite horizon MDPs and derive finite sample bounds on the estimation error due to sampling.", "startOffset": 0, "endOffset": 6}, {"referenceID": 4, "context": "By interpreting histories as Markov states, the general reinforcement learning problem reduces to a finite horizon MDP and the results of [KS06] are now directly applicable.", "startOffset": 138, "endOffset": 144}, {"referenceID": 3, "context": "The next result, adapted from [Hut05], shows that if there is a good model of the (unknown) environment in CD, then Action-Conditional CTW will predict well.", "startOffset": 30, "endOffset": 37}, {"referenceID": 10, "context": "More detail can be found in [VNHS09].", "startOffset": 28, "endOffset": 36}, {"referenceID": 1, "context": "The Biased RockPaperScissor domain is described in [FMWR07], which involves the agent repeatedly playing RockPaperScissor against an exploitable opponent.", "startOffset": 51, "endOffset": 59}, {"referenceID": 2, "context": "Two more challenging domains are included: Kuhn Poker [HSHB05], where the agent plays second against a Nash optimal player and a partially observable version of Pacman described in [VNHS09].", "startOffset": 54, "endOffset": 62}, {"referenceID": 10, "context": "Two more challenging domains are included: Kuhn Poker [HSHB05], where the agent plays second against a Nash optimal player and a partially observable version of Pacman described in [VNHS09].", "startOffset": 181, "endOffset": 189}, {"referenceID": 8, "context": "The BLHT algorithm [SH99] is closely related to our work.", "startOffset": 19, "endOffset": 25}, {"referenceID": 1, "context": "The Active-LZ [FMWR07] algorithm combines a Lempel-Ziv based prediction scheme with dynamic programming for control to produce an agent that is provably asymptotically optimal if the environment is n-Markov.", "startOffset": 14, "endOffset": 22}, {"referenceID": 5, "context": "U-Tree [McC96] is an online agent algorithm that attempts to discover a compact state representation from a raw stream of experience.", "startOffset": 7, "endOffset": 14}, {"referenceID": 5, "context": "Furthermore, the splitting heuristic contains a number of configuration options that can dramatically influence its performance [McC96].", "startOffset": 128, "endOffset": 135}, {"referenceID": 11, "context": "The \u03c1UCT algorithm shares similarities with Bayesian Sparse Sampling [WLBS05]; the key differences are estimating the leaf node values with a rollout function and guiding the search with the UCB policy.", "startOffset": 69, "endOffset": 77}, {"referenceID": 10, "context": "A more comprehensive discussion of related work can be found in [VNHS09].", "startOffset": 64, "endOffset": 72}, {"referenceID": 10, "context": "Some preliminary ideas are explored in [VNHS09].", "startOffset": 39, "endOffset": 47}], "year": 2010, "abstractText": "This paper introduces a principled approach for the design of a scalable general reinforcement learning agent. This approach is based on a direct approximation of AIXI, a Bayesian optimality notion for general reinforcement learning agents. Previously, it has been unclear whether the theory of AIXI could motivate the design of practical algorithms. We answer this hitherto open question in the affirmative, by providing the first computationally feasible approximation to the AIXI agent. To develop our approximation, we introduce a Monte Carlo Tree Search algorithm along with an agent-specific extension of the Context Tree Weighting algorithm. Empirically, we present a set of encouraging results on a number of stochastic, unknown, and partially observable domains.", "creator": "LaTeX with hyperref package"}}}