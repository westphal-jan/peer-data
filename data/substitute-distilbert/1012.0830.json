{"id": "1012.0830", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Dec-2010", "title": "Using ASP with recent extensions for causal explanations", "abstract": "we examine certain practicality for a user of using answer set programming ( asp ) for representing logical formalisms. just choose as simple amplifier a formalism aiming at capturing new explanations meaning causal stimuli. we provide an implementation, showing the naturalness enhancing relative efficiency of this translation job. we are interested in the software for writing an asp dialogue, in accordance with the fundamental ` ` declarative'' aspect of asp. limitations of the earlier systems ( poor data structure and difficulty in reusing pieces of programs ) made that in practice, the ` ` discourse dictionary'' was more theoretical than practical. tests show how recent improvements in working asp effectively facilitate a lot the translation, even if a few improvements could still be useful.", "histories": [["v1", "Fri, 3 Dec 2010 20:07:21 GMT  (35kb)", "http://arxiv.org/abs/1012.0830v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yves moinard"], "accepted": false, "id": "1012.0830"}, "pdf": {"name": "1012.0830.pdf", "metadata": {"source": "CRF", "title": "Using ASP with recent extensions for causal explanations", "authors": ["Yves Moinard"], "emails": ["moinard@irisa.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n01 2.\n08 30\nv1 [\ncs .A"}, {"heading": "1 Introduction", "text": "We examine a few difficulties encountered when trying to translate a logical formalism into a running answer set programming (ASP) program, showing how recent developments in ASP systems are of great help. We are not concerned here by complexity matters (also an important matter, for which exists a large literature). Rather, we deal with the ease for writing, and\n\u2217Paper presented at ASPOCP10, Answer Set Programming and Other Computing Paradigms Workshop, associated with ICLP, Edinburgh, July 20, 2010.\nmore importantly reading (thus modifying easily) programs in ASP for a given problem. Indeed, ASP is presented as (and is) a declarative formalism where it should be immediate to write a program from a logical formalization of a given problem. In practice, this is rarely as easy as claimed. We choose as an example a formalism that we have designed in collaboration with Philippe Besnard and Marie-Odile Cordier. This formalism aims at a logical formalization of explanations from causal and \u201cis-a\u201d statements. Given some information such as \u201cfire causes smoke\u201d and \u201cgrey smoke is a smoke\u201d, if \u201cgrey smoke\u201d is established, we want to infer that \u201cfire\u201d is a (tentative) explanation for this fact. The formalization [3, 4] is expressed in terms of rules such as\n\u201cif \u03b1 causes \u03b2 and \u03b4 isa \u03b2, then \u03b1 explains \u03b4 because {\u03b1, \u03b4} is possible\u201d. Here, \u03b1, ... may be first order atoms (without function symbols). Thus, we can express these rules in a \u201cDatalog\u201d formulation. When various explanations are possible, some of them can be subsumed by other ones, and the set of the solutions should be pruned. This concerns looking for paths in some graph and ASP is good for these tasks. There currently exist systems which are rather efficient, such as DLV1 [9] or gringo/clasp or claspD2. Transforming formal rules into an ASP program is easy. ASP should then be an interesting tool for researchers when designing a new theoretical formalization as the one examined here. An ASP program should help examining a great number of middle sized examples, and check whether the results are in accordance with our expectations. Then if middle sized examples could work, a few more optimization techniques could make real sized examples work. Since ASP rules are close to a natural language, a final user could easily adapt a general framework to his precise needs, without requiring a complex specific system.\nEven if ASP allows such direct and efficient translation, a few problems complicate the task.\nFirstly, the poor data types available in pure ASP systems is a real drawback. Our rules involve sets. There are many ways to represent sets in existing ASP systems. We had designed programs working in this way [11] (for systems not allowing functional terms), by representing a set as follows: Expl(I, J,N,E) meaning there exists an \u201cexplanation\u201d from I to J with a set of conditions which is the set {E/Expl(I, J,N,E)}, where N is an index,\n1http://www.dbai.tuwien.ac.at/proj/dlv/ 2http://potassco.sourceforge.net/\nnecessary when M sets of conditions exist (N \u2208 {1, \u00b7 \u00b7 \u00b7 ,M}). However, the program is rather hard to read, and thus to be adapted. Part of this difficulty comes from the second drawback given now.\nSecondly, in pure ASP, it is hard to reuse part of a program. Similar rules should be written again, in a slightly different way. Thus, e.g. the rules necessary to deal with sets should be rewritten in many parts of the full program.\nThirdly, there are restrictions concerning \u201cbrave\u201d or \u201ccautious\u201d reasoning. In ASP, \u201cthe problem is the program\u201d and the solution consists in one or several sets of atoms satisfying the problem. Each such set is an answer set. These answer sets are the \u201cASP models\u201d. Brave (respectively cautious) solutions mean to look for atoms true in some answer set (respectively all the answer sets). In the existing ASP systems, this is generally possible, but in a restricted way only.\nAll these difficulties make that in practice, the claimed advantage in favour of the use of ASP is not so clear when the final program is written. The rules in the program are encumbered by various tricks necessary to overcome these limitations, and any subsequent modification in the program becomes complex.\nHowever, things are evolving. To take the example of DLV, points 1 and 2 above are partly solved: DLV-Complex3 deals with the data structure problem, since it admits sets and lists. DLT 4 allows the use of \u201ctemplates\u201d, which solves to a great extent the problem for reusing part of a program. It is not yet possible to use these two improvements together. Since here the most problematic case was due to the use of sets, we have used DLVComplex, without DLT. When DLT will be able to work with DLV-Complex, the task will be yet easier.\nIn the next section, we present what should be known about our explanation formalism in order to understand its ASP translation. Then, in section 3, we describe its ASP translation, explaining the interest, and the drawback, of using ASP for this kind of job. Finally, we conclude by a few reasonable expectations about the future ASP systems which could help a final user, and make ASP a really interesting programming paradigm for such problems.\n3http://www.mat.unical.it/dlv-complex 4https://www.mat.unical.it/ianni/wiki/dlt"}, {"heading": "2 The causal explanation formalism", "text": ""}, {"heading": "2.1 Preliminaries", "text": "For simplicity, we fully present the propositional version only. The full formalism, with predicates (without functions) and with an elementary \u201contology\u201d has been described in [3, 4]. The extension from the propositional case to the general case is not difficult, as will be explained in \u00a73.5. We distinguish various types of statements in our formal system:\nC: A theory expressing causal statements. E.g. On alarm causes Heard bell or F lu causes Fever Temperature.\nO: An ontology in the form of a set of IS-A links between two items which can appear in a causal statement. E.g., Temperature 39 \u2192IS\u2212A Fever Temperature,\nTemperature 41 \u2192IS\u2212A Fever Temperature, Heard loud bell \u2192IS\u2212A Heard bell, Heard soft bell \u2192IS\u2212A Heard bell.\nW : A classical propositional theory expressing truths (incompatible facts, co-occurring facts, . . .). E.g., Heard soft bell \u2192 \u00acHeard loud bell.\nIntuitively, propositional symbols denote elementary properties describing states of affairs, which can be facts or events such as Fever Temperature, On alarm, Heard bell. The causal statements express causal relations between facts or events expressed by these propositional symbols.\nSome care is necessary when providing these causal and ontological atoms. If \u201cF lu causes Fever Temperature\u201d, we will conclude F lu explains Temperature 39 from Temperature 39 \u2192IS\u2212A Fever Temperature, but we cannot state F lu causes Temperature 39: we require that the causal information is provided \u201con the right level\u201d and in this case, Temperature 39 is not on the right level, since \u201cTemperature 39\u201d is too norrow with respect to our knowledge about flu and temperatures.\nThe formal system is meant to infer, from such premises C \u222a O \u222a W , formulas denoting explanations. This inference will be denoted \u22a2C . The ontological atoms express some common sense knowledge which is necessary to infer these \u201cexplanations\u201d. Notice that a feature of our formalism is that standard implication alone cannot help to infer explanations [3, 4].\nIn the following, \u03b1, \u03b2, . . . denote the propositional atoms and \u03a6,\u03a8, . . . denote sets thereof.\nAtoms\n1. Propositional atoms : \u03b1, \u03b2, . . ..\n2. Causal atoms : \u03b1 causes \u03b2.\n3. Ontological atoms : \u03b1 \u2192IS\u2212A \u03b2.\n4. Explanation atoms : \u03b1 explains \u03b2 because possible \u03a6.\nAn ontological atom reads: \u03b1 is a \u03b2. An explanation atom reads: \u03b1 is an explanation for \u03b2 because \u03a6 is possible.\nNotation: In order to help reading long formulas, explanation atoms are sometimes abbreviated as \u03b1 expl \u03b2 bec poss \u03a6.\nFormulas\n1. Propositional formulas : Boolean combinations of propositional atoms.\n2. Causal formulas : Boolean combinations of causal or propositional atoms.\nThe premises of the inference \u22a2C , namely C \u222aO \u222aW , consist of propositional and causal formulas, and ontological atoms (no ontological formulas). Notice that explanation atoms cannot occur in the premises.\nThe properties of causal and ontological formulas are as follows.\n1. Properties of the causal operator\n(a) Entailing [standard] implication: If \u03b1 causes \u03b2, then \u03b1 \u2192 \u03b2.\n2. Properties of the ontological operator\n(a) Entailing implication: If \u03b1 \u2192IS\u2212A \u03b2, then \u03b1 \u2192 \u03b2.\n(b) Transitivity : If a \u2192IS\u2212A b and b \u2192IS\u2212A c, then a \u2192IS\u2212A c.\n(c) Reflexivity : c \u2192IS\u2212A c.\nReflexivity is an unconventional property for an IS-A hierarchy. It is included here because it helps keeping the number of inference schemes low (note that in the ASP translation we do not need reflexivity).\nW is supposed to include (whether explicitly or via inference) all the implications induced by the ontological atoms. For example, if Heard loud bell \u2192IS\u2212A Heard bell is in O then Heard loud bell \u2192 Heard bell is in W .\nSimilarly, W is supposed to include all conditionals induced by the causal statements in C. For example, if F lu causes Fever Temperature is in C, then F lu \u2192 Fever Temperature is in W ."}, {"heading": "2.2 The formal system", "text": "The above ideas are embedded in a short proof system extending classical logic:\n1. Causal atoms entail implication: (\u03b1 causes \u03b2) \u2192 (\u03b1 \u2192 \u03b2).\n2. Ontological atoms\n(a) entail implication: If \u03b2 \u2192IS\u2212A \u03b3 then \u03b2 \u2192 \u03b3.\n(b) transitivity: If \u03b1 \u2192IS\u2212A \u03b2 and \u03b2 \u2192IS\u2212A \u03b3 then \u03b1 \u2192IS\u2212A \u03b3.\n(c) reflexivity: \u03b1 \u2192IS\u2212A \u03b1\n3. Generating the explanation atoms\n(a) Initial case If \u03b4 \u2192IS\u2212A \u03b2, \u03b4 \u2192IS\u2212A \u03b3, and W 6|= \u00ac(\u03b1 \u2227 \u03b4), then (\u03b1 causes \u03b2) \u2192 \u03b1 expl \u03b3 bec poss {\u03b1, \u03b4} (b) Transitivity (gathering the conditions) If W 6|= \u00ac \u2227 (\u03a6 \u222a\u03a8),\nthen (\u03b1 expl \u03b2 bec poss \u03a6 \u2227 \u03b2 expl \u03b3 bec poss \u03a8) \u2192 \u03b1 expl \u03b3 bec poss (\u03a6 \u222a\u03a8).\n(c) Simplification of the set of conditions If W |= \u2227 \u03a6 \u2192 \u2228n i=1 \u2227 \u03a6i,\nthen \u2227\ni\u2208{1,\u00b7\u00b7\u00b7,n} \u03b1 expl \u03b2 bec poss (\u03a6i\u222a\u03a6) \u2192 \u03b1 expl \u03b2 bec poss \u03a6.\nThese schemes allow us to obtain the inference patterns evoked in the previous section:\nThe most elementary \u201cinitial case\u201d applies (2c) upon (3a) where \u03b2 = \u03b3 = \u03b4, together with an obvious simplification (3c) since \u03b1 \u2192 \u03b2 here, getting: If \u03b1 causes \u03b2 and W 6|= \u00ac\u03b1 then \u03b1 expl \u03b2 bec poss {\u03b1}.\nTwo other particular cases read as follows (respectively \u03b3 = \u03b4 and \u03b2 = \u03b4): If \u03b1 causes \u03b2, \u03b4 \u2192IS\u2212A \u03b2 and W 6|= \u00ac(\u03b1 \u2227 \u03b4) then \u03b1 expl \u03b4 bec poss {\u03b1, \u03b4}. If \u03b1 causes \u03b2, \u03b2 \u2192IS\u2212A \u03b3 and W 6|= \u00ac\u03b1 then \u03b1 expl \u03b3 bec poss {\u03b1}.\nNotice that we do not allow explanation through the opposite ontological sequence \u03b2 \u2192IS\u2212A \u03b3 and \u03b4 \u2192IS\u2212A \u03b3 [cf the general formulation 3a]. This is from experiences with situations of the kind of those evoked in the preliminaries, and it is in accordance with the notion of \u201cright level\u201d. Suppose we would admit these sequences, then if e.g. \u03b1 causes Heard loud bell, we would necessarily get the conclusion \u03b1 expl Heard soft bell bec poss {\u03b1,Heard soft bell}, from the natural data Heard loud bell \u2192IS\u2212A Heard bell andHeard soft bell \u2192IS\u2212A Heard bell. We consider such a conclusion as unwanted in this situation.\nIt is possible that some domains of application would need other rules. Our rules are intended as a compromise between expressive power, naturalness of description and relatively efficient computability.\nThe system is independent of any opinion about the controversial discussion about transitivity of causation. However, we provide some transitivity for explanations (the conditions are gathered then, cf 3b).\nThe simplification rule (3c) is powerful and can be considered as of little interest with respect to the extra computational cost associated with it. In practice, simpler rules could suffice, and our ASP translation implements a weaker rule defined as follows:\n[3c\u2019] If W |= \u2227 \u03a6\u2212 {\u03d5} \u2192 \u2227 \u03a6, and \u03b1 explains \u03b2 because possible \u03a6 then \u03b1 explains \u03b2 because possible \u03a6\u2212 {\u03d5}. Notice a minor point: we consider as important to keep \u03b1 is such a case, thus the ASP translation does not apply this simplification (removing a redundant \u03d5 from the set of conditions) when \u03d5 = \u03b1.\nIt is important to introduce the notion of optimal explanation atoms: An atom \u03b1 explains \u03b2 because possible \u03a6 is optimal if there is no explanation atom \u03b1 explains \u03b2 because possible \u03a8 where W |= \u2227 \u03a6 \u2192 \u2227 \u03a8 while W 6|= \u2227 \u03a8 \u2192 \u2227 \u03a6. Keeping only these weakest sets of conditions is particularly\nuseful when the derivation is made only thanks to the part of W coming from Points 1 and 2a above. Indeed, this makes the result easier to read in case where many possible explanation atoms exist from \u03b1 to \u03b2. In this case, we are certain to keep all the relevant explanation atoms, even if some additional W is introduced afterwards."}, {"heading": "2.3 A generic diagram", "text": "Below an abstract diagram is depicted that summarizes many patterns of inferred explanations from various cases of causal statements and \u2192IS\u2212A links. The theory is described as follows (see Figure 1, with greek letters in their latin names): \u03b1 causes \u03b2, \u03b1 causes \u03b20, \u03b22 causes \u03b3, \u03b21 causes \u03b3, \u03b23 causes \u01eb, \u03b31 causes \u03b4, \u03b33 causes \u03b4, \u01eb3 causes \u03b33; \u03b2 \u2192IS\u2212A \u03b22, \u03b21 \u2192IS\u2212A \u03b2, \u03b23 \u2192IS\u2212A \u03b20, \u03b23 \u2192IS\u2212A \u03b21, \u03b31 \u2192IS\u2212A \u03b3, \u03b32 \u2192IS\u2212A \u03b3, \u03b32 \u2192IS\u2212A \u03b33, \u03b32 \u2192IS\u2212A \u01eb, \u01eb1 \u2192IS\u2212A \u01eb, \u01eb2 \u2192IS\u2212A \u01eb, \u01eb1 \u2192IS\u2212A \u01eb3, \u01eb2 \u2192IS\u2212A \u01eb3.\nThis example shows various different \u201cexplaining paths\u201d from a few given causal and ontological atoms. Here there is a first \u201cexplaining path\u201d from \u03b1 to \u03b4 (Figure 1, see also path (1a) on Figure 2). We get successively: \u03b1 expl \u03b22 bec poss {\u03b1}, \u03b1 expl \u03b31 bec poss {\u03b1, \u03b31}, and\n\u03b1 expl \u03b4 bec poss {\u03b1, \u03b31}. As another \u201cexplaining path\u201d, we get: \u03b1 expl \u03b4 bec poss {\u03b1, \u03b21, \u03b31}.\nThis second path is not optimal since {\u03b1, \u03b31} \u2282 {\u03b1, \u03b21, \u03b31}. The simplifying rule produces \u03b1 expl \u03b4 bec poss {\u03b1, \u03b31} from \u03b1 expl \u03b4 bec poss {\u03b1, \u03b21, \u03b31} but, from a computational point of view, it can be better not to generate the second path at all.\nHere are the four optimal explanation atoms from \u03b1 to \u03b4 (Fig. 2): (1a) \u03b1 expl \u03b4 bec poss {\u03b1, \u03b31} (1b) \u03b1 expl \u03b4 bec poss {\u03b1, \u03b32} (2a) \u03b1 expl \u03b4 bec poss {\u03b1, \u03b23, \u01eb1} (2b) \u03b1 expl \u03b4 bec poss {\u03b1, \u03b23, \u01eb2}."}, {"heading": "3 An ASP translation of the formalism", "text": ""}, {"heading": "3.1 Presentation", "text": "We have implemented a program in DLV [9], an implementation of the Answer Set Programming (ASP) formalism [1], that takes only a few seconds to give all the results \u03c31 expl \u03c32 bec poss \u03a6, for all examples of the kind depicted in Fig. 2. The first version [11] used pure DLV, and was encumbered with tricks allowing to deal with sets. Now that DLV-Complex exists, the new version is simpler. As already written, it does not make full \u201csimplification\u201d, however it makes the most important ones. For greater examples, it still works, if we omit the simplification/optimization step. We have tried a\nmuch greater example, involving two different copies of the example of the diagram, linked through an additional small set of data. This ends up with an example with more than a hundred symbols and more than 10 different explanation atoms for some (I, J). This is not a \u201creal world example\u201d yet, but it is not too small, and it shows that we are close to realistic examples. Hopefully, the progress in ASP systems will make that in a near future real world examples could work.\nAs explained below, we have encountered a fourth problem, not listed in the \u201cthree problems\u201d evoked above. Indeed, for this \u201cbig example\u201d, the full program, including simplification and testing the set of conditions, did not work on our computer (crash after more than one hour...). However, since the simplification/optimization step is clearly separated from the first generating step, and since the verification is separated also, we have separated the program into three successive programs:\nThe first one generates explanation atoms (not all of them, but sufficiently many to be able to retrieve all the optimal ones from those produced here).\nThen, starting from the results of this first program, a second program makes all the relevant simplifications and optimizations, in order to help reading the set of the solutions. The simplification does not take disjunction into account as in the powerful rule in Point 3c in \u00a72.2, rather it corresponds to Point 3c\u2019. When two possible sets \u03a6 and \u03a8 of conditions exist for some (I, J), if each \u03c8 \u2208 \u03a8 is entailed (defined as above) by some \u03d5 \u2208 \u03a6, and if the contrary is not true, then the explanation atom I expl J bec poss \u03a6 is disregarded, only the explanation atom with the weaker condition set I expl J bec poss \u03a8 (the most likely to be satisfied) is kept as a result. This tends to keep only optimal explanation atoms defined at the end of \u00a72.2 above, while remaining efficient enough (similarly to the simplification part, only a reasonably efficient part of the formal definition is implemented). This facilitates the human reading of the result, and in fact it is almost mandatory with some sets of data.\nA third program takes the result of the second one (or directly of the first one if the second seems useless) and checks whether the set of conditions is satisfied in the answer set considered. In fact, in the formalism, we should check if it is true in some answer set. This needs full brave reasoning, which\nfor now is not possible with the running systems. However, in our separated programs (not detailed here), it is easier to regroup all the answer sets into a unique big one, where the original answer sets are distinguished by an index (from 1 to the number of original answer sets). In this way, we can do brave and cautious reasoning, and check the set of conditions as described in the formalism.\nThis exhibits a fourth problem with the existing systems. This problem has been addressed in various papers about ASP, but apparently it has not yet given rise to a real running system. Indeed, [13] describes a system which allows to enumerate the answer sets, which is what we need here. However, no running system is referenced in this very interesting paper, which describes small, natural and very useful improvements for ASP systems. A more recent paper [2] describes a more ambitious system which also deals with this point. Hopefully, these very interesting and natural improvements will be introduced in available systems in a near future."}, {"heading": "3.2 The generating part: getting the relevant explana-", "text": "tion atoms\nThe \u201canswer\u201d of an ASP program is a set of answer sets, that is a set of concrete literals satisfying the rules (see e. g. [1] for exact definitions and [9] for the precise syntax of DLV).\nThe user provides the following data: symbol(alpha). for each propositional symbol alpha [mandatory only if the symbol does not appear in a causal, ontological or classical atom]. cause(alpha,beta). for each causal atom \u03b1 causes \u03b2, ont(alpha,beta). for each ontological atom \u03b1 \u2192IS\u2212A \u03b2, true(alpha). or -true(alpha). for each propositional atom \u03b1 true or false.\nCausal and propositional formulas must be put in conjunctive normal form, in order to be entered as sets of clauses such as {-true(epsilon1) v -true(gamma1) v -true(gamma2). -true(epsilon2) v -true(gamma1) v -true(gamma2).} for the formula (\u00ac\u01eb1 \u2227 \u00ac\u01eb2) \u2228 \u00ac\u03b31 \u2228 \u00ac\u03b32; or {cause(beta2,gamma) v cause(epsilon3,gamma3).} for (\u03b22 causes \u03b3) \u2228 (\u01eb3 causes \u03b33)..\nNotice that if we really need all the logical models, at least with respect to\nsome propositional or causal atoms, we must \u201ccomplete\u201d each propositional or causal atom concerned as follows:\ntrue(alpha) v -true(alpha). or cause(alpha,beta) v -cause(alpha,beta). This is generally not necessary, and should be avoided as far as possible\nsince it is computationally demanding. The interesting result consists in the explanation predicates: ecSet(alpha,beta,{alpha,delta,gamma}) represents the explanation atom \u03b1 expl \u03b2 bec poss {\u03b1, \u03b4, \u03b3}.\nHere come the first rules: ontt(I,J) :- ont(I,J). ontt(I,K) :- ontt(I,J), ont(J,K). (cf 2b \u00a72.2).\nFor the sake of \u201csafety\u201d of some rules, and for defining impCO introduced below we may need to define all the symbols, and the ones which can appear in an explanation set (suffix \u201cE\u201d). symbolE(X) :- cause(X,Y). symbolE(Y) :- cause(X,Y). symbolE(X) :- ont(X,Y). symbolE(Y) :- ont(X,Y). symbol(X) :- symbolE(X).\nImplication derived from causal and ontological atoms (\u201cs\u201d for \u201cstrict\u201d): impCO(I,J) :- cause(I,J). impCO(I,J) :- ont(I,J). impCO(I,K) :- impCO(I,J), impCO(J,K). impCO(I,I) :- symbolE(I). impCOs(I,J) :- impCO(I,J), not impCO(J,I). We split the general basic generation rule 3a \u00a72.2, in order to improve the computational performances. Indeed, in the first three particular cases, only one optimal initial explanation atom in (I,J) exists, thus the computation can be simplified.\necinit(I,J,E) represents I expl J bec poss {I, E} where this explanation atom is obtained without using the transitivity rule: ecinit(I,J,I) :- cause(I,J). ecinit(I,J,I) :- cause(I,X), ontt(J,X), impCO(I,J). ecinit(I,J,I) :- cause(I,X), ontt(X,J). ecinit(I,J,I) :- cause(I,X), ontt(E,X), ontt(E,J), impCO(I,E).\nThe most complicated case (with the two ontological axioms) may lead to several explanation atoms from I to J , which requires some complications: ecinit3p(I,J,E) :- ecinit(I,E,E), cause(I,X), ontt(E,X), ontt(E,J), not ecinit(I,J,I),\nnot ecinit(I,J,J). nonecinit(I,J,E) :- ecinit3p(I,J,E1), ecinit3p(I,J,E), impCOs(E,E1). ecinit(I,J,E) :- ecinit3p(I,J,E), not nonecinit(I,J,E).\n[Avoids keeping clearly non optimal ones.] Since the set of conditions are singletons or pairs in the initial explanation atoms [ecinit], set representation was not required. Real explanation atoms\n[ecSet] are introduced now, together with explicit sets which allow a serious simplification of the ASP rules.\nFirstly, we initialize ecSet with ecinit [#insert(Set1,E,Set) means in DLVComplex: Set = Set1 \u222a {E}]: ecSet(I,J,{I}) :- ecinit(I,J,I). ecSet(I,J,{I,J}) :- ecinit(I,J,J), not ecSet(I,J,{I}). ecSet(I,J,{I,E}) :- ecinit(I,J,E), not ecSet(I,J,{I}), not ecSet(I,J,{I,J}).\nThen comes the translation of Point 3b \u00a72.2. ecSet(I,J,Set) :- ecSet(I,K,Set1), not ecSet(I,J,Set1), ecinit(K,J,E2), E2 != K,\n#insert(Set1,E2,Set). ecSet(I,J,Set) :- ecSet(I,K,Set), ecinit(K,J,K).\n[Nothing to add in this case, since we know that Set \u22a2C K.] And this is enough for getting all the relevant explanation atoms. Only a few computational optimization tricks complicate a little bit the writing, however, the ASP rules remain very close to the formal rules given in \u00a72.2."}, {"heading": "3.3 Optimizing the explanation atoms", "text": "This is the most computationally demanding part. Rigorously, it is not mandatory. However, it is important in order to avoid providing too many unnecessary explanation atoms which complicate the interpretation of the result.\nAs a short example, suppose we have following data: \u03b1 causes \u03b2, \u03b1 causes \u03b20, \u03b22 causes \u03b3, \u03b21 causes \u03b3, \u03b22 \u2192IS\u2212A \u03b20, \u03b21 \u2192IS\u2212A \u03b2, \u03b22 \u2192IS\u2212A \u03b21.\nThen, we get the following explanation atoms concerning (\u03b1, \u03b3): Expl1: \u03b1 expl \u03b3 bec poss {\u03b1, \u03b21} and Expl2: \u03b1 expl \u03b3 bec poss {\u03b1, \u03b22}. Since we have \u03b22 \u2192IS\u2212A \u03b21, we get \u03b22 \u2192 \u03b21 from 2a \u00a72.2 in W , even if the user does not provide any explicit W . Thus, each element in {\u03b1, \u03b21} is entailed by some element in {\u03b1, \u03b22} and not conversely. Thus, the weaker set {\u03b1, \u03b21} is more likely to be satisfied, whatever are the other data, and in particular whatever may be an explicit W given as additional data. Thus, it is useless, and disturbing, to provide Expl2: Expl1 is enough. It happens here that Expl1 is optimal with the given data. Obviously, in more complex cases involving disjunction, the \u201celement wise\u201d test would not be enough to discard all the sets of conditions which are too strong for entailment. However, the\ntest described here is a good compromise between efficient computation and readability of the result.\nWe have tried various other programs providing only the [quasi] optimal sets, in order to avoid this \u201coptimizing\u201d part. All of them were much slower: it is better to provide first the explanation atoms with a program such as the one given in \u00a73.2, which does not take great care for avoiding superfluous answers, and then to prune the set of solutions.\nHere comes the \u201coptimizing part\u201d. Remind that not all the simplifications or optimizations possible are made. As explained above, only those which are easy to compute are made. Indeed, except in artificially complicated data, most of the simplifications are made in this way, while dealing with the tricky cases would make the program too slow for a marginal advantage. These simplification/optimizations are mandatory in order to facilitate human reading, and could be omitted in a purely formal perspective since anyway the produced explanation atoms cover all the possible situations. The rules are very simple:\nimp(I,J) :- impCO(I,J). (additional predicate imp useless in the version presented here).\nPropagating the truth values: true(J) :- true(I), imp(I,J). -true(I) :- -true(J), imp(I,J).\nEliminating sets of conditions which contain another set [#subSet(Set1,Set) means Set1 \u2286 Set and #member(E,Set) means E \u2208 Set]: toolargeSet(I,J,Set) :- ecSet(I,J,Set1), ecSet(I,J,Set), Set1 != Set,\n#subSet(Set1,Set). ecSetsmall(I,J,Set) :- ecSet(I,J,Set), not toolargeSet(I,J,Set). impCOSetEl(Set1,E2) :- ecSetsmall(I,J,Set1), ecSetsmall(I,J,Set2),\nSet1 != Set2, impCO(E1,E2), #member(E1,Set1), #member(E2,Set2), not #member(E1,Set2), not #member(E2,Set1).\nnonImpCOSet(Set1,Set2) :- ecSetsmall(I,J,Set1), ecSetsmall(I,J,Set2), Set1 != Set2, symbolE(E2), #member(E2,Set2),not #member(E2,Set1), not impCOSetEl(Set1,E2). % ( \u201cnot #member(E2,Set1),\u201d is optional) toostrongSet(I,J,Set) :- ecSetsmall(I,J,Set), ecSetsmall(I,J,Set1), Set != Set1, nonImpCOSet(Set1,Set), not nonImpCOSet(Set,Set1). ecSetRes(I,J,Set) :- ecSetsmall(I,J,Set), not toostrongSet(I,J,Set). As a result, we only keep the explanation atoms ecSetRes(I,J,Set) where no element can be removed from Set and where no set StrongSet is such that ecSet(I,J,StrongSet) and each element of Set is implied (in the meaning of impCO) by some element of StrongSet, and not conversely.\nThis program is rather slow: the two programs (\u00a73.2 and the present 3.3) can be launched together for examples such as in the diagram of \u00a72.3 and for slightly larger example, but it is impossible for our \u201cbig example\u201d. However, it is possible to launch the first program (instantaneous on our examples), and then the second one starting with the results of the first one. Then, our \u201cbig example\u201d is solved in far less than one minute on our computer."}, {"heading": "3.4 Checking the set of conditions", "text": "Finally, the following program starts from the result of the preceding programs and checks, in each answer set, whether the set of conditions is satisfied or not. This program could also be launched starting from the result of the first program (replacing ecSetRes with ecSet), simply superfluous explanation atoms would be checked also, and almost no \u201coptimization\u201d would be done.\nThe result is given by explVer(I,J,Set): I expl J bec poss Set where Set is satisfiable in the answer set considered (\u201cVer\u201d stands for \u201cverified\u201d). explSuppr(I,J,Set) :- ecSetRes(I,J,Set), -true(E), #member(E,Set). explVer(I,J,Set) :- ecSetRes(I,J,Set), not explSuppr(I,J,Set).\nNotice that only \u201cindividual\u201d checking is made here, in accordance with the requirement that the computational properties remain manageable. In each answer set, this check is enough.\nNotice that, as already evoked, in our running split program (not provided in full here for lack of space), all the answer sets are put into a single one, with an index parameter added for each old answer set. This allows to make real cautious reasoning when checking the consistency of the explanation sets (and only for this point), in accordance with the formalism. Then, a few more rules could be added in order to get results in full accordance with our formalism (since e.g. answer sets do not provide all the classical models). However, even if these rules are written with care, it seems unlikely that the resulting program can run in practice for great examples. As already evoked above, if we want to get all the classical models, a possibility is to require the completion of all the atoms (propositional or causal) which can provoke the existence of various answer sets, by adding the disjunctive rules\ntrue(alpha) v -true(alpha). and cause(gamma,delta) v -cause(gamma,delta). for each of these atoms involved in a non atomic formula. This solution is easy to write in the program, but becomes clearly unmanageable from a computational point of view since the number of answer sets may explode. It is the standard, but not practical, way for getting all the classical models\nin ASP. Then, together with real cautious reasoning, checking for possible consistency of the sets could be made in full accordance with the formalism. Notice that it is not always clear whether the intended meaning is better rendered by classical models than by answer sets.\nWe have taken care to describe all the practical limitations of our solution. However, apart from these (generally minor in practice) points, we hope to have convinced that ASP is very interesting in order to deal with this kind of problem.\nOne of the advantages is that if we want to modify a rule of the formalism, this can be done easily, since there is a close relation between the formal rules and the ASP rules. The main difference between formal rules and the ASP rules described above concern the \u201cinitial rule\u201d in the first program \u00a73.2. This difference comes from the fact that we have done our best to provide a program running in a reasonable time. This is another interest of using ASP: such computational optimizations can be introduced in a relatively natural way. Even with these complications, modifying the rules remains easy.\nAlso, for the example described here, the gain of using DLV-Complex instead of pure DLV (or gringo/claspD) is significant and worth mentioning."}, {"heading": "3.5 Dealing with predicate logic", "text": "For the sake of conciseness we have given the translation of the propositional version of our formalism. In fact, this is not a serious concern. Indeed, the computational efficiency is similar, since the real tricky points all appear in the propositional version. A standard way to deal with predicates in ASP, starting from a propositional version, is to add a few parameters representing the predicate symbols. As an example, let us consider atoms such as heard(bell) or like(bell) or own(student, book) in place of \u03b1 or \u03b2. In the formalism, all we need to do is to replace e. g. facts such as heard bell causes on alarm. by heard(bell) causes on(alarm)., and to replace all the rules accordingly.\nIn this way, we can also translate the slightly extended ontology described in [4]. There, two kinds of parameters are considered for each predicate: the ones for which the predicate is essentially universal and the ones for which the predicate is essentially existential. Let us suppose that we intend that heard is essentially existential with respect to its parameter and like essentially universal. Intuitively, this means that heard is intended as meaning\nheard some while like means like all. The ontological information would be provided by the user as follows: loud bell \u2192IS\u2212A(object) bell and white car \u2192IS\u2212A(object) car.\nThis would provide the following \u2192IS\u2212A relation between atoms heard(bell) \u2192IS\u2212A heard(loud bell). and like(car) \u2192IS\u2212A like(white car)..\nThis means that the ASP formulation would contain the following facts and rules: ont object(loud bell,bell). ont object(white car,car). ont([P,X],[P,Y]) :- onekind(P), ont object(X,Y). and ont([P,Y],[P,X]) :- allkind(P), ont object(X,Y).\nDealing with lists (denoted inside brackets) of DLV-Complex is convenient: a small set of ASP rules can deal with predicates of any arity, even if we do not describe the full formalism here for the sake of conciseness.\nPropositional parameters would be dealt with the following rule: ont([A],[B]) :- ont object(A,B), propkind(A), propkind(B).\nLet us consider a binary predicate own, with own(student, book) meaning that the individual (or object) student (whatever it denotes in our formalism) owns the object called book. Here, own(X, Y ) is intended to mean: \u201call X own some Y\u201d. The following rule (O-O) can deal with this predicate: ont([P,X,Y],[P,X1,Y1]) :- all onekind(P), ont object(X1,X), ont object(Y,Y1).\nThe user should state the kind of parameters for each predicate, as follows: onekind(heard). allkind(like). all onekind(own). propkind(alpha).\n(A more extensive use of the list notation would allow to write rules dealing with any arity in a yet more natural way.)\nWriting onekind(heard)means that the classes or objects which can appear as parameters of the unary predicate heard of the formal system have adapted meaning. In this example, bell may denote the class of some bells considered in the situation at hand, loud bell the class of those bells which are loud and some bell could denote a precise loud bell. Notice that the objects are intended to denote either individuals or classes of individuals.\nIn this situation the user could add the following atom to the one given above about bells: ont object(some bell,loud bell).\nAs an example, let us consider our binary predicate own, with the known informations provided by the user as follows in ASP: ont object(tom,student). ont object(book,document).\nThen, the following ontological atoms would be deduced by the system (again in ASP notation): ont([own,tom,book], [own,tom,document]) ont([own,student,book], [own,tom,book]) ont([own,student,book], [own,tom,document]).\nA predicate for which no \u201call/one\u201d information is given could be used, but it would never give rise to ontological atoms.\nThis kind of formulation is in accordance with our requirements for the formalism: allowing serious expressiveness while keeping computation manageable. To this respect, for large examples it can be useful to reduce the instantiation size by restricting the parameters which can be used for some predicates, by adding not unrestr(P), kindPar(P,X,Y) to the body of the rule (O-O). Rules such as the following ones should be added unrestr(P) :- not restr(P), pred(P). pred(P) :- onekind(P). , [...allkind(P),...]. The user would provide the relevant information about restr and kindPar."}, {"heading": "3.6 Conclusion and future work", "text": "We have shown how a recent version of running ASP systems allow easy translation of logical formalisms. The example given here is a formalism allowing to infer \u201cexplanations\u201d from \u201ccausal and ontological\u201d information, with two requirements: 1 It must be easy and natural to formalize a given situation. 2 Computation should remain as manageable as possible.\nThese requirements justify some restrictions of our formalism, in particular the fact that we accept only classical atoms inside the causal and ontological atoms, without operators such as negation or disjunction. The formalism is not restricted to the propositional case, and, as explained in the last subsection, it involves an ontology slightly more general that the rudimentary one developed in the full ASP description given in the preceding subsections.\nFrom the perspective of existing (and predictable in a near future) ASP systems, here are some conclusions that can be drawn:\nThe existing recent extensions of ASP systems are a real bonus. It is much easier to write the program now than it was a few years ago. More importantly perhaps, the difference is even greater when reading such a program. Indeed the claimed assertions about ASP, namely that it makes programs easy to write and to read, are true only when such extensions are used. Oth-\nerwise, due to the fact that in practice it is very hard to use some portion of a program in different places in a greater program, the real ASP programs are either very restricted in their application, or hard to read (and thus to evolve). In our opinion, DLV with templates (DLT) solves a serious part of this problem. However, on our formalism, it happens that it is DLVComplex, since it accepts sets and lists in a natural and efficient way, which has made the difference. Indeed, our formalism involves sets in a non trivial way, thus the present program is far more readable than the previous ones, in pure DLV.\nFrom a formal perspective, neither DLV-Complex nor DLT are revolutionary. To a great extent, all they do is add way for writing natural programs where pure ASP systems need cumbersome rewritings of parts of the programs. Generally, using them does not improve computational efficiency. The fact is that they always allow more convenient writing, and particularly much easier reading, which changes the life of the programmer. Expert ASP programmers were able to use previous ASP systems together with small parts of more standard programming, but this was not very attracting for most of the potential users of ASP systems.\nSo, what can we expect now? For now, DLT cannot work together with DLV-Complex, and this is the first thing we can expect, hopefully in a very near future, together with similar facilities for gringo/clasp and other systems.\nAlso, \u201cbrave\u201d and \u201ccautious\u201d reasoning do not exist in full generality (to our knowledge) in available systems. May be our formalism is an extreme example of this point (a mix of cautious and standard reasoning would be useful), but in fact this happens to be a serious concern in many circumstances. Again, programmers can redirect the result (the set of all answer sets) to a very simple other ASP program, for playing with the answer sets in a more or less complex way, but this is not very convenient. In the literature, we can encounter various texts about this problem, describing systems which solve it in a natural manner, but, to our knowledge, such systems are not yet available. Some [meta?]predicates, as described in e.g. [13], which present a relatively simple and natural way to write programs doing this, would suffice in many cases. In this way real brave and cautious reasoning could be envisioned, and much more. We hope that this will be the case in available systems in a near future. Clearly, dealing with too many answer sets cannot be done with huge domains, but there are many cases where it would be interesting to have full access to the set of all the answer sets.\nHere is a last feature that could be interesting. The full program did not work for what is called our \u201cgreat example\u201d. However, when split in two or three parts, it worked relatively well. In this case the split was very easy to do. Could it be that future systems detect such possible split, and thus extend their range of application? In our example, computing ecSet first, then ecSetRes and finally ecSetVer should be automatized. It seems easy to detect such one way dependencies, without retro-action. The great difference in practice between launching the three programs together, and launching them one after the other, shows that such improvement could have spectacular consequences.\nFor what concerns our own work, the important things to do are to apply the formalism to real situations, and, to this respect, firstly to significantly extend our notion of \u201contology\u201d towards a real one."}, {"heading": "Acknowledgement", "text": "The author thanks the reviewers for their helpful and constructive comments, and Marie-Odile Cordier and Philippe Besnard who made this work possible."}], "references": [{"title": "Knowledge representation, reasoning and declarative problem solving", "author": ["Chitta Baral"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "Macros, Macro Calls and Use of Ensembles in Modular Answer Set Programming, ICLP", "author": ["Chitta Baral", "Juraj Dzifcak", "Hiro Takahashi"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Ontology-based inference for causal explanation, KSEM 2007, in LNAI 4798", "author": ["Besnard", "Philippe", "Cordier", "Marie-Odile", "Moinard", "Yves"], "venue": "Zili Zhang and Jrg Siekmann (eds), Springer,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2007}, {"title": "Ontology-based inference for causal explanation, Integrated Computer- Aided Engineering", "author": ["Besnard", "Philippe", "Cordier", "Marie-Odile", "Moinard", "Yves"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Template programs for Disjunctive Logic Programming: An operational semantics", "author": ["Francesco Calimeri", "Giovambattista Ianni"], "venue": "AI Communications,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2006}, {"title": "The Conflict-Driven Answer Set Solver clasp: Progress Report", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "E. Erdem and F. Lin and T. Schaub (eds), LPNMR\u201909 In LNAI 5753, pp. 509-514. Springer-Verlag", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2009}, {"title": "Nonmonotonic Causal Theories", "author": ["E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner"], "venue": "Artificial Intelligence", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2004}, {"title": "Causes and Explanations: A Structural-Model Approach - Part II: Explanations", "author": ["J. Halpern", "J. Pearl"], "venue": "In IJCAI-01,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Trans. on Computational Logic (TOCL), 7(3):499\u2013562", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2006}, {"title": "The Facts of Causation", "author": ["H. Mellor D"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1995}, {"title": "An Experience of Using ASP for Toy Examples, ASP\u201907, in Advances in Theory and Implementation, publ", "author": ["Yves Moinard"], "venue": "Facultade de Ciencias,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Causal Logic", "author": ["G. Shafer"], "venue": "In H. Prade (ed),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1998}, {"title": "A Language for Modular Answer Set Programming: Application to ACC Tournament Scheduling, ASP 05, M. De Vos and A Provetti (eds), Answer Set Programming, Advances in Theory and Implementation, CEUR-WS.org publ", "author": ["Luis Tari", "Chitta Baral", "Saadat Anwar"], "venue": "CEUR Workshop Proc.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}], "referenceMentions": [{"referenceID": 2, "context": "The formalization [3, 4] is expressed in terms of rules such as \u201cif \u03b1 causes \u03b2 and \u03b4 isa \u03b2, then \u03b1 explains \u03b4 because {\u03b1, \u03b4} is possible\u201d.", "startOffset": 18, "endOffset": 24}, {"referenceID": 3, "context": "The formalization [3, 4] is expressed in terms of rules such as \u201cif \u03b1 causes \u03b2 and \u03b4 isa \u03b2, then \u03b1 explains \u03b4 because {\u03b1, \u03b4} is possible\u201d.", "startOffset": 18, "endOffset": 24}, {"referenceID": 8, "context": "There currently exist systems which are rather efficient, such as DLV [9] or gringo/clasp or claspD.", "startOffset": 70, "endOffset": 73}, {"referenceID": 10, "context": "We had designed programs working in this way [11] (for systems not allowing functional terms), by representing a set as follows: Expl(I, J,N,E) meaning there exists an \u201cexplanation\u201d from I to J with a set of conditions which is the set {E/Expl(I, J,N,E)}, where N is an index,", "startOffset": 45, "endOffset": 49}, {"referenceID": 2, "context": "The full formalism, with predicates (without functions) and with an elementary \u201contology\u201d has been described in [3, 4].", "startOffset": 112, "endOffset": 118}, {"referenceID": 3, "context": "The full formalism, with predicates (without functions) and with an elementary \u201contology\u201d has been described in [3, 4].", "startOffset": 112, "endOffset": 118}, {"referenceID": 2, "context": "Notice that a feature of our formalism is that standard implication alone cannot help to infer explanations [3, 4].", "startOffset": 108, "endOffset": 114}, {"referenceID": 3, "context": "Notice that a feature of our formalism is that standard implication alone cannot help to infer explanations [3, 4].", "startOffset": 108, "endOffset": 114}, {"referenceID": 8, "context": "We have implemented a program in DLV [9], an implementation of the Answer Set Programming (ASP) formalism [1], that takes only a few seconds to give all the results \u03c31 expl \u03c32 bec poss \u03a6, for all examples of the kind depicted in Fig.", "startOffset": 37, "endOffset": 40}, {"referenceID": 0, "context": "We have implemented a program in DLV [9], an implementation of the Answer Set Programming (ASP) formalism [1], that takes only a few seconds to give all the results \u03c31 expl \u03c32 bec poss \u03a6, for all examples of the kind depicted in Fig.", "startOffset": 106, "endOffset": 109}, {"referenceID": 10, "context": "The first version [11] used pure DLV, and was encumbered with tricks allowing to deal with sets.", "startOffset": 18, "endOffset": 22}, {"referenceID": 12, "context": "Indeed, [13] describes a system which allows to enumerate the answer sets, which is what we need here.", "startOffset": 8, "endOffset": 12}, {"referenceID": 1, "context": "A more recent paper [2] describes a more ambitious system which also deals with this point.", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "[1] for exact definitions and [9] for the precise syntax of DLV).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[1] for exact definitions and [9] for the precise syntax of DLV).", "startOffset": 30, "endOffset": 33}, {"referenceID": 3, "context": "In this way, we can also translate the slightly extended ontology described in [4].", "startOffset": 79, "endOffset": 82}, {"referenceID": 12, "context": "[13], which present a relatively simple and natural way to write programs doing this, would suffice in many cases.", "startOffset": 0, "endOffset": 4}], "year": 2017, "abstractText": "We examine the practicality for a user of using Answer Set Programming (ASP) for representing logical formalisms. We choose as an example a formalism aiming at capturing causal explanations from causal information. We provide an implementation, showing the naturalness and relative efficiency of this translation job. We are interested in the ease for writing an ASP program, in accordance with the claimed \u201cdeclarative\u201d aspect of ASP. Limitations of the earlier systems (poor data structure and difficulty in reusing pieces of programs) made that in practice, the \u201cdeclarative aspect\u201d was more theoretical than practical. We show how recent improvements in working ASP systems facilitate a lot the translation, even if a few improvements could still", "creator": "LaTeX with hyperref package"}}}