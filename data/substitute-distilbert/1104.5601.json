{"id": "1104.5601", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Apr-2011", "title": "Mean-Variance Optimization in Markov Decision Processes", "abstract": "sometimes consider zero horizon markov decision processes under performance measures that involve decreasing the mean and the variance of the cumulative reward. we show that either randomized or history - based policies can improve performance. we prove that the complexity of computing a policy that meets the mean reward under squared variance matrix is np - hard for some cases, and strongly np - hard for others. we finally offer pseudopolynomial exact and approximation support.", "histories": [["v1", "Fri, 29 Apr 2011 11:39:40 GMT  (21kb)", "http://arxiv.org/abs/1104.5601v1", "A full version of an ICML 2011 paper"]], "COMMENTS": "A full version of an ICML 2011 paper", "reviews": [], "SUBJECTS": "cs.LG cs.AI", "authors": ["shie mannor", "john n tsitsiklis"], "accepted": true, "id": "1104.5601"}, "pdf": {"name": "1104.5601.pdf", "metadata": {"source": "CRF", "title": "Mean-Variance Optimization in Markov Decision Processes", "authors": ["Shie Mannor"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n10 4.\n56 01\nv1 [\ncs .L\nG ]\n2 9\nA pr\nkeywords: Markov processes; dynamic programming; control; complexity theory.\nI. INTRODUCTION\nThe classical theory of Markov decision processes (MDPs) deals with the maximization of the cumulative (possibly discounted) expected reward, to be denoted by W . However, a risk-averse decision maker may be interested in additional distributional properties of W . In this paper, we focus on the case where the decision maker is interested in both the mean and the variance of the cumulative reward, and we explore the associated computational issues.\nRisk aversion in MDPs is of course an old subject. In one approach, the focus is on the maximization of E[U(W )], where U is a concave utility function. Problems of this type can be handled by state augmentation (e.g., Bertsekas, 1995), namely, by introducing an auxiliary state variable that keeps track of the cumulative past reward. In a few special cases, e.g., with an exponential utility function, state augmentation is unnecessary, and optimal policies can be found by solving a modified Bellman equation (Chung & Sobel, 1987). Another interesting case where optimal policies can be found efficiently involves piecewise linear utility functions with a single break point; see Liu and Koenig (2005).\nIn another approach, the objective is to optimize a so-called coherent risk measure (Artzner, Delbaen, Eber, & Heath\n1999), which turns out to be equivalent to a robust optimization problem: one assumes a family of probabilistic models and optimizes the worst-case performance over this family. In the multistage case\n2 (Riedel, 2004), problems of this type can be difficult (Le Tallec, 2007), except for some special cases (Iyengar, 2005; Nilim & El Ghaoui, 2005) that can be reduced to Markov games (Shapley, 1953).\nMean-variance optimization lacks some of the desirable properties of approaches involving coherent risk measures and sometimes leads to counterintuitive policies. Bellman\u2019s principle of optimality does not hold, and as a consequence, a decision maker who has received unexpectedly large rewards in the first stages, may actively seek to incur losses in subsequent stages in order to keep the variance small. Nevertheless, mean-variance optimization is an important approach in financial decision making (e.g., Luenberger, 1997), especially for static (one-stage) problems. Consider, for example, a fund manager who is interested in the 1-year performance of the fund, as measured by the mean and variance of the return. Assuming that the manager is allowed to undertake periodic re-balancing actions in the course of the year, one obtains a Markov decision process with mean-variance criteria. Mean-variance optimization can also be a meaningful objective in various engineering contexts. Consider, for example, an engineering process whereby a certain material is deposited on a surface. Suppose that the primary objective is to maximize the amount deposited, but that there is also an interest in having all manufactured components be similar to each other; this secondary objective can be addressed by keeping the variance of the amount deposited small.\nWe note that expressions for the variance of the discounted reward for stationary policies were developed in Sobel (1982). However, these expressions are quadratic in the underlying transition probabilities, and do not lead to convex optimization problems.\nMotivated by considerations such as the above, this paper deals with the computational complexity aspects of mean-variance optimization. The problem is not straightforward for various reasons. One is the absence of a principle of optimality that could lead to simple recursive algorithms. Another reason is that, as is evident from the formula Var(W ) = E[W 2]\u2212 (E[W ])2, the variance is not a linear function of the probability measure of the underlying process. Nevertheless, E[W 2] and E[W ] are linear functions, and as such can be addressed simultaneously using methods from multicriteria or constrained Markov decision processes (Altman, 1999). Indeed, we will use such an approach in order to develop pseudopolynomial exact or approximation algorithms. On the other hand, we will also obtain various NP-hardness results, which show that there is little hope for significant improvement of our algorithms.\nThe rest of the paper is organized as follows. In Section II, we describe the model and our notation. We\n3 also define various classes of policies and performance objectives of interest. In Section III, we compare different policy classes and show that performance typically improves strictly as more general policies are allowed. In Section IV, we establish NP-hardness results for the policy classes we have introduced. Then, in Sections V and VI, we develop exact and approximate pseudopolynomial time algorithms. Unfortunately, such algorithms do not seem possible for some of the more restricted classes of policies, due to strong NP-completeness results established in Section IV. Finally, Section VII contains some brief concluding remarks."}, {"heading": "II. THE MODEL", "text": "In this section, we define the model, notation, and performance objectives that we will be studying.\nThroughout, we focus on finite horizon problems. 1"}, {"heading": "A. Markov Decision Processes", "text": "We consider a Markov decision process (MDP) with finite state, action, and reward spaces. An MDP\nis formally defined by a sextuple M = (T,S,A,R, p, g) where:\n(a) T , a positive integer, is the time horizon; (b) S is a finite collection of states, one of which is designated as the initial state; (c) A is a collection of finite sets of possible actions, one set for each state; (d) R is a finite subset of Q (the set of rational numbers), and is the set of possible values of the\nimmediate rewards. We let K = maxr\u2208R |r|.\n(e) p : {0, . . . , T \u2212 1}\u00d7S \u00d7S \u00d7A \u2192 Q describes the transition probabilities. In particular, pt(s\u2032 | s, a)\nis the probability that the state at time t+1 is s\u2032, given that the state at time t is s, and that action a is chosen at time t.\n(d) g : {0, . . . , T \u2212 1} \u00d7 R \u00d7 S \u00d7 A \u2192 Q is a set of reward distributions. In particular, gt(r | s, a) is\nthe probability that the immediate reward at time t is r, given that the state and action at time t is s and a, respectively.\nWith few exceptions (e.g., for the time horizon T ), we use capital letters to denote random variables, and lower case letters to denote ordinary variables. The process starts at the designated initial state. At every stage t = 0, 1, . . . , T \u2212 1, the decision maker observes the current state St and chooses an action At.\n1Some of the results such as the approximation algorithms of Section VI can be extended to the infinite horizon discounted case; this is beyond the scope of this paper.\n4 Then, an immediate reward Rt is obtained, distributed according to gt( \u00b7 |St, At), and the next state St+1 is chosen, according to pt( \u00b7 |St, At). Note that we have assumed that the possible values of the immediate reward and the various probabilities are all rational numbers. This is in order to address the computational complexity of various problems within the standard framework of digital computation. Finally, we will use the notation x0:t to indicate the tuple (x0, . . . , xt)."}, {"heading": "B. Policies", "text": "We will use the symbol \u03c0 to denote policies. Under a deterministic policy \u03c0 = (\u00b50, . . . , \u00b5T\u22121), the action at each time t is determined according to a mapping \u00b5t whose argument is the history Ht = (S0:t, A0:t\u22121, R0:t\u22121) of the process, by letting At = \u00b5t(Ht). We let \u03a0h be the set of all such history-based policies. (The subscripts are used as a mnemonic for the variables on which the action is allowed to depend.) We will also consider randomized policies. For this purpose, we assume that there is available a sequence of i.i.d. uniform random variables U0, U1, . . . , UT\u22121, which are independent from everything else. In a randomized policy, the action at time t is determined by letting At = \u00b5t(Ht, U0:t). Let \u03a0h,u be the set of all randomized policies.\nIn classical MDPs, it is well known that restricting to Markovian policies (policies that take into account only the current state St) results in no loss of performance. In our setting, there are two different possible \u201cstates\u201d of interest: the original state St, or the augmented state (St,Wt), where\nWt = t\u22121 \u2211\nk=0\nRk,\n(with the convention that W0 = 0). Accordingly, we define the following classes of policies: \u03a0t,s (under which At = \u00b5t(St)), and \u03a0t,s,w (under which At = \u00b5t(St,Wt)), and their randomized counterparts \u03a0t,s,u (under which At = \u00b5t(St, Ut)), and \u03a0t,s,w,u (under which At = \u00b5t(St,Wt, Ut). Notice that\n\u03a0t,s \u2282 \u03a0t,s,w \u2282 \u03a0h,\nand similarly for their randomized counterparts."}, {"heading": "C. Performance Criteria", "text": "Once a policy \u03c0 and an initial state s is fixed, the cumulative reward WT becomes a well-defined random variable. The performance measures of interest are its mean and variance, defined by J\u03c0 = E\u03c0[WT ] and V\u03c0 = Var\u03c0(WT ), respectively. Under our assumptions (finite horizon, and bounded rewards), it follows\n5 that there are finite upper boundsof KT and K2T 2, for |J\u03c0| and V\u03c0, respectively, independent of the policy.\nGiven our interest in complexity results, we will focus on \u201cdecision\u201d problems that admit a yes/no\nanswer, except for Section VI. We define the following problem.\nProblem MV-MDP(\u03a0): Given an MDP M and rational numbers \u03bb, v, does there exist a policy in the set \u03a0 such that J\u03c0 \u2265 \u03bb and V\u03c0 \u2264 v?\nClearly, an algorithm for the problem MV-MDP(\u03a0) can be combined with binary search to solve (up to any desired precision) the problem of maximizing the expected value of WT subject to an upper bound on its variance, or the problem of minimizing the variance of WT subject to a lower bound on its mean."}, {"heading": "III. COMPARISON OF POLICY CLASSES", "text": "Our first step is to compare the performance obtained from different policy classes. We introduce some terminology. Let \u03a0 and \u03a0\u2032 be two policy classes. We say that \u03a0 is inferior to \u03a0\u2032 if, loosely speaking, the policy class \u03a0\u2032 can always match or exceed the \u201cperformance\u201d of policy class \u03a0, and for some instances it can exceed it strictly. Formally, \u03a0 is inferior to \u03a0\u2032 if the following hold: (i) if (M, c, d) is a \u201cyes\u201d instance of MV-MDP(\u03a0), then it is also a \u201cyes\u201d instance of MV-MDP(\u03a0\u2032); (ii) there exists some (M, c, d) which is a \u201cno\u201d instance of MV-MDP(\u03a0) but a \u201cyes\u201d instance of MV-MDP(\u03a0\u2032). Similarly, we say that two policy classes \u03a0 and \u03a0\u2032 are equivalent if every \u201cyes\u201d (respectively, \u201cno\u201d) instance of MV-MDP(\u03a0) is a \u201cyes\u201d (respectively, \u201cno\u201d) instance of MV-MDP(\u03a0\u2032).\nWe define one more convenient term. A state s is said to be terminal if it is absorbing (i.e., pt(s | s, a) =\n1, for every t and a) and provides zero rewards (i.e., gt(0 | s, a) = 1, for every t and a)."}, {"heading": "A. Randomization Improves Performance", "text": "Our first observation is that randomization can improve performance. This is not surprising given that we are dealing simultaneously with two criteria, and that randomization is helpful in constrained MDPs (e.g., Altman, 1999).\nTheorem 1. (a) \u03a0t,s is inferior to \u03a0t,s,u;\n(b) \u03a0t,s,w is inferior to \u03a0t,s,w,u; (c) \u03a0h is inferior to \u03a0h,u.\n6 Proof. It is clear that performance cannot deteriorate when randomization is allowed. It therefore suffices to display an instance in which randomization improves performance.\nConsider a one-stage MDP (T = 1). At time 0, we are at the initial state and there are two available actions, a and b. The mean and variance of the resulting reward are both zero under action a, and both equal to 1 under action b. After the decision is made, the rewards are obtained and the process terminates. Thus WT = R0, the reward obtained at time 0.\nConsider the problem of maximizing E[R0] subject to the constraint that Var(R0) \u2264 1/2. There is only one feasible deterministic policy (choose action a), and it has zero expected reward. On the other hand, a randomized policy that chooses action b with probability p has an expected reward of p and the corresponding variance satisfies\nVar(R0) \u2264 E[R 2 0] = pE[R 2 0 |A0 = b] = 2p.\nWhen 0 < p \u2264 1/4, such a randomized policy is feasible and improves upon the deterministic one.\nNote that for the above instance we have \u03a0t,s = \u03a0t,s,w = \u03a0h, and \u03a0t,s,u = \u03a0t,s,w,u = \u03a0h,u. Hence the\nabove example establishes all three of the claimed statements. q.e.d.\nB. Information Improves Performance\nWe now show that in most cases, performance can improve strictly when we allow a policy to have access to more information. The only exception arises for the pair of classes \u03a0t,s,w,u and \u03a0h,u, which we show in Section V to be equivalent (cf. Theorem 6).\nTheorem 2. (a) \u03a0t,s is inferior to \u03a0t,s,w, and \u03a0t,s,u is inferior to \u03a0t,s,w,u.\n(b) \u03a0t,s,w is inferior to \u03a0h.\nProof.\n(a) Consider the following MDP, with time horizon T = 2. The process starts at the initial state s0, at\nwhich there are two actions. Under action a1, the immediate reward is zero and the process moves to a terminal state. Under action a2, the immediate reward R0 is either 0 or 1, with equal probability, and the process moves to state s1. At state s1, there are two actions, a3 and a4: under action a3, the immediate reward R1 is equal to 0, and under action a4, it is equal to 1. We are interested in the optimal value of the expected reward E[W2] = E[R0+R1], subject to the constraint that the variance\n7 is less than or equal to zero (and therefore equal to zero). Let p be the probability that action a2 is chosen at state s0. If p > 0, and under any policy in \u03a0t,s,u, the reward R0 at state s0 has positive variance, and the reward R1 at the next stage is uncorrelated with R0. Hence, the variance of R0+R1 is positive, and such a policy is not feasible; in particular, the constraint on the variance requires that p = 0. We conclude that the largest possible expected reward under any policy in \u03a0t,s,u (and, a fortiori, under any policy in \u03a0t,s) is equal to zero. Consider now the following policy, which belongs to \u03a0t,s,w and, a fortiori, to \u03a0t,s,w,u: at state s0, choose action a2; then, at state s1, choose a3 if W1 = R0 = 1, and choose a4 if W1 = R0 = 0. In either case, the total reward is R0 + R1 = 1, while the variance of R0 + R1 is zero, thus ensuring feasibility. This establishes the first part of the theorem.\n(b) Consider the following MDP, with time horizon T = 3. At state s0 there is only one available action;\nthe next state S1 is either s1 or s\u20321, with probability p and 1\u2212p, respectively, and the immediate reward R0 is zero. At either state s1 or s\u20321, there is again only one available action; the next state, S2, is s2, and the reward R1 is zero. At state s2, there are two actions, a and b. Under action a, the mean and variance of the resulting reward R2 are both zero, and under action b, they are both equal to 1. Let us examine the largest possible value of E[W3] = E[R2], subject to the constraint Var(W2) \u2264 1/2. The class \u03a0t,s,w contains two policies, corresponding to the two deterministic choices of an action at state s2; only one of them is feasible (the one that chooses action a), resulting in zero expected reward. However, the following policy in \u03a0h has positive expected reward: choose action b at state s2 if and only if the state at time 1 was equal to s1 (which happens with probability p). As long as p is sufficiently small, the constraint Var(W ) \u2264 1/2 is met, and this policy is feasible. It follows that \u03a0t,s,w is inferior to \u03a0h. q.e.d."}, {"heading": "IV. COMPLEXITY RESULTS", "text": "In this section, we establish that mean-variance optimization in finite horizon MDPs is unlikely to admit\npolynomial time algorithms, in contrast to classical MDPs.\nTheorem 3. The problem MV-MDP(\u03a0) is NP-hard, when \u03a0 is \u03a0t,s,w, \u03a0t,s,w,u, \u03a0h, or \u03a0h,u.\nProof: We will actually show NP-hardness for the special case of MV-MDP(\u03a0), in which we wish to determine whether there exists a policy whose reward variance is equal to zero. (In terms of the problem\n8 definition, this corresponds to letting \u03bb = \u2212KT and v = 0.) The proof uses a reduction from the SUBSET SUM problem: Given n positive integers, does there exist a subset B of {1, . . . , n} such that \u2211\ni\u2208B ri = \u2211 i/\u2208B ri? Given an instance (r1, . . . , rn) of SUBSET SUM, and for any of the policy classes of interest, we construct an instance of MV-MDP(\u03a0), with time horizon T = n+1, as follows. At the initial state s0, there is only one available action, resulting in zero immediate reward (R0 = 0). With probability 1/2, the process moves to a terminal state; with probability 1/2, the process moves (deterministically) along a sequence of states s1, . . . , sn. At each state si (i = 1, . . . , n), there are two actions: ai, which results in an immediate reward of ri, and bi, which results in an immediate reward of \u2212ri.\nSuppose that there exists a set B \u2282 {1, . . . , n} such that \u2211 i\u2208B ri = \u2211 i/\u2208B ri. Consider the policy that chooses action ai at state si if and only if i \u2208 B. This policy achieves zero total reward, with probability 1, and therefore meets the zero variance constraint. Conversely, if a policy results in zero variance, then the total reward must be equal to zero, with probability 1, which implies that such a set B exists. This completes the reduction.\nNote that this argument applies no matter which particular class of policies is being considered. q.e.d. The above proof also applies to the policy classes \u03a0t,s and \u03a0t,s,u. However, for these two classes, a stronger result is possible. Recall that a problem is strongly NP-hard, if it remains NP-hard when restricted to instances in which the numerical part of the instance description involves \u201csmall\u201d numbers; see Garey and Johnson (1979) for a precise definition.\nTheorem 4. If \u03a0 is either \u03a0t,s or \u03a0t,s,u, the problem MV-MDP(\u03a0) is strongly NP-hard.\nProof. As in the proof of Theorem 3, we will prove the result for the special case of MV-MDP, in which we wish to determine whether there exists a policy under which the variance of the reward is equal to zero. The proof involves a reduction from the 3-Satisfiability problem (3SAT). An instance of 3SAT consists of n Boolean variables x1, . . . , xn, and m clauses C1, . . . , Cm, with three literals per clause. Each clause is the disjunction of three literals, where a literal is either a variable or its negation. (For example, x2 \u2228 x4 \u2228 x5 is such a clause, where a bar stands for negation.) The question is whether there exists an assignment of truth values (\u201ctrue\u201d or \u201cfalse\u201d) to the variables such that all clauses are satisfied.\nSuppose that we are given an instance of 3SAT, with n variables and m clauses, C1, . . . , Cm. We\n9 construct an instance of MV-MDP(\u03a0) as follows. There is an initial state s0, a state d0, a state cj associated with each clause Cj , and a state yi associated with each literal xi. The actions, dynamics, and rewards are as follows:\n(a) Out of state s0, there is equal probability, 1/(m+1), of reaching any one of the states d0, c1, . . . , cm,\nindependent of the action; the immediate reward is zero.\n(b) State d0 is a terminal state. At each state cj , there are three actions available: each action selects one\nof the three literals in the clause, and the process moves to the state yi associated with that literal; the immediate reward is 1 if the literal appears in the clause unnegated, and \u22121 if the literal appears in the clause negated. For an example, suppose that the clause is of the form x2 \u2228 x4 \u2228 x5. Under the first action, the next state is y2, and the reward is 1; under the second action, the next state is y4 and the reward is \u22121; under the third action, the next state is y5, and the reward is 1.\n(c) At each state yi, there are two possible actions ai and bi, resulting in immediate rewards of 1 and\n\u22121, respectively. The process then moves to the terminal state d0.\nSuppose that we have a \u201cyes\u201d instance of 3SAT, and consider a truth assignment that satisfies all clauses. We can then construct a policy in \u03a0t,s (and a fortiori in \u03a0t,s,u, whose total reward is zero (and therefore has zero variance) as follows. If xi is set to be true (respectively, false), we choose action bi (respectively, ai) at state yi. At state cj we choose an action associated with a literal that makes the clause to be true. Suppose that state cj is visited after the first transition, i.e., S1 = cj . If the literal associated with the selected action at cj is unnegated, e.g., the literal xi, then the immediate reward is 1. Since this literal makes the clause to be true, it follows that the action chosen at the subsequent state, yi, is bi, resulting in a reward of \u22121, and a total reward of zero. The argument for the case where the literal associated with the selected action at state cj is negated is similar. It follows that the total reward is zero, with probability 1.\nFor the converse direction, suppose that there exists a policy in \u03a0t,s, or more generally, in \u03a0t,s,u under which the variance of the total reward is zero. Since the total reward is equal to 0 whenever the first transition leads to state d0 (which happens with probability 1/(m + 1), it follows that the total reward must be always zero. Consider now the following truth assignment: xi is set to be true if and only if the policy chooses action bi at state yi, with positive probability. Suppose that the state visited after the first transition is cj . Suppose that the action chosen at state cj leads next to state yi and that the literal xi\n10\nappears unnegated in clause Cj . Then, the reward at state cj is 1, which implies that the reward at state yi is \u22121. It follows that the action chosen at yi is bi, and therefore xi has been set to be true. It follows that clause Cj is satisfied. A similar argument shows that clause Cj is satisfied when the literal xi associated with the chosen action at cj appears negated. In either case, we conclude that clause Cj is satisfied. Since every state cj is possible at time 1, it follows that every clause is satisfied, and we have a \u201cyes\u201d instance of 3SAT. q.e.d."}, {"heading": "V. EXACT ALGORITHMS", "text": "The comparison and complexity results of the preceding two sections indicate that the policy classes \u03a0t,s, \u03a0t,s,w, \u03a0t,s,u, and \u03a0h are inferior to the class \u03a0h,u, and furthermore some of them (\u03a0t,s, \u03a0t,s,w) appear to have higher complexity. Thus, there is no reason to consider them further. While the problem MV-MDP(\u03a0h,u) is NP-hard, there is still a possibility for approximate or pseudopolynomial time algorithms. In this section, we focus on exact pseudopolynomial time algorithms.\nOur approach involves an augmented state, defined by Xt = (St,Wt). Let X be the set of all possible values of the augmented state. Let |S| be the cardinality of the set S. Let |R| be the cardinality of the set R. Recall also that K = maxr\u2208R |r|. If we assume that the immediate rewards are integers, then Wt is an integer between \u2212KT and KT . In this case, the cardinality |X | of the augmented state space X is bounded by |S| \u00b7 (2KT + 1), which is polynomial. Without the integrality assumption, the cardinality of the set X remains finite, but it can increase exponentially with T . For this reason, we study the integer case separately in Section V-B."}, {"heading": "A. State-Action Frequencies", "text": "In this section, we provide some results on the representation of MDPs in terms of a state-action\nfrequency polytope, thus setting the stage for our subsequent algorithms.\nFor any policy \u03c0 \u2208 \u03a0h,u, and any x \u2208 X , a \u2208 A, we define the state-action frequencies at time t by\nz\u03c0t (x, a) = P\u03c0(Xt = x,At = a), t = 0, 1, . . . , T \u2212 1,\nand\nz\u03c0t (x) = P\u03c0(Xt = x), t = 0, 1, . . . , T.\nLet z\u03c0 be a vector that lists all of the above defined state-action frequencies.\n11\nFor any family \u03a0 of policies, let Z(\u03a0) = {z\u03c0 | \u03c0 \u2208 \u03a0}. The following result is well known (e.g., Altman, 1999). It asserts that any feasible state-action frequency vector can be attained by policies that depend only on time, the (augmented) state, and a randomization variable. Furthermore, the set of feasible state-action frequency vectors is a polyhedron, hence amenable to linear programming methods.\nTheorem 5. (a) We have Z(\u03a0h,u) = Z(\u03a0t,s,w,u).\n(b) The set Z(\u03a0h,u) is a polyhedron, specified by O(T \u00b7 |X | \u00b7 |A|) linear constraints.\nNote that a certain mean-variance pair (\u03bb, v) is attainable by a policy in \u03a0h,u if and only if there exists\nsome z \u2208 Z(\u03a0h,u) that satisfies\n\u2211\n(s,w)\u2208X\nwzT (s, w) = \u03bb, (1)\n\u2211\n(s,w)\u2208X\nw2zT (s, w) = v + \u03bb 2. (2)\nFurthermore, since Z(\u03a0h,u) = Z(\u03a0t,s,w,u), it follows that if a pair (\u03bb, v) is attainable by a policy in \u03a0h,u, it is also attainable by a policy in \u03a0t,s,w,u. This establishes the following result.\nTheorem 6. The policy classes \u03a0h,u and \u03a0t,s,w,u are equivalent.\nNote that checking the feasibility of the conditions z \u2208 Z(\u03a0h,u), (1), and (2) amounts to solving a linear programming problem, with a number of constraints proportional to the cardinality of the augmented state space X and, therefore, in general, exponential in T .\nB. Integer Rewards\nIn this section, we assume that the immediate rewards are integers, with absolute value bounded by K, and we show that pseudopolynomial time algorithms are possible. Recall that an algorithm is a pseudopolynomial time algorithm if its running time is polynomial in K and the instance size. (This is in contrast to polynomial time algorithms in which the running time can only grow as a polynomial of logK.)\nTheorem 7. Suppose that the immediate rewards are integers, with absolute value bounded by K. Consider the following two problems:\n(i) determine whether there exists a policy in \u03a0h,u for which (J\u03c0, V\u03c0) = (\u03bb, v), where \u03bb and v are given\nrational numbers; and,\n12\n(ii) determine whether there exists a policy in \u03a0h,u for which J\u03c0 = \u03bb and V\u03c0 \u2264 v, where \u03bb and v are\ngiven rational numbers.\nThen,\n(a) these two problems admit a pseudopolynomial time algorithm; and, (b) unless P=NP, these problems cannot be solved in polynomial time.\nProof.\n(a) As already discussed, these problems amount to solving a linear program. In the integer case, the\nnumber of variables and constraints is bounded by a polynomial in K and the instance size. The result follows because linear programming can be solved in polynomial time.\n(b) This is proved by considering the special case where \u03bb = v = 0 and the exact same argument as in\nthe proof of Theorem 3. q.e.d.\nSimilar to constrained MDPs, mean-variance optimization involves two different performance criteria. Unfortunately, however, the linear programming approach to constrained MDPs does not translate into an algorithm for the problem MV-MDP(\u03a0h,u). The reason is that the set\nPMV = {(J\u03c0, V\u03c0) | \u03c0 \u2208 \u03a0h,u}\nof achievable mean-variance pairs need not be convex. To bring the constrained MDP methodology to bear on our problem, instead of focusing on the pair (J\u03c0, V\u03c0), we define Q\u03c0 = E\u03c0[W 2T ], and focus on the pair (J\u03c0, Q\u03c0). This is now a pair of objectives that depend linearly on the state frequencies associated with the final augmented state XT . Accordingly, we define\nPMQ = {(J\u03c0, Q\u03c0) | \u03c0 \u2208 \u03a0h,u}.\nNote that PMQ is a polyhedron, because it is the image of the polyhedron Z(\u03a0h,u) under the linear mapping specified by the left-hand sides of Eqs. (1)-(2). In contrast, PMV is the image of PMQ under a nonlinear mapping:\nPMV = {(\u03bb, q \u2212 \u03bb 2) | (\u03bb, q) \u2208 PMQ},\nand is not, in general, a polyhedron.\nAs a corollary of the above discussion, and for the case of integer rewards, we can exploit convexity to devise pseudopolynomial algorithms for problems that can be formulated in terms of the convex\n13\nset PMQ. On the other hand, because of the non-convexity of PMV , we have not been able to devise pseudopolynomial time algorithms for the problem MV-MDP(\u03a0h,u), or even the simpler problem of deciding whether there exists a policy \u03c0 \u2208 \u03a0h,u that satisfies V\u03c0 \u2264 v, for some given number v, except for the very special case where v = 0, which is the subject of our next result. For a general v, an approximation algorithm will be presented in the next section.\nTheorem 8. (a) If there exists some \u03c0 \u2208 \u03a0h,u for which V\u03c0 = 0, then there exists some \u03c0\u2032 \u2208 \u03a0t,s,w for\nwhich V\u03c0\u2032 = 0.\n(b) Suppose that the immediate rewards are integers, with absolute value bounded by K. Then the problem\nof determining whether there exists a policy \u03c0 \u2208 \u03a0h,u for which V\u03c0 = 0 admits a pseudopolynomial time algorithm.\nProof.\n(a) Suppose that there exists some \u03c0 \u2208 \u03a0h,u for which V\u03c0 = 0. By Theorem 6, \u03c0 can be assumed,\nwithout loss of generality, to lie in \u03a0t,s,w,u. Let Var\u03c0(WT |U0:T ), be the conditional variance of WT , conditioned on the realization of the randomization variables U0:T . We have Var\u03c0(WT ) \u2265 E\u03c0[Var\u03c0(WT |U0:T )], which implies that there exists some u0:T such that Var\u03c0(WT |U0:T = u0:T ) = 0. By fixing the randomization variables to this particular u0:T , we obtain a deterministic policy, in \u03a0t,s,w under which the reward variance is zero.\n(b) If there exists a policy under which V\u03c0 = 0, then there exists an integer k, with |k| \u2264 KT such that,\nunder this policy, WT is guaranteed to be equal to k. Thus, we only need to check, for each k in the relevant range, whether there exists a policy such that (J\u03c0, V\u03c0) = (k, 0). By Theorem 7, this can be done in pseudopolynomial time. q.e.d.\nThe approach in the proof of part (b) above leads to a short argument, but yields a rather inefficient (albeit pseudopolynomial) algorithm. A much more efficient and simple algorithm is obtained by realizing that the question of whether WT can be forced to be k, with probability 1, is just a reachability game: the decision maker picks the actions and an adversary picks the ensuing transitions and rewards (among those that have positive probability of occurring). The decision maker wins the game if it can guarantee that WT = k. Such sequential games are easy to solve in time polynomial in the number of (augmented) states, decisions, and the time horizon, by a straightforward backward recursion. On the other hand a\n14\ngenuinely polynomial time algorithm does not appear to be possible; indeed, the proof of Theorem 3 shows that the problem is NP-complete."}, {"heading": "VI. APPROXIMATION ALGORITHMS", "text": "In this section, we deal with the optimization counterparts of the problem MV-MDP(\u03a0h,u). We are\ninterested in computing approximately the following two functions:\nv\u2217(\u03bb) = inf {\u03c0\u2208\u03a0h,u:J\u03c0\u2265\u03bb} V\u03c0, (3)\nand\n\u03bb\u2217(v) = sup {\u03c0\u2208\u03a0h,u:V\u03c0\u2264v} J\u03c0. (4)\nIf the constraint J\u03c0 \u2265 \u03bb (respectively, V\u03c0 \u2264 v) is infeasible, we use the standard convention v\u2217(\u03bb) = \u221e (respectively, \u03bb\u2217(v) = \u2212\u221e). Note that the infimum and supremum in the above definitions are both attained, because the set PMV of achievable mean-variance pairs is the image of the polyhedron PMQ under a continuous map, and is therefore compact.\nWe do not know how to efficiently compute or even generate a uniform approximation of either v\u2217(\u03bb) or \u03bb\u2217(v) (i.e., find a value v\u2032 between v\u2217(\u03bb)\u2212 \u01eb and v\u2217(\u03bb) + \u01eb, and similarly for \u03bb\u2217(v)). In the following two results we consider a weaker notion of approximation that is computable in pseudopolynomial time. We discuss v\u2217(\u03bb) as the issues for \u03bb\u2217(v) are similar.\nFor any positive \u01eb and \u03bd, we will say that v\u0302(\u00b7) is an (\u01eb, \u03bd)-aproximation of v\u2217(\u00b7) if, for every \u03bb,\nv\u2217(\u03bb\u2212 \u03bd)\u2212 \u01eb \u2264 v\u0302(\u03bb) \u2264 v\u2217(\u03bb+ \u03bd) + \u01eb. (5)\nThis is an approximation of the same kind as those considered in Papadimitriou and Yannakakis (2000): it returns a value v\u0302 such that (\u03bb, v\u0302) is an element of the \u201c(\u01eb + \u03bd)-approximate Pareto boundary\u201d of the set PMV . For a different view, the graph of the function v\u0302(\u00b7) is within Hausdorf distance \u01eb+ \u03bd from the graph of the function v\u2217(\u00b7).\nWe will show how to compute an (\u01eb, \u03bd)-aproximation in time which is pseudopolynomial, and polyno-\nmial in the parameters 1/\u01eb, and 1/\u03bd.\nWe start in Section VI-A with the case of integer rewards, and build on the pseudopolynomial time algorithms of the preceding section. We then consider the case of general rewards in Section VI-B. We finally sketch an alternative algorithm in Section VI-C based on set-valued dynamic programming.\n15\nA. Integer Rewards\nIn this section, we prove the following result.\nTheorem 9. Suppose that the immediate rewards are integers. There exists an algorithm that, given \u01eb, \u03bd, and \u03bb, outputs a value v\u0302(\u03bb) that satisfies (5), and which runs in time polynomial in |S|, |A|, T , K, 1/\u01eb, and 1/\u03bd.\nProof. Since the rewards are bounded in absolute value by K, we have v\u2217(\u03bb) = \u221e for \u03bb > KT and v\u2217(\u03bb) = v\u2217(\u2212KT ) for \u03bb < \u2212KT . For this reason, we only need to consider \u03bb \u2208 [\u2212KT,KT ]. To simplify the presentation, we assume that \u01eb = \u03bd. We let \u03b4 be such that \u01eb = 3\u03b4KT .\nThe algorithm is as follows. We consider grid points \u03bbi defined by \u03bbi = \u2212KT +(i\u22121)\u03b4, i = 1, . . . , n, where n is chosen so that \u03bbn\u22121 \u2264 KT , \u03bbn > KT . Note that n = O(KT/\u03b4). For i = 1, . . . , n \u2212 1, we calculate q\u0302(\u03bbi), the smallest possible value of E[W 2T ], when E[WT ] is restricted to lie in [\u03bbi, \u03bbi+1]. Formally,\nq\u0302(\u03bbi) = min { q \u2223 \u2223 \u2203 \u03bb\u2032 \u2208 [\u03bbi, \u03bbi+1] s.t. (\u03bb \u2032, q) \u2208 PMQ } .\nWe let u\u0302(\u03bbi) = q\u0302(\u03bbi)\u2212 \u03bb2i+1, which can be interpreted as an estimate of the least possible variance when E[WT ] is restricted to the interval [\u03bbi, \u03bbi+1]. Finally, we set\nv\u0302(\u03bb) = min i\u2265k u\u0302(\u03bbi), if \u03bb \u2208 [\u03bbk, \u03bbk+1].\nThe main computational effort is in computing q\u0302(\u03bbi) for every i. Since PMQ is a polyhedron, this amounts to solving O(KT/\u03b4) linear programming problems. Thus, the running time of the algorithm has the claimed properties.\nWe now prove correctness. Let q\u2217(\u03bb) = min{q | (\u03bb, q) \u2208 PMQ}, and u\u2217(\u03bb) = q\u2217(\u03bb)\u2212 \u03bb2, which is the\nleast possible variance for a given value of \u03bb. Note that v\u2217(\u03bb) = min{u\u2217(\u03bb\u2032) | \u03bb\u2032 \u2265 \u03bb}.\nWe have q\u0302(\u03bbi) \u2264 q\u2217(\u03bb\u2032), for all \u03bb\u2032 \u2208 [\u03bbi, \u03bbi+1]. Also, \u2212\u03bb2i+1 \u2264 \u2212(\u03bb \u2032)2, for all \u03bb\u2032 \u2208 [\u03bbi, \u03bbi+1]. By adding these two inequalities, we obtain u\u0302(\u03bbi) \u2264 u\u2217(\u03bb\u2032), for all \u03bb\u2032 \u2208 [\u03bbi, \u03bbi+1]. Given some \u03bb, let k be such that \u03bb \u2208 [\u03bbk, \u03bbk+1]. Then,\nv\u0302(\u03bb) = min i\u2265k u\u0302(\u03bbi) \u2264 min \u03bb\u2032\u2265\u03bbk u\u2217(\u03bb\u2032) \u2264 min \u03bb\u2032\u2265\u03bb u\u2217(\u03bb\u2032) = v\u2217(\u03bb\u2032),\nso that v\u0302(\u03bb) is always an underestimate of v\u2217(\u03bb).\n16\nWe now prove a reverse inequality. Fix some \u03bb and let k be such that \u03bb \u2208 [\u03bbk, \u03bbk+1]. Let i \u2265 k be\nsuch that v\u0302(\u03bb) = u\u0302(\u03bbi). Let also \u03bb\u0304 \u2208 [\u03bbi, \u03bbi+1] be such that q\u2217(\u03bb\u0304) = q\u0302(\u03bbi). Note that\n\u03bb2i+1 \u2212 \u03bb\u0304 2 \u2264 \u03bb2i+1 \u2212 \u03bb 2 i = \u03b4(\u03bbi + \u03bbi+1) \u2264 2\u03b4(KT + \u03b4) \u2264 3\u03b4KT. (6)\nThen,\nv\u0302(\u03bb) (a) = u\u0302(\u03bbi) (b) = q\u0302(\u03bbi)\u2212 \u03bb 2 i+1 (c) = q\u2217(\u03bb\u0304)\u2212 \u03bb2i+1\n(d) \u2265 q\u2217(\u03bb\u0304)\u2212 \u03bb\u03042 \u2212 3\u03b4KT\n(e) = u\u2217(\u03bb\u0304)\u2212 3\u03b4KT\n(f) \u2265 v\u2217(\u03bb\u0304)\u2212 3\u03b4KT (g) \u2265 v\u2217(\u03bb\u2212 \u03b4)\u2212 3\u03b4KT\n(h) \u2265 v\u2217(\u03bb\u2212 \u01eb)\u2212 \u01eb.\nIn the above, (a) holds by the definition of i; (b) by the definition of u\u0302(\u03bbi); (c) by the definition of \u03bb\u0304; and (d) follows from Eq. (6). Equality (e) follows from the definition of u\u2217(\u00b7). Inequality (f) follows from the definition of v\u2217(\u00b7); and (g) is obtained because v\u2217(\u00b7) is nondecreasing and because \u03bb\u0304 \u2265 \u03bb \u2212 \u03b4. (The latter fact is seen as follows: (i) if i > k, then \u03bb \u2264 \u03bbk+1 \u2264 \u03bbi \u2264 \u03bb\u0304; (ii) if i = k, then both \u03bb and \u03bb\u0304 belong to [\u03bbk, \u03bbk+1], and their difference is at most \u03b4.) Inequality (h) is obtained because of the definition \u01eb = 3\u03b4KT , the observation \u03b4 < \u01eb, and the monotonicity of v\u2217(\u00b7). q.e.d."}, {"heading": "B. General Rewards", "text": "When rewards are arbitrary, we can discretize the rewards and obtain a new MDP. The new MDP is equivalent to one with integer rewards to which the algorithm of the preceding subsection can be applied. This is a legitimate approximation algorithm for the original problem because, as we will show shortly, the function v\u2217(\u00b7) changes very little when we discretize using a fine enough discretization.\nWe are given an original MDP M = (T,S,A,R, p, g) in which the rewards are rational numbers in the interval [\u2212K,K], and an approximation parameter \u01eb. We fix a positive number \u03b4, a discretization parameter whose value will be specified later. We then construct a new MDP M\u2032 = (T,S,A,R\u2032, p, g\u2032), in which the rewards are rounded down to an integer multiple of \u03b4. More precisely, all elements of the reward range R\u2032 are integer multiples of \u03b4, and for every t, s, a \u2208 {0, 1, . . . , T \u2212 1} \u00d7 S \u00d7 A, and any integer n, we have\ngt(\u03b4n | s, a) = \u2211\nr: \u03b4n\u2264r<\u03b4(n+1)\ngt(r | s, a).\n17\nWe denote by J , Q and by J \u2032, Q\u2032 the first and second moments of the total reward in the original and new MDPs, respectively. Let \u03a0h,u and \u03a0\u2032h,u be the sets of (randomized, history-based) policies in M and M\u2032, respectively. Let PMQ and P \u2032MQ be the associated polyhedra.\nWe want to to argue that the mean-variance tradeoff curves for the two MDPs are close to each other. This is not entirely straightforward because the augmented state spaces (which include the possible values of the cumulative rewards Wt) are different for the two problems and, therefore, the sets of policies are also different. A conceptually simple but somewhat tedious approach involves an argument along the lines of Whitt (1978, 1979), generalized to the case of constrained MDPs; we outline such an argument in Section VI-C. Here, we follow an alternative approach, based on a coupling argument.\nProposition 1. There exists a polynomial function c(K, T ) such that the Hausdorf distance between PMQ and P \u2032MQ is bounded above by 2KT 2\u03b4. More precisely,\n(a) For every policy \u03c0 \u2208 \u03a0h,u, there exists a policy \u03c0\u2032 \u2208 \u03a0\u2032h,u such that\nmax {\n|J \u2032\u03c0\u2032 \u2212 J\u03c0|, |Q \u2032 \u03c0\u2032 \u2212Q\u03c0|\n}\n\u2264 2KT 2\u03b4.\n(b) Conversely, for every policy \u03a0\u2032h,u, there exists a policy \u03a0h,u such that the above inequality again\nholds.\nProof. We denote by d(r) the discretized value of a reward r, that is, d(r) = max{n\u03b4 : n\u03b4 \u2264 r, n \u2208 Z}. Let us consider a third MDP M\u2032\u2032 which is identical to M\u2032, except that its rewards R\u2032\u2032t are generated as follows. (We follow the convention of using a single or double prime to indicate variables associated with M\u2032 or M\u2032\u2032, respectively.) A random variable Rt is generated according to the distribution prescribed by gt(r | st, at), and its value is observed by the decision maker, who then incurs the reward R\u2032\u2032t = d(Rt). Let P \u2032\u2032MQ be the polyhedron associated with M \u2032\u2032. We claim that P \u2032\u2032MQ = P \u2032 MQ. The only difference between M\u2032 and M\u2032\u2032 is that the decision maker in M\u2032\u2032 has access to the additional information Rt \u2212 d(Rt). However, this information is incosequential: it does not affect the future transition probabilities or reward distributions.Thus, Rt\u2212d(Rt) can only be useful as an additional randomization variable. Since P \u2032MQ is the set of achievable pairs using general (history-based randomized) policies, having available an additional randomization variable does not change the polyhedron, and P \u2032\u2032MQ = P \u2032 MQ. Thus, to complete the proof it suffices to show that the polyhedra PMQ and P \u2032\u2032MQ are close.\nLet us compare the MDPs M and M\u2032\u2032. The information available to the decision maker is the same\n18\nfor these two MDPs (since all the history of reward truncations {R\u03c4 \u2212 d(R\u03c4 )} t\u22121 \u03c4=1 is available in M \u2032\u2032 for the decision at time t). Therefore, for every policy in one MDP, there exists a policy for the other under which (if we define the two MDPs on a common probability space, involving common random generators) the exact same sequence of states (St = S \u2032t), actions (At = A \u2032 t), and random variables Rt is realized. The only difference is that the rewards are Rt and d(Rt), in M and M\u2032\u2032, respectively. Recall that 0 \u2264 Rt \u2212 d(Rt) \u2264 \u03b4. We obtain that for every policy \u03c0 \u2208 \u03a0, there exists a policy \u03c0\u2032\u2032 \u2208 \u03a0\u2032\u2032 for which 0 \u2264 WT \u2212W \u2032\u2032 T = \u2211T\u22121 \u03c4=0 ( Rt\u2212d(Rt)) \u2264 \u03b4T , and therefore, |W 2T \u2212 (W \u2032\u2032 T ) 2| \u2264 2KT 2\u03b4. Taking expectations, we obtain |J\u03c0 \u2212 J \u2032\u2032\u03c0 | \u2264 T\u03b4, |Q\u03c0 \u2212Q \u2032\u2032 \u03c0| \u2264 2KT 2\u03b4. This completes the proof of part (a). The proof of part (b) is identical. q.e.d.\nTheorem 10. There exists an algorithm that, given \u01eb, \u03bd, and \u03bb, outputs a value v\u0302(\u03bb) that satisfies (5), and which runs in time polynomial in |S|, |A|, T , K, 1/\u01eb, and 1/\u03bd.\nProof. Assume for simplicity that \u03bd = \u01eb. Given the value of \u01eb, let \u03b4 be such that \u01eb/2 = 2KT 2\u03b4, and construct the discretized MDP M\u2032. Run the algorithm from Theorem 9 to find an (\u01eb/2, \u01eb/2)-approximation v\u0302 for M\u2032. Using Proposition 1, it is not hard to verify that this yields an (\u01eb, \u01eb)-approximation of v\u2217(\u03bb). q.e.d."}, {"heading": "C. An Exact Algorithm and its Approximation", "text": "There are two general approaches for constructing approximation algorithms. (i) One can discretize the problem, to obtain an easier one, and then apply an algorithm specially tailored to the discretized problem; this was the approach in the preceding subsection. (ii) One can design an exact (but inefficient) algorithm for the original problem and then implement the algorithm approximately. This approach will work provided the approximations do not build up excessively in the course of the algorithm. In this subsection, we elaborate on the latter approach.\nWe defined earlier the polyhedron PMQ as the set of achievable first and second moments of the cumulative reward starting at time zero at the initial state. We extend this definition by considering intermediate times and arbitrary (intermediate) augmented states. We let\nCt(s, w) = { (\u03bb, q) : \u2203\u03c0 \u2208 \u03a0h,u s.t. E\u03c0[WT | St = s, Wt = w] = \u03bb and (7)\nE\u03c0[W 2 T | St = s, Wt = w) = q\n}\n.\n19\nClearly, C0(s, 0) = PMQ. Using a straightforward backwards induction, it can be shown that Ct(\u00b7, \u00b7) satisfies the set-valued dynamic programming recursion 2\nCt(s, w) = conv a\u2208A\n{\n\u2211\ns\u2032\u2208S\npt(s \u2032 | s, a)\n\u2211\nr\u2208R\ngt(r | s, a)Ct+1(s \u2032, w + r)\n}\n, (8)\nfor every s \u2208 S, w \u2208 R, and for t = 0, 1, 2, . . . , T \u2212 1, initialized with the boundary conditions\nCT (s, w) = {(w,w 2)}. (9)\nA simple inductive proof shows that the sets Ct(s, w) are polyhedra; this is because CT (s, w) is either empty or a singleton and because the sum or convex hull of finitely many polyhedra is a polyhedron. Thus, the recursion involves a finite amount of computation, e.g., by representing each polyhedron in terms of its finitely many extreme points. In the worst case, this translates into an exponential time algorithm, because of the possibly large number of extreme points. However, such an algorithm can also be implemented approximately. If we allow for the introduction of an O(\u01eb/T ) error at each stage (where error is measured in terms of the Hausdorf distance), we can work with approximating polyhedra that involve only O(1/\u01eb) extreme points, while ending up with a O(\u01eb) total error; this is because we are approximating polyhedra in the plane, as opposed to higher dimensions where the dependence on \u01eb would have been worse dependence. The details are straightforward but somewhat tedious and are omitted. On the other hand, in practice, this approach is likely to be faster than the algorithm of the preceding subsection."}, {"heading": "VII. CONCLUSIONS", "text": "We have shown that mean-variance optimization problems for MDPs are typically NP-hard, but sometimes admit pseudopolynomial approximation algorithms. We only considered finite horizon problems, but it is clear that the negative results carry over to their infinite horizon counterparts. Furthermore, given that the contribution of the tail of the time horizon in infinite horizon discounted problems (or in \u201cproper\u201d stochastic shortest path problems as in Bertsekas (1995)) can be made arbitrarily small, our approximation algorithms can also yield approximation algorithms for infinite horizon problems.\nTwo more problems of some interest deal with finding a policy that has the smallest possible, or the\nlargest possible variance. There is not much we can say here, except for the following:\n2If X and Y are subsets of a vector space and \u03b1 a scalar, we let \u03b1X = {\u03b1x | x \u2208 X} and X + Y = {x + y | x \u2208 X, y \u2208 Y }. Furthermore, if for every a \u2208 A, we have a set X\u03b1, then conva\u2208A{X\u03b1} is the convex hull of the union of these sets.\n20\n(a) The smallest possible variance is attained by a deterministic policy, that is,\nmin \u03c0\u2208\u03a0h,u V\u03c0 = min \u03c0\u2208\u03a0h V\u03c0.\nThis is proved using the inequality Var\u03c0(WT ) \u2265 E\u03c0[Var\u03c0(WT |U0:T )].\n(b) Variance will be maximized, in general, by a randomized policy. To see this, consider a single stage\nproblem and two actions with deterministic rewards, equal to 0 and 1, respectively. Variance is maximized by assigning probability 1/2 to each of the actions. The variance maximization problem is equivalent to maximizing the concave function q\u2212\u03bb2 subject to (\u03bb, q) \u2208 PMQ. This is a quadratic programming problem over the polyhedron PMQ and therefore admits a pseudopolynomial time algorithm, when the rewards are integer.\nOur results suggest several interesting directions for future research, which we briefly outline below. First, our negative results apply to general MDPs. It would be interesting to determine whether the hardness results remain valid for specially structured MDPs. One possibly interesting special case involves multi-armed bandit problems: there are n separate MDPs (\u201carms\u201d); at each time step, the decision maker has to decide which MDP to activate, while the other MDPs remain inactive. Of particular interest here are index policies that compute a value (\u201cindex\u201d) for each MDP and select an MDP with maximal index; such policies are often optimal for the classical formulations (see Gittins (1979) and Whittle (1988)). Obtaining a policy that uses some sort of an index for the mean-variance problem or alternatively proving that such a policy cannot exist would be interesting.\nSecond, a number of complexity questions have been left open. We list a few of them:\n(a) Is there a pseudopolynomial time algorithm for computing v\u2217(\u03bb) or \u03bb\u2217(v) exactly? (b) Is there a polynomial or pseudopolynomial time algorithm that computes v\u2217(\u03bb) or \u03bb\u2217(v) within a\nuniform error bound \u01eb?\n(c) Is the problem of computing v\u0302(\u03bb) with the properties in Eq. (5) NP-hard? (d) Is there a pseudopolynomial time algorithm the smallest possible variance in the absence of any\nconstraints on the mean cumulative reward?\nThird, bias-variance tradeoffs may pay an important role in speeding up certain control and learning heuristics, such as those involving control variates (Meyn, 2008). Perhaps mean-variance optimization can be used to address the exploration/exploitation tradeoff in model-based reinforcement learning, with\n21\nvariance reduction serving as a means to reduce the exploration time (see Sutton and Barto (1998) for a general discussion of exploration-exploitation in reinforcement learning). Of course, in light of the computational complexity of bias-variance tradeoffs, incorporating bias-variance tradeoffs in learning makes sense only if experimentation is nearly prohibitive and computation time is cheap. Such an approach could be particularly useful if a coarse, low-complexity, approximate solution of a bias-variance tradeoff problem can result in significant exploration speedup.\nFourth, we only considered mean-variance tradeoffs in this paper. However, there are other interesting and potentially useful criteria that can be used to incorporate risk into multi-stage decision making. For example, Liu and Koenig (2005) consider a utility function with a single switch. Many other risk aware criteria have been considered in the single stage case. It would be interesting to develop a comprehensive theory for the complexity of solving multi-stage decision problems under general (monotone convex or concave) utility function and under risk constraints. This is especially interesting for the approximation algorithms presented in Section VI.\nAcknowledgments: This research was partially supported by the Israel Science Foundation (contract\n890015), a Horev Fellowship, and the National Science Foundation under grant CMMI-0856063.\nREFERENCES\nAltman, E. (1999). Constrained Markov decision processes. Chapman and Hall. Artzner, P., Delbaen, F., Eber, J., & Heath, D. (1999). Coherent measures of risk. Mathematical Finance, 9(3), 203-228. Bertsekas, D. (1995). Dynamic programming and optimal control. Athena Scientific. Chung, K., & Sobel, M. (1987). Discounted MDP\u2019s: distribution functions and exponential utility maximization. SIAM Journal on Control and Optimization, 25(1), 49 - 62. Garey, M. R., & Johnson, D. S. (1979). Computers and intractability: a guide to the theory of npcompleteness. New York: W.H. Freeman. Gittins, J. C. (1979). Bandit processes and dynamic allocation indices. Journal of the Royal Statistical Society. Series B (Methodological), 41(2), 148\u2013177. Iyengar, G. (2005). Robust dynamic programming. Mathematics of Operations Research, 30, 257-280. Le Tallec, Y. (2007). Robust, risk-sensitive, and data-driven control of Markov decision processes. Unpublished doctoral dissertation, Operations Research Center, MIT, Cambridge, MA. Liu, Y., & Koenig, S. (2005). Risk-sensitive planning with one-switch utility functions: Value iteration. In Proceedings of the twentieth AAAI conference on artificial intelligence (p. 993-999). Luenberger, D. (1997). Investment science. Oxford University Press. Meyn, S. P. (2008). Control techniques for complex networks. New York NY: Cambridge University Press. Nilim, A., & El Ghaoui, L. (2005). Robust Markov decision processes with uncertain transition matrices. Operations Research, 53(5), 780-798. Papadimitriou, C. H., & Yannakakis, M. (2000). On the approximability of trade-offs and optimal access of\nweb sources. In Proceedings of the 41st symposium on foundations of computer science (p. 86-92). Washington, DC, USA.\n22\nRiedel, F. (2004). Dynamic coherent risk measures. Stoch. Proc. Appl., 112, 185-200. Shapley, L. (1953). Stochastic games. Proc. of National Academy of Science, Math., 1095-1100. Sobel, M. (1982). The variance of discounted Markov decision processes. Journal of Applied Probability, 19, 794-802. Sutton, R. S., & Barto, A. G. (1998). Reinforcement learning: An introduction. MIT Press. Whitt, W. (1978). Approximation of dynamic programs \u2013 I. Mathematics of Operations Research, 3, 231-243. Whitt, W. (1979). Approximation of dynamic programs \u2013 II. Mathematics of Operations Research, 4, 179-185. Whittle, P. (1988). Restless bandits: Activity allocation in a changing world. Journal of Applied\nProbability, 25, 287\u2013298."}], "references": [{"title": "Constrained Markov decision processes", "author": ["E. Altman"], "venue": null, "citeRegEx": "Altman,? \\Q1999\\E", "shortCiteRegEx": "Altman", "year": 1999}, {"title": "Bandit processes and dynamic allocation indices", "author": [], "venue": "Journal of the Royal Statistical", "citeRegEx": "Gittins,? \\Q1979\\E", "shortCiteRegEx": "Gittins", "year": 1979}, {"title": "Robust dynamic programming", "author": ["G. Iyengar"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Iyengar,? \\Q2005\\E", "shortCiteRegEx": "Iyengar", "year": 2005}, {"title": "Robust Markov decision processes with uncertain transition matrices", "author": ["A. Press. Nilim", "L. El Ghaoui"], "venue": null, "citeRegEx": "Nilim and Ghaoui,? \\Q2005\\E", "shortCiteRegEx": "Nilim and Ghaoui", "year": 2005}, {"title": "On the approximability of trade-offs and optimal access", "author": ["C.H. Papadimitriou", "M. Yannakakis"], "venue": "Operations Research,", "citeRegEx": "Papadimitriou and Yannakakis,? \\Q2000\\E", "shortCiteRegEx": "Papadimitriou and Yannakakis", "year": 2000}, {"title": "Dynamic coherent risk measures", "author": ["F. Riedel"], "venue": "Stoch. Proc. Appl.,", "citeRegEx": "Riedel,? \\Q2004\\E", "shortCiteRegEx": "Riedel", "year": 2004}, {"title": "Reinforcement learning: An introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Sutton and Barto,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto", "year": 1998}, {"title": "Approximation of dynamic programs \u2013 II", "author": ["W. 231-243. Whitt"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Whitt,? \\Q1979\\E", "shortCiteRegEx": "Whitt", "year": 1979}], "referenceMentions": [{"referenceID": 5, "context": "(Riedel, 2004), problems of this type can be difficult (Le Tallec, 2007), except for some special cases (Iyengar, 2005; Nilim & El Ghaoui, 2005) that can be reduced to Markov games (Shapley, 1953).", "startOffset": 0, "endOffset": 14}, {"referenceID": 2, "context": "(Riedel, 2004), problems of this type can be difficult (Le Tallec, 2007), except for some special cases (Iyengar, 2005; Nilim & El Ghaoui, 2005) that can be reduced to Markov games (Shapley, 1953).", "startOffset": 104, "endOffset": 144}, {"referenceID": 0, "context": "Nevertheless, E[W ] and E[W ] are linear functions, and as such can be addressed simultaneously using methods from multicriteria or constrained Markov decision processes (Altman, 1999).", "startOffset": 170, "endOffset": 184}, {"referenceID": 1, "context": "(Riedel, 2004), problems of this type can be difficult (Le Tallec, 2007), except for some special cases (Iyengar, 2005; Nilim & El Ghaoui, 2005) that can be reduced to Markov games (Shapley, 1953). Mean-variance optimization lacks some of the desirable properties of approaches involving coherent risk measures and sometimes leads to counterintuitive policies. Bellman\u2019s principle of optimality does not hold, and as a consequence, a decision maker who has received unexpectedly large rewards in the first stages, may actively seek to incur losses in subsequent stages in order to keep the variance small. Nevertheless, mean-variance optimization is an important approach in financial decision making (e.g., Luenberger, 1997), especially for static (one-stage) problems. Consider, for example, a fund manager who is interested in the 1-year performance of the fund, as measured by the mean and variance of the return. Assuming that the manager is allowed to undertake periodic re-balancing actions in the course of the year, one obtains a Markov decision process with mean-variance criteria. Mean-variance optimization can also be a meaningful objective in various engineering contexts. Consider, for example, an engineering process whereby a certain material is deposited on a surface. Suppose that the primary objective is to maximize the amount deposited, but that there is also an interest in having all manufactured components be similar to each other; this secondary objective can be addressed by keeping the variance of the amount deposited small. We note that expressions for the variance of the discounted reward for stationary policies were developed in Sobel (1982). However, these expressions are quadratic in the underlying transition probabilities, and do not lead to convex optimization problems.", "startOffset": 105, "endOffset": 1677}, {"referenceID": 4, "context": "This is an approximation of the same kind as those considered in Papadimitriou and Yannakakis (2000): it returns a value v\u0302 such that (\u03bb, v\u0302) is an element of the \u201c(\u01eb + \u03bd)-approximate Pareto boundary\u201d of the set PMV .", "startOffset": 65, "endOffset": 101}, {"referenceID": 1, "context": "Of particular interest here are index policies that compute a value (\u201cindex\u201d) for each MDP and select an MDP with maximal index; such policies are often optimal for the classical formulations (see Gittins (1979) and Whittle (1988)).", "startOffset": 197, "endOffset": 212}, {"referenceID": 1, "context": "Of particular interest here are index policies that compute a value (\u201cindex\u201d) for each MDP and select an MDP with maximal index; such policies are often optimal for the classical formulations (see Gittins (1979) and Whittle (1988)).", "startOffset": 197, "endOffset": 231}], "year": 2011, "abstractText": "We consider finite horizon Markov decision processes under performance measures that involve both the mean and the variance of the cumulative reward. We show that either randomized or history-based policies can improve performance. We prove that the complexity of computing a policy that maximizes the mean reward under a variance constraint is NP-hard for some cases, and strongly NP-hard for others. We finally offer pseudopolynomial exact and approximation algorithms. keywords: Markov processes; dynamic programming; control; complexity theory.", "creator": "LaTeX with hyperref package"}}}