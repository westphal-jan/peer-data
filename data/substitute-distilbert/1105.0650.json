{"id": "1105.0650", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-May-2011", "title": "Transition Systems for Model Generators - A Unifying Approach", "abstract": "a fundamental task for propositional logic is to compute models of propositional formulas. programs developed for these task are termed satisfiability solvers. works show that transition patterns introduced by myers, oliveras, and boyer to model and analyze satisfiability solvers naturally be adapted for code developed for two other propositional formalisms : logic programming under the answer - set semantics, and the logic pc ( id ). we show that in each view the task of computing patterns can be seen as \" satisfiability modulo answer - set programming, \" where the goal is to find a model of a theory that already exists an answer set of a certain program. the unifying perspective to develop shows, in particular, that solvers clasp and minisatid are closely related despite being developed for different formalisms, one for base - gap programming and analytical server for the logic method ( id ).", "histories": [["v1", "Tue, 3 May 2011 18:29:58 GMT  (58kb)", "http://arxiv.org/abs/1105.0650v1", "30 pages; Accepted for presentation at ICLP 2011 and for publication in Theory and Practice of Logic Programming; contains the appendix with proofs"]], "COMMENTS": "30 pages; Accepted for presentation at ICLP 2011 and for publication in Theory and Practice of Logic Programming; contains the appendix with proofs", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yuliya lierler", "miroslaw truszczynski"], "accepted": false, "id": "1105.0650"}, "pdf": {"name": "1105.0650.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["yuliya@cs.uky.edu)", "mirek@cs.uky.edu)"], "sections": [{"heading": null, "text": "ar X\niv :1\n10 5.\n06 50\nv1 [\ncs .A\nI] 3"}, {"heading": "1 Introduction", "text": "A fundamental reasoning task for propositional logic is to compute models of propositional formulas or determine that no models exist. Programs developed for this task are commonly called model generators or satisfiability (SAT) solvers. In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms. The two formalisms we focus on are logic programming with the answer-set semantics and the logic PC(ID).\nDavis-Putnam-Logemann-Loveland (DPLL) procedure is a well-known method that exhaustively explores interpretations to generate models of a propositional formula. Most modern SAT solvers are based on variations of the DPLL procedure. Usually these variations are specified by pseudocode. Nieuwenhuis et al. (2006) proposed an alternative approach based on the notion of a transition system that describes \u201cstates of computation\u201d and allowed transitions between them. In this way, it defines a directed graph such that every execution of the DPLL procedure corresponds to a path in the graph. This abstract way of presenting DPLL-based algorithms simplifies the analysis of their correctness and facilitates studies of their properties \u2014 instead of reasoning about pseudocode constructs, we reason about properties of a graph. For instance, by proving that the graph corresponding to a DPLL-based algorithm is finite and acyclic we show that the algorithm always terminates.\nAnswer-set programming (ASP) (Marek and Truszczyn\u0301ski 1999; Niemela\u0308 1999) is a declarative programming formalism based on the answer-set semantics of logic programs (Gelfond and Lifschitz 1988). Generating answer sets of propositional programs is the\nkey step in computation with ASP. The logic FO(ID), introduced by Denecker (2000) is another formalism for declarative programming and knowledge representation. As in the case of ASP, most automated reasoning tasks in the logic FO(ID) reduce to reasoning in its propositional core, the logic PC(ID) (Marie\u0308n et al. 2008), where generating models is again the key.\nIn this paper, we show that both computing answer sets of programs and computing models of PC(ID) theories can be considered as testing satisfiability modulo theories (SMT), where the objective is to find a model of a set of clauses that is also an answer set of a certain program. We refer to this computational problem as satisfiability modulo answer-set programming and denote it by SM(ASP). We identify the propositional formalism capturing SM(ASP) \u2014 we use the same term to refer to it \u2014 and show that it is a common generalization of ASP and PC(ID). We define a simple transition system for SM(ASP) and show that it can be used as an abstract representation of the solver SMODELS1 (Niemela\u0308 and Simons 2000), an alternative to a similar characterization of SMODELS obtained earlier by Lierler (2011). We then define another more elaborate transition system for SM(ASP) that captures such features of backtracking search as backjumping and learning. We use this transition system to obtain abstract characterizations of the algorithms implemented by the ASP solvers CMODELS2 (Giunchiglia et al. 2004) and CLASP3 (Gebser et al. 2007), and the PC(ID) solver MINISAT(ID)4 (Marie\u0308n et al. 2008). Finally, we briefly mention the possibility to regard the introduced transition systems as proof systems. In that setting, transition systems could be used for comparing the solvers they represent in terms of the complexity of the corresponding proof systems.\nOur results provide a uniform correctness proof for a broad class of solvers that can be modeled by the transition system for SM(ASP), clarify essential computational principles behind ASP and PC(ID) solvers, and offer insights into how they relate to each other. In particular, our results yield the first abstract representation of CLASP in terms of transition systems (up to now CLASP has been typically specified in pseudocode), and show that at the abstract level, CLASP and MINISAT(ID) are strikingly closely related.\nThis last point is noteworthy as the two solvers were developed for different propositional formalisms. MINISAT(ID) was developed specifically for the logic PC(ID), where there is no concept of an answer set. The semantics is a natural extension of the notion of a model of a propositional theory to the setting when a theory consists of propositional clauses and definitions. Definitions are written as logic programs but they are interpreted by the well-founded semantics and not by the answer-set semantics. There is no indication in the literature that CLASP or MINISAT(ID) were influenced by each other. The two solvers were developed independently and for differently motivated formalisms. It is then of substantial interest that at the level of solving they are closely related.\n1 http://www.tcs.hut.fi/Software/smodels/ . 2 http://www.cs.utexas.edu/users/tag/cmodels . 3 http://www.cs.uni-potsdam.de/clasp/ . 4 http://dtai.cs.kuleuven.be/krr/software/minisatid ."}, {"heading": "2 Preliminaries", "text": "We now review the abstract transition system framework proposed for the DPLL procedure by Nieuwenhuis et al. (2006), and introduce some necessary terminology concerning logic programs and the logic PC(ID).\nAbstract DPLL. Most state-of-the-art SAT solvers are based on variations of the DPLL procedure (Davis et al. 1962). Nieuwenhuis et al. (2006) described DPLL by means of a transition system that can be viewed as an abstract representation of the underlying DPLL computation. In this section we review the abstract DPLL in the form convenient for our purposes, following the presentation proposed by Lierler (2011).\nFor a set A of atoms, a record relative to A is an ordered set M of literals over A , some possibly annotated by \u2206, which marks them as decision literals. A state relative to A is either a distinguished state FailState or a record relative to A . For instance, the states relative to a singleton set {a} are\nFailState, /0, a, \u00aca, a\u2206, \u00aca\u2206, a\u00aca, a\u2206\u00aca, a\u00aca\u2206, a\u2206\u00aca\u2206, \u00acaa, \u00aca\u2206 a, \u00acaa\u2206, \u00aca\u2206 a\u2206.\nFrequently, we consider M as a set of literals, ignoring both the annotations and the order among its elements. If neither a literal l nor its dual, written l, occurs in M, then l is unassigned by M. We say that M is inconsistent if both an atom a and its negation \u00aca occur in it. For instance, states b\u2206\u00acb and ba\u00acb are inconsistent.\nIf C is a disjunction (conjunction) of literals then by C we understand the conjunction (disjunction) of the duals of the literals occurring in C. In some situations, we will identify disjunctions and conjunctions of literals with the sets of these literals.\nIn this paper, a clause is a non-empty disjunction of literals and a CNF formula is a conjunction (alternatively, a set) of clauses. Each CNF formula F determines its DPLL graph DPF. The set of nodes of DPF consists of the states relative to the set of atoms occurring in F. The edges of the graph DPF are specified by four transition rules:\nUnit Propagate: M =\u21d2 Ml if C\u2228 l \u2208 F and C \u2286 M Decide: M =\u21d2 Ml\u2206 if l is unassigned by M\nFail: M =\u21d2 FailState if\n{\nM is inconsistent, and M contains no decision literals\nBacktrack: Pl\u2206 Q =\u21d2 Pl if\n{ Pl\u2206 Q is inconsistent, and Q contains no decision literals.\nA node (state) in the graph is terminal if no edge originates in it. The following proposition gathers key properties of the graph DPF .\nProposition 1\nFor any CNF formula F,\n(a) graph DPF is finite and acyclic, (b) any terminal state of DPF other than FailState is a model of F, (c) FailState is reachable from /0 in DPF if and only if F is unsatisfiable.\nThus, to decide the satisfiability of a CNF formula F it is enough to find a path leading from node /0 to a terminal node M. If M = FailState, F is unsatisfiable. Otherwise, F is satisfiable and M is a model of F.\nFor instance, let F = {a\u2228 b,\u00aca\u2228 c}. Below we show a path in DPF with every edge annotated by the name of the transition rule that gives rise to this edge in the graph:\n/0 Decide =\u21d2 a\u2206 Unit Propagate =\u21d2 a\u2206 c Decide =\u21d2 a\u2206 cb\u2206.\nThe state a\u2206 cb\u2206 is terminal. Thus, Proposition 1(b) asserts that F is satisfiable and {a,c,b} is a model of F.\nLogic Programs. A (propositional) logic program is a finite set of rules of the form\na0 \u2190 a1, . . . ,al,not al+1, . . . ,not am,not not am+1, . . . ,not not an, (1)\nwhere a0 is an atom or \u22a5 and each ai, 1\u2264 i \u2264 n, is an atom.5 If a0 is an atom then a rule (1) is weakly normal. If, in addition, n = m then it is normal. Programs consisting of weakly normal (normal, respectively) rules only are called weakly normal (normal, respectively). If \u03a0 is a program, by At(\u03a0) we denote the set of atoms that occur in \u03a0.\nThe expression a0 is the head of the rule. If a0 = \u22a5 we say that the head of the rule is empty and we often omit \u22a5 from the notation. In such case we require that n > 0. We call a rule with the empty head a constraint. We write Head(\u03a0) for the set of nonempty heads of rules in a program \u03a0.\nWe call the expression a1, . . . ,al,not al+1, . . . ,not am, not not am+1, . . . ,not not an in a rule (1) the body of the rule and often view it as the set of all elements that occur in it. If a is an atom, we set s(a) = s(not not a) = a, and s(not a) = \u00aca, and we define s(B) = {s(l) | l \u2208 B}. More directly,\ns(B) = {a1, . . . ,al,\u00acal+1, . . . ,\u00acam,am+1, . . . ,an}.\nWe also frequently identify the body B of (1) with the conjunction of elements in s(B):\na1 \u2227\u00b7\u00b7 \u00b7\u2227al \u2227\u00acal+1 \u2227\u00b7\u00b7 \u00b7\u2227\u00acam \u2227am+1 \u2227\u00b7\u00b7 \u00b7\u2227an.\nBy Bodies(\u03a0,a) we denote the set of the bodies of all rules of \u03a0 with the head a (including the empty body). If B is the body of (1), we write Bpos for the positive part of the body, that is, Bpos = {a1, . . .al}.\nWe often interpret a rule (1) as a propositional clause\na0 \u2228\u00aca1 \u2228 . . .\u2228\u00acal \u2228al+1 \u2228 . . .\u2228am \u2228\u00acam+1 \u2228 . . .\u2228\u00acan (2)\n(in the case when the rule is a constraint, a0 is absent in (2)). Given a program \u03a0, we write \u03a0cl for the set of clauses (2) corresponding to all rules in \u03a0.\nThis version of the language of logic programs is a special case of programs with nested expressions (Lifschitz et al. 1999). It is essential for our approach as it yields an alternative definition of the logic PC(ID), which facilitates connecting it to ASP. We assume that the reader is familiar with the definition of an answer set of a logic program and refer to the paper by Lifschitz et al. (1999) for details.\n5 In the paper, we do not use the term literal for expressions a, not a and not not a. We reserve the term literal exclusively for propositional literals a and \u00aca.\nWell-Founded Semantics and the Logic PC(ID). Let M be a set of (propositional) literals. By M we understand the set of the duals of the literals in M. A set U of atoms occurring in a program \u03a0 is unfounded on a consistent set M of literals with respect to \u03a0 if for every a \u2208 U and every B \u2208 Bodies(\u03a0,a), M\u2229 s(B) 6= /0 or U\u2229Bpos 6= /0. For every program \u03a0 and for every consistent set M of literals, the union of sets that are unfounded on M with respect to \u03a0 is also unfounded on M with respect to \u03a0. Thus, under the assumptions above, there exists the greatest unfounded set on M with respect to \u03a0. We denote this set by GUS(M,\u03a0).\nFor every weakly normal program \u03a0 we define an operator W\u03a0 on a set M of literals as follows\nW\u03a0(M) =\n{\nM\u222a{a | a \u2190 B \u2208 \u03a0 and s(B)\u2286 M}\u222aGUS(M,\u03a0) if M is consistent At(\u03a0)\u222aAt(\u03a0) otherwise.\nBy Wfix\u03a0 (M) we denote a fixpoint of the operator W\u03a0 over a set M of literals. One can show that it always exists since W\u03a0 is not only monotone but also increasing (for any set M of literals, M \u2286 W\u03a0(M)). The least fixpoint of W\u03a0, W fix \u03a0 ( /0), is consistent and yields the wellfounded model of \u03a0, which in general is three-valued. It is also written as lfp(W\u03a0). These definitions and properties were initially introduced for normal programs only (Van Gelder et al. 1991). They extend to programs in our syntax in a straightforward way, no changes in statements or arguments are needed (Lee 2005).\nLet \u03a0 be a program and A a set of atoms. An atom a is open with respect to \u03a0 and A if a \u2208 A\\Head(\u03a0). We denote the set of atoms that are open with respect to \u03a0 and A by O\u03a0A . By \u03a0A we denote the logic program \u03a0 extended with the rules a \u2190 not not a for each atom a \u2208 O\u03a0A . For instance, let \u03a0 be a program\na \u2190 b, not c b.\n(3)\nThen, \u03a0{c} is\nc \u2190 not not c a \u2190 b, not c b.\nWe are ready to introduce the logic PC(ID) (Denecker 2000). A PC(ID) theory is a pair (F,\u03a0), where F is a set of clauses and \u03a0 is a weakly normal logic program. For a PC(ID) theory (F,\u03a0), by \u03a0o we denote \u03a0At(F\u222a\u03a0) and by O\u03a0 we denote O\u03a0At(F\u222a\u03a0) (where At(F \u222a\u03a0) stands for the set of atoms that occur in F and \u03a0). Moreover, for a set M of literals and a set A of atoms, by MA we denote the set of those literals in M whose atoms occur in A. A set M of literals is complete over the set At of atoms if every atom in At occurs (possibly negated) in M and no other atoms occur in M.\nDefinition 1 Let (F,\u03a0) be a PC(ID) theory. A consistent and complete (over At(F\u222a\u03a0)) set M of literals is called a model of (F,\u03a0) if\n(i) M is a model of F, and (ii) M = Wfix\u03a0o(M O\u03a0).\nFor instance, let F be a clause b\u2228\u00acc and \u03a0 be program (3). The PC(ID) theory (F,\u03a0) has two models {b,\u00acc,a} and {b,c, \u00aca}. We note that although sets {\u00acb,\u00acc,a} and {\u00acb,\u00acc,\u00aca} satisfy the condition (i), that is, are models of F, they do not satisfy the condition (ii) and therefore are not models of (F,\u03a0).\nThe introduced definition of a PC(ID) theory differs from the original one (Denecker 2000). Specifically, for us the second component of a PC(ID) theory is a weakly normal program rather than a set of normal programs (definitions). Still, the two formalisms are closely related.\nProposition 2 For a PC(ID) theory (F,\u03a0) such that \u03a0 is a normal program, M is a model of (F,\u03a0) if and only if M is a model of (F,{\u03a0}) according to the definition in (Denecker 2000).\nAs the restriction to a single program in PC(ID) theories is not essential (Marie\u0308n et al. 2008), Proposition 2 shows that our definition of the logic PC(ID) can be regarded as a slight generalization of the original one (more general programs can appear as definitions in PC(ID) theories)."}, {"heading": "3 Satisfiability Modulo ASP: a unifying framework for ASP and PC(ID) solvers", "text": "For a theory T the satisfiability modulo theory (SMT) problem is: given a formula F, determine whether F is T-satisfiable, that is, whether there exists a model of F that is also a model of T. We refer the reader to (Nieuwenhuis et al. 2006) for an introduction to SMT. Typically, a theory T that defines a specific SMT problem is a first-order formula. The SMT problem that we consider here is different. The theory T is a logic program under the (slightly modified) answer-set semantics. We show that the resulting version of the SMT problem can be regarded as a joint extension of ASP and PC(ID).\nWe start by describing the modification of the answer-set semantics that we have in mind.\nDefinition 2 Given a logic program \u03a0, a set X of atoms is an input answer set of \u03a0 if X is an answer set of \u03a0\u222a (X \\Head(\u03a0)).\nInformally, the atoms of X that cannot possibly be defined by \u03a0 as they do not belong to Head(\u03a0) serve as \u201cinput\u201d to \u03a0. A set X is an input answer set of \u03a0 if it is an answer set of the program \u03a0 extended with these \u201cinput\u201d atoms from X. Input answer sets are related to stable models of a propositional logic program module (Oikarinen and Janhunen 2006).\nFor instance, let us consider program (3). Then, sets {b,c}, {a,b} are input answer sets of the program whereas set {a,b,c} is not.\nThere are two important cases when input answer sets of a program are closely related to answer sets of the program.\nProposition 3 For a logic program \u03a0 and a set X of atoms:\n(a) X \u2286 Head(\u03a0) and X is an input answer set of \u03a0 if and only if X is an answer set of \u03a0.\n(b) If (X \\Head(\u03a0))\u2229 At(\u03a0) = /0, then X is an input answer set of \u03a0 if and only if X\u2229Head(\u03a0) is an answer set of \u03a0.\nWe now introduce a propositional formalism that we call satisfiability modulo ASP and denote by SM(ASP). Later in the paper we show that SM(ASP) can be viewed as a common generalization of both ASP and PC(ID). Theories of SM(ASP) are pairs [F,\u03a0], where F is a set of clauses and \u03a0 is a program. In the definition below and in the remainder of the paper, for a set M of literals we write M+ to denote the set of atoms (non-negated literals) in M. For instance, {a,\u00acb}+ = {a}.\nDefinition 3 For an SM(ASP) theory [F,\u03a0], a consistent and complete (over At(F\u222a\u03a0)) set M of literals is a model of [F,\u03a0] if M is a model of F and M+ is an input answer set of \u03a0.\nFor instance, let F be a clause b\u2228\u00acc and \u03a0 be program (3). The SM(ASP) theory [F,\u03a0] has two models {b,\u00acc,a} and {b,c,\u00aca}.\nThe problem of finding models of pairs [F,\u03a0] can be regarded as an SMT problem in which, given a formula F and a program \u03a0, the goal is to find a model of F that is (its representation by the set of its true atoms, to be precise) an input answer set of \u03a0. This observation motivated our choice of the name for the formalism.\nAs for PC(ID) theories, also for an SM(ASP) theory [F,\u03a0] we write \u03a0o for the program \u03a0At(\u03a0\u222aF). We have the following simple observation.\nProposition 4 A set M of literals is a model of an SM(ASP) theory [F,\u03a0] if and only if M is a model of an SM(ASP) theory [F,\u03a0o].\nIt is evident that a set M of literals is a model of F if and only if M is a model of [F, /0]. Thus, SM(ASP) allows us to express the propositional satisfiability problem. We now show that the SM(ASP) formalism captures ASP. Let \u03a0 be a program. We say that a set F of clauses is \u03a0-safe if\n1. F |= \u00aca, for every a \u2208 O\u03a0At(\u03a0), and 2. for every answer set X of \u03a0 there is a model M of F such that X = M+\u2229Head(\u03a0).\nProposition 5 Let \u03a0 be a program. For every \u03a0-safe set F of clauses, a set X of atoms is an answer set of \u03a0 if and only if X = M+\u2229At(\u03a0), for some model M of [F,\u03a0].\nThis result shows that for an appropriately chosen theory F, answer sets of a program \u03a0 can be derived in a direct way from models of an SM(ASP) theory [F,\u03a0]. There are several possible choices for F that satisfy the requirement of \u03a0-safety. One of them is the Clark\u2019s completion of \u03a0 (Clark 1978). We recall that the completion of a program \u03a0 consists of clauses in \u03a0cl and of the formulas that can be written as\n\u00aca\u2228 \u2228\nB\u2208Bodies(\u03a0,a) B (4)\nfor every atom a in \u03a0 that is not a fact (that is, the set Bodies(\u03a0,a) contains no empty body). Formulas (4) can be clausified in a straightforward way by applying distributivity.\nThe set of all the resulting clauses and of those in \u03a0cl forms the clausified completion of \u03a0, which we will denote by Comp(\u03a0).\nThe theory Comp(\u03a0) does not involve any new atoms but it can be exponentially larger than the completion formula before clausification. We can avoid the exponential blowup by introducing new atoms. Namely, for each body B of a rule in \u03a0 with |B| > 1, we introduce a fresh atom fB. If |B|= 1, then we define fB = s(l), where l is the only element of B. By ED-Comp(\u03a0), we denote the set of the following clauses:\n1. all clauses in \u03a0cl 2. all clauses \u00aca\u2228 \u2228\nB\u2208Bodies(\u03a0,a) fB, for every a \u2208 At(\u03a0) such that a is not a fact in \u03a0 and |Bodies(\u03a0,a)|> 1 3. all clauses \u00aca\u2228 s(l), where a \u2208 At(\u03a0), Bodies(\u03a0,a) = {B} and l \u2208 B, 4. all clauses \u00aca, where |Bodies(\u03a0,a)|= 0 5. all clauses obtained by clausifying in the obvious way formulas fB \u2194 B, where B \u2208\nBodies(\u03a0,a), for some atom a that is not a fact in \u03a0 and |Bodies(\u03a0,a)|> 1.\nClearly, the restrictions of models of the theory ED-Comp(\u03a0) to the original set of atoms are precisely the models of Comp(\u03a0) (and of the completion of \u03a0). However, the size of ED-Comp(\u03a0) is linear in the size of \u03a0. The theory ED-Comp(\u03a0) has long been used in answer-set computation. Answer set solvers such as CMODELS (Giunchiglia et al. 2004) and CLASP (Gebser et al. 2007) start their computation by transforming the given program \u03a0 into ED-Comp(\u03a0).\nFor instance, let \u03a0 be program (3). The completion of \u03a0 is the formula\n(a\u2228\u00acb\u2228 c)\u2227b\u2227\u00acc\u2227 (\u00aca\u2228 (b\u2227\u00acc)),\nits clausified completion Comp(\u03a0) is the formula\n(a\u2228\u00acb\u2228 c)\u2227 (\u00aca\u2228b)\u2227 (\u00aca\u2228\u00acc)\u2227b\u2227\u00acc,\nand, finally, ED-Comp(\u03a0) is the formula\n(a\u2228\u00acb\u2228 c)\u2227 (\u00aca\u2228 fb\u2227\u00acc)\u2227 (fb\u2227\u00acc \u2228\u00acb\u2228 c)\u2227 (\u00acfb\u2227\u00acc \u2228b)\u2227 (\u00acfb\u2227\u00acc \u2228\u00acc)\u2227b\u2227\u00acc.\nWe now have the following corollary from Proposition 5.\nCorollary 1 For a logic program \u03a0 and a set X of atoms, the following conditions are equivalent:\n(a) X is an answer set of \u03a0, (b) X = M+ for some model M of the SM(ASP) theory [{\u00aca | a \u2208 O\u03a0At(\u03a0)},\u03a0], (c) X = M+ for some model M of the SM(ASP) theory [Comp(\u03a0),\u03a0], (d) X = M+\u2229At(\u03a0) for some model M of the SM(ASP) theory [ED-Comp(\u03a0),\u03a0].\nIt is in this sense that ASP can be regarded as a fragment of SM(ASP). Answer sets of a program \u03a0 can be described in terms of models of SM(ASP) theories. Moreover, answerset computation can be reduced in a straightforward way to the task of computing models of SM(ASP) theories.\nRemark 1 Corollary 1 specifies three ways to describe answer sets of a program in terms of models of SM(ASP) theories. This offers an interesting view into answer-set generation. The CNF formulas appearing in the SM(ASP) theories in the conditions (b) - (d) make explicit some of the \u201cpropositional satisfiability inferences\u201d that may be used when computing answer sets. The condition (b) shows that when computing answer sets of a program, atoms not occurring as heads can be inferred as false. The theory in (c) makes it clear that a much broader class of inferences can be used, namely those that are based on the clauses of the completion. The theory in (d) describes still additional inferences, as now, thanks to new atoms, we can explicitly infer whether bodies of rules must evaluate to true or false. In each case, some inferences needed for generating answer sets are still not captured by the respective CNF theory and require a reference to the program \u03a0. We note that it is possible to express these \u201canswer-set specific\u201d inferences in terms of clauses corresponding to loop formulas (Lin and Zhao 2004; Lee 2005). We do not consider this possibility in this paper.\nNext, we show that SM(ASP) encompasses the logic PC(ID). The well-founded model M of a program \u03a0 is total if it assigns all atoms occurring in \u03a0. For a PC(ID) theory (F,\u03a0), a program \u03a0 is total on a model M of F if Wfix\u03a0o(M\nO\u03a0) is total. A program \u03a0 is total if \u03a0 is total on every model M of F. The PC(ID) theories (F,\u03a0) where \u03a0 is total form an important class of total PC(ID) theories.\nThere is a tight relation between models of a total PC(ID) theory (F,\u03a0) and models of an SM(ASP) theory [F,\u03a0].\nProposition 6 For a total PC(ID) theory (F,\u03a0) and a set M of literals over the set At(F\u222a\u03a0) of atoms, the following conditions are equivalent:\n(a) M is a model of (F,\u03a0), (b) M is a model of the SM(ASP) theory [F,\u03a0], (c) M is a model of the SM(ASP) theory [Comp(\u03a0At(\u03a0))\u222aF,\u03a0], (d) for some model M\u2032 of the SM(ASP) theory [ED-Comp(\u03a0At(\u03a0))\u222aF,\u03a0], M = M\u2032 \u2229\nAt(F\u2229\u03a0).\nThe conditions (b), (c), (d) state that the logic PC(ID) restricted to total theories can be regarded as a fragment of the SM(ASP) formalism. The comments made in Remark 1 pertain also to generation of models in the logic PC(ID).\nWe now characterize models of SM(ASP) theories, and computations that lead to them, in terms of transition systems. Later we discuss implications this characterization has for ASP and PC(ID) solvers.\nWe define the transition graph SM(ASP)F,\u03a0 for an SM(ASP) theory [F,\u03a0] as follows. The set of nodes of the graph SM(ASP)F,\u03a0 consists of the states relative to At(F \u222a \u03a0). There are five transition rules that characterize the edges of SM(ASP)F,\u03a0. The transition rules Unit Propagate, Decide, Fail, Backtrack of the graph DPF\u222a\u03a0cl , and the transition rule\nUnfounded: M =\u21d2 M\u00aca if a \u2208 U for a set U unfounded on M w.r.t. \u03a0o.\nThe graph SM(ASP)F,\u03a0 can be used for deciding whether an SM(ASP) theory [F,\u03a0] has a model.\nProposition 7 For any SM(ASP) theory [F,\u03a0],\n(a) graph SM(ASP)F,\u03a0 is finite and acyclic, (b) for any terminal state M of SM(ASP)F,\u03a0 other than FailState, M is a model of [F,\u03a0], (c) FailState is reachable from /0 in SM(ASP)F,\u03a0 if and only if [F,\u03a0] has no models.\nProposition 7 shows that algorithms that correctly find a path in the graph SM(ASP)F,\u03a0 from /0 to a terminal node can be regarded as SM(ASP) solvers. It also provides a proof of correctness for every SM(ASP) solver that can be shown to work in this way.\nOne of the ways in which SM(ASP) encompasses ASP (specifically, Corollary 1(c)) is closely related to the way the answer-set solver SMODELS works. We recall that to represent SMODELS Lierler (2011) proposed a graph SM\u03a0. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SM\u03a0 (Lierler 2011). In fact, if \u03a0 = \u03a0o then these rules are identical.\nLierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SM\u03a0, and called such edges singular. Lierler (2011) denoted by SM\u2212\u03a0 the graph obtained by removing from SM\u03a0 all its singular edges and showed that SM \u2212 \u03a0 is still sufficient to serve as an abstract model of a class of ASP solvers including SMODELS. The concept of a singular edge extends literally to the case of the graph SM(ASP)F,\u03a0. An edge M =\u21d2 M\u2032 in the graph SM(ASP)F,\u03a0 is singular if:\n1. the only transition rule justifying this edge is Unfounded, and 2. some edge M =\u21d2 M\u2032\u2032 can be justified by a transition rule other than Unfounded or\nDecide.\nWe define SM(ASP)\u2212F,\u03a0 as the graph obtained by removing all singular edges from SM(ASP)F,\u03a0. Proposition 8 below can be seen as an extension of Proposition 4 in (Lierler 2011) to nontight programs.\nProposition 8 For every program \u03a0, the graphs SM\u2212\u03a0 and SM(ASP) \u2212 Comp(\u03a0),\u03a0 are equal.\nIt follows that the graph SM(ASP)\u2212Comp(\u03a0),\u03a0 provides an abstract model of SMODELS. We recall though that Comp(\u03a0) can be exponentially larger than the completion formula before clausification. Using ASP specific propagation rules such as Backchain True and All Rules Cancelled (Lierler 2011) allows SMODELS to avoid explicit representation of the clausified completion and infer all the necessary transitions directly on the basis of the program \u03a0.\nA similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs.\nThe answer-set solvers CMODELS, CLASP and the PC(ID) solver MINISAT(ID) cannot be described in terms of the graph SM(ASP) nor its subgraphs. These solvers implement such advanced features of SAT and SMT solvers as learning (forgetting), backjumping and restarts (Nieuwenhuis et al. (2006) give a good overview of these techniques). In the next section we extend the graph SM(ASP)F,\u03a0 with propagation rules that capture these techniques. In the subsequent section, we discus how this new graph models solvers CMODELS, CLASP, and MINISAT(ID). Then we provide insights into how they are related."}, {"heading": "4 Backjumping and Learning for SM(ASP)", "text": "Nieuwenhuis et al. (2006, Section 2.4) defined the DPLL System with Learning graph that can be used to describe most of the modern SAT solvers, which typically implement such sophisticated techniques as learning and backjumping. We demonstrate how to extend these findings to capture SM(ASP) framework with learning and backjumping.\nLet [F,\u03a0] be an SM(ASP) theory and let G be a formula over At(F \u222a\u03a0). We say that [F,\u03a0] entails G, written F,\u03a0 |= G, if for every model M of [F,\u03a0], M |= G.\nFor an SM(ASP) theory [F,\u03a0], an augmented state relative to F and \u03a0 is either a distinguished state FailState or a pair M||\u0393 where M is a record relative to the set of atoms occurring in F and \u03a0, and \u0393 is a set of clauses over At(F\u222a\u03a0) such that F,\u03a0o |= \u0393.\nWe now define a graph SML(ASP)F,\u03a0 for an SM(ASP) theory [F,\u03a0]. Its nodes are the augmented states relative to F and \u03a0. The rules Decide, Unfounded, and Fail of SM(ASP)F,\u03a0 are extended to SML(ASP)F,\u03a0 as follows: M||\u0393 =\u21d2 M\u2032||\u0393 (M||\u0393 =\u21d2 FailState, respectively) is an edge in SML(ASP)F,\u03a0 justified by Decide or Unfounded (Fail, respectively) if and only if M =\u21d2 M\u2032 (M =\u21d2 FailState) is an edge in SM(ASP)F,\u03a0 justified by Decide or Unfounded (Fail, respectively). The other transition rules of SML(ASP)F,\u03a0 follow:\nUnit Propagate Learn: M||\u0393 =\u21d2 Ml||\u0393 if { C\u2228 l \u2208 F\u222a\u03a0cl \u222a\u0393 and C \u2286 M\nBackjump: Pl\u2206 Q||\u0393 =\u21d2 Pl\u2032||\u0393 if { Pl\u2206Q is inconsistent and F,\u03a0o |= l\u2032\u2228P\nLearn: M||\u0393 =\u21d2 M||C,\u0393 if { every atom in C occurs in F and F,\u03a0o |= C.\nWe refer to the transition rules Unit Propagate Learn, Unfounded, Backjump, Decide, and Fail of the graph SML(ASP)F,\u03a0 as basic. We say that a node in the graph is semi-terminal if no rule other than Learn is applicable to it. We omit the word \u201caugmented\u201d before \u201cstate\u201d when this is clear from a context.\nThe graph SML(ASP)F,\u03a0 can be used for deciding whether an SM(ASP) theory [F,\u03a0] has a model.\nProposition 9 For any SM(ASP) theory [F,\u03a0],\n(a) every path in SML(ASP)F,\u03a0 contains only finitely many edges justified by basic transition rules, (b) for any semi-terminal state M||\u0393 of SML(ASP)F,\u03a0 reachable from /0|| /0, M is a model of [F,\u03a0], (c) FailState is reachable from /0|| /0 in SML(ASP)F,\u03a0 if and only if [F,\u03a0] has no models.\nOn the one hand, Proposition 9 (a) asserts that if we construct a path from /0|| /0 so that basic transition rules periodically appear in it then some semi-terminal state is eventually reached. On the other hand, parts (b) and (c) of Proposition 9 assert that as soon as a semiterminal state is reached the problem of deciding whether [F,\u03a0] has a model is solved. In other words, Proposition 9 shows that the graph SML(ASP)F,\u03a0 gives rise to a class of correct algorithms for computing models of an SM(ASP) theory [F,\u03a0]. It gives a proof\nof correctness to every SM(ASP) solver in this class and a proof of termination under the assumption that basic transition rules periodically appear in a path constructed from /0|| /0.\nNieuwenhuis et al. (2006) proposed the transition rules to model such techniques as forgetting and restarts. The graph SML(ASP)F,\u03a0 can easily be extended with such rules.\n5 Abstract CMODELS, CLASP and MINISAT(ID)\nWe can view a path in the graph SML(ASP)F,\u03a0 as a description of a process of search for a model of an SM(ASP) theory [F,\u03a0] by applying transition rules. Therefore, we can characterize the algorithm of a solver that utilizes the transition rules of SML(ASP)F,\u03a0 by describing a strategy for choosing a path in this graph. A strategy can be based, in particular, on assigning priorities to transition rules of SML(ASP)F,\u03a0, so that a solver never applies a rule in a state if a rule with higher priority is applicable to the same state.\nWe use this approach to describe and compare the algorithms implemented in the solvers CMODELS, CLASP and MINISAT(ID). We stress that we talk here about characterizing and comparing algorithms and not their specific implementations in the solvers. We refer to these algorithms as abstract CMODELS, CLASP and MINISAT(ID), respectively. Furthermore, we only discuss the abstract MINISAT(ID) for the case of the total PC(ID) theories whereas the MINISAT(ID) system implements additional totality check propagation rule to deal with the non-total theories. Given a program \u03a0, abstract CMODELS and abstract CLASP construct first ED-Comp(\u03a0). Afterwards, they search the graph SML(ASP)ED-Comp(\u03a0),\u03a0 for a path to a semi-terminal state. In other words, both algorithms, while in a node of the graph SML(ASP)ED-Comp(\u03a0),\u03a0, progress by selecting one of the outgoing edges. By Proposition 9 and Corollary 1, each algorithm is indeed a method to compute answer sets of programs.\nHowever, abstract CMODELS selects edges according to the priorities on the transition rules of the graph that are set as follows:\nBackjump,Fail \u226b Unit Propagate \u226b Decide \u226b Unfounded,\nwhile abstract CLASP uses a different prioritization:\nBackjump,Fail \u226b Unit Propagate \u226b Unfounded\u226b Decide.\nThe difference between the algorithms boils down to when the rule Unfounded is used. We now describe the algorithm behind the PC(ID) solver MINISAT(ID) (Marie\u0308n et al. 2008) for total PC(ID) theories \u2014 the abstract MINISAT(ID). Speaking precisely, MINISAT(ID) assumes that the program \u03a0 of the input PC(ID) theory (F,\u03a0) is in the definitional normal form (Marie\u0308n 2009). Therefore, in practice MINISAT(ID) is always used with a simple preprocessor that converts programs into the definitional normal form. We will assume here that this preprocessor is a part of MINISAT(ID). Under this assumption, given a PC(ID) theory (F,\u03a0), MINISAT(ID) can be described as constructing the completion ED-Comp(\u03a0o) (the new atoms are introduced by the preprocessor when it converts \u03a0 into the definitional normal form, the completion part is performed by the MINISAT(ID) proper), and then uses the transitions of the graph SML(ASP)ED-Comp(\u03a0o)\u222aF,\u03a0o to search for a path to a semi-terminal state. In other words, the graph SML(ASP)ED-Comp(\u03a0o)\u222aF,\u03a0o represents the abstract MINISAT(ID). The strategy used by the algorithm follows the prioritization:\nBackjump,Fail \u226b Unit Propagate \u226b Unfounded\u226b Decide.\nBy Propositions 4 and 6, the algorithm indeed computes models of total PC(ID) theories. Systems CMODELS, CLASP, and MINISAT(ID) implement conflict-driven backjumping and learning. They apply the transition rule Learn only when in a non-semi-terminal state reached by an application of Backjump. Thus, the rule Learn does not differentiate the algorithms and so we have not taken it into account when describing these algorithms."}, {"heading": "6 PC(ID) Theories as Logic Programs with Constraints", "text": "For a clause C = \u00aca1 \u2228 . . .\u2228\u00acal \u2228al+1 \u2228 . . .\u2228am we write Cr to denote the corresponding rule constraint\n\u2190 a1, . . . ,al,not al+1, . . . ,not am.\nFor a set F of clauses, we define Fr = {Cr | C \u2208 F}. Finally, for a PC(ID) theory (F,\u03a0) we define a logic program \u03c0(F,\u03a0) by setting\n\u03c0(F,\u03a0) = \u03a0o \u222aFr.\nThe representation of a PC(ID) theory (F,\u03a0) as \u03c0(F,\u03a0) is similar to the translation of FO(ID) theories into logic programs with variables given by Marie\u0308n et al. (2004). The difference is in the way atoms are \u201copened.\u201d We do it by means of rules of the form a \u2190 not not a, while Marie\u0308n et al. use pairs of rules a \u2190 not a\u2217 and a\u2217 \u2190 not a.\nThere is a close relation between models of a PC(ID) theory (F,\u03a0) and answer sets of a program \u03c0(F,\u03a0).\nProposition 10 For a total PC(ID) theory (F,\u03a0) and a consistent and complete (over At(F\u222a\u03a0)) set M of literals, M is a model of (F,\u03a0) if and only if M+ is an answer set of \u03c0(F,\u03a0).\nA choice rule construct {a} (Niemela\u0308 and Simons 2000) of the LPARSE6 and GRINGO7 languages can be seen as an abbreviation for a rule a \u2190 not not a (Ferraris and Lifschitz 2005). Thus, in view of Proposition 10, any answer set solver implementing language of LPARSE or GRINGO is also a PC(ID) solver (an input total PC(ID) theory (F,\u03a0) needs to be translated into \u03c0(F,\u03a0)).\nThe reduction implied by Proposition 10 by itself does not show how to relate particular solvers. However, we recall that abstract MINISAT(ID) is captured by the graph SML(ASP)ED-Comp(\u03a0o)\u222aF,\u03a0o . Moreover, we have the following property.\nProposition 11 For a PC(ID) theory (F,\u03a0), we have\nSML(ASP)ED-Comp(\u03c0(F,\u03a0)),\u03c0(F,\u03a0) = SML(ASP)ED-Comp(\u03a0o)\u222aF,\u03a0o .\nThe graph SML(ASP)ED-Comp(\u03c0(F,\u03a0)),\u03c0(F,\u03a0) captures the way CLASP works on the program \u03c0(F,\u03a0). In addition, the MINISAT(ID) and CLASP algorithms use the same prioritization. Thus, Proposition 11 implies that the abstract CLASP used as a PC(ID) solver coincides with the abstract MINISAT(ID).\n6 http://www.tcs.hut.fi/Software/smodels/ . 7 http://potassco.sourceforge.net/ ."}, {"heading": "7 Related Work and Discussion", "text": "Lierler (2011) introduced the graphs SML and GTL that extended the graphs SM and GT (Lierler 2011), respectively, with transition rules Backjump and Learn. The graph SML was used to characterize the computation of such answer set solvers implementing learning as SMODELScc\n8 (Ward and Schlipf 2004) and SUP9 (Lierler 2011) whereas the graph GTL was used to characterize CMODELS. These graphs are strongly related to our graph SML(ASP) but they are not appropriate for describing the computation behind answer set solver CLASP or PC(ID) solver MINISAT(ID). The graph SML reflects only propagation steps based on a program whereas CLASP and MINISAT(ID) proceed by considering both the program and a propositional theory. The graph GTL, on the other hand, does not seem to provide a way to imitate the behavior of the Unfounded rule in the SML(ASP) graph.\nGiunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis. Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms.\nGebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees.\nMarie\u0308n (2009) (Section 5.7) described a MINISAT(ID) transition system to model a computation behind the PC(ID) solver MINISAT(ID). We recall that we modeled the abstract MINISAT(ID) with the graph SML(ASP). The graphs SML(ASP) and MINISAT(ID) are defined using different sets of nodes and transition rules. For instance, SML(ASP) allows states containing inconsistent sets of literals whereas the MINISAT(ID) graph considers consistent states only. Due to this difference the MINISAT(ID) graph requires multiple versions of \u201cbackjump\u201d and \u201cfail\u201d transition rules.\nWe used transition systems to characterize algorithms for computing answer sets of logic programs and models of PC(ID) theories. These transition systems are also suitable for formal comparison of the strength or power of reasoning methods given rules that specify them. An approach to do so was proposed by Marie\u0308n (2009) (Section 5.7), who introduced\n8 http://www.nku.edu/\u223cwardj1/Research/smodels cc.html . 9 http://www.cs.utexas.edu/users/tag/sup .\n10 http://www.dbai.tuwien.ac.at/proj/dlv/ .\nthe concept of decide-efficiency for such analysis. We outline below how standard concepts of proof complexity (Cook et al. 1979) can be adapted to the setting of transition systems.\nLet A be an infinite set of atoms. We define a node over A to be a symbol FailState, or a finite sequence of literals over A with annotations. For a propositional formalism F over A , a proof procedure PF consists of graphs GT , where T ranges over all theories in F , such that for every theory T (i) GT is composed of nodes over A and (ii) T is unsatisfiable if and only if there is a path p in GT from the empty (start) node to the FailState node. We call each such path p a proof. We say that a proof system S is based on a proof procedure PF if (i) S\u2286F \u00d7R, where R denotes the set of all finite sequences of nodes over A , and (ii) S(T,p) holds if and only if p is a proof in the graph GT in PF . Predicate S is indeed a proof system in the sense of Cook (1979) because (i) S is polynomial-time computable, and (ii) T is unsatisfiable if and only if there exists a proof p such that S(T,p) holds.\nIn this sense, each of the graphs (transition systems) we introduced in this paper can be regarded as a proof procedure for SM(ASP) (for those involving the rule Learn, under additional assumptions to ensure the rule can be efficiently implemented). Thus, transition systems determine proof systems. Consequently, they can be compared, as well as solvers that they capture, in terms of the complexity of the corresponding proof systems."}, {"heading": "8 Conclusions", "text": "In the paper, we proposed a formalism SM(ASP) that can be regarded as a common generalization of (clausal) propositional logic, ASP, and the logic PC(ID). The formalism offers an elegant satisfiability modulo theories perspective on the latter two. We present several characterizations of these formalisms in terms of SM(ASP) theories that differ in the explicitly identified \u201csatisfiability\u201d component. Next, we proposed transition systems for SM(ASP) to provide abstract models of SM(ASP) model generators. The transition systems offer a clear and uniform framework for describing model generation algorithms in SM(ASP). As SM(ASP) subsumes several propositional formalisms, such a uniform approach provides a general proof of correctness and termination that applies to a broad class of model generators designed for these formalisms. It also allows us to describe in precise mathematical terms relations between algorithms designed for reasoning with different logics such as propositional logic, logic programming under answer-set semantics and the logic PC(ID), the latter two studied in detail in the paper. For instance, our results imply that at an abstract level of transition systems, CLASP and MINISAT(ID) are essentially identical. Finally, we note that this work gives the first description of CLASP in the abstract framework rather than in pseudocode. Such high level view on state-of-the-art solvers in different, yet, related propositional formalisms will further their understanding, and help port advances in solver technology from one area to another."}, {"heading": "Acknowledgments", "text": "We are grateful to Marc Denecker and Vladimir Lifschitz for useful discussions. We are equally grateful to the reviewers who helped eliminate minor technical problems and improve the presentation. Yuliya Lierler was supported by a CRA/NSF 2010 Computing Innovation Fellowship. Miroslaw Truszczynski was supported by the NSF grant IIS-0913459."}, {"heading": "Appendix: Proofs", "text": ""}, {"heading": "8.1 Proof of Proposition 2", "text": "We start with some additional notation and several lemmas. Let N be a set of literals. By |N| we denote a set of atoms occurring in N. For instance |{a,\u00acb, c}| = {a, b, c}. Further, by ch(N) we denote a set of rules of the form a \u2190 not not a, where a \u2208 |N|.\nBy a program literal we mean expressions a, not a and not not a, where a is an atom. For a program literal l, we set s(l) = a, if l = a or l = not not a, and s(l) = \u00aca, if l = not a. For a set B of body literals, we define s(B) = {s(l) | l \u2208 B}. If \u03a0 is a program and N is a set of literals, by \u03a0(N) we denote the program obtained from \u03a0 by removing each rule whose body contains a program literal l such that s(l) \u2208 N, and deleting from the bodies of all rules in \u03a0 every program literal l such that s(l) \u2208 N.\nLemma 1 Let \u03a0 be a logic program and N a consistent set of literals such that |N| \u2229Head(\u03a0) = /0. For every consistent set M of literals such that |N| \u2229 |M|= /0,\n{a | a \u2190 B \u2208 \u03a0\u222a ch(N) and s(B)\u2286 M\u222aN} \\N = {a | a \u2190 B \u2208 \u03a0(N) and s(B)\u2286 N}\u00b7"}, {"heading": "Proof", "text": "Let c \u2208 {a | a \u2190 B \u2208 \u03a0 \u222a ch(N) and s(B) \u2286 M \u222a N} \\N. Let c \u2208 |N|. The only rule in \u03a0\u222ach(N) with c as the head is c\u2190 not not c. It follows that c\u2208M\u222aN. Since |N|\u2229|M|= /0, c \u2208 N, a contradiction. Thus, c /\u2208 |N| and there is a rule c \u2190 B \u2208 \u03a0 such that s(B)\u2286 M\u222aN. Let B\u2032 be what remains when we remove from B all expressions l such that s(l) \u2208 N. The rule c \u2190 B\u2032 \u2208 \u03a0(N) and s(B\u2032)\u2286 M. It follows that c \u2208 {a | a \u2190 B \u2208 \u03a0(N) and s(B\u2032)\u2286 M}.\nConversely, let c \u2208 {a | a \u2190 B \u2208 \u03a0(N) and s(B) \u2286 M}. It follows that c /\u2208 |N| and so, c /\u2208 N. Moreover, there is a rule c \u2190 B\u2032 \u2208 \u03a0(N) such that s(B\u2032) \u2286 M. By the definition of \u03a0(N), there is a rule c \u2190 B \u2208 \u03a0 such that s(B) \u2286 M \u222a N. Thus, c \u2208 {a | a \u2190 B \u2208 \u03a0\u222a ch(N) and s(B)\u2286 M\u222aN} \\N.\nLet N be a set of literals. We define N\u2212 = {a | \u00aca \u2208 N}.\nLemma 2 For a logic program \u03a0, a consistent set N of literals such that |N| \u2229Head(\u03a0) = /0, and a consistent set M of literals such that |M| \u2229 |N| = /0, GUS(M \u222a N,\u03a0 \u222a ch(N)) \\N\u2212 = GUS(M,\u03a0(N))."}, {"heading": "Proof", "text": "We note that since the sets M and N are consistent and |M| \u2229 |N|= /0, M\u222aN is consistent. Moreover, we note that to prove the claim it suffices to show that U is an unfounded set on M\u222aN w.r.t. \u03a0\u222a ch(N) if and only if U \\N\u2212 is an unfounded set on M w.r.t. \u03a0(N). (\u21d2) Let a \u2208 U \\N\u2212 and let D \u2208 Bodies(\u03a0(N),a). It follows that a /\u2208 |N|. It also follows that there is a rule a \u2190 B \u2208 \u03a0 such that for every program literal l \u2208 B, s(l) /\u2208 N, and D is obtained by removing from B every program literal l such that s(l) \u2208 N.\nSince U is an unfounded set on M\u222aN w.r.t. \u03a0\u222ach(N), it follows that s(B)\u2229(M\u222aN) 6= /0 or U\u2229B+ 6= /0. In the first case, since for every program literal l \u2208 B, s(l) /\u2208 N, s(B)\u2229M 6= /0\nfollows. Moreover, D differs from B only in program literals l such that s(l) \u2208 N. Since |M|\u2229|N|= /0, we have s(D)\u2229M 6= /0. Thus, let us consider the second case. Let a\u2208U\u2229B+. Since a /\u2208 |N|, a /\u2208 N\u2212. For the same reason, a /\u2208 N. Thus, a \u2208 U \\N\u2212 and a \u2208 D+. That is, (U \\N\u2212)\u2229D+ 6= /0. This proves that U \\N\u2212 is an unfounded set on M w.r.t. \u03a0(N). (\u21d0) Let U\u2032 be any unfounded set on M w.r.t. \u03a0(N). By the definition of an unfounded set, U\u2032 contains no atoms from |N| since they do not appear in \u03a0(N). We show that U\u2032\u222aN\u2212 is an unfounded set on M\u222aN w.r.t. \u03a0\u222a ch(N). Let a be any atom in U\u2032\u222aN\u2212. Case 1. a \u2208 N\u2212. It follows that a occurs in the head of only one rule in \u03a0\u222a ch(N) namely, a \u2190 not not a. Since \u00aca \u2208 N, s(not not a) \u2208 N and, consequently, s(not not a) \u2208 M\u222aN.\nCase 2. a \u2208 U\u2032. It follows that a 6\u2208 N and so, Bodies(\u03a0\u222a ch(N),a) = Bodies(\u03a0,a). To complete the argument it suffices to show that for every body B \u2208 Bodies(\u03a0,a), s(B)\u2229 (M\u222aN) 6= /0 or (U\u2032\u222aN\u2212)\u2229B+ 6= /0 holds.\nLet B be any body in Bodies(\u03a0,a). It follows that \u03a0 contains the rule a \u2190 B. If there is a program literal l in B such that s(l) \u2208 N, then the first condition above holds. Thus, let us assume that for every program literal l\u2208B, s(l) /\u2208N. Let D be obtained from B by removing from it every program literal l such that s(l) \u2208 N. It follows that a \u2190 D \u2208 \u03a0(N). Since U\u2032 is unfounded on M w.r.t. \u03a0(N), there is l in D such that s(l) \u2208 M or U\u2032\u2229D+ 6= /0. In the first case, we have s(B)\u2229 (M \u222aN) 6= /0. In the second case, we have (U\u2032\u222aN\u2212)\u2229B+ 6= /0.\nBy W i\u03a0(M) we will denote the i-fold application of the W\u03a0 operator on the set M of literals. By convention, we assume that W0\u03a0(M) = M.\nLemma 3 For a normal logic program \u03a0 and a consistent set N of literals such that |N|\u2229Head(\u03a0)= /0,\nW i\u03a0\u222ach(N)(N) = W i \u03a0(N)( /0)\u222aN\u00b7"}, {"heading": "Proof", "text": "We proceed by induction on i. For i = 0, since N is consistent, we have\nW0\u03a0\u222ach(N)(N) = N = /0\u222aN = W 0 \u03a0(N)( /0)\u222aN\u00b7\nLet us assume that the identity holds for some i \u2265 0. We show that it holds for i+ 1. Let M denote W i\u03a0(N)( /0). We recall that W fix \u03a0(N)( /0) is the well-founded model of the normal program \u03a0(N). Consequently, the sets Wfix\u03a0(N)( /0) and W j \u03a0(N)( /0), j \u2265 0, are consistent (Van Gelder et al. 1991). In particular, M is consistent. Moreover, since |N|\u2229 |Wfix\u03a0(N)( /0)|= /0, the sets W j\u03a0(N)( /0)\u222aN, j \u2265 0, are consistent, too. Thus, we have\nW i+1\u03a0(N)( /0)\u222aN = N \u222aW\u03a0(N)(W i \u03a0(N)( /0)) = N \u222aW\u03a0(N)(M)\n= N \u222aM\u222a{a | a \u2190 B \u2208 \u03a0(N) and B \u2286 M}\u222aGUS ( M,\u03a0(N) ) \u00b7\nSince |N|\u2229 |Wfix\u03a0(N)( /0)|= /0, |M|\u2229 |N|= /0. We also observed that M is consistent. By Lemmas 1 and 2 and the fact that {\u00aca | a \u2208 N\u2212} \u2286 N, we have\nW i+1\u03a0(N)( /0)\u222aN = N \u222a (M\u222a{a | a \u2190 B \u2208 \u03a0\u222a ch(N) and B \u2286 M\u222aN} \\N)\n\u222a GUS ( M\u222aN,\u03a0\u222a ch(N) ) \\N\u2212\n= N \u222a (M\u222a{a | a \u2190 B \u2208 \u03a0\u222a ch(N) and B \u2286 M\u222aN} \\N) \u222a (GUS ( M\u222aN,\u03a0\u222a ch(N) ) \\ {\u00aca | a \u2208 N\u2212})\n= N \u222aM\u222a{a | a \u2190 B \u2208 \u03a0\u222a ch(N) and B \u2286 M\u222aN} \u222a GUS ( M\u222aN,\u03a0\u222a ch(N) ) \u00b7\nSince this last set is consistent, it is equal to W\u03a0\u222ach(N)(M\u222aN) = W\u03a0\u222ach(N)(W i \u03a0(N)( /0)\u222aN). Applying the induction hypothesis, the inductive step follows.\nProposition 2 For a PC(ID) theory (F,\u03a0) such that \u03a0 is a normal program, M is a model of (F,\u03a0) if and only if M is a model of (F,\u03a0) according to the definition in (Denecker 2000)."}, {"heading": "Proof", "text": "Let (F,\u03a0) be a PC(ID) theory. In (Denecker 2000), the authors state that a consistent and complete (over At(F\u222a\u03a0)) set M of literals is a model of (F,\u03a0) if\n(i) M is a model of F, and (ii) M = Wfix\n\u03a0(MO\u03a0 ) ( /0)\u222aMO\n\u03a0 .\nTo prove the assertion it is sufficient to show that for any model M of F such that |M|= At(\u03a0\u222aF), M = Wfix\u03a0o(M O\u03a0 ) if and only if M = Wfix \u03a0(MO\u03a0 ) ( /0)\u222aMO \u03a0 . Let N = MO \u03a0 . The definitions of O\u03a0 and \u03a0o directly imply that |N|\u2229Head(\u03a0) = /0 and that \u03a0o = \u03a0\u222ach(N). Thus, the property follows from Lemma 3."}, {"heading": "8.2 Proofs of Results from Section 3", "text": "Proposition 3 For a logic program \u03a0 and a set X of atoms,\n(a) X \u2286 Head(\u03a0) and X is an input answer set of \u03a0 if and only if X is an answer set of \u03a0. (b) if (X \\Head(\u03a0))\u2229 At(\u03a0) = /0, then X is an input answer set of \u03a0 if and only if X\u2229Head(\u03a0) is an answer set of \u03a0."}, {"heading": "Proof", "text": "The proof of part (a) is straightforward and follows directly from the definition of an input answer set. To prove (b), let us assume first that X is an input answer set of \u03a0. By the definition, X is an answer set of \u03a0\u222a(X\\Head(\u03a0)). Thus, X is the least model of the reduct [\u03a0\u222a(X\\Head(\u03a0))]X. Clearly, we have [\u03a0\u222a(X\\Head(\u03a0))]X =\u03a0X\u222a(X\\Head(\u03a0)). Since (X \\ Head(\u03a0))\u2229 At(\u03a0) = /0, \u03a0X = \u03a0X\u2229Head(\u03a0). It follows that X is the least model of \u03a0X\u2229Head(\u03a0)\u222a (X \\Head(\u03a0)). Using again the assumption (X \\Head(\u03a0))\u2229At(\u03a0) = /0, one can show that X \u2229Head(\u03a0) is the least model of \u03a0X\u2229Head(\u03a0). Thus, X \u2229Head(\u03a0) is an answer set of \u03a0\nThe proof in the other direction is similar. Let us assume that X \u2229Head(\u03a0) is an answer set of \u03a0. It follows that X \u2229Head(\u03a0) is the least model of \u03a0X\u2229Head(\u03a0). Since (X \\ Head(\u03a0))\u2229At(\u03a0) = /0, X is the least model of \u03a0X\u2229Head(\u03a0) \u222a (X \\Head(\u03a0)). Moreover, since \u03a0X\u2229Head(\u03a0)=\u03a0X , X is the least model of \u03a0X\u222a(X\\Head(\u03a0))= [\u03a0\u222a(X\\Head(\u03a0))]X. Thus, X is an input answer set of \u03a0.\nProposition 4 A set of literals M is a model of an SM(ASP) theory [F,\u03a0] if and only if M is a model of an SM(ASP) theory [F,\u03a0o]."}, {"heading": "Proof", "text": "Proceeding in each direction, we can assume that M is a complete (over At(F \u222a\u03a0)) and consistent set of literals such that |M| = |At(F\u222a\u03a0)|. It follows that to prove the assertion it suffices to show that for every such set M, M+ is an input answer set of \u03a0 if and only if M+ is an input answer set of \u03a0o.\nWe note that \u03a0o =\u03a0\u222a{a\u2190 not not a | a\u2208At(F\u222a\u03a0)\\Head(\u03a0)}. Thus, M+ \u2286Head(\u03a0) and so, by Proposition 3, M+ is an input answer set of \u03a0o if and only if M+ is an answer set of \u03a0o. It follows that to complete the argument, it suffices to show that under our assumptions about M, M+ is an answer set of \u03a0\u222a (M+ \\Head(\u03a0)) if and only if M+ is an answer set of \u03a0o. This statement is evident once we observe that the reducts of \u03a0\u222a (M+ \\Head(\u03a0)) and \u03a0o with respect to M+ are equal (they are both equal to \u03a0M+ \u222a (M+ \\Head(\u03a0))).\nProposition 5 For any SM(ASP) theory [F,\u03a0] that is \u03a0-safe, a set X of atoms is an answer set of \u03a0 if and only if X = M+\u2229At(\u03a0), for some model M of [F,\u03a0]."}, {"heading": "Proof", "text": "(\u21d2) Let X be an answer set of \u03a0. Since [F,\u03a0] is \u03a0-safe, there is a model M of F such that X = M+ \u2229Head(\u03a0). Moreover, again by the \u03a0-safety of [F,\u03a0], {\u00aca | a \u2208 O\u03a0} \u2286 M. It follows that X = M+\u2229At(\u03a0) and (M+ \\Head(\u03a0))\u2229At(\u03a0) = /0. By Proposition 3(b), M+ is an input answer set of \u03a0.\n(\u21d0) Let X = M+ \u2229At(\u03a0), where M is a model of [F,\u03a0]. It follows that M is a model of F. By the \u03a0-safety of [F,\u03a0], we have {\u00aca | a \u2208 O\u03a0} \u2286 M. As above, it follows that (M+ \\ Head(\u03a0))\u2229At(\u03a0) = /0. Since M+ is an input answer set of \u03a0, Proposition 3(b) implies that M+\u2229Head(\u03a0) is an answer set of \u03a0. From the identity (M+ \\Head(\u03a0))\u2229At(\u03a0) = /0, it follows that M+\u2229Head(\u03a0) = M+\u2229At(\u03a0). Thus, X is an answer set of \u03a0.\nCorollary 1 follows immediately from Proposition 5. We omit its proof and move on to Proposition 6. We start by proving two simple auxiliary results.\nLemma 4 For a logic program \u03a0, and a consistent and complete set M of literals over At(\u03a0), if M = W\u03a0(M), then M is a model of \u03a0."}, {"heading": "Proof", "text": "It is sufficient to show that for every rule a \u2190 B \u2208 \u03a0 if s(B)\u2286 M then a \u2208 M. This follows from the definition of the operator W\u03a0 and the fact that M = W\u03a0(M).\nLemma 5 For a logic program \u03a0 and a consistent and complete set M of literals over At(\u03a0), if M = W\u03a0(M) then M+ does not have any non-empty subset that is unfounded on M with respect to \u03a0."}, {"heading": "Proof", "text": "Let us assume that U is a non-empty subset of M+ that is unfounded on M with respect to \u03a0. It follows that U \u2286 M. Since U 6= /0, M is inconsistent, a contradiction.\nNext, we recall the following generalization of a well-known characterization of answer sets in terms of unfounded sets due to Leone et al. (1997). The generalization extended the characterization to the case of programs with double negation.\nTheorem on Unfounded Sets(Lee 2005) For a set M of literals, M+ is an answer set of a program \u03a0 if and only if M is a model of \u03a0 and M+ does not have any non-empty subset that is unfounded on M with respect to \u03a0.\nProposition 6 For a total PC(ID) theory (F,\u03a0) and a set M of literals over the set At(F\u222a \u03a0) of atoms, the following conditions are equivalent:\n(a) M is a model of (F,\u03a0) (b) M is a model of an SM(ASP) theory [F,\u03a0] (c) M is a model of an SM(ASP) theory [Comp(\u03a0At(\u03a0))\u222aF,\u03a0] (d) for some model M\u2032 of an SM(ASP) theory [ED-Comp(\u03a0At(\u03a0))\u222aF,\u03a0], M = M\u2032 \u2229\nAt(F\u2229\u03a0)."}, {"heading": "Proof", "text": "(a)\u21d2(b) It is sufficient to show that M+ is an input answer set of \u03a0, that is, an answer set of \u03a0\u222a (M+ \\Head(\u03a0)). Since M is a model of the PC(ID) theory (F,\u03a0), M is a complete and consistent set of literals over At(F \u222a\u03a0) and M = Wfix\u03a0o(M\nO\u03a0). It follows that M = W\u03a0o(M). Since At(\u03a0o) = At(F \u222a\u03a0), by Lemma 4 it follows that M is a model of \u03a0o. Consequently, M is a model of \u03a0\u222a (M+ \\Head(\u03a0)). By Theorem on Unfounded Sets, it is sufficient to show that M+ does not have any non-empty subset that is unfounded on M with respect to \u03a0\u222a (M+ \\Head(\u03a0)). For a contradiction, let us assume that there is a nonempty set U \u2286 M+ that is unfounded on M with respect to \u03a0\u222a (M+ \\Head(\u03a0)). Let a \u2208 U. It follows that a \u2208 M+. If a /\u2208 Head(\u03a0), then a is a fact in \u03a0\u222a (M+ \\Head(\u03a0)). This is a contradiction with the unfoundedness of U. Thus, a \u2208 Head(\u03a0). By the definition of \u03a0o, Bodies(\u03a0o,a) = Bodies(\u03a0,a). It follows that for every B \u2208 Bodies(\u03a0o,a), s(B)\u2229M 6= /0 or U \u2229B+ 6= /0. This shows that U is unfounded on M with respect to \u03a0o. This contradicts Lemma 5.\n(a)\u21d0(b) Since M is a model of [F,\u03a0], M is a complete and consistent set of literals over At(F \u222a\u03a0). By the assumption, M+ is an answer set of \u03a0\u2032 = \u03a0\u222a (M+ \\Head(\u03a0)). Since \u03a0\u2032 and \u03a0 have the same reducts with respect to M+, M+ is an answer set of \u03a0o.\nSince MO \u03a0 \u2286 M, W\u03a0o(MO \u03a0 )\u2286 Wo\u03a0(M). Let l \u2208 W o \u03a0(M). If l = a, where a is an atom in \u03a0o, then there is a rule a \u2190 B in \u03a0o such that s(B)\u2286 M. Since M is a model of \u03a0o (it is so since M+ is an answer set of \u03a0o), a \u2208 M. If l = \u00aca, then a \u2208 GUS(M,\u03a0o).\nLet us assume that a \u2208 M+ and let us define U = M+\u2229GUS(M,\u03a0o). Clearly, U 6= /0 and U \u2286 GUS(M,\u03a0o). Let b \u2208 U and let B \u2208 Bodies(\u03a0o,b). Let us assume that s(B)M = /0. By the completeness of M, s(B) \u2286 M. Since b \u2208 GUS(M,\u03a0o), there is an element GUS(M,\u03a0o)\u2229B+ 6= /0. Let us assume that c \u2208 GUS(M,\u03a0o)\u2229B+. It follows that c \u2208 M+ and so, c \u2208 U. Thus, U is a nonempty set contained in M+ and unfounded on M with respect to \u03a0o. By Theorem on Unfounded Sets, this contradicts the fact that M+ is an answer\nset of \u03a0o. it follows that a /\u2208 M+. By the completeness of M, \u00aca \u2208 M. Thus, Wo\u03a0(M) \u2286 M and, consequently, W\u03a0o(MO \u03a0 ) \u2286 M. By iterating, we obtain that Wfix\u03a0o(M O\u03a0 ) \u2286 M. Since (F,\u03a0) is total, Wfix\u03a0o(M O\u03a0 ) = M. Thus, (a) follows. (b)\u21d4(c) It is sufficient to show that M is a model of F if and only if M is a model of Comp(\u03a0o)\u222a F given that M+ is an input answer set of \u03a0 or, equivalently, that M+ is an answer set of \u03a0\u222aM+ \\Head(\u03a0). The \u201cif\u201d part is obvious. For the \u201conly if\u201d part, we proceed as follows. First, reasoning as above we observe that M+ is an answer set of \u03a0o. Thus, M is the model of the completion Comp(\u03a0o) and so, M is a model of Comp(\u03a0o)\u222aF, which we needed to show.\n(b)\u21d4(d) The equivalence follows from the fact that ED-Comp(\u03a0At(\u03a0)) is a conservative extension of Comp(\u03a0At(\u03a0)).\nWe now proceed to the proof of Proposition 7. We first recall a result proved by Lierler (2011) (using a slightly modified notation)..\nLemma 6 (Lemma 4 (Lierler 2011)) For any unfounded set U on a consistent set M of literals with respect to a program \u03a0, and any assignment N, if N |= M and N \u2229U 6= /0, then N+ is not an answer set for \u03a0.\nIt is well known that for any consistent and complete set M of literals over At(\u03a0) (assignment on At(\u03a0)), if M+ is an answer set for a program \u03a0, then M is a model of \u03a0cl. The property has a counterpart for SM(ASP) theories. The proof is straightforward and we omit it.\nLemma 7 For every SM(ASP) theory [F,\u03a0], if M is a model of [F,\u03a0], then M is a model of F\u222a\u03a0cl.\nNext, we prove the following auxiliary result.\nLemma 8 For every SM(ASP) theory [F,\u03a0], every state M other than FailState reachable from /0 in SM(ASP)F,\u03a0, and every model N of [F,\u03a0], if N satisfies all decision literals in M, then N satisfies M."}, {"heading": "Proof", "text": "We proceed by induction on n = |M|. The property trivially holds for n = 0. Let us assume that the property holds for all states with k\u2032 \u2264 k elements that are reachable from /0. For the inductive step, let us consider a state M = l1 . . . lk such that every model N of [F,\u03a0] that satisfies all decision literals lj with j \u2264 j satisfies M. We need to prove that applying any transition rule of SM(ASP)F,\u03a0 in the state l1 . . . lk, leads to a state M\n\u2032 = l1 . . . lk, lk+1 such that if N is a model of [F,\u03a0] and N satisfies every decision literal lj with j \u2264 k+ 1, then N satisfies M\u2032.\nUnit Propagate: By the definition of Unit Propagate, there is a clause C\u2228 l \u2208 F\u222a\u03a0cl such that C \u2286 M and M\u2032 = Ml. Let N be any model of [F,\u03a0] that satisfies all decision literals lj \u2208 Ml. It follows that N satisfies all decision literals in M. By the induction hypothesis, N |= M. Since N |= C\u2228 l and C \u2286 M, Lemma 7 implies that N |= l.\nDecide: In this case, M\u2032 = Mld (l is a decision literal). If N is a model of the theory [F,\u03a0]\nand it satisfies all decision literals in M\u2032, then N satisfies l (by the assumption) and N satisfies every decision literal in M. By the induction hypothesis, the latter implies that N |= M. Thus, N |= M\u2032.\nFail: If this rule is applicable, M has no decision literals and is inconsistent. If [F,\u03a0] has a model N, then by the induction hypothesis, N |= M, a contradiction. It follows that [F,\u03a0] has no models and the assertion is trivially true.\nBacktrack: If this rule is applied, it follows that M has the form Pldi Q, where Q contains no decision literals, and M\u2032 = Pli. Let N be a model of [F,\u03a0] such that N satisfies all decision literals in Pli. It follows that N satisfies all decision literals in P and so, by the induction hypothesis, N |= P. Let us assume that N |=li. Then, N satisfies all decision literals in M and, consequently, N |= M, a contradiction as M is inconsistent. Thus, N |= li and so, N |= M\u2032.\nUnfounded: If M\u2032 is obtained from M by an application of the Unfounded rule, then M is consistent and M\u2032 = M\u00aca, for some a \u2208 U, where U is an unfounded set on M with respect to \u03a0o. Let N be any model N of [F,\u03a0] such that N satisfies all decision literals in M\u2032. It follows that N satisfies all decision literals in M and so, by the inductive hypothesis, N |= M. By the definition of a model of [F,\u03a0], N+ is an input answer set of \u03a0. Consequently, N+ is an answer set of \u03a0\u222a (N+ \\Head(\u03a0)). Arguing as as before, we obtain that N+ is an answer set of \u03a0o. By Lemma 6, a /\u2208 N+, that is, N |= \u00aca.\nProposition 7 For any SM(ASP) theory [F,\u03a0],\n(a) graph SM(ASP)F,\u03a0 is finite and acyclic, (b) for any terminal state M of SM(ASP)F,\u03a0 other than FailState, M is a model of [F,\u03a0] (c) FailState is reachable from /0 in SM(ASP)F,\u03a0 if and only if [F,\u03a0] has no models."}, {"heading": "Proof", "text": "Parts (a) and (c) are proved as in the proof of Proposition 1 (Lierler 2011, Proposition 1) using Lemma 8. (b) Let M be a terminal state. It follows that none of the rules are applicable. From the fact that Decide is not applicable, we derive that M assigns all literals. Since neither Backtrack nor Fail are applicable, M is consistent. Since Unit Propagate is not applicable, it follows that for every clause C\u2228 a \u2208 F\u222a\u03a0cl if C \u2286 M then a \u2208 M. Consequently, if M |= C then M |= a. Thus, M is a model of F\u222a\u03a0cl. Consequently, M is a model of F.\nNext, we show that M+ is an input answer set of \u03a0, that is, that M+ is an answer set of \u03a0\u222a (M+ \\Head(\u03a0)). To this end, it is sufficient to show that M+ is an answer set of \u03a0o (we again exploit here the fact that M+ is an answer set of \u03a0\u222a(M+ \\Head(\u03a0)) if and only if M+ is an answer set of \u03a0o). Since M is a model of F\u222a\u03a0cl, M is a model of \u03a0o.\nLet us assume that M+ is not an answer set of \u03a0o. By Theorem on Unfounded Sets, it follows that there is a non-empty unfounded set U on M with respect to \u03a0o such that U \u2286 M+. Then Unfounded can be applied for some a \u2208 U. If \u00aca /\u2208 M, M is not terminal, a contradiction. Thus, \u00aca \u2208 M. Since M is consistent, a /\u2208 M+, a contradiction (as U \u2286 M+). It follows that M+ is an answer set of \u03a0o, as required.\nFinally, we sketch a proof for Proposition 8 Proposition 8 For every program \u03a0, the graphs SM\u2212\u03a0 and SM(ASP) \u2212 Comp(\u03a0),\u03a0 are equal."}, {"heading": "Proof", "text": "Sketch: First we show that the states of the graphs SM\u2212\u03a0 and SM(ASP) \u2212 Comp(\u03a0),\u03a0 coincide. In view of Proposition 3 stated and proved by Lierler (Lierler 2011) it is sufficient to show that there is a non-singular edge M =\u21d2 M\u2032 in SM\u03a0 justified by the transition Unfounded (defined for SM) if and only if there is a non-singular edge M =\u21d2 M\u2032 in SM(ASP)Comp(\u03a0),\u03a0 justified by Unfounded (defined for SM(ASP)). We conclude by proving the last statement."}, {"heading": "8.3 Proof of Proposition 9", "text": "We first extend Lemma 8 to the \u201clearning\u201d version of the graph SM(ASP)F,\u03a0.\nLemma 9 For every SM(ASP) theory [F,\u03a0], every state M||\u0393 reachable from /0|| /0 in SM(ASP)F,\u03a0, and every model N of [F,\u03a0], if N satisfies all decision literals in M, then N satisfies M."}, {"heading": "Proof", "text": "The proof is by induction on n = |M| and proceeds similarly as that of Lemma 8. In particular, the property trivially holds for n = 0. Let us assume that the property holds for all states M||\u0393, where |M| \u2264 k, that are reachable from /0|| /0. For the inductive step, let us consider a state M||\u0393, with M = l1 . . . lk, such that every model N of [F,\u03a0] that satisfies all decision literals lj with j \u2264 k satisfies M. We need to prove that applying any transition rule of SM(ASP)F,\u03a0 in the state M||\u0393, leads to a state M\u2032||\u0393\u2032, where M\u2032 = Mlk+1, such that if N is a model of [F,\u03a0] and N satisfies every decision literal lj with j \u2264 k+ 1, then N satisfies M\u2032.\nThe rules Decide, Fail and Unfounded can be dealt with as before (with only minor notational adjustments to account for extended states). Thus, we move on to the rules Unit Propagate Learn, Backjump, and Learn.\nUnit Propagate Learn: We recall that \u0393 is a set of clauses entailed by F and \u03a0. In other words, any model of [F,\u03a0] is also a model of \u0393. We now proceed as in the case of the rule Unit Propagate in the proof of Proposition 8 with F\u222a\u03a0cl replaced by F\u222a\u03a0cl \u222a\u0393. Backjump: The argument is similar to that used in the case of the transition rule Backtrack in the proof of Lemma 8.\nLearn: This case is trivially true.\nWe now recall several concepts we will need in the proofs. Given a set A of atoms, we define Bodies(\u03a0,A) = \u22c3\na\u2208A Bodies(\u03a0,a). Let \u03a0 be a program and Y a set of atoms. We call the formula\n\u2228\na\u2208Y\na \u2192 \u2228 {B | B \u2208 Bodies(\u03a0,Y) and Bpos\u2229Y = /0} (5)\nthe loop formula for Y (Lin and Zhao 2004). We can rewrite the loop formula (5) as the disjunction\n( \u2227\na\u2208Y\n\u00aca)\u2228 \u2228 {B | B \u2208 Bodies(\u03a0,Y) and Bpos \u2229Y = /0}. (6)\nThe Main Theorem in (Lee 2005) implies the following property loop formulas. In its statement we refer to the concept of a program entailing a formula. The notion is defined as follows. A program \u03a0 entails a formula F (over the set of atoms in \u03a0) if for every interpretation M (over the set of atoms in \u03a0) such that M+ is an answer set of \u03a0, M is a model of F.\nLemma 10 (Lemma on Loop Formulas) For every program \u03a0 and every set Y of atoms, Y \u2286 At(\u03a0), \u03a0 entails the loop formula (6) for Y.\nFor an SM(ASP) theory [F,\u03a0] and a list PlQ of literals, we say that a clause C\u2228 l is a reason for l to be in PlQ with respect to [F,\u03a0] if\n1. P |= \u00acC, and 2. F,\u03a0o |= C\u2228 l.\nLemma 11 Let [F,\u03a0] be an SM(ASP) theory. For every state M||\u0393 reachable from /0|| /0 in the graph SML(ASP)F,\u03a0, every literal l in M is either a decision literal or has a reason to be in M with respect to [F,\u03a0]."}, {"heading": "Proof", "text": "We proceed by induction on the length of a path from /0|| /0 to M||\u0393 in the graph SML(ASP)F,\u03a0. Since the property trivially holds in the initial state /0|| /0, we only need to prove that every transition rule of SML(ASP)F,\u03a0 preserves it.\nLet us consider an edge M||\u0393 =\u21d2 M\u2032||\u0393\u2032, where M is a sequence l1 . . . lk such that every li, 1 \u2264 i \u2264 k, is either a decision literal or has a reason to be in M with respect to [F,\u03a0]. It is evident that transition rules Backjump, Decide, Learn, and Fail preserve the property (the last one trivially, as FailState contains no literals).\nUnit Propagate Learn: The edge M||\u0393 =\u21d2 M\u2032||\u0393\u2032 is justified by the rule Unit Propagate Learn. That is, there is a clause C\u2228 l \u2208 F\u222a\u03a0cl \u222a\u0393 such that C \u2286 M and M\u2032 = Ml. By the inductive hypothesis, the property holds for every literal in M. We now show that a clause C\u2228 l is a reason for l to be in Ml. By the applicability conditions of Unit Propagate Learn, C \u2286 M. Consequently, M |= C. It remains to show that F,\u03a0o |= C\u2228 l. Case 1. C\u2228 l \u2208 F. Then, clearly, F |= C\u2228 l and, consequently, F,\u03a0o |= C\u2228 l. Case 2. C \u2228 l \u2208 \u03a0cl. Since \u03a0cl \u2286 (\u03a0o)cl, C \u2228 l \u2208 (\u03a0o)cl. Let M be a model of [F,\u03a0o]. It follows that M+ is an answer set of \u03a0o. Thus, M |= (\u03a0o)cl and so, M |= C \u2228 l. Thus, F,\u03a0o |= C\u2228 l. Case 3. C\u2228 l \u2208 \u0393. We recall that F,\u03a0o |= \u0393 by the definition of an augmented state. Consequently, F,\u03a0o |= C\u2228 l. Unfounded: We have that M is consistent, and that there is an unfounded set U on M with respect to \u03a0o and a \u2208 U such that M\u2032 = M\u00aca. By the inductive hypothesis, the property holds for every literal in M. We need to show that \u00aca has a reason to be in M\u00aca with respect to [F,\u03a0].\nLet B \u2208 Bodies(\u03a0o,U) be such that U \u2229Bpos = /0. By the definition of an unfounded\nset, it follows that s(B)\u2229M 6= /0. Consequently, s(B) contains a literal from M. We pick an arbitrary one and call it f (B). The clause\nC = \u00aca\u2228 \u2228 {f (B) | B \u2208 Bodies(\u03a0o,U) and Bpos\u2229U = /0}, (7)\nis a reason for \u00aca to be in M\u00aca with respect to [F,\u03a0]. First, by the choice of f (B), for every B \u2208 Bodies(\u03a0o,U) and Bpos \u2229U = /0, f (B) \u2208 M. Consequently,\nM |= \u00ac \u2228 {f (B) | B \u2208 Bodies(\u03a0o,U) and Bpos \u2229U = /0}\u00b7 (8)\nSecond, since f (B) \u2208 B, the loop formula\n( \u2227\nu\u2208U\n\u00acu)\u2228 \u2228 {B | B \u2208 Bodies(\u03a0,U) and Bpos \u2229U = /0} (9)\nentails C. By Lemma on Loop Formulas, it follows that \u03a0o entails C. Consequently, F,\u03a0o |= C.\nFor a list M of literals, by consistent(M) we denote the longest consistent prefix of M. For example, consistent(abc\u00acbd) = abc. A clause C is conflicting on a list M of literals with respect to an SM(ASP) theory [F,\u03a0] if consistent(M) |= \u00acC and F,\u03a0o |= C.\nFor a state M||\u0393 reachable from /0|| /0 in SML(ASP)F,\u03a0, by rM we denote a function that maps every non-decision literal in M to its reason to be in M (with respect to [F,\u03a0]). By RM we denote the set consisting of the clauses rM(l), for each non-decision literal l \u2208 consistent(M).\nA resolution derivation of a clause C from a sequence of clauses C1, . . . ,Cm is a sequence C1, . . . ,Cm, . . . ,Cn, where C \u2261 Cl for some l \u2264 n, and each clause Ci in the sequence is either a clause from C1, . . . ,Cm or is derived by applying the resolution rule to clauses Cj and Ck, where j,k < i (we call such clauses derived ). We say that a clause C is derived by a resolution derivation from a sequence of clauses C1, . . . ,Cm if there is a resolution derivation of a clause C from C1, . . . ,Cm.\nLemma 12 Let [F,\u03a0] be an SM(ASP) theory, M||\u0393 a state in the graph SM(ASP)F,\u03a0 such that M is inconsistent, and C1 a clause in RM . If clause C2 is conflicting on M with respect to [F,\u03a0], then every clause C derived from C1 and C2 is also a conflicting clause on M with respect to [F,\u03a0]."}, {"heading": "Proof", "text": "Let us assume that C is derived from C1 and C2 by resolving on some literal l \u2208 C1. Then, C2 is of the form l\u2228C\u20322.\nFrom the fact that C1 \u2208 RM, it follows that F,\u03a0o |= C1 and that C1 has the form c1 \u2228C\u20321, where consistent(M) |= \u00acC \u2032 1. Since C2 is conflicting, consistent(M) |= \u00acC2 and F,\u03a0o |= C2. By the consistency of consistent(M), there is no literal in C\u20321 such that its complement occurs in C2. Therefore l = c1 and, consequently, C = C\u20321 \u2228C \u2032 2. It follows that consistent(M) |= \u00acC. Moreover, since F,\u03a0o |= C1 and F,\u03a0o |= C2 and C results from C1 and C2 by resolution, F,\u03a0o |= C.\nFor an SM(ASP) theory [F,\u03a0] and a node M||\u0393 in SM(ASP)F,\u03a0, a resolution derivation C1, . . . ,Cn is trivial on M with respect to [F,\u03a0]11 if\n(1) {C1, . . . ,Ci}= RM (2) Ci+1 is a conflicting clause on M with respect to [F,\u03a0] (3) Cj, j > i+ 1, is derived from Cj\u22121 and a clause Ck, where k \u2264 i (that is, Ck \u2208 RM),\nby resolving on some non-decision literal of consistent(M).\nFor a record M0 l1 M1 . . . lk Mk, where li are all the decision literals of the record, we say that the literals of li Mi belong to a decision level i. For a state MlM\u2032 l\u2032M\u2032\u2032, we say that l is older than l\u2032. We say that a state is a backjump state if it is inconsistent, contains a decision literal, and is reachable from /0|| /0 in SML(ASP)F,\u03a0.\nLemma 13 For every SM(ASP) theory [F,\u03a0], the transition rule Backjump is applicable in every backjump state in SM(ASP)F,\u03a0."}, {"heading": "Proof", "text": "Let M||\u0393 be a backjump state in SM(ASP)F,\u03a0. We will show that M has the form Pl\u2206 Q and that there is a literal l\u2032 that has a reason to be in Pl\u2032 with respect to [F,\u03a0].\nSince M||\u0393 is a backjump state, it follows that M has the form consistent(M)l N. It is clear that l is not a decision literal (otherwise consistent(M)l would be consistent). By Lemma 11, there is a reason, say R for l to be in M. We denote this reason by R. Since consistent(M)l is inconsistent, l \u2208 consistent(M). This observation and the definition of a reason imply that consistent(M) |= \u00acR. Moreover, since F,\u03a0o |= R (as R is a reason), R is a conflicting clause.\nLet dec be the largest of the decision levels of the complements of the literals in R (each of them occurs in consistent(M)). Let D be the set of all non-decision literals in consistent(M). By Ddec we denote a subset of D that contains all the literals that belong to decision level dec.\nIt is clear that C1, . . . ,Ci,Ci+1, where {C1, . . .Ci} = RM and Ci+1 = R, is a trivial resolution derivation with respect to M and consistent(M) |= \u00acCi+1. Let us consider a trivial resolution derivation with respect to M of the form C1, . . . ,Ci,Ci+1, . . . ,Cn, where n\u2265 i+1 and consistent(M) |= \u00acCn. Let us assume that there is a literal l \u2208 D such that l in Cn. It follows that Cn = l\u2228C\u2032n, for some clause C \u2032 n.\nSince l \u2208 D (is a non-decision literal in consistent(M)), the set RM contains the clause rM(l), which is a reason for l to be in M. The clause rM(l) is of the form l\u2228 l1 \u2228 . . .\u2228 lm, where literals l1, . . . , lm are older than l and consistent(M) |= \u00ac(l1 \u2228 . . .\u2228 lm). Resolving Cn and rM(l) yields the clause Cn+1 = C\u2032n \u2228 l1 \u2228 . . .\u2228 lm. Clearly, C1, . . . ,Cn+1 is a trivial resolution derivation with respect to M and conistent(M) |= \u00acCn+1.\nIf we apply this construction selecting at each step a non-decision literal l \u2208 Ddec such that l \u2208 R, then at some point we obtain a clause Cn that contains exactly one literal whose complement belongs to decision level dec (the reason is that in each step of the construction, the literal with respect we perform the resolution is replaced by older ones).\n11 This definition is related to the definition of a trivial resolution derivation (Beame et al. 2004).\nBy Lemma 12, the clause C = Cn is conflicting on M with respect to [F,\u03a0], that is, consistent(M) |= \u00acC and F,\u03a0o |= C. By the construction, C = l\u2032\u2228C\u2032, where l\u2032 is the only literal whose complement belongs to the decision level dec and the complements of all literals in C\u2032 belong to lower decision levels.\nCase 1. dec = 0. Since for every literal l \u2208 C\u2032, the decision level of l is strictly lower than dec, C\u2032 = \u22a5. Since M||\u0393 is a backjump state, M contains a decision literal. Then M can be written as Pl\u2206 Q, where P contains no decision literals (in other words P consists of all literals in consistent(M) of decision level dec = 0) and l\u2032 \u2208 P. Clearly, P |= \u00acC\u2032 (as C\u2032 =\u22a5). Since F,\u03a0o |= C(= l\u2032\u2228C\u2032), C is a reason for l\u2032 to be in Pl\u2032.\nCase 2. dec \u2265 1. Let l be the decision literal in M that starts the decision level dec. Then, M can be written as Pl\u2206 Q. By the construction of the clause C, the complement of every literal in C\u2032 belongs to a decision level smaller than dec, that is, to P. It follows that P |= \u00acC\u2032. Thus, as before, we conclude that C is a reason for l\u2032 to be in Pl\u2032.\nProposition 9 For any SM(ASP) theory [F,\u03a0],\n(a) every path in SML(ASP)F,\u03a0 contains only finitely many edges justified by basic transition rules,\n(b) for any semi-terminal state M||\u0393 of SML(ASP)F,\u03a0 reachable from /0|| /0, M is a model of [F,\u03a0],\n(c) FailState is reachable from /0|| /0 in SML(ASP)F,\u03a0 if and only if [F,\u03a0] has no models."}, {"heading": "Proof", "text": "Part (a) is proved as in the proof of Proposition 13\u2191 (Lierler 2010) (we preserve the notation used in that work).\n(b) Let M||G be a semi-terminal state reachable from /0|| /0 (that is, none of the basic rules are applicable.) Since Decide is not applicable, M assigns all literals. Next, M is consistent. Indeed, if M were inconsistent then, since Fail is not applicable, M would contain a decision literal. Consequently, M||\u0393 would be a backjump state. By Lemma 13, the transition rule Backjump would be applicable in M||\u0393, contradicting our assumption that M||\u0393 is semi-terminal. We now proceed as in the proof of Proposition 7 (b) to show M is a model of F and M+ is an input answer set of \u03a0.\n(c) If FailState is reachable from /0|| /0 in SML(ASP)F,\u03a0, then there is a state M||\u0393 reachable from /0|| /0 in SML(ASP)F,\u03a0 such that there is an edge between M||\u0393 and FailState. By the definition of SML(ASP)F,\u03a0, this edge is due to the transition rule Fail. Thus, M is inconsistent and contains no decision literals. By Lemma 9, every model N of [F,\u03a0] satisfies M. Since M is inconsistent, [F,\u03a0] has no models.\nConversely, if [F,\u03a0] has no models, let us consider a maximal path in SML(ASP)F,\u03a0 starting in /0|| /0 and consisting of basic transition rules. By (a), it follows that such a path is finite and ends in a semi-terminal state. By (b), this semi-terminal must be FailState, because [F,\u03a0] has no models."}, {"heading": "8.4 Proofs of Results from Section 6", "text": "Proposition 10 For a total PC(ID) theory (F,\u03a0) and a consistent and complete (over At(F\u222a\u03a0)) set M of literals, M is a model of (F,\u03a0) if and only if M+ is an answer set of \u03c0(F,\u03a0)."}, {"heading": "Proof", "text": "By Proposition 6, it is enough to prove that M is a model of the SM(ASP) theory [F,\u03a0] if and only if M+ is an answer set of \u03c0(F,\u03a0). By the definition of \u03c0(F,\u03a0), M+ is an answer set of \u03c0(F,\u03a0) if and only if M+ is an answer set of \u03a0o and a model of F. Since M+ is a subset of Head(\u03a0o) (since Head(\u03a0o) = At(F \u222a\u03a0)), Proposition 3(a) implies that M+ is an answer set of \u03a0o if and only if M+ is an input answer set of \u03a0o. It follows that M+ is an answer set of \u03c0(F,\u03a0) if and only if M is a model of the SM(ASP) theory [F,\u03a0o]. The assertion follows now from Proposition 4.\nProposition 11 For a PC(ID) theory (F,\u03a0), we have\nSML(ASP)ED-Comp(\u03a0o)\u222aF,\u03a0o = SML(ASP)ED-Comp(\u03c0(F,\u03a0)),\u03c0(F,\u03a0)."}, {"heading": "Proof", "text": "We recall that \u03c0(F,\u03a0) = Fr \u222a\u03a0o. From the construction of ED-Comp, it is easy to see that\nED-Comp(\u03a0o)\u222aF = ED-Comp(\u03c0(F,\u03a0))\u00b7\nFurthermore, from the definition of an unfounded set it follows that for any consistent set M of literals and a set U of atoms, U is unfounded on M with respect to \u03a0o if and only if U is unfounded on M with respect to \u03c0(F,\u03a0)."}], "references": [{"title": "Towards understanding and harnessing", "author": ["P. BEAME", "H. KAUTZ", "A. SABHARWAL"], "venue": null, "citeRegEx": "BEAME et al\\.,? \\Q2004\\E", "shortCiteRegEx": "BEAME et al\\.", "year": 2004}, {"title": "The relative efficiency of propositional proof systems", "author": ["S.A. COOK", "ROBERT", "A. RECKHOW"], "venue": null, "citeRegEx": "COOK et al\\.,? \\Q1979\\E", "shortCiteRegEx": "COOK et al\\.", "year": 1979}, {"title": "A machine program for theorem proving", "author": ["M. DAVIS", "G. LOGEMANN", "D. LOVELAND"], "venue": "Journal of Symbolic Logic", "citeRegEx": "DAVIS et al\\.,? \\Q1962\\E", "shortCiteRegEx": "DAVIS et al\\.", "year": 1962}, {"title": "A deductive system for non-monotonic reasoning", "author": ["T. EITER", "N. LEONE", "C. MATEIS", "G. PFEIFER", "F. SCARCELLO"], "venue": "In", "citeRegEx": "EITER et al\\.,? 1997", "shortCiteRegEx": "EITER et al\\.", "year": 1997}, {"title": "Weight constraints as nested expressions", "author": ["P. FERRARIS", "V. LIFSCHITZ"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374.", "citeRegEx": "FERRARIS and LIFSCHITZ,? 2005", "shortCiteRegEx": "FERRARIS and LIFSCHITZ", "year": 2005}, {"title": "Conflict-driven answer set solving", "author": ["M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB"], "venue": "Proceedings of 20th International Joint Conference on Artificial Intelligence, IJCAI 2007. 386\u2013392.", "citeRegEx": "GEBSER et al\\.,? 2007", "shortCiteRegEx": "GEBSER et al\\.", "year": 2007}, {"title": "Tableau calculi for answer set programming", "author": ["M. GEBSER", "T. SCHAUB"], "venue": "Proceedings of the 22nd International Conference on Logic Programming, ICLP 2006. Lecture Notes in Computer Science, vol. 4079. Springer, Berlin, 11\u201325.", "citeRegEx": "GEBSER and SCHAUB,? 2006", "shortCiteRegEx": "GEBSER and SCHAUB", "year": 2006}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proceedings of the 5th International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, Cambridge, MA, 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "On the relation among answer set solvers", "author": ["E. GIUNCHIGLIA", "N. LEONE", "M. MARATEA"], "venue": null, "citeRegEx": "GIUNCHIGLIA et al\\.,? \\Q2008\\E", "shortCiteRegEx": "GIUNCHIGLIA et al\\.", "year": 2008}, {"title": "On the relation between answer set and SAT procedures (or, between smodels and cmodels)", "author": ["E. GIUNCHIGLIA", "M. MARATEA"], "venue": "Proceedings of the 21st International Conference on Logic Programming, ICLP 2005. Lecture Notes in Computer Science, vol. 3668. Springer, Berlin, 37\u201351.", "citeRegEx": "GIUNCHIGLIA and MARATEA,? 2005", "shortCiteRegEx": "GIUNCHIGLIA and MARATEA", "year": 2005}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["LEE J."], "venue": "In", "citeRegEx": "J.,? 2005", "shortCiteRegEx": "J.", "year": 2005}, {"title": "Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation", "author": ["N. LEONE", "P. RULLO", "F. SCARCELLO"], "venue": "Information and Computation 135(2), 69\u2013112.", "citeRegEx": "LEONE et al\\.,? 1997", "shortCiteRegEx": "LEONE et al\\.", "year": 1997}, {"title": "Sat-based answer set programming", "author": ["Y. LIERLER"], "venue": "Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "LIERLER,? 2010", "shortCiteRegEx": "LIERLER", "year": 2010}, {"title": "Abstract answer set solvers with backjumping and learning", "author": ["Y. LIERLER"], "venue": "Theory and Practice of Logic Programming 11, 135\u2013169.", "citeRegEx": "LIERLER,? 2011", "shortCiteRegEx": "LIERLER", "year": 2011}, {"title": "Nested expressions in logic programs", "author": ["V. LIFSCHITZ", "L.R. TANG", "H. TURNER"], "venue": null, "citeRegEx": "LIFSCHITZ et al\\.,? \\Q1999\\E", "shortCiteRegEx": "LIFSCHITZ et al\\.", "year": 1999}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. LIN", "Y. ZHAO"], "venue": "Artificial Intelligence 157, 115\u2013137.", "citeRegEx": "LIN and ZHAO,? 2004", "shortCiteRegEx": "LIN and ZHAO", "year": 2004}, {"title": "Stable models and an alternative logic programming", "author": ["V. MAREK", "M. TRUSZCZY\u0143SKI"], "venue": null, "citeRegEx": "MAREK and TRUSZCZY\u0143SKI,? \\Q1999\\E", "shortCiteRegEx": "MAREK and TRUSZCZY\u0143SKI", "year": 1999}, {"title": "Model generation for ID-logic", "author": ["M. MARI\u00cbN"], "venue": "Ph.D. thesis, Katholieke Universiteit Leuven.", "citeRegEx": "MARI\u00cbN,? 2009", "shortCiteRegEx": "MARI\u00cbN", "year": 2009}, {"title": "On the relation between ID-logic and answer set programming", "author": ["M. MARI\u00cbN", "D. GILIS", "M. DENECKER"], "venue": "Proceedings of the 9th European Conference on Logics in Artificial Intelligence, JELIA 2004. Lecture Notes in Computer Science, vol. 3229. Springer, Berlin, 108\u2013120.", "citeRegEx": "MARI\u00cbN et al\\.,? 2004", "shortCiteRegEx": "MARI\u00cbN et al\\.", "year": 2004}, {"title": "SAT(ID): Satisfiability of propositional logic extended with inductive definitions", "author": ["M. MARI\u00cbN", "J. WITTOCX", "M. DENECKER", "M. BRUYNOOGHE"], "venue": "Proceedings of the 11th International Conference on Theory and Applications of Satisfiability Testing, SAT 2008. Lecture Notes in Computer Science, vol. 4996. Springer, Berlin, 211\u2013224.", "citeRegEx": "MARI\u00cbN et al\\.,? 2008", "shortCiteRegEx": "MARI\u00cbN et al\\.", "year": 2008}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. NIEMEL\u00c4"], "venue": null, "citeRegEx": "NIEMEL\u00c4,? \\Q1999\\E", "shortCiteRegEx": "NIEMEL\u00c4", "year": 1999}, {"title": "Extending the Smodels system with cardinality and weight constraints", "author": ["I. NIEMEL\u00c4", "P. SIMONS"], "venue": "Logic-Based Artificial Intelligence, J. Minker, Ed. Kluwer, Dordrecht, 491\u2013521.", "citeRegEx": "NIEMEL\u00c4 and SIMONS,? 2000", "shortCiteRegEx": "NIEMEL\u00c4 and SIMONS", "year": 2000}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)", "author": ["R. NIEUWENHUIS", "A. OLIVERAS", "C. TINELLI"], "venue": "Journal of the ACM 53(6), 937\u2013977.", "citeRegEx": "NIEUWENHUIS et al\\.,? 2006", "shortCiteRegEx": "NIEUWENHUIS et al\\.", "year": 2006}, {"title": "Modular equivalence for normal logic programs", "author": ["E. OIKARINEN", "T. JANHUNEN"], "venue": "Proceedings of the 17th European Conference on Artificial Intelligence, ECAI 2006. IOS Press, Amsterdam, 412\u2013416.", "citeRegEx": "OIKARINEN and JANHUNEN,? 2006", "shortCiteRegEx": "OIKARINEN and JANHUNEN", "year": 2006}, {"title": "The well-founded semantics for general logic programs", "author": ["A. VAN GELDER", "K. ROSS", "J. SCHLIPF"], "venue": null, "citeRegEx": "GELDER et al\\.,? \\Q1991\\E", "shortCiteRegEx": "GELDER et al\\.", "year": 1991}], "referenceMentions": [{"referenceID": 7, "context": "Answer-set programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999) is a declarative programming formalism based on the answer-set semantics of logic programs (Gelfond and Lifschitz 1988).", "startOffset": 164, "endOffset": 192}, {"referenceID": 21, "context": "In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms.", "startOffset": 59, "endOffset": 85}, {"referenceID": 21, "context": "In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms. The two formalisms we focus on are logic programming with the answer-set semantics and the logic PC(ID). Davis-Putnam-Logemann-Loveland (DPLL) procedure is a well-known method that exhaustively explores interpretations to generate models of a propositional formula. Most modern SAT solvers are based on variations of the DPLL procedure. Usually these variations are specified by pseudocode. Nieuwenhuis et al. (2006) proposed an alternative approach based on the notion of a transition system that describes \u201cstates of computation\u201d and allowed transitions between them.", "startOffset": 59, "endOffset": 639}, {"referenceID": 5, "context": "2004) and CLASP3 (Gebser et al. 2007), and the PC(ID) solver MINISAT(ID)4 (Mari\u00ebn et al.", "startOffset": 17, "endOffset": 37}, {"referenceID": 9, "context": "In this paper, we show that both computing answer sets of programs and computing models of PC(ID) theories can be considered as testing satisfiability modulo theories (SMT), where the objective is to find a model of a set of clauses that is also an answer set of a certain program. We refer to this computational problem as satisfiability modulo answer-set programming and denote it by SM(ASP). We identify the propositional formalism capturing SM(ASP) \u2014 we use the same term to refer to it \u2014 and show that it is a common generalization of ASP and PC(ID). We define a simple transition system for SM(ASP) and show that it can be used as an abstract representation of the solver SMODELS1 (Niemel\u00e4 and Simons 2000), an alternative to a similar characterization of SMODELS obtained earlier by Lierler (2011). We then define another more elaborate transition system for SM(ASP) that captures such features of backtracking search as backjumping and learning.", "startOffset": 186, "endOffset": 805}, {"referenceID": 22, "context": "We now review the abstract transition system framework proposed for the DPLL procedure by Nieuwenhuis et al. (2006), and introduce some necessary terminology concerning logic programs and the logic PC(ID).", "startOffset": 90, "endOffset": 116}, {"referenceID": 20, "context": "Nieuwenhuis et al. (2006) described DPLL by means of a transition system that can be viewed as an abstract representation of the underlying DPLL computation.", "startOffset": 0, "endOffset": 26}, {"referenceID": 12, "context": "In this section we review the abstract DPLL in the form convenient for our purposes, following the presentation proposed by Lierler (2011). For a set A of atoms, a record relative to A is an ordered set M of literals over A , some possibly annotated by \u2206, which marks them as decision literals.", "startOffset": 124, "endOffset": 139}, {"referenceID": 22, "context": "We refer the reader to (Nieuwenhuis et al. 2006) for an introduction to SMT.", "startOffset": 23, "endOffset": 48}, {"referenceID": 23, "context": "Input answer sets are related to stable models of a propositional logic program module (Oikarinen and Janhunen 2006).", "startOffset": 87, "endOffset": 116}, {"referenceID": 5, "context": "2004) and CLASP (Gebser et al. 2007) start their computation by transforming the given program \u03a0 into ED-Comp(\u03a0).", "startOffset": 16, "endOffset": 36}, {"referenceID": 15, "context": "We note that it is possible to express these \u201canswer-set specific\u201d inferences in terms of clauses corresponding to loop formulas (Lin and Zhao 2004; Lee 2005).", "startOffset": 129, "endOffset": 158}, {"referenceID": 13, "context": "We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SM\u03a0 (Lierler 2011).", "startOffset": 129, "endOffset": 143}, {"referenceID": 12, "context": "We recall that to represent SMODELS Lierler (2011) proposed a graph SM\u03a0.", "startOffset": 36, "endOffset": 51}, {"referenceID": 12, "context": "We recall that to represent SMODELS Lierler (2011) proposed a graph SM\u03a0. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SM\u03a0 (Lierler 2011). In fact, if \u03a0 = \u03a0o then these rules are identical. Lierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SM\u03a0, and called such edges singular.", "startOffset": 36, "endOffset": 284}, {"referenceID": 12, "context": "We recall that to represent SMODELS Lierler (2011) proposed a graph SM\u03a0. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SM\u03a0 (Lierler 2011). In fact, if \u03a0 = \u03a0o then these rules are identical. Lierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SM\u03a0, and called such edges singular. Lierler (2011) denoted by SM\u03a0 the graph obtained by removing from SM\u03a0 all its singular edges and showed that SM \u2212 \u03a0 is still sufficient to serve as an abstract model of a class of ASP solvers including SMODELS.", "startOffset": 36, "endOffset": 420}, {"referenceID": 13, "context": "Proposition 8 below can be seen as an extension of Proposition 4 in (Lierler 2011) to nontight programs.", "startOffset": 68, "endOffset": 82}, {"referenceID": 13, "context": "Using ASP specific propagation rules such as Backchain True and All Rules Cancelled (Lierler 2011) allows SMODELS to avoid explicit representation of the clausified completion and infer all the necessary transitions directly on the basis of the program \u03a0.", "startOffset": 84, "endOffset": 98}, {"referenceID": 9, "context": "A similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs.", "startOffset": 102, "endOffset": 132}, {"referenceID": 9, "context": "A similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs. The answer-set solvers CMODELS, CLASP and the PC(ID) solver MINISAT(ID) cannot be described in terms of the graph SM(ASP) nor its subgraphs. These solvers implement such advanced features of SAT and SMT solvers as learning (forgetting), backjumping and restarts (Nieuwenhuis et al. (2006) give a good overview of these techniques).", "startOffset": 103, "endOffset": 442}, {"referenceID": 22, "context": "Nieuwenhuis et al. (2006) proposed the transition rules to model such techniques as forgetting and restarts.", "startOffset": 0, "endOffset": 26}, {"referenceID": 4, "context": "A choice rule construct {a} (Niemel\u00e4 and Simons 2000) of the LPARSE6 and GRINGO7 languages can be seen as an abbreviation for a rule a \u2190 not not a (Ferraris and Lifschitz 2005).", "startOffset": 147, "endOffset": 176}, {"referenceID": 13, "context": "Lierler (2011) introduced the graphs SML and GTL that extended the graphs SM and GT (Lierler 2011), respectively, with transition rules Backjump and Learn.", "startOffset": 84, "endOffset": 98}, {"referenceID": 13, "context": "The graph SML was used to characterize the computation of such answer set solvers implementing learning as SMODELScc 8 (Ward and Schlipf 2004) and SUP9 (Lierler 2011) whereas the graph GTL was used to characterize CMODELS.", "startOffset": 152, "endOffset": 166}, {"referenceID": 3, "context": "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode.", "startOffset": 92, "endOffset": 111}, {"referenceID": 7, "context": "Giunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis.", "startOffset": 0, "endOffset": 31}, {"referenceID": 7, "context": "Giunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis. Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al.", "startOffset": 0, "endOffset": 202}, {"referenceID": 3, "context": "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related.", "startOffset": 93, "endOffset": 237}, {"referenceID": 3, "context": "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods.", "startOffset": 93, "endOffset": 611}, {"referenceID": 3, "context": "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees. Mari\u00ebn (2009) (Section 5.", "startOffset": 93, "endOffset": 1320}, {"referenceID": 3, "context": "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees. Mari\u00ebn (2009) (Section 5.7) described a MINISAT(ID) transition system to model a computation behind the PC(ID) solver MINISAT(ID). We recall that we modeled the abstract MINISAT(ID) with the graph SML(ASP). The graphs SML(ASP) and MINISAT(ID) are defined using different sets of nodes and transition rules. For instance, SML(ASP) allows states containing inconsistent sets of literals whereas the MINISAT(ID) graph considers consistent states only. Due to this difference the MINISAT(ID) graph requires multiple versions of \u201cbackjump\u201d and \u201cfail\u201d transition rules. We used transition systems to characterize algorithms for computing answer sets of logic programs and models of PC(ID) theories. These transition systems are also suitable for formal comparison of the strength or power of reasoning methods given rules that specify them. An approach to do so was proposed by Mari\u00ebn (2009) (Section 5.", "startOffset": 93, "endOffset": 2192}], "year": 2011, "abstractText": "A fundamental task for propositional logic is to compute models of propositional formulas. Programs developed for this task are called satisfiability solvers. We show that transition systems introduced by Nieuwenhuis, Oliveras, and Tinelli to model and analyze satisfiability solvers can be adapted for solvers developed for two other propositional formalisms: logic programming under the answerset semantics, and the logic PC(ID). We show that in each case the task of computing models can be seen as \u201csatisfiability modulo answer-set programming,\u201d where the goal is to find a model of a theory that also is an answer set of a certain program. The unifying perspective we develop shows, in particular, that solvers CLASP and MINISAT(ID) are closely related despite being developed for different formalisms, one for answer-set programming and the latter for the logic PC(ID).", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}