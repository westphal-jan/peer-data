{"id": "1106.1819", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jun-2011", "title": "A Knowledge Compilation Map", "abstract": "we advocate one perspective on knowledge mapping which calls for analyzing secondary compilation approaches according to two key dimensions : the succinctness of the target compilation language, and the classification of queries comprising transformations that the language supports in polytime. instead then provide a knowledge compilation analysis, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and queries. we argue that such analysis is necessary for placing new compilation approaches within the context of existing ones., also go beyond classical, flat target compilation languages based on cnf and dnf, and consider a richer, nested network based on directed acyclic graphs ( such as path ), which we show alone include a relatively narrow number usable target process languages.", "histories": [["v1", "Thu, 9 Jun 2011 13:56:25 GMT  (385kb)", "http://arxiv.org/abs/1106.1819v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["a darwiche", "p marquis"], "accepted": false, "id": "1106.1819"}, "pdf": {"name": "1106.1819.pdf", "metadata": {"source": "CRF", "title": "A Knowledge Compilation Map", "authors": ["Adnan Darwiche", "Pierre Marquis"], "emails": ["darwiche@cs.ucla.edu", "marquis@cril.univ-artois.fr"], "sections": [{"heading": "1. Introduction", "text": "Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Gre\u0301goire, Marquis, Mazure, & Sa\u0308\u0131s, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987). According to this direction, a propositional theory is compiled off-line into a target language, which is then used on-line to answer a large number of queries in polytime. The key motivation behind knowledge compilation is to push as much of the computational overhead into the off-line phase, which is amortized over all on-line queries. But knowledge compilation can serve other important purposes as well. For example, target compilation languages and their associated algorithms can be very simple, allowing one to develop on-line reasoning systems for simple software and hardware platforms. Moreover, the simplicity of algorithms that operate on compiled languages help in streamlining the effort of algorithmic design into a single task: that of generating the smallest compiled representations possible, as that turns out to be the main computational bottleneck in compilation approaches.\nThere are three key aspects of any knowledge compilation approach: the succinctness of the target language into which the propositional theory is compiled; the class of queries that can be answered in polytime based on the compiled representation; and the class of transformations that can be applied to the representation in polytime. The AI literature has thus far focused mostly on target compilation languages which are variations on DNF and CNF formulas, such as Horn theories and prime implicates. Moreover, it has focused mostly on clausal entailment queries, with very little discussion of tractable transformations on compiled theories.\nThe goal of this paper is to provide a broad perspective on knowledge compilation by considering a relatively large number of target compilation languages and analyzing them according to their succinctness and the class of queries/transformations that they admit in polytime.\nc\u00a92002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nInstead of focusing on classical, flat target compilation languages based on CNF and DNF, we consider a richer, nested class based on representing propositional sentences using directed acyclic graphs, which we refer to as NNF. We identify a number of target compilation languages that have been presented in the AI, formal verification, and computer science literature and show that they are special cases of NNF. For each such class, we list the extra conditions that need to be imposed on NNF to obtain the specific class, and then identify the set of queries and transformations that the class supports in polytime. We also provide cross-rankings of the different subsets of NNF, according to their succinctness and the polytime operations they support.\nThe main contribution of this paper is then a map for deciding the target compilation language that is most suitable for a particular application. Specifically, we propose that one starts by identifying the set of queries and transformations needed for their given application, and then choosing the most succinct language that supports these operations in polytime.\nThis paper is structured as follows. We start by formally defining the NNF language in Section 2, where we list a number of conditions on NNF that give rise to a variety of target compilation languages. We then study the succinctness of these languages in Section 3 and provide a cross-ranking that compares them according to this measure. We consider a number of queries and their applications in Section 4 and compare the different target compilation languages according to their tractability with respect to these queries. Section 5 is then dedicated to a class of transformations, their applications, and their tractability with respect to the different target compilation languages. We finally close in Section 6 by some concluding remarks. Proofs of all theorems are delegated to Appendix A.\n2. The NNF Language\nWe consider more than a dozen languages in this paper, all of which are subsets of the NNF language, which is defined formally as follows (Darwiche, 1999, 2001a).\nDefinition 2.1 Let PS be a denumerable set of propositional variables. A sentence in NNFPS is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false, X or \u00acX, X \u2208 PS; and each internal node is labeled with \u2227 or \u2228 and can have arbitrarily many children. The size of a sentence \u03a3 in NNFPS, denoted | \u03a3 |, is the number of its DAG edges. Its height is the maximum number of edges from the root to some leaf in the DAG.\nFigure 1 depicts a sentence in NNF, which represents the odd parity function (we omit reference to variables PS when no confusion is anticipated). Any propositional sentence can be represented as a sentence in NNF, so the NNF language is complete.\nIt is important here to distinguish between a representation language and a target compilation language. A representation language is one which we expect humans to read and write with some ease. The language of CNF is a popular representation language, and so is the language of Horn clauses (especially when expressed in rules form). On other hand, a target compilation language does not need to be suitable for human specification and interpretation, but should be tractable enough to permit a non-trivial number of polytime queries and/or transformations. We will consider a number of target compilation languages that do not qualify as representation languages from this perspective, as they are not suitable for humans to construct or interpret. We will also consider a number of representation languages that do not qualify as target compilation languages.1\nA formal characterization of representation languages is outside the scope of this paper. But for a language to qualify as a target compilation language, we will require that it permits a polytime clausal entailment test. Note that a polytime consistency test is not sufficient here, as only one consistency test on a given theory does not justify its compilation. Given this definition, NNF does\n1. It appears that when proposing target compilation languages in the AI literature, there is usually an implicit requirement that the proposed language is also a representation language. As we shall see later, however, the most powerful target compilation languages are not suitable for humans to specify or interpret directly."}, {"heading": "Decomposability", "text": "not qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its subsets do. We define a number of these subsets below, each of which is obtained by imposing further conditions on NNF.\nWe will distinguish between two key subsets of NNF: flat and nested subsets. We first consider flat subsets, which result from imposing combinations of the following properties:\n\u2022 Flatness: The height of each sentence is at most 2. The sentence in Figure 3 is flat, but the one in Figure 1 is not.\n\u2022 Simple-disjunction: The children of each or-node are leaves that share no variables (the node is a clause).\n\u2022 Simple-conjunction: The children of each and-node are leaves that share no variables (the node is a term). The sentence in Figure 3 satisfies this property.\nDefinition 2.2 The language f-NNF is the subset of NNF satisfying flatness. The language CNF is the subset of f-NNF satisfying simple\u2013disjunction. The language DNF is the subset of f-NNF satisfying simple\u2013conjunction.\nCNF does not permit a polytime clausal entailment test (unless P=NP) and, hence, does not qualify as a target compilation language. But its dual DNF does.\nThe following subset of CNF, prime implicates, has been quite influential in computer science:\nDefinition 2.3 The language PI is the subset of CNF in which each clause entailed by the sentence is subsumed by a clause that appears in the sentence; and no clause in the sentence is subsumed by another.\nA dual of PI, prime implicants IP, can also be defined.\nDefinition 2.4 The language IP is the subset of DNF in which each term entailing the sentence subsumes some term that appears in the sentence; and no term in the sentence is subsumed by another term.\nThere has been some work on representing the set of prime implicates of a propositional theory in a compact way, allowing an exponential number of prime implicates to be represented in polynomial space in certain cases\u2014see for example the TRIE representation in (de Kleer, 1992), the ZBDD representation used in (Simon & del Val, 2001), and the implicit representation based on metaproducts, as proposed in (Madre & Coudert, 1992). These representations are different from the language PI in the sense that they do not necessarily support the same queries and transformations\nthat we report in Tables 5 and 7. They also exhibit different succinctness relationships than the ones we report in Table 3.\nHorn theories (and renamable Horn theories) represent another target compilation subset of CNF, but we do not consider it here since we restrict our attention to complete languages L only, i.e., we require that every propositional sentence is logically equivalent to an element of L.\nWe now consider nested subsets of the NNF language, which do not impose any restriction on the height of a sentence. Instead, these subsets result from imposing one or more of the following conditions: decomposability, determinism, smoothness, decision, and ordering. We start by defining the first three properties. From here on, if C is a node in an NNF, then Vars(C) denotes the set of all variables that label the descendants of node C. Moreover, if \u03a3 is an NNF sentence rooted at C, then Vars(\u03a3) is defined as Vars(C).\n\u2022 Decomposability (Darwiche, 1999, 2001a). An NNF satisfies this property if for each conjunction C in the NNF, the conjuncts of C do not share variables. That is, if C1, . . . , Cn are the children of and-node C, then Vars(Ci) \u2229 Vars(Cj) = \u2205 for i 6= j. Consider the and-node marked in Figure 1(a). This node has two children, the first contains variables A,B while the second contains variables C,D. This and-node is then decomposable since the two children do not share variables. Each other and-node in Figure 1(a) is also decomposable and, hence, the NNF in this figure is decomposable.\n\u2022 Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each two disjuncts of C are logically contradictory. That is, if C1, . . . , Cn are the children of or-node C, then Ci \u2227 Cj |= false for i 6= j. Consider the or-node marked in Figure 1(b), which has two children corresponding to sub-sentences \u00acA \u2227 B and \u00acB \u2227 A. The conjunction of these two sub-sentences is logically contradictory. The or-node is then deterministic and so are the other or-nodes in Figure 1(b). Hence, the NNF in this figure is deterministic.\n\u2022 Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each disjunct of C mentions the same variables. That is, if C1, . . . , Cn are the children of or-node C, then Vars(Ci) = Vars(Cj) for i 6= j. Consider the marked or-node in Figure 1(c). This node has two children, each of which mentions variables A,B. This or-node is then smooth and so are the other or-nodes in Figure 1(c). Hence, the NNF in this figure is smooth.\nIt is hard to ensure decomposability. It is also hard to ensure determinism while preserving decomposability. Yet any sentence in NNF can be smoothed in polytime, while preserving decomposability and determinism. Preserving flatness, however, may blow-up the size of given NNF. Hence, smoothness is not that important from a complexity viewpoint unless we have flatness.\nThe properties of decomposability, determinism and smoothness lead to a number of interesting subsets of NNF.\nDefinition 2.5 The language DNNF is the subset of NNF satisfying decomposability; d-NNF is the subset satisfying determinism; s-NNF is the subset satisfying smoothness; d-DNNF is the subset satisfying decomposability and determinism; and sd-DNNF is the subset satisfying decomposability, determinism and smoothness.\nNote that DNF is a strict subset of DNNF (Darwiche, 1999, 2001a). The following decision property comes from the literature on binary decision diagrams (Bryant, 1986).\nDefinition 2.6 (Decision) A decision node N in an NNF sentence is one which is labeled with true, false, or is an or-node having the form (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2), where X is a variable, \u03b1 and \u03b2 are decision nodes. In the latter case, dVar(N) denotes the variable X.\nDefinition 2.7 The language BDD is the set of NNF sentences, where the root of each sentence is a decision node.\nThe NNF sentence in Figure 2 belongs to the BDD subset. The BDD language corresponds to binary decision diagrams (BDDs), as known in the formal verification literature (Bryant, 1986). Binary decision diagrams are depicted using a more compact notation though: the labels true and false are denoted by 1 and 0, respectively; and each decision\nnode X \u00acX\u03b1 \u03b2 and\nor\nand\nis denoted by \u03b1 \u03b2\nX\n. The BDD sentence on the left of Figure 2 corresponds to the binary decision diagram on the right of Figure 2. Obviously enough, every NNF sentence that satisfies the decision property is also deterministic. Therefore, BDD is a subset of d-NNF.\nAs we show later, BDD does not qualify as a target compilation language (unless P=NP), but the following subset does.\nDefinition 2.8 FBDD is the intersection of DNNF and BDD.\nThat is, each sentence in FBDD is decomposable and satisfies the decision property. The FBDD language corresponds to free binary decision diagrams (FBDDs), as known in formal verification (Gergov & Meinel, 1994a). An FBDD is usually defined as a BDD that satisfies the read-once property: on each path from the root to a leaf, a variable can appear at most once. FBDDs are also known as read-once branching programs in the theory literature. Imposing the read-once property on a BDD is equivalent to imposing the decomposability property on its corresponding BDD sentence.\nA more influential subset of the BDD language is obtained by imposing the ordering property:\nDefinition 2.9 (Ordering) Let < be a total ordering on the variables PS. The language OBDD< is the subset of FBDD satisfying the following property: if N and M are or-nodes, and if N is an ancestor of node M , then dVar(N) < dVar(M).\nDefinition 2.10 The language OBDD is the union of all OBDD< languages.\nThe OBDD language corresponds to the well\u2013known ordered binary decision diagrams (OBDDs) (Bryant, 1986).\nOur final language definition is as follows:\nDefinition 2.11 MODS is the subset of DNF where every sentence satisfies determinism and smoothness.\nFigure 3 depicts a sentence in MODS. As we show later, MODS is the most tractable NNF subset we shall consider (together with OBDD<). This is not surprising since from the syntax of a sentence in MODS, one can immediately recover the sentence models.\nThe languages we have discussed so far are depicted in Figure 4, where arrows denote set inclusion. Table 1 lists the acronyms of all of these languages, together with their descriptions. Table 2 lists the key language properties discussed in this section, together with a short description of each."}, {"heading": "3. On the Succinctness of Compiled Theories", "text": "We have discussed more than a dozen subsets of the NNF language. Some of these subsets are well known and have been studied extensively in the computer science literature. Others, such as DNNF (Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new. The question now is: What subset should one adopt for a particular application? As we argue in this paper, that depends\non three key properties of the language: its succinctness, the class of tractable queries it supports, and the class of tractable transformations it admits.\nOur goal in this and the following sections is to construct a map on which we place different subsets of the NNF language according to the above criteria. This map will then serve as a guide to system designers in choosing the target compilation language most suitable to their application. It also provides an example paradigm for studying and evaluating further target compilation languages. We start with a study of succinctness2 in this section (Gogic, Kautz, Papadimitriou, & Selman, 1995).\nDefinition 3.1 (Succinctness) Let L1 and L2 be two subsets of NNF. L1 is at least as succinct as L2, denoted L1 \u2264 L2, iff there exists a polynomial p such that for every sentence \u03b1 \u2208 L2, there exists an equivalent sentence \u03b2 \u2208 L1 where |\u03b2| \u2264 p(|\u03b1|). Here, |\u03b1| and |\u03b2| are the sizes of \u03b1 and \u03b2, respectively.\nWe stress here that we do not require that there exists a function that computes \u03b2 given \u03b1 in polytime; we only require that a polysize \u03b2 exists. Yet, our proofs in Appendix A contain specific algorithms for computing \u03b2 from \u03b1 in certain cases. The relation \u2264 is clearly reflexive and transitive, hence, a pre-ordering. One can also define the relation <, where L1 < L2 iff L1 \u2264 L2 and L2 6\u2264 L1.\nProposition 3.1 The results in Table 3 hold.\nAn occurrence of \u2264 in the cell of row r and column c of Table 3 means that the fragment Lr given at row r is at least as succinct as the fragment Lc given at column c. An occurrence of 6\u2264 (or 6\u2264\u2217) means that Lr is not at least as succinct as Lc (provided that the polynomial hierarchy does not collapse in the case of 6\u2264\u2217). Finally, the presence of a question mark reflects our ignorance about whether Lr is at least as succinct as Lc. Figure 5 summarizes the results of Proposition 3.1 in terms of a directed acyclic graph.\nA classical result in knowledge compilation states that it is not possible to compile any propositional formula \u03b1 into a polysize data structure \u03b2 such that: \u03b1 and \u03b2 entail the same set of clauses, and clausal entailment on \u03b2 can be decided in time polynomial in its size, unless NP \u2286 P/poly (Selman & Kautz, 1996; Cadoli & Donini, 1997). This last assumption implies the collapse of the polynomial hierarchy at the second level (Karp & Lipton, 1980), which is considered very unlikely. We use this classical result from knowledge compilation in some of our proofs of Proposition 3.1, which explains why some of its parts are conditioned on the polynomial hierarchy not collapsing.\nWe have excluded the subsets BDD, s-NNF, d-NNF and f-NNF from Table 3 since they do not qualify as target compilation languages (see Section 4). We kept NNF and CNF though given their importance. Consider Figure 5 which depicts Table 3 graphically. With the exception of NNF and CNF, all other languages depicted in Figure 5 qualify as target compilation languages. Moreover, with the exception of language PI, DNNF is the most succinct among all target compilation languages\u2014we know that PI is not more succinct than DNNF, but we do not know whether DNNF is more succinct than PI.\nIn between DNNF and MODS, there is a succinctness ordering of target compilation languages:\nDNNF < d-DNNF < FBDD < OBDD < OBDD< < MODS.\nDNNF is obtained by imposing decomposability on NNF; d-DNNF by adding determinism; FBDD by adding decision; and OBDD and OBDD< by adding ordering (w.r.t. any total ordering on PS in the first case and a specific one in the second case). Adding each of these properties reduces language succinctness (assuming that the polynomial hierarchy does not collapse).\nOne important fact to stress here is that adding smoothness to d-DNNF does not affect its succinctness: the sd-DNNF and d-DNNF languages are equally succinct. It is also interesting to compare\n2. A more general notion of space efficiency (model preservation for polysize reductions) exists (Cadoli, Donini, Liberatore, & Schaerf, 1996), but we do not need its full generality here.\nsd-DNNF (which is more succinct than the influential FBDD, OBDD and OBDD< languages) with MODS, which is a most tractable language. Both sd-DNNF and MODS are smooth, deterministic and decomposable. MODS, however, is flat and obtains its decomposability from the stronger condition of simple-conjunction. Therefore, sd-DNNF can be viewed as the result of relaxing from MODS the flatness and simple-conjunction conditions, while maintaining decomposability, determinism and smoothness. Relaxing these conditions moves the language three levels up the succinctness hierarchy, although it compromises only the polytime test for sentential entailment and possibly the one for equivalence as we show in Section 4."}, {"heading": "4. Querying a Compiled Theory", "text": "In evaluating the suitability of a target compilation language to a particular application, the succinctness of the language must be balanced against the set of queries and transformations that it supports in polytime. We consider in this section a number of queries, each of which returns valuable information about a propositional theory, and then identify target compilation languages which provide polytime algorithms for answering such queries. We restrict our attention in this paper to the existence of polytime algorithms for answering queries, but we do not present the algorithms themselves. The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for some of these algorithms and to the proofs of theorems in Appendix A for others.\nThe queries we consider are tests for consistency, validity, implicates (clausal entailment), implicants, equivalence, and sentential entailment. We also consider counting and enumerating theory models; see Table 4. One can also consider computing the probability of a propositional sentence, assuming that all variables are probabilistically independent. For the subsets we consider, however, this can be done in polytime whenever models can be counted in polytime.\nFrom here on, L denotes a subset of language NNF.\nDefinition 4.1 (CO, VA) L satisfies CO (VA) iff there exists a polytime algorithm that maps every formula \u03a3 from L to 1 if \u03a3 is consistent (valid), and to 0 otherwise.\nOne of the main applications of compiling a theory is to enhance the efficiency of answering clausal entailment queries:\nDefinition 4.2 (CE) L satisfies CE iff there exists a polytime algorithm that maps every formula \u03a3 from L and every clause \u03b3 from NNF to 1 if \u03a3 |= \u03b3 holds, and to 0 otherwise.\nA key application of clausal entailment is in testing equivalence. Specifically, suppose we have a design expressed as a set of clauses \u2206d = \u2227\ni \u03b1i and a specification expressed also as a set of clauses \u2206s = \u2227\nj \u03b2j , and we want to test whether the design and specification are equivalent. By compiling\neach of \u2206d and \u2206s to targets \u0393d and \u0393s that support a polytime clausal entailment test, we can test the equivalence of \u2206d and \u2206s in polytime. That is, \u2206d and \u2206s are equivalent iff \u0393d |= \u03b2j for all j and \u0393s |= \u03b1i for all i.\nA number of the target compilation languages we shall consider support a direct polytime equivalent test:\nDefinition 4.3 (EQ, SE) L satisfies EQ (SE) iff there exists a polytime algorithm that maps every pair of formulas \u03a3, \u03a6 from L to 1 if \u03a3 \u2261 \u03a6 (\u03a3 |= \u03a6) holds, and to 0 otherwise.\nNote that sentential entailment (SE) is stronger than clausal entailment and equivalence. Therefore, if a language L satisfies SE, it also satisfies CE and EQ.\nFor completeness, we consider the following dual to CE:\nDefinition 4.4 (IM) L satisfies IM iff there exists a polytime algorithm that maps every formula \u03a3 from L and every term \u03b3 from NNF to 1 if \u03b3 |= \u03a3 holds, and to 0 otherwise.\nFinally, we consider counting and enumerating models:\nDefinition 4.5 (CT) L satisfies CT iff there exists a polytime algorithm that maps every formula \u03a3 from L to a nonnegative integer that represents the number of models of \u03a3 (in binary notation).\nDefinition 4.6 (ME) L satisfies ME iff there exists a polynomial p(., .) and an algorithm that outputs all models of an arbitrary formula \u03a3 from L in time p(n,m), where n is the size of \u03a3 and m is the number of its models (over variables occurring in \u03a3).\nTable 4 summarizes the queries we are interested in and their acronyms. The following proposition states what we know about the availability of polytime algorithms for\nanswering the above queries, with respect to all languages we introduced in Section 2.\nProposition 4.1 The results in Table 5 hold.\nThe results of Proposition 4.1 are summarized in Figure 4. One can draw a number of conclusions based on the results in this figure. First, NNF, s-NNF, d-NNF, f-NNF, and BDD fall in one equivalence class that does not support any polytime queries and CNF satisfies only VA and IM; hence, none of them qualifies as a target compilation language in this case. But the remaining languages all support polytime tests for consistency and clausal entailment. Therefore, simply imposing either of smoothness (s-NNF), determinism (d-NNF), flatness (f-NNF), or decision (BDD) on the NNF language does not lead to tractability with respect to any of the queries we consider\u2014neither of these properties seem to be significant in isolation. Decomposability (DNNF), however, is an exception and leads immediately to polytime tests for both consistency and clausal entailment, and to a polytime algorithm for model enumeration.\nRecall the succinctness ordering DNNF < d-DNNF < FBDD < OBDD < OBDD< < MODS from Figure 5. By adding decomposability (DNNF), we obtain polytime tests for consistency and clausal entailment, in addition to a polytime model enumeration algorithm. By adding determinism to decomposability (d-DNNF), we obtain polytime tests for validity, implicant and model counting, which are quite significant. It is not clear, however, whether the combination of decomposability and determinism leads to a polytime test for equivalence. Moreover, adding the decision property on top of decomposability and determinism (FBDD) does not appear to increase tractability with respect to the given queries3, although it does lead to reducing language succinctness as shown in Figure 5. On the other hand, adding the ordering property on top of decomposability, determinism and decision, leads to polytime tests for equivalence (OBDD and OBDD<) as well as sentential entailment provided that the ordering < is fixed (OBDD<).\nAs for the succinctness ordering NNF < DNNF < DNF < IP < MODS from Figure 5, note that DNNF is obtained by imposing decomposability on NNF, while DNF is obtained by imposing flatness and simple-conjunction (which is stronger than decomposability). What is interesting is that DNF is less succinct than DNNF, yet does not support any more polytime queries; see Figure 4. However, the addition of smoothness (and determinism) on top of flatness and simple-conjunction (MODS) leads to five additional polytime queries, including equivalence and entailment tests.4\nWe close this section by noting that determinism appears to be necessary (but not sufficient) for polytime model counting: only deterministic languages, d-DNNF, sd-DNNF, FBDD, OBDD, OBDD< and MODS, support polytime counting. Moreover, polytime counting implies a polytime test of validity, but the opposite is not true."}, {"heading": "5. Transforming a Compiled Theory", "text": "A query is an operation that returns information about a theory without changing it. A transformation, on the other hand, is an operation that returns a modified theory, which is then operated on using queries. Many applications require a combination of transformations and queries.\nDefinition 5.1 (\u2227C,\u2228C) Let L be a subset of NNF. L satisfies \u2227C (\u2228C) iff there exists a polytime algorithm that maps every finite set of formulas \u03a31, . . . ,\u03a3n from L to a formula of L that is logically equivalent to \u03a31 \u2227 . . . \u2227 \u03a3n (\u03a31 \u2228 . . . \u2228 \u03a3n).\nDefinition 5.2 (\u00acC) Let L be a subset of NNF. L satisfies \u00acC iff there exists a polytime algorithm that maps every formula \u03a3 from L to a formula of L that is logically equivalent to \u00ac\u03a3.\nIf a language satisfies one of the above properties, we will say that it is closed under the corresponding operator. Closure under logical connectives is important for two key reasons. First, it has implications on how compilers are constructed for a given target language. For example, if a clause can be easily compiled into some language L, then closure under conjunction implies that compiling a CNF sentence into L is easy. Second, it has implications on the class of polytime queries supported by the target language: If a language L satisfies CO and is closed under negation and conjunction, then it must satisfy SE (to test whether \u2206 |= \u0393, all we have to do, by the Refutation Theorem, is test whether \u2206 \u2227 \u00ac\u0393 is inconsistent). Similarly, if a language satisfies VA and is closed under negation and disjunction, it must satisfy SE by the Deduction Theorem.\n3. Deciding the equivalence of two sentences in FBDD, d-DNNF, or in sd-DNNF, can be easily shown to be in coNP. However, we do not have a proof of coNP-hardness, nor do we have deterministic polytime algorithms for deciding these problems. Actually, the latter case is quite unlikely as the equivalence problem for FBDD has been intensively studied, with no such algorithm in sight. Note, however, that the equivalence of two sentences in FBDD can be decided probabilistically in polytime (Blum, Chandra, & Wegman, 1980), and similarly for sentences in d-DNNF (Darwiche & Huang, 2002). 4. Given flatness, simple-conjunction and smoothness, we can obtain determinism by simply removing duplicated terms.\nIt is important to stress here that some languages are closed under a logical operator, only if the number of operands is bounded by a constant. We will refer to this as bounded closure.\nDefinition 5.3 (\u2227BC,\u2228BC) Let L be a subset of NNF. L satisfies \u2227BC (\u2228BC) iff there exists a polytime algorithm that maps every pair of formulas \u03a3 and \u03a6 from L to a formula of L that is logically equivalent to \u03a3 \u2227 \u03a6 (\u03a3 \u2228 \u03a6).\nWe now turn to another important transformation:\nDefinition 5.4 (Conditioning) (Darwiche, 1999) Let \u03a3 be a propositional formula, and let \u03b3 be a consistent term. The conditioning of \u03a3 on \u03b3, noted \u03a3 | \u03b3, is the formula obtained by replacing each variable X of \u03a3 by true (resp. false) if X (resp. \u00acX) is a positive (resp. negative) literal of \u03b3.\nDefinition 5.5 (CD) Let L be a subset of NNF. L satisfies CD iff there exists a polytime algorithm that maps every formula \u03a3 from L and every consistent term \u03b3 to a formula from L that is logically equivalent to \u03a3 | \u03b3.\nConditioning has a number of applications, and corresponds to restriction in the literature on Boolean functions. The main application of conditioning is due to a theorem, which says that \u03a3\u2227 \u03b3 is consistent iff \u03a3 | \u03b3 is consistent (Darwiche, 2001a, 1999). Therefore, if a language satisfies CO and CD, then it must also satisfy CE. Conditioning also plays a key role in building compilers that enforce decomposability. If two sentences \u22061 and \u22062 are both decomposable (belong to DNNF), their conjunction \u22061 \u2227 \u22062 is not necessarily decomposable since the sentences may share variables. Conditioning can be used to ensure decomposability in this case since \u22061 \u2227 \u22062 is equivalent to \u2228\n\u03b3(\u22061 | \u03b3) \u2227 (\u22062 | \u03b3) \u2227 \u03b3, where \u03b3 is a term covering all variables shared by \u22061 and \u22062. Note that \u2228\n\u03b3(\u22061 | \u03b3) \u2227 (\u22062 | \u03b3) \u2227 \u03b3 must be decomposable since \u22061 | \u03b3 and \u22062 | \u03b3 do not mention variables in \u03b3. The previous proposition is indeed a generalization to multiple variables of the well-known Shannon expansion in the literature on Boolean functions. It is also the basis for compiling CNF into DNNF (Darwiche, 1999, 2001a).\nAnother critical transformation we shall consider is that of forgetting (also referred to as marginalization, or elimination of middle terms (Boole, 1854)):\nDefinition 5.6 (Forgetting) Let \u03a3 be a propositional formula, and let X be a subset of variables from PS. The forgetting of X from \u03a3, denoted \u2203X.\u03a3, is a formula that does not mention any variable from X and for every formula \u03b1 that does not mention any variable from X, we have \u03a3 |= \u03b1 precisely when \u2203X.\u03a3 |= \u03b1.\nTherefore, to forget variables from X is to remove any reference to X from \u03a3, while maintaining all information that \u03a3 captures about the complement of X. Note that \u2203X.\u03a3 is unique up to logical equivalence.\nDefinition 5.7 (FO, SFO) Let L be a subset of NNF. L satisfies FO iff there exists a polytime algorithm that maps every formula \u03a3 from L and every subset X of variables from PS to a formula from L equivalent to \u2203X.\u03a3. If the property holds for singleton X, we say that L satisfies SFO.\nForgetting is an important transformation as it allows us to focus/project a theory on a set of variables. For example, if we know that some variables X will never appear in entailment queries, we can forget these variables from the compiled theory while maintaining its ability to answer such queries correctly. Another application of forgetting is in counting/enumerating the instantiations of some variables Y, which are consistent with a theory \u2206. This query can be answered by counting/enumerating the models of \u2203X.\u2206, where X is the complement of Y. Forgetting also has applications to planning, diagnosis and belief revision. For instance, in the SATPLAN framework,\ncompiling away fluents or actions amounts to forgetting variables. In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information required to compute the conflicts and the diagnoses of a system (Darwiche, 2001a). Forgetting has also been used to design update operators with valuable properties (Herzig & Rifi, 1999).\nTable 6 summarizes the transformations we are interested in and their acronyms. The following proposition states what we know about the tractability of these transformations with respect to the identified target compilation languages.\nProposition 5.1 The results in Table 7 hold.\nOne can draw a number of observations regarding Table 7. First, all languages we consider satisfy CD and, hence, lend themselves to efficient application of the conditioning transformation. As for forgetting multiple variables, only DNNF, DNF, PI and MODS permit that in polytime. It is important to stress here that none of FBDD, OBDD and OBDD< permits polytime forgetting of multiple variables. This is noticeable since some of the recent applications of OBDD< to planning\u2014within the so-called symbolic model checking approach to planning (A. Cimmati & Traverso, 1997)\u2014depend crucially\non the operation of forgetting and it may be more suitable to use a language that satisfies FO in this case. Note, however, that OBDD and OBDD< allow the forgetting of a single variable in polytime, but FBDD does not allow even that. d-DNNF is similar to FBDD as it satisfies neither FO nor SFO.\nIt is also interesting to observe that none of the target compilation languages is closed under conjunction. A number of them, however, are closed under bounded conjunction, including OBDD<, DNF, IP and MODS.\nAs for disjunction, the only target compilation languages that are closed under disjunction are DNNF and DNF. The OBDD< and PI languages, however, are closed under bounded disjunction. Again, the d-DNNF, FBDD and OBDD languages are closed under neither.\nThe only target compilation languages that are closed under negation are FBDD, OBDD and OBDD<, while it is not known whether d-DNNF or sd-DNNF are closed under this operation. Note that d-DNNF and FBDD support the same set of polytime queries (equivalence checking is unknown for both) so they are indistinguishable from that viewpoint. Moreover, the only difference between the two languages in Table 7 is the closure of FBDD under negation, which does not seem to be that significant in light of no closure under either conjunction or disjunction. Note, however, that d-DNNF is more succinct than FBDD as given in Figure 5.\nFinally, OBDD< is the only target compilation language that is closed under negation, bounded conjunction, and bounded disjunction. This closure actually plays an important role in compiling propositional theories into OBDD< and is the basis of state-of-the-art compilers for this purpose (Bryant, 1986)."}, {"heading": "6. Conclusion", "text": "The main contribution of this paper is a methodology for analyzing propositional compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations it supports in polytime. The second main contribution of the paper is a comprehensive analysis, according to the proposed methodology, of more than a dozen languages for which we have produced a knowledge compilation map, which cross-ranks these languages according to their succinctness, and the polytime queries and transformations they support. This map allows system designers to make informed decisions on which target compilation language to use: after the class of queries/transformations have been decided based on the application of interest, the designer chooses the most succinct target compilation language that supports such operations in polytime. Another key contribution of this paper is the uniform treatment we have applied to diverse target compilation languages, showing how they all are subsets of the NNF language. Specifically, we have identified a number of simple, yet meaningful, properties, including decomposability, determinism, decision and flatness, and showed how combinations of these properties give rise to different target compilation languages. The studied subsets include some well known languages such as PI, which has been influential in AI; OBDD<, which has been influential in formal verification; and CNF and DNF, which have been quite influential in computer science. The subsets also include some relatively new languages such as DNNF and d-DNNF, which appear to represent interesting, new balances between language succinctness and query/transformation tractability."}, {"heading": "Acknowledgments", "text": "This is a revised and extended version of the paper \u201cA Perspective on Knowledge Compilation,\u201d in Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI\u201901), pp. 175-182, 2001. We wish to thank Alvaro del Val, Mark Hopkins, Je\u0301ro\u0302me Lang and the anonymous reviewers for some suggestions and comments, as well as Ingo Wegener for his help with some of the issues discussed in the paper. This work has been done while the second author was a visiting researcher with the Computer Science Department at UCLA. The first author has been partly\nsupported by NSF grant IIS-9988543 and MURI grant N00014-00-1-0617. The second author has been partly supported by the IUT de Lens, the Universite\u0301 d\u2019Artois, the Nord/Pas-de-Calais Re\u0301gion under the TACT-TIC project, and by the European Community FEDER Program."}, {"heading": "Appendix A. Proofs", "text": "To simplify the proofs of our main propositions later on, we have identified a number of lemmas that we list below. Some of the proofs of these lemmas are direct, but we include them for completeness.\nLemma A.1 Every sentence in d-DNNF can be translated to an equivalent sentence in sd-DNNF in polytime.\nProof: Let \u03b1 = \u03b11 \u2228 . . .\u2228 \u03b1n be an or-node in a d-DNNF sentence \u03a3. Suppose that \u03b1 is not smooth and let V = Vars(\u03b1). Consider now the sentence \u03a3s obtained by replacing in \u03a3 each such node by\n\u2228n i=1 \u03b1i \u2227 \u2227 v\u2208V \\Vars(\u03b1i) (\u00acv \u2228 v). Then \u03a3s is equivalent to \u03a3 and is smooth. Moreover, \u03a3s can be computed in time polynomial in the size of \u03a3 and it satisfies decomposability and determinism. \u2737\nLemma A.2 Every sentence in FBDD can be translated to an equivalent sentence in FBDD \u2229 s-NNF in polytime.\nProof: Let \u03a3 be a sentence in FBDD and let \u03b1 be a node in \u03a3. We can always replace \u03b1 with (Y \u2227\u03b1)\u2228 (\u00acY \u2227 \u03b1), for some variable Y , while preserving equivalence and the decision property. Moreover, as long as the variable Y does not appear in \u03b1 and is not an ancestor of \u03b1, then decomposability is also preserved (that is, the resulting sentence is in FBDD). Note here that \u201cancestor\u201d is with respect to the binary decision diagram notation of \u03a3\u2013see left of Figure 2.\nNow, suppose that (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2) is an or-node in \u03a3. Suppose further that the or-node is not smooth. Hence, there is some Y which appears in Vars(\u03b2) but not in Vars(\u03b1) (or the other way around). Since \u03a3 is decomposable, then Y cannot be an ancestor of \u03b1 (since in that case it would also be an ancestor of \u03b2, which is impossible by decomposability of \u03a3). Hence, we can replace \u03b1 with (Y \u2227 \u03b1) \u2228 (\u00acY \u2227 \u03b1), while preserving equivalence, decision and decomposability. By repeating the above process, we can smooth \u03a3 while preserving all the necessary properties. Finally, note that for every or-node (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2) in \u03a3, we need to repeat the above process at most | Vars(\u03b1) \u2212 Vars(\u03b2) | + | Vars(\u03b2) \u2212 Vars(\u03b1) | times. Hence, the smoothing operation can be performed in polytime. \u2737\nLemma A.3 If a subset L of NNF satisfies CO and CD, then it also satisfies ME.\nProof: Let \u03a3 be a sentence in L. First, we test if \u03a3 is inconsistent (can be done in polytime). If it is, we return the empty set of models. Otherwise, we construct a decision-tree representation of the models of \u03a3. Given an ordering of the variables x1, . . . , xn of Vars(\u03a3), we start with a tree T consisting of a single root node. For i = 1 to n, we repeat the following for each leaf node \u03b1 (corresponds to a consistent term) in T :\na. If \u03a3 | \u03b1 \u2227 xi is consistent, we add xi as a child to \u03b1;\nb. If \u03a3 | \u03b1 \u2227 \u00acxi is consistent, we add \u00acxi as a child to \u03b1.\nThe key points are:\n\u2022 Test (a) and Test (b) can be performed in time polynomial in the size of \u03a3 (since L satisfies CO and CD).\n\u2022 Either Test (a) or Test (b) above must succeed (since \u03a3 is consistent). Hence, the number of tests performed is O(mn), where m is the number of leaf nodes in the final decision tree (bounded by the number of models of \u03a3) and n is the number of variables of \u03a3. \u2737\nLemma A.4 If a subset of NNF satisfies CO and CD, then it also satisfies CE.\nProof: To test whether sentence \u03a3 entails non-valid clause \u03b1, \u03a3 |= \u03b1, it suffices to test whether \u03a3 | \u00ac\u03b1 is inconsistent (Darwiche, 2001a). \u2737\nLemma A.5 Let \u03b1 and \u03b2 be two sentences that share no variables. Then \u03b1\u2228\u03b2 is valid iff \u03b1 is valid or \u03b2 is valid.\nProof: \u03b1\u2228 \u03b2 is valid iff \u00ac\u03b1\u2227\u00ac\u03b2 is inconsistent. Since \u00ac\u03b1 and \u00ac\u03b2 share no variables, then \u00ac\u03b1\u2227\u00ac\u03b2 is inconsistent iff \u00ac\u03b1 is inconsistent or \u00ac\u03b2 is. This is true iff \u03b1 is valid or \u03b2 is valid. \u2737\nLemma A.6 Let \u03a3 be a sentence in d-DNNF and let \u03b3 be a clause. Then a sentence in d-DNNF which is equivalent to \u03a3 \u2228 \u03b3 can be constructed in polytime in the size of \u03a3 and \u03b3.\nProof: Let l1, . . . , ln be the literals that appear in clause \u03b3. Then \u03b2 = \u2228n i=1(li \u2227 \u2227i\u22121 j=1 \u00aclj) is equivalent to clause \u03b3, is in d-DNNF, and can be constructed in polytime in size of \u03b3. Now let \u03b1 be the term equivalent to \u00ac\u03b3. We have that \u03a3 \u2228 \u03b3 is equivalent to ((\u03a3 | \u03b1) \u2227 \u03b1) \u2228 \u03b2. The last sentence is in d-DNNF and can be constructed in polytime in size of \u03a3 and \u03b3. \u2737\nLemma A.7 If a subset of NNF satisfies VA and CD, then it also satisfies IM.\nProof: To test whether a consistent term \u03b1 entails sentence \u03a3, \u03b1 |= \u03a3, it suffices to test whether \u00ac\u03b1\u2228\u03a3 is valid. This sentence is equivalent to \u00ac\u03b1\u2228(\u03b1\u2227\u03a3), to \u00ac\u03b1\u2228(\u03b1\u2227(\u03a3 | \u03b1)), and to \u00ac\u03b1\u2228(\u03a3 | \u03b1). Since \u00ac\u03b1 and \u03a3 | \u03b1 share no variables, the disjunction is valid iff \u00ac\u03b1 is valid or \u03a3 | \u03b1 is valid (by Lemma A.5). \u00ac\u03b1 cannot be valid since \u03b1 is consistent. \u03a3 | \u03b1 can be constructed in polytime since the language satisfies CD and its validity can be tested in polytime since the language satisfies VA. \u2737\nLemma A.8 Every CNF or DNF formula can be translated to an equivalent sentence in BDD in polytime.\nProof: It is straightforward to convert a clause or term into an equivalent sentence in BDD. In order to generate a BDD sentence corresponding to the conjunction (resp. disjunction) of BDD sentences \u03b1 and \u03b2, it is sufficient to replace the 1-sink (resp. 0-sink) of \u03b1 with the root of \u03b2. \u2737\nLemma A.9 If a subset of NNF satisfies EQ, then it satisfies CO and VA.\nProof: true and false belong to every NNF subset. \u03a3 is inconsistent iff it is equivalent to false. \u03a3 is valid iff it is equivalent to true. \u2737\nLemma A.10 If a subset of NNF satisfies SE, then it satisfies EQ, CO and VA.\nProof: Sentences \u03a31 and \u03a32 are equivalent iff \u03a31 |= \u03a32 and \u03a32 |= \u03a31. EQ implies CO and VA (Lemma A.9). \u2737\nLemma A.11 Let \u03a3 be a sentence in d-DNNF and let \u03b3 be a clause. The validity of \u03a3 \u2228 \u03b3 can be tested in time polynomial in the size of \u03a3 and \u03b3.\nProof: Construct \u03a3 \u2228 \u03b3 in polytime as given in Lemma A.6 and check its validity, which can be done in polytime too. \u2737\nLemma A.12 For every propositional formula \u03a3 and every consistent term \u03b3, we have \u03a3|\u03b3 is equivalent to \u2203Vars(\u03b3).(\u03a3 \u2227 \u03b3).\nProof: Without loss of generality, assume that \u03a3 is given by the disjunctively-interpreted set of its models (over Vars(\u03a3)). Conditioning \u03a3 on \u03b3 leads (1) to removing every model of \u00ac\u03b3, then (2) projecting the remaining models so that every variable of \u03b3 is removed. Conjoining \u03a3 with \u03b3 leads exactly to (1), while forgetting every variable of \u03b3 in the resulting formula leads exactly to (2) (Lang, Liberatore, & Marquis, 2000). \u2737\nLemma A.13 Each sentence \u03a3 in f-NNF can be converted into an equivalent sentence \u03a3\u2217 in polynomial time, where \u03a3\u2217 \u2208 CNF or \u03a3\u2217 \u2208 DNF.\nProof: We consider three cases for the sentence \u03a3:\n1. The root node of \u03a3 is an and-node. In this case, \u03a3 can be turned into a CNF sentence \u03a3\u2217 in polynomial time by simply ensuring that each or-node in \u03a3 is a clause (that is, a disjunction of literals that share no variables). Let C be an or-node in \u03a3. Since \u03a3 is flat and its root is an and-node, C must be a child of the root of \u03a3 and the children of C must be leaves. Hence, we can easily ensure that C is a clause as follows:\n\u2022 If we have one edge from C to some leaf X and another edge from C to \u00acX (C is valid), we replace the edge from the root to C by an edge from the root to true.\n\u2022 If we have more than one edge from C to the same leaf node X, we keep only one of these edges and delete the rest.\n2. The root of \u03a3 is an or-node. \u03a3 can be turned into a DNF sentence \u03a3\u2217 in a dual way.5\n3. The root of \u03a3 is a leaf node. \u03a3 is already a CNF sentence.\n\u2737\nLemma A.14 \u03b1 is a prime implicant (resp. an essential prime implicant) of sentence \u03a3 iff \u00ac\u03b1 is a prime implicate (resp. an essential prime implicate) of \u00ac\u03a3. 6\nProof: This is a folklore result, immediate from the definitions. \u2737"}, {"heading": "Proof of Proposition 3.1", "text": "The proof of this proposition is broken down into eight steps. In each step, we prove a number of succinctness relationships between different languages, and then apply transitivity of the succinctness relation to infer even more relationships. Associated with each step of the proof is a table in which\nwe mark all relationships that are proved in that step\u2013we don\u2019t show these marks in the very first table though.\nTable 8: Follows immediately from the language inclusions reported in Figure 4. Table 9: We can prove both that DNF 6\u2264 PI and CNF 6\u2264 IP (this slightly generalizes the results\nDNF 6\u2264 CNF and CNF 6\u2264 DNF given in (Gogic et al., 1995)). Let us consider the CNF formula \u03a3n = \u2227n\u22121 i=0 (x2i \u2228 x2i+1). This formula is in prime implicates form7 (and each clause in \u03a3n is an essential prime implicate of it). Hence its negation \u00ac\u03a3n is in prime implicants form (as an easy consequence of Lemma A.14).\nSince Quine\u2019s early work (Quine, 1959), we know that the number of essential prime implicants (resp. prime implicates) of a formula is a lower bound of the number of terms (resp. clauses) that can be found in any DNF (resp. CNF) representation of it (indeed, any such representation must include the essential prime). \u03a3n has 2\nn essential prime implicants. Indeed, this can be easily shown by induction on n given that (i) every literal occurring in \u03a3n occurs only once, (ii) the set of prime implicants of any nontautological clause is the set of literals occurring in it (up to logical equivalence), and (iii) the distribution property for prime implicants (see e.g., (dual of) Proposition 40 in (Marquis, 2000)) which states that IP(\u03b1\u2227\u03b2) = max({PI\u03b1\u2227PI\u03b2 | PI\u03b1 \u2208 IP(\u03b1), PI\u03b2 \u2208 IP(\u03b2)}, |=) (up to logical equivalence). Subsequently, \u00ac\u03a3n has 2n essential prime implicates (cf. Lemma A.14). Accordingly, we obtain that both DNF 6\u2264 PI and CNF 6\u2264 IP. We also obtain PI 6\u2264 IP and IP 6\u2264 PI. Now, it is well\u2013known that some DNF formulas have exponentially many prime implicants (see the proof of Proposition 5.1 where we show that IP does not satisfy SFO). Hence, their negations are CNF\n5. Note that f-NNF satisfies \u00acC and that the negation of a CNF sentence (resp. DNF sentence) can be turned into a DNF (resp. CNF) in linear time. 6. A prime implicant (resp. a prime implicate) \u03b1 of \u03a3 is essential iff the disjunction (resp. conjunction) of all prime implicants (resp. prime implicates) of \u03a3 except \u03b1 is not equivalent to \u03a3. 7. The correctness of (the dual of) Quine\u2019s consensus algorithm for computing prime implicants (Quine, 1955) ensures it, since no clause of \u03a3n is subsumed by another clause and no consensi can be performed since there are no negated variables.\nformulas having exponentially many prime implicates. Subsequently IP 6\u2264 DNF and PI 6\u2264 CNF. The remaining results in this table follow from the transitivity of \u2264.\nTable 10: The parity function On = \u2295n\u22121\ni=0 xi has linear size OBDD< representations (Bryant,\n1986) but only exponential size CNF and DNF representations. The reason is that On has 2 n essential prime implicants (resp. essential prime implicates) and the number of essential prime implicants (resp. essential prime implicates) of a formula is a lower bound of the size of any of its DNF (resp. CNF) representation. This easily shows that both CNF 6\u2264 OBDD and DNF 6\u2264 OBDD. The remaining results in this table follow from the language inclusions reported in Figure 4.\nTable 11: It is shown in (Darwiche, 2001b) that there is a sentence in d-DNNF which only has exponential FBDD representations. Accordingly, we have FBDD 6\u2264 d-DNNF. In (Gergov & Meinel, 1994a), it is shown that OBDD 6\u2264 FBDD. Finally, it is easy to show that OBDD< 6\u2264 OBDD (for instance, the formula \u03a3n = \u2227n i=1(xi \u21d4 yi) has an OBDD< representation of size polynomial in n whenever < satisfies x1 < y1 < x2 < . . . < xn < yn, while it has an OBDD< representation of size exponential in n provided that < is s.t. x1 < x2 < . . . < xn < y1 < y2 < . . . < yn). The remaining results in this table follow from the language inclusions reported in Figure 4.\nTable 12: L\u2019 6\u2264\u2217 L means that L\u2019 6\u2264 L unless the polynomial hierarchy PH collapses. The results in this table follow since the existence of polysize knowledge compilation functions for clausal entailment implies the collapse of the polynomial hierarchy PH (Selman & Kautz, 1996; Cadoli & Donini, 1997). Now, if DNNF \u2264 CNF, then for each sentence \u03a3 in CNF there exists a polysize equivalent sentence \u0393 in DNNF. Therefore, we can test whether a clause is entailed by \u03a3 in polytime by testing whether the clause is entailed by \u0393. This proves the existence of polysize knowledge compilation functions for clausal entailment, leading to the collapse of the polynomial hierarchy PH. The same is true for d-DNNF and sd-DNNF since all these languages support a polytime clausal entailment test (see Proposition 4.1).\nTable 13: In (Wegener, 1987) (Theorem 6.2 pp. 436), a family of n2-variable boolean functions \u03a3 is pointed out. Provided that every interpretation I over these n2 variables represents a n-vertices digraph (for every 1 \u2264 i, j \u2264 n, we have I(xi,j) = 1 iff (i, j) is an arc of the digraph), \u03a3(I) = 1 iff the\ndigraph represented by I contains a k-clique of a special kind (k is a parameter of the family). It is shown that for certain values of k (depending on n), every FBDD representation of \u03a3 has exponential size. Moreover, it is shown that \u03a3 has only a cubic number of prime implicants. This shows that FBDD 6\u2264 IP, hence FBDD 6\u2264 DNF. Because FBDD satisfies \u00acC (see Proposition 5.1),8 it cannot be the case that \u00ac\u03a3 has a polynomial size FBDD. Since \u00ac\u03a3 has only a cubic number of prime implicates, we obtain that FBDD 6\u2264 PI, hence FBDD 6\u2264 CNF. The remaining results in this table follow since FBDD\u2264 OBDD \u2264 OBDD<.\nTable 14: Assume that d-DNNF \u2264 DNF holds. As a consequence, every sentence \u03a3 in DNF can be compiled into an equivalent d-DNNF sentence \u03a3\u2217 of polynomial size. Now, checking whether a clause \u03b3 is entailed by the CNF sentence \u03a3 is equivalent to checking whether the DNF sentence \u00ac\u03a3 \u2228 \u03b3 is valid. Checking whether (\u00ac\u03a3)\u2217\u2228\u03b3 is valid\u2014when (\u00ac\u03a3)\u2217 is a d-DNNF sentence and \u03b3 is a clause\u2014can be achieved in polynomial time by Lemma A.11. Therefore, (\u00ac\u03a3)\u2217 is a polysize compilation of the\n8. That is, a sentence in FBDD can be negated in polytime to yield a sentence in FBDD too.\nL NNF DNNF d-DNNF FBDD OBDD OBDD< DNF CNF PI IP MODS sd-DNNF\nNNF \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 DNNF 6\u2264\u2217 \u2264 \u2264 \u2264 \u2264 \u2264 \u2264 6\u2264\u2217 \u2264 \u2264 \u2264\nd-DNNF 6\u2264\u2217 6\u2264\u2217 \u2264 \u2264 \u2264 \u2264 6\u2264\u2217 6\u2264\u2217 \u2264 \u2264 FBDD 6\u2264 6\u2264 6\u2264 \u2264 \u2264 \u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 OBDD 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 \u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 OBDD< 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 DNF 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 6\u2264 6\u2264 \u2264 \u2264 6\u2264 CNF 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 \u2264 6\u2264 6\u2264 PI 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 6\u2264 6\u2264 IP 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 6\u2264 \u2264 6\u2264 MODS \u2264 sd-DNNF 6\u2264\u2217 6\u2264\u2217 \u2264 \u2264 \u2264 \u2264 6\u2264\u2217 6\u2264\u2217 \u2264 \u2264\nTable 14:\nCNF sentence \u03a3, allowing clausal entailment to be achieved in polynomial time. The existence of such (\u00ac\u03a3)\u2217 for every CNF sentence \u03a3 implies the collapse of the polynomial hierarchy (Selman & Kautz, 1996; Cadoli & Donini, 1997). Hence, we obtain that d-DNNF 6\u2264\u2217 DNF. As a consequence, we also have d-DNNF 6\u2264\u2217 DNNF. Finally, since every d-DNNF sentence can be turned in polynomial time into an equivalent sd-DNNF sentence by Lemma A.1, we have sd-DNNF \u2264 d-DNNF. Moreover, since d-DNNF \u2264 sd-DNNF, we obtain sd-DNNF 6\u2264\u2217 DNF, sd-DNNF 6\u2264\u2217 DNNF, sd-DNNF \u2264 FBDD, sd-DNNF \u2264 OBDD, sd-DNNF \u2264 OBDD<, FBDD 6\u2264 sd-DNNF, OBDD< 6\u2264 sd-DNNF, DNF 6\u2264 sd-DNNF, CNF 6\u2264 sd-DNNF, PI 6\u2264 sd-DNNF and IP 6\u2264 sd-DNNF.\nTable 15: Let us now show that MODS is not less succinct than PI, IP, sd-DNNF and OBDD. First, let us consider the formula \u03a3 = \u2228n i=1 xi. \u03a3 can be represented by PI, IP, sd-DNNF and OBDD formulas of size polynomial in n. Contrastingly, \u03a3 cannot be represented by a MODS formula of size polynomial in n since \u03a3 has 2n \u2212 1 models over Vars(\u03a3). Now, it is well-known that the old good Quine-McCluskey\u2019s algorithm for generating prime implicants from a MODS representation of a propositional formula \u03a3 runs in time polynomial in the number of models of \u03a3 (Wegener, 1987). This shows that IP \u2264 MODS. As to CNF and OBDD<, it is obvious that a decision tree (or Shannon tree) for \u03a3 that respects a given total ordering over Vars(\u03a3) can be generated in polynomial time from a MODS representation of \u03a3. Such a decision tree has m 1-leaves where m is the number of models of \u03a3 over Vars(\u03a3). Accordingly, it has at most n \u2217m 0-leaves where n = |Vars(\u03a3)|. Since the set of all paths from the root of the tree to any 0-leaf can be read as a CNF representation of \u03a3, we obtain that CNF \u2264 MODS. On the other hand, since reducing a decision tree to derive a corresponding OBDD< can be done in polynomial time, it follows that an OBDD< representation of \u03a3 can also be generated from a MODS representation of it. Hence, OBDD< \u2264 MODS. The remaining results in this table follow from the language inclusions reported in Figure 4. \u2737"}, {"heading": "Proof of Proposition 4.1", "text": "The proof of this proposition is broken down into twelve steps. In each step, we prove a number of results. Associated with each step of the proof is a table in which we mark all results that are proved in that step. The table of the last step includes all results declared by this proposition.\nTable 16: Every classical CNF or DNF formula can be translated in a straightforward way into an equivalent f-NNF sentence (with a tree structure) in polytime. Moreover, every NNF sentence can be translated into an equivalent s-NNF sentence in polytime (Lemma A.1). Given that CO is NP-hard (resp. VA is coNP-hard) for classical CNF (resp. DNF) sentences, and the inclusion between the various NNF subsets reported in Figure 4, we obtain the table.\nTable 17: SE implies both CO and VA (Lemma A.10). Moreover, since CT implies both CO and VA, IM implies VA (valid term), and CE implies CO (inconsistent clause), we obtain the table.\nTable 18: A sentence \u03a3 is consistent (resp. valid) iff it has a model (resp. 2n models, where n = |Vars(\u03a3)|). Moreover, the number of models of \u03a3 is given by the number of edges outgoing from the or-node in any MODS representation of \u03a3. Accordingly, CO, VA and CT can be achieved in polynomial time when \u03a3 is given by a MODS formula which gives us the table.\nTable 19:Because DNNF satisfies CE (Darwiche, 2001a), CE implies CO and MODS \u2286 DNF \u2286 DNNF, IP\u2286 DNF and sd-DNNF \u2286 d-DNNF \u2286 DNNF, we obtain the table.\nObviously enough, any query concerning OBDD is equivalent to the corresponding query concerning OBDD< provided that only one DAG is brought into play. Together with the above results, we conclude that OBDD satisfies CO, VA and CT. Since this fragment satisfies CD as well, it satisfies CE, IM and ME in addition. It also satisfies EQ (see Theorem 8.11 from (Meinel & Theobald, 1998)) but does not satisfy SE (unless P = NP). Indeed, it is known that checking the consistency of two OBDD< formulas \u03b1 and \u03b2 (based on two different variable orderings <) is NP-complete (Lemma 8.14 from (Meinel & Theobald, 1998)). Since OBDD satisfies \u00acC and since \u03b1 \u2227 \u03b2 is consistent iff \u03b1 6|= \u00ac\u03b2, checking sentential entailment for OBDD formulas is coNP-complete.\nThese results lead to the table. Table 21: It is known that IM is satisfied by classical CNF formulas (hence, PI) (in order to check whether a non-valid clause is implied by a consistent term, it is sufficient to test that they share a literal). CNF (hence, PI) is also known to satisfy VA. We then obtain the table.\nTable 22: Every sentence in CNF or DNF can be turned into an equivalent sentence in BDD in polytime (Lemma A.8). Hence, a \u25e6 in a CNF or DNF cell implies a \u25e6 in the corresponding BDD cell. Similarly, since BDD \u2286 d-NNF, a \u25e6 in a BDD cell implies a \u25e6 in the corresponding d-NNF cell. This leads to the table.\nTable 23: Since EQ implies CO and VA (Lemma A.9), a \u25e6 in a CO or VA cell implies a \u25e6 in the corresponding EQ cell. This leads to the table.\nTable 24: By definition, PI satisfies CE and IP satisfies IM. Since PI \u2286 CNF and IP \u2286 DNF, this implies that both PI and IP satisfy SE. Now, SE implies EQ, hence both PI and IP satisfy EQ (actually, two equivalent formulas share the same prime implicates and the same prime implicants (both forms are canonical ones, provided that one representative per equivalence class is considered,\nonly)). Since PI satisfies CE, it also satisfies CO. Since it satisfies CD as well (cf. Proposition 5.1), it also satisfies ME (Lemma A.3). Contrastingly, the models counting problem for monotone Krom formulas (i.e. conjunctions of clauses containing at most two literals and only positive literals) is #P-complete (Roth, 1996). Such formulas can easily be turned into prime implicates form in polynomial time (Marquis, 2000), hence PI does not satisfy CT. Now, since the negation of a formula \u03a3 in prime implicates form is a formula in prime implicants form (cf. Lemma A.14), and since the number of models of \u00ac\u03a3 over Vars(\u03a3) is 2|Vars(\u03a3)| minus the number of models of \u03a3 over Vars(\u03a3), we necessarily have that IP does not satisfy CT. This also imply that IP satisfies VA, leading to the table.\nTable 25: In the proof of Proposition 3.1, we have shown that the prime implicants of \u03a3 can be computed in polytime from a MODS representation of \u03a3. As an immediate consequence, since IP satisfies IM, EQ and SE, we obtain that MODS satisfies IM, EQ and SE, leading to the table.\nTable 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA. Since it satisfies CD (Proposition 5.1), it also satisfies IM as well (Lemma A.7). Since sd-DNNF \u2286 d-DNNF, these results follow for sd-DNNF. Hence, we obtain the table.\nTable 27: It is known that determining whether the conjunction of two FBDD formulas \u03b11 and \u03b12 is consistent is NP-complete (Gergov & Meinel, 1994b) Moreover, FBDD satisfies \u00acC. Since \u03b11 \u2227 \u03b12 is inconsistent iff \u03b11 |= \u00ac\u03b12, we can reduce the consistency test into an entailment test. Hence, FBDD does not satisfy SE. Since FBDD \u2286 d-DNNF, d-DNNF does not satisfy SE either. Finally, since every d-DNNF can be translated into an equivalent sd-DNNF sentence in polytime (Lemma A.1), sd-DNNF does not satisfy SE either. This leads to the final table above. \u2737"}, {"heading": "Proof of Proposition 5.1", "text": "The proof of this proposition is broken down into eight steps. Each step corresponds to one of the transformations, where we prove all results pertaining to that transformation.\n\u2022 CD. To show that a language L satisfies CD, we want to show that for any sentence \u03a3 \u2208 L and any consistent term \u03b3, we can construct in polytime a sentence which belongs to L and is equivalent to \u03a3 | \u03b3.\n\u2013 NNF, f-NNF, CNF and DNF. The property is trivially satisfied by these languages: If \u03a3 belongs to any of these languages, then replacing the literals of \u03b3 by a Boolean constant in \u03a3 results a sentence in the same language. In the case of DNF (resp. CNF), some inconsistent terms (valid clauses) may result through conditioning, but these can be removed easily in polynomial time.\n\u2013 DNNF. It is sufficient to prove that conditioning preserves decomposability. For every propositional sentences \u03b1, \u03b2 and every consistent term \u03b3, if \u03b1 and \u03b2 do not share variables, then \u03b1|\u03b3 and \u03b2|\u03b3 do not share variables either since Vars(\u03b1|\u03b3) \u2286 Vars(\u03b1) and Vars(\u03b2|\u03b3) \u2286 Vars(\u03b2).\n\u2013 d-NNF and d-DNNF. Since NNF and DNNF satisfy CD, it is sufficient to prove that conditioning preserves determinism, i.e. for every propositional formulas \u03b1, \u03b2 and every consistent term \u03b3, if \u03b1 \u2227 \u03b2 |= false, then (\u03b1|\u03b3) \u2227 (\u03b2|\u03b3) |= false. If \u03b1 \u2227 \u03b2 |= false, then for every term \u03b3, we have (\u03b1 \u2227 \u03b2) \u2227 \u03b3 |= false. Since (\u03b1 \u2227 \u03b2) \u2227 \u03b3 \u2261 ((\u03b1 \u2227 \u03b2)|\u03b3) \u2227 \u03b3, this implies that ((\u03b1\u2227\u03b2)|\u03b3)\u2227\u03b3 |= false. Since \u03b3 is consistent and share no variable with (\u03b1\u2227\u03b2)|\u03b3, it must be the case that (\u03b1\u2227\u03b2)|\u03b3 is inconsistent. This is equivalent to state that (\u03b1|\u03b3)\u2227 (\u03b2|\u03b3) |= false.\n\u2013 s-NNF and sd-DNNF. Since NNF satisfies CD, and since conditioning preserves decomposability and determinism, all we have to show is that conditioning also preserves smoothness. This follows immediately since for two propositional sentences \u03b1, \u03b2 and a consistent term \u03b3, we have Vars(\u03b1) = Vars(\u03b2) only if Vars(\u03b1 | \u03b3) = Vars(\u03b2 | \u03b3).\n\u2013 BDD, FBDD, OBDD and OBDD<. It is well\u2013known that BDD satisfies CD\u2014the conditioning operation on binary decision diagrams is known as the restrict operation (Bryant, 1986). To condition a sentence \u03a3 in BDD on a consistent term \u03b3, we replace every node labeled by a variable in \u03b3 by one of its two children, according to the sign of the variable in \u03b3. The resulting sentence is also a BDD and is equivalent to \u03a3 | \u03b3. The same applies to FBDD, OBDD and OBDD<. \u2013 PI. The prime implicates of \u03a3 \u2227 \u03b3 can be computed in polytime when \u03a3 is in prime implicates form and \u03b3 is a term (see Proposition 36 in (Marquis, 2000)). Moreover, since\nPI satisfies FO (see below), the prime implicates of \u2203Vars(\u03b3).(\u03a3\u2227\u03b3) can be computed in polytime. But these are exactly the prime implicates of \u03a3 | \u03b3 according to Lemma A.12.\n\u2013 IP. Let \u03a3 = \u2228n\ni=1 \u03b3i be a formula in prime implicants form. It is clear that the formula ( \u2228n\ni=1 \u03b3i) | \u03b3 is a DNF formula equivalent to \u03a3 | \u03b3. Now, our claim is that the formula \u03a3\u2217 obtained by keeping only the logically weakest terms \u03b3i | \u03b3 among ( \u2228n i=1 \u03b3i) | \u03b3 is a prime implicants formula equivalent to \u03a3 | \u03b3. Removing such terms clearly is truth-preserving. Since generating \u03a3\u2217 requires only O(n2) entailment tests among terms, and since such tests can be easily achieved in polynomial time, we obtain that IP satisfies CD. Now, how to prove that \u03a3\u2217 is in prime implicants form? Since any pair of different terms of \u03a3\u2217 cannot be compared w.r.t. logical entailment, the correctness of Quine\u2019s consensus algorithm for generating prime implicants shows that it is sufficient to prove that every consensus among two terms of \u03a3\u2217 is inconsistent or entails another term of \u03a3\u2217. Let\u2019s recall that consensus is to DNF formulas what resolution is to CNF formulas. Since \u03a3 is in prime implicants form, every consensus among two terms of \u03a3 is inconsistent or entails another term of \u03a3. What happens to the terms (here, the prime implicants) of \u03a3 when conditioned by \u03b3? All those containing the negation of a literal of \u03b3 are removed and the remaining ones are shortened by removing from them every literal of \u03b3. Hence, for every pair of terms \u03b31, \u03b32 of \u03a3, if there is no consensus between \u03b31 and \u03b32, then there is no consensus between \u03b31|\u03b3 and \u03b32|\u03b3: conditioning cannot create new consensus. Now, it remains to prove that no unproductive consensus between terms of \u03a3 can be rendered productive through conditioning. Formally, let \u03b31 = \u03b3 \u2032 1 \u2227 l and \u03b32 = \u03b3\u20322 \u2227 \u00acl be two prime implicates of \u03a3 s.t. l (resp. \u00acl) does not appear in \u03b3\u20321 (resp. \u03b3\u20322). There is a consensus \u03b3\u20321\u2227\u03b3\u20322 between \u03b31 and \u03b32. Let us assume that both \u03b31 and \u03b32 have survived the conditioning: this means that both \u03b31|\u03b3 and \u03b32|\u03b3 are consistent. Especially, l belongs to \u03b31|\u03b3 and \u00acl belongs to \u03b32|\u03b3. Accordingly, there is a consensus between \u03b31|\u03b3 and \u03b32|\u03b3. By construction, this consensus is equivalent to (\u03b3\u20321|\u03b3)\u2227(\u03b3\u20322|\u03b3), hence equivalent to (\u03b3\u20321\u2227\u03b3\u20322)|\u03b3. Now, if \u03b3\u20321 \u2227 \u03b3\u20322 is inconsistent, then (\u03b3\u20321 \u2227 \u03b3\u20322)|\u03b3 is inconsistent as well and we are done. Otherwise, let us assume that there exists a prime implicant \u03b33 of \u03a3 s.t. \u03b3 \u2032 1 \u2227 \u03b3\u20322 |= \u03b33 holds. Necessarily, \u03b33 is preserved by the conditioning of \u03a3 by \u03b3. Otherwise, \u03b33 would contain the negation of a literal of \u03b3, but since every literal of \u03b33 is a literal of \u03b31 or a literal of \u03b32, \u03b32 and \u03b33 would not have both survived the conditioning. Since \u03b3 \u2032 1\u2227\u03b3\u20322 |= \u03b33\nholds, we necessarily have (\u03b3\u20321 \u2227 \u03b3\u20322)|\u03b3 |= \u03b33|\u03b3. This completes the proof. \u2013 MODS. Direct consequence of Lemma A.12 and the fact that MODS satisfies \u2227BC and FO\n(see below).\n\u2022 FO.\n\u2013 DNNF and DNF. It is known that DNNF satisfies FO (Darwiche, 2001a). It is also known that DNF satisfies FO (Lang et al., 2000).\n\u2013 NNF, s-NNF, f-NNF, d-NNF, BDD and CNF. Let \u03a3 be a sentence in CNF. We now show that if any of the previous languages satisfies FO, then we can test the consistency of \u03a3 in polytime. Since CNF does not satisfy CO (see Proposition 4.1), it then follows that none of the previous languages satisfy FO unless P = NP. First, we note that \u03a3 must also belong to NNF and f-NNF. Moreover, \u03a3 can be turned into a sentence in BDD in polytime (Lemma A.8) or a sentence in s-NNF in polytime (see the proof of Lemma A.1). We also have that \u03a3 can be turned into a sentence in d-NNF in polytime since BDD \u2286 d-NNF. Suppose now that one of the previous languages, call it L, satisfy FO. We can test the consistency of \u03a3 in polytime as follows:\n\u2217 Convert \u03a3 into a sentence \u03a3\u2217 in L in polytime (as shown above). \u2217 Compute \u2203Vars(\u03a3\u2217).\u03a3\u2217, which can be done in polytime by assumption.\n\u2217 Test the validity of \u2203Vars(\u03a3\u2217).\u03a3\u2217, which can be done in polytime since the sentence contains no variables\u2014all we have to do is check whether the sentence evaluates to true.\nFinally, note that the definition of forgetting implies that a sentence \u0393 is consistent iff \u2203Vars(\u0393).\u0393 is valid, which completes the proof.\n\u2013 d-DNNF and sd-DNNF. Follows immediately since none of these languages satisfies SFO unless P = NP (see below).\n\u2013 IP. Follows immediately since IP does not satisfy SFO.\n\u2013 FBDD, OBDD and OBDD<. We will show that if FBDD (resp. OBDD, OBDD<) satisfies FO, then for every sentence \u0393 in DNF, there must exist an equivalent sentence \u03a3 in FBDD (resp. OBDD, OBDD<), which size is polynomial in the size of \u0393. This contradicts the fact that FBDD (resp. OBDD, OBDD<) 6\u2264 DNF\u2014see Table 3. Given a DNF \u0393 consisting of terms \u03b31, ..., \u03b3n, we can convert each of these terms into equivalent FBDD (resp. OBDD, OBDD<) sentences \u03b11, . . . , \u03b1n in polytime. Let {v1, . . . , vn\u22121} be a set of variables that do not belong to PS. Construct a new set of variables PS\u2032 = PS \u222a {v1, . . . , vn\u22121}. In case of OBDD and OBDD<, we also assume that these new variables are earlier than variables PS in the ordering. Consider now the sentence \u03a3 = \u2203{v1, . . . , vn\u22121}.\u22061, with respect to variables PS\u2032, where \u2206i is inductively defined by:\n\u2217 \u2206i = \u03b1i, for i = n, and \u2217 \u2206i = (\u03b1i \u2227 vi) \u2228 (\u2206i+1 \u2227 \u00acvi), for i = 1, . . . , n \u2212 1.\nClearly enough, an FBDD (resp. OBDD, OBDD<) sentence equivalent to \u2206 1 can be computed in time polynomial in the input size. Moreover, we have \u03a3 \u2261 \u2228ni=1 \u03b1i \u2261 \u2228n\ni=1 \u03b3i \u2261 \u0393. Hence, if FBDD (resp. OBDD, OBDD<) satisfies FO, then we can convert the DNF sentence \u0393 into an equivalent FBDD (resp. OBDD, OBDD<) which size is polynomial in the size of the given DNF. This is impossible in general.\n\u2013 PI. It is known that the prime implicates of \u2203X.\u03a3 are exactly the prime implicates of \u03a3 that do not contain any variable from X (see Proposition 55 in (Marquis, 2000)). Hence, such prime implicates can be computed in time polynomial in the input size when \u03a3 is in prime implicates form.\n\u2013 MODS. Given a MODS formula \u03a3 and a subset X of PS, the formula obtained by removing every leaf node (and the corresponding incoming edges) of \u03a3 labeled by a literal x or \u00acx s.t. x \u2208 X is a MODS representation of \u2203X.\u03a3\u2014this is an easy consequence of Propositions 18 and 20 from (Lang et al., 2000). See also the polytime operation of forgetting on DNNF, as defined in (Darwiche, 2001a), which applies to MODS, since MODS \u2286 DNNF, and which can be easily modified so it guarantees that the output is in MODS when the input is also in MODS.\n\u2022 SFO.\n\u2013 DNNF, DNF, PI and MODS. Immediate from the fact that each of these languages satisfies FO (see above).\n\u2013 NNF, d-NNF, s-NNF, f-NNF, BDD, OBDD< and CNF. Direct from the fact that \u2203x.\u03a3 \u2261 (\u03a3|x)\u2228 (\u03a3|\u00acx) holds and the fact that any of these fragments satisfies CD and \u2228BC.\n\u2013 OBDD. Direct from the fact that only one OBDD sentence is considered in the transformation and OBDD< satisfies SFO.\n\u2013 d-DNNF, sd-DNNF and FBDD. Let \u03b11 and \u03b12 be two FBDD formulas. Let x be a variable not included in Vars(\u03b11) \u222a Vars(\u03b12). The formula \u03a3 = (x \u2227 \u03b11) \u2228 (\u00acx \u2227 \u03b12) is a FBDD\nformula since decomposability and decision are preserved by this construction. Since \u2203x.\u03a3 is equivalent to \u03b11 \u2228 \u03b12, if FBDD would satisfy SFO, it would satisfy \u2228BC as well, but this is not the case unless P = NP (see below). The same conclusion can be drawn for d-DNNF. Hence, FBDD and d-DNNF do not satisfy SFO unless P = NP. Since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, we obtain that sd-DNNF does not satisfy SFO unless P = NP.\n\u2013 IP. Let us show that the number of prime implicants of \u2203x.\u03a3 can be exponentially greater than the number of prime implicants of \u03a3. Let \u03a3\u2032 be the following DNF formula:\n\u03a3\u2032 =\n\n\nk \u2228\ni=1\nm \u2228\nj=1\n(pi \u2227 qi,j)\n  \u2228 k \u2227\ni=1\n\u00acpi.\n\u03a3\u2032 has (m + 1)k + mk primes implicants (Chandra & Markowsky, 1978). Now, let \u03a3 be the formula:\n\u03a3 =\n\n\nk \u2228\ni=1\nm \u2228\nj=1\n(x \u2227 pi \u2227 qi,j)\n  \u2228 (\u00acx \u2227 k \u2227\ni=1\n\u00acpi).\nSince \u03a3\u2032 can be obtained from \u03a3 by removing in every term of \u03a3 every occurrence of x and \u00acx, \u03a3\u2032 is equivalent to \u2203{x}.\u03a3 (see (Lang et al., 2000)). Now, \u03a3 has only mk + 1 prime implicants; indeed, every term of it is a prime implicant, and the converse holds since every term is maximal w.r.t. logical entailment and every consensus of two terms is inconsistent. This completes the proof.\n\u2022 \u2227C.\n\u2013 NNF, s-NNF, d-NNF, CNF. The property is trivially satisfied by these languages since determinism and smoothness are only concerned with or-nodes. Hence, if \u03b11, . . . , \u03b1n belong to one of these languages, so is \u03b11 \u2227 . . . \u2227 \u03b1n.\n\u2013 BDD. It is well\u2013known that the conjunction of two BDDs \u03b1 and \u03b2 can be easily computed by connecting the 1-sink of \u03b1 to the root of \u03b2 (see proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of \u03b1 and \u03b2. Accordingly, we can repeat this operation n times in time polynomial in the input size.\n\u2013 f-NNF. Direct from the fact that f-NNF does not satisfy \u2227BC. \u2013 FBDD, OBDD, OBDD<, DNF, PI and IP. It is straightforward to convert a clause into an\nequivalent formula in any of these languages in polynomial time. In the proof of Proposition 3.1, we show specific CNF formulas which cannot be turned into an equivalent FBDD (resp. OBDD, OBDD<, DNF, PI and IP) formulas in polynomial space (see Tables 9 and 10). Hence, such conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD<, DNF, PI and IP satisfies \u2227C.\n\u2013 DNNF, d-DNNF and sd-DNNF. Direct from the fact that none of these languages satisfy \u2227BC unless P = NP.\n\u2013 MODS. Let \u03a3 = \u2227n i=1 \u03a3i, where \u03a3i = (xi,1 \u2228 xi,2), i \u2208 1..n. Each \u03a3i has 3 models over Vars(\u03a3i). Since \u03a3 has 3\nn models, it does not have a MODS representation of size polynomial in the input size.\n\u2022 \u2227BC.\n\u2013 NNF, s-NNF, d-NNF, BDD and CNF. Immediate since each of these languages satisfy \u2227C (see above).\n\u2013 DNNF, d-DNNF, sd-DNNF, FBDD and OBDD. Checking whether the conjunction of two OBDD< formulas \u03b11 and \u03b12 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Since OBDD satisfies CO, it cannot satisfy \u2227BC unless P = NP. Since OBDD \u2286 FBDD \u2286 d-DNNF \u2286 DNNF, and d-DNNF and DNNF satisfy CO, none of them can satisfy \u2227BC unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent smoothed d-DNNF formula and since sd-DNNF satisfies CO, it cannot be the case that sd-DNNF satisfy \u2227BC unless P = NP.\n\u2013 OBDD<. Well-known fact (Bryant, 1986). \u2013 f-NNF. Let \u03b11 = \u2227n\u22121 i=0 (x2i \u2228 x2i+1) be a CNF formula and \u03b12 = \u2228n\u22121 i=0 (x \u2032 2i \u2227 x\u20322i+1) a DNF\nformula. \u03b11 has 2 n essential prime implicants and n essential prime implicates (see the proof of Proposition 3.1, Table 9). By duality, \u03b12 has n essential prime implicants and 2 n essential prime implicates. Now, \u03b11 and \u03b12 are two f-NNF formulas. By Lemma A.13, we know that every f-NNF formula \u03b2 can be turned in polynomial time into a CNF formula or a DNF formula. If f-NNF would satisfy \u2227BC, then a f-NNF formula \u03b2 s.t. \u03b2 \u2261 \u03b11\u2227\u03b12 could be computed in time polynomial in the input size. Hence, either a CNF formula equivalent to \u03b11 \u2227 \u03b12 or a DNF formula equivalent to \u03b11 \u2227 \u03b12 could be computed in polytime. But this is impossible since \u03b11 \u2227 \u03b12 has n + 2n essential prime implicates and n \u2217 2n essential prime implicants. Hence every CNF (resp. DNF ) formula equivalent to \u03b11 \u2227 \u03b12 has a size exponential in |\u03b11| + |\u03b12|. Note that in the case where the two f-NNF formulas \u03b11 and \u03b12 into consideration can be turned in polynomial time into either two CNF formulas or two DNF formulas, then a f-NNF formula equivalent to \u03b11 \u2227 \u03b12 can be computed in time polynomial in the input size (this is obvious when two CNF formulas are considered and the next item of the proof shows how this can be achieved when two DNF formulas are considered).\n\u2013 DNF and MODS. If \u03b11 and \u03b12 are sentences in one of these languages L, then we can construct a sentence in L which is equivalent to \u03b11\u2227\u03b12 by simply taking all the conjunctions of one term from \u03b11 and one term from \u03b12, while removing redundant literals in the resulting terms and removing any inconsistent terms in the result. The disjunction of all the resulting terms is a sentence from L equivalent to \u03b11 \u2227 \u03b12 and it has been computed in polynomial time.\n\u2013 PI. Let \u03b11 = \u2228k i=1 pi and \u03b12 = \u2227k i=1 \u2227m j=1(\u00acpi\u2228qi,j). Sentence \u03b11 has one prime implicate\nand \u03b12 has m \u2217 k prime implicates. But \u03b11 \u2227 \u03b12 has (m + 1)k + m \u2217 k prime implicates (Chandra & Markowsky, 1978).\n\u2013 IP. Let IP(\u03b1) be the set of prime implicants for \u03b1. We have IP(\u03b11 \u2227 \u03b12) = max({\u03b21 \u2227 \u03b22 | \u03b21 \u2208 IP(\u03b11), \u03b22 \u2208 IP(\u03b12)}, |=) (up to logical equivalence). See e.g., (dual of) Proposition 40 in (Marquis, 2000).\n\u2022 \u2228C.\n\u2013 NNF, s-NNF, DNNF and DNF. The property is trivially satisfied by these languages since decomposability is only concerned with and-nodes, and since every NNF formula can be turned in polynomial time into an equivalent smoothed NNF formula.\n\u2013 d-NNF and BDD. Direct consequence from the fact that d-NNF and BDD satisfies both \u2227C and \u00acC. Especially, it is well-known that the disjunction of two BDDs \u03b1 and \u03b2 can be easily computed by connecting the 0-sink of \u03b1 to the root of \u03b2 (see the proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of \u03b1 and \u03b2. Accordingly, we can repeat this operation n times in time polynomial in the input size.\n\u2013 f-NNF. Since f-NNF does not satisfy \u2227C but satisfies \u00acC, it cannot satisfy \u2228C (due to De Morgan\u2019s laws).\n\u2013 FBDD, OBDD, OBDD<, CNF, PI, IP and MODS. It is straightforward to convert any term into an equivalent formula from any of the previous languages in polynomial time. In the proof of Proposition 3.1, we show specific DNF formulas which cannot be turned into equivalent FBDD (resp. OBDD, OBDD<, CNF , PI, IP and MODS) formulas in polynomial space (see Tables 9, 10 and 15). Hence, the conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD<, CNF, PI, IP and MODS satisfies \u2228C.\n\u2013 d-DNNF and sd-DNNF. Immediate form the fact that none of these classes satisfies \u2228BC unless P = NP (see below).\n\u2022 \u2228BC.\n\u2013 NNF, d-NNF, DNNF, s-NNF, BDD and DNF. Immediate since each of these languages satisfies \u2228C.\n\u2013 OBDD<. Well-known fact (Bryant, 1986).\n\u2013 OBDD, FBDD, d-DNNF and sd-DNNF. Checking whether the conjunction of two OBDD< formulas \u03b11 and \u03b12 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Now, \u03b11 \u2227 \u03b12 is inconsistent iff \u00ac\u03b11 \u2228 \u00ac\u03b12 is valid. Since OBDD satisfies \u00acC, an OBDD formula equivalent to \u00ac\u03b11 (resp. \u00ac\u03b12) can be computed in time polynomial in |\u03b11| (resp. |\u03b12|). Since OBDD \u2286 FBDD \u2286 d-DNNF, the resulting formulas are also FBDD and d-DNNF formulas. If OBDD (resp. FBDD, d-DNNF) would satisfy \u2228BC, then an OBDD (resp. FBDD, d-DNNF) formula equivalent to \u00ac\u03b11 \u2228 \u00ac\u03b12 could be computed in time polynomial in |\u03b11| + |\u03b12|. But since d-DNNF satisfies VA, this is impossible unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, sd-DNNF cannot satisfy \u2228BC unless P = NP.\n\u2013 f-NNF. Since f-NNF does not satisfy \u2227BC but satisfies \u00acC, it cannot satisfy \u2228BC (due to De Morgan\u2019s laws).\n\u2013 CNF. If \u03b11 and \u03b12 are two CNF sentences, then we can construct a CNF sentence which is equivalent to \u03b11 \u2228 \u03b12 by simply taking all the disjunctions of one clause from \u03b11 and one clause from \u03b12, while removing redundant literals inside the resulting clauses and removing any valid clause in the result. The conjunction of all the resulting clauses is a CNF sentence equivalent to \u03b11 \u2228 \u03b12, and it has been computed in polynomial time. \u2013 PI. Let PI (\u03b1) be the set of prime implicates for sentence \u03b1. We have PI (\u03b11 \u2228 \u03b12) = min({\u03b21 \u2228 \u03b22 | \u03b21 \u2208 PI (\u03b11), \u03b22 \u2208 PI (\u03b12)}, |=). See Proposition 40 in (Marquis, 2000).\n\u2013 IP. Let \u03b11 = \u2227k i=1 pi and \u03b12 = \u2228k i=1 \u2228m j=1(\u00acpi\u2227qi,j). Sentence \u03b11 has one prime implicant\nand \u03b12 has m \u2217 k prime implicants. But \u03b11 \u2228 \u03b12 has (m + 1)k + m \u2217 k prime implicants (Chandra & Markowsky, 1978).\n\u2013 MODS. Let \u03b11 = \u2227n\ni=1 xi and \u03b12 = y. Sentence \u03b11 has 1 model over Vars(\u03b11) and \u03b12 has 1 model over Vars(\u03b12). But \u03b11 \u2228 \u03b12 has 2n + 1 models over Vars(\u03b11) \u222a Vars(\u03b12).\n\u2022 \u00acC.\n\u2013 NNF, s-NNF, f-NNF, BDD, FBDD, OBDD and OBDD<. The property is obviously satisfied by NNF. s-NNF also satisfies \u00acC since every NNF formula can be turned in polynomial time into an equivalent s-NNF formula. f-NNF satisfies \u00acC since applying De Morgan\u2019s laws on a f-NNF formula results in a f-NNF formula. Finally, for all the forms of BDDs, it is sufficient to switch the labels of the sinks to achieve negation (Bryant, 1986).\n\u2013 CNF. Because the negation of a DNF formula is a CNF formula that can be computed in polynomial time, if CNF would satisfy \u00acC, then it would be possible to turn any DNF formula into an equivalent CNF formula in polynomial time (by involution of negation). But we know that it is not possible in polynomial space since CNF 6\u2264 DNF(see the proof of Proposition 3.1). Hence, CNF does not satisfy \u00acC.\n\u2013 DNF. Dual of the proof just above (just replace CNF by DNF and vice-versa).\n\u2013 PI. The formula \u03a3n = \u2227n\u22121 i=0 (x2i \u2228 x2i+1) is in prime implicates form (see the proof of Proposition 3.1, Table 9). This formula has exponentially many prime implicants, that are just the negations of the prime implicates of \u00ac\u03a3n. Since \u00ac\u03a3n has exponentially many prime implicates, it cannot be the case that PI satisfies \u00acC.\n\u2013 IP. We just have to take the dual of the above proof (prime implicates case). The formula\n\u03a3n = \u2228n\u22121 i=0 (x2i\u2227x2i+1) is in prime implicants form. This formula has exponentially many prime implicates, that are just the negations of the prime implicants of \u00ac\u03a3n. Since \u00ac\u03a3n has exponentially many prime implicants, it cannot be the case that IP satisfies \u00acC.\n\u2013 DNNF. The negation of any CNF formula can be computed in polynomial time as a DNF formula, hence as a DNNF formula. If DNNF would satisfy \u00acC, then it would be possible to turn a CNF formula into an equivalent DNNF one (by involution of negation). Because DNNF satisfies CO, we would have P = NP.\n\u2013 d-NNF. Following is a procedure for negating a d-NNF sentence \u2206:9\n\u2217 Traverse nodes in the DAG of \u2206, visiting the children of a node before you visit the node itself. When visiting a node, construct its negation as follows:\n\u00b7 true is the negation of false. \u00b7 false is the negation of true. \u00b7 \u2227(N \u20321, . . . , N \u2032k) is the negation of \u2228(N1, . . . , Nk). Here, N \u2032i is the node representing\nthe negation of Ni.\n\u00b7 \u2228(\u2227(N \u20321,M1), . . . ,\u2227(N \u2032k,Mk)) is the negation of \u2227(N1, . . . , Nk). Here, N \u2032i is the node representing the negation of Ni, and Mi is a node representing the conjunction N1 \u2227 . . . \u2227 Ni\u22121. \u2217 Return the negation of the root of d-NNF \u2206. We can implement the above four steps so that we when we visit a node with k children, we only construct O(k) nodes and O(k) edges.10 Hence, the procedure complexity is\n9. Mark Hopkins pointed us to this procedure. 10. We assume that any or-node (resp. and-node) with less than two children is removed and replaced by its unique\nchild or by false (resp. true) if it has no children. This simplification process is equivalence-preserving and it can be achieved in time linear in the size of the input DAG.\nlinear in the size of the original d-NNF. It is easy to check that the result is equivalent to the negation of the given d-NNF sentence and is also in d-NNF.\n\u2013 sd-DNNF and d-DNNF. Unknown. \u2013 MODS. \u03a3 = \u2227n\ni=1 xi has only one model over \u22c3n i=1{xi} but its negation \u00ac\u03a3 has 2n \u2212 1 models over\n\u22c3n i=1{xi}. Hence MODS cannot satisfy \u00acC. \u2737"}], "references": [{"title": "Planning via model checking: a decision procedure for AR", "author": ["A. Cimmati", "F.G.E. Giunchiglia", "P. Traverso"], "venue": "In Proceedings of the 4 European Conference on Planning", "citeRegEx": "Cimmati et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cimmati et al\\.", "year": 1997}, {"title": "Equivalence of free Boolean graphs can be decided probabilistically in polynomial time", "author": ["M. Blum", "A.K. Chandra", "M.N. Wegman"], "venue": "Information Processing Letters,", "citeRegEx": "Blum et al\\.,? \\Q1980\\E", "shortCiteRegEx": "Blum et al\\.", "year": 1980}, {"title": "An investigation of the laws of thought", "author": ["G. Boole"], "venue": "Walton and Maberley, London.", "citeRegEx": "Boole,? 1854", "shortCiteRegEx": "Boole", "year": 1854}, {"title": "Tractable cover compilations", "author": ["Y. Boufkhad", "E. Gr\u00e9goire", "P. Marquis", "B. Mazure", "L. S\u00e4\u0131s"], "venue": "In Proc. of the 15 International Joint Conference on Artificial Intelligence", "citeRegEx": "Boufkhad et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Boufkhad et al\\.", "year": 1997}, {"title": "Graph-based algorithms for Boolean function manipulation", "author": ["R.E. Bryant"], "venue": "IEEE Transactions on Computers, C-35, 677\u2013691.", "citeRegEx": "Bryant,? 1986", "shortCiteRegEx": "Bryant", "year": 1986}, {"title": "Symbolic Boolean manipulation with ordered binary decision diagrams", "author": ["R.E. Bryant"], "venue": "ACM Computing Surveys, 24 (3), 293\u2013318.", "citeRegEx": "Bryant,? 1992", "shortCiteRegEx": "Bryant", "year": 1992}, {"title": "A survey on knowledge compilation", "author": ["M. Cadoli", "F. Donini"], "venue": "AI Communications,", "citeRegEx": "Cadoli and Donini,? \\Q1997\\E", "shortCiteRegEx": "Cadoli and Donini", "year": 1997}, {"title": "Comparing space efficiency of propositional knowledge representation formalisms", "author": ["M. Cadoli", "F. Donini", "P. Liberatore", "M. Schaerf"], "venue": "In Proc. of the 5 International Conference on Knowledge Representation and Reasoning", "citeRegEx": "Cadoli et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Cadoli et al\\.", "year": 1996}, {"title": "On the number of prime implicants", "author": ["A. Chandra", "G. Markowsky"], "venue": "Discrete Mathematics,", "citeRegEx": "Chandra and Markowsky,? \\Q1978\\E", "shortCiteRegEx": "Chandra and Markowsky", "year": 1978}, {"title": "Compiling knowledge into decomposable negation normal form", "author": ["A. Darwiche"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI\u201999), pp. 284\u2013289. Morgan Kaufmann, California.", "citeRegEx": "Darwiche,? 1999", "shortCiteRegEx": "Darwiche", "year": 1999}, {"title": "Decomposable negation normal form", "author": ["A. Darwiche"], "venue": "Journal of the ACM, 48 (4), 608\u2013647.", "citeRegEx": "Darwiche,? 2001a", "shortCiteRegEx": "Darwiche", "year": 2001}, {"title": "On the tractability of counting theory models and its application to belief revision and truth maintenance", "author": ["A. Darwiche"], "venue": "Journal of Applied Non-Classical Logics, 11 (1-2), 11\u201334.", "citeRegEx": "Darwiche,? 2001b", "shortCiteRegEx": "Darwiche", "year": 2001}, {"title": "Testing equivalence probabilistically", "author": ["A. Darwiche", "J. Huang"], "venue": "Tech. rep. D\u2013123,", "citeRegEx": "Darwiche and Huang,? \\Q2002\\E", "shortCiteRegEx": "Darwiche and Huang", "year": 2002}, {"title": "An improved incremental algorithm for generating prime implicates", "author": ["J. de Kleer"], "venue": "In Proc. of the 10 National Conference on Artificial Intelligence", "citeRegEx": "Kleer,? \\Q1992\\E", "shortCiteRegEx": "Kleer", "year": 1992}, {"title": "Directional resolution: the Davis-Putnam procedure, revisited", "author": ["R. Dechter", "I. Rish"], "venue": "In Proceedings of the Fourth International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Dechter and Rish,? \\Q1994\\E", "shortCiteRegEx": "Dechter and Rish", "year": 1994}, {"title": "Tractable databases: How to make propositional unit resolution complete through compilation", "author": ["A. del Val"], "venue": "In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Val,? \\Q1994\\E", "shortCiteRegEx": "Val", "year": 1994}, {"title": "Efficient analysis and manipulation of obdds can be extended to fbdds", "author": ["J. Gergov", "C. Meinel"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "Gergov and Meinel,? \\Q1994\\E", "shortCiteRegEx": "Gergov and Meinel", "year": 1994}, {"title": "On the complexity of analysis and manipulation of Boolean functions in terms of decision diagrams", "author": ["J. Gergov", "C. Meinel"], "venue": "Information Processing Letters,", "citeRegEx": "Gergov and Meinel,? \\Q1994\\E", "shortCiteRegEx": "Gergov and Meinel", "year": 1994}, {"title": "The comparative linguistics of knowledge representation", "author": ["G. Gogic", "H. Kautz", "C. Papadimitriou", "B. Selman"], "venue": "In Proc. of the 14 International Joint Conference on Artificial Intelligence", "citeRegEx": "Gogic et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Gogic et al\\.", "year": 1995}, {"title": "Propositional belief base update and minimal change", "author": ["A. Herzig", "O. Rifi"], "venue": "Artificial Intelligence,", "citeRegEx": "Herzig and Rifi,? \\Q1999\\E", "shortCiteRegEx": "Herzig and Rifi", "year": 1999}, {"title": "Some connections between non-uniform and uniform complexity classes", "author": ["R. Karp", "R. Lipton"], "venue": "In Proc. of the 12 ACM Symposium on Theory of Computing", "citeRegEx": "Karp and Lipton,? \\Q1980\\E", "shortCiteRegEx": "Karp and Lipton", "year": 1980}, {"title": "Learning to reason", "author": ["R. Khardon", "D. Roth"], "venue": "Journal of the ACM,", "citeRegEx": "Khardon and Roth,? \\Q1997\\E", "shortCiteRegEx": "Khardon and Roth", "year": 1997}, {"title": "Propositional independence\u2014Part I: formula\u2013variable independence and forgetting", "author": ["J. Lang", "P. Liberatore", "P. Marquis"], "venue": null, "citeRegEx": "Lang et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Lang et al\\.", "year": 2000}, {"title": "A new method to compute prime and essential prime implicants of boolean functions", "author": ["J.C. Madre", "O. Coudert"], "venue": "In Advanced research in VLSI and parallel systems, Proceedings of the Brown/MIT conference,", "citeRegEx": "Madre and Coudert,? \\Q1992\\E", "shortCiteRegEx": "Madre and Coudert", "year": 1992}, {"title": "Consequence finding algorithms, Vol", "author": ["P. Marquis"], "venue": "5 of Handbook of Defeasible Reasoning and Uncertainty Management Systems: Algorithms for Uncertain and Defeasible Reasoning. Kluwer Academic Publishers.", "citeRegEx": "Marquis,? 2000", "shortCiteRegEx": "Marquis", "year": 2000}, {"title": "Knowledge compilation using theory prime implicates", "author": ["P. Marquis"], "venue": "Proc. International Joint Conference on Artificial Intelligence (IJCAI\u201995), pp. 837\u2013843. Morgan Kaufmann Publishers, Inc., San Mateo, California.", "citeRegEx": "Marquis,? 1995", "shortCiteRegEx": "Marquis", "year": 1995}, {"title": "Algorithms and Data Structures in VLSI Design: OBDD Foundations and Applications", "author": ["C. Meinel", "T. Theobald"], "venue": null, "citeRegEx": "Meinel and Theobald,? \\Q1998\\E", "shortCiteRegEx": "Meinel and Theobald", "year": 1998}, {"title": "Computational complexity", "author": ["C. Papadimitriou"], "venue": "Addison\u2013Wesley.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "A way to simplify truth functions", "author": ["W. Quine"], "venue": "American Mathematical Monthly, 52, 627\u2013631.", "citeRegEx": "Quine,? 1955", "shortCiteRegEx": "Quine", "year": 1955}, {"title": "On cores and prime implicants of truth functions", "author": ["W. Quine"], "venue": "American Mathematical Monthly, 66, 755\u2013760.", "citeRegEx": "Quine,? 1959", "shortCiteRegEx": "Quine", "year": 1959}, {"title": "Foundations of assumption-based truth maintenance systems: Preliminary report", "author": ["R. Reiter", "J. de Kleer"], "venue": "In Proceedings of the Fifth National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Reiter and Kleer,? \\Q1987\\E", "shortCiteRegEx": "Reiter and Kleer", "year": 1987}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Artificial Intelligence, 82 (1-2), 273\u2013302. Schrag, R. (1996). Compilation for critically constrained knowledge bases. In Proc. of the 13 National Conference on Artificial Intelligence (AAAI\u201996), pp. 510\u2013515, Portland, Oregan.", "citeRegEx": "Roth,? 1996", "shortCiteRegEx": "Roth", "year": 1996}, {"title": "Knowledge compilation and theory approximation", "author": ["B. Selman", "H. Kautz"], "venue": "Journal of the Association for Computing Machinery,", "citeRegEx": "Selman and Kautz,? \\Q1996\\E", "shortCiteRegEx": "Selman and Kautz", "year": 1996}, {"title": "The complexity of boolean functions", "author": ["I. Wegener"], "venue": "Wiley-Teubner, Stuttgart.", "citeRegEx": "Wegener,? 1987", "shortCiteRegEx": "Wegener", "year": 1987}], "referenceMentions": [{"referenceID": 9, "context": "Introduction Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Gr\u00e9goire, Marquis, Mazure, & S\u00e4\u0131s, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987).", "startOffset": 172, "endOffset": 397}, {"referenceID": 25, "context": "Introduction Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Gr\u00e9goire, Marquis, Mazure, & S\u00e4\u0131s, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987).", "startOffset": 172, "endOffset": 397}, {"referenceID": 27, "context": "not qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its subsets do.", "startOffset": 57, "endOffset": 78}, {"referenceID": 11, "context": "\u2022 Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each two disjuncts of C are logically contradictory.", "startOffset": 14, "endOffset": 31}, {"referenceID": 11, "context": "\u2022 Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each disjunct of C mentions the same variables.", "startOffset": 13, "endOffset": 30}, {"referenceID": 4, "context": "The following decision property comes from the literature on binary decision diagrams (Bryant, 1986).", "startOffset": 86, "endOffset": 100}, {"referenceID": 4, "context": "The BDD language corresponds to binary decision diagrams (BDDs), as known in the formal verification literature (Bryant, 1986).", "startOffset": 112, "endOffset": 126}, {"referenceID": 4, "context": "The OBDD language corresponds to the well\u2013known ordered binary decision diagrams (OBDDs) (Bryant, 1986).", "startOffset": 89, "endOffset": 103}, {"referenceID": 11, "context": "Others, such as DNNF (Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new.", "startOffset": 56, "endOffset": 73}, {"referenceID": 4, "context": "The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for some of these algorithms and to the proofs of theorems in Appendix A for others.", "startOffset": 37, "endOffset": 81}, {"referenceID": 9, "context": "4 (Conditioning) (Darwiche, 1999) Let \u03a3 be a propositional formula, and let \u03b3 be a consistent term.", "startOffset": 17, "endOffset": 33}, {"referenceID": 2, "context": "Another critical transformation we shall consider is that of forgetting (also referred to as marginalization, or elimination of middle terms (Boole, 1854)):", "startOffset": 141, "endOffset": 154}, {"referenceID": 10, "context": "In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information required to compute the conflicts and the diagnoses of a system (Darwiche, 2001a).", "startOffset": 189, "endOffset": 206}, {"referenceID": 4, "context": "This closure actually plays an important role in compiling propositional theories into OBDD< and is the basis of state-of-the-art compilers for this purpose (Bryant, 1986).", "startOffset": 157, "endOffset": 171}, {"referenceID": 10, "context": "Proof: To test whether sentence \u03a3 entails non-valid clause \u03b1, \u03a3 |= \u03b1, it suffices to test whether \u03a3 | \u00ac\u03b1 is inconsistent (Darwiche, 2001a).", "startOffset": 121, "endOffset": 138}, {"referenceID": 18, "context": "Table 9: We can prove both that DNF 6\u2264 PI and CNF 6\u2264 IP (this slightly generalizes the results DNF 6\u2264 CNF and CNF 6\u2264 DNF given in (Gogic et al., 1995)).", "startOffset": 130, "endOffset": 150}, {"referenceID": 29, "context": "Since Quine\u2019s early work (Quine, 1959), we know that the number of essential prime implicants (resp.", "startOffset": 25, "endOffset": 38}, {"referenceID": 24, "context": ", (dual of) Proposition 40 in (Marquis, 2000)) which states that IP(\u03b1\u2227\u03b2) = max({PI\u03b1\u2227PI\u03b2 | PI\u03b1 \u2208 IP(\u03b1), PI\u03b2 \u2208 IP(\u03b2)}, |=) (up to logical equivalence).", "startOffset": 30, "endOffset": 45}, {"referenceID": 28, "context": "The correctness of (the dual of) Quine\u2019s consensus algorithm for computing prime implicants (Quine, 1955) ensures it, since no clause of \u03a3n is subsumed by another clause and no consensi can be performed since there are no negated variables.", "startOffset": 92, "endOffset": 105}, {"referenceID": 4, "context": "Table 10: The parity function On = \u2295n\u22121 i=0 xi has linear size OBDD< representations (Bryant, 1986) but only exponential size CNF and DNF representations.", "startOffset": 85, "endOffset": 99}, {"referenceID": 11, "context": "Table 11: It is shown in (Darwiche, 2001b) that there is a sentence in d-DNNF which only has exponential FBDD representations.", "startOffset": 25, "endOffset": 42}, {"referenceID": 33, "context": "Table 13: In (Wegener, 1987) (Theorem 6.", "startOffset": 13, "endOffset": 28}, {"referenceID": 33, "context": "Now, it is well-known that the old good Quine-McCluskey\u2019s algorithm for generating prime implicants from a MODS representation of a propositional formula \u03a3 runs in time polynomial in the number of models of \u03a3 (Wegener, 1987).", "startOffset": 209, "endOffset": 224}, {"referenceID": 10, "context": "Table 19:Because DNNF satisfies CE (Darwiche, 2001a), CE implies CO and MODS \u2286 DNF \u2286 DNNF, IP\u2286 DNF and sd-DNNF \u2286 d-DNNF \u2286 DNNF, we obtain the table.", "startOffset": 35, "endOffset": 52}, {"referenceID": 5, "context": "It is well-known that FBDD satisfies CO, VA and CT, and that OBDD< satisfies (in addition) EQ (Gergov & Meinel, 1994a; Bryant, 1992).", "startOffset": 94, "endOffset": 132}, {"referenceID": 31, "context": "conjunctions of clauses containing at most two literals and only positive literals) is #P-complete (Roth, 1996).", "startOffset": 99, "endOffset": 111}, {"referenceID": 24, "context": "Such formulas can easily be turned into prime implicates form in polynomial time (Marquis, 2000), hence PI does not satisfy CT.", "startOffset": 81, "endOffset": 96}, {"referenceID": 11, "context": "Table 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA.", "startOffset": 36, "endOffset": 53}, {"referenceID": 4, "context": "It is well\u2013known that BDD satisfies CD\u2014the conditioning operation on binary decision diagrams is known as the restrict operation (Bryant, 1986).", "startOffset": 129, "endOffset": 143}, {"referenceID": 24, "context": "The prime implicates of \u03a3 \u2227 \u03b3 can be computed in polytime when \u03a3 is in prime implicates form and \u03b3 is a term (see Proposition 36 in (Marquis, 2000)).", "startOffset": 132, "endOffset": 147}, {"referenceID": 10, "context": "It is known that DNNF satisfies FO (Darwiche, 2001a).", "startOffset": 35, "endOffset": 52}, {"referenceID": 22, "context": "It is also known that DNF satisfies FO (Lang et al., 2000).", "startOffset": 39, "endOffset": 58}, {"referenceID": 24, "context": "\u03a3 are exactly the prime implicates of \u03a3 that do not contain any variable from X (see Proposition 55 in (Marquis, 2000)).", "startOffset": 103, "endOffset": 118}, {"referenceID": 22, "context": "\u03a3\u2014this is an easy consequence of Propositions 18 and 20 from (Lang et al., 2000).", "startOffset": 61, "endOffset": 80}, {"referenceID": 10, "context": "See also the polytime operation of forgetting on DNNF, as defined in (Darwiche, 2001a), which applies to MODS, since MODS \u2286 DNNF, and which can be easily modified so it guarantees that the output is in MODS when the input is also in MODS.", "startOffset": 69, "endOffset": 86}, {"referenceID": 22, "context": "\u03a3 (see (Lang et al., 2000)).", "startOffset": 7, "endOffset": 26}, {"referenceID": 4, "context": "Well-known fact (Bryant, 1986).", "startOffset": 16, "endOffset": 30}, {"referenceID": 24, "context": ", (dual of) Proposition 40 in (Marquis, 2000).", "startOffset": 30, "endOffset": 45}, {"referenceID": 4, "context": "Well-known fact (Bryant, 1986).", "startOffset": 16, "endOffset": 30}, {"referenceID": 24, "context": "See Proposition 40 in (Marquis, 2000).", "startOffset": 22, "endOffset": 37}, {"referenceID": 4, "context": "Finally, for all the forms of BDDs, it is sufficient to switch the labels of the sinks to achieve negation (Bryant, 1986).", "startOffset": 107, "endOffset": 121}], "year": 2011, "abstractText": "We propose a perspective on knowledge compilation which calls for analyzing different compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime. We then provide a knowledge compilation map, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and queries. We argue that such analysis is necessary for placing new compilation approaches within the context of existing ones. We also go beyond classical, flat target compilation languages based on CNF and DNF, and consider a richer, nested class based on directed acyclic graphs (such as OBDDs), which we show to include a relatively large number of target compilation languages.", "creator": "dvips(k) 5.86 Copyright 1999 Radical Eye Software"}}}