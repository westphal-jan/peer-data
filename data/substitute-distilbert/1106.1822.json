{"id": "1106.1822", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jun-2011", "title": "Efficient Solution Algorithms for Factored MDPs", "abstract": "this paper addresses the problem of planning under symmetry in large markov decision processes ( mdps ). factored mdps represent a complex state space identifying state variables and the transition model using a dynamic bayesian network. this representation problem determines an exponential reduction in the parameter size of structured mdps, but the complexity of exact software algorithms for such mdps can grow exponentially in some representation lifetime. in this paper, we present two approximate solution algorithms that exploit structure in factored mdps. both use an approximate value function represented as a linear combination of basis functions, where each basis function involves only a small subset of multiple domain variables. a key contribution of this paper is shown it shows how the basic operations of both algorithms can be performed efficiently in closed form, by exploiting maximum additive and context - specific structure in a factored mdp. a central element of our efforts is a novel linear program decomposition technique, analogous to variable elimination in robust networks, which reduces an exponentially large lp after a provably equivalent, polynomial - sized one. one algorithm uses explicit design programming, and the second approximate dynamic programming. our dynamic programming algorithm is novel in that it uses an additional mapping on r - norm, a technique that more directly minimizes the terms that behave in error bounds for approximate control algorithms. we provide the results on modeling with sparse 10 ^ 40 states, demonstrating a promising formulation of the scalability of our approach, and compare our algorithm to new optimal state - of - the - art approach, showing, in some states, difficulty progression in computation algorithm.", "histories": [["v1", "Thu, 9 Jun 2011 13:58:37 GMT  (892kb)", "http://arxiv.org/abs/1106.1822v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["c guestrin", "d koller", "r parr", "s venkataraman"], "accepted": false, "id": "1106.1822"}, "pdf": {"name": "1106.1822.pdf", "metadata": {"source": "CRF", "title": "Efficient Solution Algorithms for Factored MDPs", "authors": ["Carlos Guestrin", "Daphne Koller", "Ronald Parr", "Shobha Venkataraman"], "emails": ["guestrin@cs.stanford.edu", "koller@cs.stanford.edu", "parr@cs.duke.edu", "shobha@cs.cmu.edu"], "sections": [{"heading": "1. Introduction", "text": "Over the last few years, Markov Decision Processes (MDPs) have been used as the basic semantics for optimal planning for decision theoretic agents in stochastic environments. In the MDP framework, the system is modeled via a set of states which evolve stochastically. The main problem with this representation is that, in virtually any real-life domain, the state space is quite large. However, many large MDPs have significant internal structure, and can be modeled compactly if the structure is exploited in the representation.\nFactored MDPs (Boutilier, Dearden, & Goldszmidt, 2000) are one approach to representing large, structured MDPs compactly. In this framework, a state is implicitly described by an assignment to some set of state variables. A dynamic Bayesian network (DBN) (Dean & Kanazawa, 1989) can then allow a compact representation of the transition model, by exploiting the fact that the transition of a variable often depends only on a small number\nc\u00a92003 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nof other variables. Furthermore, the momentary rewards can often also be decomposed as a sum of rewards related to individual variables or small clusters of variables.\nThere are two main types of structure that can simultaneously be exploited in factored MDPs: additive and context-specific structure. Additive structure captures the fact that typical large-scale systems can often be decomposed into a combination of locally interacting components. For example, consider the management of a large factory with many production cells. Of course, in the long run, if a cell positioned early in the production line generates faulty parts, then the whole factory may be affected. However, the quality of the parts a cell generates depends directly only on the state of this cell and the quality of the parts it receives from neighboring cells. Such additive structure can also be present in the reward function. For example, the cost of running the factory depends, among other things, on the sum of the costs of maintaining each local cell.\nContext-specific structure encodes a different type of locality of influence: Although a part of a large system may, in general, be influenced by the state of every other part of this system, at any given point in time only a small number of parts may influence it directly. In our factory example, a cell responsible for anodization may receive parts directly from any other cell in the factory. However, a work order for a cylindrical part may restrict this dependency only to cells that have a lathe. Thus, in the context of producing cylindrical parts, the quality of the anodized parts depends directly only on the state of cells with a lathe.\nEven when a large MDP can be represented compactly, for example, by using a factored representation, solving it exactly may still be intractable: Typical exact MDP solution algorithms require the manipulation of a value function, whose representation is linear in the number of states, which is exponential in the number of state variables. One approach is to approximate the solution using an approximate value function with a compact representation. A common choice is the use of linear value functions as an approximation \u2014 value functions that are a linear combination of potentially non-linear basis functions (Bellman, Kalaba, & Kotkin, 1963; Sutton, 1988; Tsitsiklis & Van Roy, 1996b). Our work builds on the ideas of Koller and Parr (1999, 2000), by using factored (linear) value functions, where each basis function is restricted to some small subset of the domain variables.\nThis paper presents two new algorithms for computing linear value function approximations for factored MDPs: one that uses approximate dynamic programming and another that uses approximate linear programming. Both algorithms are based on the use of factored linear value functions, a highly expressive function approximation method. This representation allows the algorithms to take advantage of both additive and context-specific structure, in order to produce high-quality approximate solutions very efficiently. The capability to exploit both types of structure distinguishes these algorithms differ from earlier approaches (Boutilier et al., 2000), which only exploit context-specific structure. We provide a more detailed discussion of the differences in Section 10.\nWe show that, for a factored MDP and factored value functions, various critical operations for our planning algorithms can be implemented in closed form without necessarily enumerating the entire state space. In particular, both our new algorithms build upon a novel linear programming decomposition technique. This technique reduces structured LPs with exponentially many constraints to equivalent, polynomially-sized ones. This decomposition follows a procedure analogous to variable elimination that applies both to additively\nstructured value functions (Bertele & Brioschi, 1972) and to value functions that also exploit context-specific structure (Zhang & Poole, 1999). Using these basic operations, our planning algorithms can be implemented efficiently, even though the size of the state space grows exponentially in the number of variables.\nOur first method is based on the approximate linear programming algorithm (Schweitzer & Seidmann, 1985). This algorithm generates a linear, approximate value function by solving a single linear program. Unfortunately, the number of constraints in the LP proposed by Schweitzer and Seidmann grows exponentially in the number of variables. Using our LP decomposition technique, we exploit structure in factored MDPs to represent exactly the same optimization problem with exponentially fewer constraints.\nIn terms of approximate dynamic programming, this paper makes a twofold contribution. First, we provide a new approach for approximately solving MDPs using a linear value function. Previous approaches to linear function approximation typically have utilized a least squares (L2-norm) approximation to the value function. Least squares approximations are incompatible with most convergence analyses for MDPs, which are based on max-norm. We provide the first MDP solution algorithms \u2014 both value iteration and policy iteration \u2014 that use a linear max-norm projection to approximate the value function, thereby directly optimizing the quantity that appears in our provided error bounds. Second, we show how to exploit the structure of the problem to apply this technique to factored MDPs, by again leveraging on our LP decomposition technique.\nAlthough approximate dynamic programming currently possesses stronger theoretical guarantees, our experimental results suggest that approximate linear programming is a good alternative. Whereas the former tends to generate better policies for the same set of basis functions, due to the simplicity and computational advantages of approximate linear programming, we can add more basis functions, obtaining a better policy and still requiring less computation than the approximate dynamic programming approach.\nFinally, we present experimental results comparing our approach to the work of Boutilier et al. (2000), illustrating some of the tradeoffs between the two methods. In particular, for problems with significant context-specific structure in the value function, their approach can be faster due to their efficient handling of their value function representation. However, there are cases with significant context-specific structure in the problem, rather than in the value function, in which their algorithm requires an exponentially large value function representation. In such classes of problems, we demonstrate that by using a value function that exploits both additive and context-specific structure, our algorithm can obtain a polynomial-time near-optimal approximation of the true value function.\nThis paper starts with a presentation of factored MDPs and approximate solution algorithms for MDPs. In Section 4, we describe the basic operations used in our algorithms, including our LP decomposition technique. In Section 5, we present the first of our two algorithms: the approximate linear programming algorithm for factored MDPs. The second algorithm, approximate policy iteration with max-norm projection, is presented in Section 6. Section 7 describes an approach for efficiently computing bounds on policy quality based on the Bellman error. Section 8 shows how to extend our methods to deal with context-specific structure. Our paper concludes with an empirical evaluation in Section 9 and a discussion of related work in Section 10.\nThis paper is a greatly expanded version of work that was published before in Guestrin et al. (2001a), and some of the work presented in Guestrin et al. (2001b, 2002)."}, {"heading": "2. Factored Markov Decision Processes", "text": "A Markov decision process (MDP) is a mathematical framework for sequential decision problems in stochastic domains. It thus provides an underlying semantics for the task of planning under uncertainty. We begin with a concise overview of the MDP framework, and then describe the representation of factored MDPs."}, {"heading": "2.1 Markov Decision Processes", "text": "We briefly review the MDP framework, referring the reader to the books by Bertsekas and Tsitsiklis (1996) or Puterman (1994) for a more in-depth review. AMarkov Decision Process (MDP) is defined as a 4-tuple (X, A,R, P ) where: X is a finite set of |X| = N states; A is a finite set of actions; R is a reward function R : X\u00d7A 7\u2192 R, such that R(x, a) represents the reward obtained by the agent in state x after taking action a; and P is a Markovian transition model where P (x\u2032 | x, a) represents the probability of going from state x to state x\u2032 with action a. We assume that the rewards are bounded, that is, there exists Rmax such that Rmax \u2265 |R(x, a)| ,\u2200x, a.\nExample 2.1 Consider the problem of optimizing the behavior of a system administrator (SysAdmin) maintaining a network of m computers. In this network, each machine is connected to some subset of the other machines. Various possible network topologies can be defined in this manner (see Figure 1 for some examples). In one simple network, we might connect the machines in a ring, with machine i connected to machines i+ 1 and i\u2212 1. (In this example, we assume addition and subtraction are performed modulo m.)\nEach machine is associated with a binary random variable Xi, representing whether it is working or has failed. At every time step, the SysAdmin receives a certain amount of money (reward) for each working machine. The job of the SysAdmin is to decide which machine to reboot; thus, there are m+1 possible actions at each time step: reboot one of the m machines or do nothing (only one machine can be rebooted per time step). If a machine is rebooted, it will be working with high probability at the next time step. Every machine has a small probability of failing at each time step. However, if a neighboring machine fails, this probability increases dramatically. These failure probabilities define the transition model P (x\u2032 | x, a), where x is a particular assignment describing which machines are working or have failed in the current time step, a is the SysAdmin\u2019s choice of machine to reboot and x\u2032 is the resulting state in the next time step.\nWe assume that the MDP has an infinite horizon and that future rewards are discounted exponentially with a discount factor \u03b3 \u2208 [0, 1). A stationary policy \u03c0 for an MDP is a mapping \u03c0 : X 7\u2192 A, where \u03c0(x) is the action the agent takes at state x. In the computer network problem, for each possible configuration of working and failing machines, the policy would tell the SysAdmin which machine to reboot. Each policy is associated with a value function V\u03c0 \u2208 R\nN , where V\u03c0(x) is the discounted cumulative value that the agent gets if it starts at state x and follows policy \u03c0. More precisely, the value V\u03c0 of a state x under\npolicy \u03c0 is given by:\nV\u03c0(x) = E\u03c0\n[ \u221e\u2211\nt=0\n\u03b3tR ( X(t), \u03c0(X(t)) )\u2223\u2223\u2223\u2223\u2223X (0) = x ] ,\nwhere X(t) is a random variable representing the state of the system after t steps. In our running example, the value function represents how much money the SysAdmin expects to collect if she starts acting according to \u03c0 when the network is at state x. The value function for a fixed policy is the fixed point of a set of linear equations that define the value of a state in terms of the value of its possible successor states. More formally, we define:\nDefinition 2.2 The DP operator, T\u03c0, for a stationary policy \u03c0 is:\nT\u03c0V(x) = R(x, \u03c0(x)) + \u03b3 \u2211\nx\u2032\nP (x\u2032 | x, \u03c0(x))V(x\u2032).\nThe value function of policy \u03c0, V\u03c0, is the fixed point of the T\u03c0 operator: V\u03c0 = T\u03c0V\u03c0.\nThe optimal value function V\u2217 describes the optimal value the agent can achieve for each starting state. V\u2217 is also defined by a set of non-linear equations. In this case, the value of a state must be the maximal expected value achievable by any policy starting at that state. More precisely, we define:\nDefinition 2.3 The Bellman operator, T \u2217, is:\nT \u2217V(x) = max a\n[R(x, a) + \u03b3 \u2211\nx\u2032\nP (x\u2032 | x, a)V(x\u2032)].\nThe optimal value function V\u2217 is the fixed point of T \u2217: V\u2217 = T \u2217V\u2217.\nFor any value function V, we can define the policy obtained by acting greedily relative to V. In other words, at each state, the agent takes the action that maximizes the one-step\nutility, assuming that V represents our long-term utility achieved at the next state. More precisely, we define:\nGreedy(V)(x) = argmax a\n[R(x, a) + \u03b3 \u2211\nx\u2032\nP (x\u2032 | x, a)V(x\u2032)]. (1)\nThe greedy policy relative to the optimal value function V\u2217 is the optimal policy \u03c0\u2217 = Greedy(V\u2217)."}, {"heading": "2.2 Factored MDPs", "text": "Factored MDPs are a representation language that allows us to exploit problem structure to represent exponentially large MDPs very compactly. The idea of representing a large MDP using a factored model was first proposed by Boutilier et al. (1995).\nIn a factored MDP, the set of states is described via a set of random variables X = {X1, . . . ,Xn}, where each Xi takes on values in some finite domain Dom(Xi). A state x defines a value xi \u2208 Dom(Xi) for each variable Xi. In general, we use upper case letters (e.g., X) to denote random variables, and lower case (e.g., x) to denote their values. We use boldface to denote vectors of variables (e.g., X) or their values (x). For an instantiation y \u2208 Dom(Y) and a subset of these variables Z \u2282 Y, we use y[Z] to denote the value of the variables Z in the instantiation y.\nIn a factored MDP, we define a state transition model \u03c4 using a dynamic Bayesian network (DBN) (Dean & Kanazawa, 1989). Let Xi denote the variable Xi at the current time and X \u2032i, the same variable at the next step. The transition graph of a DBN is a two-layer directed acyclic graph G\u03c4 whose nodes are {X1, . . . ,Xn,X \u2032 1, . . . ,X \u2032 n}. We denote the parents of X \u2032i in the graph by Parents\u03c4 (X \u2032 i). For simplicity of exposition, we assume that Parents\u03c4 (X \u2032 i) \u2286 X; thus, all arcs in the DBN are between variables in consecutive time slices. (This assumption is used for expository purposes only; intra-time slice arcs are handled by a small modification presented in Section 4.1.) Each node X \u2032i is associated with a conditional probability distribution (CPD) P\u03c4 (X \u2032 i | Parents\u03c4 (X \u2032 i)). The transition probability P\u03c4 (x \u2032 | x) is then defined to be:\nP\u03c4 (x \u2032 | x) =\n\u220f\ni\nP\u03c4 (x \u2032 i | ui) ,\nwhere ui is the value in x of the variables in Parents\u03c4 (X \u2032 i).\nExample 2.4 Consider an instance of the SysAdmin problem with four computers, labelled M1, . . . ,M4, in an unidirectional ring topology as shown in Figure 2(a). Our first task in modeling this problem as a factored MDP is to define the state space X. Each machine is associated with a binary random variable Xi, representing whether it is working or has failed. Thus, our state space is represented by four random variables: {X1,X2,X3,X4}. The next task is to define the transition model, represented as a DBN. The parents of the next time step variables X \u2032i depend on the network topology. Specifically, the probability that machine i will fail at the next time step depends on whether it is working at the current time step and on the status of its direct neighbors (parents in the topology) in the network at the current time step. As shown in Figure 2(b), the parents of X \u2032i in this example are Xi and Xi\u22121. The CPD of X \u2032 i is such that if Xi = false, then X \u2032 i = false with high probability;\nthat is, failures tend to persist. If Xi = true, then X \u2032 i is a noisy or of its other parents (in the unidirectional ring topology X \u2032i has only one other parent Xi\u22121); that is, a failure in any of its neighbors can independently cause machine i to fail.\nWe have described how to represent factored the Markovian transition dynamics arising from an MDP as a DBN, but we have not directly addressed the representation of actions. Generally, we can define the transition dynamics of an MDP by defining a separate DBN model \u03c4a = \u3008Ga, Pa\u3009 for each action a.\nExample 2.5 In our system administrator example, we have an action ai for rebooting each one of the machines, and a default action d for doing nothing. The transition model described above corresponds to the \u201cdo nothing\u201d action. The transition model for ai is different from d only in the transition model for the variable X \u2032i, which is now X \u2032 i = true with probability one, regardless of the status of the neighboring machines. Figure 2(c) shows the actual CPD for P (X \u2032i = Working | Xi,Xi\u22121, A), with one entry for each assignment to the state variables Xi and Xi\u22121, and to the action A.\nTo fully specify an MDP, we also need to provide a compact representation of the reward function. We assume that the reward function is factored additively into a set of localized reward functions, each of which only depends on a small set of variables. In our example, we might have a reward function associated with each machine i, which depends on Xi. That is, the SysAdmin is paid on a per-machine basis: at every time step, she receives money for machine i only if it is working. We can formalize this concept of localized functions:\nDefinition 2.6 A function f has a scope Scope[f ] = C \u2286 X if f : Dom(C) 7\u2192 R.\nIf f has scope Y and Y \u2282 Z, we use f(z) as shorthand for f(y) where y is the part of the instantiation z that corresponds to variables in Y.\nWe can now characterize the concept of local rewards. Let Ra1, . . . , R a r be a set of functions, where the scope of each Rai is restricted to variable cluster U a i \u2282 {X1, . . . ,Xn}. The reward for taking action a at state x is defined to be Ra(x) = \u2211r\ni=1R a i (U a i ) \u2208 R. In\nour example, we have a reward function Ri associated with each machine i, which depends only Xi, and does not depend on the action choice. These local rewards are represented by the diamonds in Figure 2(b), in the usual notation for influence diagrams (Howard & Matheson, 1984)."}, {"heading": "3. Approximate Solution Algorithms", "text": "There are several algorithms to compute the optimal policy in an MDP. The three most commonly used are value iteration, policy iteration, and linear programming. A key component in all three algorithms is the computation of value functions, as defined in Section 2.1. Recall that a value function defines a value for each state x in the state space. With an explicit representation of the value function as a vector of values for the different states, the solution algorithms all can be implemented as a series of simple algebraic steps. Thus, in this case, all three can be implemented very efficiently.\nUnfortunately, in the case of factored MDPs, the state space is exponential in the number of variables in the domain. In the SysAdmin problem, for example, the state x of the system is an assignment describing which machines are working or have failed; that is, a state x is an assignment to each random variable Xi. Thus, the number of states is exponential in the number m of machines in the network (|X| = N = 2m). Hence, even representing an explicit value function in problems with more than about ten machines is infeasible. One might be tempted to believe that factored transition dynamics and rewards would result in a factored value function, which can thereby be represented compactly. Unfortunately, even in trivial factored MDPs, there is no guarantee that structure in the model is preserved in the value function (Koller & Parr, 1999).\nIn this section, we discuss the use of an approximate value function, that admits a compact representation. We also describe approximate versions of these exact algorithms, that use approximate value functions. Our description in this section is somewhat abstract, and does not specify how the basic operations required by the algorithms can be performed explicitly. In later sections, we elaborate on these issues, and describe the algorithms in detail. For brevity, we choose to focus on policy iteration and linear programming; our techniques easily extend to value iteration."}, {"heading": "3.1 Linear Value Functions", "text": "A very popular choice for approximating value functions is by using linear regression, as first proposed by Bellman et al. (1963). Here, we define our space of allowable value functions V \u2208 H \u2286 RN via a set of basis functions:\nDefinition 3.1 A linear value function over a set of basis functions H = {h1, . . . , hk} is a function V that can be written as V(x) = \u2211k j=1wj hj(x) for some coefficients w = (w1, . . . , wk) \u2032.\nWe can now define H to be the linear subspace of RN spanned by the basis functions H. It is useful to define an N \u00d7 k matrix H whose columns are the k basis functions viewed as\nvectors. In a more compact notation, our approximate value function is then represented by Hw.\nThe expressive power of this linear representation is equivalent, for example, to that of a single layer neural network with features corresponding to the basis functions defining H. Once the features are defined, we must optimize the coefficients w in order to obtain a good approximation for the true value function. We can view this approach as separating the problem of defining a reasonable space of features and the induced space H, from the problem of searching within the space. The former problem is typically the purview of domain experts, while the latter is the focus of analysis and algorithmic design. Clearly, feature selection is an important issue for essentially all areas of learning and approximation. We offer some simple methods for selecting good features for MDPs in Section 11, but it is not our goal to address this large and important topic in this paper.\nOnce we have a chosen a linear value function representation and a set of basis functions, the problem becomes one of finding values for the weights w such that Hw will yield a good approximation of the true value function. In this paper, we consider two such approaches: approximate dynamic programming using policy iteration and approximate linear programming. In this section, we present these two approaches. In Section 4, we show how we can exploit problem structure to transform these approaches into practical algorithms that can deal with exponentially large state spaces."}, {"heading": "3.2 Policy Iteration", "text": ""}, {"heading": "3.2.1 The Exact Algorithm", "text": "The exact policy iteration algorithm iterates over policies, producing an improved policy at each iteration. Starting with some initial policy \u03c0(0), each iteration consists of two phases. Value determination computes, for a policy \u03c0(t), the value function V\u03c0(t) , by finding the fixed point of the equation T\u03c0(t)V\u03c0(t) = V\u03c0(t) , that is, the unique solution to the set of linear equations:\nV\u03c0(t)(x) = R(x, \u03c0 (t)(x)) + \u03b3\n\u2211\nx\u2032\nP (x\u2032 | x, \u03c0(t)(x))V\u03c0(t)(x \u2032),\u2200x.\nThe policy improvement step defines the next policy as\n\u03c0(t+1) = Greedy(V\u03c0(t)).\nIt can be shown that this process converges to the optimal policy (Bertsekas & Tsitsiklis, 1996). Furthermore, in practice, the convergence to the optimal policy is often very quick."}, {"heading": "3.2.2 Approximate Policy Iteration", "text": "The steps in the policy iteration algorithm require a manipulation of both value functions and policies, both of which often cannot be represented explicitly in large MDPs. To define a version of the policy iteration algorithm that uses approximate value functions, we use the following basic idea: We restrict the algorithm to using only value functions within the provided H; whenever the algorithm takes a step that results in a value function V that is outside this space, we project the result back into the space by finding the value function within the space which is closest to V. More precisely:\nDefinition 3.2 A projection operator \u03a0 is a mapping \u03a0 : RN \u2192 H. \u03a0 is said to be a projection w.r.t. a norm \u2016\u00b7\u2016 if \u03a0V = Hw\u2217 such that w\u2217 \u2208 argminw \u2016Hw \u2212 V\u2016.\nThat is, \u03a0V is the linear combination of the basis functions, that is closest to V with respect to the chosen norm.\nOur approximate policy iteration algorithm performs the policy improvement step exactly. In the value determination step, the value function \u2014 the value of acting according to the current policy \u03c0(t) \u2014 is approximated through a linear combination of basis functions.\nWe now consider the problem of value determination for a policy \u03c0(t). At this point, it is useful to introduce some notation: Although the rewards are a function of the state and action choice, once the policy is fixed, the rewards become a function of the state only, which we denote as R\u03c0(t) , where R\u03c0(t)(x) = R(x, \u03c0\n(t)(x)). Similarly, for the transition model: P\u03c0(t)(x\n\u2032 | x) = P (x\u2032 | x, \u03c0(t)(x)). We can now rewrite the value determination step in terms of matrices and vectors. If we view V\u03c0(t) and R\u03c0(t) as N -vectors, and P\u03c0(t) as an N \u00d7N matrix, we have the equations:\nV\u03c0(t) = R\u03c0(t) + \u03b3P\u03c0(t)V\u03c0(t) .\nThis is a system of linear equations with one equation for each state, which can only be solved exactly for relatively small N . Our goal is to provide an approximate solution, within H. More precisely, we want to find:\nw(t) = argmin w \u2016Hw \u2212 (R\u03c0(t) + \u03b3P\u03c0(t)Hw)\u2016 ;\n= argmin w\n\u2225\u2225\u2225(H\u2212 \u03b3P\u03c0(t)H)w (t) \u2212R\u03c0(t) \u2225\u2225\u2225 .\nThus, our approximate policy iteration alternates between two steps:\nw(t) = argmin w \u2016Hw \u2212 (R\u03c0(t) + \u03b3P\u03c0(t)Hw)\u2016 ; (2) \u03c0(t+1) = Greedy(Hw(t)). (3)"}, {"heading": "3.2.3 Max-norm Projection", "text": "An approach along the lines described above has been used in various papers, with several recent theoretical and algorithmic results (Schweitzer & Seidmann, 1985; Tsitsiklis & Van Roy, 1996b; Van Roy, 1998; Koller & Parr, 1999, 2000). However, these approaches suffer from a problem that we might call \u201cnorm incompatibility.\u201d When computing the projection, they utilize the standard Euclidean projection operator with respect to the L2 norm or a weighted L2 norm.\n1 On the other hand, most of the convergence and error analyses for MDP algorithms utilize max-norm (L\u221e). This incompatibility has made it difficult to provide error guarantees.\nWe can tie the projection operator more closely to the error bounds through the use of a projection operator in L\u221e norm. The problem of minimizing the L\u221e norm has been studied in the optimization literature as the problem of finding the Chebyshev solution2 to\n1. Weighted L2 norm projections are stable and have meaningful error bounds when the weights correspond to the stationary distribution of a fixed policy under evaluation (value determination) (Van Roy, 1998), but they are not stable when combined with T \u2217. Averagers (Gordon, 1995) are stable and non-expansive in L\u221e, but require that the mixture weights be determined a priori. Thus, they do not, in general, minimize L\u221e error. 2. The Chebyshev norm is also referred to as max, supremum and L\u221e norms and the minimax solution.\nan overdetermined linear system of equations (Cheney, 1982). The problem is defined as finding w\u2217 such that:\nw\u2217 \u2208 argmin w \u2016Cw \u2212 b\u2016\u221e . (4)\nWe use an algorithm due to Stiefel (1960), that solves this problem by linear programming:\nVariables: w1, . . . , wk, \u03c6 ; Minimize: \u03c6 ; Subject to: \u03c6 \u2265 \u2211k\nj=1 cijwj \u2212 bi and\n\u03c6 \u2265 bi \u2212 \u2211k j=1 cijwj, i = 1...N.\n(5)\nThe constraints in this linear program imply that \u03c6 \u2265 \u2223\u2223\u2223 \u2211k j=1 cijwj \u2212 bi \u2223\u2223\u2223 for each i, or equivalently, that \u03c6 \u2265 \u2016Cw \u2212 b\u2016\u221e. The objective of the LP is to minimize \u03c6. Thus, at the solution (w\u2217, \u03c6\u2217) of this linear program, w\u2217 is the solution of Equation (4) and \u03c6 is the L\u221e projection error.\nWe can use the L\u221e projection in the context of the approximate policy iteration in the obvious way. When implementing the projection operation of Equation (2), we can use the L\u221e projection (as in Equation (4)), where C = (H \u2212 \u03b3P\u03c0(t)H) and b = R\u03c0(t) . This minimization can be solved using the linear program of (5).\nA key point is that this LP only has k+1 variables. However, there are 2N constraints, which makes it impractical for large state spaces. In the SysAdmin problem, for example, the number of constraints in this LP is exponential in the number of machines in the network (a total of 2 \u00b72m constraints for m machines). In Section 4, we show that, in factored MDPs with linear value functions, all the 2N constraints can be represented efficiently, leading to a tractable algorithm."}, {"heading": "3.2.4 Error Analysis", "text": "We motivated our use of the max-norm projection within the approximate policy iteration algorithm via its compatibility with standard error analysis techniques for MDP algorithms. We now provide a careful analysis of the impact of the L\u221e error introduced by the projection step. The analysis provides motivation for the use of a projection step that directly minimizes this quantity. We acknowledge, however, that the main impact of this analysis is motivational. In practice, we cannot provide a priori guarantees that an L\u221e projection will outperform other methods.\nOur goal is to analyze approximate policy iteration in terms of the amount of error introduced at each step by the projection operation. If the error is zero, then we are performing exact value determination, and no error should accrue. If the error is small, we should get an approximation that is accurate. This result follows from the analysis below. More precisely, we define the projection error as the error resulting from the approximate value determination step:\n\u03b2(t) = \u2225\u2225\u2225Hw(t) \u2212 ( R\u03c0(t) + \u03b3P\u03c0(t)Hw (t) )\u2225\u2225\u2225\n\u221e .\nNote that, by using our max-norm projection, we are finding the set of weights w(t) that exactly minimizes the one-step projection error \u03b2(t). That is, we are choosing the best\npossible weights with respect to this error measure. Furthermore, this is exactly the error measure that is going to appear in the bounds of our theorem. Thus, we can now make the bounds for each step as tight as possible.\nWe first show that the projection error accrued in each step is bounded:\nLemma 3.3 The value determination error is bounded: There exists a constant \u03b2P \u2264 Rmax such that \u03b2P \u2265 \u03b2 (t) for all iterations t of the algorithm.\nProof: See Appendix A.1. Due to the contraction property of the Bellman operator, the overall accumulated error is a decaying average of the projection error incurred throughout all iterations:\nDefinition 3.4 The discounted value determination error at iteration t is defined as: \u03b2 (t) = \u03b2(t) + \u03b3\u03b2 (t\u22121) ; \u03b2 (0) = 0.\nLemma 3.3 implies that the accumulated error remains bounded in approximate policy iteration: \u03b2 (t) \u2264 \u03b2P (1\u2212\u03b3 t)\n1\u2212\u03b3 . We can now bound the loss incurred when acting according to the policy generated by our approximate policy iteration algorithm, as opposed to the optimal policy:\nTheorem 3.5 In the approximate policy iteration algorithm, let \u03c0(t) be the policy generated at iteration t. Furthermore, let V\u03c0(t) be the actual value of acting according to this policy. The loss incurred by using policy \u03c0(t) as opposed to the optimal policy \u03c0\u2217 with value V\u2217 is bounded by:\n\u2016V\u2217 \u2212 V\u03c0(t)\u2016\u221e \u2264 \u03b3 t \u2016V\u2217 \u2212 V\u03c0(0)\u2016\u221e +\n2\u03b3\u03b2 (t)\n(1\u2212 \u03b3)2 . (6)\nProof: See Appendix A.2. In words, Equation (6) shows that the difference between our approximation at iteration t and the optimal value function is bounded by the sum of two terms. The first term is present in standard policy iteration and goes to zero exponentially fast. The second is the discounted accumulated projection error and, as Lemma 3.3 shows, is bounded. This second term can be minimized by choosing w(t) as the one that minimizes:\n\u2225\u2225\u2225Hw(t) \u2212 ( R\u03c0(t) + \u03b3P\u03c0(t)Hw (t) )\u2225\u2225\u2225\n\u221e ,\nwhich is exactly the computation performed by the max-norm projection. Therefore, this theorem motivates the use of max-norm projections to minimize the error term that appears in our bound.\nThe bounds we have provided so far may seem fairly trivial, as we have not provided a strong a priori bound on \u03b2(t). Fortunately, several factors make these bounds interesting despite the lack of a priori guarantees. If approximate policy iteration converges, as occurred in all of our experiments, we can obtain a much tighter bound: If \u03c0\u0302 is the policy after convergence, then:\n\u2225\u2225V\u2217 \u2212 V\u03c0\u0302 \u2225\u2225 \u221e \u2264 2\u03b3\u03b2\u03c0\u0302 (1\u2212 \u03b3) ,\nwhere \u03b2\u03c0\u0302 is the one-step max-norm projection error associated with estimating the value of \u03c0\u0302. Since the max-norm projection operation provides \u03b2\u03c0\u0302, we can easily obtain an a\nposteriori bound as part of the policy iteration procedure. More details are provided in Section 7.\nOne could rewrite the bound in Theorem 3.5 in terms of the worst case projection error \u03b2P , or the worst projection error in a cycle of policies, if approximate policy iteration gets stuck in a cycle. These formulations would be closer to the analysis of Bertsekas and Tsitsiklis (1996, Proposition 6.2, p.276). However, consider the case where most policies (or most policies in the final cycle) have a low projection error, but there are a few policies that cannot be approximated well using the projection operation, so that they have a large one-step projection error. A worst-case bound would be very loose, because it would be dictated by the error of the most difficult policy to approximate. On the other hand, using our discounted accumulated error formulation, errors introduced by policies that are hard to approximate decay very rapidly. Thus, the error bound represents an \u201caverage\u201d case analysis: a decaying average of the projection errors for policies encountered at the successive iterations of the algorithm. As in the convergent case, this bound can be computed easily as part of the policy iteration procedure when max-norm projection is used.\nThe practical benefit of a posteriori bounds is that they can give meaningful feedback on the impact of the choice of the value function approximation architecture. While we are not explicitly addressing the difficult and general problem of feature selection in this paper, our error bounds motivate algorithms that aim to minimize the error given an approximation architecture and provide feedback that could be useful in future efforts to automatically discover or improve approximation architectures."}, {"heading": "3.3 Approximate Linear Programming", "text": ""}, {"heading": "3.3.1 The Exact Algorithm", "text": "Linear programming provides an alternative method for solving MDPs. It formulates the problem of finding a value function as a linear program (LP). Here the LP variables are V1, . . . , VN , where Vi represents V(xi): the value of starting at the ith state of the system. The LP is given by:\nVariables: V1, . . . , VN ; Minimize:\n\u2211 xi \u03b1(xi) Vi ;\nSubject to: Vi \u2265 [R(xi, a) + \u03b3 \u2211 j P (xj | xi, a)Vj ] \u2200xi \u2208 X, a \u2208 A, (7)\nwhere the state relevance weights \u03b1 are positive. Note that, in this exact case, the solution obtained is the same for any positive weight vector. It is interesting to note that steps of the simplex algorithm correspond to policy changes at single states, while steps of policy iteration can involve policy changes at multiple states. In practice, policy iteration tends to be faster than the linear programming approach (Puterman, 1994)."}, {"heading": "3.3.2 Approximate Linear Program", "text": "The approximate formulation for the LP approach, first proposed by Schweitzer and Seidmann (1985), restricts the space of allowable value functions to the linear space spanned by our basis functions. In this approximate formulation, the variables are w1, . . . , wk: the weights for our basis functions. The LP is given by:\nVariables: w1, . . . , wk ; Minimize: \u2211 x \u03b1(x) \u2211 iwi hi(x) ; Subject to: \u2211 i wi hi(x) \u2265 [R(x, a) + \u03b3 \u2211 x\u2032 P (x \u2032 | x, a) \u2211 iwi hi(x\n\u2032)] \u2200x \u2208 X,\u2200a \u2208 A. (8)\nIn other words, this formulation takes the LP in (7) and substitutes the explicit state value function by a linear value function representation \u2211 i wi hi(x), or, in our more compact notation, V is replaced by Hw. This linear program is guaranteed to be feasible if a constant function \u2014 a function with the same constant value for all states \u2014 is included in the set of basis functions.\nIn this approximate linear programming formulation, the choice of state relevance weights, \u03b1, becomes important. Intuitively, not all constraints in this LP are binding; that is, the constraints are tighter for some states than for others. For each state x, the relevance weight \u03b1(x) indicates the relative importance of a tight constraint. Therefore, unlike the exact case, the solution obtained may differ for different choices of the positive weight vector \u03b1. Furthermore, there is, in general, no guarantee as to the quality of the greedy policy generated from the approximation Hw. However, the recent work of de Farias and Van Roy (2001a) provides some analysis of the error relative to that of the best possible approximation in the subspace, and some guidance as to selecting \u03b1 so as to improve the quality of the approximation. In particular, their analysis shows that this LP provides the best approximation Hw\u2217 of the optimal value function V\u2217 in a weighted L1 sense subject to the constraint that Hw\u2217 \u2265 T \u2217Hw\u2217, where the weights in the L1 norm are the state relevance weights \u03b1.\nThe transformation from an exact to an approximate problem formulation has the effect of reducing the number of free variables in the LP to k (one for each basis function coefficient), but the number of constraints remains N \u00d7 |A|. In our SysAdmin problem, for example, the number of constraints in the LP in (8) is (m+1) \u00b7 2m, where m is the number of machines in the network. Thus, the process of generating the constraints and solving the LP still seems unmanageable for more than a few machines. In the next section, we discuss how we can use the structure of a factored MDP to provide for a compact representation and an efficient solution to this LP."}, {"heading": "4. Factored Value Functions", "text": "The linear value function approach, and the algorithms described in Section 3, apply to any choice of basis functions. In the context of factored MDPs, Koller and Parr (1999) suggest a particular type of basis function, that is particularly compatible with the structure of a factored MDP. They suggest that, although the value function is typically not structured, there are many cases where it might be \u201cclose\u201d to structured. That is, it might be wellapproximated using a linear combination of functions each of which refers only to a small number of variables. More precisely, we define:\nDefinition 4.1 A factored (linear) value function is a linear function over the basis set h1, . . . , hk, where the scope of each hi is restricted to some subset of variables Ci.\nValue functions of this type have a long history in the area of multi-attribute utility theory (Keeney & Raiffa, 1976). In our example, we might have a basis function hi for each\nmachine, indicating whether it is working or not. Each basis function has scope restricted to Xi. These are represented as diamonds in the next time step in Figure 2(b).\nFactored value functions provide the key to performing efficient computations over the exponential-sized state spaces we have in factored MDPs. The main insight is that restricted scope functions (including our basis functions) allow for certain basic operations to be implemented very efficiently. In the remainder of this section, we show how structure in factored MDPs can be exploited to perform two crucial operations very efficiently: one-step lookahead (backprojection), and the representation of exponentially many constraints in the LPs. Then, we use these basic building blocks to formulate very efficient approximation algorithms for factored MDPs, each presented in its own self-contained section: the approximate linear programming for factored MDPs in Section 5, and approximate policy iteration with max-norm projection in Section 6."}, {"heading": "4.1 One-step Lookahead", "text": "A key step in all of our algorithms is the computation of the one-step lookahead value of some action a. This is necessary, for example, when computing the greedy policy as in Equation (1). Let\u2019s consider the computation of a Q function, Qa(x), which represents the expected value the agent obtains after taking action a at the current time step and receiving a long-term value V thereafter. This Q function can be computed by:\nQa(x) = R(x, a) + \u03b3 \u2211\nx\u2032\nP (x\u2032 | x, a)V(x). (9)\nThat is, Qa(x) is given by the current reward plus the discounted expected future value. Using this notation, we can express the greedy policy as: Greedy(V)(x) = maxaQa(x).\nRecall that we are estimating the long-term value of our policy using a set of basis functions: V(x) = \u2211 i wi hi(x). Thus, we can rewrite Equation (9) as:\nQa(x) = R(x, a) + \u03b3 \u2211\nx\u2032\nP (x\u2032 | x, a) \u2211\ni\nwi hi(x). (10)\nThe size of the state space is exponential, so that computing the expectation \u2211\nx\u2032 P (x \u2032 |\nx, a) \u2211\niwi hi(x) seems infeasible. Fortunately, as discussed by Koller and Parr (1999), this expectation operation, or backprojection, can be performed efficiently if the transition model and the value function are both factored appropriately. The linearity of the value function permits a linear decomposition, where each summand in the expectation can be viewed as an independent value function and updated in a manner similar to the value iteration procedure used by Boutilier et al. (2000). We now recap the construction briefly, by first defining:\nGa(x) = \u2211\nx\u2032\nP (x\u2032 | x, a) \u2211\ni\nwi hi(x \u2032) =\n\u2211\ni\nwi \u2211\nx\u2032\nP (x\u2032 | x, a)hi(x \u2032).\nThus, we can compute the expectation of each basis function separately:\ngai (x) = \u2211\nx\u2032\nP (x\u2032 | x, a)hi(x \u2032),\nand then weight them by wi to obtain the total expectation G a(x) = \u2211 iwi g a i (x). The intermediate function gai is called the backprojection of the basis function hi through the transition model Pa, which we denote by g a i = Pahi. Note that, in factored MDPs, the transition model Pa is factored (represented as a DBN) and the basis functions hi have scope restricted to a small set of variables. These two important properties allow us to compute the backprojections very efficiently.\nWe now show how some restricted scope function h (such as our basis functions) can be backprojected through some transition model P\u03c4 represented as a DBN \u03c4 . Here h has scope restricted to Y; our goal is to compute g = P\u03c4h. We define the backprojected scope of Y through \u03c4 as the set of parents of Y\u2032 in the transition graph G\u03c4 ; \u0393\u03c4 (Y\n\u2032) = \u222aY \u2032 i \u2208Y\u2032Parents\u03c4 (Y \u2032 i ). If intra-time slice arcs are included, so that Parents\u03c4 (X \u2032 i) \u2208\n{X1, . . . ,Xn,X \u2032 1, . . . ,X \u2032 n}, then the only change in our algorithm is in the definition of backprojected scope of Y through \u03c4 . The definition now includes not only direct parents of Y \u2032, but also all variables in {X1, . . . ,Xn} that are ancestors of Y \u2032:\n\u0393\u03c4 (Y \u2032) = {Xj | there exist a directed path from Xj to any X \u2032 i \u2208 Y \u2032}.\nThus, the backprojected scope may become larger, but the functions are still factored. We can now show that, if h has scope restricted to Y, then its backprojection g has scope restricted to the parents of Y\u2032, i.e., \u0393\u03c4 (Y \u2032). Furthermore, each backprojection can be computed by only enumerating settings of variables in \u0393\u03c4 (Y \u2032), rather than settings of all variables X:\ng(x) = (P\u03c4h)(x);\n= \u2211\nx\u2032\nP\u03c4 (x \u2032 | x)h(x\u2032);\n= \u2211\nx\u2032\nP\u03c4 (x \u2032 | x)h(y\u2032);\n= \u2211\ny\u2032\nP\u03c4 (y \u2032 | x)h(y\u2032)\n\u2211\nu\u2032\u2208(x\u2032\u2212y\u2032)\nP\u03c4 (u \u2032 | x);\n= \u2211\ny\u2032\nP\u03c4 (y \u2032 | z)h(y\u2032);\n= g(z);\nwhere z is the value of \u0393\u03c4 (Y \u2032) in x and the term \u2211 u\u2032\u2208(x\u2032\u2212y\u2032) P\u03c4 (u\n\u2032 | x) = 1 as it is the sum of a probability distribution over a complete domain. Therefore, we see that (P\u03c4h) is a function whose scope is restricted to \u0393\u03c4 (Y\n\u2032). Note that the cost of the computation depends linearly on |Dom(\u0393\u03c4 (Y\n\u2032))|, which depends on Y (the scope of h) and on the complexity of the process dynamics. This backprojection procedure is summarized in Figure 3.\nReturning to our example, consider a basis function hi that is an indicator of variableXi: it takes value 1 if the ith machine is working and 0 otherwise. Each hi has scope restricted to X \u2032i, thus, its backprojection gi has scope restricted to Parents\u03c4 (X \u2032 i): \u0393\u03c4 (X \u2032 i) = {Xi\u22121,Xi}."}, {"heading": "4.2 Representing Exponentially Many Constraints", "text": "As seen in Section 3, both our approximation algorithms require the solution of linear programs: the LP in (5) for approximate policy iteration, and the LP in (8) for the approximate\nlinear programming algorithm. These LPs have some common characteristics: they have a small number of free variables (for k basis functions there are k + 1 free variables in approximate policy iteration and k in approximate linear programming), but the number of constraints is still exponential in the number of state variables. However, in factored MDPs, these LP constraints have another very useful property: the functionals in the constraints have restricted scope. This key observation allows us to represent these constraints very compactly.\nFirst, observe that the constraints in the linear programs are all of the form:\n\u03c6 \u2265 \u2211\ni\nwi ci(x)\u2212 b(x),\u2200x, (11)\nwhere only \u03c6 and w1, . . . , wk are free variables in the LP and x ranges over all states. This general form represents both the type of constraint in the max-norm projection LP in (5) and the approximate linear programming formulation in (8).3\nThe first insight in our construction is that we can replace the entire set of constraints in Equation (11) by one equivalent non-linear constraint:\n\u03c6 \u2265 max x\n\u2211\ni\nwi ci(x)\u2212 b(x). (12)\nThe second insight is that this new non-linear constraint can be implemented by a set of linear constraints using a construction that follows the structure of variable elimination in cost networks. This insight allows us to exploit structure in factored MDPs to represent this constraint compactly.\nWe tackle the problem of representing the constraint in Equation (12) in two steps: first, computing the maximum assignment for a fixed set of weights; then, representing the non-linear constraint by small set of linear constraints, using a construction we call the factored LP."}, {"heading": "4.2.1 Maximizing Over the State Space", "text": "The key computation in our algorithms is to represent a non-linear constraint of the form in Equation (12) efficiently by a small set of linear constraints. Before presenting this construction, let\u2019s first consider a simpler problem: Given some fixed weights wi, we would like to compute the maximization: \u03c6\u2217 = maxx \u2211 i wi ci(x)\u2212 b(x), that is, the state x, such\n3. The complementary constraints in (5), \u03c6 \u2265 b(x) \u2212 \u2211\ni wi ci(x), can be formulated using an analogous\nconstruction to the one we present in this section by changing the sign of ci(x) and b(x). The approximate linear programming constraints of (8) can also be formulated in this form, as we show in Section 5.\nthat the difference between \u2211\niwi ci(x) and b(x) is maximal. However, we cannot explicitly enumerate the exponential number of states and compute the difference. Fortunately, structure in factored MDPs allows us to compute this maximum efficiently.\nIn the case of factored MDPs, our state space is a set of vectors x which are assignments to the state variables X = {X1, . . . ,Xn}. We can view both Cw and b as functions of these state variables, and hence also their difference. Thus, we can define a function Fw(X1, . . . ,Xn) such that F w(x) = \u2211\ni wi ci(x) \u2212 b(x). Note that we have executed a representation shift; we are viewing Fw as a function of the variables X, which is parameterized by w. Recall that the size of the state space is exponential in the number of variables. Hence, our goal in this section is to compute maxx F\nw(x) without explicitly considering each of the exponentially many states. The solution is to use the fact that Fw has a factored representation. More precisely, Cw has the form \u2211\niwi ci(Zi), where Zi is a subset of X. For example, we might have c1(X1,X2) which takes value 1 in states where X1 = true and X2 = false and 0 otherwise. Similarly, the vector b in our case is also a sum of restricted scope functions. Thus, we can express Fw as a sum \u2211 j f w j (Zj), where f w j may or may not depend on w. In the future, we sometimes drop the superscript w when it is clear from context.\nUsing our more compact notation, our goal here is simply to compute maxx \u2211\niwi ci(x)\u2212 b(x) = maxx F\nw(x), that is, to find the state x over which Fw is maximized. Recall that Fw = \u2211m j=1 fj(Zj). We can maximize such a function, F\nw, without enumerating every state using non-serial dynamic programming (Bertele & Brioschi, 1972). The idea is virtually identical to variable elimination in a Bayesian network. We review this construction here, as it is a central component in our solution LP.\nOur goal is to compute max\nx1,...,xn\n\u2211\nj\nfj(x[Zj ]).\nThe main idea is that, rather than summing all functions and then doing the maximization, we maximize over variables one at a time. When maximizing over xl, only summands involving xl participate in the maximization.\nExample 4.2 Assume\nF = f1(x1, x2) + f2(x1, x3) + f3(x2, x4) + f4(x3, x4).\nWe therefore wish to compute:\nmax x1,x2,x3,x4 f1(x1, x2) + f2(x1, x3) + f3(x2, x4) + f4(x3, x4).\nWe can first compute the maximum over x4; the functions f1 and f2 are irrelevant, so we can push them out. We get\nmax x1,x2,x3 f1(x1, x2) + f2(x1, x3) + max x4 [f3(x2, x4) + f4(x3, x4)].\nThe result of the internal maximization depends on the values of x2, x3; thus, we can introduce a new function e1(X2,X3) whose value at the point x2, x3 is the value of the internal max expression. Our problem now reduces to computing\nmax x1,x2,x3 f1(x1, x2) + f2(x1, x3) + e1(x2, x3),\nhaving one fewer variable. Next, we eliminate another variable, say X3, with the resulting expression reducing to:\nmax x1,x2 f1(x1, x2) + e2(x1, x2),\nwhere e2(x1, x2) = max x3 [f2(x1, x3) + e1(x2, x3)].\nFinally, we define\ne3 = max x1,x2 f1(x1, x2) + e2(x1, x2).\nThe result at this point is a number, which is the desired maximum over x1, . . . , x4. While the naive approach of enumerating all states requires 63 arithmetic operations if all variables are binary, using variable elimination we only need to perform 23 operations.\nThe general variable elimination algorithm is described in Figure 4. The inputs to the algorithm are the functions to be maximized F = {f1, . . . , fm} and an elimination ordering O on the variables, where O(i) returns the ith variable to be eliminated. As in the example above, for each variable Xl to be eliminated, we select the relevant functions e1, . . . , eL, those whose scope contains Xl. These functions are removed from the set F and we introduce a new function e = maxxl \u2211L j=1 ej . At this point, the scope of the functions in F no longer depends on Xl, that is, Xl has been \u2018eliminated\u2019. This procedure is repeated until all variables have been eliminated. The remaining functions in F thus have empty scope. The desired maximum is therefore given by the sum of these remaining functions.\nThe computational cost of this algorithm is linear in the number of new \u201cfunction values\u201d introduced in the elimination process. More precisely, consider the computation of a new function e whose scope is Z. To compute this function, we need to compute |Dom[Z]| different values. The cost of the algorithm is linear in the overall number of these values, introduced throughout the execution. As shown by Dechter (1999), this cost is exponential\nin the induced width of the cost network, the undirected graph defined over the variables X1, . . . ,Xn, with an edge between Xl and Xm if they appear together in one of the original functions fj. The complexity of this algorithm is, of course, dependent on the variable elimination order and the problem structure. Computing the optimal elimination order is an NP-hard problem (Arnborg, Corneil, & Proskurowski, 1987) and elimination orders yielding low induced tree width do not exist for some problems. These issues have been confronted successfully for a large variety of practical problems in the Bayesian network community, which has benefited from a large variety of good heuristics which have been developed for the variable elimination ordering problem (Bertele & Brioschi, 1972; Kjaerulff, 1990; Reed, 1992; Becker & Geiger, 2001)."}, {"heading": "4.2.2 Factored LP", "text": "In this section, we present the centerpiece of our planning algorithms: a new, general approach for compactly representing exponentially large sets of LP constraints in problems with factored structure \u2014 those where the functions in the constraints can be decomposed as the sum of restricted scope functions. Consider our original problem of representing the non-linear constraint in Equation (12) compactly. Recall that we wish to represent the non-linear constraint \u03c6 \u2265 maxx \u2211 iwi ci(x) \u2212 b(x), or equivalently, \u03c6 \u2265 maxx F\nw(x), without generating one constraint for each state as in Equation (11). The new, key insight is that this non-linear constraint can be implemented using a construction that follows the structure of variable elimination in cost networks.\nConsider any function e used within F (including the original fi\u2019s), and let Z be its scope. For any assignment z to Z, we introduce variable uez, whose value represents ez, into the linear program. For the initial functions fwi , we include the constraint that u fi z = fwi (z). As fwi is linear in w, this constraint is linear in the LP variables. Now, consider a new function e introduced into F by eliminating a variable Xl. Let e1, . . . , eL be the functions extracted from F , and let Z be the scope of the resulting e. We introduce a set of constraints:\nuez \u2265 L\u2211\nj=1\nu ej (z,xl)[Zj ]\n\u2200xl. (13)\nLet en be the last function generated in the elimination, and recall that its scope is empty. Hence, we have only a single variable uen . We introduce the additional constraint \u03c6 \u2265 uen .\nThe complete algorithm, presented in Figure 5, is divided into three parts: First, we generate equality constraints for functions that depend on the weights wi (basis functions). In the second part, we add the equality constraints for functions that do not depend on the weights (target functions). These equality constraints let us abstract away the differences between these two types of functions and manage them in a unified fashion in the third part of the algorithm. This third part follows a procedure similar to variable elimination described in Figure 4. However, unlike standard variable elimination where we would introduce a new function e, such that e = maxxl \u2211L j=1 ej , in our factored LP procedure we introduce new LP variables uez. To enforce the definition of e as the maximum over Xl of\u2211L j=1 ej , we introduce the new LP constraints in Equation (13).\nExample 4.3 To understand this construction, consider our simple example above, and assume we want to express the fact that \u03c6 \u2265 maxx F w(x). We first introduce a set of\nvariables uf1x1,x2 for every instantiation of values x1, x2 to the variables X1,X2. Thus, if X1 and X2 are both binary, we have four such variables. We then introduce a constraint defining the value of uf1x1,x2 appropriately. For example, for our f1 above, we have u f1 t,t = 0 and uf1t,f = w1. We have similar variables and constraints for each fj and each value z in Zj. Note that each of the constraints is a simple equality constraint involving numerical constants and perhaps the weight variables w.\nNext, we introduce variables for each of the intermediate expressions generated by variable elimination. For example, when eliminating X4, we introduce a set of LP variables ue1x2,x3; for each of them, we have a set of constraints\nue1x2,x3 \u2265 u f3 x2,x4 + uf4x3,x4\none for each value x4 of X4. We have a similar set of constraint for u e2 x1,x2 in terms of uf2x1,x3 and u e1 x2,x3 . Note that each constraint is a simple linear inequality.\nWe can now prove that our factored LP construction represents the same constraint as non-linear constraint in Equation (12):\nTheorem 4.4 The constraints generated by the factored LP construction are equivalent to the non-linear constraint in Equation (12). That is, an assignment to (\u03c6,w) satisfies the factored LP constraints if and only if it satisfies the constraint in Equation (12).\nProof: See Appendix A.3. Returning to our original formulation, we have that \u2211 j f w j is Cw \u2212 b in the original set of constraints. Hence our new set of constraints is equivalent to the original set: \u03c6 \u2265 maxx \u2211 iwi ci(x) \u2212 b(x) in Equation (12), which in turn is equivalent to the exponential set of constraints \u03c6 \u2265 \u2211\niwi ci(x)\u2212 b(x),\u2200x in Equation (11). Thus, we can represent this exponential set of constraints by a new set of constraints and LP variables. The size of this new set, as in variable elimination, is exponential only in the induced width of the cost network, rather than in the total number of variables.\nIn this section, we presented a new, general approach for compactly representing exponentially-large sets of LP constraints in problems with factored structure. In the remainder of this paper, we exploit this construction to design efficient planning algorithms for factored MDPs."}, {"heading": "4.2.3 Factored Max-norm Projection", "text": "We can now use our procedure for representing the exponential number of constraints in Equation (11) compactly to compute efficient max-norm projections, as in Equation (4):\nw\u2217 \u2208 argmin w \u2016Cw \u2212 b\u2016\u221e .\nThe max-norm projection is computed by the linear program in (5). There are two sets of constraints in this LP: \u03c6 \u2265 \u2211k j=1 cijwj \u2212 bi,\u2200i and \u03c6 \u2265 bi \u2212 \u2211k j=1 cijwj ,\u2200i. Each of these sets is an instance of the constraints in Equation (11), which we have just addressed in the previous section. Thus, if each of the k basis functions in C is a restricted scope function and the target function b is the sum of restricted scope functions, then we can use our factored LP technique to represent the constraints in the max-norm projection LP compactly. The correctness of our algorithm is a corollary of Theorem 4.4:\nCorollary 4.5 The solution (\u03c6\u2217,w\u2217) of a linear program that minimizes \u03c6 subject to the constraints in FactoredLP(C, \u2212b,O) and FactoredLP(\u2212C, b,O), for any elimination order O satisfies:\nw\u2217 \u2208 argmin w \u2016Cw \u2212 b\u2016\u221e , and \u03c6 \u2217 = min w \u2016Cw \u2212 b\u2016\u221e .\nThe original max-norm projection LP had k + 1 variables and two constraints for each state x; thus, the number of constraints is exponential in the number of state variables. On the other hand, our new factored max-norm projection LP has more variables, but exponentially fewer constraints. The number of variables and constraints in the new factored LP is exponential only in the number of state variables in the largest factor in the cost network, rather than exponential in the total number of state variables. As we show in Section 9, this exponential gain allows us to compute max-norm projections efficiently when solving very large factored MDPs."}, {"heading": "5. Approximate Linear Programming", "text": "We begin with the simplest of our approximate MDP solution algorithms, based on the approximate linear programming formulation in Section 3.3. Using the basic operations described in Section 4, we can formulate an algorithm that is both simple and efficient."}, {"heading": "5.1 The Algorithm", "text": "As discussed in Section 3.3, approximate linear program formulation is based on the linear programming approach to solving MDPs presented in Section 3.3. However, in this approximate version, we restrict the space of value functions to the linear space defined by our basis functions. More precisely, in this approximate LP formulation, the variables are w1, . . . , wk \u2014 the weights for our basis functions. The LP is given by:\nVariables: w1, . . . , wk ; Minimize: \u2211 x \u03b1(x) \u2211 iwi hi(x) ; Subject to: \u2211 i wi hi(x) \u2265 [R(x, a) + \u03b3 \u2211 x\u2032 P (x \u2032 | x, a) \u2211 iwi hi(x\n\u2032)] \u2200x \u2208 X,\u2200a \u2208 A. (14)\nIn other words, this formulation takes the LP in (7) and substitutes the explicit state value function with a linear value function representation \u2211 iwi hi(x). This transformation from an exact to an approximate problem formulation has the effect of reducing the number of free variables in the LP to k (one for each basis function coefficient), but the number of constraints remains |X| \u00d7 |A|. In our SysAdmin problem, for example, the number of constraints in the LP in (14) is (m + 1) \u00b7 2m, where m is the number of machines in the network. However, using our algorithm for representing exponentially large constraint sets compactly we are able to compute the solution to this approximate linear programming algorithm in closed form with an exponentially smaller LP, as in Section 4.2.\nFirst, consider the objective function \u2211 x \u03b1(x) \u2211\ni wi hi(x) of the LP (14). Naively representing this objective function requires a summation over a exponentially large state space. However, we can rewrite the objective and obtain a compact representation. We first reorder the terms:\n\u2211\nx\n\u03b1(x) \u2211\ni\nwi hi(x) = \u2211\ni\nwi \u2211\nx\n\u03b1(x) hi(x).\nNow, consider the state relevance weights \u03b1(x) as a distribution over states, so that \u03b1(x) > 0 and \u2211 x \u03b1(x) = 1. As in backprojections, we can now write:\n\u03b1i = \u2211\nx\n\u03b1(x) hi(x) = \u2211\nci\u2208Ci\n\u03b1(ci) hi(ci); (15)\nwhere \u03b1(ci) represents the marginal of the state relevance weights \u03b1 over the domain Dom[Ci] of the basis function hi. For example, if we use uniform state relevance weights as in our experiments \u2014 \u03b1(x) = 1|X| \u2014 then the marginals become \u03b1(ci) = 1 |Ci| . Thus, we can\nrewrite the objective function as \u2211\ni wi \u03b1i, where each basis weight \u03b1i is computed as shown in Equation (15). If the state relevance weights are represented by marginals, then the cost of computing each \u03b1i depends exponentially on the size of the scope of Ci only, rather than exponentially on the number of state variables. On the other hand, if the state relevance weights are represented by arbitrary distributions, we need to obtain the marginals over the Ci\u2019s, which may not be an efficient computation. Thus, greatest efficiency is achieved by using a compact representation, such as a Bayesian network, for the state relevance weights.\nSecond, note that the right side of the constraints in the LP (14) correspond to the Qa functions:\nQa(x) = R a(x) + \u03b3\n\u2211\nx\u2032\nP (x\u2032 | x, a) \u2211\ni\nwi hi(x \u2032).\nUsing the efficient backprojection operation in factored MDPs described in Section 4.1 we can rewrite the Qa functions as:\nQa(x) = R a(x) + \u03b3\n\u2211\ni\nwi g a i (x);\nwhere gai is the backprojection of basis function hi through the transition model Pa. As we discussed, if hi has scope restricted to Ci, then g a i is a restricted scope function of \u0393a(C \u2032 i).\nWe can precompute the backprojections gai and the basis relevance weights \u03b1i. The approximate linear programming LP of (14) can be written as:\nVariables: w1, . . . , wk ; Minimize: \u2211 i \u03b1i wi ; Subject to: \u2211\niwi hi(x) \u2265 [R a(x) + \u03b3 \u2211 iwi g a i (x)] \u2200x \u2208 X,\u2200a \u2208 A.\n(16)\nFinally, we can rewrite this LP to use constraints of the same form as the one in Equation (12):\nVariables: w1, . . . , wk ; Minimize: \u2211 i \u03b1i wi ; Subject to: 0 \u2265 maxx {R a(x) + \u2211 iwi [\u03b3g a i (x) \u2212 hi(x)]} \u2200a \u2208 A.\n(17)\nWe can now use our factored LP construction in Section 4.2 to represent these non-linear constraints compactly. Basically, there is one set of factored LP constraints for each action a. Specifically, we can write the non-linear constraint in the same form as those in Equation (12) by expressing the functions C as: ci(x) = hi(x)\u2212\u03b3g a i (x). Each ci(x) is a restricted\nscope function; that is, if hi(x) has scope restricted to Ci, then g a i (x) has scope restricted to \u0393a(C \u2032 i), which means that ci(x) has scope restricted to Ci \u222a \u0393a(C \u2032 i). Next, the target function b becomes the reward function Ra(x) which, by assumption, is factored. Finally, in the constraint in Equation (12), \u03c6 is a free variable. On the other hand, in the LP in (17) the maximum in the right hand side must be less than zero. This final condition can be achieved by adding a constraint \u03c6 = 0. Thus, our algorithm generates a set of factored LP constraints, one for each action. The total number of constraints and variables in this new LP is linear in the number of actions |A| and only exponential in the induced width of each cost network, rather than in the total number of variables. The complete factored approximate linear programming algorithm is outlined in Figure 6."}, {"heading": "5.2 An Example", "text": "We now present a complete example of the operations required by the approximate LP algorithm to solve the factored MDP shown in Figure 2(a). Our presentation follows four steps: problem representation, basis function selection, backprojections and LP construction.\nProblem Representation: First, we must fully specify the factored MDP model for the problem. The structure of the DBN is shown in Figure 2(b). This structure is maintained for all action choices. Next, we must define the transition probabilities for each action. There are 5 actions in this problem: do nothing, or reboot one of the 4 machines in the network. The CPDs for these actions are shown in Figure 2(c). Finally, we must define the reward function. We decompose the global reward as the sum of 4 local reward functions, one for each machine, such that there is a reward if the machine is working. Specifically, Ri(Xi = true) = 1 and Ri(Xi = false) = 0, breaking symmetry by setting R4(X4 = true) = 2. We use a discount factor of \u03b3 = 0.9.\nBasis Function Selection: In this simple example, we use five simple basis functions. First, we include the constant function h0 = 1. Next, we add indicators for each machine which take value 1 if the machine is working: hi(Xi = true) = 1 and hi(Xi = false) = 0.\nBackprojections: The first algorithmic step is computing the backprojection of the basis functions, as defined in Section 4.1. The backprojection of the constant basis is simple:\nga0 = \u2211\nx\u2032\nPa(x \u2032 | x)h0 ;\n= \u2211\nx\u2032\nPa(x \u2032 | x) 1 ;\n= 1 .\nNext, we must backproject our indicator basis functions hi:\ngai = \u2211\nx\u2032\nPa(x \u2032 | x)hi(x \u2032 i) ;\n= \u2211\nx\u20321,x \u2032 2,x \u2032 3,x \u2032 4\n\u220f\nj\nPa(x \u2032 j | xj\u22121, xj)hi(x \u2032 i) ;\n= \u2211\nx\u2032 i\nPa(x \u2032 i | xi\u22121, xi)hi(x \u2032 i)\n\u2211\nx\u2032[X\u2032\u2212{X\u2032 i }]\n\u220f\nj 6=i\nPa(x \u2032 j | xj\u22121, xj) ;\n= \u2211\nx\u2032 i\nPa(x \u2032 i | xi\u22121, xi)hi(x \u2032 i) ;\n= Pa(X \u2032 i = true | xi\u22121, xi) 1 + Pa(X \u2032 i = false | xi\u22121, xi) 0 ; = Pa(X \u2032 i = true | xi\u22121, xi) .\nThus, gai is a restricted scope function of {Xi\u22121,Xi}. We can now use the CPDs in Figure 2(c) to specify gai :\ngreboot = ii (Xi\u22121,Xi) =\nXi = true Xi = false\nXi\u22121 = true 1 1 Xi\u22121 = false 1 1\n;\ng reboot 6= i i (Xi\u22121,Xi) =\nXi = true Xi = false\nXi\u22121 = true 0.9 0.09 Xi\u22121 = false 0.5 0.05\n.\nLP Construction: To illustrate the factored LPs constructed by our algorithms, we define the constraints for the approximate linear programming approach presented above. First, we define the functions cai = \u03b3g a i \u2212 hi, as shown in Equation (17). In our example, these functions are ca0 = \u03b3 \u2212 1 = \u22120.1 for the constant basis, and for the indicator bases:\ncreboot = ii (Xi\u22121,Xi) =\nXi = true Xi = false\nXi\u22121 = true \u22120.1 0.9 Xi\u22121 = false \u22120.1 0.9 ;\nc reboot 6= i i (Xi\u22121,Xi) =\nXi = true Xi = false\nXi\u22121 = true \u22120.19 0.081 Xi\u22121 = false \u22120.55 0.045\n.\nUsing this definition of cai , the approximate linear programming constraints are given by:\n0 \u2265 max x\n\u2211\ni\nRi + \u2211\nj\nwjc a j , \u2200a . (18)\nWe present the LP construction for one of the 5 actions: reboot = 1. Analogous constructions can be made for the other actions.\nIn the first set of constraints, we abstract away the difference between rewards and basis functions by introducing LP variables u and equality constraints. We begin with the reward functions:\nuR1x1 = 1 , u R1 x\u03041 = 0 ; u R2 x2 = 1 , uR2x\u03042 = 0 ; uR3x3 = 1 , u R3 x\u03043 = 0 ; u R4 x4 = 2 , uR4x\u03044 = 0 .\nWe now represent the equality constraints for the caj functions for the reboot = 1 action. Note that the appropriate basis function weight from Equation (18) appears in these constraints:\nuc0 = \u22120.1 w0 ; uc1x1,x4 = \u22120.1 w1 , u c1 x\u03041,x4 = 0.9 w1 , u c1 x1,x\u03044 = \u22120.1 w1 , u c1 x\u03041,x\u03044 = 0.9 w1 ;\nuc2x1,x2 = \u22120.19 w2 , u c2 x\u03041,x2 = \u22120.55 w2 , u c2 x1,x\u03042 = 0.081 w2 , u c2 x\u03041,x\u03042 = 0.045 w2 ; uc3x2,x3 = \u22120.19 w3 , u c3 x\u03042,x3 = \u22120.55 w3 , u c3 x2,x\u03043 = 0.081 w3 , u c3 x\u03042,x\u03043 = 0.045 w3 ; uc4x3,x4 = \u22120.19 w4 , u c4 x\u03043,x4 = \u22120.55 w4 , u c4 x3,x\u03044 = 0.081 w4 , u c4 x\u03043,x\u03044 = 0.045 w4 .\nUsing these new LP variables, our LP constraint from Equation (18) for the reboot = 1 action becomes:\n0 \u2265 max X1,X2,X3,X4\n4\u2211\ni=1\nuRiXi + u c0 +\n4\u2211\nj=1\nu cj Xj\u22121,Xj .\nWe are now ready for the variable elimination process. We illustrate the elimination of variable X4:\n0 \u2265 max X1,X2,X3\n3\u2211\ni=1\nuRiXi + u c0 +\n3\u2211\nj=2\nu cj Xj\u22121,Xj\n+max X4\n[ uR4X4 + u c1 X1,X4 + uc4X3,X4 ] .\nWe can represent the term maxX4 [ uR4X4 + u c1 X1,X4 + uc4X3,X4 ] by a set of linear constraints, one for each assignment of X1 and X3, using the new LP variables u e1 X1,X3\nto represent this maximum:\nue1x1,x3 \u2265 u R4 x4 + uc1x1,x4 + u c4 x3,x4 ; ue1x1,x3 \u2265 u R4 x\u03044 + u c1 x1,x\u03044 + u c4 x3,x\u03044 ; ue1x\u03041,x3 \u2265 u R4 x4 + uc1x\u03041,x4 + u c4 x3,x4 ; ue1x\u03041,x3 \u2265 u R4 x\u03044 + u c1 x\u03041,x\u03044 + u c4 x3,x\u03044 ; ue1x1,x\u03043 \u2265 u R4 x4 + uc1x1,x4 + u c4 x\u03043,x4 ; ue1x1,x\u03043 \u2265 u R4 x\u03044 + u c1 x1,x\u03044 + u c4 x\u03043,x\u03044 ; ue1x\u03041,x\u03043 \u2265 u R4 x4 + uc1x\u03041,x4 + u c4 x\u03043,x4 ; ue1x\u03041,x\u03043 \u2265 u R4 x\u03044 + u c1 x\u03041,x\u03044 + u c4 x\u03043,x\u03044 .\nWe have now eliminated variable X4 and our global non-linear constraint becomes:\n0 \u2265 max X1,X2,X3\n3\u2211\ni=1\nuRiXi + u c0 +\n3\u2211\nj=2\nu cj Xj\u22121,Xj + ue1X1,X3 .\nNext, we eliminate variable X3. The new LP constraints and variables have the form:\nue2X1,X2 \u2265 u R3 X3 + uc3X2,X3 + u e1 X1,X3 , \u2200 X1,X2,X3 ;\nthus, removing X3 from the global non-linear constraint:\n0 \u2265 max X1,X2\n2\u2211\ni=1\nuRiXi + u c0 + uc2X1,X2 + u e2 X1,X2 .\nWe can now eliminate X2, generating the linear constraints:\nue3X1 \u2265 u R2 X2 + uc2X1,X2 + u e2 X1,X2 , \u2200 X1,X2 .\nNow, our global non-linear constraint involves only X1:\n0 \u2265 max X1\nuR1X1 + u c0 + ue3X1 .\nAs X1 is the last variable to be eliminated, the scope of the new LP variable is empty and the linear constraints are given by:\nue4 \u2265 uR1X1 + u e3 X1 , \u2200 X1 .\nAll of the state variables have now been eliminated, turning our global non-linear constraint into a simple linear constraint:\n0 \u2265 uc0 + ue4 ,\nwhich completes the LP description for the approximate linear programming solution to the problem in Figure 2.\nIn this small example with only four state variables, our factored LP technique generates a total of 89 equality constraints, 115 inequality constraints and 149 LP variables, while the explicit state representation in Equation (8) generates only 80 inequality constraints and 5 LP variables. However, as the problem size increases, the number of constraints and LP variables in our factored LP approach grow as O(n2), while the explicit state approach grows exponentially, at O(n2n). This scaling effect is illustrated in Figure 7."}, {"heading": "6. Approximate Policy Iteration with Max-norm Projection", "text": "The factored approximate linear programming approach described in the previous section is both elegant and easy to implement. However, we cannot, in general, provide strong\nguarantees about the error it achieves. An alternative is to use the approximate policy iteration described in Section 3.2, which does offer certain bounds on the error. However, as we shall see, this algorithm is significantly more complicated, and requires that we place additional restrictions on the factored MDP.\nIn particular, approximate policy iteration requires a representation of the policy at each iteration. In order to obtain a compact policy representation, we must make an additional assumption: each action only affects a small number of state variables. We first state this assumption formally. Then, we show how to obtain a compact representation of the greedy policy with respect to a factored value function, under this assumption. Finally, we describe our factored approximate policy iteration algorithm using max-norm projections."}, {"heading": "6.1 Default Action Model", "text": "In Section 2.2, we presented the factored MDP model, where each action is associated with its own factored transition model represented as a DBN and with its own factored reward function. However, different actions often have very similar transition dynamics, only differing in their effect on some small set of variables. In particular, in many cases a variable has a default evolution model, which only changes if an action affects it directly (Boutilier et al., 2000).\nThis type of structure turns out to be useful for compactly representing policies, a property which is important in our approximate policy iteration algorithm. Thus, in this section of the paper, we restrict attention to factored MDPs that are defined using a default transition model \u03c4d = \u3008Gd, Pd\u3009 (Koller & Parr, 2000). For each action a, we define Effects[a] \u2286 X \u2032 to be the variables in the next state whose local probability model is different from \u03c4d, i.e., those variables X \u2032i such that Pa(X \u2032 i | Parentsa(X \u2032 i)) 6= Pd(X \u2032 i | Parentsd(X \u2032 i)).\nExample 6.1 In our system administrator example, we have an action ai for rebooting each one of the machines, and a default action d for doing nothing. The transition model described above corresponds to the \u201cdo nothing\u201d action, which is also the default transition model. The transition model for ai is different from d only in the transition model for the variable X \u2032i, which is now X \u2032 i = true with probability one, regardless of the status of the neighboring machines. Thus, in this example, Effects[ai] = X \u2032 i.\nAs in the transition dynamics, we can also define the notion of default reward model. In this case, there is a set of reward functions \u2211r i=1 Ri(Ui) associated with the default action d. In addition, each action a can have a reward function Ra(Ua). Here, the extra reward of action a has scope restricted to Rewards [a] = Uai \u2282 {X1, . . . ,Xn}. Thus, the total reward associated with action a is given by Ra + \u2211r i=1Ri. Note that R\na can also be factored as a linear combination of smaller terms for an even more compact representation.\nWe can now build on this additional assumption to define the complete algorithm. Recall that the approximate policy iteration algorithm iterates through two steps: policy improvement and approximate value determination. We now discuss each of these steps."}, {"heading": "6.2 Computing Greedy Policies", "text": "The policy improvement step computes the greedy policy relative to a value function V(t\u22121):\n\u03c0(t) = Greedy(V(t\u22121)).\nRecall that our value function estimates have the linear form Hw. As we described in Section 4.1, the greedy policy for this type of value function is given by:\nGreedy(Hw)(x) = argmax a Qa(x),\nwhere each Qa can be represented by: Qa(x) = R(x, a) + \u2211 iwi g a i (x).\nIf we attempt to represent this policy naively, we are again faced with the problem of exponentially large state spaces. Fortunately, as shown by Koller and Parr (2000), the greedy policy relative to a factored value function has the form of a decision list. More precisely, the policy can be written in the form \u3008t1, a1\u3009, \u3008t2, a2\u3009, . . . , \u3008tL, aL\u3009, where each ti is an assignment of values to some small subset Ti of variables, and each ai is an action. The greedy action to take in state x is the action aj corresponding to the first event tj in the list with which x is consistent. For completeness, we now review the construction of this decision-list policy.\nThe critical assumption that allows us to represent the policy as a compact decision list is the default action assumption described in Section 6.1. Under this assumption, the Qa functions can be written as:\nQa(x) = R a(x) +\nr\u2211\ni=1\nRi(x) + \u2211\ni\nwi g a i (x),\nwhere Ra has scope restricted to Ua. The Q function for the default action d is just: Qd(x) = \u2211r i=1 Ri(x) + \u2211 i wi g d i (x).\nWe now have a set of linear Q-functions which implicitly describes a policy \u03c0. It is not immediately obvious that these Q functions result in a compactly expressible policy. An important insight is that most of the components in the weighted combination are identical, so that gai is equal to g d i for most i. Intuitively, a component g a i corresponding to the backprojection of basis function hi(Ci) is only different if the action a influences one of the variables in Ci. More formally, assume that Effects[a] \u2229 Ci = \u2205. In this case, all of the variables in Ci have the same transition model in \u03c4a and \u03c4d. Thus, we have that gai (x) = g d i (x); in other words, the ith component of the Qa function is irrelevant when deciding whether action a is better than the default action d. We can define which components are actually relevant: let Ia be the set of indices i such that Effects[a]\u2229Ci 6= \u2205. These are the indices of those basis functions whose backprojection differs in Pa and Pd. In our example DBN of Figure 2, actions and basis functions involve single variables, so Iai = i.\nLet us now consider the impact of taking action a over the default action d. We can define the impact \u2014 the difference in value \u2014 as:\n\u03b4a(x) = Qa(x) \u2212Qd(x);\n= Ra(x) + \u2211\ni\u2208Ia\nwi [ gai (x)\u2212 g d i (x) ] . (19)\nThis analysis shows that \u03b4a(x) is a function whose scope is restricted to\nTa = U a \u222a [ \u222ai\u2208Ia\u0393a(C \u2032 i) ] . (20)\nIn our example DBN, Ta2 = {X1,X2}. Intuitively, we now have a situation where we have a \u201cbaseline\u201d value function Qd(x) which defines a value for each state x. Each action a changes that baseline by adding or subtracting an amount from each state. The point is that this amount depends only on Ta, so that it is the same for all states in which the variables in Ta take the same values.\nWe can now define the greedy policy relative to our Q functions. For each action a, define a set of conditionals \u3008t, a, \u03b4\u3009, where each t is some assignment of values to the variables Ta, and \u03b4 is \u03b4a(t). Now, sort the conditionals for all of the actions by order of decreasing \u03b4:\n\u3008t1, a1, \u03b41\u3009, \u3008t2, a2, \u03b42\u3009, . . . , \u3008tL, aL, \u03b4L\u3009.\nConsider our optimal action in a state x. We would like to get the largest possible \u201cbonus\u201d over the default value. If x is consistent with t1, we should clearly take action a1, as it gives us bonus \u03b41. If not, then we should try to get \u03b42; thus, we should check if x is consistent with t2, and if so, take a2. Using this procedure, we can compute the decisionlist policy associated with our linear estimate of the value function. The complete algorithm for computing the decision list policy is summarized in Figure 8.\nNote that the number of conditionals in the list is \u2211\na |Dom(Ta)|; Ta, in turn, depends on the set of basis function clusters that intersect with the effects of a. Thus, the size of the policy depends in a natural way on the interaction between the structure of our\nprocess description and the structure of our basis functions. In problems where the actions modify a large number of variables, the policy representation could become unwieldy. The approximate linear programming approach in Section 5 is more appropriate in such cases, as it does not require an explicit representation of the policy."}, {"heading": "6.3 Value Determination", "text": "In the approximate value determination step our algorithm computes:\nw(t) = argmin w \u2016Hw \u2212 (R\u03c0(t) + \u03b3P\u03c0(t)Hw)\u2016\u221e .\nBy rearranging the expression, we get:\nw(t) = argmin w \u2016(H\u2212 \u03b3P\u03c0(t)H)w \u2212R\u03c0(t)\u2016\u221e .\nThis equation is an instance of the optimization in Equation (4). If P\u03c0(t) is factored, we can conclude that C = (H\u2212 \u03b3P\u03c0(t)H) is also a matrix whose columns correspond to restrictedscope functions. More specifically:\nci(x) = hi(x)\u2212 \u03b3g \u03c0(t) i (x),\nwhere g\u03c0 (t)\ni is the backprojection of the basis function hi through the transition model P\u03c0(t) , as described in Section 4.1. The target b = R\u03c0(t) corresponds to the reward function, which for the moment is assumed to be factored. Thus, we can again apply our factored LP in Section 4.2.3 to estimate the value of the policy \u03c0(t).\nUnfortunately, the transition model P\u03c0(t) is not factored, as a decision list representation for the policy \u03c0(t) will, in general, induce a transition model P\u03c0(t) which cannot be represented by a compact DBN. Nonetheless, we can still generate a compact LP by exploiting the decision list structure of the policy. The basic idea is to introduce cost networks corresponding to each branch in the decision list, ensuring, additionally, that only states consistent with this branch are considered in the cost network maximization. Specifically, we have a factored LP construction for each branch \u3008ti, ai\u3009. The ith cost network only considers a subset of the states that is consistent with the ith branch of the decision list. Let Si be the set of states x such that ti is the first event in the decision list for which x is consistent. That is, for each state x \u2208 Si, x is consistent with ti, but it is not consistent with any tj with j < i.\nRecall that, as in Equation (11), our LP construction defines a set of constraints that imply that \u03c6 \u2265 \u2211 iwi ci(x) \u2212 b(x) for each state x. Instead, we have a separate set of constraints for the states in each subset Si. For each state in Si, we know that action ai is taken. Hence, we can apply our construction above using Pai \u2014 a transition model which is factored by assumption \u2014 in place of the non-factored P\u03c0(t) . Similarly, the reward function becomes Rai(x) + \u2211r i=1Ri(x) for this subset of states.\nThe only issue is to guarantee that the cost network constraints derived from this transition model are applied only to states in Si. Specifically, we must guarantee that they are applied only to states consistent with ti, but not to states that are consistent with some tj for j < i. To guarantee the first condition, we simply instantiate the variables in Ti to take the values specified in ti. That is, our cost network now considers only the variables in\n{X1, . . . ,Xn}\u2212Ti, and computes the maximum only over the states consistent with Ti = ti. To guarantee the second condition, we ensure that we do not impose any constraints on states associated with previous decisions. This is achieved by adding indicators Ij for each previous decision tj, with weight \u2212\u221e. More specifically, Ij is a function that takes value \u2212\u221e for states consistent with tj and zero for other all assignments of Tj . The constraints for the ith branch will be of the form:\n\u03c6 \u2265 R(x, ai) + \u2211\nl\nwl (\u03b3gl(x, ai)\u2212 h(x)) + \u2211\nj<i\n\u2212\u221e1(x = tj), \u2200x \u223c [ti], (21)\nwhere x \u223c [ti] defines the assignments of X consistent with ti. The introduction of these indicators causes the constraints associated with ti to be trivially satisfied by states in Sj for j < i. Note that each of these indicators is a restricted-scope function of Tj and can be handled in the same fashion as all other terms in the factored LP. Thus, for a decision list of size L, our factored LP contains constraints from 2L cost networks. The complete approximate policy iteration with max-norm projection algorithm is outlined in Figure 9."}, {"heading": "6.4 Comparisons", "text": "It is instructive to compare our max-norm policy iteration algorithm to the L2-projection policy iteration algorithm of Koller and Parr (2000) in terms of computational costs per iteration and implementation complexity. Computing the L2 projection requires (among other things) a series of dot product operations between basis functions and backprojected basis functions \u3008hi \u2022g \u03c0 j \u3009. These expressions are easy to compute if P\u03c0 refers to the transition model of a particular action a. However, if the policy \u03c0 is represented as a decision list, as is the result of the policy improvement step, then this step becomes much more complicated. In particular, for every branch of the decision list, for every pair of basis functions i and j, and for each assignment to the variables in Scope[hi]\u222a Scope[g a j ], it requires the solution of a counting problem which is \u266fP -complete in general. Although Koller and Parr show that this computation can be performed using a Bayesian network (BN) inference, the algorithm still requires a BN inference for each one of those assignments at each branch of the decision list. This makes the algorithm very difficult to implement efficiently in practice.\nThe max-norm projection, on the other hand, relies on solving a linear program at every iteration. The size of the linear program depends on the cost networks generated. As we discuss, two cost networks are needed for each point in the decision list. The complexity of each of these cost networks is approximately the same as only one of the BN inferences in the counting problem for the L2 projection. Overall, for each branch in the decision list, we have a total of two of these \u201cinferences,\u201d as opposed to one for each assignment of Scope[hi] \u222a Scope[g a j ] for every pair of basis functions i and j. Thus, the max-norm policy iteration algorithm is substantially less complex computationally than the approach based on L2-projection. Furthermore, the use of linear programming allows us to rely on existing LP packages (such as CPLEX), which are very highly optimized.\nIt is also interesting to compare the approximate policy iteration algorithm to the approximate linear programming algorithm we presented in Section 5. In the approximate linear programming algorithm, we never need to compute the decision list policy. The policy is always represented implicitly by the Qa functions. Thus, this algorithm does not\nrequire explicit computation or manipulation of the greedy policy. This difference has two important consequences: one computational and the other in terms of generality.\nFirst, not having to compute or consider the decision lists makes approximate linear programming faster and easier to implement. In this algorithm, we generate a single LP with one cost network for each action and never need to compute a decision list policy. On the other hand, in each iteration, approximate policy iteration needs to generate two LPs for every branch of the decision list of size L, which is usually significantly longer than |A|, with a total of 2L cost networks. In terms of representation, we do not require the policies to be compact; thus, we do not need to make the default action assumption. Therefore, the approximate linear programming algorithm can deal with a more general class of problems, where each action can have its own independent DBN transition model. On the other hand, as described in Section 3.2, approximate policy iteration has stronger guarantees in terms of error bounds. These differences will be highlighted further in our experimental results presented in Section 9."}, {"heading": "7. Computing Bounds on Policy Quality", "text": "We have presented two algorithms for computing approximate solutions to factored MDPs. All these algorithms generate linear value functions which can be denoted by Hw\u0302, where w\u0302 are the resulting basis function weights. In practice, the agent will define its behavior by acting according to the greedy policy \u03c0\u0302 = Greedy(Hw\u0302). One issue that remains is how this policy \u03c0\u0302 compares to the true optimal policy \u03c0\u2217; that is, how the actual value V\u03c0\u0302 of policy \u03c0\u0302 compares to V\u2217.\nIn Section 3, we showed some a priori bounds for the quality of the policy. Another possible procedure is to compute an a posteriori bound. That is, given our resulting weights w\u0302, we compute a bound on the loss of acting according to the greedy policy \u03c0\u0302 rather than the optimal policy. This can be achieved by using the Bellman error analysis of Williams and Baird (1993).\nThe Bellman error is defined as BellmanErr(V) = \u2016T \u2217V \u2212 V\u2016\u221e. Given the greedy policy \u03c0\u0302 = Greedy(V), their analysis provides the bound:\n\u2225\u2225V\u2217 \u2212 V\u03c0\u0302 \u2225\u2225 \u221e \u2264 2\u03b3BellmanErr(V)\n1\u2212 \u03b3 . (22)\nThus, we can use the Bellman error BellmanErr(Hw\u0302) to evaluate the quality of our resulting greedy policy.\nNote that computing the Bellman error involves a maximization over the state space. Thus, the complexity of this computation grows exponentially with the number of state variables. Koller and Parr (2000) suggested that structure in the factored MDP can be exploited to compute the Bellman error efficiently. Here, we show how this error bound can be computed by a set of cost networks using a similar construction to the one in our maxnorm projection algorithms. This technique can be used for any \u03c0\u0302 that can be represented as a decision list and does not depend on the algorithm used to determine the policy. Thus, we can apply this technique to solutions determined approximate linear programming if the action descriptions permit a decision list representation of the policy.\nFor some set of weights w\u0302, the Bellman error is given by:\nBellmanErr(Hw\u0302) = \u2016T \u2217Hw\u0302 \u2212Hw\u0302\u2016\u221e ;\n= max\n( maxx \u2211 i wihi(x) \u2212R\u03c0\u0302(x)\u2212 \u03b3 \u2211 x\u2032 P\u03c0\u0302(x \u2032 | x) \u2211 j wjhj(x \u2032) ,\nmaxx R\u03c0\u0302(x) + \u03b3 \u2211 x\u2032 P\u03c0\u0302(x \u2032 | x) \u2211 j wjhj(x \u2032)\u2212 \u2211 iwihi(x)\n)\n.\nIf the rewards R\u03c0\u0302 and the transition model P\u03c0\u0302 are factored appropriately, then we can compute each one of these two maximizations (maxx) using variable elimination in a cost network as described in Section 4.2.1. However, \u03c0\u0302 is a decision list policy and it does not induce a factored transition model. Fortunately, as in the approximate policy iteration algorithm in Section 6, we can exploit the structure in the decision list to perform such maximization efficiently. In particular, as in approximate policy iteration, we will generate two cost networks for each branch in the decision list. To guarantee that our maximization is performed only over states where this branch is relevant, we include the same type of indicator functions, which will force irrelevant states to have a value of \u2212\u221e, thus guaranteeing that at each point of the decision list policy we obtain the corresponding state with the maximum error. The state with the overall largest Bellman error will be the maximum over the ones generated for each point the in the decision list policy. The complete factored algorithm for computing the Bellman error is outlined in Figure 10.\nOne last interesting note concerns our approximate policy iteration algorithm with maxnorm projection of Section 6. In all our experiments, this algorithm converged, so that w(t) = w(t+1) after some iterations. If such convergence occurs, then the objective function \u03c6(t+1) of the linear program in our last iteration is equal to the Bellman error of the final policy:\nLemma 7.1 If approximate policy iteration with max-norm projection converges, so that w(t) = w(t+1) for some iteration t, then the max-norm projection error \u03c6(t+1) of the last iteration is equal to the Bellman error for the final value function estimate Hw\u0302 = Hw(t):\nBellmanErr(Hw\u0302) = \u03c6(t+1).\nProof: See Appendix A.4.\nThus, we can bound the loss of acting according to the final policy \u03c0(t+1) by substituting \u03c6(t+1) into the Bellman error bound:\nCorollary 7.2 If approximate policy iteration with max-norm projection converges after t iterations to a final value function estimate Hw\u0302 associated with a greedy policy \u03c0\u0302 = Greedy(Hw\u0302), then the loss of acting according to \u03c0\u0302 instead of the optimal policy \u03c0\u2217 is bounded by:\n\u2225\u2225V\u2217 \u2212 V\u03c0\u0302 \u2225\u2225 \u221e \u2264 2\u03b3\u03c6(t+1)\n1\u2212 \u03b3 ,\nwhere V\u03c0\u0302 is the actual value of the policy \u03c0\u0302.\nTherefore, when approximate policy iteration converges we can obtain a bound on the quality of the resulting policy without needing to compute the Bellman error explicitly."}, {"heading": "8. Exploiting Context-specific Structure", "text": "Thus far, we have presented a suite of algorithms which exploit additive structure in the reward and basis functions and sparse connectivity in the DBN representing the transition model. However, there exists another important type of structure that should also be exploited for efficient decision making: context-specific independence (CSI). For example, consider an agent responsible for building and maintaining a house, if the painting task can only be completed after the plumbing and the electrical wiring have been installed, then the probability that the painting is done is 0, in all contexts where plumbing or electricity are not done, independently of the agents action. The representation we have used so far in this paper would use a table to represent this type of function. This table is exponentially large in the number of variables in the scope of the function, and ignores the context-specific structure inherent in the problem definition.\nBoutilier et al. (Boutilier et al., 1995; Dearden & Boutilier, 1997; Boutilier, Dean, & Hanks, 1999; Boutilier et al., 2000) have developed a set of algorithms which can exploit CSI in the transition and reward models to perform efficient (approximate) planning. Although this approach is often successful in problems where the value function contains sufficient context-specific structure, the approach is not able to exploit the additive structure which is also often present in real-world problems.\nIn this section, we extend the factored MDP model to include context-specific structure. We present a simple, yet effective extension of our algorithms which can exploit both CSI and additive structure to obtain efficient approximations for factored MDPs. We first extend the factored MDP representation to include context-specific structure and then show how the basic operations from Section 4 required by our algorithms can be performed efficiently in this new representation."}, {"heading": "8.1 Factored MDPs with Context-specific and Additive Structure", "text": "There are several representations for context-specific functions. The most common are decision trees (Boutilier et al., 1995), algebraic decision diagrams (ADDs) (Hoey, St-Aubin, Hu, & Boutilier, 1999), and rules (Zhang & Poole, 1999). We choose to use rules as our basic representation, for two main reasons. First, the rule-based representation allows a fairly simple algorithm for variable elimination, which is a key operation in our framework. Second, rules are not required to be mutually exclusive and exhaustive, a requirement that can be restrictive if we want to exploit additive independence, where functions can be represented as a linear combination of a set of non-mutually exclusive functions.\nWe begin by describing the rule-based representation (along the lines of Zhang and Poole\u2019s presentation (1999)) for the probabilistic transition model, in particular, the CPDs of our DBN model. Roughly speaking, each rule corresponds to some set of CPD entries that are all associated with a particular probability value. These entries with the same value are referred to as consistent contexts:\nDefinition 8.1 Let C \u2286 {X,X\u2032} and c \u2208 Dom(C). We say that c is consistent with b \u2208 Dom(B), for B \u2286 {X,X\u2032}, if c and b have the same assignment for the variables in C \u2229B.\nThe probability of these consistent contexts will be represented by probability rules:\nDefinition 8.2 A probability rule \u03b7 = \u3008c : p\u3009 is a function \u03b7 : {X,X\u2032} 7\u2192 [0, 1], where the context c \u2208 Dom(C) for C \u2286 {X,X\u2032} and p \u2208 [0, 1], such that \u03b7(x,x\u2032) = p if (x,x\u2032) is consistent with c and is equal to 1 otherwise.\nIn this case, it is convenient to require that the rules be mutually exclusive and exhaustive, so that each CPD entry is uniquely defined by its association with a single rule.\nDefinition 8.3 A rule-based conditional probability distribution (rule CPD) Pa is a function Pa : ({X \u2032 i} \u222aX) 7\u2192 [0, 1], composed of a set of probability rules {\u03b71, \u03b72, . . . , \u03b7m} whose contexts are mutually exclusive and exhaustive. We define:\nPa(x \u2032 i | x) = \u03b7j(x,x \u2032),\nwhere \u03b7j is the unique rule in Pa for which cj is consistent with (x \u2032 i,x). We require that, for all x, \u2211\nx\u2032 i\nPa(x \u2032 i | x) = 1.\nWe can define Parentsa(X \u2032 i) to be the union of the contexts of the rules in Pa(X \u2032 i | X). An example of a CPD represented by a set of probability rules is shown in Figure 11. Rules can also be used to represent additive functions, such as reward or basis functions. We represent such context specific value dependencies using value rules:\nDefinition 8.4 A value rule \u03c1 = \u3008c : v\u3009 is a function \u03c1 : X 7\u2192 R such that \u03c1(x) = v when x is consistent with c and 0 otherwise.\nNote that a value rule \u3008c : v\u3009 has a scope C. It is important to note that value rules are not required to be mutually exclusive and exhaustive. Each value rule represents a (weighted) indicator function, which takes on a value v in states consistent with some context c, and 0 in all other states. In any given state, the values of the zero or more rules consistent with that state are simply added together.\nExample 8.5 In our construction example, we might have a set of rules:\n\u03c11 = \u3008Plumbing = done : 100\u3009; \u03c12 = \u3008Electricity = done : 100\u3009; \u03c13 = \u3008Painting = done : 100\u3009; \u03c14 = \u3008Action = plumb : \u221210\u3009;\n...\nwhich, when summed together, define the reward function R = \u03c11 + \u03c12 + \u03c13 + \u03c14 + \u00b7 \u00b7 \u00b7.\nIn general, our reward function Ra is represented as a rule-based function:\nDefinition 8.6 A rule-based function f : X 7\u2192 R is composed of a set of rules {\u03c11, . . . , \u03c1n} such that f(x) = \u2211n i=1 \u03c1i(x).\nIn the same manner, each one of our basis functions hj is now represented as a rule-based function.\nThis notion of a rule-based function is related to the tree-structure functions used by Boutilier et al. (2000), but is substantially more general. In the tree-structure value functions, the rules corresponding to the different leaves are mutually exclusive and exhaustive. Thus, the total number of different values represented in the tree is equal to the number of leaves (or rules). In the rule-based function representation, the rules are not mutually exclusive, and their values are added to form the overall function value for different settings of the variables. Different rules are added in different settings, and, in fact, with k rules, one can easily generate 2k different possible values, as is demonstrated in Section 9. Thus, the rule-based functions can provide a compact representation for a much richer class of value functions.\nUsing this rule-based representation, we can exploit both CSI and additive independence in the representation of our factored MDP and basis functions. We now show how the basic operations in Section 4 can be adapted to exploit our rule-based representation."}, {"heading": "8.2 Adding, Multiplying and Maximizing Consistent Rules", "text": "In our table-based algorithms, we relied on standard sum and product operators applied to tables. In order to exploit CSI using a rule-based representation, we must redefine these standard operations. In particular, the algorithms will need to add or multiply rules that ascribe values to overlapping sets of states.\nWe will start by defining these operations for rules with the same context:\nDefinition 8.7 Let \u03c11 = \u3008c : v1\u3009 and \u03c12 = \u3008c : v2\u3009 be two rules with context c. Define the rule product as \u03c11 \u00d7 \u03c12 = \u3008c : v1 \u00b7 v2\u3009, and the rule sum as \u03c11 + \u03c12 = \u3008c : v1 + v2\u3009.\nNote that this definition is restricted to rules with the same context. We will address this issue in a moment. First, we will introduce an additional operation which maximizes a variable from a set of rules, which otherwise share a common context:\nDefinition 8.8 Let Y be a variable with Dom[Y ] = {y1, . . . , yk}, and let \u03c1i, for each i = 1, . . . , k, be a rule of the form \u03c1i = \u3008c \u2227 Y = yi : vi\u3009. Then for the rule-based function f = \u03c11 + \u00b7 \u00b7 \u00b7+ \u03c1k, define the rule maximization over Y as maxY f = \u3008c : maxi vi\u3009 .\nAfter this operation, Y has been maximized out from the scope of the function f . These three operations we have just described can only be applied to sets of rules that satisfy very stringent conditions. To make our set of rules amenable to the application of these operations, we might need to refine some of these rules. We therefore define the following operation:\nDefinition 8.9 Let \u03c1 = \u3008c : v\u3009 be a rule, and Y be a variable. Define the rule split Split(\u03c16 Y ) of \u03c1 on a variable Y as follows: If Y \u2208 Scope[C], then Split(\u03c1 6 Y ) = {\u03c1}; otherwise,\nSplit(\u03c1 6 Y ) = {\u3008c \u2227 Y = yi : v\u3009 | yi \u2208 Dom[Y ]} .\nThus, if we split a rule \u03c1 on variable Y that is not in the scope of the context of \u03c1, then we generate a new set of rules, with one for each assignment in the domain of Y .\nIn general, the purpose of rule splitting is to extend the context c of one rule \u03c1 coincide with the context c\u2032 of another consistent rule \u03c1\u2032. Naively, we might take all variables in Scope[C\u2032] \u2212 Scope[C] and split \u03c1 recursively on each one of them. However, this process creates unnecessarily many rules: If Y is a variable in Scope[C\u2032]\u2212 Scope[C] and we split \u03c1 on Y , then only one of the |Dom[Y ]| new rules generated will remain consistent with \u03c1\u2032: the one which has the same assignment for Y as the one in c\u2032. Thus, only this consistent rule needs to be split further. We can now define the recursive splitting procedure that achieves this more parsimonious representation:\nDefinition 8.10 Let \u03c1 = \u3008c : v\u3009 be a rule, and b be a context such that b \u2208 Dom[B]. Define the recursive rule split Split(\u03c1 6 b) of \u03c1 on a context b as follows:\n1. {\u03c1}, if c is not consistent with b; else,\n2. {\u03c1}, if Scope[B] \u2286 Scope[C]; else,\n3. {Split(\u03c1i 6 b) | \u03c1i \u2208 Split(\u03c16 Y )}, for some variable Y \u2208 Scope[B]\u2212 Scope[C] .\nIn this definition, each variable Y \u2208 Scope[B] \u2212 Scope[C] leads to the generation of k = |Dom(Y )| rules at the step in which it is split. However, only one of these k rules is used in the next recursive step because only one is consistent with b. Therefore, the size of the split set is simply 1 + \u2211 Y \u2208Scope[B]\u2212Scope[C](|Dom(Y )| \u2212 1). This size is independent of the order in which the variables are split within the operation.\nNote that only one of the rules in Split(\u03c1 6 b) is consistent with b: the one with context c \u2227 b. Thus, if we want to add two consistent rules \u03c11 = \u3008c1 : v1\u3009 and \u03c12 = \u3008c2 : v2\u3009, then all we need to do is replace these rules by the set:\nSplit(\u03c11 6 c2) \u222a Split(\u03c12 6 c1),\nand then simply replace the resulting rules \u3008c1 \u2227 c2 : v1\u3009 and \u3008c2 \u2227 c1 : v2\u3009 by their sum \u3008c1 \u2227 c2 : v1 + v2\u3009. Multiplication is performed in an analogous manner.\nExample 8.11 Consider adding the following set of consistent rules:\n\u03c11 = \u3008a \u2227 b : 5\u3009, \u03c12 = \u3008a \u2227 \u00acc \u2227 d : 3\u3009."}, {"heading": "In these rules, the context c1 of \u03c11 is a \u2227 b, and the context c2 of \u03c12 is a \u2227 \u00acc \u2227 d.", "text": "Rules \u03c11 and \u03c12 are consistent, therefore, we must split them to perform the addition operation:\nSplit(\u03c11 6 c2) =\n \n \u3008a \u2227 b \u2227 c : 5\u3009, \u3008a \u2227 b \u2227 \u00acc \u2227 \u00acd : 5\u3009, \u3008a \u2227 b \u2227 \u00acc \u2227 d : 5\u3009.\nLikewise,\nSplit(\u03c12 6 c1) = { \u3008a \u2227 \u00acb \u2227 \u00acc \u2227 d : 3\u3009, \u3008a \u2227 b \u2227 \u00acc \u2227 d : 3\u3009.\nThe result of adding rules \u03c11 and \u03c12 is\n\u3008a \u2227 b \u2227 c : 5\u3009, \u3008a \u2227 b \u2227 \u00acc \u2227 \u00acd : 5\u3009, \u3008a \u2227 b \u2227 \u00acc \u2227 d : 8\u3009, \u3008a \u2227 \u00acb \u2227 \u00acc \u2227 d : 3\u3009."}, {"heading": "8.3 Rule-based One-step Lookahead", "text": "Using this compact rule-based representation, we are able to compute a one-step lookahead plan efficiently for models with significant context-specific or additive independence.\nAs in Section 4.1 for the table-based case, the rule-based Qa function can be represented as the sum of the reward function and the discounted expected value of the next state. Due to our linear approximation of the value function, the expectation term is, in turn, represented as the linear combination of the backprojections of our basis functions. To exploit CSI, we are representing the rewards and basis functions as rule-based functions. To represent Qa as a rule-based function, it is sufficient for us to show how to represent the backprojection gj of the basis function hj as a rule-based function.\nEach hj is a rule-based function, which can be written as hj(x) = \u2211 i \u03c1 (hj) i (x), where\n\u03c1 (hj) i has the form \u2329 c (hj ) i : v (hj) i \u232a . Each rule is a restricted scope function; thus, we can simplify the backprojection as:\ngaj (x) = \u2211\nx\u2032\nPa(x \u2032 | x)hj(x \u2032) ;\n= \u2211\nx\u2032\nPa(x \u2032 | x)\n\u2211\ni\n\u03c1 (hj) i (x \u2032);\n= \u2211\ni\n\u2211\nx\u2032\nPa(x \u2032 | x)\u03c1 (hj) i (x \u2032);\n= \u2211\ni\nv (hj) i Pa(c (hj) i | x);\nwhere the term v (hj) i Pa(c (hj ) i | x) can be written as a rule function. We denote this backprojection operation by RuleBackproja (\u03c1 (hj) i ).\nThe backprojection procedure, described in Figure 12, follows three steps. First, the relevant rules are selected: In the CPDs for the variables that appear in the context of \u03c1, we select the rules consistent with this context, as these are the only rules that play a role in the backprojection computation. Second, we multiply all consistent probability rules to form a local set of mutually-exclusive rules. This procedure is analogous to the addition procedure described in Section 8.2. Now that we have represented the probabilities that can affect \u03c1 by a mutually-exclusive set, we can simply represent the backprojection of \u03c1 by the product of these probabilities with the value of \u03c1. That is, the backprojection of \u03c1 is a rule-based function with one rule for each one of the mutually-exclusive probability rules \u03b7i. The context of this new value rule is the same as that of \u03b7i, and the value is the product of the probability of \u03b7i and the value of \u03c1.\nExample 8.12 For example, consider the backprojection of a simple rule,\n\u03c1 = \u3008 Painting = done : 100\u3009,\nthrough the CPD in Figure 11(c) for the paint action:\nRuleBackprojpaint(\u03c1) = \u2211\nx\u2032\nPpaint(x \u2032 | x)\u03c1(x\u2032);\n= \u2211\nPainting\u2032\nPpaint(Painting \u2032 | x)\u03c1(Painting\u2032);\n= 100 3\u220f\ni=1\n\u03b7i(Painting\u2019 = done,x) .\nNote that the product of these simple rules is equivalent to the decision tree CPD shown in Figure 11(a). Hence, this product is equal to 0 in most contexts, for example, when electricity is not done at time t. The product in non-zero only in one context: in the context associated with rule \u03b73. Thus, we can express the result of the backprojection operation by a rule-based function with a single rule:\nRuleBackprojpaint(\u03c1) = \u3008Plumbing \u2227 Electrical : 95\u3009.\nSimilarly, the backprojection of \u03c1 when the action is not paint can also be represented by a single rule:\nRuleBackproj\u00acpaint(\u03c1) = \u3008Plumbing \u2227 Electrical \u2227 Painting : 90\u3009.\nUsing this algorithm, we can now write the backprojection of the rule-based basis function hj as:\ngaj (x) = \u2211\ni\nRuleBackproja (\u03c1 (hj) i ), (23)\nwhere gaj is a sum of rule-based functions, and therefore also a rule-based function. For simplicity of notation, we use gaj = RuleBackproja(hj) to refer to this definition of backprojection. Using this notation, we can write Qa(x) = R a(x) + \u03b3 \u2211 j wjg a j (x), which is again a rule-based function."}, {"heading": "8.4 Rule-based Maximization Over the State Space", "text": "The second key operation required to extend our planning algorithms to exploit CSI is to modify the variable elimination algorithm in Section 4.2.1 to handle the rule-based representation. In Section 4.2.1, we showed that the maximization of a linear combination of table-based functions with restricted scope can be performed efficiently using non-serial dynamic programming (Bertele & Brioschi, 1972), or variable elimination. To exploit structure in rules, we use an algorithm similar to variable elimination in a Bayesian network with context-specific independence (Zhang & Poole, 1999).\nIntuitively, the algorithm operates by selecting the value rules relevant to the variable being maximized in the current iteration. Then, a local maximization is performed over this subset of the rules, generating a new set of rules without the current variable. The procedure is then repeated recursively until all variables have been eliminated.\nMore precisely, our algorithm \u201celiminates\u201d variables one by one, where the elimination process performs a maximization step over the variable\u2019s domain. Suppose that we are eliminating Xi, whose collected value rules lead to a rule function f , and f involves additional variables in some set B, so that f \u2019s scope is B \u222a {Xi}. We need to compute the maximum value for Xi for each choice of b \u2208 Dom[B]. We use MaxOut (f,Xi) to denote a procedure that takes a rule function f(B,Xi) and returns a rule function g(B) such\nthat: g(b) = maxxi f(b, xi). Such a procedure is an extension of the variable elimination algorithm of Zhang and Poole (Zhang & Poole, 1999).\nThe rule-based variable elimination algorithm maintains a set F of value rules, initially containing the set of rules to be maximized. The algorithm then repeats the following steps for each variable Xi until all variables have been eliminated:\n1. Collect all rules which depend on Xi into fi \u2014 fi = {\u3008c : v\u3009 \u2208 F | Xi \u2208 C} \u2014 and remove these rules from F .\n2. Perform the local maximization step over Xi: gi = MaxOut (fi,Xi);\n3. Add the rules in gi to F ; now, Xi has been \u201celiminated.\u201d\nThe cost of this algorithm is polynomial in the number of new rules generated in the maximization operation MaxOut (fi,Xi). The number of rules is never larger and in many cases exponentially smaller than the complexity bounds on the table-based maximization in Section 4.2.1, which, in turn, was exponential only in the induced width of the cost network graph (Dechter, 1999). However, the computational costs involved in managing sets of rules usually imply that the computational advantage of the rule-based approach over the tablebased one will only be significant in problems that possess a fair amount of context-specific structure.\nIn the remainder of this section, we present the algorithm for computing the local maximization MaxOut (fi,Xi). In the next section, we show how these ideas can be applied to extending the algorithm in Section 4.2.2 to exploit CSI in the LP representation for planning in factored MDPs.\nThe procedure, presented in Figure 13, is divided into two parts: first, all consistent rules are added together as described in Section 8.2; then, variable B is maximized. This maximization is performed by generating a set of rules, one for each assignment of B, whose contexts have the same assignment for all variables except for B, as in Definition 8.8. This set is then substituted by a single rule without a B assignment in its context and with value equal to the maximum of the values of the rules in the original set. Note that, to simplify\nthe algorithm, we initially need to add a set of value rules with 0 value, which guarantee that our rule function f is complete (i.e., there is at least one rule consistent with every context).\nThe correctness of this procedure follows directly from the correctness of the rule-based variable elimination procedure described by Zhang and Poole, merely by replacing summations with product with max, and products with products with sums. We conclude this section with a small example to illustrate the algorithm:\nExample 8.13 Suppose we are maximizing a for the following set of rules:\n\u03c11 = \u3008\u00aca : 1\u3009, \u03c12 = \u3008a \u2227 \u00acb : 2\u3009, \u03c13 = \u3008a \u2227 b \u2227 \u00acc : 3\u3009, \u03c14 = \u3008\u00aca \u2227 b : 1\u3009.\nWhen we add completing rules, we get:\n\u03c15 = \u3008\u00aca : 0\u3009, \u03c16 = \u3008a : 0\u3009.\nIn the first part of the algorithm, we need to add consistent rules: We add \u03c15 to \u03c11 (which remains unchanged), combine \u03c11 with \u03c14, \u03c16 with \u03c12, and then the split of \u03c16 on the context of \u03c13, to get the following inconsistent set of rules:\n\u03c12 = \u3008a \u2227 \u00acb : 2\u3009, \u03c13 = \u3008a \u2227 b \u2227 \u00acc : 3\u3009, \u03c17 = \u3008\u00aca \u2227 b : 2\u3009, (from adding \u03c14 to the consistent rule from Split(\u03c11 6 b)) \u03c18 = \u3008\u00aca \u2227 \u00acb : 1\u3009, (from Split(\u03c11 6 b)) \u03c19 = \u3008a \u2227 b \u2227 c : 0\u3009, (from Split(\u03c16 6 a \u2227 b \u2227 \u00acc)).\nNote that several rules with value 0 are also generated, but not shown here because they are added to other rules with consistent contexts. We can move to the second stage (repeat loop) of MaxOut. We remove \u03c12, and \u03c18, and maximize a out of them, to give:\n\u03c110 = \u3008\u00acb : 2\u3009.\nWe then select rules \u03c13 and \u03c17 and split \u03c17 on c (\u03c13 is split on the empty set and is not changed),\n\u03c111 = \u3008\u00aca \u2227 b \u2227 c : 2\u3009, \u03c112 = \u3008\u00aca \u2227 b \u2227 \u00acc : 2\u3009.\nMaximizing out a from rules \u03c112 and \u03c13, we get:\n\u03c113 = \u3008b \u2227 \u00acc : 3\u3009.\nWe are left with \u03c111, which maximized over its counterpart \u03c19 gives\n\u03c112 = \u3008b \u2227 \u00acc : 2\u3009.\nNotice that, throughout this maximization, we have not split on the variable C when \u00acb \u2208 ci, giving us only 6 distinct rules in the final result. This is not possible in a table-based representation, since our functions would then be over the 3 variables a,b,c, and therefore must have 8 entries."}, {"heading": "8.5 Rule-based Factored LP", "text": "In Section 4.2.2, we showed that the LPs used in our algorithms have exponentially many constraints of the form: \u03c6 \u2265 \u2211 iwi ci(x) \u2212 b(x),\u2200x, which can be substituted by a single, equivalent, non-linear constraint: \u03c6 \u2265 maxx \u2211\ni wi ci(x)\u2212b(x). We then showed that, using variable elimination, we can represent this non-linear constraint by an equivalent set of linear constraints in a construction we called the factored LP. The number of constraints in the factored LP is linear in the size of the largest table generated in the variable elimination procedure. This table-based algorithm can only exploit additive independence. We now extend the algorithm in Section 4.2.2 to exploit both additive and context-specific structure, by using the rule-based variable elimination described in the previous section.\nSuppose we wish to enforce the more general constraint 0 \u2265 maxy F w(y), where Fw(y) =\u2211\nj f w j (y) such that each fj is a rule. As in the table-based version, the superscriptw means that fj might depend on w. Specifically, if fj comes from basis function hi, it is multiplied by the weight wi; if fj is a rule from the reward function, it is not.\nIn our rule-based factored linear program, we generate LP variables associated with contexts; we call these LP rules. An LP rule has the form \u3008c : u\u3009; it is associated with a context c and a variable u in the linear program. We begin by transforming all our original rules fwj into LP rules as follows: If rule fj has the form \u3008cj : vj\u3009 and comes from basis function hi, we introduce an LP rule ej = \u3008cj : uj\u3009 and the equality constraint uj = wivj . If fj has the same form but comes from a reward function, we introduce an LP rule of the same form, but the equality constraint becomes uj = vj .\nNow, we have only LP rules and need to represent the constraint: 0 \u2265 maxy \u2211\nj ej(y). To represent such a constraint, we follow an algorithm very similar to the variable elimination procedure in Section 8.4. The main difference occurs in the MaxOut (f,B) operation in Figure 13. Instead of generating new value rules, we generate new LP rules, with associated new variables and new constraints. The simplest case occurs when computing a split or adding two LP rules. For example, when we add two value rules in the original algorithm, we instead perform the following operation on their associated LP rules: If the LP rules are \u3008c : ui\u3009 and \u3008c : uj\u3009, we replace these by a new rule \u3008c : uk\u3009, associated with a new LP variable uk with context c, whose value should be ui +uj . To enforce this value constraint, we simply add an additional constraint to the LP: uk = ui + uj. A similar procedure can be followed when computing the split.\nMore interesting constraints are generated when we perform a maximization. In the rule-based variable elimination algorithm in Figure 13, this maximization occurs when we replace a set of rules:\n\u3008c \u2227B = bi : vi\u3009,\u2200bi \u2208 Dom(B),\nby a new rule \u2329 c : max\ni vi\n\u232a .\nFollowing the same process as in the LP rule summation above, if we are maximizing\nei = \u3008c \u2227B = bi : ui\u3009,\u2200bi \u2208 Dom(B),\nwe generate a new LP variable uk associated with the rule ek = \u3008c : uk\u3009. However, we cannot add the nonlinear constraint uk = maxi ui, but we can add a set of equivalent linear\nconstraints uk \u2265 ui, \u2200i.\nTherefore, using these simple operations, we can exploit structure in the rule functions to represent the nonlinear constraint en \u2265 maxy \u2211 j ej(y), where en is the very last LP rule we generate. A final constraint un = \u03c6 implies that we are representing exactly the constraints in Equation (12), without having to enumerate every state.\nThe correctness of our rule-based factored LP construction is a corollary of Theorem 4.4 and of the correctness of the rule-based variable elimination algorithm (Zhang & Poole, 1999) .\nCorollary 8.14 The constraints generated by the rule-based factored LP construction are equivalent to the non-linear constraint in Equation (12). That is, an assignment to (\u03c6,w) satisfies the rule-based factored LP constraints if and only if it satisfies the constraint in Equation (12).\nThe number of variables and constraints in the rule-based factored LP is linear in the number of rules generated by the variable elimination process. In turn, the number of rules is no larger, and often exponentially smaller, than the number of entries in the table-based approach.\nTo illustrate the generation of LP constraints as just described, we now present a small example:\nExample 8.15 Let e1, e2, e3, and e4 be the set of LP rules which depend on the variable b being maximized. Here, rule ei is associated with the LP variable ui:\ne1 = \u3008a \u2227 b : u1\u3009, e2 = \u3008a \u2227 b \u2227 c : u2\u3009, e3 = \u3008a \u2227 \u00acb : u3\u3009, e4 = \u3008a \u2227 b \u2227 \u00acc : u4\u3009.\nIn this set, note that rules e1 and e2 are consistent. We combine them to generate the following rules:\ne5 = \u3008a \u2227 b \u2227 c : u5\u3009, e6 = \u3008a \u2227 b \u2227 \u00acc : u1\u3009.\nand the constraint u1 + u2 = u5. Similarly, e6 and e4 may be combined, resulting in:\ne7 = \u3008a \u2227 b \u2227 \u00acc : u6\u3009.\nwith the constraint u6 = u1 + u4. Now, we have the following three inconsistent rules for the maximization:\ne3 = \u3008a \u2227 \u00acb : u3\u3009, e5 = \u3008a \u2227 b \u2227 c : u5\u3009, e7 = \u3008a \u2227 b \u2227 \u00acc : u6\u3009.\nFollowing the maximization procedure, since no pair of rules can be eliminated right away, we split e3 and e5 to generate the following rules:\ne8 = \u3008a \u2227 \u00acb \u2227 c : u3\u3009, e9 = \u3008a \u2227 \u00acb \u2227 \u00acc : u3\u3009, e5 = \u3008a \u2227 b \u2227 c : u5\u3009.\nWe can now maximize b out from e8 and e5, resulting in the following rule and constraints respectively:\ne10 = \u3008a \u2227 c : u7\u3009, u7 \u2265 u5, u7 \u2265 u3.\nLikewise, maximizing b out from e9 and e6, we get:\ne11 = \u3008a \u2227 \u00acc : u8\u3009, u8 \u2265 u3, u8 \u2265 u6;\nwhich completes the elimination of variable b in our rule-based factored LP.\nWe have presented an algorithm for exploiting both additive and context-specific structure in the LP construction steps of our planning algorithms. This rule-based factored LP approach can now be applied directly in our approximate linear programming and approximate policy iteration algorithms, which were presented in Sections 5 and 6.\nThe only additional modification required concerns the manipulation of the decision list policies presented in Section 6.2. Although approximate linear programming does not require any explicit policy representation (or the default action model), approximate policy iteration require us to represent such policy. Fortunately, no major modifications are required in the rule-based case. In particular, the conditionals \u3008ti, ai, \u03b4i\u3009 in the decision list policies are already context-specific rules. Thus, the policy representation algorithm in Section 6.2 can be applied directly with our new rule-based representation. Therefore, we now have a complete framework for exploiting both additive and context-specific structure for efficient planning in factored MDPs."}, {"heading": "9. Experimental Results", "text": "The factored representation of a value function is most appropriate in certain types of systems: Systems that involve many variables, but where the strong interactions between the variables are fairly sparse, so that the decoupling of the influence between variables does not induce an unacceptable loss in accuracy. As argued by Herbert Simon (1981) in \u201cArchitecture of Complexity,\u201d many complex systems have a \u201cnearly decomposable, hierarchical structure,\u201d with the subsystems interacting only weakly between themselves. To evaluate our algorithm, we selected problems that we believe exhibit this type of structure.\nIn this section, we perform various experiments intended to explore the performance of our algorithms. First, we compare our factored approximate linear programming (LP) and approximate policy iteration (PI) algorithms. We also compare to the L2-projection algorithm of Koller and Parr (2000). Our second evaluation compares a table-based implementation to a rule-based implementation that can exploit CSI. Finally, we present comparisons between our approach and the algorithms of Boutilier et al. (2000)."}, {"heading": "9.1 Approximate LP and Approximate PI", "text": "In order to compare our approximate LP and approximate PI algorithms, we tested both on the SysAdmin problem described in detail in Section 2.1. This problem relates to a system\nadministrator who has to maintain a network of computers; we experimented with various network architectures, shown in Figure 1. Machines fail randomly, and a faulty machine increases the probability that its neighboring machines will fail. At every time step, the SysAdmin can go to one machine and reboot it, causing it to be working in the next time step with high probability. Recall that the state space in this problem grows exponentially in the number of machines in the network, that is, a problem withmmachines has 2m states. Each machine receives a reward of 1 when working (except in the ring, where one machine receives a reward of 2, to introduce some asymmetry), a zero reward is given to faulty machines, and the discount factor is \u03b3 = 0.95. The optimal strategy for rebooting machines will depend upon the topology, the discount factor, and the status of the machines in the network. If machine i and machine j are both faulty, the benefit of rebooting i must be weighed against the expected discounted impact of delaying rebooting j on j\u2019s successors. For topologies such as rings, this policy may be a function of the status of every single machine in the network.\nThe basis functions used included independent indicators for each machine, with value 1 if it is working and zero otherwise (i.e., each one is a restricted scope function of a single variable), and the constant basis, whose value is 1 for all states. We selected straightforward variable elimination orders: for the \u201cStar\u201d and \u201cThree Legs\u201d topologies, we first eliminated the variables corresponding to computers in the legs, and the center computer (server) was eliminated last; for \u201cRing,\u201d we started with an arbitrary computer and followed the ring order; for \u201cRing and Star,\u201d the ring machines were eliminated first and then the center one; finally, for the \u201cRing of Rings\u201d topology, we eliminated the computers in the outer rings first and then the ones in the inner ring.\nWe implemented the factored policy iteration and linear programming algorithms in Matlab, using CPLEX as the LP solver. Experiments were performed on a Sun UltraSPARCII, 359 MHz with 256MB of RAM. To evaluate the complexity of the approximate policy iteration with max-norm projection algorithm, tests were performed with increasing the number of states, that is, increasing number of machines on the network. Figure 14 shows the running time for increasing problem sizes, for various architectures. The simplest one is the \u201cStar,\u201d where the backprojection of each basis function has scope restricted to two variables and the largest factor in the cost network has scope restricted to two variables. The most difficult one was the \u201cBidirectional Ring,\u201d where factors contain five variables.\nNote that the number of states is growing exponentially (indicated by the log scale in Figure 14), but running times increase only logarithmically in the number of states, or polynomially in the number of variables. We illustrate this behavior in Figure 14(d), where we fit a 3rd order polynomial to the running times for the \u201cunidirectional ring.\u201d Note that the size of the problem description grows quadratically with the number of variables: adding a machine to the network also adds the possible action of fixing that machine. For this problem, the computation cost of our factored algorithm empirically grows approximately as O ( (n \u00b7 |A|)1.5 ) , for a problem with n variables, as opposed to the exponential complexity \u2014 poly (2n, |A|) \u2014 of the explicit algorithm.\nFor further evaluation, we measured the error in our approximate value function relative to the true optimal value function V\u2217. Note that it is only possible to compute V\u2217 for small problems; in our case, we were only able to go up to 10 machines. For comparison, we also evaluated the error in the approximate value function produced by the L2-projection\nalgorithm of Koller and Parr (2000). As we discussed in Section 6.4, the L2 projections in factored MDPs by Koller and Parr are difficult and time consuming; hence, we were only able to compare the two algorithms for smaller problems, where an equivalent L2-projection can be implemented using an explicit state space formulation. Results for both algorithms are presented in Figure 15(a), showing the relative error of the approximate solutions to the true value function for increasing problem sizes. The results indicate that, for larger problems, the max-norm formulation generates a better approximation of the true optimal value function V\u2217 than the L2-projection. Here, we used two types of basis functions: the same single variable functions, and pairwise basis functions. The pairwise basis functions contain indicators for neighboring pairs of machines (i.e., functions of two variables). As expected, the use of pairwise basis functions resulted in better approximations.\nFor these small problems, we can also compare the actual value of the policy generated by our algorithm to the value of the optimal policy. Here, the value of the policy generated by our algorithm is much closer to the value of the optimal policy than the error implied by the difference between our approximate value function and V\u2217. For example, for the \u201cStar\u201d architecture with one server and up to 6 clients, our approximation with single variable basis functions had relative error of 12%, but the policy we generated had the same value as the optimal policy. In this case, the same was true for the policy generated by the L2 projection. In a \u201cUnidirectional Ring\u201d with 8 machines and pairwise basis, the relative error between our approximation and V\u2217 was about 10%, but the resulting policy only had a 6% loss over the optimal policy. For the same problem, the L2 approximation has a value function error of 12%, and a true policy loss was 9%. In other words, both methods induce policies that have lower errors than the errors in the approximate value function (at least for small problems). However, our algorithm continues to outperform the L2 algorithm, even with respect to actual policy loss.\nFor large models, we can no longer compute the correct value function, so we cannot evaluate our results by computing \u2016V\u2217 \u2212Hw\u2016\u221e. Fortunately, as discussed in Section 7, the Bellman error can be used to provide a bound on the approximation error and can be computed efficiently by exploiting problem-specific structure. Figure 15(b) shows that the Bellman error increases very slowly with the number of states.\nIt is also valuable to look at the actual decision-list policies generated in our experiments. First, we noted that the lists tended to be short, the length of the final decision list policy grew approximately linearly with the number of machines. Furthermore, the policy itself is often fairly intuitive. In the \u201cRing and Star\u201d architecture, for example, the decision list says: If the server is faulty, fix the server; else, if another machine is faulty, fix it.\nThus far, we have presented scaling results for running times and approximation error for our approximate PI approach. We now compare this algorithm to the simpler approximate\nLP approach of Section 5. As shown in Figure 16(a), the approximate LP algorithm for factored MDPs is significantly faster than the approximate PI algorithm. In fact, approximate PI with single-variable basis functions variables is more costly computationally than the LP approach using basis functions over consecutive triples of variables. As shown in Figure 16(b), for singleton basis functions, the approximate PI policy obtains slightly better performance for some problem sizes. However, as we increase the number of basis functions for the approximate LP formulation, the value of the resulting policy is much better. Thus, in this problem, our factored approximate linear programming formulation allows us to use more basis functions and to obtain a resulting policy of higher value, while still maintaining a faster running time. These results, along with the simpler implementation, suggest that in practice one may first try to apply the approximate linear programming algorithm before deciding to move to the more elaborate approximate policy iteration approach."}, {"heading": "9.2 Comparing Table-based and Rule-based Implementations", "text": "Our next evaluation compares a table-based representation, which exploits only additive independence, to the rule-based representation presented in Section 8, which can exploit both additive and context-specific independence. For these experiments, we implemented our factored approximate linear programming algorithm with table-based and rule-based representations in C++, using CPLEX as the LP solver. Experiments were performed on a Sun UltraSPARC-II, 400 MHz with 1GB of RAM.\nTo evaluate and compare the algorithms, we utilized a more complex extension of the SysAdmin problem. This problem, dubbed the Process-SysAdmin problem, contains three state variables for each machine i in the network: Loadi, Statusi and Selectori. Each computer runs processes and receives rewards when the processes terminate. These processes are represented by the Loadi variable, which takes values in {Idle,Loaded,Success}, and the computer receives a reward when the assignment of Loadi is Success. The Statusi variable,\nrepresenting the status of machine i, takes values in {Good, Faulty, Dead}; if its value is Faulty, then processes have a smaller probability of terminating and if its value is Dead, then any running process is lost and Loadi becomes Idle. The status of machine i can become Faulty and eventually Dead at random; however, if machine i receives a packet from a dead machine, then the probability that Statusi becomes Faulty and then Dead increases. The Selectori variable represents this communication by selecting one of the neighbors of i uniformly at random at every time step. The SysAdmin can select at most one computer to reboot at every time step. If computer i is rebooted, then its status becomes Good with probability 1, but any running process is lost, i.e., the Loadi variable becomes Idle. Thus, in this problem, the SysAdmin must balance several conflicting goals: rebooting a machine kills processes, but not rebooting a machine may cause cascading faults in network. Furthermore, the SysAdmin can only choose one machine to reboot, which imposes the additional tradeoff of selecting only one of the (potentially many) faulty or dead machines in the network to reboot.\nWe experimented with two types of basis functions: \u201csingle+\u201d includes indicators over all of the joint assignments of Loadi, Statusi and Selectori, and \u201cpair\u201d which, in addition, includes a set of indicators over Statusi, Statusj, and Selectori = j, for each neighbor j of machine i in the network. The discount factor was \u03b3 = 0.95. The variable elimination order eliminated all of the Loadi variables first, and then followed the same patterns as in the simple SysAdmin problem, eliminating first Statusi and then Selectori when machine i is eliminated.\nFigure 17 compares the running times for the table-based implementation to the ones for the rule-based representation for three topologies: \u201cStar,\u201d \u201cRing,\u201d and \u201cReverse star.\u201d The \u201cReverse star\u201d topology reverses the direction of the influences in the \u201cStar\u201d: rather than the central machine influencing all machines in the topology, all machines influence the central one. These three topologies demonstrate three different levels of CSI: In the\n\u201cStar\u201d topology, the factors generated by variable elimination are small. Thus, although the running times are polynomial in the number of state variables for both methods, the tablebased representation is significantly faster than the rule-based one, due to the overhead of managing the rules. The \u201cRing\u201d topology illustrates an intermediate behavior: \u201csingle+\u201d basis functions induce relatively small variable elimination factors, thus the table-based approach is faster. However, with \u201cpair\u201d basis the factors are larger and the rule-based approach starts to demonstrate faster running times in larger problems. Finally, the \u201cReverse star\u201d topology represents the worst-case scenario for the table-based approach. Here, the scope of the backprojection of a basis function for the central machine will involve all computers in the network, as all machines can potentially influence the central one in the next time step. Thus, the size of the factors in the table-based variable elimination approach are exponential in the number of machines in the network, which is illustrated by the exponential growth in Figure 17(c). The rule-based approach can exploit the CSI in this problem; for example, the status of the central machine Status0 only depends on machine j if the value selector is j, i.e., if Selector0 = j. By exploiting CSI, we can solve the same problem in polynomial time in the number of state variables, as seen in the second curve in Figure 17(c).\nIt is also instructive to compare the portion of the total running time spent in CPLEX for the table-based as compared to the rule-based approach. Figure 18 illustrates this comparison. Note that amount of time spent in CPLEX is significantly higher for the table-based approach. There are two reasons for this difference: first, due to CSI, the LPs generated by the rule-based approach are smaller than the table-based ones; second, rulebased variable elimination is more complex than the table-based one, due to the overhead introduced by rule management. Interestingly, the proportion of CPLEX time increases as the problem size increases, indicating that the asymptotic complexity of the LP solution is higher than that of variable elimination, thus suggesting that, for larger problems, additional large-scale LP optimization procedures, such as constraint generation, may be helpful."}, {"heading": "9.3 Comparison to Apricodd", "text": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). In particular, the approximate Apricodd algorithm of Hoey et al. (1999), which uses analytic decision diagrams (ADDs) to represent the value function is a strong alternative approach for solving factored MDPs. As discussed in detail in Section 10, the Apricodd algorithm can successfully exploit context-specific structure in the value function, by representing it with the set of mutually-exclusive and exhaustive branches of the ADD. On the other hand, our approach can exploit both additive and context-specific structure in the problem, by using a linear combination of non-mutually-exclusive rules. To better understand this difference, we evaluated both our rule-based approximate linear programming algorithm and Apricodd in two problems, Linear and Expon, designed by Boutilier et al. (2000) to illustrate respectively the best-case and the worst-case behavior of their algorithm. In these experiments, we used the web-distributed version of Apricodd (Hoey, St-Aubin, Hu, & Boutilier, 2002), running it locally on a Linux Pentium III 700MHz with 1GB of RAM.\nThese two problems involve n binary variables X1, . . . ,Xn and n deterministic actions a1, . . . , an. The reward is 1 when all variables Xk are true, and is 0 otherwise. The problem is discounted by a factor \u03b3 = 0.99. The difference between the Linear and the Expon problems is in the transition probabilities. In the Linear problem, the action ak sets the variable Xk to true and makes all succeeding variables, Xi for i > k, false. If the state space of the Linear problem is seen as a binary number, the optimal policy is to set repeatedly the largest bit (Xk variable) which has all preceding bits set to true. Using an ADD, the optimal value function for this problem can be represented in linear space, with n+1 leaves (Boutilier et al., 2000). This is the \u201cbest-case\u201d for Apricodd, and the algorithm can compute this value function quite efficiently. Figure 19(a) compares the running time of Apricodd to that of one of our algorithms with indicator basis functions between pairs of consecutive variables. Note that both algorithms obtain the same policy in polynomial time in the number of variables. However, in such structured problems, the efficient implementation of the ADD package used in Apricodd makes it faster in this problem.\nOn the other hand, the Expon problem illustrates the worst-case for Apricodd. In this problem, the action ak sets the variable Xk to true, if all preceding variables, Xi for i < k, are true, and it makes all preceding variables false. If the state space is seen as a binary number, the optimal policy goes through all binary numbers in sequence, by repeatedly setting the largest bit (Xk variable) which has all preceding bits set to true. Due to discounting, the optimal value function assigns a value of \u03b32\nn\u2212j\u22121 to the jth binary number, so that the value function contains exponentially many different values. Using an ADD, the optimal value function for this problem requires an exponential number of leaves (Boutilier et al., 2000), which is illustrated by the exponential running time in Figure 19(b). However, the same value function can be approximated very compactly as a factored linear value function using n + 1 basis functions: an indicator over each variable Xk and the constant base. As shown in Figure 19(b), using this representation, our factored approximate linear programming algorithm computes the value function in polynomial time. Furthermore, the\npolicy obtained by our approach was optimal for this problem. Thus, in this problem, the ability to exploit additive independence allows an efficient polynomial time solution.\nWe have also compared Apricodd to our rule-based approximate linear programming algorithm on the Process-SysAdmin problem. This problem has significant additive structure in the reward function and factorization in the transition model. Although this type of structure is not exploited directly by Apricodd, the ADD approximation steps performed by the algorithm can, in principle, allow Apricodd to find approximate solutions to the problem. We spent a significant amount of time attempting to find the best set of parameters for Apricodd for these problems.4 We settled on the \u201csift\u201d method of variable reordering and the \u201cround\u201d approximation method with the \u201csize\u201d (maximum ADD size) criteria. To\n4. We are very grateful to Jesse Hoey and Robert St-Aubin for their assistance in selecting the parameters.\nallow the value function representation to scale with the problem size, we set the maximum ADD size to 4000 + 400n for a network with n machines. (We experimented with a variety of different growth rates for the maximum ADD size; here, as for the other parameters, we selected the choice that gave the best results for Apricodd.) We compared Apricodd with these parameters to our rule-based approximate linear programming algorithm with \u201csingle+\u201d basis functions on a Pentium III 700MHz with 1GB of RAM. These results are summarized in Figure 20.\nOn very small problems (up to 4\u20135 machines), the performance of the two algorithms is fairly similar in terms of both the running time and the quality of the policies generated. However, as the problem size grows, the running time of Apricodd increases rapidly, and becomes significantly higher than that of our algorithm . Furthermore, as the problem size increases, the quality of the policies generated by Apricodd also deteriorates. This difference in policy quality is caused by the different value function representation used by the two algorithms. The ADDs used in Apricodd represent k different values with k leaves; thus, they are forced to agglomerate many different states and represent them using a single value. For smaller problems, such agglomeration can still represent good policies. Unfortunately, as the problem size increases and the state space grows exponentially, Apricodd\u2019s policy representation becomes inadequate, and the quality of the policies decreases. On the other hand, our linear value functions can represent exponentially many values with only k basis functions, which allows our approach to scale up to significantly larger problems."}, {"heading": "10. Related Work", "text": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). We address this comparison separately below, but we begin this section with some broader background references."}, {"heading": "10.1 Approximate MDP Solutions", "text": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993).\nWithin the AI community, value function approximation developed concomitantly with the notion of value function representations for Markov chains. Sutton\u2019s seminal paper on temporal difference learning (1988), which addressed the use of value functions for prediction but not planning, assumed a very general representation of the value function and noted the connection to general function approximators such as neural networks. However, the stability of this combination was not directly addressed at that time.\nSeveral important developments gave the AI community deeper insight into the relationship between function approximation and dynamic programming. Tsitsiklis and Van Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate MDP methods via the contraction properties of the dynamic programming operator and function approximator. Tsitsiklis and Van Roy (1996b) later established a general convergence result for linear value function approximators and TD(\u03bb), and Bertsekas and\nTsitsiklis (1996) unified a large body of work on approximate dynamic programming under the name of Neuro-dynamic Programming, also providing many novel and general error analyses.\nApproximate linear programming for MDPs using linear value function approximation was introduced by Schweitzer and Seidmann (1985), although the approach was somewhat deprecated until fairly recently due the lack of compelling error analyses and the lack of an effective method for handling the large number of constraints. Recent work by de Farias and Van Roy (2001a, 2001b) has started to address these concerns with new error bounds and constraint sampling methods. Our approach, rather than sampling constraints, utilizes structure in the model and value function to represent all of the constraints compactly."}, {"heading": "10.2 Factored Approaches", "text": "Tatman and Shachter (1990) considered the additive decomposition of value nodes in influence diagrams. A number of approaches to factoring of general MDPs have been explored in the literature. Techniques for exploiting reward functions that decompose additively were studied by Meuleau et al. (1998), and by Singh and Cohn (1998).\nThe use of factored representations such as dynamic Bayesian networks was pioneered by Boutilier et al. (1995) and has developed steadily in recent years. These methods rely on the use of context-specific structures such as decision trees or analytic decision diagrams (ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and the value function. The algorithms use dynamic programming to partition the state space, representing the partition using a tree-like structure that branches on state variables and assigns values at the leaves. The tree is grown dynamically as part of the dynamic programming process and the algorithm creates new leaves as needed: A leaf is split by the application of a DP operator when two states associated with that leaf turn out to have different values in the backprojected value function. This process can also be interpreted as a form of model minimization (Dean & Givan, 1997).\nThe number of leaves in a tree used to represent a value function determines the computational complexity of the algorithm. It also limits the number of distinct values that can be assigned to states: since the leaves represent a partitioning of the state space, every state maps to exactly one leaf. However, as was recognized early on, there are trivial MDPs which require exponentially large value functions. This observation led to a line of approximation algorithms aimed at limiting the tree size (Boutilier & Dearden, 1996) and, later, limiting the ADD size (St-Aubin, Hoey, & Boutilier, 2001). Kim and Dean (2001) also explored techniques for discovering tree-structured value functions for factored MDPs. While these methods permit good approximate solutions to some large MDPs, their complexity is still determined by the number of leaves in the representation and the number of distinct values than can be assigned to states is still limited as well.\nTadepalli and Ok (1996) were the first to apply linear value function approximation to Factored MDPs. Linear value function approximation is a potentially more expressive approximation method because it can assign unique values to every state in an MDP without requiring storage space that is exponential in the number of state variables. The expressive power of a tree with k leaves can be captured by a linear function approximator with k basis functions such that basis function hi is an indicator function that tests if a state belongs\nin the partition of leaf i. Thus, the set of value functions that can be represented by a tree with k leaves is a subset of the set of value functions that can be represented by a value function with k basis functions. Our experimental results in Section 9.3 highlight this difference by showing an example problem that requires exponentially many leaves in the value function, but that can be approximated well using a linear value function.\nThe main advantage of tree-based value functions is that their structure is determined dynamically during the solution of the MDP. In principle, as the value function representation is derived automatically from the model description, this approach requires less insight from the user. In problems for which the value function can be well approximated by a relatively small number of values, this approach provides an excellent solution to the problem. Our method of linear value function approximation aims to address what we believe to be the more common case, where a large range of distinct values is required to achieve a good approximation.\nFinally, we note that Schuurmans and Patrascu (2001), based on our earlier work on max-norm projection using cost networks and linear programs, independently developed an alternative approach to approximate linear programming using a cost network. Our method embeds a cost network inside a single linear program. By contrast, their method is based on a constraint generation approach, using a cost network to detect constraint violations. When constraint violations are found, a new constraint is added, repeatedly generating and attempting to solve LPs until a feasible solution is found. Interestingly, as the approach of Schuurmans and Patrascu uses multiple calls to variable elimination in order to speed up the LP solution step, it will be most successful when the time spent solving the LP is significantly larger than the time required for variable elimination. As suggested in Section 9.2, the LP solution time is larger for the table-based approach. Thus, Schuurmans and Patrascu\u2019s constraint generation method will probably be more successful in table-based problems than in rule-based ones."}, {"heading": "11. Conclusions", "text": "In this paper, we presented new algorithms for approximate linear programming and approximate dynamic programming (value and policy iteration) for factored MDPs. Both of these algorithms leverage on a novel LP decomposition technique, analogous to variable elimination in cost networks, which reduces an exponentially large LP to a provably equivalent, polynomial-sized one.\nOur approximate dynamic programming algorithms are motivated by error analyses showing the importance of minimizing L\u221e error. These algorithms are more efficient and substantially easier to implement than previous algorithms based on the L2-projection. Our experimental results suggest that they also perform better in practice.\nOur approximate linear programming algorithm for factored MDPs is simpler, easier to implement and more general than the dynamic programming approaches. Unlike our policy iteration algorithm, it does not rely on the default action assumption, which states that actions only affect a small number of state variables. Although this algorithm does not have the same theoretical guarantees as max-norm projection approaches, empirically it seems to be a favorable option. Our experiments suggest that approximate policy iteration tends to generate better policies for the same set of basis functions. However, due to the computa-\ntional advantages, we can add more basis functions to the approximate linear programming algorithm, obtaining a better policy and still maintaining a much faster running time than approximate policy iteration.\nUnlike previous approaches, our algorithms can exploit both additive and contextspecific structure in the factored MDP model. Typical real-world systems possess both of these types of structure. thus, this feature of our algorithms will increase the applicability of factored MDPs to more practical problems. We demonstrated that exploiting context-specific independence, by using a rule-based representation instead of the standard table-based one, can yield exponential improvements in computational time when the problem has significant amounts of CSI. However, the overhead of managing sets of rules make it less well-suited for simpler problems. We also compared our approach to the work of Boutilier et al. (2000), which exploits only context-specific structure. For problems with significant context-specific structure in the value function, their approach can be faster due to their efficient handling of the ADD representation. However, there are problems with significant context-specific structure in the problem representation, rather than in the value function, which require exponentially large ADDs. In some such problems, we demonstrated that by using a linear value function our algorithm can obtain a polynomial-time near-optimal approximation of the true value function.\nThe success of our algorithm depends on our ability to capture the most important structure in the value function using a linear, factored approximation. This ability, in turn, depends on the choice of the basis functions and on the properties of the domain. The algorithms currently require the designer to specify the factored basis functions. This is a limitation compared to the algorithms of Boutilier et al. (2000), which are fully automated. However, our experiments suggest that a few simple rules can be quite successful for designing a basis. First, we ensure that the reward function is representable by our basis. A simple basis that, in addition, contained a separate set of indicators for each variable often did quite well. We can also add indicators over pairs of variables; most simply, we can choose these according to the DBN transition model, where an indicator is added between variables Xi and each one of the variables in Parents(Xi), thus representing one-step influences. This procedure can be extended, adding more basis functions to represent more influences as required. Thus, the structure of the DBN gives us indications of how to choose the basis functions. Other sources of prior knowledge can also be included for further specifying the basis.\nNonetheless, a general algorithm for choosing good factored basis functions still does not exist. However, there are some potential approaches: First, in problems with CSI, one could apply the algorithms of Boutilier et al. for a few iterations to generate partial treestructured solutions. Indicators defined over the variables in backprojection of the leaves could, in turn, be used to generate a basis set for such problems. Second, the Bellman error computation, which can be performed efficiently as shown in Section 7, does not only provide a bound on the quality of the policy, but also the actual state where the error is largest. This knowledge can be used to create a mechanism to incrementally increase the basis set, adding new basis functions to tackle states with high Bellman error.\nThere are many other possible extensions to this work. We have already pursued extensions to collaborative multiagent systems, where multiple agents act simultaneously to maximize the global reward (Guestrin et al., 2001b), and factored POMDPs, where the\nfull state is not observed directly, but indirectly through observation variables (Guestrin, Koller, & Parr, 2001c). However, there are other settings that remain to be explored. In particular, we hope to address the problem of learning a factored MDP and planning in a competitive multiagent system.\nAdditionally, in this paper we have tackled problems where the induced width of the cost network is sufficiently low or that possess sufficient context-specific structure to allow for the exact solution of our factored LPs. Unfortunately, some practical problems may have prohibitively large induced width. We plan to leverage on ideas from loopy belief propagation algorithms for approximate inference in Bayesian networks (Pearl, 1988; Yedidia, Freeman, & Weiss, 2001) to address this issue.\nWe believe that the methods described herein significantly further extend the efficiency, applicability and general usability of factored models and value functions for the control of practical dynamic systems."}, {"heading": "Acknowledgements", "text": "We are very grateful to Craig Boutilier, Dirk Ormoneit and Uri Lerner for many useful discussions, and to the anonymous reviewers for their detailed and thorough comments. We also would like to thank Jesse Hoey, Robert St-Aubin, Alan Hu, and Craig Boutilier for distributing their algorithm and for their very useful assistance in using Apricodd and in selecting its parameters. This work was supported by the DoD MURI program, administered by the Office of Naval Research under Grant N00014-00-1-0637, by Air Force contract F30602-00-2-0598 under DARPA\u2019s TASK program, and by the Sloan Foundation. The first author was also supported by a Siebel Scholarship."}, {"heading": "Appendix A. Proofs", "text": "A.1 Proof of Lemma 3.3\nThere exists a setting to the weights \u2014 the all zero setting \u2014 that yields a bounded maxnorm projection error \u03b2P for any policy (\u03b2P \u2264 Rmax). Our max-norm projection operator chooses the set of weights that minimizes the projection error \u03b2(t) for each policy \u03c0(t). Thus, the projection error \u03b2(t) must be at least as low as the one given by the zero weights \u03b2P (which is bounded). Thus, the error remains bounded for all iterations.\nA.2 Proof of Theorem 3.5\nFirst, we need to bound our approximation of V\u03c0(t) : \u2225\u2225\u2225V\u03c0(t) \u2212Hw (t) \u2225\u2225\u2225 \u221e \u2264 \u2225\u2225\u2225T\u03c0(t)Hw (t) \u2212Hw(t) \u2225\u2225\u2225 \u221e + \u2225\u2225\u2225V\u03c0(t) \u2212 T\u03c0(t)Hw (t) \u2225\u2225\u2225 \u221e ; (triangle inequality;)\n\u2264 \u2225\u2225\u2225T\u03c0(t)Hw (t) \u2212Hw(t) \u2225\u2225\u2225 \u221e + \u03b3 \u2225\u2225\u2225V\u03c0(t) \u2212Hw (t) \u2225\u2225\u2225 \u221e ; (T\u03c0(t) is a contraction.)\nMoving the second term to the right hand side and dividing through by 1\u2212 \u03b3, we obtain:\n\u2225\u2225\u2225V\u03c0(t) \u2212Hw (t) \u2225\u2225\u2225 \u221e \u2264 1 1\u2212 \u03b3 \u2225\u2225\u2225T\u03c0(t)Hw (t) \u2212Hw(t) \u2225\u2225\u2225 \u221e = \u03b2(t) 1\u2212 \u03b3 . (24)\nFor the next part of the proof, we adapt a lemma of Bertsekas and Tsitsiklis (1996, Lemma 6.2, p.277) to fit into our framework. After some manipulation, this lemma can be reformulated as:\n\u2016V\u2217 \u2212 V\u03c0(t+1)\u2016\u221e \u2264 \u03b3 \u2016V \u2217 \u2212 V\u03c0(t)\u2016\u221e +\n2\u03b3\n1\u2212 \u03b3\n\u2225\u2225\u2225V\u03c0(t) \u2212Hw (t) \u2225\u2225\u2225 \u221e . (25)\nThe proof is concluded by substituting Equation (24) into Equation (25) and, finally, induction on t.\nA.3 Proof of Theorem 4.4\nFirst, note that the equality constraints represent a simple change of variable. Thus, we can rewrite Equation (12) in terms of these new LP variables ufizi as:\n\u03c6 \u2265 max x\n\u2211\ni\nufizi , (26)\nwhere any assignment to the weights w implies an assignment for each ufizi . After this stage, we only have LP variables.\nIt remains to show that the factored LP construction is equivalent to the constraint in Equation (26). For a system with n variables {X1, . . . ,Xn}, we assume, without loss of generality, that variables are eliminated starting from Xn down to X1. We now prove the equivalence by induction on the number of variables.\nThe base case is n = 0, so that the functions ci(x) and b(x) in Equation (12) all have empty scope. In this case, Equation (26) can be written as:\n\u03c6 \u2265 \u2211\ni\nuei . (27)\nIn this case, no transformation is done on the constraint, and equivalence is immediate.\nNow, we assume the result holds for systems with i\u22121 variables and prove the equivalence for a system with i variables. In such a system, the maximization can be decomposed into two terms: one with the factors that do not depend on Xi, which are irrelevant to the maximization over Xi, and another term with all the factors that depend on Xi. Using this decomposition, we can write Equation (26) as:\n\u03c6 \u2265 max x1,...,xi\n\u2211\nj\nu ej zj ;\n\u2265 max x1,...,xi\u22121\n  \u2211\nl : xi 6\u2208zl\nuelzl +maxxi\n\u2211\nj : xi\u2208zj\nu ej zj\n\n . (28)\nAt this point we can define new LP variables uez corresponding to the second term on the right hand side of the constraint. These new LP variables must satisfy the following constraint:\nuez \u2265 maxxi\n\u2113\u2211\nj=1\nu ej (z,xi)[Zj ] . (29)\nThis new non-linear constraint is again represented in the factored LP construction by a set of equivalent linear constraints:\nuez \u2265 \u2113\u2211\nj=1\nu ej (z,xi)[Zj] ,\u2200z, xi. (30)\nThe equivalence between the non-linear constraint Equation (29) and the set of linear constraints in Equation (30) can be shown by considering binding constraints. For each new LP variable created uez, there are |Xi| new constraints created, one for each value xi of Xi. For any assignment to the LP variables in the right hand side of the constraint in Equation (30), only one of these |Xi| constraints is relevant. That is, one where \u2211\u2113 j=1 u ej (z,xi)[Zj ] is maximal, which corresponds to the maximum over Xi. Again, if for each value of z more than one assignment to Xi achieves the maximum, then any of (and only) the constraints corresponding to those maximizing assignments could be binding. Thus, Equation (29) and Equation (30) are equivalent.\nSubstituting the new LP variables uez into Equation (28), we get:\n\u03c6 \u2265 max x1,...,xi\u22121\n\u2211\nl : xi 6\u2208zl\nuelzl + u e z,\nwhich does not depend onXi anymore. Thus, it is equivalent to a system with i\u22121 variables, concluding the induction step and the proof.\nA.4 Proof of Lemma 7.1\nFirst note that at iteration t+ 1 the objective function \u03c6(t+1) of the max-norm projection LP is given by:\n\u03c6(t+1) = \u2225\u2225\u2225Hw(t+1) \u2212 ( R\u03c0(t+1) + \u03b3P\u03c0(t+1)Hw (t+1) )\u2225\u2225\u2225\n\u221e .\nHowever, by convergence the value function estimates are equal for both iterations:\nw(t+1) = w(t).\nSo we have that:\n\u03c6(t+1) = \u2225\u2225\u2225Hw(t) \u2212 ( R\u03c0(t+1) + \u03b3P\u03c0(t+1)Hw (t) )\u2225\u2225\u2225\n\u221e .\nIn operator notation, this term is equivalent to:\n\u03c6(t+1) = \u2225\u2225\u2225Hw(t) \u2212 T\u03c0(t+1)Hw (t) \u2225\u2225\u2225 \u221e .\nNote that, \u03c0(t+1) = Greedy(Hw(t)) by definition. Thus, we have that:\nT\u03c0(t+1)Hw (t) = T \u2217Hw(t).\nFinally, substituting into the previous expression, we obtain the result:\n\u03c6(t+1) = \u2225\u2225\u2225Hw(t) \u2212 T \u2217Hw(t) \u2225\u2225\u2225 \u221e ."}], "references": [{"title": "Complexity of finding embeddings in a K-tree", "author": ["S. Arnborg", "D.G. Corneil", "A. Proskurowski"], "venue": "SIAM Journal of Algebraic and Discrete Methods,", "citeRegEx": "Arnborg et al\\.,? \\Q1987\\E", "shortCiteRegEx": "Arnborg et al\\.", "year": 1987}, {"title": "A sufficiently fast algorithm for finding close to optimal clique trees", "author": ["A. Becker", "D. Geiger"], "venue": "Artificial Intelligence,", "citeRegEx": "Becker and Geiger,? \\Q2001\\E", "shortCiteRegEx": "Becker and Geiger", "year": 2001}, {"title": "Polynomial approximation \u2013 a new computational technique in dynamic programming", "author": ["R. Bellman", "R. Kalaba", "B. Kotkin"], "venue": "Math. Comp.,", "citeRegEx": "Bellman et al\\.,? \\Q1963\\E", "shortCiteRegEx": "Bellman et al\\.", "year": 1963}, {"title": "Dynamic Programming", "author": ["R.E. Bellman"], "venue": null, "citeRegEx": "Bellman,? \\Q1957\\E", "shortCiteRegEx": "Bellman", "year": 1957}, {"title": "Nonserial Dynamic Programming", "author": ["U. Bertele", "F. Brioschi"], "venue": null, "citeRegEx": "Bertele and Brioschi,? \\Q1972\\E", "shortCiteRegEx": "Bertele and Brioschi", "year": 1972}, {"title": "Decision theoretic planning: Structural assumptions and computational leverage", "author": ["C. Boutilier", "T. Dean", "S. Hanks"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Boutilier et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 1999}, {"title": "Approximating value trees in structured dynamic programming", "author": ["C. Boutilier", "R. Dearden"], "venue": "In Proc. ICML,", "citeRegEx": "Boutilier and Dearden,? \\Q1996\\E", "shortCiteRegEx": "Boutilier and Dearden", "year": 1996}, {"title": "Exploiting structure in policy construction", "author": ["C. Boutilier", "R. Dearden", "M. Goldszmidt"], "venue": "In Proc. IJCAI,", "citeRegEx": "Boutilier et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 1995}, {"title": "Stochastic dynamic programming with factored representations", "author": ["C. Boutilier", "R. Dearden", "M. Goldszmidt"], "venue": "Artificial Intelligence,", "citeRegEx": "Boutilier et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 2000}, {"title": "Approximation Theory (2nd edition)", "author": ["E.W. Cheney"], "venue": "Chelsea Publishing Co.,", "citeRegEx": "Cheney,? \\Q1982\\E", "shortCiteRegEx": "Cheney", "year": 1982}, {"title": "The linear programming approach to approximate dynamic programming", "author": ["D. de Farias", "B. Van Roy"], "venue": "Submitted to Operations Research", "citeRegEx": "Farias and Roy,? \\Q2001\\E", "shortCiteRegEx": "Farias and Roy", "year": 2001}, {"title": "On constraint sampling for the linear programming approach to approximate dynamic programming", "author": ["D. de Farias", "B. Van Roy"], "venue": "To appear in Mathematics of Operations Research", "citeRegEx": "Farias and Roy,? \\Q2001\\E", "shortCiteRegEx": "Farias and Roy", "year": 2001}, {"title": "Planning with deadlines in stochastic domains", "author": ["T. Dean", "L.P. Kaelbling", "J. Kirman", "A. Nicholson"], "venue": "In Proceedings of the Eleventh National Conference on Artificial Intelligence", "citeRegEx": "Dean et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Dean et al\\.", "year": 1993}, {"title": "A model for reasoning about persistence and causation", "author": ["T. Dean", "K. Kanazawa"], "venue": "Computational Intelligence,", "citeRegEx": "Dean and Kanazawa,? \\Q1989\\E", "shortCiteRegEx": "Dean and Kanazawa", "year": 1989}, {"title": "Model minimization in Markov decision processes", "author": ["T. Dean", "R. Givan"], "venue": "In Proceedings of the Fourteenth National Conference on Artificial Intelligence", "citeRegEx": "Dean and Givan,? \\Q1997\\E", "shortCiteRegEx": "Dean and Givan", "year": 1997}, {"title": "Abstraction and approximate decision theoretic planning", "author": ["R. Dearden", "C. Boutilier"], "venue": "Artificial Intelligence,", "citeRegEx": "Dearden and Boutilier,? \\Q1997\\E", "shortCiteRegEx": "Dearden and Boutilier", "year": 1997}, {"title": "Bucket elimination: A unifying framework for reasoning", "author": ["R. Dechter"], "venue": "Artificial Intelligence,", "citeRegEx": "Dechter,? \\Q1999\\E", "shortCiteRegEx": "Dechter", "year": 1999}, {"title": "Stable function approximation in dynamic programming", "author": ["G. Gordon"], "venue": "In Proceedings of the Twelfth International Conference on Machine Learning,", "citeRegEx": "Gordon,? \\Q1995\\E", "shortCiteRegEx": "Gordon", "year": 1995}, {"title": "Max-norm projections for factored MDPs", "author": ["C.E. Guestrin", "D. Koller", "R. Parr"], "venue": "In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Guestrin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Guestrin et al\\.", "year": 2001}, {"title": "Multiagent planning with factored MDPs", "author": ["C.E. Guestrin", "D. Koller", "R. Parr"], "venue": "In 14th Neural Information Processing Systems", "citeRegEx": "Guestrin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Guestrin et al\\.", "year": 2001}, {"title": "Solving factored POMDPs with linear value functions", "author": ["C.E. Guestrin", "D. Koller", "R. Parr"], "venue": "In Seventeenth International Joint Conference on Artificial Intelligence (IJCAI-01) workshop on Planning under Uncertainty and Incomplete Information,", "citeRegEx": "Guestrin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Guestrin et al\\.", "year": 2001}, {"title": "Context specific multiagent coordination and planning with factored MDPs", "author": ["C.E. Guestrin", "S. Venkataraman", "D. Koller"], "venue": "In The Eighteenth National Conference on Artificial Intelligence", "citeRegEx": "Guestrin et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Guestrin et al\\.", "year": 2002}, {"title": "SPUDD: Stochastic planning using decision diagrams", "author": ["J. Hoey", "R. St-Aubin", "A. Hu", "C. Boutilier"], "venue": "In Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Hoey et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Hoey et al\\.", "year": 1999}, {"title": "Stochastic planning using decision diagrams \u2013 C implementation. http://www.cs.ubc.ca/spider/staubin/Spudd", "author": ["J. Hoey", "R. St-Aubin", "A. Hu", "C. Boutilier"], "venue": null, "citeRegEx": "Hoey et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Hoey et al\\.", "year": 2002}, {"title": "Influence diagrams", "author": ["R.A. Howard", "J.E. Matheson"], "venue": "Readings on the Principles and Applications of Decision Analysis,", "citeRegEx": "Howard and Matheson,? \\Q1984\\E", "shortCiteRegEx": "Howard and Matheson", "year": 1984}, {"title": "Decisions with Multiple Objectives: Preferences and Value Tradeoffs", "author": ["R.L. Keeney", "H. Raiffa"], "venue": null, "citeRegEx": "Keeney and Raiffa,? \\Q1976\\E", "shortCiteRegEx": "Keeney and Raiffa", "year": 1976}, {"title": "Solving factored Mdps using non-homogeneous partitioning", "author": ["Kim", "K.-E", "T. Dean"], "venue": "In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Kim et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2001}, {"title": "Triangulation of graphs \u2013 algorithms giving small total state space", "author": ["U. Kjaerulff"], "venue": "Tech. rep. TR R 90-09,", "citeRegEx": "Kjaerulff,? \\Q1990\\E", "shortCiteRegEx": "Kjaerulff", "year": 1990}, {"title": "Computing factored value functions for policies in structured MDPs", "author": ["D. Koller", "R. Parr"], "venue": "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Koller and Parr,? \\Q1999\\E", "shortCiteRegEx": "Koller and Parr", "year": 1999}, {"title": "Policy iteration for factored MDPs", "author": ["D. Koller", "R. Parr"], "venue": "In Proceedings of the Sixteenth Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Koller and Parr,? \\Q2000\\E", "shortCiteRegEx": "Koller and Parr", "year": 2000}, {"title": "Solving very large weakly-coupled Markov decision processes", "author": ["N. Meuleau", "M. Hauskrecht", "K. Kim", "L. Peshkin", "L. Kaelbling", "T. Dean", "C. Boutilier"], "venue": "In Proceedings of the 15th National Conference on Artificial Intelligence,", "citeRegEx": "Meuleau et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Meuleau et al\\.", "year": 1998}, {"title": "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl,? \\Q1988\\E", "shortCiteRegEx": "Pearl", "year": 1988}, {"title": "Markov decision processes: Discrete stochastic dynamic programming", "author": ["M.L. Puterman"], "venue": null, "citeRegEx": "Puterman,? \\Q1994\\E", "shortCiteRegEx": "Puterman", "year": 1994}, {"title": "Finding approximate separators and computing tree-width quickly", "author": ["B. Reed"], "venue": "In 24th Annual Symposium on Theory of Computing,", "citeRegEx": "Reed,? \\Q1992\\E", "shortCiteRegEx": "Reed", "year": 1992}, {"title": "Direct value-approximation for factored MDPs", "author": ["D. Schuurmans", "R. Patrascu"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Schuurmans and Patrascu,? \\Q2001\\E", "shortCiteRegEx": "Schuurmans and Patrascu", "year": 2001}, {"title": "Generalized polynomial approximations in Markovian decision processes", "author": ["P. Schweitzer", "A. Seidmann"], "venue": "Journal of Mathematical Analysis and Applications, 110,", "citeRegEx": "Schweitzer and Seidmann,? \\Q1985\\E", "shortCiteRegEx": "Schweitzer and Seidmann", "year": 1985}, {"title": "The Sciences of the Artificial (second edition)", "author": ["H.A. Simon"], "venue": null, "citeRegEx": "Simon,? \\Q1981\\E", "shortCiteRegEx": "Simon", "year": 1981}, {"title": "How to dynamically merge Markov decision processes", "author": ["S. Singh", "D. Cohn"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "Singh and Cohn,? \\Q1998\\E", "shortCiteRegEx": "Singh and Cohn", "year": 1998}, {"title": "APRICODD: Approximate policy construction using decision diagrams", "author": ["R. St-Aubin", "J. Hoey", "C. Boutilier"], "venue": "In Advances in Neural Information Processing Systems 13: Proceedings of the 2000 Conference,", "citeRegEx": "St.Aubin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "St.Aubin et al\\.", "year": 2001}, {"title": "Note on Jordan elimination, linear programming and Tchebycheff approximation", "author": ["E. Stiefel"], "venue": "Numerische Mathematik,", "citeRegEx": "Stiefel,? \\Q1960\\E", "shortCiteRegEx": "Stiefel", "year": 1960}, {"title": "Learning to predict by the methods of temporal differences", "author": ["R.S. Sutton"], "venue": "Machine Learning,", "citeRegEx": "Sutton,? \\Q1988\\E", "shortCiteRegEx": "Sutton", "year": 1988}, {"title": "Scaling up average reward reinforcmeent learning by approximating the domain models and the value function", "author": ["P. Tadepalli", "D. Ok"], "venue": "In Proceedings of the Thirteenth International Conference on Machine Learning,", "citeRegEx": "Tadepalli and Ok,? \\Q1996\\E", "shortCiteRegEx": "Tadepalli and Ok", "year": 1996}, {"title": "Dynamic programming and influence diagrams", "author": ["J.A. Tatman", "R.D. Shachter"], "venue": "IEEE Transactions on Systems, Man and Cybernetics,", "citeRegEx": "Tatman and Shachter,? \\Q1990\\E", "shortCiteRegEx": "Tatman and Shachter", "year": 1990}, {"title": "Feature-based methods for large scale dynamic programming", "author": ["J.N. Tsitsiklis", "B. Van Roy"], "venue": "Machine Learning,", "citeRegEx": "Tsitsiklis and Roy,? \\Q1996\\E", "shortCiteRegEx": "Tsitsiklis and Roy", "year": 1996}, {"title": "An analysis of temporal-difference learning with function approximation", "author": ["J.N. Tsitsiklis", "B. Van Roy"], "venue": "Technical report LIDS-P-2322,", "citeRegEx": "Tsitsiklis and Roy,? \\Q1996\\E", "shortCiteRegEx": "Tsitsiklis and Roy", "year": 1996}, {"title": "Learning and Value Function Approximation in Complex Decision Processes", "author": ["B. Van Roy"], "venue": "Ph.D. thesis,", "citeRegEx": "Roy,? \\Q1998\\E", "shortCiteRegEx": "Roy", "year": 1998}, {"title": "Tight performance bounds on greedy policies based on imperfect value functions", "author": ["R.J. Williams", "L.C.I. Baird"], "venue": null, "citeRegEx": "Williams and Baird,? \\Q1993\\E", "shortCiteRegEx": "Williams and Baird", "year": 1993}, {"title": "Generalized belief propagation", "author": ["J. Yedidia", "W. Freeman", "Y. Weiss"], "venue": "In Advances in Neural Information Processing Systems 13: Proceedings of the 2000 Conference,", "citeRegEx": "Yedidia et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Yedidia et al\\.", "year": 2001}, {"title": "On the role of context-specific independence in probabilistic reasoning", "author": ["N. Zhang", "D. Poole"], "venue": "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Zhang and Poole,? \\Q1999\\E", "shortCiteRegEx": "Zhang and Poole", "year": 1999}], "referenceMentions": [{"referenceID": 40, "context": "A common choice is the use of linear value functions as an approximation \u2014 value functions that are a linear combination of potentially non-linear basis functions (Bellman, Kalaba, & Kotkin, 1963; Sutton, 1988; Tsitsiklis & Van Roy, 1996b).", "startOffset": 163, "endOffset": 239}, {"referenceID": 8, "context": "The capability to exploit both types of structure distinguishes these algorithms differ from earlier approaches (Boutilier et al., 2000), which only exploit context-specific structure.", "startOffset": 112, "endOffset": 136}, {"referenceID": 4, "context": "Finally, we present experimental results comparing our approach to the work of Boutilier et al. (2000), illustrating some of the tradeoffs between the two methods.", "startOffset": 79, "endOffset": 103}, {"referenceID": 18, "context": "This paper is a greatly expanded version of work that was published before in Guestrin et al. (2001a), and some of the work presented in Guestrin et al.", "startOffset": 78, "endOffset": 102}, {"referenceID": 32, "context": "We briefly review the MDP framework, referring the reader to the books by Bertsekas and Tsitsiklis (1996) or Puterman (1994) for a more in-depth review.", "startOffset": 109, "endOffset": 125}, {"referenceID": 5, "context": "The idea of representing a large MDP using a factored model was first proposed by Boutilier et al. (1995). In a factored MDP, the set of states is described via a set of random variables X = {X1, .", "startOffset": 82, "endOffset": 106}, {"referenceID": 2, "context": "A very popular choice for approximating value functions is by using linear regression, as first proposed by Bellman et al. (1963). Here, we define our space of allowable value functions V \u2208 H \u2286 R via a set of basis functions:", "startOffset": 108, "endOffset": 130}, {"referenceID": 17, "context": "Averagers (Gordon, 1995) are stable and non-expansive in L\u221e, but require that the mixture weights be determined a priori.", "startOffset": 10, "endOffset": 24}, {"referenceID": 9, "context": "an overdetermined linear system of equations (Cheney, 1982).", "startOffset": 45, "endOffset": 59}, {"referenceID": 39, "context": "We use an algorithm due to Stiefel (1960), that solves this problem by linear programming: Variables: w1, .", "startOffset": 27, "endOffset": 42}, {"referenceID": 32, "context": "In practice, policy iteration tends to be faster than the linear programming approach (Puterman, 1994).", "startOffset": 86, "endOffset": 102}, {"referenceID": 35, "context": "The approximate formulation for the LP approach, first proposed by Schweitzer and Seidmann (1985), restricts the space of allowable value functions to the linear space spanned by our basis functions.", "startOffset": 67, "endOffset": 98}, {"referenceID": 45, "context": "However, the recent work of de Farias and Van Roy (2001a) provides some analysis of the error relative to that of the best possible approximation in the subspace, and some guidance as to selecting \u03b1 so as to improve the quality of the approximation.", "startOffset": 46, "endOffset": 58}, {"referenceID": 28, "context": "In the context of factored MDPs, Koller and Parr (1999) suggest a particular type of basis function, that is particularly compatible with the structure of a factored MDP.", "startOffset": 33, "endOffset": 56}, {"referenceID": 25, "context": "Fortunately, as discussed by Koller and Parr (1999), this expectation operation, or backprojection, can be performed efficiently if the transition model and the value function are both factored appropriately.", "startOffset": 29, "endOffset": 52}, {"referenceID": 5, "context": "The linearity of the value function permits a linear decomposition, where each summand in the expectation can be viewed as an independent value function and updated in a manner similar to the value iteration procedure used by Boutilier et al. (2000). We now recap the construction briefly, by first defining:", "startOffset": 226, "endOffset": 250}, {"referenceID": 16, "context": "As shown by Dechter (1999), this cost is exponential", "startOffset": 12, "endOffset": 27}, {"referenceID": 27, "context": "These issues have been confronted successfully for a large variety of practical problems in the Bayesian network community, which has benefited from a large variety of good heuristics which have been developed for the variable elimination ordering problem (Bertele & Brioschi, 1972; Kjaerulff, 1990; Reed, 1992; Becker & Geiger, 2001).", "startOffset": 256, "endOffset": 334}, {"referenceID": 33, "context": "These issues have been confronted successfully for a large variety of practical problems in the Bayesian network community, which has benefited from a large variety of good heuristics which have been developed for the variable elimination ordering problem (Bertele & Brioschi, 1972; Kjaerulff, 1990; Reed, 1992; Becker & Geiger, 2001).", "startOffset": 256, "endOffset": 334}, {"referenceID": 8, "context": "In particular, in many cases a variable has a default evolution model, which only changes if an action affects it directly (Boutilier et al., 2000).", "startOffset": 123, "endOffset": 147}, {"referenceID": 28, "context": "Fortunately, as shown by Koller and Parr (2000), the greedy policy relative to a factored value function has the form of a decision list.", "startOffset": 25, "endOffset": 48}, {"referenceID": 28, "context": "It is instructive to compare our max-norm policy iteration algorithm to the L2-projection policy iteration algorithm of Koller and Parr (2000) in terms of computational costs per iteration and implementation complexity.", "startOffset": 120, "endOffset": 143}, {"referenceID": 3, "context": "This can be achieved by using the Bellman error analysis of Williams and Baird (1993). The Bellman error is defined as BellmanErr(V) = \u2016T \u2217V \u2212 V\u2016\u221e.", "startOffset": 34, "endOffset": 86}, {"referenceID": 3, "context": "Thus, we can use the Bellman error BellmanErr(H\u0175) to evaluate the quality of our resulting greedy policy. Note that computing the Bellman error involves a maximization over the state space. Thus, the complexity of this computation grows exponentially with the number of state variables. Koller and Parr (2000) suggested that structure in the factored MDP can be exploited to compute the Bellman error efficiently.", "startOffset": 21, "endOffset": 310}, {"referenceID": 7, "context": "(Boutilier et al., 1995; Dearden & Boutilier, 1997; Boutilier, Dean, & Hanks, 1999; Boutilier et al., 2000) have developed a set of algorithms which can exploit CSI in the transition and reward models to perform efficient (approximate) planning.", "startOffset": 0, "endOffset": 107}, {"referenceID": 8, "context": "(Boutilier et al., 1995; Dearden & Boutilier, 1997; Boutilier, Dean, & Hanks, 1999; Boutilier et al., 2000) have developed a set of algorithms which can exploit CSI in the transition and reward models to perform efficient (approximate) planning.", "startOffset": 0, "endOffset": 107}, {"referenceID": 7, "context": "The most common are decision trees (Boutilier et al., 1995), algebraic decision diagrams (ADDs) (Hoey, St-Aubin, Hu, & Boutilier, 1999), and rules (Zhang & Poole, 1999).", "startOffset": 35, "endOffset": 59}, {"referenceID": 5, "context": "The most common are decision trees (Boutilier et al., 1995), algebraic decision diagrams (ADDs) (Hoey, St-Aubin, Hu, & Boutilier, 1999), and rules (Zhang & Poole, 1999). We choose to use rules as our basic representation, for two main reasons. First, the rule-based representation allows a fairly simple algorithm for variable elimination, which is a key operation in our framework. Second, rules are not required to be mutually exclusive and exhaustive, a requirement that can be restrictive if we want to exploit additive independence, where functions can be represented as a linear combination of a set of non-mutually exclusive functions. We begin by describing the rule-based representation (along the lines of Zhang and Poole\u2019s presentation (1999)) for the probabilistic transition model, in particular, the CPDs of our DBN model.", "startOffset": 36, "endOffset": 754}, {"referenceID": 5, "context": "This notion of a rule-based function is related to the tree-structure functions used by Boutilier et al. (2000), but is substantially more general.", "startOffset": 88, "endOffset": 112}, {"referenceID": 16, "context": "1, which, in turn, was exponential only in the induced width of the cost network graph (Dechter, 1999).", "startOffset": 87, "endOffset": 102}, {"referenceID": 31, "context": "As argued by Herbert Simon (1981) in \u201cArchitecture of Complexity,\u201d many complex systems have a \u201cnearly decomposable, hierarchical structure,\u201d with the subsystems interacting only weakly between themselves.", "startOffset": 21, "endOffset": 34}, {"referenceID": 25, "context": "We also compare to the L2-projection algorithm of Koller and Parr (2000). Our second evaluation compares a table-based implementation to a rule-based implementation that can exploit CSI.", "startOffset": 50, "endOffset": 73}, {"referenceID": 5, "context": "Finally, we present comparisons between our approach and the algorithms of Boutilier et al. (2000).", "startOffset": 75, "endOffset": 99}, {"referenceID": 28, "context": "algorithm of Koller and Parr (2000). As we discussed in Section 6.", "startOffset": 13, "endOffset": 36}, {"referenceID": 5, "context": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). In particular, the approximate Apricodd algorithm of Hoey et al.", "startOffset": 88, "endOffset": 112}, {"referenceID": 5, "context": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). In particular, the approximate Apricodd algorithm of Hoey et al. (1999), which uses analytic decision diagrams (ADDs) to represent the value function is a strong alternative approach for solving factored MDPs.", "startOffset": 88, "endOffset": 185}, {"referenceID": 5, "context": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). In particular, the approximate Apricodd algorithm of Hoey et al. (1999), which uses analytic decision diagrams (ADDs) to represent the value function is a strong alternative approach for solving factored MDPs. As discussed in detail in Section 10, the Apricodd algorithm can successfully exploit context-specific structure in the value function, by representing it with the set of mutually-exclusive and exhaustive branches of the ADD. On the other hand, our approach can exploit both additive and context-specific structure in the problem, by using a linear combination of non-mutually-exclusive rules. To better understand this difference, we evaluated both our rule-based approximate linear programming algorithm and Apricodd in two problems, Linear and Expon, designed by Boutilier et al. (2000) to illustrate respectively the best-case and the worst-case behavior of their algorithm.", "startOffset": 88, "endOffset": 913}, {"referenceID": 8, "context": "Using an ADD, the optimal value function for this problem can be represented in linear space, with n+1 leaves (Boutilier et al., 2000).", "startOffset": 110, "endOffset": 134}, {"referenceID": 8, "context": "Using an ADD, the optimal value function for this problem requires an exponential number of leaves (Boutilier et al., 2000), which is illustrated by the exponential running time in Figure 19(b).", "startOffset": 99, "endOffset": 123}, {"referenceID": 5, "context": "The most closely related work to ours is a line of research that began with the work of Boutilier et al. (1995). We address this comparison separately below, but we begin this section with some broader background references.", "startOffset": 88, "endOffset": 112}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s.", "startOffset": 63, "endOffset": 78}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993).", "startOffset": 63, "endOffset": 199}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993). Within the AI community, value function approximation developed concomitantly with the notion of value function representations for Markov chains. Sutton\u2019s seminal paper on temporal difference learning (1988), which addressed the use of value functions for prediction but not planning, assumed a very general representation of the value function and noted the connection to general function approximators such as neural networks.", "startOffset": 63, "endOffset": 620}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993). Within the AI community, value function approximation developed concomitantly with the notion of value function representations for Markov chains. Sutton\u2019s seminal paper on temporal difference learning (1988), which addressed the use of value functions for prediction but not planning, assumed a very general representation of the value function and noted the connection to general function approximators such as neural networks. However, the stability of this combination was not directly addressed at that time. Several important developments gave the AI community deeper insight into the relationship between function approximation and dynamic programming. Tsitsiklis and Van Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate MDP methods via the contraction properties of the dynamic programming operator and function approximator.", "startOffset": 63, "endOffset": 1102}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993). Within the AI community, value function approximation developed concomitantly with the notion of value function representations for Markov chains. Sutton\u2019s seminal paper on temporal difference learning (1988), which addressed the use of value functions for prediction but not planning, assumed a very general representation of the value function and noted the connection to general function approximators such as neural networks. However, the stability of this combination was not directly addressed at that time. Several important developments gave the AI community deeper insight into the relationship between function approximation and dynamic programming. Tsitsiklis and Van Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate MDP methods via the contraction properties of the dynamic programming operator and function approximator.", "startOffset": 63, "endOffset": 1136}, {"referenceID": 3, "context": "The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the 1950\u2019s. The importance of value function approximation was recognized at an early stage by Bellman himself (1963). In the early 1990\u2019s the MDP framework was recognized by AI researchers as a formal framework that could be used to address the problem of planning under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993). Within the AI community, value function approximation developed concomitantly with the notion of value function representations for Markov chains. Sutton\u2019s seminal paper on temporal difference learning (1988), which addressed the use of value functions for prediction but not planning, assumed a very general representation of the value function and noted the connection to general function approximators such as neural networks. However, the stability of this combination was not directly addressed at that time. Several important developments gave the AI community deeper insight into the relationship between function approximation and dynamic programming. Tsitsiklis and Van Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate MDP methods via the contraction properties of the dynamic programming operator and function approximator. Tsitsiklis and Van Roy (1996b) later established a general convergence result for linear value function approximators and TD(\u03bb), and Bertsekas and", "startOffset": 63, "endOffset": 1313}, {"referenceID": 35, "context": "Approximate linear programming for MDPs using linear value function approximation was introduced by Schweitzer and Seidmann (1985), although the approach was somewhat deprecated until fairly recently due the lack of compelling error analyses and the lack of an effective method for handling the large number of constraints.", "startOffset": 100, "endOffset": 131}, {"referenceID": 22, "context": "These methods rely on the use of context-specific structures such as decision trees or analytic decision diagrams (ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and the value function.", "startOffset": 121, "endOffset": 140}, {"referenceID": 25, "context": "Techniques for exploiting reward functions that decompose additively were studied by Meuleau et al. (1998), and by Singh and Cohn (1998).", "startOffset": 85, "endOffset": 107}, {"referenceID": 25, "context": "Techniques for exploiting reward functions that decompose additively were studied by Meuleau et al. (1998), and by Singh and Cohn (1998). The use of factored representations such as dynamic Bayesian networks was pioneered by Boutilier et al.", "startOffset": 85, "endOffset": 137}, {"referenceID": 5, "context": "The use of factored representations such as dynamic Bayesian networks was pioneered by Boutilier et al. (1995) and has developed steadily in recent years.", "startOffset": 87, "endOffset": 111}, {"referenceID": 5, "context": "The use of factored representations such as dynamic Bayesian networks was pioneered by Boutilier et al. (1995) and has developed steadily in recent years. These methods rely on the use of context-specific structures such as decision trees or analytic decision diagrams (ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and the value function. The algorithms use dynamic programming to partition the state space, representing the partition using a tree-like structure that branches on state variables and assigns values at the leaves. The tree is grown dynamically as part of the dynamic programming process and the algorithm creates new leaves as needed: A leaf is split by the application of a DP operator when two states associated with that leaf turn out to have different values in the backprojected value function. This process can also be interpreted as a form of model minimization (Dean & Givan, 1997). The number of leaves in a tree used to represent a value function determines the computational complexity of the algorithm. It also limits the number of distinct values that can be assigned to states: since the leaves represent a partitioning of the state space, every state maps to exactly one leaf. However, as was recognized early on, there are trivial MDPs which require exponentially large value functions. This observation led to a line of approximation algorithms aimed at limiting the tree size (Boutilier & Dearden, 1996) and, later, limiting the ADD size (St-Aubin, Hoey, & Boutilier, 2001). Kim and Dean (2001) also explored techniques for discovering tree-structured value functions for factored MDPs.", "startOffset": 87, "endOffset": 1563}, {"referenceID": 5, "context": "The use of factored representations such as dynamic Bayesian networks was pioneered by Boutilier et al. (1995) and has developed steadily in recent years. These methods rely on the use of context-specific structures such as decision trees or analytic decision diagrams (ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and the value function. The algorithms use dynamic programming to partition the state space, representing the partition using a tree-like structure that branches on state variables and assigns values at the leaves. The tree is grown dynamically as part of the dynamic programming process and the algorithm creates new leaves as needed: A leaf is split by the application of a DP operator when two states associated with that leaf turn out to have different values in the backprojected value function. This process can also be interpreted as a form of model minimization (Dean & Givan, 1997). The number of leaves in a tree used to represent a value function determines the computational complexity of the algorithm. It also limits the number of distinct values that can be assigned to states: since the leaves represent a partitioning of the state space, every state maps to exactly one leaf. However, as was recognized early on, there are trivial MDPs which require exponentially large value functions. This observation led to a line of approximation algorithms aimed at limiting the tree size (Boutilier & Dearden, 1996) and, later, limiting the ADD size (St-Aubin, Hoey, & Boutilier, 2001). Kim and Dean (2001) also explored techniques for discovering tree-structured value functions for factored MDPs. While these methods permit good approximate solutions to some large MDPs, their complexity is still determined by the number of leaves in the representation and the number of distinct values than can be assigned to states is still limited as well. Tadepalli and Ok (1996) were the first to apply linear value function approximation to Factored MDPs.", "startOffset": 87, "endOffset": 1927}, {"referenceID": 34, "context": "Finally, we note that Schuurmans and Patrascu (2001), based on our earlier work on max-norm projection using cost networks and linear programs, independently developed an alternative approach to approximate linear programming using a cost network.", "startOffset": 22, "endOffset": 53}, {"referenceID": 4, "context": "We also compared our approach to the work of Boutilier et al. (2000), which exploits only context-specific structure.", "startOffset": 45, "endOffset": 69}, {"referenceID": 4, "context": "We also compared our approach to the work of Boutilier et al. (2000), which exploits only context-specific structure. For problems with significant context-specific structure in the value function, their approach can be faster due to their efficient handling of the ADD representation. However, there are problems with significant context-specific structure in the problem representation, rather than in the value function, which require exponentially large ADDs. In some such problems, we demonstrated that by using a linear value function our algorithm can obtain a polynomial-time near-optimal approximation of the true value function. The success of our algorithm depends on our ability to capture the most important structure in the value function using a linear, factored approximation. This ability, in turn, depends on the choice of the basis functions and on the properties of the domain. The algorithms currently require the designer to specify the factored basis functions. This is a limitation compared to the algorithms of Boutilier et al. (2000), which are fully automated.", "startOffset": 45, "endOffset": 1060}, {"referenceID": 31, "context": "We plan to leverage on ideas from loopy belief propagation algorithms for approximate inference in Bayesian networks (Pearl, 1988; Yedidia, Freeman, & Weiss, 2001) to address this issue.", "startOffset": 117, "endOffset": 163}], "year": 2011, "abstractText": "This paper addresses the problem of planning under uncertainty in large Markov Decision Processes (MDPs). Factored MDPs represent a complex state space using state variables and the transition model using a dynamic Bayesian network. This representation often allows an exponential reduction in the representation size of structured MDPs, but the complexity of exact solution algorithms for such MDPs can grow exponentially in the representation size. In this paper, we present two approximate solution algorithms that exploit structure in factored MDPs. Both use an approximate value function represented as a linear combination of basis functions, where each basis function involves only a small subset of the domain variables. A key contribution of this paper is that it shows how the basic operations of both algorithms can be performed efficiently in closed form, by exploiting both additive and context-specific structure in a factored MDP. A central element of our algorithms is a novel linear program decomposition technique, analogous to variable elimination in Bayesian networks, which reduces an exponentially large LP to a provably equivalent, polynomial-sized one. One algorithm uses approximate linear programming, and the second approximate dynamic programming. Our dynamic programming algorithm is novel in that it uses an approximation based on max-norm, a technique that more directly minimizes the terms that appear in error bounds for approximate MDP algorithms. We provide experimental results on problems with over 10 states, demonstrating a promising indication of the scalability of our approach, and compare our algorithm to an existing state-of-the-art approach, showing, in some problems, exponential gains in computation time.", "creator": "dvips(k) 5.90a Copyright 2002 Radical Eye Software"}}}