{"id": "1202.3538", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Feb-2012", "title": "Refinement Modal Logic", "abstract": "in this paper we emphasize refinement modal logic. a refinement is like a bisimulation, except that from the three interface requirements only'atoms'become'components'need to be satisfied. our logic contains a new operator'forall'in additional to the standard modalities'box'for each agent. the operator'forall'acts as a quantifier over the set of defined refinements of a given model. we call it the refinement operator. as a variation on a bisimulation quantifier, it can be seen as a refinement defined over a variable function ordered in the formula bound by the operator. the logic combines from simplicity given multi - agent modal logic upon some powers of monadic function order quantification. operators receive a plausible and complete axiomatization of multiagent refinement modal logic. we also present an extension of the operator to the modal mu - modules, and an axiomatization for the single - agent components of this logic. examples and questions are also discussed : simple software theory and design ( the set of agents can also be seen in strict set of actions ), corresponding to dynamic evolutionary logic. we further give sufficient results covering the complexity of satisfiability, and on succinctness.", "histories": [["v1", "Thu, 16 Feb 2012 09:13:18 GMT  (60kb)", "https://arxiv.org/abs/1202.3538v1", null], ["v2", "Wed, 25 Dec 2013 09:29:30 GMT  (71kb)", "http://arxiv.org/abs/1202.3538v2", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["laura bozzelli", "hans van ditmarsch", "tim french", "james hales", "sophie pinchinat"], "accepted": false, "id": "1202.3538"}, "pdf": {"name": "1202.3538.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Laura Bozzelli", "Hans van Ditmarsch", "Tim French", "James Hales", "Sophie Pinchinat"], "emails": ["laura.bozzelli@fi.upm.es", "hans.van-ditmarsch@loria.fr", "tim@csse.uwa.edu.au", "james@csse.uwa.edu.au", "Sophie.Pinchinat@irisa.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 2.\n35 38\nv2 [\ncs .L\nO ]\n2 5\nContents"}, {"heading": "1 Introduction 2", "text": ""}, {"heading": "2 Technical preliminaries 5", "text": ""}, {"heading": "3 Refinement 8", "text": "3.1 Refinement and its basic properties . . . . . . . . . . . . . . . . . . . . . . 8 3.2 Game and logical characterization of refinement . . . . . . . . . . . . . . . 10 3.3 Refinement as bisimulation plus model restriction . . . . . . . . . . . . . . 13 3.4 Refinement and action models . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.5 Modal specifications refinement . . . . . . . . . . . . . . . . . . . . . . . . 16\n\u2217Informa\u0301tica, Universidad Polite\u0301cnica de Madrid, Spain, laura.bozzelli@fi.upm.es \u2020LORIA, CNRS \u2013 Universite\u0301 de Lorraine, France, hans.van-ditmarsch@loria.fr \u2021Computer Science and Software Engineering, University of Western Australia, tim@csse.uwa.edu.au \u00a7Computer Science and Software Engineering, University of Western Australia, james@csse.uwa.edu.au \u00b6IRISA, University of Rennes, Sophie.Pinchinat@irisa.fr"}, {"heading": "4 Refinement modal logic 16", "text": "4.1 Syntax and semantics of refinement modal logic . . . . . . . . . . . . . . . 16 4.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 4.3 Refinement quantification is bisimulation quantification plus relativization 21 4.4 Alternating refinement relations . . . . . . . . . . . . . . . . . . . . . . . . 26"}, {"heading": "5 Axiomatization RML 27", "text": "5.1 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 5.2 Example derivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 5.3 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 5.4 The single-agent case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 5.5 Refinement epistemic logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 37"}, {"heading": "6 Axiomatization RML\u00b5 37", "text": "6.1 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 6.2 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44"}, {"heading": "7 Complexity 45", "text": "7.1 RML\u00b5 is non-elementary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 7.2 Succinctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51"}, {"heading": "8 Conclusions and perspectives 56", "text": ""}, {"heading": "1 Introduction", "text": "Modal logic is frequently used for modelling knowledge in multi-agent systems. The semantics of modal logic uses the notion of \u201cpossible worlds\u201d, between which an agent is unable to distinguish. In dynamic systems agents acquire new knowledge (say by an announcement, or the execution of some action) that allows agents to distinguish between worlds that they previously could not separate. From the agent\u2019s point of view, what were \u201cpossible worlds\u201d become inconceivable. Thus, a future informative event may be modelled by a reduction in the agent\u2019s accessibility relation. In [55] the future event logic is introduced. It augments the multi-agent logic of knowledge with an operation \u2200\u03d5 that stands for \u201c\u03d5 holds after all informative events\u201d \u2014 the diamond version \u2203\u03d5 stands for \u201cthere is an informative event after which \u03d5.\u201d The proposal was a generalization of a so-called arbitrary public announcement logic with an operator for \u201c\u03d5 holds after all announcements\u201d [8]. The semantics of informative events encompasses action model execution a\u0300 la Baltag et al. [9]: on finite models, it can be easily shown that a model resulting from action model execution is a refinement of the initial model, and for a given refinement of a model we can construct an action model such that the result of its execution is bisimilar to that refinement. In [56] an axiomatization of the single-agent version of this logic is presented, and also expressivity and complexity results. These questions were visited in both the context of modal logic, and of the modal \u00b5-calculus.\nIn the original motivation, the main operator \u2203 had a rather temporal sense \u2014 therefore the \u2018future event\u2019 name. However, we have come to realize that the structural transformation that interprets this operator is of much more general use, on many very different kinds of modal logic, namely anywhere where more than a mere model restriction or pruning is required. We have therefore come to call this the refinement operator, and the logic refinement modal logic.\nThus we may consider refinement modal logic to be a more abstract perspective of future event logic [55] applicable to other modal logics. To any other modal logic! This is significant in that it motivates the application of the new operator in many different settings. In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].\nLet us give an example. Consider the following structure. The \u25e6 state is the designated point. The arrows can be associated with a modality.\n\u25e6 \u2022 \u2022 \u2022\nE.g., 3332\u22a5 is true in the point. From the point of view of the modal language, this structure is essentially the same structure (it is bisimilar) as\n\u2022 \u2022 \u2022 \u25e6 \u2022 \u2022 \u2022\nThis one also satisfies 3332\u22a5 and any other modal formula for that matter. A more radical structural transformation would be to consider submodels, such as\n\u25e6 \u2022 \u2022\nA distinguishing formula between the two is 332\u22a5, which is true here and false above. Can we consider other \u2018submodel-like\u2019 transformations that are neither bisimilar structures nor strict submodels? Yes, we can. Consider\n\u2022 \u25e6 \u2022 \u2022\nIt is neither a submodel of the initial structure, nor is it bisimilar. It satisfies the formula 332\u22a5\u22273332\u22a5 that certainly is false in any submodel. We call this structure a refinement (or \u2018a refinement of the initial structure\u2019), and the original structure a simulation of the latter. Now note that if we consider the three requirements \u2018atoms\u2019, \u2018forth\u2019, and \u2018back\u2019 of a bisimulation, that \u2018atoms\u2019 and \u2018back\u2019 are satisfied but not \u2018forth\u2019, e.g., from the length-three path in the original structure the last arrow has no image. There seems to be still some \u2018submodel-like\u2019 relation with the original structure. Look at its bisimilar duplicate (the one with seven states). The last structure is a submodel of that copy.\nSuch a relation always holds: a refinement of a given structure can always be seen as the model restriction of a bisimilar copy of the given structure. This work deals with the semantic operation of refinement, as in this example, in full generality, and also applied to the multi-agent case.\nPrevious works [19, 37] employed a notion of refinement. In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose \u2014 a precursor of the dynamic epistemic logics developed later (for an overview, see [57]). This usage of refinement as a more general operation than model restriction is similar to ours.\nIn formal methods literature, see e.g. [62], refinement of datatypes is considered such that (datatype) C refines A if A simulates C. This usage of refinement as the converse of simulation [1, 11] comes close to ours \u2014 in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close. A similar usage of refinement as in [62] is found in [3, 4]. In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49]. Modal specifications are deterministic automata equipped with may-transitions and must-transitions. A must-transition is available in every component that implements the modal specification, while a may-transition need not be. This is close to our definition of refinement, as it also is some kind of submodel quantifier, but the two notions are incomparable, because \u2018must\u2019 is a subtype of \u2018may\u2019.\nWe incorporate implicit quantification over informative events directly into the language using, again, a notion of refinement; also in our case a refinement is the converse of simulation. Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22]. The refinement operator, seen as refinement quantifier, is weaker than a bisimulation quantifier [55], as it is only based on simulations rather than bisimulations, and as it only allows us to vary the interpretation of a propositional variable that does not occur in the formula bound by it. Bisimulation quantified modal logic has previously been axiomatized by providing a provably correct translation to the modal \u00b5-calculus [16]. This is reputedly a very complicated one. The axiomatization for the refinement operator, in stark contrast, is quite simple and elegant.\nOverview of the paper Section 2 gives a wide overview of our technical apparatus: modal logic, cover logic, modal \u00b5-calculus, and bisimulation quantified logic. Section 3 introduces the semantic operation of refinement. This includes a game and (modal) logical characterization. Then, in Section 4, we introduce two logics with a refinement quantifier that is interpreted with the refinement relation: refinement modal logic and refinement \u00b5-calculus. Section 5 contains the axiomatization of that refinement modal logic and the completeness proof. We demonstrate that it is equally expressive as modal logic. We mention results for model classes KD45 and S5. Section 6 gives the axiomatization of refinement \u00b5-calculus. Again, we have a reduction here, to standard \u00b5-calculus. In Section 7 we show that, although the use of refinement quantification does not change the expressive power of the logics, they do make each logic exponentially more succinct. We give a nonelementary complexity bound for refinement modal \u00b5-calculus."}, {"heading": "2 Technical preliminaries", "text": "Throughout the paper we assume a finite set of agents A and a countable set of propositional variables P as background parameters when defining the structures and the logics. Agents are named a, b, a\u2032, b\u2032, . . . , and propositional variables are p, q, r, p\u2032, p\u2032\u2032, p1, p2, . . . . Agent a is assumed female, and b male.\nStructures A model M = (S,R, V ) consists of a domain S of (factual) states (or worlds), an accessibility function R : A \u2192 P(S \u00d7 S), and a valuation V : P \u2192 P(S). States are s, t, u, v, s\u2032, . . . , s1, . . . A pair consisting of a model M (with domain S) and a state s \u2208 S is called a pointed model, for which we write Ms. For R(a) we write Ra; accessibility function R can be seen as a set of accessibility relations Ra, and V as a set of valuations V (p). Given two states s, s\u2032 in the domain, Ra(s, s\n\u2032) means that in state s agent a considers s\u2032 a possibility. We will also use a relation Ra simply as a set of pairs \u2286 S \u00d7 S, and use the abbreviation sRa = {t \u2208 S | (s, t) \u2208 Ra}. As we will be often required to discuss several models at once, we will use the convention that M = (SM , RM , V M), N = (SN , RN , V N), etc. The class of all models (given parameter sets of agents A and propositional variables P ) is denoted K. The class of all models where for all agents the accessibility relation is reflexive, transitive and symmetric is denoted S5, and the model class with a serial, transitive and euclidean accessibility relation is denoted KD45.\nThe restriction M \u2032 of a model M , notation M \u2032 \u2286 M , is a model M \u2032 = (S \u2032, R\u2032, V \u2032) such that S \u2032 \u2286 S, for each a \u2208 A, R\u2032a = Ra \u2229 (S \u2032 \u00d7 S \u2032), and for each p \u2208 P , V \u2032(p) = V (p) \u2229 S \u2032.\nMulti-agent modal logic The language L of multi-agent modal logic is inductively defined as\n\u03d5 ::= p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | 2a\u03d5\nwhere a \u2208 A and p \u2208 P . Without the construct 2a\u03d5 we get the language L0 of propositional logic. Standard abbreviations are: \u03d5 \u2228 \u03c8 iff \u00ac(\u00ac\u03d5 \u2227 \u00ac\u03c8), \u03d5 \u2192 \u03c8 iff \u00ac\u03d5 \u2228 \u03c8, \u22a4 iff p \u2228 \u00acp, \u22a5 iff p \u2227 \u00acp, and 3a\u03d5 iff \u00ac2a\u00ac\u03d5. If there is a single agent only (|A| = 1), we may write 2\u03d5 instead of 2a\u03d5. Formula variables are \u03d5, \u03c8, \u03c7, \u03d5 \u2032, . . . , \u03d51, . . . and for sets of formulas we write \u03a6,\u03a8, . . . For a finite set \u03a6 of L formulas we let the cover operator \u2207a\u03a6 be an abbreviation for 2a \u2228 \u03d5\u2208\u03a6 \u03d5 \u2227 \u2227 \u03d5\u2208\u03a6 3a\u03d5; we note \u2228 \u03d5\u2208\u2205 \u03d5 is always false, whilst \u2227 \u03d5\u2208\u2205 \u03d5 is always true. Let a finite set of formulas \u03a8 = {\u03c81, . . . , \u03c8n} and a formula \u03d5 with possible occurrences of a propositional variable p be given. Let \u03d5[\u03c8\\p] denote the substitution of all occurrences of p in \u03d5 by \u03c8. Then \u03d5[\u03a8\\p] abbreviates {\u03d5[\u03c81\\p], . . . , \u03d5[\u03c8n\\p]}, and similarly \u2228 \u03d5[\u03a8\\p]\nstands for \u03d5[\u03c81\\p] \u2228 . . . \u2228 \u03d5[\u03c8n\\p] and \u2227 \u03d5[\u03a8\\p] stands for \u03d5[\u03c81\\p] \u2227 . . . \u2227 \u03d5[\u03c8n\\p]. For example, 3a\u03a6 abbreviates {3a\u03d5 | \u03d5 \u2208 \u03a6}, and the definition of \u2207a\u03a6, above, is then written as 2a \u2228 \u03a6 \u2227 \u2227 3a\u03a6.\nWe now define the semantics of modal logic. Assume a model M = (S,R, V ). The\ninterpretation of \u03d5 \u2208 L is defined by induction.\nMs |= p iff s \u2208 Vp Ms |= \u00ac\u03d5 iff Ms 6|= \u03d5 Ms |= \u03d5 \u2227 \u03c8 iff Ms |= \u03d5 and Ms |= \u03c8 Ms |= 2a\u03d5 iff for all t \u2208 S : (s, t) \u2208 Ra implies Mt |= \u03d5\nA formula \u03d5 is valid on a model M , notation M |= \u03d5, iff for all s \u2208 S, Ms |= \u03d5; and \u03d5 is valid iff \u03d5 is valid on all M (in the model class K, given agents A and basic propositions P ). The set of validities, i.e., the logic in the stricter sense of the word, is called K.\nCover logic The cover operator \u2207 has also been used as a syntactic primitive in modal logics [16]. It has recently been axiomatized [10]. The language L\u2207 of cover logic is defined as\n\u03d5 ::= p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | \u2207a{\u03d5, . . . , \u03d5},\nwhere p \u2208 P , and a \u2208 A. The semantics of \u2207a\u03a6 is the obvious one if we recall our introduction by abbreviation of the cover operator:\nMs |= \u2207a\u03a6 iff for all \u03d5 \u2208 \u03a6 there is a t \u2208 sRa such that Mt |= \u03d5, and for all t \u2208 sRa there is a \u03d5 \u2208 \u03a6 such that Mt |= \u03d5.\nThe set of validities of cover logic is called K\u2207. The conjunction of two cover formulas is again equivalent to a cover formula:\n\u2207a\u03a6 \u2227 \u2207a\u03a8 \u21d4 \u2207a((\u03a6 \u2227 \u2228 \u03a8) \u222a (\u03a8 \u2227 \u2228 \u03a6)) .\nThe modal box and diamond are definable as 2a\u03d5 iff \u2207a\u2205\u2228\u2207a{\u03d5}, and 3a\u03d5 iff \u2207a{\u03d5,\u22a4}, respectively. Cover logic K\u2207 is equally expressive as modal logic K (also in the multi-agent version) [10, 34]. We use cover operators in the presentation of the axioms.\nModal \u00b5-calculus For the modal \u00b5-calculus, apart from the set of propositional variables P we have another parameter set X of variables to be used in the fixed-point construction. The language L\u00b5 of modal \u00b5-calculus is defined as follows.\n\u03d5 ::= x | p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | 2a\u03d5 | \u00b5x.\u03d5\nwhere a \u2208 A, x \u2208 X , p \u2208 P , and where in \u00b5x.\u03d5 the variable x only occurs positively (i.e. in the scope of an even number of negations) in the formula \u03d5. We will refer to a variable x in an expression \u00b5x.\u03d5 as a fixed-point variable. The formula \u03bdx.\u03d5 is an abbreviation for \u00ac\u00b5x.\u00ac\u03d5[\u00acx\\x]. Here, we extend the notion of substitution to modal \u00b5-calculus by ruling out the substitution of bound variables, i.e., to give the crucial clauses: (\u00b5x.\u03d5)[\u03c8\\x] = \u00b5x.\u03d5 whereas (\u00b5x.\u03d5)[\u03c8\\y] = \u00b5x.\u03d5[\u03c8\\y].\nFor the semantics of the \u00b5-calculus, the valuation V of propositional variables is extended to include fixed-point variables. We write V [x 7\u2192T ] for the operation that changes a\ngiven valuation V into one wherein V (x) = T (where T \u2286 S) and the valuation of all other fixed-point and propositional variables remains the same. Given a model M = (S,R, V ), we similarly write M [x 7\u2192T ] for the model M = (S,R, V [x 7\u2192T ]). The semantics of \u00b5x.\u03d5 (the top-down presentation, not the bottom-up presentation) is now as follows: Let \u03d5 \u2208 L\u00b5 and model M be given.\nMs |= \u00b5x.\u03d5 iff s \u2208 \u22c2 {T \u2286 S | {u | M [x 7\u2192T ]u |= \u03d5} \u2286 T}\nDisjunctive formula An important technical definition we require later on is that of a disjunctive formula. A disjunctive L\u00b5 formula is specified by the following abstract syntax:\n\u03d5 ::= x | (\u03d5 \u2228 \u03d5) | (\u03d50 \u2227 \u2227\na\u2208B\n\u2207a{\u03d5, . . . , \u03d5}) | \u00b5x.\u03d5 | \u03bdx.\u03d5 (1)\nwhere x \u2208 X , \u03d50 \u2208 L0 (propositional logic), and B \u2286 A. To get the disjunctive L formula (of modal logic) we omit the clauses containing \u00b5-calculus variables x:\n\u03d5 ::= (\u03d5 \u2228 \u03d5) | (\u03d50 \u2227 \u2227 a\u2208B \u2207a{\u03d5, . . . , \u03d5}).\nIf the context of the logic is clear, we simply write disjunctive formula (or df). If B = \u2205, we have that \u2227 a\u2208B \u2207a{\u03d51, . . . , \u03d5n} = \u22a4, as expected.\nEvery L\u00b5 formula is equivalent to a disjunctive L\u00b5 formula [31]. (2a)\nEvery L formula is equivalent to a disjunctive L formula [58]. (2b)\nBisimulation quantified modal logic The language L\u2200\u0303 is defined as\n\u03d5 ::= p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | 2a\u03d5 | \u2200\u0303p\u03d5\nwhere a \u2208 A and p \u2208 P . We let \u2203\u0303p\u03d5 abbreviate \u00ac\u2200\u0303p\u00ac\u03d5. We write \u2200\u0303 and \u2203\u0303 for the bisimulation quantifiers in order to distinguish them from the refinement quantifiers \u2200 and \u2203, to be introduced later. Given an atom p and a formula \u03d5, the expression \u2203\u0303p\u03d5 means that there exists a denotation of propositional variable p such that \u03d5. It is interpreted as follows (restricted bisimulation \u2243p is introduced further below in Definition 1):\nMs |= \u2200\u0303p\u03d5 iff for all Nt such that Nt \u2243 p Ms, Nt |= \u03d5\nIn [22, Lemma 2.43] a bisimulation quantifier characterization of fixed points is given (the details of which are deferred to Section 6 on refinement \u00b5-calculus, where they are pertinent), and from [15] we know that bisimulation quantifiers are also expressible in the modal \u00b5-calculus. For more information on the modal \u00b5-calculus, see [16, 58]."}, {"heading": "3 Refinement", "text": "In this section we define the notion of structural refinement, investigate its properties, give a game characterization in (basic) modal logic, and compare refinement to bisimulation and other established semantic notions in the literature."}, {"heading": "3.1 Refinement and its basic properties", "text": "Definition 1 (Bisimulation, simulation, refinement) Let two models M = (S,R, V ) and M \u2032 = (S \u2032, R\u2032, V \u2032) be given. A non-empty relation R \u2286 S \u00d7 S \u2032 is a bisimulation if for all (s, s\u2032) \u2208 R and a \u2208 A:\natoms s \u2208 V (p) iff s\u2032 \u2208 V \u2032(p) for all p \u2208 P ;\nforth-a for all t \u2208 S, if Ra(s, t), then there is a t \u2032 \u2208 S \u2032 such that R\u2032a(s \u2032, t\u2032) and (t, t\u2032) \u2208 R;\nback-a for all t\u2032 \u2208 S \u2032, if R\u2032a(s \u2032, t\u2032), then there is a t \u2208 S such that Ra(s, t) and (t, t \u2032) \u2208 R.\nWe write M \u2243 M \u2032 (M and M \u2032 are bisimilar) iff there is a bisimulation between M and M \u2032, and we write Ms \u2243 M \u2032 s\u2032 (Ms and M \u2032 s\u2032 are bisimilar) iff there is a bisimulation between M and M \u2032 linking s and s\u2032. A restricted bisimulation Rp : Ms \u2243 p M \u2032s\u2032 is a bisimulation that satisfies atoms for all variables except p. A total bisimulation is a bisimulation such that all states in the domain and codomain occur in a pair of the relation.\nA relation RB that satisfies atoms, back-a, and forth-a for every a \u2208 A \\ B, and that satisfies atoms, and back-b for every b \u2208 B, is a B-refinement, we say that M \u2032s\u2032 refines Ms for group of agents B, and we write Ms B M \u2032 s\u2032.\n1 An A-refinement we call a refinement (plain and simple) and for {a}-refinement we write a-refinement.\nDually to refinement, we similarly define B-simulation RB. I.e., a relation RB that satisfies atoms, back-a, and forth-a for every a \u2208 A \\B, and that satisfies atoms, and forth-b for every b \u2208 B, is a B-simulation.\nRestricted refinement and restricted simulation are defined similarly to restricted bisimulation. \u22a3\nThe definition of simulation varies slightly from the one given by Blackburn et al. [11, p.110]. Here we ensure that simulations (and refinements) preserve the interpretations (i.e., the truth and falsity) of atoms, whereas [11] has them only preserve the truth of propositional variables in a simulation\u2014and presumably preserve their falsity in a refinement. We prefer to preserve the entire interpretation, as we feel it suits our applications better. For example, in the case where refinement represents information change, we would not wish basic facts to become false in the process. The changes are supposed to be merely of information, and not factual. Another, inessential, difference with [11] is that in their case atoms and forth are required for all modalities (in the similarity type), i.e., they consider RB for B = A only.\n1We will overload the meaning of refinement and also say that M \u2032s\u2032 is a refinement of Ms\nIf RB : Ms B M \u2032 s\u2032 is a B-refinement, then the converse relation R \u2212 B ::= {(s, s \u2032) | (s\u2032, s) \u2208 RB} is a B-simulation, and if M \u2032 s\u2032 refines Ms then we can also say that Ms simulates M \u2032s\u2032. In an epistemic setting a refinement corresponds to the diminishing uncertainty of agents. This means that there is a potential decrease in the number of states and transitions in a model. On the other hand, the number of states as a consequence of refinement may also increase, because the uncertainty of agents over the extent of decreased uncertainty in other agents may still increase. This is perhaps contrary to the concept of program refinement [40] where detail is added to a specification. However, in program refinement the added detail requires a more detailed state space (i.e., extra atoms) and as such is more the domain of bisimulation quantifiers, rather than refinement quantification. Still, the consequence of program refinement is a more deterministic system which agrees with the notion of diminishing uncertainty.\nProposition 2 The relation a is reflexive and transitive (a pre-order), and satisfies the Church-Rosser property. \u22a3\nProof Reflexivity follows from the observation that the identity relation satisfies atoms, and back-a and forth-a for all agents a, and therefore also the weaker requirement for refinement. Similarly, given two a-refinements R1, andR2, we can see that their composition, {(x, z) | there is a y for which (x, y) \u2208 R1, (y, z) \u2208 R2} is also an a-refinement. This is sufficient to demonstrate transitivity. The Church-Rosser property states that if Nt a Ms and Nt a M \u2032 s\u2032 , then there is some model N \u2032 t\u2032 such that Ms a N \u2032 t\u2032 and M \u2032 s\u2032 a N \u2032 t\u2032 . From Definition 1 it follows that Ms and M \u2032 s\u2032 must be bisimilar to one another with respect to A \u2212 {a}. We may therefore construct such a model N \u2032t\u2032 by taking Ms (or M \u2032 s\u2032) and setting RN \u2032\na = \u2205 and R N \u2032 b = R M b for all b \u2208 A \u2212 {a}. It can be seen that N \u2032 t\u2032 , where\nN \u2032 = (SM , RN \u2032 , V M) and t\u2032 = s, satisfies the required properties.\nAn elementary result is the following.\nProposition 3 Let B = {a1, ..., an}, and let Ms and Mt be given. Then Ms( a1 \u25e6 \u00b7 \u00b7 \u00b7 \u25e6 an )Mt iff Ms B Mt. \u22a3\nExample 4 If Nt a Ms and Ms a Nt, it is not necessarily the case that Ms \u2243a Nt. For example, consider the one-agent models M and N where:\n\u2022 SM = {1, 2, 3}, RMa = {(1, 2), (2, 3)} and V M(p) = \u2205 for all p \u2208 P ; and\n\u2022 SN = {4, 5, 6, 7}, RNa = {(4, 5), (5, 6), (4, 7)} and V M(p) = \u2205 for all p \u2208 P .\nThese two models are clearly not bisimilar, although N4 a M1 via {(4, 1), (5, 2), (6, 3)} and M1 a N4 via {(1, 4), (2, 5), (3, 6), (2, 7)}. See Figure 1. \u22a3\nGiven that the equivalence Ms \u2261 Nt defined by Ms Nt and Ms Nt is not a bisimulation, an interesting question seems to be what it then represents. It seems to formalize that two structures are only different in resolvable differences in uncertainty (for the agent of the refinement), but not in hard and necessary facts. So the positive formulas (for that agent) should be preserved under this \u2018equivalence\u2019 \u2261. Such matters will now be addressed."}, {"heading": "3.2 Game and logical characterization of refinement", "text": "It is folklore to associate a (infinite duration) two-player game with refinement, in the spirit of [3].\nDefinition 5 (Refinement game) Let Ms and Nt be two models. We define a turn-based game Ga(Ms, Nt) between two players Spoiler and Duplicator (male and female, respectively) by Ga(Ms, Nt) = (V,E, (s, t)) where the set of positions V is partitioned into the positions VSpoiler = S M\u00d7SN of Spoiler and the positions VDuplicator = S M\u00d7[{forth, back}\u00d7 (A \u222a P )] \u00d7 SN of Duplicator. Since the initial position (s, t) \u2208 VSpoiler, Spoiler starts. The set of moves E \u2286 VSpoiler \u00d7 VDuplicator \u222a VDuplicator \u00d7 VSpoiler is the least set such that the following pairs belong to E (we take the convention that b 6= a, and for convenience, we name those moves with names similar to the properties of refinement in Definition 1):\nSpoiler\u2019s moves Move Name ((s\u2032, t\u2032), (s\u2032, (forth, p), t\u2032)) whenever s\u2032 \u2208 V M(p) forth-p? ((s\u2032, t\u2032), (s\u2032, (back, p), t\u2032)) whenever t\u2032 \u2208 V N(p) back-p? ((s\u2032, t\u2032), (s\u2032\u2032, (forth, b), t\u2032)) whenever s\u2032\u2032 \u2208 RMb (s\n\u2032) forth-b? ((s\u2032, t\u2032), (s\u2032, (back, b), t\u2032\u2032)) whenever t\u2032\u2032 \u2208 RNb (t\n\u2032) back-b? ((s\u2032, t\u2032), (s\u2032, (back, a), t\u2032\u2032)) whenever t\u2032\u2032 \u2208 RNa (t\n\u2032) back-a? Duplicator\u2019s moves\nMove Name ((s\u2032, (forth, p), t\u2032), (s\u2032, t\u2032)) whenever t\u2032 \u2208 V N(p) forth-p! ((s\u2032, (back, p), t\u2032), (s\u2032, t\u2032)) whenever s\u2032 \u2208 V M(p) back-p! ((s\u2032\u2032, (forth, b), t\u2032), (s\u2032\u2032, t\u2032\u2032)) whenever t\u2032\u2032 \u2208 RNb (t\n\u2032) forth-b! ((s\u2032, (back, b), t\u2032\u2032), (s\u2032\u2032, t\u2032\u2032)) whenever s\u2032\u2032 \u2208 RMb (s\n\u2032) back-b! ((s\u2032, (back, a), t\u2032\u2032), (s\u2032\u2032, t\u2032\u2032)) whenever s\u2032\u2032 \u2208 RMa (s \u2032) back-a!\n\u22a3\nIn the game Ga(Ms, Nt), a play is a maximal (possibly infinite) sequence of consecutive moves, or equivalently a maximal sequence of adjacentes positions in the arena. The play is winning for Duplicator if it is infinite or if it is finite and ends in position of Spoiler, otherwise, the play ends in a position of Duplicator and it is winning for Spoiler.\nA strategy of Duplicator (resp. Spoiler) is a mapping \u03c3 : V \u2217VDuplicator \u2192 V (resp. \u03c3 : V \u2217VSpoiler \u2192 V ) which recommends which moves to choose after each prefix of a play.\nA play is an outcome of a strategy for Duplicator (resp. Spoiler) if each time Duplicator (resp. Spoiler) had to play, she (resp. he) has selected the move recommended by her (resp. his) strategy. A strategy is winning if all its outcomes are winning.\nRemark 6 One easily sees that the refinement game of Definition 5 is a particular parity game [38]. Henceforth, according to [35], the refinement game is determined2, and memoryless3 strategies suffice. \u22a3\nNotice that there is no forth-a move in the game Ga(Ms, Nt), which captures the refinement relation between the structures:\nLemma 7 Ms a Nt iff Duplicator has a winning strategy in Ga(Ms, Nt). \u22a3\nProof Assume Duplicator has a winning strategy \u03c3 in Ga(Ms, Nt). By Remark 6 and without loss of generality, this winning \u03c3 can be taken to be memoryless. Namely, \u03c3 : VDuplicator \u2192 VSpoiler. Now, define the binary relation R\u03c3 \u2286 S\nM \u00d7 SN as the set of pairs (s\u2032, t\u2032) \u2208 VSpoiler that are reachable when Duplicator follows her strategy \u03c3. Then it is easy to check that R\u03c3 is an a-refinement from Ms to Nt. Also it is not difficult to see that if some a-refinement Ra exists from Ms to Nt, then any strategy of Duplicator which maintains Spoiler\u2019s positions in Ra, is winning. Note that by Definition 1 of a refinement, this is always possible for her.\nWe now consider a characterization of the refinement in terms of the logic L\u2200. Namely, given an agent a, we define the fragment of the a-positive formulas La+ \u2286 L by\nLa+ \u220b \u03d5 ::= p | \u00acp | (\u03d5 \u2227 \u03d5) | (\u03d5 \u2228 \u03d5) | 2b\u03d5 | 3b\u03d5 | 3a\u03d5\nwhere b \u2208 A \\ {a} and p \u2208 P .\nProposition 8 For any finitely branching (every state has only finitely many successors) pointed models Ms0 and Nt0, and for any agent a \u2208 A,\nMs0 a Nt0 if, and only if, for every \u03d5 \u2208 L a+, Nt0 |= \u03d5 implies Ms0 |= \u03d5. \u22a3\nProof Let us first establish that for every t \u2208 SN and s \u2208 SM , if Spoiler has a winning strategy in Ga(Ms, Nt), then there exists a formula \u03d5(s, t) \u2208 L\na+ called a distinguishing formula for (Ms, Nt), for which Nt |= \u03d5(s, t) but Ms 6|= \u03d5(s, t). Note that if Spoiler has a winning strategy in Ga(Ms, Nt), all plays induced by this strategy have finite length and end in a position where Duplicator cannot move. Moreover, by a simple application of Ko\u0308nig\u2019s Lemma (as the game graph Ga(Ms, Nt) is finitely branching), the length of those plays is bounded.\nWe reason by induction on k, the maximal length of these plays; note that because Spoiler starts, k > 0.\nIf k = 1, Spoiler has a winning move from (s, t) to some v \u2208 VDuplicator, where Duplicator is blocked. We reason on the form of v:\n2In each position, either Duplicator or Spoiler has a winning strategy from that position. 3Strategies \u03c3 that only take into account the current position in the game, instead of the entire prefix\nof the game that is currently played.\n\u2022 if v = (s, (forth, p), t) (resp. v = (s, (back, p), t)), then there is no move back to (s, t) because t 6\u2208 V N (p) (resp. s 6\u2208 V M(p)). A distinguishing formula is \u00acp (resp. p).\n\u2022 if v = (s\u2032, (forth, b), t) (resp. v = (s, (back, b), t\u2032)), then tRNb = \u2205 (resp. sR M b = \u2205).\nA distinguishing formula is 2b\u22a5 (resp. 3b\u22a4). The case v = (s, (back, a), t \u2032) is the same as (s, (back, b), t\u2032). Since forth-a moves are not allowed in the game, position v = (s\u2032, (forth, a), t) is not reachable in the game Ga(Ms, Nt), so that the formula 2a\u22a5 6\u2208 L a+ is not needed.\nAssume now that k > 1, and pick a winning strategy of Spoiler in Ga(Ms, Nt). We explore the move from the initial position (s, t) that is given by this strategy;\nbecause k > 1, this move cannot be either forth-p?, or back-p?. Three cases remain.\nforth-b? The reached position becomes (s\u2032, (forth, b), t), and from there Duplicator loses. That is, for each t\u2032 \u2208 tRNb , Spoiler wins the game Ga(Ms\u2032, Nt\u2032) in at most k \u2212 2 steps. By the induction hypothesis, there exists a distinguishing formula \u03d5(s\u2032, t\u2032) \u2208 La+ for (Ms\u2032 , Nt\u2032). It is easy to see that \u03d5(s, t) = 2b( \u2228 t\u2032\u2208tRN b \u03d5(s\u2032, t\u2032))\nis a distinguishing formula for (Ms, Nt); notice that since N is finitely branching, the conjunction is finitary.\nback-b? This case applies to b 6= a and to b = a.\nThe reached position becomes (s, (back, b), t\u2032), and from there Duplicator loses. Using a similar reasoning as for forth-b moves, it is easy to establish that there exists a formula \u03d5(s\u2032, t\u2032) \u2208 La+, such that \u03d5(s, t) = 3b( \u2227 s\u2032\u2208sRM b \u03d5(s\u2032, t\u2032)) is a distinguishing formula for (Ms, Nt); here, as M is finitely branching, a finitary disjunction is guaranteed.\nNow, according to the game characterization of refinement (Lemma 7) and the determinacy of the refinement games (Remark 6), the existence of a winning strategy for Spoiler from position (s0, t0) is equivalent to Ms0 6 a Nt0 ; this provides us with the right to left direction of the proposition.\nFor the other direction, assume Ms a Nt, and let \u03d5 \u2208 L a+ with Nt |= \u03d5. We prove that Ms |= \u03d5, by induction over the structure of the formula. Basic cases where \u03d5 is either p or \u00acp, but also the cases \u03d5 \u2227 \u03c8 and \u03d5 \u2228 \u03c8, are immediate.\nAssume Nt |= 2b\u03d5. Then for every t \u2032 \u2208 tRNb , Nt\u2032 |= \u03d5. If tR N b = \u2205, then by Property forth-b of Definition 1 this entails sRMb = \u2205 and consequently Ms |= 2b\u03d5 (whatever \u03d5 is). Otherwise, tRNb 6= \u2205. Take an arbitrary s\n\u2032 \u2208 sRMb . By Property forth-b of Definition 1, there is a t\u2032s\u2032 \u2208 tR M b with Ms\u2032 b Nt\u2032s\u2032 and Nt \u2032 s\u2032 |= \u03d5. By induction hypothesis, Ms\u2032 |= \u03d5, which entails Ms |= 2b\u03d5. Assume Nt |= 3b\u03d5, and let t\n\u2032 \u2208 tRNb be such that Nt\u2032 |= \u03d5. By Property back-b of Definition 1, there is some s\u2032 \u2208 sRMb , such that Ms\u2032 b Nt\u2032 . By induction hypothesis, Ms\u2032 |= \u03d5 which entails Ms |= 3b\u03d5.\nNote that the argument still holds if we take b = a."}, {"heading": "3.3 Refinement as bisimulation plus model restriction", "text": "A bisimulation is also a refinement, but refinement allows much more semantic variation. How much more? There is a precise relation. Semantically, a refinement is a bisimulation followed by a model restriction.\nAn a-refinement needs to satisfy back for that agent, but not forth. Let an (\u2018initial\u2019) model and a refinement of that model be given. For the sake of the exposition we assume that the initial model and the refined model are minimal, i.e., they are bisimulation contractions. Now take an arrow (a pair in the accessibility relation) in that initial model. This arrow may be missing in the refined model namely when forth is not satisfied for that arrow. On the other hand, any arrow in the refinement should be traceable to an arrow in the initial model \u2013 the back condition. There may be several arrows in the refinement that are traceable to the same arrow in the initial model, because the states in which such arrows finish may be non-bisimilar. In other words, we can see the refined model as a blowup of the initial model of which bits and pieces are cut off.\nExample 9 A simple example is as follows. Consider the structure\n\u20221 \u20222 \u20223 \u20224\nand its refinement\n\u2022b\u2032 \u2022a \u2022b \u2022c\nby way of refinement relation R = {(1, a), (2, b), (3, c), (2, b\u2032)}. The arrow (3, 4) has no image in the refined model. On the other hand, the arrow (1, 2) has two images, namely (a, b) and (a, b\u2032). These two arrows cannot be identified, because b and b\u2032 are non-bisimilar, because there is yet another arrow from b but no other arrow from b\u2032: arrow (2, 3) has only one image in the refined model. \u22a3\nThe cutting off phase can be described such that the relation to restricted bisimulation becomes clear. When expanding the initial model, the blowing up phase, make a certain propositional variable false in all states of the blowup that you want to prune (that are not in the refinement relation) and make it true in all states that you want to keep. Therefore, the blown up model is bisimilar to the initial model except for that variable. (In other words, it is a restricted bisimulation.) Then, remove arrows to states where that atom is false.\nExample 10 Continuing the previous example, consider the following structure bisimilar to the initial model, except for the value of atom p\u2014in the visualization \u2022 represents that p is true and \u25e6 represents that p is false.\n\u25e6d\u2032 \u25e6c\u2032 \u2022b\u2032 \u2022a \u2022b \u2022c \u25e6d\nThe relation R = {(1, a), (2, b), (3, c), (4, d), (2, b\u2032), (3, c\u2032), (4, d\u2032)} is a bisimulation, except for the value of p. The refinement from the previous example is a restriction of this structure, namely the result of removing the \u25e6 states and the arrows leading to those states.\u22a3\nWinding up, performing an a-refinement clearly corresponds to the following operation:\nGiven a pointed model, first choose a bisimilar pointed model, then remove some pairs from the accessibility relation for a in that model.\nGiven a propositional variable q, this has the same semantic effect as\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, such that q is (only) false in some states that are accessible for a, then remove all those pairs from the accessibility relation for a.\nIn other words:\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, then remove all pairs from the accessibility relation for a pointing to states where q is false.\nIf we do this for all agents at the same time (or if we strictly regard tree unwindings of models only), we can even see the latter operation as follows:\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, then restrict the model to the states where q is true.\nFormally, the result is as follows. First, let M be a model with accessibility relation (set of accessibility relations) R, and let R\u2032 be such that for all a \u2208 A, R\u2032a \u2286 Ra, then (analogously to a model restriction) M |R\u2032 is the model that is the same as M but with the accessibility restricted to R\u2032.\nLemma 11 Given Ms a Nt, there is an N \u2032 t (with accessibility function R \u2032) and some R\u2032\u2032 that is the same as R\u2032 except that R\u2032\u2032a \u2286 R \u2032 a, such that Ms \u2243 N \u2032 t and N \u2032 t |R \u2032\u2032 \u2243 Nt. \u22a3\nProof Let an a-refinement relation Ra \u2286 S M \u00d7 SN be given, such that (s, t) \u2208 Ra. We expand the model N and this relation Ra as follows to a model N \u2032 and a bisimulation R \u2286 SM \u00d7 SN \u2032\n. Consider SM\u2212 := S M \\R\u22121a (S N) (SM\u2212 is the set of all states in M that do not have an image in N). Now consider N \u2032 = (S \u2032, R\u2032, V \u2032) with domain S \u2032 = SN \u222aSM\u2212 , such that for each agent b (including a), (u\u2032, v\u2032) \u2208 R\u2032b iff:\n\u2022 (u\u2032, v\u2032) \u2208 RNb , or\n\u2022 (u\u2032, v\u2032) \u2208 RMb , or\n\u2022 b = a, u\u2032 \u2208 SN , v\u2032 \u2208 SM\u2212 , there is a u such that (u, u \u2032) \u2208 Ra, and (u, v \u2032) \u2208 RMa ;\nand such that V \u2032 = V N on the SN part of the domain whereas V \u2032 = V M on the new SM\u2212 part of the domain. Now define R : SM \u2192 S \u2032 as follows: (u, u\u2032) \u2208 R iff (u, u\u2032) \u2208 Ra or (u \u2208 SM\u2212 and u = u \u2032). Then R is a bisimulation linking Ms and N \u2032 t . If we restrict R \u2032 a to RNa , we get Nt back (states in the S M \u2212 part of N\n\u2032 have become unreachable). We have satisfied the proof requirement that Ms \u2243 N \u2032 t and N \u2032 t |R \u2032\u2032 a \u2243 Nt (for R \u2032\u2032 a = R N a ).\nLemma 12 Given Ms a Nt, there is an N \u2032 t (with accessibility function R \u2032) and some p \u2208 P such that Ms \u2243 p N \u2032t and N \u2032 t |R \u2032\u2032 \u2243p Nt, where R \u2032\u2032 is the same as R\u2032 except that (u, u\u2032) \u2208 R\u2032\u2032a iff N \u2032 u\u2032 |= p. \u22a3\nProof To satisfy the requirement for p, we make p false on the SM\u2212 part of the domain of N \u2032, and true anywhere else on N \u2032 (i.e., on the part of N \u2032 corresponding to the R\u22121a (S\nN) part of M). (We do not change the value of other propositional letters on N \u2032.)\nBelow, M |p is the restriction of M to the set of states satisfying p.\nProposition 13 Given Ms a Nt, there is a N \u2032 t and some p \u2208 P such that Ms \u2243 p N \u2032t and N \u2032t |p is identical to Nt except for maybe the value of p. \u22a3\nProof Clearly, in Lemma 12, N \u2032t |R \u2032\u2032 \u2243 N \u2032t |p. The model restriction gets rid of the the SM\u2212 part of N \u2032, so we now have that N \u2032t |p is identical to (and not merely bisimilar to) Nt except for maybe the value of p.\nIn Section 4.3 we build upon this semantic result by translating the logic with refinement quantifiers into the logic with bisimulation quantifiers plus relativization of formulas."}, {"heading": "3.4 Refinement and action models", "text": "We recall another important result connecting structural refinement to action model execution [9]. For full details, see [55]. An action model M = (S,R, pre) is like a model M = (S,R, V ) but with the valuation replaced by a precondition function pre : S \u2192 L (for a given language L). The elements of S are called action points. A restricted modal product (M \u2297M) consists of pairs (s, s) such that Ms |= pre(s), the product of accessibility relations namely such that ((s, s), (t, t)) \u2208 Ra iff (s, t) \u2208 Ra and (s, t) \u2208 Ra, and keeping the valuation of the state in the pair: (s, s) \u2208 V (p) iff s \u2208 V (p). A pointed action model Ms is an epistemic action.\nProposition 14 [55, Prop. 4, 5] The result of executing an epistemic action in a pointed model is a refinement of that model. Dually, for every refinement of a finite pointed model there is an epistemic action such that the result of its execution in that pointed model is a model bisimilar to the refinement. \u22a3\nIt is instructive to outline the proof of these results. Given pointed model Ms and epistemic action Ms, the resulting (M \u2297M)(s,s) is a refinement of Ms by way the relation R consisting of all pairs (t, (t, t)) such that Mt |= pre(t). Some states of the original model may get lost in the modal product, namely if there is no action whose precondition can be executed there. But all \u2018surviving\u2019 (state,action)-pairs simply can be traced back to their first argument: clearly a refinement.\nFor the other direction, construct an epistemic action Ms\u2032 that is isomorphic to a given refinement Ns\u2032 of a model Ms, but wherein valuations (determining the value of propositional variables) in states t \u2208 N are replaced by preconditions for action execution\nof the corresponding action points (also called) t. Precondition pre(t) should be satisfied in exactly those states s \u2208 M such that (s, t) \u2208 R, where R is the refinement relation linking Ms and Ns\u2032. Now in a finite model, we can single out states (up to bisimilarity) by a distinguishing formula [13]. One then shows that (M \u2297M, (s, s\u2032)) can be bisimulationcontracted to Ns\u2032. It is unknown if the finiteness restriction can be lifted, because the existence of distinguishing formulas plays a crucial part in the proof.\nExample 4.2 presents an action model and its execution in an initial information state, and we will there continue our reflections on the comparison of the frameworks."}, {"heading": "3.5 Modal specifications refinement", "text": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49]. Modal specifications are deterministic automata equipped with transitions of two types: may and must . The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45]. Informally, a must-transition is available in every component that implements the modal specification, while a may-transition need not be. Modal specifications are interpreted as logical specifications matching the conjunctive \u03bd-calculus fragment of the \u00b5-calculus [20]. In order to abstract from a particular implementation, an entire theory of modal specifications has been developed, which relies on a refinement preorder, known as modal refinement. However, although its definition is close to our definition of refinement, the two notions are incomparable: there is no way to interpret may and must as different agents (agent a and another agent b 6= a have clearly independent roles in the semantics of a-refinement), because \u2018must\u2019 is a subtype of \u2018may\u2019."}, {"heading": "4 Refinement modal logic", "text": "In this section we present the refinement modal logic, wherein we add a modal operator that we call a refinement quantifier to the language of multi-agent modal logic, or to the language of the modal \u00b5-calculus. From prior publications [55, 56] refinement modal logic is known as \u2018future event logic\u2019. In that interpretation different 2a operators stand for different epistemic operators (each describing what an agent knows), and refinement modal logic is then able express what informative events are consistent with a given information state. However, here we take a more general stance.\nWe list some relevant validities and semantic properties, and also relate the logic to well-known logical frameworks such as bisimulation quantified modal logic (by way of relativization), and dynamic epistemic logics."}, {"heading": "4.1 Syntax and semantics of refinement modal logic", "text": "The syntax and the semantics of refinement modal logic are as follows.\nDefinition 15 (Languages L\u2200 and L \u00b5 \u2200 ) Given a finite set of agents A and a countable set of propositional atoms P , the language L\u2200 of refinement modal logic is inductively defined as\n\u03d5 ::= p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | 2a\u03d5 | \u2200a\u03d5\nwhere a \u2208 A and p \u2208 P . Similarly, the language L\u00b5\u2200 of refinement \u00b5-calculus has an extra inductive clause \u00b5x.\u03d5, where X is the set of variables and x \u2208 X.\n\u03d5 ::= x | p | \u00ac\u03d5 | (\u03d5 \u2227 \u03d5) | 2a\u03d5 | \u2200a\u03d5 | \u00b5x.\u03d5 \u22a3\nWe write \u2203a\u03d5 for \u00ac\u2200a\u00ac\u03d5. For a subset {a1, . . . , an} = B \u2286 A of agents we introduce the abbreviation \u2203B\u03d5 for \u2203a1 . . .\u2203an\u03d5 (in any order), where we write \u2203\u03d5 for \u2203A\u03d5, and similarly for \u2200B and \u2200. (So in the single-agent version we are also entitled to write \u2200 and \u2203.)\nNote the two differences between bisimulation quantifiers \u2200\u0303p and the refinement quantifier \u2200. The former we write with a \u2018tilde\u2019-symbol over the quantifier. The latter (and also \u2200a) has no variable. A refinement quantifier can be seen as implicitly quantifying over a variable, namely over a variable that does not occur in the formula \u03d5 that it binds (nor should it occur in a formula of which \u2203\u03d5 is a subformula). Section 4.3 will relate bisimulation quantification to the refinement operator.\nDefinition 16 (Semantics of refinement) Assume a model M = (S,R, V ).\nMs |= \u2200a\u03d5 iff for all M \u2032 s\u2032 : Ms a M \u2032 s\u2032 implies M \u2032 s\u2032 |= \u03d5\nThe set of validities of L\u2200 is the logic RML (refinement modal logic) and the set of validities of L\u00b5\u2200 is the logic RML \u00b5 (refinement \u00b5-calculus).4 \u22a3\nIn other words, \u2200a\u03d5 is true in a pointed model iff \u03d5 is true in all its a-refinements. Typical model operations that produce an a-refinement are: blowing up the model (to a bisimilar model) such as adding copies that are indistinguishable from the current model and one another, and removing pairs of the accessibility relation for the agent a (or, alternatively worded: removing states accessible only by agent a). In the final part of this section we relate these semantics to the well-known frameworks action model logic and bisimulation quantified logic (and see also [55]).\nProposition 17 (Bisimulation invariance) Refinement modal logic and refinement \u00b5calculus are bisimulation invariant. \u22a3\nProof Bisimulation invariance is the following property: given Ms \u2243 Nt and a formula \u03d5, then Ms |= \u03d5 iff Nt |= \u03d5. If the logic has operators beyond the standard modalities 2a, this property does not automatically follow from bisimilarity.\nFor refinement modal logic bisimulation invariance is straightforward, noting that 2a is bisimulation invariant, and that \u00b5x is bisimulation invariant. The new operator \u2200a is\n4As is usual in the area, we will continue to use the term \u2018logic\u2019 in a general sense, beyond that of a set of validities.\nbisimulation invariant, because a-refinement is transitive and bisimulation is just a specific type of a-refinement. Formally, let Ms \u2243 Nt, and Ms |= \u2200a\u03d5, we have to prove that Nt |= \u2200a\u03d5. Let Ou be arbitrary such that Nt a Ou. From Ms \u2243 Nt follows Ms a Nt. From Ms a Nt and Nt a Ou follows by Proposition 2 that Ms a Ou. From Ms |= \u2200a\u03d5 and Ms a Ou follows Ou |= \u03d5. As Ou was arbitrary, we therefore conclude Nt |= \u2200a\u03d5. The reverse direction is symmetric.\nThe following result justifies our notation \u2203B for sets of agents.\nProposition 18 For all agents a, b, |= \u2203a\u2203b\u03d5 \u2194 \u2203b\u2203a\u03d5. \u22a3\nProof Let Ms be given and let Mt and Mu be such that Ms a Mt and Mt b Mu. We have that Ms( a \u25e6 b)Mu iff Ms {a,b} Mu iff Ms( b \u25e6 a)Mu. (See Proposition 3.)\nProposition 19 The following are validities of RML.\n\u2022 \u2200a\u03d5 \u2192 \u03d5 (reflexivity)\n\u2022 \u2200a\u03d5 \u2192 \u2200a\u2200a\u03d5 (transitivity)\n\u2022 \u2203a(\u03d5 \u2228 \u03c8) \u2194 (\u2203a\u03d5 \u2228 \u2203a\u03c8) and \u2200a(\u03d5 \u2227 \u03c8) \u2194 (\u2200a\u03d5 \u2227 \u2200a\u03c8)\n\u2022 \u2203a\u2200a\u03d5 \u2192 \u2200a\u2203a\u03d5 (Church-Rosser)\n\u2022 \u2203a3a\u03d5 \u2194 3a\u2203a\u03d5 \u22a3\nProof The first three items directly follow from Proposition 2. The trivial refinement is an a-refinement; composition of two refinements is a refinement; and indeed it satisfies the Church-Rosser property. The fourth item directly follows from the semantics; consider the diamond form of the equivalence: the right-to-left direction is trivial, for the left-to-right direction note that if \u03d5 \u2228 \u03c8 is true in some refinement of a given model, then \u03d5 is true or \u03c8 is true in that refinement, so \u2203a\u03d5 is true or \u2203a\u03c8 is true in the given model.\nFor the fourth, from left to right: let Ms be such that Ms |= \u2203a3a\u03d5, and let M \u2032 s\u2032 and\nt\u2032 \u2208 s\u2032R\u2032a be such that Ms a M \u2032 s\u2032 , M \u2032 s\u2032 |= 3a\u03d5, and M \u2032 t\u2032 |= \u03d5. Because of back, there is a t \u2208 sRa such that Mt a M \u2032 t\u2032 . Therefore Mt |= \u2203a\u03d5 and thus Ms |= 3a\u2203a\u03d5.\nFrom right to left: let Ms be such that Ms |= 3a\u2203a\u03d5, and let t \u2208 sRa and M \u2032 t\u2032 be such\nthat Mt a M \u2032 t\u2032 , Mt |= \u2203a\u03d5, and M \u2032 t\u2032 |= \u03d5. Consider the model N with point s that is the disjoint union of M and M \u2032 except that: all outgoing a-arrows from s in M are removed (all pairs (s, t) \u2208 Ra), a new a-arrow links s to t\n\u2032 in M \u2032 (add (s, t\u2032) to the new Ra). Then Ns is an a-refinement of Ms that, obviously, satisfies 3a\u03d5, so Ms satisfies \u2203a3a\u03d5. (This construction is typical for refinement modal logic semantics. It will reappear in various more complex forms later, e.g., in the soundness proof of the axiomatization RML.)\nThe semantics of refinement modal logic is with respect to the class K of all models (for a given set of agents and atoms). If we restrict the semantics to a specific model class only, we get a very different logic. For example \u22032\u22a5 is a validity in RML: just remove all access. But in refinement epistemic logic, interpreted on S5 models, this is not a validity: seriality of models must be preserved in every refinement. See [56, 27]."}, {"heading": "4.2 Examples", "text": "Change of knowledge Given are two agents that are uncertain about the value of a fact p, and where this is common knowledge, and where p is true. Both accessibility relations are equivalence relations, so the epistemic operators model the agents\u2019 knowledge. An informative event is possible after which a knows that p but b does not know that; this is expressed by\n\u2203a(2ap \u2227 \u00ac2b2ap)\nIn Figure 2, the initial state of information is on the left, and its refinement validating the postcondition is on the right. In the visualization the actual states are underlined. If states are accessible for both a and b we have labelled the (single) arrow with ab.\nOn the left, the formula \u2203(2ap\u2227\u00ac2b2ap) is true, because 2ap\u2227\u00ac2b2ap is true on the right. On the right, in the actual state there is no alternative for agent a (only the actual state itself is considered possible by a), so 2ap is true, whereas agent b also considers another state possible, wherein agent a considers it possible that p is false. Therefore, \u00ac2b2ap is also true in the actual state on the right.\nThe model on the right in the figure is neither an a-refinement of the model on the left, nor a b-refinement of it, but an {a, b}-refinement.\nRecalling Section 3.4 on action models, a refinement of a pointed model can also be obtained by executing an epistemic action (Proposition 14). Therefore, we should be able to see the refinement in this example as produced by an epistemic action. This is indeed the case. The epistemic action consists of two action points t and p, they can be distinguished by agent a but not by agent b. What really happens is p; it has precondition p. Agent b cannot distinguish this from t with precondition \u22a4.\nThe execution of this action is depicted in Figure 3. The point of the structure is the one with precondition p: in fact, a is learning that p, but b is uncertain between that action and the \u2018trivial\u2019 action wherein nothing is learnt. The trivial action has precondition \u22a4. It can be executed in both states of the initial model. The actual action can only be executed in the state where p is true. Therefore, the resulting structure is the refinement with three states.\nAction models can also be added as primitives to the multi-agent modal logical language and are then interpreted with a dynamic modal operator \u2014 similar to automata-PDL. To get a well-defined logical language, the set of action model frames needs to be enumerable, and therefore such action models must be finite. Thus we get action model logic. We now recall the result in Proposition 14 that on finite models every refinement corresponds to the execution of an action model and vice versa (where the action model constructed from a given refinement may be infinite), but that it is unknown if that finiteness restriction can be lifted. If that result can be generalized, that would be of interest, as that would suggest that refinement modal logic is equally expressive as action model logic with quantification over action models. If these logics were equally expressive, action model logic with quantification would be decidable\u2014a surprising fact, given that public announcement logic with quantification over public announcements (singleton action models) is undecidable [23].\nSoftware verification and design Consider a class of discrete-event systems, whose elements represent devices that interact with an environment. Each device is described by means of actions c and u, respectively called \u2018controllable\u2019 and \u2018uncontrollable\u2019 actions. Given an expected property described by some formula \u03d5, say in L\u00b5, we use refinement quantifiers to express several classic verification/synthesis problems. We let 2\u03d5 stand for 2c\u03d5 \u2227 2u\u03d5.\nThe the control problem [48], known as the question \u201cis there a way to control actions c of the system S so that property \u03d5 is guaranteed?\u201d, can be expressed in L\u2200 by wondering whether\nS |= \u2203c\u03d5 .\nThemodule checking problem [33] is the problem of determining whether an open system satisfies a given property. In other words, whether the property holds when the system is composed with an arbitrary environment. Let us say that action c is an abstract action that denotes internal ones, while action u abstracts all external actions, i.e. actions performed by the environment. Also, assume there is an atomic proposition e that distinguishes states where it is the turn of the system to act (thus only action c is available) from states where it\nis the turn of the environment (thus only action u is available). In this setting, we answer positively to the module checking problem iff S |= \u2200u\u03d5. As arbitrary environments are too permissive, we may force hypotheses such as restricting to non-blocking environments: the property can be captured by the L\u00b5-formula NonBlockingEnv := \u03bdx.(e \u21d2 3u\u22a4) \u2227 2x, which formally says that it is always the case (\u03bdx.(....) \u2227 2x) that whenever in an environment state, there is an outgoing transition from that state (e \u21d2 3u\u22a4). Now, by \u2018guarding\u2019 the universal quantification over all u-refinements (i.e. all environments) with the NonBlockingEnv assumption, the statement becomes\nS |= \u2200u(NonBlockingEnv \u21d2 \u03d5)\nThe generalized control problem is the combination of the two previous problems, by questioning the existence of a control such that the controlled system satisfies the property in all possible environments. This is expressed by wondering whether\nS |= \u2203c\u2200u(NonBlockingEnv \u21d2 \u03d5) .\nA last example is borrowed from protocol synthesis problems. Consider a specification, MUTEX, of a mutual exclusion protocol involving processes 1, 2, . . . k, and some property \u03d5 specified in L\u00b5. Now we may ask if we can find a refinement of MUTEX that satisfies \u03d5 but also such that if process i is in the critical section (csi) at time n + 1, then this is known at time n. This is expressed as\nMUTEX |= \u2203[AG(3csi \u21d2 2csi) \u2227 \u03d5]\nwhere AG is the CTL-modality, which is defined in L\u00b5 as AG(\u03c8) \u2261 \u03bdx.\u03c8\u22272x and meaning that this is true at any time. The refinement consists in moving the nondeterministic choices forward, so that a fork at time n becomes a fork at time n \u2212 1 with each branch having a single successor at time n, as depicted in Figure 4."}, {"heading": "4.3 Refinement quantification is bisimulation quantification plus", "text": "relativization\nIn Section 3.3 we presented a semantic perspective of refinement as bisimulation followed by model restriction, or, alternatively and equivalently, as a restricted bisimulation, namely except for some propositional variable, followed by a model restriction to that variable. We now lift this result to a corresponding syntactic, logical, perspective of the refinement quantifier as a bisimulation quantifier followed by relativization.\nMore precisely, in this section we will show that a refinement formula \u2203a\u03d5 is equivalent to a bisimulation quantification over a variable not occurring in \u03d5, followed by a (nonstandard) relativization for that agent to that variable, for which we write \u2203\u0303q\u03d5(a,q) (to be defined shortly). For refinement for the set of all agents (recall that we write for A, and \u2203 for \u2203A) we can expand this perspective to even more familiar ground: a refinement formula \u2203\u03d5 is equivalent to a bisimulation quantification over a variable not in \u03d5 followed\nby (standard) relativization to that variable: \u2203\u0303q\u03d5q. These results immediately clarify in what sense the refinement modality constitutes \u2018implicit\u2019 quantification, namely over a variable not occurring in the formula bound by it.\nFor the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]). We propose a definition of relativization that may be considered non-standard for several reasons. Firstly, it is relativization not merely to a propositional variable but also for a given agent only. The standard definition is then the special case of relativization to that variable for all agents (we will prove that consecutive relativization to the same variable for two different agents is commutative, in other words, order independent). Secondly, the relativization that we propose corresponds in the semantics to arrow elimination and not to state elimination (in other words, it does not correspond to submodel restriction). From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.\nThe arrow-eliminating relativization need only be done in accessible states but not in the actual state (e.g., the relativization of a variable q to a variable p is that same variable q and not p \u2227 q).\nThe difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic. As our relativization is with respect to a given agent, we have no option but to use arrow-eliminating relativization.\nGiven our purpose to translate refinement modal logic into bisimulation quantified modal logic, we also expand the definition of relativization to include quantifiers. This definition will then be used in Section 6.\nDefinition 20 (Relativization) Relativization \u2022(a,p) : L\u2200\u0303 \u2192 L\u2200\u0303 to propositional variable\np for agent a \u2208 A is defined as follows.\nq(a,p) = q (\u00ac\u03d5)(a,p) = \u00ac\u03d5(a,p) (\u03d5 \u2227 \u03c8)(a,p) = \u03d5(a,p) \u2227 \u03c8(a,p) (2a\u03d5) (a,p) = 2a(p \u2192 \u03d5\n(a,p)) (2b\u03d5) (a,p) = 2b\u03d5 (a,p) for b 6= a (\u2200\u0303q\u03d5)(a,p) = \u2200\u0303q\u03d5(a,p) for q 6= p (\u2200\u0303p\u03d5)(a,p) = \u2200\u0303q\u03d5[q\\p](a,p) choose q that does not occur in \u03d5 \u22a3\nLemma 21 Let Ms be a model with accessibility function R and R \u2032 a \u2286 Ra such that: (t, t\u2032) \u2208 R\u2032a iff Mt\u2032 |= p. Then Ms |= \u03d5 (a,p) if and only if Ms|R \u2032 a |= \u03d5. \u22a3\nProof The proof is by induction on the structure of \u03d5.\n\u2022 Ms |= q (a,p) \u21d4\nMs |= q \u21d4 propositional variables do not change value Ms|R \u2032 a |= q\n\u2022 The clauses for negation and conjunction are elementary.\n\u2022 Ms |= (2a\u03d5) (a,p) \u21d4\nMs |= 2a(p \u2192 \u03d5 (a,p)) \u21d4 for all t \u2208 sRa : Mt |= p \u2192 \u03d5 (a,p) \u21d4 for all t \u2208 sRa : Mt |= p implies Mt |= \u03d5 (a,p) \u21d4 I.H. for all t \u2208 sRa : Mt |= p implies Mt|R \u2032 a |= \u03d5 \u21d4 t \u2208 sRa and t |= p iff t \u2208 sR \u2032 a for all t \u2208 sR\u2032a : Mt|R \u2032 a |= \u03d5 \u21d4 Ms|R \u2032 a |= 2a\u03d5\n\u2022 Ms |= (2b\u03d5) (a,p) \u21d4\nMs |= 2b\u03d5 (a,p) \u21d4 for all t \u2208 sRb : Mt |= \u03d5 (a,p) \u21d4 I.H. for all t \u2208 sRb (in Mt) : Mt|R \u2032 a |= \u03d5 \u21d4 sRb in M equals sRb in M |R \u2032 a for all t \u2208 sRb (in Mt|R \u2032 a) : Mt|R \u2032 a |= \u03d5 \u21d4 Ms|R \u2032 a |= 2b\u03d5\n\u2022 For a more natural argument we take the existential quantifier instead of the universal quantifier. First, observe that:\nMs |= (\u2203\u0303q\u03d5) (a,p) \u21d4 Ms |= \u2203\u0303q\u03d5 (a,p) \u21d4 there is an Nt \u2243 q Ms : Nt |= \u03d5\n(a,p) \u21d4 I.H. there is an Nt \u2243 q Ms : Nt|R \u2032\u2032 a |= \u03d5 where R \u2032\u2032 a \u2286 R N a s.t. (u, u \u2032) \u2208 R\u2032\u2032a iff Mu\u2032 |= p\nWe also have that, by definition:\nMs|R \u2032 a |= \u2203\u0303q\u03d5 \u21d4 there is an N \u2032t\u2032 \u2243 q Ms|R \u2032 a : N \u2032 t\u2032 |= \u03d5\nIt remains to show that the two final statements in these chains of equivalences are also equivalent.\nFrom left to right is easy. If R : Nt \u2243 q Ms, then also R : Nt|R \u2032\u2032 a \u2243 q Ms|R \u2032 a. In N and M we remove all a-arrows to \u00acp states; and if it is already a bisimulation, then the forth and back requirements still hold for fewer pairs in the accessibility relation for a. So we can take N \u2032t\u2032 = Nt|R \u2032\u2032 a. From right to left is not easy. Let us first explain this informally. Given that N \u2032t\u2032 \u2243 q Ms|R \u2032 a, the part of M that is inaccessible from Ms|R \u2032 a (i.e., not in the s-generated submodel) may not be bisimilar to anything in N \u2032. This is problematic, because we need to transform N \u2032t\u2032 to some Nt in a way that establishes a q restricted bisimulation between Nt and all of Ms. Fortunately, the transformation can be an extension of N \u2032t\u2032 , wherein we uniformly treat states in that inaccessible part of M and other states of M : we do not need to be economic in our construction. These are the details.\nLetR : N \u2032t\u2032 \u2243 q Ms|R \u2032 a be the restricted bisimulation. To be explicit, letM = (S,R, V ) and let N \u2032 = (S \u2032, R\u2032, V \u2032). Consider Sap = {u \u2208 SM | \u2203v \u2208 S, (v, u) \u2208 Ra \\ R \u2032 a}. For each u \u2208 Sap we need an exact copy Mu of M (let Mu = (Su, Ru, V u)) in our construction. We now define N = (SN , RN , V N) as follows:\n\u2013 SN = S \u2032 \u222a \u22c3 {Su | u \u2208 Sap};\n\u2013 for all b 6= a, RNb = R \u2032 b \u222a \u22c3 {Rub | u \u2208 S ap}; \u2013 RNa = R \u2032 a \u222a \u22c3 {Rua | u \u2208 S ap} \u222a {(v\u2032, u) | (v\u2032, v) \u2208 R and (v, u) \u2208 Ra \\R \u2032 a}; \u2013 for all p \u2208 P , V N (p) = V \u2032(p) \u222a \u22c3 {V u(p) | u \u2208 Sap}.\nNow take t = t\u2032, and let R\u2032\u2032a as before be restriction of R N a to pairs (u, u \u2032) \u2208 RNa such that u\u2032 satisfies p. It is now immediate that Nt \u2243 q Ms and therefore also Nt|R \u2032\u2032 a |= \u03d5.\n\u2022 The other clause for the universal quantifier starts with a renaming operation (that equally applies to the existential quantifier), and then proceeds as in the previous clause.\nAgent relativization relates as expected to the standard notion of relativization (for the set of all agents simultaneously). This is because relativization to different variables for different agents is commutative.\nLemma 22 Let \u03d5 \u2208 L\u2200\u0303. Then (\u03d5 (a,p))(b,q) = (\u03d5(b,q))(a,p). \u22a3\nProof By induction on the structure of \u03d5. The non-trivial cases are 2a\u03d5, 2b\u03d5 (follows dually), \u2200\u0303p\u03d5, and \u2200\u0303q\u03d5 (also follows dually). Note that (a, p)-relativization distributes over implication.\n\u2022 ((2a\u03d5) (a,p))(b,q) \u21d4\n(2a(p \u2192 \u03d5 (a,p)))(b,q) \u21d4 2a(p \u2192 \u03d5 (a,p))(b,q) \u21d4 2a(p (b,q) \u2192 (\u03d5(a,p))(b,q)) \u21d4 I.H., and clause for variables 2a(p \u2192 (\u03d5 (b,q))(a,p)) \u21d4 (2a\u03d5 (b,q))(a,p) \u21d4 ((2a\u03d5) (b,q))(a,p)\n\u2022 ((\u2200\u0303p\u03d5)(a,p))(b,q) \u21d4 choose r 6= q (or else, yet another step) (\u2200\u0303r\u03d5[r\\p](a,p))(b,q) \u21d4 \u2200\u0303r(\u03d5[r\\p](a,p))(b,q) \u21d4 I.H. \u2200\u0303r(\u03d5[r\\p](b,q))(a,p) \u21d4 substitution of other variables than q \u2200\u0303r(\u03d5(b,q)[r\\p])(a,p) \u21d4 (\u2200\u0303p\u03d5(b,q))(a,p) \u21d4 ((\u2200\u0303p\u03d5)(b,q))(a,p)\nGiven Lemma 22, we may view a nesting of relativizations (. . . (\u03d5(a1,p)) . . .(an,p)) as a relativization \u03d5({a1,...,an},p) for the set of agents {a1, . . . , an}. Furthermore, for \u03d5\n(A,p) we can write \u03d5p: the usual relativization for all agents simultaneously.\nTo make the syntactic correspondence we now introduce a translation.\nDefinition 23 The translation t : L\u2200 \u2192 L\u2200\u0303 is defined by induction on \u03d5 \u2208 L\u2200. All clauses except \u2200a\u03d5 are trivial.\nt(p) = p t(\u00ac\u03d5) = \u00act(\u03d5) t(\u03d5 \u2227 \u03c8) = t(\u03d5) \u2227 t(\u03c8) t(2a\u03d5) = 2at(\u03d5) t(\u2200a\u03d5) = \u2200\u0303p t(\u03d5) (a,p) where p does not occur in \u03d5 \u22a3\nExample 24\nt(\u2203a\u2203br) = \u2203\u0303p t(\u2203br) (a,p) = \u2203\u0303p(\u2203\u0303p t(r)(b,p))(a,p) = \u2203\u0303p(\u2203\u0303p r(b,p))(a,p) = \u2203\u0303p(\u2203\u0303p r)(a,p) = \u2203\u0303p\u2203\u0303q r(a,q) = \u2203\u0303p\u2203\u0303q r \u22a3\nProposition 25 Let \u03d5 \u2208 L\u2200. Then \u03d5 is equivalent to t(\u03d5). \u22a3\nProof In the proposition we allowed ourselves a slight abuse of language: it means that, given any Ms, the value of \u03d5 in the semantics for refinement modal logic is equivalent to the value of t(\u03d5) in the semantics for bisimulation quantified modal logic. The proposition\nfollows from Lemma 12, Lemma 21 and Def. 23. We show the case \u2200a\u03d5 of the inductive proof\u2014and to suit the intuition we take the existential quantifier \u2203a.\nMs |= \u2203a\u03d5 iff there is an M \u2032s\u2032 such that Ms a M \u2032 s\u2032 and M \u2032 s\u2032 |= \u03d5 iff (I.H.) there is an M \u2032s\u2032 such that Ms a M \u2032 s\u2032 and M \u2032 s\u2032 |= t(\u03d5) iff (Lemma 12) there is an N \u2032t\u2032 with R \u2032\u2032 a \u2286 R \u2032 a (restr. to p true) s.t. Ms \u2243 p N \u2032t\u2032 and N \u2032 t\u2032 |R \u2032\u2032 a |= t(\u03d5) iff (Lemma 21) there is an N \u2032t\u2032 such that Ms \u2243 p N \u2032t\u2032 and N \u2032 t\u2032 |= t(\u03d5) (a,p) iff Ms |= \u2203\u0303p t(\u03d5) (a,p) iff Ms |= t(\u2203a\u03d5).\nThis corollary makes the characteristic cases of Proposition 25 stand out.\nCorollary 26 Consider \u2203\u03d5 with \u03d5 \u2208 L (i.e., \u2203-free). Then\n\u2022 a-refinement is bisimulation quantification plus a-relativization: \u2203a\u03d5 is equivalent to \u2203\u0303p\u03d5 (a,p);\n\u2022 refinement is bisimulation quantification plus relativization: \u2203\u03d5 is equivalent to \u2203\u0303p\u03d5p. \u22a3\nIn the logic of public announcements, the latter is written as: \u2203\u03d5 is equivalent to \u2203\u0303p\u3008p!\u3009\u03d5."}, {"heading": "4.4 Alternating refinement relations", "text": "Alternating transition systems (ATS) were introduced [3] to model multi-agent systems, where in each move of the game between the agents of an ATS, the choice of an agent at a state is a set of states and the successor state is determined by considering the intersection of the choices made by all agents. A notion of a-alternating refinement was introduced to reflect a refined behavior of agent a while keeping intact the behavior of the others. When restricting to turn-based ATS where only one agent plays at a time (concurrent moves are also allowed in the full setting), a-alternating refinement amounts to requiring \u2018forth\u2019 for all b \u2208 A\\{a} as we do, but \u2018back\u2019 just for agent a. As a consequence, an a-refinement is a particular a-alternating refinement. A logical characterization of a-alternating refinement has been proposed (it essentially relies on the modality \u2203a combined with the linear time temporal logic LTL) in the sense that if an ATS S \u2032 a-refines an ATS S, every formula true in S \u2032 is also true in S. Notice however that the operator \u2203a has a more restricted semantics than the one we propose, since the quantification does not range over all possible refinements of the structure but only over refinements obtained by pruning the unraveling\nof the ATS. Soon after, the more general setting of alternating-time temporal logics [2] considered universal and existential quantifications over a-refinements, for arbitrary a, combined with LTL formulas. It is worthwhile noticing that the quantifiers still range over particular refinements, and always in the original structure. As a consequence, the language cannot express the ability to nest refinements for different agents. This is easily done in our language L\u2200, as the formula \u2203a(2bp \u2227 3a(\u2203b2ap)) exemplifies. This formula tells us that one of the choices that a can make, results in b knowing p and a contemplating a subsequent choice by b that makes her to get to know p as well."}, {"heading": "5 Axiomatization RML", "text": "Here we present the axiomatization RML for the logic RML. We show the axioms and rules to be sound, we give example derivations, and this is followed by the completeness proof.\nThe axiomatization presented is a substitution schema, since the substitution rule is not valid. The substitution rule says that: if \u03d5 is a theorem, and p occurs in \u03d5, and \u03c8 is any formula, then \u03d5[\u03c8\\p] is a theorem. Note that for all atomic propositions p, p \u2192 \u2200p is valid, but the same is not true for an arbitrary formula, e.g. 3a\u22a4 \u2192 \u22003a\u22a4 is not valid, because after the maximal refinement there is no accessible state, so that 3a\u22a4 is then false even if it was true before. The logic RML is therefore not a normal modal logic.\nDefinition 27 (Axiomatization RML) The axiomatization RML consists of all substitution instances of the axioms\nProp All tautologies of propositional logic K 2a(\u03d5 \u2192 \u03c8) \u2192 2a\u03d5 \u2192 2a\u03c8 R \u2200a(\u03d5 \u2192 \u03c8) \u2192 \u2200a\u03d5 \u2192 \u2200a\u03c8\nRProp \u2200ap \u2194 p and \u2200a\u00acp \u2194 \u00acp RK \u2203a\u2207a\u03a6 \u2194 \u2227 3a\u2203a\u03a6\nRKmulti \u2203a\u2207b\u03a6 \u2194 \u2207b\u2203a\u03a6 where a 6= b RKconj \u2203a \u2227 b\u2208B \u2207b\u03a6 b \u2194 \u2227 b\u2208B \u2203a\u2207b\u03a6 b\nand the rules MP From \u03d5 \u2192 \u03c8 and \u03d5 infer \u03c8\nNecK From \u03d5 infer 2a\u03d5 NecR From \u03d5 infer \u2200a\u03d5\nwhere a, b \u2208 A, p \u2208 P , and B \u2286 A. If \u03d5 is derivable, we write \u22a2 \u03d5, and \u03d5 is called a theorem, as usual. The well-known axiomatization K for the logic K consists of the axioms Prop, K, and the rules MP and NecK. \u22a3 In the definition, given \u03a6 = {\u03d51, . . . , \u03d5n}, note that \u2203a\u2207a\u03a6 \u2194 \u2227\n3a\u2203a\u03a6 stands for \u2203a\u2207a\u03a6 \u2194 \u2227 \u03d5\u2208\u03a6 3a\u2203a\u03d5 (see the technical preliminaries) and so for \u2203a\u2207a{\u03d51, . . . , \u03d5n} \u2194 3a\u2203a\u03d51 \u2227 . . . \u2227 3a\u2203a\u03d5n. The axiomatization RML is surprisingly simple given the complexity of the semantic definition of the refinement operator \u2200; and given the well-known\ncomplexity of axiomatizations for logics involving bisimulation quantifiers instead of this single refinement quantifier. We note that while refinement is reflexive, transitive and satisfies the Church-Rosser property (Proposition 2, and Proposition 19), the corresponding modal axioms are not required. These properties are schematically derivable. First, we demonstrate soundness of RML.\nGiven the definitions of 2 and 3 in terms of cover, it may be instructive to see how the RK axiom works as a reduction principle for \u22032\u03d5 and \u22033\u03d5\u2014note that we need both, as there is no principle for \u2203\u00ac\u03d5. For simplicity we do not label the operators with agents. We get:\n\u22032\u03d5 \u2194 \u2203(\u2207{\u03d5} \u2228 \u2207\u2205) \u2194 \u2203\u2207{\u03d5} \u2228 \u2203\u2207\u2205\n(use RK) \u2194 \u2203\u2207{\u03d5} \u2228 \u2227\n3\u2203\u2205 (empty conj. is true) \u2194 \u2203\u2207{\u03d5} \u2228 \u22a4\n\u2194 \u22a4\nand \u22033\u03d5 \u2194 \u2203\u2207{\u03d5,\u22a4} (use RK) \u2194 3\u2203\u03d5 \u2227 3\u2203\u22a4\n\u2194 3\u2203\u03d5\nOne may wonder why we did not choose \u22032\u03d5 \u2194 \u22a4 and \u22033\u03d5 \u2194 3\u2203\u03d5 (we recall Proposition 19) as primitives in the axiomatization, as, after all, these are very simple axioms. They are of course valid, but the axiomatization would not be complete. The axiom RK is much more powerful, as this not merely allows \u03a6 = {\u03d5}, \u03a6 = \u2205, and \u03a6 = {\u03d5,\u22a4}, but any finite set of formulas."}, {"heading": "5.1 Soundness", "text": "Theorem 28 The axiomatization RML is sound for RML. \u22a3\nProof As all models of L\u2200 are models of L, the schemas Prop, K and the rule MP and NecK are all sound. We deal with the remaining schemas and rules below.\nR Suppose that Ms is a model such that Ms |= \u2200a(\u03d5 \u2192 \u03c8), and Ms |= \u2200a\u03d5. Then for every Nt, where Nt a Ms, we have Nt |= \u03d5 \u2192 \u03c8, and also Nt |= \u03d5. From Nt |= \u03d5 \u2192 \u03c8 and Nt |= \u03d5 follows Nt |= \u03c8. As Nt was arbitrary model such that Nt a Ms, from that and Nt |= \u03c8 follows Ms |= \u2200a\u03c8.\nRProp Let Ms and Nt be given such that Nt a Ms. By Definition 1 for the semantics of refinement, we have that s \u2208 V M(p) if and only if t \u2208 V N(p). Therefore Ms |= p iff Nt |= p,\nfor every Ms and Nt with Nt a Ms. Therefore Ms |= p iff Ms |= \u2200ap for every Ms, i.e. |= p \u2194 \u2200ap. Similarly, for |= \u00acp \u2194 \u2200a\u00acp, using that s 6\u2208 V M(p) if and only if t 6\u2208 V N(p).\nRK Suppose Ms is a model, where M = (S,R, V ), such that for some set \u03a6, Ms |= \u2203a\u2207a\u03a6. Therefore, there is a model Nt a Ms such that Nt |= \u2207a\u03a6\u2014where N = (S \u03a6, R\u03a6, V \u03a6). Expanding the definition, we have that for every \u03d5 \u2208 \u03a6 there is some u \u2208 tR\u03a6a such that Nu |= \u03d5. Also, because of back, for every such u \u2208 tR \u03a6 a there is some v \u2208 sRa such that Nu a Mv. Combining these statements we have that for every \u03d5 \u2208 \u03a6 there is some v \u2208 sRa such that Mv |= \u2203a\u03d5, and thus Ms |= \u2227 3a\u2203a\u03a6.\nConversely, suppose that Ms |= \u2227\n3a\u2203a\u03a6. Therefore, for every \u03d5 \u2208 \u03a6 there is some t\u03d5 \u2208 sRa such that Mt\u03d5 |= \u2203a\u03d5. Thus, for each \u03d5 \u2208 \u03a6, there is some model N \u03d5 u\u03d5 a Mt\u03d5 , where N\u03d5 = (S\u03d5, R\u03d5, V \u03d5), such that N\u03d5u\u03d5 |= \u03d5. Without loss of generality, we may assume that for all \u03d5, \u03d5\u2032 \u2208 \u03a6 the models N\u03d5 and N\u03d5 \u2032\nare disjoint. We construct the model M\u03a6 = (S\u03a6, R\u03a6, V \u03a6) such that:\nS\u03a6 = {s\u2032} \u222a S \u222a \u22c3\n\u03d5\u2208\u03a6 S \u03d5\nR\u03a6a = {(s \u2032, u\u03d5) | \u03d5 \u2208 \u03a6} \u222aRa \u222a \u22c3 \u03d5\u2208\u03a6R \u03d5 a R\u03a6b = {(s \u2032, t) | (s, t) \u2208 Rb} \u222a Rb \u222a \u22c3 \u03d5\u2208\u03a6 R \u03d5 b for b 6= a\nV \u03a6(p) = {s\u2032} \u222a V (p) \u222a \u22c3\n\u03d5\u2208\u03a6 V \u03d5(p) for p \u2208 P\nwhere {s\u2032} = {s\u2032} if s \u2208 V (p) and else {s\u2032} = \u2205. We can see that Ms a M \u03a6 s\u2032 , via the relation R \u03a6 = {(s, s\u2032)} \u222a I \u222a \u22c3 \u03d5\u2208\u03a6 R \u03d5 where I is the identity on S and each R\u03d5 is the refinement relation corresponding to Mt\u03d5 a N \u03d5 u\u03d5 (see also [25]). Furthermore, for each t \u2208 s\u2032R\u03a6a it is clear that M \u03a6 t \u2243 N \u03d5 u\u03d5 for some \u03d5, and thus M\u03a6t |= \u03d5, and so M \u03a6 t |= \u2228 \u03a6. Therefore M\u03a6s\u2032 |= 2a \u2228 \u03a6. Finally, for each \u03d5 \u2208 \u03a6 there is some u\u03d5 \u2208 s\u2032R\u03a6a where M \u03a6 u\u03d5 |= \u03d5, so for each \u03d5 \u2208 \u03a6 we have M \u03a6 s |= 3a\u03d5, so we have\nM\u03a6s\u2032 |= \u2227 3a\u03a6. Combined, M \u03a6 s\u2032 |= 2a \u2228 \u03a6 and M\u03a6s\u2032 |= \u2227 3a\u03a6 state that M \u03a6 s\u2032 |= \u2207a\u03a6, and therefore Ms |= \u2203a\u2207a\u03a6.\nRKmulti Suppose that Ms |= \u2203a\u2207b\u03a6. Therefore, there is a model M \u2032 t a Ms such that M \u2032 t |= \u2207b\u03a6\u2014let the accessibility relation for agent b in M \u2032 be R\u2032b. Expanding the definition, we have that for every \u03d5 \u2208 \u03a6 there is some u \u2208 tR\u2032b such that M \u2032 u |= \u03d5. Also, because of back, for every such u \u2208 tR\u2032b there is some v \u2208 sRb such that M \u2032 u a Mv. Combining these statements we have that for every \u03d5 \u2208 \u03a6 there is some v \u2208 sRb such that Mv |= \u2203a\u03d5, and thus Ms |= \u2227 3b\u2203a\u03a6. However, as forth also holds for agent b, the v \u2208 sRb we could construct above are also all the states v accessible from s. Therefore we also have Ms |= 2b \u2228 \u2203a\u03a6, so together we get Ms |= \u2207b\u2203a\u03a6.\nFor the converse direction, suppose that Ms |= \u2207b\u2203a\u03a6. From the definition of \u2207b it follows that Ms |= \u2227 3b\u2203a\u03a6. We now proceed in a similar way as in the case RK. From\nMs |= \u2227 3b\u2203a\u03a6 it follows that for every \u03d5 \u2208 \u03a6 there is some t \u03d5 \u2208 sRb such thatMt\u03d5 |= \u2203a\u03d5. Thus, for each \u03d5 \u2208 \u03a6, there is some model N\u03d5u\u03d5 a Mt\u03d5 , where N \u03d5 = (S\u03d5, R\u03d5, V \u03d5), such\nthat N\u03d5u\u03d5 |= \u03d5. Define the model M \u03a6 = (S\u03a6, R\u03a6, V \u03a6) similar to the case RK, except that: the roles of a and b have been swapped, and the accessibility relation for all agents c different from a and b is defined as that for a.\nS\u03a6 = {s\u2032} \u222a S \u222a \u22c3\n\u03d5\u2208\u03a6 S \u03d5\nR\u03a6b = {(s \u2032, u\u03d5) | \u03d5 \u2208 \u03a6} \u222aRb \u222a \u22c3 \u03d5\u2208\u03a6 R \u03d5 b R\u03a6c = {(s \u2032, t) | (s, t) \u2208 Rc} \u222a Rc \u222a \u22c3 \u03d5\u2208\u03a6R \u03d5 c for c 6= b\nV \u03a6(p) = {s\u2032} \u222a V (p) \u222a \u22c3\n\u03d5\u2208\u03a6 V \u03d5(p) for p \u2208 P\nwhere {s\u2032} = {s\u2032} if s \u2208 V (p) and else {s\u2032} = \u2205 (R\u03a6c also defines R \u03a6 a , namely for c = a).\nWe can see that Ms a M \u03a6 s\u2032 , via the relation R\n\u03a6 = {(s, s\u2032)} \u222a I \u222a \u22c3\n\u03d5\u2208\u03a6 R \u03d5 where I\nis the identity on S and each R\u03d5 is the refinement relation corresponding to Mt\u03d5 a N \u03d5 u\u03d5 (see also [25]). Furthermore, for each t \u2208 s\u2032R\u03a6b it is clear that M \u03a6 t \u2243 N \u03d5 u\u03d5 for some \u03d5, and thus M\u03a6t |= \u03d5, and so M \u03a6 t |= \u2228 \u03a6. Therefore M\u03a6s\u2032 |= 2b \u2228 \u03a6. Finally, for each \u03d5 \u2208 \u03a6 there is some u\u03d5 \u2208 s\u2032R\u03a6b where M \u03a6 u\u03d5 |= \u03d5, so for each \u03d5 \u2208 \u03a6 we have M \u03a6 s |= 3b\u03d5, so we have\nM\u03a6s\u2032 |= \u2227 3b\u03a6. Combined, M \u03a6 s\u2032 |= 2b \u2228 \u03a6 and M\u03a6s\u2032 |= \u2227 3b\u03a6 state that M \u03a6 s\u2032 |= \u2207b\u03a6, and therefore Ms |= \u2203a\u2207b\u03a6.\nRKconj The direction \u2203a \u2227 b\u2208B \u2207b\u03a6 b \u2192 \u2227 b\u2208B \u2203a\u2207b\u03a6 b is merely a more complex form of pattern \u2203a(\u03d5 \u2227 \u03c8) \u2192 (\u2203a\u03d5 \u2227 \u2203a\u03c8) which is derivable similar to 3a(\u03d5 \u2227 \u03c8) \u2192 (3a\u03d5 \u2227 3a\u03c8) in the modal logic K, using the axiom R in place of K.\nFor the other direction, suppose thatMs is such thatMs |= \u2227 b\u2208B \u2203a\u2207b\u03a6 b, where B \u2286 A.\nWe need to show that Ms |= \u2203a \u2227 b\u2208B \u2207b\u03a6 b. To do this we follow the same strategy as for\nproving RK: we construct an a-refinement Nt of Ms, and show that Nt |= \u2227 b\u2208B \u2207b\u03a6 b.\nWe begin by constructing the model Nt. Suppose that a \u2208 B. Then we have Ms |= \u2203a\u2207a\u03a6 a, and by RK this implies that Ms |= \u2227 3a\u2203a\u03a6 a. We also have that for every b \u2208 B \u2212 {a}, Ms |= \u2203a\u2207b\u03a6 b, and by RKmulti this implies that Ms |= \u2207b\u2203a\u03a6\nb, and by the definition of the cover operator, this implies that Ms |= \u2227 3b\u2203a\u03a6\nb. Hence for every b \u2208 B and \u03d5 \u2208 \u03a6b, we have that 3b\u2203a\u03d5. (In other words, for some big set of formulas \u03a8 we have that Ms |= \u2227 3b\u2203a\u03a8.) At this stage it suffices to refer to the very similar construction in the soundness proof for axiom RK, from which, similarly to there, it follows that Nt |= \u2227 b\u2208B \u2207b\u03a6 b.\nNecR If \u03d5 is a validity, then it is satisfied by every model, so for any model Ms, \u03d5 is satisfied by every model Nt a Ms, and hence every model Ms satisfies \u2200a\u03d5.\nThe soundness of axiomRK is visualized in Figure 5. It depicts the interaction between refinement and modality involved in this axiom \u2203a\u2207a\u03a6 \u2194 \u2227 3a\u2203a\u03a6, for the case that \u03a6 = {\u03d51, \u03d52, \u03d53}. The single lines are modal accessibility, and the double lines the refinement relations. The solid lines are given, and the dashed lines are required. Accessibility relations for other agents than a are omitted. The picture on the left depicts the implication from left to right in the axiom, and the picture on the right depicts the implication from right\nto left. Note that the states satisfying \u03d52 and \u03d53 have the same origin u in M\u2014the typical sort of duplication (resulting in non-bisimilar states) allowed when having back but not forth. Apart from u and t, state s in M has yet another accessible state v, that does not occur in the refinement relation: the other typical sort of thing when having back but not forth. Therefore, on the right side of the equivalence in axiom RK we only have \u2227 3a\u2203a\u03a6\nand we cannot guarantee that 2a \u2228\n\u2203a\u03a6 also follows from the left-hand side. The axiom RKmulti, defined as \u2203a\u2207b\u03a6 \u2194 \u2207b\u2203a\u03a6 for a 6= b, says that refinement with respect to one agent does not interact with the modalities (the uncertainty, say) for another agent: the operators \u2207b and \u2203a simply commute. This in contrast to the axiom RK where on the right-hand side a construct 2a \u2228 \u2203a\u03a6 is \u2018missing\u2019, so to speak. If it\nhad been 2a \u2228 \u2203a\u03a6\u2227 \u2227 3a\u2203a\u03a6, then we would have had \u2207a\u2203a\u03a6, as in RKmulti but with a = b. The axioms RK and RKmulti are different, because in an a-refinement the condition forth is not required, whereas for other agents b forth is required. Given some refinement wherein we have a cover of \u03a6, so that at least one of \u03a6 is necessary (the \u2203a\u2207a\u03a6 bit), for each of the covered states we can trace an origin before the refinement, because of back. But there may be more originally accessible states, so whatever holds in those origins, although it is all possible, is not necessary. So we have \u2227 3a\u2203a\u03a6, but we do not have 2a \u2228 \u2203a\u03a6. In contrast, when the agents are different, back and forth must hold for agent b in a refinement a witnessing the operator \u2203a: for an a-refinement, back and forth must hold for all agents b 6= a. Figure 6 should further clarify the issue\u2014compare this to Figure 5. The main difference between the figures is that there cannot now be yet another state v accessible from s but not \u2018covered\u2019 as the origin of one of the refined states. In Figure 5 what holds in t and u is not necessary for a, but in Figure 6 what holds in t and u is necessary for b."}, {"heading": "5.2 Example derivations", "text": "In these examples we also use \u2018substitution of equivalents\u2019, see Proposition 32, ahead.\nExample 29 \u22a2 3a\u22a4 \u2192 \u2203a(3a\u22a4 \u2227 (2ap \u2228 2a\u00acp)) \u22a3\nIn an epistemic setting, where 2ap means that the agent knows p, and where (in S5 models) the condition 3a\u22a4 is always satisfied, this validity expresses that the agent can always find out the truth about p: if true, announce p to the agent (and announcement is a model restriction, and therefore a refinement), after which p is known by the agent to be true, and if false, announce that p is false, after which p is known to be false. This validity is indeed also a theorem of RML. For that, it suffices to derive the equivalent 3a\u22a4 \u2192 \u2203a(\u2207a{p} \u2228 \u2207a{\u00acp}). In some cases several deductions have been combined into single statements, but this is restricted to cases of well-known modal theorems.\n\u22a2 3a\u22a4 \u2194 3a(p \u2228 \u00acp) Prop,NecK,K \u22a2 3a(p \u2228 \u00acp) \u2194 (3ap \u2228 3a\u00acp) Prop,NecK,K \u22a2 3ap \u2192 \u2203a\u2207a{p} See below \u22a2 3a\u00acp \u2192 \u2203a\u2207a{\u00acp} See below \u22a2 3ap \u2192 \u2203a(\u2207a{p} \u2228 \u2207a{\u00acp}) Prop,NecR,R \u22a2 3a\u00acp \u2192 \u2203a(\u2207a{p} \u2228 \u2207a{\u00acp}) Prop,NecR,R \u22a2 3a\u22a4 \u2192 \u2203a(\u2207a{p} \u2228 \u2207a{\u00acp}) Prop,MP\nLines 3 and 4 of the derivation require the following derivation, where \u03d5 is a propositional formula (i.e., \u03d5 \u2208 L0).\n\u22a2 \u03d5 \u2194 \u2203a\u03d5 Proposition 34, ahead \u22a2 3a\u03d5 \u2194 3a\u2203a\u03d5 Prop,NecK,K \u22a2 3a\u03d5 \u2194 \u2203a\u2207a{\u03d5} RK[\u03a6 = {\u03d5}]\nExample 30 \u22a2 (3ap \u2227 3bp \u2227 3a\u00acp \u2227 3b\u00acp) \u2192 \u2203a(2ap \u2227 \u00ac2bp) \u22a3\nConsider the informative development described in Example 4.2: given an initial information state wherein agents a and b consider either value of p possible, a can be informed such that afterwards a believes that p but not b. This theorem formalizes that. In the following, let \u03d5 be (3ap \u2227 3bp \u2227 3a\u00acp \u2227 3b\u00acp).\n\u22a2 \u03d5 \u2192 3ap \u2227 3b\u00acp Prop \u22a2 \u03d5 \u2192 3ap \u2227\u2207b{\u00acp,\u22a4} Definition of \u2207 \u22a2 \u03d5 \u2192 3a\u00ac\u00acp \u2227 \u2207b{\u00ac\u00ac\u00acp,\u00ac\u00ac\u22a4} Prop \u22a2 \u03d5 \u2192 3a\u00ac\u2200a\u00acp \u2227 \u2207b{\u00ac\u2200a\u00ac\u00acp,\u00ac\u2200a\u00ac\u22a4} RProp \u22a2 \u03d5 \u2192 3a\u2203ap \u2227 \u2207b{\u2203a\u00acp, \u2203a\u22a4} Definition of \u2203 \u22a2 \u03d5 \u2192 \u2203a\u2207a{p} \u2227 \u2207b{\u2203a\u00acp, \u2203a\u22a4} RK \u22a2 \u03d5 \u2192 \u2203a\u2207a{p} \u2227 \u2203a\u2207b{\u00acp,\u22a4} RKmulti \u22a2 \u03d5 \u2192 \u2203a(\u2207a{p} \u2227 \u2207b{\u00acp,\u22a4}) RKconj \u22a2 \u03d5 \u2192 \u2203a(2ap \u2227 3ap \u2227 3b\u00acp) Definition of \u2207 \u22a2 \u03d5 \u2192 \u2203a(2ap \u2227 3b\u00acp) Prop \u22a2 \u03d5 \u2192 \u2203a(2ap \u2227 \u00ac2bp) Definition of 3"}, {"heading": "5.3 Completeness", "text": "Completeness is shown by a fairly but not altogether straightforward reduction argument: every formula in refinement modal logic is equivalent to a formula in modal logic. So it is a theorem, if its modal logical equivalent is a theorem. In the axiomatization RML we can observe that all axioms involving refinement operators \u2203 are equivalences, except for R; however, \u2203a(\u03d5 \u2228 \u03c8) \u2194 \u2203a\u03d5 \u2228 \u2203a\u03c8 is a derivable theorem. This means that by socalled \u2018rewriting\u2019 we can push the \u2203 operators further inward into a formula, until we reach some expression \u2203\u03d5 where \u03d5 contains no refinement operators. Now we come to the less straightforward part. Because there is a hitch: there is no general way to push a \u2203 beyond a negation (or, for that matter, beyond a conjunction). For that, we use another trick, namely that all modal logical formulas are equivalent to formulas in the cover logic syntax, and that all those are equivalent to formulas in disjunctive form (see the introduction) in cover logic. Using that, once we reached some innermost \u2203\u03d5 where \u03d5 contains no refinement operators, we can continue pushing that refinement operator downward until it binds a propositional formula only, and disappears in smoke because of the RProp axiom. Then, iterate this. All \u2203 operators have disappeared in smoke. We have a formula in modal logic.\nFor a smooth argument we first give some general results, after which we apply the reduction argument and demonstrate completeness.\nDefinition 31 (Substitution of equivalents) An axiomatization satisfies substitution of equivalents if the following holds. Let \u03d51, \u03d52, \u03d53 \u2208 L and p \u2208 P . If \u22a2 \u03d51 \u2194 \u03d52 then \u22a2 \u03d53[\u03d52\\p] \u2194 \u03d53[\u03d51\\p]. \u22a3\nProposition 32 The axiomatization RML satisfies substitution of equivalents. \u22a3\nProof This can be shown by induction on \u03d53. All cases are standard. The case 2a\u03d5 is shown by using an inductive hypothesis \u22a2 \u03d5[\u03d52\\p] \u2194 \u03d5[\u03d51\\p] and then successively applying NecK, K, and some elementary tautologies and applications of MP. (The required pattern is: from \u22a2 x \u2192 y, to \u22a2 2(x \u2192 y), to \u22a2 2x \u2192 2y. Then, similarly, for the other direction of the equivalence x \u2194 y. Then, some more propositional steps to wind it up.) Whereas the case \u2200a\u03d5 is shown with the same inductive hypothesis but applying NecR and R instead of NecK and K.\nProposition 33\n1. \u22a2 \u2200a(\u03d5 \u2227 \u03c8) \u2194 \u2200a\u03d5 \u2227 \u2200a\u03c8\n2. \u22a2 \u2203a(\u03d5 \u2228 \u03c8) \u2194 \u2203a\u03d5 \u2228 \u2203a\u03c8\n3. \u22a2 \u2203a(\u03d5 \u2227 \u03c8) \u2192 \u2203a\u03d5 \u2227 \u2203a\u03c8 \u22a3\nProof Item 1. can be easily derived from R, NecR and MP, similarly to the way that in modal logic we derive \u22a2 2(\u03d5 \u2227 \u03c8) \u2194 2\u03d5 \u2227 2\u03c8. Item 2. is the dual of item 1. and requires mere propositional reasoning. Item 3. can be derived using the tautologies \u03d5\u2227\u03c8 \u2192 \u03d5 and \u03d5 \u2227 \u03c8 \u2192 \u03c8, respectively, propositional reasoning, and R. (Alternatively, for Item 3., we can think of deriving its dual, with the crucial steps in the derivation that \u03d5 \u2192 \u03d5 \u2228 \u03c8 is a tautology, from which with R and MP we get \u2200\u03d5 \u2192 \u2200(\u03d5 \u2228 \u03c8).)\nProposition 34\n1. \u22a2 \u2200a\u03d5 \u2194 \u03d5 for all propositional \u03d5.\n2. \u22a2 \u2203a\u03d5 \u2194 \u03d5 for all propositional \u03d5.\nProof We show \u22a2 \u2200a\u03d5 \u2194 \u03d5 for all propositional \u03d5. 5 The proof of \u22a2 \u2203a\u03d5 \u2194 \u03d5 for all propositional \u03d5 is similar. For convenience in the proof we omit the agent label and write \u2200.\nWe first show \u22a2 \u03d5 \u2192 \u2200\u03d5. Assume that \u03d5 is in disjunctive normal form (i.e., for propositional logic, different from the disjunctive form, df, often used in this work). Formula \u03d5 therefore has the form \u2228 \u03b3\u2208\u0393, where each formula \u03b3 is a conjunction of atoms or their\nnegation, for which we write, slightly abusing the language, \u03b3 = \u2227\np\u2208\u03b3 p \u2014 where p = p if p is a conjunct of \u03b3 and p = \u00acp if \u00acp is a conjunct of \u03b3. We now get the following. We omit trivial steps of chaining implications and applying MP. For readability we assume the \u2018\u03d5 \u2192\u2019 part in some derived formulas.\n5Of course we do not have for all \u03d5 \u2208 L\u2200 that \u22a2 \u2200a\u03d5 \u2194 \u03d5. But we then still have \u22a2 \u2200\u03d5 \u2192 \u03d5, or, dually, \u22a2 \u03d5 \u2192 \u2203\u03d5. This can be easily shown by induction on the disjunctive form structure of a formula.\n\u22a2 \u03d5 \u2192 \u2228\n\u03b3\u2208\u0393 \u2227 p\u2208\u03b3 p DNF of \u03d5,Prop\n\u22a2 . . . \u2228\n\u03b3\u2208\u0393 \u2227 p\u2208\u03b3 \u2200p RProp\n\u22a2 . . . \u2228 \u03b3\u2208\u0393 \u2200 \u2227\np\u2208\u03b3 p R, NecR, and Prop. 33.1 (\u2200(\u03d5 \u2227 \u03c8) \u2194 \u2200\u03d5 \u2227 \u2200\u03c8) \u22a2 . . . \u2200 \u2228 \u03b3\u2208\u0393 \u2227 p\u2208\u03b3 p R, NecR, and tautology \u03d5 \u2192 \u03d5 \u2228 \u03c8 \u22a2 \u03d5 \u2192 \u2200\u03d5 DNF of \u03d5\nFor the converse direction we convert \u03d5 to the conjunctive normal form for propositional formulas, i.e., \u03d5 is equivalent to \u2227 \u03b3\u2208\u0393 \u2228 p\u2208\u03b3 p (where we now write p = p if p is a disjunct\u2014 not conjunct\u2014of \u03b3 and p = \u00acp if \u00acp is a disjunct of \u03b3).\n\u22a2 \u2200\u03d5 \u2192 \u2200 \u2227\n\u03b3\u2208\u0393 \u2228 p\u2208\u03b3 p CNF of \u03d5,Prop,NecR,R\n\u22a2 . . . \u2227 \u03b3\u2208\u0393 \u2200 \u2228 p\u2208\u03b3 p Prop. 33.1\n\u22a2 . . . \u2227\n\u03b3\u2208\u0393 \u2228 p\u2208\u03b3 p \u2217\n\u22a2 \u2200\u03d5 \u2192 \u03d5 CNF of \u03d5\nWe show why * holds by outlining the method and giving an example: write the conjunct\u2228 p\u2208\u03b3 p in implicative fashion, e.g., instead of p \u2228 q \u2228 \u00acr \u2228 s we write \u00acp \u2192 \u00acq \u2192 r \u2192 s. Then, applying NecR and R and MP repeatedly, we get first \u2200(\u00acp \u2192 \u00acq \u2192 r \u2192 s) and then \u2200\u00acp \u2192 \u2200\u00acq \u2192 \u2200r \u2192 \u2200s. Then, applying RProp, we get \u00acp \u2192 \u00acq \u2192 r \u2192 s, in other words, we have p \u2228 q \u2228 \u00acr \u2228 s back.\nProposition 35 \u22a2 (\u03d5 \u2227 \u2203a\u03c8) \u2194 \u2203a(\u03d5 \u2227 \u03c8) for all propositional \u03d5 (and any \u03c8 \u2208 L\u2200). \u22a3\nProof Proposition 33 demonstrated that \u2203a(\u03d5\u2227\u03c8) \u2192 \u2203a\u03d5\u2227\u2203a\u03c8 from which, using Proposition 34.2, also follows \u03d5\u2227\u2203a\u03c8. For the other direction we first derive (\u2200a\u03d5\u2227\u2203a\u03c8) \u2192 \u2203a(\u03d5\u2227\u03c8) by propositional means and applications of Nec and R. This goes as follows. For convenience of applying the available axioms, instead of (\u2200a\u03d5 \u2227 \u2203a\u03c8) \u2192 \u2203a(\u03d5 \u2227 \u03c8) use the equivalent form \u2200a\u00ac(\u03d5\u2227\u03c8) \u2192 \u2200a\u03d5 \u2192 \u2200a\u00ac\u03c8. Now we observe that \u00ac(\u03d5\u2227\u03c8) \u2192 \u03d5 \u2192 \u00ac\u03c8 is a tautology and therefore derivable, applying NecR gets us \u2200a(\u00ac(\u03d5 \u2227 \u03c8) \u2192 \u03d5 \u2192 \u00ac\u03c8) and successively applying R gets us \u2200a\u00ac(\u03d5 \u2227 \u03c8) \u2192 \u2200a\u03d5 \u2192 \u2200a\u00ac\u03c8. Then, finally, we use that \u2200a\u03d5 \u2194 \u03d5 (Proposition 34.1) and thus get (\u03d5 \u2227 \u2203a\u03c8) \u2192 \u2203a(\u03d5 \u2227 \u03c8).\nWe now first show that every L\u2200 formula is logically equivalent to a L formula. We then show that if the latter is a theorem in K, the former is a theorem in RML.\nProposition 36 Every formula of L\u2200 is logically equivalent to a formula of L. \u22a3\nProof Given a formula \u03c8 \u2208 L\u2200, we prove by induction on the number of the occurrences of \u2203a in \u03c8 (for any a \u2208 A) that it is equivalent to an \u2203a-free formula, and therefore to a formula \u03d5 \u2208 L, the standard modal logic. The base is trivial. Now assume \u03c8 contains n + 1 occurrences of \u2203a-operators for some a \u2208 A (so these may be refinement operators for different agents). Choose a subformula of type \u2203a\u03d5 of our given formula \u03c8, where \u03d5 is \u2203b-free for any b \u2208 A (i.e. choose an innermost \u2203a). Let \u03d5\n\u2032 be a disjunctive formula that is equivalent to \u03d5. We prove by induction on the structure of \u03d5\u2032 that \u2203a\u03d5\n\u2032 is logically equivalent to a formula \u03c7 without \u2203a. There are two cases:\n\u2022 \u2203a(\u03d5 \u2228 \u03c8); \u2022 \u2203a(\u03d50 \u2227 \u2227 b\u2208B \u2207b\u03a6 b) where \u03d50 is propositional, B \u2286 A, and each \u03a6 b a set of dfs.\nIn the first case, apply Proposition 33.2, we get \u2203a\u03d5 \u2228 \u2203a\u03c8, and then apply induction. In the second case, if B = \u2205 we use that \u2203a\u03d50 \u2194 \u03d50 (Proposition 34.2). If B 6= \u2205, then from Proposition 35 follows that this is equivalent to \u03d50 \u2227 \u2203a \u2227 b\u2208B \u2207b\u03a6\nb, and we further reduce the right conjunct with one of the axioms RK (if B = {a}), RKmulti (if B = {b} with b 6= a), or RKconj (if |B| > 1), and apply induction again.\nThus we are able to push the refinement operators deeper into the formula until they eventually reach a propositional formula, at which point they disappear and we are left with the required \u2203-free formula \u03c7 that is equivalent to \u2203\u03d5. Replacing \u2203\u03d5\u2032 by \u03c7 in \u03c8 gives a result with one less \u2203-operator, to which the (original) induction hypothesis applies.\nProposition 37 Let \u03d5 \u2208 L\u2200 be given and \u03c8 \u2208 L be equivalent to \u03d5. If \u03c8 is a theorem in K, then \u03d5 is a theorem in RML. \u22a3\nProof Given a \u03d5 \u2208 L\u2200, Proposition 36 gives us an equivalent \u03c8 \u2208 L. Assume that \u03c8 is a theorem in K. We can extend the derivation of \u03c8 to a derivation of \u03d5 by observing that all steps used in Proposition 36 are not merely logical but also provable equivalences \u2014 where we also apply Proposition 32 of substitution of equivalents.\nTheorem 38 The axiom schema RML is sound and complete for the logic RML. \u22a3\nProof The soundness proof is given in Theorem 28, so we are left to show completeness. Suppose that \u03d5 \u2208 L\u2200 is valid: |= \u03d5. Applying Lemma 36 we know that there is some equivalent formula \u03c8 \u2208 L, i.e., not containing any refinement operator. As \u03d5 is valid, from that and the validity \u03d5 \u2194 \u03c8 it follows that \u03c8 is also valid in refinement modal logic, and therefore also valid in the logic K (note that the model class is the same). From the completeness of K it follows that \u03c8 is derivable, i.e. it is a theorem. From Proposition 37 it follows that \u03d5 is a theorem."}, {"heading": "5.4 The single-agent case", "text": "The axiomatization for the single-agent case is the unlabelled version of RML, minus the axioms RKmulti and RKconj.6 The single-agent axiomatization was presented in [56]. The completeness proof there is (slightly) different from the multi-agent case of the proof here. In [56] it is used that every refinement modal logical formula is equivalent to a formula in cover logic with the special syntax \u03d5 ::= \u22a5 | \u22a4 | \u03d5 \u2228 \u03d5 | p \u2227 \u03d5 | \u00acp \u2227 \u03d5 | \u2207{\u03d5, . . . , \u03d5} [10, 34], plus induction on that form. (This syntax is of course very \u2018disjunctive formula like\u2019.) That proof was suggested by Yde Venema, as a shorter alternative to the proof with disjunctive forms.\n6It is clear that axiom RKmulti is not needed in the single-agent case, as this is for different agents. But axiom RKconj is also not necessary in the single-agent case. We recall that \u2207a\u03a6\u2227\u2207a\u03a8 is equivalent to \u2207a((\u03a6 \u2227 \u2228 \u03a8) \u222a (\u03a8 \u2227 \u2228 \u03a6)), see page 6. So, we can assume that there are no conjunctions of cover formulas in the single-agent case."}, {"heading": "5.5 Refinement epistemic logic", "text": "Refinement modal logic RML is presented with respect to the class of all models. As mentioned in Section 4.1, by restricting the class of models that the logic is interpreted over, we may associate different meanings with the modalities. For example, the epistemic logic S5, a.k.a. the logic of knowledge, is interpreted over the model class S5, and the logic of belief KD45 is interpreted over the class KD45. Given any class of models C, the semantic interpretation of \u2200 is given by:\nMs |= \u2200a\u03d5 iff for all M \u2032 s\u2032 \u2208 C : Ms a M \u2032 s\u2032 implies M \u2032 s\u2032 |= \u03d5.\nThus we can consider various refinement epistemic logics. Although \u22032\u22a5 is a validity in RML (just remove all access) it is not so in the refinement logic of knowledge, interpreted on S5 models, because seriality of models must be preserved in every refinement. And therefore it is also not valid in the refinement logic of belief.\nOur axiomatization RML may not be sound for more restricted model classes. Let us consider the single-agent case, and the axiom\nRK \u2203\u2207\u03a6 \u2194 \u2227 3\u2203\u03a6.\nFor example, in S5 we have that \u2203\u2207{2p,\u00ac2p} is inconsistent, but that 3\u22032p\u22273\u2203\u00ac2p is consistent: you do not consider an informative development possible after which you both know and don\u2019t know p at the same time. Therefore, axiom RK is invalid for that class.\nThe axioms replacing RK in refinement logic of knowledge and refinement logic of belief are, respectively:\nRS5 \u2203\u2207\u03a6 \u2194 ( \u2228 \u03a6 \u2227 \u2227 3\u03a6),\nand, for \u03a6 6= \u2205,\nRKD45 \u2203\u2207\u03a6 \u2194 \u2227 3\u03a6,\nwhere \u03a6 is a set of purely propositional formulas. Now if apart from RS5 we also add the usual S5 axioms T, 4, and 5, we have a complete axiomatization for the refinement logic of knowledge. In the case of the refinement logic of belief, we add axioms D (for seriality), 4, and 5 and RKD45 to get a complete axiomatization. For details, see [27].\nA study of how various classes of models affect the properties of bisimulation quantified logics is given in [22]. Refinement epistemic logics are investigated in [27, 25]. In [25] a multi-agentKD45 axiomatization is also reported. (For multi-agent S5, see \u2018Recent results\u2019 in Section 8.)"}, {"heading": "6 Axiomatization RML\u00b5", "text": "In this section we give the axiomatization for refinement modal \u00b5-calculus. We restrict ourselves to single-agent refinement modal \u00b5-calculus. The axiomatization is an extension of the (single-agent) axiomatization RML for refinement modal logic.\nWe recall the definition of modal \u00b5-calculus in the technical introductory Section 2. In [22, Lemma 2.43] a bisimulation quantifier characterization of fixed points is given. The characterization employs the universal modality which quantifies over all states in the model. Let L\u2200\u0303 be the language of bisimulation quantified modal logic with as well. First, observe that this impacts the semantics of bisimulation quantification. For two models to be bisimilar, it must now also be the case that every state in one model is bisimilar to a state in the other.\nWe can inductively define a truth-preserving translation t : L\u00b5 7\u2192 L\u2200\u0303 . The crucial clauses are those for the fixed-point operators. The atoms p introduced in the translation are required not to occur in \u03d5.\nt(\u03bdx.\u03d5) is equivalent to \u2203\u0303p(p \u2227 (p \u2192 t(\u03d5[p\\x])))\nt(\u00b5x.\u03d5) is equivalent to \u2200\u0303p( (t(\u03d5[p\\x]) \u2192 p) \u2192 p)\nThe first equation captures the intuition of a greatest fixed point as a least upper bound of the set of states that are postfixed points of \u03d5, whereas the second equation captures a least fixed point as the greatest lower bound of the set of states that are prefixed points of \u03d5. From [15] we know that bisimulation quantifiers are also expressible in the modal \u00b5-calculus, and thus these equivalences also hold in the modal \u00b5-calculus.\nHaving these tools for modal \u00b5-calculus at our disposition, let us now apply them in refinement modal \u00b5-calculus. In order to demonstrate the soundness of the axiomatization defined below, we need to expand the relativization \u2022p : L\u2200\u0303 \u2192 L\u2200\u0303 (Definition 20), singleagent version, to a version \u2022p : L\u2200\u0303 \u2192 L\u2200\u0303 by including a clause for the universal modality:\n( \u03d5)p = \u03d5p\nEmploying that expanded relativization we can expand the translation t : L\u2200 \u2192 L\u2200\u0303 (Definition 23) to a translation\nt : L\u00b5\u2200 \u2192 L\u2200\u0303\nby adding the two clauses above for fixed points (this explains why we also wrote t(\u2022) there). This translation t remains truth-preserving (due to Proposition 25 and [22, Lemma 2.43]). We recall the crucial interaction of the translation and the relativization, namely that t(\u2203\u03d5) is equivalent to \u2203\u0303p t(\u03d5)p. The translation plays an important role in the soundness proof: axioms are shown to be sound by showing that their translations are valid.\nDefinition 39 (axiomatization RML\u00b5) The axiomatization RML\u00b5 is a substitution schema of the (single-agent) axioms and rules of RML along with the axiom and rule for the modal \u00b5-calculus:\nF1 \u03d5[\u00b5x.\u03d5\\x] \u2192 \u00b5x.\u03d5 F2 From \u03d5[\u03c8\\x] \u2192 \u03c8 infer \u00b5x.\u03d5 \u2192 \u03c8\nand two new interaction axioms:"}, {"heading": "R\u00b5 \u2200\u00b5x.\u03d5 \u2194 \u00b5x.\u2200\u03d5 where \u03d5 is a df", "text": "R\u03bd \u2200\u03bdx.\u03d5 \u2194 \u03bdx.\u2200\u03d5 where \u03d5 is a df\nFor single-agent RML, see Definition 27 and Section 5.4. We recall that single-agent RML does not contain the axioms RKmulti and RKconj.\nWe emphasize that the interaction axioms have the important associated condition that the refinement quantification will only commute with a fixed-point operator if the fixed-point formula is a disjunctive formula."}, {"heading": "6.1 Soundness", "text": "The soundness proofs of Section 5.1 still apply and the soundness of F1 and F2 are well known [5], so we are left to show that R\u00b5 and R\u03bd are sound. In the proof we use the characterization of refinement quantification in terms of bisimulation quantification and relativization that was established in Proposition 25. We will also use the characterization of both fixed points in terms of bisimulation quantification as in the previous subsection.\nTheorem 40 The axioms R\u00b5 and R\u03bd are sound. \u22a3\nProof The proof consists of two cases, R\u00b5 and R\u03bd .\nCase R\u00b5\nIt is more convenient in this proof to reason about the axiom in its contrapositive form: \u2203\u03bdx.\u03d5 \u2194 \u03bdx.\u2203\u03d5. The proof demonstrates that t(\u2203\u03bdx.\u03d5) is equivalent to t(\u03bdx.\u2203\u03d5) in bisimulation quantified logic (with the universal modality). Using the translation and relativization equivalences above we have that, for any \u03d5 \u2208 L\u2200:\nt(\u2203\u03bdx.\u03d5) \u21d4 \u2203\u0303p t(\u03bdx.\u03d5)p\n\u21d4 \u2203\u0303p(\u2203\u0303q(q \u2227 (q \u2192 t(\u03d5[q\\x]))))p \u21d4 \u2203\u0303p\u2203\u0303q(q \u2227 ( (q \u2192 t(\u03d5[q\\x])))p) \u21d4 \u2203\u0303p\u2203\u0303q(q \u2227 (q \u2192 t(\u03d5[q\\x])p)) \u21d4 \u2203\u0303q\u2203\u0303p(q \u2227 (q \u2192 t(\u03d5[q\\x])p)) \u21d4 \u2203\u0303q(q \u2227 \u2203\u0303p (q \u2192 t(\u03d5[q\\x])p)) \u21d2 \u2203\u0303q(q \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x])p)) (\u2217) \u21d4 \u2203\u0303q(q \u2227 (q \u2192 \u2203\u0303p t(\u03d5[q\\x])p))\n\u21d4 \u2203\u0303q(q \u2227 (q \u2192 t(\u2203\u03d5[q\\x]))) \u21d4 t(\u03bdx.\u2203\u03d5)\nThis proof simply applies known validities of bisimulation quantifiers. Note that line (\u2217) is not an equivalence. The other direction holds if \u03d5 is a df . This we now prove.\nWe may assume w.l.o.g. that disjunctive formula \u03bdx.\u03d5 contains no free variables, i.e., \u03d5 is (also) a disjunctive formula with only the free variable x. We recall that in a disjunctive formula, a conjunction can only be between a purely propositional part and a cover modality part, and that fixed-point variables are not allowed in the propositional part (see Section 2). Importantly this means that propositional variable q (witnessing fixed-point variable x), that occurs in the formula (\u03d5[q\\x])p, can only appear in a conjunction, if it appears in the scope of a cover operator within that conjunction. This has the following significant consequence:\nIf Ms |= \u03d5[q\\x], where \u03d5 is a disjunctive formula, then there is a model Nu \u2243 q Ms such that N \u2217 u |= \u03d5[q\\x] where N \u2217 u is the restriction of Nu to states that are not successors of q states.\nThat is, whether or not Nu satisfies \u03d5[q\\x] is invariant to any successors of states in V N \u2217\n(q).7 To see this, we note that a disjunctive formula \u03d5[q\\x] is true at Ms, if and only if there is some pointed model Nu that is bisimilar to Ms, and some minimal relation \u03c1 between the states of SNu and subformulas of \u03d5[q\\x] such that:\n1. u \u03c1 \u03d5[q\\x];\n2. if v \u03c1 (\u03c81 \u2228 \u03c82), then either v \u03c1 \u03c81 or v \u03c1 \u03c82 but not both;\n3. if v \u03c1 (\u03c7\u2227\u2207\u03a6), then Nv |= \u03c7 and for every successor v \u2032 of v there is a unique \u03c8 \u2208 \u03a6\nsuch that v\u2032 \u03c1 \u03c8, and for every \u03c8 \u2208 \u03a6, there is at least one successor v\u2032 of v where v\u2032 \u03c1 \u03c8;\n4. if v \u03c1 \u03bdy.\u03c8, then v \u03c1 \u03c8[\u03bdy.\u03c8\\y].\nIt is clear that if such a relation exists then Nu |= \u03d5. As q is replacing the fixed-point variable x (which can only appear in the scope of a cover operator), the minimality of \u03c1 guarantees that if v \u03c1 q, then there is no formula \u03c8 6= q such that v \u03c1 \u03c8, and hence, for all successors v\u2032 of v there is no formula \u03c8 such that v\u2032 \u03c1 \u03c8. Consequently these successors do not impact the existence of the relation \u03c1, and thus do not affect whether or not Nu |= \u03d5[q\\x].\nAn explicit construction for Nu can be given via the tableaux of Janin and Walukiewicz [30]. Using their tableaux [30, Def. 3.1], the concept of a marking [30, Def. 3.6] can be adapted to give the required model, Nu. This construction is important for the proof now to follow.\nSuppose Ms is any countable model such that Ms |= \u2203\u0303q(q \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x]) p)),\nwhere \u03d5 is a df . We would like to build some model M\u03c9u such that\n\u2022 M\u03c9u \u2243 p,q Ms,\n\u2022 M\u03c9u |= q \u2227 (q \u2192 t(\u03d5[q\\x]) p)\nWe inductively build a sequence of (pointed) models M iu = (S i, Ri, V i, u) such that\nM iu \u2243 p,q Ms, and furthermore, the models M i are fixed up to a given set of states.\nDefinition 41 Suppose that Ms = (S,R, V, s) is a pointed tree like model (so for each t \u2208 S, there is at most one t\u2032 \u2208 S such that (t\u2032, t) \u2208 R). Let T \u2286 S \u2212 {s}. The model Ms up to T (written Ms \u2191 T ) is the model (S\n\u2032, R\u2032, V, s) where S \u2032 is the set of states that are not proper descendants of T and R\u2032 = R \u2229 (S \u2032 \u00d7 S \u2032). \u22a3\n7Throughout this proof we will assume that all models are trees or forests (i.e. every state has at most one predecessor). As every model is bisimilar to a tree, and L\u00b5\u2200 and L\u2200\u0303 are bisimulation invariant, this will not affect the validity of the presented argument.\nEffectively, the model Ms \u2191 T is the model Ms with all the successors of any state in T removed. For each i there will be a set of states T i \u2282 Si such that for all j > i, M i \u2191 T i = M j \u2191 T i.\nThis means we are able to give a well-defined limit for this sequence. At each point of the induction, T i will represent a frontier of states in the model where we require q\u2227 t(\u03d5[q\\x])p to be true. Because we are working with disjunctive formulas, we can change the submodels rooted at states in T i, without affecting the interpretation of t(\u03d5[q\\x])p in other parts of the model. This way we are able to find a single model M\u03c9s with the required properties.\nWe now define the sequence of models M i. For each i we define a model and a set of states T i \u2286 Si on which we will extend the construction. The proposition to be shown by inductive proof is\nM iu \u2243 p,q Ms \u2200u\u2032 \u2208 T i, M iu\u2032 |= \u2203\u0303q(q \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x]) p)), \u2200j < i, \u2200u\u2032 \u2208 T j, M iu\u2032 |= q \u2227 t(\u03d5[q\\x]) p, and \u2200j < i,N i \u2191 T j = N j \u2191 T j.\nTo define the base case, it is sufficient to let M0 = M and T 0 = {s}. It is clear that the induction hypothesis holds here. Now, for the inductive step, assume that the proposition holds for i. For each u \u2208 T i, we have\nM iu |= \u2203\u0303q(q \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x]) p)).\nHence, for each u \u2208 T i, there is some (tree-like) Nuvu \u2243 p,q M iu such that\nNuvu |= q \u2227 t(\u03d5[q\\x]) p \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x])p).\nWe will assume w.l.o.g. that all models Nu for u \u2208 T i and M i have disjoint sets of states. As \u03d5 is a disjunctive formula, we may further assume that Nuvu |= t(\u03d5[q\\x])\np is invariant to any successors of V N u\n(q)\\{vu}. This allows us (as the induction proceeds) to replace the submodels rooted at vu without affecting whether t(\u03d5[q\\x])p is satisfied in other parts of the model.\nWe now append the models Nuvu (for u \u2208 T i) to the model M i. Formally, let M \u2032 ="}, {"heading": "M i \u2191 T i = (S \u2032, R\u2032, V \u2032), then", "text": "Si+1 = S \u2032 \u222a \u22c3\nu\u2208T i S Nu ;\nRi+1 = R\u2032 \u222a \u22c3\nu\u2208T i R Nu \u222a {(u, v) | u \u2208 T i, vuRN u\nv}; for all r : V i+1(r) = V \u2032(r) \u22c3 u\u2208T i V Nu(r).\nFinally, we let T i+1 = \u22c3\nu\u2208T i V Nu(q).\nWe can see that the proposition to be shown holds for i+ 1 as follows:\n\u2022 M i+1s \u2243 p,q Ms since, for all u \u2208 T i, M iu \u2243 p,q Nuvu , and M i s \u2243 p,q Ms from the induction hypothesis. A {p, q}-bisimulation between M i+1s and Ms can be constructed by composing these bisimulations.8\n\u2022 \u2200v \u2208 T i+1, M i+1v |= \u2203\u0303q(q\u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x]) p)), since for all u \u2208 T i+1, u \u2208 V i+1(q),\nand Nuvu |= q \u2227 \u2203\u0303p(q \u2192 t(\u03d5[q\\x]) p).\n\u2022 \u2200j < i + 1, \u2200u \u2208 T j, M ju |= q \u2227 t(\u03d5[q\\x]) q; by the reasoning presented above, M ju |=\nt(\u03d5[q\\x])q is invariant to the successors of the states in T j+1. Therefore, if M ju |= q \u2227 t(\u03d5[q\\x])q, then M j+1u |= t(\u03d5[q\\x]) q.\n\u2022 \u2200j < i,M i \u2191 T j = M j \u2191 T j follows immediately from the construction.\nWe now let M\u03c9 = (S\u03c9, R\u03c9, V \u03c9) where\n\u2022 s\u2032 \u2208 S\u03c9 iff for some i, s\u2032 \u2208 Sj for all j > i,\n\u2022 uR\u03c9v iff for some i, uRjv for all j > i,\n\u2022 u \u2208 V \u03c9(r) iff for some i, u \u2208 V j(r) for all j > i,\nand let T \u03c9 = \u2205. It is clear that the limit step will also preserve the induction hypothesis, so we have M\u03c9u \u2243 p,q Ms and N \u03c9 |= q \u2227 (q \u2192 t(\u03d5[q\\x])p), since by construction V \u03c9(q) =\u22c3\ni<\u03c9 T i. Thus, Ms |= \u2203\u0303p\u2203\u0303q(q \u2227 (q \u2192 t(\u03d5[q\\x]) p)) (i.e., Ms |= \u2203\u03bdx.\u03d5) as required. The construction is represented in Figure 7.\nCase R\u03bd\nWe also use the contrapositive form of the axiom: \u2203\u00b5x.\u03d5 \u2194 \u00b5x.\u2203\u03d5. For any \u03d5 \u2208 L\u2200 we have that:\nt(\u2203\u00b5x.\u03d5) \u21d4 \u2203\u0303p t(\u00b5x.\u03d5)p\n\u21d4 \u2203\u0303p(\u2200\u0303q( (t(\u03d5[q\\x]) \u2192 q) \u2192 q))p \u21d4 \u2203\u0303p\u2200\u0303q( (t(\u03d5[q\\x])p \u2192 q) \u2192 q) \u21d2 \u2200\u0303q\u2203\u0303p( (t(\u03d5[q\\x])p \u2192 q) \u2192 q) (\u2217\u2217) \u21d4 \u2200\u0303q\u2203\u0303p( (t(\u03d5[q\\x])p \u2227 \u00acq) \u2228 q) \u21d4 \u2200\u0303q(\u2203\u0303p (t(\u03d5[q\\x])p \u2227 \u00acq) \u2228 q) \u21d4 \u2200\u0303q( \u2203\u0303p(t(\u03d5[q\\x])p \u2227 \u00acq) \u2228 q) (\u2217 \u2217 \u2217) \u21d4 \u2200\u0303q( (\u2203\u0303p t(\u03d5[q\\x])p \u2227 \u00acq) \u2228 q) \u21d4 \u2200\u0303q( (\u2203\u0303p t(\u03d5[q\\x])p \u2192 q) \u2192 q)\n\u21d4 \u2200\u0303q( (\u2203\u03d5[q\\x] \u2192 q) \u2192 q) \u21d4 t(\u00b5x.\u2203\u03d5)\n8Specifically, let Ru be the {p, q}-bsimulation between M iu and N u vu , and R i be the {p, q}-bisimulation between M is and Ms. We define the {p, q}-bisimulation R i+1 from M i+1s to Ms by: for all t \u2208 S i+1, for all t\u2032 in S, (t, t\u2032) \u2208 Ri+1 if and only if either (t \u2208 Si and (t, t\u2032) \u2208 Ri), or (t \u2208 SN u\n, and for some v \u2208 Si, (t, v) \u2208 Ru and (v, t\u2032) \u2208 Ri). It is straightforward to check that Ri+1 is a bisimulation.\nThe equivalence in (***) is true because is the existential modality which quantifies over all states in the model. Obviously, the implication in line (**) is only true in one direction (the usual quantifier swap \u2203\u2200 \u2192 \u2200\u2203).\nTo prove the other direction in the equivalence \u2203\u00b5x.\u03d5 \u2194 \u00b5x.\u2203\u03d5, we now show directly that |= \u00b5x.\u2203\u03d5 \u2192 \u2203\u00b5x.\u03d5 in refinement \u00b5-calculus, for \u03d5 a df (observe that \u00b5x.\u03d5 is then a df as well). We use the inductive characterization of \u00b5x.\u2203\u03d5 of [5] which tells that Ms |= \u00b5x.\u2203\u03d5 if and only if s \u2208 \u2016\u2203\u03d5\u2016\u03c4 for some ordinal \u03c4 , where we recall the definition of the semantic operation \u2016 \u2022 \u2016: \u2016\u2203\u03d5\u20160 = \u2205, and s \u2208 \u2016\u2203\u03d5\u2016\u03c4 whenever M \u03c4 s |= \u2203\u03d5, where M\n\u03c4 = M [\u03c3] with \u03c3 = x 7\u2192 \u22c3 \u03c4 \u2032<\u03c4 \u2016\u2203\u03d5\u2016\u03c4 \u2032.\nSuppose Ms |= \u00b5x.\u2203\u03d5. Since L \u00b5 \u2200 is bisimulation invariant, without loss of generality we may suppose that M is a countable tree-like model. As Ms satisfies \u00b5x.\u2203\u03d5, there must be some least ordinal \u03c4 whereby s \u2208 \u2016\u2203\u03d5\u2016\u03c4 . We give a proof by induction over \u03c4 that s \u2208 \u2016\u2203\u03d5\u2016\u03c4 implies Ms |= \u2203\u00b5x.\u03d5. The base case where \u03c4 = 0 is trivial. Now consider M \u03c4 = M [\u03c3] with \u03c3 = x 7\u2192 \u22c3 \u03c4 \u2032<\u03c4 \u2016\u2203\u03d5\u2016\u03c4 \u2032. Then M \u03c4 s |= \u2203\u03d5. As \u00b5x.\u03d5 is a df , there is a refinement of M \u03c4 with a frontier such that x may only be true at s or on this frontier, and no point beyond the frontier affects the interpretation of \u03d5. Formally, there is a set of states {u0, u1, ...} \u2208 V \u03c4 (x) such that M \u2032s |= \u2203\u03d5 (i.e., M \u2032 s |= \u2203\u0303p t(\u03d5)\np), where M \u2032 = (S \u2032, R\u2032, V \u2032) with\n\u2022 S \u2032 \u2286 S\u03c4 is the set of states reachable from s, but not from any ui;\n\u2022 V \u2032(x) = {t, u0, u1, ...}, V \u2032(y) = V M\n\u03c4\n(y) for y 6= x; and\n\u2022 R\u2032 = R\u03c4\\{(ui, t) | t \u2208 S \u03c4 , i = 0, 1, ...}.\nWe note that M \u2032s is a refinement of M \u03c4 s . Now as for each i, ui \u2208 \u2016\u2203\u03d5\u2016j for some j < \u03c4 , by the inductive hypothesis we may assume there is some model N i = (Si, Ri, V i) where N ivi\nM \u03c4ui and N i ui |= \u00b5x.\u03d5. We may append these models to M \u2032, to define M\u2217 = (S\u2217, R\u2217, V \u2217) where S\u2217 = S \u2032\u222a \u22c3 i S i, R\u2217 = R\u2032\u222a \u22c3 i R i\u222a{(t, vi) | (t, ui) \u2208 R \u2032}, and V \u2217(y) = V \u2032(y)\u222a \u22c3 i V i(y) for all y \u2208 P . (Notice the similar construction in the soundness proof of axiom RK.) It is clear that M\u2217s is a refinement of Ms, and by the axiom F1 we can see M \u2217 s |= \u00b5x.\u03d5 as required.\nThe general form of R\u00b5 is not sound. For example, take \u03d5 = \u00b5z.3(p \u2192 q) \u2192 3(\u00acp \u2192 x). Then \u2200\u00b5x.\u03d5 is true if p is true at every immediate successor of the current state, whereas \u00b5x.\u2200\u03d5 is only true at states with no successor. Likewise R\u03bd is not true in the general case, as can be seen by taking \u03d5 = p \u2227 2(3\u22a4 \u2192 x). Then \u03bdx.\u2200\u03d5 is true if and only if p is true at every reachable state, and \u2200\u03bdx.\u03d5 is true only if p is true at every state within one step."}, {"heading": "6.2 Completeness", "text": "The completeness proof of RML\u00b5 proceeds exactly as for Theorem 38, replacing the formulas in cover logic with disjunctive formulas, to get a statement similar to that of Proposition 36.\nProposition 42 Every formula of L\u00b5\u2200 is equivalent to a formula of L \u00b5. \u22a3\nProof Given a formula \u03c8, we prove by induction on the number of the occurrences of \u2203 in \u03c8 that it is equivalent to an \u2203-free formula, and therefore to a formula in the modal \u00b5-calculus L\u00b5. The base is trivial. Now assume \u03c8 contains n + 1 \u2203-operators. Choose a subformula of type \u2203\u03d5 of our given formula \u03c8, where \u03d5 is \u2203-free (i.e. choose an innermost \u2203). As \u03d5 is \u2203-free, it is semantically equivalent to a formula in disjunctive normal form, and by the completeness of Kozen\u2019s axiom system [59] this equivalence is provable in RML\u00b5. By NecR and R it follows that \u2203\u03d5 is provably equivalent to some formula \u2203\u03c8 where \u03c8 is a disjunctive formula (analogously to Proposition 32 one can easily show that RML\u00b5 satisfies substitution of equivalents). Thus without loss of generality, we may assume in the following that \u03d5 is in disjunctive normal form. We may now proceed by induction over the complexity of \u03d5, and conclude that \u2203\u03d5 is logically equivalent to a formula \u03c7 without \u2203. All cases of this induction are as before, we only show the final two, different cases:\n\u2022 \u2203\u00b5x.\u03d5 iff \u00b5x.\u2203\u03d5 (by R\u03bd noting that all subformulas of a disjunctive formula are themselves disjunctive); IH.\n\u2022 \u2203\u03bdx.\u03d5 iff \u03bdx.\u2203\u03d5 (by R\u00b5); IH.\nReplacing \u2203\u03d5 by \u03c7 in \u03c8 gives a result with one less \u2203-operator, to which the (original) induction hypothesis applies.\nTheorem 43 The axiom schema RML\u00b5 is sound and complete for the logic RML\u00b5 \u22a3\nProof Soundness follows from Theorem 40 and Theorem 28. To see RML\u00b5 is complete, suppose \u03d5 \u2208 L\u00b5\u2200 is a valid formula. Then by Lemma 42, \u03d5 is provably equivalent to some valid formula \u03c8 \u2208 L\u00b5. As \u03c8 is valid, it must be provable since Prop, K, F1, F2, NecK, and MP give a sound and complete proof system for the modal \u00b5-calculus [59]. A proof of \u03d5 follows by MP."}, {"heading": "7 Complexity", "text": "Decidability for both L\u2200 and L \u00b5 \u2200 follows from the fact that a computable translation is given in the completeness proofs of Sections 5 and 6: note that the given translations to L and L\u00b5 respectively, are recursive and involve transforming formulas into their disjunctive normal forms. Hence they are non-elementary in the size of the original formula. This non-elementary procedure for L\u00b5\u2200 is optimal as shown in Section 7.1 below.\nUnfortunately we were not able to corroborate in this paper the upper complexity claims for RML reported in [56]. But towards some indication of a result in that direction, we further establish a doubly exponential succinctness proof for L\u2200 in Section 7.2. (On complexity, see also \u2018Recent results\u2019 in Section 8.)"}, {"heading": "7.1 RML\u00b5 is non-elementary", "text": "This section is dedicated to the proof of the following result.\nTheorem 44 The satisfiability problem for RML\u00b5 is non-elementary, even for the singleagent setting. \u22a3\nIn the rest of this section, we only consider a single-agent setting. First, we recall a fragment, written CTL\u2212, of the standard branching-time logic Computation Tree Logic (CTL) [14], which in turn is a fragment of L\u00b5 (see also the example Section 4.2).\nCTL\u2212 \u220b \u03d5 ::= \u22a4 | \u22a5| p | \u00ac\u03d5 | \u03d5 \u2227 \u03d5 |2\u03d5 | 3\u03d5 | EF\u03d5 | AF\u03d5\nLet M be a model and s be an M-state. A path from s is a finite or infinite sequence of states \u03c0 = s0, s1, . . . s.t. s0 = s and each si+1 is an successor of si. Only the semantics of AF and EF is recalled (as for other formulas it is clear):\nMs |= EF\u03d5 iff there are a maximal path \u03c0 = s0, s1, . . . from s and i \u2265 0 such that Msi |= \u03d5 Ms |= AF\u03d5 iff for each maximal path \u03c0 = s0, s1, . . . from s, there is i \u2265 0 such that Msi |= \u03d5\nDirectly translating CTL\u2212 in L\u00b5 is routine via the following mapping \u03c4 : CTL\u2212 \u2192 L\u00b5, defined by induction over the formulas: \u03c4(\u22a4) = \u22a4, \u03c4(p) = p, \u03c4(\u00ac\u03d5) = \u00ac\u03c4(\u03d5), \u03c4(\u03d5 \u2227 \u03d5\u2032) =\n\u03c4(\u03d5) \u2227 \u03c4(\u03d5\u2032), \u03c4(2\u03d5) = 2\u03c4(\u03d5), \u03c4(3\u03d5) = 3\u03c4(\u03d5), \u03c4(EF\u03d5) = \u00b5x.\u03c4(\u03d5) \u2228 3x, \u03c4(AF\u03d5) = \u00b5x.\u03c4(\u03d5) \u2228 2x.\nWe also use standard abbreviations for the duals AG\u03d5 iff \u00acEF\u00ac\u03d5 (\u2018universal always\u2019), and EG\u03d5 iff \u00acAF\u00ac\u03d5 (\u2018existential always\u2019). A CTL\u2212 formula is in positive form if negation is applied only to propositional variables. A CTL\u2212 formula \u03d5 is existential if it is in positive form and there are no occurrences of the universal modalities AF and AG and the modality 2. The following can be proved by using Proposition 8, enriched for the case of EF formulas (with a transfinite induction argument for this fixed-point formula).\nProposition 45 Let Ms and Nt be two models with Ms Nt. Then for each existential CTL\u2212 formula \u03d5, Nt |= \u03d5 implies Ms |= \u03d5. \u22a3\nDefinition 46 (Refinement CTL\u2212) Refinement CTL\u2212 (CTL\u2212\u2200 , for short) is the extension of CTL\u2212 with the refinement quantifiers \u2203 and \u2200. \u22a3\nDefinition 47 (Refinement Quantifier Alternation Depth) We first define the alternation length \u2113(\u03c7) of finite sequence \u03c7 \u2208 {\u2203, \u2200}\u2217 of quantifiers, as the number of alternations of existential and universal refinement quantifiers in \u03c7. Formally, \u2113(\u01eb) = 0, \u2113(Q) = 0 for every Q \u2208 {\u2203, \u2200}\u2217, and \u2113(QQ\u2032\u03c7) = \u2113(Q\u2032\u03c7) if Q = Q\u2032, \u2113(Q\u2032\u03c7) + 1 otherwise.\nGiven a L\u2200 (resp., L \u00b5 \u2200, resp., CTL \u2212 \u2200 ) formula \u03d5, the refinement quantifier alternation depth \u03b4(\u03d5) of \u03d5 is defined via the standard tree-encoding T (\u03d5) of \u03d5, where each node is labeled by either a modality, a boolean connective, or a propositional variable. Then, \u03b4(\u03d5) is the maximum of the alternation lengths \u2113(\u03c7) where \u03c7 is the sequence of refinement quantifiers along a maximal path of T (\u03d5) from the root. \u22a3\nTheorem 48 Let the class Ck = {\u03d5 \u2208 CTL \u2212 \u2200 | \u03b4(\u03d5) \u2264 k}. The satisfiability problem for Ck is k-Expspace-hard, for any k. \u22a3\nTheorem 48 is proved by a polynomial-time reduction from satisfiability of Quantified Propositional Temporal Logic (QPTL) [50]. First, we recall the syntax and the semantics of QPTL. The syntax of QPTL formulas \u03d5 over a countable set P of propositional variables is defined as follows:\n\u03d5 ::= p | \u00ac\u03d5 | \u03d5 \u2227 \u03d5 | \u03d5 \u2228 \u03d5 | X\u03d5 | F\u03d5 | \u2203p.\u03d5\nwhere p \u2208 P , X is the \u2018next\u2019 modality, F is the \u2018eventually\u2019 modality, and \u2203 is the existential quantifier.9 We also use standard abbreviation G\u03d5 for \u00acF\u00ac\u03d5 (\u2018always\u2019).\nThe semantics is given w.r.t. elements of (2P )\u03c9, namely infinite words w over 2P . Beforehand, we need some technical notions. Let w \u2208 (2P )\u03c9. For each i \u2265 0, w(i) denotes the ith symbol of w. Moreover, for each P \u2032 \u2286 P , we define the equivalence relation \u2261P \u2032 over (2P )\u03c9: two infinite words w1 and w2 are \u2261P \u2032-equivalent whenever their projections onto P \u2032 are equal. The projection of an infinite word w onto P \u2032, written proj(w, P \u2032), is obtained\n9We distinguish (domain) quantifiers \u2203 and \u2200 in use here, from the refinement quantifiers \u2203 and \u2200, and from the bisimulation quantifiers \u2203\u0303 and \u2200\u0303.\nby removing from each symbol of w all the propositions in P \\ P \u2032. Hence, w1 \u2261P \u2032 w2 iff proj(w1, P \u2032) = proj(w2, P \u2032).\nGiven a QPTL formula \u03d5, an infinite word w over 2P , and a position h \u2265 0 along w, the satisfaction relation (w, h) |= \u03d5 is inductively defined as follows (we omit the clauses for the boolean connectives):\n(w, h) |= p iff p \u2208 w(h) (w, h) |= X\u03d5 iff (w, h+ 1) |= \u03d5 (w, h) |= F\u03d5 iff there is h\u2032 \u2265 h such that (w, h) |= \u03d5 (w, h) |= \u2203p.\u03d5 iff there is w\u2032, w\u2032 \u2261P\\{p} w and (w \u2032, h) |= \u03d5\nWe say that the word w satisfies \u03d5, written w |= \u03d5, if (w, 0) |= \u03d5. A QPTL formula \u03d5 is in positive normal form if it is of the form Q1p1.Q2p2. . . . Qnpn.\u03d5n+1, where Qj \u2208 {\u2203, \u2200} for each 1 \u2264 j \u2264 n, and \u03d5n+1 is a quantification-free QPTL-formula in which negation is applied only to propositional variables10. The quantifier alternation depth of Q1p1.Q2p2. . . . Qnpn.\u03d5n+1 is the number of alternations of (existential and universal) quantifiers in the string Q1Q2 . . . Qn. The following is a well-known result.\nTheorem 49 [50] Let k \u2265 0. Then, the satisfiability problem for the class of QPTL formulas in positive normal form whose quantifier alternation depth is k is k-Expspacehard. \u22a3\nNote that Theorem 49 holds even if we assume that formulas in positive normal form like Q1p1.Q2p2. . . .Qnpn.\u03d5n+1 (with \u03d5n+1 quantification-free) are such that p1, . . . , pn are pairwise distinct, each proposition occurring in \u03d5n+1 is in {p1, . . . , pn}, and Qn = \u2200.\nTheorem 48 directly follows from Theorem 49 and the following theorem, whose proof is given in the rest of this section.\nTheorem 50 For every \u03d5 \u2208 QPTL, one can construct in time polynomial in the size of \u03d5 a formula \u03d5\u0303 \u2208 CTL\u2212\u2200 , such that \u03d5 is satisfiable if, and only if, \u03d5\u0303 is satisfiable. Moreover, the refinement quantifier alternation depth of \u03d5\u0303, \u03b4(\u03d5\u0303), is equal to the quantifier alternation depth of \u03d5. \u22a3\nBefore proving Theorem 50, we need additional definitions. Let P = {p1, . . . , pn} and P\u0303 = P \u222a {p0, p1, . . . , pn}, where p0, p1, . . . , pn are fresh propositional variables (intuitively, pi is used to encode the negation of pi for each 1 \u2264 i \u2264 n, and p0 is a new variable that will be used to mark a path). For a model M and two states s and s\u2032 in M , s\u2032 is reachable from s if there is a finite path from s leading to s\u2032. Let 0 \u2264 j \u2264 n. A pointed model Ms (over P\u0303 ) is well-formed w.r.t. j if the following holds:\n1. for each state s\u2032 of M which is reachable from s, there is exactly one proposition p \u2208 P\u0303 such that s\u2032 \u2208 V M(p) (we say that s\u2032 is a p-state); moreover, s is a p0-state;\n10Every QPTL formula is constructively equivalent to a formula in positive normal form, with linear size.\n2. each state s\u2032 reachable from s which is not a p0-state has no successor;\n3. each p0-state s \u2032 which is reachable from s satisfies: (i) s\u2032 has some p0-successor, (ii)\nfor all 1 \u2264 i \u2264 j, either s\u2032 has a pi-state successor or (exclusive) a pi-state successor, and (iii) for all j+1 \u2264 i \u2264 n, s\u2032 has both a pi-state successor and a pi-state successor.\nFor each 0 \u2264 j \u2264 n, the following CTL\u2212 formula \u03c8j over P\u0303 characterizes the set of pointed models which are well-formed w.r.t. j:\n\u03c8j := p0 \u2227 AG {[\u2228 p\u2208P\u0303 (p \u2227 \u2227 p\u2032\u2208P\u0303\\{p} \u00acp \u2032) ] \u2227 [ \u00acp0 \u2192 2\u22a5 ] \u2227\np0 \u2192 [ 3p0 \u2227 \u2227 j+1\u2264i\u2264n(3pi \u2227 3pi) \u2227 \u2227 1\u2264i\u2264j(3(pi \u2228 pi) \u2227 (2\u00acpi \u2228 2\u00acpi))\n]}\nIntuitively, \u03c8j enforces the existence of infinite paths \u03c0 = s0s1 . . . which visit only p0states si such that the following holds: the set of successors of si \u2018encodes\u2019 a specific truth valuation of the variables p1, . . . , pj and all the possible truth valuations of the variables pj+1, . . . , pn.\nA pointed model Ms is well-formed if it is well-formed w.r.t. j for some 0 \u2264 j \u2264 n. In this case, we say that Ms is minimal if, additionally, each p0-state which is reachable from s has exactly one p0-successor.\nA well-formed pointed model Ms encodes a set of infinite words over 2 P , written words(Ms), given by: w \u2208 words(Ms) iff there is an infinite path \u03c0 = s0, s1, . . . of M from s (note that \u03c0 consists of p0-states) such that for all h \u2265 0 and 1 \u2264 j \u2264 n, either pj \u2208 w(h) and sh has some pj-successor, or pj /\u2208 w(h) and sh has some pj-successor.\nNote that if Ms is well-formed w.r.t. 0, then words(Ms) = (2 P )\u03c9. If instead Ms is well-formed w.r.t. j for some 0 < j \u2264 n and Ms is also minimal, then there is an infinite word uj \u2208 (2 {p1,...,pj})\u03c9 such that words(Ms) = {w \u2208 (2 P )\u03c9 | proj(w, {p1, . . . , pj}) = uj}. In particular, when j = n, words(Ms) is a singleton. Also, one can easily see that if Ms Nt then words(Ms) \u2287 words(Nt).\nConstruction of the CTL\u2212\u2200 formula \u03d5\u0303 (in Theorem 50). Pick an QPTL formula \u03d5 = Q1p1.Q2p2. . . . Qnpn.\u03d5n+1. For each 1 \u2264 j \u2264 n, we let \u03d5j = Qjpj.Qj+1pj+1. . . . Qnpn.\u03d5n+1 (note that \u03d51 corresponds to \u03d5).\nFirst, we construct a CTL\u2212\u2200 formula \u03d5\u0303j over P\u0303 by using the CTL \u2212 formulas \u03c8j\u22121, for each 1 \u2264 j \u2264 n + 1. The construction is based on an induction on n+ 1 \u2212 j = 0, . . . , n as follows:\nBase case (j = n+1). Recall that \u03d5n+1 is a quantification-free QPTL formula in positive normal form over P . Let \u03a5 be the following mapping from the set of quantificationfree QPTL formulas \u03be over P in positive normal form to the set of existential CTL\u2212\nformulas over P\u0303 (it is defined by induction).\n\u2022 \u03a5(p) = 3p and \u03a5(\u00acp) = 3p for each p \u2208 P ;\n\u2022 \u03a5(\u03be1 \u2228 \u03be2) = \u03a5(\u03be1) \u2228\u03a5(\u03be2) and \u03a5(\u03be1 \u2227 \u03be2) = \u03a5(\u03be1) \u2227\u03a5(\u03be2);\n\u2022 \u03a5(X\u03be) = 3(p0 \u2227 \u03a5(\u03be)), \u03a5(F\u03be) = EF(p0 \u2227 \u03a5(\u03be)), and \u03a5(G\u03be) = EG(p0 \u2227 \u03a5(\u03be)).\nThen, \u03d5\u0303n+1 := \u03a5(\u03d5n+1).\nInduction case (1 \u2264 j \u2264 n). Recall \u03d5j = Qjpj.\u03d5j+1.\nThen, \u03d5\u0303j := { \u2203(\u03c8j \u2227 \u03d5\u0303j+1) if Qj = \u2203 \u2200(\u03c8j \u2192 \u03d5\u0303j+1) if Qj = \u2200\nFinally, the CTL\u2212\u2200 formula \u03d5\u0303 over P\u0303 is given by \u03d5\u0303 := \u03c80 \u2227 \u03d5\u03031.\nCorrectness of the construction. Note that the size of \u03d5\u0303 is polynomial in the size of \u03d5. Moreover, the refinement quantifier alternation depth of \u03d5\u0303 is equal to the quantifier alternation depth of \u03d5. Thus, in order to prove Theorem 50, it remains to show that \u03d5 is satisfiable iff \u03d5\u0303 is satisfiable. For this, we need three preliminary lemmata.\nLemma 51 Let Ms be a pointed model which is well-formed w.r.t. n and minimal, with words(Ms) = {w}. Then, for each quantification-free QPTL formula \u03be in positive normal form, w |= \u03be if and only if Ms |= \u03a5(\u03be). \u22a3\nProof Let \u03c0 = s0, s1, . . . be the unique infinite path of M from state s (note that \u03c0 consists of p0-states). Then, by a straightforward structural induction, one can show that for each quantification-free QPTL formula in positive normal form \u03be, the following holds: for all h \u2265 0, Msh |= \u03a5(\u03be) iff (w, h) |= \u03be. Hence, the result follows.\nLet 0 \u2264 j \u2264 n and let Ms be a pointed model which is well-formed w.r.t. j. For each j \u2264 i \u2264 n, an h-segment of Ms is a refinement Nt of Ms which is well-formed w.r.t. h and minimal. Note that for each w \u2208 words(Ms) and for each j \u2264 h \u2264 n, by construction, there exists an h-segment Nt of Ms such that w \u2208 words(Nt).\nLemma 52 Let 1 \u2264 j \u2264 n and Ms be a pointed model which is well-formed w.r.t. j \u2212 1 such that for each w \u2208 words(Ms), w |= \u03d5j. Then, Ms |= \u03d5\u0303j. \u22a3\nProof The proof is by induction on n\u2212 j = 0, . . . , n\u2212 1.\nBase case (j = n). Recall \u03d5n = \u2200pn.\u03d5n+1, where \u03d5n+1 is a quantification-free QPTL formula in positive normal form. By construction, \u03d5\u0303n = \u2200(\u03c8n \u2192 \u03a5(\u03d5n+1) ). Let Nt be a refinement of Ms which satisfies formula \u03c8n (if any). We need to show that Nt |= \u03a5(\u03d5n+1). By definition of \u03c8n, Nt is well-formed w.r.t. n. Let N \u2032 u be any n-\nsegment of Nt, and let words(N \u2032 u) = {w}. By transitivity, N \u2032 u is a refinement of Ms, so that w \u2208 words(Ms). Thus, by hypothesis, w |= \u03d5n = \u2200 pn.\u03d5n+1, which implies w |= \u03d5n+1. By Lemma 51, it follows that N \u2032 u |= \u03a5(\u03d5n+1). Since N \u2032 u is a refinement of Nt and \u03a5(\u03d5n+1) is an existential CTL \u2212 formula, by Proposition 45 we deduce that Nt |= \u03a5(\u03d5n+1) as well. Hence, the result holds.\nInduction step (1 \u2264 j \u2264 n\u2212 1). By construction, there are two cases:\n(1) \u03d5j = \u2203 pj .\u03d5j+1 and \u03d5\u0303j = \u2203(\u03c8j \u2227 \u03d5\u0303j+1): let w0 \u2208 words(Ms). By hypothesis, w0 |= \u03d5j . Hence, there is infinite word w \u2032 0 over 2\nP such that w\u20320 \u2261P\\{pj} w0 and w\u20320 |= \u03d5j+1. Since Ms is well-formed w.r.t. j \u2212 1 and w0 \u2208 words(Ms), it follows that w\u20320 \u2208 words(Ms) as well. Let Ns be any j-segment of Ms such that w \u2032 0 \u2208 words(Ns). By definition of \u03c8j , Ns |= \u03c8j . Thus, it suffices to show that Ns |= \u03d5\u0303j+1. Since Ns is well-formed w.r.t. j and minimal, and w \u2032 0 \u2208 words(Ns), it holds that for each w\u2032 \u2208 words(Ns), w \u2032 \u2261{p1,...,pj} w \u2032 0. Since every proposition in {pj+1, . . . , pn} does not occur free in \u03d5j+1 and w \u2032 0 |= \u03d5j+1, it follows that for each w \u2032 \u2208 words(Ns), w \u2032 |= \u03d5j+1. Thus, by the induction hypothesis, we obtain that Ns |= \u03d5\u0303j+1, and the result holds.\n(2) \u03d5j = \u2200 pj.\u03d5j+1 and \u03d5\u0303j = \u2200(\u03c8j \u2192 \u03d5\u0303j+1): let Nt be a refinement of Ms which satisfies formula \u03c8j (if any). We need to show that Nt |= \u03d5\u0303j+1. By definition of \u03c8j , Nt is well-formed w.r.t. j. Thus, by the induction hypothesis it suffices to show that for each w \u2208 words(Nt), w |= \u03d5j+1. Let w \u2208 words(Nt). Since Nt is a refinement of Ms, it holds that w \u2208 words(Ms). Thus, by hypothesis, w |= \u03d5j = \u2200 pj .\u03d5j+1. Hence, w |= \u03d5j+1, and the result follows.\nLemma 53 Let 1 \u2264 j \u2264 n and let Ms be a pointed model which is well-formed w.r.t. (j\u22121) and such that Ms |= \u03d5\u0303j. Then, there is a (j \u2212 1)-segment Nt of Ms such that Nt |= \u03d5\u0303j and for each w \u2208 words(Nt), w |= \u03d5j. \u22a3\nProof The proof is by induction on n \u2212 j = 0, . . . , n \u2212 1, for which there are two cases. Recall that \u03d5n = \u2200pn.\u03d5n+1. (1) \u03d5j = \u2200 pj .\u03d5j+1 and \u03d5\u0303j = \u2200(\u03c8j \u2192 \u03d5\u0303j+1): let Nt be any (j \u2212 1)-segment of Ms. By hypothesis Ms |= \u03d5\u0303j . Since every refinement of Nt is also a refinement of Ms, it follows that Nt |= \u03d5\u0303j. Thus, it suffices to show that for each w \u2208 words(Nt), w |= \u03d5j . Fix w \u2208 words(Nt) and let w\u2032 be an infinite word over 2P such that w\u2032 \u2261P\\{pj} w. Since Nt is well-formed w.r.t. j\u22121, w\u2032 \u2208 words(Nt) as well. Let N \u2032 u be a j-segment of Nt such that w\n\u2032 \u2208 words(N \u2032u). By definition of \u03c8j , N \u2032 u |= \u03c8j . Thus, since Nt |= \u03d5\u0303j, we deduce that N \u2032 u |= \u03d5\u0303j+1. There are two cases:\n\u2022 j = n (base step): by construction, words(N \u2032u) is a singleton, \u03d5\u0303n+1 = \u03a5(\u03d5n+1), and \u03d5n+1 is a quantification-free QPTL-formula in positive normal form. Since w\n\u2032 \u2208 words(N \u2032u) and N \u2032 u |= \u03d5\u0303n+1, by Lemma 51, it follows that w \u2032 |= \u03d5n+1.\n\u2022 j \u2264 n \u2212 1 (induction step): since w\u2032 \u2208 words(N \u2032u) and N \u2032 u |= \u03d5\u0303j+1, by the induction\nhypothesis (note that since N \u2032u is minimal, for each j-segment N \u2032\u2032 v of N \u2032 u, words(N \u2032\u2032 v ) = words(N \u2032u)), it follows that w \u2032 |= \u03d5j+1.\nThus, in both cases w\u2032 |= \u03d5j+1. Since w \u2032 is an arbitrary infinite word over 2P such that w\u2032 \u2261P\\{pj} w, we obtain that w |= \u2200 pj .\u03d5j+1 = \u03d5j, and the result follows.\n(2) \u03d5j = \u2203 pj.\u03d5j+1, \u03d5\u0303j = \u2203(\u03c8j \u2227 \u03d5\u0303j+1), and j \u2264 n \u2212 1 (induction step): since Ms |= \u03d5\u0303j , there is a refinement Nt of Ms satisfying both \u03c8j and \u03d5\u0303j+1. By definition of \u03c8j , Nt is well-formed w.r.t. j. Thus, since Nt |= \u03d5\u0303j+1 and j \u2264 n \u2212 1, by the induction hypothesis, there is a j-segment N \u2032u of Nt such that N \u2032 u |= \u03c8j , N \u2032 u |= \u03d5\u0303j+1, and for each w \u2208 words(N \u2032 u), w |= \u03d5j+1. Since Nt is a refinement of Ms, it easily follows that N \u2032 u is the refinement of some (j \u2212 1)-segment M \u2032v of Ms. Since N \u2032 u |= \u03c8j \u2227 \u03d5\u0303j+1, it holds that M \u2032 v |= \u03d5\u0303j . Hence, it suffices to show that for each w \u2208 words(M \u2032v), w |= \u03d5j. Let w \u2208 words(M \u2032 v). Then, since M \u2032v (resp., N \u2032 u) is minimal and well-formed w.r.t. j \u2212 1 (resp., j) and N \u2032 u is a refinement of M \u2032v, it follows that there is w \u2032 \u2208 words(N \u2032u) such that w \u2032 \u2261P\\{pj} w. Since w \u2032 |= \u03d5j+1, we obtain that w |= \u2203 pj.\u03d5j+1 = \u03d5j, and the result follows.\nNow, we can prove the correctness of the construction.\nTheorem 54 \u03d5 is satisfiable if, and only if, \u03d5\u0303 is satisfiable. \u22a3\nProof First, assume that \u03d5\u0303 = \u03c80 \u2227 \u03d5\u03031 is satisfiable. Hence, there is a pointed model Ms which satisfies both \u03c80 and \u03d5\u03031. By definition of formula \u03c80, it follows that Ms is wellformed w.r.t. 0. Since Ms |= \u03d5\u03031, by Lemma 53, we deduce that there is an infinite word w over 2P such that w |= \u03d51. Since \u03d5 = \u03d51, it follows that \u03d5 is satisfiable.\nNow, assume that \u03d5 is satisfiable. Since any proposition in P does not occur free in \u03d5, it follows that for each infinite word w over 2P , w |= \u03d5. Let Ms be any pointed model which is well-formed w.r.t. 0. By definition of formula \u03c80, it holds that Ms |= \u03c80. Moreover, since w |= \u03d5 for each w \u2208 words(Ms), and \u03d5 = \u03d51, by Lemma 52 it follows that Ms |= \u03d5\u03031. Therefore, Ms |= \u03c80 \u2227 \u03d5\u03031 = \u03d5\u0303. Hence, \u03d5\u0303 is satisfiable.\nBy using Theorem 48 and the fact that there exists a linear time translation of CTL\u2212\u2200 into L\u00b5\u2200 (see page 45) we now obtain the required proof of Theorem 44."}, {"heading": "7.2 Succinctness", "text": "In this section we establish the following result.\nTheorem 55 RML is doubly exponentially more succinct than K, and RML\u00b5 is doubly exponentially more succinct than modal \u00b5-calculus. \u22a3\nTheorem 55 directly follows from the following result whose proof is given in the rest of this section.\nProposition 56 There is a finite set P of propositional variables and a family (\u03d5n)n\u2208N of one-agent L\u2200 formulas over P such that for each n \u2208 N, \u03d5n has size O(n\n2) and refining quantifier alternation depth 2, and each equivalent one-agent L\u00b5 formula has size at least 22 \u2126(n) .11 \u22a3\n11Recall that f(n) \u2208 \u2126(g(n)) iff g(n) \u2208 O(f(n)).\nConstruction of the L\u2200 formulas \u03d5n in Proposition 56: let P = {l, r,#, 0, 1, a, b}. An n-configuration is a string on {a, b} of length exactly 22 n\n. We define a class Cn of pointed models, where each pointed model in the class encodes, in a suitable way, a pair of n-configurations. Then, we construct the L\u2200 formula \u03d5n in such a way that the following holds: a pointed model Ms \u2208 Cn satisfies \u03d5n iff the two n-configurations encoded by Ms coincide. In order to formally define the class Cn, we need additional definitions. An nblock is a pair bl = (c, i) such that c \u2208 {a, b} and 1 \u2264 i \u2264 22 n\n. We say that c is the content of bl and i is the position of bl. Intuitively, bl represents the ith symbol of some n-configuration. First, we define an encoding of (c, i) by a set code(c, i) of strings over 2P of length n + 3. Since 1 \u2264 i \u2264 22 n\n, i can be encoded by a binary string over {0, 1} of length exactly 2n. Moreover, we keep track, for each 1 \u2264 j \u2264 2n, of the binary encoding (a string over {0, 1} of length n)12 of the position j of the jth bit in the binary encoding of i. This leads to the following definition. An n-sub-block is a string over 2P of length n+2 of the form sbl = {#}, {b1}, . . . , {bn}, {B}, where b1, . . . , bn, B \u2208 {0, 1}. The content of sbl is B and the position of sbl is the integer 1 \u2264 j \u2264 2n whose binary encoding is b1, . . . , bn. Intuitively, sbl encodes the position and the content B of a bit along the binary encoding of an integer 1 \u2264 i \u2264 22 n\n. Then, code(c, i) is the set of strings over 2P of length n+3 such that\n\u2022 for each u \u2208 code(c, i), u = sbl \u00b7 {c}, where sbl is an n-sub-block whose position j and content b satisfy the following: b is the jth bit in the binary encoding of i.\n\u2022 for each 1 \u2264 j \u2264 2n, let Bj be the jth bit in the binary encoding of i and sblj be the n-sub-block whose position is j and whose content is Bj . Then, sblj \u00b7 {c} \u2208 code(c, i).\nLet Ms be a pointed model over P . We denote by Traces(Ms) the set of finite or infinite strings over 2P of the form (V M)\u22121(s0), (V\nM)\u22121(s1), . . . such that s0, s1, . . . is a maximal path of M starting from s. A pointed model Ms encodes an n-block (c, i) if\nTraces(Ms) = code(c, i) and Ms |= n\u22121\u2227\nd=0\n2 d(31 \u2227 30) \u2208 L\nNote that the set of pointed models encoding (c, i) is nonempty. Let (wl, wr) be a pair of n-configurations. A pointed model Ms encodes the pair (wl, wr) if it holds that:\n\u2022 s has two successors sl and sr (called the left successor and right successor of s, respectively). Moreover, (V M)\u22121(s) = \u2205, (V M)\u22121(sl) = {l} and (V M)\u22121(sr) = {r};\n\u2022 for each dir \u2208 {l, r}, sdir has 2 2n successors s1,dir, . . . , s22n ,dir. Moreover, for each\n1 \u2264 i \u2264 22 n\n, Msi,dir encodes the n-block (ci,dir, i), where ci,dir is the ith symbol of the n-configuration wdir.\n12Here, it is not relevant to specify the form of the binary encoding which is used.\nIf additionally wl = wr, then we say that Ms is balanced. The class Cn is the class of pointed models Ms such that Ms encodes some pair (wl, wr) of n-configurations. In order to define the L\u2200 formula \u03d5n (for each n \u2265 0), we first show Lemma 57. This lemma asserts that there is an L\u2200 formula \u03c8n of size O(n\n2) which allows one to select, for a given pointed model Ms \u2208 Cn, only the n-blocks encoded by Ms having the same position.\nLemma 57 For each n \u2265 0, one can construct a one-agent L\u2200 formula \u03c8n of size O(n 2) and refinement quantifier alternation depth 1 satisfying the following for all pairs (wl, wr) of n-configurations: for each Ms \u2208 Cn encoding the pair (wl, wr) and each refinement M \u2032 s\u2032 of Ms,\n\u2022 M \u2032s\u2032 satisfies \u03c8n iff there is 1 \u2264 i \u2264 2 2n such that the set of #-states (i.e. states whose\nlabel is {#}) s\u2032# reachable from s \u2032 is nonempty and for each of such states s\u2032#, M \u2032 s\u2032# encodes an n-block whose position is i and whose content is either the ith symbol of wl or the ith symbol of wr. \u22a3\nProof The L\u2200 formula \u03c8n is defined as follows:\n\u03c8n := \u03ben \u2227 \u2200(\u03b8n \u2192 \u2228\nb\u2208{0,1}\n2 n+3b)\nwhere \u03ben and \u03b8n are L formulas defined as follows:\n\u03ben := 3\u22a4 \u2227 23\u22a4 \u2227 n\u22121\u2227\nd=0\n2 d+2(31 \u2227 30) \u2227 2n+23\u22a4 \u2227 2n+33\u22a4\n\u03b8n := 3\u22a4 \u2227 23\u22a4 \u2227 2 2 3\u22a4 \u2227\nn\u2227\nd=1\n\u2228\nb\u2208{0,1}\n2 d+2(b \u2227 3\u22a4) \u2227 2n+33\u22a4\nNote that \u03c8n has size O(n 2) and that \u03b4(\u03c8n) = 1 (refinement alternation depth). Thus, it remains to prove the second part of the lemma. Fix Ms \u2208 Cn encoding some pair (wl, wr) of n-configurations, and let M \u2032s\u2032 be a refinement of Ms. By construction, for each #-state s\u2032# reachable from s\n\u2032 in M \u2032, there is a #-state s# reachable from s in M such that M \u2032 s\u2032# is\na refinement of Ms# . Moreover, Ms# encodes some n-block (c, i), where the content c is either the ith symbol of wl or the ith symbol of wr. Thus, by definition of \u03ben, we obtain the following.\nFact 1: M \u2032s\u2032 satisfies \u03ben iff the set of #-states s \u2032 # reachable from s \u2032 is nonempty and for each of such states s\u2032#, M\n\u2032 s\u2032# encodes some n-block (c, i), where the content c is either the\nith symbol of wl or the ith symbol of wr.\nIn the second conjunct \u2200(\u03b8n \u2192 \u2228 b\u2208{0,1} 2 n+3b) of the definition of \u03c8n, the formula \u03b8n intuitively enforces one to select the refinements M \u2032s\u2032 of Ms encoding only n-blocks having the same position. Formally, by definition of \u03b8n, we obtain the following.\nFact 2: Let M \u2032\u2032s\u2032\u2032 be a refinement of M \u2032 s\u2032 . Then, M \u2032\u2032 s\u2032\u2032 satisfies \u03b8n iff for all u, u \u2032 \u2208 Traces(M \u2032\u2032s\u2032\u2032), u, u \u2032 \u2208 Traces(Ms) and the n-sub-block in u and the n-sub-block in u \u2032 have the same position.\nThus, by Fact 2 it follows that the second conjunct \u2200(\u03b8n \u2192 \u2228 b\u2208{0,1} 2 n+3b) of definition of \u03c8n requires that all the n-sub-blocks in Traces(M \u2032 s\u2032) having the same position have also the same content, i.e., all the n-blocks encoded by M \u2032s\u2032 have the same position. Thus, by Fact 1 the result follows.\nFor each n \u2265 0, let \u03c8n be the L\u2200 formula satisfying the statement of Lemma 57. Then, the one-agent L\u2200 formula \u03d5n is defined as follows:\n\u03d5n = \u2200(\u03c8n \u2192 \u2228\nc\u2208{a,b}\n2 n+4c)\nBy construction and Lemma 57, we easily obtain the following result.\nLemma 58 For each n \u2265 0, the L\u2200 formula \u03d5n has size O(n 2) and \u03b4(\u03d5n) = 2 (refinement alternation depth). Moreover, for each Ms \u2208 Cn, Ms satisfies \u03d5n iff Ms is balanced. \u22a3\nProof of Proposition 56: by Lemma 58, in order to complete the proof of Proposition 56, we need to show that for each n \u2265 0, each one-agent L\u00b5 formula equivalent to \u03d5n has size at least 22 \u2126(n) . For this, we use a well-known automata-characterization of (oneagent) L\u00b5 in terms of parity symmetric alternating (finite-state) automata (PSAA) which operate on pointed models [61]. First, we recall the class of PSAA. We need additional definitions.\nA tree T is a prefix closed subset of N\u2217. The elements of T are called nodes and the empty word \u03b5 is the root of T . For x \u2208 T , the set of children of x (in T ) is {x\u00b7i \u2208 T | i \u2208 N}. A path of T is a maximal sequence \u03c0 = x0x1 . . . of T -nodes such that x0 = \u03b5 and for any i, xi+1 is a child of xi. For an alphabet \u03a3, a \u03a3-labeled tree is a pair \u3008T, r\u3009 where T is a tree and r : T \u2192 \u03a3. For a set X , B+(X) denotes the set of positive boolean formulas over X , built from elements in X using \u2228 and \u2227 (we also allow the formulas true and false). A subset Y of X satisfies \u03b8 \u2208 B+(X) iff the truth assignment that assigns true to the elements in Y and false to the elements of X \\ Y satisfies \u03b8.\nA parity symmetric alternating automaton (PSAA) over P is a tupleA = \u3008P,Q, q0, \u03b4, Acc\u3009, whereQ is a finite set of locations, q0 \u2208 Q is an initial location, \u03b4 : Q\u00d72 P \u2192 B+ ( {2,3}\u00d7Q) is the transition function, and Acc : Q \u2192 N is a parity acceptance condition assigning to each location q \u2208 Q an integer (called priority). Intuitively, a target of a move of A is encoded by an element in {2,3}\u00d7Q. An atom (3, q) means that from the current state s (of the pointed input model) A moves to some successor of s and the location is updated to q. On the other hand, an atom (2, q) means that from the current state s the automaton splits in multiple copies and, for each successor s\u2032 of s, one of such copies moves to s\u2032 and the location is updated to q.\nFormally, for a pointed model Ms0 over P , a run of A over Ms0 is a (Q\u00d7 S M)-labeled tree \u3008T, r\u3009.13 Moreover, we require that r(\u03b5) = (q0, s0) (initially, A is in the initial location q0 reading state s0), and for each y \u2208 T with r(y) = (q, s), there is a (possibly empty) minimal set H \u2286 {2,3}\u00d7Q satisfying \u03b4(q, (V M)\u22121(s)) such that the set L(y) of labels of children of y in T is the smallest set satisfying the following: for all atoms at \u2208 H ,\n\u2022 if at = (3, q\u2032), then for some successor s\u2032 of s in M , (q\u2032, s\u2032) \u2208 L(y);\n\u2022 if at = (2, q\u2032), then for each successor s\u2032 of s in M , (q\u2032, s\u2032) \u2208 L(y).\nFor an infinite path \u03c0 = y0y1 . . . of T , let inf(\u03c0) be the set of locations in Q that appear in r(y0)r(y1) . . . infinitely often. The run \u3008T, r\u3009 is accepting if for each infinite path \u03c0 of T , the smallest priority of the locations in inf(\u03c0) is even. The language of A is the set of pointed models Ms over P such that A has an accepting run over Ms. The following is a well-known result.\nProposition 59 [61] Given a one-agent L\u00b5 formula \u03d5 over P , one can construct a PSAA A\u03d5 with O(|\u03d5|) locations whose language is the set of pointed models over P satisfying \u03d5.\u22a3\nProposition 56 directly follows from Proposition 59 and the following result.\nLemma 60 Let n \u2265 0 and An be a PSAA over P whose language is the set of pointed models satisfying the L\u2200 formula \u03d5n. Then, the number of locations of An is at least 2 2n.\u22a3\nProof Let n \u2265 0 and An as in the statement of the lemma (note that An exists by Proposition 59 together with Proposition 42), and Q be the set of An-locations. For each n-configuration w, let Mwsw be some balanced pointed model encoding the pair (w,w), and H(w) be the set of sets Ql \u2286 Q such that there is an accepting run \u3008T, r\u3009 of An over the pointed model Mwsw so that:\n\u2022 Ql is the set of locations associated with the replicas ofAn in the run \u3008T, r\u3009 which read the left successor sl of sw in M\nw, i.e., Ql = {q \u2208 Q | for some x \u2208 T, r(x) = (q, sl)}. (Note that Ql = \u2205 if \u3008T, r\u3009 does not visit the left successor sl of sw.)\nFirst, we show that H(w) 6= \u2205. By hypothesis and Lemma 58, there must exist some accepting run of An over the input M w sw . Now, by construction, H(w) is a set of subsets of Q, and H(w) is non-empty if and only if there is some accepting run of An over M w sw . (If no accepting run of An visits the left successor sl of sw in M w, then H(w) is a singleton containing just the empty set.) Hence, non-emptiness of H(w) follows. Next, we prove the following.\nClaim: for all n-configurations w and w\u2032 such that w 6= w\u2032, H(w) \u2229H(w\u2032) = \u2205. Proof of the claim: for a model M and a set S \u2032 \u2286 SM , the restriction of M to S \u2032 is defined in the obvious way. For s \u2208 SM , let [Ms] denote the restriction of M to the set of\n13Intuitively, each node of T labeled by (q, s) describes a copy of A that is in location q and reads the state s of M .\nstates reachable from s in M . For all n-configurations w and dir \u2208 {l, r}, let sw,dir be the dir-successor of sw in M\nw. We prove the claim by contradiction. So, assume that there are two distinct n-configurations w and w\u2032 such that H(w) \u2229H(w\u2032) 6= \u2205. Without loss of generality we can assume that Mw and Mw \u2032 have no states in common. Let Mw,w \u2032\nsw be any\npointed model satisfying the following: the successors of sw in M w,w\u2032 are sw\u2032,l and sw,r, and [Mw,w \u2032\nsw\u2032,l ] = [Mw\n\u2032\nsw\u2032,l ] and [Mw,w\n\u2032\nsw,r ] = [Mwsw,r ]. Evidently, M w,w\u2032 sw is a pointed model encoding\nthe pair (w\u2032, w). Since w 6= w\u2032, by hypothesis and Lemma 58, An does not accept M w,w\u2032\nsw .\nOn the other hand, since there is Q \u2208 H(w) \u2229 H(w\u2032), by definition of the sets H(w) and H(w\u2032) and the semantics of PSAA, it easily follows that there is an accepting run of An over Mw,w \u2032\nsw , which is a contradiction. Hence, the claim holds.\nBy the claim above, it follows that for each n-configuration w, there is Qw \u2208 H(w) (recall that H(w) 6= \u2205) such that for all n-configurations w\u2032 distinct from w, Qw /\u2208 H(w \u2032). Since the number of distinct n-configurations is 22 2n\nand the number of subsets of Q is 2|Q|, we obtain that |Q| \u2265 22 n , and the result holds."}, {"heading": "8 Conclusions and perspectives", "text": "Conclusions We conclude that we hope to have established a platform for structural refinement in various modal logics. We established results on axiomatization, complexity, expressivity, and we gave applications to software verification and design, and to dynamic epistemic logics. We clearly established the relation to bisimulation quantified logics: refinement quantification is bisimulation followed by relativization. The multi-agent refinement modal logic and the furthest generalization in the form of refinement \u00b5-calculus are only the beginning. One could think of refinement CTL, refinement PDL, (yet other) refinement epistemic logics, refinement with further structural restrictions or with protocol restrictions, and so on. Each of these logics may have different axiomatizations and complexities, and equal expressivity as the logic without refinement is certainly not to be expected; e.g., we estimate that refinement modal logic is more expressive than the base modal logic on the KT model class.\nRecent results Following the initial submission of the paper, some further results have been obtained in this area, typically involving one of the authors. In [12] it was established that the complexity of refinement modal logic for a single agent is AEXPpol-complete, which means that the satisfiability of an RML formula can be decided by an exponential-time bounded Alternating Turing Machine with a linearly-bounded number of alternations. In [28] an axiomatization of the multi-agent refinement modal logic of knowledge is given, among other results. As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.e., \u2018there is a refinement after which \u03d5 is true\u2019 means the same as \u2018there is an action model such that after its\nexecution \u03d5 is true\u2019. This answers one of the open questions on logics with quantification over information change, posed in the recent survey [54]. That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54]. It should not be forgotten to mention that many of these, including our own proposal, go back to the original publication [21].\nFurther research We wish to determine the complexity of model checking in the various refinement modal logics. On the further horizon loom the detailed investigation of other refinement logics, mainly refinement PDL and refinement CTL, and the exploration of their applications. The relation of refinement quantification to other forms of propositional quantification over information change also needs further investigation."}, {"heading": "Acknowledgements", "text": "We acknowledge a very insightful and detailed review from a journal referee. Hans van Ditmarsch is also affiliated to IMSc (Institute of Mathematical Sciences), Chennai, India. We acknowledge support from ERC project EPS 313360, and from EU 7th Framework Programme under grant agreement no. 295261 (MEALS)."}], "references": [{"title": "Non-Well-Founded Sets", "author": ["P. Aczel"], "venue": "CSLI Publications, Stanford, CA", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1988}, {"title": "Alternating-time temporal logic", "author": ["R. Alur", "T.A. Henzinger", "O. Kupferman"], "venue": "Lecture Notes in Computer Science, 1536:23\u201360", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1998}, {"title": "Alternating refinement relations", "author": ["Rajeev Alur", "Thomas A. Henzinger", "Orna Kupferman", "Moshe Y. Vardi"], "venue": "In International Conference on Concurrency Theory,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1998}, {"title": "20 years of modal and mixed specifications", "author": ["Adam Antonik", "Michael Huth", "Kim G. Larsen", "Ulrik Nyman", "Andrzej Wasowski"], "venue": "Bulletin of European Association of Theoretical Computer Science,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Rudiments of \u03bc-calculus", "author": ["A. Arnold", "D. Niwinski"], "venue": "North Holland", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "Characterizing updates in dynamic epistemic logic", "author": ["G. Aucher"], "venue": "Proceedings of Twelfth KR. AAAI Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "DEL-sequents for regression and epistemic planning", "author": ["G. Aucher"], "venue": "Journal of Applied Non-Classical Logics, 22(4):337\u2013367", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "H", "author": ["P. Balbiani", "A. Baltag"], "venue": "van Ditmarsch, A. Herzig, T. Hoshi, and T. De Lima. \u2018Knowable\u2019 as \u2018known after an announcement\u2019. Review of Symbolic Logic, 1(3):305\u2013 334", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2008}, {"title": "The logic of public announcements", "author": ["A. Baltag", "L.S. Moss", "S. Solecki"], "venue": "common knowledge, and private suspicions. In Proc. of 7th TARK, pages 43\u201356. Morgan Kaufmann", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1998}, {"title": "Proof systems for the coalgebraic cover modality", "author": ["M. Bilkova", "A. Palmigiano", "Y. Venema"], "venue": "Carlos Areces and Robert Goldblatt, editors, Advances in Modal Logic, pages 1\u201321. College Publications", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2008}, {"title": "M", "author": ["P. Blackburn"], "venue": "de Rijke, and Y. Venema. Modal Logic. Cambridge University Press, Cambridge", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2001}, {"title": "The complexity of one-agent refinement modal logic", "author": ["Laura Bozzelli", "Hans P. van Ditmarsch", "Sophie Pinchinat"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Characterizing Kripke structures in temporal logic", "author": ["M. Browne", "E. Clarke", "O. Gr\u00fcmberg"], "venue": "H. Ehrig, R. Kowalski, G. Levi, and U. Montanari, editors, TAPSOFT \u201987, LNCS 249, pages 256\u2013270. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1987}, {"title": "Design and Verification of Synchronization Skeletons using Branching Time Temporal Logic", "author": ["E.M. Clarke", "E.A. Emerson"], "venue": "Proceedings of Workshop on Logic of Programs, LNCS 131, pages 52\u201371. Springer-Verlag", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1981}, {"title": "Logical questions concerning the \u03bc-calculus: Interpolation, Lyndon and Los-Tarski", "author": ["G. d\u2019Agostino", "M. Hollenberg"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2000}, {"title": "An axiomatization of bisimulation quantifiers via the \u03bc-calculus", "author": ["G. d\u2019Agostino", "G. Lenzi"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "A note on bisimulation quantifiers and fixed points over transitive frames", "author": ["G. d\u2019Agostino", "G. Lenzi"], "venue": "J. Log. Comput.,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Extensions and Applications of Dynamic Epistemic Logic", "author": ["P. Economou"], "venue": "PhD thesis, Oxford University", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}, {"title": "Reasoning about Knowledge", "author": ["R. Fagin", "J.Y. Halpern", "Y. Moses", "M.Y. Vardi"], "venue": "MIT Press, Cambridge MA", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1995}, {"title": "Modal specifications for the control theory of discrete-event systems", "author": ["Guillaume Feuillade", "Sophie Pinchinat"], "venue": "Discrete Event Dynamic Systems,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2007}, {"title": "Propositional quantifiers in modal logic", "author": ["K. Fine"], "venue": "Theoria, 36(3):336\u2013346", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1970}, {"title": "Bisimulation quantifiers for modal logic", "author": ["T. French"], "venue": "PhD thesis, University of Western Australia", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2006}, {"title": "Undecidability for arbitrary public announcement logic", "author": ["T. French", "H. van Ditmarsch"], "venue": "Advances in Modal Logic", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2008}, {"title": "Reasoning about information change", "author": ["J.D. Gerbrandy", "W. Groeneveld"], "venue": "Journal of Logic, Language, and Information, 6:147\u2013169", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1997}, {"title": "Refinement quantifiers for logics of belief and knowledge", "author": ["J. Hales"], "venue": "Honours Thesis, University of Western Australia", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2011}, {"title": "Arbitrary action model logic and action model synthesis", "author": ["J. Hales"], "venue": "Proc. of 28th LICS, pages 253\u2013262. IEEE", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2013}, {"title": "Refinement quantified logics of knowledge", "author": ["J. Hales", "T. French", "R. Davies"], "venue": "Electr. Notes Theor. Comput. Sci., 278:85\u201398", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2011}, {"title": "Refinement quantified logics of knowledge and belief for multiple agents", "author": ["J. Hales", "T. French", "R. Davies"], "venue": "Advances in Modal Logic 9, pages 317\u2013338. College Publications", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2012}, {"title": "Dynamic Logic", "author": ["D. Harel", "D. Kozen", "J. Tiuryn"], "venue": "MIT Press, Cambridge MA", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2000}, {"title": "Automata for the modal mu-calculus and related results", "author": ["D. Janin", "I. Walukiewicz"], "venue": "Proc. of 20th MFCS, LNCS 969, pages 552\u2013562. Springer", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1995}, {"title": "On the expressive completeness of the propositional mu-calculus with respect to monadic second order logic", "author": ["D. Janin", "I. Walukiewicz"], "venue": "Concurrency Theory, 7th International Conference, volume 1119 of LNCS, pages 263\u2013277. Springer", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1996}, {"title": "Expressivity and completeness for public update logics via reduction axioms", "author": ["B. Kooi"], "venue": "Journal of Applied Non-Classical Logics, 17(2):231\u2013254", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2007}, {"title": "Module checking", "author": ["O. Kupferman", "M. Vardi", "P. Wolper"], "venue": "Information and Computation, 164(2):322\u2013344", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2001}, {"title": "Completeness of the finitary moss logic", "author": ["C. Kupke", "A. Kurz", "Y. Venema"], "venue": "C. Areces and R. Goldblatt, editors, Advances in Modal Logic 7, pages 193\u2013217. College Publications", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2008}, {"title": "Memoryless determinacy of parity games. In Automata logics, and infinite games, pages 95\u2013106", "author": ["Ralf K\u00fcsters"], "venue": null, "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2002}, {"title": "Modal I/O automata for interface and product line theories", "author": ["Kim G. Larsen", "Ulrik Nyman", "Andrzej Wasowski"], "venue": "In Proceedings of the 16th European Symposium on Programming (ESOP\u201907),", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "An algorithmic approach to knowledge evolution", "author": ["A.R. Lomuscio", "M.D. Ryan"], "venue": "Artificial Intelligence for Engineering Design, Analysis and Manufacturing (AIEDAM), 13(2)", "citeRegEx": "37", "shortCiteRegEx": null, "year": 1998}, {"title": "Infinite games. Automata logics, and infinite games, pages 197\u2013204", "author": ["Ren\u00e9 Mazala"], "venue": null, "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2002}, {"title": "The undecidability of iterated modal relativization", "author": ["J.S. Miller", "L.S. Moss"], "venue": "Studia Logica, 79(3):373\u2013407", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2005}, {"title": "Programming from Specifications: Second Edition", "author": ["C. Morgan"], "venue": "Prentice Hall International, Hempstead, UK", "citeRegEx": "40", "shortCiteRegEx": null, "year": 1994}, {"title": "Topology and epistemic logic", "author": ["R. Parikh", "L.S. Moss", "C. Steinsvold"], "venue": "M. Aiello, I. Pratt-Hartmann, and J. van Benthem, editors, Handbook of Spatial Logics, pages 299\u2013341. Springer Verlag", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2007}, {"title": "Logic for social software", "author": ["M. Pauly"], "venue": "PhD thesis, University of Amsterdam", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2001}, {"title": "Logics of public communications", "author": ["J.A. Plaza"], "venue": "Proc. of the 4th ISMIS, pages 201\u2013216. Oak Ridge National Laboratory", "citeRegEx": "43", "shortCiteRegEx": null, "year": 1989}, {"title": "Quotient de sp\u00e9cifications pour la r\u00e9utilisation de composants", "author": ["Jean-Baptiste Raclet"], "venue": "PhD thesis, Universite\u0301 de Rennes I, December", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2007}, {"title": "Residual for component specifications", "author": ["Jean-Baptiste Raclet"], "venue": "In Proc. of the 4th International Workshop on Formal Aspects of Component Software (FACS\u201907),", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2008}, {"title": "Why are modalities good for interface theories", "author": ["Jean-Baptiste Raclet", "Eric Badouel", "Albert Benveniste", "Benoit Caillaud", "Roberto Passerone"], "venue": "In Proceedings of the 9th International Conference on Application of Concurrency to System Design (ACSD\u201909),", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2009}, {"title": "On the supervisory control of discrete event systems", "author": ["P. Ramadge", "W. Wonham"], "venue": "Proc. of the IEEE, pages 81\u201398", "citeRegEx": "47", "shortCiteRegEx": null, "year": 1989}, {"title": "Quantified mu-calculus for control synthesis", "author": ["St\u00e9phane Riedweg", "Sophie Pinchinat"], "venue": "MFCS, volume 2747 of Lecture Notes in Computer Science,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2003}, {"title": "Agents and roles: Refinement in alternating-time temporal logic", "author": ["M. Ryan", "P.-Y. Schobbens"], "venue": "Revised Papers from the 8th International Workshop on Intelligent Agents VIII (ATAL \u201901), pages 100\u2013114. Springer", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2002}, {"title": "The Complementation Problem for Buchi Automata with Appplications to Temporal Logic", "author": ["A.P. Sistla", "M.Y. Vardi", "P. Wolper"], "venue": "Theoretical Computer Science, 49:217\u2013237", "citeRegEx": "50", "shortCiteRegEx": null, "year": 1987}, {"title": "On the control of discrete event dynamical systems", "author": ["J. Tsitsoklis"], "venue": "Mathematics of Control Signals and Systems, 2(2):95\u2013107", "citeRegEx": "51", "shortCiteRegEx": null, "year": 1989}, {"title": "An essay on sabotage and obstruction", "author": ["J. van Benthem"], "venue": "In Mechanizing Mathematical Reasoning,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 2005}, {"title": "One is a lonely number: on the logic of communication", "author": ["J. van Benthem"], "venue": "In Logic colloquium 2002. Lecture Notes in Logic,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2006}, {"title": "Quantifying notes", "author": ["H. van Ditmarsch"], "venue": "In Proc. of 19th WoLLIC,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2012}, {"title": "Simulation and information", "author": ["H. van Ditmarsch", "T. French"], "venue": "Presented at LOFT 2008 and KRAMAS", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2008}, {"title": "Future event logic - axioms and complexity", "author": ["H. van Ditmarsch", "T. French", "S. Pinchinat"], "venue": "Advances in Modal Logic, Moscow,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2010}, {"title": "Dynamic Epistemic Logic, volume 337 of Synthese Library", "author": ["H. van Ditmarsch", "W. van der Hoek", "B. Kooi"], "venue": null, "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2007}, {"title": "Lecture notes on the modal \u03bc-calculus", "author": ["Y. Venema"], "venue": "(Draft)", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2012}, {"title": "Completeness of Kozen\u2019s axiomatisation of the propositional mucalculus", "author": ["I. Walukiewicz"], "venue": "INFCTRL: Information and Computation (formerly Information and Control), 157", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2000}, {"title": "An alternative logic for knowability", "author": ["X. Wen", "H. Liu", "F. Huang"], "venue": "Logic, Rationality, and Interaction (Proceedings of LORI-3), LNCS 6953, pages 342\u2013355. Springer", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2011}, {"title": "CTL is exponentially more succinct than CTL", "author": ["T. Wilke"], "venue": "Proc. 19th FSTTCS, LNCS 1738, pages 110\u2013121. Springer", "citeRegEx": "61", "shortCiteRegEx": null, "year": 1999}, {"title": "Using Z \u2014 Specification", "author": ["J. Woodcock", "J. Davies"], "venue": "Refinement and Proof. Prentice Hall", "citeRegEx": "62", "shortCiteRegEx": null, "year": 1996}], "referenceMentions": [{"referenceID": 54, "context": "In [55] the future event logic is introduced.", "startOffset": 3, "endOffset": 7}, {"referenceID": 7, "context": "\u201d The proposal was a generalization of a so-called arbitrary public announcement logic with an operator for \u201c\u03c6 holds after all announcements\u201d [8].", "startOffset": 142, "endOffset": 145}, {"referenceID": 8, "context": "[9]: on finite models, it can be easily shown that a model resulting from action model execution is a refinement of the initial model, and for a given refinement of a model we can construct an action model such that the result of its execution is bisimilar to that refinement.", "startOffset": 0, "endOffset": 3}, {"referenceID": 55, "context": "In [56] an axiomatization of the single-agent version of this logic is presented, and also expressivity and complexity results.", "startOffset": 3, "endOffset": 7}, {"referenceID": 54, "context": "Thus we may consider refinement modal logic to be a more abstract perspective of future event logic [55] applicable to other modal logics.", "startOffset": 100, "endOffset": 104}, {"referenceID": 41, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 20, "endOffset": 27}, {"referenceID": 1, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 20, "endOffset": 27}, {"referenceID": 46, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 49, "endOffset": 57}, {"referenceID": 50, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 49, "endOffset": 57}, {"referenceID": 28, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 131, "endOffset": 135}, {"referenceID": 39, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 180, "endOffset": 184}, {"referenceID": 40, "context": "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].", "startOffset": 266, "endOffset": 270}, {"referenceID": 18, "context": "Previous works [19, 37] employed a notion of refinement.", "startOffset": 15, "endOffset": 23}, {"referenceID": 36, "context": "Previous works [19, 37] employed a notion of refinement.", "startOffset": 15, "endOffset": 23}, {"referenceID": 36, "context": "In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose \u2014 a precursor of the dynamic epistemic logics developed later (for an overview, see [57]).", "startOffset": 3, "endOffset": 7}, {"referenceID": 56, "context": "In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose \u2014 a precursor of the dynamic epistemic logics developed later (for an overview, see [57]).", "startOffset": 235, "endOffset": 239}, {"referenceID": 61, "context": "[62], refinement of datatypes is considered such that (datatype) C refines A if A simulates C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "This usage of refinement as the converse of simulation [1, 11] comes close to ours \u2014 in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close.", "startOffset": 55, "endOffset": 62}, {"referenceID": 10, "context": "This usage of refinement as the converse of simulation [1, 11] comes close to ours \u2014 in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close.", "startOffset": 55, "endOffset": 62}, {"referenceID": 61, "context": "A similar usage of refinement as in [62] is found in [3, 4].", "startOffset": 36, "endOffset": 40}, {"referenceID": 2, "context": "A similar usage of refinement as in [62] is found in [3, 4].", "startOffset": 53, "endOffset": 59}, {"referenceID": 3, "context": "A similar usage of refinement as in [62] is found in [3, 4].", "startOffset": 53, "endOffset": 59}, {"referenceID": 44, "context": "In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49].", "startOffset": 95, "endOffset": 103}, {"referenceID": 48, "context": "In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49].", "startOffset": 95, "endOffset": 103}, {"referenceID": 16, "context": "Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22].", "startOffset": 88, "endOffset": 96}, {"referenceID": 21, "context": "Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22].", "startOffset": 88, "endOffset": 96}, {"referenceID": 54, "context": "The refinement operator, seen as refinement quantifier, is weaker than a bisimulation quantifier [55], as it is only based on simulations rather than bisimulations, and as it only allows us to vary the interpretation of a propositional variable that does not occur in the formula bound by it.", "startOffset": 97, "endOffset": 101}, {"referenceID": 15, "context": "Bisimulation quantified modal logic has previously been axiomatized by providing a provably correct translation to the modal \u03bc-calculus [16].", "startOffset": 136, "endOffset": 140}, {"referenceID": 15, "context": "Cover logic The cover operator \u2207 has also been used as a syntactic primitive in modal logics [16].", "startOffset": 93, "endOffset": 97}, {"referenceID": 9, "context": "It has recently been axiomatized [10].", "startOffset": 33, "endOffset": 37}, {"referenceID": 9, "context": "Cover logic K\u2207 is equally expressive as modal logic K (also in the multi-agent version) [10, 34].", "startOffset": 88, "endOffset": 96}, {"referenceID": 33, "context": "Cover logic K\u2207 is equally expressive as modal logic K (also in the multi-agent version) [10, 34].", "startOffset": 88, "endOffset": 96}, {"referenceID": 30, "context": "Every L formula is equivalent to a disjunctive L formula [31].", "startOffset": 57, "endOffset": 61}, {"referenceID": 57, "context": "Every L formula is equivalent to a disjunctive L formula [58].", "startOffset": 57, "endOffset": 61}, {"referenceID": 14, "context": "43] a bisimulation quantifier characterization of fixed points is given (the details of which are deferred to Section 6 on refinement \u03bc-calculus, where they are pertinent), and from [15] we know that bisimulation quantifiers are also expressible in the modal \u03bc-calculus.", "startOffset": 182, "endOffset": 186}, {"referenceID": 15, "context": "For more information on the modal \u03bc-calculus, see [16, 58].", "startOffset": 50, "endOffset": 58}, {"referenceID": 57, "context": "For more information on the modal \u03bc-calculus, see [16, 58].", "startOffset": 50, "endOffset": 58}, {"referenceID": 10, "context": ", the truth and falsity) of atoms, whereas [11] has them only preserve the truth of propositional variables in a simulation\u2014and presumably preserve their falsity in a refinement.", "startOffset": 43, "endOffset": 47}, {"referenceID": 10, "context": "Another, inessential, difference with [11] is that in their case atoms and forth are required for all modalities (in the similarity type), i.", "startOffset": 38, "endOffset": 42}, {"referenceID": 39, "context": "This is perhaps contrary to the concept of program refinement [40] where detail is added to a specification.", "startOffset": 62, "endOffset": 66}, {"referenceID": 2, "context": "It is folklore to associate a (infinite duration) two-player game with refinement, in the spirit of [3].", "startOffset": 100, "endOffset": 103}, {"referenceID": 37, "context": "Remark 6 One easily sees that the refinement game of Definition 5 is a particular parity game [38].", "startOffset": 94, "endOffset": 98}, {"referenceID": 34, "context": "Henceforth, according to [35], the refinement game is determined, and memoryless strategies suffice.", "startOffset": 25, "endOffset": 29}, {"referenceID": 8, "context": "We recall another important result connecting structural refinement to action model execution [9].", "startOffset": 94, "endOffset": 97}, {"referenceID": 54, "context": "For full details, see [55].", "startOffset": 22, "endOffset": 26}, {"referenceID": 12, "context": "Now in a finite model, we can single out states (up to bisimilarity) by a distinguishing formula [13].", "startOffset": 97, "endOffset": 101}, {"referenceID": 35, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 43, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 44, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 45, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 3, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 48, "context": "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].", "startOffset": 135, "endOffset": 158}, {"referenceID": 43, "context": "The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45].", "startOffset": 159, "endOffset": 167}, {"referenceID": 44, "context": "The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45].", "startOffset": 159, "endOffset": 167}, {"referenceID": 19, "context": "Modal specifications are interpreted as logical specifications matching the conjunctive \u03bd-calculus fragment of the \u03bc-calculus [20].", "startOffset": 126, "endOffset": 130}, {"referenceID": 54, "context": "From prior publications [55, 56] refinement modal logic is known as \u2018future event logic\u2019.", "startOffset": 24, "endOffset": 32}, {"referenceID": 55, "context": "From prior publications [55, 56] refinement modal logic is known as \u2018future event logic\u2019.", "startOffset": 24, "endOffset": 32}, {"referenceID": 54, "context": "In the final part of this section we relate these semantics to the well-known frameworks action model logic and bisimulation quantified logic (and see also [55]).", "startOffset": 156, "endOffset": 160}, {"referenceID": 55, "context": "See [56, 27].", "startOffset": 4, "endOffset": 12}, {"referenceID": 26, "context": "See [56, 27].", "startOffset": 4, "endOffset": 12}, {"referenceID": 22, "context": "If these logics were equally expressive, action model logic with quantification would be decidable\u2014a surprising fact, given that public announcement logic with quantification over public announcements (singleton action models) is undecidable [23].", "startOffset": 242, "endOffset": 246}, {"referenceID": 47, "context": "The the control problem [48], known as the question \u201cis there a way to control actions c of the system S so that property \u03c6 is guaranteed?\u201d, can be expressed in L\u2200 by wondering whether S |= \u2203c\u03c6 .", "startOffset": 24, "endOffset": 28}, {"referenceID": 32, "context": "Themodule checking problem [33] is the problem of determining whether an open system satisfies a given property.", "startOffset": 27, "endOffset": 31}, {"referenceID": 52, "context": "For the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]).", "startOffset": 115, "endOffset": 123}, {"referenceID": 38, "context": "For the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]).", "startOffset": 115, "endOffset": 123}, {"referenceID": 38, "context": "From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.", "startOffset": 51, "endOffset": 55}, {"referenceID": 52, "context": "From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.", "startOffset": 89, "endOffset": 93}, {"referenceID": 42, "context": "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.", "startOffset": 178, "endOffset": 185}, {"referenceID": 8, "context": "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.", "startOffset": 178, "endOffset": 185}, {"referenceID": 31, "context": "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.", "startOffset": 238, "endOffset": 246}, {"referenceID": 23, "context": "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.", "startOffset": 238, "endOffset": 246}, {"referenceID": 2, "context": "Alternating transition systems (ATS) were introduced [3] to model multi-agent systems, where in each move of the game between the agents of an ATS, the choice of an agent at a state is a set of states and the successor state is determined by considering the intersection of the choices made by all agents.", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "Soon after, the more general setting of alternating-time temporal logics [2] considered universal and existential quantifications over a-refinements, for arbitrary a, combined with LTL formulas.", "startOffset": 73, "endOffset": 76}, {"referenceID": 24, "context": "We can see that Ms a M \u03a6 s , via the relation R \u03a6 = {(s, s)} \u222a I \u222a \u22c3 \u03c6\u2208\u03a6 R \u03c6 where I is the identity on S and each R is the refinement relation corresponding to Mt\u03c6 a N \u03c6 u\u03c6 (see also [25]).", "startOffset": 184, "endOffset": 188}, {"referenceID": 24, "context": "We can see that Ms a M \u03a6 s , via the relation R \u03a6 = {(s, s)} \u222a I \u222a \u22c3 \u03c6\u2208\u03a6 R \u03c6 where I is the identity on S and each R is the refinement relation corresponding to Mt\u03c6 a N \u03c6 u\u03c6 (see also [25]).", "startOffset": 184, "endOffset": 188}, {"referenceID": 55, "context": "The single-agent axiomatization was presented in [56].", "startOffset": 49, "endOffset": 53}, {"referenceID": 55, "context": "In [56] it is used that every refinement modal logical formula is equivalent to a formula in cover logic with the special syntax \u03c6 ::= \u22a5 | \u22a4 | \u03c6 \u2228 \u03c6 | p \u2227 \u03c6 | \u00acp \u2227 \u03c6 | \u2207{\u03c6, .", "startOffset": 3, "endOffset": 7}, {"referenceID": 9, "context": ", \u03c6} [10, 34], plus induction on that form.", "startOffset": 5, "endOffset": 13}, {"referenceID": 33, "context": ", \u03c6} [10, 34], plus induction on that form.", "startOffset": 5, "endOffset": 13}, {"referenceID": 26, "context": "For details, see [27].", "startOffset": 17, "endOffset": 21}, {"referenceID": 21, "context": "A study of how various classes of models affect the properties of bisimulation quantified logics is given in [22].", "startOffset": 109, "endOffset": 113}, {"referenceID": 26, "context": "Refinement epistemic logics are investigated in [27, 25].", "startOffset": 48, "endOffset": 56}, {"referenceID": 24, "context": "Refinement epistemic logics are investigated in [27, 25].", "startOffset": 48, "endOffset": 56}, {"referenceID": 24, "context": "In [25] a multi-agentKD45 axiomatization is also reported.", "startOffset": 3, "endOffset": 7}, {"referenceID": 14, "context": "From [15] we know that bisimulation quantifiers are also expressible in the modal \u03bc-calculus, and thus these equivalences also hold in the modal \u03bc-calculus.", "startOffset": 5, "endOffset": 9}, {"referenceID": 4, "context": "1 still apply and the soundness of F1 and F2 are well known [5], so we are left to show that R and R are sound.", "startOffset": 60, "endOffset": 63}, {"referenceID": 29, "context": "An explicit construction for Nu can be given via the tableaux of Janin and Walukiewicz [30].", "startOffset": 87, "endOffset": 91}, {"referenceID": 4, "context": "\u2203\u03c6 of [5] which tells that Ms |= \u03bcx.", "startOffset": 6, "endOffset": 9}, {"referenceID": 58, "context": "As \u03c6 is \u2203-free, it is semantically equivalent to a formula in disjunctive normal form, and by the completeness of Kozen\u2019s axiom system [59] this equivalence is provable in RML.", "startOffset": 135, "endOffset": 139}, {"referenceID": 58, "context": "As \u03c8 is valid, it must be provable since Prop, K, F1, F2, NecK, and MP give a sound and complete proof system for the modal \u03bc-calculus [59].", "startOffset": 135, "endOffset": 139}, {"referenceID": 55, "context": "Unfortunately we were not able to corroborate in this paper the upper complexity claims for RML reported in [56].", "startOffset": 108, "endOffset": 112}, {"referenceID": 13, "context": "First, we recall a fragment, written CTL, of the standard branching-time logic Computation Tree Logic (CTL) [14], which in turn is a fragment of L (see also the example Section 4.", "startOffset": 108, "endOffset": 112}, {"referenceID": 49, "context": "Theorem 48 is proved by a polynomial-time reduction from satisfiability of Quantified Propositional Temporal Logic (QPTL) [50].", "startOffset": 122, "endOffset": 126}, {"referenceID": 49, "context": "Theorem 49 [50] Let k \u2265 0.", "startOffset": 11, "endOffset": 15}, {"referenceID": 60, "context": "For this, we use a well-known automata-characterization of (oneagent) L in terms of parity symmetric alternating (finite-state) automata (PSAA) which operate on pointed models [61].", "startOffset": 176, "endOffset": 180}, {"referenceID": 60, "context": "Proposition 59 [61] Given a one-agent L formula \u03c6 over P , one can construct a PSAA A\u03c6 with O(|\u03c6|) locations whose language is the set of pointed models over P satisfying \u03c6.", "startOffset": 15, "endOffset": 19}, {"referenceID": 11, "context": "In [12] it was established that the complexity of refinement modal logic for a single agent is AEXPpol-complete, which means that the satisfiability of an RML formula can be decided by an exponential-time bounded Alternating Turing Machine with a linearly-bounded number of alternations.", "startOffset": 3, "endOffset": 7}, {"referenceID": 27, "context": "In [28] an axiomatization of the multi-agent refinement modal logic of knowledge is given, among other results.", "startOffset": 3, "endOffset": 7}, {"referenceID": 7, "context": "As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.", "startOffset": 84, "endOffset": 87}, {"referenceID": 25, "context": "As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.", "startOffset": 209, "endOffset": 213}, {"referenceID": 53, "context": "This answers one of the open questions on logics with quantification over information change, posed in the recent survey [54].", "startOffset": 121, "endOffset": 125}, {"referenceID": 51, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 102, "endOffset": 106}, {"referenceID": 17, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 108, "endOffset": 112}, {"referenceID": 6, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 114, "endOffset": 117}, {"referenceID": 5, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 133, "endOffset": 136}, {"referenceID": 59, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 143, "endOffset": 147}, {"referenceID": 53, "context": "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]\u2014for details, see [54].", "startOffset": 165, "endOffset": 169}, {"referenceID": 20, "context": "It should not be forgotten to mention that many of these, including our own proposal, go back to the original publication [21].", "startOffset": 122, "endOffset": 126}], "year": 2013, "abstractText": "In this paper we present refinement modal logic. A refinement is like a bisimulation, except that from the three relational requirements only \u2018atoms\u2019 and \u2018back\u2019 need to be satisfied. Our logic contains a new operator \u2200 in addition to the standard modalities 2 for each agent. The operator \u2200 acts as a quantifier over the set of all refinements of a given model. As a variation on a bisimulation quantifier, this refinement operator or refinement quantifier \u2200 can be seen as quantifying over a variable not occurring in the formula bound by it. The logic combines the simplicity of multi-agent modal logic with some powers of monadic second-order quantification. We present a sound and complete axiomatization of multi-agent refinement modal logic. We also present an extension of the logic to the modal \u03bc-calculus, and an axiomatization for the single-agent version of this logic. Examples and applications are also discussed: to software verification and design (the set of agents can also be seen as a set of actions), and to dynamic epistemic logic. We further give detailed results on the complexity of satisfiability, and on succinctness.", "creator": "LaTeX with hyperref package"}}}