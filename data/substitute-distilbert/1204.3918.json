{"id": "1204.3918", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Apr-2012", "title": "Eliminating the Weakest Link: Making Manipulation Intractable?", "abstract": "successive elimination of candidates proves often a route to rendered manipulation intractable to compute. we prove to eliminating candidates does not necessarily increase the computational complexity of manipulation. however, for many voting rules used in practice, the computational complexity increases. for example, ) is already known that it is np - hard to compute how a single voter can manipulate the result of single transferable voting ( the elimination version of plurality representation ). we show here that it is too - hard to compute how so single party can manipulate the behavior of the elimination version of veto voting, of how closely related coombs'rule, and of the rejected versions of a various class of scoring rules.", "histories": [["v1", "Tue, 17 Apr 2012 21:08:39 GMT  (29kb)", "http://arxiv.org/abs/1204.3918v1", "To appear in Proceedings of Twenty-Sixth Conference on Artificial Intelligence (AAAI-12)"]], "COMMENTS": "To appear in Proceedings of Twenty-Sixth Conference on Artificial Intelligence (AAAI-12)", "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.GT", "authors": ["jessica davies", "nina narodytska", "toby walsh"], "accepted": true, "id": "1204.3918"}, "pdf": {"name": "1204.3918.pdf", "metadata": {"source": "CRF", "title": "Eliminating the Weakest Link: Making Manipulation Intractable?", "authors": ["Jessica Davies", "Nina Narodytska", "Toby Walsh"], "emails": ["jdavies@cs.toronto.edu", "ninan@cse.unsw.edu.au", "toby.walsh@nicta.com.au"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 4.\n39 18\nv1 [\ncs .A\nI] 1\n7 A\npr 2\n01 2"}, {"heading": "Introduction", "text": "Voting is a general mechanism for combining the preferences together of multiple agents. Voting is, however, not without its problems. One such problem is that agents may vote strategically, mis-reporting their true preferences in order to improve the outcome for them. For instance, in each round of a popular TV game show, players vote on which other player to eliminate. The host, Anne Robinson then tells the unlucky player, \u201cYou are the weakest link, goodbye!\u201d. Players have an interesting strategic decision to make. On the one hand, they should vote to eliminate weak players (as weak players will tend to reduce the size of the jackpot). On the other hand, they should vote to eliminate strong players (as the overall winner takes the final jackpot and everyone else walks away empty-handed). Similarly, when the International Olympic Committee (IOC) meets to select a site for the next Olympics, there is an election in which the weakest city is successively eliminated. Strategic voting often appears to take place. For example, in the vote for the site of the 2012 Olympics, New York had 19 votes in the first round but only 16 in the second as several IOC members switched allegiances. In this paper, we study the computational resistance of elimination style voting rules to such strategic voting.\nResults like those of Gibbard-Satterthwaite prove that most voting rules are manipulable. That is, it may pay for agents to mis-report their preferences. One potentially appealing escape from manipulation is computational com-\nCopyright c\u00a9 2013, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nplexity (Bartholdi, Tovey, and Trick 1989). Whilst manipulations might exist, what if they are too hard to find? Unfortunately, only a few voting rules used in practice are known to be NP-hard to manipulate with unweighted votes and a single manipulator: single transferable voting (STV) (Bartholdi and Orlin 1991), a variant of the Copeland rule (Bartholdi, Tovey, and Trick 1989), ranked pairs (Xia et al. 2009), and Nanson\u2019s and Baldwin\u2019s rules (Narodytska, Walsh, and Xia 2011). A feature common to a majority of these rules is that they successively eliminate candidates. We therefore explore in more detail whether such elimination style voting makes manipulation intractable to compute."}, {"heading": "Background", "text": "We consider a general class of voting rules. A scoring rule over m candidates is defined by a vector (s1, . . . , sm) where for each vote ranking a candidate in position i, the candidate receives a score of si. The candidate with the highest total score wins. Plurality has the scoring vector (1, 0, . . . , 0), Borda has (m \u2212 1,m\u2212 2, . . . , 0), whilst veto has (1, . . . , 1, 0). For a scoring rule X with scoring vector (s1, . . . , sm), the adjoint of X , written X\u2217 has the scoring vector (s1 \u2212 sm, . . . , s1 \u2212 s2, s1 \u2212 s1). For example, the adjoint of plurality is veto. Note that (X\u2217)\u2217 = X .\nElimination versions of scoring rules can vary along a number of dimensions: Base rule: STV is an elimination version of plurality vot-\ning, whilst Nanson\u2019s and Baldwin\u2019s rules are elimination versions of Borda voting. We consider here elimination versions of other scoring rules like veto voting.\nElimination criteria: Different criteria can be used to eliminate candidates. For instance, in STV and Baldwin\u2019s rule, we succcessively eliminate the last placed candidate. On the other hand, in Nanson\u2019s rule, we eliminate all candidates with less than the average Borda score.\nStopping criteria: Do we stop when all but one candidate has been eliminated, or as soon as one candidate has a majority of first placed votes? For example, Coombs\u2019 rule is an elimination version of veto voting which stops when one candidates has a majority.\nVoting: Do agents vote just once, or in each round? For example, in STV voting, agents vote only once. On the other\nhand, when selecting Olympic venues, IOC members can cast a new vote in each round. We shall show that this increases the opportunity for manipulation.\nGiven a voting rule X , eliminate(X) is the rule that successively eliminates the candidate placed in last place by X . For a scoring rule X , divide(X) is the rule that successively eliminates those candidates with the mean or smaller score. For non-scoring rules X , divide(X) is the rule that successively eliminates candidates ranked by X in the bottom half. Finally, sequential(X) is the voting rule which runs a sequence of elections using X to eliminate the last placed candidate from each successive election. In each round, voters can change their vote according to which candidates remain.\nExample 1 STV is eliminate(plurality). Note that eliminate(STV ) is STV itself. Baldwin\u2019s rule is eliminate(Borda). Nanson\u2019s rule is divide(Borda). Exhaustive ballot is sequential(plurality). The IOC uses sequential(plurality) to select Olympic sites. The FIFA executive committee uses the same rule to select the location of the World Cup. The TV game shows, \u201cSurvivor\u201d and \u201cThe Weakest Link\u201d both use sequential(veto) to eliminate players up to the final round. Finally, Coombs\u2019 rule is related to eliminate(veto). Coombs\u2019 rule successively eliminates the candidate in last place in the most votes until there is a candidate with a majority of first place votes.\nElimination style voting rules satisfy several desirable axiomatic properties. For example, consider Condorcet consistency, the property that a voting rule elects the candidate that beats all others in pairwise comparisons when such a candidate exists. Whilst the Borda rule is not Condorcet consistent, elimination versions of Borda voting like Nanson\u2019s and Baldwin\u2019s rule are Condorcet consistent. On the other hand, elimination rounds can also destroy a deriable axiomatic property. In particular, consider monotonicity, the property that raising the position of the winner in some ballots does not change the winner. Whilst Borda voting is monotonic, elimination style voting rules like STV, Nanson\u2019s and Baldwin\u2019s are not monotonic. The loss of monotonicity is one of the significant trade-offs involved in obtaining a voting rule that is, as we shall see, somewhat more resistant to manipulation."}, {"heading": "Manipulation", "text": "Successively eliminating candidates can increase the complexity of computing a manipulation. For example, computing a manipulation of plurality is polynomial, but of eliminate(plurality) is NP-hard (Bartholdi and Orlin 1991). Similarly, computing a manipulation of Borda by one manipulator is polynomial, but of eliminate(Borda) and divide(Borda) is NP-hard (Narodytska, Walsh, and Xia 2011). Elkind and Lipmaa (2005) conjectured that many elimination style voting rules will be intractable to manipulate. They argue that \u201c[such elimination style] protocols provide the most faithful manipulation-resistant approximation to the underlying protocols, which makes them compelling alternatives to the original protocols\u201d.\nWe might wonder if elimination always increases tie computational complexity. The following result demonstrates that it does not always make computing a manipulation intractable.\nTheorem 1 There exists a non-dictatorial voting rule X for which computing a manipulation of X , eliminate(X) and divide(X) are polynomial.\nProof: Consider the rule which orders candidates alphabetically unless there is unanimity when it returns the unanimous order.\nIndeed there are even (admittedly artificial) voting rules where successively eliminating candidates reduces the computational complexity of computing a manipulation.\nTheorem 2 There exists a voting rule X for which computing a manipulation of X is NP-hard but of eliminate(X) and of divide(X) are polynomial.\nProof: Let candidates be integers in [0,m]. X is a rule whose result decides a 1-in-3-SAT problem on positive clauses over m variables. A vote which starts with 0 is interpreted as a positive clause by taking the candidates in 2nd to 4th place as its literals. Any other vote is interpreted as a truth assignment: those candidates appearing before 0 are interpreted as true literals, and those after as false. With 2 candidates, X returns the majority winner. With 3 or more candidates, X returns 0 as winner if one of the votes represents a truth assignment which satisfies exactly 1 in 3 literals in each clause represented by a vote, otherwise 1 is winner. Other candidates are returned in numerical order. Computing a manipulation of X is NP-hard. However, computing a manipulation of eliminate(X) or divide(X) is polynomial. 0 and 1 always enter the final round, and the overall winner is simply the majority winner between 0 and 1."}, {"heading": "Eliminate(veto)", "text": "Adding elimination rounds to plurality makes finding a manipulation intractable. Veto is essentially the opposite rule to plurality. This is reflected in the alternate name for veto of \u201canti-plurality\u201d. Computing a manipulation of veto is polynomial. We just veto the current winner until our chosen candidate wins. An interesting case to consider then is eliminate(veto). With weighted votes, Coleman and Teague (2007) have proved that computing a manipulation of eliminate(veto) is polynomial when the number of candidates is bounded1. They left \u201cthe difficult[y] of WCM [weighted coalition manipulation] on Coombs for unlimited candidates as an open question\u201d. We resolve this open question. Computing a manipulation of eliminate(veto) and of the closely related Coombs\u2019 rule is NP-hard even with unweighted votes and an unbounded number of candidates.\nTheorem 3 Deciding if a single manipulator can make a candidate win for eliminate(veto) is NP-complete.\nProof: (Sketch, the full proof can be found online in a technical report). The proof is inspired by ideas\n1Note that Coleman and Teague call the voting rule studied in their paper Coombs\u2019 rule but it is, in fact, eliminate(veto).\nfrom (Bartholdi and Orlin 1991). We reduce from the 3- COVER problem. We are given a set S = {d1, . . . , dn} with |S| = n and subsets S1, S2, . . . , Sm \u2282 S with |Si| = 3 for i \u2208 [1,m]. We ask if there exists an index set I with |I| = n/3 and \u22c3 i\u2208I Si = S. This set of Si is called a cover for S. We create an eliminate(veto) election such that a manipulator can make a given candidate win iff there exists a cover for S.\nThe set of all candidates is C where |C| = c, and consists of 7 groups: \u2018preferred candidate\u2019 p; \u2018items\u2019 {d1, . . . , dn} and an extra \u2018item\u2019 d0; \u2018first losers\u2019 {a1, a\u03041 . . . , am, a\u0304m}; \u2018second line\u2019 {b1, b\u03041, . . . , bm, b\u0304m} ; \u2018pumps\u2019 {p1, . . . , pm}; \u2018switches\u2019 s1 and s2; \u2018garbage collectors\u2019 gd0 , . . . , g \u2032 s1 (see Table 1 for the complete list of garbage collectors). The elimination has 4 phases: (1) cover selection, (2),(3) cover verification (4) garbage collection.\nLet \u03c3k(c\u2032), c\u2032 \u2208 C be the number of last place votes for candidate c\u2032 at round k. We call this the veto-score of c\u2032. First, we explain the candidates. The candidates \u2018first losers\u2019, \u2018second line\u2019 and \u2018pumps\u2019 form a gadget to select a cover. There are 5m candidates of these types in total, logically partitioned into elimination groups \u3008ai, a\u0304i, bi, b\u0304i, pi\u3009, i \u2208 [1,m]. The construction makes sure that 4 out of 5 elements of ith group are eliminated consecutively during 4 rounds starting at round 4i + 1, i \u2208 [0,m). Moreover, {ai, a\u0304i, pi}, i \u2208 [1,m] must be eliminated letting one of the {bi, b\u0304i} reach round 4m. Eliminated candidates bi determine selection sets Si. The \u2018pump\u2019 pi increases the veto-scores of all candidates except \u2018garbage collectors\u2019 and i running candidates from groups j, j \u2264 i. This allows us to remember i choices of the manipulator encoded in these i running candidates from 2i candidates in {bj , b\u0304j}, j = 1, .., i. The \u2018items\u2019 candidates encode the set of items. The\u2018switches\u2019 check the cover. The first \u2018switch\u2019 s1 separates elimination of p, d0, . . . , dn, s2 from the elimination of other candidates. The second \u2018switch\u2019 s2 is the most dangerous candidate that can be eliminated iff a valid cover is selected during the first 4m rounds. \u2018Garbage collectors\u2019 gd0 , . . . , gs1 control the veto-scores of non-garbage candidates. \u2018Garbage collectors\u2019 g\u2032d0, . . . , g \u2032 s1 prevent p from having a majority (which is needed later on to prove Theorem 6). We partition votes into two sets: P1 and P2. Table 1 shows the votes. in reverse preference order. We refer to sets of votes in each line of the table by the number in the third column. For convenience, we introduce a new garbage candidate in each set of votes. Unspecified candidates are ordered in the same arbitrary order, starting with gd0 , . . . , gdn in all votes. P1 is the main construction. Lines 1\u20133 set up initial veto-scores for the preferred candidate and \u2018items\u2019. Lines 4\u2013 22 encode the 1st phase. The important point to observe is how \u2018pumps\u2019 work (lines 18\u201328). The candidate pi is eliminated last in its group and increases the veto-score of all other running candidates by a constant 2f2 except running candidates in \u222aij=1{bj, b\u0304j} and \u2018garbage\u2019 candidates. This allows m running candidates selected from \u222amj=1{bj, b\u0304j} to reach the 4th phase. Lines 23\u201328 make sure that veto-score of \u2018items\u2019 and \u2018switches\u2019, that are not eliminated during the 1st phase, grow the same way as veto-scores of a\u2019s, b\u2019s and p\u2019s. Line 27 is used to eliminate s1 at round 4m+ 1. Lines\n29-34 are used to check a cover. In particular, lines 33\u201334 are used to count how many candidates di, i \u2208 [0, n] are eliminated by increasing veto-scores of s2. Finally, line 35 is responsible for triggering the garbage collection procedure.P2 ensures that all \u2018pumps\u2019 and the \u2018switch\u2019 s1 have initial score of X , where X is sufficiently large number, e.g. X > 16m5 and \u03c31P1(c \u2032) is the number of last place votes for candidate c\u2032 in the votes P1 at the first round. The initial veto-score of a garbage collector equals 0 and stays less than X until the 4th phase. So we do not have to worry about the garbage\ncollectors during the first three phases. We also define the following constants required to control elimination inside each group \u3008ai, a\u0304i, bi, b\u0304i, pi\u3009, i \u2208 [1,m]. The f constants in Table 1 satisfy the following constraints: f12 = f1 + f2, f123 = f1 + f2 + f3, f1 \u2265 f2 + 2f3 + 2, 2f2 \u2265 f1 + 2, 2f2 \u2265 f3 + 2, f1 \u2265 f3 + 2, fi \u2265 2m + 3 for i \u2208 [1, 3], and f4 = 2m\u2212 2n/3 + 3. For example, f1 = 11(2m+ 3), f2 = 8(2m+ 3) and f3 = 3 + (2m+ 3). Overall, the construction ensures that initial veto-scores of all candidates a, b, p, s1 equals X with an exception of a1 and a\u03041 that have X+3 veto-points. All the other candidates have veto-scores that are less than or equal to X . This forces the manipulator to make a choice between a1 and a\u03041 in the first round which triggers a selection of sets in a cover. We assume the tie-breaking rule: s2 \u227a d0 \u227a p \u227a d1,\u227a . . . \u227a dn, . . ..\nPhase 1. Cover selection. Rounds 1 to 4m. The 1st phase eliminates m candidates, one from each pair {bi, b\u0304i}, i \u2208 [1,m]. If bi is eliminated then the set Si is selected in the cover. A manipulator will choose which candidate from each pair is eliminated. We claim the following holds in the first 4m rounds where i \u2208 [0,m\u2212 1]: \u22b2 Round 4i+1. The following invariant holds immediately before the 4i+ 1st candidate is eliminated:\n\u03c34i+1(ai+1) = \u03c3 4i+1(a\u0304i+1) \u2265 \u03c3 4i+1(c\u2032) + 3,\nwhere c\u2032 \u2208 C \\ {a1, a\u03041, .., ai+1, a\u0304i+1, b1, b\u03041, .., bi, b\u0304i}. The manipulator can select which of ai+1 or a\u0304i+1 is eliminated.\nThe manipulator cannot change the outcome of the following three rounds. \u22b2 Round 4i + 2. bi+1 is eliminated at this round iff ai+1 is eliminated at the previous round. Similarly, b\u0304i+1 is eliminated iff a\u0304i+1 is eliminated at the previous round. \u22b2 Round 4i+3. ai+1 is eliminated at this round iff a\u0304i+1 is eliminated at the 4i+1st round. Similarly, a\u0304i+1 is eliminated at this round iff ai+1 is eliminated at the 4i+ 1st round. \u22b2 Round 4i+ 4. The candidate pi+1 is eliminated. Hence, the manipulator select m candidates in \u222ami=1{bi, b\u0304i} to eliminate. The elimination of pm at round 4m forces an increase of the veto-scores of p, d0, . . . , dn, s1, s2 by 2f2 (lines 23\u201326,28) and an additional increase of f1 in the veto-score of s1 (line 27). This means s1 is the next candidate to be eliminated.\nPhase 2. Pump up of p, s2, d0, . . . , dn. Round 4m + 1. The elimination of s1 increases the veto-scores of p, s2, d0, . . . , dn by 4f2 + f1.\nPhase 3. Cover verification. Rounds 4m+2 to 4m+2+ (n+1). This phase ensures that p reaches the next phase iff the sets Si that correspond to eliminated candidates bi form a cover of d1, . . . , dn and there are exactly n/3 such candidates. Consider the candidates p, s2, d0, . . . , dn. We observe that at round 4m+ 2:\n\u03c34m+2(p) = \u03c34m+2(di)\u2212 1 + 2\u2212 y 4m+2 i ,\n\u03c34m+2(p) = \u03c34m+2(d0)\u2212 1 + 2(m\u2212 n/3 + 1)\u2212 y 4m+2 0 ,\n\u03c34m+2(p) = \u03c34m+2(s2)\u2212 1 + (n+ 1) + 2,\nwhere y4m+2i , i \u2208 [0, n] is the veto-score that candidate di gets during the first 4m+ 1 rounds in addition to its initial veto-score, y4m+2i is even. As can be seen from these equations, s2 can be eliminated before p iff s2 gets n+2 extra veto-points. This is possible iff d0, . . . , dn are eliminated before s2 so that s2 gets n+1 veto-points from lines 33\u201334. Moreover, the manipulator must give an extra veto-point to s2. Then, by the tie-breaking rule, s2 is eliminated before p. Consider how to eliminate d0, . . . , dn before s2 and p. \u22b2 Candidates di for i = 1, . . . , n: Let dk be the candidate with the highest value y4m+2k . If y 4m+2 k \u2265 2 then dk is eliminated. This only increases the veto-score of s2 by 1 and does not affect the veto-scores of other running candidates. Suppose that there exists k such that y4m+2k = 0. In this case p has 1 veto-point extra compared to dk. Moreover, the manipulator cannot save p from elimination due to the tie-breaking rule. Hence, y4m+2i \u2265 2 for i \u2208 [1, n]. This means that sets Sj that correspond to candidates bj that are eliminated during the first phase cover all values. Next we show that exactly n/3 of bj\u2019s are eliminated. \u22b2 The candidate d0: This candidate has 2(m \u2212 n/3) + 1 veto-points less than the veto-score of p. Hence, during the first phase d0 needs to get at least 2(m \u2212 n/3) extra vetopoints. This means that m\u2212n/3 of the candidates b\u0304j have to be eliminated during the first phase. Hence exactly n/3 bj\u2019s can be eliminated during the first phase. Finally, the manipulator gives one extra veto-point to d0 and, by the tie-breaking rule, d0 is eliminated. Hence, s2 is eliminated after dis, and p reaches the next round.\nPhase 4. Garbage collection. Rounds 4m + 2 + (n + 1)+1 to c. This phase ensures that p wins if it is not already eliminated. p is either the last, first or second candidate in all remaining votes at this round. Hence, its veto-score does not change until the penultimate round. The elimination of d0, and then s2, increases the veto-score of a candidate gd0 by 2X \u2212 (n+1)\u2212 2(m\u2212 n/3)\u2212 5 (lines 2 and 35), which triggers elimination of other running candidates up to round c\u2212 2. When only 2 candidates remain, p must win.\nThe reverse direction is trivial. Given a cover I , we construct the vote of a manipulator in the following way. If i is in cover, we put ai at position c \u2212 2i and a\u0304i at position c\u22122i\u22121. Otherwise, we invert their positions. Then we put d0, s2. Finally, we make p the most preferred candidate, and put the remaining candidates in an arbitrary order."}, {"heading": "Coombs\u2019 Rule", "text": "Coombs\u2019 rule is a variant of eliminate(veto) with the stopping criteria that a winner is declared when one candidate has a majority of first placed votes (instead of when one candidate remains). Although this is a small change, it can have a large impact on the result and on strategic voting. For instance, there are a family of elections where the number of manipulators required to achieve victory for a particular candidate is unbounded for eliminate(veto) but bounded for Coombs\u2019, and vice versa.\nTheorem 4 There exists an election with n + 3 candidates where a given candidate has already won with eliminate(veto) but the number of manipulators with\nCoombs\u2019 rule is \u2126(n).\nProof: We have n votes: (a, d1, .., dn, b, c), (a, d2, .., dn\u22121, b, c), .., (a, dn, .., d1, b, c). Note that positions 2\u2212 (n+ 1) in these votes contain a cyclic permutation of candidates d1, . . . , dn. Similarly, for the other two groups of n votes. We also have n votes: (b, a, d1, .., dn, c), (b, a, d2, .., dn\u22121, c), .., (b, a, dn, .., d1, c). Finally we have n votes: (c, b, a, d1, .., dn), (b, a, d2, .., dn\u22121), .., (c, b, a, dn, .., d1). The preferred candidate is a. As is common in the literature, ties are broken in favor of manipulators. For eliminate(veto), c is eliminated in the first round and b in the second. a is now in first place in all votes so ultimately wins. For Coombs\u2019, c is eliminated in the first round. b is then in the first place in 2n votes and wins by the majority rule. There are two options for the manipulators. Either they add n votes to the elections to make sure that b does not have a majority after the first elimination round, or they prevent the elimination of the candidate c in the first round. With the exception of c, each candidate has has only one veto point. Therefore, the manipulators need at least 2n\u2212 1 votes to prevent the elimination of c.\nTheorem 5 There exists an election with n + 2 candidates which a single manipulator can manipulate with Coombs\u2019 rule but eliminate(veto) requires \u2126(n) manipulators.\nProof: We have n votes: (a, b, d1, .., dn), (a, b, d2, .., dn\u22121), .., (a, b, dn, .., d1). Note that positions 2 \u2212 (n + 1) in these votes contain a cyclic permutation of candidates d1, . . . , dn. Similarly, for the other group of n votes. We also have n votes: (b, d1, .., dn, a), (b, d2, .., dn\u22121, a), .., (b, dn, .., d1, a). None of the candidates has a majority. For Coombs\u2019, if one manipulator puts a in first place then a wins. For eliminate(veto), the manipulators must prevent the elimination of a in the first round. As candidates d1 to dn have only 1 veto point we need at least n \u2212 1 manipulators to prevent the elimination of a.\nDespite these differences between Coombs\u2019 rule and eliminate(veto), it is intractable to compute a manipulation for Coombs\u2019 as it is with eliminate(veto).\nTheorem 6 Deciding if a single manipulator can make a candidate win for the Coombs\u2019 rule is NP-complete.\nProof: Follows from the proof of Theorem 3 as g\u2032i can be eliminated after a cover is verified."}, {"heading": "Eliminate(scoring rule)", "text": "We next consider scoring rules in general. With weighted votes, Coleman and Teague (2007) have proved that manipulation by a coalition is NP-hard to compute for the elimination version of any scoring rule X that is not isomorphic to veto. With unweighted votes, we prove a general result that relates the computational complexity of manipulating a scoring rule and the elimination version of its adjoint.\nTheorem 7 Deciding whether k manipulators can make a candidate win for eliminate(X) is NP-complete if it is NPcomplete also for X\u2217.\nProof: First, we argue that for votes V , k manipulators can make a candidate win with X\u2217 iff for the reversed\nset of votes V \u2217, k manipulator can make a candidates come last with X . The proof is similar to Lemma 10 in (Coleman and Teague 2007). We simply reverse all the manipulating votes. Suppose V \u2217 is an election over m candidates where m \u2265 3, and the k manipulators want cm to come last. Let U be s1(|V |+ k+ 1) copies of the following votes:\nc1 \u227b c2 \u227b . . . \u227b cm\u22121 \u227b cm, c2 \u227b c3 \u227b . . . \u227b cm \u227b c1,\n... cm \u227b c1 \u227b . . . \u227b cm\u22122 \u227b cm\u22121\nEach candidate receives the same score in U irrespective of X . We argue that there is a manipulation making c1 win in V \u2217 \u222a U for eliminate(X) if there is a manipulation making cm last in V \u2217 for X . By the same argument as in the proof of Theorem 13 in (Coleman and Teague 2007), if ci is the first candidate eliminated in V \u2217 \u222a U , then no matter how the manipulators vote, the elimination order is ci, ci\u22121, ci\u22122, . . . , ci+1 (where cm+1 = c1) and ci+1 wins. Hence c1 wins iff cm is eliminated first. The manipulators can force cm to be eliminated first in V \u2217\u222aU if they can force cm to be last in V \u2217 as the relative scores of the candidates are initially the same in V \u2217 and in V \u2217 \u222aU . Hence manipulation of X\u2217 reduces to manipulation of eliminate(X).\nBorda is NP-hard to manipulate with 2 manipulators (Betzler, Niedermeier, and Woeginger 2011; Davies et al. 2011). Since the adjoint of Borda is Borda itself, it follows from Theorem 7 that eliminate(Borda), which is Baldwin\u2019s rule, is NP-hard to manipulate by 2 manipulators. This result is strengthened to NP-hard with just one manipulator in (Narodytska, Walsh, and Xia 2011). Note that the reverse of Theorem 7 does not hold. STV, which is eliminate(plurality), is NP-hard to manipulate but plurality is only polynomial to manipulate.\nWe next identify a large class of scoring rules which are intractable to manipulate. Given a fixed k, a truncated scoring rule (scoret) has a scoring vector (s1, . . . , sm) with si = 0 for all i > k. For example, plurality and kapproval voting are both truncated scoring rules. As a second example, the Heisman Trophy, which is awarded annually to the best player in collegiate football, uses the truncated scoring rule (3, 2, 1, 0, . . . , 0). As a third and final example, the Eurovision song contest uses the truncated scoring rule (12, 10, 8, 7, 6, 5, 4, 3, 2, 1, 0, . . . , 0). We now prove out next major results: computing a manipulation of eliminate(scoret) or of divide(scoret) is intractable. When candidates are eliminated, we suppose that the scoring vector is truncated to the first m positions where m is the number of candidates left after elimination.\nTheorem 8 Deciding if a single manipulator can make a candidate win for eliminate(scoret) is NP-complete.\nProof: (Sketch, the full proof can again be found online in a technical report). The proof is also inspired by ideas from (Bartholdi and Orlin 1991) and uses a reduction from 3-COVER. We block the first k \u2212 1 positions in each vote with an additional set of q(k \u2212 1) dummy candidates,\nwhere the value q is computed taking into account the scoring vector. By this construction, only those scores at positions k to c, which are (sk, 0, . . . , 0), determine the elimination order for the first c \u2212 q(k \u2212 1) \u2212 1 rounds, where c is the total number of candidates. We thereby reduce our problem to one that resembles a multiple of the reduction used for STV. Only one non-dummy candidate reaches the (c \u2212 q(k \u2212 1) \u2212 1)th round. If the preferred candidate p reaches this round then the remaining votes are such that p wins the election. Similar to the reduction used in the STV proof, this only happens if there is a 3-COVER. As we have a large number of additional dummy candidates, we can make sure that the individual score of each dummy candidate is greater than the score of any non-dummy candidate until the (c \u2212 q(k \u2212 1)\u2212 1)th round and is smaller than the score of p at the (c\u2212 q(k \u2212 1)\u2212 1)th round.\nTheorem 9 Deciding if a single manipulator can make a candidate win for divide(scoret) is NP-complete.\nProof: (Sketch, the full proof can again be found online in a technical report). The proof uses a reduction from the 3- COVER problem where k = n/3, n is the number of items. The first two rounds encode solving the 3-COVER problem and the remaining rounds are used to collect garbage. The main types of candidates are n \u2018items\u2019, m \u2018sets\u2019 and one \u2018preferred\u2019. The rest of the candidates are dummy candidates that are used to control scores of non-dummy candidates and the average score. In the first round, we select k sets. Using a large number of dummy candidates we make sure that the score of \u2019sets\u2019 candidates equals the average score at the first round. Hence, manipulator can select k of them to pass to the second round. In the second round, we check that this forms a cover. If this is the case, all \u2019items\u2019 candidates in the covered set are eliminated. Otherwise, one of the \u2018items\u2019 candidates reaches the third round and wins the election."}, {"heading": "Sequential Rules", "text": "When selecting the site of the next Olympics, IOC members can cast a new vote in each round. This increases the opportunity for manipulation. In fact, we can exhibit an election in which a manipulator can only change the result if the manipulator votes differently in each round.\nExample 2 Consider the following 21 votes: 1: (a, h, p, . . . ), 1: (c, a, h, p, . . . ), 1: (d, a, h, p, . . . ) 3: (g, a, h, p, . . . ), 2: (b, h, p, . . . ), 2: (e, b, h, p, . . . ) 2: (f, b, h, p, . . . ), 6: (h, p, . . . ), 5: (p, h, . . . )\nThe election uses sequential(plurality), and the manipulator wants p to win. The tie-breaking rule is p \u227a g \u227a c \u227a d \u227a a \u227a e \u227a f \u227a b \u227a h.\nWe first argue that a single manipulator cannot make p win. Note that p cannot gain any points until h is eliminated. For p to win, the manipulator needs to give p one point so that it has 6 points (and beats h by the tie-breaking rule) and no other candidate receives more than 6 points. In order for h not to receive any more than the initial 6 points, a and b must not be eliminated. The manipulator must save a from elimination in the first round by voting for a. The first two rounds therefore eliminate c and d. Unfortunately,\nthe manipulator cannot stop b being eliminated next. h now receives 2 more points and p cannot win the election. Therefore, a single manipulator cannot make p win.\nOn the other hand, if a single manipulator votes for a in the first two rounds, c and d are eliminated and a has 3 points and is safe for now. At this point, b is in danger with only 2 points. If the manipulator now votes for b, b is saved and both e and f are eliminated next. At this point, a and g are tied. If the manipulator now votes for a again, g is eliminated and the score of a increases to 6. At this point, all candidates except p have 6 points, and if the manipulator now votes for p, h is eliminated by tie-breaking and p wins the election. Hence, if the manipulator can change votes after each round, p can win.\nIn general, manipulating a sequential elimination election requires a strategy, which provides a manipulating response however the other agents vote. It is not hard to see that deciding if such a strategy exists is PSPACE-complete. In fact, strategic voting in a sequential elimination election invites a game theoretic analysis. We can view a sequential elimination election as a finite repeated sequential game. We could, for example, use backward induction to find the subgame perfect Nash equilibrium in which each agent makes the best strategic move in each round."}, {"heading": "Other Related Work", "text": "Bag, Sabourian and Winter (2009) proved that many sequential elimination rules including sequential(plurality) elect candidates in the top cycle (and are hence Condorcet consistent) supposing strategic voting. Contizer and Sandholm (2003) studied the impact on the tractability of manipulation of adding an initial round of the Cup rule to a voting rule. This initial round eliminates half the candidates and makes manipulation NP-hard to compute for several voting rule including plurality and Borda. Elkind and Lipmaa (2005) extended this idea to a general technique for combining two voting rules. The first voting rule is run for some number of rounds to eliminate some of the candidates, before the second voting rule is applied to the candidates that remain. They proved that many such combinations of voting rules are NP-hard to manipulate. However, they did not consider the veto or truncated scoring rules at the centre of our study here. They also considered the closed protocol, where a rule is combined with itself. In many cases, the closed protocol of X is eliminate(X). They conjectured that such closed protocols will often be NP-hard to manipulate."}, {"heading": "Conclusions", "text": "We have provided more evidence that successively eliminating candidates is often a route to making manipulation intractable to compute. In general, eliminating candidates does not necessarily increase the computational complexity of manipulation. Indeed, we exhibited an artificial voting rule where the computational complexity actually decreases. However, for many voting rules used in practice, the computational complexity increases. For example, it was known that it is NP-hard to compute how a single voter can manipulate the result of STV (the elimination verison of plurality\nvoting), and Nanson\u2019s and Baldwin\u2019s rule (elimination versions of Borda voting). In this paper, we showed that it is NP-hard to compute how a single voter can manipulate the result of the elimination version of veto voting, of the closely related Coombs\u2019 rule, and of the elimination versions of a general class of truncated scoring rules. On the other hand, we showed that permitting voters to re-vote between elimination rounds can increase the opportunity for manipulation.\nWhat general lessons can be learnt from these studies? First, elimination style voting does indeed appear to provide some computational resistance to manipulation. Second, these results have involved worst case complexity notions like NP-hardness. We need to treat these with care as there is theoretical evidence (for instance, (Xia and Conitzer 2008a; Friedgut, Kalai, and Nisan 2008; Xia and Conitzer 2008b)), as well as practical experience which suggests that elimination style rules like STV (Coleman and Teague 2007; Walsh 2010), as well as voting rules like veto (Walsh 2009) can be easy to manipulate on average. Third, if voters can re-vote between elimination rounds, new opportunities for manipulation arise. It would be interesting therefore to consider both game-theoretic and computational aspects of such strategic voting. For example, what are the possible equilibria and how difficult are they to compute? Fourth, manipulation is closely connected to questions about possible winners given uncertainty about the votes (Pini et al. 2007; Walsh 2007) and to elicitation (Walsh 2008). It would therefore be interesting to consider reasoning about possible winners and preference elicitation for elimination style voting rules."}, {"heading": "Acknowledgments", "text": "The authors are supported by the Australian Government\u2019s Department of Broadband, Communications and the Digital Economy, the Australian Research Council and the Asian Office of Aerospace Research and Development through grants AOARD-104123 and 124056."}], "references": [{"title": "Multi-stage voting, sequential elimination and condorcet consistency", "author": ["Sabourian Bag", "P. Winter 2009] Bag", "H. Sabourian", "E. Winter"], "venue": "Journal of Economic Theory", "citeRegEx": "Bag et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bag et al\\.", "year": 2009}, {"title": "Single transferable vote resists strategic voting. Social Choice and Welfare 8(4):341\u2013354", "author": ["Bartholdi", "J. Orlin 1991] Bartholdi", "J. Orlin"], "venue": null, "citeRegEx": "Bartholdi et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Bartholdi et al\\.", "year": 1991}, {"title": "The computational difficulty of manipulating an election", "author": ["Tovey Bartholdi", "J. Trick 1989] Bartholdi", "C. Tovey", "M. Trick"], "venue": "Social Choice and Welfare", "citeRegEx": "Bartholdi et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Bartholdi et al\\.", "year": 1989}, {"title": "Unweighted coalitional manipulation under the Borda rule is NP-hard", "author": ["Niedermeier Betzler", "N. Woeginger 2011] Betzler", "R. Niedermeier", "G. Woeginger"], "venue": "Proc. of the 22nd International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Betzler et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Betzler et al\\.", "year": 2011}, {"title": "On the complexity of manipulating elections", "author": ["Coleman", "T. Teague 2007] Coleman", "V. Teague"], "venue": null, "citeRegEx": "Coleman et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Coleman et al\\.", "year": 2007}, {"title": "Universal voting protocol tweaks to make manipulation hard", "author": ["Conitzer", "V. Sandholm 2003] Conitzer", "T. Sandholm"], "venue": "In Proc. of 18th International Joint Conference on Artificial Intelligence", "citeRegEx": "Conitzer et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Conitzer et al\\.", "year": 2003}, {"title": "Complexity of and algorithms for Borda manipulation", "author": ["Davies"], "venue": "Proc. of the Twenty-Fifth AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "Davies,? \\Q2011\\E", "shortCiteRegEx": "Davies", "year": 2011}, {"title": "Hybrid voting protocols and hardness of manipulation", "author": ["Elkind", "E. Lipmaa 2005] Elkind", "H. Lipmaa"], "venue": "Proc. of 16th International Symposium on Algorithms and Computation (ISAAC 2005),", "citeRegEx": "Elkind et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Elkind et al\\.", "year": 2005}, {"title": "Elections can be manipulated often", "author": ["Kalai Friedgut", "E. Nisan 2008] Friedgut", "G. Kalai", "N. Nisan"], "venue": "In Proc. of the 49th Annual IEEE Symposium on Foundations of Computer Science (FOCS 2008),", "citeRegEx": "Friedgut et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Friedgut et al\\.", "year": 2008}, {"title": "Manipulation of Nanson\u2019s and Baldwin\u2019s rules", "author": ["Walsh Narodytska", "N. Xia 2011] Narodytska", "T. Walsh", "L. Xia"], "venue": "Proc. of the Twenty-Fifth AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "Narodytska et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Narodytska et al\\.", "year": 2011}, {"title": "Incompleteness and incomparability in preference aggregation", "author": ["Pini"], "venue": "Proc. of the 20th International Joint Conference on Artificial Intelligence", "citeRegEx": "Pini,? \\Q2007\\E", "shortCiteRegEx": "Pini", "year": 2007}, {"title": "Uncertainty in preference elicitation and aggregation", "author": ["T. Walsh"], "venue": "In Proc. of the 22nd National Conference on AI,", "citeRegEx": "Walsh,? \\Q2007\\E", "shortCiteRegEx": "Walsh", "year": 2007}, {"title": "Complexity of terminating preference elicitation", "author": ["T. Walsh"], "venue": "7th International Joint Conference on Autonomous Agents and Multiagent Systems", "citeRegEx": "Walsh,? \\Q2008\\E", "shortCiteRegEx": "Walsh", "year": 2008}, {"title": "Where are the really hard manipulation problems? The phase transition in manipulating the veto rule", "author": ["T. Walsh"], "venue": "Proc. of the 21st International Joint Conference on Artificial Intelligence", "citeRegEx": "Walsh,? \\Q2009\\E", "shortCiteRegEx": "Walsh", "year": 2009}, {"title": "An empirical study of the manipulability of single transferable voting", "author": ["T. Walsh"], "venue": "Proc. of the 19th European Conference on Artificial Intelligence (ECAI-2010),", "citeRegEx": "Walsh,? \\Q2010\\E", "shortCiteRegEx": "Walsh", "year": 2010}, {"title": "Generalized scoring rules and the frequency of coalitional manipulability", "author": ["Xia", "L. Conitzer 2008a] Xia", "V. Conitzer"], "venue": "Proc. of the 9th ACM conference on Electronic Commerce (EC\u2019", "citeRegEx": "Xia et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Xia et al\\.", "year": 2008}, {"title": "A sufficient condition for voting rules to be frequently manipulable", "author": ["Xia", "L. Conitzer 2008b] Xia", "V. Conitzer"], "venue": "Proc. of the 9th ACM conference on Electronic Commerce (EC\u2019", "citeRegEx": "Xia et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Xia et al\\.", "year": 2008}, {"title": "Complexity of unweighted coalitional manipulation under some common voting rules", "author": ["Xia"], "venue": "Proc. of the 21st International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Xia,? \\Q2009\\E", "shortCiteRegEx": "Xia", "year": 2009}], "referenceMentions": [{"referenceID": 11, "context": "Similarly, computing a manipulation of Borda by one manipulator is polynomial, but of eliminate(Borda) and divide(Borda) is NP-hard (Narodytska, Walsh, and Xia 2011). Elkind and Lipmaa (2005) conjectured that many elimination style voting rules will be intractable to manipulate.", "startOffset": 145, "endOffset": 192}, {"referenceID": 14, "context": "We need to treat these with care as there is theoretical evidence (for instance, (Xia and Conitzer 2008a; Friedgut, Kalai, and Nisan 2008; Xia and Conitzer 2008b)), as well as practical experience which suggests that elimination style rules like STV (Coleman and Teague 2007; Walsh 2010), as well as voting rules like veto (Walsh 2009) can be easy to manipulate on average.", "startOffset": 250, "endOffset": 287}, {"referenceID": 13, "context": "We need to treat these with care as there is theoretical evidence (for instance, (Xia and Conitzer 2008a; Friedgut, Kalai, and Nisan 2008; Xia and Conitzer 2008b)), as well as practical experience which suggests that elimination style rules like STV (Coleman and Teague 2007; Walsh 2010), as well as voting rules like veto (Walsh 2009) can be easy to manipulate on average.", "startOffset": 323, "endOffset": 335}, {"referenceID": 11, "context": "For example, what are the possible equilibria and how difficult are they to compute? Fourth, manipulation is closely connected to questions about possible winners given uncertainty about the votes (Pini et al. 2007; Walsh 2007) and to elicitation (Walsh 2008).", "startOffset": 197, "endOffset": 227}, {"referenceID": 12, "context": "2007; Walsh 2007) and to elicitation (Walsh 2008).", "startOffset": 37, "endOffset": 49}], "year": 2013, "abstractText": "Successive elimination of candidates is often a route to making manipulation intractable to compute. We prove that eliminating candidates does not necessarily increase the computational complexity of manipulation. However, for many voting rules used in practice, the computational complexity increases. For example, it is already known that it is NP-hard to compute how a single voter can manipulate the result of single transferable voting(the elimination version of plurality voting). We show here that it is NP-hard to compute how a single voter can manipulate the result of the elimination version of veto voting, of the closely related Coombs\u2019 rule, and of the elimination versions of a general class of scoring rules.", "creator": "LaTeX with hyperref package"}}}