{"id": "1205.1975", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-May-2012", "title": "Expressivity of Time-Varying Graphs and the Power of Waiting in Dynamic Networks", "abstract": "communicating infrastructure - less highly dynamic networks, computing and performing even basic tasks ( such including routing and broadcasting ) means a pretty challenging activity due to the necessity that connectivity does not necessarily hold, and the network may constantly be disconnected at every time track. clearly the task of designing protocols for these networks is less difficult if the environment saves waiting ( i. e., it provides the security with store - carry - forward - like mechanisms such as local buffering ) than where waiting is not feasible. slight quantitative corroborations of this fact exist ( e. on., no answer to the question : how much easier? ). in this paper, topics engage these philosophical questions about dynamic networks, modeled as time - varying ( or evolving ) graphs, where edges exist only but some times.", "histories": [["v1", "Wed, 9 May 2012 13:19:46 GMT  (23kb)", "http://arxiv.org/abs/1205.1975v1", null]], "reviews": [], "SUBJECTS": "cs.DC cs.CL", "authors": ["arnaud casteigts", "paola flocchini", "emmanuel godard", "nicola santoro", "masafumi yamashita"], "accepted": false, "id": "1205.1975"}, "pdf": {"name": "1205.1975.pdf", "metadata": {"source": "CRF", "title": "Expressivity of Time-Varying Graphs and the Power of Waiting in Dynamic Networks", "authors": ["A. Casteigts", "P. Flocchini", "E. Godard", "N. Santoro", "M. Yamashita"], "emails": ["casteig@eecs.uottawa.ca", "flocchin@eecs.uottawa.ca", "egodard@cmi.univ-mrs.fr", "santoro@scs.carleton.ca", "mak@csce.kyushu-u.ac.jp"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 5.\n19 75\nv1 [\ncs .D\nC ]\nWe prove that the set of languages Lnowait when no waiting is allowed contains all computable languages. On the other end, using algebraic properties of quasi-orders, we prove that Lwait is just the family of regular languages. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (difficulty of the environment) drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting.\nWe also study bounded waiting; that is when waiting is allowed at a node only for at most d time units. We prove the negative result that Lwait[d] = Lnowait; that is, the expressivity decreases only if the waiting is finite but unpredictable (i.e., under the control of the protocol designer and not of the environment)."}, {"heading": "1 Introduction", "text": ""}, {"heading": "1.1 Highly Dynamic Networks", "text": "Computing in static networks (complex or otherwise) is a subject which has been intensively studied from many point of views (serial/distributed, centralized/decentralized, offline/online, etc.), and it is one of the central themes of distributed computing. Computing in dynamic networks, that is where the structure of the network changes in time, is relatively less understood. Extensive research has been devoted to systems where the network dynamics are due to faults (e.g., node or edge deletions or additions). Indeed fault-tolerance is probably the most profound concern in distributed computing. Faults however are limited in scope, bounded\nin number, and are considered anomalies with respect to the correct behaviour of the system. The study of computing in systems where the network faults are actually extensive and possibly unbounded is at the core of the field of self-stabilization; the goal of the research is to devise protocols that, operating in such extreme faulty conditions, are nevertheless able to provide correct solutions if the system instability subsides (for long enough time). Also in this case, faults in the network structure are considered anomalies with respect to the correct behaviour of the system.\nWhat about systems where the instability never ends? where the network is never connected? where changes are unbounded and occur continuously? where they are not anomalies but integral part of the nature of the system?\nSuch highly dynamic systems do exist, are actually quite widespread, and becoming more ubiquitous. The most obvious class is that of wireless ad hoc mobile networks: the topology of the communication network, formed by having an edge between two entities when they are in communication range, changes continuously in time as the movement of the entities destroys old connections and creates new ones. These changes can be dramatic; connectivity does not necessarily hold, at least with the usual meaning of contemporaneous end-to-end multi-hop paths between any pair of nodes, and the network may actually be disconnected at every time instant. These infrastructure-less highly dynamic networks, variously called delay-tolerant, disruptive-tolerant, challenged, opportunistic, have been long and extensively investigated by the engineering community and, more recently, by distributed computing researchers, especially with regards to the problems of broadcast and routing (e.g. [22, 27, 33]).\nIn these networks, the protocol designer has no a priori knowledge nor control over the trajectories of the entities. However, similar highly dynamic conditions occur also when the mobility of the entities follows a predictable pattern, e.g. periodic or cyclic routes, like in the case of public transports with fixed timetables, low earth orbiting (LEO) satellite systems, security guards\u2019 tours, etc. (e.g., see [28, 32]). Interestingly, similar complex dynamics occur also in environments where there is no mobility at all, e.g., in social networks (e.g. [12, 24]).\nNote that when dealing with these dynamic networks, most of the basic network and graph concepts - such as path, distance, diameter, connected components, etc - have no meaning without a temporal context; indeed, all the usual connectivity concepts have to be extended to a temporal version to take into account the realities of the environments being modeled."}, {"heading": "1.2 Journey and Wait", "text": "From a formal point of view, the highly dynamic features of these networks and their temporal nature are captured by the model of time-varying graphs (or evolving graphs), where edges between nodes exist only at some times, a priori unknown to the algorithm designer (e.g., see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).\nA crucial aspect of dynamic networks, and obviously of time-varying graphs, is that a path from a node to another might still exist over time, even though at no time the path exists in its entirety. It is this fact that renders routing, broadcasting, and thus computing possible in spite of the otherwise unsurmountable difficulties imposed by the nature of those networks. Hence, the notion of \u201cpath over time\u201d, formally called journey, is a fundamental concepts and plays a central role in the definition of almost all concepts related to connectivity in time-varying graphs.\nExamined extensively, under a variety of names (e.g., temporal path, schedule-conforming path, timerespecting path, trail), informally a journey is a walk <e1, e2, ..., ek> and a sequence of time instants <t1, t2, ..., tk> where edge ei exists at time ti and its latency \u03b6i at that time is such that ti+1 \u2265 ti + \u03b6i.\nWhile the concept of journey captures the notion of \u201cpath over time\u201d so crucial in dynamical systems, it does not yet capture additional limitations that some of these environments can impose on the use of the journeys during a computation. More specifically, there are systems that provide the entities with storecarry-forward-like mechanisms (e.g., local buffering); thus an entity wanting to communicate with a specific\nother entity at time t0, can wait until the opportunity of communication presents itself. There are however environments where such a provision is not available (e.g., there are no buffering facilities), and thus waiting is not allowed. In time-varying graphs, this distinction is the one between a direct journey where \u2200i, ti+1 = ti + \u03b6i, and an indirect journey where \u2203i, ti+1 > ti + \u03b6i.\nWith regards to problem solving, any restriction, imposed by the nature of the system on the protocol designer, has clearly an impact on the computability and complexity of problems. In dynamic networks, computing (already a difficult task) is intuitively more difficult in environments that do not allow waiting than in those where waiting is possible; that is, environments where the only feasible journeys are the direct ones are clearly more challenging (for the problem solver) than those where journeys can be indirect.\nIn the common view of the environment as the adversary that the problem solver has to face, an environment that forbids waiting is clearly a more difficult (i.e. stronger) adversary than the one that allows waiting. The natural and immediate question is \u201chow much stronger is the adversary if waiting is not allowed?\u201d which can be re-expressed as: \u201cif waiting is allowed, how much easier is to solve problems?\u201d, or simply \u201cwhat is the computational power of waiting?\u201d\nA first difficulty in addressing these important questions is that most of the terms are qualitative, and currently there are no measures that allow to quantify even the main concepts e.g. \u201ccomplexity\u201d of the environment, \u201cstrength\u201d of the adversary, \u201cdifficulty\u201d of solving problems, etc.\nIn this paper, motivated by these qualitative questions, we examine the complexity of the environment (modeled as a time-varying graph) in terms of its expressivity, and establish results showing the (surprisingly dramatic) difference that the possibility of waiting creates."}, {"heading": "1.3 Contributions", "text": "Given a dynamic network modeled as a time-varying graph G, a journey in G can be viewed as a word on the alphabet of the edge labels; in this light, the class of feasible journeys defines the language Lf (G) expressed by G, where f \u2208 {wait, nowait} indicates whether or not indirect journeys are considered feasible by the environment.\nWe focus on the sets of languages Lnowait = {Lnowait(G) : G \u2208 U} and Lwait = {Lwait(G) : G \u2208 U}, where U is the set of all time-varying graphs; that is, we look at the languages expressed when waiting is, or is not allowed. For each of these two sets, the complexity of recognizing any language in the set (that is, the computational power needed by the accepting automaton) defines the level of difficulty of the environment.\nWe first study the expressivity of time-varying graphs when waiting is not allowed, that is the only feasible journeys are direct ones. We prove that the set Lnowait contains all computable languages. That is, we show that, for any computable language L, there exists a time-varying graph G such that L = Lnowait(G).\nWe next examine the expressivity of time-varying graphs if indirect journey are allowed. We prove that Lwait is precisely the set of regular languages. The proof is algebraic and based on order techniques, relying on a theorem by Harju and Ilie [19] that enables to characterize regularity from the closure of the sets from a well quasi-order. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (i.e., the difficulty of the environment, the power of the adversary), drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State Machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting.\nTo better understand the power of waiting, we then turn our attention to bounded waiting; that is when indirect journeys are considered feasible if the pause between consecutive edges in the journeys have a bounded duration d > 0. In other words, at each step of the journey, waiting is allowed only for at most d time units. We examine the set Lwait[d] of the languages expressed by time-varying graphs when waiting is allowed up to d time units. We prove the negative result that for any fixed d \u2265 0, Lwait[d] = Lnowait, which implies that the complexity of the environment is not affected by allowing waiting for a limited amount of\ntime. As a result, the power of the adversary is decreased only if it has no control over the length of waiting, i.e., if the waiting is unpredictable."}, {"heading": "1.4 Related Work", "text": "The literature on dynamic networks and dynamic graphs could fill volumes. Here we briefly mention only some of the work most directly connected to the results of this paper. The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6]. The evolving graph views the dynamics of the system as a sequence of global snapshots (taken either in discrete steps or when events occur). The equivalent model of time-varying graph (TVG), formalized in [10] and used here, views the dynamics of the system from the local point of view of the entities: for any given entity, the local edges and neighborhood can be considered independently from the entire graph (e.g. how long it is available, with what properties, with what latency, etc.).\nBoth viewpoints have been extensively employed in the analysis of basic problems such as routing, broadcasting, gossiping and other forms of information spreading (e.g., [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.g., [4, 13]); and in the investigations of emerging properties in social networks (e.g., [23, 31]). A characterization of classes of TVGs with respect to properties typically assumed in the research can be found in [10]. The related investigations on dynamic networks include also the extensive work on population protocols (e.g., [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph). The impact of bounded waiting in dynamic networks has been investigated for exploration [21]."}, {"heading": "2 Definitions and Terminology", "text": "Time-varying graphs: A time-varying graph1 G is a quintuple G = (V,E,T , \u03c1, \u03b6), where V is a finite set of entities or nodes; E \u2286 V \u00d7 V \u00d7 \u03a3 is a finite set of relations between these entities (edges), possibly labeled by symbols in an alphabet \u03a3. The system is studied over a given time span T \u2286 T called lifetime, where T is the temporal domain (typically, N or R+ for discrete and continuous-time systems, respectively); \u03c1 : E \u00d7 T \u2192 {0, 1} is the presence function, which indicates whether a given edge is available at a given time; \u03b6 : E \u00d7 T \u2192 T, is the latency function, which indicates the time it takes to cross a given edge if starting at a given date (the latency of an edge could vary in time). Both presence and latency are arbitrary computable functions. The directed edge-labeled graph G = (V,E), called the footprint of G, may contain loops, and it may have more than one edge between the same nodes, but all with different labels.\nA path over time, or journey, is a sequence < (e1, t1), (e2, t2), ..., (ek , tk) > where < e1, e2, ..., ek > is a walk in the footprint G, \u03c1(ei, ti) = 1 (for 1 \u2264 i < k), and \u03b6(ei, ti) is such that ti+1 \u2265 ti + \u03b6(ei, ti) (for 1 \u2264 i < k). If \u2200i, ti+1 = ti + \u03b6(ei, ti) the journey is said to be direct, indirect otherwise. We denote by J \u2217(G) the set of all journeys in G.\nThe time-varying-graph (TVG) formalism can arguably describe a multitude of different scenarios, from transportation networks to communication networks, complex systems, or social networks [10]. Figure 1 shows two simple examples of TVGs, depicting respectively a transportation network (Figure 1(a)) and a communication network (Figure 1(b)). In the transportation network, an edge from node u to node v represents the possibility for some agent to move from u to v; typical edges in this scenario are available on a punctual basis, i.e., the presence function \u03c1 for these edges returns 1 only at particular date(s) when the\n1We use the notation for time-varying graphs introduced in [10]\ntrip can be started. The latency function \u03b6 may also vary from one edge to another, as well as for different availability dates of a same given edge (e.g. variable traffic on the road, depending on the departure time). In the communication network, the labels are not indicated; shown instead are the intervals of time when the presence function \u03c1 is 1. An example of direct journey in this graph is J1 = {(ab, 2), (bc, 2+\u03b6)}. Examples of indirect ones include J2 = {(ac, 2), (cd, 5)}, and J3 = {(ab, 2), (bc, 2 + \u03b6), (cd, 5)}.\nTVG-automata: Given a time-varying graph G = (V,E,T , \u03c1, \u03b6) whose edges are labeled over \u03a3, we define a TVG-automaton A(G) as the 5-tuple A(G) = (\u03a3, S, I, E , F ) where \u03a3 is the input alphabet; S = V is the set of states; I \u2286 S is the set of initial states; F \u2286 S is the set of accepting states; E \u2286 S\u00d7T \u00d7\u03a3\u00d7S\u00d7 T is the set of transitions such that (s, t, a, s\u2032, t\u2032) \u2208 E iff \u2203e = (s, s\u2032, a) \u2208 E : \u03c1(e, t) = 1, \u03b6(e, t) = t\u2032 \u2212 t. In the following we shall denote (s, t, a, s\u2032, t\u2032) \u2208 E also by s, t a \u2192 s\u2032, t\u2032. A TVG-automaton A(G) is deterministic if for any time t \u2208 T , any state s \u2208 S, any symbol a \u2208 \u03a3, there is at most one transition of the form (s, t a \u2192 s\u2032, t\u2032); it is non-deterministic otherwise.\nGiven a TVG-automaton A(G), a journey in A(G) is a finite sequence of transitions J = (s0, t0 a0\u2192\ns1, t1), (s1, t \u2032 1 a1\u2192 s2, t2) . . . (sp\u22121, t \u2032 p\u22121 ap\u22121 \u2192 sp, tp) such that the sequence<(e0, t0), (e1, t\u20321), ..., (ep\u22121, t \u2032 p\u22121)> is a journey in G and tp = t\u2032p\u22121 + \u03b6(ep\u22121, t \u2032 p\u22121), where ei = (si, si+1, ai) (for 0 \u2264 i < p). Consistently with the above definitions, we say that J is direct if \u2200i, t\u2032i = ti (there is no pause between transitions), and indirect otherwise (i.e., \u2203i : t\u2032i > ti). We denote by \u03bb(J ) the associated word a0, a1, ...ap\u22121 and by start(J ) and arrival(J ) the dates t0 and tp, respectively. To complete the definition, an empty journey J\u2205 consists of a single state, involves no transitions, its associated word is the empty word \u03bb(J\u2205) = \u03b5, and its arrival date is the starting date.\nA journey is said accepting iff it starts in an initial state s0 \u2208 I and ends in a accepting state sp \u2208 F . A TVG-automaton A(G) accepts a word w \u2208 \u03a3\u2217 iff there exists an accepting journey J such that \u03bb(J ) = w.\nLetLnowait(G) denote the set of words (i.e., the language) accepted by TVG-automaton A(G) using only direct journeys, and let Lwait(G) be the language recognized if journeys are allowed to be indirect. Given the set U of all possible TVGs, let us denote Lnowait = {Lnowait(G) : G \u2208 U} and Lwait = {Lwait(G) : G \u2208 U} the sets of all languages being possibly accepted by a TVG-automaton if journeys are constrained to be direct (i.e., no waiting is allowed) and if they are unconstrained (i.e., waiting is allowed), respectively.\nIn the following, when no ambiguity arises, we will use interchangeably the terms node and state, and the terms edge and transition; the term journey will be used both in reference to the sequence of edges in the TVG and to the corresponding sequence of transitions in the associated TVG-automaton.\nThe closest concept to TVG-automata are Timed automata proposed by [1] to model real-time systems. A timed automaton has real valued clocks and the transitions are guarded with simple comparisons on the clock values; with only one clock and no reset it is a TVG-automaton with 0 latency.\nExample of TVG-automaton: Figure 2 shows an example of a deterministic TVG-automaton that recognizes the context-free language anbn for n \u2265 1 (using only direct journeys). Consider the graph G1 = (V,E,T , \u03c1, \u03b6), composed of three nodes: V = {v0, v1, v2}, and five edges: E = {(v0, v0, a), (v0, v1, b),\n(v1, v1, b), (v1, v2, b), (v0, v2, b))}. The presence and latency functions are as shown in Table 1, where p and q are two distinct prime numbers greater than 1. Consider now the corresponding automaton A(G1) where v0 is the initial state and v2 is the accepting state. For clarity, let us assume that A(G1) starts at time 1 (the same behavior could be obtained by modifying slightly the formulas involving t in Table 1). It is clear that the an portion of the word anbn is read entirely at v0 within t = pn time. If n = 1, at this time the only available edge is e3 (labeled b) which allows to correctly accept ab. Otherwise (n > 1) at time t = pn, the only available edge is e1 which allows to start reading the bn portion of the word. By construction of \u03c1 and \u03b6 , edge e2 is always present except for the very last b, which has to be read at time t = pnqn\u22121. At that time, only e4 is present and the word is correctly recognized. It is easy to verify that only these words are recognized, and the automaton is deterministic. The reader may have noticed the basic principle employed here (and later in the paper) of using latencies as a means to encode words into time, and presences as a means to select through opening the appropriate edges at the appropriate time."}, {"heading": "3 No waiting allowed", "text": "This section focuses on the expressivity of time-varying graphs when only direct journeys are allowed. We prove that Lnowait includes all computable languages.\nLet L be an arbitrary computable language defined over a finite alphabet \u03a3. Let \u03b5 denote the empty word; note that L might or might not contain \u03b5. The notation \u03b1.\u03b2 indicates the concatenation of \u03b1 \u2208 \u03a3\u2217 with \u03b2 \u2208 \u03a3\u2217. Let q = |\u03a3| be the size of the alphabet, and w.l.o.g assume that \u03a3 = {0, . . . , q\u2212 1}. We define an injective encoding \u03d5 : \u03a3\u2217\u2192N associating to each word w = a0.a1 . . . ak \u2208 \u03a3\u2217 the sum qk+1 + \u2211k j=0 ajq k\u2212j . It is exactly the integer corresponding to 1.w interpreted in base q. By convention, \u03d5(\u03b5) = 0. Consider now the TVG G2 where V = {v0, v1, v2}, E = {{(v0, v1, i), i \u2208 \u03a3} \u222a {{(v0, v2, i), i \u2208 \u03a3},\u222a{(v1, v1, i), i \u2208 \u03a3} \u222a {(v1, v2, i), i \u2208 \u03a3} \u222a {(v2, v1, i), i \u2208 \u03a3} \u222a {(v2, v2, i), i \u2208 \u03a3}}. The presence\nand latency functions are defined relative to which node is the end-point of an edge. For all u \u2208 {v0, v1, v2}, i \u2208 \u03a3, and t \u2265 0, we define\n\u2022 \u03c1((u, v1, i), t) = 1 iff t \u2208 \u03d5(\u03a3\u2217) and \u03d5\u22121(t).i \u2208 L,\n\u2022 \u03b6((u, v1, i), t) = \u03d5(\u03d5 \u22121(t).i) \u2212 t\n\u2022 \u03c1((u, v2, i), t) = 1 iff t \u2208 \u03d5(\u03a3\u2217) and \u03d5\u22121(t).i /\u2208 L,\n\u2022 \u03b6((u, v2, i), t) = \u03d5(\u03d5 \u22121(t).i) \u2212 t\nConsider the corresponding TVG-automaton A(G2) where v0 is the initial state, and v1 is the unique accepting state if the \u03b5 /\u2208 L (see Figure 3), while both v0 and v1 are accepting states if \u03b5 \u2208 L.\nTheorem 3.1. Lnowait(G2) = L.\nProof. We want to show there is a unique accepting journey J with \u03bb(J ) = w iff w \u2208 L. We first show that for all words w \u2208 \u03a3\u2217, there is exactly one direct journey J in A(G2) such that \u03bb(J ) = w, and in this case arrival(J ) = \u03d5(w). This is proven by induction on k \u2208 N, the length of the words. It clearly holds for k = 0 since the only word of that length is \u03b5 and \u03d5(\u03b5) = 0. Let k \u2208 N. Suppose now that for all w \u2208 \u03a3\u2217, |w| = k we have exactly one associated direct journey, and arrival(J ) = \u03d5(w). Consider w1 \u2208 \u03a3\u2217 with |w1| = k + 1. Without loss of generality, let w1 = w.i where w \u2208 \u03a3\u2217 and i \u2208 \u03a3. By induction there is exactly one direct journey J with \u03bb(J ) = w. Let u = arrival(J ) be the node of arrival and t the arrival time. By induction, t \u2208 \u03d5(\u03a3\u2217); furthermore since the presence function depends only on the node of arrival and not on the node of origin, there exists exactly one transition, labeled i from u. So there exists only one direct journey labeled by w1. By definition of the latency function, its arrival time is \u03d5(\u03d5\u22121(t).i) = \u03d5(w.i) = \u03d5(w1). This ends the induction. We now show that such a unique journey is accepting iff w \u2208 L. In fact, by construction of the presence function, every journey that corresponds to w \u2208 L,w 6= \u03b5, ends in v1, which is an accepting state. The empty journey corresponding to \u03b5 ends in v0 which, by definition, is accepting iff \u03b5 \u2208 L."}, {"heading": "4 Waiting allowed", "text": "We now turn the attention to the case of time-varying graphs where indirect journeys are possible, that is entities have the choice to wait for future opportunities of interaction rather than seizing only those that are directly available. In striking contrast with the non-waiting case, we show that the languages Lwait recognized by TVG-automata consists only of regular languages. Let R denote the set of regular languages. We show that\nTheorem 4.1. Lwait = R.\nProof. (of inclusion for regular languages) This first inclusion follows easily from observing that any finitestate machine (FSM) is a particular TVG-automaton whose edges are always present and have a nil latency. The fact that we allow waiting here does not modify the behavior of the automata as long as we consider deterministic FSMs only (which is sufficient), since at most one choice exists at each state for each symbol read. Thus, for any regular language L, there exists a corresponding TVG G such that Lwait(G) = L.\nThe reverse inclusion is more involved. Consider G = (V,E,T , \u03c1, \u03b6) with labels in \u03a3, we have to show that Lwait(G) \u2208 R.\nThe proof is algebraic, and based on order techniques, relying on a theorem of Harju and Ilie (Theorem 4.16 in [19]) that enables to characterize regularity from the closure of the sets from a well quasi-order. We will use here an inclusion order on journeys (to be defined formally below). Informally, a journey J is included in another journey J \u2032 if its sequence of transition is included (in the same order) in the sequence of transitions of J \u2032. It should be noted that sets of indirect journeys from one node to another are obviously closed under this inclusion order (on the journey J it is possible to wait on a node as if the missing transitions from J \u2032 were taking place), which is not the case for direct journeys as it is not possible to wait. In order to apply the theorem, we have to show that this inclusion order is a well quasi-order, i.e. that it is not possible to find an infinite set of journeys such that none of them could be included in another from the same set.\nLet us first introduce some definitions and results about quasi-orders. We denote by \u2264 a quasi-order over a given set Q. A set X \u2282 Q is an antichain if all elements of X are pairwise incomparable. The quasi-order \u2264 is well founded if in Q, there is no infinite descending sequence x1 \u2265 x2 \u2265 x3 \u2265 . . . (where \u2265 is the inverse of \u2264) such that for no i, xi \u2264 xi+1. If \u2264 is well founded and all antichains are finite then \u2264 is a well quasi-order on Q. When Q = \u03a3\u2217 for alphabet \u03a3, a quasi-order is monotone if for all x, y, w1, w2 \u2208 \u03a3\u2217, we have x \u2264 y \u21d2 w1xw2 \u2264 w1yw2.\nA word x \u2208 \u03a3\u2217 is a subword of y \u2208 \u03a3\u2217 if x can be obtained by deleting some letters on y. This defines a relation that is obviously transitive and we denote \u2286 the subword order on \u03a3\u2217. We can extend the \u2286 order to labeled walks as follows: given two walks \u03b3, \u03b3\u2032 on the footprint G of G, we note \u03b3 \u2286 \u03b3\u2032 if \u03b3 and \u03b3\u2032 begin on the same node and end on the same node, and \u03b3 is a subwalk of \u03b3\u2032.\nGiven a date t \u2208 T and a word x in \u03a3\u2217, we denote by J \u2217t, x the set {J \u2208 J \u2217(G) : start(J ) = t, \u03bb(J ) = x}. J \u22170, x is simply denoted J \u2217x. Given two nodes u and v, we allow the notation u x\nt v if\nthere exists a journey from u to v in J \u2217t, x. Given a journey J , J is the corresponding labeled walk (in the footprint G). We will denote by \u0393(x) the set {J : \u03bb(J ) = x}.\nLet x and y be two words in \u03a3\u2217. We define the quasi-order \u227a, as follows: x \u227a y if\n\u2200J \u2208 J \u2217y,\u2203\u03b3 \u2208 \u0393(x), \u03b3 \u2286 J .\nThe relation \u227a is obviously reflexive. We now establish the link between comparable words and their associated journeys and walks, and state some useful properties of relation \u227a.\nLemma 4.2. Let x, y \u2208 \u03a3\u2217 be such that x \u227a y. Then for any Jy \u2208 J \u2217y, there exists Jx \u2208 J \u2217x such that Jx \u2286 Jy, start(Jx) = start(Jy), arrival(Jx) = arrival(Jy).\nProof. By definition, there exists a labeled path \u03b3 \u2208 \u0393(x) such that \u03b3 \u2286 Jy. It is then possible to find a journey Jx \u2208 J \u2217x with Jx = \u03b3 and arrival(Jx) = arrival(Jy) by using for every edge of Jx the schedule of the same edge in Jy.\nProposition 4.3. The relation \u227a is transitive.\nProof. Suppose we have x \u227a y and y \u227a z. Consider J \u2208 J \u2217z. By Lemma 4.2, we get a journey Jy \u2208 J \u2217y, such that Jy \u2286 J . By definition, there exists \u03b3 \u2208 \u0393(x) such that \u03b3 \u2286 Jy. Therefore \u03b3 \u2286 J , and finally x \u227a z.\nThe main proposition to be proved now is the following\nProposition 4.4. (\u03a3\u2217,\u227a) is a well quasi-order.\nIndeed, consider the two following results.\nDefinition 4.5. Let L \u2282 \u03a3\u2217. For any quasi-order \u2264, we denote DOWN\u2264(L) = {x | \u2203y \u2208 L, x \u2264 y}.\nThis is a corollary of Lemma 4.2\nCorollary 4.6. Consider the language L of words induced by labels of journeys from u to v starting at time t. Then DOWN\u227a(L)L.\nThe following theorem is due to Harju and Ilie:\nTheorem 4.7 ([19]). For any monotone well quasi order \u2264 of \u03a3\u2217, for any L \u2282 \u03a3\u2217, the language DOWN\u2264(L) is regular.\nFrom Proposition 4.4, Corollary 4.6, and Theorem 4.7, the claim of Theorem 4.1 will immediately follow. The remaining of this section is devoted to the proof that \u227a is a well quasi-order. We have first to prove the following.\nProposition 4.8. The quasi-order \u227a is monotone.\nProof. Let x, y be such that x \u227a y. Let z \u2208 \u03a3\u2217. Let J \u2208 J \u2217yz. Then there exists Jy \u2208 J \u2217y and Jz \u2208 J\n\u2217start(Jy), z such that the end node of Jy is the start node of Jz . By Lemma 4.2, there exists Jx that ends in the same node as Jy and with the same arrival time. We can consider J \u2032 the concatenation of Jx and Jz. By construction J \u2032 \u2208 \u0393(xz), and J \u2032 \u2286 J . Therefore xz \u227a yz. The property zx \u227a zy is proved similarly using the start property of Lemma 4.2.\nProposition 4.9. The quasi-order \u227a is well funded.\nProof. Consider a descending chain x1 \u227b x2 \u227b x3 \u227b . . . such that for no i xi \u227a xi+1. We show that this chain is finite. Suppose the contrary. By definition of \u227a, we can find \u03b31, \u03b32, . . . such that for all i, \u03b3i \u2208 J \u2217xi, and such that \u03b3i+1 \u2286 \u03b3i. This chain of walks is necessarily stationary and there exits i0 such that \u03b3i0 = \u03b3i0+1. Therefore, xi0 = xi0+1, a contradiction.\nTo prove that \u227a is a well quasi-order, we now have to prove that all antichains are finite. Let (Q,\u2264) be a quasi-order. For all A,B \u2282 Q, we denote A\u2264PB if there exists an injective mapping \u03d5 : A \u2212\u2192 B, such that for all a \u2208 A, a \u2264 \u03d5(a). The relation \u2264P is transitive and defines a quasi-order on P(Q).\nAbout the finiteness of antichains, we recall the following result\nLemma 4.10 ([20]). Let (Q,\u2264) be a well quasi-order. Then (P(Q),\u2264P ) is a well quasi-order.\nand the fundamental result of Higman:\nTheorem 4.11 ([20]). Let \u03a3 be a finite alphabet. Then (\u03a3\u2217,\u2286) is a well quasi-order.\nThis implies that our set of journey-induced walks is also a well quasi-order for \u2286 as it can be seen as a special instance of Higman\u2019s Theorem about the subword order.\nWe are now ready to prove that all antichains are finite.\nTheorem 4.12. Let L \u2282 \u03a3\u2217 be an antichain for \u227a. Then L is finite.\nWe prove this theorem by using a technique similar to the variation by [29] of the proof of [20]. First, we need the following property:\nLemma 4.13. Let X be an antichain of \u03a3\u2217. If \u227a is a well quasi-order on DOWN\u227a(X)\\X then X is finite.\nProof. We denote Q = DOWN\u227a(X)\\X, and suppose Q is a well quasi-order for \u227a. Therefore the product and the associated product order (\u03a3 \u00d7 Q,\u227a\u00d7) define also a well quasi-order. We consider A = {(a, x) | a \u2208 \u03a3x \u2208 Qax \u2208 X}. Because \u227a is monotone, for all (a, x), (a\u2032, x\u2032) \u2208 A, (a, x) \u227a\u00d7 (b, y) \u21d2 ax \u227a by. Indeed, in this case a = b and x \u227a y \u21d2 ax \u227a ay. So A has to be an antichain of the well quasi-order \u03a3\u00d7Q. Therefore A is finite. By construction, this implies that X is also finite.\nProof. We can now end the proof of Theorem 4.12. Suppose we have an infinite antichain X0. By applying recursively the previous lemma, there exists for all i \u2208 N, Xi+1 \u2282 DOWN\u227a(Xi)\\Xi that is also an infinite antichain of \u03a3\u2217. By definition of DOWN\u227a, for all x \u2208 Xi+1, there exists y \u2208 Xi such that x \u227a y, ie x \u2286 y. It is also possible to choose the elements x such that no pair is sharing a common y. So Xi+1 \u2286P Xi, and we have a infinite descending chain of (P(\u03a3\u2217),\u2286P). This would contradict Lemma 4.10.\nFrom Propositions 4.3, 4.8, 4.9 and Theorem 4.12 it follows that (\u03a3\u2217,\u227a) is a well quasi-order, completing the proof of Proposition 4.4; thus, Lwait(G) is a regular language for any TVG G, concluding the proof of Theorem 4.1. That is Lwait = R.\nRemark 4.14. The reader should note that \u227a does not correspond to \u2286P if we were to identify a word x with the subset of corresponding walks. Indeed, if W denotes the set of walks, then for A,B \u2208 P(W ), A \u2282 B \u21d2 A \u2286P B, however if A = \u0393(x), B = \u0393(y), then A \u2282 B \u21d2 y \u227a x. Therefore the above theorem cannot be derived by a simple application of the results of Higman."}, {"heading": "5 Bounded waiting allowed", "text": "To better understand the power of waiting, we now turn our attention to bounded waiting; that is when indirect journeys are considered feasible if the pause between consecutive edges has a bounded duration d > 0. We examine the set Lwait[d] of all languages expressed by time-varying graphs when waiting is allowed up to d time units, and prove the negative result that for any fixed d \u2265 0, Lwait[d] = Lnowait. That is, the complexity of the environment is not affected by allowing waiting for a limited amount of time.\nThe basic idea is to reuse the same technique as in Section 3, but with a dilatation of time, i.e., given the bound d, the edge schedule is time-expanded by a factor d (and thus no new choice of transition is created compared to the no-waiting case).\nTheorem 5.1. For any duration d, Lwait[d] = Lwait[0] (i.e., Lnowait)\nProof. Let L be an arbitrary computable language defined over a finite alphabet \u03a3. Let d \u2208 N be the maximal waiting duration. We consider a TVG G2,d structurally equivalent to G2 (see Figure 3 in Section 3), i.e.,, G2,d = (V,E,T , \u03c1, \u03b6) such that V = {v0, v1, v2}, E = {{(v0, v1, i), i \u2208 \u03a3} \u222a {{(v0, v2, i), i \u2208 \u03a3},\u222a{(v1, v1, i), i \u2208 \u03a3}\u222a {(v1, v2, i), i \u2208 \u03a3}\u222a {(v2, v1, i), i \u2208 \u03a3}\u222a {(v2, v2, i), i \u2208 \u03a3}}. The initial state is v0, and the accepting state is v1. If \u03b5 \u2208 L then v0 is also accepting.\nBased on the mapping \u03d5 defined for G2 in Section 3, we define another mapping \u03d5d that associates to any word w the value (d + 1)\u03d5(w). We also define \u03c8d(t) to be equal to \u03d5\u22121(\u230a t d+1\u230b) when it is defined. For instance, \u03d55(0110) in base 2 gives (101 + 1) \u00d7 10110 (i.e., 132 in base 10). Reversely, we have \u03c85(132) = ... = \u03c85(137) = 0110, and \u03c85(138) = ... = \u03c85(143) = 0111.\nThe presence and latency functions are now defined along the lines as those of G2, the only difference being that we are using \u03d5d (resp. \u03c8d) instead of \u03d5 (resp. \u03d5\u22121). Thus, for all u \u2208 {v0, v1, v2}, i \u2208 \u03a3, and t \u2265 0, we define\n\u2022 \u03c1((u, v1, i), t) = 1 iff \u230a td+1\u230b \u2208 \u03d5d(\u03a3 \u2217) and \u03c8d(t).i \u2208 L,\n\u2022 \u03b6((u, v1, i), t) = \u03d5d(\u03c8d(t).i) \u2212 t\n\u2022 \u03c1((u, v2, i), t) = 1 iff \u230a td+1\u230b \u2208 \u03d5d(\u03a3 \u2217) and \u03c8d(t).i /\u2208 L,\n\u2022 \u03b6((u, v2, i), t) = \u03d5d(\u03c8 \u22121 d (t).i) \u2212 t\nBy the same induction technique as in Section 3, we have that L \u2286 L(G2,d). Similarly, we have that any journey labeled by w ends at time exactly \u03d5d(w), even if some d\u2212waiting occurred.\nFinally, we remark that for all words w,w\u2032 \u2208 \u03a3+ such that w 6= w\u2032, we have |\u03d5d(w) \u2212 \u03d5d(w\u2032)| > d. Indeed, if w 6= w\u2032 then they differ by at least one letter. The minimal time difference is when this is the last letter and these last letters are i, i + 1 w.l.o.g. In this case, |\u03d5d(w) \u2212 \u03d5d(w\u2032)| \u2265 d + 1 by definition of \u03d5d. Therefore waiting for a duration of d does not enable more transitions in terms of labeling."}], "references": [{"title": "A theory of timed automata", "author": ["R. Alur", "D.L. Dill"], "venue": "Theoretical Comp. Sci.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1994}, {"title": "The computational power of population protocols", "author": ["D. Angluin", "J. Aspnes", "D. Eisenstat", "E. Ruppert"], "venue": "Distributed Computing,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "How to explore a fast-changing world", "author": ["C. Avin", "M. Koucky", "Z. Lotker"], "venue": "In Proc. 35th International Colloquium on Automata, Languages and Programming (ICALP),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Parsimonious flooding in dynamic graphs", "author": ["H. Baumann", "P. Crescenzi", "P. Fraigniaud"], "venue": "In Proceedings 28th ACM Symposium on Principles of Distributed Computing (PODC),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Complexity of connected components in evolving graphs and the computation of multicast trees in dynamic networks", "author": ["S. Bhadra", "A. Ferreira"], "venue": "In Proc. 2nd Intl. Conference on Ad Hoc Networks and Wireless (ADHOC- NOW),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Computing shortest, fastest, and foremost journeys in dynamic networks", "author": ["B. Bui-Xuan", "A. Ferreira", "A. Jarry"], "venue": "Intl. J. of Foundations of Comp. Science,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Characterizing topological assumptions of distributed algorithms in dynamic networks", "author": ["A. Casteigts", "S. Chaumette", "A. Ferreira"], "venue": "In Proc. 16th Intl. Colloquium on Structural Information and Communication Complexity (SIROCCO),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Deterministic computations in time-varying graphs: Broadcasting under unstructured mobility", "author": ["A. Casteigts", "P. Flocchini", "B. Mans", "N. Santoro"], "venue": "In Proc. 5th IFIP Conference on Theoretical Computer Science (TCS),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Measuring temporal lags in delay-tolerant networks", "author": ["A. Casteigts", "P. Flocchini", "B. Mans", "N. Santoro"], "venue": "In Proc. 25th IEEE Intl. Parallel and Distr. Processing Symp. (IPDPS),", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Time-varying graphs and dynamic networks", "author": ["A. Casteigts", "P. Flocchini", "W. Quattrociocchi", "N. Santoro"], "venue": "In Proc. 10th Int. Conf. on Ad Hoc Networks and Wireless (ADHOC-NOW),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Mediated population protocols", "author": ["I. Chatzigiannakis", "O. Michail", "P. Spirakis"], "venue": "Proc. 36th Int. Colloquium on Automata, Languages and Programming,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2009}, {"title": "Rumor spreading in social networks", "author": ["F. Chierichetti", "S. Lattanzi", "A. Panconesi"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Flooding time in edge-markovian dynamic graphs", "author": ["A. Clementi", "C. Macci", "A. Monti", "F. Pasquale", "R. Silvestri"], "venue": "In Proc. 27th ACM Symp. on Principles of Distributed Computing (PODC),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Information spreading in stationary markovian evolving graphs", "author": ["A. Clementi", "A. Monti", "F. Pasquale", "R. Silvestri"], "venue": "In Proc. of the 23rd IEEE International Parallel and Distributed Processing Symposium (IPDPS),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Prioritized gossip in vehicular networks", "author": ["A. Cornejo", "C. Newport"], "venue": "In Proc. of the 6th International Workshop on Foundations of Mobile Computing (DIALM-POMC),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "Building a reference combinatorial model for MANETs", "author": ["A. Ferreira"], "venue": "IEEE Network,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2004}, {"title": "Exploration of periodically varying graphs", "author": ["P. Flocchini", "B. Mans", "N. Santoro"], "venue": "In Proc. 20th Intl. Symposium on Algorithms and Computation (ISAAC),", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "What model and what conditions to implement unreliable failure detectors in dynamic networks", "author": ["F. Greve", "L. Arantes", "P. Sens"], "venue": "In Proceedings of the 3rd International Workshop on Theoretical Aspects of Dynamic Distributed Systems,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "On quasi orders of words and the confluence property", "author": ["T. Harju", "L. Ilie"], "venue": "Theoretical Computer Science,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1998}, {"title": "Ordering by divisibility in abstract algebras", "author": ["G. Higman"], "venue": "Proceedings of the London Mathematical Society,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1952}, {"title": "On the power of waiting when exploring public transportation systems", "author": ["D. Ilcinkas", "A. Wade"], "venue": "Principles of Distributed Systems (OPODIS),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2011}, {"title": "Practical routing in delay-tolerant networks", "author": ["E.P.C. Jones", "L. Li", "J.K. Schmidtke", "P.A.S. Ward"], "venue": "IEEE Transactions on Mobile Computing,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2007}, {"title": "Protocols and impossibility results for gossip-based communication mechanisms", "author": ["D. Kempe", "J. Kleinberg"], "venue": "In Proc. 43rd Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}, {"title": "The structure of information pathways in a social communication network", "author": ["G. Kossinets", "J. Kleinberg", "D. Watts"], "venue": "In Proc. 14th Intl. Conf. on Knowledge Discovery and Data Mining (KDD),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2008}, {"title": "Distributed computation in dynamic networks", "author": ["F. Kuhn", "N. Lynch", "R. Oshman"], "venue": "In Proceedings of the 42nd ACM Symposium on Theory of computing (STOC),", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2010}, {"title": "Coordinated consensus in dynamic networks", "author": ["F. Kuhn", "Y. Moses", "R. Oshman"], "venue": "In Proc. of the 30th ACM Symposium on Principles of Distributed Computing (PODC),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2011}, {"title": "Efficient adaptive routing in delay tolerant networks", "author": ["C. Liu", "J. Wu"], "venue": "In Proc. of IEEE International Conference on Communications (ICC\u201909),", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "Scalable routing in cyclic mobile networks", "author": ["C. Liu", "J. Wu"], "venue": "IEEE Trans. Parallel Distrib. Syst.,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "On well-quasi-ordering finite trees", "author": ["C. St. J.A. Nash-Williams"], "venue": "Mathematical Proceedings of the Cambridge Philosophical Society,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1963}, {"title": "Information dissemination in highly dynamic graphs", "author": ["R. O\u2019Dell", "R. Wattenhofer"], "venue": "In Proc. Joint Workshop on Foundations of Mobile Computing (FOMC),", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2005}, {"title": "Small-world behavior in time-varying graphs", "author": ["J. Tang", "S. Scellato", "M. Musolesi", "C. Mascolo", "V. Latora"], "venue": "Phys. Rev. E,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "Study of a bus-based disruption-tolerant network: mobility modeling and impact on routing", "author": ["X. Zhang", "J. Kurose", "B.N. Levine", "D. Towsley", "H. Zhang"], "venue": "In Proc. 13th ACM Int. Conference on Mobile Computing and Networking,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2007}, {"title": "Routing in intermittently connected mobile ad hoc networks and delay tolerant networks: Overview and challenges", "author": ["Z. Zhang"], "venue": "IEEE Communications Surveys & Tutorials,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2006}], "referenceMentions": [{"referenceID": 21, "context": "[22, 27, 33]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 26, "context": "[22, 27, 33]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 32, "context": "[22, 27, 33]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 27, "context": ", see [28, 32]).", "startOffset": 6, "endOffset": 14}, {"referenceID": 31, "context": ", see [28, 32]).", "startOffset": 6, "endOffset": 14}, {"referenceID": 11, "context": "[12, 24]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 23, "context": "[12, 24]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 3, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 6, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 9, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 13, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 15, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 16, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 17, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 20, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 24, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 25, "context": ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).", "startOffset": 6, "endOffset": 44}, {"referenceID": 18, "context": "The proof is algebraic and based on order techniques, relying on a theorem by Harju and Ilie [19] that enables to characterize regularity from the closure of the sets from a well quasi-order.", "startOffset": 93, "endOffset": 97}, {"referenceID": 15, "context": "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].", "startOffset": 115, "endOffset": 119}, {"referenceID": 4, "context": "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].", "startOffset": 206, "endOffset": 212}, {"referenceID": 5, "context": "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].", "startOffset": 206, "endOffset": 212}, {"referenceID": 9, "context": "The equivalent model of time-varying graph (TVG), formalized in [10] and used here, views the dynamics of the system from the local point of view of the entities: for any given entity, the local edges and neighborhood can be considered independently from the entire graph (e.", "startOffset": 64, "endOffset": 68}, {"referenceID": 2, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 2, "endOffset": 19}, {"referenceID": 7, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 2, "endOffset": 19}, {"referenceID": 8, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 2, "endOffset": 19}, {"referenceID": 14, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 2, "endOffset": 19}, {"referenceID": 29, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 2, "endOffset": 19}, {"referenceID": 16, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 98, "endOffset": 106}, {"referenceID": 20, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 98, "endOffset": 106}, {"referenceID": 17, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 137, "endOffset": 141}, {"referenceID": 24, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 156, "endOffset": 164}, {"referenceID": 25, "context": ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.", "startOffset": 156, "endOffset": 164}, {"referenceID": 3, "context": ", [4, 13]); and in the investigations of emerging properties in social networks (e.", "startOffset": 2, "endOffset": 9}, {"referenceID": 12, "context": ", [4, 13]); and in the investigations of emerging properties in social networks (e.", "startOffset": 2, "endOffset": 9}, {"referenceID": 22, "context": ", [23, 31]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 30, "context": ", [23, 31]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 9, "context": "A characterization of classes of TVGs with respect to properties typically assumed in the research can be found in [10].", "startOffset": 115, "endOffset": 119}, {"referenceID": 1, "context": ", [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph).", "startOffset": 2, "endOffset": 9}, {"referenceID": 10, "context": ", [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph).", "startOffset": 2, "endOffset": 9}, {"referenceID": 20, "context": "The impact of bounded waiting in dynamic networks has been investigated for exploration [21].", "startOffset": 88, "endOffset": 92}, {"referenceID": 9, "context": "The time-varying-graph (TVG) formalism can arguably describe a multitude of different scenarios, from transportation networks to communication networks, complex systems, or social networks [10].", "startOffset": 189, "endOffset": 193}, {"referenceID": 9, "context": "We use the notation for time-varying graphs introduced in [10]", "startOffset": 58, "endOffset": 62}, {"referenceID": 0, "context": "The closest concept to TVG-automata are Timed automata proposed by [1] to model real-time systems.", "startOffset": 67, "endOffset": 70}, {"referenceID": 18, "context": "16 in [19]) that enables to characterize regularity from the closure of the sets from a well quasi-order.", "startOffset": 6, "endOffset": 10}, {"referenceID": 18, "context": "7 ([19]).", "startOffset": 3, "endOffset": 7}, {"referenceID": 19, "context": "10 ([20]).", "startOffset": 4, "endOffset": 8}, {"referenceID": 19, "context": "11 ([20]).", "startOffset": 4, "endOffset": 8}, {"referenceID": 28, "context": "We prove this theorem by using a technique similar to the variation by [29] of the proof of [20].", "startOffset": 71, "endOffset": 75}, {"referenceID": 19, "context": "We prove this theorem by using a technique similar to the variation by [29] of the proof of [20].", "startOffset": 92, "endOffset": 96}], "year": 2014, "abstractText": "In infrastructure-less highly dynamic networks, computing and performing even basic tasks (such as routing and broadcasting) is a very challenging activity due to the fact that connectivity does not necessarily hold, and the network may actually be disconnected at every time instant. Clearly the task of designing protocols for these networks is less difficult if the environment allows waiting (i.e., it provides the nodes with store-carry-forward-like mechanisms such as local buffering) than if waiting is not feasible. No quantitative corroborations of this fact exist (e.g., no answer to the question: how much easier?). In this paper, we consider these qualitative questions about dynamic networks, modeled as time-varying (or evolving) graphs, where edges exist only at some times. We examine the difficulty of the environment in terms of the expressivity of the corresponding time-varying graph; that is in terms of the language generated by the feasible journeys in the graph. We prove that the set of languages Lnowait when no waiting is allowed contains all computable languages. On the other end, using algebraic properties of quasi-orders, we prove that Lwait is just the family of regular languages. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (difficulty of the environment) drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting. We also study bounded waiting; that is when waiting is allowed at a node only for at most d time units. We prove the negative result that Lwait[d] = Lnowait; that is, the expressivity decreases only if the waiting is finite but unpredictable (i.e., under the control of the protocol designer and not of the environment).", "creator": "LaTeX with hyperref package"}}}