{"id": "1205.2621", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-May-2012", "title": "Logical Inference Algorithms and Matrix Representations for Probabilistic Conditional Independence", "abstract": "logical inference algorithms integrating conditional independence ( ci ) statements offer commercial applications under turing consistency during knowledge elicitation to visual structure learning of graphical models. we prove that the implication problem for ci statements is decidable, given that the size of the domains of the random variables is known and fixed. we will present an approximate logical inference algorithm which combines simultaneous falsification and a novel validation algorithm. the validation algorithm represents each set of ci statements as a sparse 0 - 1 value a and validates members of the implication problem by combining specific linear programs with discrete matrix a. we will show experimentally that method algorithm is both effective and efficient as calculating and falsifying instances of the probabilistic ci implication problem.", "histories": [["v1", "Wed, 9 May 2012 17:28:17 GMT  (198kb)", "http://arxiv.org/abs/1205.2621v1", "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["mathias niepert"], "accepted": false, "id": "1205.2621"}, "pdf": {"name": "1205.2621.pdf", "metadata": {"source": "CRF", "title": "Logical Inference Algorithms and Matrix Representations for Probabilistic Conditional Independence", "authors": ["Mathias Niepert"], "emails": ["mniepert@indiana.edu"], "sections": [{"heading": null, "text": "Logical inference algorithms for conditional independence (CI) statements have important applications from testing consistency during knowledge elicitation to constraintbased structure learning of graphical models. We prove that the implication problem for CI statements is decidable, given that the size of the domains of the random variables is known and fixed. We will present an approximate logical inference algorithm which combines a falsification and a novel validation algorithm. The validation algorithm represents each set of CI statements as a sparse 0-1 matrixA and validates instances of the implication problem by solving specific linear programs with constraint matrix A. We will show experimentally that the algorithm is both effective and efficient in validating and falsifying instances of the probabilistic CI implication problem."}, {"heading": "1 Introduction", "text": "Knowledge elicitation is an important task in the field of reasoning under uncertainty [1]. For example, consider the problem of eliciting knowledge from several domain experts in an attempt to model a probabilistic system (e.g., a Bayesian or Markov network). The resulting incomplete expert feedback might be a combination of some specific subjective probabilities, (conditional) independence and dependence information for the random variables under consideration, and conditional probabilities. Furthermore, in some cases, statistical tests on different heterogeneous data sets could provide additional sources of evidence. Each of these bits of information can be interpreted as a constraint on the joint probability distribution one wants to model. Finding a suitable model can\nthen be interpreted as a constraint satisfaction problem (CSP), and the approach to harness CSP solvers for instances of this and related problems has been known for more than 10 years (Druzdzel and van der Gaag [2], Dechter [3]). However, (conditional) independence and dependence statements pose a special problem, because they often introduce non-linear constraints which mostly result in infeasible CSP instances. Therefore, a remaining important challenge in the context of knowledge elicitation is to test for consistency of the (conditional) independence and dependence information that has been collected from different sources. For this to be possible, one would need an algorithm that decides the implication problem for CI statements (Geiger and Pearl [4]), that is, an algorithm that can infer CI statements which are logically implied by a set of given ones, relative to the class of discrete probability measures. There are several other important applications of an inference algorithm for CI statements. For example, the representation of CI information is mostly based on the well-known semigraphoid axioms of independence. There are ways to improve on this representation by using the notion of o-dominant triplets (Studeny\u0301 [5]) and stable independence (de Waal and van der Gaag [6]), both of which need fast logical inference algorithms. Furthermore, inference algorithms for CI statements have been used to learn the structure of graphical models using only few independence tests (Gandhi et al. [7]).\nIn this paper, we will first prove that the implication problem for CI statements relative to the class of discrete (positive) probability measures is decidable, given that the cardinalities of the domains of all random variables are known and fixed. We achieve this by encoding instances of the implication problem as sentences in the first-order theory over the reals with addition and multiplication. An instance of the implication problem holds if and only if the corresponding sentence in the first-order theory has no model. The decidability then follows since the first-order theory over the reals with addition and multiplication is de-\ncidable (Tarski [8]). Since encoding instances of the implication problem as decision problems in the firstorder theory over the reals is not feasible for practical applications, we will introduce an approximate logical inference algorithm which combines a falsification and a novel validation algorithm. The validation algorithm represents each set of CI statements as a sparse 0-1 matrixA, and validates instances of the implication problem by solving linear programs with constraint matrix A. Thus, by only requiring the algorithm to decide most but not all instances of the implication problem, we can leverage linear constraint solvers for our purposes. In an extensive experimental section, we will demonstrate this inference algorithm to be both effective and efficient in validating and falsifying instances of the implication problem."}, {"heading": "2 Preliminaries", "text": "Definition 2.1. A probability model over S = {s1, . . . , sn} is a pair (dom,P ), where dom is a domain mapping that maps each si to a finite domain dom(si), and P is a probability measure having dom(s1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 dom(sn) as its sample space. For A = {a1, . . . , ak} \u2286 S, we will say that a is a domain vector of A if a \u2208 dom(a1)\u00d7 \u00b7 \u00b7 \u00b7 \u00d7 dom(ak).\nIn what follows, we will only refer to probability measures, keeping their probability models implicit.\nDefinition 2.2. Let I(A,B|C) be a CI statement, and let P be a probability measure. We say that P satisfies I(A,B|C), and write |=P I(A,B|C), if for every domain vector a, b, and c of A, B, and C, respectively, PC(c)PABC(a,b, c) = PAC(a, c)PBC(b, c)."}, {"heading": "3 On the Decidability of Implication Problems for CI Statements", "text": "In this section we will investigate the decidability of the implication problem for CI statements relative to the class of discrete probability measures. One of the key ideas is to leverage the fact that every discrete probability measure is fully characterized by specifying a finite number of probability densities. For an in-depth discussion of related observations and ideas in the context of the probability calculus we refer the reader to (Fitelson [19]). Using this idea, we will be able to show that the implication problem for probabilistic conditional independence statements can be encoded as a sentence in the first-order theory over the reals with addition and multiplication, given that the cardinalities of the domains of the random variables are fixed a priori, which is an assumption often made for probabilistic models. This will, for instance, imply the decidability of the implication problem for\nCI statements relative to the class of binary discrete probability measures. Let us first define the implication problem relative to the notion of satisfaction from Definition 2.2.\nDefinition 3.1. Let S be a finite set of random variables, let C and D be two non-empty sets of CI statements over S, let P be the class of discrete probability measures over S. We say that C implies D relative to P , and write C |= D, if every P \u2208 P that satisfies each CI statement in C also satisfies at least one CI statement in D. We will denote the corresponding decision problem with (S, C,D).\nThis is the most general definition of the decision problem which is necessary for cases where perfect models are not guaranteed. For a discussion of perfect models and related logical and algorithmic concepts of probabilistic conditional independence, we refer the reader to (Geiger and Pearl [4]). We can now prove the decidability of the implication problem for conditional independence statements under the additional assumption that the cardinalities of the domains of all random variables are known and fixed.\nTheorem 3.2. Let k1, ..., kn \u2208 N, let S = {s1, ..., sn} be a set of n discrete random variables with |si| = ki for 1 \u2264 i \u2264 n, and let C and D be sets of CI statements over S. Then (S, C,D) is decidable.\nProof. Let N = \u220f\nsi\u2208S |si| = \u220fn i=1 ki. Let C and D\nbe two sets of CI statements over S. Every discrete probability measure P over S can be fully characterized by N probability densities P (s), for all s \u2208 dom(s1)\u00d7 \u00b7 \u00b7 \u00b7 \u00d7 dom(sn). Every (marginal) probabil-\nity can then be expressed as a sum of densities: For every A = {ai1 , . . . , aik} \u2286 S and a \u2208 dom(ai1)\u00d7\u00b7 \u00b7 \u00b7\u00d7 dom(aik) we have that P A(a) = \u2211 {s with s|A=a} P (s) where s|A is the projection of s onto A. Let \u03bb : dom(s1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 dom(sn) \u2192 {1, ..., N} be a bijection that maps each element in dom(s1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 dom(sn) to a number in {1, ..., N}. Let \u03d5 be the function that maps each marginal probability to the formula in the first-order theory over the reals that encodes the corresponding sum of density symbols indexed according to \u03bb. We can now encode the instance of the implication problem as a sentence in the first-order theory with addition and multiplication as depicted in Figure 1. Tarski showed that the first-order theory over the reals with addition and multiplication is decidable, by providing an algorithm (using quantifier elimination) that can return, on any input sentence \u03a8 and in a finite number of steps, whether or not there exists a model M of \u03a8 [8]. Hence, what remains to be shown is that there exists a model M of \u03a6 if and only if C 6|= D. Let P be the measure that corresponds to M. Since M satisfies (3) and (4), P satisfies the first and the second of Kolmogorov\u2019s axioms. Furthermore, by definition of M and P , P satisfies the third of Kolmogorov\u2019s axioms. Hence, M corresponds to a discrete probability measure over S. Since M satisfies (1) and (2) we have that P satisfies every I(A,B|C) \u2208 C but no I(A,B|C) \u2208 D. This implies C 6|= D. Finally, assume that C 6|= D. Hence, there exists a discrete probability measure P over S such that P satisfies every I(A,B|C) \u2208 C but no I(A,B|C) \u2208 D. Let M \u2208 RN and let the i-th element ofM be the density P (\u03bb\u22121(i)). It follows that M is a model of \u03a6.\nOf course, the theorem implies the decidability of the implication problem relative to the class of binary discrete probability measures. Note that the size of \u03a6 (that is, the number of polynomials) grows exponentially with the number of variables. Indeed, each of the first-order sentences \u03a6 over binary variables will contain an exponential number of polynomials since each CI statement in C leads to 2|S| conjunctions of different polynomials in \u03a6. By replacing the inequalities \u2265 in part (3) of the first-order sentence \u03a6 with strict inequalities >, we can derive the following corollary.\nCorollary 3.3. Let k1, ..., kn \u2208 N, let S = {s1, ..., sn} be a set of n discrete random variables with |si| = ki for 1 \u2264 i \u2264 n, and let C and D be sets of CI statements over S. Then C |= D is decidable relative to the class of positive discrete probability measures over S.\nEven though considerable progress has been made in improving Tarski\u2019s quantifier elimination algorithm (for a survey of methods we refer the reader to Collins [10]), the method remains infeasible even\nfor small instances. The time complexity of deciding whether a model for a first-order sentence with addition and multiplication exists over the reals is doubly-exponential in the worst case, and in the case of instances of the CI implication problem, the input is already exponential in the size of S. However, there are ways to approximate the decision of the implication problem by combining powerful falsification and validation algorithms (Bouckaert and Studeny\u0301 [9]). These algorithms falsify and validate instances of the implication problem relative to the class of discrete probability measures with arbitrary finite domains, which makes them also applicable to instances of the implication problem where the domain cardinalities are fixed."}, {"heading": "4 Approximate Logical Inference", "text": "We will harness one of the recently discovered falsification algorithms and introduce a novel validation algorithm that encodes instances of the implication problem as linear programs with sparse 0-1 constraint matrices. Our goal is to compute, for any given set of CI statements C over a finite set S, those CI statements over S that are implied by C and those that are not implied. In order to achieve this, we will first apply the falsification algorithm to falsify a large fraction of invalid instances of the implication problem and also use it to compute the input to the validation algorithm. Furthermore, we will be able to show that the validation algorithm is closely related to the theory of structural and combinatorial imsets (Studeny\u0301 [17]). Before we discuss the technical details of the validation algorithm, let us first recall the falsification algorithm introduced in (Niepert et al. [12])."}, {"heading": "4.1 Falsification Algorithm", "text": "Since our objective is the implication problem relative to the class of discrete probability measures with arbitrary finite domains, for which perfect models exist (Geiger and Pearl [4]), deciding C |= D is equivalent to deciding whether C |= d for at least one d \u2208 D. Therefore, in the remainder of this section, we will focus on algorithms that decide the implication problem C |= c for a set of CI statements C and a single CI statement c. This will simplify both the notation and the technical parts of the following sections.\nGiven two subsets A and B of S, we will write [A,B] for the lattice {U | A \u2286 U & U \u2286 B}. Using the notion of a lattice, we can associate semi-lattices with conditional independence statements.\nDefinition 4.1. Let I(A,B|C) be a CI statement. The semi-lattice of I(A,B|C) is defined by L(A,B|C) = [C, S]\u2212 ([A,S] \u222a [B,S]).\nWe will write L(c) to denote the semi-lattice of a conditional independence statement c, and L(C) to denote the union of semi-lattices, \u22c3\nc\u2032\u2208C L(c \u2032), of a set of CI\nstatements C. These semi-lattices can be used to falsify instances of the implication problem.\nProposition 4.2 (Niepert et al. [12]). Let C be a set of CI statements and c be a single CI statement. If L(C) + L(c), then C 6|= c.\nExample 4.3. Let S = {a, b, c, d}, let C = {I(a, b|cd), I(a, d|bc)} and let I(a, bd|c) be a single CI statement. Then, L(C) = L(a, b|cd) \u222a L(a, d|bc) = {cd} \u222a {bc} = {cd, bc} and L(a, bd|c) = {c, bc, cd}. Since L(C) + L(a, bd|c) we have that C 6|= I(a, bd|c).\nIt has been shown that testing for semi-lattice inclusion is a coNP-complete decision problem (Niepert and Van Gucht [13]). However, we also know that there exists a linear time reduction to SAT and that we can leverage SAT solvers to decide semi-lattice inclusion very efficiently (without storing the exponentially sized semi-lattices), even for instances of up to several hundreds of variables (Niepert and Van Gucht [13]). Indeed, we discovered in our experiments that the critical and most time-consuming part of the approximate logical inference algorithm is not the falsification but the validation algorithm."}, {"heading": "4.2 Validation Algorithm", "text": "In general, a validation algorithm takes as input an instance of the implication problem, consisting of a set of CI statements C and a single CI statement c over a finite set S, and accepts only if C |= c. Of course, the algorithm not accepting an instance of the implication problem does not imply that the instance is invalid. Please note that one of the most prominent validation algorithms is the algorithm that computes the closure of the semi-graphoid axioms (Dawid [11], Pearl [16]). However, the closure of the semi-graphoid axioms can only validate a small fraction of the set of verifiable instances. Before we can derive our validation algorithm, we need some definitions of important technical concepts.\nDefinition 4.4. Let P and Q be two probability measures over a discrete sample space, and let P be absolutely continuous with respect to Q. Then, the relative entropy (Kullback-Leibler divergence) H is defined as\nH(P |Q) := \u2211\nx\n{P (x) log P (x)\nQ(x) , P (x) > 0},\nwith x ranging over all elements of the discrete sample space.\nDefinition 4.5 (Studeny\u0301 [17]). Let P be a probability measure, and let H be the relative entropy. The multiinformation function MP : 2 S \u2192 [0,\u221e] induced by P\nis defined as\nMP (A) := H(P A|\n\u220f\na\u2208A\nP {a}),\nfor each non-empty subset A of S and MP (\u2205) = 0.\nDefinition 4.6. Let S be a finite set, and let F be a real-valued function over S. The Mo\u0308bius inversion of F is the real-valued function \u2206F defined by \u2206F (X) = \u2211\nX\u2286U\u2286S(\u22121) |U|\u2212|X|F (U), for each X \u2286 S.\nNow we have the following crucial relationship between a multiinformation function, its Mo\u0308bius inversion, and the semi-lattice of a CI statement.\nLemma 4.7. Let S be a finite set of random variables, let P be a discrete probability measure over S, let MP be the multiinformation function induced by P , let \u2206MP be the Mo\u0308bius inversion of MP , and let I(A,B|C) be a CI statement over S. Then, the following statements are equivalent\n(1) P satisfies I(A,B|C)\n(2) MP (ABC) +MP (C)\u2212MP (AC)\u2212MP (BC) = 0\n(3) \u2211\nU\u2208L(A,B|C)\n\u2206MP (U) = 0\nProof. Studeny\u0301 showed that (1) if and only if (2) [17]. In addition, we have that (2) if and only if (3), because F (ABC) + F (C) \u2212 F (AC) \u2212 F (BC) = \u2211\nU\u2208L(A,B|C) \u2206F (U) for any real-valued function F . We refer the reader to Sayrafi and Van Gucht [14] for a proof of the later statement.\nWe will now be able to harness the equivalences stated in the previous lemma to represent each set of CI statements C as a minimal sparse 0-1 matrix A. Each instance of the implication problem with C as the set of antecedents will then correspond to a linear program with equality constraints specified by A. Before we explain the construction of the constraint matrix A, however, we have to define some additional technical concepts. For some of the following results, we need the concept of elementary CI statements, which are simply CI statements I(a, b|K) with a, b \u2208 S and K \u2286 S \\ {a, b}. We will write B(S) to denote the set of elementary CI statements over a finite set S.\nDefinition 4.8. Let S be a finite set and let C be a set of CI statements over S. The set of relevant elementary CI statements R(C) is defined as follows:\nR(C) = {I(a, b|K) \u2208 B(S) | L(a, b|K) \u2286 L(C)}.\nWe will use the elementary CI statements in R(C) to construct the constraint matrix A. Please note\nthat R(C) is the set of elementary CI statements over S that remain after the application of the falsification algorithm (Niepert et al. [12]). Hence, it follows that polynomial-time heuristics and SAT solvers can be employed to compute the set R(C) efficiently for up to several hundreds of variables (Niepert and Van Gucht [13]). By Proposition 4.2, only CI statements I(A,B|C) with L(A,B|C) \u2286 L(C) can possibly be implied by C. Now, using the concept of a semi-lattice, each of these candidate CI statements c = I(A,B|C) can be written as a vector vc relative to the space {0, 1}L(C) as follows: For every U \u2208 L(C) we have vc(U) = 1 if U \u2208 L(A,B|C) and vc(U) = 0 otherwise. The vector representation of a set of CI statements C can then be defined as the sum of the vectors corresponding to individual elements in C: vC = \u2211\nc\u2208C vc. This is equivalent to the definition of an imset (Studeny\u0301 [17]), except that we use the Mo\u0308bius inversion to avoid negative elements in the vector representation and that the vector representation is constructed relative to the union of semi-lattices L(C) of the CI statements in C. Given these definitions of vector representations for individual CI statements and for sets of CI statements, we can state the following crucial result.\nProposition 4.9. Let S be a finite set, let C be a set of CI statements, let c be a single CI statement over S and let Q+ be the non-negative rational numbers. Then, C |= c if\nvC = vc + \u2211 r\u2208R(C) kr \u00b7 vr with kr \u2208 Q +. (5)\nProof. Let P be a probability measure that satisfies all CI statements in C and let \u2206MP be the Mo\u0308bius inversion of the multiinformation function MP induced by P . Since MP is a supermodular function (Studeny\u0301 [17]), we have \u2211\nr\u2208R(C) \u00b7(kr \u00b7 \u2211 U\u2208L(r) \u2206MP (U)) \u2265 0, and\nalso \u2211\nU\u2208L(c) \u2206MP (U) \u2265 0. Now, since P satisfies all CI statements in C we have that \u2211\nc\u2032\u2208C\n\u2211\nU\u2208L(c\u2032) \u2206MP (U) = 0 by Lemma 4.7. Since\nequality (5) holds by assumption, we have that \u2211\nc\u2032\u2208C\n\u2211 U\u2208L(c\u2032) \u2206MP (U) = \u2211\nU\u2208L(c) \u2206MP (U) + \u2211\nr\u2208R(C) \u00b7(kr \u00b7 \u2211\nU\u2208L(r) \u2206MP (U)) = 0. Hence, \u2211\nU\u2208L(c) \u2206MP (U) = 0 and by Lemma 4.7 it follows that P satisfies c.\nIn light of these results, we can now rewrite equation (5) in the previous proposition as a linear program (Schrijver [18]). A linear program has the form\nminimize cTx (6)\nsubject to Ax eq b,x \u2265 0 (7)\nwhere eq is one of {\u2264,\u2265,=}. For our purposes, eq is the equality sign, the columns of matrix A are the vec-\ntors vr for each of the relevant elementary CI statements, that is, for the CI statements in R(C), and b = vC\u2212vc. Clearly, our objective function is the zerofunction 0T because we are only interested in the existence of a solution for the equality constraints. This is often referred to as the feasibility problem of finding a solution for the system of linear constraints.\nExample 4.10. Let S = {a, b, c, d} and let C = {I(a, b|\u2205), I(c, d|a), I(c, d|b), I(a, b|cd)}. Then, R(C) = {I(a, b|\u2205), I(a, b|c), I(a, b|d), I(a, b|cd), I(c, d|\u2205), I(c, d|a), I(c, d|b), I(c, d|ab)} and L(C) = {\u2205, a, b, c, d, ab, cd}. The columns of the minimal 0-1 matrix A below correspond to the eight relevant elementary CI statements and the number of rows is determined by L(C).\nA = e1 e2 e3 e4 e5 e6 e7 e8 cd 1 1 1 1 0 0 0 0 ab 0 0 0 0 1 1 1 1 a 0 0 0 0 1 1 0 0 b 0 0 0 0 1 0 1 0 c 1 1 0 0 0 0 0 0 d 1 0 1 0 0 0 0 0 \u2205 1 0 0 0 1 0 0 0\nWe have that vTC = (2, 2, 1, 1, 1, 1, 1). Now, let I(c, d|\u2205) be a CI statement. Then we have that bT = vTC \u2212 v T I(c,d|\u2205) = (2, 2, 1, 1, 1, 1, 1)\u2212 (0, 1, 1, 1, 0, 0, 1) = (2, 1, 0, 0, 1, 1, 0). Finally, it follows that C |= I(c, d|\u2205) since b = e2 + e3 + e8.\nIt is well-known that linear programs (LPs) are solvable in polynomial time in the number of variables. However, in the worst case the reduction leads to an LP with an exponential number of variables ( (\n|S| 2\n)\n2|S|\u22122; the maximum number of elementary CI\nstatements over S) and constraints (2|S| \u2212 |S| \u2212 1; the maximum cardinality of the set L(C)). As a rule of thumb, the more columns matrix A has the more difficult is the corresponding LP problem. An advantage of our method over a na\u0308\u0131ve approach is that A only consists of the vectors representing the relevant elementary CI statements R(C). This means that the number of columns (that is, the number of variables of the LP) can be very small compared to the worst case. In rare cases, the solutions to the LPs might be inaccurate due to round-off and truncation errors. Therefore, when we obtain a solution, we expand the elements of the solution vector into fractions of integers, which results in a vector xf , and only accept if Axf = b. We also would like to underscore that matrix A is always a 0-1 matrix, leading to better numerical stability and the possibility to employ existing sparse matrix data structures. We will come back to algorithmic issues when we discuss the results of our experiments."}, {"heading": "4.3 Combinatorial and Structural Imsets", "text": "There is a close link to Studeny\u0301\u2019s theory of imsets [17], on which we will briefly elaborate in this section. Let C be a set of CI statements and let c be a CI statement over a set S. Then, under the assumption that we can ignore numerical inaccuracies, one can test whether imset uC \u2212 uc is structural using the previously introduced reduction to a linear program. Furthermore, one can test whether the imset is combinatorial by reducing it to the identical integer program. Again, we want to stress that numerical rounding and truncation errors might lead to inaccurate results, and, therefore, the method should be used with caution when mathematical properties about combinatorial and structural imsets are to be proved. However, one of the results of our experiments is that the solver of the LP instances delivered integer and small rational solutions in all but some cases which allowed us to verify their correctness. We refer the reader to Hemmecke et al. [20] who used, among other tools, integer programming to find a structural imset which is not combinatorial."}, {"heading": "5 Experiments", "text": "We will try to mainly address the following empirical questions with our experiments:\n1. Effectiveness: What fraction of the instances of the implication problem can we either falsify or validate?\n2. Efficiency: How fast does the algorithm run; to how many variables does it scale? Howmuch more efficient is the algorithm compared to the na\u0308\u0131ve approach both in terms of time and space complexity?\n3. Structural and Numerical properties: How large is the constraint matrix A for different instances? What are the numerical properties of the solutions?\nTo judge the effectiveness and efficiency of the algorithm we must apply it to instances of the implication problem over different number of variables. Since the distribution of implication problems in real-world applications is unknown, our experiments need to be run on randomly generated instances. Using the method of randomly generating test instances from (Bouckaert and Studeny\u0301 [9]) allows us to compare the experimental outcomes with existing results. Hence, for each experiment we first generated instances of the implication problem (S, C, c) by randomly selecting n different sets of elementary CI statements over S as antecedents C, and for each of these, k different elementary CI statements c over S as consequence, one at a time. We first applied the falsification algorithm\nto these instances and used it to create the constraint matrix A and vector b from C and c as described in the previous section. For the resulting linear programs we used lp solve1 an open-source linear programming system that can solve both linear and integer programs. It is based on the revised simplex method and the branch-and-bound method for integer programs. We did not change the standard optimization settings of the solver. Furthermore, we only accepted a solution if its rational expansion solved the respective constraints. For our purposes this is unproblematic because the objective is to validate as many instances of the implication problem as possible while entirely ruling out false positives. All experiments were run on a dual-core 3.2GHz Linux PC with 2GB RAM.\nFigure 2 shows the number of instances that could either be validated or falsified by the algorithms for five variables. For each \u2113 = 2, ..., 58 (the number of antecedents) we randomly created 4,500 different sets of \u2113 elementary CI statements, and for each of those randomly selected 20 different elementary CI statements as consequences, one at a time, resulting in 90,000 instances of the implication problems for each \u2113. The results show that only a small fraction of the instances could not be decided and that for larger values of \u2113 (for five variables: \u2113 > 40) all of the instances could either be falsified or validated. This behavior of the algorithmwas consistent over all tested number of variables (4,...,15).\n1Michel Berkelaar, Kjell Eikland, and Peter Notebaert. lp solve, an open source (Mixed-Integer) Linear Programming system originally developed at Eindhoven University of Technology; http://lpsolve.sourceforge.net/\nFigure 3 depicts the average size (that is, the number of columns and rows) of the constraint matrix A, and the average time in milliseconds to solve one linear program and the corresponding integer program, respectively. After solving the linear programs, that is, determining whether or not there exists a solution, we also solved the equivalent integer programs. Interestingly, for each and every of the 2,700,000 instances for five variables, if there existed a solution to the linear program, then there also existed one for the corresponding integer program.\nFigure 4 illustrates the computational advantage one gains when using the minimal constraint matrix A consisting only of the relevant elementary CI state-\nments, over using the matrix consisting of all elementary CI statements. The times in milliseconds provided are for 6 and 7 variables, averaged over 30,000 trials, for 1000 sets of \u2113 = 10, 20, ..., 100 antecedents, and 30 different consequences, one at a time. Figure 5 depicts the average time in seconds to solve instances of the linear programs and the average dimensions of constraint matrix A for different number of variables, averaged over 1000 trails.\nFinally, we want to compare our algorithm to the racing algorithm introduced in (Bouckaert and Studeny\u0301 [9]). The falsification procedure of the racing algorithm is rooted in the theory of imsets: an instance of the implication problem is falsified if one of the supermodular functions constructed by the algorithm is a counter-model for the instance of the implication problem [9]. It is heavily randomized, has super-exponential running time, and could therefore only be tested for up to 6 variables. Furthermore, the racing algorithm might falsify implications that actually do hold. This is a consequence of the fact that the class of multiinformation functions induced by discrete probability measures is a strict subset of the class of all supermodular functions. (See Examples 4.1 and 6.2 in Studeny\u0301\u2019s monograph [17].) The falsification algorithm based on Proposition 4.2, on the other hand, ensures that falsified instance of the implication problem are guaranteed not to be valid. The validation procedure of the racing algorithm tests whether an imset that encodes an instance of the implication problem is combinatorial. It makes use of some ad-hoc heuristics to speed-up the computations. The validation algorithm presented here introduces two novel ideas: (1) the representation of instances of the implication problem as linear programs; and (2) the notion and construction of minimal constraint matrices that increase the efficiency of the algorithm."}, {"heading": "6 Conclusion", "text": "Logical inference algorithms for probabilistic conditional independence statements have several important applications from checking consistency during knowledge elicitation to constraint-based structure learning of graphical models (Gandhi et al. [7]). We proved that the implication problem for CI statements is decidable, given that the size of the domains of the random variables is known and fixed. We then presented an approximate inference algorithm which combines a falsification and a novel validation algorithm. The validation algorithm represents each set of CI statements as a minimal sparse 0-1 matrix A and validates instances of the implication problem by solving linear programs with A as the constraint matrix. We demonstrated experimentally that the approximate inference algorithm is both effective and efficient in validating and falsifying instances of the implication problem. We hope that the inference algorithm will prove useful to both researchers and practitioners."}, {"heading": "Acknowledgments", "text": "The author wants to thank Dirk Van Gucht and Marc Gyssens for helpful discussions, and the anonymous reviewers for their valuable comments and suggestions."}], "references": [{"title": "S", "author": ["S. Renooij", "H.J.M. Tabachneck-Schijf"], "venue": "M. Mahoney (eds.) Proceedings of the 6th UAI Bayesian Modelling Applications Workshop", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2008}, {"title": "Elicitation of Probabilities for Belief Networks: Combining Qualitative and Quantitative Information", "author": ["M. Druzdzel", "L.C. van der Gaag"], "venue": "Proceedings of the 11th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1995}, {"title": "Constraint Processing", "author": ["R. Dechter"], "venue": "Morgan Kaufmann Publishers Inc.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "Logical and algorithmic properties of conditional independence and graphical models", "author": ["D. Geiger", "J. Pearl"], "venue": "The Annals of Statistics, 21(4):2001\u2013 2021", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1993}, {"title": "Complexity of structural models", "author": ["M. Studen\u00fd"], "venue": "Proceedings of the 13th Prague Conference on Information Theory, Statistical Decision Functions and Random Processes, pages 521\u2013528", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1998}, {"title": "Stable independence and complexity of representation", "author": ["P. de Waal", "L.C. van der Gaag"], "venue": "Proceedings of the 20th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2004}, {"title": "Learning Markov Network Structure using Few Independence Tests", "author": ["P. Gandhi", "F. Bromberg", "D. Margaritis"], "venue": "Proceedings of the SIAM Conference on Data Mining, pages 680\u2013691", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2008}, {"title": "A Decision Method for Elementary Algebra and Geometry", "author": ["A. Tarski"], "venue": "2nd edition. University of California Press", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1951}, {"title": "Racing algorithms for conditional independence inference", "author": ["R.R. Bouckaert", "M. Studen\u00fd"], "venue": "Int. J. Approx. Reasoning, 45(2):386\u2013401", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2007}, {"title": "Quantifier Elimination by Cylindrical Algebraic Decomposition\u2013Twenty Years of Progress", "author": ["G.E. Collins"], "venue": "Quantifier Elimination and Cylindrical Algebraic Decomposition Springer-Verlag, pages 8\u201323", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1998}, {"title": "Conditional Independence in Statistical Theory", "author": ["A.P. Dawid"], "venue": "Journal of the Royal Statistical Society, 41:1\u201331", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1979}, {"title": "On the conditional independence implication problem: A lattice-theoretic approach", "author": ["M. Niepert", "D. Van Gucht", "M. Gyssens"], "venue": "Proceedings of the 24th Conference on Uncertainty in Artificial Intelligence, pages 435\u2013443", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2008}, {"title": "Logical Properties of Stable Conditional Independence", "author": ["M. Niepert", "D. Van Gucht"], "venue": "Proceedings of the 4th European Workshop on Probabilistic Graphical Models, pages 225\u2013232", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2008}, {"title": "Differential constraints", "author": ["B. Sayrafi", "D. Van Gucht"], "venue": "Proceedings of the ACM PODS Conference, pages 348\u2013357", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2005}, {"title": "Ascending and descending conditional independence relations", "author": ["F. Mat\u00fa\u0161"], "venue": "Transactions of the 11th Prague Conference on Information Theory, pages 189\u2013200", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1992}, {"title": "Probabilistic reasoning in intelligent systems: networks of plausible inference", "author": ["J. Pearl"], "venue": "Morgan Kaufmann Publishers Inc.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1988}, {"title": "Probabilistic Conditional Independence Structures", "author": ["M. Studen\u00fd"], "venue": "Springer-Verlag", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2005}, {"title": "Theory of Linear and Integer Programming", "author": ["A. Schrijver"], "venue": "John Wiley & Sons, Inc", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1986}, {"title": "A Decision Procedure for Probability Calculus with Applications", "author": ["B. Fitelson"], "venue": "The Review of Symbolic Logic, 1:111-125", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2008}, {"title": "Three counter-examples on semigraphoids", "author": ["R. Hemmecke", "J. Morton", "A. Shiu", "B. Sturmfels"], "venue": "Combinatorics, Probability and Computing, 17(2):239\u2013257", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "Knowledge elicitation is an important task in the field of reasoning under uncertainty [1].", "startOffset": 87, "endOffset": 90}, {"referenceID": 1, "context": "Finding a suitable model can then be interpreted as a constraint satisfaction problem (CSP), and the approach to harness CSP solvers for instances of this and related problems has been known for more than 10 years (Druzdzel and van der Gaag [2], Dechter [3]).", "startOffset": 241, "endOffset": 244}, {"referenceID": 2, "context": "Finding a suitable model can then be interpreted as a constraint satisfaction problem (CSP), and the approach to harness CSP solvers for instances of this and related problems has been known for more than 10 years (Druzdzel and van der Gaag [2], Dechter [3]).", "startOffset": 254, "endOffset": 257}, {"referenceID": 3, "context": "For this to be possible, one would need an algorithm that decides the implication problem for CI statements (Geiger and Pearl [4]), that is, an algorithm that can infer CI statements which are logically implied by a set of given ones, relative to the class of discrete probability measures.", "startOffset": 126, "endOffset": 129}, {"referenceID": 4, "context": "There are ways to improve on this representation by using the notion of o-dominant triplets (Studen\u00fd [5]) and stable independence (de Waal and van der Gaag [6]), both of which need fast logical inference algorithms.", "startOffset": 101, "endOffset": 104}, {"referenceID": 5, "context": "There are ways to improve on this representation by using the notion of o-dominant triplets (Studen\u00fd [5]) and stable independence (de Waal and van der Gaag [6]), both of which need fast logical inference algorithms.", "startOffset": 156, "endOffset": 159}, {"referenceID": 6, "context": "[7]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "cidable (Tarski [8]).", "startOffset": 16, "endOffset": 19}, {"referenceID": 18, "context": "For an in-depth discussion of related observations and ideas in the context of the probability calculus we refer the reader to (Fitelson [19]).", "startOffset": 137, "endOffset": 141}, {"referenceID": 3, "context": "For a discussion of perfect models and related logical and algorithmic concepts of probabilistic conditional independence, we refer the reader to (Geiger and Pearl [4]).", "startOffset": 164, "endOffset": 167}, {"referenceID": 7, "context": "Tarski showed that the first-order theory over the reals with addition and multiplication is decidable, by providing an algorithm (using quantifier elimination) that can return, on any input sentence \u03a8 and in a finite number of steps, whether or not there exists a model M of \u03a8 [8].", "startOffset": 278, "endOffset": 281}, {"referenceID": 9, "context": "Even though considerable progress has been made in improving Tarski\u2019s quantifier elimination algorithm (for a survey of methods we refer the reader to Collins [10]), the method remains infeasible even for small instances.", "startOffset": 159, "endOffset": 163}, {"referenceID": 8, "context": "However, there are ways to approximate the decision of the implication problem by combining powerful falsification and validation algorithms (Bouckaert and Studen\u00fd [9]).", "startOffset": 164, "endOffset": 167}, {"referenceID": 16, "context": "Furthermore, we will be able to show that the validation algorithm is closely related to the theory of structural and combinatorial imsets (Studen\u00fd [17]).", "startOffset": 148, "endOffset": 152}, {"referenceID": 11, "context": "[12]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "Since our objective is the implication problem relative to the class of discrete probability measures with arbitrary finite domains, for which perfect models exist (Geiger and Pearl [4]), deciding C |= D is equivalent to deciding whether C |= d for at least one d \u2208 D.", "startOffset": 182, "endOffset": 185}, {"referenceID": 11, "context": "[12]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "It has been shown that testing for semi-lattice inclusion is a coNP-complete decision problem (Niepert and Van Gucht [13]).", "startOffset": 117, "endOffset": 121}, {"referenceID": 12, "context": "However, we also know that there exists a linear time reduction to SAT and that we can leverage SAT solvers to decide semi-lattice inclusion very efficiently (without storing the exponentially sized semi-lattices), even for instances of up to several hundreds of variables (Niepert and Van Gucht [13]).", "startOffset": 296, "endOffset": 300}, {"referenceID": 10, "context": "Please note that one of the most prominent validation algorithms is the algorithm that computes the closure of the semi-graphoid axioms (Dawid [11], Pearl [16]).", "startOffset": 143, "endOffset": 147}, {"referenceID": 15, "context": "Please note that one of the most prominent validation algorithms is the algorithm that computes the closure of the semi-graphoid axioms (Dawid [11], Pearl [16]).", "startOffset": 155, "endOffset": 159}, {"referenceID": 16, "context": "5 (Studen\u00fd [17]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 16, "context": "Studen\u00fd showed that (1) if and only if (2) [17].", "startOffset": 43, "endOffset": 47}, {"referenceID": 13, "context": "We refer the reader to Sayrafi and Van Gucht [14] for a proof of the later statement.", "startOffset": 45, "endOffset": 49}, {"referenceID": 11, "context": "[12]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "Hence, it follows that polynomial-time heuristics and SAT solvers can be employed to compute the set R(C) efficiently for up to several hundreds of variables (Niepert and Van Gucht [13]).", "startOffset": 181, "endOffset": 185}, {"referenceID": 16, "context": "This is equivalent to the definition of an imset (Studen\u00fd [17]), except that we use the M\u00f6bius inversion to avoid negative elements in the vector representation and that the vector representation is constructed relative to the union of semi-lattices L(C) of the CI statements in C.", "startOffset": 58, "endOffset": 62}, {"referenceID": 16, "context": "Since MP is a supermodular function (Studen\u00fd [17]), we have \u2211", "startOffset": 45, "endOffset": 49}, {"referenceID": 17, "context": "In light of these results, we can now rewrite equation (5) in the previous proposition as a linear program (Schrijver [18]).", "startOffset": 118, "endOffset": 122}, {"referenceID": 16, "context": "There is a close link to Studen\u00fd\u2019s theory of imsets [17], on which we will briefly elaborate in this section.", "startOffset": 52, "endOffset": 56}, {"referenceID": 19, "context": "[20] who used, among other tools, integer programming to find a structural imset which is not combinatorial.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "Using the method of randomly generating test instances from (Bouckaert and Studen\u00fd [9]) allows us to compare the experimental outcomes with existing results.", "startOffset": 83, "endOffset": 86}, {"referenceID": 8, "context": "Finally, we want to compare our algorithm to the racing algorithm introduced in (Bouckaert and Studen\u00fd [9]).", "startOffset": 103, "endOffset": 106}, {"referenceID": 8, "context": "The falsification procedure of the racing algorithm is rooted in the theory of imsets: an instance of the implication problem is falsified if one of the supermodular functions constructed by the algorithm is a counter-model for the instance of the implication problem [9].", "startOffset": 268, "endOffset": 271}, {"referenceID": 16, "context": "2 in Studen\u00fd\u2019s monograph [17].", "startOffset": 25, "endOffset": 29}, {"referenceID": 6, "context": "[7]).", "startOffset": 0, "endOffset": 3}], "year": 2009, "abstractText": "Logical inference algorithms for conditional independence (CI) statements have important applications from testing consistency during knowledge elicitation to constraintbased structure learning of graphical models. We prove that the implication problem for CI statements is decidable, given that the size of the domains of the random variables is known and fixed. We will present an approximate logical inference algorithm which combines a falsification and a novel validation algorithm. The validation algorithm represents each set of CI statements as a sparse 0-1 matrixA and validates instances of the implication problem by solving specific linear programs with constraint matrix A. We will show experimentally that the algorithm is both effective and efficient in validating and falsifying instances of the probabilistic CI implication problem.", "creator": "LaTeX with hyperref package"}}}