{"id": "1205.4655", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-May-2012", "title": "The View-Update Problem for Indefinite Databases", "abstract": "this paper introduces and studies a declarative framework for updating views over indefinite databases. geographic indefinite database is a database exhibiting null values that are represented, following the global database approach, by a single null constant. 1 paper formalizes views over such databases as indefinite deductive databases, and defines for them several classes encoding database repairs that reflect view - update properties. most notable is the class of constrained repairs. constrained repairs change the database \" minimally \" and avoid making arbitrary selections. they narrow down the space of alternative ways to react to view - alter request to those that are grounded, in a legally strong sense, in the database, the view ignores the view - update request.", "histories": [["v1", "Mon, 21 May 2012 16:42:06 GMT  (41kb)", "http://arxiv.org/abs/1205.4655v1", "24 pages (includes proofs)"]], "COMMENTS": "24 pages (includes proofs)", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["luciano caroprese", "irina trubitsyna", "miroslaw truszczynski", "ester zumpano"], "accepted": false, "id": "1205.4655"}, "pdf": {"name": "1205.4655.pdf", "metadata": {"source": "CRF", "title": "The View-Update Problem for Indefinite Databases", "authors": ["Luciano Caroprese", "Irina Trubitsyna", "Miros\u0142aw Truszczy\u0144ski", "Ester Zumpano"], "emails": ["caroprese@deis.unical.it", "irina@deis.unical.it", "zumpano@deis.unical.it", "mirek@cs.uky.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 5.\n46 55\nv1 [\ncs .D\nB ]\n2 1\nM ay"}, {"heading": "1 Introduction", "text": "A typical database system is large and complex. Users and applications rarely can access the entire system directly. Instead, it is more common that access is granted in terms of a view, a virtual database consisting of relations defined by a query to the stored and maintained database. Querying a view does not present a conceptual problem. In contrast, another key task, view updating, poses major challenges.\nExample 1. Let D = {q(a,b)} be a database over relation symbols q and r, where the relation r has arity three and is currently empty. Let us consider the view over D given by the Datalog program P = {p(X)\u2190 q(X ,Y ),r(X ,Y,Z)}. That view consists of a single unary relation p. Given the present state of D, the view is empty.\nTo satisfy the request that p(a) holds in the view (as it is now, it does not), one needs to update the database D. Such update consists of executing update actions that specify facts to insert to and to delete from D. These update actions (in a simplified setting that we consider for now) are \u201csigned\u201d facts +F and \u2212G, where +F stands for \u201cinsert F\u201d and \u2212G stands for \u201cdelete G.\u201d In our case, the set of update actions {\u2212q(a,b),+q(a,a),+r(a,a,a)} is a correct update to D. Executing it on D results in the database D\u2032 = {q(a,a),r(a,a,a)}, which has the desired property that p(a) holds in the view determined by P. There are also other ways to satisfy the user\u2019s request, for instance: {+r(a,b,a)} and {+q(c,d),+r(c,d,d)}, where c and d are any elements of the domain of the database.\nAs this example suggests, view updating consists of translating a view-update request, that is, an update request against the view, into an update, a set of update actions\nagainst the stored (extensional) database. The example highlights the basic problem of view updating. It may be (in fact, it is common), that a view-update request can be fulfilled by any of a large number of database updates. One of them has to be committed to and executed. Thus, developing methods to automate the selection process or, at least, aid the user in making the choice is essential and has been one of the central problems of view updating [9, 2, 13, 11]. That problem is also the focus of our paper.1\nTo restrict the space of possible database updates to select from, it is common to consider only those that accomplish the view-update request and are in some sense minimal. That reduces the space of updates. For instance, the update {\u2212q(a,b),+q(a,a), +r(a,a,a)} in Example 1 is not minimal. We can remove \u2212q(a,b) from it and what remains is still an update that once executed ensures that p(a) holds in the view. Minimal updates fulfilling the view-update request are commonly called repairs.\nEven imposing minimality may still leave a large number of candidate repairs. In Example 1, updates {+r(a,b,\u03c8)}, where \u03c8 is any domain element, are repairs, and there are still more. As long as we insist on the completeness of the repaired database, there is little one can do at this point but ask the user to select one.\nThe situation changes if we are willing to allow indefiniteness (incomplete information) in databases. Given the \u201cregular\u201d structure of the family of repairs above, one could represent it by a single indefinite repair, {+r(a,b,\u03c8)} regarding \u03c8 as a distinct null value standing for some unspecified domain elements. The choice facing the user substantially simplifies as possibly infinitely many repairs is reduced to only one.\nThis approach was studied by Farre\u0301 et al. [5], where the terminology of Skolem constants rather than null values was used. However, while seemingly offering a plausible solution to the problem of multiple repairs, the approach suffers from two drawbacks. First, the use of multiple Skolem constants (essentially, multiple null values) violates the SQL standard [15]. Second, the approach assumes that the initial database is complete (does not contain null values). Thus, while the approach might be applied once, iterating it fails as soon as an indefinite database is produced, since no guidance on how to proceed in such case is given.\nWe consider the view-update problem in the setting when both the original and the updated databases are indefinite (may contain occurrences of null values). To be compliant with the SQL standard, we allow a single null value only. We denote it by \u22a5 and interpret it as expressing the existence of unknown values for each attribute it is used for [10]. Typically, a database is represented as a set of facts. We propose to represent indefinite databases by two sets of facts that we interpret by means of a two-level closedworld assumption tailored to the case of indefinite information. We interpret indefinite databases in terms of their possible worlds. We extend the possible-world semantics to the setting of views, which we formalize in terms of indefinite deductive databases, and apply the resulting formalism to state and study the view-updating problem.\nWe then turn attention to the problem of multiple repairs. In general, using null values to encode multiple repairs is still not enough to eliminate them entirely (cf. our\n1 In some cases no update satisfies the view-update request. The question whether the lack of an appropriate update is caused by errors in the design of the view, in the extensional database, or in the view-update request is interesting and deserves attention, but is outside the scope of the present work.\ndiscussion above), and some level of the user\u2019s involvement may be necessary. Therefore, it is important to identify principled ways to narrow down the space of repairs for the user to consider. As the setting we consider here, when both the original and the updated databases may contain null values has not been considered before, we propose a concept of minimality tailored precisely to that situation. The primary concern is to minimize the set of new constants introduced by an update. The secondary concern is to minimize the degree of the semantic change. The resulting notion of minimality yields the notion of a repair.\nOur concept of minimality leads us also to the concept of a relevant repair, an update that introduces no new constants and minimizes the degree of change. In Example 1, {+r(a,b,\u22a5)}, {+r(a,a,\u22a5),+q(a,a)} and {+r(a,c,\u22a5),+q(a,c)}, where c is an element of the database domain other than a and b, are all repairs. The first two are obviously relevant, the third one is not.\nSome occurrences of non-nullary constants in a relevant repair may still be \u201cungrounded\u201d or \u201carbitrary,\u201d that is, replacing them with another constant results in a repair. For instance, replacing in the relevant repair {+r(a,a,\u22a5),+q(a,a)} the second and the forth occurrences of a with a fresh constant c yields {+r(a,c,\u22a5),+q(a,c)}, an update that is a repair. Intuitively, \u201carbitrary\u201d occurrences of constants, being replaceable, are not forced by the information present in the view (deductive database) and in the view-update request. By restricting relevant repairs to those without arbitrary occurrences of constants we arrive at the class of constrained repairs. In the view-update problem considered in Example 1, there is only one constrained repair, {+r(a,b,\u22a5)}.\nFinally, we study the complexity of the problems of the existence of repairs, relevant repairs and constrained repairs. We obtain precise results for the first two classes and an upper bound on the complexity for the last class.\nTo summarize, our main contributions are as follows. We propose a two-set representation of indefinite database that is more expressive than the standard one. We define the semantics and the operation of updating indefinite databases (Section 2). We define views over indefinite databases (indefinite deductive databases), and generalize the semantics of indefinite databases to views (Section 3). We state and study the view-update problem in the general setting when the initial and the repaired databases are indefinite. We propose a notion of minimality of an update and use it to define the concept of a repair. We address the problem of multiple repairs by defining relevant and constrained repairs (Section 4). We study the complexity of problems of existence of repairs, relevant repairs and constrained repairs (Section 5). The proofs are in the appendix."}, {"heading": "2 Indefinite Databases", "text": "We consider a finite set \u03a0 of relation symbols and a set Dom of constants that includes a designated element \u22a5, called the null value. We define Domd = Dom\\ {\u22a5}. Normally, we assume that Dom is an infinite countable set. However, for the sake of simplicity, in several of the examples the set Dom is finite.\nSome predicates in \u03a0 are designated as base (or extensional) predicates and all the remaining ones are understood as derived (or intensional) predicates. A term is a constant from Dom or a variable. An atom is an expression of the form p(t1, . . . , tk), where p \u2208 \u03a0 is a predicate symbol of arity k and ti\u2019s are terms. An atom is ground if\nit does not contain variables. We refer to ground atoms as facts. We denote the set of all facts by At. We call facts defined in terms of base and derived predicates base facts and derived facts respectively. A fact is definite if it does not contain occurrences of \u22a5. Otherwise, it is indefinite. Given a set S of atoms, we define Dom(S) (resp. Domd(S)) as the set of constants in Dom (resp. Domd) occurring in S. For every two tuples of terms t = (t1, . . . , tk) and t \u2032 = (t \u20321, . . . , t \u2032 k) and every k-ary predicate symbol p \u2208 \u03a0 , we write t t \u2032 and p(t) p(t \u2032) if for every i, 1 \u2264 i \u2264 k, ti = t \u2032i or ti =\u22a5. We say in such case that t \u2032 and p(t \u2032) are at least as informative as t and p(t), respectively. If, in addition, t 6= t \u2032, we write t \u227a t \u2032 and p(t) \u227a p(t \u2032), and say that t \u2032 and p(t \u2032) are more informative than t and p(t). Sometimes, we say \u201cat most as informative\u201d and \u201cless informative,\u201d with the obvious understanding of the intended meaning. We also define t and t \u2032 (respectively, p(t) and p(t \u2032)) to be compatible, denoted by t \u2248 t \u2032 (respectively, p(t) \u2248 p(t \u2032)), if for some k-tuple s of terms, t s and t \u2032 s. Finally, for a set D \u2286 At, we define\nD\u21d3= {a | there is b \u2208 D s.t. a b} D\u21d1= {a | there is b \u2208 D s.t. b a} D\u2248= {a | there is b \u2208 D s.t. b \u2248 a} D\u223c= D\u2248 \\D\u21d3.\nTo illustrate, let q be a binary relation symbol and Dom = {\u22a5,1,2}. Then: {q(1,\u22a5)}\u21d3 = {q(1,\u22a5),q(\u22a5,\u22a5)} {q(1,\u22a5)}\u21d1 = {q(1,\u22a5),q(1,1),q(1,2)} {q(1,\u22a5)}\u2248 = {q(1,\u22a5),q(1,1),q(1,2),q(\u22a5,1),q(\u22a5,2),q(\u22a5,\u22a5)} {q(1,\u22a5)}\u223c = {q(1,1),q(1,2),q(\u22a5,1),q(\u22a5,2)}. We note also note that D\u2248 = (D\u21d1)\u21d3. In the most common case, databases are finite subsets of At that contain definite facts only. The semantics of such databases is given by the closed-world assumption or CWA [12]: a definite fact q is true in a database D if q \u2208 D. Otherwise, q is false in D. We are interested in databases that may contain indefinite facts, too. Generalizing, we will for now assume that an indefinite database is a finite set of possibly indefinite atoms. The key question is that of the semantics of indefinite databases.\nLet D be an indefinite database. Clearly, all facts in D are true in D. In addition, any fact that is less informative than a fact in D is also true in D. Indeed, each such fact represents an existential statement, whose truth is established by the presence of a more informative fact in D (for instance, the meaning of p(\u22a5) is that there is an element c in the domain of the database such that p(c) holds; if p(1) \u2208 D, that statement is true). Summarizing, every fact in D\u21d3 is true in D.\nBy CWA adapted for the setting of indefinite databases [10], facts that are not in D\u21d3 are not true in D, as D contains no evidence to support their truth. Those facts among them that are compatible with facts in D (in our notation, facts in D\u223c), might actually be true, but the database just does not know that. Of course, they may also be false, the database does not exclude that possibility either. They are regarded as unknown. By CWA again, the facts that are not compatible with any fact in D are false in D, as D provides no explicit evidence otherwise.\nThe simple notion of an indefinite database, while intuitive and having a clear semantics, has a drawback. It has a limited expressive power. For instance, there is no database D to represent our knowledge that p(1) is false and that there is some definite c such that p(c) holds (clearly, this c is not 1). To handle such cases, we introduce a more general concept of an indefinite database, still using CWA to specify its meaning.\nDefinition 1. An indefinite database (a database, for short) is a pair I = \u3008D,E\u3009, where D and E are finite sets of (possibly indefinite) facts.\nThe intended role of D is to represent all facts that are true in the database \u3008D,E\u3009, while E is meant to represent exceptions, those facts that normally would be unknown, but are in fact false (and the database knows it). More formally, the semantics of indefinite databases is presented in the following definition.\nDefinition 2. Let \u3008D,E\u3009 be a database and let q \u2208 At be a fact. Then: (1) q is true in \u3008D,E\u3009, written \u3008D,E\u3009 |= q, if q \u2208 D\u21d3; (2) q is unknown in \u3008D,E\u3009, if q \u2208 (D\u2248 \\D\u21d3)\\E\u21d1 (= D\u223c \\E\u21d1); (3) q is false in \u3008D,E\u3009, denoted \u3008D,E\u3009 |= \u00acq, in all other cases, that is, if q /\u2208 D\u2248 or if q \u2208 D\u223c\u2229E\u21d1.\nThe use of E\u21d1 in the definition (items (2) and (3)) reflects the property that if an atom a is false then every atom b at least as informative as a must be false, too.\nWe denote the sets of all facts that are true, unknown and false in a database I = \u3008D,E\u3009 by I t , I u and I f , respectively. Restating the definition we have:\nI t = D \u21d3, I u = D \u223c \\E\u21d1, and I f = (At \\D \u2248)\u222a (D\u223c\u2229E\u21d1).\nExample 2. The knowledge that p(c) holds for some constant c and that p(1) is false can be captured by the database \u3008{p(\u22a5)},{p(1)}\u3009. The database \u3008{q(\u22a5,\u22a5),q(1,1)}, {q(1,\u22a5)}\u3009 specifies that the atoms q(1,1), q(1,\u22a5), q(\u22a5,1) and q(\u22a5,\u22a5) are true, that all definite atoms q(1,d), with d 6= 1, are false, and that all other atoms q(c,d) are unknown. While the fact that q(\u22a5,\u22a5) is true follows from the fact that q(1,1) is true, the presence of the former in the database is not redundant, that is, the database without it would have a different meaning. Namely, q(\u22a5,\u22a5) makes all atoms q(a,b) potentially unknown (with some of them true or false due to other elements of the database).\nDefinition 3. A set W of definite facts is a possible world for a database I = \u3008D,E\u3009 if I t \u2286 W\u21d3 (W \u201cexplains\u201d all facts that are true in I ), W \u2286 I t \u222aI u (only definite facts that are true or unknown appear in a possible world).\nDatabases represent sets of possible worlds. For a database I , we write W (I ) to denote the family of all possible worlds for I . Due to the absence of indefinite facts in W \u2208W (I ), every fact in At is either true (if it belongs to W\u21d3) or false (otherwise) w.r.t. W . Extending the notation we introduced earlier, for a possible world W and a \u2208 At we write W |= a if a \u2208W\u21d3 and W |= \u00aca, otherwise. The following proposition shows that the semantics of a database can be stated in terms of its possible worlds.\nProposition 1. Let I be a database and q a fact. Then q \u2208 I t if and only if W |= q, for every W \u2208 W (I ), and q \u2208 I f if and only if W |= \u00acq, for every W \u2208 W (I ).\nUpdating a database \u3008D,E\u3009 consists of executing on it update actions: inserting a base fact a into D or E , and deleting a base fact a from D or E . We denote them by +aD, +aE , \u2212aD and \u2212aE , respectively. For a set U of update actions, we define UD+ = {a |+a D \u2208U}, UE+ = {a |+a E \u2208U}, UD\u2212 = {a | \u2212a D \u2208U}, and UE\u2212 = {a | \u2212a E \u2208 U}. To be executable, a set U of update actions must not contain contradictory update\nactions: +aD and \u2212aD, or +aE and \u2212aE . A contradiction-free set U of update actions is an update. We denote the set of all updates (in the fixed language we consider) by U .\nWe now define the operation to update a database, that is, to apply an update to it.\nDefinition 4. Let I = \u3008D,E\u3009 be an indefinite database and U an update. We define I \u25e6U as the database \u3008D\u2032,E \u2032\u3009, where D\u2032 = (D\u222aUD+ )\\U D \u2212 and E \u2032 = (E \u222aUE+)\\U E \u2212 ."}, {"heading": "3 Indefinite Deductive Databases", "text": "Integrity constraints (ICs, for short) are first-order sentences in the language L determined by the set of predicates \u03a0 and by the set Domd of definite constants. A database with integrity constraints is a pair \u3008I ,\u03b7\u3009, where I is a database and \u03b7 is a set of ICs. Possible worlds can be regarded as interpretations of the language L with Domd as their domain. This observation and Proposition 1 suggest a definition of the semantics of databases with ICs.\nDefinition 5. Let \u3008I ,\u03b7\u3009 be a database with ICs. A possible world W \u2208 W (I ) is a possible world for a database \u3008I ,\u03b7\u3009 if W satisfies every integrity constraint in \u03b7 . We denote the set of possible worlds of \u3008I ,\u03b7\u3009 by W (I ,\u03b7). A database with ICs, \u3008I ,\u03b7\u3009, is consistent if W (I ,\u03b7) 6= /0. Otherwise, \u3008I ,\u03b7\u3009 is inconsistent.\nA fact q is true in \u3008I ,\u03b7\u3009 if W |= q, for every W \u2208 W (I ,\u03b7); q is false in \u3008I ,\u03b7\u3009 if W |= \u00acq, for every W \u2208 W (I ,\u03b7); otherwise, q is unknown in \u3008I ,\u03b7\u3009.\nExample 3. Let us consider the database I = \u3008{p(1), p(2),q(\u22a5)}, /0\u3009 (there are no exceptions) and let \u03b7 = {\u2200X(q(X)\u2192 p(X))}. Possible worlds of I include {p(1), p(2), q(1)}, {p(1), p(2), q(2)} and {p(1), p(2),q(3)}. The first two satisfy the integrity constraint, the third one does not. Thus, only the first two are possible worlds of \u3008I ,\u03b7\u3009. Since p(1) belongs to all possible worlds of \u3008I ,\u03b7\u3009, p(1) is true in \u3008I ,\u03b7\u3009. Further, p(3) is false in every possible world of I and so also in every possible world of \u3008I ,\u03b7\u3009. Thus, p(3) is false in \u3008I ,\u03b7\u3009. Lastly, we note that q(1) and q(2) are unknown in \u3008I ,\u03b7\u3009, while q(3) is false (due to p(3) being false and the integrity constraint).\nWe note that the possible-world semantics can capture additional information contained in integrity constraints. In Example 3, the semantics derives that q(3) is false in \u3008I ,\u03b7\u3009 even though this knowledge is not present in the database I .\nThe concepts of an update and of the operation to execute an update on a database extend literally to the case of databases with ICs.\nFollowing Ullman [16], views are safe Datalog\u00ac programs. We use the standard terminology and talk about (Datalog\u00ac) rules, and bodies and heads of rules. A rule is safe if each variable occurring in the head or in a negative literal in the body also occurs in a positive literal in the body. A Datalog\u00ac program is safe if each rule is safe. We assume that views do not contain occurrences of \u22a5. The semantics of Datalog\u00acprograms is given in terms of answer sets [6, 7]. A precise definition of that semantics is immaterial to our study and so we do not provide the details.\nDefinition 6. An indefinite deductive database (from now, simply, a deductive database) is a tuple D = \u3008I ,\u03b7 ,P\u3009, where I is a database, \u03b7 is a set of integrity constraints, and\nP is a safe Datalog\u00ac program (the specification of a view) such that no predicate occurring in the head of a rule in P is a base predicate.\nClearly, a deductive database with the empty view is a database with ICs, and a deductive database with the empty view and no ICs is simply a database.\nDefinition 7. A deductive database D = \u3008I ,\u03b7 ,P\u3009 is consistent if \u3008I ,\u03b7\u3009 is consistent and for every possible world W \u2208 W (I ,\u03b7), the program W \u222aP has answer sets. We denote the family of all those answer sets by W (D) or W (I ,\u03b7 ,P). We call elements of W (D) possible worlds of D .\nThere is an alternative to our concept of consistency. One could define a deductive database \u3008I ,\u03b7 ,P\u3009 as consistent if for at least one world W \u2208 W (I ,\u03b7), the program W \u222aP has an answer set. That concept of consistency would allow situations where for some possible worlds of \u3008I ,\u03b7\u3009, one of which could be a description of the real world, the view P does not generate any meaningful virtual database. Our concept of consistency is more robust. It guarantees that the user can have a view of a database no matter how the real world looks like, that is, which of the possible worlds describes it.\nExample 4. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database, where I = \u3008{p(\u22a5)}, /0\u3009, \u03b7 = /0 and P = {t \u2190 p(1), p(2),not t}, for some derived ground atom t. Every non-empty set W \u2286{p(u) |u\u2208 Domd} is a possible world of \u3008I ,\u03b7\u3009. In particular, the set {p(1), p(2)} is a possible world of \u3008I ,\u03b7\u3009. Since the program P\u222a{p(1), p(2)} has no answer sets, D is inconsistent (according to our definition). If D \u2032 = \u3008I ,{p(1)\u2227 p(2)\u2192 \u22a5},P\u3009, then the integrity constraint in D \u2032 eliminates the offending possible world and one can check that for every possible world W of \u3008I ,{p(1)\u2227 p(2)\u2192\u22a5}\u3009, P\u222aW has an answer set. Thus, D \u2032 is consistent.2\nThe concept of an update extends in a natural way to deductive databases. If U is an update, and D = \u3008I ,\u03b7 ,P\u3009, we define the result of updating D by U by D \u25e6U = \u3008I \u25e6U,\u03b7 ,P\u3009.\nNext, we define the semantics of a deductive database D = \u3008I ,\u03b7 ,P\u3009, again building on the characterization given by Proposition 1.\nDefinition 8. A fact a \u2208 At is true in a deductive database D = \u3008I ,\u03b7 ,P\u3009, denoted by D |= a, if for every possible world W \u2208 W (D), W |= a; a is false in D , denoted by D |= \u00aca, if for every W \u2208 W (D), W |= \u00aca; a is unknown in D , otherwise. We denote the truth value of a in D by vD(a).\nExample 5. Let Dom = {\u22a5,1,2,3} and D = \u3008I ,\u03b7 ,P\u3009 be a deductive database, where I = \u3008{p(\u22a5)}, /0\u3009, \u03b7 = {p(2)\u2192\u22a5} and P = {q(X)\u2190 p(X)}.\nWe have W (I ,\u03b7) = {{p(1)},{p(3)}, {p(1), p(3)}}. Each of the possible worlds in W (I ,\u03b7), when extended with the view P, gives rise to a program that has answer sets. Thus, D is consistent. Moreover, the possible worlds for D are {p(1),q(1)}, {p(3),q(3)} and {p(1),q(1), p(3),q(3)} (in this case, one for each possible world in W (I ,\u03b7)). It follows that p(\u22a5) and q(\u22a5) are true, p(2) and q(2) are false, and p(1),q(1), p(3) and q(3) are unknown in D .\n2 We point out that in the paper, we overload the notation \u22a5. We use it to denote both the single null value in the language and the falsity symbol in the first-order language used for integrity constraints. Since the meaning is always clear from the context, no ambiguity arises."}, {"heading": "4 View Updating", "text": "In the view update problem, the user specifies a request, a list of facts the user learned (observed) to be true or false, and wants the stored database to be updated to reflect it.3\nDefinition 9. A request over a deductive database D is a pair S = (S t ,S f ), where S t and S f are disjoint sets of facts requested to be true and false, respectively.\nTo fulfill a request we need an update which, when executed, yields a database such that the view it determines satisfies the request. We call such updates weak repairs.\nDefinition 10. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database and S a request. An update U for I is a weak repair for (D ,S ) if U fulfills S , that is, if for every a \u2208 S t , vD\u25e6U (a) = true and for every a \u2208 S f , vD\u25e6U (a) = false.\nWe are primarily interested in updates that do not drastically change the database. One condition of being \u201cnon-drastic\u201d is not to introduce new predicate or constant symbols. That leads us to the notion of a relevant weak repair.\nDefinition 11. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database and S a request. A constant is relevant with respect to D and S if it occurs in D , or S , or if it is \u22a5. A predicate is relevant with respect to D and S if it occurs in D or in S . A weak repair U for (D ,S ) is relevant if every constant and predicate occurring in U is relevant.\nMore generally, a weak repair is \u201cnon-drastic\u201d if it minimizes the change it incurs [14]. There are two aspects to the minimality of change: (1) minimizing the set of new predicate symbols and constants introduced by an update to the database (in the extreme case, no new symbols must be introduced, and we used that requirement to define relevant weak repairs above); (2) minimizing the change in the truth values of facts with respect to the database. Following the Ockham\u2019s Razor principle to avoid introducing new entities unless necessary, we take the minimality of the set of new symbols as a primary consideration. To define the resulting notion of change minimality, we assume that the truth values are ordered false \u2264 unknown \u2264 true. Further, for a deductive database D , a request set S and an update U \u2208 U we define NC(D ,S ,U) as the set of non nullary constants that occur in U and not in D and S .\nDefinition 12. Let D = \u3008I ,\u03b7\u3009 be a database with integrity constraints. For updates V,U \u2208 U , we define U \u2291 V if: NC(D ,S ,U) \u2282 NC(D ,S ,V ), or NC(D ,S ,U) = NC(D ,S ,V ) and for every base atom a\n1. if vD(a) = true, then vD\u25e6U (a)\u2265 vD\u25e6V (a) 2. if vD(a) = false, then vD\u25e6V (a)\u2265 vD\u25e6U (a) 3. if vD(a) = unknown, then vD\u25e6U (a) = unknown or vI \u25e6V (a) = vD\u25e6U (a).\nWe also define U \u228fV if U \u2291V and V 6\u2291U.\n3 We do not allow requests that facts be unknown. That is, we only allow definite requests. While there may be situations when all the user learns about the fact is that it is unknown, they seem to be rather rare. In a typical situation, the user will learn the truth or falsity of a fact.\nWe now define the classes of repairs and relevant repairs as subclasses of the respective classes of weak repairs consisting of their \u2291-minimal elements.\nDefinition 13. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database and S a request. A (relevant) repair for (D ,S ) is a \u2291-minimal (relevant) weak repair for (D ,S ).\nWe note that the existence of (weak) repairs does not guarantee the existence of relevant (weak) repairs. The observation remains true even if the view is empty.\nExample 6. Let D = \u3008I ,\u03b7 ,P\u3009, where I = \u3008 /0, /0\u3009, \u03b7 = /0 and P = {t \u2190 p(x),q(x)}. If the request is ({t}, /0), then each repair is of the form {+p(i)D, +q(i)D}, for some i \u2208 Domd . None of them is relevant. (We note that {+p(\u22a5)D,+q(\u22a5)D} is not a (weak) repair. The database resulting from the update would admit possible worlds of the form {p(i),q( j)}, where i 6= j. Clearly, the corresponding possible world of the view over any such database does not contain t and so the update does not fulfill the request.)\nSome relevant constants are not \u201cforced\u201d by the database and the request, that is, can be replaced by other constants. If such constants are present in a relevant (weak) repair, this repair is arbitrary. Otherwise, it is constrained. A formal definition follows.\nDefinition 14. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database and S a request. A relevant (weak) repair U for (D ,S ) is constrained if there is no non-nullary constant a in U such that replacing some occurrences of a in U with a constant b 6= a (b might be \u22a5), results in a weak repair for (D ,S ).\nExample 7. Let D = \u3008I ,\u03b7 ,P\u3009, where I = \u3008{p(1),h(2)}, /0\u3009, \u03b7 = /0 and P = {t \u2190 p(X),q(X); s \u2190 r(X)}. Let us consider the request S = ({s, t}, /0). The updates Ri = {+q(1)D,+r(i)D}, i \u2208 {\u22a5,1,2}, and R \u2032i = {+q(2)\nD,+p(2)D,+r(i)D}, i \u2208 {\u22a5,1,2}, are relevant weak repairs. One of them, R\u22a5, is constrained. Indeed, replacing in R\u22a5 the unique occurrence of a non-nullary constant (in this case, 1) with any other constant does not yield a weak repair. On the other hand, Ri, i \u2208 {1,2}, and R \u2032i , i \u2208 {\u22a5,1,2}, are not constrained. Indeed, replacing with 3 the second occurrence of 1 in R1, or the occurrence of 2 in R2, or both occurrences of 2 in R \u2032i in each case results in a weak repair. Also weak repairs Ri = {+q(1)D,+r(i)D} and R \u2032i = {+q(2)\nD,+p(2)D,+r(i)D}, i \u2208 {3, . . .}, are not constrained as they are not even relevant.\nWe stress that, in order to test whether a relevant (weak) repair R is constrained, we need to consider every subset of occurrences of non-nullary constants in R. For instance, in the case of the repair R1 = {q(1),r(1)} from Example 7, the occurrence of the constant 1 in q(1) is constrained by the presence of p(1). Replacing that occurrence of 1 with 3 does not result in a weak repair. However, replacing the occurrence of 1 in r with 3 gives a weak repair and shows that R1 is not constrained.\nExample 8. Let Dom= {\u22a5,1,2, . . .} and D = \u3008I ,\u03b7 ,P\u3009, where I = \u3008{q(1,2),s(1,2,3)}, /0\u3009, \u03b7 = /0 and P = {p(X)\u2190 q(X ,Y ),r(X ,Y,Z); r(X ,Y,Z)\u2190 s(X ,Y,Z), t(X ,Y,Z)}. Let us consider the request S = ({p(1)}, /0). In this case, our approach yields a unique constrained repair R = {+t(1,2,3)D}. It recognizes that thanks to s(1,2,3) simply inserting t(1,2,3) guarantees r(1,2,3) to be true and, consequently, ensures the presence of p(1) in the view. There are other repairs and other relevant repairs, but only the one listed above is constrained.\nWe observe that every (relevant, constrained) weak repair contains a (relevant, constrained) repair.\nProposition 2. Let D = \u3008I ,\u03b7 ,P\u3009 be a deductive database and S a request. A (relevant, constrained) repair for (D ,S ) exists if and only if a (relevant, constrained) weak repair for (D ,S ) exists."}, {"heading": "5 Complexity", "text": "Finally, we discuss the complexity of decision problems concerning the existence of (weak) repairs of types introduced above. The results we present here have proofs that are non-trivial despite rather strong assumptions we adopted. We present them in the appendix.\nWe assume that the sets of base and derived predicate symbols, the set of integrity constraints \u03b7 and the view P are fixed. The only varying parts in the problems are a database I and a request S . That is, we consider the data complexity setting. Moreover, we assume that Dom = {\u22a5,1,2, . . .}, and take = and \u2264, both with the standard interpretation on {1,2, . . .}, as the only built-in relations. We restrict integrity constraints to expressions of the form: \u2203X(\u2200Y (A1 \u2227 . . .\u2227Ak \u2192 B1 \u2228 . . .\u2228Bm)), where Ai and Bi are atoms with no occurrences of \u22a5 constructed of base and built-in predicates, and where every variable occurring in the constraint belongs to X \u222aY , and occurs in some atom Ai built of a base predicate.\nWe start by stating the result on the complexity of deciding the consistency of an indefinite database with integrity constraints. While interesting in its own right, it is also relevant to problems concerning the existence of repairs, as one of the conditions for U to be a repair is that the database that results from executing U be consistent.\nTheorem 1. The problem to decide whether a database \u3008I ,\u03b7\u3009 has a possible world (is consistent) is NP-complete.\nWe now turn attention to the problem of checking request satisfaction. Determining the complexity of that task is a key stepping stone to the results on the complexity of deciding whether updates are (weak) repairs that are necessary for our results on the complexity of the existence of (weak) repairs. However, checking request satisfaction turns out to be a challenge even for very simple classes of views. In this paper, we restrict attention to the case when P is a safe definite (no constraints) acyclic (no recursion) Horn program, although we obtained Proposition 3 in a more general form.\nProposition 3. The problem to decide whether a ground atom t is true in a deductive database \u3008I ,\u03b7 ,P\u3009, where \u3008I ,\u03b7\u3009 is consistent and P is a safe Horn program, is in the class co-NP.\nNext, we consider the problem to decide whether a ground atom t is false in a deductive database \u3008I ,\u03b7 ,P\u3009. We state it separately from the previous one as our present proof of that result requires the assumption of acyclicity.\nProposition 4. The problem to decide whether a ground atom t is false (ground literal \u00act is true) in a deductive database \u3008I ,\u03b7 ,P\u3009, where \u3008I ,\u03b7\u3009 is consistent and P is an acyclic Horn program, is in the class co-NP.\nWith Propositions 3 and 4 in hand, we move on to study the complexity of the problems of the existence of weak repairs. First, we establish an upper bound on the complexity of checking whether and update is a (relevant) weak repair.\nProposition 5. Let D = \u3008I ,\u03b7 ,P\u3009, where \u03b7 is a set of integrity constraints, P an acyclic Horn program, U an update and S a request set. The problem of checking whether an update U is a weak repair (relevant weak repair) for (D ,S ) is in \u2206 P2 .\nWith the results above, we can address the question of the complexity of the existence of repairs. The first problem concerns weak repairs and stands apart from others. It turns out, that deciding the existence of a weak repair is NP-complete, which may seem at odds with Proposition 5 (an obvious non-deterministic algorithm guesses an update U and checks that it is a weak repair apparently performing a \u201c\u03a3P2 computation\u201d). However, this low complexity of the problem is simply due to the fact that there are no relevance, constrainedness or minimality constraints are imposed on weak repairs. Thus, the question can be reduced to the question whether there is a \u201csmall\u201d database J , in which the request holds. The corresponding weak repair consists of deleting all elements from I and \u201crepopulating\u201d the resulting empty database so that to obtain J .\nTheorem 2. Let D = \u3008I ,\u03b7 ,P\u3009, where \u03b7 is a set of integrity constraints, and P an acyclic Horn program, and let S be a request set. The problem of deciding whether there is a weak repair for (D ,S ) is NP-complete.\nAs noted, the case of the existence of weak repairs is an outlier and deciding the existence of (weak) repairs of other types is much harder (under common assumptions concerning the polynomial hierarchy).\nTheorem 3. Let D = \u3008I ,\u03b7 ,P\u3009, where \u03b7 is a set of integrity constraints, and P an acyclic Horn program, and let S be a request set. The problems of deciding whether there is a relevant weak repair and whether there is a relevant repair for (D ,S ) are \u03a3P2 -complete.\nThe last result concerns constrained (weak) repairs. It provides an upper bound on the complexity of the problem of deciding the existence of constrained repairs. We conjecture that the upper bound is in fact tight but have not been able to prove it. We leave the problem for future work.\nTheorem 4. Let D = \u3008I ,\u03b7 ,P\u3009, where \u03b7 is a set of integrity constraints, and P an acyclic Horn program, and let S be a request set. The problems of deciding whether there is a constrained weak repair and whether there is a constrained repair for (D ,S ) are in \u03a3P3 ."}, {"heading": "6 Discussion and conclusion", "text": "We presented a declarative framework for view updating and integrity constraint maintenance for indefinite databases. The framework is based on the notion of an indefinite deductive database. In our approach, the indefiniteness appears in the extensional\ndatabase and is modeled by a single null value, consistent with the standards of database practice (a condition not followed by earlier works on the view-update problem over indefinite databases). We defined a precise semantics for indefinite deductive databases in terms of possible worlds. We used the framework to formulate and study the viewupdate problem. Exploiting the concept of minimality of change introduced by an update, we defined several classes of repairs, including relevant and constrained repairs, that translate an update request against a view into an update of the underlying database. Finally, we obtained several complexity results concerning the existence of repairs.\nOur paper advances the theory of view updating in three main ways. First, it proposes and studies the setting where extensional databases are indefinite both before and after an update. While introducing indefiniteness to narrow down the class of potential repairs was considered before [5], the assumption there was that the initial extensional database was complete. That assumption substantially limits the applicability of the earlier results. Second, our paper proposes a more expressive model of an indefinite extensional database. In our model databases are determined by two sets of facts. The first set of facts specifies what is true and provides an upper bound to what might still be unknown. By CWA, everything else is false. The second set of facts lists exceptions to the \u201cunknown range,\u201d that is, facts that according to the first set might be unknown but are actually false (exceptions). Third, our paper introduces two novel classes or repairs, relevant and constrained, that often substantially narrow down possible ways to fulfill an update request against a view. Relevant repairs do not introduce any new constants and minimize change. Constrained repairs in addition do not involve constants that are in some precise sense \u201creplaceable\u201d and, thus, not grounded in the problem specification.\nWe already discussed some earlier work on view updating in the introduction as a backdrop to our approach. Expanding on that discussion, we note that the view-update problem is closely related to abduction and is often considered from that perspective. Perhaps the first explicit connection between the two was made by Bry [1] who proposed to use deductive tools as a means for implementing the type of abductive reasoning required in updating views. That idea was pursued by others with modifications that depended on the class and the semantics of the views. For instance, Kakas and Mancarella [9] exploited in their work on view updates the abductive framework by Eshghi and Kowalski [4] and were the first to consider the stable-model semantics for views. Neither of the two works mentioned above was, however, concerned with the case of updates to views over indefinite databases. Console et al. [2] studied the case in which requests can involve variables. These variables are replaced by null values and, in this way, null values eventually end up in repaired databases. However, once there, they loose their null value status and are treated just as any other constants. Consequently, no reasoning over null values takes place, in particular, they have no special effect on the notion of minimality. None of the papers discussed studied the complexity of the view-update problem. Instead, the focus was on tailoring resolution-based deductive reasoning tools to handle abduction. Some results on the complexity of abduction for logic programs were obtained by Eiter, Gottlob and Leone [3]. However, again the setting they considered did not assume incompleteness in extensional databases.\nOur paper leaves several interesting questions for future work. First, we considered restricted classes of views. That suggests the problem to extend our complexity\nresults to the full case of Horn programs and, later, stratified ones. Next, we considered a limited class of integrity constraints. Importantly, we disallowed tuple-generating constraints. However, once they are allowed, even a problem of repairing consistency in an extensional database becomes undecidable. A common solution in the database research is to impose syntactic restrictions on the constraints [8]. That suggests considering view-updating in the setting in which only restricted classes of constraints are allowed."}, {"heading": "Acknowledgments", "text": "The third author was supported by the NSF grant IIS-0913459. We are grateful to Sergio Greco and Leopoldo Bertossi for helpful discussions."}], "references": [{"title": "Intensional updates: Abduction via deduction", "author": ["Fran\u00e7ois Bry"], "venue": "In Proceedings of ICLP", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1990}, {"title": "The role of abduction in database view updating", "author": ["Luca Console", "Maria Luisa Sapino", "Daniele Theseider Dupr\u00e9"], "venue": "J. Intell. Inf. Syst.,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1995}, {"title": "Abduction from logic programs: Semantics and complexity", "author": ["Thomas Eiter", "Georg Gottlob", "Nicola Leone"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1997}, {"title": "Abduction compared with negation by failure", "author": ["K. Eshghi", "R.A. Kowalski"], "venue": "In Proceedings of ICLP", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1989}, {"title": "Handling existential derived predicates in view updating", "author": ["Carles Farr\u00e9", "Ernest Teniente", "Toni Urp\u0131"], "venue": "In Proceedings of ICLP 2003,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "In Proceedings of ICLP/SLP", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "New Generation Comput.,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1991}, {"title": "Stratification criteria and rewriting techniques for checking chase termination", "author": ["Sergio Greco", "Francesca Spezzano", "Irina Trubitsyna"], "venue": "PVLDB, 4(11):1158\u20131168,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Database updates through abduction", "author": ["A.C. Kakas", "P. Mancarella"], "venue": "In Proceedings of the sixteenth international conference on Very large databases,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1990}, {"title": "A semantics-based approach to design of query languages for partial information", "author": ["Leonid Libkin"], "venue": "In Semantics in Databases,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1995}, {"title": "Consistency preserving updates in deductive databases", "author": ["Enric Mayol", "Ernest Teniente"], "venue": "IEEE TDKE,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "On closed world data bases", "author": ["R. Reiter"], "venue": "Logic and data bases,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1978}, {"title": "Updating knowledge bases while maintaining their consistency", "author": ["Ernest Teniente", "Antoni Oliv\u00e9"], "venue": "VLDB J.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1995}, {"title": "Automatic constraint maintenance and updating defined relations", "author": ["Stephen Todd"], "venue": "In IFIP Congress,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1977}, {"title": "Semantic integrity support in sql: 1999 and commercial (object-)relational database management systems", "author": ["Can T\u00fcrker", "Michael Gertz"], "venue": "VLDB J.,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2001}, {"title": "Principles of Database and Knowledge-Base Systems, Volume I", "author": ["Jeffrey D. Ullman"], "venue": "Computer Science Press,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1988}], "referenceMentions": [{"referenceID": 8, "context": "Thus, developing methods to automate the selection process or, at least, aid the user in making the choice is essential and has been one of the central problems of view updating [9, 2, 13, 11].", "startOffset": 178, "endOffset": 192}, {"referenceID": 1, "context": "Thus, developing methods to automate the selection process or, at least, aid the user in making the choice is essential and has been one of the central problems of view updating [9, 2, 13, 11].", "startOffset": 178, "endOffset": 192}, {"referenceID": 12, "context": "Thus, developing methods to automate the selection process or, at least, aid the user in making the choice is essential and has been one of the central problems of view updating [9, 2, 13, 11].", "startOffset": 178, "endOffset": 192}, {"referenceID": 10, "context": "Thus, developing methods to automate the selection process or, at least, aid the user in making the choice is essential and has been one of the central problems of view updating [9, 2, 13, 11].", "startOffset": 178, "endOffset": 192}, {"referenceID": 4, "context": "[5], where the terminology of Skolem constants rather than null values was used.", "startOffset": 0, "endOffset": 3}, {"referenceID": 14, "context": "First, the use of multiple Skolem constants (essentially, multiple null values) violates the SQL standard [15].", "startOffset": 106, "endOffset": 110}, {"referenceID": 9, "context": "We denote it by \u22a5 and interpret it as expressing the existence of unknown values for each attribute it is used for [10].", "startOffset": 115, "endOffset": 119}, {"referenceID": 11, "context": "The semantics of such databases is given by the closed-world assumption or CWA [12]: a definite fact q is true in a database D if q \u2208 D.", "startOffset": 79, "endOffset": 83}, {"referenceID": 9, "context": "By CWA adapted for the setting of indefinite databases [10], facts that are not in D\u21d3 are not true in D, as D contains no evidence to support their truth.", "startOffset": 55, "endOffset": 59}, {"referenceID": 15, "context": "Following Ullman [16], views are safe Datalog\u00ac programs.", "startOffset": 17, "endOffset": 21}, {"referenceID": 5, "context": "The semantics of Datalogprograms is given in terms of answer sets [6, 7].", "startOffset": 66, "endOffset": 72}, {"referenceID": 6, "context": "The semantics of Datalogprograms is given in terms of answer sets [6, 7].", "startOffset": 66, "endOffset": 72}, {"referenceID": 13, "context": "More generally, a weak repair is \u201cnon-drastic\u201d if it minimizes the change it incurs [14].", "startOffset": 84, "endOffset": 88}, {"referenceID": 4, "context": "While introducing indefiniteness to narrow down the class of potential repairs was considered before [5], the assumption there was that the initial extensional database was complete.", "startOffset": 101, "endOffset": 104}, {"referenceID": 0, "context": "Perhaps the first explicit connection between the two was made by Bry [1] who proposed to use deductive tools as a means for implementing the type of abductive reasoning required in updating views.", "startOffset": 70, "endOffset": 73}, {"referenceID": 8, "context": "For instance, Kakas and Mancarella [9] exploited in their work on view updates the abductive framework by Eshghi and Kowalski [4] and were the first to consider the stable-model semantics for views.", "startOffset": 35, "endOffset": 38}, {"referenceID": 3, "context": "For instance, Kakas and Mancarella [9] exploited in their work on view updates the abductive framework by Eshghi and Kowalski [4] and were the first to consider the stable-model semantics for views.", "startOffset": 126, "endOffset": 129}, {"referenceID": 1, "context": "[2] studied the case in which requests can involve variables.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "Some results on the complexity of abduction for logic programs were obtained by Eiter, Gottlob and Leone [3].", "startOffset": 105, "endOffset": 108}, {"referenceID": 7, "context": "A common solution in the database research is to impose syntactic restrictions on the constraints [8].", "startOffset": 98, "endOffset": 101}], "year": 2013, "abstractText": "This paper introduces and studies a declarative framework for updating views over indefinite databases. An indefinite database is a database with null values that are represented, following the standard database approach, by a single null constant. The paper formalizes views over such databases as indefinite deductive databases, and defines for them several classes of database repairs that realize view-update requests. Most notable is the class of constrained repairs. Constrained repairs change the database \u201cminimally\u201d and avoid making arbitrary commitments. They narrow down the space of alternative ways to fulfill the view-update request to those that are grounded, in a certain strong sense, in the database, the view and the view-update request.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}