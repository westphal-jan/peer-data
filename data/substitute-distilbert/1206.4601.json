{"id": "1206.4601", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jun-2012", "title": "Convex Multitask Learning with Flexible Task Clusters", "abstract": "traditionally, multitask learning ( mtl ) assumes that all the tasks structurally related. this can lead to negative transfer when tasks are indeed incoherent. recently, a number of suggestions have been proposed that alleviate this problem as discovering the underlying task clusters or relationships. however, they lack limited to modeling these relationships at the task level, which may be restrictive in some applications. in this paper, we propose a novel mtl theory that gives task relationships achieving common feature - level. holding on the interactions among tasks required features, the proposed method construct different task clusters for different features, covering even the need of pre - specifying the number possible clusters. computationally, whatever proposed formulation is strongly convex, and can be efficiently proved by accelerated proximal methods. experiments are performed on a number of synthetic and real - looking knowledge sets. under various cases of task relationships, the accuracy of every proposed method is consistently among the best. moreover, the feature - specific task units obtained agree with the known / virtual task structures of the data.", "histories": [["v1", "Mon, 18 Jun 2012 14:40:55 GMT  (3237kb)", "http://arxiv.org/abs/1206.4601v1", "ICML2012"]], "COMMENTS": "ICML2012", "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["wenliang zhong", "james tin-yau kwok"], "accepted": true, "id": "1206.4601"}, "pdf": {"name": "1206.4601.pdf", "metadata": {"source": "CRF", "title": "Convex Multitask Learning with Flexible Task Clusters", "authors": ["Leon Wenliang Zhong", "James T. Kwok"], "emails": ["WZHONG@CSE.UST.HK", "JAMESK@CSE.UST.HK"], "sections": [{"heading": "1. Introduction", "text": "Many real-world problems involve the learning of a number of tasks. Instead of learning them individually, it is now well-known that better generalization performance can be obtained by harnessing the intrinsic task relationships and allowing tasks to borrow strength from each other. In recent years, a number of techniques have been developed under this multitask learning (MTL) framework.\nTraditional MTL methods assume that all the tasks are related (Evgeniou & Pontil, 2004; Evgeniou et al., 2005).\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nHowever, when this assumption does not hold, the performance can be even worse than single-task learning. If it is known that the tasks are clustered, a simple remedy is to constrain task sharing to be just within the same cluster (Argyriou et al., 2008; Evgeniou et al., 2005). This can be further extended to the case where task relationships are represented in the form of a network (Kato et al., 2007). However, in practice, such an explicit knowledge of task clusters/network is rarely available.\nRecently, by adopting different modeling assumptions, a number of approaches have been proposed that identify task relationships simultaneously with parameter learning. For example, some assume that the task parameters share a common prior in a Bayesian model (Yu et al., 2005; Zhang & Schneider, 2010; Zhang & Yeung, 2010); that the data follows a dirty model (Jalali et al., 2010); that most of the tasks lie in a low-dimensional subspace (Ando & Zhang, 2005; Chen et al., 2010), or that outlier tasks are present (Chen et al., 2011a). In this paper, we will mainly be interested in techniques that assume the tasks are clustered (Argyriou et al., 2008; Evgeniou et al., 2005), and then infer the clustering structure automatically during learning (Jacob et al., 2008; Kang et al., 2011). Interestingly, it is recently shown that this clustered MTL approach is equivalent to alternating structure optimization (Ando & Zhang, 2005) that assumes the tasks share a low-dimensional structure (Zhou et al., 2011).\nHowever, all the existing methods model the task relationships at the task level, and the features are assumed to always observe the same set of task clusters or covariance structure (Figure 1(a)). This may be restrictive in some real-world applications. For example, in recommender systems, each customer corresponds to a task and each feature a movie attribute. Suppose that we have a relatively coherent group of customers, such as Jackie Chan fans who are interested in action comedy movies (Figure 1(b)). On the \u201clanguage\u201d attribute, however, some of them may prefer English, some prefer standard Chinese (Putonghua/Mandarin), some prefer Cantonese or even a combination of these. Hence, the clustering structure as seen by this feature is very different from those of the oth-\ners. Another example is when the features are obtained by some feature extraction algorithm (such as PCA) and so have different discrimination abilities. While the less discriminating features may be used in a similar manner by all the tasks, highly discriminating features may be very class-specific and are used differently by different tasks (Figure 1(c)). Hence, again, these features may observe different task relationships. This phenomenon will also be demonstrated in the experiments in Section 3.\nIn this paper, we extend clustered MTL such that the task cluster structure can vary from feature to feature. This is thus more fine-grained than existing MTL methods that only capture task-level (but not feature-level) relationships. Moreover, a key difference with (Jacob et al., 2008) is that we do not require the number of clusters to be pre-specified. Indeed, depending on the complexity of the tasks and usefulness of each feature, different numbers of clusters can be formed for different features.\nComputationally, the optimization problem is often challenging in clustered MTL algorithms. For example, in (Kang et al., 2011), it leads to a mixed integer program, which has to be relaxed as a nonlinear optimization problem and then solved by gradient descent. This suffers from the local minimum problem and potentially slow convergence. On the other hand, the proposed approach directly leads to a (strongly) convex optimization problem, which can then be efficiently solved by accelerated proximal methods (Nesterov, 2007) after some transformations.\nNotation: Vector/matrix transpose is denoted by the superscript \u2032, \u2016A\u2016F = \u221a trace(A\u2032A) is the Frobenius norm of matrix A, Ai\u00b7 is its ith row and A\u00b7j its jth column."}, {"heading": "2. The Model", "text": "Suppose that there are T tasks. The tth task has nt training samples {(x(t)1 , y (t) 1 ), . . . , (x (t) nt , y (t) nt )}, with input x (t) i \u2208 RD and output y(t)i \u2208 R. We stack the inputs and outputs together to form matrices X(t) = [x(t)1 , . . . ,x (t) nt ] \u2032 and y(t) = [y (t) 1 , . . . , y (t) nt ] \u2032, respectively. A linear model is used to learn each task. Let the weight associated with task t be wt. The predictions on the nt samples are stored in the vector X(t)wt."}, {"heading": "2.1. Simultaneous Clustering of Task Parameters", "text": "We decompose each wt into ut+vt, where ut tries to capture the shared clustering structure among task parameters, and vt captures variations specific to each task. Learning of wt\u2019s is performed jointly with the clustering of ut\u2019s via the following regularized risk minimization problem:\nminU,V T\u2211 t=1 \u2016y(t) \u2212X(t)(ut + vt)\u20162 + \u03bb1\u2016U\u2016clus\n+\u03bb2\u2016U\u20162F + \u03bb3\u2016V\u20162F , (1)\nwhere U = [u1, . . . ,uT ] and V = [v1, . . . ,vT ], and \u03bb1, \u03bb2, \u03bb3 are regularization parameters. The first term in (1) is the empirical (squared) loss on the training data, and \u2016U\u2016clus is the sum of pairwise differences for elements in each row of U,\n\u2016U\u2016clus = D\u2211 d=1 \u2211 i<j |Udi \u2212 Udj |. (2)\nFor each feature d and each (ui,uj) pair, the pairwise penalty in \u2016U\u2016clus encourages Udi, Udj to be close together, leading to feature-specific task clusters. It can also be shown that \u2016U\u2016clus is a convex relaxation of k-means clustering on each feature. Note that this is different from the fused lasso regularizer (Tibshirani et al., 2005), which is used for clustering features in single-task learning while \u2016U\u2016clus is for clustering tasks in MTL. It is also different from the graph-guided fused lasso (GFlasso) (Chen et al., 2011b), which does not decompose wt as ut + vt, and subsequently cannot cluster the tasks due to the use of smoothing. The regularizer \u2016V\u20162F = \u2211T t=1 \u2016vt\u20162 penalizes the deviations of each wt from ut, and \u2016U\u20162F is the usual ridge regularizer penalizing U\u2019s complexity. Since \u2016U\u20162F , \u2016V\u20162F are strongly convex and the other terms in (1) are convex, (1) is a strongly convex optimization problem.\nSome MTL papers also decompose wt as ut + vt, but the formulations and goals are different from ours. In (Evgeniou et al., 2005), ut is the (single) cluster center of all the tasks; in (Ando & Zhang, 2005; Chen et al., 2010; 2011a),\nut comes from a low-dimensional linear subspace, which is extended to a nonlinear manifold in (Agarwal et al., 2010); in (Jalali et al., 2010), ut is the component that uses features shared by other tasks.\nMoreover, model (1) encompasses a number of interesting special cases: (i) \u03bb1 \u2192 \u221e:1 For each d, all Udt\u2019s become the same. Thus, wt reduces to u\u0304 + vt for some \u201cmean weight\u201d u\u0304, and (1) reduces to the model in (Evgeniou et al., 2005). (ii) \u03bb1 = 0: The following Proposition shows that (1) reduces to independent ridge regression on each task. Proposition 1. When \u03bb1 = 0, model (1) reduces to minwt \u2016y(t) \u2212X(t)wt\u20162 + \u03bb2\u03bb3\u03bb2+\u03bb3 \u2016wt\u2016 2, t = 1, . . . , T .\n(iii) \u03bb2 6= 0, \u03bb3 = 0: Since ut is penalized while vt is not, ut will become zero at optimality, irrespective of the value of \u03bb1. Thus, (1) reduces to independent least squares regression on each task: minwt \u2016y(t) \u2212 X(t)wt\u20162. Obviously, this is the same as setting \u03bb1 = \u03bb2 = \u03bb3 = 0."}, {"heading": "2.2. Properties", "text": "Denote the optimal solution in (1) by (U\u2217,V\u2217), and let W\u2217 \u2261 U\u2217 + V\u2217. The following Proposition shows that if tasks i and j have similar weights on feature d, the corresponding U\u2217 entries are clustered together. On the other hand, for an outlier task t, its ut component is separated from the main group. Proposition 2. If |W \u2217di \u2212W \u2217dj | < \u03bb1 \u03bb3 , then U\u2217di = U \u2217 dj . If |W \u2217di \u2212W \u2217dj | > (T \u2212 1) \u03bb1 \u03bb3 , then U\u2217di 6= U\u2217dj .\nFor simplicity, all T tasks are assumed to have the same number of training instances n. Assume that the data for task t is generated as y(t) = X(t)w\u0306t + , where \u223c N (0, \u03c32I) is the i.i.d. Gaussian noise, and \u2016X(t)\u00b7i \u2016 \u2264 \u221a 2n. The following Theorem shows that, with high probability, W\u2217 is close to the ground truth W\u0306 = [w\u03061, . . . , w\u0306T ] w.r.t. the elementwise `\u221e-error \u2016W\u0306 \u2212 W\u2217\u2016\u221e,\u221e = maxd=1,...,D maxt=1,...,T |W\u0306dt \u2212 Wdt|. Moreover, when all the tasks are identical, the shared clustering component U\u2217 is close to W\u0306; and V\u2217, the deviation from the cluster center, goes to zero.\nTheorem 1. 1. \u2016W\u0306 \u2212 W\u2217\u2016\u221e,\u221e \u2264 c1 \u221a \u039b\u0303max\u03c32\nn + C\nholds with probability at least 1\u22122 exp(\u2212c2 log(DT )) for any c1 > \u221a (1 + c2) log(DT ) and c2 > 0. Here, \u039b\u0303max = maxt \u039b\u0303 (t) max with \u039b\u0303 (t) max being an upper bound on the eigen-\nvalue of \u03a3(t) = (\n1 nX (t)\u2032X(t) + \u03bb2\u03bb32n(\u03bb2+\u03bb3)I )\u22121 , and C =\nmaxt\n( \u03bb2\u03bb3\n2n(\u03bb2+\u03bb3) \u2225\u2225\u2225\u03a3(t)W\u0306\u00b7t\u2225\u2225\u2225 \u221e + (T\u22121)\u03bb1\u03bb32n(\u03bb2+\u03bb3) \u2225\u2225\u03a3(t)\u2225\u2225\u221e,1).\nIf n \u2192 \u221e, 1nX (t)\u2032X(t) \u2192 C(t) where C(t) is a posi-\ntive definite matrix, and \u03bb1, \u03bb2, \u03bb3 = O( \u221a n), then\n1Indeed, \u03bb1 is only required to be sufficiently large. The precise statement is in Proposition 2.\n\u03a3(t) \u2192 [C(t)]\u22121 and \u2016W\u2217 \u2212 W\u0306\u2016\u221e,\u221e \u2264 O (\n1\u221a n\n) with\narbitrary high probability.\n2. When all tasks are identical (i.e., w\u03061 = \u00b7 \u00b7 \u00b7 = w\u0306T and C(1) = \u00b7 \u00b7 \u00b7 = C(T )), \u03bb3\u03bb2 \u2192 \u221e and \u03bb1 \u2192\n\u221e, we have \u2016W\u2217 \u2212 W\u0306\u2016\u221e,\u221e \u2264 c\u03021 \u221a \u039b\u0302max\u03c32\nnT + C\u0302\nand \u2016V\u2016\u221e,\u221e \u2192 0 hold with probability at least 1 \u2212 2 exp(\u2212c\u03022 logD) for any c\u03021 > \u221a 2(1 + c\u03022) log(D) and c\u03022 > 0. Here, \u039b\u0302max is an upper bound on the eigen-\nvalue of \u03a3\u0302 =  1nT X (1)\n... X(T )\n \u2032 X (1)\n... X(T )\n+ \u03bb22nI  \u22121 , and\nC\u0302 = \u03bb22n \u2225\u2225\u2225\u03a3\u0302W\u0306\u00b71\u2225\u2225\u2225 \u221e + o(1). If n \u2192 \u221e, \u03bb1, \u03bb3 = O(n2) and \u03bb2 = O( \u221a n), then \u2016W\u2217\u2212W\u0306\u2016\u221e,\u221e \u2264 O ( 1\u221a nT ) with arbitrary high probability.\nMoreover, the following Corollary shows that the underlying clustering structure can be exactly recovered when n is sufficiently large.\nCorollary 1. Suppose that for any feature d, W\u0306di = W\u0306dj if i, j are in the same cluster; and |W\u0306di \u2212 W\u0306dj | \u2265 \u03c1 otherwise. Assume that 12 \u2225\u2225\u2225\u03a3(t)W\u0306\u00b7t\u2225\u2225\u2225 \u221e \u2264\nC1 and T\u221212 \u2225\u2225\u03a3(t)\u2225\u2225\u221e,1 \u2264 C2. Then for n \u2265[\n2T \u03c1 ( c1 \u221a \u039b\u0303max\u03c32 + k2k3C1 k2+k3 + k1k3C2k2+k3 )]2 , where \u03bb1 =\nk1 \u221a n, \u03bb2 = k2 \u221a n, \u03bb3 = k3 \u221a n and k1k3 = \u03c1 T , we have U\u2217di = U \u2217 dj if i, j are in the same cluster; and U\u2217di 6= U\u2217dj otherwise, with probability at least 1 \u2212 2 exp(\u2212c2 log(DT )) for any c1 > \u221a (1 + c2) log(DT ) and c2 > 0."}, {"heading": "2.3. Optimization via Accelerated Proximal Method", "text": "In recent years, accelerated proximal methods (Nesterov, 2007) have been popularly used by the machine learning community (Bach et al., 2011) for convex problems of the form min\u03b8 f(\u03b8)+r(\u03b8), where f(\u03b8) is convex and smooth, and r(\u03b8) is convex but nonsmooth. The convergence rate is optimal for the class of first-order methods. Together with their algorithmic and implementation simplicities, they can be used on large smooth/nonsmooth convex problems.\nIn this paper, we use the well-known method of FISTA (Fast Iterative Shrinkage-Thresholding Algorithm) (Beck & Teboulle, 2009). Extending to other accelerated proximal methods is straightforward. Each FISTA iteration performs the following proximal step\nmin \u03b8 f(\u03b8\u0303k) + (\u03b8 \u2212 \u03b8\u0303k)\u2032\u2207f(\u03b8\u0303k) + Lk 2 \u2016\u03b8 \u2212 \u03b8\u0303k\u20162F + r(\u03b8), (3) where \u03b8\u0303k is the current iterate, and Lk is a scalar often\ndetermined by line search. Since (3) is required in every FISTA iteration, it needs to be solved very efficiently.\nFor problem (1), let \u0398 = [U\u2032,V\u2032]\u2032. Define\nf(\u0398) = T\u2211 t=1 \u2016y(t) \u2212X(t)(ut + vt)\u20162, (4) r(\u0398) = \u03bb1\u2016U\u2016clus + \u03bb2\u2016U\u20162F + \u03bb3\u2016V\u20162F .\nStep (3) can be rewritten as min\u0398 \u2016\u0398 \u2212 \u0398\u0302\u20162F + 2Lk r(\u0398), where \u0398\u0302 = [U\u0302\u2032, V\u0302\u2032]\u2032 = \u0398\u0303k \u2212 1Lk\u2207f(\u0398\u0303k) (Chen et al., 2011a). Expressing back in terms of U and V, (3) becomes\nminU,V \u2016U\u2212 U\u0302\u20162F + \u03bb\u03021\u2016U\u2016clus + \u03bb\u03022\u2016U\u20162F +\u2016V \u2212 V\u0302\u20162F + \u03bb\u03023\u2016V\u20162F , (5)\nwhere \u03bb\u0302i = 2\u03bbiLk (i = 1, 2, 3) and\nU\u0302 = U\u0303k\u2212 1\nLk \u2202Uf(\u0398\u0303k), V\u0302 = V\u0303k\u2212\n1\nLk \u2202Vf(\u0398\u0303k). (6)\nAs f(\u0398) in (4) is simply the squared loss, the tth columns of both \u2202Uf(\u0398\u0303k) and \u2202Vf(\u0398\u0303k) can be easily obtained as 2(X(t))\u2032(X(t)[\u0398\u0303k]\u00b7t \u2212 y(t)). Since f in the proximal step is only required to be convex and smooth, many other commonly used loss functions can be used in (1) instead.\nAs U and V are now decoupled, they can be optimized independently as will be shown in the sequel. The whole algorithm for solving (1) is shown in Algorithm 1.\nAlgorithm 1 Algorithm for solving (1). 1: Initialize: U\u03031, V\u03031, \u03c41 \u2190 1. 2: for k = 1, 2, . . . , N \u2212 1 do 3: Compute U\u0302 and V\u0302 in (6). 4: Uk \u2190 arg minU \u2016U \u2212 U\u0302\u20162F + \u03bb\u03021\u2016U\u2016clus +\n\u03bb\u03022\u2016U\u20162F using the algorithm in (Zhong & Kwok, 2011). 5: Vk \u2190 [ v\u0302ij\n1+\u03bb\u03023\n] .\n6: \u03c4k+1 \u2190 1+ \u221a 1+4\u03c42k 2 .\n7:\n[ U\u0303k+1\nV\u0303k+1 ] \u2190 [ Uk Vk ] + \u03c4k\u22121\u03c4k+1 ([ Uk Vk ] \u2212 [ Uk\u22121 Vk\u22121 ]) .\n8: end for 9: Output UN ."}, {"heading": "2.3.1. COMPUTING V", "text": "For fixed U, the subproblem in (5) related to V is minV \u2016V \u2212 V\u0302\u20162F + \u03bb\u03023\u2016V\u20162F . On setting the gradient of the objective w.r.t. V to zero, we obtain V = [ v\u0302ij\n1+\u03bb\u03023\n] ."}, {"heading": "2.3.2. COMPUTING U", "text": "For fixed V, the subproblem in (5) related to U is minU \u2016U\u2212U\u0302\u20162F + \u03bb\u03021\u2016U\u2016clus+ \u03bb\u03022\u2016U\u20162F . Because of the\nO(T 2) number of terms in \u2016U\u20162F , this is more challenging than the computing of V in Section 2.3.1. However, as the rows of U are independent, U can be optimized row by row. For the dth row, we have\nmin u \u2016u\u2212 u\u0302\u20162 + \u03bb\u03021 \u2211 i<j |ui \u2212 uj |+ \u03bb\u03022\u2016u\u20162, (7)\nwhere u\u0302 = U\u0302d\u00b7 = [u\u03021, . . . , u\u0302T ]\u2032. It can be shown that (7) can be rewritten as the optimization problem considered in (Zhong & Kwok, 2011), and hence can be solved efficiently using the algorithm proposed there."}, {"heading": "2.3.3. TIME COMPLEXITY", "text": "Computing the gradients \u2202Uf(\u0398\u0303k) and \u2202Vf(\u0398\u0303k) takes O(nDT ) time. Computing Vk takes O(DT ) time. Computing one row of Uk using the algorithm in (Zhong & Kwok, 2011) takes O(T log T ) time, and thus O(DT log T ) time for the whole Uk. Hence, the total complexity for Algorithm 1 is onlyO(TDn+DT log T ). Moreover, FISTA converges as O(1/N2) (Beck & Teboulle, 2009), where N is the number of iterations. This is much faster than traditional gradient methods, which converges as O(1/ \u221a N). It is also faster than GFlasso (Chen et al., 2011b), which solves a similar problem as (1), but converges as O(1/N) and has a per-iteration complexity of O(T 2).\nThough (7) is similar to the optimization problems of the pairwise fused lasso in (Petry et al., 2011; She, 2010), using the optimization procedures there are much more expensive. Specifically, the procedure in (Petry et al., 2011) takes O(T 6) time, as it involves a QP with ( T 2 ) additional optimization variables; while (She, 2010) relies on annealing, which is even more complicated and expensive."}, {"heading": "2.4. Adaptive Clustering", "text": "As in the adaptive lasso (Zou, 2006), weights can be added to each term of \u2016U\u2016clus as \u2211D d=1 \u2211 i\u0303<j\u0303 \u03b1d,\u0303ij\u0303 |Udi\u0303 \u2212 Udj\u0303 |, where \u03b1d,\u0303ij\u0303 is the weight associated with the ith and jth largest entries (Udi\u0303 and Udj\u0303 , respectively) on the dth row of U. To set the weights \u03b1d,\u0303ij\u0303 , we first run model (1) with the unweighted \u2016U\u2016clus to obtain W, and then set \u03b1d,\u0303ij\u0303 =\n1 |Wdi\u0303\u2212Wdj\u0303 | . Hence, when Wdi\u0303,Wdj\u0303 are similar, Udi\u0303, Udj\u0303 will be strongly encouraged to be clustered together, and vice verse. Moreover, the optimization procedure in Algorithm 1 can still be used."}, {"heading": "3. Experiments", "text": "In this section, we perform experiments on a number of synthetic and real-world data sets. All the data sets are standardized such that the features have zero mean and unit variance for each task. The output of each task is also standardized to have mean zero."}, {"heading": "3.1. Synthetic Data Sets", "text": "In this experiment, the input has dimensionality D = 30 and is generated from the multivariate normal distribution x \u223c N (0, I). We use T = 10 tasks, with the output of the tth task generated as yt \u223c x\u2032w\u0306t + N (0, 400). All tasks have 30 training samples and 100 test samples. The task parameters are designed in the following manner to mimic various real-world scenarios:\n(C1) All tasks are independent: w\u0306t \u223c N (0, 25I) for all t.\n(C2) All tasks are from the same cluster: w\u0306t = wm + N (0, I) for all t.\n(C3) All tasks are from the same cluster as in C2, but with corrupted features as are often encountered in real-world data sets. We first generate w\u0306t \u223c wm + N (0, I) for all t. Then, for each feature, we randomly pick one task and replace its weight by a random number from 10 +N (0, 100).\n(C4) A main task cluster plus a few outlier tasks: w\u0306t \u223c {\nwm +N (0, I) t = 1, 2, 3, 4, 5, 6, 7, 8, 10 \u00b7 1 +N (0, 100I) t = 9, 10.\n(C5) Tasks in overlapping groups: We have two groups with weights w(1),w(2). For each feature d, several tasks (1-9) are randomly assigned to group 1, and the rest to group 2. Suppose that task t belongs to group g, we then generate [w\u0306t]i \u223c [w(g)]i +N (0, 1).\n(C6) This is used to simulate the recommender systems example in Section 1. All but the last two features are generated from a common cluster, as [w\u0306t]i \u223c [wm]i +N (0, 1). For the last two features, we generate [w\u0306t]i \u223c 10 +N (0, 100) for each task t.\nThe proposed model will be called FlexTClus (Flexible Task-Clustered MTL). It is compared with a variety of single-task and state-of-the-art MTL algorithms, including: 1) Independent ridge regression on each task; 2) Pooling all the training data together to learn a single model:\nThis assumes that all the tasks are identical; 3) Regularized MTL: This assumes that all the tasks come from a single cluster (Evgeniou & Pontil, 2004); 4) The dirty model in (Jalali et al., 2010); 5) Low-rank-based robust MTL (Chen et al., 2011a); 6) Sparse-LowRank MTL (Chen et al., 2010), which learns sparse and low-rank patterns from the tasks; 7) Clustered MTL (Jacob et al., 2008)2 and 8) Multitask relationship learning (MTRL) (Zhang & Yeung, 2010).\nRegularization parameters for all the methods are tuned by a validation set of size 100. To reduce statistical variability, results are averaged over 10 repetitions. In each repetition, wm is generated from N (0, 25I); whereas in C5, w(1) \u223c N (0, 25I) and w(2) \u223c N (0, 100I). The normalized mean squared error (NMSE), which is defined as the MSE divided by the variance of the ground truth, is used for performance evaluation.\nResults are shown in Table 1. We have the following observations.\n\u2022 C1: Since the tasks are independent, so as expected, ridge gives good result, while pooling is the worst. Recall that FlexTClus can be reduced to ridge regression with a suitable choice of regularization parameters. Hence, both versions of FlexTClus are as good as ridge. Similarly, regularized MTL can also be reduced to ridge regression by using a very strong regularizer on the task mean parameter. As for clustered MTL, since the true number of clusters is given (which is equal to the number of tasks in this case), it reduces to ridge regression and so the result is also good. On the other hand, the remaining MTL methods suffer from negative transfer.\n\u2022 In C2, all tasks are from the same group, and hence regularized MTL and FlexTClus (which can be reduced to regularized MTL) perform best. This is followed by pooling, while the other MTL methods\n2The clustered MTL algorithm of (Jacob et al., 2008) requires the number of task clusters as input. This is set to be the ground truth in the experiment. Hence, results obtained for this method can be overly optimistic.\nlag further behind and suffer from negative transfer. When noisy features are added (C3), pooling suffers tremendously, while FlexTClus still retains its superior performance.\n\u2022 C4 is a common MTL setup. As expected, almost all MTL methods perform well.\n\u2022 C5 and C6 are the most challenging. FlexTClus (and its adaptive variant) is the only method that can capture the complicated feature-wise task relationships.\nFigure 2 compares the ground truth clustering structures of the task parameters with those obtained by adaptive FlexTClus. As can be seen, FlexTClus can well capture the underlying structure."}, {"heading": "3.2. Examination Score Prediction", "text": "In this section, experiment is performed on the school data set (Bakker & Heskes, 2003). As in (Chen et al., 2011a), we use 10%, 20% and 30% of the data for training, another 45% for testing, and the remaining for validation. To reduce statistical variability, results are averaged over 5 repetitions.\nResults are shown in Table 2. Note that though the school data has been popularly used as a MTL benchmark, it has been pointed out previously that all the tasks are indeed the same (Bakker & Heskes, 2003; Evgeniou et al., 2005).\nHence, the trend in Table 2 is similar to that of C2 in Table 1. As can be seen, both versions of FlexTClus are very competitive in this single-cluster case, and are better than the other MTL methods. Figure 3 shows the task clustering structure obtained by adaptive FlexTClus. Clearly, it indicates that there is only one underlying task cluster."}, {"heading": "3.3. Handwritten Digit Recognition", "text": "In this section, we perform experiments on two popular handwritten digits data sets, USPS and MNIST. As in (Kang et al., 2011), PCA is used to reduce the feature dimensionality to 64 for USPS and 87 for MNIST. For each digit, we randomly choose 10, 30, 50 samples for training, 500 samples for validation and another 500 samples for testing. The 10-class classification problem is decomposed into 10 one-vs-rest binary problems, each of which is treated as a task.\nResults averaged over 5 repetitions are shown in Table 3. We do not compare with pooling, which assumes that all the tasks are identical and is clearly invalid in this one-vsrest setting. As can be seen, FlexTClus and its adaptive version are consistently among the best, while many other MTL methods suffer from negative transfer and are only comparable or even worse than ridge regression. Fig. 4 shows the task clustering structures obtained. As expected, many trailing PCA features are not useful for discrimination and the corresponding weights are zero. In contrast,\nthe leading PCA features are more discriminative and are used by the different tasks in different manners, leading to more varied cluster structures."}, {"heading": "3.4. Rating of Products", "text": "In this section, we use the computer survey data in (Argyriou et al., 2008). This contains the ratings of 201 students on 20 different personal computers, each described by 13 attributes. After removing the invalid ratings and students with more than 8 zero ratings, we are left with 172 students (tasks). For each task, we randomly split the 20 instances into training, validation and test sets of sizes 8,8, and 4, respectively.\nTable 4 shows the root mean squared error (RMSE) averaged over 10 random splits. Again, FlexTClus and its adaptive variant outperform the other models. Figure 5 shows the task clustering structure obtained in a typical run. Note that the first 12 features are about the PC\u2019s performance (such as memory and CPU speed). As can be seen, there is one main cluster, indicating that most students in this survey have similar preference on these attributes. On the other hand, the last feature is price, and the result indicates that there are lots of varied opinions on this attribute."}, {"heading": "4. Conclusion and Future Work", "text": "While existing MTL methods can only model task relationships at the task level, we introduced in this paper\na novel MTL formulation that captures task relationships at the feature-level. Depending on the myriad relationships among tasks and features, the proposed method can cluster tasks in a flexible feature-by-feature manner, without even the need of pre-specifying the number of clusters. Moreover, the proposed formulation is (strongly) convex, and can be solved by accelerated proximal methods with an efficient and scalable proximal step. Experiments on a number of synthetic and real-world data sets show that the proposed method is accurate. The obtained feature-specific task clustering structure also agrees with the known/plausible clustering structure of the tasks."}, {"heading": "Acknowledgments", "text": "This research was supported in part by the Research Grants Council of the Hong Kong Special Administrative Region (Grant 614311)."}], "references": [{"title": "Learning multiple tasks using manifold regularization", "author": ["A. Agarwal", "H. Daum\u00e9 III", "S. Gerber"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Agarwal et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Agarwal et al\\.", "year": 2010}, {"title": "A framework for learning predictive structures from multiple tasks and unlabeled data", "author": ["R.K. Ando", "T. Zhang"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Ando and Zhang,? \\Q2005\\E", "shortCiteRegEx": "Ando and Zhang", "year": 2005}, {"title": "Convex multitask feature learning", "author": ["A. Argyriou", "T. Evgeniou", "M. Pontil"], "venue": "Machine Learning,", "citeRegEx": "Argyriou et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Argyriou et al\\.", "year": 2008}, {"title": "Convex optimization with sparsity-inducing norms", "author": ["F. Bach", "R. Jenatton", "J. Mairal", "G. Obozinski"], "venue": "In Optimization for Machine Learning,", "citeRegEx": "Bach et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bach et al\\.", "year": 2011}, {"title": "Task clustering and gating for Bayesian multitask learning", "author": ["B. Bakker", "T. Heskes"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Bakker and Heskes,? \\Q2003\\E", "shortCiteRegEx": "Bakker and Heskes", "year": 2003}, {"title": "A fast iterative shrinkagethresholding algorithm for linear inverse problems", "author": ["A. Beck", "M. Teboulle"], "venue": "SIAM Journal on Imaging Sciences,", "citeRegEx": "Beck and Teboulle,? \\Q2009\\E", "shortCiteRegEx": "Beck and Teboulle", "year": 2009}, {"title": "Learning incoherent sparse and low-rank patterns from multiple tasks", "author": ["J. Chen", "J. Liu", "J. Ye"], "venue": "In Proceedings of the 16th International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Chen et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2010}, {"title": "Integrating low-rank and group-sparse structures for robust multi-task tearning", "author": ["J. Chen", "J. Zhou", "J. Ye"], "venue": "In Proceedings of the 17th International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Chen et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2011}, {"title": "Smoothing proximal gradient method for general structured sparse learning", "author": ["X. Chen", "Q. Lin", "S. Kim", "J.G. Carbonell", "E.P. Xing"], "venue": "In Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "Chen et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2011}, {"title": "Regularized multi-task learning", "author": ["T. Evgeniou", "M. Pontil"], "venue": "In Proceedings of the 10th International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Evgeniou and Pontil,? \\Q2004\\E", "shortCiteRegEx": "Evgeniou and Pontil", "year": 2004}, {"title": "Learning multiple tasks with kernel methods", "author": ["T. Evgeniou", "C.A. Micchelli", "M. Pontil"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Evgeniou et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Evgeniou et al\\.", "year": 2005}, {"title": "Clustered multi-task learning: A convex formulation", "author": ["L. Jacob", "F. Bach", "J. Vert"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Jacob et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Jacob et al\\.", "year": 2008}, {"title": "A dirty model for multi-task learning", "author": ["A. Jalali", "P. Ravikumar", "S. Sanghavi", "C. Ruan"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Jalali et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jalali et al\\.", "year": 2010}, {"title": "Learning with whom to share in multi-task feature learning", "author": ["Z. Kang", "K. Grauman", "K. Sha"], "venue": "In Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "Kang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kang et al\\.", "year": 2011}, {"title": "Multitask learning via conic programming", "author": ["T. Kato", "H. Kashima", "M. Sugiyama", "K. Asai"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Kato et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kato et al\\.", "year": 2007}, {"title": "Gradient methods for minimizing composite objective function", "author": ["Y. Nesterov"], "venue": "Technical Report 76, Catholic University of Louvain,", "citeRegEx": "Nesterov,? \\Q2007\\E", "shortCiteRegEx": "Nesterov", "year": 2007}, {"title": "Pairwise fused lasso", "author": ["S. Petry", "C. Flexeder", "G. Tutz"], "venue": "Technical Report 102,", "citeRegEx": "Petry et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Petry et al\\.", "year": 2011}, {"title": "Sparse regression with exact clustering", "author": ["Y. She"], "venue": "Electronic Journal of Statistics,", "citeRegEx": "She,? \\Q2010\\E", "shortCiteRegEx": "She", "year": 2010}, {"title": "Sparsity and smoothness via the fused lasso", "author": ["R. Tibshirani", "M. Saunders", "S. Rosset", "J. Zhu", "K. Knight"], "venue": "Journal of the Royal Statistical Society: Series B,", "citeRegEx": "Tibshirani et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Tibshirani et al\\.", "year": 2005}, {"title": "Learning Gaussian processes from multiple tasks", "author": ["K. Yu", "V. Tresp", "A. Schwaighofer"], "venue": "In Proceedings of the 22nd International Conference on Machine Learning,", "citeRegEx": "Yu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2005}, {"title": "Learning multiple tasks with a sparse matrix-normal penalty", "author": ["Y. Zhang", "J. Schneider"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Zhang and Schneider,? \\Q2010\\E", "shortCiteRegEx": "Zhang and Schneider", "year": 2010}, {"title": "A convex formulation for learning task relationships in multi-task learning", "author": ["Y. Zhang", "Yeung", "D.-Y"], "venue": "In Proceedings of the 24th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "Zhang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2010}, {"title": "Efficient sparse modeling with automatic feature grouping", "author": ["L.W. Zhong", "J.T. Kwok"], "venue": "In Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "Zhong and Kwok,? \\Q2011\\E", "shortCiteRegEx": "Zhong and Kwok", "year": 2011}, {"title": "Clustered multi-task learning via alternating structure optimization", "author": ["J. Zhou", "J. Chen", "J. Ye"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Zhou et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhou et al\\.", "year": 2011}, {"title": "The adaptive lasso and its oracle properties", "author": ["H. Zou"], "venue": "Journal of the American Statistical Association,", "citeRegEx": "Zou,? \\Q2006\\E", "shortCiteRegEx": "Zou", "year": 2006}], "referenceMentions": [{"referenceID": 10, "context": "Traditional MTL methods assume that all the tasks are related (Evgeniou & Pontil, 2004; Evgeniou et al., 2005).", "startOffset": 62, "endOffset": 110}, {"referenceID": 2, "context": "If it is known that the tasks are clustered, a simple remedy is to constrain task sharing to be just within the same cluster (Argyriou et al., 2008; Evgeniou et al., 2005).", "startOffset": 125, "endOffset": 171}, {"referenceID": 10, "context": "If it is known that the tasks are clustered, a simple remedy is to constrain task sharing to be just within the same cluster (Argyriou et al., 2008; Evgeniou et al., 2005).", "startOffset": 125, "endOffset": 171}, {"referenceID": 14, "context": "This can be further extended to the case where task relationships are represented in the form of a network (Kato et al., 2007).", "startOffset": 107, "endOffset": 126}, {"referenceID": 19, "context": "For example, some assume that the task parameters share a common prior in a Bayesian model (Yu et al., 2005; Zhang & Schneider, 2010; Zhang & Yeung, 2010); that the data follows a dirty model (Jalali et al.", "startOffset": 91, "endOffset": 154}, {"referenceID": 12, "context": ", 2005; Zhang & Schneider, 2010; Zhang & Yeung, 2010); that the data follows a dirty model (Jalali et al., 2010); that most of the tasks lie in a low-dimensional subspace (Ando & Zhang, 2005; Chen et al.", "startOffset": 91, "endOffset": 112}, {"referenceID": 6, "context": ", 2010); that most of the tasks lie in a low-dimensional subspace (Ando & Zhang, 2005; Chen et al., 2010), or that outlier tasks are present (Chen et al.", "startOffset": 66, "endOffset": 105}, {"referenceID": 2, "context": "In this paper, we will mainly be interested in techniques that assume the tasks are clustered (Argyriou et al., 2008; Evgeniou et al., 2005), and then infer the clustering structure automatically during learning (Jacob et al.", "startOffset": 94, "endOffset": 140}, {"referenceID": 10, "context": "In this paper, we will mainly be interested in techniques that assume the tasks are clustered (Argyriou et al., 2008; Evgeniou et al., 2005), and then infer the clustering structure automatically during learning (Jacob et al.", "startOffset": 94, "endOffset": 140}, {"referenceID": 11, "context": ", 2005), and then infer the clustering structure automatically during learning (Jacob et al., 2008; Kang et al., 2011).", "startOffset": 79, "endOffset": 118}, {"referenceID": 13, "context": ", 2005), and then infer the clustering structure automatically during learning (Jacob et al., 2008; Kang et al., 2011).", "startOffset": 79, "endOffset": 118}, {"referenceID": 23, "context": "Interestingly, it is recently shown that this clustered MTL approach is equivalent to alternating structure optimization (Ando & Zhang, 2005) that assumes the tasks share a low-dimensional structure (Zhou et al., 2011).", "startOffset": 199, "endOffset": 218}, {"referenceID": 11, "context": "Moreover, a key difference with (Jacob et al., 2008) is that we do not require the number of clusters to be pre-specified.", "startOffset": 32, "endOffset": 52}, {"referenceID": 13, "context": "For example, in (Kang et al., 2011), it leads to a mixed integer program, which has to be relaxed as a nonlinear optimization problem and then solved by gradient descent.", "startOffset": 16, "endOffset": 35}, {"referenceID": 15, "context": "On the other hand, the proposed approach directly leads to a (strongly) convex optimization problem, which can then be efficiently solved by accelerated proximal methods (Nesterov, 2007) after some transformations.", "startOffset": 170, "endOffset": 186}, {"referenceID": 18, "context": "Note that this is different from the fused lasso regularizer (Tibshirani et al., 2005), which is used for clustering features in single-task learning while \u2016U\u2016clus is for clustering tasks in MTL.", "startOffset": 61, "endOffset": 86}, {"referenceID": 10, "context": "In (Evgeniou et al., 2005), ut is the (single) cluster center of all the tasks; in (Ando & Zhang, 2005; Chen et al.", "startOffset": 3, "endOffset": 26}, {"referenceID": 6, "context": ", 2005), ut is the (single) cluster center of all the tasks; in (Ando & Zhang, 2005; Chen et al., 2010; 2011a),", "startOffset": 64, "endOffset": 110}, {"referenceID": 0, "context": "ut comes from a low-dimensional linear subspace, which is extended to a nonlinear manifold in (Agarwal et al., 2010); in (Jalali et al.", "startOffset": 94, "endOffset": 116}, {"referenceID": 12, "context": ", 2010); in (Jalali et al., 2010), ut is the component that uses features shared by other tasks.", "startOffset": 12, "endOffset": 33}, {"referenceID": 10, "context": "Thus, wt reduces to \u016b + vt for some \u201cmean weight\u201d \u016b, and (1) reduces to the model in (Evgeniou et al., 2005).", "startOffset": 85, "endOffset": 108}, {"referenceID": 15, "context": "In recent years, accelerated proximal methods (Nesterov, 2007) have been popularly used by the machine learning community (Bach et al.", "startOffset": 46, "endOffset": 62}, {"referenceID": 3, "context": "In recent years, accelerated proximal methods (Nesterov, 2007) have been popularly used by the machine learning community (Bach et al., 2011) for convex problems of the form min\u03b8 f(\u03b8)+r(\u03b8), where f(\u03b8) is convex and smooth, and r(\u03b8) is convex but nonsmooth.", "startOffset": 122, "endOffset": 141}, {"referenceID": 16, "context": "Though (7) is similar to the optimization problems of the pairwise fused lasso in (Petry et al., 2011; She, 2010), using the optimization procedures there are much more expensive.", "startOffset": 82, "endOffset": 113}, {"referenceID": 17, "context": "Though (7) is similar to the optimization problems of the pairwise fused lasso in (Petry et al., 2011; She, 2010), using the optimization procedures there are much more expensive.", "startOffset": 82, "endOffset": 113}, {"referenceID": 16, "context": "Specifically, the procedure in (Petry et al., 2011) takes O(T ) time, as it involves a QP with ( T", "startOffset": 31, "endOffset": 51}, {"referenceID": 17, "context": "2 ) additional optimization variables; while (She, 2010) relies on annealing, which is even more complicated and expensive.", "startOffset": 45, "endOffset": 56}, {"referenceID": 24, "context": "As in the adaptive lasso (Zou, 2006), weights can be added to each term of \u2016U\u2016clus as \u2211D d=1 \u2211 \u0129<j\u0303 \u03b1d,\u0303ij\u0303 |Ud\u0129 \u2212 Udj\u0303 |, where \u03b1d,\u0303ij\u0303 is the weight associated with the ith and jth largest entries (Ud\u0129 and Udj\u0303 , respectively) on the dth row of U.", "startOffset": 25, "endOffset": 36}, {"referenceID": 12, "context": "It is compared with a variety of single-task and state-of-the-art MTL algorithms, including: 1) Independent ridge regression on each task; 2) Pooling all the training data together to learn a single model: This assumes that all the tasks are identical; 3) Regularized MTL: This assumes that all the tasks come from a single cluster (Evgeniou & Pontil, 2004); 4) The dirty model in (Jalali et al., 2010); 5) Low-rank-based robust MTL (Chen et al.", "startOffset": 381, "endOffset": 402}, {"referenceID": 6, "context": ", 2011a); 6) Sparse-LowRank MTL (Chen et al., 2010), which learns sparse and low-rank patterns from the tasks; 7) Clustered MTL (Jacob et al.", "startOffset": 32, "endOffset": 51}, {"referenceID": 11, "context": ", 2010), which learns sparse and low-rank patterns from the tasks; 7) Clustered MTL (Jacob et al., 2008)2 and 8) Multitask relationship learning (MTRL) (Zhang & Yeung, 2010).", "startOffset": 84, "endOffset": 104}, {"referenceID": 11, "context": "The clustered MTL algorithm of (Jacob et al., 2008) requires the number of task clusters as input.", "startOffset": 31, "endOffset": 51}, {"referenceID": 10, "context": "Note that though the school data has been popularly used as a MTL benchmark, it has been pointed out previously that all the tasks are indeed the same (Bakker & Heskes, 2003; Evgeniou et al., 2005).", "startOffset": 151, "endOffset": 197}, {"referenceID": 13, "context": "As in (Kang et al., 2011), PCA is used to reduce the feature dimensionality to 64 for USPS and 87 for MNIST.", "startOffset": 6, "endOffset": 25}, {"referenceID": 2, "context": "In this section, we use the computer survey data in (Argyriou et al., 2008).", "startOffset": 52, "endOffset": 75}], "year": 2012, "abstractText": "Traditionally, multitask learning (MTL) assumes that all the tasks are related. This can lead to negative transfer when tasks are indeed incoherent. Recently, a number of approaches have been proposed that alleviate this problem by discovering the underlying task clusters or relationships. However, they are limited to modeling these relationships at the task level, which may be restrictive in some applications. In this paper, we propose a novel MTL formulation that captures task relationships at the feature-level. Depending on the interactions among tasks and features, the proposed method construct different task clusters for different features, without even the need of pre-specifying the number of clusters. Computationally, the proposed formulation is strongly convex, and can be efficiently solved by accelerated proximal methods. Experiments are performed on a number of synthetic and real-world data sets. Under various degrees of task relationships, the accuracy of the proposed method is consistently among the best. Moreover, the feature-specific task clusters obtained agree with the known/plausible task structures of the data.", "creator": "TeX"}}}