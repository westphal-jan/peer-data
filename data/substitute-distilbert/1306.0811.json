{"id": "1306.0811", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Jun-2013", "title": "A Gang of Bandits", "abstract": "multi - armed bandit problems are receiving a great deal of attention following they adequately formalize the exploration - intensive roll - offs arising in several global based applications, such as global advertisement and, more generally, recommendation systems. in many cases, however, these applications have a strong social component, whose innovation in the bandit algorithm could lead to a dramatic performance increase. for instance, we may want enhanced serve content to a group of users by taking advantage of an expanded network of communication relationships among them. pursuing this paper, \u2022 introduce novel algorithmic approaches to the solution of such networked bandit problems. more specifically, we design and analyze a global strategy which allocates a bandit algorithm to each network activity ( user ) \u2014 enables it to \" share \" signals ( contexts whose payoffs ) with the data nodes. we then create two more scalable variants of this strategy based \" innovative ways of engaging specific graph nodes. we experimentally compare the algorithm and its variants to institute - of - the - art methods for contextual simulations that don't use the relational information. our experiments, carried out on synthetic and real - world datasets, show a marked increase in prediction performance obtained by exploiting the network structure.", "histories": [["v1", "Tue, 4 Jun 2013 14:24:31 GMT  (934kb,D)", "https://arxiv.org/abs/1306.0811v1", null], ["v2", "Fri, 25 Oct 2013 16:32:25 GMT  (957kb,D)", "http://arxiv.org/abs/1306.0811v2", "NIPS 2013"], ["v3", "Mon, 4 Nov 2013 10:07:42 GMT  (959kb,D)", "http://arxiv.org/abs/1306.0811v3", "NIPS 2013"]], "reviews": [], "SUBJECTS": "cs.LG cs.SI stat.ML", "authors": ["nicol\u00f2 cesa-bianchi", "claudio gentile", "giovanni zappella"], "accepted": true, "id": "1306.0811"}, "pdf": {"name": "1306.0811.pdf", "metadata": {"source": "CRF", "title": "A Gang of Bandits", "authors": ["Nicol\u00f2 Cesa-Bianchi", "Claudio Gentile"], "emails": ["nicolo.cesa-bianchi@unimi.it", "claudio.gentile@uninsubria.it", "giovanni.zappella@unimi.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 6.\n08 11\nv3 ["}, {"heading": "1 Introduction", "text": "The ability of a website to present personalized content recommendations is playing an increasingly crucial role in achieving user satisfaction. Because of the appearance of new content, and due to the ever-changing nature of content popularity, modern approaches to content recommendation are strongly adaptive, and attempt to match as closely as possible users\u2019 interests by learning good mappings between available content and users. These mappings are based on \u201ccontexts\u201d, that is sets of features that, typically, are extracted from both contents and users. The need to focus on content that raises the user interest and, simultaneously, the need of exploring new content in order to globally improve the user experience creates an exploration-exploitation dilemma, which is commonly formalized as a multi-armed bandit problem. Indeed, contextual bandits have become a reference model for the study of adaptive techniques in recommender systems (e.g, [5, 7, 15] ). In many cases, however, the users targeted by a recommender system form a social network. The network structure provides an important additional source of information, revealing potential affinities between pairs of users. The exploitation of such affinities could lead to a dramatic increase in the quality of the recommendations. This is because the knowledge gathered about the interests of a given user may be exploited to improve the recommendation to the user\u2019s friends. In this work, an algorithmic approach to networked contextual bandits is proposed which is provably able to leverage user similarities represented as a graph. Our approach consists in running an instance of a contextual bandit algorithm at each network node. These instances are allowed to interact during the learning process, sharing contexts and user feedbacks. Under the modeling assumption that user similarities are properly reflected by the network structure, interactions allow to effectively speed up the learning process that takes place at each node. This mechanism is implemented by running instances of a linear contextual bandit algorithm in a specific reproducing kernel Hilbert space (RKHS). The underlying kernel, previously used for solving online multitask classification problems (e.g., [8]), is defined in terms of the Laplacian matrix of the graph. The Laplacian matrix provides the information we rely upon to share user feedbacks from one node to the others, according to the network structure. Since the Laplacian kernel is linear, the implementation in kernel space is straightforward. Moreover, the existing performance guarantees for the specific bandit algorithm we use can be directly lifted to the RKHS, and expressed in terms of spectral properties of the user network. Despite its crispness, the principled approach described above has two drawbacks hindering its practical usage. First, running a network of linear contextual bandit algorithms with a Laplacian-based feedback sharing mechanism may cause significant scaling problems, even on small to medium sized social networks. Second, the social information provided by the network structure at hand need not be fully reliable in accounting for user behavior similarities. Clearly enough, the more such algorithms hinge on the network to improve learning rates, the more they are penalized if the network information is noisy and/or misleading. After collecting empirical evidence on the sensitivity\nof networked bandit methods to graph noise, we propose two simple modifications to our basic strategy, both aimed at circumventing the above issues by clustering the graph nodes. The first approach reduces graph noise simply by deleting edges between pairs of clusters. By doing that, we end up running a scaled down independent instance of our original strategy on each cluster. The second approach treats each cluster as a single node of a much smaller cluster network. In both cases, we are able to empirically improve prediction performance, and simultaneously achieve dramatic savings in running times. We run experiments on two real-world datasets: one is extracted from the social bookmarking web service Delicious, and the other one from the music streaming platform Last.fm."}, {"heading": "2 Related work", "text": "The benefit of using social relationships in order to improve the quality of recommendations is a recognized fact in the literature of content recommender systems \u2014see e.g., [5, 13, 18] and the survey [3]. Linear models for contextual bandits were introduced in [4]. Their application to personalized content recommendation was pioneered in [15], where the LinUCB algorithm was introduced. An analysis of LinUCB was provided in the subsequent work [9]. To the best of our knowledge, this is the first work that combines contextual bandits with the social graph information. However, non-contextual stochastic bandits in social networks were studied in a recent independent work [20]. Other works, such as [2, 19], consider contextual bandits assuming metric or probabilistic dependencies on the product space of contexts and actions. A different viewpoint, where each action reveals information about other actions\u2019 payoffs, is the one studied in [7, 16], though without the context provided by feature vectors. A non-contextual model of bandit algorithms running on the nodes of a graph was studied in [14]. In that work, only one node reveals its payoffs, and the statistical information acquired by this node over time is spread across the entire network following the graphical structure. The main result shows that the information flow rate is sufficient to control regret at each node of the network. More recently, a new model of distributed non-contextual bandit algorithms has been presented in [21], where the number of communications among the nodes is limited, and all the nodes in the network have the same best action."}, {"heading": "3 Learning model", "text": "We assume the social relationships over users are encoded as a known undirected and connected graph G = (V,E), where V = {1, . . . , n} represents a set of n users, and the edges in E represent the social links over pairs of users. Recall that a graph G can be equivalently defined in terms of its Laplacian matrix L = [ Li,j ]n i,j=1 , where Li,i is the degree of node i (i.e., the number of incoming/outgoing edges) and, for i 6= j, Li,j equals \u22121 if (i, j) \u2208 E, and 0 otherwise.\nLearning proceeds in a sequential fashion: At each time step t = 1, 2, . . . , the learner receives a user index it \u2208 V together with a set of context vectors Cit = {xt,1,xt,2, . . . ,xt,ct} \u2286 Rd. The learner then selects some kt \u2208 Cit to recommend to user it and observes some payoff at \u2208 [\u22121, 1], a function of it and x\u0304t = xt,kt . No assumptions whatsoever are made on the way index it and set Cit are generated, in that they can arbitrarily depend on past choices made by the algorithm.1\nA standard modeling assumption for bandit problems with contextual information (one that is also adopted here) is to assume that rewards are generated by noisy versions of unknown linear functions of the context vectors. That is, we assume each node i \u2208 V hosts an unknown parameter vector ui \u2208 Rd, and that the reward value ai(x) associated with node i and context vector x \u2208 Rd is given by the random variable ai(x) = u > i x + i(x), where i(x) is a conditionally zero-mean and bounded variance noise term. Specifically, denoting by Et[ \u00b7 ] the conditional expectation E [ \u00b7 \u2223\u2223 (i1, Ci1 , a1), . . . , (it\u22121, Cit\u22121 , at\u22121) ], we take the general approach of [1], and assume that for any fixed i \u2208 V and x \u2208 Rd, the variable i(x) is conditionally sub-Gaussian with variance parameter \u03c32 > 0, namely, Et [ exp(\u03b3 i(x)) ] \u2264 exp ( \u03c32 \u03b32/2 ) for all \u03b3 \u2208 R and all x, i.\nThis implies Et[ i(x)] = 0 and Vt [ i(x) ] \u2264 \u03c32, where Vt[\u00b7] is a shorthand for\nthe conditional variance V [ \u00b7 \u2223\u2223 (i1, Ci1 , a1), . . . , (it\u22121, Cit\u22121 , at\u22121) ]. So we clearly\nhave Et[ai(x)] = u>i x and Vt [ ai(x) ] \u2264 \u03c32. Therefore, u>i x is the expected reward observed at node i for context vector x. In the special case when the noise i(x) is a bounded random variable taking values in the range [\u22121, 1], this implies Vt[ai(x)] \u2264 4.\nThe regret rt of the learner at time t is the amount by which the average reward of the best choice in hindsight at node it exceeds the average reward of the algorithm\u2019s choice, i.e.,\nrt = ( max x\u2208Cit u>itx ) \u2212 u>it x\u0304t .\nThe goal of the algorithm is to bound with high probability (over the noise variables it) the cumulative regret \u2211T t=1 rt for the given sequence of nodes i1, . . . , iT and observed context vector sets Ci1 , . . . , CiT . We model the similarity among users in V by making the assumption that nearby users hold similar underlying vectors ui, so that reward signals received at a given node it at time t are also, to some extent, informative to learn the behavior of other users j connected to it within G. We make this more precise by taking the perspective of known multitask learning settings (e.g., [8]), and assume that\u2211\n(i,j)\u2208E\n\u2016ui \u2212 uj\u20162 (1)\nis small compared to \u2211 i\u2208V \u2016ui\u20162, where \u2016 \u00b7 \u2016 denotes the standard Euclidean norm of vectors. That is, although (1) may possibly contain a quadratic number\n1 Formally, it and Cit can be arbitrary (measurable) functions of past rewards a1, . . . , at\u22121, indices i1, . . . , it\u22121, and sets Ci1 , . . . , Cit\u22121 .\nof terms, the closeness of vectors lying on adjacent nodes in G makes this sum comparatively smaller than the actual length of such vectors. This will be our working assumption throughout, one that motivates the Laplacian-regularized algorithm presented in Section 4, and empirically tested in Section 5."}, {"heading": "4 Algorithm and regret analysis", "text": "Our bandit algorithm maintains at time t an estimate wi,t for vector ui. Vectors wi,t are updated based on the reward signals as in a standard linear bandit algorithm (e.g., [9]) operating on the context vectors contained in Cit . Every node i of G hosts a linear bandit algorithm like the one described in Figure 1. The algorithm in Figure 1 maintains at time t a prototype vector wt which is the result of a standard linear least-squares approximation to the unknown parameter vector u associated with the node under consideration. In particular, wt\u22121 is obtained by multiplying the inverse correlation matrix Mt\u22121 and the bias vector bt\u22121. At each time t = 1, 2, . . . , the algorithm receives context vectors xt,1, . . . ,xt,ct contained in Ct, and must select one among them. The linear bandit algorithm selects x\u0304t = xt,kt as the vector in Ct that maximizes an upper-confidence-corrected estimation of the expected reward achieved over context vectors xt,k. The estimation is based on the current wt\u22121, while the upper confidence level cbt is suggested by the standard analysis of linear bandit algorithms \u2014see, e.g., [1, 9, 10]. Once the actual reward at associated with x\u0304t is observed, the algorithm uses x\u0304t for updating Mt\u22121 to Mt via a rankone adjustment, and bt\u22121 to bt via an additive update whose learning rate is precisely at. This algorithm can be seen as a version of LinUCB [9], a linear bandit algorithm derived from LinRel [4].\nWe now turn to describing our GOB.Lin (Gang Of Bandits, Linear version) algorithm. GOB.Lin lets the algorithm in Figure 1 operate on each node i of G (we should then add subscript i throughout, replacing wt by wi,t, Mt by Mi,t, and so forth). The updates Mi,t\u22121 \u2192 Mi,t and bi,t\u22121 \u2192 bi,t are performed at node i through vector x\u0304t both when i = it (i.e., when node i is the one which the context vectors in Cit refer to) and to a lesser extent when i 6= it (i.e., when node i is not the one which the vectors in Cit refer to). This is because, as we said, the payoff at received for node it is somehow informative also for all other nodes i 6= it. In other words, because we are assuming the underlying parameter vectors ui are close to each other, we should let the corresponding prototype vectors wi,t undergo similar updates, so as to also keep the wi,t close to each other over time.\nWith this in mind, we now describe GOB.Lin in more detail. It is convenient to introduce first some extra matrix notation. Let A = In + L, where L is the Laplacian matrix associated with G, and In is the n \u00d7 n identity matrix. Set A\u2297 = A \u2297 Id, the Kronecker product2 of matrices A and Id. Moreover, the\n2 The Kronecker product between two matrices M \u2208 Rm\u00d7n and N \u2208 Rq\u00d7r is the block matrix M \u2297N of dimension mq \u00d7 nr whose block on row i and column j is the q \u00d7 r matrix Mi,jN .\n\u201ccompound\u201d descriptor for the pairing (i,x) is given by the long (and sparse)\nvector \u03c6i(x) \u2208 Rdn defined as\n\u03c6i(x) > = ( 0, . . . , 0\ufe38 \ufe37\ufe37 \ufe38\n(i\u22121)d times ,x>, 0, . . . , 0\ufe38 \ufe37\ufe37 \ufe38 (n\u2212i)d times\n) .\nWith the above notation handy, a compact description of GOB.Lin is presented in Figure 2, where we deliberately tried to mimic the pseudocode of Figure 1. Notice that in Figure 2 we overloaded the notation for the confidence bound cbt, which is now defined in terms of the Laplacian L of G. In particular, \u2016u\u2016 in Figure 1 is replaced in Figure 2 by \u2016U\u0303\u2016, where U\u0303 = A1/2\u2297 U and we define U = (u>1 ,u > 2 , . . . ,u > n ) > \u2208 Rdn. Clearly enough, the potentially unknown quantities \u2016u\u2016 and \u2016U\u0303\u2016 in the two expressions for cbt can be replaced by suitable upper bounds.\nWe now explain how the modified long vectors \u03c6\u0303t,k = A \u22121/2 \u2297 \u03c6it(xt,k) act in the update of matrix Mt and vector bt. First, observe that if A\u2297 were the identity matrix then, according to how the long vectors \u03c6it(xt,k) are defined, Mt would be a block-diagonal matrix Mt = diag(D1, . . . , Dn), whose i-th block Di is the d\u00d7 d matrix Di = Id + \u2211 t : kt=i xtx > t . Similarly, bt would be the dn-\nlong vector whose i-th d-dimensional block contains \u2211 t : kt=i\natxt. This would be equivalent to running n independent linear bandit algorithms (Figure 1), one per node of G. Now, because A\u2297 is not the identity, but contains graph G represented through its Laplacian matrix, the selected vector xt,kt \u2208 Cit for node it gets spread via A \u22121/2 \u2297 from the it-th block over all other blocks, thereby making the contextual information contained in xt,kt available to update the internal status of all other nodes. Yet, the only reward signal observed at time t is the one available at node it. A theoretical analysis of GOB.Lin relying on the learning model of Section 3 is sketched in Section 4.1.\nGOB.Lin\u2019s running time is mainly affected by the inversion of the dn \u00d7 dn matrix Mt, which can be performed in time of order (dn)\n2 per round by using well-known formulas for incremental matrix inversions. The same quadratic dependence holds for memory requirements. In our experiments, we observed that projecting the contexts on the principal components improved performance. Hence, the quadratic dependence on the context vector dimension d is not really hurting us in practice. On the other hand, the quadratic dependence on the number of nodes n may be a significant limitation to GOB.Lin\u2019s practical deployment. In the next section, we show that simple graph compression schemes (like node clustering) can conveniently be applied to both reduce edge noise and bring the algorithm to reasonable scaling behaviors."}, {"heading": "4.1 Regret Analysis", "text": "We now provide a regret analysis for GOB.Lin that relies on the high probability analysis contained in [1] (Theorem 2 therein). The analysis can be seen as a combination of the multitask kernel contained in, e.g., [8, 17, 12] and a version of the linear bandit algorithm described and analyzed in [1].\nTheorem 1. Let the GOB.Lin algorithm of Figure 2 be run on graph G = (V,E), V = {1, . . . , n}, hosting at each node i \u2208 V vector ui \u2208 Rd. Define\nL(u1, . . . ,un) = \u2211 i\u2208V \u2016ui\u20162 + \u2211 (i,j)\u2208E \u2016ui \u2212 uj\u20162 .\nLet also the sequence of context vectors xt,k be such that \u2016xt,k\u2016 \u2264 B, for all k = 1, . . . , ct, and t = 1, . . . , T . Then the cumulative regret satisfies\nT\u2211 t=1 rt \u2264 2\n\u221a T ( 2\u03c32 ln\n|MT | \u03b4 + 2L(u1, . . . ,un)\n) (1 +B2) ln |MT |\nwith probability at least 1\u2212 \u03b4.\nCompared to running n independent bandit algorithms (which corresponds to A\u2297 being the identity matrix), the bound in the above theorem has an extra term \u2211 (i,j)\u2208E \u2016ui \u2212 uj\u20162, which we assume small according to our working assumption. However, the bound has also a significantly smaller log determinant ln |MT | on the resulting matrix MT , due to the construction of \u03c6\u0303t,k via A\u22121/2\u2297 . In particular, when the graph is very dense, the log determinant in GOB.Lin is a factor n smaller than the corresponding term for the n independent bandit case (see, e.g.,[8], Section 4.2 therein). To make things clear, consider two extreme situations. When G has no edges then tr(MT ) = tr(I) + T = nd + T , hence ln |MT | \u2264 dn ln(1 + T/(dn)). On the other hand, When G is the complete graph then tr(MT ) = tr(I) + 2t/(n+ 1) = nd+ 2T/(n+ 1), hence ln |MT | \u2264 dn ln(1+2T/(dn(n+1))). The exact behavior of ln |Mt| (one that would ensure a significant advantage in practice) depends on the actual interplay between the data and the graph, so that the above linear dependence on dn is really a coarse upper bound."}, {"heading": "5 Experiments", "text": "In this section, we present an empirical comparison of GOB.Lin (and its variants) to linear bandit algorithms which do not exploit the relational information provided by the graph. We run our experiments by approximating the cbt func-\ntion in Figure 1 with the simplified expression \u03b1 \u221a x>t,kM \u22121 t\u22121xt,k log(t+ 1), and the cbt function in Figure 2 with the corresponding expression in which xt,k is replaced by \u03c6\u0303t,k. In both cases, the factor \u03b1 is used as tunable parameter. Our preliminary experiments show that this approximation does not affect the predictive performances of the algorithms, while it speeds up computation significantly. We tested our algorithm and its competitors on a synthetic dataset and two freely available real-world datasets extracted from the social bookmarking web service Delicious and from the music streaming service Last.fm. These datasets are structured as follows.\n4Cliques. This is an artificial dataset whose graph contains four cliques of 25 nodes each to which we added graph noise. This noise consists in picking a random pair of nodes and deleting or creating an edge between them. More precisely, we created a n \u00d7 n symmetric noise matrix of random numbers in [0, 1], and we selected a threshold value such that the expected number of matrix elements above this value is exactly some chosen noise rate parameter. Then we set to 1 all the entries whose content is above the threshold, and to zero the remaining ones. Finally, we XORed the noise matrix with the graph adjacency matrix, thus obtaining a noisy version of the original graph.\nLast.fm. This is a social network containing 1,892 nodes and 12,717 edges. There are 17,632 items (artists), described by 11,946 tags. The dataset contains information about the listened artists, and we used this information in order to create the payoffs: if a user listened to an artist at least once the payoff is 1, otherwise the payoff is 0.\nDelicious. This is a network with 1,861 nodes and 7,668 edges. There are 69,226 items (URLs) described by 53,388 tags. The payoffs were created using the information about the bookmarked URLs for each user: the payoff is 1 if the user bookmarked the URL, otherwise the payoff is 0.\nLast.fm and Delicious were created by the Information Retrieval group at Universidad Autonoma de Madrid for the HetRec 2011 Workshop [6] with the goal of investigating the usage of heterogeneous information in recommendation systems.3 These two networks are structurally different: on Delicious, payoffs depend on users more strongly than on Last.fm. In other words, there are more popular artists, whom everybody listens to, than popular websites, which everybody bookmarks \u2014see Figure ??. This makes a huge difference in practice, and the choice of these two datasets allow us to make a more realistic comparison of recommendation techniques. Since we did not remove any items from these datasets (neither the most frequent nor the least frequent), these differences do influence the behavior of all algorithms \u2014see below.\nSome statistics about Last.fm and Delicious are reported in Table 1. In Figure ?? we plotted the distribution of the number of preferences per item in order to make clear and visible the differences explained in the previous paragraphs.4\n3 Datasets and their full descriptions are available at www.grouplens.org/node/462. 4 In the context of recommender systems, these two datasets may be seen as representatives of two \u201cmarkets\u201d whose products have significantly different market shares (the well-known dichotomy of hit vs. niche products). Niche product markets give rise to power laws in user preference statistics (as in the blue plot of Figure ??).\nWe preprocessed datasets by breaking down the tags into smaller tags made up of single words. In fact, many users tend to create tags like \u201cwebdesign tutorial css\u201d. This tag has been splitted into three smaller tags corresponding to the three words therein. More generally, we splitted all compound tags containing underscores, hyphens and apexes. This makes sense because users create tags independently, and we may have both \u201crock and roll\u201d and \u201crock n roll\u201d. Because of this splitting operation, the number of unique tags decreased from 11,946 to 6,036 on Last.fm and from 53,388 to 9,949 on Delicious. On Delicious, we also removed all tags occurring less than ten times.5 The algorithms we tested do not use any prior information about which user provided a specific tag. We used all tags associated with a single item to create a TF-IDF context vector that uniquely represents that item, independent of which user the item is proposed to. In both datasets, we only retained the first 25 principal components of context vectors, so that xt,k \u2208 R25 for all t and k. We generated random context sets Cit of size 25 for Last.fm and Delicious, and of size 10 for 4Cliques. In practical scenarios, these numbers would be varying over time, but we kept them fixed so as to simplify the experimental setting. In 4Cliques we assigned the same unit norm random vector ui to every node in the same clique i of the original graph (before adding graph noise). Payoffs were then generated according to the following stochastic model: ai(x) = u > i x + , where (the payoff noise) is uniformly distributed in a bounded interval centered around zero. For Delicious and Last.fm, we created a set of context vectors for every round t as follows: we first picked it uniformly at random in {1, . . . , n}. Then, we generated context vectors xt,1, . . . ,xt,25 in Cit by picking 24 vectors at random from the dataset and one among those vectors with nonzero payoff for user it. This is necessary in order to avoid a meaningless comparison: with high probability, a purely random selection would result in payoffs equal to zero for all the context vectors in Cit .\n5 We did not repeat the same operation on Last.fm because this dataset was already extremely sparse.\nIn our experimental comparison, we tested GOB.Lin and its variants against two baselines: a baseline LinUCB-IND that runs an independent instance of the algorithm in Figure 1 at each node (this is equivalent to running GOB.Lin in Figure 2 with A\u2297 = Idn) and a baseline LinUCB-SIN, which runs a single instance of the algorithm in Figure 1 shared by all the nodes. LinUCB-IND lends itself to be a reasonable comparator when, as in the Delicious dataset, there are many moderately popular items. On the other hand, LinUCB-SIN is a competitive baseline when, as in the Last.fm dataset, there are few very popular items. The two scalable variants of GOB.Lin which we empirically\nanalyzed are based on node clustering,6 and are defined as follows.\nGOB.Lin.MACRO: GOB.Lin is run on a weighted graph whose nodes are the clusters of the original graph. The edges are weighted by the number of inter-cluster edges in the original graph. When all nodes are clustered together, then GOB.Lin.MACRO recovers the baseline LinUCB-SIN as a special case. In order to strike a good trade-off between the speed of the algorithms and the loss\n6 We used the freely available Graclus graph clustering tool, whose interns are described, e.g., in [11]. We used Graclus with normalized cut, zero local search steps, and no spectral clustering options.\nof information resulting from clustering, we tested three different cluster sizes: 50, 100, and 200. Our plots refer to the best performing choice.\nGOB.Lin.BLOCK: GOB.Lin is run on a disconnected graph whose connected components are the clusters. This makes A\u2297 and Mt (Figure 2) block-diagonal matrices. When each node is clustered individually, then GOB.Lin.BLOCK recovers the baseline LinUCB-IND as a special case. Similar to GOB.Lin.MACRO, in order to trade-off running time and cluster sizes, we tested three different cluster sizes (5, 10, and 20), and report only on the best performing choice.\nAs the running time of GOB.Lin scales quadratically with the number of nodes, the computational savings provided by the clustering are also quadratic. Moreover, as we will see in the experiments, the clustering acts as a regularizer, limiting the influence of noise. In all cases, the parameter \u03b1 in Figures 1 and 2 was selected based on the scale of instance vectors x\u0304t and \u03c6\u0303t,kt , respectively, and tuned across appropriate ranges. Table 2 and Figure 3 show the cumulative reward for each algorithm, as compared (\u201cnormalized\u201d) to that of the random predictor, that is \u2211 t(at\u2212a\u0304t), where at is the payoff obtained by the algorithm and a\u0304t is the payoff obtained by the random predictor, i.e., the average payoff over the context vectors available at time t. Table 2 (synthetic datasets) shows that GOB.Lin and LinUCB-SIN are more robust to payoff noise than LinUCB-IND. Clearly, LinUCB-SIN is also unaffected by graph noise, but it never outperforms GOB.Lin. When the payoff noise is low and the graph noise grows GOB.Lin\u2019s performance tends to degrade. Figure 3 reports the results on the two real-world datasets. Notice that GOB.Lin and its variants always outperform the baselines (not relying on graphical information) on both datasets. As expected, GOB.Lin.MACRO works best on Last.fm, where many users gave positive payoffs to the same few items. Hence, macro nodes apparently help GOB.Lin.MACRO to perform better than its corresponding baseline LinUCB-SIN. In fact, GOB.Lin.MACRO also outperforms GOB.Lin, thus showing the regularization effect of using macro nodes. On Delicious, where we have many moderately popular items, GOB.Lin.BLOCK tends to perform best, GOB.Lin being the runner-up. As expected, LinUCB-IND works better than LinUCB-SIN, since the former is clearly more prone to personalize item recommendation than the latter. In summary, we may conclude that our system is able to exploit the information provided by the graphical structure. Moreover, regularization via graph clustering seems to be of significant help. Future work will consider experiments against different methods for sharing contextual and feedback information in a set of users, such as the feature hashing technique of [22]."}, {"heading": "A Appendix", "text": "This appendix contains the proof of Theorem 1.\nProof. Recall that\nU\u0303 = A 1/2 \u2297 U where U = (u > 1 ,u > 2 , . . . ,u > n ) > \u2208 Rdn .\nLet then t be a fixed time step, and introduce the following shorthand notation:\nx\u2217t = argmax k=1,...,ct\nu>itxt,k and \u03c6\u0303 \u2217 t = argmax\nk=1,...,ct\nU\u0303>\u03c6\u0303t,k .\nNotice that, for any k we have\nU\u0303>\u03c6\u0303t,k = U >A 1/2 \u2297 A \u22121/2 \u2297 \u03c6it(xt,k) = U >\u03c6it(xt,k) = u > itxt,k .\nHence we decompose the time-t regret rt as follows:\nrt = u > itx \u2217 t \u2212 u>itxt,kt\n= U\u0303>\u03c6\u0303 \u2217 t \u2212 U\u0303>\u03c6\u0303t,kt = U\u0303>\u03c6\u0303 \u2217 t \u2212w>t\u22121\u03c6\u0303 \u2217 t +w > t\u22121\u03c6\u0303 \u2217 t + cbt(\u03c6\u0303 \u2217 t )\u2212 cbt(\u03c6\u0303 \u2217 t )\u2212 U\u0303>\u03c6\u0303t,kt \u2264 U\u0303>\u03c6\u0303 \u2217 t \u2212w>t\u22121\u03c6\u0303 \u2217 t +w > t\u22121\u03c6\u0303t,kt + cbt(\u03c6\u0303t,kt)\u2212 cbt(\u03c6\u0303 \u2217 t )\u2212 U\u0303>\u03c6\u0303t,kt ,\nthe inequality deriving from\nw>t\u22121\u03c6\u0303t,kt + cbt(\u03c6\u0303t,kt) \u2265 w > t\u22121\u03c6\u0303t,k + cbt(\u03c6\u0303t,k), k = 1, . . . , ct.\nAt this point, we rely on [1] (Theorem 2 therein with \u03bb = 1) to show that\u2223\u2223U\u0303>\u03c6\u0303\u2217t \u2212w>t\u22121\u03c6\u0303\u2217t \u2223\u2223 \u2264 cbt(\u03c6\u0303\u2217t ) and \u2223\u2223w>t\u22121\u03c6\u0303t,kt \u2212 U\u0303>\u03c6\u0303t,kt\u2223\u2223 \u2264 cbt(\u03c6\u0303t,kt) both hold simultaneously for all t with probability at least 1\u2212 \u03b4 over the noise sequence. Hence, with the same probability,\nrt \u2264 2cbt(\u03c6\u0303t,kt)\nholds uniformly over t. Thus the cumulative regret \u2211T t=1 rt satisfies\nT\u2211 t=1 rt \u2264 \u221a\u221a\u221a\u221aT T\u2211 t=1 r2t\n\u2264 2 \u221a\u221a\u221a\u221aT T\u2211 t=1 ( cbt(\u03c6\u0303t,kt) )2\n\u2264 2 \u221a\u221a\u221a\u221aT (\u03c3\u221aln |MT | \u03b4 + \u2016U\u0303\u2016 )2 T\u2211 t=1 \u03c6\u0303 > t,ktM \u22121 t\u22121\u03c6\u0303t,kt .\nNow, using (see, e.g., [?])\nT\u2211 t=1 \u03c6\u0303 > t,ktM \u22121 t\u22121\u03c6\u0303t,kt \u2264 (1 + maxk=1,...,ct \u2016\u03c6\u0303t,k\u20162) ln |MT | ,\nwith\nmax k=1,...,ct \u2016\u03c6\u0303t,k\u20162 = max k=1,...,ct \u03c6it(xt,k)A \u22121 \u2297 \u03c6it(xt,k)\n\u2264 max k=1,...,ct \u2016\u03c6it(xt,k)\u20162\n= max k=1,...,ct\n\u2016xt,k\u20162\n\u2264 B2 ,\nalong with (a+ b)2 \u2264 2a2 + 2b2 applied with a = \u03c3 \u221a\nln |MT |\u03b4 and b = \u2016U\u0303\u2016 yields\nT\u2211 t=1 rt \u2264 2\n\u221a T ( 2\u03c32 ln\n|MT | \u03b4\n+ 2\u2016U\u0303\u20162 ) (1 +B2) ln |MT | .\nFinally, observing that\n\u2016U\u0303\u20162 = U>A\u2297U = L(u1, . . . ,un)\ngives the desired bound."}], "references": [{"title": "Improved algorithms for linear stochastic bandits", "author": ["Y. Abbasi-Yadkori", "D. P\u00e1l", "C. Szepesv\u00e1ri"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "Graphical models for bandit problems", "author": ["K. Amin", "M. Kearns", "U. Syed"], "venue": "Proceedings of the Twenty-Seventh Conference Uncertainty in Artificial Intelligence", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Algorithms and methods in recommender systems", "author": ["D. Asanov"], "venue": "Berlin Institute of Technology, Berlin, Germany", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Using confidence bounds for exploration-exploitation trade-offs", "author": ["P. Auer"], "venue": "Journal of Machine Learning Research, 3:397\u2013422", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2002}, {"title": "Movie recommendation using random walks over the contextual graph", "author": ["T. Bogers"], "venue": "CARS\u201910: Proceedings of the 2nd Workshop on Context-Aware Recommender Systems", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "and T", "author": ["I. Cantador", "P. Brusilovsky"], "venue": "Kuflik. 2nd Workshop on Information Heterogeneity and Fusion in Recommender Systems ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Leveraging side observations in stochastic bandits", "author": ["S. Caron", "B. Kveton", "M. Lelarge", "S. Bhagat"], "venue": "Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence, pages 142\u2013151", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Linear algorithms for online multitask classification", "author": ["G. Cavallanti", "N. Cesa-Bianchi", "C. Gentile"], "venue": "Journal of Machine Learning Research, 11:2597\u2013 2630", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Contextual bandits with linear payoff functions", "author": ["W. Chu", "L. Li", "L. Reyzin", "R.E. Schapire"], "venue": "Proceedings of the International Conference on Artificial Intelligence and Statistics, pages 208\u2013214", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "Multiclass classification with bandit feedback using adaptive regularization", "author": ["K. Crammer", "C. Gentile"], "venue": "Machine Learning, 90(3):347\u2013383", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "Weighted graph cuts without eigenvectors a multilevel approach", "author": ["I.S. Dhillon", "Y. Guan", "B. Kulis"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on, 29(11):1944\u20131957", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2007}, {"title": "Regularized multi\u2013task learning", "author": ["T. Evgeniou", "M. Pontil"], "venue": "Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining, KDD \u201904, pages 109\u2013117, New York, NY, USA", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Personalized recommendation of social software items based on social relations", "author": ["I. Guy", "N. Zwerdling", "D. Carmel", "I. Ronen", "E. Uziel", "S. Yogev", "S. Ofek- Koifman"], "venue": "Proceedings of the Third ACM Conference on Recommender Sarxiv ystems, pages 53\u201360. ACM", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Bandit problems in networks: Asymptotically efficient distributed allocation rules", "author": ["S. Kar", "H.V. Poor", "S. Cui"], "venue": "Decision and Control and European Control Conference (CDC-ECC), 2011 50th IEEE Conference on, pages 1771\u20131778. IEEE", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "A contextual-bandit approach to personalized news article recommendation", "author": ["L. Li", "W. Chu", "J. Langford", "R.E. Schapire"], "venue": "Proceedings of the 19th International Conference on World Wide Web, pages 661\u2013670. ACM", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2010}, {"title": "From bandits to experts: On the value of sideobservations", "author": ["S. Mannor", "O. Shamir"], "venue": "Advances in Neural Information Processing Systems, pages 684\u2013692", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Kernels for multi\u2013task learning", "author": ["C.A. Micchelli", "M. Pontil"], "venue": "Advances in Neural Information Processing Systems, pages 921\u2013928", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2004}, {"title": "How social relationships affect user similarities", "author": ["A. Said", "E.W. De Luca", "S. Albayrak"], "venue": "Proceedings of the 2010 Workshop on Social Recommender Systems, pages 1\u20134", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}, {"title": "Contextual bandits with similarity information", "author": ["A. Slivkins"], "venue": "Journal of Machine Learning Research \u2013 Proceedings Track, 19:679\u2013702", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Multi-armed bandits in the presence of side observations in social networks", "author": ["B. Swapna", "A. Eryilmaz", "N.B. Shroff"], "venue": "Proceedings of 52nd IEEE Conference on Decision and Control (CDC)", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "Gossip-based distributed stochastic bandit algorithms", "author": ["B. Sz\u00f6r\u00e9nyi", "R. Busa-Fekete", "I. Hegedus", "R. Orm\u00e1ndi", "M. Jelasity", "B. K\u00e9gl"], "venue": "Proceedings of the 30th International Conference on Machine Learning", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2013}, {"title": "Feature hashing for large scale multitask learning", "author": ["K. Weinberger", "A. Dasgupta", "J. Langford", "A. Smola", "J. Attenberg"], "venue": "Proceedings of the 26th International Conference on Machine Learning, pages 1113\u20131120. Omnipress", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 4, "context": "g, [5, 7, 15] ).", "startOffset": 3, "endOffset": 13}, {"referenceID": 6, "context": "g, [5, 7, 15] ).", "startOffset": 3, "endOffset": 13}, {"referenceID": 14, "context": "g, [5, 7, 15] ).", "startOffset": 3, "endOffset": 13}, {"referenceID": 7, "context": ", [8]), is defined in terms of the Laplacian matrix of the graph.", "startOffset": 2, "endOffset": 5}, {"referenceID": 4, "context": ", [5, 13, 18] and the survey [3].", "startOffset": 2, "endOffset": 13}, {"referenceID": 12, "context": ", [5, 13, 18] and the survey [3].", "startOffset": 2, "endOffset": 13}, {"referenceID": 17, "context": ", [5, 13, 18] and the survey [3].", "startOffset": 2, "endOffset": 13}, {"referenceID": 2, "context": ", [5, 13, 18] and the survey [3].", "startOffset": 29, "endOffset": 32}, {"referenceID": 3, "context": "Linear models for contextual bandits were introduced in [4].", "startOffset": 56, "endOffset": 59}, {"referenceID": 14, "context": "Their application to personalized content recommendation was pioneered in [15], where the LinUCB algorithm was introduced.", "startOffset": 74, "endOffset": 78}, {"referenceID": 8, "context": "An analysis of LinUCB was provided in the subsequent work [9].", "startOffset": 58, "endOffset": 61}, {"referenceID": 19, "context": "However, non-contextual stochastic bandits in social networks were studied in a recent independent work [20].", "startOffset": 104, "endOffset": 108}, {"referenceID": 1, "context": "Other works, such as [2, 19], consider contextual bandits assuming metric or probabilistic dependencies on the product space of contexts and actions.", "startOffset": 21, "endOffset": 28}, {"referenceID": 18, "context": "Other works, such as [2, 19], consider contextual bandits assuming metric or probabilistic dependencies on the product space of contexts and actions.", "startOffset": 21, "endOffset": 28}, {"referenceID": 6, "context": "A different viewpoint, where each action reveals information about other actions\u2019 payoffs, is the one studied in [7, 16], though without the context provided by feature vectors.", "startOffset": 113, "endOffset": 120}, {"referenceID": 15, "context": "A different viewpoint, where each action reveals information about other actions\u2019 payoffs, is the one studied in [7, 16], though without the context provided by feature vectors.", "startOffset": 113, "endOffset": 120}, {"referenceID": 13, "context": "A non-contextual model of bandit algorithms running on the nodes of a graph was studied in [14].", "startOffset": 91, "endOffset": 95}, {"referenceID": 20, "context": "More recently, a new model of distributed non-contextual bandit algorithms has been presented in [21], where the number of communications among the nodes is limited, and all the nodes in the network have the same best action.", "startOffset": 97, "endOffset": 101}, {"referenceID": 0, "context": ", (it\u22121, Cit\u22121 , at\u22121) ], we take the general approach of [1], and assume that for any fixed i \u2208 V and x \u2208 R, the variable i(x) is conditionally sub-Gaussian with variance parameter \u03c3 > 0, namely, Et [ exp(\u03b3 i(x)) ] \u2264 exp ( \u03c3 \u03b3/2 ) for all \u03b3 \u2208 R and all x, i.", "startOffset": 58, "endOffset": 61}, {"referenceID": 7, "context": ", [8]), and assume that \u2211", "startOffset": 2, "endOffset": 5}, {"referenceID": 8, "context": ", [9]) operating on the context vectors contained in Cit .", "startOffset": 2, "endOffset": 5}, {"referenceID": 0, "context": ", [1, 9, 10].", "startOffset": 2, "endOffset": 12}, {"referenceID": 8, "context": ", [1, 9, 10].", "startOffset": 2, "endOffset": 12}, {"referenceID": 9, "context": ", [1, 9, 10].", "startOffset": 2, "endOffset": 12}, {"referenceID": 8, "context": "This algorithm can be seen as a version of LinUCB [9], a linear bandit algorithm derived from LinRel [4].", "startOffset": 50, "endOffset": 53}, {"referenceID": 3, "context": "This algorithm can be seen as a version of LinUCB [9], a linear bandit algorithm derived from LinRel [4].", "startOffset": 101, "endOffset": 104}, {"referenceID": 0, "context": "Lin that relies on the high probability analysis contained in [1] (Theorem 2 therein).", "startOffset": 62, "endOffset": 65}, {"referenceID": 7, "context": ", [8, 17, 12] and a version of the linear bandit algorithm described and analyzed in [1].", "startOffset": 2, "endOffset": 13}, {"referenceID": 16, "context": ", [8, 17, 12] and a version of the linear bandit algorithm described and analyzed in [1].", "startOffset": 2, "endOffset": 13}, {"referenceID": 11, "context": ", [8, 17, 12] and a version of the linear bandit algorithm described and analyzed in [1].", "startOffset": 2, "endOffset": 13}, {"referenceID": 0, "context": ", [8, 17, 12] and a version of the linear bandit algorithm described and analyzed in [1].", "startOffset": 85, "endOffset": 88}, {"referenceID": 7, "context": ",[8], Section 4.", "startOffset": 1, "endOffset": 4}, {"referenceID": 0, "context": "More precisely, we created a n \u00d7 n symmetric noise matrix of random numbers in [0, 1], and we selected a threshold value such that the expected number of matrix elements above this value is exactly some chosen noise rate parameter.", "startOffset": 79, "endOffset": 85}, {"referenceID": 5, "context": "fm and Delicious were created by the Information Retrieval group at Universidad Autonoma de Madrid for the HetRec 2011 Workshop [6] with the goal of investigating the usage of heterogeneous information in recommendation systems.", "startOffset": 128, "endOffset": 131}, {"referenceID": 10, "context": ", in [11].", "startOffset": 5, "endOffset": 9}, {"referenceID": 21, "context": "Future work will consider experiments against different methods for sharing contextual and feedback information in a set of users, such as the feature hashing technique of [22].", "startOffset": 172, "endOffset": 176}], "year": 2013, "abstractText": "Multi-armed bandit problems are receiving a great deal of attention because they adequately formalize the exploration-exploitation trade-offs arising in several industrially relevant applications, such as online advertisement and, more generally, recommendation systems. In many cases, however, these applications have a strong social component, whose integration in the bandit algorithm could lead to a dramatic performance increase. For instance, we may want to serve content to a group of users by taking advantage of an underlying network of social relationships among them. In this paper, we introduce novel algorithmic approaches to the solution of such networked bandit problems. More specifically, we design and analyze a global strategy which allocates a bandit algorithm to each network node (user) and allows it to \u201cshare\u201d signals (contexts and payoffs) with the neghboring nodes. We then derive two more scalable variants of this strategy based on different ways of clustering the graph nodes. We experimentally compare the algorithm and its variants to state-of-the-art methods for contextual bandits that do not use the relational information. Our experiments, carried out on synthetic and real-world datasets, show a marked increase in prediction performance obtained by exploiting the network structure. 1 ar X iv :1 30 6. 08 11 v3 [ cs .L G ] 4 N ov 2 01 3", "creator": "LaTeX with hyperref package"}}}