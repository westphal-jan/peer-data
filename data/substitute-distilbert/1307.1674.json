{"id": "1307.1674", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Jul-2013", "title": "Stochastic Optimization of PCA with Capped MSG", "abstract": "we study pca as a stochastic optimization problem and expect a novel stochastic approximation algorithm which we refer repeatedly as \" matrix stochastic gradient \" ( msg ), as well through a practical variant, capped msg. will study the method both theoretically encountered empirically.", "histories": [["v1", "Fri, 5 Jul 2013 17:39:40 GMT  (88kb,D)", "http://arxiv.org/abs/1307.1674v1", null]], "reviews": [], "SUBJECTS": "stat.ML cs.LG", "authors": ["raman arora", "andrew cotter", "nati srebro"], "accepted": true, "id": "1307.1674"}, "pdf": {"name": "1307.1674.pdf", "metadata": {"source": "CRF", "title": "Stochastic Optimization of PCA with Capped MSG", "authors": ["Raman Arora", "Andrew Cotter"], "emails": ["arora@ttic.edu,", "cotter@ttic.edu,", "nati@ttic.edu"], "sections": [{"heading": "1 Introduction", "text": "Principal Component Analysis (PCA) is a ubiquitous tool used in many data analysis, machine learning and information retrieval applications. It is used for obtaining a lower dimensional representation of a high dimensional signal that still captures as much as possible of the original signal. Such a low dimensional representation can be useful for reducing storage and computational costs, as complexity control in learning systems, or to aid in visualization.\nPCA is typically phrased as a question about a fixed data set: given a data set of n vectors in Rd, what is the k-dimensional subspace that captures most of the variance in the data set (or equivalently, that is best in reconstructing the vectors, minimizing the sum squared distances, or residuals, to the subspace)? It is well known that this subspace is given by the leading k components of the singular value decomposition of the data matrix (or equivalently of the empirical second moment matrix). And so, the study of computational approaches for PCA has mostly focused on methods for finding the SVD (or leading components of the SVD) for a given n \u00d7 d matrix [Oja and Karhunen, 1985, Sanger, 1989, Mitliagkas et al., 2013].\nIn this paper we approach PCA as a stochastic optimization problem, where the goal is to optimize a \u201cpopulation objective\u201d based on i.i.d. draws from the population. That is, in the case of PCA, we consider a setting in which we have some unknown source (\u201cpopulation\u201d) distribution D over Rd, and the goal is to find the k-dimensional subspace maximizing the (uncentered) variance of D inside the subspace (or equivalently, minimizing the average squared residual in the population), based on i.i.d. samples from D. The main point here is that\nar X\niv :1\n30 7.\n16 74\nv1 [\nst at\n.M L\n] 5\nJ ul\nthe true objective is not how well the subspace captures the sample (i.e. the \u201ctraining error\u201d), but rather how well the subspace captures the underlying source distribution (i.e. the \u201cgeneralization error\u201d). Furthermore, we are not concerned here with capturing some \u201ctrue\u201d subspace, and so do not measure the angle to it, but rather at finding a \u201cgood\u201d subspace, that is almost as good as the optimal one.\nOf course, finding the subspace that best captures the sample is a very reasonable approach to PCA on the population. This is essentially an Empirical Risk Minimization (ERM) approach. However, when comparing it to alternative, perhaps computationally cheaper, approaches, we argue that one should not compare the error on the sample, but rather the population objective. Such a view can justify and favor computational approaches that are far from optimal on the sample, but are essentially as good as ERM on the population.\nSuch a population-based view of optimization has recently been advocated in machine learning, and has been used to argue for crude stochastic approximation approaches (online-type methods) over sophisticated deterministic optimization of the empirical (training) objective (i.e. \u201cbatch\u201d methods) [Bottou and Bousquet, 2007, Shalev-Shwartz and Srebro, 2008]. A similar argument was also made in the context of stochastic optimization, where Nemirovski et al. [2009] argues for stochastic approximation (SA) approaches over ERM. Accordingly, SA approaches, mostly variants of Stochastic Gradient Descent, are often the methods of choice for many learning problems, especially when very large data sets are available [Shalev-Shwartz et al., 2007, Collins et al., 2008, ShalevShwartz and Tewari, 2009]. We would like to take the same view in order to advocate for, study, and develop stochastic approximation approaches for PCA.\nIn an empirical study of stochastic approximation methods for PCA, a heuristic \u201cincremental\u201d method showed very good empirical performance [Arora et al., 2012]. However, no theoretical guarantees or justification were given for incremental PCA. In fact, it was shown that for some distributions it can converge to a suboptimal solution with high probability (see Section 5.2 for more about this \u201cincremental\u201d algorithm). Also relevant is careful theoretical work on online PCA by Warmuth and Kuzmin [2008], in which an online regret guarantee was established. Using an online-to-batch conversion, this online algorithm can be converted to a stochastic approximation algorithm with good iteration complexity, however the runtime for each iteration is essentially the same as that of ERM (i.e. of PCA on the sample), and thus senseless as a stochastic approximation method (see Section 3.3 for more on this algorithm).\nIn this paper we borrow from these two approaches and present a novel algorithm for stochastic PCA\u2014the Matrix Stochastic Gradient (MSG) algorithm. MSG enjoys similar iteration complexity to Warmuth\u2019s and Kuzmin\u2019s algorithm, and in fact we present a unified view of both algorithms as different instantiations of Mirror Descent for the same convex relaxation of PCA. We then present the capped MSG, which is a more practical variant of MSG, has very similar updates to those of the \u201cincremental\u201d method, and works well in practice, and does not get stuck like the \u201cincremental\u201d method. The Capped MSG is thus a clean, theoretically well founded method, with interesting connections to other\nstochastic/online PCA methods, and excellent practical performance\u2014a \u201cbest of both worlds\u201d algorithm."}, {"heading": "2 Problem Setup", "text": "We consider PCA as the problem of finding the maximal (uncentered) variance k-dimensional subspace with respect to an (unknown) distribution D over x \u2208 Rd. We assume without loss of generality a scaling such that Ex\u223cD[\u2016x\u20162] \u2264 1. We also require for our analysis a bounded fourth moment: Ex\u223cD[\u2016x\u20164] \u2264 1. We represent a k-dimensional subspace by an orthonormal basis, collected in the columns of a matrix U . With this parametrization, PCA is defined as the following stochastic optimization problem,\nmaximize : Ex\u223cD[xTUUTx] (2.1) subject to : U \u2208 Rd\u00d7k, UTU = I.\nIn a stochastic optimization setting we do not have direct knowledge of the distribution and have access to it only through i.i.d. samples\u2014these can be thought of as \u201ctraining examples\u201d. As with other studies of stochastic approximation methods, we are less concerned with the number of required samples, but rather with the overall runtime required to obtain an -suboptimal solution.\nThe standard approach to (2.1) is empirical risk minimization (ERM): given samples {xt}Tt=1, from the distribution, we compute the empirical covariance matrix C\u0302 = 1T \u2211T t=1 xtx T t , and pick the columns of U to be the eigenvectors of C\u0302 corresponding to the top-k eigenvalues. This approach requires O(d2) memory and O(d2) operations just in order to compute the covariance matrix, plus some additional time for the SVD. We are interested in methods with much lower sample time and space complexity, preferably linear rather than quadratic in d."}, {"heading": "3 MSG and MEG", "text": "A natural stochastic approximation (SA) approach to PCA is to perform projected stochastic gradient descent (SGD) on Problem 2.1, with respect to the variable U . This leads to the stochastic power method with each iteration given as\nU (t+1) = Porth ( U (t) + \u03b7xtx T t ) ,\nwhere, xtx T t is the gradient of the PCA objective w.r.t. U , \u03b7 is a step size, and Porth (\u00b7) projects its argument onto the set of orthogonal matrices. Unfortunately, although SGD is well understood for convex problems, Problem 2.1 is non-convex. Consequently, obtaining a theoretical understanding of the stochastic power method, or of how the step size should be set, has proved elusive. Under some conditions, convergence to the optimal solution can be ensured, but no rate is known [Oja and Karhunen, 1985, Sanger, 1989, Arora et al., 2012].\nInstead, we consider a re-parameterization of the PCA problem where the objective is convex. Instead of representing a linear subspace in terms of its basis matrix, U , we parametrize it using the corresponding projection matrix M = UUT . We can now reformulate the PCA problem as\nmaximize : Ex\u223cD[xTMx] (3.1) subject to : M \u2208 Rd\u00d7d, \u03c3i (M) \u2208 {0, 1} , rankM = k,\nwhere \u03c3i (M) is the i th eigenvalue of M .\nWe now have a convex (even linear) objective, but the constraints in (3.1) are not convex. This prompts us to consider its convex relaxation:\nmaximize : Ex\u223cD[xTMx] (3.2) subject to : M \u2208 Rd\u00d7d, 0 M I, trM = k.\nSince the objective is linear, and the constraint set of (3.2) is just the convex hull of the constraints of (3.1), an optimum of (3.2) is always attained at a \u201cvertex\u201d, i.e. a point on the boundary of the original constraints (3.1). The optimum of (3.1) and (3.2) are thus the same (strictly speaking\u2014every optimum of (3.1) is also an optimum of (3.2)), and solving (3.2) is equivalent to solving (3.1).\nFurthermore, even if some -suboptimal solution we find for (3.2) is not rankk, i.e. is not a feasible point of (3.1), we can easily sample from it a rank-k solution, feasible for (3.1), with the same value (in expectation). This follows from the following result of Warmuth and Kuzmin [2008].\nLemma 3.1 (Rounding [Warmuth and Kuzmin, 2008]). Any feasible solution of (3.2) can be expressed as a convex combination of at most d feasible solutions of (3.1).\nFurthermore, Algorithm 4.1 of Warmuth and Kuzmin [2008] shows how to efficiently find such a convex combination. Since the objective is linear, treating the coefficients of the convex combination as sampling weights and choosing randomly among the d components yields a rank-k matrix with the desired objective function value, in expectation."}, {"heading": "3.1 Matrix Stochastic Gradient", "text": "Performing SGD on the convex Problem 3.2 (w.r.t. the variable M) yields the following iterates: M (t+1) = P ( M (t) + \u03b7xtx T t ) , (3.3)\nwhere the projection is now performed onto the (convex) constraints of (3.2). The Matrix Stochastic Gradient (MSG) algorithm entails:\n1. Choose step-size \u03b7, iteration count T , and starting point M (0). 2. Iterate the updates (3.3) T times, each time using an independent sample xt \u223c D.\n3. Average the iterates as M\u0304 = 1T \u2211T t=1M (t).\nAlgorithm 1 Matrix stochastic gradient (MSG) update: compute an eigendecomposition of M \u2032 + \u03b7xxT from a rank-n eigendecomposition M \u2032 = U \u2032diag(\u03c3\u2032)(U \u2032)T and project the resulting solution onto the constraint set. The computational cost of this algorithm is dominated by the matrix multiplication defining U (line 4 or 7) costing O(m2d) operations.\nmsg-step ( d, k,m : N, U \u2032 : Rd\u00d7m, \u03c3\u2032 : Rm, x : Rd, \u03b7 : R ) 1 x\u0302\u2190 \u221a\u03b7(U \u2032)Tx; x\u22a5 \u2190 \u221a \u03b7x\u2212 U \u2032x\u0302; r \u2190 \u2016x\u22a5\u2016; 2 if r > 0 3 V, \u03c3 \u2190 eig([diag(\u03c3\u2032) + x\u0302x\u0302T , rx\u0302; rx\u0302T , r2]); 4 U \u2190 [U \u2032, x\u22a5/r]V ; 5 else 6 V, \u03c3 \u2190 eig(diag(\u03c3\u2032) + x\u0302x\u0302T ); 7 U \u2190 U \u2032V ; 8 \u03c3 \u2190 distinct eigenvalues in \u03c3; \u03ba\u2190 corresponding multiplicities; 9 \u03c3 \u2190 project (d, k,m, \u03c3, \u03ba);\n10 return U, \u03c3;\n4. Sample a rank-k solution M\u0303 from M\u0304 using the rounding procedure discussed in the previous section. Analyzing MSG is straightforward using the standard SGD analysis [Nemirovski and Yudin, 1983]: Theorem 1. After T iterations of MSG (on Problem 3.2), with step size \u03b7 =\u221a k T , and starting at M (0) = 0,\nE[Ex\u223cD[xT M\u0303x]] \u2265 Ex\u223cD[xTM\u2217x]\u2212 1\n2\n\u221a k\nT ,\nwhere the expectation is w.r.t. the i.i.d. samples x1, . . . , xT \u223c D and the rounding, and M\u2217 is the optimum of (3.1).\nProof. Standard SGD analysis of Nemirovski and Yudin [1983] yields that\nE[xTM\u2217x\u2212 xT M\u0304x] \u2264 \u03b7 2 Ex\u223cD[\u2016g\u20162F ] + \u2016M\u2217 \u2212M (0)\u20162F 2\u03b7T , (3.4)\nwhere g = xxT is the gradient of the PCA objective. Now, Ex\u223cD[\u2016g\u20162F ] = Ex\u223cD[\u2016x\u20164] \u2264 1 and \u2225\u2225M\u2217 \u2212M (0)\u2225\u22252 F\n= \u2016M\u2217\u20162F = k. In the last inequality, we used the fact that M\u2217 has k eigenvalues of value 1 each, and hence \u2016M\u2217\u2016F =\u221a k."}, {"heading": "3.2 Efficient Implementation and Projection", "text": "A naive implementation of the MSG update requires O(d2) memory and O(d2) operations per iteration. In this section, we show how to perform this update\nefficiently by maintaining an up-to-date eigendecomposition of M (t). Pseudocode for the update is given as Algorithm 1. Consider the eigendecomposition M (t) = U \u2032diag(\u03c3)(U \u2032)T , at the tth iteration, where rank(M (t)) = kt and U\n\u2032 \u2208 Rd\u00d7kt . Given a new observation xt, the eigendecomposition of M (t) + \u03b7xtxTt can be updated efficiently using a (kt + 1)\u00d7 (kt + 1) SVD [Brand, 2002, Arora et al., 2012] (steps 1-7 of Algorithm 1). This rank-one eigen-update is followed by projection onto the constraints of (3.2), invoked as project in step 8 of Algorithm 1, discussed in the following paragraphs and given as Algorithm 2. The projection procedure is based on the following lemma1:\nLemma 3.2. Let M \u2032 \u2208 Rd\u00d7d be a symmetric matrix, with eigenvalues \u03c3\u20321, . . . , \u03c3\u2032d and associated eigenvectors v\u20321, . . . , v \u2032 d. Its projection M = P (M \u2032) onto the feasible region of Problem 3.2 with respect to the Frobenius norm, is the unique feasible matrix which has the same eigenvectors as M \u2032, with the associated eigenvalues \u03c31, . . . , \u03c3d satisfying:\n\u03c3i = max (0,min (1, \u03c3 \u2032 i + S))\nwith S \u2208 R being chosen in such a way that \u2211d\ni=1 \u03c3i = k.\nProof. In Appendix A.\nThis result shows that projecting onto the feasible region amounts to finding the value of S such that, after shifting the eigenvalues by S and clipping the results to [0, 1], the result is feasible. Importantly, the projection operates only on the eigenvalues. Algorithm 2 contains pseudocode which finds S from a list of eigenvalues. It is optimized to efficiently handle repeated eigenvalues\u2014 rather than receiving the eigenvalues in a length-d list, it instead receives a length-n list containing only the distinct eigenvalues, with \u03ba containing the corresponding multiplicities. In Sections 4 and 5, we will see why this is an important optimization.\nThe central idea motivating the algorithm is that, in a sorted array of eigenvalues, all elements with indices below some threshold i will be clipped to 0, and all of those with indices above another threshold j will be clipped to 1. The pseudocode simply searches over all possible pairs of such thresholds until it finds the one that works.\nThe rank-one eigen-update combined with the fast projection step yields an efficient MSG update that requires O(dkt) memory and O(dk 2 t ) operations per iteration, where recall that kt is the rank of the iterate M (t). This is a significant improvement over the O(d2) memory and O(d2) computation required by a standard implementation of MSG, if the iterates have relatively low rank.\n1Note that our projection problem onto the capped simplex, even when seen in the vector setting, is substantially different from Duchi et al. [2008]. We project onto the set {0 \u2264 \u03c3 \u2264 1, \u2016\u03c3\u20161 = k} in (3.2) and {0 \u2264 \u03c3 \u2264 1, \u2016\u03c3\u20161 = k, \u2016\u03c3\u20160 \u2264 K} in (5.1) whereas Duchi et al. [2008] project onto {0 \u2264 \u03c3, \u2016\u03c3\u20161 = k}.\nAlgorithm 2 Routine which finds the S of Lemma 3.2. It takes as parameters the dimension d, \u201ctarget\u201d subspace dimension k, and the number of distinct eigenvalues n of the current iterate. The length-n arrays \u03c3\u2032 and \u03ba\u2032 contain the distinct eigenvalues and their multiplicities, respectively, of M \u2032 (with \u2211n i=1 \u03ba \u2032 i = d). Line 1 sorts \u03c3\n\u2032 and re-orders \u03ba\u2032 so as to match this sorting. The loop will be run at most 2n times (once for each possible increment to i or j on lines 12\u201315), so the computational cost is dominated by that of the sort: O(n logn).\nproject (d, k, n : N, \u03c3\u2032 : Rn, \u03ba\u2032 : Nn) 1 \u03c3\u2032, \u03ba\u2032 \u2190 sort(\u03c3\u2032, \u03ba\u2032); 2 i\u2190 1; j \u2190 1; si \u2190 0; sj \u2190 0; ci \u2190 0; cj \u2190 0; 3 while i \u2264 n 4 if (i < j) 5 S \u2190 (k \u2212 (sj \u2212 si)\u2212 (d\u2212 cj))/(cj \u2212 ci); 6 b\u2190 ( 7 (\u03c3\u2032i + S \u2265 0) and (\u03c3\u2032j\u22121 + S \u2264 1) 8 and ((i \u2264 1) or (\u03c3\u2032i\u22121 + S \u2264 0)) 9 and ((j \u2265 n) or (\u03c3\u2032j+1 \u2265 1))\n10 ); 11 return S if b; 12 if (j \u2264 n) and (\u03c3\u2032j \u2212 \u03c3\u2032i \u2264 1) 13 sj \u2190 sj + \u03ba\u2032j\u03c3\u2032j ; cj \u2190 cj + \u03ba\u2032j ; j \u2190 j + 1; 14 else 15 si \u2190 si + \u03ba\u2032i\u03c3\u2032i; ci \u2190 ci + \u03ba\u2032i; i\u2190 i+ 1; 16 return error;"}, {"heading": "3.3 Matrix Exponentiated Gradient", "text": "Since M is constrained by its trace, and not by its Frobenius norm, it is tempting to consider mirror descent (MD) [Beck and Teboulle, 2003] instead of SGD updates for solving Problem 3.2. Recall that the Mirror Descent updates depend on a choice of \u201cpotential function\u201d \u03a8(\u00b7) which should be chosen according to the geometry of the feasible set and the subgradients [Srebro et al., 2011]. Using the squared Frobenius norm as a potential function, i.e. \u03a8(M) = \u2016M\u20162F , yields SGD, i.e. the MSG updates (3.3). The trace-norm constraint suggests using the von Neumann entropy of the spectrum as the potential function, i.e. \u03a8h(M) = \u2211 i \u03bbi(M) log \u03bbi(M) where \u03bbi are the eigenvalues of M . This leads to multiplicative updates which we refer to as Matrix Exponentiated Gradient (MEG) update similar to those presented by [Warmuth and Kuzmin, 2008]. In fact, Warmuth and Kuzmin\u2019s algorithm exactly corresponds to online Mirror Descent on (3.2) with this potential function, but taking the optimization variable to be M\u22a5 = I \u2212M (with the constraints trM\u22a5 = d\u2212 k and 0 M\u22a5 I). In either case, using the entropy potential, despite being well suited for the trace-geometry, does not actually lead to better dependence2 on d or k, and\n2This is because in our case, due to the other constraints, \u2016M\u2217\u2016F = \u221a\ntrM\u2217. Furthermore, the SGD analysis depends on the Frobenius norm of the stochastic gradients, but since all stochastic gradients are rank one, this is the same as their spectral norm, which comes up in\nMirror Descent analysis again yields an excess loss of \u221a k/T . Warmuth and Kuzmin do present an \u201coptimistic\u201d analysis, with a dependence on the \u201creconstruction error\u201d L\u2217 = E[xT (I \u2212 M\u2217)x], which yields an excess error of\nO\n(\u221a L\u2217k log(d/k)\nT + k log(d/k) T\n) (their logarithmic term can be avoided by a more\ncareful analysis)."}, {"heading": "4 MSG runtime and the rank of the iterates", "text": "As we saw, MSG requires O(k/ 2) iterations to obtain an -suboptimal solution and each iteration of MSG costs O(k2t d) operations where kt is the rank of\niterate M (t). This yields a total runtime of O(k\u03042dk/ 2), where k\u03042 = \u2211T\nt=1 k 2 t .\nClearly, the runtime for MSG depends critically on the rank of the iterates. If the rank of the iterates is as large as d, MSG achieves a runtime that is cubic in the dimensionality. On the other hand, if the rank of the iterates is O(k), the runtime is linear in the dimensionality. Fortunately, in practice the ranks are typically much lower than the dimensionality. The reason for this is that MSG performs a rank-1 update followed by a projection onto the constraints. Since M \u2032 = M (t) + \u03b7xtx T t will have a larger trace than M\n(t) (i.e. trM \u2032 \u2265 k), the projection, as is shown by Lemma 3.2, will subtract a quantity S from every eigenvalue of M \u2032, clipping each to 0 if it becomes negative. Therefore, each MSG update will increase the rank of the iterate by at most 1, and has the potential to decrease it, perhaps significantly. It\u2019s very difficult to theoretically quantify how the rank of the iterates will evolve over time, but we have observed empirically that the iterates do tend to have relatively low rank.\nWe explore this issue in greater detail experimentally, on a distribution which we expect to be difficult for MSG. To this end, we generated data from known 32- dimensional distributions with diagonal covariance matrices \u03a3 = diag(\u03c3/ \u2016\u03c3\u2016), where \u03c3i = \u03c4 \u2212i/ \u221132 j=1 \u03c4 \u2212j , for i = 1, . . . , 32 and for some \u03c4 > 1. Observe that \u03a3(k) has a smoothly-decaying set of eigenvalues and the rate of decay is controlled by \u03c4 . As \u03c4 \u2192 1, the spectrum becomes flatter resulting in distributions that present challenging test cases for MSG. We experimented with \u03c4 = 1.1 and k \u2208 {1, 2, 4}, where k is the desired subspace dimension used by each algorithm. The data is generated by sampling the ith standard unit basis vector ei with probability \u221a \u03a3ii. We refer to this as the \u201corthogonal distribution\u201d, since it is a discrete distribution over 32 orthogonal vectors. In Figure 1, we show the results with k = 4. We can see from the left-hand plot that MSG algorithm maintains a subspace of dimension around 15. The plot on the right shows how the set of nonzero eigenvalues of the MSG iterates evolves over time, from which we can see that many of the extra dimensions are \u201cwasted\u201d on very small eigenvalues, corresponding to directions which leave the state matrix only a handful of iterations after they enter. This suggests that constraining k\u2032t can lead to significant speedups and motivates capped MSG\nthe entropy-case analysis, and again there is no benefit.\nupdates discussed in the next section."}, {"heading": "5 Capped MSG", "text": "While, as was observed in the previous section, MSG\u2019s iterates will tend to have ranks k\u2032t smaller than d, they will nevertheless also be larger than k. For this reason, in practice, we recommend adding a hard constraint K on the rank of the iterates:\nmaximize : Ex\u223cD[xTMx] (5.1) subject to : M \u2208 Rd\u00d7d, 0 M I\ntrM = k, rankM \u2264 K\nWe will refer MSG where the projection is replaced with a projection onto the constraints of (5.1) (i.e. where the iterates are SGD iterates on (5.1)) as \u201ccapped MSG\u201d. For similar reasons as discussed before, as long as K \u2265 k, Problem 5.1 and Problem 3.2 have the same optimum, and it is achieved at a rank-k matrix, and the extra rank constraint in 5.1 is inactive at the optimum. However, the rank constraint does affect the iterates, especially since Problem 5.1 is no longer convex. Nonetheless if K > k (i.e. the hard rank-constraint K is strictly larger than the target rank k), we can easily check if we are at a global optimum of 5.1, and hence of 3.2: if the capped MSG algorithm converges to a solution of rank K, then the upper bound K should be increased. Conversely, if it has converged to a rank-deficient solution, then it must be the global optimum. There is thus an advantage in using K > k, and we recommend setting K = k + 1, as we do in our experiments, and increasing K only if a rank deficient solution is not found.\nSetting K = k, the only way to satisfy the trace constraint is to have all non-zero eigenvalues be equal to one, and (5.1) becomes identical to (3.1). The detour through the convex problem (3.2), allows us to increase the search rank K, allowing for more flexibility in the search, while still encouraging the desired rank k through the rank constraint."}, {"heading": "5.1 Implementing the projection", "text": "Implementing capped MSG is similar to implementing MSG (Algorithm 1) except for the projection step. Reasoning as in the proof of Lemma 3.2 shows that if M (t+1) =P (M \u2032) with M \u2032 = M (t) + \u03b7xtxTt , then M (t) and M \u2032 are simultaneously diagonalizable, and therefore we can consider only how the projection acts on the eigenvalues. Hence, if we let \u03c3\u2032 be the vector of the eigenvalues of M \u2032, and suppose that there are more than K such eigenvalues, then there is a sizeK subset of \u03c3\u2032 such that applying Algorithm 2 to this set gives the projected eigenvalues. Since we perform only a rank-1 update at every iteration, we must check at most K possibilities, at a total cost of O(K2 logK) operations, with no effect on asymptotic runtime because Algorithm 1 requires O(K2d) operations."}, {"heading": "5.2 Relationship to the incremental PCA method", "text": "The capped MSG updates with K = k are similar to the incremental algorithm of Arora et al. [2012]. The incremental algorithm maintains a rank-k approximation of the covariance matrix with updates given by\nM (t+1) = Prank-k ( M (t) + xtx T t ) ,\nwhere the projection is onto the set of rank-k matrices. Unlike MSG, incremental updates do not have a step-size. Updates can be performed efficiently much in the same way as described in Section 3.2, by maintaining the eigendecomposition of the iterates.\nThe incremental algorithm was found to perform extremely well in practice\u2013 it was the best, in fact, among the compared algorithms [Arora et al., 2012].\nHowever, there exist cases in which the incremental algorithm can get stuck at a suboptimal solution. For example, If the data are drawn from a discrete distribution D which samples [ \u221a 3, 0]T with probability 1/3 and [0, \u221a 2]T with probability 2/3, and one runs the incremental algorithm with k = 1, then it will converge to [1, 0]T with probability 5/9, despite the fact that the maximal eigenvector is [0, 1]T . The reason for this failure is essentially that the orthogonality of the data interacts poorly with the low-rank projection: any update which does not entirely displace the maximal eigenvector in one iteration will be removed entirely by the projection, causing the algorithm to fail to make progress. Capped MSG algorithm with K > k, will not get stuck in such situations, using the additional \u201cdimensions\u201d to \u201csearch\u201d in the new direction. Only as it becomes more confident in its current candidate, the trace of M will become increasingly concentrated on the top k directions. To illustrate this empirically, we generalized the toy example above and generated the data using the 32-dimensional \u201corthogonal\u201d distribution described in Sec. 4. This distribution presents challenging test-cases for MSG, capped MSG as well as incremental algorithm. Figure 2 shows plots of individual runs of MSG, capped MSG with K = k + 1, the incremental algorithm, and Warmuth and Kuzmin\u2019s algorithm, all based on the same sequence of samples drawn from the orthogonal distribution. We compare algorithms in terms of the suboptimality on the population objective based on the largest k eigenvalues of the state matrix M (t). The plots show the incremental algorithm getting stuck for k \u2208 {1, 4}, and the others intermittently plateauing at intermediate solutions before beginning to again converge rapidly towards the optimum. This behavior is to be expected on the capped MSG algorithm, due to the fact that the dimension of the subspace stored at each iterate is constrained. However, it is somewhat surprising that MSG and Warmuth and Kuzmin\u2019s algorithm behaved similarly, and barely faster than capped MSG."}, {"heading": "6 Experiments", "text": "We also compared the algorithms on the real-world MNIST dataset, which consists of 70, 000 binary images of handwritten digits of size 28 \u00d7 28, resulting in a dimensionality of 784. We pre-normalized the data by mean centering the feature vectors and scaling each feature by the product of its standard deviation and the data dimension, so that each feature vector is zero mean and unit norm in expectation. In addition to MSG, capped MSG, the incremental algorithm and Warmuth and Kuzmin\u2019s algorithm, we also compare to a Grassmannian SGD algorithm of Balzano et al. [2010]. All algorithms except the incremental algorithm have a step-size parameter. In these experiments, we ran each algorithm with decreasing step sizes \u03b7t = c/ \u221a t for c \u2208 {2\u221212, 2\u221219, . . . , 25} and picked the best c, in terms of the average suboptimality over the run, on a validation set. Since we cannot evaluate the true population objective, we estimate it by evaluating on a held-out test set. We use 40% of samples in the dataset for training, 20% for validation (tuning step-size), and 40% for testing. We are\ninterested in learning a maximum variance subspace of dimension k \u2208 {1, 4, 8} in a single \u201cpass\u201d over the training sample. In order to compare MSG, capped MSG, incremental and Warmuth and Kuzmin\u2019s algorithm in terms of runtime, we calculate the dominant term in the computational complexity: \u2211t s=1(k \u2032 s)\n2. The results are averaged over 100 random splits into train-validation-test sets.\nWe can see from Figure 3 that the incremental algorithm makes the most progress per iteration and is also the fastest of all algorithms. MSG is comparable to the incremental algorithm in terms of the the progress made per iteration. However, its runtime is slightly worse than the incremental because it will often keep a slightly larger representation (of dimension k\u2032t) than the incremental algorithm. The capped MSG variant (with K = k + 1) is significantly faster\u2013 almost as fast as the incremental algorithm, while, as we saw in the previous section, being less prone to getting stuck. Warmuth and Kuzmin\u2019s algorithm fares well with k = 1, but its performance drops for higher k. Inspection of the underlying data shows that, in the k \u2208 {4, 8} experiments, it also tends to have a larger k\u2032t than MSG in these experiments, and therefore has a higher cost-periteration. Grassmannian SGD performs better than Warmuth and Kuzmin, but much worse when compared with MSG and capped MSG."}, {"heading": "7 Conclusions", "text": "In this paper, we presented a careful development and analysis of MSG, a stochastic approximation algorithm for PCA, which enjoys good theoretical guarantees and offers a computationally efficient variant, capped MSG. We show that capped MSG is well-motivated theoretically and that it does not get stuck at a suboptimal solution. Capped MSG is also shown to have excellent empirical performance and it therefore is a much better alternative to the recently proposed incremental PCA algorithm of Arora et al. [2012]. Furthermore, we provided a cleaner interpretation of PCA updates of Warmuth and Kuzmin [2008] in terms of Matrix Exponentiated Gradient (MEG) updates and showed that both MSG and MEG can be interpreted as mirror descent algorithms on the same relaxation of the PCA optimization problem but with different distance generating functions."}, {"heading": "A Proof of Lemma 3.2", "text": "Lemma 3.2. Let M \u2032 \u2208 Rd\u00d7d be a symmetric matrix, with eigenvalues \u03c3\u20321, . . . , \u03c3\u2032d and associated eigenvectors v\u20321, . . . , v \u2032 d. If M = P (M \u2032) projects M \u2032 onto the feasible region of Problem 3.2 with respect to the Frobenius norm, then M will be the unique feasible matrix which has the same set of eigenvectors as M \u2032, with the associated eigenvalues \u03c31, . . . , \u03c3d satisfying:\n\u03c3i = max (0,min (1, \u03c3 \u2032 i + S))\nwith S \u2208 R being chosen in such a way that d\u2211\ni=1\n\u03c3i = k.\nProof. The problem of finding M can be written in the form of a convex optimization problem as:\nminimize : \u2016M \u2212M \u2032\u20162F subject to : 0 M I, trM = k.\nBecause the objective is strongly convex, and the constraints are convex, this problem must have a unique solution. Letting \u03c31, . . . , \u03c3d and v1, . . . , vd be the eigenvalues and associated eigenvectors of M , we may write the KKT first-order optimality conditions [Boyd and Vandenberghe, 2004] as:\n0 = M \u2212M \u2032 + \u00b5I \u2212 d\u2211\ni=1\n\u03b1iviv T i + d\u2211 i=1 \u03b2iviv T i , (A.1)\nwhere \u00b5 is the Lagrange multiplier for the constraint trM = k, and \u03b1i, \u03b2i \u2265 0 are the Lagrange multipliers for the constraints 0 M and M I, respectively. The complementary slackness conditions are that \u03b1i\u03c3i = \u03b2i (\u03c3i \u2212 1) = 0. In addition, M must be feasible.\nBecause every term in Equation A.1 except for M \u2032 has the same set of eigenvectors as M , it follows that an optimal M must have the same set of eigenvectors as M \u2032, so we may take vi = v \u2032 i, and write Equation A.1 purely in terms of the eigenvalues:\n\u03c3i = \u03c3 \u2032 i \u2212 \u00b5+ \u03b1i \u2212 \u03b2i.\nComplementary slackness and feasibility with respect to the constraints 0 M I gives that if 0 \u2264 \u03c3\u2032i \u2212 \u00b5 \u2264 1, then \u03c3i = \u03c3\u2032i \u2212 \u00b5. Otherwise, \u03b1i and \u03b2i will be chosen so as to clip \u03c3i to the active constraint:\n\u03c3i = max (0,min (1, \u03c3 \u2032 i \u2212 \u00b5)) .\nPrimal feasibility with respect to the constraint trM = k gives that \u00b5 must be chosen in such a way that trM = k, completing the proof."}], "references": [{"title": "Stochastic optimization for pca and pls", "author": ["Raman Arora", "Andrew Cotter", "Karen Livescu", "Nathan Srebro"], "venue": "In 50th Annual Allerton Conference on Communication, Control, and Computing,", "citeRegEx": "Arora et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Arora et al\\.", "year": 2012}, {"title": "Online identification and tracking of subspaces from highly incomplete information", "author": ["Laura Balzano", "Robert Nowak", "Benjamin Recht"], "venue": "CoRR, abs/1006.4046,", "citeRegEx": "Balzano et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Balzano et al\\.", "year": 2010}, {"title": "Mirror descent and nonlinear projected subgradient methods for convex optimization", "author": ["A. Beck", "M. Teboulle"], "venue": "Operations Research Letters,", "citeRegEx": "Beck and Teboulle.,? \\Q2003\\E", "shortCiteRegEx": "Beck and Teboulle.", "year": 2003}, {"title": "The tradeoffs of large scale learning", "author": ["Leon Bottou", "Olivier Bousquet"], "venue": "In NIPS\u201907,", "citeRegEx": "Bottou and Bousquet.,? \\Q2007\\E", "shortCiteRegEx": "Bottou and Bousquet.", "year": 2007}, {"title": "Convex Optimization", "author": ["Stephen Boyd", "Lieven Vandenberghe"], "venue": null, "citeRegEx": "Boyd and Vandenberghe.,? \\Q2004\\E", "shortCiteRegEx": "Boyd and Vandenberghe.", "year": 2004}, {"title": "Incremental singular value decomposition of uncertain data with missing values", "author": ["Matthew Brand"], "venue": "In ECCV,", "citeRegEx": "Brand.,? \\Q2002\\E", "shortCiteRegEx": "Brand.", "year": 2002}, {"title": "Exponentiated gradient algorithms for conditional random fields and max-margin markov networks", "author": ["Michael Collins", "Amir Globerson", "Terry Koo", "Xavier Carreras", "Peter L. Bartlett"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "Collins et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Collins et al\\.", "year": 2008}, {"title": "Efficient projections onto the l1-ball for learning in high dimensions", "author": ["John Duchi", "Shai Shalev-Shwartz", "Yoram Singer", "Tushar Chandra"], "venue": "In Proceedings of the 25th international conference on Machine learning,", "citeRegEx": "Duchi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2008}, {"title": "Streaming, memory-limited pca", "author": ["Ioannis Mitliagkas", "Constantine Caramanis", "Prateek Jain"], "venue": "URL http://users.ece.utexas.edu/~cmcaram/ pubs/Streaming-PCA.pdf. UT-Austin", "citeRegEx": "Mitliagkas et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mitliagkas et al\\.", "year": 2013}, {"title": "Problem complexity and method efficiency in optimization", "author": ["Arkadi Nemirovski", "David Yudin"], "venue": null, "citeRegEx": "Nemirovski and Yudin.,? \\Q1983\\E", "shortCiteRegEx": "Nemirovski and Yudin.", "year": 1983}, {"title": "Robust stochastic approximation approach to stochastic programming", "author": ["Arkadi Nemirovski", "Anatoli Juditsky", "Guanghui Lan", "Alexander Shapiro"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "Nemirovski et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Nemirovski et al\\.", "year": 2009}, {"title": "On stochastic approximation of the eigenvectors and eigenvalues of the expectation of a random matrix", "author": ["Erkki Oja", "Juha Karhunen"], "venue": "Journal of Mathematical Analysis and Applications,", "citeRegEx": "Oja and Karhunen.,? \\Q1985\\E", "shortCiteRegEx": "Oja and Karhunen.", "year": 1985}, {"title": "Optimal unsupervised learning in a single-layer linear feedforward neural network", "author": ["Terence D. Sanger"], "venue": "Neural Networks,", "citeRegEx": "Sanger.,? \\Q1989\\E", "shortCiteRegEx": "Sanger.", "year": 1989}, {"title": "SVM optimization: Inverse dependence on training set size", "author": ["Shai Shalev-Shwartz", "Nathan Srebro"], "venue": "In ICML\u201908,", "citeRegEx": "Shalev.Shwartz and Srebro.,? \\Q2008\\E", "shortCiteRegEx": "Shalev.Shwartz and Srebro.", "year": 2008}, {"title": "Stochastic methods for l1 regularized loss minimization", "author": ["Shai Shalev-Shwartz", "Ambuj Tewari"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "Shalev.Shwartz and Tewari.,? \\Q2009\\E", "shortCiteRegEx": "Shalev.Shwartz and Tewari.", "year": 2009}, {"title": "Pegasos: Primal Estimated sub-GrAdient SOlver for SVM", "author": ["Shai Shalev-Shwartz", "Yoram Singer", "Nathan Srebro"], "venue": "In ICML\u201907,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2007}, {"title": "On the universality of online mirror descent", "author": ["N. Srebro", "K. Sridharan", "A. Tewari"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "Srebro et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Srebro et al\\.", "year": 2011}, {"title": "Randomized online PCA algorithms with regret bounds that are logarithmic in the dimension", "author": ["Manfred K. Warmuth", "Dima Kuzmin"], "venue": "Journal of Machine Learning Research (JMLR),", "citeRegEx": "Warmuth and Kuzmin.,? \\Q2008\\E", "shortCiteRegEx": "Warmuth and Kuzmin.", "year": 2008}, {"title": "Because the objective is strongly convex, and the constraints are convex, this problem must have a unique solution", "author": ["M I", "trM = k"], "venue": "Letting \u03c31,", "citeRegEx": "I and k.,? \\Q2004\\E", "shortCiteRegEx": "I and k.", "year": 2004}], "referenceMentions": [{"referenceID": 0, "context": "In an empirical study of stochastic approximation methods for PCA, a heuristic \u201cincremental\u201d method showed very good empirical performance [Arora et al., 2012].", "startOffset": 139, "endOffset": 159}, {"referenceID": 2, "context": "\u201cbatch\u201d methods) [Bottou and Bousquet, 2007, Shalev-Shwartz and Srebro, 2008]. A similar argument was also made in the context of stochastic optimization, where Nemirovski et al. [2009] argues for stochastic approximation (SA) approaches over ERM.", "startOffset": 18, "endOffset": 186}, {"referenceID": 0, "context": "In an empirical study of stochastic approximation methods for PCA, a heuristic \u201cincremental\u201d method showed very good empirical performance [Arora et al., 2012]. However, no theoretical guarantees or justification were given for incremental PCA. In fact, it was shown that for some distributions it can converge to a suboptimal solution with high probability (see Section 5.2 for more about this \u201cincremental\u201d algorithm). Also relevant is careful theoretical work on online PCA by Warmuth and Kuzmin [2008], in which an online regret guarantee was established.", "startOffset": 140, "endOffset": 506}, {"referenceID": 17, "context": "This follows from the following result of Warmuth and Kuzmin [2008].", "startOffset": 42, "endOffset": 68}, {"referenceID": 17, "context": "1 (Rounding [Warmuth and Kuzmin, 2008]).", "startOffset": 12, "endOffset": 38}, {"referenceID": 17, "context": "1 of Warmuth and Kuzmin [2008] shows how to efficiently find such a convex combination.", "startOffset": 5, "endOffset": 31}, {"referenceID": 9, "context": "Analyzing MSG is straightforward using the standard SGD analysis [Nemirovski and Yudin, 1983]:", "startOffset": 65, "endOffset": 93}, {"referenceID": 9, "context": "Standard SGD analysis of Nemirovski and Yudin [1983] yields that", "startOffset": 25, "endOffset": 53}, {"referenceID": 7, "context": "1Note that our projection problem onto the capped simplex, even when seen in the vector setting, is substantially different from Duchi et al. [2008]. We project onto the set {0 \u2264 \u03c3 \u2264 1, \u2016\u03c3\u20161 = k} in (3.", "startOffset": 129, "endOffset": 149}, {"referenceID": 7, "context": "1Note that our projection problem onto the capped simplex, even when seen in the vector setting, is substantially different from Duchi et al. [2008]. We project onto the set {0 \u2264 \u03c3 \u2264 1, \u2016\u03c3\u20161 = k} in (3.2) and {0 \u2264 \u03c3 \u2264 1, \u2016\u03c3\u20161 = k, \u2016\u03c3\u20160 \u2264 K} in (5.1) whereas Duchi et al. [2008] project onto {0 \u2264 \u03c3, \u2016\u03c3\u20161 = k}.", "startOffset": 129, "endOffset": 278}, {"referenceID": 2, "context": "Since M is constrained by its trace, and not by its Frobenius norm, it is tempting to consider mirror descent (MD) [Beck and Teboulle, 2003] instead of SGD updates for solving Problem 3.", "startOffset": 115, "endOffset": 140}, {"referenceID": 16, "context": "Recall that the Mirror Descent updates depend on a choice of \u201cpotential function\u201d \u03a8(\u00b7) which should be chosen according to the geometry of the feasible set and the subgradients [Srebro et al., 2011].", "startOffset": 177, "endOffset": 198}, {"referenceID": 17, "context": "This leads to multiplicative updates which we refer to as Matrix Exponentiated Gradient (MEG) update similar to those presented by [Warmuth and Kuzmin, 2008].", "startOffset": 131, "endOffset": 157}, {"referenceID": 0, "context": "The capped MSG updates with K = k are similar to the incremental algorithm of Arora et al. [2012]. The incremental algorithm maintains a rank-k approximation of the covariance matrix with updates given by", "startOffset": 78, "endOffset": 98}, {"referenceID": 0, "context": "The incremental algorithm was found to perform extremely well in practice\u2013 it was the best, in fact, among the compared algorithms [Arora et al., 2012].", "startOffset": 131, "endOffset": 151}, {"referenceID": 1, "context": "In addition to MSG, capped MSG, the incremental algorithm and Warmuth and Kuzmin\u2019s algorithm, we also compare to a Grassmannian SGD algorithm of Balzano et al. [2010]. All algorithms except the incremental algorithm have a step-size parameter.", "startOffset": 145, "endOffset": 167}, {"referenceID": 0, "context": "Capped MSG is also shown to have excellent empirical performance and it therefore is a much better alternative to the recently proposed incremental PCA algorithm of Arora et al. [2012]. Furthermore, we provided a cleaner interpretation of PCA updates of Warmuth and Kuzmin [2008] in terms of Matrix Exponentiated Gradient (MEG) updates and showed that both MSG and MEG can be interpreted as mirror descent algorithms on the same relaxation of the PCA optimization problem but with different distance generating functions.", "startOffset": 165, "endOffset": 185}, {"referenceID": 0, "context": "Capped MSG is also shown to have excellent empirical performance and it therefore is a much better alternative to the recently proposed incremental PCA algorithm of Arora et al. [2012]. Furthermore, we provided a cleaner interpretation of PCA updates of Warmuth and Kuzmin [2008] in terms of Matrix Exponentiated Gradient (MEG) updates and showed that both MSG and MEG can be interpreted as mirror descent algorithms on the same relaxation of the PCA optimization problem but with different distance generating functions.", "startOffset": 165, "endOffset": 280}], "year": 2013, "abstractText": "We study PCA as a stochastic optimization problem and propose a novel stochastic approximation algorithm which we refer to as \u201cMatrix Stochastic Gradient\u201d (MSG), as well as a practical variant, Capped MSG. We study the method both theoretically and empirically.", "creator": "LaTeX with hyperref package"}}}