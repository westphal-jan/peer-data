{"id": "1307.7809", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jul-2013", "title": "Les POMDP font de meilleurs hackers: Tenir compte de l'incertitude dans les tests de penetration", "abstract": "penetration hiding is a methodology about internet network security, by generating and executing possible hacking factors. doing so automatically allows for regular and systematic testing. a key question is choosing to generate the attacks. this is naturally realised as planning under uncertainty, i. e., under incomplete knowledge about the network configuration. previous work uses classical planning, while offers costly pre - processes reducing this deficit by extensive application of scanning methods. by contrast, we herein model the attack planning problem underlying terms of partially observable markov decision processes ( pomdp ). this allows to reason about the knowledge available, and to intelligently employ scanning actions as part of the attack. as one would expect, without accurate method does not scale. vendors devise a code that focused on stealth to find good attacks on individual machines, when are then composed into an attack on internet network as a whole. this decomposition exploits network hacking to the extent possible, making targeted approximations ( only ) where needed. riding this method on a suitably adapted industrial test suite, we adjust its effectiveness in both runtime well solution quality.", "histories": [["v1", "Tue, 30 Jul 2013 04:21:54 GMT  (119kb,D)", "http://arxiv.org/abs/1307.7809v1", "JFPDA 2012 (7\\`emes Journ\\'ees Francophones Planification, D\\'ecision, et Apprentissage pour la conduite de syst\\`emes), Nancy, France"]], "COMMENTS": "JFPDA 2012 (7\\`emes Journ\\'ees Francophones Planification, D\\'ecision, et Apprentissage pour la conduite de syst\\`emes), Nancy, France", "reviews": [], "SUBJECTS": "cs.AI cs.CR", "authors": ["carlos sarraute", "olivier buffet", "joerg hoffmann core security technologies", "itba", "inria)"], "accepted": false, "id": "1307.7809"}, "pdf": {"name": "1307.7809.pdf", "metadata": {"source": "CRF", "title": "Les POMDP font de meilleurs hackers: Tenir compte de l\u2019incertitude dans les tests de pe\u0301ne\u0301tration", "authors": ["Carlos Sarraute", "Olivier Buffet", "J\u00f6rg Hoffmann"], "emails": ["carlos@coresecurity.com", "olivier.buffet@loria.fr", "hoffmann@cs.uni-saarland.de"], "sections": [{"heading": null, "text": "Les POMDP font de meilleurs hackers: Tenir compte de l\u2019incertitude dans les tests de p\u00e9n\u00e9tration\nCarlos Sarraute1, Olivier Buffet2, J\u00f6rg Hoffmann3\n1 Core Security & ITBA Buenos Aires, Argentina\ncarlos@coresecurity.com http://corelabs.coresecurity.com/\n2 INRIA / Universit\u00e9 de Lorraine LORIA, Nancy, France\nolivier.buffet@loria.fr http://www.loria.fr/\u223cbuffet/\n3 Saarland University Saarbr\u00fccken, Germany\nhoffmann@cs.uni-saarland.de http://www.loria.fr/\u223choffmanj/\nR\u00e9sum\u00e9 : Les tests de p\u00e9n\u00e9tration sont une m\u00e9thodologie pour \u00e9valuer la s\u00e9curit\u00e9 d\u2019un r\u00e9seau en g\u00e9n\u00e9rant et ex\u00e9cutant de possibles attaques informatiques. Automatiser cette t\u00e2che permet de r\u00e9aliser des tests r\u00e9guliers et syst\u00e9matiques. Une question clef est : \u201cComment g\u00e9n\u00e9rer ces attaques ?\u201d Ce probl\u00e8me se formule naturellement comme de la planification dans l\u2019incertain, plus pr\u00e9cis\u00e9ment avec une connaissance incompl\u00e8te de la configuration du r\u00e9seau. Les travaux ant\u00e9rieurs emploient de la planification classique, et requi\u00e8rent de co\u00fbteux pr\u00e9-traitements r\u00e9duisant cette incertitude par l\u2019application extensive de m\u00e9thodes de scan. Au contraire, nous mod\u00e9lisons ici le probl\u00e8me de la planification d\u2019attaques \u00e0 travers des processus de d\u00e9cision markoviens partiellement observables (POMDP). Ceci nous permet de raisonner \u00e0 propos de la connaissance disponible, et d\u2019employer intelligemment les actions de scan comme faisant partie de l\u2019attaque. Comme on s\u2019y attendrait, cette solution pr\u00e9cise ne passe pas \u00e0 l\u2019\u00e9chelle. Nous concevons donc une m\u00e9thode qui repose sur les POMDP pour trouver de bonnes attaques sur des machines individuelles, lesquelles sont recompos\u00e9es en une attaque sur le r\u00e9seau complet. Cette d\u00e9composition exploite la structure du r\u00e9seau dans la mesure du possible, faisant des approximations cibl\u00e9es (seulement) o\u00f9 cela est n\u00e9cessaire. En \u00e9valuant cette m\u00e9thode sur un jeu de tests industriels adapt\u00e9s convenablement, nous d\u00e9montrons son efficacit\u00e9 \u00e0 la fois en temps de calcul et en qualit\u00e9 de la solution."}, {"heading": "1 Introduction", "text": "Les tests de p\u00e9n\u00e9tration (le Penetration Testing, ou pentesting) sont une m\u00e9thodologie pour \u00e9valuer la s\u00e9curit\u00e9 d\u2019un r\u00e9seau en g\u00e9n\u00e9rant et ex\u00e9cutant de possibles attaques exploitant des vuln\u00e9rabilit\u00e9s connues des syst\u00e8mes d\u2019exploitation et des applications (voir, par exemple, (Arce & McGraw, 2004)). Automatiser cette t\u00e2che permet des tests r\u00e9guliers et syst\u00e9matiques sans un travail humain prohibitif et rend le pentesting plus accessible aux non-experts. Une question clef est : \u201cComment g\u00e9n\u00e9rer ces attaques ?\u201d\nUne fa\u00e7on naturelle de r\u00e9soudre cette question est sous la forme d\u2019un probl\u00e8me de planification d\u2019attaques. C\u2019est connu dans la communaut\u00e9 de la planification automatique comme le domaine de la \u201cCyber S\u00e9curit\u00e9\u201d (Boddy et al., 2005). Ind\u00e9pendamment (mais bien plus tard), l\u2019approche a \u00e9t\u00e9 mise en avant aussi par Core Security (Lucangeli et al., 2010), une compagnie de l\u2019industrie du pentesting. Sous cette forme, la planification d\u2019attaques est tr\u00e8s technique, s\u2019attachant aux d\u00e9tails de bas niveau de la configuration syst\u00e8me qui sont pertinents pour les vuln\u00e9rabilit\u00e9s. Ici nous nous int\u00e9ressons exclusivement \u00e0 ce cadre. Nous consid\u00e9rons le pentesting\nar X\niv :1\n30 7.\n78 09\nv1 [\ncs .A\nI] 3\n0 Ju\nl 2 01\n3\nr\u00e9gulier automatique tel que conduit dans l\u2019outil \u201cCore Insight Enterprise\u201d de Core Security. Nous utiliserons le terme \u201cplanification d\u2019attaques\u201d dans ce sens.\nLucangeli et al. (2010) encodent la planification d\u2019attaques en PDDL et utilise des planificateurs pr\u00eat-\u00e0l\u2019emploi. Ceci est, en soi, d\u00e9j\u00e0 utile \u2013 en fait, c\u2019est actuellement employ\u00e9 dans le produit commercial Core Insight Enterprise, reposant sur une variante de Metric-FF (Hoffmann, 2003). Toutefois, cette approche est limit\u00e9e par son incapacit\u00e9 \u00e0 g\u00e9rer l\u2019incertitude. L\u2019outil de pentesting ne peut \u00eatre \u00e0 jour sur tous les d\u00e9tails de la configuration de chaque machine dans le r\u00e9seau, lesquelles sont maintenues par des utilisateurs individuels.\nCore Insight Enterprise r\u00e9soud cela par l\u2019utilisation extensive de m\u00e9thodes de scan comme pr\u00e9-traitement \u00e0 la planification, qui ne consid\u00e8re alors que des exploits, c\u2019est-\u00e0-dire des actions de piratage modifiant l\u2019\u00e9tat du syst\u00e8me. Les inconv\u00e9nients de cela sont (a) ce pr\u00e9-traitement entraine des co\u00fbts importants en termes de temps d\u2019ex\u00e9cution et de trafic r\u00e9seau, et (b) de toute fa\u00e7on, puisque les scans sont imparfaits, il reste une incertitude r\u00e9siduelle (Metric-FF est lanc\u00e9 sur la base de la configuration qui semble la plus probable). Un travail ant\u00e9rieur (Sarraute et al., 2011b) a r\u00e9solu (b) en associant \u00e0 chaque exploit une probabilit\u00e9 de succ\u00e8s. Cela ne permet pas de mod\u00e9liser les d\u00e9pendences entre exploits, et requiert quand m\u00eame des scans extensifs (pour obtenir des probabilit\u00e9s de succ\u00e8s r\u00e9alistes) et ne r\u00e9soud donc pas (a). Ici, nous fournissons la premi\u00e8re solution capable de r\u00e9soudre \u00e0 la fois (a) et (b), m\u00ealant intelligemment scans et exploits comme un vrai hacker le ferait. L\u2019intuition fondamentale est que le pentesting peut \u00eatre mod\u00e9lis\u00e9 naturellement comme la r\u00e9solution d\u2019un POMDP.\nNous encodons la connaissance incompl\u00e8te comme une incertitude sur l\u2019\u00e9tat, mod\u00e9lisant ainsi les configurations possibles du r\u00e9seau \u00e0 l\u2019aide d\u2019une distribution de probabilit\u00e9s. Scans et exploits sont d\u00e9terministes puisque leurs r\u00e9sultats d\u00e9pendent seulement de l\u2019\u00e9tat dans lequel ils sont ex\u00e9cut\u00e9s. Des r\u00e9compenses n\u00e9gatives encodent le co\u00fbt (la dur\u00e9e) des scans et exploits ; des r\u00e9compenses positives encodent la valeur des cibles atteintes. Ce mod\u00e8le incorpore des pare-feux, des effets de bord pr\u00e9judiciables des exploits (plantage de programmes ou de machines compl\u00e8tes), et les d\u00e9pendances entre exploits reposant sur des vuln\u00e9rabilit\u00e9s similaires.\nLes r\u00e9solveurs de POMDP ne passent pas \u00e0 l\u2019\u00e9chelle pour de grands r\u00e9seaux. Cela n\u2019est pas surprenant \u2013 m\u00eame le mod\u00e8le en entr\u00e9e cro\u00eet exponentiellement avec le nombre de machines. Nous montrons comment r\u00e9soudre cela en exploitant la structure du r\u00e9seau. Nous voyons les r\u00e9seaux comme des graphes dont les n\u0153uds sont des sous-r\u00e9seaux compl\u00e8tement connect\u00e9s, et dont les arcs encodent les connections entre ceux-ci, filtr\u00e9es par des pare-feux. Nous d\u00e9composons ce graphe en composants bi-connect\u00e9s. Nous approximons les attaques sur ces composants en combinant des attaques sur des sous-r\u00e9seaux individuels. Nous approximons ces derni\u00e8res en combinant des attaques sur des machines individuelles. Ces approximations sont conservatives, c\u2019est-\u00e0-dire qu\u2019elle ne surestiment jamais la valeur de la politique retourn\u00e9e. Les attaques sur des machines individuelles sont mod\u00e9lis\u00e9es et r\u00e9solues comme des POMDP, et les solutions sont propag\u00e9es vers les plus hauts niveaux. Nous \u00e9valuons cette approche sur un jeu de tests industriels de Core Insight Enterprise, montrant que, en comparaison avec un mod\u00e8le POMDP global, elle am\u00e9liore largement le temps de calcul \u00e0 un faible co\u00fbt en termes de qualit\u00e9 d\u2019attaque.\nNous pr\u00e9sentons ci-apr\u00e8s quelques pr\u00e9liminaires. Nous d\u00e9crivons ensuite notre mod\u00e8le POMDP, notre algorithme de d\u00e9composition, et nos r\u00e9sultats exp\u00e9rimentaux, avant de conclure cet article.\n2 Pr\u00e9liminaires Nous pr\u00e9sentons quelques notions sur la structure du r\u00e9seau et le pentesting, et donnons un rapide aper\u00e7u des POMDP."}, {"heading": "2.1 Structure du r\u00e9seau", "text": "Les r\u00e9seaux informatiques peuvent \u00eatre vus comme des graphes orient\u00e9s dont les n\u0153uds sont donn\u00e9s par un ensemble M de machines, et dont les arcs sont des connections entre paires de m \u2208 M . Toutefois, en pratique, ces graphes de r\u00e9seaux ont une structure particuli\u00e8re. Ils tendent \u00e0 \u00eatre constitu\u00e9s de sous-r\u00e9seaux, c\u2019est-\u00e0-dire de groupes N (pour Network) de machines dans lesquels chaque m \u2208 N est directement connect\u00e9 \u00e0 chaque m\u2032 \u2208 N . A l\u2019inverse, tout sous-r\u00e9seau N n\u2019est pas connect\u00e9 \u00e0 n\u2019importe quel autre sous-r\u00e9seau N \u2032 et, typiquement, si une telle connexion existe, elle est alors filtr\u00e9e par un pare-feu.\nDu point de vue d\u2019un attaquant, les pare-feux filtrent les connexions et limitent ainsi les attaques qui peuvent \u00eatre ex\u00e9cut\u00e9es quand on essaye de p\u00e9n\u00e9trer un sous-r\u00e9seau N \u2032 depuis un autre sous-r\u00e9seau N . D\u2019autre part, une fois que l\u2019attaquant a r\u00e9ussi \u00e0 s\u2019introduire dans un sous-r\u00e9seau N , l\u2019acc\u00e8s \u00e0 toutes les machines dans N est facilit\u00e9. Ainsi, une repr\u00e9sentation naturelle du r\u00e9seau, du point de vue de la planification d\u2019attaques, est celle d\u2019un graphe dont les n\u0153uds sont des sous-r\u00e9seaux, et dont les arcs sont annot\u00e9s avec des pare-feux F (pour Firewall). Nous appellerons ici ce graphe le r\u00e9seau logique LN (pour Logical Network), et d\u00e9notons ces arcs avec N F\u2212\u2192 N \u2032.\nNous formalisons les pare-feux comme des ensembles de r\u00e8gles d\u00e9crivant quels types de communications (par exemple des ports) sont interdits. Ainsi, de plus petits ensembles correspondent \u00e0 des pare-feux \u201cplus faibles\u201d, et le pare-feu vide ne bloque aucune communication.\nOn remarque que, dans notre mod\u00e8le POMDP, nous ne pr\u00e9voyons pas l\u2019escalade de privil\u00e8ge ou l\u2019obtention de mots de passe. Cela peut \u00e0 la place \u00eatre mod\u00e9lis\u00e9 au niveau de LN . Diff\u00e9rents niveaux de privil\u00e8ges sur la m\u00eame machine m peuvent \u00eatre encod\u00e9s \u00e0 l\u2019aide de diff\u00e9rentes copies de m. Si le contr\u00f4le de m permet la r\u00e9cup\u00e9ration de mots de passe, alors m peut \u00eatre connect\u00e9e \u00e0 l\u2019aide de pare-feux vides aux machines m\u2032 qui peuvent \u00eatre atteintes en utilisant ces mots de passe, ou plus pr\u00e9cis\u00e9ment \u00e0 des copies \u00e0 haut-privil\u00e8ges de ces m\u2032."}, {"heading": "2.2 Les tests de p\u00e9n\u00e9tration", "text": "L\u2019incertitude dans le pentesting appara\u00eet parce qu\u2019il est impossible de garder trace de tous les d\u00e9tails de configuration des machines individuelles, c\u2019est-\u00e0-dire des versions exactes des programmes install\u00e9s, etc. Toutefois, on peut sans risque faire l\u2019hypoth\u00e8se que l\u2019outil de pentesting conna\u00eet la structure du r\u00e9seau, c\u2019est-\u00e0-dire le graphe LN et le filtrage effectu\u00e9 par chaque pare-feu : les changements \u00e0 ce niveau sont peu fr\u00e9quents et peuvent \u00eatre facilement enregistr\u00e9s.\nL\u2019objectif du pentesting est de prendre contr\u00f4le de certaines machines (au contenu critique) du r\u00e9seau. A n\u2019importe qu\u2019elle moment, chaque machine a un statut unique. Une machine contr\u00f4l\u00e9e m a d\u00e9j\u00e0 \u00e9t\u00e9 pirat\u00e9e. Une machine atteinte m est connect\u00e9e \u00e0 une machine contr\u00f4l\u00e9e, c\u2019est-\u00e0-dire que soit m est dans un sous-r\u00e9seau N dont une machine est contr\u00f4l\u00e9e, soit m est dans un sous-r\u00e9seau N \u2032 avec un arc de LN , N F\u2212\u2192 N \u2032, tel que l\u2019une des machines de N est contr\u00f4l\u00e9e. Toutes les autres machines sont non atteintes. L\u2019algorithme commence avec une machine contr\u00f4l\u00e9e, d\u00e9not\u00e9e ici par \u2217. 1 Nous utiliserons la situation suivante (petite mais r\u00e9aliste) comme exemple dans la suite de cet article.\nExemple 1 L\u2019attaquant a d\u00e9j\u00e0 pirat\u00e9 une machine m\u2032, et souhaite maintenant attaquer une machine m dans le m\u00eame sousr\u00e9seau. L\u2019attaquant conna\u00eet deux exploits : SA, l\u2019exploit \u201cSymantec Rtvscan buffer overflow\u201d ; et CAU, l\u2019exploit \u201cCA Unicenter message queuing\u201d. SA cible une version particuli\u00e8re de \u201cSymantec Antivirus\u201d, lequel \u00e9coute usuellement le port 2967. CAU cible une version particuli\u00e8re de \u201cCA Unicenter\u201d, qui \u00e9coute usuellement sur le port 6668. Les deux fonctionnent seulement si un m\u00e9canisme de protection appel\u00e9 DEP (\u201cData Execution Prevention\u201d) est d\u00e9sactiv\u00e9.\nSi SA \u00e9choue, alors il est probable que CAU \u00e9chouera aussi (parce que DEP est activ\u00e9). L\u2019attaquant ferait alors mieux d\u2019essayer autre chose. Atteindre un tel comportement requiert que le plan d\u2019attaque observe les r\u00e9sultats des actions, et r\u00e9agisse en cons\u00e9quence. La planification classique (qui suppose une connaissance parfaite du monde au moment de la planification) ne peut accomplir cela.\nEn outre, les scans de ports \u2013 des actions d\u2019observation testant si un port particulier est ouvert ou non \u2013 devraient \u00eatre utilis\u00e9s seulement si l\u2019on a r\u00e9ellement l\u2019intention d\u2019ex\u00e9cuter un exploit en rapport. Ici, si nous commen\u00e7ons avec SA, nous devrions scanner seulement le port 2967. Nous pouvons obtenir un tel comportement \u00e0 travers l\u2019utilisation de POMDP. En revanche, pour r\u00e9duire l\u2019incertitude, la planification classique requiert un pr\u00e9-traitement ex\u00e9cutant tous les scans possibles. Dans cet exemple, il n\u2019y en a que deux \u2013 les ports 2967 et\n1. Par simplicit\u00e9, nous d\u00e9noterons \u2217 comme un n\u0153ud s\u00e9par\u00e9 de LN . Si \u2217 fait partie du sous-r\u00e9seau N , cela implique de transformer N \\ {\u2217} en un n\u0153ud s\u00e9par\u00e9 de LN , connect\u00e9 \u00e0 \u2217 \u00e0 l\u2019aide d\u2019un pare-feu vide.\n6668 \u2013 mais en g\u00e9n\u00e9ral il y en a un grand nombre, ce qui provoque un important trafic r\u00e9seau et un important temps d\u2019attente."}, {"heading": "2.3 Les POMDP", "text": "Les processus d\u00e9cisionnels de Markov partiellement observables (POMDP) sont usuellement d\u00e9finis (Monahan, 1982; Kaelbling et al., 1998) par un uplet \u3008S,A,O, T,O, r, b0\u3009. Si le syst\u00e8me est dans un \u00e9tat s \u2208 S (l\u2019espace d\u2019\u00e9tat), et l\u2019agent effectue une action a \u2208 A (l\u2019espace d\u2019action), alors en r\u00e9sulte (1) une transition vers un \u00e9tat s\u2032 selon la fonction de transition T (s, a, s\u2032) = Pr(s\u2032|s, a), (2) une observation o \u2208 O (l\u2019espace d\u2019observation) selon la fonction d\u2019observation O(s\u2032, a, o) = Pr(o|s\u2032, a) et (3) une r\u00e9compense scalaire r(s, a, s\u2032). b0, la croyance initiale, est une distribution de probabilit\u00e9 sur S.\nL\u2019agent doit trouver une politique de d\u00e9cision \u03c0 choisissant, \u00e0 chaque \u00e9tape, la meilleure action en fonction de ses observations pass\u00e9es et des actions de mani\u00e8re \u00e0 maximiser ses gains futurs, lesquels nous mesurons ici \u00e0 travers le total des r\u00e9compenses accumul\u00e9es. La valeur esp\u00e9r\u00e9e d\u2019une politique optimale est d\u00e9not\u00e9e V \u2217.\nL\u2019agent raisonne typiquement sur l\u2019\u00e9tat cach\u00e9 du syst\u00e8me en utilisant un \u00e9tat de croyance b, une distribution de probabilit\u00e9 sur S. Pour nos exp\u00e9rimentations nous utilisons SARSOP (Kurniawati et al., 2008), un algorithme \u00e0 base de points de l\u2019\u00e9tat de l\u2019art, c\u2019est-\u00e0-dire un algorithme approchant la fonction de valeur comme l\u2019enveloppe sup\u00e9rieure d\u2019un ensemble d\u2019hyperplans, lesquels correspondent \u00e0 une s\u00e9lection d\u2019\u00e9tats de croyance particuliers (appel\u00e9s \u201cpoints\u201d)."}, {"heading": "3 Mod\u00e8le POMDP", "text": "Une version pr\u00e9liminaire de notre mod\u00e8le POMDP a \u00e9t\u00e9 pr\u00e9sent\u00e9e dans le workshop SecArt\u201911 (Sarraute et al., 2011a). Le lecteur peut se r\u00e9f\u00e9rer \u00e0 cet article pour un exemple plus d\u00e9taill\u00e9 listant des mod\u00e8les de transition et d\u2019observation complets pour certaines actions, et illustrant l\u2019\u00e9volution des \u00e9tats de croyance quand ces actions sont appliqu\u00e9es. Dans ce qui suit, nous gardons des descriptions br\u00e8ves par soucis de gain d\u2019espace."}, {"heading": "3.1 \u00c9tats", "text": "Plusieurs aspects du probl\u00e8me \u2013 notamment la structure du r\u00e9seau et les r\u00e8gles de filtrage des pare-feux \u2013 sont connus et statiques. Les variables encodant ces aspects peuvent \u00eatre \u00e9limin\u00e9es lors d\u2019un pr\u00e9-traitement, et ne sont pas incluses dans notre mod\u00e8le.\nLes \u00e9tats saisissent le statut de chaque machine (contr\u00f4l\u00e9e/atteinte/non atteinte). Pour les machines non contr\u00f4l\u00e9es, ils sp\u00e9cifient aussi la configuration logicielle (syst\u00e8me d\u2019exploitation, serveurs, ports ouverts, . . .). Nous sp\u00e9cifions les programmes vuln\u00e9rables, ainsi que les programmes qui peuvent fournir de l\u2019information \u00e0 propos de ceux-ci (par exemple, le m\u00e9canisme de protection \u201cDEP\u201d de notre exemple est pertinent pour les deux exploits). Les \u00e9tats indiquent aussi si une machine ou un programme donn\u00e9 a plant\u00e9.\nFinalement, nous introduisons un \u00e9tat sp\u00e9cial, terminal, dans le mod\u00e8le POMDP (de l\u2019ensemble du r\u00e9seau, pas des machines individuelles). Cet \u00e9tat correspond \u00e0 l\u2019abandon de l\u2019attaque, quand, pour chaque action disponible (s\u2019il en reste), le b\u00e9n\u00e9fice potentiel ne compense pas les co\u00fbts d\u2019action.\nExemple 2 Les \u00e9tats d\u00e9crivent la machine attaqu\u00e9e m. Pour simplifier, nous ferons l\u2019hypoth\u00e8se que les exploits ne risquent pas ici de planter la machine (voir aussi la sous-section suivante). A part l\u2019\u00e9tat terminal et l\u2019\u00e9tat repr\u00e9sentant le fait que m est contr\u00f4l\u00e9e, les \u00e9tats sp\u00e9cifient quels programmes (\u201cSA\u201d ou \u201cCAU\u201d) sont pr\u00e9sents, s\u2019ils sont vuln\u00e9rables, et si \u201cDEP\u201d est activ\u00e9. Chaque application \u00e9coute sur un port diff\u00e9rent, donc un port est ouvert ssi l\u2019application associ\u00e9e est pr\u00e9sente, et nous n\u2019avons pas besoin de mod\u00e9liser les ports s\u00e9par\u00e9ment. Nous avons ainsi un total de 20 \u00e9tats :\n1 terminal 2 m_controlled\n3 m_none 4 m_CAU 5 m_CAU_Vul 6 m_SA 7 m_SA_CAU 8 m_SA_CAU_Vul 9 m_SA_Vul 10 m_SA_Vul_CAU 11 m_SA_Vul_CAU_Vul\n12 m_DEP_none 13 m_DEP_CAU 14 m_DEP_CAU_Vul 15 m_DEP_SA 16 m_DEP_SA_CAU 17 m_DEP_SA_CAU_Vul 18 m_DEP_SA_Vul 19 m_DEP_SA_Vul_CAU 20 m_DEP_SA_Vul_CAU_Vul\nEn r\u00e9sum\u00e9, les \u00e9tats de chaque machine m sont essentiellement des uplets de valeurs de statuts pour chaque programme pertinent. Les \u00e9tats du syst\u00e8me global sont alors des uplets des ces \u00e9tats de machines, avec une entr\u00e9e pour chaque m \u2208 M . L\u2019espace d\u2019\u00e9tat \u00e9num\u00e8re ces uplets. Dit autrement, l\u2019espace d\u2019\u00e9tat est factoris\u00e9 d\u2019une fa\u00e7on naturelle, par programmes et par machines. Une option \u00e9vidente est donc de mod\u00e9liser et r\u00e9soudre le probl\u00e8me en utilisant des POMDP factoris\u00e9s (Hansen & Feng, 2000). Nous n\u2019avons pas encore essay\u00e9 cela ; notre g\u00e9n\u00e9rateur de mod\u00e8le POMDP \u00e9num\u00e8re les \u00e9tats en interne et fournit ce mod\u00e8le \u00e0 SARSOP. 2\nLa nature factoris\u00e9e de notre probl\u00e8me implique aussi que l\u2019espace d\u2019\u00e9tat est \u00e9norme. Dans un cadre r\u00e9aliste, l\u2019ensemble C des uplets de configurations possibles pour chaque machine m \u2208 M est tr\u00e8s grand, donnant un espace d\u2019\u00e9tat \u00e9norme |S| = O(|C||M |). En pratique, nous n\u2019ex\u00e9cuterons des POMDP que sur des machines seules, c\u2019est-\u00e0-dire pour |M | = 1."}, {"heading": "3.2 Actions", "text": "Pour atteindre l\u2019\u00e9tat terminal, nous avons besoin d\u2019une action terminate (terminer) indiquant que l\u2019on abandonne l\u2019attaque. Il y a deux principaux types d\u2019actions, les scans et les exploits, les deux devant \u00eatre cibl\u00e9es vers des machines atteignables. Les scans peuvent \u00eatre des actions de d\u00e9tection d\u2019OS ou des scans de ports. Dans la plupart des cas, ils n\u2019auront pas d\u2019effet sur l\u2019\u00e9tat de la machine cible. Leur objectif est d\u2019acqu\u00e9rir de la connaissance \u00e0 propos de la configuration de la machine \u00e0 l\u2019aide d\u2019une observation qui permet typiquement d\u2019\u00e9liminer certains \u00e9tats de la croyance (par exemple, observer que l\u2019OS doit \u00eatre une certaine version de Windows XP). Les exploits font usage d\u2019une vuln\u00e9rabilit\u00e9 \u2013 si elle est pr\u00e9sente \u2013 pour prendre le contr\u00f4le d\u2019une machine. Le r\u00e9sultat de cet exploit est observ\u00e9 par l\u2019attaquant, de sorte que l\u2019\u00e9chec d\u2019un exploit peut, comme un scan, donner de l\u2019information \u00e0 propos de la configuration (par exemple, que le m\u00e9canisme de protection est probablement actif). Pour une minorit\u00e9 d\u2019exploits, une tentative rat\u00e9e plante la machine.\nPour toutes les actions, le r\u00e9sultat est d\u00e9terministe : quelle observation est retourn\u00e9e, et si un exploit r\u00e9ussit/\u00e9choue/plante, est d\u00e9termin\u00e9 de mani\u00e8re unique par la configuration de la machine cible.\nExemple 3 Dans notre exemple, il y a cinq actions possibles : m_exploit_SA m_exploit_CAU m_scan_port_2967 m_scan_port_6668 terminate Le mod\u00e8le POMDP sp\u00e9cifie, pour chaque \u00e9tat dans l\u2019exemple 2, le r\u00e9sultat de chaque action. Par exemple, m_exploit_SA r\u00e9ussit si et seulement si SA est pr\u00e9sent et vuln\u00e9rable, et DEP est d\u00e9sactiv\u00e9. Ainsi, quand appliqu\u00e9e \u00e0 l\u2019\u00e9tat 9, 10 ou 11, m_exploit_SA r\u00e9sulte en l\u2019\u00e9tat 2, et retourne l\u2019observation succeeded. Appliqu\u00e9e \u00e0 n\u2019importe quel autre \u00e9tat, m_exploit_SA laisse l\u2019\u00e9tat inchang\u00e9, et l\u2019observation est failed.\nLes r\u00e9sultats des actions d\u00e9pendent aussi du pare-feu (s\u2019il y en a un) \u00e9rig\u00e9 entre le pentesteur et la cible. Si le pare-feu filtre le port associ\u00e9 \u00e0 une action, alors celle-ci est inutilisable : son mod\u00e8le de transition laisse\n2. Notons que cette approche permet certaines optimisations non-triviales : certains des \u00e9tats dans l\u2019exemple 2 pourraient \u00eatre fusionn\u00e9s. Si DEP est activ\u00e9, alors il importe peu que CAU/SA soient vuln\u00e9rables. Par souci de bri\u00e8vet\u00e9, nous ne discutons pas ici ce point en d\u00e9tail.\nl\u2019\u00e9tat inchang\u00e9, et aucune observation n\u2019est retourn\u00e9e. Par exemple, si le pare-feu F filtre le port 2967, alors m_scan_port_2967 et m_exploit_SA sont inutilisables \u00e0 travers F , mais peuvent \u00eatre employ\u00e9es d\u00e8s qu\u2019une machine derri\u00e8re F est sous contr\u00f4le."}, {"heading": "3.3 R\u00e9compenses", "text": "Aucune r\u00e9compense n\u2019est obtenue quand on utilise l\u2019action terminate ou dans l\u2019\u00e9tat terminal. La r\u00e9compense instantan\u00e9e pour n\u2019importe quelle action scan/exploit d\u00e9pend de la transition qu\u2019elle entra\u00eene depuis l\u2019\u00e9tat courant. Notre mod\u00e8le simple est de d\u00e9composer additivement la r\u00e9compense instantan\u00e9e r(s, a, s\u2032) en r(s, a, s\u2032) = re(s, a, s\u2032)+rt(a)+rd(a). Ici, (i) re(s, a, s\u2032) est la valeur de la machine attaqu\u00e9e dans le cas o\u00f9 la transition (s, a, s\u2032) correspond \u00e0 un exploit r\u00e9ussi, et vaut 0 pour toute autre transition ; (ii) rt(a) est un co\u00fbt qui d\u00e9pend de la dur\u00e9e de l\u2019action ; et (iii) rd(a) est un co\u00fbt qui refl\u00e8te le risque de d\u00e9tection quand on utilise cette action. (iii) est orthogonal au risque de planter un programme ou une machine, ce que, comme d\u00e9crit, nous mod\u00e9lisons comme un possible r\u00e9sultat d\u2019exploits. Notons que (ii) et (iii) peuvent \u00eatre corr\u00e9l\u00e9s ; toutefois, il n\u2019y a pas bijection entre dur\u00e9e et risque de d\u00e9tection d\u2019un exploit, il est donc pertinent d\u2019\u00eatre capable de distinguer les deux. Finalement, notons que (i) r\u00e9sulte de la somme des r\u00e9compenses pour les exploits r\u00e9ussis sur diff\u00e9rentes machines. Ce n\u2019est pas une hypoth\u00e8se contraignante : on peut r\u00e9compenser le fait de p\u00e9n\u00e9trer dans [m1 OU m2] en introduisant une nouvelle machine virtuelle, accessible sans co\u00fbt depuis aussi bien m1 que m2.\nExemple 4 Dans notre exemple, nous fixons re = 1000 en cas de succ\u00e8s, 0 sinon ; rt = \u221210 pour toutes les actions ; and rd = 0 (aucun risque de d\u00e9tection). Nous verrons ci-dessous quel effet ces r\u00e9glages ont sur une politique optimale.\nPuisque toutes les actions sont d\u00e9terministes, il n\u2019est pas utile de les r\u00e9p\u00e9ter sur la m\u00eame cible \u00e0 travers le m\u00eame pare-feu \u2013 cela ne produira pas de nouveaux effets ou n\u2019apportera pas de nouvelles informations. En particulier, les r\u00e9compenses positives ne peuvent \u00eatre re\u00e7ues plusieurs fois. Ainsi, des comportements cycliques encourent des co\u00fbts n\u00e9gatifs infinis. Cela implique que le retour esp\u00e9r\u00e9 d\u2019une politique optimale est fini m\u00eame sans facteur d\u2019att\u00e9nuation. 3"}, {"heading": "3.4 Concevoir la croyance initiale", "text": "Un test de p\u00e9n\u00e9tration est effectu\u00e9 \u00e0 intervalles de temps r\u00e9guliers. La croyance initiale \u2013 notre connaissance du r\u00e9seau quand on commence le pentest \u2013 d\u00e9pend de (a) ce qui \u00e9tait connu \u00e0 la fin du pentest pr\u00e9c\u00e9dent, et de (b) ce qui peut avoir chang\u00e9 depuis. Nous faisons l\u2019hypoth\u00e8se pour des raisons de simplicit\u00e9 que la connaissance (a) est parfaite, c\u2019est-\u00e0-dire qu\u2019une configuration concr\u00e8te I(m) est affect\u00e9e \u00e0 chaque machine m au temps 0 (du dernier pentest). Nous calculons alors la croyance initiale comme une fonction b0(I, T ) o\u00f9 T est le nombre de jours pass\u00e9s depuis le dernier pentest. L\u2019incertitude dans cette croyance vient de ne pas savoir quelles mises \u00e0 jour logicielles ont \u00e9t\u00e9 appliqu\u00e9es. Nous faisons l\u2019hypoth\u00e8se que les mises \u00e0 jour sont effectu\u00e9es ind\u00e9pendamment sur chaque machine (hypoth\u00e8se simplificatrice, mais raisonnable \u00e9tant donn\u00e9 que les mises \u00e0 jour sont contr\u00f4l\u00e9es par des utilisateurs individuels).\nUn mod\u00e8le simple de mises \u00e0 jour (Sarraute et al., 2011a) encode l\u2019\u00e9volution incertaine de chaque programme ind\u00e9pendamment au moyen d\u2019une cha\u00eene de Markov. Les \u00e9tats de chaque cha\u00eene correspondent aux diff\u00e9rentes versions du programme, et les transitions mod\u00e9lisent les mises \u00e0 jour possibles du programme (avec des probabilit\u00e9s estim\u00e9es que ces mises \u00e0 jour auront lieu). La croyance initiale est alors la distribution r\u00e9sultant de cette cha\u00eene apr\u00e8s T pas de temps.\nExemple 5 Dans notre exemple, les trois composants de l\u2019unique machine sont DEP, CAU et SA. Ils sont mis \u00e0 jour \u00e0 l\u2019aide de trois cha\u00eenes de Markov ind\u00e9pendantes, chacune avec deux \u00e9tats, comme illustr\u00e9 sur la figure 1. Les\n3. En fait, le probl\u00e8me tombe dans la classe des probl\u00e8mes de chemin stochastique le plus court (Bertsekas & Tsitsiklis, 1996).\nprobabilit\u00e9s indiquent quelles sont les chances que la machine passe d\u2019un \u00e9tat \u00e0 un autre pendant un jour. Disons que l\u2019on fixe T = 30, et lancions les cha\u00eenes de Markov sur la configuration I dans laquelle m a le DEP d\u00e9sactiv\u00e9, et SA et CAU sont tous deux vuln\u00e9rables aux exploits de l\u2019attaquant. Dans la croyance initiale r\u00e9sultante b0(I, T ), DEP a des chances d\u2019\u00eatre activ\u00e9 ; le poids des \u00e9tats 12\u201320 dans l\u2019exemple 2 est \u00e9lev\u00e9 dans b0 (> 70%).\nIci, nous utilisons ce mod\u00e8le simple comme bloc de construction \u00e9l\u00e9mentaire dans une m\u00e9thode prenant en compte que la version x du programme A peut n\u00e9cessiter la version y ou z du programme B. Nous faisons l\u2019hypoth\u00e8se que les programmes sont organis\u00e9s d\u2019une mani\u00e8re hi\u00e9rarchique, le syst\u00e8me d\u2019exploitation \u00e9tant \u00e0 la racine d\u2019un graphe orient\u00e9 acyclique, et un programme ayant comme parents les programmes dont il d\u00e9pend directement. Cela donne un r\u00e9seau bay\u00e9sien dynamique, dans lequel chaque distribution de probabilit\u00e9 conditionnelle est d\u00e9riv\u00e9 d\u2019une cha\u00eene de Markov Pr(Xt = x\u2032|Xt\u22121 = x) filtr\u00e9e par une fonction de compatibilit\u00e9 \u03b4(X = x, parent1(X) = x1, . . . , parentk(X) = xk), qui retourne 1 ssi la valeur de X est compatible avec les versions des parents, 0 sinon. Ce mod\u00e8le de mises \u00e0 jour est raisonnable, mais \u00e9videmment pas encore r\u00e9aliste ; les travaux futurs devront \u00e9tudier de tels mod\u00e8les en d\u00e9tail.\nNous illustrons maintenant comment le fait de raisonner avec les probabilit\u00e9s de la croyance initiale permet d\u2019obtenir le comportement intelligent d\u00e9sir\u00e9.\nExemple 6 Supposons que nous calculons la croyance initiale b0(I, T ) comme dans l\u2019exemple 5. Puisque le poids des \u00e9tats 12\u201320 est \u00e9lev\u00e9 dans b0, si m_exploit_SA \u00e9choue, alors la probabilit\u00e9 de succ\u00e8s de m_exploit_CAU est r\u00e9duite au point de ne plus valoir d\u2019efforts, et que l\u2019attaquant (une politique optimale) abandonne, c\u2019est-\u00e0-dire qu\u2019elle essaye une attaque diff\u00e9rente non entrav\u00e9e par le DEP. Plus pr\u00e9cis\u00e9ment, consid\u00e9ronsPr(CAU+|2967+), c\u2019est-\u00e0-dire la probabilit\u00e9 que m_exploit_CAU r\u00e9ussisse, apr\u00e8s avoir observ\u00e9 que le port 2967 est ouvert. Cela correspond au poids (A) des \u00e9tats 8 et 11 dans l\u2019exemple 2, par rapport aux \u00e9tats (B) 6\u201311 plus 15\u201320. Ce poids (A/B) est \u00e0 peu pr\u00e8s 20%. Ainsi la valeur esp\u00e9r\u00e9e de m_exploit_CAU dans cette situation est \u00e0 peu pr\u00e8s 100 \u2217 0, 2 [r\u00e9compense de succ\u00e8s] \u221210 [co\u00fbt d\u2019action] = 10, cf. exemple 4, de sorte que l\u2019action en vaut la peine. A l\u2019inverse, supposons que m_exploit_SA a d\u00e9j\u00e0 \u00e9t\u00e9 essay\u00e9e et a \u00e9chou\u00e9. Alors (A) est r\u00e9duit \u00e0 l\u2019\u00e9tat 8 seul, alors que (B) contient toujours (en particulier) tous les \u00e9tats DEP 15\u201320. Ces derniers \u00e9tats ont un poids important, et donc Pr(CAU+|2967+,SA\u2212) n\u2019est que d\u2019environ 5%. Compte tenu de cela, la valeur esp\u00e9r\u00e9e de m_exploit_CAU est n\u00e9gative, et il est pr\u00e9f\u00e9rable d\u2019appliquer terminate \u00e0 la place."}, {"heading": "4 L\u2019algorithme de d\u00e9composition 4AL", "text": "Comme \u00e9voqu\u00e9, les POMDP ne passent pas \u00e0 l\u2019\u00e9chelle pour de grands r\u00e9seaux (cf. les exp\u00e9rimentations dans la section suivante). Nous pr\u00e9sentons maintenant une approche utilisant d\u00e9composition et approximation pour surmonter ce probl\u00e8me, reposant sur les POMDP seulement pour attaquer des machines individuelles. L\u2019approche est appel\u00e9e 4AL parce qu\u2019elle s\u2019attache \u00e0 l\u2019attaque d\u2019un r\u00e9seau \u00e0 4 niveaux d\u2019abstraction diff\u00e9rents (4 abstraction levels). 4AL est un r\u00e9solveur de POMDP sp\u00e9cialis\u00e9 dans la planification d\u2019attaques telle que consid\u00e9r\u00e9e ici. Son entr\u00e9e est un r\u00e9seau logique LN et des mod\u00e8les POMDP encodant les attaques de machines individuelles. Sa sortie est une politique (une attaque) pour le POMDP global encodant LN , de m\u00eame qu\u2019une\napproximation de la fonction de valeur globale. Nous donnons dans la suite un aper\u00e7u de l\u2019algorithme, puis pr\u00e9cisons les d\u00e9tails techniques. Pour simplifier la pr\u00e9sentation, nous nous concentrerons sur l\u2019approximation de la fonction de valeur, et d\u00e9crirons seulement bri\u00e8vement comment construire la politique."}, {"heading": "4.1 Aper\u00e7u de 4AL et propri\u00e9t\u00e9s \u00e9l\u00e9mentaires", "text": "Les quatre niveaux de 4AL sont : (1) d\u00e9composer le r\u00e9seau, (2) attaquer les composants, (3) attaquer les sous-r\u00e9seaux, et (4) attaquer les machines individuelles. Nous d\u00e9crivons les niveaux tour \u00e0 tour avant de fournir des d\u00e9tails techniques. La figure 2 fournit des illustrations.\n\u2013 Niveau 1 : D\u00e9compose le r\u00e9seau logique LN en un arbre de composants bi-connect\u00e9s, enracin\u00e9 en \u2217. Dans l\u2019ordre topologique inverse, appeler le niveau 2 sur chaque composant ; propager les r\u00e9sultats vers le haut dans l\u2019abre.\nChaque graphe se d\u00e9compose en un unique arbre de composants bi-connect\u00e9s (Hopcroft & Tarjan, 1973). Un composant bi-connect\u00e9 est un sous-graphe qui reste connect\u00e9 quand on retire n\u2019importe quel arc. Dans le pentesting, cela signifie intuitivement qu\u2019il y a plus qu\u2019une fa\u00e7on (plus d\u2019un chemin) pour attaquer les sousr\u00e9seaux de ce composant, ce qui n\u00e9cessite de raisonner \u00e0 propos du composant comme un tout (ce qui est le travail du niveau 2). Au contraire, si retirer le sous-r\u00e9seau X (par exemple, N2 dans la figure 2 (b)) fait que le graphe est coup\u00e9 en deux morceaux (C2 vs. le reste de LN , voir aussi la figure 2 (a)), alors toutes les attaques de \u2217 vers l\u2019un de ces sous-graphes (ici C2) doivent d\u2019abord traverser X (ici N2). Ainsi la valeur esp\u00e9r\u00e9e totale de l\u2019attaque peut \u00eatre calcul\u00e9e par (1) le calcul la valeur d\u2019une attaque de ce sous-graphe (C2) seul, et (2) l\u2019ajout de ce r\u00e9sultat comme une r\u00e9compense de pivotement pour r\u00e9compenser la prise de contr\u00f4le de X (N2). Dit autrement, nous \u201cpropageons les r\u00e9sultats vers le haut\u201d dans l\u2019arbre repr\u00e9sent\u00e9 dans la figure 2 (a).\nAlgorithm 1: Level 1 (Decomposing the Network) Input: LN : Logical Network. Output: Approximation V of expected value V \u2217\nof attacking LN from controlled machine \u2217.\n/* Decompose LN into tree DLN of biconnected components, rooted at \u2217; see text for\n\u201cclean-up\u201d. */\n1 DLN \u2190HopcroftTarjan(LN); 2 Set tree root to \u2217 and clean-up LN and DLN ; 3 C1, . . . , Ck \u2190 a topological ordering of DLN ; 4 Intitialize pivoting reward pr(N) for all N \u2208 LN\nto 0; 5 for i = k, ..., 1 do\n/* Call Level 2 to attack each component.\n*/\n6 V (Ci)\u2190Level2(Ci, pr); /* Propagate expected reward. */ 7 N \u2190 the parent of Ci in LN ; 8 pr(N)\u2190 pr(N) + V (Ci); 9 return pr(\u2217)\nAlgorithm 2: Level 2 (Attacking Components) Input: Biconnected component C, reward function\npr. Output: Approximation V of expected value V \u2217\nof attacking C, given its parent is controlled and its pivoting rewards are pr.\n1 R\u2190 0; /* Account for each rewarded vertex N. */ 2 while \u2203N \u2208 C s.t. r(N) > 0 or pr(N) > 0 do 3 P \u2190 \u3008\u3009 ; R(P )\u2190 0 ; P (N)\u2190 P ;\n/* Maximize over all simple paths (no repeated vertices) from an entry vertex\nto N. */\n4 foreach simple path P of the form F0\u2212\u2192 N1 F1\u2212\u2192 N2 . . . Fk\u22121\u2212\u2212\u2212\u2192 Nk = N where\nN1, . . . , Nk \u2208 C and N1 \u2208 C\u2217 do /* Propagate rewards along P, calling\nLevel 3 for attack on each\nsubnetwork. */\n5 R(P )\u2190 0; 6 for i = k, ..., 1 do 7 R(P )\u2190\nLevel3(Ni, Fi\u22121, pr(Ni), R(P ));\n8 P (N)\u2190 arg max(R(P (N)), R(P )); 9 R\u2190 R+R(P (N));\n10 r(Ni), pr(Ni)\u2190 0 for all vertices Ni on P (N);\n11 return R\nAlgorithm 3: Level 3 (Attacking Subnetworks) Input: Firewall F , subnetwork N , rewards pR,\npathR. Output: Approximation V of expected value V \u2217\nof attacking N through F , given F is reached, N \u2019s pivoting reward is pR, and the path reward behind N is pathR.\n1 R\u2190 0; /* Maximize over reward obtained when hacking\nfirst into a particular machine m \u2208 N. */\n2 foreach m \u2208 N do 3 R(m)\u2190 r(m);\n/* After breaking m, we can pivot behind N, and reach all m 6= m\u2032 \u2208 N without F.\n*/\n4 R(m)\u2190 R(m) + pR+ pathR; 5 foreach m 6= m\u2032 \u2208 N do 6 R(m)\u2190 R(m)+Level4(m\u2032, \u2205, r(m\u2032)); 7 R\u2190 max(R, Level4(m,F,R(m))); 8 return R\nAlgorithm 4: Level 4 (Attacking Individual Machines) Input: Firewall F , machine m, reward R. Output: Approximation V of expected value V \u2217\nof attacking m through F , given m is reached and the current reward of breaking it is R.\n1 if (m,F,R) is cached then 2 return V (m,F,R) 3 M \u2190createPOMDP(m,F,R); 4 V \u2190solvePOMDP(M); 5 Cache (m,F,R) with V ; 6 return V\nIl est important de noter que cette d\u00e9composition arborescente r\u00e9sultera typiquement en une \u00e9norme r\u00e9duction de complexit\u00e9. Les composants bi-connect\u00e9s dans LN ne proviennent que de clusters de plus de 2 sous-r\u00e9seaux partageant une m\u00eame machine pare-feu (physique). De tels clusters tendent \u00e0 \u00eatre petits. Dans le sc\u00e9nario de test r\u00e9aliste utilis\u00e9 par Core Security et ici dans nos exp\u00e9rimentations, il n\u2019y a qu\u2019un seul cluster, de taille 3. S\u2019il\nn\u2019y a pas de cluster du tout, LN est un arbre et le niveau 2 de 4AL devient compl\u00e8tement trivial. \u2013 Niveau 2 : Etant donn\u00e9 le composant C, consid\u00e9rons, pour chaque sous-r\u00e9seau r\u00e9compens\u00e9 N \u2208 C, tous\nles chemins P dans C qui atteignent N . En remontant chaque P en arri\u00e8re, appeler le niveau 3 sur chaque sous-r\u00e9seau avec chaque pare-feu associ\u00e9. Choisir le meilleur chemin pour chaque N . Agr\u00e9ger les valeurs de ces chemins sur tout N , en additionnant mais en ignorant les r\u00e9compenses qui ont d\u00e9j\u00e0 \u00e9t\u00e9 prises en compte par un chemin pr\u00e9c\u00e9dent dans la somme.\nDans le cas o\u00f9 un composant bi-connect\u00e9 C contient plus d\u2019un sous-r\u00e9seau, pour obtenir la meilleure attaque de C, en g\u00e9n\u00e9ral nous n\u2019avons d\u2019autre choix que d\u2019encoder le composant entier comme un POMDP. Puisque ce n\u2019est pas faisable, le niveau 2 consid\u00e8re des \u201cchemins d\u2019attaque\u201d individuels \u00e0 l\u2019int\u00e9rieur de C. N\u2019importe quel chemin P est \u00e9quivalent \u00e0 une s\u00e9quence d\u2019attaques sur des sous-r\u00e9seaux individuels ; ces attaques sont \u00e9valu\u00e9es en utilisant le niveau 3. Nous consid\u00e9rons les n\u0153uds r\u00e9compens\u00e9s N s\u00e9par\u00e9ment, en \u00e9num\u00e9rant les chemins d\u2019attaque et en choisissant le meilleur. Les valeurs des meilleurs chemins sont agr\u00e9g\u00e9es sur toutN d\u2019une mani\u00e8re conservative (pessimiste), en tenant compte de chaque r\u00e9compense au plus une fois. Une sous-estimation stricte a lieu dans le cas o\u00f9 les meilleurs chemins pour certains n\u0153uds r\u00e9compens\u00e9s ne sont pas disjoints : alors ces attaques partagent une partie de leur co\u00fbt, de sorte qu\u2019une attaque combin\u00e9e a une r\u00e9compense esp\u00e9r\u00e9e plus \u00e9lev\u00e9e que la somme des attaques ind\u00e9pendantes.\nDans la figure 2 (b), N2 et N3 ont une r\u00e9compense de pivotement parce qu\u2019ils permettent d\u2019atteindre les composants C2 et C3 respectivement. Si les meilleurs chemins pour \u00e0 la fois N2 et N3 passent par N1 (parce que le pare-feu F \u22173 est tr\u00e8s strict), alors ces chemins ne sont pas disjoints, dupliquant l\u2019effort pour p\u00e9n\u00e9trer dans N1.\n\u00c9videmment, \u00e9num\u00e9rer les chemins d\u2019attaque dans C est exponentiel en la taille de C. C\u2019est le seul point dans 4AL \u2013 \u00e0 part \u00e9videmment les appels au r\u00e9solveur de POMDP \u2013 qui a un temps d\u2019ex\u00e9cution exponentiel dans le pire cas. En pratique, les composants bi-connect\u00e9s sont typiquement petits, cf. ci-dessus.\n\u2013 Niveau 3 : Etant donn\u00e9 un sous-r\u00e9seauN et un pare-feu F \u00e0 travers lequel attaquerN , pour chaque machine m \u2208 N , approximer la r\u00e9compense obtenue en attaquant m d\u2019abord. Pour cela, modifier la r\u00e9compense de m pour tenir compte du fait que, apr\u00e8s avoir p\u00e9n\u00e9tr\u00e9 m, nous serons derri\u00e8re F : appeler le niveau 4 pour obtenir les valeurs de tous les m\u2032 6= m avec un pare-feu vide ; ajouter ensuite ces valeurs, plus toute r\u00e9compense de pivotement, \u00e0 la r\u00e9compense de m et appeler le niveau 4 sur ce m modifi\u00e9 avec le pare-feu F . Maximiser la valeur r\u00e9sultante sur tous les m \u2208 N .\nConsid\u00e9rons la figure 2 (c). Quand on attaque N (ici, N3) depuis une machine derri\u00e8re F (ici, F 13 ), nous avons \u00e0 choisir quelle machine dans N attaquer. Etant donn\u00e9 qu\u2019on s\u2019engage sur un tel choix m, le probl\u00e8me de l\u2019attaque devient celui de p\u00e9n\u00e9trer dans m et apr\u00e8s cela d\u2019exploiter la connexion directe vers n\u2019importe quel m 6= m\u2032 \u2208 N , et n\u2019importe quel r\u00e9seau descendant (ici, C3) vers lequel on peut pivoter. Comme d\u00e9crit, on peut traiter cela en combinant des attaques sur des machines individuelles avec des r\u00e9compenses modifi\u00e9es. (La r\u00e9compense de pivotement pour les r\u00e9seaux descendants est calcul\u00e9e au pr\u00e9alable par les niveaux 1 et 2.)\nComme le niveau 2, le niveau 3 fait des approximations conservatives. Il fixe un choix du m \u2208 N \u00e0 attaquer. Au contraire, la meilleure strat\u00e9gie peut consister \u00e0 basculer entre diff\u00e9rents m \u2208 N selon le succ\u00e8s de l\u2019attaque jusqu\u2019ici. Par exemple, si un exploit a de grandes chances de r\u00e9ussir, alors il peut \u00eatre payant de l\u2019essayer d\u2019abord sur tous les m, avant d\u2019essayer quoi que ce soit d\u2019autre.\n\u2013 Niveau 4 : Etant donn\u00e9e une machinem et un pare-feu F , mod\u00e9liser le probl\u00e8me de planification d\u2019attaques pour une seule machine comme un POMDP, et lancer un r\u00e9solveur pr\u00eat-\u00e0-l\u2019emploi. Mettre en cacher les r\u00e9sultats obtenus pour \u00e9viter les doubles emplois.\nCette derni\u00e8re \u00e9tape ne devrait pas avoir besoin d\u2019explications. Le mod\u00e8le POMDP est cr\u00e9\u00e9 comme d\u00e9crit pr\u00e9c\u00e9demment. Notons que le niveau 3 peut, durant l\u2019ex\u00e9cution de 4AL, appeler la m\u00eame machine avec le m\u00eame pare-feu plus d\u2019une fois. Par exemple, dans la figure 2 (c), quand on bascule vers l\u2019attaque de m\u20321 au lieu de m, l\u2019appel du niveau 4 avec m\u2032k et un pare-feu vide est r\u00e9p\u00e9t\u00e9.\nPour r\u00e9sumer, 4AL a un temps de calcul bas polynomial sauf pour l\u2019\u00e9num\u00e9ration de chemins dans les composants bi-connect\u00e9s (niveau 2), et r\u00e9soudre des POMDP pour une seule machine (niveau 4). La d\u00e9composition au niveau 1 ne subit aucune perte d\u2019information. Les niveaux 2 et 3 font des approximations conservatives, de sorte que, si les solutions des POMDP sont conservatives (par exemple, optimales), alors le r\u00e9sultat d\u2019ensemble de 4AL est aussi conservatif."}, {"heading": "4.2 D\u00e9tails techniques", "text": "Pour fournir une compr\u00e9hension plus d\u00e9taill\u00e9e de 4AL, nous discutons maintenant du pseudo-code de l\u2019algorithme, fourni dans la figure 6. Consid\u00e9rons d\u2019abord l\u2019algorithme 1. Il devrait \u00eatre clair comment la structure d\u2019ensemble de l\u2019algorithme correspond \u00e0 notre discussion pr\u00e9c\u00e9dente. Il appelle l\u2019algorithme \u00e0 temps lin\u00e9aire de Hopcroft & Tarjan (1973) (par la suite, HT) pour trouver la d\u00e9composition. La boucle i = k, . . . , 1 traite les composants dans l\u2019ordre topologique inverse. La fonction de r\u00e9compense de pivotement pr encode la propagation de r\u00e9compenses vers le haut de l\u2019arbre ; cela ne devrait pas avoir besoin d\u2019explications, \u00e0 part pour l\u2019expression \u201cle parent\u201d de Ci dans LN . Cette derni\u00e8re repose sur le fait que, apr\u00e8s nettoyage (\u201cclean-up\u201d, ligne 2), chaque composant a exactement un tel parent.\nPour expliquer le nettoyage, notons d\u2019abord que HT travaille sur des graphes non-orient\u00e9s ; quand nous l\u2019appliquons, nous ignorons la direction des arcs dans LN . Le r\u00e9sultat est un arbre non-orient\u00e9 de composants bi-connect\u00e9s, o\u00f9 les n\u0153uds-coupes \u2013 les n\u0153uds dont la suppression coupe le graphe en morceaux \u2013 sont partag\u00e9s entre plusieurs composants. Dans la figure 2 (b), par exemple, N2, avant nettoyage, appartient \u00e0 la fois \u00e0 C1 et C2. Le nettoyage fixe la racine de l\u2019arbre \u00e0 \u2217, et affecte chaque n\u0153ud-coupe au composant le plus proche de \u2217 (par exemple, N2 est affect\u00e9 \u00e0 C1) ; \u2217 lui-m\u00eame est transform\u00e9 en un composant s\u00e9par\u00e9. En r\u00e9-introduisant l\u2019orientation des arcs dans LN , nous \u00e9liminons alors les n\u0153uds non accessibles depuis \u2217. Ensuite, nous retirons les arcs qui ne peuvent pas participer \u00e0 des chemins d\u2019attaque non redondants partant de \u2217. Puisqu\u2019aller vers \u2217 dans la d\u00e9composition arborescente ram\u00e8ne n\u00e9cessairement toute attaque vers un n\u0153ud qu\u2019elle a d\u00e9j\u00e0 visit\u00e9 (p\u00e9n\u00e9tr\u00e9), apr\u00e8s une telle suppression les arcs entre les composants forment un arbre orient\u00e9 comme sur la figure 2 (a). Chaque composant non-racine Ci (par exemple C3) a exactement un parent composant C dans l\u2019arbre nettoy\u00e9 (par exemple C1). Le sous-r\u00e9seau respectifN \u2208 C (par exempleN3) est un n\u0153ud-coupe de LN . Ainsi, comme affirm\u00e9 plus haut, N est le seul n\u0153ud, dans LN , connect\u00e9 \u00e0 Ci.\nDe mani\u00e8re \u00e9vidente, toutes les attaques sur Ci doivent passer \u00e0 travers leur parent N . De plus, les n\u0153uds et arcs supprim\u00e9s par nettoyage ne peuvent pas faire partie d\u2019une attaque optimale. Ainsi le niveau 1 est sans perte. Pour exprimer cela \u2013 et les autres propri\u00e9t\u00e9s de 4AL \u2013 formellement, nous avons besoin de quelques notations. Nous utiliserons V \u2217 pour d\u00e9signer la valeur esp\u00e9r\u00e9e r\u00e9elle (optimale) d\u2019une attaque, et V pour d\u00e9signer l\u2019approximation 4AL. L\u2019objet attaqu\u00e9 est donn\u00e9 en argument. Par exemple, V \u2217(LN) est la valeur esp\u00e9r\u00e9e pour attaquer LN ; V (C, pr) est le r\u00e9sultat de l\u2019ex\u00e9cution de 4AL niveau 2 sur le composant C et la fonction de r\u00e9compense de pivotement pr.\nProposition 1 Soit LN un r\u00e9seau logique. Supposons que, pour tous les appels \u00e0 4AL niveau 2 effectu\u00e9s par 4AL niveau 1 quand lanc\u00e9 sur LN , nous avons V (C, pr) = V \u2217(C, pr). Alors V (LN) = V \u2217(LN). Si V (C, pr) \u2264 V \u2217(C, pr) pour tous les appels \u00e0 4AL niveau 2, alors V (LN) \u2264 V \u2217(LN).\nConsid\u00e9rons maintenant l\u2019algorithme 2. Notre description pr\u00e9c\u00e9dente \u00e9tait impr\u00e9cise en omettant l\u2019argument additionnel de l\u2019algorithme pr. Celui-ci s\u2019int\u00e8gre \u00e0 l\u2019algorithme en \u00e9tant pass\u00e9, pour chaque sous-r\u00e9seau sur les chemins que nous consid\u00e9rons (ligne 7), \u00e0 l\u2019algorithme 3 qui l\u2019ajoute \u00e0 la r\u00e9compense obtenue pour avoir p\u00e9n\u00e9tr\u00e9 dans ce sous-r\u00e9seau (algorithm 3 ligne 4). R agr\u00e8ge les valeurs (lignes 1, 9) sur tous les sous-r\u00e9seaux r\u00e9compens\u00e9s N . Cette agr\u00e9gation est rendue conservative en enlevant toutes les r\u00e9compenses \u2013 les r\u00e9compenses de pivotement aussi bien que les r\u00e9compenses propres des machines individuelles impliqu\u00e9es \u2013 qui ont d\u00e9j\u00e0 \u00e9t\u00e9 prise en compte (ligne 10). En ce qui concerne les machines individuelles, l\u2019algorithme 2 utilise pour faire plus court (a) r(N) > 0 (ligne 2) et (b) r(N) \u2190 0 (ligne 10) ; (a) signifie qu\u2019il existe m \u2208 N tel que r(m) > 0 ; (b) signifie que r(m) \u2190 0 pour tout m \u2208 N . En ce qui concerne les r\u00e9compenses de pivotement, notons que la ligne 10 de l\u2019algorithme 2 modifie la fonction pr maintenue par l\u2019algorithme 1. Cela ne cr\u00e9\u00e9 pas de conflits puisque, quand l\u2019algorithme 1 appelle l\u2019algorithme 2 sur le composant C, tous les descendants de C dans LN ont d\u00e9j\u00e0 \u00e9t\u00e9 trait\u00e9s, et donc en particulier l\u2019algorithme 1 ne fera plus de mises \u00e0 jour de la valeur de pr(N), quelque soit N \u2208 C.\nPar C\u2217 (ligne 4) nous d\u00e9signons l\u2019ensemble {N \u2208 C | \u2203N \u2032 \u2208 LN,N \u2032 6\u2208 C : (N \u2032, N) \u2208 LN} de sousr\u00e9seaux qui servent d\u2019entr\u00e9e dans C (par exemple, N1 et N3 pour C1 dans la figure 2 (b)). Notons \u00e0 la ligne 4 que le chemin P commence avec un pare-feu F0. Pour comprendre cela, observons la situation consid\u00e9r\u00e9e. L\u2019algorithme suppose que le parent N de C (\u2217, pour le composant C1 dans la figure 2 (b)) est sous contr\u00f4le.\nMais alors, pour p\u00e9n\u00e9trer C, nous avons encore besoin de traverser un arc de N vers C. F0 est le pare-feu sur l\u2019arc choisi par P (F \u22171 ou F \u2217 3 dans la figure 2 (b)).\nLes appels au niveau 3 (ligne 7) comprennent le r\u00e9seau Ni dans lequel p\u00e9n\u00e9trer, le pare-feu Fi\u22121 qui doit \u00eatre travers\u00e9 pour cela, la r\u00e9compense de pivotement de Ni, ainsi que la r\u00e9compense de chemin actuelle R(P ) qui est r\u00e9tro-propag\u00e9e le long du chemin. Clairement, c\u2019est \u00e9quivalent \u00e0 la s\u00e9quence d\u2019attaques requise pour ex\u00e9cuter P et r\u00e9colter toutes les r\u00e9compenses de pivotement associ\u00e9es \u00e0 une telle attaque. Ainsi, l\u2019agr\u00e9gation \u00e0 travers les sous-r\u00e9seaux N \u00e9tant conservative, nous obtenons :\nProposition 2 Soit C un composant bi-connect\u00e9, et soit pr une fonction de r\u00e9compense de pivotement. Supposons que, pour tout appel \u00e0 4AL niveau 3 effectu\u00e9 par 4AL niveau 2 quand ex\u00e9cut\u00e9 sur (C, pr), nous avons\nV (F,N, pR, pathR) \u2264 V \u2217(F,N, pR, pathR).\nAlors V (C, pr) \u2264 V \u2217(C, pr).\nLes algorithmes 3 et 4 ne devraient pas n\u00e9cessiter d\u2019explications, \u00e9tant donn\u00e9e notre discussion pr\u00e9c\u00e9dente. Notons juste que la r\u00e9compense de pivotement pR est repr\u00e9sent\u00e9e par l\u2019arc de m vers C3 dans la figure 2 (c), laquelle est prise en compte simplement en l\u2019additionnant \u00e0 la valeur de m (algorithme 3 ligne 4). La r\u00e9compense de chemin pathR (non illustr\u00e9e dans la figure 2 (c)) est aussi ajout\u00e9e \u00e0 la valeur dem (algorithme 3 ligne 4). Maximiser sur les attaques de machines individuelles m est, de mani\u00e8re \u00e9vidente, une approximation conservative parce que les strat\u00e9gies d\u2019attaque sont libres de choisir m. Ainsi :\nProposition 3 Soit F un pare-feu, N un sous-r\u00e9seau, pR une r\u00e9compense de pivotement, et pathR une r\u00e9compense de chemin. Supposons que, pour tous les appels \u00e0 4AL niveau 4 effectu\u00e9s par 4AL niveau 3 quand ex\u00e9cut\u00e9 sur (F,N, pR, pathR), nous avons\nV (F,m,R) \u2264 V \u2217(F,m,R).\nAlors V (F,N, pR, pathR) \u2264 V \u2217(F,N, pR, pathR)."}, {"heading": "4.3 Construction de la politique", "text": "Au niveau 1, la politique globale est construite \u00e0 partir de politiques du niveau 2 simplement en suivant la d\u00e9composition arborescente : en partant de la racine de l\u2019arbre, on ex\u00e9cute les politiques de niveau 2 pour tous les composants atteints (dans n\u2019importe quel ordre) ; une fois que le piratage d\u2019un composant a r\u00e9ussi, les composants enfants respectifs deviennent atteints. Au niveau 2, c\u2019est-\u00e0-dire \u00e0 l\u2019int\u00e9rieur d\u2019un composant bi-connect\u00e9 C, la politique correspond \u00e0 l\u2019ensemble des chemins P consid\u00e9r\u00e9s par l\u2019algorithme 2. Chaque P est trait\u00e9 tour \u00e0 tour. Pour chaque n\u0153ud N de P (jusqu\u2019\u00e0 \u00e9chec \u00e0 entrer dans ce sous-r\u00e9seau), nous appelons la politique de niveau 3 correspondante.\nAu niveau 3, c\u2019est-\u00e0-dire en consid\u00e9rant un seul sous-r\u00e9seauN , notre politique attaque simplement la machine m \u2208 N qui donnait le maximum dans l\u2019algorithme 3. La politique attaque d\u2019abord m \u00e0 travers le pare-feu en utilisant la politique de niveau 4 associ\u00e9e. Dans le cas o\u00f9 l\u2019attaque r\u00e9ussit, la politique attaque les machines restantes m\u2032 \u2208 N dans n\u2019importe quel ordre (c\u2019est-\u00e0-dire, pour chaque m\u2032, nous ex\u00e9cutons la politique de niveau 4 associ\u00e9e jusqu\u2019\u00e0 terminaison). Au niveau 4, la politique est une politique POMDP classique retourn\u00e9e par notre r\u00e9solveur de POMDP.\n5 Exp\u00e9rimentations Nous avons \u00e9valu\u00e9 4AL contre le mod\u00e8le POMDP \u201cglobal\u201d, encodant le probl\u00e8me de l\u2019attaque tout entier dans un seul POMDP. Les exp\u00e9rimentations sont lanc\u00e9es sur une machine avec un CPU Intel Core2 Duo \u00e0 2,2 GHz et\navec 3 Go de RAM. L\u2019algorithme 4AL est impl\u00e9ment\u00e9 en Python. Pour r\u00e9soudre et \u00e9valuer les POMDP g\u00e9n\u00e9r\u00e9s par le niveau 4, nous utilisons la bo\u00eete \u00e0 outils APPL. 4"}, {"heading": "5.1 Sc\u00e9narios de test", "text": "Notre sc\u00e9nario de test repose sur la structure de r\u00e9seau montr\u00e9e dans la figure 4. L\u2019attaque commence depuis Internet (\u2217 est le nuage dans le coin en haut \u00e0 gauche). Le r\u00e9seau consiste en 3 zones \u2013 Exposed, Sensitive, User \u2013 s\u00e9par\u00e9es par des pare-feux. En interne, Exposed comme Sensitive sont compl\u00e8tement connect\u00e9es (c\u2019est-\u00e0-dire que ces zones sont des sous-r\u00e9seaux), alors que User consiste en un arbre de sous-r\u00e9seaux s\u00e9par\u00e9s par des parefeux vides. Seules deux machines sont r\u00e9compens\u00e9es, une dans Sensitive (r\u00e9compense 9000) et une dans un sous-r\u00e9seau feuille de User (r\u00e9compense 5000). Le co\u00fbt des scans de ports et des exploits est de 10, le co\u00fbt des d\u00e9tections d\u2019OS de 50. Nous permettons de faire cro\u00eetre le nombre de machines |M | en distribuant, toutes les 40 machines, la premi\u00e8re dans Exposed, la seconde dans Sensitive, et les 38 restantes dans User. Les exploits sont pris dans la base de donn\u00e9es de Core Security. Le nombre d\u2019exploits |E| est pass\u00e9 \u00e0 l\u2019\u00e9chelle en distribuant ceux-ci sur 13 mod\u00e8les, et en affectant \u00e0 chaque machine m un tel mod\u00e8le en tant que I(m) (la configuration \u00e0 l\u2019instant du dernier pentest). La croyance initiale b0(I, T ), o\u00f9 T est le temps pass\u00e9 depuis le dernier pentest, est alors g\u00e9n\u00e9r\u00e9 tel que d\u00e9crit.\nLes param\u00e8tres fix\u00e9s ici (r\u00e9compenses, co\u00fbts d\u2019action, distribution des machines sur les zones, nombre de mod\u00e8les) sont estim\u00e9s \u00e0 partir de l\u2019exp\u00e9rience pratique de Core Security. La structure du r\u00e9seau et les exploits sont r\u00e9alistes, et sont utilis\u00e9s pour des tests industriels dans cette compagnie. La principale faiblesse du sc\u00e9nario r\u00e9side dans l\u2019approximation des mises \u00e0 jour logicielles soustendant b0(I, T ). Dans l\u2019ensemble, le sc\u00e9nario est encore simplifi\u00e9, mais il est naturel et approche la complexit\u00e9 des tests de p\u00e9n\u00e9tration r\u00e9els.\nPar manque d\u2019espace, dans ce qui suit nous faisons passer \u00e0 l\u2019\u00e9chelle seulement |M | et |E|, en fixant T = 50. Cette derni\u00e8re valeur est difficile : le pentesting est typiquement accomplit \u00e0 peu pr\u00e8s une fois par mois ; de plus petits T sont plus faciles \u00e0 r\u00e9soudre puisqu\u2019il y a moins d\u2019incertitude."}, {"heading": "5.2 Perte en approximation", "text": "La figure 3 (a) montre la perte relative de qualit\u00e9 quand on ex\u00e9cute 4AL au lieu d\u2019une solution POMDP globale, pour des valeurs de |E| et |M | o\u00f9 cette derni\u00e8re est faisable. Nous montrons quality(global -POMDP)\u2212 quality(4AL) en pourcent de quality(global -POMDP). La qualit\u00e9 de la politique est ici estim\u00e9e en ex\u00e9cutant 2000 simulations. Cette mesure subit une variance, laquelle est presque plus forte que le tr\u00e8s petit avantage en qualit\u00e9 de la solution POMDP globale. La perte maximale pour n\u2019importe quelle combinaison de |E| et |M |\n4. APPL 0.93 sur http ://bigbird.comp.nus.edu.sg/pmwiki/farm/appl/\nest de 14, 1% (pour |E| = 7, |M | = 6), la perte moyenne sur toutes les combinaisons est de 1, 96%. La perte moyenne cro\u00eet de fa\u00e7on monotone selon |M |, de \u22121, 14% pour |M | = 1 \u00e0 4, 37% for |M | = 6. Selon |E|, le comportement est moins r\u00e9gulier ; la perte moyenne maximale, 5, 4%, est obtenue en fixant |E| = 5."}, {"heading": "5.3 Passage \u00e0 l\u2019\u00e9chelle", "text": "La figure 3 (b) montre le temps d\u2019\u00e9xecution de 4AL quand on passe \u00e0 de plus grandes valeurs de |E| et |M |. Le comportement de passage \u00e0 l\u2019\u00e9chelle selon |M | refl\u00e8te clairement le fait que 4AL est polynomial en ce param\u00e8tre, sauf pour la taille des composants bi-connect\u00e9s (ici 4). Faire cro\u00eetre E donne des POMDP monomachines plus difficiles, r\u00e9sultant parfois en une croissance forte du temps de calcul. Pourtant, m\u00eame avec |M | et |E| tous deux proches de 100, ce qui est une taille r\u00e9aliste en pratique, le temps d\u2019ex\u00e9cution est toujours sous les 37 secondes."}, {"heading": "6 Conclusion", "text": "Nous avons con\u00e7u un mod\u00e8le POMDP pour les tests de p\u00e9n\u00e9tration qui permet de repr\u00e9senter naturellement beaucoup des caract\u00e9ristiques de cette application, en particulier la connaissance incompl\u00e8te de la configuration du r\u00e9seau, ainsi que les d\u00e9pendences entre les diff\u00e9rentes attaques possibles et les pare-feux. A la diff\u00e9rence des m\u00e9thodes pr\u00e9c\u00e9dentes, cette approche est capable de m\u00e9langer intelligemment scans et exploits. Si cette solution exacte ne passe pas \u00e0 l\u2019\u00e9chelle, de grands r\u00e9seaux peuvent \u00eatre trait\u00e9s par un algorithme de d\u00e9composition. Nos r\u00e9sultats exp\u00e9rimentaux sugg\u00e8rent que c\u2019est accompli pour une faible perte en qualit\u00e9 par rapport \u00e0 une solution POMDP globale.\nUne importante question ouverte est dans quelle mesure notre approche POMDP+decomposition est plus efficace en termes de co\u00fbts que la solution par planification classique actuellement employ\u00e9e par Core Security. Notre prochaine \u00e9tape sera de r\u00e9pondre \u00e0 cette question exp\u00e9rimentalement, en comparant la qualit\u00e9 des attaques de 4AL avec celle de la politique qui ex\u00e9cute des scans extensifs et ex\u00e9cute ensuite les plans de FF associ\u00e9s \u00e0 la\nconfiguration la plus probable. 4AL est un algorithme sp\u00e9cifique \u00e0 un domaine et, en tant que tel, ne contribue pas \u00e0 la r\u00e9solution de POMDP en g\u00e9n\u00e9ral. A un haut niveau d\u2019abstraction, son id\u00e9e peut \u00eatre comprise comme imposant un sch\u00e9ma sur la politique construite, restreignant ainsi l\u2019espace des politiques explor\u00e9es (et employant des algorithmes d\u00e9di\u00e9s dans chaque partie du sch\u00e9ma). En cela, cette approche est assez similaire aux approches de d\u00e9composition de POMDP connues (par exemple, (Pineau et al., 2003; M\u00fcller & Biundo, 2011)). Il reste \u00e0 voir si cette connexion peut s\u2019av\u00e9rer fructueuse soit pour de travaux futurs en planification d\u2019attaques, soit pour la r\u00e9solution de POMDP de mani\u00e8re plus g\u00e9n\u00e9rale.\nLes principales directions pour des travaux futurs sont de concevoir des mod\u00e8les plus pr\u00e9cis des mises \u00e0 jour logicielles (donc obtenant des calculs plus r\u00e9alistes de la croyance initiale) ; d\u2019adapter les r\u00e9solveurs de POMDP \u00e0 ce type particulier de probl\u00e8me, qui a certaines caract\u00e9ristiques sp\u00e9cifiques, en particulier l\u2019absence d\u2019actions non-d\u00e9terministes et le fait que certaines parties de l\u2019\u00e9tat (par exemple les syst\u00e8mes d\u2019exploitation) sont statiques ; et de faire progresser l\u2019application industrielle de cette technologie. Nous esp\u00e9rons que tout cela inspirera aussi d\u2019autres recherches.\nR\u00e9f\u00e9rences ARCE I. & MCGRAW G. (2004). Why attacking systems is a good idea. IEEE Computer Society - Security &\nPrivacy Magazine, 2(4). BERTSEKAS D. & TSITSIKLIS J. (1996). Neurodynamic Programming. Athena Scientific. BODDY M. S., GOHDE J., HAIGH T. & HARP S. A. (2005). Course of action generation for cyber security\nusing classical planning. In Proc. of ICAPS\u201905. HANSEN E. & FENG Z. (2000). Dynamic programming for POMDPs using a factored state representation. In\nProceedings of the International Conference on AI Planning and Scheduling (AIPS\u201900). HOFFMANN J. (2003). The Metric-FF planning system : Translating \u201cignoring delete lists\u201d to numeric state\nvariables. Journal of Artificial Intelligence Research, 20, 291\u2013341. HOPCROFT J. & TARJAN R. (1973). Algorithm 447 : efficient algorithms for graph manipulation. Communi-\ncations of the ACM, 16, 372\u2013378. KAELBLING L., LITTMAN M. & CASSANDRA A. (1998). Planning and acting in partially observable stochas-\ntic domains. Artificial Intelligence, 101(1\u20132), 99\u2013134. KURNIAWATI H., HSU D. & LEE W. (2008). SARSOP : Efficient point-based POMDP planning by approxi-\nmating optimally reachable belief spaces. In Robotics : Science and Systems IV. LUCANGELI J., SARRAUTE C. & RICHARTE G. (2010). Attack planning in the real world. In Workshop on\nIntelligent Security (SecArt 2010). MONAHAN G. (1982). A survey of partially observable Markov decision processes. Management Science, 28,\n1\u201316. M\u00dcLLER F. & BIUNDO S. (2011). HTN-style planning in relational POMDPs using first-order FSCs. In\nProceedings of the 34th German Conference on AI (KI\u201911), p. 216\u2013227. PINEAU J., GORDON G. & THRUN S. (2003). Policy-contingent abstraction for robust robot control. In\nProceedings of the 19th Conference on Uncertainty in Articifical Intelligence (UAI\u201903), p. 477\u2013484. SARRAUTE C., BUFFET O. & HOFFMANN J. (2011a). Penetration testing == POMDP solving ? In Proceedings\nof the 3rd Workshop on Intelligent Security (SecArt\u201911). SARRAUTE C., RICHARTE G. & LUCANGELI J. (2011b). An algorithm to find optimal attack paths in nonde-\nterministic scenarios. In ACM Workshop on Artificial Intelligence and Security (AISec\u201911)."}], "references": [], "referenceMentions": [], "year": 2013, "abstractText": "R\u00e9sum\u00e9 : Les tests de p\u00e9n\u00e9tration sont une m\u00e9thodologie pour \u00e9valuer la s\u00e9curit\u00e9 d\u2019un r\u00e9seau en g\u00e9n\u00e9rant et ex\u00e9cutant de possibles attaques informatiques. Automatiser cette t\u00e2che permet de r\u00e9aliser des tests r\u00e9guliers et syst\u00e9matiques. Une question clef est : \u201cComment g\u00e9n\u00e9rer ces attaques ?\u201d Ce probl\u00e8me se formule naturellement comme de la planification dans l\u2019incertain, plus pr\u00e9cis\u00e9ment avec une connaissance incompl\u00e8te de la configuration du r\u00e9seau. Les travaux ant\u00e9rieurs emploient de la planification classique, et requi\u00e8rent de co\u00fbteux pr\u00e9-traitements r\u00e9duisant cette incertitude par l\u2019application extensive de m\u00e9thodes de scan. Au contraire, nous mod\u00e9lisons ici le probl\u00e8me de la planification d\u2019attaques \u00e0 travers des processus de d\u00e9cision markoviens partiellement observables (POMDP). Ceci nous permet de raisonner \u00e0 propos de la connaissance disponible, et d\u2019employer intelligemment les actions de scan comme faisant partie de l\u2019attaque. Comme on s\u2019y attendrait, cette solution pr\u00e9cise ne passe pas \u00e0 l\u2019\u00e9chelle. Nous concevons donc une m\u00e9thode qui repose sur les POMDP pour trouver de bonnes attaques sur des machines individuelles, lesquelles sont recompos\u00e9es en une attaque sur le r\u00e9seau complet. Cette d\u00e9composition exploite la structure du r\u00e9seau dans la mesure du possible, faisant des approximations cibl\u00e9es (seulement) o\u00f9 cela est n\u00e9cessaire. En \u00e9valuant cette m\u00e9thode sur un jeu de tests industriels adapt\u00e9s convenablement, nous d\u00e9montrons son efficacit\u00e9 \u00e0 la fois en temps de calcul et en qualit\u00e9 de la solution.", "creator": "LaTeX with hyperref package"}}}