{"id": "1401.3436", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Online Planning Algorithms for POMDPs", "abstract": "partially observable markov flow processes ( eps ) provide a rich framework for sequential decision - making addressing uncertainty in stochastic domains. however, solving a pomdp is never intractable except for potential problems due to narrow magnitude. here, vendors focus on online approaches that alleviate the computational complexity by computing good local policies at each decision step during the execution. online algorithms generally consist of a lookahead matrix to find the best procedures to execute at each time step in an environment. our objectives here are constantly survey basically various existing online pomdp methods, analyze their needs and exploit their advantages and disadvantages ; and to thoroughly evaluate these online approaches in different environments under various metrics ( return, error bound reduction, weak bound improvement ). our experimental results indicate that state - of - the - art online heuristic search methods quickly handle large pomdp users efficiently.", "histories": [["v1", "Wed, 15 Jan 2014 04:52:25 GMT  (443kb)", "http://arxiv.org/abs/1401.3436v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["st\\'ephane ross", "joelle pineau", "s\\'ebastien paquet", "brahim chaib-draa"], "accepted": false, "id": "1401.3436"}, "pdf": {"name": "1401.3436.pdf", "metadata": {"source": "CRF", "title": "Online Planning Algorithms for POMDPs", "authors": ["St\u00e9phane Ross", "Joelle Pineau", "S\u00e9bastien Paquet", "Brahim Chaib-draa"], "emails": ["stephane.ross@mail.mcgill.ca", "jpineau@cs.mcgill.ca", "spaquet@damas.ift.ulaval.ca", "chaib@damas.ift.ulaval.ca"], "sections": [{"heading": "1. Introduction", "text": "The Partially Observable Markov Decision Process (POMDP) is a general model for sequential decision problems in partially observable environments. Many planning and control problems can be modeled as POMDPs, but very few can be solved exactly because of their computational complexity: finite-horizon POMDPs are PSPACE-complete (Papadimitriou & Tsitsiklis, 1987) and infinite-horizon POMDPs are undecidable (Madani, Hanks, & Condon, 1999).\nIn the last few years, POMDPs have generated significant interest in the AI community and many approximation algorithms have been developed (Hauskrecht, 2000; Pineau, Gordon, & Thrun, 2003; Braziunas & Boutilier, 2004; Poupart, 2005; Smith & Simmons, 2005; Spaan & Vlassis, 2005). All these methods are offline algorithms, meaning that they specify, prior to the execution, the best action to execute for all possible situations. While these approximate algorithms can achieve very good performance, they often take significant time (e.g. more than an hour) to solve large problems, where there are too many possible situations to enumerate (let alone plan for). Furthermore, small changes in the environment\u2019s dynamics require recomputing the full policy, which may take hours or days.\nc\u00a92008 AI Access Foundation. All rights reserved.\nOn the other hand, online approaches (Satia & Lave, 1973; Washington, 1997; Barto, Bradtke, & Singhe, 1995; Paquet, Tobin, & Chaib-draa, 2005; McAllester & Singh, 1999; Bertsekas & Castanon, 1999; Shani, Brafman, & Shimony, 2005) try to circumvent the complexity of computing a policy by planning online only for the current information state. Online algorithms are sometimes also called agent-centered search algorithms (Koenig, 2001). Whereas an offline search would compute an exponentially large contingency plan considering all possible happenings, an online search only considers the current situation and a small horizon of contingency plans. Moreover, some of these approaches can handle environment changes without requiring more computation, which allows online approaches to be applicable in many contexts where offline approaches are not applicable, for instance, when the task to accomplish, as defined by the reward function, changes regularly in the environment. One drawback of online planning is that it generally needs to meet real-time constraints, thus greatly reducing the available planning time, compared to offline approaches.\nRecent developments in online POMDP search algorithms (Paquet, Chaib-draa, & Ross, 2006; Ross & Chaib-draa, 2007; Ross, Pineau, & Chaib-draa, 2008) suggest that combining approximate offline and online solving approaches may be the most efficient way to tackle large POMDPs. In fact, we can generally compute a very rough policy offline using existing offline value iteration algorithms, and then use this approximation as a heuristic function to guide the online search algorithm. This combination enables online search algorithms to plan on shorter horizons, thereby respecting online real-time constraints and retaining a good precision. By doing an exact online search over a fixed horizon, we can guarantee a reduction in the error of the approximate offline value function. The overall time (offline and online) required to obtain a good policy can be dramatically reduced by combining both approaches.\nThe main purpose of this paper is to draw the attention of the AI community to online methods as a viable alternative for solving large POMDP problems. In support of this, we first survey the various existing online approaches that have been applied to POMDPs, and discuss their strengths and drawbacks. We present various combinations of online algorithms with various existing offline algorithms, such as QMDP (Littman, Cassandra, & Kaelbling, 1995), FIB (Hauskrecht, 2000), Blind (Hauskrecht, 2000; Smith & Simmons, 2005) and PBVI (Pineau et al., 2003). We then compare empirically different online approaches in two large POMDP domains according to different metrics (average discounted return, error bound reduction, lower bound improvement). We also evaluate how the available online planning time and offline planning time affect the performance of different algorithms. The results of our experiments show that many state-of-the-art online heuristic search methods are tractable in large state and observation spaces, and achieve the solution quality of stateof-the-art offline approaches at a fraction of the computational cost. The best methods achieve this by focusing the search on the most relevant future outcomes for the current decision, e.g. those that are more likely and that have high uncertainty (error) on their longterm values, such as to minimize as quickly as possible an error bound on the performance of the best action found. The tradeoff between solution quality and computing time offered by the combinations of online and offline approaches is very attractive for tackling increasingly large domains."}, {"heading": "2. POMDP Model", "text": "Partially observable Markov decision processes (POMDPs) provide a general framework for acting in partially observable environments (Astrom, 1965; Smallwood & Sondik, 1973; Monahan, 1982; Kaelbling, Littman, & Cassandra, 1998). A POMDP is a generalization of the MDP model for planning under uncertainty, which gives the agent the ability to effectively estimate the outcome of its actions even when it cannot exactly observe the state of its environment.\nFormally, a POMDP is represented as a tuple (S,A, T,R,Z,O) where:\n\u2022 S is the set of all the environment states. A state is a description of the environment at a specific moment and it should capture all information relevant to the agent\u2019s decision-making process.\n\u2022 A is the set of all possible actions.\n\u2022 T : S \u00d7 A \u00d7 S \u2192 [0, 1] is the transition function, where T (s, a, s\u2032) = Pr(s\u2032|s, a) represents the probability of ending in state s\u2032 if the agent performs action a in state s.\n\u2022 R : S \u00d7 A \u2192 R is the reward function, where R(s, a) is the reward obtained by executing action a in state s.\n\u2022 Z is the set of all possible observations.\n\u2022 O : S\u00d7A\u00d7Z \u2192 [0, 1] is the observation function, where O(s\u2032, a, z) = Pr(z|a, s\u2032) gives the probability of observing z if action a is performed and the resulting state is s\u2032.\nWe assume in this paper that S, A and Z are all finite and that R is bounded. A key aspect of the POMDP model is the assumption that the states are not directly observable. Instead, at any given time, the agent only has access to some observation z \u2208 Z that gives incomplete information about the current state. Since the states are not observable, the agent cannot choose its actions based on the states. It has to consider a complete history of its past actions and observations to choose its current action. The history at time t is defined as:\nht = {a0, z1, . . . , zt\u22121, at\u22121, zt}. (1)\nThis explicit representation of the past is typically memory expensive. Instead, it is possible to summarize all relevant information from previous actions and observations in a probability distribution over the state space S, which is called a belief state (Astrom, 1965). A belief state at time t is defined as the posterior probability distribution of being in each state, given the complete history:\nbt(s) = Pr(st = s|ht, b0). (2)\nThe belief state bt is a sufficient statistic for the history ht (Smallwood & Sondik, 1973), therefore the agent can choose its actions based on the current belief state bt instead of all past actions and observations. Initially, the agent starts with an initial belief state b0,\nrepresenting its knowledge about the starting state of the environment. Then, at any time t, the belief state bt can be computed from the previous belief state bt\u22121, using the previous action at\u22121 and the current observation zt. This is done with the belief state update function \u03c4(b, a, z), where bt = \u03c4(bt\u22121, at\u22121, zt) is defined by the following equation:\nbt(s \u2032) = \u03c4(bt\u22121, at\u22121, zt)(s \u2032) = 1\nPr(zt|bt\u22121, at\u22121) O(s\u2032, at\u22121, zt)\n\u2211\ns\u2208S\nT (s, at\u22121, s \u2032)bt\u22121(s), (3)\nwhere Pr(z|b, a), the probability of observing z after doing action a in belief b, acts as a normalizing constant such that bt remains a probability distribution:\nPr(z|b, a) = \u2211\ns\u2032\u2208S\nO(s\u2032, a, z) \u2211\ns\u2208S\nT (s, a, s\u2032)b(s). (4)\nNow that the agent has a way of computing its belief, the next interesting question is how to choose an action based on this belief state.\nThis action is determined by the agent\u2019s policy \u03c0, specifying the probability that the agent will execute any action in any given belief state, i.e. \u03c0 defines the agent\u2019s strategy for all possible situations it could encounter. This strategy should maximize the amount of reward earned over a finite or infinite time horizon. In this article, we restrict our attention to infinite-horizon POMDPs where the optimality criterion is to maximize the expected sum of discounted rewards (also called the return or discounted return). More formally, the optimal policy \u03c0\u2217 can be defined by the following equation:\n\u03c0\u2217 = argmax \u03c0\u2208\u03a0 E\n[ \u221e\u2211\nt=0\n\u03b3t \u2211\ns\u2208S\nbt(s) \u2211\na\u2208A\nR(s, a)\u03c0(bt, a) |b0\n]\n, (5)\nwhere \u03b3 \u2208 [0, 1) is the discount factor and \u03c0(bt, a) is the probability that action a will be performed in belief bt, as prescribed by the policy \u03c0.\nThe return obtained by following a specific policy \u03c0, from a certain belief state b, is defined by the value function equation V \u03c0:\nV \u03c0(b) = \u2211\na\u2208A\n\u03c0(b, a) [ RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)V \u03c0(\u03c4(b, a, z)) ] . (6)\nHere the function RB(b, a) specifies the immediate expected reward of executing action a in belief b according to the reward function R:\nRB(b, a) = \u2211\ns\u2208S\nb(s)R(s, a). (7)\nThe sum over Z in Equation 6 is interpreted as the expected future return over the infinite horizon of executing action a, assuming the policy \u03c0 is followed afterwards.\nNote that with the definitions of RB(b, a), Pr(z|b, a) and \u03c4(b, a, z), one can view a POMDP as an MDP over belief states (called the belief MDP), where Pr(z|b, a) specifies the probability of moving from b to \u03c4(b, a, z) by doing action a, andRB(b, a) is the immediate reward obtained by doing action a in b.\nThe optimal policy \u03c0\u2217 defined in Equation 5 represents the action-selection strategy that will maximize equation V \u03c0(b0). Since there always exists a deterministic policy that maximizes V \u03c0 for any belief states (Sondik, 1978), we will generally only consider deterministic policies (i.e. those that assign a probability of 1 to a specific action in every belief state).\nThe value function V \u2217 of the optimal policy \u03c0\u2217 is the fixed point of Bellman\u2019s equation (Bellman, 1957):\nV \u2217(b) = max a\u2208A\n[ RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)V \u2217(\u03c4(b, a, z)) ] . (8)\nAnother useful quantity is the value of executing a given action a in a belief state b, which is denoted by the Q-value:\nQ\u2217(b, a) = RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)V \u2217(\u03c4(b, a, z)). (9)\nHere the only difference with the definition of V \u2217 is that the max operator is omitted. Notice that Q\u2217(b, a) determines the value of a by assuming that the optimal policy is followed at every step after action a.\nWe now review different offline methods for solving POMDPs. These are used to guide some of the online heuristic search methods discussed later, and in some cases they form the basis of other online solutions."}, {"heading": "2.1 Optimal Value Function Algorithm", "text": "One can solve optimally a POMDP for a specified finite horizon H by using the value iteration algorithm (Sondik, 1971). This algorithm uses dynamic programming to compute increasingly more accurate values for each belief state b. The value iteration algorithm begins by evaluating the value of a belief state over the immediate horizon t = 1. Formally, let V be a value function that takes a belief state as parameter and returns a numerical value in R of this belief state. The initial value function is:\nV1(b) = max a\u2208A RB(b, a). (10)\nThe value function at horizon t is constructed from the value function at horizon t\u2212 1 by using the following recursive equation:\nVt(b) = max a\u2208A\n[ RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)Vt\u22121(\u03c4(b, a, z))\n] . (11)\nThe value function in Equation 11 defines the discounted sum of expected rewards that the agent can receive in the next t time steps, for any belief state b. Therefore, the optimal policy for a finite horizon t is simply to choose the action maximizing Vt(b):\n\u03c0\u2217t (b) = argmax a\u2208A\n[ RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)Vt\u22121(\u03c4(b, a, z))\n] . (12)\nThis last equation associates an action to a specific belief state, and therefore must be computed for all possible belief states in order to define a full policy.\nA key result by Smallwood and Sondik (1973) shows that the optimal value function for a finite-horizon POMDP can be represented by hyperplanes, and is therefore convex and piecewise linear. It means that the value function Vt at any horizon t can be represented by a set of |S|-dimensional hyperplanes: \u0393t = {\u03b10, \u03b11, . . . , \u03b1m}. These hyperplanes are often called \u03b1-vectors. Each defines a linear value function over the belief state space associated with some action a \u2208 A. The value of a belief state is the maximum value returned by one of the \u03b1-vectors for this belief state. The best action is the one associated with the \u03b1-vector that returned the best value:\nVt(b) = max \u03b1\u2208\u0393t\n\u2211\ns\u2208S\n\u03b1(s)b(s). (13)\nA number of exact value function algorithms leveraging the piecewise-linear and convex aspects of the value function have been proposed in the POMDP literature (Sondik, 1971; Monahan, 1982; Littman, 1996; Cassandra, Littman, & Zhang, 1997; Zhang & Zhang, 2001). The problem with most of these exact approaches is that the number of \u03b1-vectors needed to represent the value function grows exponentially in the number of observations at each iteration, i.e. the size of the set \u0393t is in O(|A||\u0393t\u22121|\n|Z|). Since each new \u03b1-vector requires computation time in O(|Z||S|2), the resulting complexity of iteration t for exact approaches is in O(|A||Z||S|2|\u0393t\u22121|\n|Z|). Most of the work on exact approaches has focused on finding efficient ways to prune the set \u0393t, such as to effectively reduce computation."}, {"heading": "2.2 Offline Approximate Algorithms", "text": "Due to the high complexity of exact solving approaches, many researchers have worked on improving the applicability of POMDP approaches by developing approximate offline approaches that can be applied to larger problems.\nIn the online methods we review below, approximate offline algorithms are often used to compute lower and upper bounds on the optimal value function. These bounds are leveraged to orient the search in promising directions, to apply branch-and-bound pruning techniques, and to estimate the long term reward of belief states, as we will show in Section 3. However, we will generally want to use approximate methods which require very low computational cost. We will be particularly interested in approximations that use the underlying MDP1 to compute lower bounds (Blind policy) and upper bounds (MDP, QMDP, FIB) on the exact value function. We also investigate the usefulness of using more precise lower bounds provided by point-based methods. We now briefly review the offline methods which will be featured in our empirical investigation. Some recent publications provide a more comprehensive overview of offline approximate algorithms (Hauskrecht, 2000; Pineau, Gordon, & Thrun, 2006)."}, {"heading": "2.2.1 Blind policy", "text": "A Blind policy (Hauskrecht, 2000; Smith & Simmons, 2005) is a policy where the same action is always executed, regardless of the belief state. The value function of any Blind\n1. The MDP defined by the (S,A,T, R) components of the POMDP model.\npolicy is obviously a lower bound on V \u2217 since it corresponds to the value of one specific policy that the agent could execute in the environment. The resulting value function is specified by a set of |A| \u03b1-vectors, where each \u03b1-vector specifies the long term expected reward of following its corresponding blind policy. These \u03b1-vectors can be computed using a simple update rule:\n\u03b1at+1(s) = R(s, a) + \u03b3 \u2211\ns\u2032\u2208S\nT (s, a, s\u2032)\u03b1at (s), (14)\nwhere \u03b1a0 = mins\u2208S R(s, a)/(1\u2212\u03b3). Once these \u03b1-vectors are computed, we use Equation 13 to obtain the lower bound on the value of a belief state. The complexity of each iteration is in O(|A||S|2), which is far less than exact methods. While this lower bound can be computed very quickly, it is usually not very tight and thus not very informative."}, {"heading": "2.2.2 Point-Based Algorithms", "text": "To obtain tighter lower bounds, one can use point-based methods (Lovejoy, 1991; Hauskrecht, 2000; Pineau et al., 2003). This popular approach approximates the value function by updating it only for some selected belief states. These point-based methods sample belief states by simulating some random interactions of the agent with the POMDP environment, and then update the value function and its gradient over those sampled beliefs. These approaches circumvent the complexity of exact approaches by sampling a small set of beliefs and maintaining at most one \u03b1-vector per sampled belief state. Let B represent the set of sampled beliefs, then the set \u0393t of \u03b1-vectors at time t is obtained as follows:\n\u03b1a(s) = R(s, a), \u0393a,zt = {\u03b1 a,z i |\u03b1 a,z i (s) = \u03b3 \u2211 s\u2032\u2208S T (s, a, s \u2032)O(s\u2032, a, z)\u03b1\u2032i(s \u2032), \u03b1\u2032i \u2208 \u0393t\u22121},\n\u0393bt = {\u03b1 a b |\u03b1 a b = \u03b1\na + \u2211 z\u2208Z argmax\u03b1\u2208\u0393a,zt \u2211 s\u2208S \u03b1(s)b(s), a \u2208 A},\n\u0393t = {\u03b1b|\u03b1b = argmax\u03b1\u2208\u0393bt\n\u2211 s\u2208S b(s)\u03b1(s), b \u2208 B}.\n(15)\nTo ensure that this gives a lower bound, \u03930 is initialized with a single \u03b1-vector \u03b10(s) = mins\u2032\u2208S,a\u2208A R(s \u2032,a) 1\u2212\u03b3 . Since |\u0393t\u22121| \u2264 |B|, each iteration has a complexity in O(|A||Z||S||B|(|S|+ |B|)), which is polynomial time, compared to exponential time for exact approaches.\nDifferent algorithms have been developed using the point-based approach: PBVI (Pineau et al., 2003), Perseus (Spaan & Vlassis, 2005), HSVI (Smith & Simmons, 2004, 2005) are some of the most recent methods. These methods differ slightly in how they choose belief states and how they update the value function at these chosen belief states. The nice property of these approaches is that one can tradeoff between the complexity of the algorithm and the precision of the lower bound by increasing (or decreasing) the number of sampled belief points."}, {"heading": "2.2.3 MDP", "text": "The MDP approximation consists in approximating the value function V \u2217 of the POMDP by the value function of its underlying MDP (Littman et al., 1995). This value function is an upper bound on the value function of the POMDP and can be computed using Bellman\u2019s equation:\nV MDPt+1 (s) = max a\u2208A\n[ R(s, a) + \u03b3 \u2211\ns\u2032\u2208S\nT (s, a, s\u2032)V MDPt (s \u2032)\n] . (16)\nThe value V\u0302 (b) of a belief state b is then computed as V\u0302 (b) = \u2211\ns\u2208S V MDP (s)b(s). This\ncan be computed very quickly, as each iteration of Equation 16 can be done in O(|A||S|2)."}, {"heading": "2.2.4 QMDP", "text": "The QMDP approximation is a slight variation of the MDP approximation (Littman et al., 1995). The main idea behind QMDP is to consider that all partial observability disappear after a single step. It assumes the MDP solution is computed to generate V MDPt (Equation 16). Given this, we define:\nQMDPt+1 (s, a) = R(s, a) + \u03b3 \u2211\ns\u2032\u2208S\nT (s, a, s\u2032)V MDPt (s \u2032). (17)\nThis approximation defines an \u03b1-vector for each action, and gives an upper bound on V \u2217 that is tighter than V MDP ( i.e. V QMDPt (b) \u2264 V MDP t (b) for all belief b). Again, to obtain the value of a belief state, we use Equation 13, where \u0393t will contain one \u03b1-vector \u03b1a(s) = QMDPt (s, a) for each a \u2208 A."}, {"heading": "2.2.5 FIB", "text": "The two upper bounds presented so far, QMDP and MDP, do not take into account the partial observability of the environment. In particular, information-gathering actions that may help identify the current state are always suboptimal according to these bounds. To address this problem, Hauskrecht (2000) proposed a new method to compute upper bounds, called the Fast Informed Bound (FIB), which is able to take into account (to some degree) the partial observability of the environment. The \u03b1-vector update process is described as follows:\n\u03b1at+1(s) = R(s, a) + \u03b3 \u2211\nz\u2208Z\nmax \u03b1t\u2208\u0393t\n\u2211\ns\u2032\u2208S\nO(s\u2032, a, z)T (s, a, s\u2032)\u03b1t(s \u2032). (18)\nThe \u03b1-vectors \u03b1a0 can be initialized to the \u03b1-vectors found by QMDP at convergence, i.e. \u03b1a0(s) = Q\nMDP (s, a). FIB defines a single \u03b1-vector for each action and the value of a belief state is computed according to Equation 13. FIB provides a tighter upper bound than QMDP ( i.e. V FIBt (b) \u2264 V QMDP t (b) for all b ). The complexity of the algorithm remains acceptable, as each iteration requires O(|A|2|S|2|Z|) operations."}, {"heading": "3. Online Algorithms for POMDPs", "text": "With offline approaches, the algorithm returns a policy defining which action to execute in every possible belief state. Such approaches tend to be applicable only when dealing with small to mid-size domains, since the policy construction step takes significant time. In large POMDPs, using a very rough value function approximation (such as the ones presented in Section 2.2) tends to substantially hinder the performance of the resulting approximate\npolicy. Even more recent point-based methods produce solutions of limited quality in very large domains (Paquet et al., 2006).\nHence in large POMDPs, a potentially better alternative is to use an online approach, which only tries to find a good local policy for the current belief state of the agent. The advantage of such an approach is that it only needs to consider belief states that are reachable from the current belief state. This focuses computation on a small set of beliefs. In addition, since online planning is done at every step (and thus generalization between beliefs is not required), it is sufficient to calculate only the maximal value for the current belief state, not the full optimal \u03b1-vector. In this setting, the policy construction steps and the execution steps are interleaved with one another as shown in Figure 1. In some cases, online approaches may require a few extra execution steps (and online planning), since the policy is locally constructed and therefore not always optimal. However the policy construction time is often substantially shorter. Consequently, the overall time for the policy construction and execution is normally less for online approaches (Koenig, 2001). In practice, a potential limitation of online planning is when we need to meet short real-time constraints. In such case, the time available to construct the plan is very small compared to offline algorithms."}, {"heading": "3.1 General Framework for Online Planning", "text": "This subsection presents a general framework for online planning algorithms in POMDPs. Subsequently, we discuss specific approaches from the literature and describe how they vary in tackling various aspects of this general framework.\nAn online algorithm is divided into a planning phase, and an execution phase, which are applied alternately at each time step.\nIn the planning phase, the algorithm is given the current belief state of the agent and computes the best action to execute in that belief. This is usually achieved in two steps. First a tree of reachable belief states from the current belief state is built by looking at several possible sequences of actions and observations that can be taken from the current belief. In this tree, the current belief is the root node and subsequent reachable beliefs (as calculated by the \u03c4(b, a, z) function of Equation 3) are added to the tree as child nodes of their immediate previous belief. Belief nodes are represented using OR-nodes (at which we must choose an action) and actions are included in between each layer of belief nodes using AND-nodes (at which we must consider all possible observations that lead to subsequent\nbeliefs). Then the value of the current belief is estimated by propagating value estimates up from the fringe nodes, to their ancestors, all the way to the root, according to Bellman\u2019s equation (Equation 8). The long-term value of belief nodes at the fringe is usually estimated using an approximate value function computed offline. Some methods also maintain both a lower bound and an upper bound on the value of each node. An example on how such a tree is contructed and evaluated is presented in Figure 2.\nOnce the planning phase terminates, the execution phase proceeds by executing the best action found for the current belief in the environment, and updating the current belief and tree according to the observation obtained.\nNotice that in general, the belief MDP could have a graph structure with cycles. Most online algorithms handle such a structure by unrolling the graph into a tree. Hence, if they reach a belief that is already elsewhere in the tree, it is duplicated. These algorithms could always be modified to handle generic graph structures by using a technique proposed in the LAO* algorithm (Hansen & Zilberstein, 2001) to handle cycles. However there are some advantages and disadvantages to doing this. A more in-depth discussion of this issue is presented in Section 5.4.\nA generic online algorithm implementing the planning phase (lines 5-9) and the execution phase (lines 10-13) is presented in Algorithm 3.1. The algorithm first initializes the tree to contain only the initial belief state (line 2). Then given the current tree, the planning phase of the algorithm proceeds by first selecting the next fringe node (line 6) under which it should pursue the search (construction of the tree). The Expand function (line 7) constructs the\n1: Function OnlinePOMDPSolver() Static: bc: The current belief state of the agent.\nT : An AND-OR tree representing the current search tree. D: Expansion depth. L: A lower bound on V \u2217. U : An upper bound on V \u2217.\n2: bc \u2190 b0 3: Initialize T to contain only bc at the root 4: while not ExecutionTerminated() do 5: while not PlanningTerminated() do 6: b\u2217 \u2190 ChooseNextNodeToExpand() 7: Expand(b\u2217, D) 8: UpdateAncestors(b\u2217) 9: end while 10: Execute best action a\u0302 for bc 11: Perceive a new observation z 12: bc \u2190 \u03c4(bc, a\u0302, z) 13: Update tree T so that bc is the new root 14: end while\nAlgorithm 3.1: Generic Online Algorithm.\nnext reachable beliefs (using Equation 3) under the selected leaf for some pre-determined expansion depth D and evaluates the approximate value function for all newly created nodes. The new approximate value of the expanded node is propagated to its ancestors via the UpdateAncestors function (line 8). This planning phase is conducted until some terminating condition is met (e.g. no more planning time is available or an -optimal action is found).\nThe execution phase of the algorithm executes the best action a\u0302 found during planning (line 10) and gets a new observation from the environment (line 11). Next, the algorithm updates the current belief state and the search tree T according to the most recent action a\u0302 and observation z (lines 12-13). Some online approaches can reuse previous computations by keeping the subtree under the new belief and resuming the search from this subtree at the next time step. In such cases, the algorithm keeps all the nodes in the tree T under the new belief bc and deletes all other nodes from the tree. Then the algorithm loops back to the planning phase for the next time step, and so on until the task is terminated.\nAs a side note, an online planning algorithm can also be useful to improve the precision of an approximate value function computed offline. This is captured in Theorem 3.1.\nTheorem 3.1. (Puterman, 1994; Hauskrecht, 2000) Let V\u0302 be an approximate value function and = supb |V\n\u2217(b) \u2212 V\u0302 (b)|. Then the approximate value V\u0302 D(b) returned by a Dstep lookahead from belief b, using V\u0302 to estimate fringe node values, has error bounded by |V \u2217(b)\u2212 V\u0302 D(b)| \u2264 \u03b3D .\nWe notice that for \u03b3 \u2208 [0, 1), the error converges to 0 as the depthD of the search tends to \u221e. This indicates that an online algorithm can effectively improve the performance obtained by an approximate value function computed offline, and can find an action arbitrarily close to the optimal for the current belief. However, evaluating the tree of all reachable beliefs within depth D has a complexity in O((|A||Z|)D |S|2), which is exponential in D. This becomes quickly intractable for large D. Furthermore, the planning time available during the execution may be very short and exploring all beliefs up to depth D may be infeasible.\nHence this motivates the need for more efficient online algorithms that can guarantee similar or better error bounds.\nTo be more efficient, most of the online algorithms focus on limiting the number of reachable beliefs explored in the tree (or choose only the most relevant ones). These approaches generally differ only in how the subroutines ChooseNextNodeToExpand and Expand are implemented. We classify these approaches into three categories : Branch-and-Bound Pruning, Monte Carlo Sampling and Heuristic Search. We now present a survey of these approaches and discuss their strengths and drawbacks. A few other online algorithms do not proceed via tree search; these approaches are discussed in Section 3.5."}, {"heading": "3.2 Branch-and-Bound Pruning", "text": "Branch-and-Bound pruning is a general search technique used to prune nodes that are known to be suboptimal in the search tree, thus preventing the expansion of unnecessary lower nodes. To achieve this in the AND-OR tree, a lower bound and an upper bound are maintained on the value Q\u2217(b, a) of each action a, for every belief b in the tree. These bounds are computed by first evaluating the lower and upper bound for the fringe nodes of the tree. These bounds are then propagated to parent nodes according to the following equations:\nLT (b) = { L(b), if b \u2208 F(T ) maxa\u2208A LT (b, a), otherwise\n(19)\nLT (b, a) = RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)LT (\u03c4(b, a, z)), (20)\nUT (b) = { U(b), if b \u2208 F(T ) maxa\u2208A UT (b, a), otherwise\n(21)\nUT (b, a) = RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)UT (\u03c4(b, a, z)), (22)\nwhere F(T ) denotes the set of fringe nodes in tree T , UT (b) and LT (b) represent the upper and lower bounds on V \u2217(b) associated to belief state b in the tree T , UT (b, a) and LT (b, a) represent corresponding bounds onQ\u2217(b, a), and L(b) and U(b) are the bounds used at fringe nodes, typically computed offline. These equations are equivalent to Bellman\u2019s equation (Equation 8), however they use the lower and upper bounds of the children, instead of V \u2217. Several techniques presented in Section 2.2 can be used to quickly compute lower bounds (Blind policy) and upper bounds (MDP, QMDP, FIB) offline.\nGiven these bounds, the idea behind Branch-and-Bound pruning is relatively simple: if a given action a in a belief b has an upper bound UT (b, a) that is lower than another action a\u0303\u2019s lower bound LT (b, a\u0303), then we know that a\u0303 is guaranteed to have a value Q\n\u2217(b, a\u0303) \u2265 Q\u2217(b, a). Thus a is suboptimal in belief b. Hence that branch can be pruned and no belief reached by taking action a in b will be considered."}, {"heading": "3.2.1 RTBSS", "text": "The Real-Time Belief Space Search (RTBSS) algorithm uses a Branch-and-Bound approach to compute the best action to take in the current belief (Paquet et al., 2005, 2006). Starting\n1: Function Expand(b, d) Inputs: b: The belief node we want to expand.\nd: The depth of expansion under b. Static: T : An AND-OR tree representing the current search tree.\nL: A lower bound on V \u2217. U : An upper bound on V \u2217.\n2: if d = 0 then 3: LT (b)\u2190 L(b) 4: else 5: Sort actions {a1, a2, . . . , a|A|} such that U(b, ai) \u2265 U(b, aj) if i \u2264 j 6: i\u2190 1 7: LT (b)\u2190 \u2212\u221e 8: while i \u2264 |A| and U(b, ai) > LT (b) do 9: LT (b, ai)\u2190 RB(b, ai) + \u03b3 \u2211 z\u2208Z Pr(z|b, ai)Expand(\u03c4(b, ai, z), d\u2212 1)\n10: LT (b)\u2190 max{LT (b), LT (b, ai)} 11: i\u2190 i+ 1 12: end while 13: end if 14: return LT (b)\nAlgorithm 3.2: Expand subroutine of RTBSS.\nfrom the current belief, it expands the AND-OR tree in a depth-first search fashion, up to some pre-determined search depth D. The leaves of the tree are evaluated by using a lower bound computed offline, which is propagated upwards such that a lower bound is maintained for each node in the tree.\nTo limit the number of nodes explored, Branch-and-Bound pruning is used along the way to prune actions that are known to be suboptimal, thus excluding unnecessary nodes under these actions. To maximize pruning, RTBSS expands the actions in descending order of their upper bound (first action expanded is the one with highest upper bound). By expanding the actions in this order, one never expands an action that could have been pruned if actions had been expanded in a different order. Intuitively, if an action has a higher upper bound than the other actions, then it cannot be pruned by the other actions since their lower bound will never exceed their upper bound. Another advantage of expanding actions in descending order of their upper bound is that as soon as we find an action that can be pruned, then we also know that all remaining actions can be pruned, since their upper bounds are necessarily lower. The fact that RTBSS proceeds via a depth-first search also increases the number of actions that can be pruned since the bounds on expanded actions become more precise due to the search depth.\nIn terms of the framework in Algorithm 3.1, RTBSS requires the ChooseNextNodeToExpand subroutine to simply return the current belief bc. The UpdateAncestors function does not need to perform any operation since bc has no ancestor (root of the tree T ). The Expand subroutine proceeds via depth-first search up to a fixed depth D, using Branch-and-Bound pruning, as mentioned above. This subroutine is detailed in Algorithm 3.2. After this expansion is performed, PlanningTerminated evaluates to true and the best action found is executed. At the end of each time step, the tree T is simply reinitialized to contain the new current belief at the root node.\nThe efficiency of RTBSS depends largely on the precision of the lower and upper bounds computed offline. When the bounds are tight, more pruning will be possible, and the search will be more efficient. If the algorithm is unable to prune many actions, searching will\nbe limited to short horizons in order to meet real-time constraints. Another drawback of RTBSS is that it explores all observations equally. This is inefficient since the algorithm could explore parts of the tree that have a small probability of occurring and thus have a small effect on the value function. As a result, when the number of observations is large, the algorithm is limited to exploring over a short horizon.\nAs a final note, since RTBSS explores all reacheable beliefs within depth D (except some reached by suboptimal actions), then it can guarantee the same error bound as a D-step lookahead (see Theorem 3.1). Therefore, the online search directly improves the precision of the original (offline) value bounds by a factor \u03b3D. This aspect was confirmed empirically in different domains where the RTBSS authors combined their online search with bounds given by various offline algorithms. In some cases, their results showed a tremendous improvement of the policy given by the offline algorithm (Paquet et al., 2006)."}, {"heading": "3.3 Monte Carlo Sampling", "text": "As mentioned above, expanding the search tree fully over a large set of observations is infeasible except for shallow depths. In such cases, a better alternative may be to sample a subset of observations at each expansion and only consider beliefs reached by these sampled observations. This reduces the branching factor of the search and allows for deeper search within a set planning time. This is the strategy employed by Monte Carlo algorithms."}, {"heading": "3.3.1 McAllester and Singh", "text": "The approach presented by McAllester and Singh (1999) is an adaptation of the online MDP algorithm presented by Kearns, Mansour, and Ng (1999). It consists of a depth-limited search of the AND-OR tree up to a certain fixed horizon D where instead of exploring all observations at each action choice, C observations are sampled from a generative model. The probabilities Pr(z|b, a) are then approximated using the observed frequencies in the sample. The advantage of such an approach is that sampling an observation from the distribution Pr(z|b, a) can be achieved very efficiently in O(log |S|+ log |Z|), while computing the exact probabilities Pr(z|b, a) is in O(|S|2) for each observation z. Thus sampling can be useful to alleviate the complexity of computing Pr(z|b, a), at the expense of a less precise estimate. Nevertheless, a few samples is often sufficient to obtain a good estimate as the observations that have the most effect on Q\u2217(b, a) (i.e. those which occur with high probability) are more likely to be sampled. The authors also apply belief state factorization as in Boyen and Koller (1998) to simplify the belief state calculations.\nFor the implementation of this algorithm, the Expand subroutine expands the tree up to fixed depth D, using Monte Carlo sampling of observations, as mentioned above (see Algorithm 3.3). At the end of each time step, the tree T is reinitialized to contain only the new current belief at the root.\nKearns et al. (1999) derive bounds on the depth D and the number of samples C needed to obtain an -optimal policy with high probability and show that the number of samples required grows exponentially in the desired accuracy. In practice, the number of samples required is infeasible given realistic online time constraints. However, performance in terms of returns is usually good even with many fewer samples.\n1: Function Expand(b, d) Inputs: b: The belief node we want to expand.\nd: The depth of expansion under b. Static: T : An AND-OR tree representing the current search tree.\nC: The number of observations to sample.\n2: if d = 0 then 3: LT (b)\u2190 maxa\u2208A RB(b, a) 4: else 5: LT (b)\u2190 \u2212\u221e 6: for all a \u2208 A do 7: Sample Z = {z1, z2, . . . zC} from distribution Pr(z|b, a) 8: LT (b, a)\u2190 RB(b, a) + \u03b3 \u2211\nz\u2208Z|Nz(Z)>0 Nz(Z) C Expand(\u03c4\u0302(b, a, z), d\u2212 1)\n9: LT (b)\u2190 max{LT (b), LT (b, a)} 10: end for 11: end if 12: return LT (b)\nAlgorithm 3.3: Expand subroutine of McAllester and Singh\u2019s Algorithm.\nOne inconvenience of this method is that no action pruning can be done since Monte Carlo estimation is not guaranteed to correctly propagate the lower (and upper) bound property up the tree. In their article, the authors simply approximate the value of the fringe belief states by the immediate reward RB(b, a); this could be improved by using any good estimate of V \u2217 computed offline. Note also that this approach may be difficult to apply in domains where the number of actions |A| is large. Of course this may further impact performance."}, {"heading": "3.3.2 Rollout", "text": "Another similar online Monte Carlo approach is the Rollout algorithm (Bertsekas & Castanon, 1999). The algorithm requires an initial policy (possibly computed offline). At each time step, it estimates the future expected value of each action, assuming the initial policy is followed at future time steps, and executes the action with highest estimated value. These estimates are obtained by computing the average discounted return obtained over a set of M sampled trajectories of depth D. These trajectories are generated by first taking the action to be evaluated, and then following the initial policy in subsequent belief states, assuming the observations are sampled from a generative model. Since this approach only needs to consider different actions at the root belief node, the number of actions |A| only influences the branching factor at the first level of the tree. Consequently, it is generally more scalable than McAllester and Singh\u2019s approach. Bertsekas and Castanon (1999) also show that with enough sampling, the resulting policy is guaranteed to perform at least as well as the initial policy with high probability. However, it generally requires many sampled trajectories to provide substantial improvement over the initial policy. Furthermore, the initial policy has a significant impact on the performance of this approach. In particular, in some cases it might be impossible to improve the return of the initial policy by just changing the immediate action (e.g. if several steps need to be changed to reach a specific subgoal to which higher rewards are associated). In those cases, the Rollout policy will never improve over the initial policy.\n1: Function Expand(b, d) Inputs: b: The belief node we want to expand.\nd: The depth of expansion under b. Static: T : An AND-OR tree representing the current search tree.\n\u03a0: A set of initial policies. M : The number of trajectories of depth d to sample.\n2: LT (b)\u2190 \u2212\u221e 3: for all a \u2208 A do 4: for all \u03c0 \u2208 \u03a0 do 5: Q\u0302\u03c0(b, a)\u2190 0 6: for i = 1 to M do 7: b\u0303\u2190 b 8: a\u0303\u2190 a 9: for j = 0 to d do 10: Q\u0302\u03c0(b, a)\u2190 Q\u0302\u03c0(b, a) + 1\nM \u03b3jRB(b\u0303, a\u0303)\n11: z \u2190 SampleObservation(b\u0303, a\u0303) 12: b\u0303\u2190 \u03c4(b\u0303, a\u0303, z) 13: a\u0303\u2190 \u03c0(b\u0303) 14: end for 15: end for 16: end for 17: LT (b, a) = max\u03c0\u2208\u03a0 Q\u0302\u03c0(b, a) 18: end for\nAlgorithm 3.4: Expand subroutine of the Parallel Rollout Algorithm.\nTo address this issue relative to the initial policy, Chang, Givan, and Chong (2004) introduced a modified version of the algorithm, called Parallel Rollout. In this case, the algorithm starts with a set of initial policies. Then the algorithm proceeds as Rollout for each of the initial policies in the set. The value considered for the immediate action is the maximum over that set of initial policies, and the action with highest value is executed. In this algorithm, the policy obtained is guaranteed to perform at least as well as the best initial policy with high probability, given enough samples. Parallel Rollout can handle domains with a large number of actions and observations, and will perform well when the set of initial policies contain policies that are good in different regions of the belief space.\nThe Expand subroutine of the Parallel Rollout algorithm is presented in Algorithm 3.4. The original Rollout algorithm by Bertsekas and Castanon (1999) is the same algorithm in the special case where the set of initial policies \u03a0 contains only one policy. The other subroutines proceed as in McAllester and Singh\u2019s algorithm."}, {"heading": "3.4 Heuristic Search", "text": "Instead of using Branch-and-Bound pruning or Monte Carlo sampling to reduce the branching factor of the search, heuristic search algorithms try to focus the search on the most relevant reachable beliefs by using heuristics to select the best fringe beliefs node to expand. The most relevant reachable beliefs are the ones that would allow the search algorithm to make good decisions as quickly as possible, i.e. by expanding as few nodes as possible.\nThere are three different online heuristic search algorithms for POMDPs that have been proposed in the past: Satia and Lave (1973), BI-POMDP (Washington, 1997) and AEMS (Ross & Chaib-draa, 2007). These algorithms all maintain both lower and upper bounds on the value of each node in the tree (using Equations 19 - 22) and only differ in the specific heuristic used to choose the next fringe node to expand in the AND/OR tree. We\nfirst present the common subroutines for these algorithms, and then discuss their different heuristics.\nRecalling the general framework of Algorithm 3.1, three steps are interleaved several times in heuristic search algorithms. First, the best fringe node to expand (according to the heuristic) in the current search tree T is found. Then the tree is expanded under this node (usually for only one level). Finally, ancestor nodes\u2019 values are updated; their values must be updated before we choose the next node to expand, since the heuristic value usually depends on them. In general, heuristic search algorithms are slightly more computationally expensive than standard depth- or breadth-first search algorithms, due to the extra computations needed to select the best fringe node to expand, and the need to update ancestors at each iteration. This was not required by the previous methods using Branch-and-Bound pruning and/or Monte Carlo sampling. If the complexity of these extra steps is too high, then the benefit of expanding only the most relevant nodes might be outweighed by the lower number of nodes expanded (assuming a fixed planning time).\nIn heuristic search algorithms, a particular heuristic value is associated with every fringe node in the tree. This value should indicate how important it is to expand this node in order to improve the current solution. At each iteration of the algorithm, the goal is to find the fringe node that maximizes this heuristic value among all fringe nodes. This can be achieved efficiently by storing in each node of the tree a reference to the best fringe node to expand within its subtree, as well as its associated heuristic value. In particular, the root node always contains a reference to the best fringe node for the whole tree. When a node is expanded, its ancestors are the only nodes in the tree where the best fringe node reference, and corresponding heuristic value, need to be updated. These can be updated efficiently by using the references and heuristic values stored in the lower nodes via a dynamic programming algorithm, described formally in Equations 23 and 24. Here H\u2217T (b) denotes the highest heuristic value among the fringe nodes in the subtree of b, b\u2217T (b) is a reference to this fringe node, HT (b) is the basic heuristic value associated to fringe node b, and HT (b, a) and HT (b, a, z) are factors that weigh this basic heuristic value at each level of the tree T . For example, HT (b, a, z) could be Pr(z|b, a) in order to give higher weight to (and hence favor) fringe nodes that are reached by the most likely observations.\nH\u2217T (b) = { HT (b) if b \u2208 F(T ) maxa\u2208AHT (b, a)H \u2217 T (b, a) otherwise\nH\u2217T (b, a) = maxz\u2208Z HT (b, a, z)H \u2217 T (\u03c4(b, a, z))\n(23)\nb\u2217T (b) = { b if b \u2208 F(T ) b\u2217T (b, a T b ) otherwise\nb\u2217T (b, a) = b \u2217 T (\u03c4(b, a, z T b,a))\naTb = argmaxa\u2208A HT (b, a)H \u2217 T (b, a)\nzTb,a = argmaxz\u2208Z HT (b, a, z)H \u2217 T (\u03c4(b, a, z))\n(24)\nThis procedure finds the fringe node b \u2208 F(T ) that maximizes the overall heuristic value HT (bc, b) = HT (b) \u220fdT (b) i=1 HT (bi, ai)HT (bi, ai, zi), where bi, ai and zi represent the i th belief, action and observation on the path from bc to b in T , and dT (b) is the depth of fringe node b. Note that H\u2217T and b \u2217 T are only updated in the ancestor nodes of the last expanded node. By reusing previously computed values for the other nodes, we have a procedure\n1: Function Expand(b) Inputs: b: An OR-Node we want to expand. Static: bc: The current belief state of the agent.\nT : An AND-OR tree representing the current search tree. L: A lower bound on V \u2217. U : An upper bound on V \u2217.\n2: for each a \u2208 A do 3: for each z \u2208 Z do 4: b\u2032 \u2190 \u03c4(b, a, z) 5: UT (b\u2032)\u2190 U(b\u2032) 6: LT (b\u2032)\u2190 L(b\u2032) 7: H\u2217T (b \u2032)\u2190 HT (b \u2032) 8: b\u2217T (b \u2032)\u2190 b\u2032\n9: end for 10: LT (b, a)\u2190 RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)LT (\u03c4(b, a, z))\n11: UT (b, a)\u2190 RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)UT (\u03c4(b, a, z)) 12: zT b,a \u2190 argmaxz\u2208Z HT (b, a, z)H \u2217 T (\u03c4(b, a, z)) 13: H\u2217T (b, a) = HT (b, a, z T b,a )H\u2217T (\u03c4(b, a, z T b,a )) 14: b\u2217 T (b, a)\u2190 b\u2217 T (\u03c4(b, a, zT b,a )) 15: end for 16: LT (b)\u2190 max{maxa\u2208A LT (b, a), LT (b)} 17: UT (b)\u2190 min{maxa\u2208A UT (b, a), UT (b)} 18: aT\nb \u2190 argmaxa\u2208A HT (b, a)H \u2217 T (b, a)"}, {"heading": "19: H\u2217", "text": "T (b)\u2190 HT (b, a T b )H\u2217 T (b, aT b ) 20: b\u2217 T (b)\u2190 b\u2217 T (b, aT b )\nAlgorithm 3.5: Expand : Expand subroutine for heuristic search algorithms.\nthat can find the best fringe node to expand in the tree in time linear in the depth of the tree (versus exponential in the depth of the tree for the exhaustive search through all fringe nodes). These updates are performed in both the Expand and the UpdateAncestors subroutines, each of which is described in more detail below. After each iteration, the ChooseNextNodeToExpand subroutine simply returns the reference to this best fringe node stored in the root of the tree, i.e. b\u2217T (bc).\nThe Expand subroutine used by heuristic search methods is presented in Algorithm 3.5. It performs a one-step lookahead under the fringe node b. The main difference with respect to previous methods in Sections 3.2 and 3.3 is that the heuristic value and best fringe node to expand for these new nodes are computed at lines 7-8 and 12-14. The best leaf node in b\u2019s subtree and its heuristic value are then computed according to Equations 23 and 24 (lines 18-20).\nThe UpdateAncestors function is presented in Algorithm 3.6. The goal of this function is to update the bounds of the ancestor nodes, and find the best fringe node to expand next. Starting from a given OR-Node b\u2032, the function simply updates recursively the ancestor nodes of b\u2032 in a bottom-up fashion, using Equations 19-22 to update the bounds and Equations 23-24 to update the reference to the best fringe to expand and its heuristic value. Notice that the UpdateAncestors function can reuse information already stored in the node objects, such that it does not need to recompute \u03c4(b, a, z), Pr(z|b, a) and RB(b, a). However it may need to recompute HT (b, a, z) and HT (b, a) according to the new bounds, depending on how the heuristic is defined.\nDue to the anytime nature of these heuristic search algorithms, the search usually keeps going until an -optimal action is found for the current belief bc, or the available planning\n1: Function UpdateAncestors(b\u2032) Inputs: b\u2032: An OR-Node for which we want to update all its ancestors. Static: bc: The current belief state of the agent.\nT : An AND-OR tree representing the current search tree. L: A lower bound on V \u2217. U : An upper bound on V \u2217.\n2: while b\u2032 6= bc do 3: Set (b, a) so that action a in belief b is parent node of belief node b\u2032 4: LT (b, a)\u2190 RB(b, a) + \u03b3 \u2211\nz\u2208Z Pr(z|b, a)LT (\u03c4(b, a, z)) 5: UT (b, a)\u2190 RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)UT (\u03c4(b, a, z)) 6: zT b,a \u2190 argmaxz\u2208Z HT (b, a, z)H \u2217 T (\u03c4(b, a, z)) 7: H\u2217 T (b, a)\u2190 HT (b, a, z T b,a )H\u2217 T (\u03c4(b, a, zT b,a )) 8: b\u2217 T (b, a)\u2190 b\u2217 T (\u03c4(b, a, zT b,a ))\n9: LT (b)\u2190 maxa\u2032\u2208A LT (b, a\u2032) 10: UT (b)\u2190 maxa\u2032\u2208A UT (b, a\u2032) 11: aT\nb \u2190 argmaxa\u2032\u2208A HT (b, a \u2032)H\u2217 T (b, a\u2032)\n12: H\u2217T (b)\u2190 HT (b, a T b )H\u2217T (b, a T b ) 13: b\u2217T (b)\u2190 b \u2217 T (b, a T b ) 14: b\u2032 \u2190 b 15: end while\nAlgorithm 3.6: UpdateAncestors : Updates the bounds of the ancestors of all ancestors of an OR-Node\ntime is elapsed. An -optimal action is found whenever UT (bc) \u2212 LT (bc) \u2264 or LT (bc) \u2265 UT (bc, a\n\u2032),\u2200a\u2032 6= argmaxa\u2208A LT (bc, a) (i.e. all other actions are pruned, in which case the optimal action has been found).\nNow that we have covered the basic subroutines, we present the different heuristics proposed by Satia and Lave (1973), Washington (1997) and Ross and Chaib-draa (2007). We begin by introducing some useful notation.\nGiven any graph structure G, let us denote F(G) the set of all fringe nodes in G and HG(b, b\n\u2032) the set of all sequences of actions and observations that lead to belief node b\u2032 from belief node b in the search graph G. If we have a tree T , then HT (b, b \u2032) will contain at most a single sequence which we will denote hb,b \u2032\nT . Now given a sequence h \u2208 HG(b, b \u2032), we define\nPr(hz |b, ha) the probability that we observe the whole sequence of observations hz in h, given that we start in belief node b and perform the whole sequence of actions ha in h. Finally, we define Pr(h|b, \u03c0) to be the probability that we follow the entire action/observation sequence h if we start in belief b and behave according to policy \u03c0. Formally, these probabilities are computed as follows:\nPr(hz|b, ha) =\nd(h)\u220f\ni=1\nPr(hiz |b hi\u22121 , hia), (25)\nPr(h|b, \u03c0) =\nd(h)\u220f\ni=1\nPr(hiz |b hi\u22121 , hia)\u03c0(b hi\u22121 , hia), (26)\nwhere d(h) represents the depth of h (number of actions in the sequence h), hia denotes the ith action in sequence h, hiz the i\nth observation in the sequence h, and bhi the belief state obtained by taking the first i actions and observations of the sequence h from b. Note that bh0 = b."}, {"heading": "3.4.1 Satia and Lave", "text": "The approach of Satia and Lave (1973) follows the heuristic search framework presented above. The main feature of this approach is to explore, at each iteration, the fringe node b in the current search tree T that maximizes the following term:\nHT (bc, b) = \u03b3 d(hbc,b T ) Pr(hbc,bT,z |bc, h bc,b T,a )(UT (b)\u2212 LT (b)), (27)\nwhere b \u2208 F(T ) and bc is the root node of T . The intuition behind this heuristic is simple: recalling the definition of V \u2217, we note that the weight of the value V \u2217(b) of a fringe node b on V \u2217(bc) would be exactly \u03b3 d(hbc,b T ) Pr(hbc,bT,z |bc, h bc,b T,a ), provided h bc,b T,a is a sequence of optimal actions. The fringe nodes where this weight is high have the most effect on the estimate of V \u2217(bc). Hence one should try to minimize the error at these nodes first. The term UT (b)\u2212LT (b) is included since it is an upper bound on the (unknown) error V\n\u2217(b)\u2212LT (b). Thus this heuristic focuses the search in areas of the tree that most affect the value V \u2217(bc) and where the error is possibly large. This approach also uses Branch-and-Bound pruning, such that a fringe node reached by an action that is dominated in some parent belief b is never going to be expanded. Using the same notation as in Algorithms 3.5 and 3.6, this heuristic can be implemented by defining HT (b), HT (b, a) and HT (b, a, z), as follows:\nHT (b) = UT (b)\u2212 LT (b),\nHT (b, a) = { 1 if UT (b, a) > LT (b), 0 otherwise,\nHT (b, a, z) = \u03b3 Pr(z|b, a),\n(28)\nThe condition UT (b, a) > LT (b) ensures that the global heuristic value HT (bc, b \u2032) = 0 if some action in the sequence hbc,b \u2032\nT,a is dominated (pruned). This guarantees that such fringe nodes will never be expanded.\nSatia and Lave\u2019s heuristic focuses the search towards beliefs that are most likely to be reached in the future, and where the error is large. This heuristic is likely to be efficient in domains with a large number of observations, but only if the probability distribution over observations is concentrated over only a few observations. The term UT (b) \u2212 LT (b) in the heuristic also prevents the search from doing unnecessary computations in areas of the tree where it already has a good estimate of the value function. This term is most efficient when the bounds computed offline, U and L, are sufficiently informative. Similarly, node pruning is only going to be efficient if U and L are sufficiently tight, otherwise few actions will be pruned."}, {"heading": "3.4.2 BI-POMDP", "text": "Washington (1997) proposed a slightly different approach inspired by the AO\u2217 algorithm (Nilsson, 1980), where the search is only conducted in the best solution graph. In the case of online POMDPs, this corresponds to the subtree of all belief nodes that are reached by sequences of actions maximizing the upper bound in their parent beliefs.\nThe set of fringe nodes in the best solution graph of G, which we denote F\u0302(G), can be defined formally as F\u0302(G) = {b \u2208 F(G)|\u2203h \u2208 HG(bc, b),Pr(h|b, \u03c0\u0302G) > 0}, where \u03c0\u0302G(b, a) = 1 if a = argmaxa\u2032\u2208A UG(b, a \u2032) and \u03c0\u0302G(b, a) = 0 otherwise. The AO \u2217 algorithm simply specifies\nexpanding any of these fringe nodes. Washington (1997) recommends exploring the fringe node in F\u0302(G) (where G is the current acyclic search graph) that maximizes UG(b)\u2212LG(b). Washington\u2019s heuristic can be implemented by defining HT (b), HT (b, a) and HT (b, a, z), as follows:\nHT (b) = UT (b)\u2212 LT (b),\nHT (b, a) =\n{ 1 if a = argmaxa\u2032\u2208A UT (b, a\n\u2032), 0 otherwise,\nHT (b, a, z) = 1.\n(29)\nThis heuristic tries to guide the search towards nodes that are reachable by \u201cpromising\u201d actions, especially when they have loose bounds on their values (possibly large error). One nice property of this approach is that expanding fringe nodes in the best solution graph is the only way to reduce the upper bound at the root node bc. This was not the case for Satia and Lave\u2019s heuristic. However, Washington\u2019s heuristic does not take into account the probability Pr(hz |b, ha), nor the discount factor \u03b3\nd(h), such that it may end up exploring nodes that have a very small probability of being reached in the future, and thus have little effect on the value of V \u2217(bc). Hence, it may not explore the most relevant nodes for optimizing the decision at bc. This heuristic is appropriate when the upper bound U computed offline is sufficiently informative, such that actions with highest upper bound would also usually tend to have highest Q-value. In such cases, the algorithm will focus its search on these actions and thus should find the optimal action more quickly then if it explored all actions equally. On the other hand, because it does not consider the observation probabilities, this approach may not scale well to large observation sets, as it will not be able to focus its search towards the most relevant observations."}, {"heading": "3.4.3 AEMS", "text": "Ross and Chaib-draa (2007) introduced a heuristic that combines the advantages of BIPOMDP, and Satia and Lave\u2019s heuristic. It is based on a theoretical error analysis of tree search in POMDPs, presented by Ross et al. (2008).\nThe core idea is to expand the tree such as to reduce the error on V \u2217(bc) as quickly as possible. This is achieved by expanding the fringe node b that contributes the most to the error on V \u2217(bc). The exact error contribution eT (bc, b) of fringe node b on bc in tree T is defined by the following equation:\neT (bc, b) = \u03b3 d(hbc,b T )Pr(hbc,bT |bc, \u03c0 \u2217)(V \u2217(b)\u2212 LT (b)). (30)\nThis expression requires \u03c0\u2217 and V \u2217 to be computed exactly. In practice, Ross and Chaibdraa (2007) suggest approximating the exact error (V \u2217(b) \u2212 LT (b)) by (UT (b) \u2212 LT (b)), as was done by Satia and Lave, and Washington. They also suggest approximating \u03c0\u2217 by some policy \u03c0\u0302T , where \u03c0\u0302T (b, a) represents the probability that action a is optimal in its parent belief b, given its lower and upper bounds in tree T . In particular, Ross et al. (2008) considered two possible approximations for \u03c0\u2217. The first one is based on a uniformity assumption on the distribution of Q-values between the lower and upper bounds, which yields:\n\u03c0\u0302T (b, a) =\n{ \u03b7 (UT (b,a)\u2212LT (b)) 2\nUT (b,a)\u2212LT (b,a) if UT (b, a) > LT (b),\n0 otherwise, (31)\nwhere \u03b7 is a normalization constant such that the sum of the probabilities \u03c0\u0302T (b, a) over all actions equals 1.\nThe second is inspired by AO\u2217 and BI-POMDP, and assumes that the action maximizing the upper bound is in fact the optimal action:\n\u03c0\u0302T (b, a) =\n{ 1 if a = argmaxa\u2032\u2208A UT (b, a\n\u2032), 0 otherwise.\n(32)\nGiven the approximation \u03c0\u0302T of \u03c0 \u2217, the AEMS heuristic will explore the fringe node b\nthat maximizes:\nHT (bc, b) = \u03b3 d(hbc,b T ) Pr(hbc,bT |bc, \u03c0\u0302T )(UT (b)\u2212 LT (b)). (33)\nThis can be implemented by defining HT (b), HT (b, a) and HT (b, a, z) as follows:\nHT (b) = UT (b)\u2212 LT (b), HT (b, a) = \u03c0\u0302T (b, a),\nHT (b, a, z) = \u03b3 Pr(z|b, a). (34)\nWe refer to this heuristic as AEMS1 when \u03c0\u0302T is defined as in Equation 31, and AEMS2 when it is defined as in Equation 32.2\nLet us now examine how AEMS combines the advantages of both the Satia and Lave, and BI-POMDP heuristics. First, AEMS encourages exploration of nodes with loose bounds and possibly large error by considering the term UT (b) \u2212 LT (b) as in previous heuristics. Moreover, as in Satia and Lave, it focuses the exploration towards belief states that are likely to be encountered in the future. This is good for two reasons. As mentioned before, if a belief state has a low probability of occurrence in the future, it has a limited effect on the value V \u2217(bc) and thus it is not necessary to know its value precisely. Second, exploring the highly probable belief states increases the chance that we will be able to reuse these computations in the future. Hence, AEMS should be able to deal efficiently with large observation sets, assuming the distribution over observations is concentrated over a few observations. Finally, as in BI-POMDP, AEMS favors the exploration of fringe nodes reachable by actions that seem more likely to be optimal (according to \u03c0\u0302T ). This is useful to handle large action sets, as it focuses the search on actions that look promising. If these \u201cpromising\u201d actions are not optimal, then this will quickly become apparent. This will work well if the best actions have the highest probabilities in \u03c0\u0302T . Furthermore, it is possible to define \u03c0\u0302T such that it automatically prunes dominated actions by ensuring that \u03c0\u0302T (b, a) = 0 whenever UT (b, a) < LT (b). In such cases, the heuristic will never choose to expand a fringe node reached by a dominated action.\nAs a final note, Ross et al. (2008) determined sufficient conditions under which the search algorithm using this heuristic is guaranteed to find an -optimal action within finite time. This is stated in Theorem 3.2.\n2. The AEMS2 heuristic was also used for a policy search algorithm by Hansen (1998).\nTheorem 3.2. (Ross et al., 2008) Let > 0 and bc the current belief. If for any tree T and parent belief b in T where UT (b) \u2212 LT (b) > , \u03c0\u0302T (b, a) > 0 for a = argmaxa\u2032\u2208A UT (b, a\n\u2032), then the AEMS algorithm is guaranteed to find an -optimal action for bc within finite time.\nWe observe from this theorem that it is possible to define many different policies \u03c0\u0302T under which the AEMS heuristic is guaranteed to converge. AEMS1 and AEMS2 both satisfy this condition."}, {"heading": "3.4.4 HSVI", "text": "A heuristic similar to AEMS2 was also used by Smith and Simmons (2004) for their offline value iteration algorithm HSVI as a way to pick the next belief point at which to perform \u03b1-vector backups. The main difference is that HSVI proceeds via a greedy search that descends the tree from the root node b0, going down towards the action that maximizes the upper bound and then the observation that maximizes Pr(z|b, a)(U(\u03c4(b, a, z))\u2212L(\u03c4(b, a, z))) at each level, until it reaches a belief b at depth d where \u03b3\u2212d(U(b) \u2212 L(b)) < . This heuristic could be used in an online heuristic search algorithm by instead stopping the greedy search process when it reaches a fringe node of the tree and then selecting this node as the one to be expanded next. In such a setting, HSVI\u2019s heuristic would return a greedy approximation of the AEMS2 heuristic, as it may not find the fringe node which actually maximizes \u03b3d(h bc,b T\n) Pr(hbc,bT |bc, \u03c0\u0302T )(UT (b) \u2212 LT (b)). We consider this online version of the HSVI heuristic in our empirical study (Section 4). We refer to this extension as HSVI-BFS. Note that the complexity of this greedy search is the same as finding the best fringe node via the dynamic programming process that updates H\u2217T and b \u2217 T in the UpdateAncestors subroutine."}, {"heading": "3.5 Alternatives to Tree Search", "text": "We now present two alternative online approaches that do not proceed via a lookahead search in the belief MDP. In all online approaches presented so far, one problem is that no learning is achieved over time, i.e. everytime the agent encounters the same belief, it has to recompute its policy starting from the same initial upper and lower bounds computed offline. The two online approaches presented next address this problem by presenting alternative ways of updating the initial value functions computed offline so that the performance of the agent improves over time as it stores updated values computed at each time step. However, as is argued below and in the discussion (Section 5.2), these techniques lead to other disadvantages in terms of memory consumption and/or time complexity."}, {"heading": "3.5.1 RTDP-BEL", "text": "An alternative approach to searching in AND-OR graphs is the RTDP algorithm (Barto et al., 1995) which has been adapted to solve POMDPs by Geffner and Bonet (1998). Their algorithm, called RTDP-BEL, learns approximate values for the belief states visited by successive trials in the environment. At each belief state visited, the agent evaluates all possible actions by estimating the expected reward of taking action a in the current belief\n1: Function OnlinePOMDPSolver() Static: bc: The current belief state of the agent.\nV0: Initial approximate value function (computed offline). V : A hashtable of beliefs and their approximate value. k: Discretization resolution.\n2: Initialize bc to the initial belief state and V to an empty hashtable. 3: while not ExecutionTerminated() do 4: For all a \u2208 A: Evaluate Q(bc, a) = RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)V (Discretize(\u03c4(b, a, z), k))\n5: a\u0302\u2190 argmaxa\u2208A Q(bc, a) 6: Execute best action a\u0302 for bc 7: V (Discretize(bc, k))\u2190 Q(bc, a\u0302) 8: Perceive a new observation z 9: bc \u2190 \u03c4(bc, a\u0302, z) 10: end while\nAlgorithm 3.7: RTDP-Bel Algorithm.\nstate b with an approximate Q-value equation:\nQ(b, a) = RB(b, a) + \u03b3 \u2211\nz\u2208Z\nPr(z|b, a)V (\u03c4(b, a, z)), (35)\nwhere V (b) is the value learned for the belief b. If the belief state b has no value in the table, then it is initialized to some heuristic value. The authors suggest using the MDP approximation for the initial value of each belief state. The agent then executes the action that returned the greatest Q(b, a) value. Afterwards, the value V (b) in the table is updated with the Q(b, a) value of the best action. Finally, the agent executes the chosen action and it makes the new observation, ending up in a new belief state. This process is then repeated again in this new belief.\nThe RTDP-BEL algorithm learns a heuristic value for each belief state visited. To maintain an estimated value for each belief state in memory, it needs to discretize the belief state space to have a finite number of belief states. This also allows generalization of the value function to unseen belief states. However, it might be difficult to find the best discretization for a given problem. In practice, this algorithm needs substantial amounts of memory (greater than 1GB in some cases) to store all the learned belief state values, especially in POMDPs with large state spaces. The implementation of the RTDP-Bel algorithm is presented in Algorithm 3.7.\nThe function Discretize(b, k) returns a discretized belief b\u2032 where b\u2032(s) = round(kb(s))/k for all states s \u2208 S, and V (b) looks up the value of belief b in a hashtable. If b is not present in the hashtable, the value V0(b) is returned by V . Supported by experimental data, Geffner and Bonet (1998) suggest choosing k \u2208 [10, 100], as it usually produces the best results. Notice that for a discretization resolution of k there are O((k + 1)|S|) possible discretized beliefs. This implies that the memory storage required to maintain V is exponential in |S|, which becomes quickly intractable, even for mid-size problems. Furthermore, learning good estimates for this exponentially large number of beliefs usually requires a very large number of trials, which might be infeasible in practice. This technique can sometimes be applied in large domains when a factorized representation is available. In such cases, the belief can be maintained as a set of distributions (one for subset of conditionaly independent state variables) and the discretization applied seperately to each distribution. This can greatly reduce the possible number of discretized beliefs."}, {"heading": "3.5.2 SOVI", "text": "A more recent online approach, called SOVI (Shani et al., 2005), extends HSVI (Smith & Simmons, 2004, 2005) into an online value iteration algorithm. This approach maintains a priority queue of the belief states encountered during the execution and proceeds by doing \u03b1-vector updates for the current belief state and the k belief states with highest priority at each time step. The priority of a belief state is computed according to how much the value function changed at successor belief states, since the last time it was updated. Its authors also propose other improvements to the HSVI algorithm to improve scalability, such as a more efficient \u03b1-vector pruning technique, and avoiding to use linear programs to update and evaluate the upper bound. The main drawback of this approach is that it is hardly applicable in large environments with short real-time constraints, since it needs to perform a value iteration update with \u03b1-vectors online, and this can have very high complexity as the number of \u03b1-vectors representing the value function increases (i.e. O(k|S||A||Z|(|S| + |\u0393t\u22121|)) to compute \u0393t)."}, {"heading": "3.6 Summary of Online POMDP Algorithms", "text": "In summary, we see that most online POMDP approaches are based on lookahead search. To improve scalability, different techniques are used: branch-and-bound pruning, search heuristics, and Monte Carlo sampling. These techniques reduce the complexity from different angles. Branch-and-bound pruning lowers the complexity related to the action space size. Monte Carlo sampling has been used to lower the complexity related to the observation space size, and could also potentially be used to reduce the complexity related to the action space size (by sampling a subset of actions). Search heuristics lower the complexity related to actions and observations by orienting the search towards the most relevant actions and observations. When appropriate, factored POMDP representations can be used to reduce the complexity related to state. A summary of the different properties of each online algorithm is presented in Table 1."}, {"heading": "4. Empirical Study", "text": "In this section, we compare several online approaches in two domains found in the POMDP literature: Tag (Pineau et al., 2003) and RockSample (Smith & Simmons, 2004). We consider a modified version of RockSample, called FieldVisionRockSample (Ross & Chaib-draa, 2007), that has a higher observation space than the original RockSample. This environment is introduced as a means to test and compare the different algorithms in environments with large observation spaces."}, {"heading": "4.1 Methodology", "text": "For each environment, we first compare the real-time performance of the different heuristics presented in Section 3.4 by limiting their planning time to 1 second per action. All heuristics were given the same lower and upper bounds such that their results would be comparable. The objective here is to evaluate which search heuristic is most efficient in different types of environments. To this end, we have implemented the different search heuristics (Satia and Lave, BI-POMDP, HSVI-BFS and AEMS) into the same best-first search algorithm, such that we can directly measure the efficiency of the heuristic itself. Results were also obtained for different lower bounds (Blind and PBVI) to verify how this choice affects the heuristic\u2019s efficiency. Finally, we compare how online and offline times affect the performance of each approach. Except where stated otherwise, all experiments were run on an Intel Xeon 2.4 Ghz with 4GB of RAM; processes were limited to 1GB of RAM."}, {"heading": "4.1.1 Metrics to compare online approaches", "text": "We compare performance first and foremost in terms of average discounted return at execution time. However, what we really seek with online approaches is to guarantee better solution quality than that provided by the original bounds. In other words, we seek to reduce the error of the original bounds as much as possible. This suggests that a good metric for the efficiency of online algorithms is to compare the improvement in terms of the error bounds at the current belief before and after the online search. Hence, we define the error bound reduction percentage to be:\nEBR(b) = 1\u2212 UT (b)\u2212 LT (b)\nU(b)\u2212 L(b) , (36)\nwhere UT (b), LT (b), U(b) and L(b) are defined as in Section 3.2. The best online algorithm should provide the highest error bound reduction percentage, given the same initial bounds and real-time constraint.\nBecause the EBR metric does not necessarily reflect true error reduction, we also compare the return guarantees provided by each algorithm, i.e. the lower bounds on the expected return provided by the computed policies for the current belief. Because improvement of the lower bound compared to the initial lower bound computed offline is a direct indicator of true error reduction, the best online algorithm should provide the greatest lower bound improvement at the current belief, given the same initial bounds and real-time constraint. Formally, we define the lower bound improvement to be:\nLBI(b) = LT (b)\u2212 L(b). (37)\nIn our experiments, both the EBR and LBI metrics are evaluated at each time step for the current belief. We are interested in seeing which approach provides the highest EBR and LBI on average.\nWe also consider other metrics pertaining to complexity and efficiency. In particular, we report the average number of belief nodes maintained in the search tree. Methods that have lower complexity will generally be able to maintain bigger trees, but the results will show that this does not always relate to higher error bound reduction and returns. We will also measure the efficiency of reusing part of the search tree by recording the percentage of belief nodes that were reused from one time step to the next.\n4.2 Tag\nTag was initially introduced by Pineau et al. (2003). This environment has also been used more recently in the work of several authors (Poupart & Boutilier, 2003; Vlassis & Spaan, 2004; Pineau, 2004; Spaan & Vlassis, 2004; Smith & Simmons, 2004; Braziunas & Boutilier, 2004; Spaan & Vlassis, 2005; Smith & Simmons, 2005). For this environment, an approximate POMDP algorithm is necessary because of its large size (870 states, 5 actions and 30 observations). The Tag environment consists of an agent that has to catch (Tag) another agent while moving in a 29-cell grid domain. The reader is referred to the work of Pineau et al. (2003) for a full description of the domain. Note that for all results presented below, the belief state is represented in factored form. The domain is such that an exact factorization is possible.\nTo obtain results in Tag, we run each algorithm in each starting configuration 5 times, ( i.e. 5 runs for each of the 841 different starting joint positions, excluding the 29 terminal states ). The initial belief state is the same for all runs and consists of a uniform distribution over the possible joint agent positions.\nTable 2 compares the different heuristics by presenting 95% confidence intervals on the average discounted return per run (Return), average error bound reduction percentage per time step (EBR), average lower bound improvement per time step (LBI), average belief nodes in the search tree per time step (Belief Nodes), the average percentage of belief nodes reused per time step (Nodes Reused), the average online planning time used per time step (Online Time). In all cases, we use the FIB upper bound and the Blind lower bound. Note that the average online time is slightly lower than 1 second per step because algorithms sometimes find -optimal solutions in less than a second.\nWe observe that the efficiency of HSVI-BFS, BI-POMDP and AEMS2 differs slightly in this environment and that they outperform the three other heuristics: RTBSS, Satia and Lave, and AEMS1. The difference can be explained by the fact that the latter three methods do not restrict the search to the best solution graph. As a consequence, they explore many irrelevant nodes, as shown by the lower error bound reduction percentage, lower bound improvement, and nodes reused. This poor reuse percentage explains why Satia and Lave, and AEMS1 were limited to a lower number of belief nodes in their search tree, compared to the other methods which reached averages around 70K. The results of the three other heuristics do not differ much here because the three heuristics only differ in the way they choose the observations to explore in the search. Since only two observations are possible after the first action and observation, and one of these observations leads directly\nto a terminal belief state, the possibility that the heuristics differed significantly was very limited. Due to this limitation of the Tag domain, we now compare these online algorithms in a larger and more complex domain: RockSample.\n4.3 RockSample\nThe RockSample problem was originally presented by Smith and Simmons (2004). In this domain, an agent has to explore the environment and sample some rocks (see Figure 3), similarly to what a real robot would do on the planet Mars. The agent receives rewards by sampling rocks and by leaving the environment (at the extreme right of the environment). A rock can have a scientific value or not, and the agent has to sample only good rocks.\nWe define RockSample[n, k] as an instance of the RockSample problem with an n \u00d7 n grid and k rocks. A state is characterized by k+1 variables: XP , which defines the position of the robot and can take values {(1, 1), (1, 2), . . . , (n, n)} and k variables, XR1 through X R k , representing each rock, which can take values {Good,Bad}.\nThe agent can perform k+ 5 actions: {North, South,East,West, Sample,Check1, . . . , Checkk}. The four motion actions are deterministic. The Sample action samples the rock at the agent\u2019s current location. Each Checki action returns a noisy observation from {Good,Bad} for rock i.\nThe belief state is represented in factored form by the known position and a set of k probabilities, namely the probability of each rock being good. Since the observation of a rock\nstate is independent of the other rock states (it only depends on the known robot position), the complexity of computing Pr(z|b, a) and \u03c4(b, a, z) is greatly reduced. Effectively, the computation of Pr(z|b, Checki) reduces to: Pr(z|b, Checki) = Pr(Accurate|XP , Checki) \u00b7 Pr(XRi = z) + (1 \u2212 Pr(Accurate|XP , Checki)) \u00b7 (1 \u2212 Pr(X R i = z)). The probability that the sensor is accurate on rock i, Pr(Accurate|XP , Checki) = 1+\u03b7(Xp,i)\n2 , where \u03b7(Xp, i) =\n2\u2212d(Xp,i)/d0 , d(Xp, i) is the euclidean distance between position Xp and the position of rock i, and d0 is a constant specifying the half efficiency distance. Pr(X R i = z) is obtained directly from the probability (stored in b) that rock i is good. Similarly, \u03c4(b, a, z) can be computed quite easily as the move actions deterministically affect variable XP , and a Checki action only changes the probability associated to XRi according to the sensor\u2019s accuracy.\nTo obtain our results in RockSample, we run each algorithm in each starting rock configuration 20 times (i.e. 20 runs for each of the 2k different joint rock states). The initial belief state is the same for all these runs and consists of 0.5 that each rock is good, plus the known initial robot position."}, {"heading": "4.3.1 Real-Time Performance of Online Search", "text": "In Table 3, we present 95% confidence intervals on the mean of our metrics of interest, for RockSample[7,8] (12545 states, 13 actions, 2 observations), with real-time contraints of 1 second per action. We compare performance using two different lower bounds, the Blind policy and PBVI, and use QMDP for the upper bound in both cases. The performance of the policy defined by each lower bound is shown in the comparison header. For RTBSS, the notation RTBSS(k) indicates a k-step lookahead; we use the depth k that yields an average online time closest to 1 second per action.\nReturn In terms of the return, we first observe that the AEMS2 and HSVI-BFS heuristics obtain very similar results. Each of these obtains the highest return by a slight margin with one of the lower bounds. BI-POMDP obtains a similar return when combined with the\nPBVI lower bound, but performs much worse with the Blind lower bound. The two other heuristics, Satia and Lave, and AEMS1, perform considerably worse in terms of return with either lower bound.\nEBR and LBI In terms of error bound reduction and lower bound improvement, AEMS2 obtains the best results with both lower bounds. HSVI-BFS is a close second. This indicates that AEMS2 can more effectively reduce the true error than the other heuristics, and therefore, guarantees better performance. While BI-POMDP tends to be less efficient than AEMS2 and HSVI-BFS, it does significantly better than RTBSS, Satia and Lave, and AEMS1, which only slightly improve the bounds in both case. Satia and Lave is unable to increase the Blind lower bound, which explains why it obtains the same return as the Blind policy. We also observe that the higher the error bound reduction and lower bound improvement, the higher the average discounted return usually is. This confirms our intuition that guiding the search such as to minimize the error at the current belief bc is a good strategy to obtain better return.\nNodes Reused In terms of the percentage of nodes reused, AEMS2 and HVSI-BFS generally obtain the best scores. This allows these algorithms to maintain a higher number of nodes in their trees, which could also partly explain why they outperform the other heuristics in terms of return, error bound reduction and lower bound improvement. Note that RTBSS does not reuse any node in the tree because the algorithm does not store the tree in memory. As a consequence, the reuse percentage is always 0.\nOnline Time Finally, we also observe that AEMS2 requires less average online time per action than the other algorithms to attain its performance. In general, a lower average online time means the heuristic is efficient at finding -optimal actions in a small amount of time. The running time for RTBSS is determined by the chosen depth, as it cannot stop before completing the full lookahead search.\nSummary Overall, we see that AEMS2 and HSVI-BFS obtain similar results. However AEMS2 seems slightly better than HSVI-BFS, as it provides better performance guarantees (lower error) within a shorter period of time. But the difference is not very significant. This may be due to the small number of observations in this environment, in which case the two heuristics expand the tree in very similar ways. In the next section, we explore a domain with many more observations to evaluate the impact of this factor.\nThe lower performances of the three other heuristics can be explained by various reasons. In the case of BI-POMDP, this is due to the fact that it does not take into account the observation probabilities Pr(z|b, a) and discount factor \u03b3 in the heuristic value. Hence it tend to expand fringe nodes that did not affect significantly the value of the current belief. As for Satia and Lave, its poor performance in the case of the Blind policy can be explained by the fact that the fringe nodes that maximize this heuristic are always leaves reached by a sequence of Move actions. Due to the deterministic nature of the Move actions (Pr(z|b, a) = 1 for these actions, whereas Check actions have Pr(z|b, a) = 0.5 initially), the heuristic value for fringe nodes reached by Move actions is much higher until the error is reduced significantly. As a result, the algorithm never explores any nodes under the Check actions, and the robot always follows the Blind policy (moving east, never checking or sampling any rocks). This demonstrates the importance of restricting the choice of which\nleaves to explore to those reached by a sequence of actions maximizing the upper bound, as done in AEMS2, HSVI-BFS and BI-POMDP. In the case of AEMS1, it probably behaves less efficiently because the term it uses to estimate the probability that a certain action is optimal is not a good approximation in this environment. Moreover, because AEMS1 does not restrict the exploration to the best solution graph, it probably also suffers, in part, from the same problems as the Satia and Lave heuristic. RTBSS also did not perform very well with the Blind lower bound. This is due to the short depth allowed to search the tree, required to have a running time \u2264 1 second/action. This confirms that we can do significantly better than an exhaustive search by having good heuristics to guide the search."}, {"heading": "4.3.2 Long-Term Error Reduction of Online Heuristic Search", "text": "To compare the long term performance of the different heuristics, we let the algorithms run in offline mode from the initial belief state of the environment, and log changes in the lower and upper bound values of this initial belief state over 1000 seconds. Here, the initial lower and upper bounds are provided by the Blind policy and QMDP respectively. We see from Figure 4 that Satia and Lave, AEMS1 and BI-POMDP are not as efficient as HSVI-BFS and AEMS2 at reducing the error on the bounds. One interesting thing to note is that the upper bound tends to decrease slowly but continuously, whereas the lower bound often increases in a stepwise manner. We believe this is due to the fact that the upper bound is much tighter than the lower bound. We also observe that most of the error bound reduction happens in the first few seconds of the search. This confirms that the nodes expanded earlier in the tree have much more impact on the error of bc than those expanded very far in the tree (e.g. after hundreds of seconds). This is an important result in support of using online (as opposed to offline) methods."}, {"heading": "4.3.3 Influence of Offline and Online Time", "text": "We now compare how the performance of online approaches is influenced by the available online and offline times. This allows us to verify if a particular method is better when the available online time is shorter (or longer), or whether increasing the offline time could be beneficial.\nWe consider the three approaches that have shown best overall performance so far (BIPOMDP, HSVI-BFS and AEMS2) and compare their average discounted return as a function of the online time constraint per action. Experiments were run in RockSample[10,10] (102,401 states, 15 actions, 2 observations) for each of the following online time constraints: 0.1s, 0.2s, 0.5s, 1s, 2s, 5s and 10s. To vary the offline time, we used 3 different lower bounds: Blind policy, PBVI with 8 belief points, and PBVI with 16 belief points, taking respectively 15s, 82s, and 193s. The upper bound used is QMDP in all cases. These results were obtained on an Intel Xeon 3.0 Ghz processor.\nIn Figure 5, we observe that AEMS2 fares significantly better than HSVI-BFS and BI-POMDP for short time constraints. As the time constraint increases, AEMS2 and HSVI-BFS performs similarly (no significant statistical difference). We also notice that the performance of BI-POMDP stops improving after 1 second of planning time. This can be explained by the fact that it does not take into account the observation probabilities Pr(z|b, a), nor the discount factor. As the search tree grows bigger, more and more fringe nodes have small probability of being reached in the future, such that it becomes more and more important to take these probabilities into account in order to improve performance. Otherwise, as we observe in the case of BI-POMDP, most expanded nodes do not affect the quality of the solution found.\nFrom Figure 6, we observe that increasing the offline time has a beneficial effect mostly when we have very short real-time constraints. When more online planning time is available,\nthe difference between the performances of AEMS2 with the Blind lower bound, and AEMS2 with PBVI becomes insignificant. However, for online time constraints smaller than one second, the difference in performance is very large. Intuitively, with very short real-time constraints the algorithm does not have enough time to expand a lot of nodes, such that the policy found relies much more on the bounds computed offline. On the other hand, with longer time constraints, the algorithm has enough time to significantly improve the bounds computed offline, and thus the policy found does not rely as much on the offline bounds.\n4.4 FieldVisionRockSample\nIt seems from the results presented thus far that HSVI-BFS and AEMS2 have comparable performance on standard domains. We note however that these environments have very small observation sets (assuming observations with zero probability are removed). We believe AEMS2 is especially well suited for domains with large observation spaces. However, there are few such standard problems in the literature. We therefore consider a modified version of the RockSample environment, called FieldVisionRockSample (Ross & Chaib-draa, 2007), which has an observation space size exponential in the number of rocks.\nThe FieldVisionRockSample (FVRS) problem differs from the RockSample problem only in the way the robot is able to perceive the rocks in the environment. Recall that in RockSample, the agent has to do a Check action on a specific rock to observe its state through a noisy sensor. In FVRS, the robot observes the state of all rocks, through the same noisy sensor, after any action is conducted in the environment. Consequently, this eliminates the use of Check actions, and the remaining actions for the robot include only the four move actions {North, East, South, West} and the Sample action. The robot can perceive each rock as being either Good or Bad, thus the observation space size is 2k for an instance of the problem with k rocks. As in RockSample, the efficiency of the sensor is defined through the parameter \u03b7 = 2\u2212d/d0 , where d is the distance of the rock and d0 is the half efficiency distance. We assume the sensor\u2019s observations are independent for each rock.\nIn FVRS, the partial observability of the environment is directly proportional to the parameter d0: as d0 increases, the sensor becomes more accurate and the uncertainty on the state of the environment decreases. The value d0 defined for the different instances of RockSample in the work of Smith and Simmons (2004) is too high for the FVRS problem (especially in the bigger instances of RockSample), making it almost completely observable. Consequently, we re-define the value d0 for the different instances of the FieldVisionRockSample according to the size of the grid (n). By considering the fact that in an n\u00d7 n grid, the largest possible distance between a rock and the robot is (n \u2212 1) \u221a (2), it seems reasonable that at this distance, the probability of observing the real state of the rock should be close to 50% for the problem to remain partially observable. Consequently, we define d0 = (n\u2212 1) \u221a (2)/4.\nTo obtain results for the FVRS domain, we run each algorithm in each starting rock configurations 20 times (i.e. 20 runs for each of the 2k different joint rock states). The initial belief state is the same for all runs and corresponds to a probability of 0.5 that each rock is good, as well as the known initial position of the robot."}, {"heading": "4.4.1 Real-Time Performance of Online Search", "text": "In Table 4, we present 95% confidence intervals on the mean for our metrics of interest. We consider two instances of this environment, FVRS[5,5] (801 states, 5 actions, 32 observations) and FVRS[5,7] (3201 states, 5 actions, 128 observations). In both cases, we use the QMDP upper bound and Blind lower bound, under real-time constraints of 1 second per action.\nReturn In terms of return, we do not observe any clear winner. BI-POMDP performs surpringly well in FVRS[5,5] but significantly worse than AEMS2 and HSVI-BFS in FVRS[5,7]. On the other hand, AEMS2 does significantly better than HSVI-BFS in FVRS[5,5] but both get very similar performances in FVRS[5,7]. Satia and Lave performs better in this environment than in RockSample. This is likely due to the fact that the transitions in belief space are no longer deterministic (as was the case with the Move actions in RockSample). In FVRS[5,5], we also observe that even when RTBSS is given 3 seconds per action to perform a two-step lookahead, its performance is worse than any of the heuristic search methods. This clearly shows that expanding all observations equally in the search is not a good strategy, as many of these observations can have negligible impact for the current decision.\nEBR and LBI In terms of error bound reduction and lower bound improvement, we observe that AEMS2 performs much better than HSVI-BFS in FVRS[5,5], but not significantly better in FVRS[5,7]. On the other hand, BI-POMDP obtains similar results to AEMS2 in FVRS[5,5] but does significantly worse in terms of EBR and LBI than in FVRS[5,7]. This suggests that AEMS2 is consistently effective at reducing the error, even in environments with large branching factors.\nNodes Reused The percentage of belief nodes reused is much lower in FVRS due to the much higher branching factor. We observe that HSVI-BFS has the best reuse percentage\nin all environments, however not significantly higher than AEMS2. Both of these methods reuse significantly larger portion of the tree than the other methods. This confirms that these two methods are able to guide the search towards the most likely beliefs."}, {"heading": "4.4.2 Long-Term Error Reduction of Online Heuristic Search", "text": "Overall, while Table 4 confirms the consistent performance of HSVI-BFS and AEMS2, the difference with other heuristics is modest. Considering the complexity of this environment, this may be due to the fact that the algorithms do not have enough time to expand a significant number of nodes within 1 second. The long-term analysis of the bounds\u2019 evolution in Figures 7 and 8 confirms this. We observe in these figures that the lower bound converges slightly more rapidly with AEMS2 than with other heuristics. The AEMS1 heuristic also performs well in the long run on this problem, and seems to be the second best heuristic, while Satia and Lave is not far behind. On the other hand, the HSVI-BFS heuristic is far worse in this problem than in RockSample. This seems to be in part due to the fact that this heuristic takes more time to find the next node to expand than the others, and thus explores fewer belief states."}, {"heading": "5. Discussion", "text": "The previous sections presented and evaluated several online POMDP algorithms. We now discuss important issues that arise when applying online methods in practice, and summarize some of their advantages and disadvantages. This should help researchers decide whether online algorithms are a good approach for solving a given problem."}, {"heading": "5.1 Lower and Upper Bound Selection", "text": "Online algorithms can be combined with many valid lower and upper bounds. However, there are some properties that these bounds should satisfy for the online search to perform efficiently in practice. One of the desired properties is that the lower and upper bound functions should be monotone. The monotone property states that \u2200b : L(b) \u2264 maxa\u2208A [ RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)L(\u03c4(b, a, z)) ] for the lower bound and \u2200b : U(b) \u2265\nmaxa\u2208A [ RB(b, a) + \u03b3 \u2211 z\u2208Z Pr(z|b, a)U(\u03c4(b, a, z)) ] for the upper bound. This property guarantees that when a certain fringe node is expanded, its lower bound is non-decreasing and its upper bound is non-increasing. This is sufficient to guarantee that the error bound UT (b) \u2212 LT (b) on b is non-increasing after the expansion of b, such that the error bound given by the algorithm on the value of the root belief state bc, cannot be worse than the error bound defined by the initial bounds given. Note however that monotonicity is not necessary for AEMS to converge to an -optimal solution, as shown in previous work (Ross et al., 2008); boundedness is sufficient."}, {"heading": "5.2 Improving the Bounds over Time", "text": "As we mentioned in our survey of online algorithms, one drawback of many online approaches is that they do not store improvements made to the offline bounds during the online search, such that, if the same belief state is encountered again, the same computations need to be performed again, restarting from the same offline bounds. A trivial way to improve this is to maintain a large hashtable (or database) of belief states for which we have improved the lower and upper bounds in previous search, with their associated new bounds. There are however many drawbacks in doing this. First every time we want to evaluate the lower and upper bound of a fringe belief, a search through this hashtable needs to be performed to check if we have better bounds available. This may require significant time if the hashtable is large (e.g. millions of beliefs). Furthermore, experiments conducted with RTDP-Bel in large domains, such as RockSample[7,8], have shown that such a process usually runs out of memory (i.e. requires more than 1 GB) before good performance is achieved and requires several thousands episodes before performing well (Paquet, 2006).\nThe authors of RTBSS have also tried combining their search algorithm with RTDPBel such as to preserve the improvements made by the search (Paquet, 2006). While this combination usually performed better and learned faster than RTDP-Bel alone, it was found that in most domains, a few thousand episodes are still required before any improvement can be seen (in terms of return). Hence, such point updates of the offline bounds tend to be useful in large domains only if the task to accomplish is repeated a very large number of times.\nA better strategy to improve the lower bound might be to save some time to perform \u03b1-vector updates for some of the beliefs expanded during the search, such that the offline lower bound improves over time. Such updates have the advantage of improving the lower bound over the whole belief space, instead of at a single belief state. However this can be very time consuming, especially in large domains. Hence, if we need to act within very short time constraints, such an approach is infeasible. However if several seconds of planning time are available per action, then it might be advantageous to use some of this time to perform \u03b1-vector updates, rather than use all the available time to search through the tree. A good\nidea here would be to perform \u03b1-vector updates for a subset of the beliefs in the search tree, where the lower bound most improves."}, {"heading": "5.3 Factored POMDP Representations", "text": "The efficiency of online algorithms relies heavily on the ability to quickly compute \u03c4(b, a, z) and Pr(z|b, a), as these must be computed for evey belief state in the search tree. Using factored POMDP representations is an effective way to reduce the time complexity of computing these quantities. Since most environments with large state spaces are structured and can be described by sets of features, obtaining factored representation of complex systems should not be an issue in most cases. However, in domains with significant dependencies between state features, it may be useful to use algorithms proposed by Boyen and Koller (1998) and Poupart (2005) to find approximate factored representations where most features are independent, with minimal degradation in the solution quality. While the upper and lower bounds might not hold anymore if they are computed over the approximate factored representation, usually it may still yield good results in practice."}, {"heading": "5.4 Handling Graph Structure", "text": "As we have mentioned before, the general tree search algorithm used by online algorithms will duplicate belief states whenever there are multiple paths leading to the same posterior belief from the current belief bc. This greatly simplifies the complexity related to updating the values of ancestor nodes, and it also reduces the complexity related to finding the best fringe node to expand (using the technique in Section 3.4 which is only valid for trees). The disadvantage of using a tree structure is that inevitably, some computations will be redundant, as the algorithm will potentially expand the same subtree under every duplicate belief. To avoid this, we could use the LAO\u2217 algorithm proposed by Hansen and Zilberstein (2001) as an extension of AO\u2217 that can handle generic graph structure, including cyclic graphs. After each expansion, it runs a value (or policy) iteration algorithm until convergence among all ancestor nodes in order to update their values.\nThe heuristics we surveyed in Section 3.4 can be generalized to guide best-first search algorithms that handle graph structure, like LAO\u2217. The first thing to notice is that, in any graph, if a fringe node is reached by multiple paths, then its error contributes multiple times to the error on the value of bc. Under this error contribution perspective, the heuristic value of such a fringe node should be the sum of its heuristic values over all paths reaching it. For instance, in the case of the AEMS heuristic, using the notation we have defined in Section 3.4, the global heuristic value of a given fringe node b, on the current belief state bc in any graph G, can be computed as follows:\nHG(bc, b) = (U(b) \u2212 L(b)) \u2211\nh\u2208HG(bc,b)\n\u03b3d(h) Pr(h|bc, \u03c0\u0302G). (38)\nNotice that for cyclic graphs, there can be infinitely many paths in HG(bc, b). In such case, we could use dynamic programming to estimate the heuristic value.\nBecause solving HG(bc, b) for all fringe nodes b in the graph G will require a lot of time in practice, especially if there are many fringe nodes, we have not experimented with this method in Section 4. However, it would be practical to use this heuristic if we could find an\nalternative way to determine the best fringe node without computing HG(bc, b) separately for each fringe node b and performing an exhaustive search over all fringe nodes."}, {"heading": "5.5 Online vs. Offline Time", "text": "One important aspect determining the efficiency and applicability of online algorithms is the amount of time available during the execution for planning. This of course is often taskdependent. For real-time problems like robot navigation, this amount of time may be very short, e.g. between 0.1 to 1 second per action. On the other hand for tasks like portfolio management, where acting every second is not necessary, several minutes could easily be taken to plan any stock buying/selling action. As we have seen from our experiments, the shorter the available online planning time, the greater the importance of having a good offline value function to start with. In such case, it is often necessary to reserve sufficient time to compute a good offline policy. As more and more planning time is available online, the influence of the offline value function becomes negligible, such that a very rough offline value function is sufficient to obtain good performance. The best trade-off between online and offline time often depends on how large the problem is. When the branching factor (|A||Z|) is large and/or computing successor belief states takes a long time, then more online time will be required to achieve a significant improvement over the offline value function. However, for small problems, an online time of 0.1 second per action may be sufficient to perform near-optimally even with a very rough offline value function."}, {"heading": "5.6 Advantages and Disadvantages of Online Algorithms", "text": "We now discuss the advantages and disadvantages of online planning algorithms in general."}, {"heading": "5.6.1 Advantages", "text": "\u2022 Most online algorithms can be combined with any offline solving algorithm, assuming it provides a lower bound or an upper bound on V \u2217, such as to improve the quality of the policy found offline.\n\u2022 Online algorithms require very little offline computation before being executable in an environment, as they can perform well even using very loose bounds, which are quick to compute.\n\u2022 Online methods can exploit the knowledge of the current belief to focus computation on the most relevant future beliefs for the current decision, such that they scale well to large action and observation spaces.\n\u2022 Anytime online methods are applicable in real-time environments, as they can be stopped whenever planning time runs out, and still provide the best solution found so far."}, {"heading": "5.6.2 Disadvantages", "text": "\u2022 The branching factor depends on the number of actions and observations. Thus if there are many observations and/or actions, it might be impossible to search deep\nenough, to provide significant improvement of the offline policy. In such cases, sampling methods designed to reduce the branching factor could be useful. While we cannot guarantee that the lower and upper bounds are still valid when sampling is used, we can guarantee that they are valid with high probability, given that enough samples are drawn.\n\u2022 Most online algorithms do not store improvements made to the offline policy by the online search, and so the algorithm has to plan again with the same bounds each time the environment is restarted. If time is available, it could be advantageous to add \u03b1-vector updates for some belief states explored in the tree, so that the offline bounds improve with time."}, {"heading": "6. Conclusion", "text": "POMDPs provide a rich and elegant framework for planning in stochastic partially observable domains, however their time complexity has been a major issue preventing their application to complex real-world systems. This paper thoroughly surveys the various existing online algorithms and the key techniques and approximations used to solve POMDPs more efficiently. We empirically compare these online approaches in several POMDP domains under different metrics: average discounted return, average error bound reduction and average lower bound improvement, and using different lower and upper bounds: PBVI, Blind, FIB and QMDP.\nFrom the empirical results, we observe that some of the heuristic search methods, namely AEMS2 and HSVI-BFS, obtain very good performances, even in domains with large branching factors and large state spaces. These two methods are very similar and perform well because they orient the search towards nodes that can improve the current approximate value function as quickly as possible; i.e. the belief nodes that have largest error and are most likely to be reached in the future by \u201cpromising\u201d actions. However, in environments with large branching factors, we may only have time to expand a few nodes at each turn. Hence, it would be interesting to develop further approximations to reduce the branching factor in such cases.\nIn conclusion, we believe that online approaches have an important role to play in improving the scalability of POMDP solution methods. A good example is the succesful applications of the RTBSS algorithm to the RobocupRescue simulation by Paquet et al. (2005). This environment is very challenging as the state space is orders of magnitude beyond the scope of current algorithms. Offline algorithms remain very important to obtain tight lower and upper bounds on the value function. The interesting question is not whether online or offline approaches are better, but how we can improve both kinds of approaches, such that their synergy can be exploited to solve complex real-world problems."}, {"heading": "Acknowledgments", "text": "This research was supported by the Natural Sciences and Engineering Council of Canada and the Fonds Que\u0301be\u0301cois de la Recherche sur la Nature et les Technologies. We would also like to thank the anonymous reviewers for their helpful comments and suggestions."}], "references": [{"title": "Optimal control of Markov decision processes with incomplete state estimation", "author": ["K.J. Astrom"], "venue": "Journal of Mathematical Analysis and Applications, 10, 174\u2013205.", "citeRegEx": "Astrom,? 1965", "shortCiteRegEx": "Astrom", "year": 1965}, {"title": "Learning to act using real-time dynamic programming", "author": ["A.G. Barto", "S.J. Bradtke", "S.P. Singhe"], "venue": "Artificial Intelligence,", "citeRegEx": "Barto et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Barto et al\\.", "year": 1995}, {"title": "Dynamic Programming", "author": ["R. Bellman"], "venue": "Princeton University Press, Princeton, NJ, USA.", "citeRegEx": "Bellman,? 1957", "shortCiteRegEx": "Bellman", "year": 1957}, {"title": "Rollout algorithms for stochastic scheduling problems", "author": ["D.P. Bertsekas", "D.A. Castanon"], "venue": "Journal of Heuristics,", "citeRegEx": "Bertsekas and Castanon,? \\Q1999\\E", "shortCiteRegEx": "Bertsekas and Castanon", "year": 1999}, {"title": "Tractable inference for complex stochastic processes", "author": ["X. Boyen", "D. Koller"], "venue": "Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Boyen and Koller,? \\Q1998\\E", "shortCiteRegEx": "Boyen and Koller", "year": 1998}, {"title": "Stochastic local search for POMDP controllers", "author": ["D. Braziunas", "C. Boutilier"], "venue": "In The Nineteenth National Conference on Artificial Intelligence", "citeRegEx": "Braziunas and Boutilier,? \\Q2004\\E", "shortCiteRegEx": "Braziunas and Boutilier", "year": 2004}, {"title": "Incremental pruning: a simple, fast, exact method for partially observable Markov decision processes", "author": ["A. Cassandra", "M.L. Littman", "N.L. Zhang"], "venue": "In Proceedings of the Thirteenth Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Cassandra et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cassandra et al\\.", "year": 1997}, {"title": "Parallel rollout for online solution of partially observable Markov decision processes", "author": ["H.S. Chang", "R. Givan", "E.K.P. Chong"], "venue": "Discrete Event Dynamic Systems,", "citeRegEx": "Chang et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Chang et al\\.", "year": 2004}, {"title": "Solving large POMDPs using real time dynamic programming", "author": ["H. Geffner", "B. Bonet"], "venue": "In Proceedings of the Fall AAAI symposium on POMDPs,", "citeRegEx": "Geffner and Bonet,? \\Q1998\\E", "shortCiteRegEx": "Geffner and Bonet", "year": 1998}, {"title": "Solving POMDPs by searching in policy space", "author": ["E.A. Hansen"], "venue": "Fourteenth Conference on Uncertainty in Artificial Intelligence (UAI-98), pp. 211\u2013219.", "citeRegEx": "Hansen,? 1998", "shortCiteRegEx": "Hansen", "year": 1998}, {"title": "LAO * : A heuristic search algorithm that finds solutions with loops", "author": ["E.A. Hansen", "S. Zilberstein"], "venue": "Artificial Intelligence,", "citeRegEx": "Hansen and Zilberstein,? \\Q2001\\E", "shortCiteRegEx": "Hansen and Zilberstein", "year": 2001}, {"title": "Value-function approximations for partially observable Markov decision processes", "author": ["M. Hauskrecht"], "venue": "Journal of Artificial Intelligence Research, 13, 33\u201394.", "citeRegEx": "Hauskrecht,? 2000", "shortCiteRegEx": "Hauskrecht", "year": 2000}, {"title": "Planning and acting in partially observable stochastic domains", "author": ["L.P. Kaelbling", "M.L. Littman", "A.R. Cassandra"], "venue": "Artificial Intelligence,", "citeRegEx": "Kaelbling et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Kaelbling et al\\.", "year": 1998}, {"title": "A sparse sampling algorithm for nearoptimal planning in large markov decision processes", "author": ["M.J. Kearns", "Y. Mansour", "A.Y. Ng"], "venue": "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Kearns et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Kearns et al\\.", "year": 1999}, {"title": "Agent-centered search", "author": ["S. Koenig"], "venue": "AI Magazine, 22 (4), 109\u2013131.", "citeRegEx": "Koenig,? 2001", "shortCiteRegEx": "Koenig", "year": 2001}, {"title": "Algorithms for sequential decision making", "author": ["M.L. Littman"], "venue": "Ph.D. thesis, Brown University.", "citeRegEx": "Littman,? 1996", "shortCiteRegEx": "Littman", "year": 1996}, {"title": "Learning policies for partially observable environments: scaling up", "author": ["M.L. Littman", "A.R. Cassandra", "L.P. Kaelbling"], "venue": "In Proceedings of the 12th International Conference on Machine Learning", "citeRegEx": "Littman et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Littman et al\\.", "year": 1995}, {"title": "Computationally feasible bounds for POMDPs", "author": ["W.S. Lovejoy"], "venue": "Operations Research, 39 (1), 162\u2013175.", "citeRegEx": "Lovejoy,? 1991", "shortCiteRegEx": "Lovejoy", "year": 1991}, {"title": "On the undecidability of probabilistic planning and infinite-horizon partially observable Markov decision problems", "author": ["O. Madani", "S. Hanks", "A. Condon"], "venue": "In Proceedings of the Sixteenth National Conference on Artificial Intelligence", "citeRegEx": "Madani et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Madani et al\\.", "year": 1999}, {"title": "Approximate Planning for Factored POMDPs using Belief State Simplification", "author": ["D. McAllester", "S. Singh"], "venue": "In Proceedings of the 15th Annual Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "McAllester and Singh,? \\Q1999\\E", "shortCiteRegEx": "McAllester and Singh", "year": 1999}, {"title": "A survey of partially observable Markov decision processes: theory, models and algorithms", "author": ["G.E. Monahan"], "venue": "Management Science, 28 (1), 1\u201316.", "citeRegEx": "Monahan,? 1982", "shortCiteRegEx": "Monahan", "year": 1982}, {"title": "Principles of Artificial Intelligence", "author": ["N. Nilsson"], "venue": "Tioga Publishing.", "citeRegEx": "Nilsson,? 1980", "shortCiteRegEx": "Nilsson", "year": 1980}, {"title": "The complexity of Markov decision processes", "author": ["C. Papadimitriou", "J.N. Tsitsiklis"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Papadimitriou and Tsitsiklis,? \\Q1987\\E", "shortCiteRegEx": "Papadimitriou and Tsitsiklis", "year": 1987}, {"title": "Distributed Decision-Making and Task Coordination in Dynamic, Uncertain and Real-Time Multiagent Environments", "author": ["S. Paquet"], "venue": "Ph.D. thesis, Laval University.", "citeRegEx": "Paquet,? 2006", "shortCiteRegEx": "Paquet", "year": 2006}, {"title": "Hybrid POMDP algorithms", "author": ["S. Paquet", "B. Chaib-draa", "S. Ross"], "venue": "In Proceedings of The Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Paquet et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Paquet et al\\.", "year": 2006}, {"title": "An online POMDP algorithm for complex multiagent environments", "author": ["S. Paquet", "L. Tobin", "B. Chaib-draa"], "venue": "In Proceedings of The fourth International Joint Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Paquet et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Paquet et al\\.", "year": 2005}, {"title": "Point-based value iteration: an anytime algorithm for POMDPs", "author": ["J. Pineau", "G. Gordon", "S. Thrun"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence", "citeRegEx": "Pineau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Pineau et al\\.", "year": 2003}, {"title": "Anytime point-based approximations for large POMDPs", "author": ["J. Pineau", "G. Gordon", "S. Thrun"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Pineau et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Pineau et al\\.", "year": 2006}, {"title": "Tractable planning under uncertainty: exploiting structure", "author": ["J. Pineau"], "venue": "Ph.D. thesis, Carnegie Mellon University.", "citeRegEx": "Pineau,? 2004", "shortCiteRegEx": "Pineau", "year": 2004}, {"title": "Exploiting structure to efficiently solve large scale partially observable Markov decision processes", "author": ["P. Poupart"], "venue": "Ph.D. thesis, University of Toronto.", "citeRegEx": "Poupart,? 2005", "shortCiteRegEx": "Poupart", "year": 2005}, {"title": "Bounded finite state controllers", "author": ["P. Poupart", "C. Boutilier"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Poupart and Boutilier,? \\Q2003\\E", "shortCiteRegEx": "Poupart and Boutilier", "year": 2003}, {"title": "Markov Decision Processes: Discrete Stochastic Dynamic Programming", "author": ["M.L. Puterman"], "venue": "John Wiley & Sons, Inc.", "citeRegEx": "Puterman,? 1994", "shortCiteRegEx": "Puterman", "year": 1994}, {"title": "Aems: An anytime online search algorithm for approximate policy refinement in large POMDPs", "author": ["S. Ross", "B. Chaib-draa"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence", "citeRegEx": "Ross and Chaib.draa,? \\Q2007\\E", "shortCiteRegEx": "Ross and Chaib.draa", "year": 2007}, {"title": "Theoretical analysis of heuristic search methods for online POMDPs", "author": ["S. Ross", "J. Pineau", "B. Chaib-draa"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Ross et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ross et al\\.", "year": 2008}, {"title": "Markovian decision processes with probabilistic observation of states", "author": ["J.K. Satia", "R.E. Lave"], "venue": "Management Science,", "citeRegEx": "Satia and Lave,? \\Q1973\\E", "shortCiteRegEx": "Satia and Lave", "year": 1973}, {"title": "Adaptation for changing stochastic environments through online POMDP policy learning", "author": ["G. Shani", "R. Brafman", "S. Shimony"], "venue": "In Proceedings of the Workshop on Reinforcement Learning in Non-Stationary Environments,", "citeRegEx": "Shani et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Shani et al\\.", "year": 2005}, {"title": "The optimal control of partially observable Markov processes over a finite horizon", "author": ["R.D. Smallwood", "E.J. Sondik"], "venue": "Operations Research,", "citeRegEx": "Smallwood and Sondik,? \\Q1973\\E", "shortCiteRegEx": "Smallwood and Sondik", "year": 1973}, {"title": "Heuristic search value iteration for POMDPs", "author": ["T. Smith", "R. Simmons"], "venue": "In Proceedings of the 20th Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Smith and Simmons,? \\Q2004\\E", "shortCiteRegEx": "Smith and Simmons", "year": 2004}, {"title": "Point-based POMDP algorithms: improved analysis and implementation", "author": ["T. Smith", "R. Simmons"], "venue": "In Proceedings of the 21th Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Smith and Simmons,? \\Q2005\\E", "shortCiteRegEx": "Smith and Simmons", "year": 2005}, {"title": "The optimal control of partially observable Markov processes", "author": ["E.J. Sondik"], "venue": "Ph.D. thesis, Stanford University.", "citeRegEx": "Sondik,? 1971", "shortCiteRegEx": "Sondik", "year": 1971}, {"title": "The optimal control of partially observable Markov processes over the infinite horizon: Discounted costs", "author": ["E.J. Sondik"], "venue": "Operations Research, 26 (2), 282\u2013304.", "citeRegEx": "Sondik,? 1978", "shortCiteRegEx": "Sondik", "year": 1978}, {"title": "A point-based POMDP algorithm for robot planning", "author": ["M.T.J. Spaan", "N. Vlassis"], "venue": "Proceedings of the IEEE International Conference on Robotics and Automation", "citeRegEx": "Spaan and Vlassis,? \\Q2004\\E", "shortCiteRegEx": "Spaan and Vlassis", "year": 2004}, {"title": "Perseus: randomized point-based value iteration for POMDPs", "author": ["M.T.J. Spaan", "N. Vlassis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Spaan and Vlassis,? \\Q2005\\E", "shortCiteRegEx": "Spaan and Vlassis", "year": 2005}, {"title": "A fast point-based algorithm for POMDPs", "author": ["N. Vlassis", "M.T.J. Spaan"], "venue": "Benelearn", "citeRegEx": "Vlassis and Spaan,? \\Q2004\\E", "shortCiteRegEx": "Vlassis and Spaan", "year": 2004}, {"title": "BI-POMDP: bounded, incremental partially observable Markov model planning", "author": ["R. Washington"], "venue": "Proceedings of the 4th European Conference on Planning, pp. 440\u2013451.", "citeRegEx": "Washington,? 1997", "shortCiteRegEx": "Washington", "year": 1997}, {"title": "Speeding up the convergence of value iteration in partially observable Markov decision processes", "author": ["N.L. Zhang", "W. Zhang"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Zhang and Zhang,? \\Q2001\\E", "shortCiteRegEx": "Zhang and Zhang", "year": 2001}], "referenceMentions": [{"referenceID": 11, "context": "In the last few years, POMDPs have generated significant interest in the AI community and many approximation algorithms have been developed (Hauskrecht, 2000; Pineau, Gordon, & Thrun, 2003; Braziunas & Boutilier, 2004; Poupart, 2005; Smith & Simmons, 2005; Spaan & Vlassis, 2005).", "startOffset": 140, "endOffset": 279}, {"referenceID": 29, "context": "In the last few years, POMDPs have generated significant interest in the AI community and many approximation algorithms have been developed (Hauskrecht, 2000; Pineau, Gordon, & Thrun, 2003; Braziunas & Boutilier, 2004; Poupart, 2005; Smith & Simmons, 2005; Spaan & Vlassis, 2005).", "startOffset": 140, "endOffset": 279}, {"referenceID": 44, "context": "On the other hand, online approaches (Satia & Lave, 1973; Washington, 1997; Barto, Bradtke, & Singhe, 1995; Paquet, Tobin, & Chaib-draa, 2005; McAllester & Singh, 1999; Bertsekas & Castanon, 1999; Shani, Brafman, & Shimony, 2005) try to circumvent the complexity of computing a policy by planning online only for the current information state.", "startOffset": 37, "endOffset": 229}, {"referenceID": 14, "context": "Online algorithms are sometimes also called agent-centered search algorithms (Koenig, 2001).", "startOffset": 77, "endOffset": 91}, {"referenceID": 11, "context": "We present various combinations of online algorithms with various existing offline algorithms, such as QMDP (Littman, Cassandra, & Kaelbling, 1995), FIB (Hauskrecht, 2000), Blind (Hauskrecht, 2000; Smith & Simmons, 2005) and PBVI (Pineau et al.", "startOffset": 153, "endOffset": 171}, {"referenceID": 11, "context": "We present various combinations of online algorithms with various existing offline algorithms, such as QMDP (Littman, Cassandra, & Kaelbling, 1995), FIB (Hauskrecht, 2000), Blind (Hauskrecht, 2000; Smith & Simmons, 2005) and PBVI (Pineau et al.", "startOffset": 179, "endOffset": 220}, {"referenceID": 26, "context": "We present various combinations of online algorithms with various existing offline algorithms, such as QMDP (Littman, Cassandra, & Kaelbling, 1995), FIB (Hauskrecht, 2000), Blind (Hauskrecht, 2000; Smith & Simmons, 2005) and PBVI (Pineau et al., 2003).", "startOffset": 230, "endOffset": 251}, {"referenceID": 0, "context": "Partially observable Markov decision processes (POMDPs) provide a general framework for acting in partially observable environments (Astrom, 1965; Smallwood & Sondik, 1973; Monahan, 1982; Kaelbling, Littman, & Cassandra, 1998).", "startOffset": 132, "endOffset": 226}, {"referenceID": 20, "context": "Partially observable Markov decision processes (POMDPs) provide a general framework for acting in partially observable environments (Astrom, 1965; Smallwood & Sondik, 1973; Monahan, 1982; Kaelbling, Littman, & Cassandra, 1998).", "startOffset": 132, "endOffset": 226}, {"referenceID": 0, "context": "Instead, it is possible to summarize all relevant information from previous actions and observations in a probability distribution over the state space S, which is called a belief state (Astrom, 1965).", "startOffset": 186, "endOffset": 200}, {"referenceID": 40, "context": "Since there always exists a deterministic policy that maximizes V \u03c0 for any belief states (Sondik, 1978), we will generally only consider deterministic policies (i.", "startOffset": 90, "endOffset": 104}, {"referenceID": 2, "context": "The value function V \u2217 of the optimal policy \u03c0\u2217 is the fixed point of Bellman\u2019s equation (Bellman, 1957):", "startOffset": 89, "endOffset": 104}, {"referenceID": 39, "context": "One can solve optimally a POMDP for a specified finite horizon H by using the value iteration algorithm (Sondik, 1971).", "startOffset": 104, "endOffset": 118}, {"referenceID": 36, "context": "A key result by Smallwood and Sondik (1973) shows that the optimal value function for a finite-horizon POMDP can be represented by hyperplanes, and is therefore convex and piecewise linear.", "startOffset": 16, "endOffset": 44}, {"referenceID": 39, "context": "A number of exact value function algorithms leveraging the piecewise-linear and convex aspects of the value function have been proposed in the POMDP literature (Sondik, 1971; Monahan, 1982; Littman, 1996; Cassandra, Littman, & Zhang, 1997; Zhang & Zhang, 2001).", "startOffset": 160, "endOffset": 260}, {"referenceID": 20, "context": "A number of exact value function algorithms leveraging the piecewise-linear and convex aspects of the value function have been proposed in the POMDP literature (Sondik, 1971; Monahan, 1982; Littman, 1996; Cassandra, Littman, & Zhang, 1997; Zhang & Zhang, 2001).", "startOffset": 160, "endOffset": 260}, {"referenceID": 15, "context": "A number of exact value function algorithms leveraging the piecewise-linear and convex aspects of the value function have been proposed in the POMDP literature (Sondik, 1971; Monahan, 1982; Littman, 1996; Cassandra, Littman, & Zhang, 1997; Zhang & Zhang, 2001).", "startOffset": 160, "endOffset": 260}, {"referenceID": 11, "context": "Some recent publications provide a more comprehensive overview of offline approximate algorithms (Hauskrecht, 2000; Pineau, Gordon, & Thrun, 2006).", "startOffset": 97, "endOffset": 146}, {"referenceID": 11, "context": "A Blind policy (Hauskrecht, 2000; Smith & Simmons, 2005) is a policy where the same action is always executed, regardless of the belief state.", "startOffset": 15, "endOffset": 56}, {"referenceID": 17, "context": "To obtain tighter lower bounds, one can use point-based methods (Lovejoy, 1991; Hauskrecht, 2000; Pineau et al., 2003).", "startOffset": 64, "endOffset": 118}, {"referenceID": 11, "context": "To obtain tighter lower bounds, one can use point-based methods (Lovejoy, 1991; Hauskrecht, 2000; Pineau et al., 2003).", "startOffset": 64, "endOffset": 118}, {"referenceID": 26, "context": "To obtain tighter lower bounds, one can use point-based methods (Lovejoy, 1991; Hauskrecht, 2000; Pineau et al., 2003).", "startOffset": 64, "endOffset": 118}, {"referenceID": 26, "context": "Different algorithms have been developed using the point-based approach: PBVI (Pineau et al., 2003), Perseus (Spaan & Vlassis, 2005), HSVI (Smith & Simmons, 2004, 2005) are some of the most recent methods.", "startOffset": 78, "endOffset": 99}, {"referenceID": 16, "context": "The MDP approximation consists in approximating the value function V \u2217 of the POMDP by the value function of its underlying MDP (Littman et al., 1995).", "startOffset": 128, "endOffset": 150}, {"referenceID": 16, "context": "The QMDP approximation is a slight variation of the MDP approximation (Littman et al., 1995).", "startOffset": 70, "endOffset": 92}, {"referenceID": 11, "context": "To address this problem, Hauskrecht (2000) proposed a new method to compute upper bounds, called the Fast Informed Bound (FIB), which is able to take into account (to some degree) the partial observability of the environment.", "startOffset": 25, "endOffset": 43}, {"referenceID": 24, "context": "Even more recent point-based methods produce solutions of limited quality in very large domains (Paquet et al., 2006).", "startOffset": 96, "endOffset": 117}, {"referenceID": 14, "context": "Consequently, the overall time for the policy construction and execution is normally less for online approaches (Koenig, 2001).", "startOffset": 112, "endOffset": 126}, {"referenceID": 31, "context": "(Puterman, 1994; Hauskrecht, 2000) Let V\u0302 be an approximate value function and = supb |V \u2217(b) \u2212 V\u0302 (b)|.", "startOffset": 0, "endOffset": 34}, {"referenceID": 11, "context": "(Puterman, 1994; Hauskrecht, 2000) Let V\u0302 be an approximate value function and = supb |V \u2217(b) \u2212 V\u0302 (b)|.", "startOffset": 0, "endOffset": 34}, {"referenceID": 24, "context": "In some cases, their results showed a tremendous improvement of the policy given by the offline algorithm (Paquet et al., 2006).", "startOffset": 106, "endOffset": 127}, {"referenceID": 17, "context": "The approach presented by McAllester and Singh (1999) is an adaptation of the online MDP algorithm presented by Kearns, Mansour, and Ng (1999).", "startOffset": 26, "endOffset": 54}, {"referenceID": 17, "context": "The approach presented by McAllester and Singh (1999) is an adaptation of the online MDP algorithm presented by Kearns, Mansour, and Ng (1999). It consists of a depth-limited search of the AND-OR tree up to a certain fixed horizon D where instead of exploring all observations at each action choice, C observations are sampled from a generative model.", "startOffset": 26, "endOffset": 143}, {"referenceID": 4, "context": "The authors also apply belief state factorization as in Boyen and Koller (1998) to simplify the belief state calculations.", "startOffset": 56, "endOffset": 80}, {"referenceID": 4, "context": "The authors also apply belief state factorization as in Boyen and Koller (1998) to simplify the belief state calculations. For the implementation of this algorithm, the Expand subroutine expands the tree up to fixed depth D, using Monte Carlo sampling of observations, as mentioned above (see Algorithm 3.3). At the end of each time step, the tree T is reinitialized to contain only the new current belief at the root. Kearns et al. (1999) derive bounds on the depth D and the number of samples C needed to obtain an -optimal policy with high probability and show that the number of samples required grows exponentially in the desired accuracy.", "startOffset": 56, "endOffset": 440}, {"referenceID": 3, "context": "Bertsekas and Castanon (1999) also show that with enough sampling, the resulting policy is guaranteed to perform at least as well as the initial policy with high probability.", "startOffset": 0, "endOffset": 30}, {"referenceID": 3, "context": "The original Rollout algorithm by Bertsekas and Castanon (1999) is the same algorithm in the special case where the set of initial policies \u03a0 contains only one policy.", "startOffset": 34, "endOffset": 64}, {"referenceID": 44, "context": "There are three different online heuristic search algorithms for POMDPs that have been proposed in the past: Satia and Lave (1973), BI-POMDP (Washington, 1997) and AEMS (Ross & Chaib-draa, 2007).", "startOffset": 141, "endOffset": 159}, {"referenceID": 34, "context": "There are three different online heuristic search algorithms for POMDPs that have been proposed in the past: Satia and Lave (1973), BI-POMDP (Washington, 1997) and AEMS (Ross & Chaib-draa, 2007).", "startOffset": 109, "endOffset": 131}, {"referenceID": 33, "context": "Now that we have covered the basic subroutines, we present the different heuristics proposed by Satia and Lave (1973), Washington (1997) and Ross and Chaib-draa (2007).", "startOffset": 96, "endOffset": 118}, {"referenceID": 33, "context": "Now that we have covered the basic subroutines, we present the different heuristics proposed by Satia and Lave (1973), Washington (1997) and Ross and Chaib-draa (2007).", "startOffset": 96, "endOffset": 137}, {"referenceID": 32, "context": "Now that we have covered the basic subroutines, we present the different heuristics proposed by Satia and Lave (1973), Washington (1997) and Ross and Chaib-draa (2007). We begin by introducing some useful notation.", "startOffset": 141, "endOffset": 168}, {"referenceID": 34, "context": "The approach of Satia and Lave (1973) follows the heuristic search framework presented above.", "startOffset": 16, "endOffset": 38}, {"referenceID": 21, "context": "Washington (1997) proposed a slightly different approach inspired by the AO\u2217 algorithm (Nilsson, 1980), where the search is only conducted in the best solution graph.", "startOffset": 87, "endOffset": 102}, {"referenceID": 44, "context": "Washington (1997) recommends exploring the fringe node in F\u0302(G) (where G is the current acyclic search graph) that maximizes UG(b)\u2212LG(b).", "startOffset": 0, "endOffset": 18}, {"referenceID": 33, "context": "In particular, Ross et al. (2008) considered two possible approximations for \u03c0\u2217.", "startOffset": 15, "endOffset": 34}, {"referenceID": 33, "context": "As a final note, Ross et al. (2008) determined sufficient conditions under which the search algorithm using this heuristic is guaranteed to find an -optimal action within finite time.", "startOffset": 17, "endOffset": 36}, {"referenceID": 9, "context": "The AEMS2 heuristic was also used for a policy search algorithm by Hansen (1998).", "startOffset": 67, "endOffset": 81}, {"referenceID": 33, "context": "(Ross et al., 2008) Let > 0 and bc the current belief.", "startOffset": 0, "endOffset": 19}, {"referenceID": 37, "context": "A heuristic similar to AEMS2 was also used by Smith and Simmons (2004) for their offline value iteration algorithm HSVI as a way to pick the next belief point at which to perform \u03b1-vector backups.", "startOffset": 46, "endOffset": 71}, {"referenceID": 1, "context": "An alternative approach to searching in AND-OR graphs is the RTDP algorithm (Barto et al., 1995) which has been adapted to solve POMDPs by Geffner and Bonet (1998).", "startOffset": 76, "endOffset": 96}, {"referenceID": 1, "context": "An alternative approach to searching in AND-OR graphs is the RTDP algorithm (Barto et al., 1995) which has been adapted to solve POMDPs by Geffner and Bonet (1998). Their algorithm, called RTDP-BEL, learns approximate values for the belief states visited by successive trials in the environment.", "startOffset": 77, "endOffset": 164}, {"referenceID": 8, "context": "Supported by experimental data, Geffner and Bonet (1998) suggest choosing k \u2208 [10, 100], as it usually produces the best results.", "startOffset": 32, "endOffset": 57}, {"referenceID": 35, "context": "A more recent online approach, called SOVI (Shani et al., 2005), extends HSVI (Smith & Simmons, 2004, 2005) into an online value iteration algorithm.", "startOffset": 43, "endOffset": 63}, {"referenceID": 26, "context": "In this section, we compare several online approaches in two domains found in the POMDP literature: Tag (Pineau et al., 2003) and RockSample (Smith & Simmons, 2004).", "startOffset": 104, "endOffset": 125}, {"referenceID": 28, "context": "This environment has also been used more recently in the work of several authors (Poupart & Boutilier, 2003; Vlassis & Spaan, 2004; Pineau, 2004; Spaan & Vlassis, 2004; Smith & Simmons, 2004; Braziunas & Boutilier, 2004; Spaan & Vlassis, 2005; Smith & Simmons, 2005).", "startOffset": 81, "endOffset": 266}, {"referenceID": 26, "context": "Tag was initially introduced by Pineau et al. (2003). This environment has also been used more recently in the work of several authors (Poupart & Boutilier, 2003; Vlassis & Spaan, 2004; Pineau, 2004; Spaan & Vlassis, 2004; Smith & Simmons, 2004; Braziunas & Boutilier, 2004; Spaan & Vlassis, 2005; Smith & Simmons, 2005).", "startOffset": 32, "endOffset": 53}, {"referenceID": 26, "context": "Tag was initially introduced by Pineau et al. (2003). This environment has also been used more recently in the work of several authors (Poupart & Boutilier, 2003; Vlassis & Spaan, 2004; Pineau, 2004; Spaan & Vlassis, 2004; Smith & Simmons, 2004; Braziunas & Boutilier, 2004; Spaan & Vlassis, 2005; Smith & Simmons, 2005). For this environment, an approximate POMDP algorithm is necessary because of its large size (870 states, 5 actions and 30 observations). The Tag environment consists of an agent that has to catch (Tag) another agent while moving in a 29-cell grid domain. The reader is referred to the work of Pineau et al. (2003) for a full description of the domain.", "startOffset": 32, "endOffset": 636}, {"referenceID": 37, "context": "The RockSample problem was originally presented by Smith and Simmons (2004). In this domain, an agent has to explore the environment and sample some rocks (see Figure 3), similarly to what a real robot would do on the planet Mars.", "startOffset": 51, "endOffset": 76}, {"referenceID": 37, "context": "The value d0 defined for the different instances of RockSample in the work of Smith and Simmons (2004) is too high for the FVRS problem (especially in the bigger instances of RockSample), making it almost completely observable.", "startOffset": 78, "endOffset": 103}, {"referenceID": 33, "context": "Note however that monotonicity is not necessary for AEMS to converge to an -optimal solution, as shown in previous work (Ross et al., 2008); boundedness is sufficient.", "startOffset": 120, "endOffset": 139}, {"referenceID": 23, "context": "requires more than 1 GB) before good performance is achieved and requires several thousands episodes before performing well (Paquet, 2006).", "startOffset": 124, "endOffset": 138}, {"referenceID": 23, "context": "The authors of RTBSS have also tried combining their search algorithm with RTDPBel such as to preserve the improvements made by the search (Paquet, 2006).", "startOffset": 139, "endOffset": 153}, {"referenceID": 4, "context": "However, in domains with significant dependencies between state features, it may be useful to use algorithms proposed by Boyen and Koller (1998) and Poupart (2005) to find approximate factored representations where most features are independent, with minimal degradation in the solution quality.", "startOffset": 121, "endOffset": 145}, {"referenceID": 4, "context": "However, in domains with significant dependencies between state features, it may be useful to use algorithms proposed by Boyen and Koller (1998) and Poupart (2005) to find approximate factored representations where most features are independent, with minimal degradation in the solution quality.", "startOffset": 121, "endOffset": 164}, {"referenceID": 9, "context": "To avoid this, we could use the LAO\u2217 algorithm proposed by Hansen and Zilberstein (2001) as an extension of AO\u2217 that can handle generic graph structure, including cyclic graphs.", "startOffset": 59, "endOffset": 89}, {"referenceID": 23, "context": "A good example is the succesful applications of the RTBSS algorithm to the RobocupRescue simulation by Paquet et al. (2005). This environment is very challenging as the state space is orders of magnitude beyond the scope of current algorithms.", "startOffset": 103, "endOffset": 124}], "year": 2008, "abstractText": "Partially Observable Markov Decision Processes (POMDPs) provide a rich framework for sequential decision-making under uncertainty in stochastic domains. However, solving a POMDP is often intractable except for small problems due to their complexity. Here, we focus on online approaches that alleviate the computational complexity by computing good local policies at each decision step during the execution. Online algorithms generally consist of a lookahead search to find the best action to execute at each time step in an environment. Our objectives here are to survey the various existing online POMDP methods, analyze their properties and discuss their advantages and disadvantages; and to thoroughly evaluate these online approaches in different environments under various metrics (return, error bound reduction, lower bound improvement). Our experimental results indicate that state-of-the-art online heuristic search methods can handle large POMDP domains efficiently.", "creator": "dvips(k) 5.96dev Copyright 2007 Radical Eye Software"}}}