{"id": "1401.3849", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend!", "abstract": "description patterns are knowledge representation formalisms that state, for example, the logical underpinning by the w3c owl standards. conjunctive queries, the newer query language algebraic databases, have recently gained significant attention as demonstrating expressive formalism for querying common languages knowledge bases. several different techniques for deciding conjunctive query entailment are available detailing a wide range query dls. nevertheless, the separation of nominals, inverse roles, and number restrictions in owl 1 and owl 2 dl causes unsolvable problems for the techniques hitherto available. we tackle this problem and present query decidability result reflecting entailment of unions of conjunctive queries in l dl alchoiqb that contains all three problematic constructors simultaneously. once that queries contain only two roles, our result often states decidability of entailment of ( unions of ) conjunctive queries in the logic that underpins owl 1 dl and we believe that the presented results generally pave the way for further progress towards conjunctive query entailment decision procedures documenting the actual semantics underlying the owl standards.", "histories": [["v1", "Thu, 16 Jan 2014 04:58:22 GMT  (461kb)", "http://arxiv.org/abs/1401.3849v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["sebastian rudolph", "birte glimm"], "accepted": false, "id": "1401.3849"}, "pdf": {"name": "1401.3849.pdf", "metadata": {"source": "CRF", "title": "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend!", "authors": ["Sebastian Rudolph", "Birte Glimm"], "emails": ["rudolph@kit.edu", "birte.glimm@comlab.ox.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "We present a decidability result for entailment of unions of conjunctive queries in the very expressive Description Logic ALCHOIQb. The article is an extended version of the conference paper Status QIO: Conjunctive Query Entailment is Decidable, Proceedings of the 12th International Conference on the Principles of Knowledge Representation and Reasoning (KR 2010), May 09\u201313, 2010 (Glimm & Rudolph, 2010).\nDescription Logics (DLs) are a family of logic based knowledge representation formalisms (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). Most DLs correspond to the function-free two variable fragment of First-Order Logic (FOL) often extended with counting quantifiers (e.g., \u2200x\u2203\u2264ny(R(x, y))) and DLs are also closely related to the (2- variable) guarded fragment since DL formulae naturally result in guarded formulae when translated into FOL. In line with the restriction to 2 variables, DL formulae contain only unary and binary predicates, which are called concepts and roles in DLs. The constructors for building complex expressions are usually chosen such that the key inference problems, such as concept satisfiability, are decidable. A DL knowledge base (KB) consists of a TBox, which contains intensional knowledge such as concept definitions and general background knowledge (essentially a FOL theory), and an ABox, which contains extensional knowledge and is used to describe individuals (a set of ground facts). Using a database metaphor, the TBox corresponds to the schema, and the ABox corresponds to the data. In contrast to\nc\u00a92010 AI Access Foundation. All rights reserved.\ndatabases, however, DL knowledge bases, as FOL in general, adopt an open world semantics, i.e., they represent information about the domain in an incomplete way.\nStandard DL reasoning services include testing concepts for satisfiability and retrieving certain instances of a given concept. The latter retrieves, for a knowledge base consisting of an ABox A and a TBox T , all (ABox) individuals that are instances of the given (possibly complex) concept expression C, i.e., all those individuals a such that T and A entail that a is an instance of C. The underlying reasoning problems are well-understood, and the computational complexity of the standard reasoning tasks given a knowledge base as input range from PTime-complete for DLs with limited expresivity such as DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), EL (Baader, 2003), and ELP (Kro\u0308tzsch, Rudolph, & Hitzler, 2008) to 2-NExpTime-complete for very expressive DLs such as SROIQ (Kazakov, 2008).\nDespite the high worst case complexity of the standard reasoning problems for very expressive DLs such as SROIQ, there are highly optimized implementations available, e.g., FaCT++ (Tsarkov & Horrocks, 2006), Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007), and HermiT (Motik, Shearer, & Horrocks, 2009). These systems are used in a wide range of applications, e.g., biology (Sidhu, Dillon, Chang, & Sidhu, 2005), bio informatics (Wolstencroft, Brass, Horrocks, Lord, Sattler, Turi, & Stevens, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), information integration (Calvanese, De Giacomo, Lenzerini, Nardi, & Rosati, 1998b), geography (Goodwin, 2005), geology (Jet Propulsion Laboratory, 2006), defense (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005), and configuration (McGuinness & Wright, 1998). Most prominently, DLs are known for their use as a logical underpinning of ontology languages, e.g., OIL, DAML+OIL, the W3C standard OWL 1 (Bechhofer, van Harmelen, Hendler, Horrocks, McGuinness, PatelSchneider, & Stein, 2004), and its successor OWL 2 (W3C OWL Working Group, 2009). There are three species of OWL 1: OWL Lite, OWL DL, and OWL Full. OWL 2 extends OWL 1 and adds three further sublanguages (called OWL 2 profiles): OWL EL, OWL QL, and OWL RL. OWL Lite corresponds to the DL SHIF in which the standard reasoning tasks are ExpTime-complete, OWL 1 DL corresponds to the DL SHOIN , in which the standard reasoning tasks are NExpTime-complete, and OWL 2 DL extends this to the DL SROIQ. For OWL Full the standard reasoning tasks are no longer decidable. The new QL, EL, and RL profiles are more restrictive than OWL DL and each of the profiles trades off different aspects of OWL\u2019s expressive power in return for different computational and/or implementational benefits. OWL EL corresponds to the DL EL ++ (Baader, Brandt, & Lutz, 2005) and the basic reasoning problems can be performed in time that is polynomial with respect to the size of the input knowledge base. OWL 2 QL is based on the DL-Lite family of Description Logics, where the data complexity of conjunctive query entailment is in AC0. Thus, conjunctive query answering can be implemented using standard relational database technology. OWL 2 RL enables the implementation of polynomial time reasoning algorithms using rule-extended database technologies.\nIn data-intensive applications, querying KBs plays a central role. Instance retrieval is, in some aspects, a rather weak form of querying: although possibly complex concept expressions are used as queries, we can only query for tree-like relational structures, as a DL concept cannot express arbitrary cyclic structures. This property is known as the tree model property and is considered an important reason for the decidability of most\nModal and Description Logics (Gra\u0308del, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result. Conjunctive queries (CQs) and unions of conjunctive queries (UCQs) are well known in the database community and constitute an expressive query language with capabilities that go well beyond standard instance retrieval. In FOL terms, CQs and UCQs are formulae from the positive existential fragment. Free variables in a query (not bound by an existential quantifier) are also called answer variables or distinguished variables, whereas existentially quantified variables are called non-distinguished.\nIf the query contains no distinguished variables, the query answer is just true or false and the query is called a Boolean query. Given a knowledge base K and a Boolean UCQ q, the query entailment problem is deciding whether q is true or false w.r.t. K, i.e., we have to decide whether each model of K provides for a suitable assignment for the variables in q. For a query with distinguished variables, the answers to the query are those tuples of individual names (constants) for which the knowledge base entails the query that is obtained by replacing the free variables with the individual names in the answer tuple. These answers are also called certain answers. The problem of finding all answer tuples is known as query answering. We present a decidability result for query entailment, which is a decision problem, but this is no restriction since query answering can easily be reduced to query entailment as we illustrate in more detail in Section 3."}, {"heading": "1.1 Related Work", "text": "Conjunctive queries have been first mentioned in the context of Description Logics (DLs) by Levy and Rousset (1996). The first account of conjunctive queries as main topic is given by Calvanese, De Giacomo, and Lenzerini (1998a). In particular in recent years, the problem of decidability of conjunctive query entailment and the complexity of the problem in different logics has gained significant attention. For the DLs SHIQ and SHOQ decidability and 2-ExpTime-completeness of the problem is known (Glimm, Horrocks, Lutz, & Sattler, 2008a; Glimm, Horrocks, & Sattler, 2008b; Lutz, 2008; Eiter, Lutz, Ortiz, & Simkus, 2009). Conjunctive query entailment is already 2-ExpTime-hard in the relatively weak DL ALCI (Lutz, 2008), which was initially attributed to inverse roles. Recently, it was shown, however, that also transitive roles together with role hierarchies as in the DL SH make conjunctive query entailment 2-ExpTime-hard (Eiter et al., 2009). The techniques by Glimm et al. for SHIQ and SHOQ (Glimm et al., 2008a, 2008b) reduce query entailment to the standard reasoning task of knowledge base satisfiability checking in the DL extended with role conjunctions. An alternative technique is the so-called knots technique (Ortiz, Simkus, & Eiter, 2008b), which is an instance of the mosaic technique originating in Modal Logic. This technique also gives worst-case optimal algorithms for SHIQ and several of its sub-logics. Further, there are automata-based decision procedures for positive existential path queries (Calvanese, Eiter, & Ortiz, 2007, 2009). Positive existential path queries generalize unions of conjunctive queries and, therefore, decision procedures for this kind of query also provides decision procedures for unions of conjunctive queries. In particular the most recent extension (Calvanese et al., 2009) is very close to a conjunctive query entailment decision procedure for OWL 2, which corresponds to the DL SROIQ, because it covers\nSRIQ, SROQ, and SROI. The use of the three problematic constructors for nominals, inverses, and number restrictions is, however, not covered.\nRegarding data complexity, i.e., the complexity with respect to the ABox (the data) only, CQ entailment is usually coNP-complete for expressive logics. For example, for DLs from ALE up to SHIQ this is the case (Glimm et al., 2008a) and this holds also for CQ entailment in the two variable guarded fragment with counting (Pratt-Hartmann, 2009). The latter work is quite closely related since many Description Logics can be translated into the two variable guarded fragment with counting, i.e., the results of Pratt-Hartmann also hold for SHIQ with only simple roles (roles that are not transitive and have no transitive subrole) in the query. Given the same restriction on the query, also SHOQ and SHOI were shown to have coNP-complete data complexity w.r.t. conjunctive query entailment (Ortiz, Calvanese, & Eiter, 2008a).\nQuery entailment and answering have also been studied in the context of databases with incomplete information (Rosati, 2006b; van der Meyden, 1998; Grahne, 1991). In this setting, DLs can be used as schema languages, but the expressivity of the considered DLs is usually much lower than the expressivity of the DL ALCHOIQb that we consider here and reasoning in them is usually tractable. For example, the constructors provided by logics of the DL-Lite family (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007) are chosen such that the standard reasoning tasks are in PTime regarding combined complexity and query entailment is in AC0 with respect to data complexity. Thus, TBox reasoning can be done independently of the ABox and the ABox can be stored and accessed using a standard database SQL engine. Another tractable DL is EL (Baader, 2003). Conjunctive query entailment in EL is, however, not tractable as the complexity increases to coNP-complete (Rosati, 2007b). Moreover for EL++ (Baader et al., 2005), a still tractable extension of EL, query entailment is even undecidable (Kro\u0308tzsch, Rudolph, & Hitzler, 2007). This is mainly because in EL++, one can use unrestricted role compositions. This allows for encoding context-free languages, and conjunctive queries can then be used to check the intersection of such languages, which is known to be an undecidable problem. Since the logics used in databases with incomplete information are considerable less expressive than ALCHOIQb, the techniques developed in that area do not transfer to our setting.\nGiven that query entailment is a (computationally) harder task than, for example, knowledge base satisfiability, it is not very surprising that decidability of the latter task does not necessarily transfer to the problem of CQ entailment. Most of the undecidability results can be transferred from FOL since many DLs can directly be translated into an equivalent FOL theory. For example, it is known that conjunctive query entailment is undecidable in the two variable fragment of First-Order Logic L2 (Rosati, 2007a), and Rosati identifies a relatively small set of constructors that cause the undecidability (most notably role negation axioms, i.e., axioms of the form \u2200x, y (\u00acR(x, y)\u2192 P (x, y)) for R,P binary predicates). Pratt-Hartmann (2009) recently established decidability for CQ entailment in the two variable guarded fragment with counting (GC2). It is worth noting that Pratt-Hartmann assumes that the background theory (that is the knowledge base in our case) is constant free and formulae of the form \u2203=1x(P (x)), which can be used to simulate constants/nominals, are not considered guarded. His result covers, therefore, only the DL ALCHIQb and is not applicable to the case, when the input knowledge base (the background theory) contains nominals (individual constants).\nMost of the implemented DL reasoners, e.g., KAON2,1 Pellet, and RacerPro,2 provide an interface for conjunctive query answering, although KAON2 and RacerPro consider only named individuals in the ABox for the assignments of variables. Under that restriction queries do no longer have the standard FOL semantics and decidability is obviously not an issue since conjunctive query answering with this restriction can be reduced to standard instance retrieval by replacing the variables with individual names from the ABox and then testing entailment of each conjunct separately. Pellet goes beyond that and also provides an interface for conjunctive queries with FOL semantics under the restriction that the queries have a kind of tree shape. Under this restriction decidability is known since CQs can then be expressed as normal concepts (possibly by adding role conjunctions)."}, {"heading": "1.2 Contributions and Overview", "text": "Given all these results, which show a great interest in the problem of conjunctive query entailment over expressive DLs, it is very interesting that for the DLs SHIF , SHOIN , and SROIQ that underpin the widely adopted standards OWL Lite, OWL 1 DL, and OWL 2 DL, respectively, decidability of conjunctive query entailment has only been established for OWL Lite. The main obstacle in devising a decision procedure is the combination of inverse roles (I), nominals (O), and number restrictions/counting quantifiers (F stands for functionality, N for unqualified number restrictions, and Q for qualified number restrictions). The complications arising from the combination of these constructors caused also a major hurdle in the development of implementable algorithms for knowledge base satisfiability in SHOIN and extensions thereof, but Horrocks and Sattler (2005) devised a tableau-based decision procedure that has since been extended to SROIQ. Meanwhile also alternative approaches such as resolution (Kazakov & Motik, 2008), and hypertableau-based procedures (Motik et al., 2009) are available and implemented.\nThe key obstacle in establishing a decision procedure is the existence of potentially infinitely many new nominals, i.e., elements that are uniquely identifiable in any model of a KB. For an example, consider the KB K given in Fig. 1. A concept of the form {o} has to be interpreted as a singleton set, containing only the interpretation of the constant o. For simplicity, we assume for now that a constant is always interpreted as itself, e.g., the interpretation of o is o. An axiom of the form {o1} v \u2203f.\u2203s.\u2203f\u2212.{o2} can then be understood as follows: For the constant o1, there must be two elements, say d1 and d2, such that f(o1, d1), s(d1, d2), and f(o2, d2) holds. Note that o2 occurs as the first element in f(o2, d2) since an inverse role (f\u2212) is used. Thus, an interpretation for the KB must contain the three elements o1, o2, and o3, which must be interconnected in the following way: paths of the shape\nf\u2192 \u00b7 s\u2192 \u00b7 f\u2190 have to lead from o1 to o2 as well as from o2 to o3 and from o3 to o1. Moreover, the role f is defined to be functional, meaning that every element can have at most one f -successor. This also applies to all individuals oi, which forces the existence of an s-cycle. Observe that a cyclic Boolean query such as {s(x, y), s(y, z), s(z, x)} that checks for the existence of such a cycle cannot be answered by applying standard techniques such as replacing variables with individual names (oi) or rewriting the query into an equivalent\n1. http://kaon2.semanticweb.org 2. http://www.racer-systems.com\ntree-shaped query. The elements in the cycle behave as if they were nominals, but we do not have names for them.\nWe tackle the problem of conjunctive query entailment in a very expressive DL that contains all the three problematic constructors simultaneously and prove decidability of (unions of) conjunctive queries. The most challenging part is to establish finite representability of countermodels in case the query given as input is not entailed by the knowledge base. Our results also hold for SHOIQ knowledge bases, i.e., with some roles declared as transitive, provided that the queries contain only simple roles (roles that are neither transitive nor have a transitive subrole). This is essentially the same restriction that is placed on roles that can occur in number restrictions since otherwise the standard reasoning tasks become undecidable. Under this restriction, we can use standard techniques for eliminating transitivity (Kazakov & Motik, 2008). Hence, we also show decidability of conjunctive query entailment in OWL DL, for queries with only simple roles.\nWe believe that our work is also valuable for understanding, in general, the structure of models in DLs that contain nominals, inverse roles, and number restrictions. Furthermore, we devise non-trivial extensions of standard techniques such as unraveling, which we believe will prove useful when working with such expressive DLs.\nThe paper is organized as follows: in Section 2, we give a bird\u2019s-eye view of the techniques and ideas used to establish decidability. In Section 3, we give the necessary definitions and introduce standard notations. In Sections 4, 5, and 6 we present the main results that we then use in Section 7 to show how models that do not satisfy the query can be finitely represented before we conclude in Section 8."}, {"heading": "2. The Big Picture", "text": "Before going into the technical details, we will describe our overall line of argumentation establishing decidability of conjunctive query entailment in ALCHOIQb."}, {"heading": "2.1 Decidability via Finitely Representable Countermodels", "text": "Let K be an ALCHOIQb knowledge base and let q be the conjunctive query in question, i.e., we aim to determine whether\nK |= q.\nClearly, as ALCHOIQb is a fragment of first-order predicate logic with equality, K can be translated into a FOL sentence FOL(K). Likewise we find a FOL sentence FOL(q) for\nq being just an existentially quantified formula. Hence, checking the above entailment is equivalent to determining whether the first-order theory FOL(K) entails FOL(q). As a result of the completeness theorem for FOL (Go\u0308del, 1929), the consequences of a finite FOL theory are recursively enumerable, which provides us with a procedure that terminates if K |= q. Hence, we can establish decidability by providing another algorithm that terminates iff the entailment above does not hold \u2013 i.e., if there is a so-called countermodel being a model I of K for which I 6|= q.\nWe will provide such an algorithm by showing that, whenever such a countermodel I exists at all, there is also a countermodel I that is finitely representable. More precisely, I can be encoded into a word Rep(I) of finite length over a finite alphabet, whereby the encoding Rep has the property that for every such finite word it can be effectively checked whether it represents a countermodel for a given knowledge base and query.\nAs a consequence thereof, we can create the desired algorithm that enumerates all words, checks each for being a countermodel, and terminates as soon as it has found one."}, {"heading": "2.2 Finite Representability by Bounding Nominals and Blocking", "text": "We now outline how we are going to show that there is always a finitely representable countermodel, if there is one at all. We do this by taking an arbitrary countermodel and cautiously transforming it into a countermodel that is finitely representable. Cautiously means that we have to make sure that the transformation does preserve the two properties of 1) being a model of the underlying knowledge base K and 2) not entailing the considered query q.\nThe result of the overall transformation is going to be a regular model, i.e., a structure where substructures are being in a certain sense periodically repeated. It is common practice in DL theory to construct this kind of models from arbitrary ones by blocking techniques, whereby certain element configurations occurring twice in the original model are detected and the new model is generated by infinitely stringing together the same finite substructure that is delimited by those two configurations.\nIn the case we consider, this technique cannot be applied directly to the original countermodel. This is due to an intricate interplay of nominals, inverse roles and cardinality constraints by which an arbitrary \u2013 even an infinite \u2013 number of domain elements can be forced to \u201cbehave\u201d like nominals; this is why those elements are usually referred to as new nominals in a DL setting. In FOL, nominals are often called kings and the new nominals are called the court. In our case, the presence of infinitely many new nominals in the model may prevent the existence of repeated configurations needed for blocking.\nWe overcome this difficulty by first applying a transformation by means of which the original countermodel is converted into a countermodel with only finitely many new nominals. This guarantees that the subsequent blocking-based transformation is applicable and will yield the desired regular (and thus finitely representable) model."}, {"heading": "2.3 Bounding Nominals by Transformations of Forest Quasi-Models", "text": "For our argumentation, we introduce the notion of forest quasi-models. These are structures not satisfying the originally considered knowledge base but a weakened form of it. In\nreturn to this concession, they exhibit a proper forest structure that is easier to handle and manipulate.\nWe employ two techniques to turn \u201cproper\u201d models into forest quasi-models and vice versa: a model can be unraveled yielding a forest quasi-model. A forest quasi-model can be collapsed to obtain a \u201cproper\u201d model. Both techniques preserve certain structural properties.\nOur strategy to construct a countermodel with finitely many nominals consists of the following three steps:\n\u2022 Take an arbitrary countermodel and unravel it.\n\u2022 Transform the obtained forest quasi-model by substituting critical parts by wellbehaved ones,\n\u2022 Collapse the obtained structure into a (proper) model.\nThe mentioned \u201ccritical parts\u201d are those giving rise to new nominals. They have to be \u2013 at least largely \u2013 avoided (we do not care about a finite set of those critical parts remaining).\nThe central question is: where do these mysterious well-behaved substitutes come from? Fortunately, the plethora of critical parts brings about its own remedy. We can use infinite sets of critical parts to construct well-behaved ones in an infinite approximation process (this is why infinity is your friend). We thereby obtain parts which have not been present in our structure before, but are well compatible with it and can hence be used for its reorganization.\nAfter having informally introduced our main line of argumentation, we now move on to the technical details."}, {"heading": "3. Preliminaries", "text": "We first define the syntax and semantics of roles, and then go on to SHOIQb-concepts, individuals, and knowledge bases. We do not actually use the full expressivity of SHOIQb, but it is a convenient umbrella for all DLs we are working with and we can define less expressive DLs of interest as restrictions of SHOIQb.\nDefinition 1 (Syntax of SHOIQb). Let NC , NR, and NI be countable, infinite, and pairwise disjoint sets of concept names, role names, and individual names, respectively. We call S = (NC ,NR,NI ) a signature. The set rol(S) of SHOIQb-roles over S (or roles for short) is NR \u222a {r\u2212 | r \u2208 NR}, where roles of the form r\u2212 are called inverse roles. A role inclusion axiom is of the form r v s with r, s roles. A transitivity axiom is of the form trans(r) for r a role. A role hierarchy H is a finite set of role inclusion and transitivity axioms.\nFor a role hierarchy H, we define the function inv over roles as inv(r) := r\u2212 if r \u2208 NR and inv(r) := s if r = s\u2212 for a role name s \u2208 NR. Further, we define vH as the smallest transitive reflexive relation on roles such that r v s \u2208 H implies r vH s and inv(r) vH inv(s). We write r \u2261H s if r vH s and s vH r. A role r is transitive w.r.t. H (notation r+ vH r) if a\nrole s exists such that r vH s, s vH r, and trans(s) \u2208 H or trans(inv(s)) \u2208 H. A role s is called simple w.r.t. H if there is no role r such that r is transitive w.r.t. H and r vH s.\nFor r \u2208 rol(S) a simple role, a Boolean role expressions U is defined as follows:"}, {"heading": "U ::= r | \u00acU | U u U | U t U.", "text": "We use ` to denote standard Boolean entailment between a set of roles R \u2286 rol(S) and role expressions. Let r \u2208 rol(S), and U a Boolean role expression over R. We inductively define:\n\u2022 R ` r if r \u2208 R, and R 6` r otherwise,\n\u2022 R ` \u00acU if R 6` U , and R 6` \u00acU otherwise,\n\u2022 R ` U u V if R ` U and R ` V , and R 6` U u V otherwise,\n\u2022 R ` U t V if R ` U or R ` V , and R 6` U t V otherwise.\nA Boolean role expression U is safe if \u2205 6` U . Given a signature S = (NC , NR, NI ), the set of SHOIQb-concepts (or concepts for short) over S is the smallest set built inductively over symbols from S using the following grammar, where o \u2208 NI , A \u2208 NC , n \u2208 IN0, s is a simple role, and U is a role or a safe Boolean role expression:\nC ::= > | \u22a5 | {o} | A | \u00acC | C1 u C2 | C1 t C2 | \u2200U.C | \u2203U.C | 6n s.C | >n s.C. 4\nAlternatively, safeness can be characterized as follows: a Boolean role expression U is safe if, after transforming it into disjunctive normal form, each disjunct contains at least one non-negated role. Intuitively, this implies that a safe role expression can never relate individuals that are not in a direct role relation with each other.\nDefinition 2 (Semantics of SHOIQb-concepts). An interpretation I = (\u2206I , \u00b7I) consists of a non-empty set \u2206I , the domain of I, and a function \u00b7I , which maps every concept name A \u2208 NC to a subset AI \u2286 \u2206I , every role name r \u2208 NR to a binary relation rI \u2286 \u2206I \u00d7\u2206I , and every individual name a \u2208 NI to an element aI \u2208 \u2206I . For each role name r \u2208 NR, the interpretation of its inverse role (r\u2212)I consists of all pairs \u3008\u03b4, \u03b4\u2032\u3009 \u2208 \u2206I \u00d7\u2206I for which \u3008\u03b4\u2032, \u03b4\u3009 \u2208 rI .\nThe semantics of SHOIQb-concepts over a signature S is defined as follows:\n(\u00acr)I = \u2206I \u00d7\u2206I \\ rI (r1 u r2)I = rI1 \u2229 rI2 (r1 t r2)I = rI1 \u222a rI2 >I = \u2206I \u22a5I = \u2205 ({o})I = {oI}\n(\u00acC)I = \u2206I \\ CI (C uD)I = CI \u2229DI (C tD)I = CI \u222aDI (\u2200U.C)I = {\u03b4 \u2208 \u2206I | if \u3008\u03b4, \u03b4\u2032\u3009 \u2208 UI , then \u03b4\u2032 \u2208 CI} (\u2203U.C)I = {\u03b4 \u2208 \u2206I | there is a \u3008\u03b4, \u03b4\u2032\u3009 \u2208 UI with \u03b4\u2032 \u2208 CI}\n(6n s.C)I = {\u03b4 \u2208 \u2206I | ](sI(\u03b4, C)) \u2264 n} (>n s.C)I = {\u03b4 \u2208 \u2206I | ](sI(\u03b4, C)) \u2265 n}\nwhere ](M) denotes the cardinality of the set M and sI(\u03b4, C) is defined as\n{\u03b4\u2032 \u2208 \u2206I | \u3008\u03b4, \u03b4\u2032\u3009 \u2208 sI and \u03b4\u2032 \u2208 CI}.\nA concept C is in negation normal form (NNF) if negation occurs only in front of concept names and we use nnf(C) to denote the negation normal form of a concept C. 4\nAny concept can be transformed in linear time into an equivalent one in NNF by pushing negation inwards, making use of de Morgan\u2019s laws and the duality between existential and universal restrictions, and between at-most and at-least number restrictions of the form 6n r.C and > n r.C respectively (Horrocks, Sattler, & Tobies, 2000).\nDefinition 3 (Syntax and Semantics of Axioms and Knowledge Bases). A functionality restriction is an expression func(f) for f a role. For C,D concepts, a general concept inclusion (GCI) is an expression C v D. We introduce C \u2261 D as an abbreviation for C v D and D v C. A finite set of GCIs and functionality restrictions is called a TBox. An (ABox) assertion is an expression of the form C(a), r(a, b), \u00acr(a, b), a .= b, or a 6 .= b, where C is a concept, r is a role, and a, b \u2208 NI are individual names. An ABox is a finite set of assertions. A knowledge base K is a triple (T , H, A) with T a TBox, H a role hierarchy, and A an ABox.\nWe use con(K), rol(K), and nom(K) to denote, respectively, the set of concept names, roles (including inverses), and individual names occurring in K. The closure cl(K) of K is the smallest set containing nnf(\u00acC t D) if C v D \u2208 T ; D if D is a sub-concept of C and C \u2208 cl(K); and nnf(\u00acC) if C \u2208 cl(K). A role f is functional in K if K contains the functionality axiom func(f) and it is inverse functional in K if K contains the functionality axiom func(inv(f)).\nLet I = (\u2206I , \u00b7I) be an interpretation. Then I satisfies a role inclusion axiom r v s if rI \u2286 sI , I satisfies a transitivity axiom trans(r) if rI is a transitive binary relation, and a role hierarchy H if it satisfies all role inclusion and transitivity axioms in H. The interpretation I satisfies a functionality restriction func(f) if, for each \u03b4 \u2208 \u2206I , ]({\u03b4\u2032 | \u3008\u03b4, \u03b4\u2032\u3009 \u2208 fI}) \u2264 1; I satisfies a GCI C v D if CI \u2286 DI ; and I satisfies a TBox T if it satisfies each functionality restriction and each GCI in T . The interpretation I satisfies an assertion C(a) if aI \u2208 CI , r(a, b) if \u3008aI , bI\u3009 \u2208 rI , \u00acr(a, b) if \u3008aI , bI\u3009 /\u2208 rI , a .= b if aI = bI , and a 6 .= b if aI 6= bI ; I satisfies an ABox if it satisfies each assertion in A. We say that I satisfies K if I satisfies T , H, and A. In this case, we say that I is a model of K and write I |= K. We say that K is consistent if K has a model. 4\nIf the knowledge base K is clear from the context, we simply say that a role f is (inverse) functional instead of saying f is (inverse) functional in K.\nThe names of DLs indicate which constructors are supported. The basic DL ALC supports Boolean concept constructors and GCIs, but no role hierarchies, functionality restrictions et cetera. If transitivity axioms are added, we use S instead of ALC. Inverse roles are indicated by the letter I, role inclusion axioms by H, nominals, i.e., concepts of the form {o} for o \u2208 NI , by O, functionality restrictions by F , qualified number restrictions, i.e., concepts of the form 6n s.C and > n s.C, by Q, and safe Boolean role expressions by b. If number restrictions are limited to concepts of the form 6n s.> and >n s.>, we use the letter N .\nWe mostly refer to a few particular DLs in this paper: the DL SHOIQ is obtained from SHOIQb by disallowing Boolean role expressions. The DLs SHIQ, SHOQ, and SHOI are obtained from SHOIQ by disallowing nominals, inverse roles, and number restrictions (incl. functionality restrictions), respectively. Finally, the DL ALCOIFb is obtained from SHOIQb by disallowing transitivity axioms (we use ALC instead of S in the name of the DL to indicate this), role inclusion axioms, and concepts of the form 6n s.C and >n s.C."}, {"heading": "3.1 Conjunctive Queries and Unions of Conjunctive Queries", "text": "We now introduce Boolean conjunctive queries since they are the basic form of queries we are concerned with. We later also define non-Boolean queries and show how they can be reduced to Boolean queries. Finally, unions of conjunctive queries are just a disjunction of conjunctive queries.\nDefinition 4 (Syntax and Semantics of Conjunctive Queries). Let S = (NC ,NR,NI ) be a signature and NV a countably infinite set of variables disjoint from NC , NR, and NI . A term t is an element from NV \u222a NI . Let A \u2208 NC be a concept name, r \u2208 NR a role name, and t, t\u2032 terms. An atom is an expression A(t) or r(t, t\u2032) and we refer to these two types of atoms as concept atoms and role atoms respectively. A Boolean conjunctive query q is a non-empty set of atoms. We use var(q) to denote the set of (existentially quantified) variables occurring in q and term(q) to denote the set of variables and individual names occurring in q. As usual, we use ](q) to denote the cardinality of q, which is simply the number of atoms in q, and we use |q| for the size of q, i.e., the number of symbols necessary to write q.\nLet I = (\u2206I , \u00b7I) be an interpretation. A total function \u03c0 : term(q)\u2192 \u2206I is an evaluation if \u03c0(a) = aI for each individual name a occurring in q. For A(t), r(t, t\u2032) atoms, we write\n\u2022 I |=\u03c0 A(t) if \u03c0(t) \u2208 AI ;\n\u2022 I |=\u03c0 r(t, t\u2032) if (\u03c0(t), \u03c0(t\u2032)) \u2208 rI .\nIf, for an evaluation \u03c0, I |=\u03c0 At for all atoms At \u2208 q, we write I |=\u03c0 q. We say that I satisfies q and write I |= q if there exists an evaluation \u03c0 such that I |=\u03c0 q. We call such a \u03c0 a match for q in I.\nLet K be a knowledge base and q a conjunctive query. If I |= K implies I |= q, we say that K entails q and write K |= q. 4\nThe query entailment problem is defined as follows: given a knowledge base K and a query q, decide whether K |= q.\nDefinition 5 (Unions of Conjunctive Queries). A union of Boolean conjunctive queries is a formula q1 \u2228 . . . \u2228 qn, where each disjunct qi is a Boolean conjunctive query.\nA knowledge base K entails a union of Boolean conjunctive queries q1\u2228 . . .\u2228 qn, written as K |= q1 \u2228 . . .\u2228 qn, if, for each interpretation I such that I |= K, there is some i such that I |= qi and 1 \u2264 i \u2264 n. 4\nWe now clarify the connection between query entailment and query answering. For query answering, let the variables of a conjunctive query be typed: each variable can either be existentially quantified (also called non-distinguished) or free (also called distinguished or answer variables). Let q be a query in n variables (i.e., ](var(q)) = n), of which v1, . . . , vm (m \u2264 n) are answer variables. The answers of K to q are those m-tuples (a1, . . . , am) of individual names such that, for all models I of K, I |=\u03c0 q for some \u03c0 that satisfies \u03c0(vi) = aIi for all i with 1 \u2264 i \u2264 m. Recall that we use nom(K) to denote the set of individual names occurring in K (in the form of nominals or ABox individuals). It is not hard to see (cf. Chandra & Merlin, 1977) that the answers of K to q can be computed by testing, for each\n(a1, . . . , am) \u2208 nom(K)m, whether the query q[v1,...,vm/a1,...,am] obtained from q by replacing each occurrence of vi with ai for 1 \u2264 i \u2264 m is entailed by K. The set of certain answers to q is then the set of all m-tuples (a1, . . . , am) for which K |= q[v1,...,vm/a1,...,am]. Let k = ](nom(K)) be the number of individual names occurring in K. Since K is finite, clearly k is finite. Hence, deciding which tuples belong to the set of answers can be checked with at most km entailment tests.\nThe algorithm that we present in this paper decides query entailment. The reasons for devising a decision procedure for query entailment instead of query answering are twofold: first, query answering can be reduced to query entailment as shown above; second, in contrast to query answering, query entailment is a decision problem and can be studied in terms of complexity theory."}, {"heading": "3.2 Simplifying Assumptions", "text": "In the following, we make several assumptions that are without loss of generality, but simplify the presentation of the decision procedure.\n3.2.1 From SHOIQ and ALCHOIQb to simplified ALCOIFb Knowledge Bases\nIn the following, we only work with ALCOIFb knowledge bases. Nevertheless, our results also hold for SHOIQ knowledge bases and queries with only simple roles in the query and for ALCHOIQb knowledge bases, i.e., when the knowledge base contains safe Boolean role expressions, but no transitivity. The restriction to ALCOIFb is without loss of generality, as we show now.\nProvided the query contains only simple roles, we can use the elimination techniques for transitivity (Kazakov & Motik, 2008) to reduce a SHOIQ knowledge base to anALCHOIQ knowledge base with extended signature. We can further eliminate qualified number restrictions and role inclusion axioms by transforming an ALCHOIQb knowledge base into an ALCOIFb knowledge base that is equivalent to the original one up to an extension of the signature (Rudolph, Kro\u0308tzsch, & Hitzler, 2008). We do not repeat a formal proof here, but rather give an informal argument as to how this reduction works.\nWe assume that the knowledge base is in negation normal form, i.e., all GCIs are of the form > v C with C a concept in NNF. Now, consider a concept expression of the form > n r.C with r a role and C a concept. This means that there are at least n distinct rneighbors satisfying C. However, this situation can be enforced by introducing n new roles r1, . . . , rn each of which is deemed to have r as a superrole (ri v r) and which are pairwise disjoint (> v \u2200(ri u rj).\u22a5). Under those \u201cside conditions\u201d, the above concept expression can be replaced by \u2203r1.C u . . . u \u2203rn.C.\nA somewhat dual argumentation is possible for concept expressions of the form 6n r.C restricting the number of r-neighbors satisfying C to at most n. Again we extend the signature by introducing new roles r1, . . . , rn, but this time, we let them \u201ccover\u201d all outgoing r-links in the following sense: whenever an r-link leads to some domain element \u03b4 which satisfies C, then one of the roles r1, . . . , rn also leads there. Indeed, safe Boolean role expressions allow for expressing this correspondence via the concept description \u2200(ru\u00acr1u . . . u \u00acrn).\u00acC. It is now easy to see, that this concept expression can replace the above if we additionally demand all roles r1, . . . , rn to be functional.\n{o} v \u2203r.A A v \u2203r.A A v \u2203s.B\nfunc(f\u2212) func(g\u2212) B v C tD\nC v \u2203f.E D v \u2203g.E E v B t {o}\nFinally consider a role hierarchy statement r v s, stating that whenever two domain elements \u03b41 and \u03b42 are connected by role r, they are also interconnected via s. Clearly, this statement can be reformulated as: there are no two domain elements connected by r and by \u00acs. This, in turn, can be equivalently rephrased by saying that no domain element has an r u \u00acs-neighbor or, expressed as GCI, > v \u2200(r u \u00acs).\u22a5.\nThese transformations can be applied to an ALCHOIQb knowledge base, whereby all cardinality constraints and role inclusion axioms are eliminated. This leaves us with an equivalent ALCOIFb knowledge base up to an extension of the signature.\nFigure 2 displays an ALCOIFb knowledge base and an according model, which we will refer to as a running example throughout the paper.\nFurthermore, we assume that the ABox is internalized (e.g., C(a) is replaced by the equivalent GCI {a} v C, r(a, b) by {a} v \u2203r.{b}, etc.). Thus, we effectively decide query entailment with respect to a TBox only since knowledge bases in this setting have an empty ABox.\nFor T an ALCOIFb TBox, it is always possible to transform T into an equivalent TBox T \u2032 up to signature extension such that all GCIs in T \u2032 have one of the following simplified forms:\nl Ai v \u2294 Bj | A \u2261 {o} | A v \u2200U.B | A v \u2203U.B | func(f), (1)\nwhere A(i) and B(j) are concept names, o is an individual name, U is a safe Boolean role expression, and f is a role. If i = 0, we interpret d Ai as > and if j = 0, we interpret \u2294 Bj as \u22a5. An ALCOIFb knowledge base K = (T ,A) is simplified if T is simplified and A is empty. Every ALCOIFb knowledge base, which is not in this form, can be transformed in polynomial time into the desired form by using the standard structural transformation, which iteratively introduces definitions for compound sub-concepts (Kazakov & Motik, 2008). Thus, we assume in the remainder that any knowledge base is rewritten into a simplified ALCOIFb knowledge base."}, {"heading": "3.2.2 Connected and Constant-free Queries", "text": "We assume that queries are connected. More precisely, let q be a conjunctive query. We say that q is connected if, for all t, t\u2032 \u2208 term(q), there exists a sequence t1, . . . , tn such that t1 = t, tn = t\u2032 and, for all 1 \u2264 i < n, there exists a role name r such that r(ti, ti+1) \u2208 q or r(ti+1, ti) \u2208 q. A collection q1, . . . , qn of queries is a partitioning of q if q = q1 \u222a . . . \u222a qn, term(qi) \u2229 term(qj) = \u2205 for 1 \u2264 i < j \u2264 n, and each qi is connected.\nLemma 6. Let K be a knowledge base, q a conjunctive query, and q1, . . . , qn a partitioning of q. Then K |= q iff K |= qi for each i with 1 \u2264 i \u2264 n.\nA proof is given by Tessaris (2001) and, with this lemma, it is clear that the restriction to connected queries is indeed without loss of generality since entailment of q can be decided by checking entailment of each qi at a time. In what follows, we therefore assume queries to be connected without further notice.\nIn unions of conjunctive queries, we assume that the variable names in each disjunct are different from the variable names in the other disjuncts. This can always be achieved by naming variables apart. We further assume that each disjunct in a UCQ is a connected conjunctive query. This is without loss of generality since a UCQ which contains unconnected disjuncts can always be transformed into conjunctive normal form; we can then decide entailment for each resulting conjunct separately and each conjunct is a union of connected conjunctive queries (Glimm et al., 2008a). Note that, due to the transformation into conjunctive normal form, the resulting number of unions of connected conjunctive queries for which we have to test entailment can be exponential in the size of the original query.\nWe further assume that queries do not contain constants (individual names) to occur in the position of variables. In the presence of nominals this is without loss of generality: for each individual name a occurring in q, we extend the knowledge base K with the axioms {a} \u2261 Na for Na \u2208 NC a fresh concept name, and replace each occurrence of a in q with a fresh variable xa \u2208 NV and add a concept atom Na(xa) to q."}, {"heading": "3.2.3 General Notation", "text": "Throughout this paper, concept names and role expressions are written in upper case, while roles and individual names are written in lower case. Unless stated otherwise, we use A and B for concept names; C and D for possibly complex concepts; r and s for roles, f for functional or inverse functional roles; U and V for safe Boolean role expressions; and o for nominals that are used in TBox axioms or that occur in complex concepts. Sub- and superscripts might be appended if necessary. If not stated otherwise, we use q (possibly with subscripts) for a connected Boolean conjunctive query, K for a simplified ALCOIFb knowledge base, I for an interpretation (\u2206I , \u00b7I), and \u03c0, \u00b5 for evaluations."}, {"heading": "4. Model Construction", "text": "In this section, we introduce interpretations and models that have a kind of forest shape. The main notion of a forest is, however, very weak since we do also allow for arbitrary relations between tree elements and roots. Without such relations, we call the result a strict forest. We exploit the nice properties of trees and forests in the following sections,\nwhen we replace parts in interpretations that give rise to an infinite number of new nominals. Since even models of an ALCOIFb knowledge base that have a kind of forest shape are not really forests, we also introduce \u201capproximations\u201d of models in which nominals are no longer interpreted as singleton sets. We call these structures quasi-interpretations or quasi-models and such interpretations can have the form of real forests. Further, we provide a way of \u201cunraveling\u201d an arbitrary model into a forest that is a quasi-model for the knowledge base and a way of \u201ccollapsing\u201d such forest quasi-models back into real models of the knowledge base that still have a kind of forest shape.\nDefinition 7 (Forest (Quasi-)Interpretations and (Quasi-)Models). A tree T is a nonempty, prefix-closed subset of IN\u2217. For w,w\u2032 \u2208 T , we call w\u2032 a successor of w if w\u2032 = w \u00b7 c for some c \u2208 IN, where \u201c\u00b7\u201d denotes concatenation. We call w\u2032 a predecessor of w if w = w\u2032 \u00b7c for some c \u2208 IN, and w\u2032 is a neighbor of w if w\u2032 is a successor of w or vice versa. The empty word \u03b5 is called the root of the tree. We use |w| to denote the length of w.\nA forest F is a subset of R\u00d7IN\u2217, where R is a countable, possibly infinite set of elements such that, for each \u03c1 \u2208 R, the set {w | (\u03c1, w) \u2208 F} is a tree. Each pair (\u03c1, \u03b5) \u2208 F is called a root of F . For (\u03c1, w), (\u03c1\u2032, w\u2032) \u2208 F , we call (\u03c1\u2032, w\u2032) a successor of (\u03c1, w) if \u03c1\u2032 = \u03c1 and w\u2032 is a successor of w; (\u03c1\u2032, w\u2032) is a predecessor of (\u03c1, w) if \u03c1\u2032 = \u03c1 and w\u2032 is a predecessor of w; (\u03c1\u2032, w\u2032) is a neighbor of (\u03c1, w) if (\u03c1\u2032, w\u2032) is a successor of (\u03c1, w) or vice versa. A node (\u03c1, w) is an ancestor of a node (\u03c1\u2032, w\u2032) if \u03c1 = \u03c1\u2032 and w is a prefix of w\u2032 and it is a descendant if \u03c1 = \u03c1\u2032 and w\u2032 is a prefix of w.\nA forest interpretation of a knowledge base K is an interpretation I = (\u2206I , \u00b7I) that satisfies the following conditions:\nFI1 \u2206I is a forest with roots R;\nFI2 there is a total and surjective function \u03bb : nom(K)\u2192 R \u00d7 {\u03b5} such that \u03bb(o) = (\u03c1, \u03b5) iff oI = (\u03c1, \u03b5);\nFI3 for each role r \u2208 rol(K), if \u3008(\u03c1, w), (\u03c1\u2032, w\u2032)\u3009 \u2208 rI , then either\n(a) w = \u03b5 or w\u2032 = \u03b5, or\n(b) (\u03c1, w) is a neighbor of (\u03c1\u2032, w\u2032).\nIf I |= K, we say that I is a forest model for K. If \u2206I has a single root, we call I a tree interpretation and a tree model for K, respectively.\nLet K be an ALCOIFb knowledge base. With nomFree(K), we denote the ALCIFb knowledge base obtained from K by replacing each nominal concept {o} with o \u2208 nom(K) with a fresh concept name No. A forest quasi-interpretation for K is an interpretation J = (\u2206J , \u00b7J ) of nomFree(K) that satisfies the following properties:\nFQ1 \u2206J is a forest with roots R;\nFQ2 there is a total and surjective function \u03bb : nom(K)\u2192 R \u00d7 {\u03b5} such that \u03bb(o) = (\u03c1, \u03b5) iff (\u03c1, \u03b5) \u2208 NJo\nFQ3 for each role r \u2208 rol(K), if \u3008(\u03c1, w), (\u03c1\u2032, w\u2032)\u3009 \u2208 rI , then either\n(a) w = \u03b5 or w\u2032 = \u03b5, or\n(b) (\u03c1, w) is a neighbor of (\u03c1\u2032, w\u2032).\nNote that condition FQ2 allows for elements (\u03c1, w) \u2208 \u2206J with w 6= \u03b5 such that (\u03c1, w) \u2208 NJo . We call J strict if in condition FQ3, only FQ3(b) is allowed. If J |= nomFree(K) we say that J is a forest quasi-model for K.\nThe branching degree d(w) of a node w in a tree T is the number of successors of w. Let I = (\u2206I , \u00b7I) be a forest (quasi) interpretation for K. If there is a k such that d(w) \u2264 k for each (\u03c1, w) \u2208 \u2206I , then we say that I has branching degree k. 4\nIn the remainder, when we use the concept name No, we mean the fresh concept name that was introduced in nomFree(K) for the nominal concept {o} with o \u2208 nom(K). Elements in the extension of a concept No are called nominal placeholders. Please note that, in a forest quasi-interpretations J , we can have several elements (\u03c1, w) with w 6= \u03b5 such that (\u03c1, w) \u2208 NJo .\nIn the following, we define a notion of isomorphism between forest interpretations. Note that we demand not only structural identity w.r.t. concepts and roles but also w.r.t. the successor relation.\nDefinition 8 (Isomorphism between Forest Interpretations). Let I, I \u2032 be two forest interpretations of K with \u03b41, \u03b42 \u2208 \u2206I , \u03b4\u20321, \u03b4\u20322 \u2208 \u2206I \u2032 . The pairs \u3008\u03b41, \u03b42\u3009, \u3008\u03b4\u20321, \u03b4\u20322\u3009 are isomorphic w.r.t. K, written \u3008\u03b41, \u03b42\u3009 \u223c=K \u3008\u03b4\u20321, \u03b4\u20322\u3009 iff\n1. \u3008\u03b41, \u03b42\u3009 \u2208 rI iff \u3008\u03b4\u20321, \u03b4\u20322\u3009 \u2208 rI \u2032 for each r \u2208 rol(K),\n2. \u03b4i \u2208 AI iff \u03b4\u2032i \u2208 AI \u2032 for i \u2208 {1, 2} and each A \u2208 con(K),\n3. \u03b4i = oI iff \u03b4\u2032i = o I\u2032 for i \u2208 {1, 2} and each o \u2208 nom(K).\nWe say that I and I \u2032 are isomorphic w.r.t. K, written: I \u223c=K I \u2032, if there is a bijection \u03d5 : \u2206I \u2192 \u2206I\u2032 such that, for each \u03b41, \u03b42 \u2208 \u2206I , \u3008\u03b41, \u03b42\u3009 \u223c=K \u3008\u03d5(\u03b41), \u03d5(\u03b42)\u3009 and \u03b41 is a successor of \u03b42 iff \u03d5(\u03b41) is a successor of \u03d5(\u03b42). 4\nIf clear from the context, we omit the subscript K of \u223c=K. We extend the above definition in the obvious way to forest quasi-interpretations, i.e., by omitting condition 3 and defining the isomorphism with respect to K\u2032 = nomFree(K).\nForest quasi-models have, intuitively, the purpose of an intermediate step between arbitrary models of K and forest models of K. When identifying each \u03b4 in the interpretation of a concept No in the knowledge base K\u2032 with a root that is in the interpretation of No, we obtain an interpretation that would be a model for K apart from functionality restrictions for some nominals that might be violated. We show later how we can eliminate those relations from the forest back to the roots that violate functionality restrictions and how we can eventually obtain a forest model from a forest quasi-model.\nAnother useful property of quasi-interpretations is that, for simplified ALCIFb knowledge bases, it can be checked locally whether an interpretation I is actually a model of K.\nDefinition 9 (Local K-consistency). Let I = (\u2206I , \u00b7I) be an interpretation for a simplified ALCIFb knowledge base K with \u03b4 \u2208 \u2206I . We define local satisfaction for \u03b4 and concepts that can occur in simplified ALCIFb axioms as follows:\n1. for A1, . . . , An \u2208 con(K):\n(a) I, \u03b4 |= d Ai if \u03b4 \u2208 AIi for each i with 1 \u2264 i \u2264 n; I, \u03b4 6|= d Ai otherwise;\n(b) I, \u03b4 |= \u2294 Ai if \u03b4 \u2208 AIi for some i with 1 \u2264 i \u2264 n; I, \u03b4 6|= \u2294 Ai otherwise;\n2. for U a safe Boolean role expression over rol(K), A \u2208 con(K):\n(a) I, \u03b4 |= \u2203U.A if there is some \u03b4\u2032 \u2208 \u2206I such that \u3008\u03b4, \u03b4\u2032\u3009 \u2208 UI and I, \u03b4\u2032 |= A; I, \u03b4 6|= \u2203U.A otherwise;\n(b) I, \u03b4 |= \u2200U.A if, for each \u03b4\u2032 \u2208 \u2206I such that \u3008\u03b4, \u03b4\u2032\u3009 \u2208 UI , I, \u03b4\u2032 |= A; I, \u03b4 6|= \u2200U.A otherwise;\n3. for f \u2208 rol(K), I, \u03b4 |= func(f) if ]({\u03b4\u2032 \u2208 \u2206I | \u3008\u03b4, \u03b4\u2032\u3009 \u2208 fI}) \u2264 1; I, \u03b4 6|= func(f) otherwise.\nAn element \u03b4 \u2208 \u2206I locally satisfies a GCI C v D with C,D ALCIFb-concepts if I, \u03b4 |= C implies I, \u03b4 |= D. It locally satisfies a functionality restriction func(f) if I, \u03b4 |= func(f). An element \u03b4 \u2208 \u2206I is locally K-consistent if it locally satisfies each axiom in K. 4\nLemma 10. Let K be a simplified ALCIFb knowledge base and I = (\u2206I , \u00b7I) an interpretation for K. Then I is a model for K iff each element \u03b4 \u2208 \u2206I is locally K-consistent.\nProof. For simplified ALCIFb knowledge bases, only axioms of the form A v \u2200U.B and A v \u2203U.B involve checking neighbors of an element \u03b4 and, since B is a concept name in simplified knowledge bases, it is immediate that satisfaction of B can be checked locally for the neighbor of \u03b4 in question.\nFor a knowledge base K with nominals, we can also use local K-consistency, but we need an additional global condition that ensures that nominals are interpreted as singleton sets. The following is an immediate consequence of Lemma 10 and the extra condition 2 for nominals:\nProposition 11. Let K be a simplified ALCOIFb knowledge base and I = (\u2206I , \u00b7I) an interpretation for K. Then I is a model for K iff\n1. each element \u03b4 \u2208 \u2206I is locally K-consistent and,\n2. for each o \u2208 nom(K), there is exactly one element \u03b4 \u2208 \u2206I such that oI = \u03b4.\nWe now show how we can obtain a forest quasi-model from a model of K by using an adapted version of unraveling.\nDefinition 12 (Unraveling). Let K be a consistent ALCOIFb knowledge base and I = (\u2206I , \u00b7I) a model for K. Let choose be a function that returns, for a concept C = \u2203U.B \u2208 cl(K) and an element \u03b4 \u2208 (\u2203U.B)I an element \u03b4C,\u03b4 \u2208 \u2206I such that \u3008\u03b4, \u03b4C,\u03b4\u3009 \u2208 UI and \u03b4C,\u03b4 \u2208 BI .\nWithout loss of generality, we assume that, for all \u03b4 \u2208 \u2206I and concepts C1 = \u2203U1.B1, C2 = \u2203U2.B2 \u2208 cl(K) such that \u03b4 \u2208 CI1 \u2229 CI2 , if choose(C1, \u03b4) = \u03b41, choose(C2, \u03b4) = \u03b42, and \u3008\u03b4, \u03b41\u3009 \u223c= \u3008\u03b4, \u03b42\u3009, then \u03b41 = \u03b42.\nAn unraveling for some element \u03b4 \u2208 \u2206I , denoted as \u2193(I, \u03b4), is an interpretation that is obtained from I and \u03b4 as follows: we define the set S \u2286 (\u2206I)\u2217 of sequences to be the smallest set such that\n\u2022 \u03b4 is a sequence;\n\u2022 \u03b41 \u00b7 \u00b7 \u00b7 \u03b4n \u00b7 \u03b4n+1 is a sequence, if\n\u2013 \u03b41 \u00b7 \u00b7 \u00b7 \u03b4n is a sequence, \u2013 if n > 2 and \u3008\u03b4n, \u03b4n\u22121\u3009 \u2208 fI for some functional role f , then \u03b4n+1 6= \u03b4n\u22121, \u2013 \u03b4n+1 = choose(C, \u03b4n) for some C = \u2203U.B \u2208 cl(K).\nNow fix a set F \u2286 {\u03b4} \u00d7 IN\u2217 and a bijection \u03bb : F \u2192 S such that\n(i) F is a forest,\n(ii) \u03bb(\u03b4, \u03b5) = \u03b4,\n(iii) if (\u03b4, w), (\u03b4, w \u00b7 c) \u2208 F with w \u00b7 c a successor of w, then \u03bb(\u03b4, w \u00b7 c) = \u03bb(\u03b4, w) \u00b7 \u03b4n+1 for some \u03b4n+1 \u2208 \u2206I .\nSuch a forest F and bijection \u03bb exist because S is a prefix-closed set with root \u03b4. Thus, we just map from the notion of sequences to that of forests.\nFor each o \u2208 nom(K), let No \u2208 NC be a fresh concept name. For each (\u03b4, w) \u2208 F , set Tail(\u03b4, w) = \u03b4n if \u03bb(\u03b4, w) = \u03b41 \u00b7 \u00b7 \u00b7 \u03b4n. Now, we define the unraveling for \u03b4 as the interpretation J = (\u2206J , \u00b7J ) with \u2206J = F and, for each (\u03b4, w) \u2208 \u2206J , we define the interpretation of concept and role names as follows:\n(a) for each o \u2208 nom(K), NJo = {(\u03b4, w) \u2208 \u2206J | Tail(\u03b4, w) \u2208 oI};\n(b) for each concept name A \u2208 con(K), AJ = {(\u03b4, w) \u2208 \u2206J | Tail(\u03b4, w) \u2208 AI};\n(c) for each role name r \u2208 rol(K), \u3008(\u03b4, w), (\u03b4, w\u2032)\u3009 \u2208 rJ iff w\u2032 is a neighbor of w, and \u3008Tail(\u03b4, w),Tail(\u03b4, w\u2032)\u3009 \u2208 rI .\nLet R be the subset of \u2206I that contains exactly those \u03b4 \u2208 \u2206I such that oI = \u03b4 for some o \u2208 nom(K). Let U be a set containing an unraveling of I starting from each \u03b4 \u2208 R. The union of all interpretations from U is called an unraveling for I, denoted as \u2193(I), where unions of interpretations are defined in the natural way. 4\nFigure 3 shows the unraveling for our example knowledge base and model. The dotted lines under the non-root elements labeled No indicate that a copy of the whole tree should be appended since we do not stop unraveling at nominal placeholders.\nIt might be helpful to think of the function Tail as a homomorphism (up to signature extension) from the elements in the unraveling J to elements in the original model I. Indeed, Tail satisfies the following properties: For each (\u03b4, w), (\u03b4\u2032, w\u2032) \u2208 \u2206J ,\n\u2022 Tail(\u03b4, w) = oI iff (\u03b4, w) \u2208 NJo , for all o \u2208 nom(K),\n\u2022 Tail(\u03b4, w) \u2208 AI iff (\u03b4, w) \u2208 AJ , for all A \u2208 con(K), and\n\u2022 \u3008Tail(\u03b4, w),Tail(\u03b4\u2032, w\u2032)\u3009 \u2208 rI iff \u3008(\u03b4, w), (\u03b4\u2032, w\u2032)\u3009 \u2208 rJ , for all r \u2208 rol(K).\nUnravelings are the first step in the process of transforming an arbitrary model of K into a forest model since the resulting model is a forest quasi-model of K, as we show in the next lemma.\nLemma 13. Let K be a consistent ALCOIFb knowledge base and I = (\u2206I , \u00b7I) a model of K. Then J = (\u2206J , \u00b7J ) = \u2193(I) is a strict forest quasi-model for K.\nProof. Let K\u2032 = nomFree(K). By construction, J satisfies conditions FQ1 and FQ3 of forest quasi-models and the strictness condition. Since J is obtained from a model I of K, by definition of unravelings as starting from each \u03b4 \u2208 \u2206I such that oI = \u03b4 for some o \u2208 nom(K), and by condition (a) of unravelings, there is, for each o \u2208 nom(K), one root (\u03b4, \u03b5) \u2208 \u2206J such that (\u03b4, \u03b5) \u2208 NJo . Thus, J satisfies also property FQ2 and J is a forest quasi-interpretation for K. We show that J is a model of K\u2032 by demonstrating that each (\u03b4, w) \u2208 \u2206J is locally K\u2032-consistent. Since we assume all knowledge bases to be simplified, we only have to consider axioms of form (1).\nLet Ax be an axiom of the form d Ai v \u2294 Bj and assume that (\u03b4, w) \u2208 ( d Ai)J . By\ncondition (b) of unravelings, we have \u03b4w = Tail(\u03b4, w) \u2208 ( d Ai)I and, since I |= K, we have \u03b4w \u2208 BIj for some j. Again by condition (b) of unravelings, we then have (\u03b4, w) \u2208 B J j as required. Axioms of the form A \u2261 {o} in K are rewritten into A \u2261 No in K\u2032. We consider A v No and No v A separately. Let Ax be of the form A v No for o \u2208 nom(K) and assume that (\u03b4, w) \u2208 AJ . By condition (b), we have that \u03b4w = Tail(\u03b4, w) \u2208 AI and, since I |= K, we have \u03b4w \u2208 {oI}. By condition (a) of unravelings, we then have that (\u03b4, w) \u2208 NJo as required. For No v A with o \u2208 nom(K), assume that (\u03b4, w) \u2208 NJo . By condition (a), we have \u03b4w = Tail(\u03b4, w) \u2208 {oI} and, since I |= K, we have \u03b4w \u2208 AI . By condition (b) of unravelings, we then have (\u03b4, w) \u2208 AJ as required.\nLet Ax be an axiom of the form A v \u2200U.B and assume that (\u03b4, w) \u2208 AJ . By condition (b), we have \u03b4w = Tail(\u03b4, w) \u2208 AI and, since I |= K, we have each \u03b4w\u2032 \u2208 \u2206I such that \u3008\u03b4w, \u03b4w\u2032\u3009 \u2208 UI is such that \u03b4w\u2032 \u2208 BI . Let (\u03b4\u2032, w\u2032) be such that \u3008(\u03b4, w), (\u03b4\u2032, w\u2032)\u3009 \u2208 UJ and (\u03b4\u2032, w\u2032) /\u2208 BJ . By condition (c) of unravelings, we then have that \u3008\u03b4w, \u03b4w\u2032\u3009 \u2208 UI for \u03b4w\u2032 = Tail(\u03b4\u2032, w\u2032) and by condition (b) that \u03b4w\u2032 /\u2208 BI , which is a contradiction.\nLet Ax be an axiom of the form A v \u2203U.B and assume that (\u03b4, w) \u2208 AJ . By condition (b), we have \u03b4w = Tail(\u03b4, w) \u2208 AI and, since I |= K, we have there is at least one \u03b4w\u2032 \u2208 \u2206I such that \u3008\u03b4w, \u03b4w\u2032\u3009 \u2208 UI and \u03b4w\u2032 \u2208 BI . In case there is more than one such element, let \u03b4w\u2032 be such that \u03b4w\u2032 = choose(C, \u03b4w). Then, by definition of sequences, there is some neighbor (\u03b4, w\u2032) of (\u03b4, w) with Tail(\u03b4, w\u2032) = \u03b4w\u2032 . Let \u03bb(\u03b4, w) = \u03b41 \u00b7 \u00b7 \u00b7 \u03b4n, i.e., \u03b4n = \u03b4w. We distinguish two cases:\n1. The element \u03b4w\u2032 is such that \u03b4w\u2032 = \u03b4n\u22121. By definition of the bijection \u03bb, w = w\u2032 \u00b7 c, by definition of J from I (condition (c)) and since \u3008\u03b4w, \u03b4w\u2032\u3009 \u2208 UI , we have \u3008(\u03b4, w), (\u03b4, w\u2032)\u3009 \u2208 UJ . Then, since B is a concept name and \u03b4w\u2032 \u2208 BI , we have by condition (b) that (\u03b4, w\u2032) \u2208 BJ , which proves the claim.\n2. The element \u03b4w\u2032 is such that \u03b4w\u2032 6= \u03b4n\u22121. By definition of sequences and the bijection \u03bb, we have that \u03bb(\u03b4, w\u2032) = \u03b41 \u00b7 \u00b7 \u00b7 \u03b4n \u00b7 \u03b4w\u2032 . Now, by definition of J from I (in particular properties (b) and (c)), we have \u3008(\u03b4, w), (\u03b4, w\u2032)\u3009 \u2208 UJ and, again since B is a concept name, (\u03b4, w\u2032) \u2208 BJ , which proves the claim.\nLet Ax be an axiom of the form func(r) for r \u2208 rol(K). Assume, to the contrary of what is to be shown, that (\u03b4, w) has two distinct neighbors (\u03b4, w1), (\u03b4, w2) such that \u3008(\u03b4, w), (\u03b4, w1)\u3009, \u3008(\u03b4, w), (\u03b4, w2)\u3009 \u2208 rJ . Since the function \u03bb introduced in the unraveling is a bijection, there are two distinct sequences s1 and s2 such that \u03bb(\u03b4, w1) = s1 and \u03bb(\u03b4, w2) = s2 and Tail(\u03b4, w1) = \u03b41,Tail(\u03b4, w2) = \u03b42 with \u03b41 6= \u03b42. Since \u3008(\u03b4, w), (\u03b4, w1)\u3009, \u3008(\u03b4, w), (\u03b4, w2)\u3009 \u2208 rJ we get, due to condition (c), that \u3008Tail(\u03b4, w), \u03b41\u3009, \u3008Tail(\u03b4, w), \u03b42\u3009 \u2208 rI , which is a contradiction since I |= K.\nSince (\u03b4, w) was arbitrarily chosen, we have that each element in the domain of J is locally K\u2032-consistent as required and J |= K\u2032 by Lemma 10.\nLemma 14. Let K be a consistent ALCOIFb knowledge base, I = (\u2206I , \u00b7I) a model of K, and J = (\u2206J , \u00b7J ) = \u2193(I) an unraveling for I. Then J has a branching degree bounded in |cl(K)|.\nProof. Let m be the number of axioms in K. Each axiom of a simplified knowledge base can contain at most one existential restriction and, due to the definition of the function choose used in the unraveling, there are, for each sequence s \u2208 S, at most m elements \u03b41, . . . , \u03b4m \u2208 \u2206I such that s \u00b7 \u03b4i with 1 \u2264 i \u2264 m is a sequence in S. Since the mapping \u03bb from the forest \u2206J to sequences is a bijection, \u2206J is a forest with branching degree m.\nIn the following steps, we traverse a forest quasi-model in an order in which elements with smaller tree depth are always of smaller order than elements with greater tree depth. Elements with the same tree depth are ordered lexicographically. The bounded branching degree of unravelings then guarantees that, after a finite number of steps, we go on to the next level in the forest and process all nodes eventually. Further, we can merge nodes such that, finally, all nominal placeholders (in the extension of some No) can be interpreted as nominals without violating functionality restrictions. In fact, we do not only have to merge nominal placeholders, but also elements that are related to a nominal placeholder by an inverse functional role since, by definition of the semantics, these elements have to correspond to the same element in a model. In order to identify such elements, we define the notion of backwards counting paths as follows:\nDefinition 15 (Paths and BCPs). Let I = (\u2206I , \u00b7I) be an interpretation. We call \u03b41 \u00b7 . . . \u00b7\u03b4n a path from \u03b41 to \u03b4n if, for each i with 1 \u2264 i < n, \u3008\u03b4i, \u03b4i+1\u3009 \u2208 rIi for some role ri \u2208 rol(K). The length |p| of a path p = \u03b41 \u00b7 . . . \u00b7 \u03b4n is n \u2212 1. Each element \u03b4 \u2208 \u2206I is a path of length 0. We write \u03b41 U1\u2192 \u03b42 . . . Un\u22121\u2192 \u03b4n to denote a path from \u03b41 to \u03b4n such that \u3008\u03b4i, \u03b4i+1\u3009 \u2208 UIi for each 1 \u2264 i < n and Ui a safe Boolean role expression. Let K be an ALCOIFb knowledge base and I = (\u2206I , \u00b7I) a forest model (a forest quasimodel) of K. A path p = \u03b41 \u00b7. . .\u00b7\u03b4n in I is a descending path if there is some root (\u03c1, \u03b5) \u2208 \u2206I such that, for each i with 1 \u2264 i \u2264 n, \u03b4i = (\u03c1, wi) and, for 1 \u2264 i < n, |wi| < |wi+1|. The path p is a backwards counting path (BCP) in I if \u03b4n = oI (\u03b4n \u2208 NIo ) for some nominal o \u2208 nom(K) and, for each i with 1 \u2264 i < n, \u3008\u03b4i, \u03b4i+1\u3009 \u2208 fIi for some inverse functional role fi \u2208 rol(K). The path p is a descending BCP if it is a BCP and a descending path. Given a BCP p = \u03b41 f1\u2192 \u03b42 . . . fn\u2192 \u03b4n+1 with \u03b4n+1 \u2208 oJ (\u03b4n+1 \u2208 NJo ), we call the sequence f1 \u00b7 \u00b7 \u00b7 fno a path sketch of p. 4\nPlease note that an element \u03b4 in the domain of J already counts as a (descending) BCP if \u03b4 \u2208 oJ (NJo ) for some o \u2208 nom(K).\nWe now define the order that guarantees that in an iterative parsing process, we not only process all nodes, but also that we can merge nodes as required so that, finally, all nominal placeholders can be interpreted as nominals without violating functionality restrictions.\nDefinition 16 (Ordering). For convenience and without loss of generality, we assume that the set of individual names NI is ordered. Let K be a consistent ALCOIFb knowledge base and J a forest quasi-interpretation for K. We extend the order to elements in \u2206J as follows: let w1 = wp \u00b7 c11 \u00b7 \u00b7 \u00b7 cn1 , w2 = wp \u00b7 c12 \u00b7 \u00b7 \u00b7 cm2 \u2208 IN\u2217 where wp \u2208 IN\u2217 is the longest common prefix of w1 and w2, then w1 < w2 if either n < m or both n = m and c11 < c 1 2. For (\u03c11, \u03b5), (\u03c12, \u03b5) \u2208 \u2206J , let o1 \u2208 nom(K) be the smallest nominal such that (\u03c11, \u03b5) \u2208 NJo1 and o2 \u2208 nom(K) the smallest nominal such that (\u03c12, \u03b5) \u2208 NJo2 . Now (\u03c11, w1) < (\u03c12, w2) if either (i) |w1| < |w2| or (ii) |w1| = |w2| and o1 < o2 or (ii) |w1| = |w2|, o1 = o2 and w1 < w2.\nIn the following, we are merging elements in an unraveling and, in this process, create new roots of the form (\u03c1w, \u03b5) from elements of the form (\u03c1, w) and elements of the form (\u03c1w,w\u2032) from (\u03c1, ww\u2032). We extend, therefore, the order to elements of this form as follows: (\u03c11w1, w\u20321) < (\u03c12w2, w \u2032 2) if (\u03c11, w1w \u2032 1) < (\u03c12, w2w \u2032 2). 4\nRoughly speaking, we proceed as follows in order to transform a quasi-forest model J into a forest model I: we work our way downwards the trees level by level along the descending BCPs and use the above defined order for this purpose. By definition of the semantics, elements that start the same descending BCP or, more precisely, that start BCPs with identical path sketches, have to correspond to the same element in the forest model I that we produce. During the traversal of the forest quasi-model, we distinguish two situations: (i) we encounter an element (\u03c1, w) that starts a descending BCP and we have not seen another element before that starts a descending BCP with the same path sketch. In this case, we promote (\u03c1, w) to become a new root node of the form (\u03c1w, \u03b5) and we shift the subtree rooted in (\u03c1, w) with it; (ii) we encounter a node (\u03c1, w) that starts a descending BCP, but we have already seen a node (\u03c1\u2032, w\u2032) that starts a descending BCP with that path sketch and which is now a root of the form (\u03c1\u2032w\u2032, \u03b5). In this case, we delete the subtree rooted in (\u03c1, w) and identify (\u03c1, w) with (\u03c1\u2032w\u2032, \u03b5). If (\u03c1, w) is an f -successor of its predecessor for some inverse functional role f , we delete all f\u2212-successors of (\u03c1\u2032w\u2032, \u03b5) and their subtrees in order to satisfy the functionality restriction. We use a notion of collapsing admissibility to characterize models in which the predecessor of (\u03c1, w) satisfies the same atomic concepts as the deleted successor of (\u03c1\u2032, w\u2032), which ensures that local consistency is preserved. By virtue of this notion, we can characterize forest quasi-models that can be collapsed into proper models irrespective of whether they have been obtained by unraveling of a model or not.\nIn order to keep the domain as a forest when promoting an element (\u03c1, w) to a new root, we build the new domain with elements of the form (\u03c1w, \u03b5) for (\u03c1, w) and elements of the form (\u03c1w,w\u2032) for descendants (\u03c1, ww\u2032) of (\u03c1, w).\nDefinition 17 (Equivalence Relation \u223c and Collapsings). Let K be an ALCOIFb knowledge base, K\u2032 = nomFree(K), and J = (\u2206J , \u00b7J ) a forest quasi-interpretation of K. We define \u223c as the smallest equivalence relation on \u2206J that satisfies \u03b41 \u223c \u03b42 if \u03b41, \u03b42 start descending BCPs with identical path sketches.\nLet J be a strict forest quasi-interpretation for K, J0 = (\u2206J0 , \u00b7J0) = J and (\u03c10, w0) \u2208 \u2206J0 the smallest element with w0 6= \u03b5 that starts a descending BCP. We call J0 an initial collapsing for J and (\u03c10, w0) the focus of J0.\nLet Ji be a collapsing for J and (\u03c1i, wi) \u2208 \u2206Ji the focus of Ji. We obtain a collapsing Ji+1 = (\u2206Ji+1 , \u00b7Ji+1) with focus (\u03c1i+1, wi+1) for J from Ji according to the following two cases:\n1. There is no element (\u03c1, \u03b5) \u2208 \u2206Ji such that (\u03c1, \u03b5) is smaller than the focus (\u03c1i, wi) and (\u03c1, \u03b5) \u223c (\u03c1i, wi). Then Ji+i is obtained from Ji by renaming each element (\u03c1i, wiw\u2032i) \u2208 \u2206Ji to (\u03c1iwi, w\u2032i).\n2. There is an element (\u03c1, \u03b5) \u2208 \u2206Ji such that (\u03c1, \u03b5) is smaller than the focus (\u03c1i, wi) and (\u03c1, \u03b5) \u223c (\u03c1i, wi). Let (\u03c1, \u03b5) be the smallest such element.\n(a) \u2206Ji+1 = \u2206Ji \\ ({(\u03c1i, wiw\u2032i) | w\u2032i \u2208 IN\u2217} \u222a {(\u03c1, w) | w = c \u00b7 w\u2032, c \u2208 IN, w\u2032 \u2208 IN\u2217, (\u03c1i, wi) has a predecessor (\u03c1i, w\u2032i) such that \u3008(\u03c1i, w\u2032i), (\u03c1i, wi)\u3009 \u2208 fJi for an inverse functional role f in rol(K) and \u3008(\u03c1, c), (\u03c1, \u03b5)\u3009 \u2208 fJi});\n(b) for each concept name A \u2208 con(K) and (\u03c1, w) \u2208 \u2206Ji+1 , (\u03c1, w) \u2208 AJi+1 iff (\u03c1, w) \u2208 AJi ;\n(c) for each role name r \u2208 rol(K) and (\u03c11, w1), (\u03c12, w2) \u2208 \u2206Ji+1 , \u3008(\u03c11, w1), (\u03c12, w2)\u3009 \u2208 rJi+1 iff\ni. \u3008(\u03c11, w1), (\u03c12, w2)\u3009 \u2208 rJi or ii. (\u03c11, w1) is the predecessor of (\u03c1i, wi) in Ji (i.e., \u03c11 = \u03c1i and wi = w1 \u00b7 c for\nsome c \u2208 IN), (\u03c12, w2) = (\u03c1, \u03b5), and \u3008(\u03c11, w1), (\u03c1i, wi)\u3009 \u2208 rJi .\nThe focus (\u03c1i+1, wi+1) in Ji+1 is the smallest descending BCP with (\u03c1i, wi) < (\u03c1i+1, wi+1). For a collapsing Ji, let safe(Ji) be the restriction of Ji to elements (\u03c1, w) such that (\u03c1, w) \u2208 Jj for all j \u2265 i. With J\u03c9 we denote the non-disjoint union of all interpretations safe(Ji) obtained from subsequent collapsings Ji for J . The interpretation obtained from J\u03c9 by interpreting each o \u2208 nom(K) as (\u03c1, \u03b5) \u2208 NJ\u03c9o is denoted by collapse(J ) and called a purified interpretation with respect to J. If collapse(J ) |= K, we call collapse(J ) a purified model of K. 4\nIn Figures 4 to 7 we illustrate the first collapsing steps for the unraveling depicted in Figure 3. Apart from the nominal placeholder concepts, the concept interpretations are not shown in the figures, but are assumed to be as indicated in Figure 3. The edges for descending BCPs are shown in red color, and the dashed lines in Figure 4 indicate the levels of the tree because, within a tree, the order in which the nodes are processed depends firstly on their level. Within a level, we assume that the order increases from left to right. The numbers next to nodes in Figure 4 indicate, which elements are used as focus element in a collapsing step and their order. For the initial collapsing (Figure 4) the focus is on the first non-root element that starts a BCP, which we indicate with a black border around the node and a black triangle pointing to the focus.\nIn the first collapsing step we just rename elements to promote the focus from Figure 4 to a root. Because the focus element highlighted in Figure 5 starts a BCP with path sketch different from the ones started by smaller elements, we again only rename elements to obtain a new root (Figure 6). Now, the focus is on a nominal placeholder and since nominal placeholder are BCPs, we have a root with the same path sketch and use the second case of Definition 17. The resulting collapsing is depicted in Figure 7.\nFinally, we obtain a collapsing for the unraveling shown in Figure 3 as the one depicted in Figure 8.\nWe can now show that the collapsing of an unraveling results in a forest model for K. Our aim is, however, to show something more general. We want to collapse not only unravelings into forest models, but also forest quasi-models which have been obtained in another way. Unfortunately, it is not the case that the collapsing of any forest quasi-model results in a forest model for K since the elements that we merge in the collapsing process do not necessarily satisfy the same atomic concepts. We define, therefore, the following admissibility criterion that characterizes forest quasi-models that can be collapsed into forest models.\nDefinition 18 (Collapsing-admissibility). Let J be a forest quasi-interpretation for some ALCOIFb knowledge base K. Then J is collapsing-admissible if there exists a function ch : (cl(K)\u00d7\u2206J )\u2192 \u2206J such that\n1. for each concept C = \u2203U.B \u2208 cl(K) and each \u03b4 \u2208 CJ , we have \u3008\u03b4, ch(C, \u03b4)\u3009 \u2208 UJ and ch(C, \u03b4) \u2208 BJ . Moreover, if there is no functional role f for which \u3008\u03b4, ch(C, \u03b4)\u3009 \u2208 fJ then ch(C, \u03b4) is a successor of \u03b4,\n2. for each concept C = \u2203U.B \u2208 cl(K) and elements \u03b4, \u03b4\u2032 \u2208 CJ that start descending BCPs with identical path sketches, we have \u3008\u03b4, ch(C, \u03b4)\u3009 \u223c= \u3008\u03b4\u2032, ch(C, \u03b4\u2032)\u3009.\n4\nLemma 19. Let K be an ALCOIFb knowledge base. Any unraveling J of a model I for K is collapsing-admissible.\nProof. We define a function ch directly from the function choose used in the unraveling as follows: for each C \u2208 cl(K) and (\u03c1, w) \u2208 \u2206J with \u03bb(\u03c1, w) = \u03b41 \u00b7 . . . \u00b7 \u03b4n and choose(C,Tail(\u03c1, w)) = {\u03b4\u2032}, we set ch(C, (\u03c1, w)) = (\u03c1, w\u2032) for (\u03c1, w\u2032) = \u03bb\u2212(\u03b41 \u00b7 . . . \u00b7 \u03b4n \u00b7 \u03b4\u2032) if \u03b41 \u00b7 . . . \u00b7 \u03b4n \u00b7 \u03b4\u2032 is a sequence in S and (\u03c1, w\u2032) = \u03bb\u2212(\u03b41 \u00b7 . . . \u00b7 \u03b4n\u22121) otherwise. This is well-defined since the function \u03bb in unravelings is total and bijective and it is as required for admissibility since elements that start BCPs with identical path sketches are always generated from the same element in I. The first condition of collapsing-admissibility holds since in unravelings, we always add \u03b41 \u00b7 . . . \u00b7 \u03b4n \u00b7 \u03b4\u2032 to the set of sequences unless the pair \u3008\u03b4n, \u03b4n\u22121\u3009 is in the interpretation of some functional role. In that case, the function ch uses the predecessor instead of the successor, which is still admissible.\nLemma 20. Let K be a consistent ALCOIFb knowledge base, J = (\u2206J , \u00b7J ) a strict forest quasi-model for K with branching degree b that is collapsing-admissible. Then collapse(J ) is a forest model for K with branching degree b.\nProof. Let K\u2032 = nomFree(K). Since J is a forest quasi-model of K by assumption, J |= K\u2032. We first show that each collapsing Ji for J is a forest quasi-model for K, i.e., Ji |= K\u2032. We then show that each collapsing Ji+1 produced from an admissible collapsing Ji is again collapsing-admissible. Finally, we show that, for each o \u2208 nom(K), there is exactly one node in J\u03c9 of the form (\u03c1, \u03b5) such that (\u03c1, \u03b5) \u2208 NJ\u03c9o , which implies by Proposition 11 that collapse(J ) is a forest model for K.\nWe start with the first claim: For the initial collapsing this is immediate since J is a forest quasi-model for K. In particular, J0 is locally K\u2032-consistent. Assume that Ji is a locally K\u2032-consistent collapsing and (\u03c1i, wi) is the focus in Ji. We show that Ji+1 is locally\nK\u2032-consistent. Since K\u2032 is simplified by assumption, we only have to consider axioms of form (1).\nIf Ji+1 is obtained according to the first case of Definition 17, we only rename elements of the domain in order to create a new root node and local K\u2032-consistency is immediate. We assume, thus, that Ji+1 is obtained according to the second case of Definition 17.\nAxioms of the form d Ai v \u2294 Bj and A \u2261 {o} (rewritten into A \u2261 No in K\u2032) hold immediately due to condition 2.b of collapsings. Let Ax be an axiom of the form A v \u2200U.B and assume that (\u03c1, w) \u2208 AJ . The only interesting elements are the predecessor (\u03c1i, w\u2032i) of the focus (\u03c1i, wi) and (\u03c1, \u03b5). However, (\u03c1i, wi) \u223c (\u03c1, \u03b5) and, since J is collapsing-admissible, (\u03c1i, wi) and (\u03c1, \u03b5) satisfy the same atomic concepts with respect to con(K). Further, the interpretation of atomic concepts is not changed due to 2.b, which again implies local K\u2032-consistency for this kind of axioms.\nLet Ax be an axiom of the form A v \u2203U.B and assume that (\u03c1, w) \u2208 AJi+1 . We concentrate on the three interesting cases where the direct neighborhoods of elements change:\n1. We start with the case where the focus (\u03c1i, wi) is the corresponding U -successor of (\u03c1, w), i.e., \u03c1i = \u03c1, wi = w\u00b7c for some c \u2208 IN, \u3008(\u03c1, w), (\u03c1i, wi)\u3009 \u2208 UJi , and (\u03c1i, wi) \u2208 BJi . Since (\u03c1, \u03b5) and (\u03c1i, wi) are in the same equivalence class for \u223c by assumption, (\u03c1, \u03b5) starts a BCP with the same path sketch as (\u03c1i, wi) and both (\u03c1, \u03b5) and (\u03c1i, wi) satisfy the same atomic concepts with respect to con(K). Then condition 2.(c)ii. ensures that (\u03c1, \u03b5) is the required U -successor for (\u03c1, w) in Ji+1.\n2. Assume that (\u03c1, w) = (\u03c1, \u03b5), \u3008(\u03c1, \u03b5), (\u03c1, c)\u3009 \u2208 UJi , (\u03c1, c) \u2208 BJi , (\u03c1, c) /\u2208 \u2206Ji+1 , and (\u03c1, \u03b5) /\u2208 (\u2203U.B)Ji+1 . Due to 2.a, the focus (\u03c1i, wi) has a predecessor (\u03c1i, w\u2032i) such that \u3008(\u03c1i, w\u2032i), (\u03c1i, wi)\u3009 \u2208 fJi for an inverse functional role f \u2208 rol(K) and \u3008(\u03c1, \u03b5), (\u03c1, c)\u3009 \u2208 (f\u2212)Ji . Since f is inverse functional and Ji is, by assumption, locally K\u2032-consistent, there is no successor (\u03c1i, wi \u00b7 ci) of (\u03c1i, wi) such that \u3008(\u03c1i, wi), (\u03c1i, wi \u00b7 ci)\u3009 \u2208 (f\u2212)Ji . Similarly, there is no element (\u03c1\u2032, w\u2032) such that \u3008(\u03c1, \u03b5), (\u03c1\u2032, w\u2032)\u3009 \u2208 (f\u2212)Ji . Then, since Ji is collapsing-admissible, we have that (\u03c1i, w\u2032i) \u2208 ch(\u2203U.B, (\u03c1i, wi)), (\u03c1, c) \u2208 ch(\u2203U.B, (\u03c1, \u03b5)), and \u3008(\u03c1i, wi), (\u03c1i, w\u2032i)\u3009 \u223c= \u3008(\u03c1, \u03b5), (\u03c1, c)\u3009 since (\u03c1i, wi) and (\u03c1, \u03b5) start descending BCPs with identical path sketches. In particular, \u3008(\u03c1i, wi), (\u03c1i, w\u2032i)\u3009 \u2208 UJi and (\u03c1i, w\u2032i) \u2208 BJi . Then, by condition 2.(c)ii., \u3008(\u03c1, \u03b5), (\u03c1i, w\u2032i)\u3009 \u2208 UJi+1 , by condition 2.b, (\u03c1i, w\u2032i) \u2208 BJi+1 , and, thus, (\u03c1, \u03b5) \u2208 (\u2203U.B)Ji+1 as required.\n3. We assume that (\u03c1i, wi) has a predecessor (\u03c1i, w\u2032i) such that \u3008(\u03c1i, w\u2032i), (\u03c1i, wi)\u3009 \u2208 fJi for an inverse functional role f in rol(K) and \u3008(\u03c1, c), (\u03c1, \u03b5)\u3009 \u2208 fJi , causing the deletion of (\u03c1, c) and its descendants, one of which, say (\u03c1, v) is connected to some (\u03c2, \u03b5), such that \u3008(\u03c2, \u03b5), (\u03c1, v)\u3009 \u2208 UJi and (\u03c1, v) \u2208 BJi . Now, if there is no inverse functional role g for which \u3008(\u03c2, \u03b5), (\u03c1, v)\u3009 \u2208 gJi , then the strictness and collapsing-admissibility of Ji ensure the existence of a c\u2032 \u2208 IN for which \u3008(\u03c2, \u03b5), (\u03c2, c)\u3009 \u2208 UJi and (\u03c2, c) \u2208 BJi and, consequently, also \u3008(\u03c2, \u03b5), (\u03c2, c)\u3009 \u2208 UJi+1 and (\u03c2, c) \u2208 BJi+1 . If \u3008(\u03c2, \u03b5), (\u03c1, v)\u3009 \u2208 gJi for some inverse functional role g, then strictness of the initial collapsing implies that (\u03c1, v) itself started a descending BCP and, due to the defined order, it must have been a focus before and now be a root itself. This contradicts, however, the initial assumption that (\u03c1, v) is a descendant of (\u03c1, \u03b5) and we are done.\nIn all cases, the elements in \u2206Ji+1 have the required successors.\nLet Ax be an axiom of the form func(f) for f \u2208 rol(K). We concentrate on relations between the predecessor (\u03c1i, w\u2032i) of the focus and (\u03c1, \u03b5) since otherwise local K\u2032-consistency is immediate. A predecessor exists for the focus since we process elements in ascending order starting with non-root nodes. Assume \u3008(\u03c1i, w\u2032i), (\u03c1i, wi)\u3009 \u2208 fJi , in which case \u3008(\u03c1i, w\u2032i), (\u03c1, \u03b5)\u3009 \u2208 fJi+1 due to 2.(c)ii. and assume (\u03c1, \u03b5) has a successor (\u03c1, c) in Ji such that \u3008(\u03c1, c), (\u03c1, \u03b5)\u3009 \u2208 fJi . In this case, (\u03c1, c) /\u2208 \u2206Ji+1 according to 2.a and together with local K\u2032-consistency of Ji, this implies that (\u03c1i, w\u2032i) is the only element in \u2206Ji+1 such that \u3008(\u03c1i, w\u2032i), (\u03c1, \u03b5)\u3009 \u2208 fJi+1 .\nWe now show that each Ji+1 produced from an admissible collapsing Ji is again admissible for collapsing. By assumption, the initial collapsing is admissible, so let Ji be an admissible collapsing and chi the required function. We distinguish two cases:\n1. Let Ji+1 be produced according to the first case of collapsings. We define a function chi+1 for Ji+1 as follows: For each C \u2208 cl(K) and \u03b4 \u2208 \u2206Ji+1 , we set chi+1(C, \u03b4) = \u03b4\u2032 for \u03b4\u2032 = (\u03c1iwi, w\u20321) if chi(C, \u03b4) = (\u03c1i, wiw \u2032 i) for (\u03c1i, wi) the focus in Ji and \u03b4\u2032 = chi(C, \u03b4)\notherwise. Since we just change the names of the elements and leave the interpretation of concepts and roles as before, the function is as required for admissibility.\n2. Let Ji+1 be produced according to the second case of collapsings. We define a function chi+1 for Ji+1 as follows: For each C \u2208 cl(K),\n(a) for each \u03b4 \u2208 \u2206Ji+1 /\u2208 {(\u03c1i, w\u2032i), (\u03c1, \u03b5)} with (\u03c1i, w\u2032i) the predecessor of the focus (\u03c1i, wi), we set chi+1(C, \u03b4) = \u03b4\u2032 for \u03b4\u2032 such that \u03b4\u2032 \u2208 \u2206Ji+1 and \u03b4\u2032 = chi(C, \u03b4); this is well-defined since only successors of (\u03c1, \u03b5) and (\u03c1i, w\u2032i) are deleted in Ji+1. (b) for \u03b4 = (\u03c1, \u03b5) and (\u03c1i, w\u2032i) the predecessor of the focus, chi+1(C, \u03b4) = \u03b4 \u2032 for \u03b4\u2032 = (\u03c1i, w\u2032i) if chi(C, \u03b4) = (\u03c1, c) and (\u03c1, c) /\u2208 \u2206Ji+1 and \u03b4\u2032 = chi(C, \u03b4) otherwise; (c) for \u03b4 = (\u03c1i, w\u2032i) the predecessor of the focus, we set chi+1(C, \u03b4) = \u03b4\n\u2032 for \u03b4\u2032 = (\u03c1, \u03b5) if chi(C, \u03b4) = (\u03c1i, wi) and \u03b4\u2032 = chi(C, \u03b4) otherwise.\nFor elements apart from the predecessor of the focus (\u03c1i, w\u2032i) and the root (\u03c1, \u03b5) that replaces (\u03c1i, wi), the interpretation of concepts and roles remains as before by properties 2.b and 2.c and the function is as required. For (\u03c1i, w\u2032i), we change the function so that in cases where (\u03c1i, wi) was returned, (\u03c1, \u03b5) is returned. Since (\u03c1i, wi) \u223c (\u03c1, \u03b5), this is admissible. Similarly, if a successor (\u03c1, c) of (\u03c1, \u03b5) is not contained in \u2206Ji+1 , then (\u03c1i, w\u2032i) is used instead. This is admissible since, in this case, \u3008(\u03c1i, wi), (\u03c1i, w\u2032i)\u3009 \u223c= \u3008(\u03c1, \u03b5), (\u03c1, c)\u3009 as argued above for axioms of the form A v \u2203U.B.\nWe now show that, for each o \u2208 nom(K), there is exactly one node in J\u03c9 of the form (\u03c1, \u03b5) such that (\u03c1, \u03b5) \u2208 NJ\u03c9o . Nominal placeholders are descending BCPs by definition and, when a nominal placeholder becomes the focus, it is merged into a root that is in the same equivalence class of \u223c and which is by definition of lower order. Such a root exists because of property FQ2 of forest quasi-interpretations.\nThe interpretation J\u03c9 is obtained by building the non-disjoint union of the \u201csafe\u201d parts for all collapsings, which contain only elements which will neither be renamed nor deleted. Thus, J\u03c9 does not contain nominal placeholders as required. Considering any one element (\u03c1, w) \u2208 \u2206J\u03c9 , we find that there is an i \u2208 IN such that all successors and all root neighbors\nof (\u03c1, w) in Ji are the same as in J\u03c9. As we have shown, Ji is locally K\u2032-consistent and therefore (\u03c1, w) has a consistent neighborhood. Hence J\u03c9 is a forest quasi-model of K.\nNow, when interpreting each o \u2208 nom(K) as {(\u03c1, \u03b5) \u2208 \u2206J\u03c9 | (\u03c1, \u03b5) \u2208 NJ\u03c9o } in collapse(J ), we obtain a forest model for K, where the set of roots is {(\u03c1, \u03b5) | (\u03c1, \u03b5) \u2208 \u2206J\u03c9}.\nThe bounded branching degree is an immediate consequence of the construction since we never add successors during the construction and the starting forest quasi-interpretation J has a bounded branching degree by assumption.\nSince unravelings of a model I for K are strict forest quasi-models of K with branching degree bounded in |cl(K)| by Lemma 13, and unravelings are collapsing-admissible by Lemma 19, it is an immediate consequence of Lemma 20 that the collapsing of an unraveling yields a forest model branching degree bounded in |cl(K)|.\nCorollary 21. Let K be an ALCOIFb knowledge base and I an interpretation such that I |= K, then the purified interpretation collapse(\u2193(I)) is a forest model for K with branching degree b bounded in |cl(K)|.\nSince the number of roots might still be infinite in purified models, we could, up to now, have obtained the same result by unraveling an arbitrary model, where we take all elements on BCPs as roots instead of taking just the nominals and creating new roots in the collapsing process. In the next sections, however, we show how we can transform an unraveling of a counter-model for the query such that it remains collapsing-admissible and such that it can in the end be collapsed into a forest model with a finite number of roots that is still a counter model for the query. For this transformation it is much more convenient to work with real (strict) trees and forests, which is why we use (strict) forest quasi-interpretations.\nIn the next sections, we also use the following alternative characterization of the result of a collapsing, which comes in handy for the subsequent proofs.\nWe start by defining the so-called pruning of a forest quasi-interpretation, which is, roughly speaking, the structure obtained by just deleting all the nodes, which will be erased in the course of the collapsing process anyway.\nDefinition 22 (Pruning). Let J be a strict forest quasi-model for an ALCOIFb knowledge base K that is collapsing-admissible and let J0,J1, . . . ,J\u03c9 be as defined in Definition 17. The pruning of J (written prune(J )) is obtained by restricting J to a set \u0393 \u2286 \u2206J which is defined as follows: \u0393 contains all \u3008\u03c1w1, w2w3\u3009 \u2208 \u2206J for which \u3008\u03c1w1w2, w3\u3009 \u2208 \u2206J\u03c9 or \u3008\u03c1w1w2, w3\u3009 is the focus in some Ji. 4\nWe again use the equivalence relation \u223c for elements that start descending BCPs with identical path sketches from Definition 17 and construct an interpretation from a pruning by identifying equivalent nodes, also known as factorization.\nDefinition 23 (Factorization). Let K be an ALCOIFb knowledge base, J a strict forest quasi-interpretation for K that is collapsing-admissible, and L = prune(J ).\nThe factorization of L by \u223c (denoted by L/\u223c) is now defined as the forest quasi-interpretation M = (\u2206M, \u00b7M) with\n\u2022 \u2206M = {[\u03b4]\u223c | \u03b4 \u2208 \u2206L};\n\u2022 for each A \u2208 con(K), AM = {[\u03b4]\u223c | \u03b4 \u2208 AL},\n\u2022 for each r \u2208 rol(K), rM = {\u3008[\u03b4]\u223c, [\u03b4\u2032]\u223c\u3009 | \u3008\u03b4, \u03b4\u2032\u3009 \u2208 rL}, and\n\u2022 for each o \u2208 nom(K), oM = [\u03b4]\u223c for \u03b4 \u2208 NLo . 4\nNote that the interpretation of nominals in M is well defined as, by definition, all No-instances are in the same \u223c-equivalence class.\nNow we are ready to establish the wanted correspondence: the collapsing of a forest quasi-interpretation can essentially be obtained by first pruning and then factorizing it.\nLemma 24. Let J be a strict forest quasi-model for an ALCOIFb knowledge base K and let J be collapsing-admissible. Then collapse(J ) \u223c= prune(J )/\u223c. Moreover the new roots in collapse(J ) correspond to those \u223c-equivalence classes that contain J -elements which start descending BCPs in J .\nProof. Considering the first claim, note that by definition of the collapsing procedure, for every (\u03c1w,w\u2032) \u2208 \u2206collapse(J ) there is exactly one pair w1, w2 with w = w1w2 such that (\u03c1w1, w2w\u2032) \u2208 \u2206prune(J ). Moreover, case 1 of the construction assures that \u2206collapse(J ) contains one element from every \u223c-equivalence class from \u2206prune(J )/\u223c . Hence the mapping \u03d5 : \u2206collapse(J ) \u2192 \u2206prune(J )/\u223c with \u03d5(\u03c1w,w\u2032) = [(\u03c1w1, w2w\u2032)]\u223c is a bijection and, as a consequence of the construction, an isomorphism.\nThe second claim is also a direct consequence of the construction of the collapsing."}, {"heading": "5. Quasi-Entailment in Quasi-Models", "text": "In this section, we will provide a characterization for forest quasi-models that mirrors query entailment for the corresponding \u201cproper models\u201d. In our further argumentation, we will talk about the initial part of a tree, i.e., the part that is left if branches are cut down to a fixed length. For a forest interpretation I = (\u2206I , \u00b7I) and an n \u2208 IN, we therefore denote with cutn(I) the interpretation obtained from I by restricting \u2206I to those pairs (\u03c1, w) for which |w| \u2264 n.\nThe following lemma ensures that in the case of purified models, we find only finitely many unraveling trees of depth n that \u201clook different\u201d.\nLemma 25. Let K be a consistent ALCOIFb knowledge base. Then there is a purified interpretation I such that I |= K and, for every n \u2208 IN, there are only finitely many non-isomorphic trees of depth n.\nProof. Since K has a model by assumption, Corollary 21 guarantees that there is some purified model I of K. In particular, I is a forest model with the branching degree bounded in the size of cl(K).\nWe now compute the maximal number of non-isomorphic trees of depth n over the domain of I. We denote this bound by Tn. The argumentation is close to the one used by Levy and Rousset (1998) for their definition of tree blocking.\nLet c = |cl(K)| and r = |rol(K)|. We first consider trees of depth n = 0. We have 2c choices for the different subsets of concepts in cl(K). For n > 0, each concept at level 0 can trigger the generation of a new successor and we can have any number of successors between 0 and c. Assume, for now, that we have only a single role name r \u2208 rol(K) and that each node in a level smaller than n is the root of a tree with depth n\u2212 1 with exactly c successors for each node. In this case, there are O(2cT cn\u22121) non-isomorphic sub-trees of depth n. Taking into account that a node does not necessarily have c successors, but we can choose any number between 0 and c, we get a bound of O(2ccT cn\u22121) for the number of nonisomorphic sub-trees of depth n. Finally, since we have not only one but a choice of r roles, we get a bound of O(2c(cT cn\u22121)\nr). We now abbreviate 2ccr with x and rc with a and rewrite the obtained bound as Tn = O(x(Tn\u22121)a). Unfolding yields Tn = O((x1+a+...+a n\u22121 )(T0)a n ) which is bounded by O((xa n )(2c)a n ) = O((x2c)a n ). By expanding the abbreviated symbols, we obtain a bound for Tn of O((2ccr)(rc) n ).\nFor our further considerations, we introduce the notion of \u201canchored n-components\u201d. These are meant to be certain substructures of forest quasi-interpretations. In the first place, these substructures contain a connected set of nodes W \u2032 which are situated \u201cclosely together\u201d in the original structure, this closeness being witnessed by the fact that all elements of W \u2032 are descendants of some node \u03b4 and have a distance \u2264 n to \u03b4. Moreover for each of those nodes \u03b4\u2032 from W \u2032, the anchored n-component may (but does not need to) contain a finite number of descending BCPs starting from \u03b4\u2032.\nDefinition 26 (Anchored Components). Let J be a forest quasi-interpretation and \u03b4 \u2208 \u2206J . An interpretation C will be called anchored n-component of J with witness \u03b4 if C can be created by restricting J to a set W \u2286 \u2206J obtained as follows:\n\u2022 Let J\u03b4 be the subtree of J that is started by \u03b4 and let J\u03b4,n := cutn(J\u03b4). Select a subset W \u2032 \u2286 \u2206J\u03b4,n that is closed under predecessors.\n\u2022 For every \u03b4\u2032 \u2208W \u2032, let P be a finite set (possibly empty) of descending BCPs p starting from \u03b4\u2032 and let W\u03b4\u2032 contain all nodes from all p \u2208 P .\n\u2022 Set W = W \u2032 \u222a \u22c3 \u03b4\u2032\u2208W \u2032W\u03b4\u2032 .\n4\nNow think of a forest quasi-model J and some query q. The following definition and lemma employ the notion of anchored n-components to come up with the notion of quentailment (short for quasi-entailment), a criterion that reflects query-entailment in the world of forest quasi-models.\nDefinition 27 (Quentailment). Let q be a conjunctive query with ](q) = n and J some forest quasi-model of an ALCOIFb knowledge base K. We say that J quentails q (written J |\u2248 q) if, for V = var(q), J contains connected anchored n-components C1, . . . , C` and there are according functions \u00b5i : V \u2192 2\u2206 Ci such that the following hold:\nQ1 For every x \u2208 V , there is at least one Ci, such that \u00b5i(x) 6= \u2205\nQ2 For all A(x) \u2208 q, we have \u00b5i(x) \u2286 AJ for all i.\nQ3 For every r(x, y) \u2208 q there is a Ci such that there are \u03b41 \u2208 \u00b5i(x) and \u03b42 \u2208 \u00b5i(y) such that \u3008\u03b41, \u03b42\u3009 \u2208 rJ .\nQ4 If, for some x \u2208 V , there are connected anchored n-components Ci and Cj with \u03b4 \u2208 \u00b5i(x) and \u03b4\u2032 \u2208 \u00b5j(x), then there is\n\u2022 a sequence Cn1 , . . . , Cnk with n1 = i and nk = j and \u2022 a sequence \u03b41, . . . , \u03b4k with \u03b41 = \u03b4 and \u03b4k = \u03b4\u2032 as well as \u03b4m \u2208 \u00b5nm(x) for all\n1 \u2264 m < k,\nsuch that, for every m with 1 \u2264 m < k, we have that\n\u2022 Cnm contains a descending BCP p1 started by \u03b4m, \u2022 Cnm+1 contains a descending BCP p2 started by \u03b4m+1, \u2022 p1 and p2 have the same path sketch.\nFor a union of conjunctive queries u = q1 \u2228 . . . \u2228 qh, we say that J quentails u (written J |\u2248u) if J |\u2248 q for a q \u2208 {q1, . . . , qh}. 4\nNote that an anchored component may contain none, one or several instantiations of a variable x \u2208 V . Intuitively, the definition ensures, that we find matches of query parts which when fitted together by identifying BCP-equal elements yield a complete query match.\nLemma 28. Let u = q1 \u2228 . . . \u2228 qh be a union of conjunctive queries and K an ALCOIFb knowledge base. Then\n1. For any model I of K, \u2193(I) |\u2248u implies I |= u.\n2. For any strict forest quasi-model J of K that is collapsing-admissible, collapse(J ) |= u implies J |\u2248u.\nProof. 1. Let q be a disjunct of u such that \u2193(I) |\u2248 q, V = var(q), and C1, . . . , C` the connected anchored n-components witnessing the quentailment. We use the function Tail from Definition 12 and exploit its properties as a homomorphism. Note that Tail maps nodes in \u2193(I) to the same individual in I, if they start descending BCPs with the same path sketches. Due to condition Q4 from Definition 27, this implies, for every x \u2208 V and every \u03b41 \u2208 \u00b5i(x) and \u03b42 \u2208 \u00b5j(x), that Tail(\u03b41) = Tail(\u03b42). Hence, the total function \u00b5 : V \u2192 \u2206I defined by letting \u00b5(x) = \u03b3 whenever Tail(\u03b4) = \u03b3 for some \u03b4 \u2208 \u00b5i(x) and some i with 1 \u2264 i \u2264 `, is well-defined. We now show that \u00b5 is a query match for q in I by examining the atoms of q:\n\u2022 For every unary atom A(x), the definition of quentailment ensures that there exist a Ci and a \u03b4 \u2208 \u2206Ci with \u03b4 \u2208 \u00b5i(x) and \u03b4 \u2208 AJ . Then, by definition of Tail, it follows that \u00b5(x) = Tail(\u03b4) \u2208 AI . \u2022 Likewise, for every binary atom r(x, y), the definition of quentailment ensures\nthat there exists a Ci and \u03b41, \u03b42 \u2208 \u2206Ci such that \u03b41 \u2208 \u00b5i(x) and \u03b42 \u2208 \u00b5i(y) as well as \u3008\u03b41, \u03b42\u3009 \u2208 rJ . Again, by definition of Tail, it follows that \u3008\u00b5(x), \u00b5(y)\u3009 = \u3008Tail(\u03b41),Tail(\u03b42)\u3009 \u2208 rI .\n2. To prove this, we employ the alternative characterization of collapsings as established in Lemma 24. Let I \u2032 = (\u2206I\u2032 , \u00b7I\u2032) = prune(J )/\u223c and let \u00b5 : V \u2192 \u2206I \u2032 be a match for\nq in I \u2032. We use \u00b5 to construct the anchored n-components and functions needed to show that J quentails q. Let V \u2217 \u2286 V contain those variables that \u00b5 maps to a singleton \u223c-equivalence class. We now define V = {V1, . . . , Vm} as the finest partitioning on V \u2217 such that, for any x, y \u2208 V \u2217, x and y are in the same partition whenever r(x, y) \u2208 q for some r \u2208 rol(K). Next, we assign to every partition V \u2032 \u2208 V the set QV \u2032 of query atoms containing variables from V \u2032. We now construct for every V \u2032 an anchored n-component CV \u2032 and a function \u00b5V \u2032 (initialized as yielding \u2205 for all inputs) as follows:\n\u2022 For every x \u2208 V \u2032, let CV \u2032 contain the J -element \u03b4 for which \u00b5(x) = {\u03b4}. Note that \u2206I \u2032 consists of the \u223c-equivalence classes over elements from J , i.e., {\u03b4} is\none of the \u223c-equivalence classes from \u2206I\u2032 . Moreover, set \u00b5V \u2032(x) = \u00b5V \u2032(x)\u222a {\u03b4}. \u2022 For every r(x, y) \u2208 QV \u2032 with y 6\u2208 V \u2032 and \u00b5(x) = {\u03b4}, let CV \u2032 contain an addi-\ntional element \u03b4\u2032 \u2208 \u00b5(y) for which \u3008\u03b4, \u03b4\u2032\u3009 \u2208 rJ (existence assured by definition of collapsing via factorization) and all elements from some descending BCP in prune(J ) starting from \u03b4 (existence assured since [\u03b4\u2032]\u223c is not a singleton class). Moreover set \u00b5V \u2032(y) = \u00b5V \u2032(y) \u222a {\u03b4\u2032}. \u2022 Likewise, for every r(x, y) \u2208 QV \u2032 with x 6\u2208 V \u2032 and \u00b5(y) = {\u03b4}, let CV \u2032 contain an\nadditional element \u03b4\u2032 \u2208 \u00b5(x) for which \u3008\u03b4\u2032, \u03b4\u3009 \u2208 rJ (existence assured by definition of collapsing via factorization) and all elements from the shortest descending BCP in prune(J ) starting from \u03b4\u2032 (existence assured since [\u03b4\u2032]\u223c is not a singleton class). Moreover set \u00b5V \u2032(x) = \u00b5V \u2032(x) \u222a {\u03b4\u2032}.\nWe furthermore construct, for each query atom a that contains no variables from V \u2217, its own anchored n-component Ca and function \u00b5a (again initialized to always return \u2205) as follows:\n\u2022 If a = r(x, y), let Ca contain two nodes \u03b41 and \u03b42 for which \u03b41 \u2208 \u00b5(x) and \u03b42 \u2208 \u00b5(y) and \u3008\u03b41, \u03b42\u3009 \u2208 rJ (existence assured by definition via factorization) as well as some prune(J )-descending BCP starting from \u03b41 and the shortest prune(J )-descending BCP starting from \u03b42. \u2022 If a = A(x), let Ca contain a node \u03b4 for which \u03b4 \u2208 \u00b5(x) and \u03b4 \u2208 AJ (existence\nassured by definition via factorization) as well as the shortest prune(J )-descending BCP starting from \u03b4.\nLet C contain all CV \u2032 and Ca defined so far. Note that C already satisfies the conditions Q1-Q3 of Definition 27. We now have to add some more anchored n-components in order to satisfy condition Q4 as well. Let C\u2032 be initially empty. For any x \u2208 V where \u00b5(x) is a non-singleton equivalence class and any two C\u03b1, C\u03b2 \u2208 C with \u03b4 \u2208 \u00b5\u03b1(x) and \u03b4\u2032 \u2208 \u00b5\u03b2(x), we have that, since \u03b4 and \u03b4\u2032 are in the same \u223c-equivalence class \u00b5(x), there is a sequence \u03b41, . . . , \u03b4k of J -nodes with \u03b4 = \u03b41 and \u03b4\u2032 = \u03b4k and every \u03b4i and \u03b4i+1 start a descending BCP having the same path sketch. We enhance C\u2032 by one anchored component per \u03b4i which contains just \u03b4i and the corresponding descending\nBCPs. Then, by construction, the elements of C\u222aC\u2032 constitute the necessary anchored n-components to justify that J quentails q and, thus, J quentails u.\nAs an example for the correspondence between (query) entailment and quentailment, consider the conjunctive query\nq = {r(x1, x2), s(x2, x3), f(x4, x3), s(x5, x4)}.\nA match \u00b5 for this query into our example model from Figure 2 is displayed in the upper part of Figure 9, which witnesses I |= q. In the lower part, the anchored components C1 and C2 and according functions \u00b51 and \u00b52 establish \u2193(I) |\u2248 q."}, {"heading": "6. Limits and Forest Transformations", "text": "Before introducing the following constructions in detail, we will try to provide some highlevel explanation to convey the intuition behind the subsequent steps. As mentioned before, one of the major obstacles for a decision procedure for conjunctive query entailment is that\nfor DLs including inverses, nominals, and cardinality restrictions (or alternatively functionality), there are potentially infinitely many so-called \u201cnew nominals\u201d: domain elements which can be identified by being linked to a \u201cproper nominal\u201d via a BCP.\nHowever, we will show that for every model of a knowledge base that does not satisfy a conjunctive query (i.e., for every countermodel), there is a \u201cnice\u201d countermodel with only finitely many new nominals (in the subsequent section, we will then argue that this ensures the existence of a procedure that terminates when the query is not entailed by the knowledge base in question). We provide a construction which transforms an arbitrary countermodel into a \u201cnice\u201d one by first unraveling it into a quasi forest model, then substituting new nominals by uncritical elements and finally collapsing the result back into a proper model. For doing this, we have to find appropriate substitutes for most of the new nominals. Those substitutes have to fit in their environment without themselves introducing new nominals.\nDue to the global cardinality constraints that BCPs impose on their elements, the existence of infinitely many new nominals implies that their \u201cwitnessing\u201d BCPs must get longer and longer, such that by just looking at some finite-distance neighborhood, most of those new nominals just look like non-nominal domain elements. This state of affairs can be exploited by essentially constructing new domain elements as \u201cenvironment-limits\u201d. In a way, those new domain elements are characterized by the property that they can be approximated with arbitrary precision by already present domain elements \u2013 possibly without themselves being present in the domain.3 We will see in the following that those new domain elements can serve as the substitutes we are looking for.\nDefinition 29 (Limits of a Model). Let I = (\u2206I , \u00b7I) with \u03b4 \u2208 \u2206I be some model of an ALCOIFb knowledge base K. A tree interpretation J is said to be generated by \u03b4 (written: J C \u03b4), if it is isomorphic to the restriction of \u2193(I, \u03b4) to elements of {(\u03b4, cw) | (\u03b4, cw) \u2208 \u2206\u2193(I,\u03b4), c 6\u2208 H} for some H \u2286 IN.\nThe set of limits of I (written lim I) is the set of all tree interpretations J such that for every k \u2208 IN, there are infinitely many \u03b4 \u2208 \u2206I such that cutk(L) \u223c= cutk(J ) for some LC \u03b4. 4\nFigure 10 displays one limit element of our example model. The following lemma gives some useful properties of limits. Besides some rather obvious compatibility considerations with respect to knowledge base satisfaction, claim 3 of Lemma 30 provides us with the as pleasant as useful insight that the root node of a limit can never be part of a BCP at all.\nLemma 30. Let K be an ALCOIFb knowledge base, K\u2032 = nomFree(K), I a purified model of K, and n some fixed natural number. Then the following hold:\n1. Let L\u2032 be a tree interpretation such that there are infinitely many \u03b4 \u2208 \u2206I with L\u2032 \u223c= cutn(L) for some LC\u03b4. Then, there is at least one limit J \u2208 lim I such that cutn(J ) \u223c= L\u2032.\n2. Every J \u2208 lim I is locally K\u2032-consistent apart from its root (\u03c1, \u03b5).\n3. As an analogy, consider the fact that any real number can be approximated by a sequence of rational numbers, even if it is itself irrational.\n3. For every J \u2208 lim I it holds that its root (\u03c1, \u03b5) has no BCP to any (\u03c1, w) \u2208 \u2206J .\n4. If J \u2208 lim I contains a node \u03b4 starting two backwards counting paths with path sketches s1 and s2, then for any element \u03b4\u2217 in any unraveling holds: if the direct neighborhood of \u03b4\u2217 is isomorphic to that of \u03b4 and \u03b4\u2217 starts a descending BCP with path sketch s1 then it also starts a descending BCP with path sketch s2.\n5. Every J \u2208 lim I is collapsing-admissible.\nProof. 1. Let b be the branching degree of I, let Dn be the (by assumption infinite) set of all \u03b4 \u2208 \u2206I such that L\u2032 \u223c= cutn(L) for some L C \u03b4, and let Jn contain all those L. Starting with k = n, we now iteratively increase k and construct sets Jk and Dk and tree interpretations Lk. On our way, we inductively prove some properties. By induction hypothesis we know that Dk is infinite and there is some Lk with Lk \u223c= cutk(M) for all M\u2208 Jk. By Lemma 25, there are only finitely many non-isomorphic tree interpretations of depth k + 1 with branching degree b, and we can partition Jk into finitely many sets Jk,1, . . . , Jk,m such that every two M,M\u2032 from any Jk,i satisfy cutk+1(M) \u223c= cutk+1(M\u2032). Likewise, we can define classes Dk,1, . . . , Dk,m with Dk = Dk,1 \u222a . . . \u222a Dk,m such that \u03b4 \u2208 Dk,i if there is an L C \u03b4 with L \u2208 Jk,i. Now, as Dk is infinite, one of the Dk,i must be infinite as well and we can set Dk+1 = Dk,i and Jk+1 = Jk,i. Hence, we know that Dk+1 is infinite and there is some Lk+1 with Lk+1 \u223c= cutk+1(M) for all M\u2208 Jk+1. Thus, we have established an infinite sequence Ln,Ln+1, . . . with Li \u223c= cuti(Lj) for all j > i. Without loss of generality, we can assume that isomorphic nodes are named identically, i.e., we even have Li = cuti(Lj) for all j > i. Now we can define J as the (non-disjoint) union of all Li. This way we have established the structure J for which cutk(J ) = Lk and we know that for every k there are infinitely many \u03b4 (namely all elements from Dk) such that cutk(L) \u223c= Lk for some LC \u03b4. Hence this J is the limit element with the desired properties.\n2. Let (\u03c1, w) with w 6= \u03b5 be a node in J . Now choose a \u03b4 \u2208 \u2206I such that cut|w|+1(L) \u223c= cut|w|+1(J ) for some L C \u03b4 (by definition, there are even infinitely many such \u03b4s to\nchoose from). Then L contains a node \u03b4\u2217 whose direct neighborhood is isomorphic to that of (\u03c1, w). However, as L is contained in \u2193(I, \u03b4) and I |= K by assumption, it is locally K\u2032-consistent and hence \u03b4\u2217 is. Therefore (\u03c1, w) is locally K\u2032-consistent in J .\n3. Assume the contrary, i.e., that some J \u2208 lim I has a BCP from the root (\u03c1, \u03b5) to some (\u03c1, w) \u2208 \u2206J with (\u03c1, w) \u2208 NJo for some o \u2208 nom(K). Since we have only functionality and by definition of BCPs, a BCP uniquely identifies one domain individual. By definition of lim I, however, there are infinitely many \u03b4 \u2208 \u2206I satisfying cut|w|(L) \u223c= cut|w|(J ) for some J C \u03b4 and we have an infinite number of individuals with the same counting path to oI . This is a contradiction.\n4. Choose k to be the maximum length of the two BCPs. By definition of the limit, I contains an element \u03b3 such that cut|w|+k(L) \u223c= cut|w|+k(J ) for some L C \u03b3. Now, let \u03b4\u2032 \u2208 \u2206L be the element that (with respect to this isomorphism) corresponds to \u03b4 \u2208 \u2206J . Then, \u03b4\u2032 is the origin of two descending BCPs with path sketches s1 and s2. Let Tail(\u03b4\u2032) = \u03b3\u2032. Since path sketches of descending BCPs uniquely identify one domain individual, every node \u03b4\u2217 in any unraveling that starts a descending BCP with path sketch s1 must have been caused by \u03b3\u2032 as well. Furthermore (as their direct neighborhoods are isomorphic and by the specific design of the choose function from Definition 12 which renders all successors non-isomorphic), all successors of \u03b4\u2217\nuniquely correspond to neighbors of \u03b3\u2032 and in turn to successors of \u03b4\u2032.\nThis in turn implies that, for every successor of \u03b4\u2217, one finds a successor of \u03b4\u2032 with isomorphic direct neighbourhood. Yet, this synchronicity argument can be inductively applied and thereby iterated down the BCP. Thus, we obtain that \u03b4\u2217 also starts a descending BCP with path sketch s2.\n5. We define the function ch : (cl(K) \u00d7 \u2206J ) \u2192 \u2206J essentially like in the proof of Lemma 19, namely by referring to the function choose. For a given element \u03b4 \u2208 \u2206J that starts a BCP of length ` in J , choose a \u03b4\u2032 \u2208 \u2206I such that cut|\u03b4|+`(L) \u223c= cut|\u03b4|+`(J ) for some LC \u03b4\u2032. As L is contained in \u2193(I, \u03b4\u2032), we can now proceed and define ch(C, \u03b4) as demonstrated in the proof of Lemma 19.\nHaving defined limit elements as convenient building blocks for restructuring forest quasi-interpretations, the following definition provides the first hints on where inside such a structure one existing node (and all its successors) can safely be exchanged by a limit element.\nDefinition 31 (n-Secure Replacement). Let K be an ALCOIFb knowledge base, I a model for K, J some forest quasi-model for K with \u03b4 \u2208 \u2206J . A strict tree quasi-interpretation J \u2032 \u2208 lim I is called an n-secure replacement for \u03b4 if\n\u2022 cutn(\u2193(J , \u03b4)) is isomorphic to cutn(J \u2032),\n\u2022 for every anchored n-component of J \u2032 with witness \u03b4\u2032, there is an isomorphic anchored n-component of J with witness \u03b4.\nIf a \u03b4 \u2208 \u2206J has an n-secure replacement in lim I, we call \u03b4 n-replaceable w.r.t. I, otherwise we call \u03b4 n-irreplaceable w.r.t. I. 4\nFigure 11 displays a 3-secure replacement in the considered unraveling of our example model.\nAfter having defined which elements of a forest quasi-model are eligible for being replaced by a limit element, we have to make sure that not too many elements (actually defined in terms of the original model) are exempt from being replaced.\nLemma 32. Every purified model I of an ALCOIFb knowledge base K contains only finitely many distinct elements that start a BCP and are the cause for n-irreplaceable nodes in the unraveling of I.\nProof. Assume the converse: let a purified model I of K contain an infinite set D of elements giving rise to n-irreplaceable nodes in \u2193(I). Then there must be an L\u2032 such that there is an infinite set D\u2032 \u2286 D such that every d\u2032 \u2208 D\u2032 generates an L for which cutn(L) \u223c= L (since by Lemma 25, there are only finitely many non-isomorphic choices for L\u2032). This set D\u2032 can be used to guide the construction of a specific limit element J \u2208 lim I according to Lemma 30.1. Now, for an element (\u03c1, w) from J starting a BCP, let l(\u03c1,w) \u2208 IN be the length of the shortest such BCP starting from (\u03c1, w). Then, let k be the maximum over all l(\u03c1,w) of individuals (\u03c1, w) from J that start a BCP and for which |w| \u2264 n. By construction, D\u2032 contains one element d\u2032\u2032 generating an L with cutk(L) \u223c= cutk(J ) (actually infinitely many). By the choice of k and Lemma 30.4, we can conclude that J is an n-secure replacement for the irreplaceable \u2193(I)-node caused by d\u2032\u2032 which contradicts the fact that d\u2032\u2032 \u2208 D.\nNow we know, which elements of a forest quasi-model can be replaced by a suitable limit element. The following definition exactly tells us, how such a replacement is carried out: the respective element and all its successors are deleted and the limit element (together with its successors) is inserted at the same position.\nDefinition 33 (Replacement Step). Let K be an ALCOIFb knowledge base, I a model of K, and J a forest quasi-model of K, i.e., J |= K\u2032 = nomFree(K). Let (\u03c1, w) \u2208 \u2206J be n-replaceable w.r.t. I and J \u2032 an according n-replacement for (\u03c1, w) from lim I with root (\u03c2, \u03b5).\nWe define the result of replacing (\u03c1, w) by J \u2032 as the interpretation R where\n\u2022 \u2206R = \u2206Jred \u222a {(\u03c1, ww \u2032\u2032) | (\u03c2, w\u2032\u2032) \u2208 \u2206J \u2032} with \u2206Jred = (\u2206 J \\ {(\u03c1, ww\u2032) | |w\u2032| > 1})\n\u2022 for each A \u2208 con(K\u2032), AR = (AJ \u2229\u2206Jred) \u222a {(\u03c1, ww \u2032) | (\u03c2, w\u2032) \u2208 AJ \u2032}\n\u2022 for each r \u2208 rol(K\u2032), rR = (rJ \u2229\u2206Jred\u00d7\u2206 J red)\u222a{\u3008(\u03c1, ww \u2032), (\u03c1, ww\u2032\u2032)\u3009 | \u3008(\u03c2, w\u2032), (\u03c2, w\u2032\u2032)\u3009 \u2208 rJ \u2032}\n4\nFigure 12 displays the result of carrying out this replacement step on our example. The following lemma assures that during a replacement as described above, no new anchored n-components are introduced, instead all anchored n-components present after an n-secure transformation were present before or completely contained in the inserted limit element.\nLemma 34. Let K be an ALCOIFb knowledge base, I a model for K, J a forest quasimodel for K, i.e., J |= K\u2032 = nomFree(K), and let (\u03c1, w) \u2208 \u2206J be n-replaceable w.r.t. I. Let J \u2032 be an n-replacement for (\u03c1, w) with root (\u03c2, \u03b5) and R be the result of replacing (\u03c1, w) by J \u2032. Then the following hold:\n1. cutn(\u2193(J , (\u03c1, w))) is isomorphic to cutn(\u2193(R, (\u03c1, w))).\n2. If n \u2265 1, then R is locally K\u2032-consistent.\n3. Whenever R contains an anchored n-component C, then one of J or J \u2032 contains an anchored n-component isomorphic to C.\nProof. 1. This is a direct consequence from Definitions 31 and 33.\n2. We make a case distinction when element-wise investigating local consistency of R (note that K and K\u2032 are simplified and that local consistency of a node (\u03c1, v) \u2208 \u2206R depends only on this node and its direct neighbors):\n\u2022 v = ww\u2032 for some w\u2032 6= \u03b5: then the direct neighborhood of (\u03c1, v) in R is isomorphic to the direct neighborhood of (\u03c2, w\u2032) in J \u2032 (recall that (\u03c2, \u03b5) is the root of J \u2032). By Lemma 30.2, J \u2032 is locally K\u2032-consistent except possibly for (\u03c2, \u03b5). Hence also (\u03c1, v) is locally K\u2032-consistent in R. \u2022 v 6= ww\u2032 for any w\u2032, i.e., (\u03c1, v) was not affected by the replacement: then the\ndirect neighborhood of (\u03c1, v) has not changed by the replacement and, therefore, the neighborhoods of (\u03c1, v) in J and R coincide. As J is locally K\u2032-consistent by assumption, so is (\u03c1, v) in R. \u2022 v = w: in that case, the direct neighborhood of (\u03c1, v) has changed but remained\nisomorphic. This follows from the preceding statement (34.1).\n3. Let (\u03c1\u2032, w\u2032) be the witness of C. We distinguish three cases:\n\u2022 \u03c1\u2032 = \u03c1 and w is a prefix of w\u2032. Then, clearly C is completely contained in J \u2032. \u2022 \u03c1\u2032 = \u03c1 and w\u2032 is a prefix of w. Let C\u2032 be the structure obtained by restricting C\nto all elements of the form (\u03c1, ww\u2032\u2032) and then renaming every element (\u03c1, ww\u2032\u2032) to (\u03c2, w\u2032\u2032), where (\u03c2, \u03b5) is the root of J \u2032. Then C\u2032 is an anchored n-component in J \u2032 with witness (\u03c2, \u03b5). Now, by definition of replacing, J must contain an isomorphic copy of C\u2032 with witness (\u03c1, w). Since the other part of C (consisting of those nodes (\u03c1\u2032, w\u2032) such that w is not a prefix of w\u2032) has not been altered by the replacement, we can conclude that J must contain an isomorphic copy of C. \u2022 Neither of the above. Then, (\u03c1\u2032, w\u2032) and the subtree rooted in (\u03c1\u2032, w\u2032) is contained\nin J as this part of J has not been affected by the replacement. Then, clearly also C is contained in J .\nWe are now ready for defining the whole process of restructuring a forest quasi-model essentially by substituting as many nodes as possible by appropriate limit elements.\nDefinition 35 (n-Secure Transformation). Let I be a model of some ALCOIFb knowledge base K and J an unraveling for I. An interpretation J \u2032 is called an n-secure transformation of J if it is obtained by (possibly infinitely) repeating the following step:\nChoose one unvisited and w.r.t. tree-depth minimal node (\u03c1, w) that is n-replaceable w.r.t. I. Replace (\u03c1, w) with one of its n-secure replacements from lim I and mark (\u03c1, w) as visited. 4\nNote that this is well-defined as every node is visited at most once and no formerly irreplaceable node ever becomes replaceable. Hence for every k \u2208 IN, the \u201cinitial segment\u201d cutk(J ) of the current intermediate structure J is already isomorphic to the initial segment cutk(J \u2032) of J \u2032 after a bounded number of replacement steps, due to the fact that all involved structures have bounded branching degree.\nBy now, the whole effort might still look a bit contrived and pointless, however, the following lemma establishes a bunch of properties that in the end allow us to deduce the existence of a very well-behaved countermodel whenever there is any at all.\nWe show that the process of unraveling, n-secure transformation and collapsing preserves the property of being a model of a knowledge base and (with the right choice of n) also preserves the property of not entailing a conjunctive query. Moreover, this model conversion process ensures that the resulting model contains only finitely many new nominals (witnessed by a bound on the length of BCPs). Figure 13 illustrates these properties for our example model. Note that only two new nominals are left whereas collapsing the original unraveling yields infinitely many.\nLemma 36. Let I be a purified model of some ALCOIFb knowledge base K, J an unraveling of I, and J \u2032 an n-secure transformation of J . Then the following hold:\n1. J \u2032 is a strict forest quasi-model for K.\n2. J \u2032 is collapsing-admissible.\n3. collapse(J \u2032) is a model of K.\n4. There is a natural number m such that J \u2032 does not contain any node whose shortest descending BCP has a length greater than m.\n5. If J \u2032 contains an anchored n-component C, then J contains an anchored n-component isomorphic to C.\n6. If, for some union of conjunctive queries u = q1 \u2228 . . . \u2228 qh, we have J |6\u2248u and n > maxq\u2208{q1,...,qh} ](q), then J \u2032 |6\u2248u.\n7. If, for some union of conjunctive queries u = q1 \u2228 . . . \u2228 qh, we have I 6|= u and n > maxq\u2208{q1,...,qh} ](q), then collapse(J \u2032) 6|= u.\nProof. 1. Let K\u2032 = nomFree(K). Due to Lemma 13, J is a strict forest quasi-model for K. By Lemma 34.2, each replacement step preserves local K\u2032-consistency and results, thus, in a forest quasi-model for K. Since each n-replacement is a strict tree quasi-interpretation also strictness is preserved. By induction it follows that every interpretation produced in the n-secure transformation procedure is a strict forest quasimodel for K. For every node in J \u2032, its direct predecessor and direct successors have not changed any more after finitely many replacement steps and local K\u2032-consistency depends solely on those neighbors. Hence J \u2032 is also locally K\u2032-consistent.\n2. By Lemma 19, J is collapsing-admissible, by Lemma 30.5 every limit of I is. Moreover, as is obvious from the proofs of both propositions, it is possible to define the respective ch-functions recurring to the original choose-function on I, hence every two elements from (even different) unravelings or limits that start descending BCPs with identical path sketches correspond to the very same element in I whence the separate ch-functions are compatible with each other. Therefore, replacing an element in the unraveling yields a strict forest quasi-model that is collapsing-admissible. Applying the same argument inductively yields that every intermediate strict forest quasi-model during the n-secure transformation is collapsing-admissible. Finally, as the according ch-function stabilizes after finitely many replacement steps (together with the neighborhood of the considered elements), also J \u2032 is collapsing-admissible.\n3. This follows from the two previous facts (36.1 and 36.2) together with Lemma 20.\n4. Consider the set D of all \u03b4 \u2208 \u2206I causing n-irreplaceable nodes in J . By Lemma 32, D is finite. We obtain D\u2032 by removing all \u03b4 from D that do not start any descending BCPs.\nFor \u03b4 \u2208 D\u2032, let dBCP(\u03b4) denote the set of descending BCPs starting in \u03b4 and choose\nm := max \u03b4\u2208D\u2032\n( min p\u2208dBCP(\u03b4) |p| )\nNow assume there were a \u03b4\u2032 \u2208 \u2206I having a shortest descending BCP of length greater than m. Obviously, as \u03b4\u2032 6\u2208 D\u2032, there must be a (\u03c1, w) generated by \u03b4\u2032 that is nreplaceable. However, during the n-secure transformation all n-replaceable elements have been replaced by elements that do not start any descending BCPs at all due to Lemma 30.3.\n5. We prove this by induction on the replacement steps of the n-secure transformation process by showing that this is true for every intermediate replacement result R\u2032.\nThe claim for J \u2032 then follows from the fact that, for every considered C (which is always finite), only a finite part cut`(J \u2032) is relevant and that for every `, there is a bounded number of replacement steps after which we have cut`(R\u2032) = cut`(J \u2032) for every further intermediate R\u2032.\nAs base case (zero replacement steps carried out), we find that for R\u2032 = J , the claim is trivially true.\nNow assume that the claim has been established for R and has to be shown for R\u2032 that is created by replacing (\u03c1, w) in R with some J \u2032\u2032. By Lemma 34.3, we then know that one of the following is the case:\n\u2022 R contains C. Yet, we can apply the induction hypothesis and conclude that also J contains C as claimed.\n\u2022 J \u2032\u2032 contains C. But, since C is finite, it is already contained in cutk(J \u2032\u2032) for some k \u2208 IN and, as J \u2032\u2032 is a limit element, we find one \u03b4 \u2208 \u2206I with cutk(\u2193(I, \u03b4)) = cutk(J \u2032\u2032). Since I is purified, we find a (\u03c1, w) \u2208 \u2206J that corresponds to \u03b4, i.e., J contains an isomorphic copy of \u2193(I, \u03b4) which in turn contains an isomorphic copy of C.\n6. This is actually a straightforward consequence from the preceding proposition and the definition of quentailment.\nFor the indirect proof, we suppose J |6\u2248u and n > maxq\u2208{q1,...,qh} ](q) and J \u2032 |\u2248u, the latter witnessed by J \u2032 |\u2248 q for a q \u2208 {q1, . . . , qh}. By definition, the latter assures the existence of adequate anchored n-components in J \u2032. Then, applying the preceding proposition (36.5), we obtain that isomorphic copies of all those anchored n-components are contained in J which, by definition, just means J |\u2248 q and, therefore, J |\u2248u. Hence, we have a contradiction, which proves the claim.\n7. We prove this indirectly, so assume I 6|= u, n > maxq\u2208{q1,...,qh} ](q), and collapse(J \u2032) |=\nu, witnessed by collapse(J \u2032) |= q for a q \u2208 {q1, . . . , qh}.\nThen, from Lemma 28.2, it follows that J \u2032 |\u2248 q. By the previous proposition (36.6), we conclude J |\u2248 q, which in turn implies I |= q by Lemma 28.1. This implies I |= u, a contradiction.\nNow we are able to establish our first milestone on the way to showing finite representability of countermodels.\nTheorem 37. For every ALCOIFb knowledge base K with K 6|= u, there is a forest model I of K with finitely many roots such that I 6|= u. Moreover, I has bounded branching degree.\nProof. Let u = q1 \u2228 . . . \u2228 qh. Since an inconsistent knowledge base entails every query, we can assume that K is consistent and, since K 6|= u, there is a model I of K with I 6|= u. Choose an n > maxq\u2208{q1,...,qh} ](q) and let J\n\u2032 be obtained by carrying out an n-secure transformation on \u2193(I) and let I \u2032 = collapse(J \u2032). We know that I \u2032 is a model of K (via Lemma 36.3) and that I \u2032 6|= u (by Lemma 36.7).\nBy Lemma 36.4, we know that there is a fixed natural number m such that the shortest descending BCP started by any node in J \u2032 is shorter than m. Note that there are only finitely many path sketches of length \u2264 m. This means that every node in J \u2032 that starts a descending BCP at all can be assigned to one such path sketch. However, this entails that there are only finitely many elements (i.e., \u223c-equivalence classes) in I \u2032 that contain J \u2032-elements starting descending BCPs in J \u2032. This implies, via Lemma 24, that I \u2032 contains only finitely many roots.\nThe fact that I \u2032 has bounded branching degree is a direct consequence from the fact that the initial unraveling has bounded branching degree, that replacement do not change the branching degree nor do collapsings as assured by Lemma 20."}, {"heading": "7. Finite Representations of Models", "text": "In this section, we show how we can construct a finite representation of a forest model of a knowledge base that has only a finite number of roots. We then show that these finite representations can be used to check query entailment. In order to do this, we use a technique that is very similar to the blocking techniques used in tableau algorithms (see, e.g., Horrocks & Sattler, 2007). A tableau algorithm builds a so-called completion graph that is a finite representation of a model. A completion graph has essentially the same structure as our forest quasi-models. It contains root nodes for the nominals occurring in the input knowledge base plus further root nodes for new nominals that start BCPs. Each (new and old) nominal is the root of a tree, and relations only occur between direct neighbors within a tree, between elements within a tree and a root, or between the roots. An initial completion graph contains only nodes for the nominals occurring in the input knowledge base. Concepts are expanded according to a set of expansion rules, and new nodes are added to the graph when expanding existential restrictions. New nominals are added by the so-called NN-rule whenever an element from within a tree has a relationship with an inverse functional role to a root node that represents a nominal from the input knowledge base, i.e., when a BCP is created. In order to obtain a finite representation, tableau algorithms usually employ some cycle detection mechanism, called blocking. Otherwise the depth of the trees and the number of new nominals might grow infinitely. For logics as expressive as ALCOIFb, blocking usually requires two pairs of elements. In our notation, a (non-root) node n with predecessor n\u2032 blocks a node m with predecessor m\u2032, if \u3008n\u2032, n\u3009 \u223c= \u3008m\u2032,m\u3009. In order to obtain a real model from the finite representation, the part between n and m is copied and appended infinitely often. We use a similar technique to obtain a finite representation for a forest model. Since we want to preserve non-entailment, working with just pairs of elements is not sufficient. Instead, we take the length n of the query into account and use isomorphic trees of depth n to define blocking. This technique has first been employed for deciding query entailment in ALCN with role conjunctions (Levy & Rousset, 1998) and has recently been extended to the logics ALCHIQ, ALCHOQ, and ALCHOI (Ortiz, 2008;\nOrtiz et al., 2008a) and extends, as our result, to the DLs SHIQ, SHOQ, and SHOI (i.e., with transitivity) as long as the query contains only simple roles.\nAs for forest quasi-interpretations, we use isomorphisms between forest interpretations or parts of them.\nDefinition 38 (Isomorphism between Forest Interpretations). Let K be an ALCOIFb knowledge base and I = (\u2206I , \u00b7I), I \u2032 = (\u2206I\u2032 , \u00b7I\u2032) two forest interpretations of K. Without loss of generality, we assume from now on that each root \u03b4 = (\u03c1, \u03b5) \u2208 \u2206I is in the extension of a unique concept N\u03b4 that does not occur in con(K). Then I and I \u2032 are called isomorphic w.r.t. K, written: I \u223c=K I \u2032, iff there is a bijection \u03d5 : \u2206I \u2192 \u2206I \u2032 such that:\n\u2022 \u03b41 is a successor of \u03b42 iff \u03d5(\u03b41) is a successor of \u03d5(\u03b42) for all \u03b41, \u03b42 \u2208 \u2206I ,\n\u2022 \u3008\u03b41, \u03b42\u3009 \u2208 rI iff \u3008\u03d5(\u03b41), \u03d5(\u03b42)\u3009 \u2208 rI \u2032 for all \u03b41, \u03b42 \u2208 \u2206I and r \u2208 rol(K),\n\u2022 \u03b4 \u2208 AI iff \u03d5(\u03b4) \u2208 AI\u2032 for all \u03b4 \u2208 \u2206I and A \u2208 con(K) \u222a {N\u03b4 | \u03b4 = (\u03c1, \u03b5) \u2208 \u2206I}.\n\u2022 \u03b4 = oI iff \u03d5(\u03b4) = oI\u2032 for all \u03b4 \u2208 \u2206I and o \u2208 nom(K). 4\nUsually, we omit the subscript K from \u223c=K and assume that it is clear from the context.\nDefinition 39 (n-Blocking). Let n \u2208 IN be a fixed natural number and I = (\u2206I , \u00b7I) with (\u03b4, w) \u2208 \u2206I , w 6= \u03b5 a forest interpretation for some ALCOIFb knowledge base K. An n-blocking-tree w.r.t. (\u03b4, w), denoted blocknI(\u03b4, w), is the interpretation obtained from I by restricting I to elements in {(\u03b4, ww\u2032) | |w\u2032| \u2264 n} \u222a {(\u03c1, \u03b5) | (\u03c1, \u03b5) \u2208 \u2206I}. An n-blocking-tree blocknI(\u03b4, w) n-blocks an n-blocking-tree block n I(\u03b4, ww \u2032) if\n1. blocknI(\u03b4, w) and block n I(\u03b4, ww \u2032) have disjoint domains except for root elements,\n2. there is a bijection \u03d5 from elements in blocknI(\u03b4, w) to elements in block n I(\u03b4, ww \u2032) that witnesses blocknI(\u03b4, w) \u223c= blocknI(\u03b4, ww\u2032), and\n3. for each descendant (\u03b4, wv) of (\u03b4, w), there is no inverse functional role f and root (\u03c1, \u03b5) \u2208 \u2206I such that \u3008(\u03b4, wv), (\u03c1, \u03b5)\u3009 \u2208 fI .\nA node (\u03b4, v) \u2208 \u2206I is n-blocked, if (\u03b4, v) is either directly or indirectly n-blocked ; (\u03b4, v) is indirectly n-blocked, if one of its ancestors is n-blocked; (\u03b4, v) is directly n-blocked if none of its ancestors is n-blocked and (\u03b4, v) is a leaf of some n-blocking-tree blocknI(\u03b4, ww\n\u2032) in I that is n-blocked; in this case we say that (\u03b4, v) is (directly) n-blocked by \u03d5\u2212(\u03b4, ww\u2032) for \u03d5 the bijection witnessing \u223c=.\nWithout loss of generality, we assume that the n-blocking-trees used above are minimal w.r.t. the order of elements in \u2206I (cf. Definition 16).\nA forest interpretation I = (\u2206I , \u00b7I) for K is an n-representation of K if\n1. \u2206I is finite,\n2. \u2206I contains no indirectly n-blocked nodes,\n3. for each o \u2208 nom(K), there is one element of the form (\u03c1, \u03b5) \u2208 \u2206I such that oI = (\u03c1, \u03b5)I ,\n4. each element that is not directly n-blocked is locally K-consistent. 4\nNote that n = 1 is more restrictive than standard pairwise blocking since two trees of depth one need to be isomorphic before blocking occurs, whereas standard blocking already occurs for two isomorphic pairs of nodes. For DLs as expressive as ALCOIFb, however, n has to be greater than 0 (at least trees of depth 1) if we want to transform n-representations into models of the knowledge base. We now show that each knowledge base has an n-representation for some fixed n \u2208 IN and, afterwards, that we can use an n-representation to build a model for the knowledge base.\nLemma 40. Let K be a consistent ALCOIFb knowledge base and u = q1\u2228 . . .\u2228 qh a union of conjunctive queries and n a fixed natural number greater than max1\u2264i\u2264h|qi|. If K 6|= u, then there is an n-representation of K that does not satisfy u.\nProof. By assumption, K is consistent and K 6|= u. Then, by Theorem 37, there is a forest model I of K with finitely many roots and branching degree bounded in |cl(K)|, and for all q \u2208 {q1, . . . , qh} holds I 6|= q. We show that we can find an n-representation R for I.\nWe use a similar argumentation as in Lemma 25 to show that there are only finitely many non-isomorphic n-blocking trees. We again denote this bound by Tn. Let c = |cl(K)|, r = |rol(K)|, and m the (finite) number of roots in I. Each root \u03c1 \u2208 \u2206I is annotated with a special concept N\u03c1 by assumption. For n = 0, we again have 2c choices. For n > 0, each element can have between 0 and c successors and between 0 and m relations with roots. For roots we have 2c+m choices for the concepts. We use 2cm as bound for the choice of concepts for roots and this clearly bounds the choice for non-roots as well. Each non-root node in a level smaller than n is the root of a tree with depth n \u2212 1 and each node in the sub-tree can again have up to m relations to a root. Assuming that we have only a single role name r \u2208 rol(K), we get a bound of O(2ccmT cmn\u22121) for the number of non-isomorphic sub-trees of depth n with relations to the at most m roots. Since we have not only one but a choice of r roles, we get a bound of O(2c(cmT cmn\u22121) r). We now abbreviate 2c(cm)r with x and cmr with a and rewrite the obtained bound as Tn = O(x(Tn\u22121)a). Unfolding yields Tn = O((x1+a+...+a n\u22121 )(T0)a n ) which is bounded by O((xa n )(2c)a n ) = O((x2c)a n ). By expanding the abbreviated symbols, we obtain a bound for Tn of O((2c(cm)r)(cmr) n ).\nTogether with the fact that I is obtained from a collapsing and relations from elements within a tree to a root in collapsings are never for inverse functional roles, this shows that there is an n-representation of I because for each tree rooted in a node (\u03b4, \u03b5) \u2208 \u2206I with depth greater than Tn, there are two nodes (\u03b4, w) and (\u03b4, ww\u2032) such that blocknI(\u03b4, w) n-blocks blocknI(\u03b4, ww\n\u2032), and we can simply discard indirectly n-blocked nodes from I to obtain the desired n-representation.\nSince I 6|= q and the n-representation is a restriction of I, non-entailment of q is clearly preserved.\nPlease note that we would not obtain such a bound if we had not fixed a bound on the number of new nominals (roots) beforehand and that we cannot use the standard tableau algorithms to obtain this result. The reason for this is that the number of new nominals (roots) in the tableau algorithms depends on the length of the longest path before blocking\noccurs. For our n-blocking-trees, however, we also have to consider relations back to the roots, which means that blocking occurs the later the more roots we have. On the other hand, delaying blocking may lead to the introduction of more and more new roots. Due to this cyclic argument, termination cannot be guaranteed for the tableau algorithms unless we have fixed a bound on the number of new nominals beforehand. This is also the reason why the tableau algorithm for entailment of conjunctive queries with only simple roles in the query of Calvanese et al. (2009) is sound, complete, and terminating on SHIQ, SHOQ, and SHOI knowledge bases, but is not guaranteed to terminate on SHOIQ knowledge bases (transitivity, i.e., having a DL with S instead of ALC does not have any impact on this).\nWe now show, how we can obtain a model for a knowledge base K from some nrepresentation of K. We use a technique that is directly inspired from tableau algorithms and resembles the process of building a tableau from a complete and clash-free completion graph. In particular the tableau algorithm by Ortiz et al. (Ortiz, 2008; Ortiz et al., 2008a) is very similar as it also uses tree blocking.\nDefinition 41 (Models for n-Representations). Let R = (\u2206R, \u00b7R) be an n-representation of some ALCOIFb knowledge base K. Let s = \u03b4\n\u2032 1 \u03b41 , . . . , \u03b4 \u2032 m \u03b4m\nbe a sequence of pairs of elements from \u2206R. With |s| we denote the length m of s. For such a sequence s, we set last\u2217(s) = \u03b4\u2032m and last\u2217(s) = \u03b4m. By s | \u03b4\u2032m+1 \u03b4m+1 we denote the sequence \u03b4 \u2032 1 \u03b41 , . . . , \u03b4 \u2032 m \u03b4m , \u03b4\u2032m+1 \u03b4m+1\n. The set of R-induced elements, denoted elem(R), is inductively defined as follows:\n\u2022 If \u03b4 = (\u03c1, \u03b5) \u2208 \u2206R, then \u03b4\u03b4 \u2208 elem(R).\n\u2022 If s \u2208 elem(R), \u03b4 = (\u03c1, w) \u2208 \u2206R, \u03b4 is not n-blocked, and \u03b4 is a successor of last\u2217(s), then s | \u03b4\u03b4 \u2208 elem(R).\n\u2022 If s \u2208 elem(R), \u03b4 = (\u03c1, w) \u2208 \u2206R, \u03b4 is directly n-blocked by some \u03b4\u2032 \u2208 \u2206R, and \u03b4 is a successor of last\u2217(s), then s | \u03b4\u2032\u03b4 \u2208 elem(R). We define the interpretation I = (\u2206I , \u00b7I) induced by R as follows:\n\u2022 \u2206I = elem(R),\n\u2022 for each s \u2208 \u2206I and A \u2208 con(K), s \u2208 AI iff last\u2217(s) \u2208 AR,\n\u2022 for each s \u2208 \u2206I and o \u2208 nom(K), s = oI iff last\u2217(s) = oR,\n\u2022 for each s, s\u2032 \u2208 \u2206I and r \u2208 rol(K), rI =\n{\u3008s, s\u2032\u3009 | s\u2032 = s | \u03b4\u2032\u03b4 and \u3008last \u2217(s), last\u2217(s\u2032)\u3009 \u2208 rR}\u222a {\u3008s, s\u2032\u3009 | s = s\u2032 | \u03b4\u2032\u03b4 and \u3008last\u2217(s), last \u2217(s\u2032)\u3009 \u2208 rR}\u222a {\u3008s, s\u2032\u3009 | s\u2032 = \u03b4\u03b4 and \u3008last \u2217(s), \u03b4\u3009 \u2208 rR}\u222a {\u3008s, s\u2032\u3009 | s = \u03b4\u03b4 and \u3008\u03b4, last \u2217(s\u2032)\u3009 \u2208 rR}.\n4\nThe interpretation of nominals is well-defined since n-representations are forest interpretations for K (hence, there is a unique root for each nominal) and pairs \u03b4\u03b4 with \u03b4 = (\u03c1, \u03b5) are never appended to sequences in elem(R).\nLemma 42. Let K be a consistent ALCOIFb knowledge base, u = q1 \u2228 . . .\u2228 qh a union of conjunctive queries, and n \u2265 1 a fixed natural number greater than max1\u2264i\u2264h|qi|. If R is an n-representation of K such that R 6|= u, then there is a model I of K such that I 6|= u.\nThe proof is essentially as the one by Ortiz et al. (2008a), but adapted to our case, where we work completely on interpretations. Our n-representations correspond to completion graphs and our models to tableaux in their case.\nProof. Let I be an interpretation induced by R. Since n-representations do not contain relations from an element within a tree to a root for an inverse functional role by definition, functionality restrictions are not violated in I. Further, since K is simplified andR is a forest interpretation for K such that all elements apart from (directly) n-blocked ones are locally K-consistent, it is quite straightforward that each element in the induced interpretation is locally K-consistent. Together with the restriction on nominals (property 3), this implies that I is a model for K. This is essentially the same principle as the one used to prove that tableaux constructed from completion graphs are proper representations of models of the input knowledge base.\nAssume, to the contrary of what is to be shown, that I |= u. Then there is a disjunct q \u2208 {q1, . . . , qh} and a match \u00b5 for q such that I |=\u00b5 q. We use \u00b5 to construct a match \u03c0 for q in R by \u201cshifting\u201d the mapping for variables into parts that have no direct counterpart in R upwards.\nWe define the match graph G for q in I as an undirected graph containing a node s for each s \u2208 \u2206I such that \u00b5(x) = s for some x \u2208 var(q) and containing an edge \u3008s, s\u2032\u3009 for each s, s\u2032 \u2208 \u2206I such that there is an atom r(x, y) \u2208 q, \u00b5(x) = s, and \u00b5(y) = s\u2032. We call nodes of G that correspond to roots in \u2206I root nodes of G (i.e., nodes s such that s = \u03b4\u03b4 ) and we call all other nodes tree nodes. Note that the restriction of G to tree nodes is a set of trees that we refer to as G1, . . . , Gk and that each such tree has a depth smaller than n.\nFor each x \u2208 var(q) such that \u00b5(x) = \u03b4\u03b4 ( \u03b4 \u03b4 is a root node in G), we set \u03c0(x) = last \u2217( \u03b4\u03b4 ). Note that \u03b4 is a root node in R.\nFor each Gi \u2208 {G1, . . . , Gk}, we distinguish two situations:\n1. Gi contains a node s such that last\u2217(s) 6= last\u2217(s) (i.e., Gi contains a path from within an n-blocking tree to a copy of the path starting from the node that blocks). Due to the use of n-blocking, a single tree Gi can never cover more than one n-blocking tree and it can use at most nodes from two n-blocking trees (leaving one and then entering the next one in less than n steps). For each node s\u2032 in Gi such that |s\u2032| < |s| and x \u2208 var(q) such that \u00b5(x) = s\u2032, we set \u03c0(x) = \u03d5(last\u2217(s\u2032)). For each s\u2032 in Gi with |s\u2032| \u2265 |s| and x \u2208 var(q) such that \u00b5(x) = s\u2032, we set \u03c0(x) = last\u2217(s\u2032).\n2. Gi contains no node s such that last\u2217(s) 6= last\u2217(s) (i.e., Gi contains a path that lies completely within an n-blocking tree or from a path outside of an n-blocking-tree into an n-blocking-tree). For each node s in Gi and x \u2208 var(q) such that \u00b5(x) = s, we set \u03c0(x) = last\u2217(s).\nBy definition of \u03c0, I as an induced model of R, and n-blocking, we immediately have that, for each A(x) \u2208 q, \u03c0(x) \u2208 AR. We show that, for each r(x, y) \u2208 q, \u3008\u03c0(x), \u03c0(y)\u3009 \u2208 rR, which proves R |= q. We distinguish three cases:\n1. \u00b5(x) = \u03b4\u03b4 for some \u03b4 \u2208 \u2206 R. Then \u03c0(x) = \u03b4 = (\u03c1, \u03b5) \u2208 \u2206R. We distinguish three cases\nfor \u00b5(y):\n(a) \u00b5(y) = \u03b4 \u2032 \u03b4\u2032 is also a root, then \u03c0(y) = \u03b4 \u2032 = (\u03c1\u2032, \u03b5) \u2208 \u2206R and, since \u00b5 is a match\nfor q in I and by definition of I as an induced interpretation of R, we have that \u3008\u03c0(x), \u03c0(y)\u3009 = \u3008\u03b4, \u03b4\u2032\u3009 \u2208 rR.\n(b) \u00b5(y) is a successor of \u00b5(x) in I, i.e., \u00b5(y) = s = \u03b4\u03b4 | \u03b4\u2032\n\u03b4\u2032 . Then s is not n-blocked and \u03c0(y) = \u03b4\u2032 = (\u03c1\u2032, c) \u2208 \u2206R for c \u2208 IN. Again, since \u00b5 is a match for q in I and by definition of I as an induced interpretation of R, we have that \u3008\u03c0(x), \u03c0(y)\u3009 = \u3008\u03b4, \u03b4\u2032\u3009 \u2208 rR.\n(c) \u00b5(y) is neither a root (\u00b5(y) 6= \u03b4\u2032\u03b4\u2032 for any \u03b4 \u2032 \u2208 \u2206R) nor a successor of \u00b5(x) in I\n(\u00b5(y) 6= \u03b4\u03b4 | \u03b4\u2032 \u03b4\u2032 for any \u03b4 \u2032 \u2208 \u2206R). Then \u00b5(y) belongs to some graph match component Gi and \u03c0(y) = last\u2217(\u00b5(y)) or \u03c0(y) = \u03d5\u2212(last\u2217(\u00b5(y))). Since the isomorphism between n-blocking trees also takes the relations to root nodes into account and other parts have direct counterparts in R, we have that \u3008\u03c0(x), \u03c0(y)\u3009 \u2208 rR.\n2. \u00b5(x) = s 6= \u03b4\u03b4 for any \u03b4 \u2208 \u2206 R. The cases when \u00b5(y) = \u03b4\n\u2032\n\u03b4\u2032 for some \u03b4 \u2032 \u2208 \u2206R is as\nabove. We assume, therefore, that \u00b5(y) = s\u2032 with |s\u2032| > 1. By definition of I, this means that either s = s\u2032| \u03b4\u03b4\u2032 or s \u2032 = s| \u03b4\u03b4\u2032 for some \u03b4, \u03b4 \u2032 \u2208 \u2206R. We assume s\u2032 = s| \u03b4\u03b4\u2032 . The opposite case is analogous. By definition of the match graph G, there is a component Gi of G that contains both s and s\u2032. We distinguish two cases:\n(a) The component Gi contains a node s\u0304 such that last\u2217(s\u0304) 6= last\u2217(s\u0304). The most interesting case is when last\u2217(\u00b5(y)) 6= last\u2217(\u00b5(y)), i.e., s\u0304 = s\u2032. Then \u03c0(x) = \u03d5\u2212(last\u2217(s)) and \u03c0(y) = last\u2217(s\u2032). Since last\u2217(s\u2032) 6= last\u2217(s\u2032), we have that last\u2217(s\u2032) is the node that directly n-blocks last\u2217(s\u2032) and, by definition of the bijection \u03d5, which witnesses the isomorphism, we have that \u03c0(x) = \u03d5\u2212(last\u2217(s)) is the predecessor of \u03c0(y) = last\u2217(s\u2032) and, by definition of I from R, that \u3008\u03c0(x), \u03c0(y)\u3009 \u2208 rR.\n(b) The component Gi contains no node s\u0304 such that last\u2217(s\u0304) 6= last\u2217(s\u0304). Then \u03c0(x) = last\u2217(\u00b5(x)) and \u03c0(y) = last\u2217(\u00b5(y)). By definition of I from R, we immediately have that \u3008\u03c0(x), \u03c0(y)\u3009 \u2208 rR.\nIn any case, we have that \u3008\u03c0(x), \u03c0(y)\u3009 \u2208 rR, which implies R |=\u03c0 q contradicting the initial assumption.\nNow Lemma 40 guarantees that, in case K 6|= q, there is always a finite n-representation R for K such that R 6|= q and Lemma 42 guarantees that R can be transformed into a model I of K such that I 6|= q. This suffices to show that we can enumerate all (finite) n-representations for K and check whether they entail a disjunct of the union of conjunctive queries. Together with the semi-decidability result for FOL, we get the following theorem.\nTheorem 43. Let K be an ALCOIFb knowledge base and u = q1 \u2228 . . . \u2228 qh a union of conjunctive queries. The question whether K |= u is decidable."}, {"heading": "8. Conclusions", "text": "We have solved the long-standing open problem of deciding conjunctive query entailment in the presence of nominals, inverse roles, and qualified number restrictions. We have shown that the problem is decidable by providing a decision procedure and proving its correctness. Since the approach is purely a decision procedure, the computational complexity of the problem remains open.\nOur result also shows decidability of entailment of unions of conjunctive queries in SHOIQ and SROIQ (underlying OWL DL and OWL 2) if we disallow non-simple roles as binary query predicates. We thereby have reached a first important milestone towards tackling the problem of conjunctive queries for OWL 1 DL and OWL 2 DL.\nEntailment of unions of conjunctive queries is also closely related to the problem of adding rules to a DL knowledge base, e.g., in the form of Datalog rules. Augmenting a DL KB with an arbitrary Datalog program easily leads to undecidability (Levy & Rousset, 1998). In order to ensure decidability, the interaction between the Datalog rules and the DL knowledge base is usually restricted by imposing a safeness condition. The DL+log framework (Rosati, 2006a) provides the least restrictive integration proposed so far and Rosati presents an algorithm that decides the consistency of a DL+log knowledge base by reducing the problem to entailment of unions of conjunctive queries. Notably, Rosati\u2019s results (2006a, Thm. 11) imply that the consistency of an ALCHOIQb knowledge base extended with (weakly-safe) Datalog rules is decidable if and only if entailment of unions of conjunctive queries in ALCHOIQb is decidable, which we have established.\nCorollary 44. The consistency of ALCHOIQb+log-knowledge bases (both under FOL semantics and under non-monotonic semantics) is decidable.\nAnother related reasoning problem is query containment. Given a schema (or TBox) S and two queries q and q\u2032, we have that q is contained in q\u2032 w.r.t. S iff every interpretation I that satisfies S and q also satisfies q\u2032. It is well known that query containment w.r.t. a TBox can be reduced to deciding entailment for unions of conjunctive queries w.r.t. a knowledge base (Calvanese et al., 1998a). Decidability of unions of conjunctive query entailment in ALCHOIQb implies, therefore, also decidability of query containment w.r.t. an ALCHOIQb TBox.\nThere are two obvious avenues for future work. We will embark on extending our results in order to allow non-simple roles as query predicates. This is a non-trivial task as our current approach heavily relies on a certain locality of query matches, which has to be relinquished when considering non-simple roles. On the other hand, we are eager to determine the associated computational complexities and provide techniques that can form the basis for implementable algorithms."}, {"heading": "Acknowledgments", "text": "During his stay in Oxford where our collaboration started, Sebastian Rudolph was supported by a scholarschip of the German Academic Exchange Service (DAAD). Continuative work on the subject was enabled by funding through the ExpresST project of the German Research Foundation (DFG).\nBirte Glimm was supported by EPSRC in the project HermiT: Reasoning with Large Ontologies.\nWe thank the three anonymous reviewers for their numerous helpful comments. We thank Ian Pratt-Hartmann for (unknowingly) smashing our graphomata, Maria Magdalena Ortiz de la Fuente for establishing the competitive atmosphere, Yevgeny Kazakov for breath-taking discussions on black holes, Boris Motik for his motivating considerations on the value of the academic life, and last not least God for providing us with extraordinary weather and \u2013 most notably \u2013 infinity."}], "references": [{"title": "Terminological cycles in a description logic with existential restrictions", "author": ["F. Baader"], "venue": "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Baader,? \\Q2003\\E", "shortCiteRegEx": "Baader", "year": 2003}, {"title": "The Description Logic Handbook", "author": ["F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2003}, {"title": "DL-Lite: Tractable description logics for ontologies", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Proceedings of the 20th National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Calvanese et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2005}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "On the decidability of query containment under constraints", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini"], "venue": "In Proceedings of the 17th ACM SIGACT SIGMOD Symposium on Principles of Database Systems (PODS", "citeRegEx": "Calvanese et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 1998}, {"title": "Description logic framework for information integration", "author": ["D. Calvanese", "G. De Giacomo", "M. Lenzerini", "D. Nardi", "R. Rosati"], "venue": "In Proceedings of the 6th International Conference on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Calvanese et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 1998}, {"title": "Answering regular path queries in expressive description logics: An automata-theoretic approach", "author": ["D. Calvanese", "T. Eiter", "M. Ortiz"], "venue": "In Proceedings of the 22th National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Regular path queries in expressive description logics with nominals", "author": ["D. Calvanese", "T. Eiter", "M. Ortiz"], "venue": "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Calvanese et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2009}, {"title": "Optimal implementation of conjunctive queries in relational data bases", "author": ["A.K. Chandra", "P.M. Merlin"], "venue": "In Proceedings of the 9th ACM Symposium on Theory of Computing (STOC", "citeRegEx": "Chandra and Merlin,? \\Q1977\\E", "shortCiteRegEx": "Chandra and Merlin", "year": 1977}, {"title": "Query answering in description logics with transitive roles", "author": ["T. Eiter", "C. Lutz", "M. Ortiz", "M. Simkus"], "venue": "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Eiter et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2009}, {"title": "Conjunctive query answering for the description logic SHIQ", "author": ["B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Glimm et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Glimm et al\\.", "year": 2008}, {"title": "Status QIO: Conjunctive query entailment is decidable", "author": ["B. Glimm", "S. Rudolph"], "venue": "In Proceedings of the 12th International Conference on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Glimm and Rudolph,? \\Q2010\\E", "shortCiteRegEx": "Glimm and Rudolph", "year": 2010}, {"title": "\u00dcber die Vollst\u00e4ndigkeit des Logikkalk\u00fcls", "author": ["K. G\u00f6del"], "venue": "Ph.D. thesis,", "citeRegEx": "G\u00f6del,? \\Q1929\\E", "shortCiteRegEx": "G\u00f6del", "year": 1929}, {"title": "The foundational model of anatomy in OWL: Experience and perspectives", "author": ["C. Golbreich", "S. Zhang", "O. Bodenreider"], "venue": "Journal of Web Semantics,", "citeRegEx": "Golbreich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Golbreich et al\\.", "year": 2006}, {"title": "Experiences of using OWL at the ordnance survey", "author": ["J. Goodwin"], "venue": "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED 2005),", "citeRegEx": "Goodwin,? \\Q2005\\E", "shortCiteRegEx": "Goodwin", "year": 2005}, {"title": "Why are modal logics so robustly decidable", "author": ["E. Gr\u00e4del"], "venue": "Current Trends in Theoretical Computer Science, Entering the 21th Century,", "citeRegEx": "Gr\u00e4del,? \\Q2001\\E", "shortCiteRegEx": "Gr\u00e4del", "year": 2001}, {"title": "Problem of Incomplete Information in Relational Databases. Lecture Notes in Computer Science", "author": ["G. Grahne"], "venue": "In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Grahne,? \\Q1991\\E", "shortCiteRegEx": "Grahne", "year": 1991}, {"title": "Reasoning with Individuals for the Description Logic SHIQ", "author": ["I. Horrocks", "U. Sattler", "S. Tobies"], "venue": "Proceedings of the 17th Conference on Automated Deduction (CADE 2000),", "citeRegEx": "Horrocks et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2000}, {"title": "A resolution-based decision procedure for SHOIQ", "author": ["Y. Kazakov", "B. Motik"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Kazakov and Motik,? \\Q2008\\E", "shortCiteRegEx": "Kazakov and Motik", "year": 2008}, {"title": "Conjunctive queries for a tractable fragment of OWL", "author": ["M. Kr\u00f6tzsch", "S. Rudolph", "P. Hitzler"], "venue": "Proceedings of the 7th International Semantic Web Conference (ISWC 2007),", "citeRegEx": "Kr\u00f6tzsch et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2007}, {"title": "ELP: Tractable rules for OWL", "author": ["M. Kr\u00f6tzsch", "S. Rudolph", "P. Hitzler"], "venue": "Proceedings of the 8th International Semantic Web Conference (ISWC 2008),", "citeRegEx": "Kr\u00f6tzsch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2008}, {"title": "Experiences using OWL in military applications", "author": ["L. Lacy", "G. Aviles", "K. Fraser", "W. Gerber", "A. Mulvehill", "R. Gaskill"], "venue": "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED", "citeRegEx": "Lacy et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lacy et al\\.", "year": 2005}, {"title": "CARIN: A representation language combining horn rules and description logics", "author": ["A.Y. Levy", "Rousset", "M.-C"], "venue": "In Proceedings of the 12th European Conference on Artificial Intelligence (ECAI", "citeRegEx": "Levy et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Levy et al\\.", "year": 1996}, {"title": "Combining horn rules and description logics in CARIN", "author": ["A.Y. Levy", "Rousset", "M.-C"], "venue": "Artificial Intelligence,", "citeRegEx": "Levy et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Levy et al\\.", "year": 1998}, {"title": "The complexity of conjunctive query answering in expressive description logics", "author": ["C. Lutz"], "venue": "In Proceedings of the International Joint Conference on Automated Reasoning (IJCAR", "citeRegEx": "Lutz,? \\Q2008\\E", "shortCiteRegEx": "Lutz", "year": 2008}, {"title": "An industrial strength description logic-based configuration platform", "author": ["D.L. McGuinness", "J.R. Wright"], "venue": "IEEE Intelligent Systems,", "citeRegEx": "McGuinness and Wright,? \\Q1998\\E", "shortCiteRegEx": "McGuinness and Wright", "year": 1998}, {"title": "Hypertableau reasoning for description logics. Submitted to a journal. http://www.hermit-reasoner.com/publications/ msh08hypertableau-journal.pdf", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "In Proceedings of Logics in Artificial Intelligence,", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Data complexity of query answering in expressive description logics via tableaux", "author": ["M. Ortiz", "D. Calvanese", "T. Eiter"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Conjunctive query answering in sh using knots", "author": ["M. Ortiz", "M. Simkus", "T. Eiter"], "venue": "In Proceedings of the 2008 Description Logic Workshop (DL", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Data-complexity of the two-variable fragment with counting quantifiers", "author": ["I. Pratt-Hartmann"], "venue": "Forthcoming in Information and Computation", "citeRegEx": "Pratt.Hartmann,? \\Q2009\\E", "shortCiteRegEx": "Pratt.Hartmann", "year": 2009}, {"title": "DL+log: Tight integration of description logics and disjunctive datalog", "author": ["R. Rosati"], "venue": "In Proceedings of the 10th International Conference on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Rosati,? \\Q2006\\E", "shortCiteRegEx": "Rosati", "year": 2006}, {"title": "On the decidability and finite controllability of query processing in databases with incomplete information", "author": ["R. Rosati"], "venue": "In Proceedings of the 25th ACM SIGACT SIGMOD Symposium on Principles of Database Systems (PODS", "citeRegEx": "Rosati,? \\Q2006\\E", "shortCiteRegEx": "Rosati", "year": 2006}, {"title": "The limits of querying ontologies", "author": ["R. Rosati"], "venue": "Proceedings of the 11th International Conference on Database Theory (ICDT 2007),", "citeRegEx": "Rosati,? \\Q2007\\E", "shortCiteRegEx": "Rosati", "year": 2007}, {"title": "Terminological reasoning in SHIQ with ordered binary decision diagrams", "author": ["S. Rudolph", "M. Kr\u00f6tzsch", "P. Hitzler"], "venue": "In Proc. 23rd National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Rudolph et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Rudolph et al\\.", "year": 2008}, {"title": "Protein ontology development using OWL", "author": ["A. Sidhu", "T. Dillon", "E. Chang", "B.S. Sidhu"], "venue": "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED 2005),", "citeRegEx": "Sidhu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sidhu et al\\.", "year": 2005}, {"title": "Pellet: A practical OWL-DL reasoner", "author": ["E. Sirin", "B. Parsia", "B. Cuenca Grau", "A. Kalyanpur", "Y. Katz"], "venue": "Journal of Web Semantics,", "citeRegEx": "Sirin et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Sirin et al\\.", "year": 2007}, {"title": "Questions and answers: Reasoning and querying in Description Logic", "author": ["S. Tessaris"], "venue": "PhD thesis,", "citeRegEx": "Tessaris,? \\Q2001\\E", "shortCiteRegEx": "Tessaris", "year": 2001}, {"title": "FaCT++ description logic reasoner: System description", "author": ["D. Tsarkov", "I. Horrocks"], "venue": "In Proceedings of the International Joint Conference on Automated Reasoning (IJCAR 2006),", "citeRegEx": "Tsarkov and Horrocks,? \\Q2006\\E", "shortCiteRegEx": "Tsarkov and Horrocks", "year": 2006}, {"title": "Logical approaches to incomplete information: A survey. In Logics for Databases and Information Systems, pp. 307\u2013356", "author": ["R. van der Meyden"], "venue": null, "citeRegEx": "Meyden,? \\Q1998\\E", "shortCiteRegEx": "Meyden", "year": 1998}, {"title": "Why is modal logic so robustly decidable", "author": ["M.Y. Vardi"], "venue": "In Descriptive Complexity and Finite Models: Proceedings of a DIMACS Workshop,", "citeRegEx": "Vardi,? \\Q1997\\E", "shortCiteRegEx": "Vardi", "year": 1997}, {"title": "A Little Semantic Web Goes a Long Way in Biology", "author": ["K. Wolstencroft", "A. Brass", "I. Horrocks", "P. Lord", "U. Sattler", "D. Turi", "R. Stevens"], "venue": "In Proceedings of the 5th International Semantic Web Conference (ISWC", "citeRegEx": "Wolstencroft et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Wolstencroft et al\\.", "year": 2005}], "referenceMentions": [{"referenceID": 0, "context": "The underlying reasoning problems are well-understood, and the computational complexity of the standard reasoning tasks given a knowledge base as input range from PTime-complete for DLs with limited expresivity such as DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), EL (Baader, 2003), and ELP (Kr\u00f6tzsch, Rudolph, & Hitzler, 2008) to 2-NExpTime-complete for very expressive DLs such as SROIQ (Kazakov, 2008).", "startOffset": 289, "endOffset": 303}, {"referenceID": 14, "context": ", biology (Sidhu, Dillon, Chang, & Sidhu, 2005), bio informatics (Wolstencroft, Brass, Horrocks, Lord, Sattler, Turi, & Stevens, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), information integration (Calvanese, De Giacomo, Lenzerini, Nardi, & Rosati, 1998b), geography (Goodwin, 2005), geology (Jet Propulsion Laboratory, 2006), defense (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005), and configuration (McGuinness & Wright, 1998).", "startOffset": 280, "endOffset": 295}, {"referenceID": 15, "context": "Modal and Description Logics (Gr\u00e4del, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result.", "startOffset": 29, "endOffset": 56}, {"referenceID": 39, "context": "Modal and Description Logics (Gr\u00e4del, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result.", "startOffset": 29, "endOffset": 56}, {"referenceID": 24, "context": "For the DLs SHIQ and SHOQ decidability and 2-ExpTime-completeness of the problem is known (Glimm, Horrocks, Lutz, & Sattler, 2008a; Glimm, Horrocks, & Sattler, 2008b; Lutz, 2008; Eiter, Lutz, Ortiz, & Simkus, 2009).", "startOffset": 90, "endOffset": 214}, {"referenceID": 24, "context": "Conjunctive query entailment is already 2-ExpTime-hard in the relatively weak DL ALCI (Lutz, 2008), which was initially attributed to inverse roles.", "startOffset": 86, "endOffset": 98}, {"referenceID": 9, "context": "Recently, it was shown, however, that also transitive roles together with role hierarchies as in the DL SH make conjunctive query entailment 2-ExpTime-hard (Eiter et al., 2009).", "startOffset": 156, "endOffset": 176}, {"referenceID": 7, "context": "In particular the most recent extension (Calvanese et al., 2009) is very close to a conjunctive query entailment decision procedure for OWL 2, which corresponds to the DL SROIQ, because it covers", "startOffset": 40, "endOffset": 64}, {"referenceID": 29, "context": ", 2008a) and this holds also for CQ entailment in the two variable guarded fragment with counting (Pratt-Hartmann, 2009).", "startOffset": 98, "endOffset": 120}, {"referenceID": 16, "context": "Query entailment and answering have also been studied in the context of databases with incomplete information (Rosati, 2006b; van der Meyden, 1998; Grahne, 1991).", "startOffset": 110, "endOffset": 161}, {"referenceID": 0, "context": "Another tractable DL is EL (Baader, 2003).", "startOffset": 27, "endOffset": 41}, {"referenceID": 0, "context": "Another tractable DL is EL (Baader, 2003). Conjunctive query entailment in EL is, however, not tractable as the complexity increases to coNP-complete (Rosati, 2007b). Moreover for EL++ (Baader et al., 2005), a still tractable extension of EL, query entailment is even undecidable (Kr\u00f6tzsch, Rudolph, & Hitzler, 2007). This is mainly because in EL++, one can use unrestricted role compositions. This allows for encoding context-free languages, and conjunctive queries can then be used to check the intersection of such languages, which is known to be an undecidable problem. Since the logics used in databases with incomplete information are considerable less expressive than ALCHOIQb, the techniques developed in that area do not transfer to our setting. Given that query entailment is a (computationally) harder task than, for example, knowledge base satisfiability, it is not very surprising that decidability of the latter task does not necessarily transfer to the problem of CQ entailment. Most of the undecidability results can be transferred from FOL since many DLs can directly be translated into an equivalent FOL theory. For example, it is known that conjunctive query entailment is undecidable in the two variable fragment of First-Order Logic L2 (Rosati, 2007a), and Rosati identifies a relatively small set of constructors that cause the undecidability (most notably role negation axioms, i.e., axioms of the form \u2200x, y (\u00acR(x, y)\u2192 P (x, y)) for R,P binary predicates). Pratt-Hartmann (2009) recently established decidability for CQ entailment in the two variable guarded fragment with counting (GC2).", "startOffset": 28, "endOffset": 1503}, {"referenceID": 26, "context": "Meanwhile also alternative approaches such as resolution (Kazakov & Motik, 2008), and hypertableau-based procedures (Motik et al., 2009) are available and implemented.", "startOffset": 116, "endOffset": 136}, {"referenceID": 12, "context": "As a result of the completeness theorem for FOL (G\u00f6del, 1929), the consequences of a finite FOL theory are recursively enumerable, which provides us with a procedure that terminates if K |= q.", "startOffset": 48, "endOffset": 61}, {"referenceID": 35, "context": "A proof is given by Tessaris (2001) and, with this lemma, it is clear that the restriction to connected queries is indeed without loss of generality since entailment of q can be decided by checking entailment of each qi at a time.", "startOffset": 20, "endOffset": 36}, {"referenceID": 2, "context": "This is also the reason why the tableau algorithm for entailment of conjunctive queries with only simple roles in the query of Calvanese et al. (2009) is sound, complete, and terminating on SHIQ, SHOQ, and SHOI knowledge bases, but is not guaranteed to terminate on SHOIQ knowledge bases (transitivity, i.", "startOffset": 127, "endOffset": 151}, {"referenceID": 27, "context": "The proof is essentially as the one by Ortiz et al. (2008a), but adapted to our case, where we work completely on interpretations.", "startOffset": 39, "endOffset": 60}], "year": 2010, "abstractText": "Description Logics are knowledge representation formalisms that provide, for example, the logical underpinning of the W3C OWL standards. Conjunctive queries, the standard query language in databases, have recently gained significant attention as an expressive formalism for querying Description Logic knowledge bases. Several different techniques for deciding conjunctive query entailment are available for a wide range of DLs. Nevertheless, the combination of nominals, inverse roles, and number restrictions in OWL 1 and OWL 2 DL causes unsolvable problems for the techniques hitherto available. We tackle this problem and present a decidability result for entailment of unions of conjunctive queries in the DL ALCHOIQb that contains all three problematic constructors simultaneously. Provided that queries contain only simple roles, our result also shows decidability of entailment of (unions of) conjunctive queries in the logic that underpins OWL 1 DL and we believe that the presented results will pave the way for further progress towards conjunctive query entailment decision procedures for the Description Logics underlying the OWL standards.", "creator": "TeX"}}}