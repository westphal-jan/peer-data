{"id": "1402.0562", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Online Stochastic Optimization under Correlated Bandit Feedback", "abstract": "in this paper we consider the problem - online stochastic optimization algorithm a locally smooth sequence under bandit feedback. one introduce the high confidence loss ( hct ) algorithm, a novel any - time $ \\ mathcal x $ - armed bandit algorithm, and derive regret bounds matching the performance of existing state - of - the - art in terms of dependency on bounds of steps $ n $ and near - optimality dimensions $ e $.... main advantage of hct is that it handles the challenging case of correlated threads, whereas existing methods require that nodes to be conditionally independent of each others. hct also improves on the state - of - the - art in usage of space complexity as often as requiring a weaker smoothness assumption on the mean - reward function rather compare to the previous any time methods. finally, we notice how hct can be tailored to the problem of policy search objective supervised learning and we report preliminary empirical results.", "histories": [["v1", "Tue, 4 Feb 2014 01:34:50 GMT  (527kb)", "https://arxiv.org/abs/1402.0562v1", null], ["v2", "Thu, 13 Feb 2014 20:50:52 GMT  (527kb)", "http://arxiv.org/abs/1402.0562v2", null], ["v3", "Mon, 19 May 2014 17:30:53 GMT  (527kb)", "http://arxiv.org/abs/1402.0562v3", null]], "reviews": [], "SUBJECTS": "stat.ML cs.LG cs.SY", "authors": ["mohammad gheshlaghi azar", "alessandro lazaric", "emma brunskill"], "accepted": true, "id": "1402.0562"}, "pdf": {"name": "1402.0562.pdf", "metadata": {"source": "CRF", "title": "Online Stochastic Optimization under Correlated Bandit Feedback", "authors": ["Mohammad Gheshlaghi Azar", "Alessandro Lazaric", "Emma Brunskill"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 2.\n05 62\nv3 [\nst at\n.M L\n] 1\n9 M"}, {"heading": "1 Introduction", "text": "We consider the problem of maximizing the sum of the rewards obtained by sequentially evaluating an unknown function, where the function itself may be stochastic. This is known as online stochastic optimization under bandit feedback or X -armed bandit, since each function evaluation can be viewed as pulling one of the arms in a general arm space X . Our objective is to minimize the cumulative regret relative to evaluating/executing at each time point the global maximum of the function. In particular, we focus on the case that the reward (function evaluation) of an arm may depend on prior history of evaluations and outcomes. This immediately implies that the reward, conditioned on its corresponding arm pull, is not an independent and identically distributed (iid) random variable, in contrast to the prior work on X -armed bandits (Bull, 2013; Djolonga et al., 2013; Bubeck et al., 2011a; Srinivas et al., 2009; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007). X -armed bandit with correlated reward is relevant to many real world optimization applications, including internet auctions, adaptive routing, and online games. As one important example, we show that the problem of policy search in a Markov Decision Process (MDP), a popular approach to learning in unknown MDPs, can be framed as an instance of the setting we consider in this paper (Sect. 5). To the best of our knowledge, the algorithm introduced in this paper is the first to guarantee sub-linear regret in continuous state-action-policy space MDPs.\nOur approach builds on recent advances in X -armed bandits for iid settings (Bubeck et al., 2011a; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007). Under regularity assumptions on the mean-reward function (e.g. Lipschitzsmoothness), these methods provide formal guarantees in terms of bounds on the regret, which is proved to scale\n\u2217mohammad.azar@northwestern.edu \u2020alessandro.lazaric@inria.fr \u2021ebrun@cs.cmu.edu\nsub-linearly w.r.t. the number of steps n. To obtain this regret, these methods rely heavily on the iid assumption. To handle the correlated feedback, we introduce a new anytime X -armed bandit algorithm, called high confidence tree (HCT) (Sect. 3). Similar to the HOO algorithm of Bubeck et al. (2011a), HCT makes use of a covering binary tree for exploring the arm space. The tree is constructed incrementally in an optimistic fashion, exploring parts of the arm space guided by upper bounds on the potential best reward of the arms covered within a particular node.\nOur key insight is that to achieve good performance it is only necessary to expand the tree by refining an optimistic node when the estimate of the mean-reward of that node has become sufficiently accurate. This allows us to obtain an accurate estimate of the return of a particular arm even in the non-iid setting, under some mild ergodicity and mixing assumptions (Sect. 2). Despite handling a more general case of correlated feedback, our regret bounds matches (Sect. 4.1) that of HOO (Bubeck et al., 2011a) and zooming algorithm (Kleinberg et al., 2008), both of which only apply to iid setting, in terms of dependency on the number of steps n and the near-optimality dimension d (to be defined later). Furthermore, HCT also requires milder assumptions on the smoothness of the function, which is required to be Lipschitz only w.r.t. the maximum, whereas HOO assumes the mean-reward to be Lipschitz also between any pair of arms close to the maximum. An important part of our proof of this result (though we delay this and all proofs to the supplement, due to space considerations) is the development of concentration inequalities for non-iid episodic random variables. In addition to this main result, the structure of our HCT approach has a favorable sub-linear space complexity of O(nd/(d+2)(log n)2/(d+2)) and a linearithmic runtime complexity, making it suitable for scaling to big data scenarios. These results meet or improve the space and time complexity of prior work designed for iid data (Sect. 4.2), and we will demonstrate this benefit in simulations (Sect. 6). We also show how our approach can lead to finite-sample guarantees for policy search method, and provide preliminary simulation results which show the advantage of our method in the case of MDPs."}, {"heading": "2 Preliminaries", "text": "The optimization problem. Let X be a measurable space of arms. We formalize the optimization problem as an interaction between the learner and the environment. At each time step t, the learner pulls an arm xt in X and the environment returns a reward rt \u2208 [0, 1] and possibly a context yt \u2208 Y , with Y a measurable space (e.g., the state space of a Markov decision process). Whenever needed, we relate rt to the arm pulled by using the notation rt(x). The context yt and the reward rt may depend on the history of all previous rewards, pulls, contexts and the current pull xt. For any time step t > 0, the space of histories Ht := ([0, 1] \u00d7 X \u00d7 Y)t is defined as the space of past rewards, arms,and observations (with H0 = \u2205). An environment M corresponds to an infinite sequence of time-dependent probability measures M = (Q1, Q2, . . . ), such that each Qt : Ht\u22121 \u00d7 X \u2192 M([0, 1] \u00d7 Y) is a mapping from the history Ht\u22121 and the arm space X to the space of probability measures on rewards and contexts. Let Z = ([0, 1] \u00d7 X \u00d7 Y), at each step t we define the random variable zt = (rt, xt, yt) \u2208 Z and we introduce the filtration Ft as a \u03c3-algebra generated by (z1, z2, . . . , zt). At each step t, the arm xt is Ft\u22121-measurable since it is based on all the information available up to time t \u2212 1. The pulling strategy of the learner can be expressed as an infinite sequence of measurable mappings (\u03c81, \u03c82, . . . ), where \u03c8t : Ht\u22121 \u2192 M(X ) maps Ht\u22121 to the space of probability measures on arms. We refine this general setting with two assumptions on the reward-generating process.\nDefinition 1 (Time average reward). For any x \u2208 X , S > 0 and 0 < s \u2264 S, the time average reward is\nr\u0304s\u2192S(x) := 1 S \u2212 s+ 1 S\u2211\ns\u2032=s\nrs\u2032(x). (1)\nWe now state our first assumption which guarantees that the mean of the process is well defined (ergodicity).\nAssumption 1 (Ergodicity). For any x \u2208 X , any s > 0 and any sequence of prior pulls (x1, x2, . . . , xs\u22121), the process (zt)t>0 is such that the mean-reward function\nf(x) := lim S\u2192\u221eE(r\u0304s\u2192S(x)|Fs\u22121)\nexists.\nThis assumption implies that, regardless of the history of prior observations, if arm x is pulled infinitely many times from time s, then the time average reward converges in expectation to a fixed point which only depends on arm x and is independent from the past history. We also make the following mixing assumption (see e.g., Levin et al., 2006).\nAssumption 2 (Finite mixing time). There exists a constant \u0393 \u2265 0 (mixing time) such that for any x \u2208 X , any S > 0, any 0 < s \u2264 S and any sequence of prior pulls (x1, x2, . . . , xs\u22121), the process (zt)t>0 is such that we have that\n|E[ \u2211\nS s\u2032=s(rs\u2032(x)\u2212 f(x)) \u2223\u2223Fs\u22121]| \u2264 \u0393. (2)\nThis assumption implies that the stochastic reward process induced by pulling arm x can not substantially deviate from f(x) in expectation for more than \u0393 transient steps. Note that both assumptions trivially hold if each arm is an iid process: in this case f(x) is the mean of x and \u0393 = 0.\nGiven the mean-reward f , we assume that the maximizer x\u2217=argmaxx f(x) exists and we denote the corresponding maximum f(x\u2217) by f\u2217. We measure the performance of the learner over n steps by its regret Rn w.r.t. the f\u2217, defined as\nRn := nf \u2217 \u2212\nn\u2211\nt=1\nrt.\nThe goal of learner, at every 0 \u2264 t \u2264 n, is to choose a strategy \u03c8t such that the regret Rn is as small as possible. Relationship to other models. Although the learner observes a context yt at each time t, this problem differs from the contextual bandit setting (see e.g., the extensions of the zooming algorithm to contextual bandits by Slivkins, 2009). In contextual bandits, the context y \u2208 Y is provided before selecting an arm x, and the immediate reward rt is defined to be a function only of the selected arm and input context, rt(x, y). The contextual bandit objective is typically to minimize the regret against the optimal arm in the context provided at each step, yt, i.e. x\u2217t = argmax rt(x, yt). A key difference is that in our model the reward, and next context, may depend on the entire history of rewards, arms pulled, and contexts, instead of only the current context and arm, and we define f(x) only as the average reward obtained by pulling arm x. In this sense, our model is related to the reinforcement learning (RL) problem of trying to find a policy that maximizes the long run reward (see further discussion in Sect. 5). Among prior work in RL our setting is most similar to the general reinforcement learning model of Lattimore et al. (2013) which also considers an arbitrary temporal dependence between the rewards and observations. Our setting differs from that of Lattimore et al. (2013), since we consider the regret in undiscounted reward scenario, whereas Lattimore et al. (2013) focus on proving PAC-bounds in discounted reward case. Another difference is that in our model (unlike Lattimore et al., 2013) the space of observations and actions is not needed to be finite.\nThe cover tree. Similar to recent optimization methods (e.g., Bubeck et al., 2011a), our approach seeks to minimize regret by smartly building an estimate of f using an infinite binary covering tree T , in which each node covers a subset of X .1 We denote by (h, i) the node at depth h and index i among the nodes at the same depth (e.g., the root node which covers X is indexed by (0, 1)). By convention (h + 1, 2i \u2212 1) and (h + 1, 2i) refer to the two children of the node (h, i). The area corresponding to each node (h, i) is denoted by Ph,i \u2282 X . These regions must be measurable and, at each depth, they partition X with no overlap:\n1The reader is referred to Bubeck et al. (2011a) for a more detailed description of the covering tree.\nP0,1 = X Ph,i = Ph+1,2i\u22121 \u222a Ph,2i \u2200h \u2265 0 and 1 \u2264 i \u2264 2h.\nFor each node (h, i), we define an arm xh,i \u2208 Ph,i, which the algorithm pulls whenever the node (h, i) is selected. We now state a few additional geometrical assumptions.\nAssumption 3 (Dissimilarity). The space X is equipped with a dissimilarity function \u2113 : X 2 \u2192 R such that \u2113(x, x\u2032) \u2265 0 for all (x, x\u2032) \u2208 X 2 and \u2113(x, x) = 0.\nGiven a dissimilarity \u2113, the diameter of a subset A \u2286 X is defined as diam(A) := supx,y\u2208A \u2113(x, y), while an \u2113\u2013open ball of radius \u03b5 > 0 and center x \u2208 X is defined as B(x, \u03b5) := {x\u2032 \u2208 X : \u2113(x, x\u2032) \u2264 \u03b5}. Assumption 4 (local smoothness). We assume that there exist constants \u03bd2, \u03bd1 > 0 and 0 < \u03c1 < 1 such that for all nodes (h, i):\n(a) diam(Ph,i) \u2264 \u03bd1\u03c1h\n(b) \u2203 xoh,i \u2208 Ph,i s.t. Bh,i := B(xoh,i, \u03bd2\u03c1h) \u2282 Ph,i,\n(c) Bh,i \u2229 Bh,j = \u2205,\n(d) For all x \u2208 X , f\u2217 \u2212 f(x) \u2264 \u2113(x\u2217, x).\nLocal smoothness. These assumptions coincide with those in (Bubeck et al., 2011a), except for the local smoothness (Assumption 4.d), which is weaker than that of Bubeck et al. (2011a), where the function is assumed to be Lipschitz between any two arms x, x\u2032 close to the maximum x\u2217 (i.e., |f(x) \u2212 f(x\u2032)| \u2264 \u2113(x, x\u2032)), while here we only require the function to be Lipschitz w.r.t. the maximum.\nFinally, we characterize the complexity of the problem using the near-optimality dimension, which defines how large is the set of \u01eb-optimal arms in X . For the sake of clarity, we consider a slightly simplified definition of near-optimality dimension w.r.t. Bubeck et al. (2011a).\nAssumption 5 (Near-optimality dimension). Let \u01eb = 3\u03bd1\u03c1h and \u01eb\u2032 = \u03bd2\u03c1h < \u01eb, for any subset of \u01eb-optimal nodes X\u01eb = {x \u2208 X : f\u2217 \u2212 f(x) \u2264 \u01eb}, there exists a constant C such that N ( X\u01eb, \u2113, \u01eb\u2032 ) \u2264 C(\u01eb\u2032)\u2212d, where d is the near-optimality dimension of function f and N (X\u01eb, \u2113, \u01eb\u2032) is the \u01eb\u2032-cover number of the set X\u01eb w.r.t. the dissimilarity measure \u2113.2"}, {"heading": "3 The High Confidence Tree algorithm", "text": "We now introduce the High Confidence Tree (HCT) algorithm for stochastic online optimization under bandit feedback. Throughout this discussion, a function evaluation is equivalent to the reward received from pulling an arm (since an arm corresponds to selecting an input to evaluate the function at). We first describe the general algorithm framework before discussing two particular variants: HCT-iid, designed for the case when rewards of a given arm are iid and HCT-\u0393 which handles the correlated feedback case, where the reward from pulling an arm may depend on all prior arms pulled and resulting outcomes. Alg. 1 shows the structure of the algorithm for HCT-iid and HCT-\u0393, noting the minor modifications between the two.\n2Note that, in many cases, the near-optimality dimension d can be much smaller than D, the actual dimension of arm space X in the continuous case. In fact one can show that under some mild smoothness assumption the near optimality dimension of a function equals 0, regardless of the dimension of its input space X (see Munos, 2013; Valko et al., 2013, for a detailed discussion).\nAlgorithm 1 The HCT algorithm. Require: Parameters \u03bd1 > 0, \u03c1 \u2208 (0, 1), c > 0, tree structure (Ph,i)h\u22650,1\u2264i\u22642i and confidence \u03b4.\nInitialize t = 1, Tt = {(0, 1), (1, 1), (1, 2)}, H(t) = 1, U1,1(t) = U1,2(t) = +\u221e, loop\nif t = t+ then \u22b2 Refresh phase for all (h, i) \u2208 Tt do\nUh,i(t) \u2190 \u00b5\u0302h,i(t) + \u03bd1\u03c1h + \u221a\nc2 log(1/\u03b4\u0303(t+)) Th,i(t)\nend for; for all (h, i) \u2208 Tt Backward from H(t) do\nif (h, i) \u2208 leaf(Tt) then Bh,i(t) \u2190 Uh,i(t) else Bh,i(t) \u2190 min [ Uh,i(t), max\nj\u2208{2i\u22121,2i} Bh+1,j(t)\n]\nend if end for\nend if; {(ht, it), Pt} \u2190 OptTraverse(Tt) if Algorithm HCT-iid then\nPull arm xh,i and observe rt t = t+ 1\nelse if Algorithm HCT-\u0393 then Tcur = Tht,it(t) while Tht,it(t) < 2Tcur AND t < t\n+ do Pull arm xh,i and observe rt (ht+1, it+1) = (ht, it) t = t+ 1\nend while end if Update counter Tht,it(t) and empirical average \u00b5\u0302ht,it(t)\nUht,it(t) \u2190 \u00b5\u0302ht,it(t) + \u03bd1\u03c1h + \u221a\nc2 log(1/\u03b4\u0303(t+)) Tht,it (t)\nUpdateB(Tt, Pt, (ht, it)) \u03c4h(t) =\nc2 log(1/\u03b4\u0303(t+)) \u03bd21 \u03c1\u22122ht\nif Tht,it(t) \u2265 \u03c4ht(t) AND (ht, it) =leaf(T ) then It = {(ht + 1, 2it \u2212 1), (ht + 1, 2it)} T \u2190 T \u222a It Uht+1,2it\u22121(t) = Uht+1,2it(t) = +\u221e\nend if end loop\nThe general structure. The HCT algorithm relies on a binary covering tree T provided as input used to construct a hierarchical approximation of the mean-reward function f . At each node (h, i) of the tree, the algorithm keeps track of some statistics regarding the corresponding arm xh,i associated with the node (h, i). These include the empirical estimate \u00b5\u0302h,i(t) of the mean-reward function corresponding for arm xh,i at time step t computed as\n\u00b5\u0302h,i(t) := (1/Th,i(t)) \u2211Th,i(t)\ns=1 rs(xh,i), (3)\nAlgorithm 2 The OptTraverse function. Require: Tree T\n(h, i) \u2190 (0, 1), P \u2190 (0, 1) T0,1 = \u03c40(t) = 1; while (h, i) /\u2208 Leaf(T ) AND Th,i(t) \u2265 \u03c4h(t) do\nif Bh+1,2i\u22121 \u2265 Bh+1,2i then (h, i) \u2190 (h+ 1, 2i \u2212 1) else (h, i) \u2190 (h+ 1, 2i) end if P \u2190 P \u222a {(h, i)}\nend while return (h, i) and P\nAlgorithm 3 The UpdateB function. Require: Tree T , the path Pt, selected node (ht, it)\nif (ht, it) \u2208 Leaf(T ) then Bht,it(t) = Uht,it(t) else Bht,it(t) = min [ Uht,it(t), max\nj\u2208{2it\u22121,2it} Bht+1,j(t)\n]\nend if; for all (h, i) \u2208 Pt \u2212 (ht, it) backward do\nBh,i(t) = min [ Uh,i(t), max\nj\u2208{2i\u22121,2i} Bh+1,j(t)\n]\nend for\nwhere Th,i(t) is the number of times node (h, i) has been selected in the past and rs(xh,i) denotes the s-th reward observed after pulling xh,i (while we previously used rt to denote the t-th sample of the overall process). As explained in Sect. 2, although a node is associated to a single arm xh,i, it also covers a full portion of the input space X , i.e., the subset Ph,i. Thus, similar to the HOO algorithm (Bubeck et al., 2011a), HCT also maintains two upper-bounds, Uh,i and Bh,i, which are meant to bound the mean-reward f(x) of all the arms x \u2208 Ph,i. In particular, for any node (h, i), the upper-bound Uh,i is computed directly from the observed reward for pulling xh,i as\nUh,i(t) := \u00b5\u0302h,i(t) + \u03bd1\u03c1 h + \u221a c2 log(1/\u03b4\u0303(t+))/Th,i(t), (4)\nwhere t+ = 2\u230alog(t)\u230b+1 and \u03b4\u0303(t) := min{c1\u03b4/t, 1}. Intuitively speaking, the second term is related to the resolution of node (h, i) and the third term accounts for the uncertainty of \u00b5\u0302h,i(t) in estimating the mean-reward f(xh,i). The B-values are designed to have a tighter upper bound on f(x) by taking the minimum between Uh,i for the current node, and the maximum upper bound of the node\u2019s two child nodes, if present.3 More precisely,\nBh,i(t)=    Uh,i(t) (h, i)\u2208 leaf(Tt)\nmin[Uh,i(t), max j\u2208{2i\u22121,2i} Bh+1,j(t)] otherwise.\n(5)\nTo identify which arm to pull, the algorithm traverses the tree along a path Pt obtained by selecting nodes with maximum Bh,i until it reaches an optimistic node (ht, it), which is either a leaf or a node which is not pulled\n3Since the node\u2019s children together contain the same input space as the node (i.e., Ph,i = Ph+1,2i\u22121 \u222a Ph,2i), the node\u2019s maximum cannot be greater than the maximum of its children.\nenough w.r.t. to a given threshold \u03c4h(t), i.e., Th,i(t) \u2264 \u03c4h(t) (see function OptTraverse in Alg. 2). Then the arm xht,it \u2208 Pht,it corresponding to selected node (ht, it) is pulled. The key step of HCT is in deciding when to expand the tree. We expand a leaf node only if we have pulled its corresponding arm a sufficient number of times such that the uncertainty over the maximum value of the arms contained within that node is dominated by size of the subset of X it covers. Recall from Equation 4 that the upper bound Uh,i of a node (h, i) two additional terms added to the empirical average reward. The first \u03bd1\u03c1h is a constant that depends only on the node depth, and bounds the possible difference in the mean-reward function between the representative arm for this node and all other arms also contained in this node, i.e., the difference between f(xh,i) and f(x) for any other x \u2208 Ph,i (as follows from Assumptions 3 and 4). The second term depends only on t and decreases with the number of pulls to this node. At some point, the second term will become smaller than the first term, meaning that the uncertainty over the possible rewards of nodes in Ph,i becomes dominated by the potential difference in rewards amongst arms that are contained within the same node. This means that the domain Ph,i is too large, and thus the resolution of the current approximation of f in that region needs to be increased. Therefore our approach chooses the point at which these two terms become of the same magnitude to expand a node, which occurs when the the number of pulls Tht,it(t) has exceeded a threshold\n\u03c4h(t) := c 2 log(1/\u03b4\u0303(t+))\u03c1\u22122ht/\u03bd21 . (6)\n(see Sect. A of the supplement for further discussion). It is at this point that expanding the node to two children can lead to a more accurate approximation of f(x), since \u03bd1\u03c1h+1 \u2264 \u03bd1\u03c1h. Therefore if Tht,it(t) \u2265 \u03c4h(t), the algorithm expands the leaf, creates both children leaves, and set their U -values to +\u221e. Furthermore, notice that this expansion only occurs for nodes which are likely to contain x\u2217. In fact, OptTraverse does select nodes with big B-value, which in turn receive more pulls and are thus expanded first. The selected arm xht,it is pulled either for a single time step (in HCT-iid) or for a full episode (in HCT-\u0393), and then the statistics of all the nodes along the optimistic path Pt are updated backwards. The statistics of all the nodes outside the optimistic path remain unchanged.\nAs HCT is an anytime algorithm, we periodically need to recalculate the node upper bounds to guarantee their validity with enough probability (see supplementary material for a more precise discussion). To do so, at the beginning of each step t, the algorithm verifies whether the B and U values need to be refreshed or not. In fact, in the definition of U in Eq. 4, the uncertainty term depends on the confidence \u03b4\u0303(t+), which changes at t = 1, 2, 4, 8, . . .. Refreshing the U and B values triggers a \u201cresampling phase\u201d of the internal nodes of the tree Tt along the optimistic path. In fact, the second condition in the OptTraverse function (Alg. 2) forces HCT to pull arms that belong to the current optimistic path Pt until the number of pulls Th,i(t) becomes greater than \u03c4h(t) again. Notice that the choice of the confidence term \u03b4\u0303 is particularly critical. For instance, choosing a more natural \u03b4\u0303(t) would tend to trigger the refresh (and the resampling) phase too often thus increasing the computational complexity of the algorithm and seriously affecting its theoretical properties in the correlated feedback scenario. 4 On the other hand, the choice of \u03b4\u0303(t+) limits the need to refresh the U and B values to only O(log(n)) times over n rounds and guarantees that U and B are valid upper bounds with high probability.\nHCT-iid and HCT-\u0393. The main difference between the two implementations of HCT is that, while HCT-iid pulls the selected arm for only one step before re-traversing the tree from the root to again find another optimistic node, HCT-\u0393 pulls the the representative arm of the optimistic node for an episode of Tcur steps, where Tcur is the number of pulls of arm xh,i at the beginning of episode. In other words, the algorithm doubles the number of pulls of each arm throughout the episode. Note that not all the episodes may actually finish after Tcur steps and double the number of pulls: The algorithm may interrupt the episode when the confidence bounds of B and U are not valid anymore (i.e., t \u2265 t+) and perform a refresh phase. The reason for this change is that in order to accurately estimate the mean-reward given correlated bandit feedback,\n4If we refresh the upper-bound statistics at every time step the algorithm may select a different arm at every time step, whereas in correlated feedback scenario having a small number of switches is critical for the convergence of the algorithm.\nit is necessary to pull an arm for a series of pulls rather than a single pull. Due to our assumption on the mixing time (Assumption. 2), pulling an arm for a sufficiently long sequence will provide an accurate estimate of the potential mean reward even in the correlated setting, thus ensuring that the empirical average rewards \u00b5\u0302h,i actually concentrates towards their mean value (see Lem. 7 in the supplementary material). It is this mechanism, coupled with only expanding the nodes after obtaining a good estimate of their mean reward, that allows us to handle correlated feedback setting. Although in this sense HCT-\u0393 is more general, we do however include the HCT-iid variant because whenever the rewards are iid it performs better than HCT-\u0393. This is due to the fact that, unlike HCT-iid, HCT-\u0393 has to keep pulling an arm for a full episode even when there is evidence that another arm could be better. We also notice that there is a small difference in the constants c1 and c between HCT-iid and HCT-\u0393: in the case of HCT-iid c1 := 8 \u221a \u03c1/(3\u03bd1) and c := 2 \u221a 1/(1 \u2212 \u03c1), whereas HCT-\u0393 uses c1 := 9 \u221a \u03c1/(4\u03bd1) and c := 3(3\u0393 + 1) \u221a 1/(1 \u2212 \u03c1)."}, {"heading": "4 Theoretical Analysis", "text": "In this section we analyze the regret and the complexity of HCT . All the proofs are reported in the supplement."}, {"heading": "4.1 Regret Analysis", "text": "We start by reporting a bound on the maximum depth of the trees generated by HCT .\nLemma 1. Given the threshold \u03c4h(t) in Eq. 6, the depth H(n) of the tree Tn is bounded as\nH(n) \u2264 Hmax(n) = 1/(1 \u2212 \u03c1) log(n\u03bd21/(2(c\u03c1)2)). (7)\nThis bound guarantees that HCT never expands trees beyond depth O(log n). This is ensured by the fact the HCT waits until the value of a node f(xh,i) is sufficiently well estimated before expanding it and this implies that the number of pulls exponentially grows with the depth of tree, thus preventing the depth to grow linearly as in HOO.\nWe report regret bounds in high probability, bounds in expectation can be obtained using standard techniques.\nTheorem 1 (Regret bound of HCT-iid). Pick a \u03b4 \u2208 (0, 1). Assume that at each step t, the reward rt, conditioned on xt, is independent of all prior random events and the immediate mean reward f(x) = E(r|x) exists for every x \u2208 X . Then under Assumptions 3\u20135 the regret of HCT-iid in n steps is, with probability (w.p.) 1\u2212 \u03b4,5\nRn \u2264 O (( log (n/\u03b4) )1/(d+2) n(d+1)/(d+2) ) .\nRemark (the bound). We notice that the bound perfectly matches the bound for HOO up to constants (see Thm. 6 in (Bubeck et al., 2011a)). This represents a first sanity check w.r.t. the structure of HCT , since it shows that changing the structure of HOO and expanding nodes only when they are pulled enough, preserves the regret properties of the algorithm. Furthermore, this result holds under milder assumptions than HOO. In fact, Assumption 4-(d) only requires f to be Lipschitz w.r.t. to the maximum x\u2217. Other advantages of HCT-iid are discussed in the Sect. 4.2 and 6.\nAlthough the proof is mostly based on standard techniques and tools from bandit literature, HCT has a different structure from HOO (and similar algorithms) and moving from iid to correlated arms calls for the development of a significantly different proof technique. The main technical issue is to show that the empirical average \u00b5\u0302h,i computed by averaging rewards obtained across different episodes actually converges to f(xh,i). In particular, we prove the following high-probability concentration inequality (see Lem. 7 in the supplement for further details).\n5Constants are provided in Sect. A of the supplement.\nLemma 2. Under Assumptions 1 and 2, for any fixed node (h, i) and step t, we have that, w.p. 1\u2212 \u03b4,\n|\u00b5\u0302h,i(t)\u2212 f(xh,i)| \u2264 (3\u0393 + 1) \u221a 2 log(5/\u03b4)\nTh,i(t) +\n\u0393 log(t)\nTh,i(t) .\nFurthermore Kh,i(t), the number of episodes in which (h, i) is selected, is bounded by log2(4Th,i(t)) + log2(t).\nThis technical lemma is at the basis of the derivation of the following regret bound for HCT-\u0393.\nTheorem 2 (Regret bound of HCT-\u0393). We assume that Assumptions 1\u20135 hold and that rewards are generated according to the general model defined in Section 2. Then the regret of HCT-iid after n steps is, w.p. 1\u2212 \u03b4,\nRn \u2264 O (( log (n/\u03b4) )1/(d+2) n(d+1)/(d+2) ) .\nRemark (the bound). The most interesting aspect of this bound is that HCT-\u0393 achieves the same regret as HCT-iid when samples are non-iid. This represents a major step forward w.r.t. HOO since it shows that the very general case of correlated arms can be managed as well as the much simpler iid case. In the next section we also discuss how this result can be used in policy search for MDPs."}, {"heading": "4.2 Complexity", "text": "Time complexity. The run time complexity of both versions of HCT is O(n log(n)). This is due to the boundedness of the depth H(n) and by the structure of the refresh phase. By Lem. 1, we have that the maximum depth is O(log(n)). As a result, at each step t, the cost of traversing the tree to select a node is at most O(log n), which also coincides with the cost of updating the B and U values of the nodes in the optimistic path Pt. Thus, the total cost of selecting, pulling, and updating nodes is no larger than O(n log n). Notice that in case of HCT-\u0393, once a node is selected is pulled for an entire episode, which further reduces the total selection cost. Another computational cost is represented by the refresh phase where all the nodes in the tree are actually updated. Since the refresh is performed only when t = t+, then the number of times all the nodes are refreshed is of order of O(log n) and the boundedness of the depth guarantees that the number of nodes to update cannot be larger than O(2log n), which still corresponds to a total cost of O(n log n). This implies that HCT achieves the same run time as T-HOO (Bubeck et al., 2011a). Though unlike T-HOO, our algorithm is fully anytime and it does not suffer from the extra regret incurred due to the truncation and the doubling trick.\nSpace complexity. The following theorem provides bound on space complexity of the HCT algorithm.\nTheorem 3. Under the same conditions of Thm. 2, let Nn denote the space complexity of HCT-\u0393, then we have that\nE(Nn) = O(log(n)2/(d+2)nd/(d+2)).\nThe previous theorem guarantees that the space complexity of HCT scales sub-linearly w.r.t. n. An important observation is that the space complexity of HCT increases slower, by a factor of O\u0303(n1/(d+2)), than its regret. This implies that, for small values of d, HCT does not require to use a large memory space to achieve a good performance. An interesting special case is the class of problem with near-optimality dimension d = 0. For this class of problems the bound translates to a space complexity of O(log(n)), whereas the space complexity of alternative algorithms may be as large as n (see e.g., HOO). As it has been shown in (Valko et al., 2013) the case of d = 0 covers a rather large class of functions, since every function which satisfies some mild local smoothness assumption, around its\nglobal optima, has a near-optimality dimension equal to 0 (see Valko et al., 2013, for further discussions). The fact that HCT can achieve a near-optimal performance, using only a relatively small memory space, which makes it a suitable choice for big-data applications, where the algorithms with linear space complexity can not be used due to very large size of the dataset.\nSwitching frequency. Finally, we also remark another interesting feature of HCT-\u0393. Since an arm is pulled for an entire episode before another arm could be selected, this drastically reduces the number of switches between arms. In many applications, notably in reinforcement learning (see next section), this can be a significant advantage since pulling an arm may correspond to the actual implementation of a complex solution (e.g., a position in a portfolio management problem) and continuously switch between different arms might not be feasible. More formally, since each node has a number of episodes bounded by O(log n) (Lem. 2), then the number of switches can be derived be the number of nodes in Thm. 3 multiplied by O(log n), which leads to O(log(n)(d+4)/(d+2)nd/(d+2))."}, {"heading": "5 Application to Policy Search in MDPs", "text": "As we discussed in Sect. 2, HCT is designed to handle the very general case of optimization in problems where there exists a strong correlation among the rewards, arm pulls, and contexts, at different time steps. An important subset of this general class is represented by the problem of policy search in infinite-horizon Markov decision processes. Notice that the extension to the case of partially observable MDPs is straightforward as long as the POMDP satisfies some ergodicity assumptions.\nA MDP M is defined as a tuple \u3008S,A, P \u3009 where S is the set of states, A is the set of actions, P : S \u00d7 A \u2192 M(S \u00d7 [0, 1]) is the transition kernel mapping each state-action pair to a distribution over states and rewards. A (stochastic) policy \u03c0 : S \u2192 M(A) is a mapping from states to distribution over actions. Policy search algorithms (Scherrer & Geist, 2013; Azar et al., 2013; Kober & Peters, 2011) aim at finding the policy in a given policy set which maximizes the long-term performance. Formally, a policy search algorithm receives as input a set of policies G = {\u03c0\u03b8; \u03b8 \u2208 \u0398}, each of them parameterized by a parameter vector \u03b8 in a given set \u0398 \u2282 \u211cd. Any policy \u03c0\u03b8 \u2208 G induces a state-reward transition kernel T : S \u00d7\u0398 \u2192 M(S \u00d7 [0, 1]). T relates to the state-reward-action transition kernel P and the policy kernel \u03c0\u03b8 as follows\nT (ds\u2032, dr|s, \u03b8) := \u222b\nu\u2208A P (ds\u2032, dr|s, u)\u03c0\u03b8(du|s).\nFor any \u03c0\u03b8 \u2208 G and initial state s0 \u2208 S, the time-average reward over n steps is\n\u00b5\u03c0\u03b8(s0, n) := 1\nn E [\u2211n t=1 rt ] ,\nwhere r1, r2, . . . , rn is the sequence of rewards observed by running \u03c0\u03b8 for n steps staring at s0. If the Markov reward process induced by \u03c0\u03b8 is ergodic, \u00b5\u03c0\u03b8(s0, n) converges to a fixed point independent of the initial state s0. The average reward of \u03c0\u03b8 is thus defined as\n\u00b5(\u03b8) := lim n\u2192\u221e\n\u00b5\u03c0\u03b8(s0, n).\nThe goal of policy search is to find the best \u03b8\u2217 = argmax\u03b8\u2208\u0398 \u00b5(\u03b8). Note that \u03c0\u03b8\u2217 is optimal in the policy class G and it may not coincide with the optimal policy \u03c0\u2217 of the MDP, when \u03c0\u2217 is not covered by G. It is straightforward now to match the MDP scenario to the general setting in Sect. 2, notably mapping \u0398 to X and \u00b5(\u03b8) to f(x). More precisely the parameter space \u03b8 \u2208 \u0398 corresponds to the space of arms X , since in the policy search we want to explore the parameter space \u0398 to learn the best parameter \u03b8\u2217. Also the state space S in MDP\nsetting is the special from of context space of Sect. 2 where here the contexts evolve according to some controlled Markov process. Further the transition kernel T , which at each time step t determines the distribution on the current state and reward given the last state and \u03b8 is again a special case of of the more general (Qt)t which may depend on the entire history of prior observations. Likewise \u00b5(\u03b8), \u00b5\u2217\u0398 and \u03b8\n\u2217 translate into f(\u03b8), f\u2217 and x\u2217, respectively, using the notation of Sect. 2. The Asm. 1 and 2 in Sect. 2 are also the general version of the standard ergodicity and mixing assumption in MDPs, in which the notion of filtration in assumptions of Sect. 2 is simply replaced by the the initial state s0 \u2208 S . This allows us to directly apply HCT-\u0393 to the problem of policy search. The advantage of HCT-\u0393 algorithm w.r.t. prior work is that, to the best of our knowledge, it is the first policy search algorithm which provides finite sample guarantees in the form of regret bounds on the performance loss of policy search in MDPs (see Thm. 2), which guarantee that HCT-\u0393 suffers from a small sub-linear regret w.r.t. \u03c0\u03b8\u2217 . Also it is not difficult to prove that the policy induced by HCT-\u0393 has a small simple regret, that is, the average reward of the policy chosen by HCT-\u0393 converges to \u00b5(\u03b8\u2217) with a polynomial rate.6 Another interesting feature of HCT-\u0393 is that can be readily used in large (continuous) state-action problems since it does not make any restrictive assumption on the size of state-action space.\nPrior regret bounds for continuous MDPs. A related work to HCT-\u0393 is the UCCRL algorithm by Ortner & Ryabko (2012), which extends the original UCRL algorithm (Jaksch et al., 2010) to continuous state spaces. Although a direct comparison between the two methods is not possible, it is interesting to notice that the assumptions used in UCCRL are stronger than for HCT-\u0393, since they require both the dynamics and the reward function to be globally Lipschitz. Furthermore, UCCRL requires the action space to be finite, while HCT-\u0393 can deal with any continuous policy space. Finally, while HCT-\u0393 is guaranteed to minimize the regret against the best policy in the policy class G, UCCRL targets the performance of the actual optimal policy of the MDP at hand. Another relevant work is the OMDP algorithm of Abbasi et al. (2013) which deals with the problem of RL in continuous state-action MDPs with adversarial rewards. OMDP achieves a sub-linear regret under the assumption that the space of policies is finite, whereas in HCT the space of policy can be continuous."}, {"heading": "6 Numerical Results", "text": "While our primary contribution is the definition of HCT and its technical analysis, we also give some preliminary simulation results to demonstrate some of its properties.\nSetup. We focus on minimizing the regret across repeated noisy evaluations of the garland function f(x) = x(1 \u2212 x)(4 \u2212 \u221a | sin(60x)|) relative to repeatedly selecting its global optima.We select this function due to its several interesting properties: (1) it contains many local optima, (2) it is locally smooth around its global optima x\u2217 (it behaves as f\u2217 \u2212 c|x \u2212 x\u2217|\u03b1, for c = 2 and \u03b1 = 1/2), (3) it is also possible to show that the near-optimality dimension d of f equals 0.\nWe evaluate the performances of each algorithm in terms of the per-step regret, R\u0303n = Rn/n. Each run is n = 105 steps and we average the performance on 10 runs. For all the algorithms compared in the following, parameters7 are optimized to maximize their performance.\nI.i.d. setting. For our first experiment\nwe compare HCT-iid to the truncated hierarchical optimistic optimization (T-HOO) algorithm Bubeck et al. (2011a). T-HOO is a state-of-the-art X -armed bandit algorithm, developed as a computationally-efficient alternative of HOO. In Fig. 1(a) we show the per-step regret, the runtime, and the space requirements of each approach. As predicted by the theoretical bounds, the per-step regret R\u0303n of both HCT-iid and truncated HOO decrease rapidly with number of steps. Though the big O theoretical bounds are identical for both approaches, empirically we observe in this\n6Refer to Bubeck et al. (2011a); Munos (2013) for how to transform bounds on accumulated regret to simple regret bounds. 7For both HCT and T-HOO we introduce a tuning parameter used to multiply the upper bounds, while for PoWER we optimize the\nwindow for computing the weighted average.\nexample that HCT-iid outperforms T-HOO by a large margin. Similarly, though the computational complexity of both approaches matches in the dependence on the number of time steps, empirically we observe that our approach outperforms T-HOO (Fig. 1(b)). Perhaps the most significant expected advantage of HCT-iid over T-HOO for iid settings is in the space requirements. HCT-iid has a space requirement for this domain that scales logarithmically with the time step n, as predicted by Thm. 3. since the near-optimality dimension d = 0). In contrast, a brief analysis of T-HOO suggests that its space requirements can grow polynomially, and indeed in this domain we observe a polynomial growth of memory usage for T-HOO. These patterns mean that HCT-iid can achieve a very small regret using a sparse decision tree with only few hundred nodes, whereas truncated HOO requires orders of magnitude more nodes than HCT-iid.\nCorrelated setting. We create a continuous-state-action MDP out of the previously described Garland function by introducing the state of the environment s. Upon taking continuous-valued action x, the state of the environment changes deterministically to st+1 = (1 \u2212 \u03b2)st + \u03b2x, where we set \u03b2 = 0.2. The agent receives a stochastic reward for being in state s, which is (the Garland function) f(s) + \u03b5, where as before \u03b5 is drawn randomly from [0, 1]. The initial state s0 is also drawn randomly from [0, 1]. A priori, the agent does not know the transition or reward function, making this a reinforcement learning problem. Though not a standard benchmark RL instance, this problem has multiple local optima and therefore is a interesting case for policy search, where \u0398 = X is the policy set (which coincides with the action set in this case).\nIn this setting, we compare HCT-\u0393 to a PoWER, a standard RL policy search algorithm Kober & Peters (2011) on the above MDP problem MDP constructed out of garland function.PoWER uses an Expectation Maximization approach to optimize the policy parameters and is therefore not guaranteed to find the global optima. We also compare our algorithm with T-HOO, though this algorithm is specifically designed for iid setting and one may expect that it may fail to converge to global optima under correlated bandit feedback. Fig. 2(a) shows per-step regret of the 3 approaches in the MDP. Only HCT-\u0393 succeeds in finding the globally optimal policy, as is evident because only in the case of HCT-\u0393 does the average regret tends to converge to zero (which is as predicted from Thm. 2). The PoWER method finds worse solutions than both stochastic optimization approaches for the same amount of computational time, likely due to using EM which is known to be susceptible to local optima. On the other hand, its primary advantage is that it has a very small memory requirement. Overall this suggests the benefit of our proposed approach to be used for online MDP policy search, since it quickly (as a function of samples and runtime) can find a global optima, and is, to our knowledge, one of the only policy search methods guaranteed to do so."}, {"heading": "7 Discussion and Future Work", "text": "In the current version of HCT we assume that the learner has access to the information regarding the smoothness of function f(x) and the mixing time \u0393. In many problems those information are not available to the learner. In the future it would be interesting to build on prior work that handles unknown smoothness in iid settings and extend it to correlated feedback. For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm. 4, and do not require knowledge of the dissimilarity measure \u2113. On the other hand, Slivkins (2011) and Bull (2013) study the cumulative regret but consider a different definition of smoothness related to the zooming concept introduced by Kleinberg et al. (2008). Finally, we notice that to deal with unknown mixing time, one may rely on data-dependent tail\u2019s inequalities, such as empirical Bernstein inequality (Tolstikhin & Seldin, 2013; Maurer & Pontil, 2009), replacing the mixing time with the empirical variance of the rewards.\nIn the future we also wish to explore using HCT to optimize other problems that can be modeled using correlated bandit feedback. For example, HCT may be used for policy search in partially observable MDPs (Vlassis & Toussaint, 2009; Baxter & Bartlett, 2000), as long as the POMDP is ergodic.\nTo conclude, in this paper we introduce a new X -armed bandit algorithm, called HCT , for optimization under bandit feedback and prove regret bounds and simulation results for it. Our approach improves on existing results to handle the important case of correlated bandit feedback. This allows HCT to be applied to a broader range of problems than prior X -armed bandit algorithms, such as we demonstrate by using it to perform policy search for continuous MDPs.\nAppendices"}, {"heading": "A Proof of Thm. 1", "text": "In this section we report the full proof of the regret bound of HCT-iid.\nWe begin by introducing some additional notation, required for the analysis of both algorithms. We denote the indicator function of an event E by IE . For all 1 \u2264 h \u2264 H(t) and t > 0, we denote by Ih(t) the set of all nodes created by the algorithm at depth h up to time t and by I+h (t) the subset of Ih(t) including only the internal nodes (i.e., nodes that are not leaves), which corresponds to nodes at depth h which have been expanded before time t. At each time step t, we denote by (ht, it) the node selected by the algorithm. For every (h, i) \u2208 T , we define the set of time steps when (h, i) has been selected as Ch,i := {t = 1, . . . , n : (ht, it) = (h, i)}. We also define the set of times that a child of (h, i) has been selected as Cch,i := Ch+1,2i\u22121\n\u22c3Ch+1,2i. We need to introduce three important steps related to node (h, i):\n\u2022 t\u0304h,i := maxt\u2208Ch,i t is the last time (h, i) has been selected,\n\u2022 t\u0303h,i := maxt\u2208Cch,i t is the last time when any of the two children of (h, i) has been selected,\n\u2022 th,i := min{t : Th,i(t) > \u03c4h(t)} is the step when (h, i) is expanded.\nThe choice of \u03c4h. The threshold on the the number of pulls needed before expanding a node at depth h is determined\nso that, at each time t, the two confidence terms in the definition of U (Eq. 4) are roughly equivalent, that is\n\u03bd1\u03c1 h = c\n\u221a log(1/\u03b4\u0303(t+))\n\u03c4h(t) =\u21d2 \u03c4h(t) =\nc2 log(1/\u03b4\u0303(t+))\n\u03bd21 \u03c1\u22122h.\nFurthermore, since t \u2264 t+ \u2264 2t then\nc2\n\u03bd21 \u03c1\u22122h \u2264 c\n2 log(1/\u03b4\u0303(t))\n\u03bd21 \u03c1\u22122h \u2264 \u03c4h(t) \u2264\nc2 log(2/\u03b4\u0303(t))\n\u03bd21 \u03c1\u22122h, (8)\nwhere we used the fact that 0 < \u03b4\u0303(t) \u2264 1 for all t > 0. As described in Section 3, the idea is that the expansion of a node, which corresponds to an increase in the resolution of the approximation of f , should not be performed until the empirical estimate \u00b5\u0302h,i of f(xh,i) is accurate enough. Notice that the number of pulls Th,i(t) for an expanded node (h, i) does not necessarily coincide with \u03c4h(t), since t might correspond to a time step when some leaves have not been pulled until \u03c4h(t) and other nodes have not been fully resampled after a refresh phase.\nWe begin our analysis by bounding the maximum depth of the trees constructed by HCT-iid.\nLemma 1 Given the number of samples \u03c4h(t) required for the expansion of nodes at depth h in Eq. 6, the depth H(n) of the tree Tn is bounded as\nH(n) \u2264 Hmax(n) = 1 1\u2212 \u03c1 log ( n\u03bd21 2(c\u03c1)2 ) .\nProof. The deepest tree that can be developed by HCT-iid is a linear tree, where at each depth h only one node is expanded, that is , |I+h (n)| = 1 and |Ih(n)| = 2 for all h < H(n). Thus we have\nn =\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) Th,i(n) \u2265\nH(n)\u22121\u2211\nh=0\n\u2211\ni\u2208Ih(n) Th,i(n) \u2265\nH(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nTh,i(n) \u2265 H(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nTh,i(th,i)\n(1) \u2265 H(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\n\u03c4h,i(th,i) \u2265 H(n)\u22121\u2211\nh=1\nc2\n\u03bd21 \u03c1\u22122h \u2265 (c\u03c1)\n2\n\u03bd21 \u03c1\u22122H(n)\nH(n)\u22121\u2211\nh=1\n\u03c1\u22122(h\u2212H(n)+1),\nwhere inequality (1) follows from the fact that a node (h, i) is expanded at time th,i only when it is pulled enough, i.e., Th,i(th,i) \u2265 \u03c4h(th,i). Since all the elements in the summation over h are positive, then we can lower-bound the sum by its last element (h = H(n)), which is 1, and obtain\nn \u2265 2(c\u03c1) 2 \u03bd21 H(n)\u03c1\u22122H(n) \u2265 2(c\u03c1) 2 \u03bd21 \u03c1\u22122H(n),\nwhere we used the fact that H(n) \u2265 1. By solving the previous expression we obtain\n\u03c1\u22122H(n) \u2264 n \u03bd 2 1 2(c\u03c1)2 =\u21d2 H(n) \u2264 1 2 log ( n\u03bd21 2(c\u03c1)2 ) / log(1/\u03c1).\nFinally, the statement follows using log(1/\u03c1) \u2265 1\u2212 \u03c1.\nWe now introduce a high probability event under which the mean reward for all the expanded nodes is within a confidence interval of the empirical estimates at a fixed time t.\nLemma 3 (High-probability event). We define the set of all the possible nodes in trees of maximum depth Hmax(t) as\nLt = \u22c3\nT :Depth(T )\u2264Hmax(t) Nodes(T ).\nWe introduce the event\nEt = { \u2200(h, i) \u2208 Lt,\u2200Th,i(t) = 1..t : \u2223\u2223\u2223\u00b5\u0302h,i(t)\u2212 f(xh,i) \u2223\u2223\u2223 \u2264 c\n\u221a log(1/\u03b4\u0303(t))\nTh,i(t)\n} ,\nwhere xh,i \u2208 Ph,i is the arm corresponding to node (h, i). If\nc = 2\n\u221a 1\n1\u2212 \u03c1 and \u03b4\u0303(t) = \u03b4 t 8\n\u221a \u03c1\n3\u03bd1 ,\nthen for any fixed t, the event Et holds with probability at least 1\u2212 \u03b4/t6.\nProof. We upper bound the probability of the complementary event as\nP[Ect ] \u2264 \u2211\n(h,i)\u2208Lt\nt\u2211\nTh,i(t)=1\nP [\u2223\u2223\u00b5\u0302h,i(t)\u2212 \u00b5h,i \u2223\u2223 \u2265 c\n\u221a log(1/\u03b4\u0303(t))\nTh,i(t)\n]\n\u2264 \u2211\n(h,i)\u2208Lt\nt\u2211\nTh,i(t)=1\n2 exp ( \u2212 2Th,i(t)c2 log(1/\u03b4\u0303(t))\nTh.i(t)\n)\n= 2exp ( \u2212 2c2 log(1/\u03b4\u0303(t)) ) t|Lt|,\nwhere the first inequality is an application of a union bound and the second inequality follows from the ChernoffHoeffding inequality. We upper bound the number of nodes in Lt by the largest binary tree with a maximum depth Hmax(t), i.e., |Lt| \u2264 2Hmax(t)+1. Thus\nP[Ect ] \u2264 2(\u03b4\u0303(t))2c 2 t2Hmax(t)+1.\nWe first derive a bound on the the term 2Hmax(t) as\n2Hmax(t) \u2264 pow ( 2, log2 ( t\u03bd21\n2(c\u03c1)2\n) 1 2 log2(e)(1\u2212\u03c1) ) \u2264 ( t\u03bd21\n2(c\u03c1)2\n) 1 2(1\u2212\u03c1)\n,\nwhere we used the upper bound Hmax(t) from Lemma 1 and log2(e) > 1. This leads to\nP[Ect ] \u2264 4t ( \u03b4\u0303(t)\n)2c2 (\nt\u03bd21 2(c\u03c1)2\n) 1 2(1\u2212\u03c1)\n.\nThe choice of c and \u03b4\u0303(t) as in the statement leads to\nP[Ect ] \u2264 4t ( 8 \u221a \u03c1/(3\u03bd1)\u03b4/t ) 8 1\u2212\u03c1 ( t\u03bd21(1\u2212 \u03c1)\n8\u03c12\n) 1 2(1\u2212\u03c1)\n= 4t ( \u03b4/t ) 8 1\u2212\u03c1 ( \u03c1/(3\u03bd1) ) 1 1\u2212\u03c1 t 1 2(1\u2212\u03c1) ( \u03bd1 \u221a 1\u2212 \u03c1\u221a 8\u03c1 ) 1 1\u2212\u03c1\n\u2264 4\u03b4t1\u2212 8 1\u2212\u03c1 + 1 2(1\u2212\u03c1) (\u221a 1\u2212 \u03c1 3 \u221a 8 ) 1 1\u2212\u03c1 \u2264 4 3 \u221a 8 \u03b4t \u22122\u03c1\u221213 2(1\u2212\u03c1) \u2264 \u03b4t\u221213/2 \u2264 \u03b4/t6,\nwhich completes the proof.\nRecalling the definition the regret from Sect. s:preliminaries, we decompose the regret of HCT-iid in two terms depending on whether event Et holds or not (i.e., failing confidence intervals). Let the instantaneous regret be \u2206t = f \u2217 \u2212 rt, then we rewrite the regret as\nRn =\nn\u2211\nt=1\n\u2206t =\nn\u2211\nt=1\n\u2206tIEt + n\u2211\nt=1\n\u2206tIEct = R E n +R Ec n . (9)\nWe first study the regret in the case of failing confidence intervals.\nLemma 4 (Failing confidence intervals). Given the parameters c and \u03b4\u0303(t) as in Lemma 3, the regret of HCT-iid when confidence intervals fail to hold is bounded as\nRE c n \u2264 \u221a n,\nwith probability 1\u2212 \u03b4 5n2 .\nProof. We first split the time horizon n in two phases: the first phase until \u221a n and the rest. Thus the regret becomes\nRE c\nn =\nn\u2211\nt=1\n\u2206tIEct =\n\u221a n\u2211\nt=1\n\u2206tIEct + n\u2211\nt= \u221a n+1\n\u2206tIEct .\nWe trivially bound the regret of first term by \u221a n. So in order to prove the result it suffices to show that event Ect\nnever happens after \u221a n, which implies that the remaining term is zero with high probability. By summing up the probabilities P[Ect ] from \u221a n+ 1 to n and applying union bound we deduce\nP\n[ n\u22c3\nt= \u221a n+1\nEct ] \u2264 n\u2211\nt= \u221a n+1\nP[Ect ] \u2264 n\u2211\n\u221a n+1\n\u03b4 t6 \u2264 \u222b +\u221e \u221a n \u03b4 t6 dt \u2264 \u03b4 5n5/2 \u2264 \u03b4 5n2 .\nIn words this result implies that w.p. \u2265 1 \u2212 \u03b4/(5n2) we can not have a failing confidence interval after time \u221an. This combined with the trivial bound of \u221a n for the first \u221a n steps completes the proof.\nWe are now ready to prove the main theorem, which only requires to study the regret term under events {Et}. Theorem 1 (Regret bound of HCT-iid). Let \u03b4 \u2208 (0, 1), \u03b4\u0303(t) = 8 \u221a \u03c1/(3\u03bd1)\u03b4/t, and c = 2 \u221a 1/(1 \u2212 \u03c1). We assume that Assumptions 3\u20135 hold and that at each step t, the reward rt is independent of all prior random events and E(rt|xt) = f(xt). Then the regret of HCT-iid after n steps is\nRn \u2264 3 ( 22d+7\u03bd 2(d+1) 1 C\u03bd \u2212d 2 \u03c1 d (1\u2212 \u03c1)d+7 ) 1 d+2 ( log (2n \u03b4 8 \u221a 3\u03bd1 \u03c1 )) 1d+2 n d+1 d+2 + 2 \u221a n log(4n/\u03b4),\nwith probability 1\u2212 \u03b4.\nProof. Step 1: Decomposition of the regret. We start by further decomposing the regret in two terms. We rewrite the instantaneous regret \u2206t as\n\u2206t = f \u2217 \u2212 rt = f\u2217 \u2212 f(xht,it) + f(xht,it)\u2212 rt = \u2206ht,it + \u2206\u0302t,\nwhich leads to a regret (see Eq. 9)\nREn = n\u2211\nt=1\n\u2206ht,itIEt + n\u2211\nt=1\n\u2206\u0302tIEt \u2264 n\u2211\nt=1\n\u2206ht,itIEt + n\u2211\nt=1\n\u2206\u0302t = R\u0303 E n + R\u0302 E n. (10)\nWe start bounding the second term. We notice that the sequence {\u2206\u0302t}nt=1 is a bounded martingale difference sequence since E(\u2206\u0302t|Ft\u22121) = 0 and |\u2206\u0302t| \u2264 1. Therefore, an immediate application of the Azuma\u2019s inequality leads to\nR\u0302En = n\u2211\nt=1\n\u2206\u0302t \u2264 2 \u221a n log(4n/\u03b4), (11)\nwith probability 1\u2212 \u03b4/(4n2). Step 2: Preliminary bound on the regret of selected nodes and their parents. We now proceed with the study of the first term R\u0303En, which refers to the regret of the selected nodes as measured by its mean-reward. We start by characterizing which nodes are actually selected by the algorithm under event Et. Let (ht, it) be the node chosen at time t and Pt be the path from the root to the selected node. Let (h\u2032, i\u2032) \u2208 Pt and (h\u2032\u2032, i\u2032\u2032) be the node which immediately follows (h\u2032, i\u2032) in Pt (i.e., h\u2032\u2032 = h\u2032 + 1). By definition of B and U values, we have that\nBh\u2032,i\u2032(t)=min [ Uh\u2032,i\u2032(t);max ( Bh\u2032+1,2i\u2032\u22121(t);Bh\u2032+1,2i\u2032(t) )] \u2264max ( Bh\u2032+1,2i\u2032\u22121(t);Bh\u2032+1,2i\u2032(t) ) =Bh\u2032\u2032,i\u2032\u2032(t),\n(12)\nwhere the last equality follows from the fact that the OptTraverse function selects the node with the largest B value. By iterating the previous inequality for all the nodes in Pt until the selected node (ht, it) and its parent (h p t , i p t ), we obtain that\nBh\u2032,i\u2032(t) \u2264 Bht,it(t) \u2264 Uht,it(t), \u2200(h\u2032, i\u2032) \u2208 Pt Bh\u2032,i\u2032(t) \u2264 Bhpt ,ipt (t) \u2264 Uhpt ,ipt (t), \u2200(h \u2032, i\u2032) \u2208 Pt \u2212 (ht, it)\nby definition of B-values. Thus for any node (h, i) \u2208 Pt}, we have that Uht,it(t) \u2265 Bh,i(t). Furthermore, since the root node (0, 1) which covers the whole arm space X is in Pt, thus there exists at least one node (h\u2217, i\u2217) in the set Pt which includes the maximizer x\u2217 (i.e., x\u2217 \u2208 Ph\u2217,i\u2217) and has the the depth h\u2217 \u2264 hpt < ht.8 Thus\nUht,it(t) \u2265 Bh\u2217,i\u2217(t). Uhpt ,i p t (t) \u2265 Bh\u2217,i\u2217(t)\n(13)\nNotice that in the set Pt we may have multiple nodes (h\u2217, i\u2217) which contain x\u2217 and that for all of them we have the following sequence of inequalities holds\nf\u2217 \u2212 f(xh\u2217,i\u2217) \u2264 \u2113(x\u2217, xh\u2217,i\u2217) \u2264 diam(Ph\u2217,i\u2217) \u2264 \u03bd1\u03c1h \u2217 , (14)\nwhere the second inequality holds since x\u2217 \u2208 Ph\u2217,i\u2217 . Now we expand the inequality in Eq. 13 on both sides using the high-probability event Et. First we have\nUht,it(t) = \u00b5\u0302ht,it(t) + \u03bd1\u03c1 ht + c\n\u221a log(1/\u03b4\u0303(t+))\nTht,it(t) \u2264 f(xht,it) + c\n\u221a log(1/\u03b4\u0303(t))\nTht,it(t) + \u03bd1\u03c1\nht + c\n\u221a log(1/\u03b4\u0303(t+))\nTht,it(t)\n\u2264 f(xht,it) + \u03bd1\u03c1ht + 2c \u221a log(1/\u03b4\u0303(t+))\nTht,it(t) , (15)\nwhere the first inequality holds on E by definition of U and the second by the fact that t+ \u2265 t (and log(1/\u03b4\u0303(t)) \u2264 log(1/\u03b4\u0303(t+))). The same result also holds for (hpt , i p t ) at time t:\nUhpt ,i p t (t) \u2264 f(xhpt ,ipt ) + \u03bd1\u03c1\nhpt + 2c\n\u221a log(1/\u03b4\u0303(t+))\nThpt ,i p t (t)\n. (16)\n8Note that we never pull the root node (0, 1), therefore ht > 0.\nWe now show that for any node (h\u2217, i\u2217) such that x\u2217 \u2208 Ph\u2217,i\u2217 , then Uh\u2217,i\u2217(t) is a valid upper bound on f\u2217:\nUh\u2217,i\u2217(t) = \u00b5\u0302h\u2217,i\u2217(t) + \u03bd1\u03c1 h + c\n\u221a log(1/\u03b4\u0303(t+))\nTh\u2217,i\u2217(t)\n(1) \u2265 \u00b5\u0302h\u2217,i\u2217(t) + \u03bd1\u03c1h \u2217 + c\n\u221a log(1/\u03b4\u0303(t))\nTh\u2217,i\u2217(t)\n(2) \u2265 f(xh\u2217,i\u2217) + \u03bd1\u03c1h \u2217 (3) \u2265 f\u2217,\nwhere (1) follows from the fact that t+ \u2265 t, on (2) we rely on the fact that the event Et holds at time t and on (3) we use the regularity of the function w.r.t. the maximum f\u2217 from Eq. 14. If an optimal node (h\u2217, i\u2217) is a leaf, then Bh\u2217,i\u2217(t) = Uh\u2217,i\u2217(t) \u2265 f\u2217. In the case that (h\u2217, i\u2217) is not a leaf, there always exists a leaf (h+, i+) such that x\u2217 \u2208 Ph+,i+ for which (h\u2217, i\u2217) is its ancestor, since all the optimal nodes with h > h\u2217 are descendants of (h\u2217, i\u2217). Now by propagating the bound backward from (h+, i+) to (h\u2217, i\u2217) through Eq. 5 (see Eq. 12) we can show that Bh\u2217,i\u2217(t) is still a valid upper bound of the optimal value f\u2217. Thus for any optimal node (h\u2217, i\u2217) at time t under the event Et we have\nBh\u2217,i\u2217(t) \u2265 f\u2217.\nCombining this with Eq. 15, Eq. 16 and Eq. 13 , we obtain that on event Et the selected node (ht, it) and its parent (hpt , i p t ) at any time t is such that\n\u2206ht,it = f \u2217 \u2212 f(xht,it) \u2264 \u03bd1\u03c1ht + 2c\n\u221a log(1/\u03b4\u0303(t+))\nTht,it(t) .\n\u2206hpt ,i p t = f\u2217 \u2212 f(xhpt ,ipt ) \u2264 \u03bd1\u03c1 hpt + 2c\n\u221a log(1/\u03b4\u0303(t+))\nThpt ,i p t (t)\n.\n(17)\nFurthermore, since HCT-iid only selects nodes with Th,i(t) < \u03c4h(t) the previous expression can be further simplified as\n\u2206ht,it \u2264 3c \u221a log(2/\u03b4\u0303(t))\nTht,it(t) , (18)\nwhere we also used that t+ \u2264 2t for any t. Although this provides a preliminary bound on the instantaneous regret of the selected nodes, we need to further refine this bound.\nIn the case of parent (hpt , i p t ), since Thpt ,i p t (t) \u2265 \u03c4hpt (t), we deduce\n\u2206hpt ,i p t \u2264 \u03bd1\u03c1h\np t + 2c\n\u221a log(1/\u03b4\u0303(t+))\n\u03c4hpt (t) = 3\u03bd1\u03c1\nhpt , (19)\nThis implies that every selected node (ht, it) has a 3\u03bd1\u03c1ht\u22121-optimal parent under the event Et. Step 3: Bound on the cumulative regret. We first decompose R\u0303En over different depths. Let 1 \u2264 H \u2264 H(n) a\nconstant to be chosen later, then we have\nR\u0303En = n\u2211\nt=1\n\u2206ht,itIEt \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n\u2206h,iI(ht,it)=(h,i)IEt\n(1) \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n3c\n\u221a log(2/\u03b4\u0303(t))\nTh,i(t) I(ht,it)=(h,i)\n(2) \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nTh,i(n)\u2211\ns=1\n3c\n\u221a log(2/\u03b4\u0303(t\u0304h,i))\ns\n\u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u222b Th,i(n)\n1 3c\n\u221a log(2/\u03b4\u0303(t\u0304h,i))\ns ds \u2264\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) 6c\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n= 6c\nH\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (a)\n+6c\nH(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (b)\n(20)\nwhere in (1) we rely on the definition of event Et and Eq. 18 and in (2) we rely on the fact that at any time step t when the algorithm pulls the arm (h, i), Th,i is incremented by 1 and that by definition of t\u0304h,i we have that t \u2264 t\u0304h,i . We now bound the two terms in the RHS of Eq. 20. We first simplify the first term as\n(a) =\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i)) \u2264 H\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a \u03c4h(n) log(2/\u03b4\u0303(n))\n= H\u2211\nh=0\n|Ih(n)| \u221a \u03c4h(n) log(2/\u03b4\u0303(n)), (21)\nwhere the inequality follows from Th,i(n) \u2264 \u03c4h(n) and t\u0304h,i \u2264 n. We now need to provide a bound on the number of nodes at each depth h. We first notice that since T is a binary tree, the number of nodes at depth h is at most twice the number of nodes at depth h\u2212 1 that have been expanded (i.e., the parent nodes), i.e., |Ih(n)| \u2264 2|I+h\u22121(n)|. We also recall the result of Eq. 19 which guarantees that (hpt , i p t ), the parent of the selected node (ht, it), is 3\u03bd1\u03c1 ht\u22121 optimal, that is, HCT never selects a node (ht, it) unless its parent is 3\u03bd1\u03c1ht\u22121 optimal. From Asm. 5 we have that the number of 3\u03bd1\u03c1h-optimal nodes is bounded by the covering number N (3\u03bd1/\u03bd2\u03b5, l, \u03b5) with \u03b5 = \u03bd1\u03c1h. Thus we obtain the bound\n|Ih(n)| \u2264 2|I+h\u22121(n)| \u2264 2C(\u03bd2\u03c1(h\u22121))\u2212d, (22)\nwhere d is the near-optimality dimension of f around x\u2217. This bound combined with Eq. 21 implies that\n(a) \u2264 H\u2211\nh=0\n2C\u03bd\u2212d2 \u03c1 \u2212(h\u22121)d \u221a \u03c4h(n) log(2/\u03b4\u0303(n)) \u2264 H\u2211\nh=0\n2C\u03bd\u2212d2 \u03c1 \u2212(h\u22121)d\n\u221a c2 log(1/\u03b4\u0303(n+))\n\u03bd21 \u03c1\u22122h log(2/\u03b4\u0303(n))\n\u2264 2C\u03bd\u2212d2 c log(2/\u03b4\u0303(n+))\n\u03bd1 \u03c1d\nH\u2211\nh=0\n\u03c1\u2212h(d+1) \u2264 2C\u03bd\u2212d2 c log(2/\u03b4\u0303(n+))\n\u03bd1 \u03c1d\n\u03c1\u2212H(d+1)\n1\u2212 \u03c1 . (23)\nWe now bound the second term of Eq. 20 as\n(b) (1) \u2264 \u221a\u221a\u221a\u221a\u221a H(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n) log(2/\u03b4(t\u0304h,i))\n\u221a\u221a\u221a\u221a\u221a H(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n) Th,i(n)\n(2) \u2264 \u221a\u221a\u221a\u221a\u221a H(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n) log(2/\u03b4\u0303(t\u0304h,i))\n\u221a n (24)\nwhere in (1) we make use of Cauchy-Schwarz inequality and in (2) we simply bound the total number of samples by n. We now focus on the summation in the first square root. We recall that we denote by t\u0303h,i the last time when any of the two children of node (h, i) has been pulled. Then we have the following sequence of inequalities.\nn =\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) Th,i(n) \u2265\nH(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nTh,i(n) \u2265 H(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nTh,i(t\u0303h,i) (1) \u2265 H(n)\u22121\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\n\u03c4h(t\u0303h,i)\n\u2265 H(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\n\u03c4h(t\u0303h,i) \u2265 H(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\n\u03c1\u22122hc2 log(1/\u03b4\u0303(t\u0303+h,i))\n\u03bd21\n\u2265 c 2\u03c1\u22122H\n\u03bd21\nH(n)\u22121\u2211\nh=H\n\u03c12(H\u2212h) \u2211\ni\u2208I+ h (n)\nlog(1/\u03b4\u0303(t\u0303+h,i)) (2) \u2265 c 2\u03c1\u22122H\n\u03bd21\nH(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\nlog(1/\u03b4\u0303(t\u0303+h,i))),\n(25)\nwhere in (1) we rely on the fact that, at each time step t, HCT-iid only selects a node when Th,i(t) \u2265 \u03c4h,i(t) for its parent and in (2) we used that \u03c12(H\u2212h) \u2265 1 for all h \u2265 H . We notice that, by definition of t\u0303h,i, for any internal node (h, i) t\u0303h,i = max(t\u0304h+1,2i\u22121, t\u0304h+1,2i). We also notice that for any t1, t2 > 0 we have that [max(t1, t2)]+ = max(t+1 , t + 2 ). This implies that\nn \u2265 c 2\u03c1\u22122H\n\u03bd21\nH(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\nlog(1/\u03b4\u0303([max(t\u0304h+1,2i\u22121, t\u0304h+1,2i)] +))\n(1) =\nc2\u03c1\u22122H\n\u03bd21\nH(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\nmax(log(1/\u03b4\u0303(t\u0304+h+1,2i\u22121)), log(1/\u03b4\u0303(t\u0304 + h+1,2i\u22121)))\n(2) \u2265 c 2\u03c1\u22122H\n\u03bd21\nH(n)\u22121\u2211\nh=H\n\u2211\ni\u2208I+ h (n)\nlog(1/\u03b4\u0303(t\u0304+h+1,2i\u22121)) + log(1/\u03b4\u0303(t\u0304 + h+1,2i))\n2\n(3) =\nc2\u03c1\u22122H\n2\u03bd21\nH(n)\u2211\nh\u2032=H+1\n\u2211\ni\u2208I+ h\u2032\u22121 (n)\nlog(1/\u03b4\u0303(t\u0304+h\u2032,2i\u22121)) + log(1/\u03b4\u0303(t\u0304 + h\u2032,2i))\n(4) =\nc2\u03c1\u22122H\n2\u03bd21\nH(n)\u2211\nh\u2032=H+1\n\u2211\ni\u2032\u2208Ih\u2032 (n) log(1/\u03b4\u0303(t\u0304+h\u2032,i\u2032)),\n(26)\nwhere in (1) we rely on the fact that, for any t > 0, log(1/\u03b4\u0303(t)) is an increasing function of t. Therefore we have that log(1/\u03b4\u0303(max(t1, t2))) = max(log(1/\u03b4\u0303(t1)), log(1/\u03b4\u0303(t2))) for any t1, t2 > 0 . In (2) we rely on the fact that the maximum of some random variables is always larger than their average. We introduce a new variable h\u2032 = h+1 to derive (3). For proving (4) we rely on the argument that, for any h > 0, I+h (n) covers all the internal nodes at layer h. This implies that the set of the children of I+h (n) covers Ih+1(n). This combined with fact that the inner sum in (3) is essentially taken on the set of the children of I+h\u2032\u22121(n) proves (4). Inverting Eq. 26 we have\nH(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n) log(1/\u03b4\u0303(t\u0304+h,i)) \u2264\n2\u03bd21\u03c1 2Hn\nc2 . (27)\nBy plugging Eq. 27 into Eq. 24 we deduce\n(b) \u2264 \u221a\u221a\u221a\u221a\u221a H(n)\u2211\nh=H+1\n\u2211 i\u2208Ih log(2/\u03b4\u0303(t\u0304+h,i)) \u221a n \u2264\n\u221a\u221a\u221a\u221a\u221a H(n)\u2211\nh=H+1\n\u2211 i\u2208Ih 2 log(1/\u03b4\u0303(t\u0304+h,i)) \u221a n\n\u2264\n\u221a 4\u03bd21\u03c1 2Hn\nc2 \u221a n = 2 c \u03bd1\u03c1 Hn.\nThis combined with Eq. 23 provides the following bound on R\u0303n:\nR\u0303En \u2264 12\u03bd1 [ Cc2\u03bd\u2212d2 \u03c1 d log(2/\u03b4\u0303(n))\n\u03bd21(1\u2212 \u03c1) \u03c1\u2212H(d+1) + \u03c1Hn\n] .\nWe then choose H to minimize the previous bound. Notably we equalize the two terms in the bound by choosing\n\u03c1H =\n( c2C\u03bd\u2212d2 \u03c1 d\n(1\u2212 \u03c1)\u03bd21 log(2/\u03b4\u0303(n)) n\n) 1 d+2\n,\nwhich, once plugged into the previous regret bound, leads to\nR\u0303En \u2264 24\u03bd1 c\n( c2C\u03bd\u2212d2 \u03c1 d\n(1\u2212 \u03c1)\u03bd21\n) 1 d+2 (\nlog(2/\u03b4\u0303(n)) ) 1 d+2n d+1 d+2 .\nUsing the values of \u03b4\u0303(t) and c defined in Lemma 3, the previous expression becomes\nR\u0303En \u2264 3 ( 22(d+3)\u03bd 2(d+1) 1 C\u03bd \u2212d 2 \u03c1 d (1\u2212 \u03c1)d/2+3 ) 1 d+2 ( log (2n \u03b4 8 \u221a 3\u03bd1 \u03c1 )) 1d+2 n d+1 d+2 .\nThis combined with the regret bound of Eq. 11 and the result of Lem. 4 and a union bound on all n \u2208 {1, 2, 3, . . . } proves the final result with a probability at least 1\u2212 \u03b4."}, {"heading": "B Correlated Bandit feedback", "text": "We begin the analysis of HCT-\u0393 by proving some useful concentration inequalities for non-iid random variables under the mixing assumptions of Sect. 2.\nB.1 Concentration Inequality for non-iid Episodic Random Variables\nIn this section we extend the result in (Azar et al., 2013) and we derive a concentration inequality for averages of non-iid random variables grouped in episodes. In fact, given the structure of the HCT-\u0393 algorithm, the rewards observed from an arm x are not necessarily consecutive but they are obtained over multiple episodes. This result is of independent interest, thus we first report it in its general form and we later apply it to HCT-\u0393.\nIn HCT-\u0393, once an arm is selected, it is pulled for a number of consecutive steps and many steps may pass before it is selected again. As a result, the rewards observed from one arm are obtained through a series of episodes. Given a fixed horizon n, let Kn(x) be the total number of episodes when arm x has been selected, we denote by tk(x), with k = 1, . . . ,Kn(x), the step when k-th episode of arm x has started and by vk(x) the length of episode k. Finally,\nTn(x) = \u2211Kn(x)\nk vk(x) is the total number of samples from arm x. The objective is to study the concentration of the empirical mean built using all the samples\n\u00b5\u0302n(x) = 1\nTn(x)\nKn(x)\u2211\nk=1\ntk(x)+vk(x)\u2211\nt=tk(x)\nrt(x),\ntowards the mean-reward f(x) of the arm. In order to simplify the notation, in the following we drop the dependency from n and x and we use K , tk, and vk. We first introduce two quantities. For any t = 1, . . . , n and for any k = 1, . . . ,K , we define\nMkt (x) = E [ tk+vk\u2211\nt\u2032=tk\nrt\u2032 \u2223\u2223Ft ] ,\nas the expectation of the sum of rewards within episode k, conditioned on the filtration Ft up to time t (see definition in Section 2),9 and the residual\n\u03b5kt (x) = M k t (x)\u2212Mkt\u22121(x).\nWe prove the following.\nLemma 5. For any x \u2208 X , k = 1, . . . ,K , and t = 1, . . . , n, \u03b5kt (x) is a bounded martingale sequence difference, i.e., \u03b5kt (x) \u2264 2\u0393 + 1 and E[\u03b5kt (x)|Ft\u22121] = 0.\nProof. Given the definition of Mkt (x) we have that\n\u03b5kt (x) = M k t (x)\u2212Mkt\u22121(x) = E\n[ tk+vk\u2211\nt\u2032=tk\nrt\u2032 \u2223\u2223Ft ] \u2212 E [ tk+vk\u2211\nt\u2032=tk\nrt\u2032 \u2223\u2223Ft\u22121\n]\n=\nt\u2211\nt\u2032=tk\nrt\u2032 + E [ tk+vk\u2211\nt\u2032=t+1\nrt\u2032 \u2223\u2223Ft ] \u2212 t\u22121\u2211\nt\u2032=tk\nrt\u2032 \u2212 E [ tk+vk\u2211\nt\u2032=t\nrt\u2032 \u2223\u2223Ft\u22121\n]\n= rt + E [ tk+vk\u2211\nt\u2032=t+1\nrt\u2032 \u2223\u2223Ft ] \u2212 E [ tk+vk\u2211\nt\u2032=t\nrt\u2032 \u2223\u2223Ft\u22121\n]\n= rt \u2212 f(x) + E [ tk+vk\u2211\nt\u2032=t+1\nrt\u2032 \u2223\u2223Ft ] \u2212 (tk + vk \u2212 t)f(x) + (tk + vk \u2212 t+ 1)f(x)\u2212 E [ tk+vk\u2211\nt\u2032=t\nrt\u2032 \u2223\u2223Ft\u22121\n]\n\u2264 1 + \u0393 + \u0393.\nSince the previous inequality holds both ways, we obtain that |\u03b5kt (x)| \u2264 2\u0393 + 1. Furthermore, we have that\nE [ \u03b5kt (x)|Ft\u22121] = E [ Mkt (x)\u2212Mkt\u22121(x)|Ft\u22121 ]\n= E [ rt + E [ tk+vk\u2211\nt\u2032=t+1\nrt\u2032 \u2223\u2223Ft ]\u2223\u2223\u2223\u2223Ft\u22121 ] \u2212 E [ tk+vk\u2211\nt\u2032=t\nrt\u2032 \u2223\u2223Ft\u22121 ] = 0.\nWe can now proceed to derive a high-probability concentration inequality for the average reward of each arm x.\n9Notice that the index t of the filtration can be before, within, or after the k-th episode.\nLemma 6. For any x \u2208 X pulled K(x) episodes, each of length vk(x), for a total number of T (x) samples, we have that\n\u2223\u2223\u2223\u2223 1\nT (x)\nK(x)\u2211\nk=1\ntk+vk\u2211\nt=tk\nrt \u2212 f(x) \u2223\u2223\u2223\u2223 \u2264 (2\u0393 + 1) \u221a 2 log(2/\u03b4)\nT (x) +\nK(x)\u0393\nT (x) , (28)\nwith probability 1\u2212 \u03b4.\nProof. We first notice that for any episode k10\ntk+vk\u2211\nt=tk\nrt = M k tk+vk ,\nsince Mktk+vk = E [\u2211tk+vk t\u2032=tk rt\u2032 \u2223\u2223Ftk+vk ] and the filtration completely determines all the rewards. We can further develop the previous expression using a telescopic expansion which allows us to rewrite the sum of the rewards as a sum of residuals \u03b5kt as\ntk+vk\u2211\nt=tk\nrt = M k tk+vk = Mktk+vk \u2212M k tk+vk\u22121 +M k tk+vk\u22121 \u2212M k tk+vk\u22122 +M k tk+vk\u22122 + \u00b7 \u00b7 \u00b7 \u2212M k tk +Mktk\n= \u03b5ktk+vk + \u03b5 k tk+vk\u22121 + \u00b7 \u00b7 \u00b7+ \u03b5 k tk+1 +Mktk =\ntk+vk\u2211\nt=tk+1\n\u03b5kt +M k tk .\nThus we can proceed by bounding\n\u2223\u2223\u2223\u2223 K(x)\u2211\nk=1\n( tk+vk\u2211\nt=tk\nrt \u2212 vkf(x) )\u2223\u2223\u2223\u2223 \u2264 \u2223\u2223\u2223\u2223 K(x)\u2211\nk=1\ntk+vk\u2211\nt=tk+1\n\u03b5kt \u2223\u2223\u2223\u2223+ \u2223\u2223\u2223\u2223 K(x)\u2211\nk=1\n( Mktk \u2212 vkf(x) )\u2223\u2223\u2223\u2223\n\u2264 \u2223\u2223\u2223\u2223 K(x)\u2211\nk=1\ntk+vk\u2211\nt=tk+1\n\u03b5kt \u2223\u2223\u2223\u2223+K(x)\u0393.\nBy Lem. 5 \u03b5kt is a bounded martingale sequence difference, thus we can directly apply the Azuma\u2019s inequality and obtain that\n\u2223\u2223\u2223\u2223 K(x)\u2211\nk=1\ntk+vk\u2211\nt=tk+1\n\u03b5kt \u2223\u2223\u2223\u2223 \u2264 (2\u0393 + 1) \u221a 2T (x) log(2/\u03b4).\nGrouping all the terms together and dividing by T (x) leads to the statement.\nB.2 Proof of Thm. 2\nThe notation needed in this section is the same as in Section A. We only need to restate the notation about the episodes from previous section to HCT-\u0393. We denote by Kh,i(n) the number of episodes for node (h, i) up to time n, by th,i(k) the step when episode k is started, and by vh,i(k) the number of steps of episode k.\nWe first notice that Lemma 1 holds unchanged also for HCT-\u0393, thus bounding the maximum depth of an HCT tree\nto H(n) \u2264 Hmax(n) = 11\u2212\u03c1 log ( n\u03bd21 2(c\u03c1)2 ) . We begin the main analysis by applying the result of Lem. 6 to bound the estimation error of \u00b5\u0302h,i(t) at each time step t.\n10We drop the dependency of M on x.\nLemma 7. Under Assumptions 1 and 2, for any fixed node (h, i) and step t, we have that\n|\u00b5\u0302h,i(t)\u2212 f(xh,i)| \u2264 (3\u0393 + 1) \u221a 2 log(5/\u03b4)\nTh,i(t) +\n\u0393 log(t)\nTh,i(t) .\nwith probability 1\u2212 \u03b4. Furthermore, the previous expression can be conveniently restated for any 0 < \u03b5 \u2264 1 as\nP(|\u00b5\u0302h,i(t)\u2212 f(xh,i)| > \u01eb) \u2264 5t1/3 exp ( \u2212 Th,i(t)\u03b5 2\n2(3\u0393 + 1)2\n)\nProof. As a direct consequence of Lem. 6 we have w.p. 1\u2212 \u03b4,\n|\u00b5\u0302h,i(t)\u2212 f(xh,i)| \u2264 (2\u0393 + 1) \u221a 2 log(2/\u03b4)\nTh,i(t) +\nKh,i(t)\u0393\nTh,i(t) ,\nwhere Kh,i(t) is the number of episodes in which we pull arm xh,i. At each episode in which xh,i is selected, its number of pulls Th,i is doubled w.r.t. the previous episode, except for those episodes where the current time s becomes larger than s+, which triggers the termination of the episode. However since s+ doubles whenever s becomes larger than s+, the total number of times when episodes are interrupted because of s \u2265 s+ can be at maximum log2(t) withing a time horizon of t. This means that the total number of times an episode finishes without doubling Th,i(t) is bounded by log2(t). Thus we have\nTh,i(t) \u2265 Kh,i(t)\u2212log2(t)\u22121\u2211\nk=1\n2k\u22121 \u2265 2Kh,i(t)\u2212log2(t)\u22122,\nwhere in the second inequality we simply keep the last term of the summation. Inverting the previous inequality we obtain that Kh,i(t) \u2264 log2(4Th,i(t)) + log2(t), which bounds the number of episodes w.r.t. the number of pulls and the time horizon t. Combining this result with the high probability bound of Lem. 6, we obtain\n|\u00b5\u0302h,i(t)\u2212 f(xh,i)| \u2264 (2\u0393 + 1) \u221a 2 log(2/\u03b4)\nTh,i(t) + \u0393\nlog2(4Th,i(t))\nTh,i(t) + \u0393\nlog(t) Th,i(t) ,\nwith probability 1 \u2212 \u03b4. The statement of the Lemma is obtained by further simplifying the second term in the right hand side with the objective of achieving a more homogeneous expression. In particular, we have that\nlog2(4Th,i(t)) = 2 log2(2 \u221a Th,i(t)) = 2(log2( \u221a Th,i(t)) + 1) \u2264 2 \u221a Th,i(t),\nand\n|\u00b5\u0302h,i(t)\u2212 f(xh,i)| \u2264 (2\u0393 + 1) \u221a 2 log(2/\u03b4)\nTh,i(t) +\n2\u0393 \u221a\nTh,i(t)\nTh,i(t) +\n\u0393 log(t)\nTh,i(t)\n\u2264 (3\u0393 + 1) \u221a 2 log(5/\u03b4)\nTh,i(t) +\n\u0393 log(t)\nTh,i(t) .\nTo prove the second statement we choose \u03b5 := (3\u0393 + 1) \u221a\n2 log(5/\u03b4) Th,i(t) + \u0393 log(t)Th,i(t) and we solve the previous expression\nw.r.t. \u03b4:\n\u03b4 = 5exp [ \u2212Th,i(t)(\u03b5 \u2212 \u0393 log(t)/Th,i(t)) 2\n2(3\u0393 + 1)2\n] .\nThe following sequence of inequalities then follows\nP(|\u00b5\u0302h,i(t)\u2212 f(xh,i)| > \u03b5) \u2264 \u03b4 = 5exp [ \u2212Th,i(t)(\u03b5\u2212 \u0393 log(t)/Th,i(t)) 2\n2(3\u0393 + 1)2\n] \u2264 5 exp [ \u2212Th,i(t)(\u03b5\n2 \u2212 2\u03b5\u0393 log(t)/Th,i(t)) 2(3\u0393 + 1)2\n]\n\u2264 5 exp [ \u2212Th,i(t)(\u03b5\n2 \u2212 2\u0393 log(t)/Th,i(t)) 2(3\u0393 + 1)2\n] = 5exp [ \u2212 Th,i(t)\u03b5 2\n(3\u0393 + 1)2 +\n2\u0393 log(t)\n2(3\u0393 + 1)2\n]\n\u2264 5 exp [ \u2212 Th,i(t)\u03b5 2\n(3\u0393 + 1)2 +\n2\u0393 log(t)\n12\u0393\n] = 5exp [ \u2212 Th,i(t)\u03b5 2\n2(3\u0393 + 1)2 + log(t1/6)\n] ,\nwhich concludes the proof.\nThe result of Lem. 7 facilitates the adaption of the previous results of iid case to the case of correlated rewards, since this bound is similar to those of standard tail\u2019s inequality such as Hoeffding and Azuma\u2019s inequality. Based on this result we can extend the results of previous section to the case of dependent arms.\nWe now introduce the high probability event Et,n under which the mean reward for all the selected nodes in the interval [t, n] is within a confidence interval of the empirical estimates at every time step in the interval. The event Et,n is needed to concentrate the sum of obtained rewards around the sum of their corresponding arm means. Note that unlike the previous theorem where we could make use of a simple martingale argument to concentrate the rewards around their means, here the rewards are not unbiased samples of the arm means. Therefore, we need a more advanced technique than the Azuma\u2019s inequality for concentration of measure.\nLemma 8 (High-probability event). We define the set of all the possible nodes in trees of maximum depth Hmax(t) as\nLt = \u22c3\nT :Depth(T )\u2264Hmax(t) Nodes(T ).\nWe introduce the event\n\u2126t = { \u2200(h, i) \u2208 Lt,\u2200Th,i(t) = 1, . . . , t : \u2223\u2223\u00b5\u0302h,i(t)\u2212 f(xh,i) \u2223\u2223 \u2264 c\n\u221a log(1/\u03b4\u0303(t))\nTh,i(t)\n} ,\nwhere xh,i \u2208 Ph,i is the arm corresponding to node (h, i), and the event Et,n = \u22c2n s=t\u2126s. If\nc = 6(3\u0393 + 1)\n\u221a 1\n1\u2212 \u03c1 and \u03b4\u0303(t) = \u03b4 t 9\n\u221a \u03c1\n4\u03bd1 ,\nthen for any fixed t, the event \u2126t holds with probability 1 \u2212 \u03b4/t7 and the joint event Et,n holds with probability at least 1\u2212 \u03b4/(6t6).\nProof. We upper bound the probability of complementary event of \u2126t after t steps\nP[\u2126ct ] = \u2211\n(h,i)\u2208Lt\nt\u2211\nTh,i(t)=1\nP [\u2223\u2223\u00b5\u0302h,i(t)\u2212 f(xh,i) \u2223\u2223 \u2265 c\n\u221a log(1/\u03b4\u0303(t))\nTh,i(t)\n]\n\u2264 \u2211\n(h,i)\u2208Lt\nt\u2211\nTh,i(t)=1\n5t1/3 exp ( \u2212 Th,i(t)c2 log(1/\u03b4\u0303(t))\n(3\u0393 + 1)2Th,i(t)\n)\n\u2264 5 exp(\u2212c2/(3\u0393 + 1)2 log(1/\u03b4\u0303(t)))t4/3|Lt|,\nSimilar to the proof of Lem. 4, we have that |Lt| \u2264 2Hmax(t)+1. Thus\nP[\u2126ct ] \u2264 5(\u03b4\u0303(t))(c/(3\u0393+1)) 2 t4/32Hmax(t)+1.\nWe first derive a bound on the the term 2Hmax(t) as\n2Hmax(t) \u2264 pow ( 2, log2 ( t\u03bd21\n2(c\u03c1)2\n) 1 2 log2(e)(1\u2212\u03c1) ) \u2264 ( t\u03bd21\n2(c\u03c1)2\n) 1 2(1\u2212\u03c1)\n,\nwhere we used the definition of the upper bound Hmax(t). which leads to\nP[\u2126ct ] \u2264 10t4/3 ( \u03b4\u0303(t)\n)(c/(3\u0393+1))2 (\nt\u03bd21 2(c\u03c1)2\n) 1 2(1\u2212\u03c1)\n.\nThe choice of c and \u03b4\u0303(t) as in the statement leads to P[\u2126ct ] \u2264 \u03b4t7 (steps are similar to Lemma 3) . The bound on the joint event Et,n follows from a union bound as\nP [ Ect,n ] = P\n[ n\u22c3\ns=t\n\u2126cs\n] \u2264 n\u2211\ns=t\nP(\u2126cs) \u2264 \u222b \u221e\nt\n\u03b4\ns7 ds =\n\u03b4\n6t6 .\nRecalling the definition of regret from Sect. 2, we decompose the regret of HCT-iid in two terms depending on whether event Et holds or not (i.e., failing confidence intervals). Let the instantaneous regret be \u2206t = f\u2217 \u2212 rt, then we rewrite the regret as\nRn =\nn\u2211\nt=1\n\u2206t =\nn\u2211\nt=1\n\u2206tIEt + n\u2211\nt=1\n\u2206tIEct = R E n +R Ec n . (29)\nWe first study the regret in the case of failing confidence intervals.\nLemma 9 (Failing confidence intervals). Given the parameters c and \u03b4\u0303(t) as in Lemma 8, the regret of HCT-iid when confidence intervals fail to hold is bounded as\nRE c n \u2264 \u221a n,\nwith probability 1\u2212 \u03b4 30n2 .\nProof. The proof is the same as in Lemma 4 expect for the union bound which is applied to Et,n for t = \u221a n, . . . , n.\nWe are now ready to prove the main theorem, which only requires to study the regret term under events {Et,n}. Theorem 2 (Regret bound of HCT-\u0393). Let \u03b4 \u2208 (0, 1) and c := 6(3\u0393 + 1) \u221a 1/(1 \u2212 \u03c1). We assume that Assumptions 1\u20135 hold and that rewards are generated according to the general model defined in Section 2. Then the regret of HCT-\u0393 after n steps is\nRn \u2264 2(3 \u221a 2 + 4)\n( c2C\u03bd\u221221 \u03bd \u2212d 2 \u03c1 d\n1\u2212 \u03c1\n) 1 d+2 ( log (2n \u03b4 9 \u221a 3\u03bd1 \u03c1 )) 1d+2 n d+1 d+2 + \u221a n,\nwith probability 1\u2212 \u03b4.\nProof. The structure of the proof is exactly the same as in Thm. 1. Thus, here we report only the main differences in each step.\nStep 1: Decomposition of the regret. We first decompose the regret in two terms. We rewrite the instantaneous regret \u2206t as\n\u2206t = f \u2217 \u2212 rt = f\u2217 \u2212 f(xht,it) + f(xht,it)\u2212 rt = \u2206ht,it + \u2206\u0302t,\nwhich leads to a regret\nREn = n\u2211\nt=1\n\u2206ht,itIEt,n + n\u2211\nt=1\n\u2206\u0302tIEt,n = R\u0303 E n + R\u0302 E n. (30)\nUnlike in Thm. 1, the definition of R\u0302En still requires the event IEt,n and the sequence {\u2206\u0302t}nt=1 is no longer a bounded martingale difference sequence. In fact, E(\u2206\u0302t|Ft\u22121) 6= 0 since the expected value of rt does not coincide with the mean-reward value of the corresponding node f(xht,it). This prevents from directly using the Azuma inequality and extra care is needed to derive a bound. We have that\nR\u0302En = n\u2211\nt=1\n\u2206\u0302tIEt,n \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n\u2206\u0302tIEt,nI(ht,it)=(h,i)\n=\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n(f(xh,i)\u2212 rt)IEt,nI(ht,it)=(h,i) (1) \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n(f(xh,i)\u2212 rt)I\u2126th,i,nI(ht,it)=(h,i)\n(2) =\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) Th,i(t\u0304h,i)(f(xh,i)\u2212 \u00b5\u0302h,i(t\u0304h,i))I\u2126t\u0304h,i\n(3) \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) cTh,i(t\u0304h,i)\n\u221a log(2/\u03b4\u0303(t\u0304h,i))\nTh,i(t\u0304h,i) \u2264\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) c\n\u221a Th,i(t\u0304h,i) log(2/\u03b4\u0303(t\u0304h,i))\n\u2264 c H\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (a)\n+c\nH(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (b)\n,\n(31)\nwhere (1) follows from the definition of Et,n = \u22c2n\ns=t\u2126s, thus if Et,n holds at time t then \u2126s also holds at s = t\u0304h,i \u2265 t. Step (2) follows from the definition of \u00b5\u0302h,i: First we notice that for the node (hn, in) we have that Thn,in(n)\u00b5\u0302hn,in(n) = \u2211n t=1 rtI(ht,it)=(hn,in) since we update the statistics at the end. for every other node we have that the last selection time t\u0304h,i and the end of last episode coincides together . Now since we update the statistics of the selected node at the end of every episode, thus, we have that Th,i(t\u0304h,i)\u00b5\u0302h,i(t\u0304h,i) = \u2211n t=1 rtI(ht,it)=(h,i) also for (h, i) 6= (hn, in). Step (3) follows from the definition of \u2126s. The resulting bound matches the one in Eq. 20 up to constants and it can be bound similarly.\nR\u0302En \u2264 2\u03bd1 [ Cc2\u03bd\u2212d2 \u03c1 d log(2/\u03b4\u0303(n))\n\u03bd21(1\u2212 \u03c1) \u03c1\u2212H(d+1) + \u03c1Hn\n] .\nStep 2: Preliminary bound on the regret of selected nodes. The second step follows exactly the same steps as in the proof of Thm. 1 with the only difference that here we use the high-probability event Et,n. As a result the following inequalities hold for the node (ht, it) selected at time t and its parent (h p t , i p t )\n\u2206ht,it \u2264 3c \u221a log(2/\u03b4\u0303(t))\nTht,it(t) .\n\u2206hpt ,i p t \u2264 3\u03bd1\u03c1ht\u22121.\n(32)\nStep 3: Bound on the cumulative regret. Unlike in the proof of Thm. 1, the total regret R\u0303En should be analyzed with extra care since here we do not update the selected arm as well as the statistics Th,i(t) and \u00b5\u0302h,i(t) for the the entire length of episode, whereas in Thm. 1 we update at every step. Thus the development of R\u0303En slightly differs from Eq. 20. Let 1 \u2264 H \u2264 H(n) a constant to be chosen later, then we have\nR\u0303En (1) =\nn\u2211\nt=1\n\u2206ht,itIEt,n = H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nn\u2211\nt=1\n\u2206h,iI(ht,it)=(h,i)IEt,n = H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nKh,i(n)\u2211\nk=1\nth,i(k)+vh,i(k)\u2211\nt=th,i(k)\n\u2206h,iIEt,n\n(2) \u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nKh,i(n)\u2211\nk=1\nth,i(k)+vh,i(k)\u2211\nt=th,i(k)\n 3c \u221a log(2/\u03b4\u0303(t))\nTh,i(t)\n  (3)= H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\nKh,i(n)\u2211\nk=1\nvh,i(k)\n 3c \u221a log(2/\u03b4\u0303(th,i(k)))\nTh,i(th,i(k))\n \n\u2264 H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) 3c\n\u221a log(2/\u03b4\u0303(t\u0304h,i)) Kh,i(n)\u2211\nk=1\nvh,i(k)\u221a Th,i(th,i(k))\n(4) \u2264 3( \u221a 2 + 1)c H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a log(2/\u03b4\u0303(t\u0304h,i))Th,i(th,i(Kh,i(n))) \u2264 3( \u221a 2 + 1)c H(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a log(2/\u03b4\u0303(t\u0304h,i))Th,i(n)\n= 3( \u221a 2 + 1)c H\u2211\nh=0\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (a)\n+3( \u221a 2 + 1)c H(n)\u2211\nh=H+1\n\u2211\ni\u2208Ih(n)\n\u221a Th,i(n) log(2/\u03b4\u0303(t\u0304h,i))\n\ufe38 \ufe37\ufe37 \ufe38 (b)\n,\n(33)\nwhere the first sequence of equalities in (1) simply follows from the definition of episodes. In (2) we bound the instantaneous regret by Eq. 32. Step (3) follows from the fact that when (h, i) is selected, its statistics, including Th,i, are not changed until the end of the episode. Step (4) is an immediate application of Lemma 19 in Jaksch et al. (2010).\nConstants apart the terms (a) and (b) coincides with the terms defined in Eq. 20 and similar bounds can be derived.\nPutting the bounds on R\u0302En and R\u0303 E n together leads to\nREn \u2264 2(3 \u221a 2 + 4)\u03bd1\n[ Cc2\u03bd\u2212d2 \u03c1 d log(2/\u03b4\u0303(n))\n\u03bd21(1\u2212 \u03c1) \u03c1\u2212H(d+1) + \u03c1Hn\n] .\nIt is not difficult to prove that for a suitable choice H , we obtain the final bound of O(log(n)1/(d+2)n(d+1)/(d+2)) on Rn. This combined with the result of Lem. 8 and a union bound on all n \u2208 {1, 2, 3, . . . } proves the final result.\nB.3 Proof of Thm. 3\nTheorem 3 Let \u03b4 \u2208 (0, 1), \u03b4\u0303(n) = 9 \u221a \u03c1/(4\u03bd1)\u03b4/n, and c = 3(3\u0393+1) \u221a\n1/(1 \u2212 \u03c1). We assume that Assumptions 1\u20135 hold and that rewards are generated according to the general model defined in Section 2. Then if \u03b4 = 1/n the space complexity of HCT-\u0393 is\nE(Nn) = O(log(n)2/(d+2)nd/(d+2)).\nProof. We assume that the space requirement for each node (i.e., storing variables such as \u00b5\u0302h,i, Th.i) is a unit. Let Bt denote the event corresponding to the branching/expansion of the node (ht, it) selected at time t, then the space\ncomplexity is Nn = \u2211n t=1 IBt . Similar to the regret analysis, we decompose Nn depending on events Et,n, that is\nNn = n\u2211\nt=1\nIBtIEt,n + n\u2211\nt=1\nIBtIEct,n = N E n +N E c n . (34)\nSince we are targeting the expected space complexity, we take the expectation of the previous expression and the second term can be easily bounded as\nE [ N Ecn ] = n\u2211\nt=1\nIBtP[Ect,n] \u2264 n\u2211\nt=1\nP[Ect ] \u2264 n\u2211\nt=1\n\u03b4\n6t6 \u2264 C, (35)\nwhere the last inequality follows from Lemma 8 and C is a constant independent from n. We now focus on the first term N En . We first rewrite it as the total number of nodes |Tn| generated by HCT over n steps. For any depth H > 0 we have\nN En = H(n)\u2211\nh=0\n|Ih(n)| = 1 + H\u2211\nh=1\n|Ih(n)|+ H(n)\u2211\nh=H+1 |Ih(n)| \u2264 1 +H|IH(n)|\ufe38 \ufe37\ufe37 \ufe38 (c) +\nH(n)\u2211\nh=H+1\n|Ih(n)|\n\ufe38 \ufe37\ufe37 \ufe38 (d)\n. (36)\nA bound on term (d) can be recovered through the following sequence of inequalities\nn =\nH(n)\u2211\nh=0\n\u2211\ni\u2208Ih(n) Th,i(n) \u2265\nH(n)\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nTh,i(n) (1) \u2265 H(n)\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\n\u03c4h,i(th,i)\n(2) \u2265 H(n)\u2211\nh=0\n\u2211\ni\u2208I+ h (n)\nc2 \u03bd21 \u03c1\u22122h (3) \u2265 1 \u03bd21\nH(n)\u22121\u2211\nh=H\n|I+h (n)|\u03c1\u22122h = 1 \u03bd21 \u03c1\u22122H\nH(n)\u22121\u2211\nh=H\n|I+h (n)|\u03c12(H\u2212h)\n\u2265 1 \u03bd21\n\u03c1\u22122H H(n)\u22121\u2211\nh=H\n|I+h (n)| (4) \u2265 1 2\u03bd21\n\u03c1\u22122H H(n)\u2211\nh=H+1\n|Ih(n)|,\n(37)\nwhere (1) follows from the fact that nodes in I+h (n) have been expanded at time th,i when their number of pulls Th,i(th,i) \u2264 Th,i(n) exceeded the threshold \u03c4h,i(th,i). Step (2) follows from Eq. 8, while (3) from the definition of c > 1. Finally, step (4) follows from the fact that the number of nodes at depth h cannot be larger than twice the parent nodes at depth h\u2212 1. By inverting the previous inequality, we obtain\n(d) \u2264 2\u03bd21n\u03c12H .\nOn other hand, in order to bound (c), we need to use the same the high-probability events Et,n and similar passages as in Eq. 22, which leads to |Ih(n)| \u2264 2|I+h\u22121(n)| \u2264 2C(\u03bd2\u03c1(h\u22121))\u2212d. Plugging these results back in Eq. 36 leads to\nN En \u2264 1 + 2HC(\u03bd2\u03c1(H\u22121))\u2212d + 2\u03bd21n\u03c12H ,\nwith high probability. Together with N Ecn we obtain\nE [ Nn ] \u2264 1 + 2HC(\u03bd2\u03c1(H\u22121))\u2212d + 2\u03bd21n\u03c12H + C \u2264 1 + 2Hmax(n)C(\u03bd2\u03c1(H\u22121))\u2212d + 2\u03bd21n\u03c12H + C,\nwhere Hmax(n) is the upper bound on the depth of the tree in Lemma 1. Optimizing H in the remaining terms leads to the statement."}], "references": [{"title": "Online learning in markov decision processes with adversarially chosen transition probability distributions", "author": ["Abbasi", "Yasin", "Bartlett", "Peter", "Kanade", "Varun", "Seldin", "Yevgeny", "Szepesvari", "Csaba"], "venue": "K.Q. (eds.), Advances in Neural Information Processing Systems", "citeRegEx": "Abbasi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Abbasi et al\\.", "year": 2013}, {"title": "Improved rates for the stochastic continuum-armed bandit problem", "author": ["Auer", "Peter", "Ortner", "Ronald", "Szepesv\u00e1ri", "Csaba"], "venue": "In COLT, pp", "citeRegEx": "Auer et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Auer et al\\.", "year": 2007}, {"title": "Regret bounds for reinforcement learning with policy advice", "author": ["Azar", "Mohammad Gheshlaghi", "Lazaric", "Alessandro", "Brunskill", "Emma"], "venue": "In ECML/PKDD,", "citeRegEx": "Azar et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Azar et al\\.", "year": 2013}, {"title": "Reinforcement learning in pomdp\u2019s via direct gradient ascent", "author": ["Baxter", "Jonathan", "Bartlett", "Peter L"], "venue": "In ICML, pp", "citeRegEx": "Baxter et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Baxter et al\\.", "year": 2000}, {"title": "Lipschitz bandits without the lipschitz constant", "author": ["Bubeck", "S\u00e9bastien", "Stoltz", "Gilles", "Yu", "Jia Yuan"], "venue": "In ALT,", "citeRegEx": "Bubeck et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bubeck et al\\.", "year": 2011}, {"title": "Adaptive-tree bandits", "author": ["Bull", "Adam"], "venue": "arXiv preprint arXiv:1302.2489,", "citeRegEx": "Bull and Adam.,? \\Q2013\\E", "shortCiteRegEx": "Bull and Adam.", "year": 2013}, {"title": "Regret and convergence bounds for immediate-reward reinforcement learning with continuous action spaces", "author": ["Cope", "Eric"], "venue": "IEEE Transactions on Automatic Control,", "citeRegEx": "Cope and Eric.,? \\Q2009\\E", "shortCiteRegEx": "Cope and Eric.", "year": 2009}, {"title": "High dimensional gaussian process bandits", "author": ["Djolonga", "Josip", "Krause", "Andreas", "Cevher", "Volkan"], "venue": "In Neural Information Processing Systems (NIPS),", "citeRegEx": "Djolonga et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Djolonga et al\\.", "year": 2013}, {"title": "Near-optimal regret bounds for reinforcement learning", "author": ["Jaksch", "Thomas", "Ortner", "Ronald", "Auer", "Peter"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Jaksch et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jaksch et al\\.", "year": 2010}, {"title": "Multi-armed bandits in metric spaces", "author": ["Kleinberg", "Robert", "Slivkins", "Aleksandrs", "Upfal", "Eli"], "venue": "In STOC,", "citeRegEx": "Kleinberg et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kleinberg et al\\.", "year": 2008}, {"title": "Policy search for motor primitives in robotics", "author": ["Kober", "Jens", "Peters", "Jan"], "venue": "Machine Learning,", "citeRegEx": "Kober et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kober et al\\.", "year": 2011}, {"title": "The sample-complexity of general reinforcement learning", "author": ["Lattimore", "Tor", "Hutter", "Marcus", "Sunehag", "Peter"], "venue": "In Proceedings of Thirtieth International Conference on Machine Learning (ICML),", "citeRegEx": "Lattimore et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Lattimore et al\\.", "year": 2013}, {"title": "Empirical bernstein bounds and sample variance penalization", "author": ["Maurer", "Andreas", "Pontil", "Massimiliano"], "venue": "arXiv preprint arXiv:0907.3740,", "citeRegEx": "Maurer et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Maurer et al\\.", "year": 2009}, {"title": "Optimistic optimization of a deterministic function without the knowledge of its smoothness", "author": ["Munos", "R\u00e9mi"], "venue": "In NIPS, pp", "citeRegEx": "Munos and R\u00e9mi.,? \\Q2011\\E", "shortCiteRegEx": "Munos and R\u00e9mi.", "year": 2011}, {"title": "From bandits to monte-carlo tree search: The optimistic principle applied to optimization and planning", "author": ["Munos", "R\u00e9mi"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "Munos and R\u00e9mi.,? \\Q2013\\E", "shortCiteRegEx": "Munos and R\u00e9mi.", "year": 2013}, {"title": "Online regret bounds for undiscounted continuous reinforcement learning", "author": ["Ortner", "Ronald", "Ryabko", "Daniil"], "venue": "K.q. (eds.), Advances in Neural Information Processing Systems", "citeRegEx": "Ortner et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Ortner et al\\.", "year": 2012}, {"title": "Policy search: Any local optimum enjoys a global performance guarantee", "author": ["Scherrer", "Bruno", "Geist", "Matthieu"], "venue": "arXiv preprint arXiv:1306.1520,", "citeRegEx": "Scherrer et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Scherrer et al\\.", "year": 2013}, {"title": "Contextual bandits with similarity information", "author": ["Slivkins", "Aleksandrs"], "venue": "CoRR, abs/0907.3986,", "citeRegEx": "Slivkins and Aleksandrs.,? \\Q2009\\E", "shortCiteRegEx": "Slivkins and Aleksandrs.", "year": 2009}, {"title": "Multi-armed bandits on implicit metric spaces", "author": ["Slivkins", "Aleksandrs"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Slivkins and Aleksandrs.,? \\Q2011\\E", "shortCiteRegEx": "Slivkins and Aleksandrs.", "year": 2011}, {"title": "Gaussian process bandits without regret: An experimental design approach", "author": ["Srinivas", "Niranjan", "Krause", "Andreas", "Kakade", "Sham M", "Seeger", "Matthias"], "venue": "CoRR, abs/0912.3995,", "citeRegEx": "Srinivas et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Srinivas et al\\.", "year": 2009}, {"title": "PAC-bayes-empirical-bernstein inequality", "author": ["Tolstikhin", "Ilya O", "Seldin", "Yevgeny"], "venue": "In Advances in Neural Information Processing Systems, pp", "citeRegEx": "Tolstikhin et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Tolstikhin et al\\.", "year": 2013}, {"title": "Stochastic simultaneous optimistic optimization", "author": ["Valko", "Michal", "Carpentier", "Alexandra", "Munos", "R\u00e9mi"], "venue": "In Proceedings of the 30th International Conference on Machine Learning", "citeRegEx": "Valko et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Valko et al\\.", "year": 2013}, {"title": "Model-free reinforcement learning as mixture learning", "author": ["Vlassis", "Nikos", "Toussaint", "Marc"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "Vlassis et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Vlassis et al\\.", "year": 2009}], "referenceMentions": [{"referenceID": 7, "context": "This immediately implies that the reward, conditioned on its corresponding arm pull, is not an independent and identically distributed (iid) random variable, in contrast to the prior work on X -armed bandits (Bull, 2013; Djolonga et al., 2013; Bubeck et al., 2011a; Srinivas et al., 2009; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 208, "endOffset": 343}, {"referenceID": 19, "context": "This immediately implies that the reward, conditioned on its corresponding arm pull, is not an independent and identically distributed (iid) random variable, in contrast to the prior work on X -armed bandits (Bull, 2013; Djolonga et al., 2013; Bubeck et al., 2011a; Srinivas et al., 2009; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 208, "endOffset": 343}, {"referenceID": 9, "context": "This immediately implies that the reward, conditioned on its corresponding arm pull, is not an independent and identically distributed (iid) random variable, in contrast to the prior work on X -armed bandits (Bull, 2013; Djolonga et al., 2013; Bubeck et al., 2011a; Srinivas et al., 2009; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 208, "endOffset": 343}, {"referenceID": 1, "context": "This immediately implies that the reward, conditioned on its corresponding arm pull, is not an independent and identically distributed (iid) random variable, in contrast to the prior work on X -armed bandits (Bull, 2013; Djolonga et al., 2013; Bubeck et al., 2011a; Srinivas et al., 2009; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 208, "endOffset": 343}, {"referenceID": 9, "context": "Our approach builds on recent advances in X -armed bandits for iid settings (Bubeck et al., 2011a; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 76, "endOffset": 153}, {"referenceID": 1, "context": "Our approach builds on recent advances in X -armed bandits for iid settings (Bubeck et al., 2011a; Cope, 2009; Kleinberg et al., 2008; Auer et al., 2007).", "startOffset": 76, "endOffset": 153}, {"referenceID": 9, "context": ", 2011a) and zooming algorithm (Kleinberg et al., 2008), both of which only apply to iid setting, in terms of dependency on the number of steps n and the near-optimality dimension d (to be defined later).", "startOffset": 31, "endOffset": 55}, {"referenceID": 4, "context": "Similar to the HOO algorithm of Bubeck et al. (2011a), HCT makes use of a covering binary tree for exploring the arm space.", "startOffset": 32, "endOffset": 54}, {"referenceID": 10, "context": "Among prior work in RL our setting is most similar to the general reinforcement learning model of Lattimore et al. (2013) which also considers an arbitrary temporal dependence between the rewards and observations.", "startOffset": 98, "endOffset": 122}, {"referenceID": 10, "context": "Among prior work in RL our setting is most similar to the general reinforcement learning model of Lattimore et al. (2013) which also considers an arbitrary temporal dependence between the rewards and observations. Our setting differs from that of Lattimore et al. (2013), since we consider the regret in undiscounted reward scenario, whereas Lattimore et al.", "startOffset": 98, "endOffset": 271}, {"referenceID": 10, "context": "Among prior work in RL our setting is most similar to the general reinforcement learning model of Lattimore et al. (2013) which also considers an arbitrary temporal dependence between the rewards and observations. Our setting differs from that of Lattimore et al. (2013), since we consider the regret in undiscounted reward scenario, whereas Lattimore et al. (2013) focus on proving PAC-bounds in discounted reward case.", "startOffset": 98, "endOffset": 366}, {"referenceID": 4, "context": ", Bubeck et al., 2011a), our approach seeks to minimize regret by smartly building an estimate of f using an infinite binary covering tree T , in which each node covers a subset of X .1 We denote by (h, i) the node at depth h and index i among the nodes at the same depth (e.g., the root node which covers X is indexed by (0, 1)). By convention (h + 1, 2i \u2212 1) and (h + 1, 2i) refer to the two children of the node (h, i). The area corresponding to each node (h, i) is denoted by Ph,i \u2282 X . These regions must be measurable and, at each depth, they partition X with no overlap: The reader is referred to Bubeck et al. (2011a) for a more detailed description of the covering tree.", "startOffset": 2, "endOffset": 626}, {"referenceID": 4, "context": "These assumptions coincide with those in (Bubeck et al., 2011a), except for the local smoothness (Assumption 4.d), which is weaker than that of Bubeck et al. (2011a), where the function is assumed to be Lipschitz between any two arms x, x\u2032 close to the maximum x\u2217 (i.", "startOffset": 42, "endOffset": 166}, {"referenceID": 4, "context": "These assumptions coincide with those in (Bubeck et al., 2011a), except for the local smoothness (Assumption 4.d), which is weaker than that of Bubeck et al. (2011a), where the function is assumed to be Lipschitz between any two arms x, x\u2032 close to the maximum x\u2217 (i.e., |f(x) \u2212 f(x\u2032)| \u2264 l(x, x\u2032)), while here we only require the function to be Lipschitz w.r.t. the maximum. Finally, we characterize the complexity of the problem using the near-optimality dimension, which defines how large is the set of \u01eb-optimal arms in X . For the sake of clarity, we consider a slightly simplified definition of near-optimality dimension w.r.t. Bubeck et al. (2011a). Assumption 5 (Near-optimality dimension).", "startOffset": 42, "endOffset": 655}, {"referenceID": 21, "context": "As it has been shown in (Valko et al., 2013) the case of d = 0 covers a rather large class of functions, since every function which satisfies some mild local smoothness assumption, around its", "startOffset": 24, "endOffset": 44}, {"referenceID": 2, "context": "Policy search algorithms (Scherrer & Geist, 2013; Azar et al., 2013; Kober & Peters, 2011) aim at finding the policy in a given policy set which maximizes the long-term performance.", "startOffset": 25, "endOffset": 90}, {"referenceID": 8, "context": "A related work to HCT-\u0393 is the UCCRL algorithm by Ortner & Ryabko (2012), which extends the original UCRL algorithm (Jaksch et al., 2010) to continuous state spaces.", "startOffset": 116, "endOffset": 137}, {"referenceID": 0, "context": "Another relevant work is the OMDP algorithm of Abbasi et al. (2013) which deals with the problem of RL in continuous state-action MDPs with adversarial rewards.", "startOffset": 47, "endOffset": 68}, {"referenceID": 4, "context": "For our first experiment we compare HCT-iid to the truncated hierarchical optimistic optimization (T-HOO) algorithm Bubeck et al. (2011a). T-HOO is a state-of-the-art X -armed bandit algorithm, developed as a computationally-efficient alternative of HOO.", "startOffset": 116, "endOffset": 138}, {"referenceID": 4, "context": "For our first experiment we compare HCT-iid to the truncated hierarchical optimistic optimization (T-HOO) algorithm Bubeck et al. (2011a). T-HOO is a state-of-the-art X -armed bandit algorithm, developed as a computationally-efficient alternative of HOO. In Fig. 1(a) we show the per-step regret, the runtime, and the space requirements of each approach. As predicted by the theoretical bounds, the per-step regret R\u0303n of both HCT-iid and truncated HOO decrease rapidly with number of steps. Though the big O theoretical bounds are identical for both approaches, empirically we observe in this Refer to Bubeck et al. (2011a); Munos (2013) for how to transform bounds on accumulated regret to simple regret bounds.", "startOffset": 116, "endOffset": 625}, {"referenceID": 4, "context": "For our first experiment we compare HCT-iid to the truncated hierarchical optimistic optimization (T-HOO) algorithm Bubeck et al. (2011a). T-HOO is a state-of-the-art X -armed bandit algorithm, developed as a computationally-efficient alternative of HOO. In Fig. 1(a) we show the per-step regret, the runtime, and the space requirements of each approach. As predicted by the theoretical bounds, the per-step regret R\u0303n of both HCT-iid and truncated HOO decrease rapidly with number of steps. Though the big O theoretical bounds are identical for both approaches, empirically we observe in this Refer to Bubeck et al. (2011a); Munos (2013) for how to transform bounds on accumulated regret to simple regret bounds.", "startOffset": 116, "endOffset": 639}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant.", "startOffset": 13, "endOffset": 35}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm.", "startOffset": 13, "endOffset": 201}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm.", "startOffset": 13, "endOffset": 218}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm. 4, and do not require knowledge of the dissimilarity measure l. On the other hand, Slivkins (2011) and Bull (2013) study the cumulative regret but consider a different definition of smoothness related to the zooming concept introduced by Kleinberg et al.", "startOffset": 13, "endOffset": 439}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm. 4, and do not require knowledge of the dissimilarity measure l. On the other hand, Slivkins (2011) and Bull (2013) study the cumulative regret but consider a different definition of smoothness related to the zooming concept introduced by Kleinberg et al.", "startOffset": 13, "endOffset": 455}, {"referenceID": 4, "context": "For example, Bubeck et al. (2011b) require a stronger global Lipschitz assumption and propose an algorithm to estimate the Lipschitz constant. Other work on the iid setting include Valko et al. (2013) and Munos (2011), which are limited to the simple regret scenario, but who only use the mild local smoothness assumption we define in Asm. 4, and do not require knowledge of the dissimilarity measure l. On the other hand, Slivkins (2011) and Bull (2013) study the cumulative regret but consider a different definition of smoothness related to the zooming concept introduced by Kleinberg et al. (2008). Finally, we notice that to deal with unknown mixing time, one may rely on data-dependent tail\u2019s inequalities, such as empirical Bernstein inequality (Tolstikhin & Seldin, 2013; Maurer & Pontil, 2009), replacing the mixing time with the empirical variance of the rewards.", "startOffset": 13, "endOffset": 602}, {"referenceID": 2, "context": "1 Concentration Inequality for non-iid Episodic Random Variables In this section we extend the result in (Azar et al., 2013) and we derive a concentration inequality for averages of non-iid random variables grouped in episodes.", "startOffset": 105, "endOffset": 124}, {"referenceID": 8, "context": "Step (4) is an immediate application of Lemma 19 in Jaksch et al. (2010). Constants apart the terms (a) and (b) coincides with the terms defined in Eq.", "startOffset": 52, "endOffset": 73}], "year": 2014, "abstractText": "In this paper we consider the problem of online stochastic optimization of a locally smooth function under bandit feedback. We introduce the high-confidence tree (HCT) algorithm, a novel any-time X -armed bandit algorithm, and derive regret bounds matching the performance of existing state-of-the-art in terms of dependency on number of steps and smoothness factor. The main advantage of HCT is that it handles the challenging case of correlated rewards, whereas existing methods require that the reward-generating process of each arm is an identically and independent distributed (iid) random process. HCT also improves on the state-of-the-art in terms of its memory requirement as well as requiring a weaker smoothness assumption on the mean-reward function in compare to the previous anytime algorithms. Finally, we discuss how HCT can be applied to the problem of policy search in reinforcement learning and we report preliminary empirical results.", "creator": "LaTeX with hyperref package"}}}