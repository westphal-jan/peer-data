{"id": "1402.0570", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "A Feature Subset Selection Algorithm Automatic Recommendation Method", "abstract": "many feature subset selection ( fss ) algorithms have been proposed, but not all of them are appropriate whenever a given feature selection problem. at the critical time, so far there is rarely a good way to choose appropriate fss algorithms over the problem at hand. thus, fss algorithm automatic recommendation became very important and practically useful. in this paper, a meta learning based software algorithm automatic recommendation method is presented. the proposed method first identifies the data sets that are most similar to the one at maturity by the k - unit neighbor classification database, and the distances among competing data sets are calculated based on seven properly - used data set characteristics. then, it ranks all the candidate fss selections according to their performance on these similar garbage sets, and chooses the algorithms with best ranks as the appropriate size. the performance along the candidate fss algorithms is evaluated by a multi - criteria metric that takes into account not only superior classification accuracy over the selected features, but indirectly the runtime cumulative feature lengths and the number of selected features. the official recommendation method is extensively tested on 115 real world multimedia packages. 22 well - known and frequently - used different fss algorithms for five representative classifiers. the results show the effectiveness of our proposed fss algorithm recommendation method.", "histories": [["v1", "Tue, 4 Feb 2014 01:37:24 GMT  (855kb)", "http://arxiv.org/abs/1402.0570v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["guangtao wang", "qinbao song", "heli sun", "xueying zhang", "baowen xu", "yuming zhou"], "accepted": false, "id": "1402.0570"}, "pdf": {"name": "1402.0570.pdf", "metadata": {"source": "CRF", "title": "A Feature Subset Selection Algorithm Automatic Recommendation Method", "authors": ["Guangtao Wang", "Qinbao Song", "Heli Sun", "Xueying Zhang", "Baowen Xu", "Yuming Zhou"], "emails": ["gt.wang@stu.xjtu.edu.cn", "qbsong@mail.xjtu.edu.cn", "hlsun@mail.xjtu.edu.cn", "zhangxueying.725@stu.xjtu.edu.cn", "bwxu@nju.edu.cn", "zhouyuming@nju.edu.cn"], "sections": [{"heading": "1. Introduction", "text": "Feature subset selection (FSS) plays an important role in the fields of data mining and machine learning. A good FSS algorithm can effectively remove irrelevant and redundant features and take into account feature interaction. This not only leads up to an insight understanding of the data, but also improves the performance of a learner by enhancing the generalization capacity and the interpretability of the learning model (Pudil, Novovic\u030cova\u0301, Somol, & Vrn\u030cata, 1998a; Pudil, Novovic\u030cova\u0300, Somol, & Vrn\u030cata, 1998b; Molina, Belanche, & Nebot, 2002; Guyon & Elisseeff, 2003; Saeys, Inza, & Larran\u0303aga, 2007; Liu & Yu, 2005; Liu, Motoda, Setiono, & Zhao, 2010).\nc\u00a92013 AI Access Foundation. All rights reserved.\nAlthough a large number of FSS algorithms have been proposed, there is no single algorithm which performs uniformly well on all feature selection problems. Experiments (Hall, 1999; Zhao & Liu, 2007) have confirmed that there could exist significant differences of performance (e.g., classification accuracy) among different FSS algorithms over a given data set. That means for a given data set, some FSS algorithms outperform others.\nThis raises a practical and very important question: which FSS algorithms should be picked up for a given data set? The common solution is to apply all candidate FSS algorithms to the given data set, and choose one with the best performance by the crossvalidation strategy. However, this solution is quite time-consuming especially for highdimensional data (Brodley, 1993).\nFor the purpose of addressing this problem in a more efficient way, in this paper, an FSS algorithm automatic recommendation method is proposed. The assumption underlying our proposed method is that the performance of an FSS algorithm on a data set is related to the characteristics of the data set. The rationality of this assumption can be demonstrated as follows:\n1) Generally, when a new FSS algorithm is proposed, its performance needs to be extensively evaluated at least on real world data sets. However, the published FSS algorithms are rarely tested on the identical group of data sets (Hall, 1999; Zhao & Liu, 2007; Yu & Liu, 2003; Dash & Liu, 2003; Kononenko, 1994). That is, for any two algorithms, they are usually tested on the different data. This implies that the performance of an FSS algorithm biases to some data sets.\n2) At the same time, the famous NFL (No Free Lunch) (Wolpert, 2001) theory tells us that, for a particular data set, different algorithms have different data-conditioned performance, and the performance differences vary with data sets.\nThe above evidences imply that there is a relationship between the performance of an FSS algorithm and the characteristics of data sets. In this paper, we intend to explore this relationship and utilize it to automatically recommend appropriate FSS algorithm(s) for a given data set. The recommendation process can be viewed as a specific application of meta-learning (Vilalta & Drissi, 2002; Brazdil, Carrier, Soares, & Vilalta, 2008) that has been used to recommend algorithms for classification problems (Ali & Smith, 2006; King, Feng, & Sutherland, 1995; Brazdil, Soares, & Da Costa, 2003; Kalousis, Gama, & Hilario, 2004; Smith-Miles, 2008; Song, Wang, & Wang, 2012).\nTo model this relationship, there are three fundamental issues to be considered: i) which features (often are referred to as meta-features) are used to characterize a data set; ii) how to evaluate the performance of an FSS algorithm and identify the applicable one(s) for a given data set; iii) how to recommend FSS algorithm(s) for a new data set.\nIn this paper, the meta-features, which are frequently used in meta-learning (Vilalta & Drissi, 2002; Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Castiello, Castellano, & Fanelli, 2005), are employed to characterize data sets. At the same time, a multi-criteria metric, which takes into account not only the classification accuracy of a classifier with an FSS algorithm but also the runtime of feature selection and the number of selected features, is used to evaluate the performance of the FSS algorithm. Meanwhile, a k -NN (k -Nearest Neighbor) based method is proposed to recommend FSS algorithm(s) for a new data set.\nOur proposed FSS algorithm recommendation method has been extensively tested on 115 real world data sets with 22 well-known and frequently-used different FSS algorithms for five representative classifiers. The results show the effectiveness of our proposed recommendation method.\nThe rest of this paper is organized as follows. Section 2 introduces the preliminaries. Section 3 describes our proposed FSS algorithm recommendation method. Section 4 provides the experimental results. Section 5 conducts the sensitivity analysis of the number of the nearest data sets on the recommendation results. Finally, section 6 summarizes the work and draws some conclusions."}, {"heading": "2. Preliminaries", "text": "In this section, we first describe the meta-features used to characterize data sets. Then, we introduce the multi-criteria evaluation metric used to measure the performance of FSS algorithms."}, {"heading": "2.1 Meta-features of Data Sets", "text": "Our proposed FSS algorithm recommendation method is based on the relationship between the performance of FSS algorithms and the meta-features of data sets.\nThe recommendation can be viewed as a data mining problem, where the performance of FSS algorithms and the meta-features are the target function and the input variables, respectively. Due to the ubiquity of \u201cGarbage In, Garbage Out\u201d (Lee, Lu, Ling, & Ko, 1999) in the field of data mining, the selection of the meta-features is crucial for our proposed FSS recommendation method.\nThe meta-features are measures that are extracted from data sets and can be used to uniformly characterize different data sets, where the underlying properties are reflected. The meta-features should be not only conveniently and efficiently calculated, but also related to the performance of machine learning algorithms (Castiello et al., 2005).\nThere has been 15 years of research to study and improve on the meta-features proposed in the StatLog project (Michie, Spiegelhalter, & Taylor, 1994). A number of meta-features have been employed to characterize data sets (Brazdil et al., 2003; Castiello et al., 2005; Michie et al., 1994; Engels & Theusinger, 1998; Gama & Brazdil, 1995; Lindner & Studer, 1999; Sohn, 1999), and have been demonstrated working well in modeling the relationship between the characteristics of data sets and the performance (e.g., classification accuracy) of learning algorithms (Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Kalousis et al., 2004; Smith-Miles, 2008). As these meta-features do characterize data sets themselves, and have no connection with learning algorithms and their types, so we use them to model the relationship between data sets and FSS algorithms.\nThe most commonly used meta-features are established focusing on the following three aspects of a data set: i) general properties, ii) statistic-based properties, and iii) informationtheoretic based properties (Castiello et al., 2005). Table 11 shows the details.\n1. In order to compute the information-theoretic features, for data sets with continuous-valued features, if needed, the well-known MDL (Minimum Description Length) method with Fayyad & Irani criterion was used to discretize the continuous values."}, {"heading": "2.2 Multi-criteria Metric for FSS Algorithm Evaluation", "text": "In this section, first, the classical metrics evaluating the performance of FSS algorithm are introduced. Then, by analyzing the user requirements in practice application, based on these metrics, a new and user-oriented multi-criteria metric is proposed for FSS algorithm evaluation by combining these metrics together."}, {"heading": "2.2.1 Classical Performance Metrics", "text": "When evaluating the performance of an FSS algorithm, the following three metrics are extensively used in feature selection literature: i) classification accuracy , ii) runtime of feature selection, and iii) number of selected features.\n1) The classification accuracy (acc) of a classifier with the selected features can be used to measure how well the selected features describe a classification problem. This is because for a given data set, different feature subsets generally result in different classification accuracies. Thus, it is reasonable that the feature subset with higher classification accuracy has stronger capability of depicting the classification problem. The classification accuracy also reflects the ability of an FSS algorithm in identifying the salient features for learning.\n2) The runtime (t) of feature selection measures the efficiency of an FSS algorithm for picking up the useful features. It is also viewed as a metric to measure the cost of feature selection. The longer the runtime, the higher the expenditure of feature selection.\n3) The number of selected features (n) measures the simplicity of the feature selection results. If the classification accuracies with two FSS algorithms are similar, we usually favor the algorithm with fewer features.\nFeature subset selection aims to improve the performance of learning algorithms which usually is measured with classification accuracy. The FSS algorithms with higher classification accuracy are in favor. However, this does not mean that the runtime and the number of selected features could be ignored. This can be explained by the following two considerations:\n1) Suppose there are two different FSS algorithms Ai and Aj , and a given data set D. If the classification accuracy with Ai on D is slightly greater than that with Aj , but the\nruntime of Ai and the number of features selected by Ai are much greater than those of Aj , then Aj is often chosen.\n2) Usually, we do not prefer to use the algorithms with higher accuracy but longer runtime, so is those with lower accuracy but shorter runtime. Therefore, we need a tradeoff between classification accuracy and the runtime of feature selection/the number of selected features. For example, in real-time systems, it is impossible to choose the algorithm with high time-consumption even if its classification accuracy is high.\nTherefore, it is necessary to allow users making a user-oriented performance evaluation for different FSS algorithms. For this purpose, it is needed to address the problem of how to integrate classification accuracy with the runtime of feature selection and the number of selected features to obtain a unified metric. In this paper, we resort to the multi-criteria metric to explore this problem. The underlying reason lies that the multi-criteria metric has been successfully used to evaluate data mining algorithms by considering the positive properties (e.g. classification accuracy) and the negative ones (e.g. runtime and number of selected features) simultaneously (Nakhaeizadeh & Schnabl, 1997, 1998).\nWhen comparing two algorithms, besides the metrics used to evaluate their performance, the ratio of the metric values can also be used. For example, suppose A1 and A2 are two different FSS algorithms, if A1 is better than A2 in terms of classification accuracy, i.e., acc1 > acc2\n2, then ratio acc1/acc2 > 1 can be used to show A1 is better than A2 as well. On the contrary, for the negative metrics runtime of feature selection and number of of the selected features, the corresponding ratio < 1 means a better algorithm.\nActually, a multi-criteria metric adjusted ratio of ratios (ARR) (Brazdil et al., 2003), which combines classification accuracy and runtime together as a unified metric, has been proposed to evaluate the performance of a learning algorithm. We extend ARR by integrating it with the runtime of feature selection and the number of selected features, so a new multi-criteria metric EARR (extened ARR) is proposed. In the following discussion, we will show that the new metric EARR is more inclusive, very flexible, and easy to understand."}, {"heading": "2.2.2 Multi-Criteria Metric EARR", "text": "Let DSet = {D1, D2, \u00b7 \u00b7 \u00b7 , DN} be a set of N data sets, and ASet = {A1, A2, \u00b7 \u00b7 \u00b7 , AM} be a set of M FSS algorithms. Suppose accji is the classification accuracy of a classifier with FSS algorithm Ai on data set Dj (1 \u2264 i \u2264 M , 1 \u2264 j \u2264 N), and tji and nji denote the runtime and the number of selected features of FSS algorithm Ai on data set Dj , respectively. Then the EARR of Ai to Aj over Dk is defined as\nEARRDkAi,Aj = accki /acc k j\n1 + \u03b1 \u00b7 log (tki /tkj ) + \u03b2 \u00b7 log (nki /nkj ) (1 \u2264 i 6= j \u2264 M, 1 \u2264 k \u2264 N), (1)\nwhere \u03b1 and \u03b2 are the user-predefined parameters which denote the relative importance of the runtime of feature selection and the number of selected features, respectively.\nThe computation of the metric EARR is based on the ratios of the classical FSS algorithm performance metrics, the classification accuracy, the runtime of feature selection and\n2. Where acc1 and acc2 are the corresponding classification accuracies of algorithms A1 and A2, respectively.\nthe number of selected features. From the definition we can know that EARR evaluates an FSS algorithm by comparing it with another algorithm. This is reasonable since it is more objective to assert an algorithm is good or not by comparing it with another one instead of just focusing on its own performance. For example, suppose there is a classifier with 70% classification accuracy on a data set, we will get confused on whether the classifier is good or not. However, if we compare it with another classifier that can obtain 90% classification accuracy on the same data set, then we can definitely say that the first classifier is not good compared with the second one.\nNoted that, in practice, the runtime difference between two different FSS algorithms usually can be quite great. Meanwhile, for high-dimensional data sets, the difference of the number of selected features for two different FSS algorithms can be great as well. Thus, the ratio of runtime and the ratio of the number of selected features usually have much more wide ranges than that of the classification accuracy. If the simple ratio of runtime and the simple ratio of the number of selected features are employed, they would dominate the value of EARR, and the ratio of the classification accuracy will be drowned. In order to avoid this situation, the common logarithm (i.e., the logarithm with base 10) of the ratio of runtime and the common logarithm of the ratio of the number of selected features are employed.\nThe parameters \u03b1 and \u03b2 represent the amount of classification accuracy that a user is willing to trade for a 10 times speedup/reduction on the runtime of feature selection/the number of selected features, respectively. This allows users to choose the algorithms with shorter runtime and less features but acceptable accuracy. This can be illustrated by the following example. Suppose that accki = (1 + \u03b1 + \u03b2) \u00b7 acckj , the runtime of algorithm Ai on a given data set is 10 times of that of Aj (i.e., tki = 10 \u00b7 tkj ), and the number of selected features of algorithm Ai is 10 times of that of Aj (i.e., nki = 10 \u00b7 nkj ). Then, according to Eq. (1), EARRDkAi,Aj = 1, and EARR Dk Aj ,Ai = 1 1\u2212(\u03b1+\u03b2)2 > 1.\n3 In this case, Aj outperforms Ai. If a user prefers fast algorithms with less features, Aj will be his/her choice.\nThe value of EARR varies around 1. The value of EARRDkAi,Aj is greater than (or equal to, or smaller than) that of EARRDkAj ,Ai indicates that Ai is better than (or equal to, or worse than) Aj .\nEq. (1) can be directly used to evaluate the performance of two different FSS algorithms. When comparing multiple FSS algorithms, the performance of any algorithm Ai \u2208 ASet on a given data set D can be evaluated by the metric EARRDAi defined as follows:\nEARRDAi = 1 M \u2212 1 M\u2211\nj=1\u2227j 6=i EARRDAi,Aj . (2)\nThis equation shows that the EARR of an FSS algorithm Ai on D is the arithmetic mean of the EARRDAi,Aj of Ai to other algorithm Aj on D. That is, the performance of any FSS algorithm Ai \u2208 ASet is evaluated based on the comparisons with other algorithms in {ASet \u2212{Ai}}. The larger the value of EARR, the better the corresponding FSS algorithm on the given data set D.\n3. Since log (x/y) = \u2212 log (y/x) and (\u03b1 + \u03b2)2 > 0"}, {"heading": "3. FSS Algorithm Recommendation Method", "text": "In this section, we first give the framework of the FSS algorithm recommendation. Then, we introduce the nearest neighbor based recommendation method in detail."}, {"heading": "3.1 Framework", "text": "Based on the assumption that there is a relationship between the performance of an FSS algorithm on a given data set and the data set characteristics (aka meta-features), our proposed recommendation method firstly constructs a meta-knowledge database consisting of data set meta-features and FSS algorithm performance. After that, with the help of the meta-knowledge database, a k-NN based method is used to model this relationship and recommend appropriate FSS algorithms for a new data set.\nTherefore, our proposed recommendation method consists of two parts: Meta-knowledge Database Construction and FSS Algorithm Recommendation. Fig. 1 shows the details."}, {"heading": "1) Meta-Knowledge Database Construction", "text": "As mentioned previously, the meta-knowledge database consists of the meta-features of a set of historical data sets and the performance of a group of FSS algorithms on them. It is the foundation of our proposed recommendation method, and the effectiveness of the recommendations depends heavily on this database.\nThe meta-knowledge database is constructed by the following three steps. Firstly, the meta-features in Table 1 are extracted from each historical data set by the module \u201cMetafeatures extraction\u201d. Then, each candidate FSS algorithm is applied on each historical data set. The classification accuracy, the runtime of feature selection and the number of selected features are recorded, and the corresponding value of the performance metric EARR is calculated. This is accomplished by the module \u201cPerformance metric calculation\u201d. Finally, for each data set, a tuple, which is composed of the meta-features and the values of the performance metric EARR for all the candidate FSS algorithms, is obtained and added into the knowledge database. 2) FSS Algorithm Recommendation\nBased on the introduction of the first part \u201cMeta-knowledge Database Construction\u201d we presented above, the learning target of the meta-knowledge data is a set of EARR values instead of an appropriate FSS algorithm. In this case, it has been demonstrated that the researchers usually resort to the instance-based or k -NN (nearest neighbors) methods or their variations (Brazdil et al., 2003, 2008) for algorithm recommendation. Thus, a k -NN based FSS algorithm recommendation procedure is proposed.\nWhen recommending FSS algorithms for a new data set, firstly, the meta-features of this data set are extracted. Then, the distance between the new data set and each historical data set is calculated according to the meta-features. After that, its k nearest data sets are identified, and the EARR values of the candidate FSS algorithms on these k data sets are retrieved from the meta-knowledge database. Finally, all the candidate FSS algorithms are ranked according to these EARR values, where the algorithm with the highest EARR achieves the top rank, the one with the second highest EARR gets second rank, and so forth, and the top r algorithms are recommended."}, {"heading": "3.2 Recommendation Method", "text": "To recommend appropriate FSS algorithms for a new data set Dnew based on its k nearest data sets, there are two foundational issues to be solved: i) how to identify its k nearest data sets, and ii) how to recommend appropriate FSS algorithms based on these k data sets. 1) k nearest data sets identification\nThe k nearest data sets of Dnew are identified by calculating the distance between Dnew and each historical data set based on their meta-features. The smaller the distance, the more similar the corresponding data set to Dnew.\nIn order to effectively calculate the distance between two data sets, the L1 norm distance (Atkeson, Moore, & Schaal, 1997) is adopted since it is easy to understand and calculate, and its ability in measuring the similarity between two data sets has been demonstrated by Brazdil et al. (2003).\nLet Fi = <fi,1, fi,2, \u00b7 \u00b7 \u00b7 , fi,h> be the meta-features of data set Di, where fi,p is the value of pth feature of Fi and h is the length of the meta-features. The L1 norm distance between data sets Di and Dj can be formulated as\ndist(Di, Dj) = \u2016Fi \u2212 Fj\u20161 = h\u2211\np=1\n|fi,p \u2212 fj,p|. (3)\nIt is worth noting that the ranges of different meta-features are quite different. For example, of the meta-features introduced in Table 1, the value of normalized class entropy varies from 0 to 1, while the number of instances can be millions. Thus, if these meta-features with different ranges are directly used to calculate the distance between two data sets, the metafeatures with large range would dominate the distance, and the meta-features with small range will be ignored. In order to avoid this problem, the 0-1 standardized method (Eq. (4)) is employed to make all the meta-features have the same range [0, 1].\nfi,p \u2212min (f\u00b7,p) max (f\u00b7,p)\u2212min (f\u00b7,p) , (4)\nwhere fi,p (1 \u2264 p \u2264 h) is the value of the pth meta-feature of data set Di, min (f\u00b7,p) and max (f\u00b7,p) denote the minimum and maximum values of the pth meta-feature over historical data sets, respectively."}, {"heading": "2) FSS algorithm recommendation", "text": "Once getting the k nearest data sets of Dnew, the performance of the candidate FSS algorithms on Dnew is evaluated according to those on the k nearest data sets. Then, the algorithms with the best performance are recommended.\nLet Dknn = {D1, D2, \u00b7 \u00b7 \u00b7 , Dk} be the k nearest data sets of Dnew and EARRDjAi be the performance metric of the FSS algorithm Ai on data set Dj \u2208 Dknn (1 \u2264 j \u2264 k). Then the performance of Ai on the new data set Dnew can be evaluated by\nEARRDknnAi = k\u2211\nj=1\n\u03c9j \u00b7 EARRDjAi , where \u03c9j = dj\u22121/ k\u2211\nt=1\ndt \u22121, dj = dist(Dnew, Dj). (5)\nEq. (5) indicates that the performance of the FSS algorithm Ai on Dnew is evaluated by its performance on the Dknn of Dnew. For a data set Dj \u2208 Dknn, the smaller the distance dj between itself and Dnew, the more similar the two data sets. This means for two data sets Dp and Dq, if dp < dq then the data set Dp is more similar to Dnew, so the EARR of Ai on Dp is more important for evaluating the performance of Ai on Dnew. Thus, the weighted average, which takes into account the relative importance of each data set in Dknn rather than treating each data set equally, is employed. Moreover, in the domain of machine learning, the reciprocal of the distance usually is used to measure the similarity. So the \u03c9j = dj\u22121/ k\u2211\nt=1 dt \u22121 is used as the weight of the EARR of Ai on Dj \u2208 Dknn.\nAccording to the EARR of each candidate FSS algorithm in ASet on Dnew, a rank of these candidate FSS algorithms can be obtained. The greater the EARR, the higher the rank. Then, the top r (e.g., r = 3 in this paper) FSS algorithms are picked up as the appropriate ones for the new data set Dnew.\nProcedure FSSAlgorithmRecommendation shows the pseudo-code of the recommendation. Time complexity. The recommendation procedure consists of two parts. In the first part (lines 1-3), the k nearest data sets of the given new data set D are identified. Firstly, the meta-features F of D are extracted by function MetaFeatureExtraction(). Then, the k-nearest historical data sets are identified by function NeighborRecognition() based on the distance between F and the meta-features Fi of each historical data set Di. Suppose that P is the number of instances and Q is the number of features in the given data set D, the time complexity of function MetaFeatureExtraction() is O(P + Q). For function NeighborRecognition(), the time complexity is O(n) which depends on the number of the historical data sets n. Consequently, the time complexity of the first part is O(P +Q)+O(n).\nIn the second part (lines 4-8), the r FSS algorithms are recommended for the data set D. Since the weights and EARRs of the k nearest data sets can be obtained directly, the time complexity of these two steps is O(1). The time complexity for estimating and ranking the EARRs of the algorithms in ASet is O(k \u00b7m)+O(m \u00b7 log(m)), where k is the preassigned number of the nearest data sets and m is the number of the candidate FSS algorithms.\nProcedure FSSAlgorithmRecommendation\nInputs : D - a new given data set; DSet - {D1, D2, \u00b7 \u00b7 \u00b7 , Dn}, historical data sets; ASet - {A1, A2, \u00b7 \u00b7 \u00b7 , Am}, candidate FSS algorithms; MetaDataBase - {<Fi, EARRsi>|1 \u2264 i \u2264 n} where Fi and EARRsi are the meta-features and the EARRs of ASet on Di, respectively; k - the predefined number of the nearest neighbors; r - the number of recommended FSS algorithms. Output: RecAlgs - Recommended FSS algorithms for D\n//Part 1: Recognition of the k nearest data sets for D F = MetaFeatureExtraction (D);//Extract meta-features from D1 MetaFeatureSet = {F1, F2, \u00b7 \u00b7 \u00b7 , Fn};//Meta-feature of each data set in DSet2 Neighbors = NeighborRecognition (k, F, MetaFeatureSet);3\n//Part 2: Appropriate FSS algorithm recommendation\nWeightSet = calculate the weight for each data set in Neighbors //See Eq. (5)4 EARRSet = the corresponding EARRs for each data set in Neighbors from MetaDataBase;5 Estimate the EARR of each FSS algorithm \u2208 ASet on D according to WeightSet and EARRSet6 by Eq. (5) and rank the algorithms in ASet based on these EARRs; RecAlgs = top r FSS algorithms;7 return RecAlgs;8\nTo sum up, the time complexity of the recommendation procedure is O(P +Q)+O(n)+ O(k\u00b7m)+O(m\u00b7log(m)). In practice, for a data set D that needs to conduct feature selection, the number of the instances P and/or the number of the features Q in D are much greater than the number of the nearest data sets k and the number of the candidate FSS algorithms m, so the major time consumption of this recommendation procedure is determined by the first part."}, {"heading": "4. Experimental Results and Analysis", "text": "In this section, we experimentally evaluate the proposed feature subset selection (FSS) algorithm recommendation method by recommending algorithms over the benchmark data sets."}, {"heading": "4.1 Benchmark Data Sets", "text": "115 extensively-used real world data sets, which come from different areas such as Computer, Image, Life, Biology, Physical and Text 4, are employed in our experiment. The sizes of these data sets vary from 10 to 24863 instances, and the numbers of their features are between 5 and 27680.\nThe statistical summary of these data sets is shown in Table 2 in terms of the number of instances (denoted as I), the number of features (denoted as F) and the number of target concepts (denoted as T).\n4. These data sets are available from http://archive.ics.uci.edu/ml/datasets.html, http:// featureselection.asu.edu/datasets.php, http://sci2s.ugr.es/keel/datasets.php, http://www. upo.es/eps/bigs/datasets.html, and http://tunedit.org/repo/Data, respectively."}, {"heading": "4.2 Experimental Setup", "text": "In order to evaluate the performance of the proposed FSS algorithm recommendation method, further verify whether the proposed method is potentially useful in practice, and confirm the reproducibility of our experiments, we set the experimental study as follows."}, {"heading": "4.2.1 FSS Algorithms", "text": "FSS algorithms can be grouped into two broad categories: Wrapper and Filter (Molina et al., 2002; Kohavi & John, 1997). The Wrapper method uses the error rate of the classification algorithm as the evaluation function to measure a feature subset, while the evaluation function of the Filter method is independent of the classification algorithm. The accuracy of the Wrapper method is usually high; however, the generality of the result is limited, and the computational complexity is high. In comparison, Filter method is of generality, and the computational complexity is low. Due to the fact that the Wrapper method is computationally expensive (Dash & Liu, 1997), the Filter method is usually a good choice\nwhen the number of features is very large. Thus, we focus on the Filter method in our experiment.\nA number of Filter based FSS algorithms have been proposed to handle feature selection problems. These algorithms can be significantly distinguished by i) the search method used to generate the feature subset being evaluated, and ii) the evaluation measures used to assess the feature subset (Liu & Yu, 2005; de Souza, 2004; Dash & Liu, 1997; Pudil, Novovic\u030cova\u0301, & Kittler, 1994).\nIn order to guarantee the generality of our experimental results, twelve well-known or the latest search methods and four representative evaluation measures are employed. The brief introduction of these search methods and evaluation measures is as follows."}, {"heading": "1) Search methods", "text": "i) Sequential forward search (SFS): Starting from the empty set, sequentially add the feature which results in the highest value of objective function into the current feature subset.\nii) Sequential backward search (SBS): Starting from the full set, sequentially eliminate the feature which results in smallest or no decrease in the value of objective function from the current feature subset.\niii) Bi-direction search (BiS): A parallel implementation of SFS and SBS. It searches the feature subset space in two directions.\niv) Genetic search (GS): A randomized search method which performs using a simple genetic algorithm (Goldberg, 1989). The genetic algorithm finds the feature subset to maximize special output function using techniques inspired by natural evolution.\nv) Linear search (LS): An extension of BestFirst search (Gutlein, Frank, Hall, & Karwath, 2009) which searches the space of feature subsets by greedy hill-climbing augmented with a backtracking facility.\nvi) Rank search (RS) (Battiti, 1994): It uses a feature evaluator (such as gain ratio) to rank all the features. After a feature evaluator is specified, a forward selection search is used to generate a ranking list.\nvii) Scatter search (SS) (Garci\u2019a Lopez, Garci\u2019a Torres, Melian Batista, Moreno Perez, & Moreno-Vega, 2006): This method performs a scatter search through the feature subset space. It starts with a population of many significant and diverse feature subsets, and stops when the assessment criteria is higher than a given threshold or does not have improvement any longer.\nviii) Stepwise search (SWS) (Kohavi & John, 1997): A variation of the forward search. At each step in the search process, after a new feature is added, a test is performed to check if some features can be eliminated without significant reduction in the output function.\nix) Tabu search (TS) (Hedar, Wang, & Fukushima, 2008): It is proposed for combinatorial optimization problems. It is an adaptive memory and responsive exploration by combining a local search process with anti-cycling memory-based rules to avoid trapping in local optimal solutions.\nx) Interactive search (Zhao & Liu, 2007): It traverses the feature subset space for maximizing the target function while taking consideration the interaction among features.\nxi) FCBF search (Yu & Liu, 2003): It evaluates features via the relevance and redundancy analysis, and uses the analysis results as guideline to choose features.\nxii) Ranker (Kononenko, 1994; Kira & Rendell, 1992; Liu & Setiono, 1995): It evaluates each feature individually and ranks the features by the values of their evaluation metrics."}, {"heading": "2) Evaluation measures", "text": "i) Consistency (Liu & Setiono, 1996; Zhao & Liu, 2007): This kind of measure evaluates the worth of a feature subset by the level of consistency in the target concept when the instances are projected onto the feature subset. The consistency of any feature subset can never be lower than that of the full feature set.\nii) Dependency (Hall, 1999; Yu & Liu, 2003): This kind of measure evaluates the worth of a subset of features by considering the individual predictive ability of each feature along with the degree of redundancy among these features. The FSS methods based on this kind of measure assume that good feature subsets contain features closely correlated with the target concept, but uncorrelated with each other.\niii) Distance (Kira & Rendell, 1992; Kononenko, 1994): This kind of measure is proposed based on the assumption that the distance of instances from different target concepts is greater than that from same target concepts.\niv) Probabilistic significance (Zhou & Dillon, 1988; Liu & Setiono, 1995): This measure evaluates the worth of a feature by calculating the probabilistic significance as a two-way function, i.e., the association between feature and the target concept. A good feature should have significant association with the target concept.\nWe should pay attention to that, besides the above four evaluation measures, there is another basic kind of measure: information-based measure (Liu & Yu, 2005; de Souza, 2004; Dash & Liu, 1997), which is not contemplated in the experiments. The reason is demonstrated as follow. The information-based measure is usually in conjunction with ranker search method. Thus, the FSS algorithms based on this kind of measure usually provide a rank list of the features instead of telling us which features are relevant to the learning target. In this case, we should preassign particular thresholds for these FSS algorithms to pick up the relevant features. However, there is not any effective method to set the thresholds or any acknowledged default threshold for these FSS algorithms. Moreover, it is unfair to conclude that these information measure based FSS algorithms with any assigned threshold are not appropriate when comparing to the other FSS algorithms. Therefore, this kind of FSS algorithm is not employed in our experiments.\nBased on the search methods and the evaluation measures introduced above, 22 different FSS algorithms are obtained. Table 3 shows the brief introduction of these FSS algorithms. Where all these algorithms are available in the data mining toolkit Weka5 (Hall, Frank,\n5. http://www.cs.waikato.ac.nz/ml/weka/\nHolmes, Pfahringer, Reutemann, & Witten, 2009), and the search method INTERACT is implemented based on Weka and its source codes are available online6.\nIt is noted that some of these algorithms require particular settings of certain parameters. For the purpose of allowing other researchers to confirm our results, we introduce the parameter settings of these FSS algorithms. Such as, for FSS algorithms \u201cINTERACT-D\u201d and \u201cINTERACT-C\u201d, there is a parameter, c-contribution threshold, used to identify the irrelevant features. We set this threshold as 0.0001 suggested by Zhao and Liu (2007). For FSS algorithm \u201cFCBF\u201d, we set the relevance threshold to be the SU (Symmetric Uncertainty) value of the bN/ log Ncth ranked feature suggested by Yu and Liu (2003). For FSS algorithm \u201cRelief-F\u201d, we set the significance threshold to 0.01 used by Robnik-S\u030cikonja and Kononenko (2003). For FSS algorithm \u201cSignific\u201d, there is a threshold, statistical significance level \u03b1, used to identify the irrelevant features. We set \u03b1 as the commonly-used value 0.01 in our experiment. The other FSS algorithms are conducted in the Weka environment with the default setting(s)."}, {"heading": "4.2.2 Classification Algorithms", "text": "Since the actual relevant features of real world data sets are usually not known in advance, it is impracticable to directly evaluate an FSS algorithm by the selected features. Classification accuracy is an extensively used metric for evaluating the performance of FSS algorithms, and also plays an important role in our proposed performance metric EARR for assessing different FSS algorithms.\nHowever, different classification algorithms have different biases. An FSS algorithm may be more suitable for some classification algorithms than others (de Souza, 2004). This fact affects the performance evaluation of FSS algorithms.\nWith this in mind, in order to demonstrate that our proposed FSS algorithm recommendation method is not limited to any particular classification algorithm, five representative classification algorithms based on different hypotheses are employed. They are bayes-based Naive Bayes (John & Langley, 1995) and Bayes Network (Friedman, Geiger, & Goldszmidt, 1997), information gain-based C4.5 (Quinlan, 1993), rule-based PART (Frank & Witten, 1998), and instance-based IB1 (Aha, Kibler, & Albert, 1991), respectively.\nAlthough Naive Bayes and Bayes Net are both bayes-based classification algorithms, they are quite different from each other since Naive Bayes is proposed based on the hypoth-\n6. http://www.public.asu.edu/huanliu/INTERACT/INTERACTsoftware.html\nesis that the features are conditional independent (John & Langley, 1995), while Bayes Net takes into account the feature interaction (Friedman et al., 1997)."}, {"heading": "4.2.3 Measures to Evaluate the Recommendation Method", "text": "FSS algorithm recommendation is an application of meta-learning. So far as we know, there are no unified measures to evaluate the performance of the meta-learning methods. In order to assess our proposed FSS algorithm recommendation method, two measures, recommendation hit ratio and recommendation performance ratio, are defined.\nLet D be a given data set and Arec be an FSS algorithm recommended by the recommendation method for D, these two measures can be introduced as follows."}, {"heading": "1) Recommendation hit ratio", "text": "An intuitive evaluation criterion is whether the recommended FSS algorithm Arec meets users\u2019 requirements. That is, whether Arec is the optimal FSS algorithm for D, or the performance of Arec on D has no significant difference with that of the optimal FSS algorithm.\nSuppose Aopt represents the optimal FSS algorithm for D, and ASetopt denotes the FSS algorithm set in which each algorithm has no significant difference with Aopt (of course it includes Aopt as well). Then, a measure named recommendation hit can be defined to assess whether the recommended algorithm Arec is effective on D.\nDefinition 1 (Recommendation hit). If an FSS algorithm Arec is recommended to a data set D, then the recommendation hit Hit(Arec, D) is defined as\nHit(Arec, D) = { 1, if Arec \u2208 ASetopt 0, otherwise . (6)\nWhere Hit(Arec, D) = 1 means the recommendation is effective since the recommended FSS algorithm Arec is one of the algorithms in ASetopt for D, while hit(Arec, D) = 0 indicates the recommended FSS algorithm Arec is not a member of ASetopt, i.e., Arec is significantly worse than the optimal FSS algorithm Aopt on D, thus the recommendation is bad.\nFrom Definition 1 we know that the recommendation hit Hit(Arec, D) is used to evaluate the recommendation method for a single data set. Thus, it is extended as recommendation hit ratio to evaluate the recommendation for a set of data sets, and is defined as follows.\nDefinition 2 Recommendation hit ratio\nHit Ratio(Arec) = 1 G\nG\u2211\ni=1\nHit(Arec, Di). (7)\nWhere G is the number of the historical data sets, e.g., G = 115 in our experiment. Definition 2 represents the percentage of data sets on which the appropriate FSS algorithms are effectively recommended by our recommendation method. The larger this value, the better the recommendation method."}, {"heading": "2) Recommendation performance ratio", "text": "The recommendation hit ratio reveals that whether or not an appropriate FSS algorithm is recommended for a given data set, but it cannot tell us the margin of the recommended algorithm to the best one. Thus, a new measure, the recommendation performance ratio for a recommendation, is defined.\nDefinition 3 (Recommendation performance ratio). Let EARRrec and EARRopt be the performance of the recommended FSS algorithm Arec and the optimal FSS algorithm on D, respectively. Then, the recommendation performance ratio (RPR) for Arec is defined as\nRPR(Arec, D) = EARRrec/EAARopt. (8)\nIn this definition, the best performance EARRopt is employed as a benchmark. Without the benchmark, it is hard to determine the recommended algorithms are good or not. For example, suppose the EARR of Arec on D is 0.59. If EARRopt = 0.61, then the recommendation is effective since EARR of Arec is very close to EARRopt. However, the recommendation is poor if EARRopt = 0.91.\nRPR is the ratio of EARR of a recommended FSS algorithm to that of the optimal one. It measures how close the recommended FSS algorithm to the optimal one, and reveals the relative performance of the recommended FSS algorithm. Its value varies from 0 to 1, and the larger the value of RPR, the closer the performance of the recommended FSS algorithm to that of the optimal one. The recommended algorithm is the optimal one if and only if RPR = 1."}, {"heading": "4.2.4 Values of the Parameters \u03b1 and \u03b2", "text": "In this paper, a multi-criteria metric EARR is proposed to evaluate the performance of an FSS algorithm. For the proposed metric EARR, two parameters \u03b1 and \u03b2 are established for users to express their requirements on algorithm performance.\nIn the experiment, when presenting the results, two representative value pairs of parameters \u03b1 and \u03b2 are used as follows:\n1) \u03b1 = 0 and \u03b2 = 0. This setting represents the situation where the classification accuracy is most important. The higher the classification accuracy over the selected features, the better the corresponding FSS algorithms.\n2) \u03b1 6= 0 and \u03b2 6= 0. This setting represents the situation where the user can tolerate an accuracy attenuation and favor the FSS algorithms with shorter runtime and fewer selected features. In the experiment, both \u03b1 and \u03b2 are set to 10% that is quite different from \u03b1 = \u03b2 = 0. This allows us can explore the impact of these two parameters on the recommendation results.\nMoreover, in order to explore how parameters \u03b1 and \u03b2 affect the recommended FSS algorithms in terms of classification accuracy, runtime and the number of selected features, different parameters settings are provided. Specifically, the values of \u03b1 and \u03b2 vary from 0 to 10% with an increase of 1%."}, {"heading": "4.3 Experimental Process", "text": "In order to make sure the soundness of our experimental conclusion and guarantee the experiments reported being reproducible, in this part, we introduce the four crucial processes used in our experiments. They are i) meta-knowledge database construction, ii) optimal FSS algorithm set identification for a given data set, iii) Recommendation method validation and iv) sensitivity analysis of the number of the nearest data sets on recommendations.\n1) Meta-knowledge database construction\nProcedure PerformanceEvaluation Inputs : data = a given data set, i.e, one of the 115 data sets;\nlearner = a given classification algorithm, i.e., one of {Naive Bayes, C4.5, PART, IB1 or Bayes Network}; FSSAlgSet = {FSSAlg1, FSSAlg2, \u00b7 \u00b7 \u00b7 , FSSAlg22}, the set of the 22 FSS algorithms; Output: EARRset = {EARR1, EARR2, \u00b7 \u00b7 \u00b7 , EARR22}, the EARRs of the 22 FSS\nalgorithms on data; M = 5; FOLDS = 10;1 for i = 1 to 22 do2 EARRi = 0;3\nfor i = 1 to M do4 randomized order from data;5 generate FOLDS bins from data;6 for j = 1 to FOLDS do7\nTestData = bin[j ];8 TrainData = data- TestData;9 numberList = Null , runtimeList = Null , accuracyList = Null ;10 for k = 1 to 22 do11 (Subset , runtime) = apply FSSAlg k on TrainData;12 number = |Subset |;13 RedTestData = reduce TestData according to selected Subset ;14 RedTrainData = reduce TrainData according to selected Subset ;15 classifier = learner (RedTrainData);16 accuracy = apply classifier to RedTestData;17 numberList [k ] = number , runtimeList [k ] = runtime, accuracyList [k ] =18 accuracy ;\nfor k = 1 to 22 do19 EARR = EARRCompution(accuracyList , runtimeList , numberList , k);20 //Compute EARR of FSSAlgk on jth bin of pass i according Eqs. (1) and (2) EARRk = EARRk + EARR;21\nfor i \u2190 1 to 22 do22 EARRi = EARRi/(M\u00d7FOLDS);23\nreturn EARRset ;24\nFor each data set Di (1 \u2264 i \u2264 115), we i) extract its meta-features Fi; ii) calculate the EARRs for the 22 candidate FSS algorithms with the stratified 5\u00d710-fold cross-validation strategy (Kohavi, 1995), and iii) combine the meta-features Fi and the EARR of each FSS algorithm together to form a tuple, which is finally added to the meta-knowledge database.\nSince the extraction of meta-features and the combination of the meta-features and the EARRs are straightforward, we just present the calculation of EARRs, procedure PerformanceEvaluation shows the details."}, {"heading": "2) Optimal FSS algorithm set identification", "text": "The optimal FSS algorithm set for a given data set Di consists of the optimal FSS algorithm for this data set and those algorithms that have no significant performance difference with the optimal one on Di.\nThe optimal FSS algorithm set for a given data set Di is obtained via a non-parametric Friedman test (1937) followed by a Holm procedure test (1988) on the performance, which\nis estimated by the 5\u00d710 cross validation strategy, of the 22 FSS algorithms. If the result of the Friedman test shows that there is no significant performance difference among the 22 FSS algorithms, these 22 FSS algorithms are added to the optimal FSS algorithm set. Otherwise, the FSS algorithm with the highest performance is viewed as the optimal one and added to the optimal FSS algorithm set. Then, the Holm procedure test is performed to identify the algorithms from the rest 21 FSS algorithms. The algorithms that have no significant performance differences with the optimal one are added into the optimal FSS algorithm set.\nThe reason why the non-parametric test is employed lies in that it is difficult for the performance values to follow the normal distribution and satisfy variance homogeneous condition.\nNote that the optimal FSS algorithm sets for different settings of parameters \u03b1 and \u03b2 are different, since the values of these two parameters directly affect the required performance values."}, {"heading": "3) Recommendation method validation", "text": "The leave-one-out strategy is used to empirically evaluate our proposed FSS algorithm recommendation method as follows: for each data set Di (1 \u2264 i \u2264 115) that is viewed as the test data, i) identify its k nearest data sets from the training data = {D1, \u00b7 \u00b7 \u00b7 , Di\u22121, Di+1, \u00b7 \u00b7 \u00b7 , D115} excluding Di; ii) calculate the performance of the 22 candidate FSS algorithms according to Eq. (5) based on the k nearest data sets where the value of k is determined by the standard cross-validation strategy, and recommend the top three to Di; and iii) evaluate the recommendations by the measures introduced in section 4.2.3."}, {"heading": "4) Sensitivity analysis of the number of the nearest data sets on recommendations", "text": "In order to explore the effect of the number of the nearest data sets on the recommendations and provide users an empirical method to choose its value, for each data set, all the possible numbers of the nearest data sets are tested. That is, when identifying the k nearest data sets for a given data set, k is set from 1 to the number of the historical data sets minus 1 (e.g., 114 in this experiment)."}, {"heading": "4.4 Results and Analysis", "text": "In this section, we present the recommendation results in terms of recommended FSS algorithms, hit ratio and performance ratio , respectively. Due to the space limit of the paper, we do not list all the recommendations, but instead present the results under two significantly different pairs of \u03b1 and \u03b2, i.e., (\u03b1 = 0, \u03b2 = 0) and (\u03b1 = 10%, \u03b2 = 10%).\nAfterward, we also provide the experimental results of the influence of the user-oriented parameters \u03b1 and \u03b2 on recommendations in terms of classification accuracy, runtime, and the number of selected features, respectively."}, {"heading": "4.4.1 Recommended Algorithms and Hit Ratio", "text": "Figs. 2, 3, 4, 5 and 6 show the first recommended FSS algorithms for the 115 data sets when the classification algorithms Naive Bayes, C4.5, PART, IB1 and Bayes Network are used, respectively.\nIn each figure, there are two sub-figures corresponding to the recommendation results for (\u03b1 = 0, \u03b2 = 0) and (\u03b1 = 10%, \u03b2 = 10%), respectively. In each sub-figure, \u2018\u25e6\u2019 and \u2018\u00d7\u2019 denote the correctly and incorrectly recommended algorithms, respectively.\nFrom these figures, we observe that:\n1) For all the five classifiers, the proposed method can effectively recommend appropriate FSS algorithms for most of the 115 data sets.\nIn the case of (\u03b1 = 0, \u03b2 = 0), the number of data sets, whose appropriate FSS algorithms are correctly recommended, is 109 out of 115 for Naive Bayes, 111 out of 115 for C4.5, 109 out of 115 for PART, 108 out of 115 for IB1, and 109 out of 115 for Bayes\nNetwork, respectively. This states that the recommendation method is effective when classification accuracy is most important.\nIn the case of (\u03b1 = 10%, \u03b2 = 10%), the number of data sets, whose appropriate FSS algorithms are correctly recommended, is 104 out of 115 for Naive Bayes, 109 out of 115 for C4.5, 110 out of 115 for PART, 106 out of 115 for IB1, and 104 out of 115 for Bayes Network, respectively. This indicates that the recommendation method also works well when tradeoff is required among classification accuracy, runtime, and the number of selected features. 2) The distribution of the recommended FSS algorithms for the 115 data sets is different for different parameters settings. The distribution is relatively uniform for (\u03b1 = 0, \u03b2 = 0),\nwhile it is seriously biased to some algorithm (e.g., the 22th FSS algorithm) for (\u03b1 = 10%, \u03b2 = 10%).\nThis phenomenon is similar for all the five classifiers. This can be explained as follows. The FSS algorithms with the best classification accuracy distribute on the 115 data sets uniformly. Thus, in the case of (\u03b1 = 0, \u03b2 = 0) where users favor accurate classifiers, the distribution of the recommended FSS algorithms is relatively uniform as well. However, there exist some FSS algorithms that run faster (e.g., the 22th algorithm \u201cSignific\u201d) or select fewer features (e.g., the 8th algorithm \u201cCFS-SWS\u201d, the 18th algorithm \u201cConsSWS\u201d, and the 22th algorithm \u201cSignific\u201d) on most of the 115 data sets. For this reason, in the case of (\u03b1 = 10%, \u03b2 = 10%) where users prefer the FSS algorithms with less runtime and fewer features, the distribution of the FSS algorithms with the best performance on the 115 data sets is biased to some algorithms, so is the recommended FSS algorithms. 3) The 22th FSS algorithm performs well on about 85 out of 115 data sets for all classifiers when (\u03b1 = 10%, \u03b2 = 10%). It seems that this FSS algorithm is a generally wellperformed FSS algorithm that can be adopted by all FSS tasks and there is no need for FSS algorithm recommendation. Unfortunately, this is not the case. The 22th FSS algorithm is still failing to perform well over about a quarter of the 115 data sets. Yet, our recommendation method can distinguish these data sets and further effectively recommend appropriate FSS algorithms for them. This indicates our recommendation method is still necessary in this case.\nCompared with (\u03b1 = 0, \u03b2 = 0), we can know that this case is due to the larger \u03b1 and \u03b2 values and can be explained as follows. For all the 22 FSS algorithms, although the classification accuracies of a classifier over the features selected by them are different, the differences are usually bounded. Meanwhile, from Eq. (1) we know that when \u03b1/\u03b2 is set to be greater than the bound value, the value of EARR will be dominated by the runtime/the number of selected features. This means that if \u03b1 or \u03b2 is set to be a relatively large value, the algorithm with a lower time complexity or the algorithm that chooses smaller number of features will be recommended, and the classification\naccuracy over the selected features will be ignored. However, as we know, one of the most important targets of feature selection is to improve the performance of learning algorithms. So it is unreasonable to ignore the classification accuracy and just focus on the speed and the simplicity of an FSS algorithm.\nThus, in real applications, the values of \u03b1 and \u03b2 should be set under the limit of classification accuracies. Generally, the \u03b1/\u03b2 should be bounded by (accmax\u2212accmin)/accmin, where accmax and accmin denote the maximum and the minimum classification accuracies, respectively.\nTable 4 shows the hit ratio of the recommended FSS algorithms for the five classifiers. From it we can observe that:\n1) If a single FSS algorithm is recommended, the hit ratio of the first recommended algorithm Alg1st is the highest, its value is up to 96.52% and at least is 90.43% for all the five classifiers. Thus, Alg1st should be the first choice. 2) If the top three algorithms are recommended, the hit ratio is up to 100% and at least is 98.62%. That indicates that the confidence of the top three algorithms including an appropriate one is very high. This is the reason why only the top three algorithms are recommended. Moreover, the proposed recommendation method has reduced the number of candidate algorithms to three, users can further pick up the one that fits his/her specific requirement from them."}, {"heading": "4.4.2 Recommendation Performance Ratio", "text": "Figs. 7 and 8 show the recommendation performance ratio RPR of the first recommended FSS algorithm for the five classifiers with (\u03b1 = 0, \u03b2 = 0) and (\u03b1 = 10%, \u03b2 = 10%), respectively. From these two figures we can observe that, for most data sets and the two settings of \u03b1 and \u03b2, the RPRs of the recommended FSS algorithms are greater than 95% and some of them are up to 100% no matter which classifier is used. This indicates that the FSS algorithms recommended by our proposed method are very close to the optimal one.\nTable 5 shows the average RPRs over the 115 data sets for the five classifiers under different settings of (\u03b1, \u03b2). In this table, for each classifier, columns \u201cRec\u201d and \u201cDef\u201d shows the RPR value corresponding to the recommended FSS algorithms and default FSS algorithms, respectively. Where the default FSS algorithm is the most frequent best one on the 115 data sets under the classifier.\nFrom it we observe that the average RPRs range from 97.32% to 98.8% for (\u03b1 = 0, \u03b2 = 0), and from 97.82% to 98.99% for (\u03b1 = 10%, \u03b2 = 10%), respectively. Moreover, the average RPR of the recommended FSS algorithms surpasses that of the default FSS algorithms for all the five different classifiers. This means our proposed recommendation method works very well and greatly fits user\u2019s performance requirement."}, {"heading": "4.4.3 Recommendation Time", "text": "When recommending FSS algorithms for a feature selection problem, the recommendation time is contributed by meta-features extraction, k nearest data sets identification, and the candidate algorithm ranking according to their performance on the k data sets.\nOf these three recommendation time contributors, only the candidate algorithm ranking is related with the parameters \u03b1 and \u03b2 of the performance metric EARR.\nHowever, the computation of performance EARR is the same whatever the values of \u03b1 and \u03b2 are. This means recommendation time is independent of the specific settings of \u03b1 and \u03b2. Thus, we just present the recommendation time with (\u03b1 = 0, \u03b2 = 0), and Table 6 shows the details.\nFrom Table 6 we observe that for a given data set, the recommendation time differences for the five classifiers are small. The reason is that the recommendation time is mainly contributed by the extraction of meta-features, which has no relation with classifiers. This is consistent with the time complexity analysis in Section 3.2. We also observe that for most of the data sets, the recommendation time is less than 0.1 second, and its average value on the 115 data sets is around 0.65 second for each of the five classifiers. This is much faster than the conventional cross validation method."}, {"heading": "4.4.4 Impact of the Parameters \u03b1 and \u03b2", "text": "Figs. 9, 10, 11, 12 and 13 show the impact of the settings of \u03b1 and \u03b2 on the classification accuracy, the runtime of feature selection, the number of selected features, the Hit Ratio and the RPR value, respectively.\nFig. 9 shows the classification accuracies of the five classifiers under the different values of \u03b1 and \u03b2. From it we observe that, with the increase of either \u03b1 or \u03b2, the classification accuracies of the five classifiers with the recommended FSS algorithms decrease. This is because the increase of \u03b1 or \u03b2 indicates that users much prefer faster FSS algorithms or the FSS algorithms that can get less features. Thus, the proportion of classification accuracy in performance is decreased. This means the ranks of the FSS algorithms that run faster and/or get less features are improved and the corresponding FSS algorithms are finally selected.\nFig. 10 shows the runtime of the FSS algorithms that recommended to the five classifiers under the different values of \u03b1 and \u03b2 for the five classifiers. From it we observe that:\n1) With the increase of \u03b1, the average runtime of the recommended FSS algorithms for each classifier decreases. Note a larger value of \u03b1 means users favor faster FSS algorithms. Thus, this indicates that user\u2019s performance requirement is met since faster FSS algorithms were recommended. 2) With the increase of \u03b2, the average runtime of the recommended FSS algorithms increases as well. This is because in our proposed recommendation method, the appropriate FSS algorithms for a given data set are recommended based on its nearest data sets. Moreover, in the experiment, for more than half (i.e., 69) of the 115 data sets, there is a negative correlation between the number of selected features and the runtime of the 22 FSS algorithms. Thus, the more data sets with this kind of negative correlation, the more possible the nearest neighbors of a given data set have the negative correlation. Therefore, a larger \u03b2 means longer runtime. Another possible reason is that a larger value of \u03b2 means users favor the FSS algorithms that choose fewer features, and in order to get fewer features, the FSS algorithms need to consume relatively more time.\nFig. 11 shows the number of features selected by the FSS algorithms that recommended to the five classifiers under different values of \u03b1 and \u03b2. From it we observe that:\n1) With the increase of \u03b1, the average number of selected features increases as well. This is because in our proposed recommendation method, the appropriate FSS algorithms for a given data set are recommended based on its nearest data sets. Moreover, in the experiment, for more than half (i.e., 69) of the 115 data sets, there is a negative correlation between the number of selected features and the runtime of the 22 FSS algorithms. Thus, the more data sets with this kind of negative correlation, the more possible the nearest neighbors of a given data set have the negative correlation. Therefore, a larger \u03b1 means more features. Another possible reason is that a larger value of \u03b1 means users favor faster FSS algorithms. It is possible that shorter computation time can be obtained via filter out less features so more features are remained.\nNote that there is an exception. That is, the average number of selected features for C4.5 decreases when the value of \u03b1 is small. However, the decrement comes up in a quite small range of \u03b1 (i.e., < 0.005). 2) With the increase of \u03b2, the average number of features selected by the recommended FSS algorithm decreases. Note a larger value of \u03b2 means users favor the FSS algorithms that can get fewer features. Thus, this indicates that user\u2019s requirement is met since the FSS algorithms that can get fewer features were recommended.\nFigs. 12 and 13 show the average hit ratio and RPR of the recommended FSS algorithms under different values of \u03b1 and \u03b2 for the five classifiers.\nFrom them we observe that, the average hit ratio falls in the intervals [91.74%, 100%] under \u03b1 and [92.56%, 99.13%]) under \u03b2. The average RPR varies in the intervals [97.69%, 98.82%] under \u03b1 and [97.68%, 98.73%] under \u03b2. With the change of the \u03b1 and \u03b2, the hit ratio and RPR of the recommended FSS algorithms vary as well. However, the change intervals fall in a relative small interval and the lower bound stands at a fairly high level. The minimum average hit ratio is up to 91.74% and the minimum average RPR is up to 97.68%. This indicates that the proposed FSS algorithm recommendation method has general application and works well for different settings of \u03b1 and \u03b2."}, {"heading": "5. Sensitivity Analysis of the Number of Nearest Data Sets on", "text": "Recommendation Results\nIn this section, we analyze how the number of the nearest data sets affects the recommendation performance. Based on the experimental results, we provide some guidelines for selecting the appropriate number of nearest data sets in practice."}, {"heading": "5.1 Experimental Method", "text": "Generally, different numbers of the nearest data sets (i.e., k) will result in different recommendations. Thus, when recommending FSS algorithms to a feature selection problem, an appropriate k value is very important.\nThe k value that results in higher recommendation performance is preferred. However, the recommendation performance difference under two different k values sometimes might be random and not significant. Thus, in order to identify an appropriate k value from alternatives, we should first determine whether or not the performance differences among them are statistically significant. Non-parametric statistical test, Friedman test followed by Holm procedure test as suggested by Dems\u030car (2006), can be used for this purpose.\nIn the experiment, we conducted FSS algorithm recommendation with all possible k values (i.e., from 1 to 114) over the 115 data sets. When identifying the appropriate k values, the non-parametric statistical test is conducted as follows.\nFirstly, the Friedman test is performed over the 114 recommendation performance at the significance level 0.05. Its null hypothesis is that the 114 k values perform equivalently well in the proposed recommendation method over the 115 data sets.\nIf the Friedman test rejects the null hypothesis, that is, there exists significant difference among these 114 k values, then we choose one under which the recommendation has the best performance as the reference. After that, the Holm procedure test is performed to find out the k values under which the recommendation performance has no significant difference with that of the reference. The identified k values including the reference are the appropriate numbers of the nearest data sets."}, {"heading": "5.2 Results Analysis", "text": "Fig. 14 shows how the number of the nearest data sets (i.e., k) affects the performance of the recommendation method under different settings of \u03b1 and \u03b2, where \u2018\u00d7\u2019 denotes the k under which the recommendation performance is significantly worse than others at the significance level of 0.05. From it we observe that:\n1) When \u03b1 = \u03b2 = 0 (Fig. 14(a)), for each of the five classifiers, the RPR varies with different k values. Specifically, the RPR is fluctuant when k is smaller than 20, while it is relatively flat in the middle part, and it decreases when k is larger than 79 except for C4.5. However, the increment of C4.5 is very small (< 0.002). This might be due to that C4.5 picks up useful features to build the tree by itself, so the impact of other feature selection methods is less. Moreover, the difference among accuracies of C4.5 on most data sets is relatively small, while the performance metric EARR that used to evaluate different FSS algorithms depends only on classification accuracy when \u03b1 = \u03b2 = 0. Thus, the RPR of C4.5 is relatively stable for the different values of k. 2) In the case of \u03b1 = \u03b2 = 10% (Fig. 14(b)), the variation of RPR is different from that of \u03b1 = \u03b2 = 0. For each of the five classifiers, the RPR first decreases with fluctuations, then increases, and finally decreases slowly and steadily. This could be due to that, when the parameters \u03b1 and \u03b2 are set to be a relatively large value (such as 10% in our experiment), the runtime of ( or the number of features selected by) an FSS algorithm will play a more important role in evaluating the performance of the FSS algorithm. Thus, for a given data set, the FSS algorithms with lower time complexity (or the smaller number of selected features) will be more possibly higher ranked and have larger RPR. Therefore, with the increasing of k, these algorithms are more possibly recommended. Meanwhile, for most data sets, these algorithms are either the real appropriate algorithms or with larger RPR, so the RPR averaged over all data sets is relatively stable with the increasing of k.\n3) Comparing the cases of \u03b1 = \u03b2 = 0 and \u03b1 = \u03b2 = 10%, we found that \u2018\u00d7\u2019 appears when k < 21 for the former and k < 29 for the latter, while it emerges again when k > 76 for the former. This means we cannot choose the k values falling into these ranges. At the same time, we also found that the peak values of RPR for \u03b1 = \u03b2 = 10% appear in the range of [32, 54], which is also one of the peak value ranges for \u03b1 = \u03b2 = 0 except C4.5. This means if we set k to 28% to 47% of the number of data sets, better recommendation performance can be obtained."}, {"heading": "6. Conclusion", "text": "In this paper, we have presented an FSS algorithm recommendation method with the aim to support the automatic selection of appropriate FSS algorithms for a new feature selection problem from a number of candidates.\nThe proposed recommendation method consists of meta-knowledge database construction and algorithm recommendation. The former obtains the meta-features and the performance of all the candidate FSS algorithms, while the latter models the relationship between the meta-features and the FSS algorithm performance based on a k -NN method and recommends appropriate algorithms for a feature selection problem with the built up model.\nWe have thoroughly tested the recommendation method with 115 real world data sets, 22 different FSS algorithms, and five representative classification algorithms under two typical user\u2019s performance requirements. The experimental results show that our recommendation method is effective.\nWe have also conducted a sensitivity analysis to explore how the number of the nearest data sets (k) impacts the FSS algorithm recommendation, and suggest to set k as the 28% to 47% of the number of the historical data sets.\nIn this paper, we have utilized the well-known and commonly-used meta-features to characterize different data sets. \u201cWhich meta-features are informative?\u201d and \u201cAre there any other more informative meta-features?\u201d are still open questions. To our knowledge, there still does not exist any effective method to answer these questions. Thus, for future work, we plan to explore further that how to measure the information of the meta-features and whether there are some more informative meta-features that can lead to further improvements for FSS algorithm recommendation."}, {"heading": "Acknowledgements", "text": "This work is supported by the National Natural Science Foundation of China under grant 61070006."}], "references": [{"title": "Instance-based learning", "author": ["D.W. Aha", "D. Kibler", "M.K. Albert"], "venue": null, "citeRegEx": "Aha et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Aha et al\\.", "year": 1991}, {"title": "Locally weighted learning", "author": ["C.G. Atkeson", "A.W. Moore", "S. Schaal"], "venue": "Artificial intelligence review,", "citeRegEx": "Atkeson et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Atkeson et al\\.", "year": 1997}, {"title": "Using mutual information for selecting features in supervised neural net learning", "author": ["R. Battiti"], "venue": "IEEE Transactions on Neural Networks,", "citeRegEx": "Battiti,? \\Q1994\\E", "shortCiteRegEx": "Battiti", "year": 1994}, {"title": "Metalearning: Applications to data", "author": ["P. Brazdil", "C. Carrier", "C. Soares", "R. Vilalta"], "venue": null, "citeRegEx": "Brazdil et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Brazdil et al\\.", "year": 2008}, {"title": "Ranking learning algorithms: Using IBL and meta-learning on accuracy and time results", "author": ["P.B. Brazdil", "C. Soares", "J.P. Da Costa"], "venue": "Machine Learning,", "citeRegEx": "Brazdil et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Brazdil et al\\.", "year": 2003}, {"title": "Addressing the selective superiority problem: Automatic algorithm/model class selection", "author": ["C.E. Brodley"], "venue": "In Proceedings of the Tenth International Conference on Machine Learning,", "citeRegEx": "Brodley,? \\Q1993\\E", "shortCiteRegEx": "Brodley", "year": 1993}, {"title": "Meta-data: Characterization of input features for meta-learning", "author": ["C. Castiello", "G. Castellano", "A. Fanelli"], "venue": "Modeling Decisions for Artificial Intelligence,", "citeRegEx": "Castiello et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Castiello et al\\.", "year": 2005}, {"title": "Feature selection for classification", "author": ["M. Dash", "H. Liu"], "venue": "Intelligent data analysis,", "citeRegEx": "Dash and Liu,? \\Q1997\\E", "shortCiteRegEx": "Dash and Liu", "year": 1997}, {"title": "Consistency-based search in feature selection", "author": ["M. Dash", "H. Liu"], "venue": "Artificial Intelligence,", "citeRegEx": "Dash and Liu,? \\Q2003\\E", "shortCiteRegEx": "Dash and Liu", "year": 2003}, {"title": "Feature selection with a general hybrid algorithm", "author": ["J.T. de Souza"], "venue": "Ph.D. thesis,", "citeRegEx": "Souza,? \\Q2004\\E", "shortCiteRegEx": "Souza", "year": 2004}, {"title": "Statistical comparisons of classifiers over multiple data sets", "author": ["J. Dem\u0161ar"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Dem\u0161ar,? \\Q2006\\E", "shortCiteRegEx": "Dem\u0161ar", "year": 2006}, {"title": "Using a data metric for preprocessing advice for data mining applications", "author": ["R. Engels", "C. Theusinger"], "venue": null, "citeRegEx": "Engels and Theusinger,? \\Q1998\\E", "shortCiteRegEx": "Engels and Theusinger", "year": 1998}, {"title": "Generating accurate rule sets without global optimization", "author": ["E. Frank", "I.H. Witten"], "venue": "In Proceedings of the 25th international conference on Machine learning,", "citeRegEx": "Frank and Witten,? \\Q1998\\E", "shortCiteRegEx": "Frank and Witten", "year": 1998}, {"title": "The use of ranks to avoid the assumption of normality implicit in the analysis of variance", "author": ["M. Friedman"], "venue": "Journal of the American Statistical Association,", "citeRegEx": "Friedman,? \\Q1937\\E", "shortCiteRegEx": "Friedman", "year": 1937}, {"title": "Bayesian network classifiers", "author": ["N. Friedman", "D. Geiger", "M. Goldszmidt"], "venue": "Machine learning,", "citeRegEx": "Friedman et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Friedman et al\\.", "year": 1997}, {"title": "Characterization of classification algorithms", "author": ["J. Gama", "P. Brazdil"], "venue": "Progress in Artificial Intelligence,", "citeRegEx": "Gama and Brazdil,? \\Q1995\\E", "shortCiteRegEx": "Gama and Brazdil", "year": 1995}, {"title": "Solving feature subset selection problem by a parallel scatter search", "author": ["F. Garci\u2019a Lopez", "M. Garci\u2019a Torres", "B. Melian Batista", "J.A. Moreno Perez", "J.M. MorenoVega"], "venue": "European Journal of Operational Research,", "citeRegEx": "Lopez et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Lopez et al\\.", "year": 2006}, {"title": "Genetic algorithms in search, optimization, and machine learning. Addison-Wesley Professional", "author": ["D.E. Goldberg"], "venue": null, "citeRegEx": "Goldberg,? \\Q1989\\E", "shortCiteRegEx": "Goldberg", "year": 1989}, {"title": "Large-scale attribute selection using wrappers", "author": ["M. Gutlein", "E. Frank", "M. Hall", "A. Karwath"], "venue": "In Proceedings of IEEE Symposium on Computational Intelligence and Data Mining,", "citeRegEx": "Gutlein et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gutlein et al\\.", "year": 2009}, {"title": "An introduction to variable and feature selection", "author": ["I. Guyon", "A. Elisseeff"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Guyon and Elisseeff,? \\Q2003\\E", "shortCiteRegEx": "Guyon and Elisseeff", "year": 2003}, {"title": "The weka data mining software: an update", "author": ["M. Hall", "E. Frank", "G. Holmes", "B. Pfahringer", "P. Reutemann", "I. Witten"], "venue": "ACM SIGKDD Explorations Newsletter,", "citeRegEx": "Hall et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hall et al\\.", "year": 2009}, {"title": "Correlation-based Feature Selection for Machine Learning", "author": ["M.A. Hall"], "venue": "Ph.D. thesis, The University of Waikato", "citeRegEx": "Hall,? \\Q1999\\E", "shortCiteRegEx": "Hall", "year": 1999}, {"title": "Tabu search for attribute reduction in rough set theory. Soft Computing-A Fusion of Foundations", "author": ["A.R. Hedar", "J. Wang", "M. Fukushima"], "venue": "Methodologies and Applications,", "citeRegEx": "Hedar et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hedar et al\\.", "year": 2008}, {"title": "A stagewise rejective multiple test procedure based on a modified bonferroni", "author": ["G. Hommel"], "venue": "test. Biometrika,", "citeRegEx": "Hommel,? \\Q1988\\E", "shortCiteRegEx": "Hommel", "year": 1988}, {"title": "Estimating continuous distributions in Bayesian classifiers", "author": ["G.H. John", "P. Langley"], "venue": "In Proceedings of the eleventh conference on uncertainty in artificial intelligence,", "citeRegEx": "John and Langley,? \\Q1995\\E", "shortCiteRegEx": "John and Langley", "year": 1995}, {"title": "On data and algorithms: Understanding inductive performance", "author": ["A. Kalousis", "J. Gama", "M. Hilario"], "venue": "Machine Learning,", "citeRegEx": "Kalousis et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Kalousis et al\\.", "year": 2004}, {"title": "Statlog: comparison of classification algorithms on large real-world problems", "author": ["R.D. King", "C. Feng", "A. Sutherland"], "venue": "Applied Artificial Intelligence,", "citeRegEx": "King et al\\.,? \\Q1995\\E", "shortCiteRegEx": "King et al\\.", "year": 1995}, {"title": "A practical approach to feature selection", "author": ["K. Kira", "L. Rendell"], "venue": "In Proceedings of the ninth international workshop on Machine learning,", "citeRegEx": "Kira and Rendell,? \\Q1992\\E", "shortCiteRegEx": "Kira and Rendell", "year": 1992}, {"title": "A study of cross-validation and bootstrap for accuracy estimation and model selection", "author": ["R. Kohavi"], "venue": "In International joint Conference on artificial intelligence,", "citeRegEx": "Kohavi,? \\Q1995\\E", "shortCiteRegEx": "Kohavi", "year": 1995}, {"title": "Wrappers for feature subset selection", "author": ["R. Kohavi", "G. John"], "venue": "Artificial intelligence,", "citeRegEx": "Kohavi and John,? \\Q1997\\E", "shortCiteRegEx": "Kohavi and John", "year": 1997}, {"title": "Estimating attributes: analysis and extensions of RELIEF", "author": ["I. Kononenko"], "venue": "In Proceedings of the European conference on machine learning on Machine Learning,", "citeRegEx": "Kononenko,? \\Q1994\\E", "shortCiteRegEx": "Kononenko", "year": 1994}, {"title": "Cleansing data for mining and warehousing", "author": ["M. Lee", "H. Lu", "T. Ling", "Y. Ko"], "venue": "In Proceedings of the 10th International Conference on Database and Expert Systems Applications,", "citeRegEx": "Lee et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Lee et al\\.", "year": 1999}, {"title": "AST: Support for algorithm selection with a CBR approach", "author": ["G. Lindner", "R. Studer"], "venue": "Principles of Data Mining and Knowledge Discovery,", "citeRegEx": "Lindner and Studer,? \\Q1999\\E", "shortCiteRegEx": "Lindner and Studer", "year": 1999}, {"title": "Feature Selection: An Ever Evolving Frontier in Data Mining", "author": ["H. Liu", "H. Motoda", "R. Setiono", "Z. Zhao"], "venue": "In The Fourth Workshop on Feature Selection in Data Mining,", "citeRegEx": "Liu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2010}, {"title": "A probabilistic approach to feature selection-a filter solution", "author": ["H. Liu", "R. Setiono"], "venue": null, "citeRegEx": "Liu and Setiono,? \\Q1996\\E", "shortCiteRegEx": "Liu and Setiono", "year": 1996}, {"title": "Toward integrating feature selection algorithms for classification and clustering", "author": ["H. Liu", "L. Yu"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "Liu and Yu,? \\Q2005\\E", "shortCiteRegEx": "Liu and Yu", "year": 2005}, {"title": "Machine learning, neural and statistical classification", "author": ["D. Michie", "D.J. Spiegelhalter", "C.C. Taylor"], "venue": null, "citeRegEx": "Michie et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Michie et al\\.", "year": 1994}, {"title": "Feature selection algorithms: A survey and experimental evaluation", "author": ["L.C. Molina", "L. Belanche", "\u00c0. Nebot"], "venue": "In Proceedings of IEEE International Conference on Data Mining,", "citeRegEx": "Molina et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Molina et al\\.", "year": 2002}, {"title": "Development of multi-criteria metrics for evaluation of data mining algorithms", "author": ["G. Nakhaeizadeh", "A. Schnabl"], "venue": "In Proceedings of the 3rd International Conference on Knowledge Discovery and Data mining,", "citeRegEx": "Nakhaeizadeh and Schnabl,? \\Q1997\\E", "shortCiteRegEx": "Nakhaeizadeh and Schnabl", "year": 1997}, {"title": "Towards the personalization of algorithms evaluation in data mining", "author": ["G. Nakhaeizadeh", "A. Schnabl"], "venue": "In Proceedings of the 4th International Conference on Knowledge Discovery and Data mining,", "citeRegEx": "Nakhaeizadeh and Schnabl,? \\Q1998\\E", "shortCiteRegEx": "Nakhaeizadeh and Schnabl", "year": 1998}, {"title": "Floating search methods in feature selection", "author": ["P. Pudil", "J. Novovi\u010dov\u00e1", "J. Kittler"], "venue": "Pattern recognition letters,", "citeRegEx": "Pudil et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Pudil et al\\.", "year": 1994}, {"title": "Conceptual base of feature selection consulting", "author": ["P. Pudil", "J. Novovi\u010dov\u00e1", "P. Somol", "R. Vr\u0148ata"], "venue": "system. Kybernetika,", "citeRegEx": "Pudil et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Pudil et al\\.", "year": 1998}, {"title": "Feature selection expertuser oriented approach", "author": ["P. Pudil", "J. Novovi\u010dov\u00e0", "P. Somol", "R. Vr\u0148ata"], "venue": "Advances in Pattern Recognition,", "citeRegEx": "Pudil et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Pudil et al\\.", "year": 1998}, {"title": "C4.5: programs for machine learning", "author": ["J.R. Quinlan"], "venue": null, "citeRegEx": "Quinlan,? \\Q1993\\E", "shortCiteRegEx": "Quinlan", "year": 1993}, {"title": "Theoretical and empirical analysis of relieff and rrelieff", "author": ["M. Robnik-\u0160ikonja", "I. Kononenko"], "venue": "Machine learning,", "citeRegEx": "Robnik.\u0160ikonja and Kononenko,? \\Q2003\\E", "shortCiteRegEx": "Robnik.\u0160ikonja and Kononenko", "year": 2003}, {"title": "A review of feature selection techniques", "author": ["Y. Saeys", "I. Inza", "P. Larra\u00f1aga"], "venue": "in bioinformatics. Bioinformatics,", "citeRegEx": "Saeys et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Saeys et al\\.", "year": 2007}, {"title": "Cross-disciplinary perspectives on meta-learning for algorithm selection", "author": ["K.A. Smith-Miles"], "venue": "ACM Computing Surveys,", "citeRegEx": "Smith.Miles,? \\Q2008\\E", "shortCiteRegEx": "Smith.Miles", "year": 2008}, {"title": "Meta analysis of classification algorithms for pattern recognition", "author": ["S.Y. Sohn"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "Sohn,? \\Q1999\\E", "shortCiteRegEx": "Sohn", "year": 1999}, {"title": "Automatic recommendation of classification algorithms based on data set characteristics", "author": ["Q.B. Song", "G.T. Wang", "C. Wang"], "venue": "Pattern Recognition,", "citeRegEx": "Song et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Song et al\\.", "year": 2012}, {"title": "A perspective view and survey of meta-learning", "author": ["R. Vilalta", "Y. Drissi"], "venue": "Artificial Intelligence Review,", "citeRegEx": "Vilalta and Drissi,? \\Q2002\\E", "shortCiteRegEx": "Vilalta and Drissi", "year": 2002}, {"title": "The supervised learning no-free-lunch theorems", "author": ["D.H. Wolpert"], "venue": "In Proceedings of 6th Online World Conference on Soft Computing in Industrial Applications,", "citeRegEx": "Wolpert,? \\Q2001\\E", "shortCiteRegEx": "Wolpert", "year": 2001}, {"title": "Feature selection for high-dimensional data: A fast correlationbased filter solution", "author": ["L. Yu", "H. Liu"], "venue": "In Proceedings of The Twentieth International Conference on Machine Leaning,", "citeRegEx": "Yu and Liu,? \\Q2003\\E", "shortCiteRegEx": "Yu and Liu", "year": 2003}, {"title": "Searching for interacting features", "author": ["Z. Zhao", "H. Liu"], "venue": "In Proceedings of the 20th International Joint Conference on Artifical Intelligence,", "citeRegEx": "Zhao and Liu,? \\Q2007\\E", "shortCiteRegEx": "Zhao and Liu", "year": 2007}, {"title": "A heuristic-statistical feature selection criterion for inductive machine learning in the real world", "author": ["X. Zhou", "T. Dillon"], "venue": "In Proceedings of the IEEE International Conference on Systems, Man, and Cybernetics,", "citeRegEx": "Zhou and Dillon,? \\Q1988\\E", "shortCiteRegEx": "Zhou and Dillon", "year": 1988}], "referenceMentions": [{"referenceID": 21, "context": "Experiments (Hall, 1999; Zhao & Liu, 2007) have confirmed that there could exist significant differences of performance (e.", "startOffset": 12, "endOffset": 42}, {"referenceID": 5, "context": "However, this solution is quite time-consuming especially for highdimensional data (Brodley, 1993).", "startOffset": 83, "endOffset": 98}, {"referenceID": 21, "context": "However, the published FSS algorithms are rarely tested on the identical group of data sets (Hall, 1999; Zhao & Liu, 2007; Yu & Liu, 2003; Dash & Liu, 2003; Kononenko, 1994).", "startOffset": 92, "endOffset": 173}, {"referenceID": 30, "context": "However, the published FSS algorithms are rarely tested on the identical group of data sets (Hall, 1999; Zhao & Liu, 2007; Yu & Liu, 2003; Dash & Liu, 2003; Kononenko, 1994).", "startOffset": 92, "endOffset": 173}, {"referenceID": 50, "context": "2) At the same time, the famous NFL (No Free Lunch) (Wolpert, 2001) theory tells us that, for a particular data set, different algorithms have different data-conditioned performance, and the performance differences vary with data sets.", "startOffset": 52, "endOffset": 67}, {"referenceID": 46, "context": "The recommendation process can be viewed as a specific application of meta-learning (Vilalta & Drissi, 2002; Brazdil, Carrier, Soares, & Vilalta, 2008) that has been used to recommend algorithms for classification problems (Ali & Smith, 2006; King, Feng, & Sutherland, 1995; Brazdil, Soares, & Da Costa, 2003; Kalousis, Gama, & Hilario, 2004; Smith-Miles, 2008; Song, Wang, & Wang, 2012).", "startOffset": 223, "endOffset": 387}, {"referenceID": 26, "context": "In this paper, the meta-features, which are frequently used in meta-learning (Vilalta & Drissi, 2002; Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Castiello, Castellano, & Fanelli, 2005), are employed to characterize data sets.", "startOffset": 77, "endOffset": 201}, {"referenceID": 4, "context": "In this paper, the meta-features, which are frequently used in meta-learning (Vilalta & Drissi, 2002; Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Castiello, Castellano, & Fanelli, 2005), are employed to characterize data sets.", "startOffset": 77, "endOffset": 201}, {"referenceID": 6, "context": "The meta-features should be not only conveniently and efficiently calculated, but also related to the performance of machine learning algorithms (Castiello et al., 2005).", "startOffset": 145, "endOffset": 169}, {"referenceID": 4, "context": "A number of meta-features have been employed to characterize data sets (Brazdil et al., 2003; Castiello et al., 2005; Michie et al., 1994; Engels & Theusinger, 1998; Gama & Brazdil, 1995; Lindner & Studer, 1999; Sohn, 1999), and have been demonstrated working well in modeling the relationship between the characteristics of data sets and the performance (e.", "startOffset": 71, "endOffset": 223}, {"referenceID": 6, "context": "A number of meta-features have been employed to characterize data sets (Brazdil et al., 2003; Castiello et al., 2005; Michie et al., 1994; Engels & Theusinger, 1998; Gama & Brazdil, 1995; Lindner & Studer, 1999; Sohn, 1999), and have been demonstrated working well in modeling the relationship between the characteristics of data sets and the performance (e.", "startOffset": 71, "endOffset": 223}, {"referenceID": 36, "context": "A number of meta-features have been employed to characterize data sets (Brazdil et al., 2003; Castiello et al., 2005; Michie et al., 1994; Engels & Theusinger, 1998; Gama & Brazdil, 1995; Lindner & Studer, 1999; Sohn, 1999), and have been demonstrated working well in modeling the relationship between the characteristics of data sets and the performance (e.", "startOffset": 71, "endOffset": 223}, {"referenceID": 47, "context": "A number of meta-features have been employed to characterize data sets (Brazdil et al., 2003; Castiello et al., 2005; Michie et al., 1994; Engels & Theusinger, 1998; Gama & Brazdil, 1995; Lindner & Studer, 1999; Sohn, 1999), and have been demonstrated working well in modeling the relationship between the characteristics of data sets and the performance (e.", "startOffset": 71, "endOffset": 223}, {"referenceID": 26, "context": ", classification accuracy) of learning algorithms (Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Kalousis et al., 2004; Smith-Miles, 2008).", "startOffset": 50, "endOffset": 152}, {"referenceID": 4, "context": ", classification accuracy) of learning algorithms (Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Kalousis et al., 2004; Smith-Miles, 2008).", "startOffset": 50, "endOffset": 152}, {"referenceID": 25, "context": ", classification accuracy) of learning algorithms (Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Kalousis et al., 2004; Smith-Miles, 2008).", "startOffset": 50, "endOffset": 152}, {"referenceID": 46, "context": ", classification accuracy) of learning algorithms (Ali & Smith, 2006; King et al., 1995; Brazdil et al., 2003; Kalousis et al., 2004; Smith-Miles, 2008).", "startOffset": 50, "endOffset": 152}, {"referenceID": 6, "context": "The most commonly used meta-features are established focusing on the following three aspects of a data set: i) general properties, ii) statistic-based properties, and iii) informationtheoretic based properties (Castiello et al., 2005).", "startOffset": 210, "endOffset": 234}, {"referenceID": 4, "context": "Actually, a multi-criteria metric adjusted ratio of ratios (ARR) (Brazdil et al., 2003), which combines classification accuracy and runtime together as a unified metric, has been proposed to evaluate the performance of a learning algorithm.", "startOffset": 65, "endOffset": 87}, {"referenceID": 3, "context": "In order to effectively calculate the distance between two data sets, the L1 norm distance (Atkeson, Moore, & Schaal, 1997) is adopted since it is easy to understand and calculate, and its ability in measuring the similarity between two data sets has been demonstrated by Brazdil et al. (2003). Let Fi = <fi,1, fi,2, \u00b7 \u00b7 \u00b7 , fi,h> be the meta-features of data set Di, where fi,p is the value of pth feature of Fi and h is the length of the meta-features.", "startOffset": 272, "endOffset": 294}, {"referenceID": 37, "context": "FSS algorithms can be grouped into two broad categories: Wrapper and Filter (Molina et al., 2002; Kohavi & John, 1997).", "startOffset": 76, "endOffset": 118}, {"referenceID": 17, "context": "iv) Genetic search (GS): A randomized search method which performs using a simple genetic algorithm (Goldberg, 1989).", "startOffset": 100, "endOffset": 116}, {"referenceID": 2, "context": "vi) Rank search (RS) (Battiti, 1994): It uses a feature evaluator (such as gain ratio) to rank all the features.", "startOffset": 21, "endOffset": 36}, {"referenceID": 30, "context": "xii) Ranker (Kononenko, 1994; Kira & Rendell, 1992; Liu & Setiono, 1995): It evaluates each feature individually and ranks the features by the values of their evaluation metrics.", "startOffset": 12, "endOffset": 72}, {"referenceID": 21, "context": "ii) Dependency (Hall, 1999; Yu & Liu, 2003): This kind of measure evaluates the worth of a subset of features by considering the individual predictive ability of each feature along with the degree of redundancy among these features.", "startOffset": 15, "endOffset": 43}, {"referenceID": 30, "context": "iii) Distance (Kira & Rendell, 1992; Kononenko, 1994): This kind of measure is proposed based on the assumption that the distance of instances from different target concepts is greater than that from same target concepts.", "startOffset": 14, "endOffset": 53}, {"referenceID": 49, "context": "0001 suggested by Zhao and Liu (2007). For FSS algorithm \u201cFCBF\u201d, we set the relevance threshold to be the SU (Symmetric Uncertainty) value of the bN/ log Ncth ranked feature suggested by Yu and Liu (2003).", "startOffset": 18, "endOffset": 38}, {"referenceID": 49, "context": "For FSS algorithm \u201cFCBF\u201d, we set the relevance threshold to be the SU (Symmetric Uncertainty) value of the bN/ log Ncth ranked feature suggested by Yu and Liu (2003). For FSS algorithm \u201cRelief-F\u201d, we set the significance threshold to 0.", "startOffset": 148, "endOffset": 166}, {"referenceID": 30, "context": "01 used by Robnik-\u0160ikonja and Kononenko (2003). For FSS algorithm \u201cSignific\u201d, there is a threshold, statistical significance level \u03b1, used to identify the irrelevant features.", "startOffset": 30, "endOffset": 47}, {"referenceID": 43, "context": "5 (Quinlan, 1993), rule-based PART (Frank & Witten, 1998), and instance-based IB1 (Aha, Kibler, & Albert, 1991), respectively.", "startOffset": 2, "endOffset": 17}, {"referenceID": 14, "context": "esis that the features are conditional independent (John & Langley, 1995), while Bayes Net takes into account the feature interaction (Friedman et al., 1997).", "startOffset": 134, "endOffset": 157}, {"referenceID": 28, "context": "For each data set Di (1 \u2264 i \u2264 115), we i) extract its meta-features Fi; ii) calculate the EARRs for the 22 candidate FSS algorithms with the stratified 5\u00d710-fold cross-validation strategy (Kohavi, 1995), and iii) combine the meta-features Fi and the EARR of each FSS algorithm together to form a tuple, which is finally added to the meta-knowledge database.", "startOffset": 188, "endOffset": 202}, {"referenceID": 13, "context": "The optimal FSS algorithm set for a given data set Di is obtained via a non-parametric Friedman test (1937) followed by a Holm procedure test (1988) on the performance, which", "startOffset": 87, "endOffset": 108}, {"referenceID": 13, "context": "The optimal FSS algorithm set for a given data set Di is obtained via a non-parametric Friedman test (1937) followed by a Holm procedure test (1988) on the performance, which", "startOffset": 87, "endOffset": 149}, {"referenceID": 10, "context": "Non-parametric statistical test, Friedman test followed by Holm procedure test as suggested by Dem\u0161ar (2006), can be used for this purpose.", "startOffset": 95, "endOffset": 109}], "year": 2013, "abstractText": "Many feature subset selection (FSS) algorithms have been proposed, but not all of them are appropriate for a given feature selection problem. At the same time, so far there is rarely a good way to choose appropriate FSS algorithms for the problem at hand. Thus, FSS algorithm automatic recommendation is very important and practically useful. In this paper, a meta learning based FSS algorithm automatic recommendation method is presented. The proposed method first identifies the data sets that are most similar to the one at hand by the k -nearest neighbor classification algorithm, and the distances among these data sets are calculated based on the commonly-used data set characteristics. Then, it ranks all the candidate FSS algorithms according to their performance on these similar data sets, and chooses the algorithms with best performance as the appropriate ones. The performance of the candidate FSS algorithms is evaluated by a multi-criteria metric that takes into account not only the classification accuracy over the selected features, but also the runtime of feature selection and the number of selected features. The proposed recommendation method is extensively tested on 115 real world data sets with 22 wellknown and frequently-used different FSS algorithms for five representative classifiers. The results show the effectiveness of our proposed FSS algorithm recommendation method.", "creator": " TeX output 2013.05.02:0946"}}}