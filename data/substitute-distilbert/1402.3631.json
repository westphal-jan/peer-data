{"id": "1402.3631", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Feb-2014", "title": "Privately Solving Linear Programs", "abstract": "in similar paper, we initiate the systematic study of solving linear programs and differential privacy. the first step is simply to define hidden problem : to this end, we introduce several natural classes of private linear programs that capture possible ways sensitive data can be incorporated into a linear equation. throughout each class of linear programs we give an indirect, differentially private solver based on the multiplicative identity framework, or we give an impossibility result.", "histories": [["v1", "Sat, 15 Feb 2014 00:55:46 GMT  (41kb)", "https://arxiv.org/abs/1402.3631v1", null], ["v2", "Thu, 8 May 2014 19:52:34 GMT  (41kb)", "http://arxiv.org/abs/1402.3631v2", null]], "reviews": [], "SUBJECTS": "cs.DS cs.CR cs.LG", "authors": ["justin hsu", "aaron roth", "tim roughgarden", "jonathan ullman"], "accepted": false, "id": "1402.3631"}, "pdf": {"name": "1402.3631.pdf", "metadata": {"source": "CRF", "title": "Privately Solving Linear Programs", "authors": ["Justin Hsu", "Aaron Roth", "Tim Roughgarden", "Jonathan Ullman"], "emails": ["aaroth@cis.upenn.edu.", "jullman@seas.harvard.edu."], "sections": [{"heading": null, "text": "ar X\niv :1\n40 2.\n36 31\nv2 [\ncs .D\nS] 8\nM ay\n2 01\n\u2217Department of Computer and Information Science, University of Pennsylvania. Supported in part by NSF Grant CNS-1065060.\n\u2020Department of Computer and Information Science, University of Pennsylvania. Supported in part by an NSF CAREER award, NSF Grants CCF-1101389 and CNS-1065060, and a Google Focused Research Award. Email: aaroth@cis.upenn.edu.\n\u2021Department of Computer Science, Stanford University. Supported in part by NSF Awards CCF-1016885 and CCF-1215965, and an ONR PECASE Award.\n\u00a7School of Engineering and Applied Sciences and Center for Research on Computation and Society, Harvard University. Supported by NSF grant CNS-1237235. Email: jullman@seas.harvard.edu.\nContents"}, {"heading": "1 Introduction 2", "text": "1.1 Our Results and Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5"}, {"heading": "2 Differential Privacy Preliminaries 6", "text": ""}, {"heading": "3 Constraint Private LPs 8", "text": "3.1 Solving LPs with Dense Multiplicative Weights . . . . . . . . . . . . . . . . . . . . . 9 3.2 Achieving Constraint Privacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.3 Private Fractional Set Cover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13"}, {"heading": "4 Low-Sensitivity LPs 15", "text": "4.1 Solving LPs with Multiplicative Weights . . . . . . . . . . . . . . . . . . . . . . . . . 15 4.2 Scalar-Private LPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 4.3 Row/Matrix-Private LPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 4.4 Column Private LPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 4.5 Objective Private LPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23"}, {"heading": "5 Lower Bounds 24", "text": "5.1 High-Sensitivity Scalars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 5.2 High-Sensitivity Objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 5.3 High-Sensitivity Constraints/Columns . . . . . . . . . . . . . . . . . . . . . . . . . . 26"}, {"heading": "6 Discussion 27", "text": ""}, {"heading": "1 Introduction", "text": "Linear programming is one of the most fundamental and powerful tools in algorithmic design. It is used ubiquitously throughout computer science: applications include maximum matching, maximum and minimum cost flow, and fractional packing and covering problems. Linear programming relaxations of NP-complete problems also underlie countless efficient approximation algorithms.\nAt the same time, differential privacy is a field where efficient algorithms have been difficult to find. For many problems in differential privacy, the initial focus was on understanding the information-theoretic complexity\u2014the extent to which solving the problem, efficiently or not, is compatible with differential privacy. As a result, there are many central problems that are known to be privately solvable, but for which computationally efficient algorithms are not known. For example, Kasiviswanathan et al. [19] show how to privately PAC learn any PAC learnable concept class (without privacy) with only a small increase in the sample complexity, but via an exponential time algorithm. It remains open whether a computationally efficient algorithm can do this in general. Similarly, Blum et al. [4] show how to privately release a summary of a private database that approximately preserves the answers to rich families of linear queries, again via an exponential time algorithm. In fact, under standard cryptographic assumptions, it is not possible to efficiently and privately answer large collections of general linear queries [10, 28, 27].\nThe two preceding examples are among the many algorithms that use the extremely general exponential mechanism of McSherry and Talwar [23] to achieve near optimal error. However, the exponential mechanism is not efficient in general: it requires running time linear in the size of its output range, which can be extremely large. In contrast, general tools for designing efficient differentially private algorithms are harder to come by (although not non-existent, e.g., the sample and aggregate framework [24] and output/objective perturbation for unconstrained convex optimization [6, 21]).\nOur work contributes to the toolbox of general algorithmic techniques for designing computationally efficient and differentially private algorithms; specifically, we give tools to privately and efficiently solve linear programs (LPs) of various types. An initial problem is to simply define what it means to solve a linear program privately. Differential privacy is defined in terms of neighboring databases. A database is a collection of records from some domain and two databases are neighboring if they differ in a single record. Differential privacy requires the output distribution of an algorithm to be nearly identical when run on either of a pair of neighboring databases. If linear programs can depend on private databases, we naturally have a notion of neighboring linear programs, and we want an algorithm for solving these linear programs that is differentially private with respect to this notion of neighboring inputs.\nThe way in which the linear program is derived from the database gives rise to several distinct notions of neighboring linear programs. For instance, consider an LP with objective c\u22a4x and constraints Ax \u2264 b, where moving to a neighboring LP neighboring database leaves c and A unchanged but perturbs b by only a small amount in each coordinate. Solving this kind of linear programming privately is similar to the well-studied linear query release problem in differential privacy, and techniques for linear query release\u2014such as the private multiplicative weights algorithm of Hardt and Rothblum [15] (and its offline variants [14, 16])\u2014can be adapted with minor changes. (This result may even be considered folklore.) On the other hand, the situation is qualitatively different if moving to a neighboring LP can change either the constraint matrix A or the objective vector c. Some of these private LPs can still be solved; others are provably impossible to solve to nontrivial accuracy under differential privacy.\nIn this paper, we develop a taxonomy of private LPs. For each class, we either present an efficient and accurate differentially private solver, or prove that general LPs of this type cannot be accurately solved while preserving privacy."}, {"heading": "1.1 Our Results and Techniques", "text": "We consider linear programs LP (D) defined by a database D, with form\nmax x\u2208Rd+\nc\u22a4x\ns.t. Ax \u2264 b.\nHere, the vector x represents the variables of the linear program, and c = c(D), A = A(D), and b = b(D) may each depend on the private database D. Our goal is to find an approximate solution to LP (D) in a sense to be defined, while ensuring differential privacy for the underlying database D.\nWe classify private LPs along two dimensions: which part of the LP depends on the database and how sensitive the LP is to changes in the database. Along the second axis, we will consider: 1)\nlow-sensitivity LPs, where changing one record of the database induces a small difference between coefficients that vanishes as the size of the database n grows and 2) high-sensitivity LPs, where changing one record of the database can induce a potentially large change in some coefficient. Lowsensitivity LPs are natural when the coefficients of the LP represent some kind of average over the database, whereas high-sensitivity LPs are natural when the coefficients represent specific records of the database.\nFurthermore, we consider four parts of the LP that might depend on the database: 1) the rows of A, 2) the scalars b, 3) the columns of A, and 4) the objective c. These four parts of the LP, combined with the two notions of sensitivity, lead to the following eight notions of private linear programming:\n1. The constraints: For these linear programs, moving to a neighboring database can affect at most one row of A and the corresponding entry of b, which corresponds to changing one constraint of the LP.\n(a) High-sensitivity: For high-sensitivity constraint private LPs (Section 3), moving to a neighboring database can change a single constraint arbitrarily. That is, for every pair of neighboring databases D,D\u2032, there exists a row i such that for every row j 6= i, A(D)j = A(D \u2032)j and b(D)j = b(D \u2032)j . This kind of linear program arises, for example,\nin covering LPs in which each record of the database represents an individual that needs to be covered. We cannot hope to approximately satisfy every constraint while ensuring privacy,1 but we show that by using a variant of multiplicative weights that operates only over a restricted set of distributions, we can still find solutions to such LPs that approximately satisfy most of the constraints. As an example of our technique, we solve a private version of the fractional set cover problem.\n(b) Low-sensitivity: For low-sensitivity constraint private LPs (Section 4.3), moving to a neighboring database can change a single row of A by a small amount in each entry\u2014 for some row i, \u2016Ai(D) \u2212 Ai(D\u2032)\u2016\u221e \u2264 1/n. We show how to solve these LPs using multiplicative weights; our techniques work equally well if the entire constraint matrix can change on neighboring problems (we will sometimes call these low-sensitivity matrix or row private LPs).\n2. The scalars: For these linear programs, c and A are fixed and moving to a neighboring database only affects b = b(D).\n(a) High-sensitivity: For high-sensitivity scalar private LPs, for every neighboring D,D\u2032, there is a row i such that for every j 6= i, b(D)j = b(D\u2032)j . We show that in general, such LPs cannot be solved privately.\n(b) Low-sensitivity: For low-sensitivity scalar private LPs, moving to a neighboring database can change every entry in b slightly, such that \u2016b(D)\u2212 b(D\u2032)\u2016\u221e \u2264 1/n. These LPs capture the private linear query release problem, so we will sometimes refer to them as query release LPs. In this problem, the database is viewed as a histogram D \u2208 Nd+ and\n1For example, given a solution x to LP (D), we can always derive a new constraint (Ai, bi) that is far from being satisfied by x. If we introduce this new constraint in a neighboring linear program LP (D\u2032), by the differential privacy condition, this new constraint must also be far from being satisfied in LP (D\u2032) with high probability.\nthe objective is to find a synthetic database x \u2208 Rd+ such that for every linear query q in some family, \u3008q, x\u3009 \u2248 \u3008q,D\u3009. We show how to adapt existing techniques for this problem and derive resulting accurate solvers for LPs of this form (Section 4.2).\n3. One column in A: For these linear programs, moving to a neighboring database can affect at most one column of A.\nThese LPs arise literally as the dual linear programs of row private LPs. For example, in a LP where variables represent different tasks, the private coefficients corresponding to a single variable may represent the amount of resources needed for that task. Then, a packing LP seeks to maximize some objective subject to resource constraints.\n(a) High-sensitivity: For high-sensitivity column private LPs, for every neighboringD,D\u2032, the matrices A(D), A(D\u2032) are arbitrarily different in a single column, and identical in all other columns. We show that in general, such LPs cannot be solved privately (Section 5.3).\n(b) Low-sensitivity: For low-sensitivity column private LPs, moving to a neighboring database can change every entry in a single column of A by a small amount. More generally, if Ai is the ith row of A, then \u2016A(D)i \u2212A(D\u2032)i\u20161 \u2264 1/n for each i. We show how to use these LPs using multiplicative weights (Section 4.4).\n4. The objective: For these linear programs, moving to a neighboring database can affect the objective c. The scalars b and constraints A remain unchanged.\n(a) High-sensitivity: For high-sensitivity objective private LPs, for every neighboring D,D\u2032, a single entry of the objective c(D), c(D\u2032) can change arbitrarily. We show that in general, such LPs cannot be solved privately (Section 5.2).\n(b) Low-sensitivity: For low-sensitivity objective private LPs, for every neighboring D,D\u2032, the objective vectors c(D), c(D\u2032) satisfy \u2016c(D) \u2212 c(D\u2032)\u20161 \u2264 1/n. This kind of linear program can be solved inefficiently to high accuracy by selecting from the set of vertices of the feasible polytope with the exponential mechanism; we show that linear programs in this class can also be solved efficiently and accurately, by directly using randomized response (Section 4.5).\nThis taxonomy is summarized in Table 1. We will formally define accuracy, but roughly speaking, an accurate solution satisfies each constraint to within additive \u03b1, and has objective within additive \u03b1 of optimal (when there is an objective). The exception is constraint privacy (indicated by the asterisk), where our algorithm finds a solution that satisfies only most of the constraints to within additive \u03b1, and may violate the other constraints arbitrarily."}, {"heading": "1.2 Related Work", "text": "Differential privacy emerged from a line of work initiated by Dinur and Nissim [7], was defined by Dwork et al. [9], and is now a standard definition of privacy in computer science. Below, we discuss relevant results in differential privacy; the survey by Dwork [8] is an excellent source for a more comprehensive overview.\nPrivate optimization has been studied since the work of Blum et al. [3] and Kasiviswanathan et al. [19], who considered how to choose an optimal classifier privately. Blum et al. [3] give an efficient reduction from SQ learning to private SQ learning, and Kasiviswanathan et al. [19] give a very general but inefficient reduction from PAC learning to private PAC learning using the exponential mechanism of McSherry and Talwar [23]. Private learning was placed explicitly into an optimization framework by Chaudhuri et al. [6], who give two techniques for privately solving certain unconstrained convex optimization problems. Gupta et al. [12] give several algorithms for problems in private combinatorial optimization, but these were specialized combinatorial algorithms for specific problems.\nIn parallel, a line of work initiated by Blum et al. [4] and continuing with Dwork et al. [10], Roth and Roughgarden [26], Dwork et al. [11], Hardt and Rothblum [15], Gupta et al. [14], Hardt et al. [16] study the problem of privately producing synthetic data consistent with some private database on many linear queries. (Of particular note is the private multiplicative weights mechanism of Hardt and Rothblum [15], which achieves the optimal accuracy and running time bounds [27, 5].) This problem can be represented as a linear program with queries defining constraints, and indeed, the private multiplicative weights algorithm of Hardt and Rothblum [15] can be directly applied to solve this kind of linear program. This observation motivates our current investigation.\nOur algorithms are mostly based on different variants of the multiplicative weights method of solving linear programs, which was introduced by Plotkin et al. [25] (see the excellent survey by Arora et al. [2] for more details). Whereas Plotkin et al. [25] maintain a distribution over the dual variables with multiplicative weights, depending on the kind of linear program we are solving, we either maintain a distribution over the dual variables or the primal variables. To solve constraint private LPs, we use a combination of the multiplicative weights update method and Bregman projections [2]\u2014Hsu et al. [18] use a similar version of this technique in designing analyst private mechanisms."}, {"heading": "2 Differential Privacy Preliminaries", "text": "Differential privacy is a strong notion of privacy, first introduced by Dwork et al. [9]. In the typical setting, we consider a database as a multisets of records, each belonging to a single individual. Then, a randomized function from databases to an output range satisfies differential privacy if, for any change in a single record of the input database, the distribution on outputs remains roughly the same. More formally, we have the following definition.\nDefinition 1 (Dwork et al. [9]). Let \u01eb > 0 and 0 \u2264 \u03b4 < 1 be given. A randomized function M : D \u2192 R mapping databases to an output range is (\u01eb, \u03b4)-differentially private if for every subset\nS \u2286 R and for every pair of database D,D\u2032 that differ in a single record,\nPr[M(D) \u2208 S] \u2264 e\u01eb Pr[M(D\u2032) \u2208 S] + \u03b4.\nWhen \u03b4 = 0, we will say that M is \u01eb-differentially private.\nWe will use two basic mechanisms from differential privacy: the Laplace mechanism and the exponential mechanism. The Laplace mechanism privately releases a number by adding noise drawn from the Laplace distribution.\nDefinition 2 (Dwork et al. [9]). Let \u01eb > 0 be given. A function f : D \u2192 R is \u2206-sensitive if for every pair of database D,D\u2032 that differ in a single record,\n|f(D)\u2212 f(D\u2032)| \u2264 \u2206.\nThe Laplace mechanism applied to a \u2206-sensitive function releases\nf(D) + \u03bd,\nwhere \u03bd is a draw from the Laplace distribution with parameter \u01eb/\u2206; that is, with probability density function\nF (\u03bd) = \u01eb\n2\u2206 exp\n( \u2212|\u03bd|\u01eb\n\u2206\n) .\nThe Laplace mechanism is \u01eb-differentially private and satisfies the following tail bound, which is also an accuracy guarantee for the Laplace mechanism.\nLemma 3. Let \u03b2 \u2208 (0, 1) be given, and let \u03bd be drawn from the Laplace distribution with scale b. Then,\nPr[|\u03bd| \u2265 T ] \u2264 \u03b2 for T = 1 b log(1/\u03b2).\nWe will also use the exponential mechanism [23], which can privately produce a non-numeric or discrete output. The exponential mechanism is defined in terms of a quality score that maps a database and an element of the range to a real valued score. For a given a database, the exponential mechanism privately outputs an element of the range that approximately maximizes the quality score.\nDefinition 4 (McSherry and Talwar [23]). Let \u01eb > 0 be given, and suppose the quality score Q : R\u00d7D \u2192 R is \u2206-sensitive in the database. On database D, the \u01eb-private exponential mechanism with quality score Q outputs r \u2208 R with probability proportional to\nexp ( \u01eb 2\u2206 \u00b7Q(r,D) ) .\nThe exponential mechanism is \u01eb-differentially private, and satisfies the following accuracy guarantee.\nTheorem 5 (McSherry and Talwar [23]). Let \u03b2 \u2208 (0, 1) and the database D be given. Suppose that the maximum value of the quality score Q on database D is OPT. Then, the \u01eb-private exponential mechanism with quality score Q on D outputs r \u2208 R such that\nPr [ Q(r,D) \u2265 OPT\u22122\u2206\n\u01eb log ( |R| \u03b2 )] \u2265 1\u2212 \u03b2.\nTo combine these mechanisms, we will use standard composition theorems.\nTheorem 6 (Dwork et al. [11]). For any \u03b4 \u2208 (0, 1), the composition of k (adaptively chosen) \u01eb\u2032-private mechanisms is (\u01eb, \u03b4)-differentially private, for\n\u01eb\u2032 = \u01eb\u221a\n8k log(1/\u03b4) ."}, {"heading": "3 Constraint Private LPs", "text": "Let us begin by considering constraint private LPs, with the general form\nmax x\u2208K\nc\u22a4x\ns.t. Ax \u2264 b,\nwhere A \u2208 Rm\u00d7d, b \u2208 Rm, c \u2208 Rd, and K \u2286 Rd. We think of K as the easy constraints, those that are independent of the database, like non-negativity.\nLet KOPT = K \u2229 {x \u2208 Rd | c\u22a4x = OPT}. Then, the original LP can be solved approximately by repeatedly solving the feasibility problem\nfind x \u2208 KOPT s.t. Ax \u2264 b,\nbinary searching on the optimal objective value OPT.2 Thus, unless we specify otherwise, we will restrict our attention to feasibility LPs. Furthermore, since a linear program has a convex feasible region, K (and hence KOPT) are convex. From now on, we will write K for KOPT.\nRoughly, a private database D defines a linear program with objective vector c(D), constraint matrix A(D), and vector b(D), which we will call the scalars. In a constraint private LP, the objective c(D) = c(D\u2032) is independent of the data and for every two neighboring datasets D,D\u2032, the matrices A(D) and A(D\u2032) are exactly the same, except one matrix has an additional row that the other does not. The vectors b(D) and b(D\u2032) are also identical, except there is an entry corresponding to the different constraint in A in one b, but not the other. Then, we want a LP solver that satisfies the differential privacy guarantee with respect to this notion of adjacency. Formally:\nDefinition 7. A randomized algorithm M with inputs m \u2208 N, vector b \u2208 Rm, and matrix A \u2208 Rm\u00d7d and outputting a vector in Rd is (\u01eb, \u03b4)-high sensitivity constraint private if for any A,A\u2032 such that A\u2032 is equal to A with an additional row appended, and b, b\u2032 such that b\u2032 is equal to b with an additional entry, Pr[M(m, b,A) \u2208 S] \u2264 e\u01eb Pr[M(m+ 1, b\u2032, A\u2032) \u2208 S] + \u03b4 for any set S \u2286 Rd.\n2Binary search will incur an additional overhead in privacy, but in some situations may not be necessary: for instance, if a bound on the sensitivity of the optimal objective is known, we can solve the LP non-privately and estimate OPT with the Laplace mechanism."}, {"heading": "3.1 Solving LPs with Dense Multiplicative Weights", "text": "A standard approach to solving LPs is via no-regret algorithms. For a brief summary, these algorithms operate over a series of timesteps, selecting a single action at each step. Once the action is selected, the loss for each action is revealed (perhaps adversarially); the no-regret algorithm then adjusts to favor actions with less loss. While LPs can be solved using any no-regret algorithm, for concreteness we use the multiplicative weights update algorithm.\nThroughout, we will use calligraphic letters (A) to denote sets of actions, Roman letters (A) to denote measures on those actions A : A \u2192 [0, 1], and letters with tildes (A\u0303) to denote a probability distributions over actions. We will write |A| to mean the density of measure A, defined to be\u2211\na\u2208AAa. We will use a variant of the standard multiplicative weights algorithm that maintains a dense distribution over the set of constraints, i.e., a distribution that doesn\u2019t place too much probability on any action. We will call this algorithm, due to Herbster and Warmuth [17], the dense multiplicative weights algorithm (Algorithm 1). Roughly, the algorithm projects the MW distribution on actions into the set of dense distributions at each step. The loss at each step will be defined by a point that approximately satisfies the average constraint weighted by the MW distribution\u2014by capping the probability on any constraint, we ensure that this point can be selected privately even when a single constraint can change arbitrarily on neighboring instances.\nWe first define this projection step, also known as a Bregman projection.\nDefinition 8. Let s > 0. Given a measure A such that |A| \u2264 s, let \u0393sA be the (Bregman) projection of A into the set of 1/s-dense distributions, defined by \u0393sAa = 1 s \u00b7min{1, cAa} for every\na \u2208 A, where c \u2265 0 is such that s =\u2211a\u2208Amin{1, cAa}.\nThen, we can define the Dense Multiplicative Weights algorithm, which uses the standard multiplicative weights update rule combined with a Bregman projection into the set of dense distributions after each step.\nAlgorithm 1 The Dense Multiplicative Weights algorithm, DMWs,\u03b7 Let A1 be the uniform measure on A For t = 1, 2, . . . , T :\nLet B\u0303t = \u0393sA t Receive loss vector \u2113t (may depend on B1, . . . , Bt) Update: For each a \u2208 A:\nUpdate At+1a = e \u2212\u03b7\u2113taAta\nThen, dense multiplicative weights satisfies the following (regret) guarantee.3\nTheorem 9 (Herbster and Warmuth [17]). Let A1 be the uniform measure of density 1 and let{ B\u0303t } be the sequence of projected distributions obtained by DMWs,\u03b7 with arbitrary losses { \u2113t }\nsatisfying \u2016\u2113t\u2016\u221e \u2264 1 and \u03b7 \u2264 1/2. Let B\u0303\u2217 be the uniform distribution on some subset S\u2217 \u2286 A of 3Note that the regret guarantee is only with respect to dense distributions, rather than arbitrary distributions. This is a result of projecting the MW distribution to a dense distribution\u2014the algorithm may not be able to compete with non-dense distributions.\nsize s. Then,\n1\nT\nT\u2211\ni=1\n\u3008\u2113t, B\u0303t\u3009 \u2264 1 T\nT\u2211\ni=1\n\u3008\u2113t, B\u0303\u2217\u3009+ \u03b7 + log |A| \u03b7T .\nRecall we can assume that we know the optimal value OPT, so the objective can be represented as the constraint c\u22a4x = OPT. Hence, let K = {x \u2208 Rd+ | c\u22a4x = OPT} be the public feasible set. We will assume that there is a known, data-independent upper bound \u03c1 such that\n\u03c1 \u2265 max D max x\u2208K \u2016A(D)x \u2212 b(D)\u2016\u221e,\nwhich we call the width of the LP. We will define our algorithm in terms of an approximate oracle for solving a linear minization problem. (For a concrete example of such an oracle in the context of fractional set cover, see the next section.)\nDefinition 10. An (\u03b1, \u03b2)-approximate, \u03c1-bounded oracle, given a distribution y \u2208 Rm and matrix A \u2208 Rm\u00d7d, with probability at least 1\u2212 \u03b2 finds x\u2217 \u2208 Rd with\nm\u2211\ni=1\nyi(Ai \u00b7 x\u2217) \u2264 min x\u2208K\nm\u2211\ni=1\nyi(Ai \u00b7 x) + \u03b1\nand \u2016Ax\u2217 \u2212 b\u2016\u221e \u2264 \u03c1.\nTo solve linear programs, we use the dense multiplicative weights algorithm to maintain a distribution over the constraints, and pick points xt \u2208 K that best satisfy the weighted combination of constraints at each step. Intuitively, the losses will lead to more weight on violated constraints, leading to points that are more feasible. Taking the average of the points xt will yield an approximately feasible point, if it exists. See Algorithm 2 for the full algorithm.\nWe note that similar techniques for solving linear programs using multiplicative weights have been known since at least Plotkin et al. [25]; the novelty in our approach is that we use multiplicative weights paired with a projection onto the set of dense distributions, and show that the solution approximately satisfies most of the constraints. As we will see, the projection step is needed for privacy.\nTheorem 11. Let 0 < \u03b1 \u2264 9\u03c1, and let \u03b2 \u2208 (0, 1). Suppose there is a feasible solution of the linear program. Then with probability at least 1 \u2212 \u03b2, Algorithm 2 with density parameter s run with an (\u03b1/3, \u03b2/T )-approximate, \u03c1-bounded oracle finds a point x\u2217 in K such that there is a set of constraints S of size at most |S| < s, with Aix\u2217 \u2264 bi + \u03b1 for every i /\u2208 S.\nProof. By a union bound over T steps, the oracle succeeds on all steps with probability at least 1\u2212 \u03b2; condition on this event.\nLet Ks = {y \u2208 Rm | 1\u22a4y, \u2016y\u2016\u221e \u2264 1/s} be the set of 1/s-dense distributions. Then, y\u22a4Ax\u2217 \u2264 y\u22a4b for any y \u2208 Ks, so in particular the oracle finds xt with y\u22a4Axt < y\u22a4b+ \u03b1/3.\nThus, the loss vectors \u2113t = (1/2\u03c1)(b \u2212 Axt) + 1/2 satisfy \u2113t \u00b7 yt \u2265 1/2 \u2212 \u03b1/6\u03c1, which is at least \u22121 if \u03b1 \u2264 9\u03c1. Since the oracle is \u03c1-bounded, \u2113t \u00b7 yt \u2264 1. So, Theorem 9 applies; for p any point in\nAlgorithm 2 Solving for LP feasibility with dense multiplicative weights\nInput A \u2208 Rm\u00d7d, b \u2208 Rm. Let y\u03031 be the uniform distribution in Rm, \u03c1 \u2265 maxx\u2208K \u2016Ax\u2212 b\u2016\u221e be the width of the LP, s \u2208 N be the density parameter, and \u03b1 > 0 be the desired accuracy. Let Oracle be an (\u03b1, \u03b2)-accurate, \u03c1-bounded oracle, and set\n\u03b7 =\n\u221a logm\nT , T =\n36\u03c12 logm\n\u03b12 .\nFor t = 1, . . . , T : Find xt = Oracle(y\u0303t, A) Compute losses \u2113ti := (1/2\u03c1)(bi \u2212Ai \u00b7 xt) + 1/2. Update y\u0303t+1 from y\u0303t and \u2113t via dense multiplicative weights with density s. Output x = (1/T ) \u2211T\nt=1 x t.\nKs, we have the following bound:\n1 2 \u2212 \u03b1 6\u03c1 \u2264 1 T\nT\u2211\nt=1\n( \u2113t \u00b7 p ) + \u03b7 + logm\n\u03b7T\n= 1\nT\nT\u2211\nt=1\n( 1\n2\u03c1\n( b\u2212Axt ) + 1\n2\n) \u00b7 p+ \u03b7 + logm\n\u03b7T\nThus,\n\u2212 \u03b1 6\u03c1 \u2264 1 T\nT\u2211\nt=1\n1\n2\u03c1\n( b\u2212Axt ) \u00b7 p+ \u03b7 + logm\n\u03b7T .\nDefine x = (1/T ) \u2211T\nt=1 x t, and rearrange:\np\u22a4Ax \u2264 p\u22a4b+ 2\u03c1\u03b7 + 2\u03c1 logm \u03b7T + \u03b1 3 .\nBy our choice of \u03b7 and T , we get p\u22a4Ax \u2264 p\u22a4b+ \u03b1.\nSince this holds for any p \u2208 Ks, x satisfies all but s\u22121 constraints with error \u03b1\u2014if it didn\u2019t, letting p be the uniform distribution on the s violated constraints would give a contradiction."}, {"heading": "3.2 Achieving Constraint Privacy", "text": "Now, we will see how to make Algorithm 2 constraint private. First, the output point depends on the private data (the constraints A) only through the minimization step. Thus, if we can make the minimization private (in a certain sense), then each xt (and hence the final point x) will satisfy constraint privacy. Note that if the oracle privately minimizes over K, the final point x will automatically be in K since K is convex. Hence, we can also think of K as the public constraints, the ones that are always satisfied.\nTheorem 12. Let \u01eb, \u03b4, T > 0, and let\n\u01eb\u2032 = \u01eb\u221a\n8T log(1/\u03b4) .\nwith density parameter s \u2208 N. Suppose the oracle is \u01eb\u2032-private, where on neighboring instances the inputs (distributions) y\u0303, y\u0303\u2032 satisfy\n\u2016y\u0303\u2016\u221e \u2264 1/s, \u2016y\u0303\u2032\u2016\u221e \u2264 1/s, \u2016y\u0303 \u2212 y\u0303\u2032\u20161 \u2264 2/s,\nand the matrices A,A\u2032 are exactly the same except one has an additional row, and the vectors b, b\u2032 except one has a corresponding additional entry. Then, Algorithm 2 with density s is (\u01eb, \u03b4)-high sensitivity constraint private.\nProof. If the oracle is \u01eb\u2032-differentially private, then (\u01eb, \u03b4)-constraint privacy for the whole algorithm follows directly by composition (Theorem 6).\nTo show that the oracle is private when adding or removing a constraint from the LP, we know that A,A\u2032 are exactly the same except one has an extra row, and we know that \u2016y\u0303\u2016\u221e \u2264 1/s since we have projected into the set Ks. Hence, it only remains to check that neighboring y\u0303, y\u0303\u2032 satisfy \u2016y\u0303 \u2212 y\u0303\u2032\u20161 \u2264 2/s for each timestep t. We use a result about the sensitivity of Bregman projections from from Hsu et al. [18]; we reproduce the proof for completeness.\nLemma 13 (Hsu et al. [18]). Let s > 0 be given. Suppose A,A\u2032 be measures on sets A,A \u222a a\u2032 respectively, and identical on A. If A\u0303, A\u0303\u2032 are the respective Bregman projections into the set of 1/s-dense distributions, then \u2016A\u0303\u2212 A\u0303\u2032\u20161 \u2264 2/s. Here and below, we treat A,A\u2032 as supported on the same set with Aa\u2032 fixed at 0.\nProof. From the definition of the projection (Definition 8), it\u2019s clear that sA\u0303a \u2265 sA\u0303\u2032a for all a 6= a\u2032. We then have the following:\n\u2211\na\u2208A\u222aa\u2032\n|sA\u0303a \u2212 sA\u0303\u2032a| = |sA\u0303a\u2032 \u2212 sA\u0303\u2032a\u2032 |+ \u2211\na6=a\u2032\n|sA\u0303a \u2212 sA\u0303\u2032a|\n\u2264 1 + \u2211\na6=a\u2032\n|sA\u0303a \u2212 sA\u0303\u2032a|\n= 1 + \u2211\na6=a\u2032\nsA\u0303a \u2212 sA\u0303\u2032a\n= 1 + s|A\u0303\u2032| \u2212 s(|A\u0303\u2032| \u2212 A\u0303\u2032a\u2032) \u2264 1 + s\u2212 (s\u2212 1) = 2\nDividing through by s, we are done.\nSince y, y\u2032 are identical except for the weight corresponding to the differing constraint, we are done by the lemma.\nNow that we have presented our algorithm for solving LPs under constraint privacy, we give an example of how to instantiate the oracle and apply Theorem 11."}, {"heading": "3.3 Private Fractional Set Cover", "text": "We will consider the example of the fractional set cover LP, though our arguments extend to constraint private LPs with a private oracle that has low width. (For example, many covering and packing LPs satisfy this property.)\nSuppose there are d sets, each covering some subset of m people. Each set has a cost cS , and we wish to select the cheapest collection of sets that covers every person. We will consider the fractional relaxation of this problem, where instead of selecting whole sets for the cover, we can decide to select a fraction of each set, i.e., each set can be chosen to some non-negative degree, and the cost for set S is the degree to which it is open times cS . We again want the cheapest fractional collection of sets, such that at least weight 1 covers each person.4\nTo formulate this as a linear program, let the variables be x \u2208 Rd+; variable xS will be the degree that we choose set S in the cover. For the constraints, let Ai \u2208 {0, 1}m such that AiS is 1 exactly when set S covers i, otherwise 0.\nWe will assume that the optimal value OPT is known, and the goal is to compute an approximate fractional set covering x\u2217 corresponding to OPT. This is equivalent to solving the following linear program:\nfind: x \u2208 K s.t. Ai \u00b7 x \u2265 1 for each i\nwhere K = {x \u2208 Rd+ | c \u00b7 x = OPT} is the feasible region. We wish to achieve constraint privacy: if each individual corresponds to a covering constraint, then we want an approximate solution that is hides whether a person i needs to be covered or not. This is not always possible\u2014if each set contains just one person, then the presence of a set in any valid covering will reveal information about the people that need to be covered. Thus, we will find a solution violating a few constraints, so only covering most people.\nTo use our constraint private LP solver, we first define a private oracle solving the minimization problem\nO(y) = argmin x\u2208K\n\u2211\ni\nyi(Ai \u00b7 x).\nSince the oracle is minimizing a linear function, the optimal point lies at a vertex of K and is of the form\nx\u2217 = OPT\nci ei\nfor some i, where ei is the i\u2019th standard basis vector, i.e., all zeros except for a 1 in the i\u2019th coordinate. We can use the exponential mechanism to privately select this vertex.\nLemma 14. Let \u03b3 \u2208 (0, 1) be given. Suppose \u2016y\u2016\u221e \u2264 1/s, and suppose that \u2016y \u2212 y\u2032\u2016\u221e \u2264 2/s on adjacent inputs. Let O(y) be the \u01eb-private exponential mechanism over the vertices of K with quality score\nQ(j, y) = \u2211\ni\nyi ( Ai \u00b7 OPT\ncj ej \u2212 1\n) = OPT\ncj\n\u2211\ni\nyiaij \u2212 1.\n4To highlight the constraint private LP, we will only consider the fractional version. It is also possible to round the fractional solution to an integral solution (with slightly worse cost), since randomized rounding is independent of the private data.\nThen O is an (\u03b1, \u03b3)-approximate, \u03c1-bounded oracle, with\n\u03c1 = OPT cmin \u2212 1 and \u03b1 = 6OPT log d log(1/\u03b3) cmin \u00b7 s \u00b7 \u01eb .\nProof. The width of the oracle is clear: when returning a point x = OPTci ei,\nAi \u00b7 x\u2212 1 \u2264 OPT\ncmin \u2212 1.\nFor accuracy, note that the quality score Q has sensitivity at most\n\u2206 = 3OPT\ncmin \u00b7 s .\nWhy? On neighboring databases, there are two possible changes: first we may have |yi\u2212 y\u2032i| \u2264 2/s, and second we may have an extra term in the sum on one neighbor (since the sum is taken over all constraints, and one neighboring instance has an extra constraint). The first source contributes sensitivity 2OPT /(cmins), and since \u2016y\u2016\u221e, \u2016y\u2032\u2016\u221e \u2264 1/s, the second source contributes sensitivity OPT /(cmins).\nNow, since there are d possible outputs, the accuracy guarantee for the exponential mechanism (Theorem 5) shows that O selects a point with additive error at most\n\u03b1 = 2\u2206\n\u01eb log d log(1/\u03b3) =\n6OPT cmins\u01eb log d log(1/\u03b3)\nwith probability at least 1\u2212 \u03b3. Hence, we are done.\nNow, it follows that Algorithm 2 solves the private fractional set cover problem with the following accuracy guarantee.\nTheorem 15. Let \u03b2 \u2208 (0, 1). With probability at least 1 \u2212 \u03b2, Algorithm 2 with the exponential mechanism as an oracle (Lemma 14)\u2014where \u03c1 is the width of the oracle and \u03b1 \u2264 9\u03c1\u2014finds a point x\u2217 such that Aix \u2217 \u2265 1\u2212 \u03b1 except for at most s constraints i, where\ns = O\u0303\n( OPT2 log d log1/2 m log(1/\u03b2) log1/2(1/\u03b4)\nc2 \u00b7 \u03b12 \u00b7 \u01eb\n) .\nAlgorithm 2 is also \u01eb-high sensitivity constraint private.\nProof. Let \u01eb\u2032 be as in Theorem 12, and let \u03b3 = \u03b2/T with T as in Algorithm 2. Unfolding the definition of \u01eb\u2032 and \u03c1 and applying Lemma 14, the oracle gives accuracy\n6OPT cmins\u01eb\u2032 log d log(1/\u03b3) =\n96 \u221a 2OPT2 log d log1/2 m log(1/\u03b3) log1/2(1/\u03b4)\nc2min\u01ebs\u03b1\nwith probability at least 1 \u2212 \u03b3. Set this equal to \u03b1/3. By assumption \u03b1 \u2264 9\u03c1, so Theorem 11 applies: with probability at least 1\u2212 \u03b2, there is a set S of at most s constraints such Aix\u2217 \u2265 1\u2212\u03b1 for every i /\u2208 S, where\ns = O\n( OPT2 log d log1/2 m log(1/\u03b3) log1/2(1/\u03b4)\nc2 \u00b7 \u03b12 \u00b7 \u01eb\n) .\nand \u03b3 = \u03b2/T .\nRemark 16. A variant of the efficient private set cover problem has been investigated by Gupta et al. [12]. Our techniques are more general, but the solution we provide here has an imcomparable accuracy guarantee. We include this example to demonstrate how to use Algorithm 2 and Theorem 11. On the one hand, we may fail to satisfy some of the coverage constraints, and if we imagine that each uncovered element can be covered at a cost of 1, our approximation guarantee now depends on OPT unlike the guarantee of Gupta et al. [12].\nOn the other hand, we output an explicit solution whereas the algorithm of Gupta et al. [12] outputs an implicit solution, a \u201cset of instructions\u201d that describes a set cover when paired with the private data. (Their approach can also be interpreted as satisfying the weaker guarantee of joint differential privacy [20] rather than standard differential privacy.) Finally, our techniques apply to general constraint-private linear programs, not just set cover."}, {"heading": "4 Low-Sensitivity LPs", "text": "Let us now turn to low-sensitivity LPs. Recall that for these LPs, the distance between adjacent inputs decreases as the size of the database (i.e., the number of individuals) grows. First, a few simplifying assumptions. Like above, we will continue to solve feasibility LPs of the following form:\nfind x \u2208 Rd+ s.t. Ax \u2264 b\nUnlike the case for general constraint private LPs, we require that the feasible solution is a distribution, i.e., is non-negative and has \u21131 norm 1. Note that if the optimal solution has \u21131 norm L, then the rescaled LP\nfind x \u2208 Rd+ s.t. Ax \u2264 b/L\nhas a distribution as a solution. Our algorithms will find a point x\u2217 such that Ax\u2217 \u2264 b/L + \u03b1 \u00b7 1, so if we set \u03b1 = \u03b1\u2032/L, then A(Lx\u2217) \u2264 b+\u03b1\u2032 gives an approximate solution to the original, unscaled LP."}, {"heading": "4.1 Solving LPs with Multiplicative Weights", "text": "Before getting into specific kinds of low-sensitivity LPs, we first review another standard method for solving LPs via the standard multiplicative weights algorithm presented in Algorithm 3.\nAlgorithm 3 The Multiplicative Weights Algorithm, MW\u03b7\nLet A\u03031 be the uniform distribution on A For t = 1, 2, . . . , T :\nReceive loss vector \u2113t (may depend on A1, . . . , At) For each a \u2208 A:\nUpdate At+1a = e \u2212\u03b7\u2113taA\u0303ta for every a \u2208 A\nNormalize A\u0303t+1 = At+1/|At+1|\nUnlike the dense multiplicative weights approach presented earlier (Algorithm 2), we use multiplicative weights to maintain a distribution over the variables rather than the constraints.5 This distribution will be the candidate solution, and we define losses by the maximum constraint violation of this candidate solution at each step. It will be useful to first define an oracle for linear maximizations.\nDefinition 17. For \u01eb > 0, \u03b3 > 0 an (\u03b1, \u03b3)-dual oracle, given A, b, x as input, finds a constraint i \u2208 [m] such that\nAix\u2212 bi \u2265 max j Ajx\u2212 bj \u2212 \u03b1,\nwith probability at least 1\u2212 \u03b3.\nWe now give the full algorithm in Algorithm 4.\nAlgorithm 4 Solving for LP feasibility with primal multiplicative weights\nInput A \u2208 Rm\u00d7d, b \u2208 Rm. Let x\u03031 be the uniform distribution in Rd, \u03c1 = maxij |Aij | be the width of the LP, \u03b1 > 0 be the desired accuracy. Let Oracle be a (\u03b1, \u03b3)-dual oracle, and set\n\u03b7 =\n\u221a log d\nT , T =\n9\u03c12 log d\n\u03b12 .\nFor t = 1, . . . , T : Find pt = Oracle(A, b, x\u0303t) Compute losses \u2113ti := (1/\u03c1)Apti Update x\u0303t+1 from x\u0303t and \u2113t via multiplicative weights. Output x = (1/T ) \u2211T\nt=1 x\u0303 t\nThen, the following accuracy guarantee is known.\nTheorem 18 (Plotkin et al. [25]). Suppose there is a feasible distribution solution of the linear program Ax \u2264 b. Then, running Algorithm 4 with an (\u03b1/3, \u03b3)-dual oracle finds a point x such that Ax \u2264 b+ \u03b1 \u00b7 1 with probability at least 1\u2212 T\u03b3."}, {"heading": "4.2 Scalar-Private LPs", "text": "First, we consider linear programs where the objective and constraint coefficients are public data, but the right hand side in the constraints may contain private data. Roughly, a private database D maps to an objective vector c(D), a constraint matrix A(D), and a vector b(D). For every pair of neighboring databases D,D\u2032, we have c(D) = c(D\u2032) and A(D) = A(D\u2032) independent of the data, and \u2016b(D)\u2212 b(D\u2032)\u2016\u221e \u2264 \u2206\u221e. We will think of \u2206\u221e as decreasing in n; our accuracy guarantees will be trivial if this is not true. As usual, we will assume the LP is in feasibility form, and leave the objective c implicit. Formally:\n5Readers familiar with game theory may notice that we are solving LPs by finding the equilibrium of a two player, zero-sum game. Then, Algorithm 2 is solving the game with MW over the constraints and best response over the variables, while the approach we present in this section swaps the two roles.\nDefinition 19. A randomized algorithm M with inputs vector b \u2208 Rm and matrix A \u2208 Rm\u00d7d, and outputting a vector in Rd is (\u01eb, \u03b4)-low sensitivity scalar private with sensitivity \u2206\u221e if for any b, b \u2032 such that \u2016b\u2212 b\u2032\u2016\u221e \u2264 \u2206\u221e,\nPr[M(b,A) \u2208 S] \u2264 e\u01eb Pr[M(b\u2032, A\u2032) \u2208 S] + \u03b4\nfor any set S \u2286 Rd. The algorithm we use is a slight generalization of the offline private multiplicative weights algorithm [13, 16] (building on the influential work of Hardt and Rothblum [15], who introduced the \u201conline\u201d variant). In our framework, we will express the algorithm as a differentially private variant of Algorithm 4 to solve these linear programs while preserving differential privacy.\nThroughout, we assume that the vector b is private data. On neighboring databases, b can change by at most \u2206\u221e in \u2113\u221e norm. Looking at Algorithm 4, we see that the only place we touch the private data is in the dual oracle. Accordingly, if the dual oracle is private in b, then the whole algorithm is private.\nTheorem 20. Let \u01eb, \u03b4, T be as in Algorithm 4, and let\n\u01eb\u2032 = \u01eb\u221a\n8T log(1/\u03b4) .\nAlgorithm 4, run with an \u01eb\u2032-private dual oracle is (\u01eb, \u03b4)-differentially private.\nProof. Direct from composition (Theorem 6).\nJust like in private multiplicative weights for private query release, the exponential mechanism gives an appropriate dual oracle.\nLemma 21. Let \u01eb, \u03b3 > 0 be given, and suppose the vector b can differ by at most \u2206\u221e in \u2113\u221e norm on neighboring instances. Then, the \u01eb-private exponential mechanism with quality score\nQ(i, b) = Aix\u2212 bi is an (\u03b1, \u03b3)-dual oracle, for\n\u03b1 = 2\u2206\u221e \u01eb\n\u00b7 log ( m\n\u03b3\n) .\nProof. This is \u01eb-private by definition, and the accuracy follows from the accuracy of the exponential mechanism (Theorem 5)\u2014the quality score is \u2206\u221e-sensitive in b, and the output ranges over the constraints, so has size m.\nCombining the MW with the oracle, our private low-sensitivity scalar-private LP solver Algorithm 4 satisfies the following accuracy guarantee.\nTheorem 22. Let \u03b1, \u03b2 \u2208 (0, 1) be given. Suppose the linear program Ax \u2264 b has a distribution as a feasible solution. Algorithm 4, run with the exponential mechanism as a dual oracle (Lemma 21), is (\u01eb, \u03b4)-low sensitiivty scalar private with sensitivity \u2206\u221e, and finds x\n\u2217 satisfying Ax\u2217 \u2264 b+ \u03b1 \u00b7 1, with probability at least 1\u2212 \u03b2, where\n\u03b1 = O\u0303\n( \u03c11/2\u2206 1/2 \u221e\n\u01eb1/2 \u00b7 log1/4 d log1/4(1/\u03b4) log1/2(1/\u03b2) log1/2 m\n) .\nProof. Let \u01eb\u2032 be as in Theorem 20, and let \u03b3 = \u03b2/T with T from Algorithm 4. By Lemma 21, the \u01eb\u2032-private exponential mechanism with quality score\nQ(i, b) = Aix\u2212 bi\nis an (\u03b1/3, \u03b3)-dual oracle for\n\u03b1 = 6\u2206\u221e\n\u221a 8T log(1/\u03b4)\n\u01eb \u00b7 log\n( mT\n\u03b2\n) = 18\u03c1\u2206\u221e \u221a 8 log d log(1/\u03b4)\n\u03b1\u01eb \u00b7 log\n( 9\u03c12(log d)m\n\u03b12\u03b2\n) .\nSolving,\n\u03b1 = O\u0303\n( \u03c11/2\u2206 1/2 \u221e\n\u01eb1/2 \u00b7 log1/4 d log1/4(1/\u03b4) log1/2(1/\u03b2) log1/2 m\n)\nas desired.\nRemark 23. This bound generalizes the guarantee for the private multiplicative weights algorithm when privately generating synthetic data for linear queries [15]. In that setting, there is one variable for each element in some underlying data universe X (and so d = |X |), and there is one equality constraint for each of k linear queries (and so m = k).\nNow, let us consider the low-sensitivity version of constraint privacy: neighboring instances have constraint matrices that differ to a small degree. We distinguish two further subcases: either every coefficient in each constraint can differ, or only a few coefficients in each constraint can differ."}, {"heading": "4.3 Row/Matrix-Private LPs", "text": "Suppose we have the feasibility problem\nfind x\ns.t. Ax \u2264 b,\nwhere some entries in A may change by at most \u2206\u221e on a neighboring instance. Roughly, a private database D maps to an objective vector c(D), a constraint matrix A(D), and a vector b(D). For every pair of neighboring databases D,D\u2032, we have c(D) = c(D\u2032) and b(D) = b(D\u2032) independent of the data, and \u2016A(D) \u2212A(D\u2032)\u2016\u221e \u2264 \u2206\u221e. Again, we will think of \u2206\u221e as decreasing in n; our accuracy guarantees will be trivial if this is not true. Our techniques work equally well whether only a single row of A or the entire matrix A can differ, so we will assume the latter. We will also assume that the LP is in feasibility form, and leave the objective c implicit. Formally:\nDefinition 24. A randomized algorithm M with inputs vector b \u2208 Rm and matrix A \u2208 Rm\u00d7d, and outputting a vector in Rd is (\u01eb, \u03b4)-low sensitivity row private with sensitivity \u2206\u221e if for any A,A \u2032 such that \u2016A\u2212A\u2032\u2016\u221e \u2264 \u2206\u221e,\nPr[M(b,A) \u2208 S] \u2264 e\u01eb Pr[M(b\u2032, A\u2032) \u2208 S] + \u03b4\nfor any set S \u2286 Rd.\nAlgorithm 5 Row/matrix private LP solver\nInput A \u2208 [\u22121, 1]m\u00d7d, b \u2208 Rm. Let x\u03031 be the uniform distribution in Rd, \u03b1 > 0 be the desired accuracy, and \u2206\u221e be the sensitivity. Let Oracle be a (\u03b1, \u03b3)-dual oracle, and set\nT = 144 log d\n\u03b12 , \u01eb\u2032 =\n\u01eb\n4 \u221a dT log(1/\u03b4) , \u03b7 =\n\u221a log d\nT .\nFor t = 1, . . . , T : Find pt = Oracle(A, b, x\u0303t).\nCompute private losses \u2113\u0302ti := Apti+Lap( \u2206\u221e \u01eb\u2032 ) 2 . For each i, update xt+1i = e \u2212\u03b7\u2113\u0302ti \u00b7 x\u0303ti.\nNormalize x\u0303t+1 = xt+1/|xt+1|. Output x = (1/T ) \u2211T t=1 x\u0303 t.\nWe will normalize the problem so each entry in A is in [\u22121, 1]. The basic idea is to use multiplicative weights over the primal variables, with a dual oracle selecting the most violated constraint\u2014since the losses fed into the multiplicative weights algorithm now depend on private data (the matrix A), we add Laplace noise to the loss vectors as they are selected. The full algorithm is given in Algorithm 5.\nWe can now show privacy and accuracy for Algorithm 5.\nTheorem 25. Let \u01eb, \u01eb\u2032, \u03b4,\u2206\u221e be as in Algorithm 5. Algorithm 5 run with an \u01eb \u2032-private dual oracle is (\u01eb, \u03b4)-low sensitivity row private with sensitivity \u2206\u221e.\nProof. Algorithm 5 performs dT Laplace operations, and T oracle operations. Each operation is \u01eb\u2032-private, so this is at most 2dT \u01eb\u2032-private operations. By our choice of \u01eb\u2032 and Theorem 6, the whole algorithm is (\u01eb, \u03b4)-differentially private.\nWe can show that the exponential mechanism is a private dual oracle.\nLemma 26. Let \u01eb, \u03b3 > 0 be given, and suppose the matrix A can differ by at most \u2206\u221e in \u2113\u221e norm on neighboring instances. Let x be any distribution. Then, the \u01eb-private exponential mechanism with quality score Q(i, b) = Aix\u2212 bi is an (\u03b1, \u03b3)-dual oracle, for\n\u03b1 = 2\u2206\u221e \u01eb\n\u00b7 log ( m\n\u03b3\n) .\nProof. Since x is a distribution, the quality score is \u2206\u221e-sensitive and accuracy follows from accuracy of the exponential mechanism (Theorem 5).\nWhile previously our accuracy theorems followed from standard accuracy results for solving LPs using multiplicative weights, the proof for Algorithm 5 does not. Since the constraint matrix is private, Algorithm 4 perturbs the losses and requires a more custom analysis. So, we will need a standard regret bound for multiplicative weights.\nTheorem 27 (Littlestone and Warmuth [22]). Let { A\u0303t }\nbe the distributions obtained by MW\u03b7\nwith arbitrary losses { \u2113t } satisfying \u2016\u2113t\u2016\u221e \u2264 1. Suppose that \u03b7 \u2264 1/2. Let A\u2217 = 1a=a\u2217 , for some a\u2217 \u2208 A. Then,\nT\u2211\nt=1\n\u3008\u2113t, A\u0303t\u3009 \u2264 T\u2211\nt=1\n\u3008\u2113t, A\u2217\u3009+ \u03b7 + log |A| \u03b7T .\nThen, we have the following accuracy guarantee.\nTheorem 28. Let \u03b2 > 0. Suppose the program has a distribution as a feasible solution. Then, with probability at least 1 \u2212 \u03b2, Algorithm 5 run with the exponential mechanism as a dual oracle (Lemma 26) finds a solution x\u2217 such that Ax\u2217 \u2264 b+ \u03b1 \u00b7 1, where\n\u03b1 = O\u0303\n( \u2206 1/2 \u221e d1/4\n\u01eb1/2 \u00b7 polylog\n( d,m, 1\n\u03b2 , 1 \u03b4\n)) .\nProof. Let \u01eb\u2032 be as in Theorem 25, T be from Algorithm 5, and \u03b3 = \u03b2/2dT . By Lemma 26, with probability at least 1/\u03b3, the oracle\u2019s choices satisfy\n( Ai \u00b7 x\u0303t \u2212 bi ) \u2212 ( Apt \u00b7 x\u0303t \u2212 bpt ) \u2264 2\u2206\u221e\n\u01eb\u2032 \u00b7 log\n( m\n\u03b3\n)\nfor all constraints i. Note that the left hand side is equal to ( Ai \u00b7 x\u0303t \u2212 bi ) \u2212 ( \u2113t \u00b7 x\u0303t \u2212 bpt ) . Taking a union bound over all T steps, this is true for all pt with probability at least 1\u2212 \u03b2/2d \u2265 1\u2212 \u03b2/2; condition on this event.\nBy a tail bound on the Laplace mechanism (Lemma 3), with probability at least 1\u2212 \u03b3, a noisy loss \u2113\u0302ti satisfies \u2223\u2223\u2223\u2113\u0302ti \u2212 (1/2)\u2113ti \u2223\u2223\u2223 \u2264 \u2206\u221e \u01eb\u2032 \u00b7 log ( 1 \u03b3 ) .\nTaking a union bound over all T steps and d losses, this is true for all losses with probability at least 1\u2212 \u03b2/2; condition on this event.\nWe first show that if these errors are small, then the theorem holds. Assume\n2\u2206\u221e \u01eb\u2032\n\u00b7 log ( m\n\u03b3\n) \u2264 \u03b1\n6 , (1)\nso that both right hand sides above are at most \u03b1/6. Since \u03b1 < 1, this implies that every Laplace noise is at most 1, so the noisy losses are bounded: |\u2113\u0302ti| \u2264 1.\nLet x\u2217 be an exactly feasible point, with \u21131 norm 1. By the regret guarantee for multiplicative weights (Theorem 27),\n1\nT\n\u2211\nt\n\u2113\u0302t \u00b7 x\u0303t \u2264 1 T\n\u2211\nt\n\u2113\u0302t \u00b7 x\u2217 + \u03b7 + log d \u03b7T\n1\nT\n\u2211\nt\n( Apt\n2 +\n\u03bd\n2\n) \u00b7 x\u0303t \u2212 bpt\n2 =\n1\nT\n\u2211\nt\n\u2113\u0302t \u00b7 x\u0303t \u2212 bpt 2 \u2264 1 T\n\u2211\nt\n\u2113\u0302t \u00b7 x\u2217 \u2212 bpt 2 + \u03b7 + log d \u03b7T ,\nwhere \u03bd is a vector of independent draws from Lap(\u2206\u221e/\u01eb \u2032). Let i be any constraint. Since we assumed the error of the exponential mechanism to be small (Equation (1)) and x\u0303t is a distribution,\n1\nT\n\u2211\nt\n( 1\n2 Ai \u00b7 x\u0303t \u2212 bi 2\n) + 1\n2 \u03bd \u2264 1 T\n\u2211\nt\n\u2113\u0302t \u00b7 x\u2217 \u2212 bpt 2 + \u03b7 + log d \u03b7T + \u03b1 6 .\nBy assumption (Equation (1)) |\u03bd| \u2264 \u03b1/6, so\n1\nT\n\u2211\nt\nAi \u00b7 x\u0303t \u2212 bi \u2264 1\nT\n\u2211\nt\n2\u2113\u0302t \u00b7 x\u2217 \u2212 bpt + \u03b1/3 + \u03b1/6 + \u03b7 + log d\n\u03b7T .\nSince x\u2217 is a feasible point, Ai \u00b7x\u2217\u2212bi \u2264 0 for all i. By assumption (Equation (1)), \u2223\u2223\u2223Ai \u2212 2\u2113\u0302ti \u2223\u2223\u2223 \u2264 \u03b1/3. By our choice of \u03b7 and T ,\nAi \u00b7 x\u2212 bi \u2264 1\nT\n\u2211\nt\nAi \u00b7 x\u2217 \u2212 bi + \u03b1/3 + \u03b1/3 + \u03b1/6 + \u03b7 + log d\n\u03b7T\n\u2264 5\u03b1 6 + \u03b7 + log d \u03b7T \u2264 \u03b1,\nas desired. Now, it only remains to show Equation (1). By unfolding definitions like before, it suffices to take\n\u03b1 \u2265 12\u2206 1/2 \u221e d1/4(log d)1/4(log(1/\u03b4))1/4 \u01eb1/2 \u00b7 ( log 288d log dm \u03b12\u03b2 )1/2 ."}, {"heading": "4.4 Column Private LPs", "text": "Rather than an entire row changing, neighboring LPs may differ in a column; that is, they differ in coefficients corresponding to a single variable. Roughly, a private database D maps to an objective vector c(D), a constraint matrix A(D), and a vector b(D). For every pair of neighboring databases D,D\u2032, we have c(D) = c(D\u2032) and b(D) = b(D\u2032) independent of the data, and \u2016A(D)i\u2212A(D\u2032)i\u2016\u221e \u2264 \u22061 for every row i of the constraint matrix. Again, we will think of \u22061 as decreasing in n; our accuracy guarantees will be trivial if this is not true. Formally:\nDefinition 29. A randomized algorithm M with inputs vector b \u2208 Rm and matrix A \u2208 Rm\u00d7d, and outputting a vector in Rd is (\u01eb, \u03b4)-low sensitivity column private with sensitivity \u22061 if for any A,A \u2032 such that \u2016Ai \u2212A\u2032i\u2016\u221e \u2264 \u22061 for each row i \u2208 [m],\nPr[M(b,A) \u2208 S] \u2264 e\u01eb Pr[M(b\u2032, A\u2032) \u2208 S] + \u03b4\nfor any set S \u2286 Rd.\nWe can use a very slight modification of Algorithm 5 to solve these LPs privately; the algorithm is given in Algorithm 6.\nLike before, we can show that the exponential mechanism can be used as a private dual oracle.\nAlgorithm 6 Column private LP solver\nInput A \u2208 [\u22121, 1]m\u00d7d, b \u2208 Rm. Let x\u03031 be the uniform distribution in Rd, \u03b1 > 0 be the desired accuracy, and \u22061 be the sensitivity. Let Oracle be an (\u03b1, \u03b3)-dual oracle, and set\nT = 144 log d\n\u03b12 , \u01eb\u2032 =\n\u01eb\n4 \u221a T log(1/\u03b4) , \u03b7 =\n\u221a log d\nT .\nFor t = 1, . . . , T : Find pt = Oracle(A, b, x\u0303t).\nCompute private losses \u2113\u0302ti := Apti+Lap\n(\n\u22061 \u01eb\u2032\n)\n2 .\nFor each i, update xt+1i = e \u2212\u03b7\u2113\u0302ti \u00b7 x\u0303ti.\nNormalize x\u0303t+1 = xt+1/|xt+1|. Output x = (1/T ) \u2211T t=1 x\u0303 t.\nLemma 30. Let \u01eb, \u03b3 > 0 be given, and suppose neighboring matrices A,A\u2032 satisfy \u2016Ai\u2212A\u2032i\u20161 \u2264 \u22061 for every row i. Let x be any distribution. Then, the \u01eb-private exponential mechanism with quality score Q(i, b) = Aix\u2212 bi is an (\u03b1, \u03b3)-dual oracle, for\n\u03b1 = 2\u22061 \u01eb\n\u00b7 log ( m\n\u03b3\n) .\nProof. Since x is a distribution, the quality score is \u22061-sensitive and accuracy follows from accuracy of the exponential mechanism (Theorem 5).\nTheorem 31. Let \u01eb, \u01eb\u2032, \u03b4,\u22061 be as in Algorithm 6. Algorithm 6 run with an \u01eb \u2032-private dual oracle is (\u01eb, \u03b4)-low sensitiivty column private with sensitivity \u22061.\nProof. Since the loss vector \u2113t can differ by at most \u22061 in \u21131 norm, adding Laplace noise with scale \u22061/\u01eb suffices for \u01eb-differentially privacy. Thus, there are T Laplace and oracle mechanism steps, each \u01eb\u2032-private. By choice of \u01eb\u2032 and composition, Algorithm 6 is (\u01eb, \u03b4)-differentially private.\nTheorem 32. Let \u03b2 > 0. Suppose the program has a distribution as a feasible solution. Then, with probability at least 1 \u2212 \u03b2, Algorithm 6 run with the exponential mechanism (Lemma 30) as oracle finds a point x\u2217 such that Ax\u2217 \u2264 b+ \u03b1 \u00b7 1, where\n\u03b1 = O\u0303\n( \u2206\n1/2 1\n\u01eb1/2 \u00b7 polylog\n( d,m, 1\n\u03b2 , 1 \u03b4\n)) .\nProof. Let \u01eb\u2032 be as in Theorem 31, T be as inAlgorithm 6, and \u03b3 = \u03b2/2dT . Letting the dual oracle by the \u01eb\u2032-private exponential mechanism, the proof is nearly identical to Theorem 28. The main difference is that we need\n2\u22061 \u01eb\u2032\n\u00b7 log ( 1\n\u03b3\n) \u2264 \u03b1\n6\nfor everything to go through. By unfolding definitions, it suffices to take\n\u03b1 \u2265 12\u2206 1/2 1 (log d) 1/4(log(1/\u03b4))1/4 \u01eb1/2 \u00b7 ( log 288m log d \u03b12\u03b2 )1/2 .\nComparing the two previous algorithms, note \u2206\u221e \u2264 \u22061 \u2264 d\u2206\u221e. Algorithm 5 performs better when the right inequality is tighter, i.e., when all the coefficients in a row can differ by a small amount. In contrast, Algorithm 6 performs better when the left inequality is tighter, that is, when a few coefficients in a row can differ by a larger amount."}, {"heading": "4.5 Objective Private LPs", "text": "For our final type of low-sensitivity LP, we consider linear programs with objectives that depend on private data. We show that a very simple approach\u2014randomized response\u2014can solve these types of LPs accurately. Throughout, we will assume that the optimal solution to the LP has \u21131 weight equal to 1. We start with an LP in general form:\nmax c\u22a4x\ns.t. Ax \u2264 b, On instances corresponding to neighboring database D,D\u2032, the objective may change by \u22061 in \u21131 norm: \u2016c(D)\u2212 c(D\u2032)\u20161 \u2264 \u22061. Formally: Definition 33. A randomized algorithm M with inputs vectors b \u2208 Rm, c \u2208 Rd and matrix A \u2208 Rm\u00d7d, and outputting a vector in Rd is (\u01eb, \u03b4)-low sensitivity objective private with sensitivity \u22061 if for any c, c\n\u2032 such that \u2016c\u2212 c\u2032\u20161 \u2264 \u22061, Pr[M(c, b, A) \u2208 S] \u2264 e\u01eb Pr[M(c\u2032, b, A) \u2208 S] + \u03b4\nfor any set S \u2286 Rd. For a concrete case, a single objective coefficient may change by \u22061. All other parts of the LP do not change: A(D) = A(D\u2032), and b(D) = b(D\u2032). If we add Laplace noise to the objective and solve the resulting LP, we will get an almost optimal, exactly feasible solution.\nTheorem 34. Suppose an objective private LP has optimal objective OPT, and has optimal solution with \u21131 weight 1. Define\nc\u0302 = c+ Lap\n( \u22061 \u221a 8d log(1/\u03b4)\n\u01eb\n)d ,\nwhere the noise is d independent draws from the Laplace distribution with the given parameter. Then, releasing the perturbed LP\nmax c\u0302\u22a4x\ns.t. Ax \u2264 b and 1\u22a4x = 1 is (\u01eb, \u03b4)-low sensitivity objective private with sensitivity \u22061. With probability 1 \u2212 \u03b2, solving the perturbed LP non-privately yields a point x\u2217 such that Ax\u2217 \u2264 b and c\u22a4x\u2217 \u2265 OPT\u2212\u03b1, where\n\u03b1 = 4\u22061\n\u221a 8d log(d/\u03b4)\n\u01eb .\nProof. Since the \u21131 sensitivity of c is 1 and d numbers are released, (\u01eb, \u03b4)-privacy follows from the composition theorem (Theorem 6).6\nFor the accuracy, note that with probability at least 1 \u2212 \u03b2/d, a single draw of the Laplace distribution is bounded by\n\u03b1 2 =\n2\u22061 \u221a 8d log(d/\u03b4)\n\u01eb .\nBy a union bound, this happens with probability at least 1 \u2212 \u03b2 for all d draws; condition on this event. Then, note that if x\u2217 is the optimal solution to the original LP, then it is also a feasible solution to the perturbed LP. Let x\u0302\u2217 be the optimal solution of the perturbed LP. Since the noise added to each objective coefficient is bounded by \u03b1/2, if\nc\u22a4x\u0302\u2217 < OPT\u2212\u03b1\nthen c\u0302\u22a4x\u0302\u2217 < OPT\u2212\u03b1/2 but also c\u0302\u22a4x\u2217 \u2265 OPT\u2212\u03b1/2,\ncontradicting optimality of x\u0302\u2217 in the perturbed program. Thus, this algorithm finds an exactly feasible, \u03b1-optimal solution."}, {"heading": "5 Lower Bounds", "text": "Now that we have considered various low-sensitivity LPs, let us turn to high-sensitivity LPs. In this section, we show that most high-sensitivity LPs cannot be solved privately to non-trivial accuracy. The exception is constraint private LPs\u2014as we saw (Section 3), these can be solved in a relaxed sense. Our lower bounds are all reductions to reconstruction attacks: as the following theorem shows, differential privacy precludes reconstructing a non-trivial fraction of a database. The idea of reconstruction being a key feature of privacy violation is due to Dinur and Nissim [7]. The following theorem is folklore; we provide a proof for completeness.\nTheorem 35. Let mechanism M : {0, 1}n \u2192 [0, 1]n be (\u01eb, \u03b4)-differentially private, and suppose that for all database D, with probability at least 1\u2212 \u03b2, \u2016M(D)\u2212D\u20161 \u2264 \u03b1n. Then,\n\u03b1 \u2265 1 2 \u2212 e\n\u01eb + \u03b4\n2(1 + e\u01eb)(1\u2212 \u03b2) := c(\u01eb, \u03b4, \u03b2).\nThe same is true even if D is restricted to have exactly n/2 zero entries.\nProof. If we have M as in the hypothesis, then we can round each entry of M(D) to {0, 1} while preserving (\u01eb, \u03b4)-differential privacy. Note that by assumption \u2016M(D)\u2212D\u20161 \u2264 \u03b1n, so the number of entries M(D)i that are more than 1/2 away from Di is at most 2\u03b1n. Thus, rounding reconstructs a database in {0, 1}n at most 2\u03b1n distance from the true database in \u21131 norm; hence we may assume that M(D) \u2208 {0, 1}n with \u21131 norm at most 2\u03b1n from D.\nAssume n is even; we prove the case where the input database D has exactly n/2 zero entries. Let D \u2208 {0, 1}n have exactly n/2 zero entries, and sample an index i such that Di = 1, and an index j such that Dj = 0, both uniformly at random from [n]. Let D\n\u2032 be identical to D except with bits i and j swapped. By assumption, we have that with probability at least 1\u2212 \u03b2\n\u2016M(D) \u2212D\u20161 \u2264 2\u03b1n and \u2016M(D\u2032)\u2212D\u2032\u20161 \u2264 2\u03b1n. 6This is similar to the case of privately releasing histogram queries.\nSince i is chosen uniformly, we also know\nPr[M(D)i = Di] \u2265 (1\u2212 2\u03b1)(1 \u2212 \u03b2) and Pr[M(D\u2032)i = D\u2032i] \u2265 (1\u2212 2\u03b1)(1 \u2212 \u03b2).\nHence, Pr[M(D\u2032)i = Di] \u2264 1\u2212 (1\u2212 2\u03b1)(1 \u2212 \u03b2) because Di 6= D\u2032i. By (\u01eb, \u03b4)-differential privacy, we get\n(1\u2212 2\u03b1)(1 \u2212 \u03b2) \u2264 Pr[M(D)i = Di] \u2264 e\u01eb Pr[M(D\u2032)i = Di] + \u03b4 \u2264 e\u01eb(1\u2212 (1\u2212 2\u03b1)(1 \u2212 \u03b2)) + \u03b4.\nFinally,\n1\u2212 2\u03b1 \u2264 e \u01eb + \u03b4\n(1 + e\u01eb)(1 \u2212 \u03b2) ,\nas desired.\nFor each type of impossible private LP, we show how to convert a database D \u2208 {0, 1}n to a LP, such that neighboring databases D,D\u2032 lead to neighboring LPs. We then show that a LP solver that privately solves this LP to non-trivial accuracy leads to a reconstruction attack on D, violating Theorem 35.\nFirst, some notation. For the general LP\nmax c\u22a4x\ns.t. Ax \u2264 b,\nwe say that x\u2217 is an \u03b1-feasible solution if Ax\u2217 \u2264 b+\u03b1 \u00b7 1. Likewise, we say that x\u2217 is an \u03b1-optimal solution if it is feasible, and\nc\u22a4x\u2217 \u2265 max x:Ax\u2264b c\u22a4x\u2212 \u03b1."}, {"heading": "5.1 High-Sensitivity Scalars", "text": "Consider a database D \u2208 {0, 1}n, and the following LP:\nfind x\ns.t. xi = Di for each i\nNote that changing a single bit in D will change a single right hand side in a constraint by 1.\nTheorem 36. Suppose mechanism M is (\u01eb, \u03b4)-high sensitivity scalar private, and with probability at least 1\u2212 \u03b2, finds an \u03b1-feasible solution. Then, \u03b1 \u2265 1/2.\nProof. Consider the gadget LP above. Note that if M guarantees \u03b1 < 1/2, then |xi \u2212Di| < 1/2 so rounding xi to 0 or 1 will reconstruct Di exactly. By Theorem 35, this is impossible under differential privacy."}, {"heading": "5.2 High-Sensitivity Objective", "text": "Consider a database D \u2208 {0, 1}n with exactly n/2 zeros, and the following LP:\nmaximize \u2211\ni\nDixi \u2212 n/2\ns.t. \u2211\ni\nxi = n/2, xi \u2208 [0, 1]\nNote that swapping a zero and a non-zero bit in D will change exactly two objective coefficients in the LP by 1. Observe that this is similar to the objective private LP (Section 4.5) because we are only allowing the objective to change. However here we consider the setting where a single objective coefficient changes arbitrarily, rather than by a small amount.\nTheorem 37. Suppose mechanism M is (\u01eb, \u03b4)-high-sensitivity objective private, and with probability at least 1 \u2212 \u03b2, finds an exactly feasible, additive (\u03b1n)-optimal solution. Then, \u03b1 \u2265 c(2\u01eb, \u03b4(1 + e\u01eb), \u03b2).\nProof. Consider the gadget LP above. Note that the optimal solution is xi = Di, with objective 0. With probability at least 1\u2212\u03b2, M finds a solution x\u2217 with objective at least \u2212\u03b1n. In this case, x\u2217 places at most \u03b1n mass on indices with Di = 0, so at least (1\u2212 \u03b1)n mass of D and x\u2217 are shared. Thus, \u2016D \u2212 x\u2217\u20161 \u2264 \u03b1n. Since a change in D leads to a distance two change in the LP, the composition is (2\u01eb, \u03b4(1 + e\u01eb))private. By Theorem 35, \u03b1 \u2265 c(2\u01eb, \u03b4(1 + e\u01eb), \u03b2)."}, {"heading": "5.3 High-Sensitivity Constraints/Columns", "text": "Consider a database D \u2208 {0, 1}n with exactly n/2 zeros, and the following LP:\nfind xi\ns.t. \u2211\ni\nDixi = n/2\nxi \u2208 [0, 1] and \u2211\ni\nxi = n/2\nNote that changing a single bit in D will change coefficients in a single constraint in the LP by 1. Observe that this is similar to the column private LP (Section 4.4) because we are allowing the coefficients for a single variable to change. However here we consider the setting where this coefficient can change arbitrarily, rather than by only a small amount.\nThis problem is also a special case of constraint private LPs (Section 3) because the coefficients in one (i.e., the only) constraint can change arbitrarily. In the current setting, we want a solution that approximately satisfies all constraints, rather than just satisfying most of the constraints.\nTheorem 38. Suppose mechanism M is (\u01eb, \u03b4)-high-sensitivity constraint private, and finds an \u03b1-feasible solution that satisfies all public constraints with probability at least 1 \u2212 \u03b2. Then, \u03b1 \u2265 c(2\u01eb, \u03b4(1 + e\u01eb), \u03b2).\nProof. Consider the gadget LP above. Suppose with probability 1 \u2212 \u03b2, M finds x\u2217 such that \u2016Ax\u2217 \u2212 b\u2016\u221e \u2264 \u03b1 for the gadget LP. By reasoning analogous to Theorem 37, at least (1 \u2212 \u03b1)n of the mass of x\u2217 will coincide with D, hence \u03b1 \u2265 c(2\u01eb, \u03b4(1 + e\u01eb), \u03b2) by Theorem 35.\nAlso note that the LPs produced by this reduction differ only in the coefficients corresponding to two variables. Hence, Theorem 38 also shows that privately solving column private LPs to nontrivial accuracy is impossible. It\u2019s possible that a relaxed solution, similar to allowing unsatisfied constraints in the constraint-private case, could be possible under column privacy.\nHowever, it is not enough to allow some constraints to be unsatisfied. Since we can simply duplicate the constraint in our lower bound gadget multiple times, producing a solution satisfying any single constraint to non-trivial accuracy is impossible under high-sensitivity column privacy. A different relaxation would be needed for non-trivial accuracy under column privacy."}, {"heading": "6 Discussion", "text": "In this paper, we have initiated the study of privately solving general linear programs. We have given a taxonomy of private linear programs, classified by how the private data affects the LP. For each type of linear program in the taxonomy, we have either given an efficient algorithm, or an impossibility result.\nOne natural question is, to what extent do our results extend to other private convex programs, e.g., semidefinite programs (SDPs)? A tempting approach is to to use the Matrix Multiplicative Weights algorithm of Arora and Kale [1] for solving SDPs. However, certain features of the standard multiplicative weights algorithm which we use crucially\u2014such as compatibility with Bregman projections\u2014seem more delicate when using Matrix Multiplicative Weights."}], "references": [{"title": "A combinatorial, primal-dual approach to semidefinite programs", "author": ["Sanjeev Arora", "Satyen Kale"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "The multiplicative weights update method: a meta-algorithm and Theory of Computing", "author": ["Sanjeev Arora", "Elad Hazan", "Satyen Kale"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Practical privacy: the sulq framework", "author": ["Avrim Blum", "Cynthia Dwork", "Frank McSherry", "Kobbi Nissim"], "venue": "In ACM SIGACT\u2013SIGMOD\u2013SIGART Symposium on Principles of Database Systems (PODS),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "A learning theory approach to noninteractive database privacy", "author": ["Avrim Blum", "Katrina Ligett", "Aaron Roth"], "venue": "Journal of the ACM,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Fingerprinting codes and the price of approximate differential", "author": ["Mark Bun", "Jonathan Ullman", "Salil P Vadhan"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Differentially private empirical risk minimization", "author": ["Kamalika Chaudhuri", "Claire Monteleoni", "Anand D. Sarwate"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Revealing information while preserving privacy", "author": ["Irit Dinur", "Kobbi Nissim"], "venue": "In ACM SIGACT\u2013SIGMOD\u2013SIGART Symposium on Principles of Database Systems (PODS),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2003}, {"title": "Differential privacy: A survey of results", "author": ["Cynthia Dwork"], "venue": "In Theory and Applications of MOdels of Computation (TAMC), Xi\u2019an,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "Calibrating noise to sensitivity in private data analysis", "author": ["Cynthia Dwork", "Frank McSherry", "Kobbi Nissim", "Adam Smith"], "venue": "In IACR Theory of Cryptography Conference (TCC),", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "On the complexity of differentially private data release: efficient algorithms and hardness results", "author": ["Cynthia Dwork", "Moni Naor", "Omer Reingold", "Guy N. Rothblum", "Salil Vadhan"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Boosting and differential privacy", "author": ["Cynthia Dwork", "Guy N. Rothblum", "Salil Vadhan"], "venue": "In IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Differentially private combinatorial optimization", "author": ["Anupam Gupta", "Katrina Ligett", "Frank McSherry", "Aaron Roth", "Kunal Talwar"], "venue": "In ACM\u2013SIAM Symposium on Discrete Algorithms", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Privately releasing conjunctions and the statistical query barrier", "author": ["Anupam Gupta", "Moritz Hardt", "Aaron Roth", "Jonathan Ullman"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2011}, {"title": "Iterative constructions and private data release", "author": ["AnupamGupta", "Aaron Roth", "Jonathan Ullman"], "venue": "In IACR Theory of Cryptography Conference (TCC),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "A multiplicative weights mechanism for privacy-preserving data analysis", "author": ["Moritz Hardt", "Guy N. Rothblum"], "venue": "In IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "A simple and practical algorithm for differentially private", "author": ["Moritz Hardt", "Katrina Ligett", "Frank McSherry"], "venue": "In Conference on Neural Information Processing Systems (NIPS), Lake Tahoe,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "Tracking the best linear predictor", "author": ["Mark Herbster", "Manfred K. Warmuth"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2001}, {"title": "Differential privacy for the analyst via private equilibrium computation", "author": ["Justin Hsu", "Aaron Roth", "Jonathan Ullman"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2013}, {"title": "What can we learn privately", "author": ["Shiva Prasad Kasiviswanathan", "Homin K. Lee", "Kobbi Nissim", "Sofya Raskhodnikova", "Adam Smith"], "venue": "SIAM Journal on Computing,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}, {"title": "Mechanism design in large games: Incentives and privacy", "author": ["Michael Kearns", "Mallesh Pai", "Aaron Roth", "Jonathan Ullman"], "venue": "In ACM SIGACT Innovations in Theoretical Computer Science (ITCS),", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "Private convex empirical risk minimization and high-dimensional regression", "author": ["Daniel Kifer", "Adam Smith", "Abhradeep Thakurta"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "The weighted majority algorithm", "author": ["N. Littlestone", "Manfred K. Warmuth"], "venue": "Information and Computation,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1994}, {"title": "Mechanism design via differential privacy", "author": ["Frank McSherry", "Kunal Talwar"], "venue": "In IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2007}, {"title": "Smooth sensitivity and sampling in private data analysis", "author": ["Kobbi Nissim", "Sofya Raskhodnikova", "Adam Smith"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2007}, {"title": "Fast approximation algorithms for fractional packing and covering problems", "author": ["Serge A. Plotkin", "David B. Shmoys", "\u00c9va Tardos"], "venue": "Mathematics of Operations Research,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "Answering n2+o(1) counting queries with differential privacy is hard", "author": ["Jonathan Ullman"], "venue": "In ACM SIGACT Symposium on Theory of Computing (STOC), Palo Alto, California,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2013}, {"title": "PCPs and the hardness of generating private synthetic data", "author": ["Jonathan Ullman", "Salil Vadhan"], "venue": "In IACR Theory of Cryptography Conference (TCC),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2011}], "referenceMentions": [{"referenceID": 18, "context": "[19] show how to privately PAC learn any PAC learnable concept class (without privacy) with only a small increase in the sample complexity, but via an exponential time algorithm.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4] show how to privately release a summary of a private database that approximately preserves the answers to rich families of linear queries, again via an exponential time algorithm.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "In fact, under standard cryptographic assumptions, it is not possible to efficiently and privately answer large collections of general linear queries [10, 28, 27].", "startOffset": 150, "endOffset": 162}, {"referenceID": 26, "context": "In fact, under standard cryptographic assumptions, it is not possible to efficiently and privately answer large collections of general linear queries [10, 28, 27].", "startOffset": 150, "endOffset": 162}, {"referenceID": 25, "context": "In fact, under standard cryptographic assumptions, it is not possible to efficiently and privately answer large collections of general linear queries [10, 28, 27].", "startOffset": 150, "endOffset": 162}, {"referenceID": 22, "context": "The two preceding examples are among the many algorithms that use the extremely general exponential mechanism of McSherry and Talwar [23] to achieve near optimal error.", "startOffset": 133, "endOffset": 137}, {"referenceID": 23, "context": ", the sample and aggregate framework [24] and output/objective perturbation for unconstrained convex optimization [6, 21]).", "startOffset": 37, "endOffset": 41}, {"referenceID": 5, "context": ", the sample and aggregate framework [24] and output/objective perturbation for unconstrained convex optimization [6, 21]).", "startOffset": 114, "endOffset": 121}, {"referenceID": 20, "context": ", the sample and aggregate framework [24] and output/objective perturbation for unconstrained convex optimization [6, 21]).", "startOffset": 114, "endOffset": 121}, {"referenceID": 14, "context": "Solving this kind of linear programming privately is similar to the well-studied linear query release problem in differential privacy, and techniques for linear query release\u2014such as the private multiplicative weights algorithm of Hardt and Rothblum [15] (and its offline variants [14, 16])\u2014can be adapted with minor changes.", "startOffset": 250, "endOffset": 254}, {"referenceID": 13, "context": "Solving this kind of linear programming privately is similar to the well-studied linear query release problem in differential privacy, and techniques for linear query release\u2014such as the private multiplicative weights algorithm of Hardt and Rothblum [15] (and its offline variants [14, 16])\u2014can be adapted with minor changes.", "startOffset": 281, "endOffset": 289}, {"referenceID": 15, "context": "Solving this kind of linear programming privately is similar to the well-studied linear query release problem in differential privacy, and techniques for linear query release\u2014such as the private multiplicative weights algorithm of Hardt and Rothblum [15] (and its offline variants [14, 16])\u2014can be adapted with minor changes.", "startOffset": 281, "endOffset": 289}, {"referenceID": 6, "context": "2 Related Work Differential privacy emerged from a line of work initiated by Dinur and Nissim [7], was defined by Dwork et al.", "startOffset": 94, "endOffset": 97}, {"referenceID": 8, "context": "[9], and is now a standard definition of privacy in computer science.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "Below, we discuss relevant results in differential privacy; the survey by Dwork [8] is an excellent source for a more comprehensive overview.", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "[3] and Kasiviswanathan et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 18, "context": "[19], who considered how to choose an optimal classifier privately.", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "[3] give an efficient reduction from SQ learning to private SQ learning, and Kasiviswanathan et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 18, "context": "[19] give a very general but inefficient reduction from PAC learning to private PAC learning using the exponential mechanism of McSherry and Talwar [23].", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[19] give a very general but inefficient reduction from PAC learning to private PAC learning using the exponential mechanism of McSherry and Talwar [23].", "startOffset": 148, "endOffset": 152}, {"referenceID": 5, "context": "[6], who give two techniques for privately solving certain unconstrained convex optimization problems.", "startOffset": 0, "endOffset": 3}, {"referenceID": 11, "context": "[12] give several algorithms for problems in private combinatorial optimization, but these were specialized combinatorial algorithms for specific problems.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4] and continuing with Dwork et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[10], Roth and Roughgarden [26], Dwork et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11], Hardt and Rothblum [15], Gupta et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[11], Hardt and Rothblum [15], Gupta et al.", "startOffset": 25, "endOffset": 29}, {"referenceID": 13, "context": "[14], Hardt et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] study the problem of privately producing synthetic data consistent with some private database on many linear queries.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "(Of particular note is the private multiplicative weights mechanism of Hardt and Rothblum [15], which achieves the optimal accuracy and running time bounds [27, 5].", "startOffset": 90, "endOffset": 94}, {"referenceID": 25, "context": "(Of particular note is the private multiplicative weights mechanism of Hardt and Rothblum [15], which achieves the optimal accuracy and running time bounds [27, 5].", "startOffset": 156, "endOffset": 163}, {"referenceID": 4, "context": "(Of particular note is the private multiplicative weights mechanism of Hardt and Rothblum [15], which achieves the optimal accuracy and running time bounds [27, 5].", "startOffset": 156, "endOffset": 163}, {"referenceID": 14, "context": ") This problem can be represented as a linear program with queries defining constraints, and indeed, the private multiplicative weights algorithm of Hardt and Rothblum [15] can be directly applied to solve this kind of linear program.", "startOffset": 168, "endOffset": 172}, {"referenceID": 24, "context": "[25] (see the excellent survey by Arora et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "[2] for more details).", "startOffset": 0, "endOffset": 3}, {"referenceID": 24, "context": "[25] maintain a distribution over the dual variables with multiplicative weights, depending on the kind of linear program we are solving, we either maintain a distribution over the dual variables or the primal variables.", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "To solve constraint private LPs, we use a combination of the multiplicative weights update method and Bregman projections [2]\u2014Hsu et al.", "startOffset": 122, "endOffset": 125}, {"referenceID": 17, "context": "[18] use a similar version of this technique in designing analyst private mechanisms.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[9].", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 22, "context": "We will also use the exponential mechanism [23], which can privately produce a non-numeric or discrete output.", "startOffset": 43, "endOffset": 47}, {"referenceID": 22, "context": "Definition 4 (McSherry and Talwar [23]).", "startOffset": 34, "endOffset": 38}, {"referenceID": 22, "context": "Theorem 5 (McSherry and Talwar [23]).", "startOffset": 31, "endOffset": 35}, {"referenceID": 10, "context": "[11]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "Throughout, we will use calligraphic letters (A) to denote sets of actions, Roman letters (A) to denote measures on those actions A : A \u2192 [0, 1], and letters with tildes (\u00c3) to denote a probability distributions over actions.", "startOffset": 138, "endOffset": 144}, {"referenceID": 16, "context": "We will call this algorithm, due to Herbster and Warmuth [17], the dense multiplicative weights algorithm (Algorithm 1).", "startOffset": 57, "endOffset": 61}, {"referenceID": 16, "context": "3 Theorem 9 (Herbster and Warmuth [17]).", "startOffset": 34, "endOffset": 38}, {"referenceID": 24, "context": "[25]; the novelty in our approach is that we use multiplicative weights paired with a projection onto the set of dense distributions, and show that the solution approximately satisfies most of the constraints.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18]; we reproduce the proof for completeness.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12].", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12].", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] outputs an implicit solution, a \u201cset of instructions\u201d that describes a set cover when paired with the private data.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "(Their approach can also be interpreted as satisfying the weaker guarantee of joint differential privacy [20] rather than standard differential privacy.", "startOffset": 105, "endOffset": 109}, {"referenceID": 24, "context": "[25]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "The algorithm we use is a slight generalization of the offline private multiplicative weights algorithm [13, 16] (building on the influential work of Hardt and Rothblum [15], who introduced the \u201conline\u201d variant).", "startOffset": 104, "endOffset": 112}, {"referenceID": 15, "context": "The algorithm we use is a slight generalization of the offline private multiplicative weights algorithm [13, 16] (building on the influential work of Hardt and Rothblum [15], who introduced the \u201conline\u201d variant).", "startOffset": 104, "endOffset": 112}, {"referenceID": 14, "context": "The algorithm we use is a slight generalization of the offline private multiplicative weights algorithm [13, 16] (building on the influential work of Hardt and Rothblum [15], who introduced the \u201conline\u201d variant).", "startOffset": 169, "endOffset": 173}, {"referenceID": 14, "context": "This bound generalizes the guarantee for the private multiplicative weights algorithm when privately generating synthetic data for linear queries [15].", "startOffset": 146, "endOffset": 150}, {"referenceID": 21, "context": "Theorem 27 (Littlestone and Warmuth [22]).", "startOffset": 36, "endOffset": 40}, {"referenceID": 6, "context": "The idea of reconstruction being a key feature of privacy violation is due to Dinur and Nissim [7].", "startOffset": 95, "endOffset": 98}, {"referenceID": 0, "context": "Let mechanism M : {0, 1}n \u2192 [0, 1]n be (\u01eb, \u03b4)-differentially private, and suppose that for all database D, with probability at least 1\u2212 \u03b2, \u2016M(D)\u2212D\u20161 \u2264 \u03b1n.", "startOffset": 28, "endOffset": 34}, {"referenceID": 0, "context": "i xi = n/2, xi \u2208 [0, 1]", "startOffset": 17, "endOffset": 23}, {"referenceID": 0, "context": "i Dixi = n/2 xi \u2208 [0, 1] and \u2211", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": ", semidefinite programs (SDPs)? A tempting approach is to to use the Matrix Multiplicative Weights algorithm of Arora and Kale [1] for solving SDPs.", "startOffset": 127, "endOffset": 130}], "year": 2014, "abstractText": "In this paper, we initiate the systematic study of solving linear programs under differential privacy. The first step is simply to define the problem: to this end, we introduce several natural classes of private linear programs that capture different ways sensitive data can be incorporated into a linear program. For each class of linear programs we give an efficient, differentially private solver based on the multiplicative weights framework, or we give an impossibility result. Department of Computer and Information Science, University of Pennsylvania. Supported in part by NSF Grant CNS-1065060. Department of Computer and Information Science, University of Pennsylvania. Supported in part by an NSF CAREER award, NSF Grants CCF-1101389 and CNS-1065060, and a Google Focused Research Award. Email: aaroth@cis.upenn.edu. Department of Computer Science, Stanford University. Supported in part by NSF Awards CCF-1016885 and CCF-1215965, and an ONR PECASE Award. School of Engineering and Applied Sciences and Center for Research on Computation and Society, Harvard University. Supported by NSF grant CNS-1237235. Email: jullman@seas.harvard.edu.", "creator": "LaTeX with hyperref package"}}}