{"id": "1405.3790", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-May-2014", "title": "Transaction Logic with (Complex) Events", "abstract": "this work deals with the problem of combining reactive features, such as its ability to respond to events and define complex events, with smooth execution of variables over general knowledge bases ( kbs ).", "histories": [["v1", "Thu, 15 May 2014 10:18:12 GMT  (376kb,D)", "http://arxiv.org/abs/1405.3790v1", "To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["ana sofia gomes", "jos\\'e j\\'ulio alferes"], "accepted": false, "id": "1405.3790"}, "pdf": {"name": "1405.3790.pdf", "metadata": {"source": "CRF", "title": "Transaction Logic with (Complex) Events", "authors": ["Ana Sofia Gomes", "Jos\u00e9 J\u00falio Alferes"], "emails": [], "sections": [{"heading": null, "text": "With this as goal, we build on Transaction Logic (T R), a logic precisely designed to model and execute transactions in KBs defined by arbitrary logic theories. In it, transactions are written in a logic-programming style, by combining primitive update operations over a general KB, with the usual logic programming connectives and some additional connectives e.g. to express sequence of actions. While T R is a natural choice to deal with transactions, it remains the question whether T R can be used to express complex events, but also to deal simultaneously with the detection of complex events and the execution of transactions. In this paper we show that the former is possible while the latter is not. For that, we start by illustrating how T R can express complex events, and in particular, how SNOOP event expressions can be translated in the logic. Afterwards, we show why T R fails to deal with the two issues together, and to solve the intended problem propose Transaction Logic with Events, its syntax, model theory and executional semantics. The achieved solution is a non-monotonic extension of T R, which guarantees that every complex event detected in a transaction is necessarily responded.\nTo appear in Theory and Practice of Logic Programming (TPLP)\nKEYWORDS: reactivity, complex events, transaction logic"}, {"heading": "1 Introduction", "text": "Reactivity stands for the ability to detect complex changes (also denoted as events) in the environment and react automatically to them according to some pre-defined rules. This is a pre-requisite of many real-world applications, such as web-services providing different services depending on external information, multi-agent systems adapting their knowledge and actions according to the changes in the environment, or monitoring systems reacting to information detected by their sensors and issuing actions automatically in response to it. In reactive systems, e.g. in those based on Event-Condition-Action (ECA) languages (Alferes et al. 2011; Bry et al. 2006; Chomicki et al. 2003), the reaction triggered by the detection of a complex event may itself be a complex action, formed e.g. by the sequencial execution of several basic actions. Moreover, we sustain that sometimes reactive systems are also required to execute transactions in response to events. For example, consider an airline web-service scenario where an external event arrives stating that a partner airline is on strike for a given time period. Then, the airline must address this event by e.g.\n\u2217 The authors thank Michael Kifer for the valuable discussions in a preliminary version of this work. The first author was supported by the grant SFRH/BD/64038/2009 and by project ERRO (PTDC/EIA-CCO/121823/2010). The second author was supported by project ASPEN PTDC/EIA-CCO/110921/2009\nar X\niv :1\n40 5.\n37 90\nv1 [\ncs .A\nI] 1\n5 M\nay 2\nrescheduling flights with alternative partners or refund tickets for passengers who do not accept the changes. Clearly, some transactional properties regarding these actions must be ensured: viz. it can never be the case that a passenger is simultaneously not refunded nor have an alternative flight; or that she is completely refunded and has a rescheduled flight.\nAlthough the possibility of executing transactions is of crucial importance in many of today\u2019s systems, and a must e.g. in database systems, most reactive languages do not deal with it. Some exceptions exist, but are either completely procedural and thus lack from a clear declarative semantics (as e.g. in (Papamarkos et al. 2006)), or have a strong limitation on the expressivity of either the actions or events (as e.g. in (Zaniolo 1995; Lausen et al. 1998)).\nIn this paper we propose Transaction Logic with Events, T Rev , an extension of T R (Bonner and Kifer 1993) integrating the ability to reason and execute transactions over very general forms of KBs, with the ability to detect complex events. For this, after a brief overview of T R, we show how it can be used to express and reason about complex events, and in particular, how it can express most SNOOP event operators (Adaikkalavan and Chakravarthy 2006) (Section 2). We proceed by showing why T R alone is not able to deal with both the detection of complex events and the execution of transactions, and, in particular, why it does not guarantee that all complex events detected during the execution of a transaction are responded within that execution. For solving this problem, we define T Rev , its language and model theory (Section 3.1), as well as its executional semantics (Section 3.2)."}, {"heading": "2 Using T R to express complex events", "text": "In this section we briefly recall T R\u2019s syntax and semantics with minor syntactic changes from the original, to help distinguish between actions and event occurrences, something that is useful ahead in the paper when extending T R to deal with reactive features and complex events.\nAtoms in T R have the form p(t1, . . . , tn) where p is a predicate symbol and ti\u2019s are terms (variables, constants, function terms). For simplicity, and without loss of generality (Bonner and Kifer 1998), we consider Herbrand instantiations, as usual. To build complex formulas, T R uses the classical connectives \u2227,\u2228,\u00ac,\u2190 and the connectives \u2297,\u2666 denoting serial conjunction and hypothetical execution. Informally, \u03c6 \u2297 \u03c8 is an action composed of an execution of \u03c6 followed by an execution of \u03c8; and \u2666\u03c6 tests if \u03c6 can be executed without materializing the changes. In general, formulas are viewed as (the execution of) transactions, where, \u03c6\u2227\u03c8 is the simultaneous execution of \u03c6 and \u03c8; \u03c6 \u2228 \u03c8 the non-deterministic choice of executing \u03c6 or \u03c8. \u03c6 \u2190 \u03c8 is a rule saying that one way to execute of \u03c6 is by executing \u03c8. As in classical logic, \u2227 and\u2190 can be written using \u2228 and \u00ac (e.g. \u03c6 \u2227 \u03c8 \u2261 \u00ac(\u00ac\u03c6 \u2228 \u00ac\u03c8)). Finally, we also use the connective ; as it is useful to express common complex events. \u03c6;\u03c8 says that \u03c8 is true after \u03c6 but possibly interleaved with other occurrences, and it can be written in T R syntax as: \u03c6\u2297 path\u2297 \u03c8 where path \u2261 (\u03d5 \u2228 \u00ac\u03d5) is a tautology that holds in paths of arbitrary size (Bonner and Kifer 1998).\nFor making possible the separation between the theory of states and updates, from the logic that combines them in transactions, T R considers a pair of oracles \u2013 Od (data oracle) and Ot (transition oracle) \u2013 as a parameter of the theory. These oracles are mappings that assume a set of state identifiers. Od is a mapping from state identifiers to a set of formulas that hold in that state, and Ot is a mapping from pairs of state identifiers to sets of formulas that hold in the transition of those states. These oracles can be instantiated with a wide variety of semantics, as e.g. relational databases, well-founded semantics, action languages, etc. (Bonner and Kifer 1993). For example, a relational database can be modeled by having states represented as sets of\nground atomic formulas. Then, the data oracle simply returns all these formulas, i.e., Od(D) = D, and for each predicate p in the KB, the transition oracle defines p.ins and p.del, representing the insertion and deletion of p, respectively. Formally, p.ins \u2208 Ot(D1, D2) iff D2 = D1 \u222a {p} and, p.del \u2208 Ot(D1, D2) iff D2 = D1\\{p}. SQL-style bulk updates can also be defined by Ot.\nExample 1 (Moving objects - T R) As a T R\u2019s illustration, assume the prior relational database oracles and the actionmove(O,X, Y ) defining the relocation of object O from position X into position Y . In such a KB, states are defined using the predicates location(O,P ) saying that object O is in position P , and clear(X) stating that X is clear to receive an object. In T R, the move (trans)action can be expressed by: move(O,X, Y )\u2190 location(O,X)\u2297 clear(Y )\u2297 localUpdt(O,X, Y ) localUpdt(O,X, Y )\u2190 location(O,X).del \u2297 location(O, Y ).ins\u2297 clear(Y ).del \u2297 clear(X).ins\nT R\u2019s theory is built upon the notion of sequences of states denoted as paths. Formulas are evaluated over paths, and truth in T R means execution: a formula is said to succeed over a path, if that path represents a valid execution for that formula. Although not part of the original T R, here paths\u2019 state transitions are labeled with information about what (atomic occurrences) happen in the transition of states. Precisely, paths have the form \u3008D0O1\u2192D2O2\u2192 . . .Ok\u2192Dk\u3009, where Di\u2019s are states and Oi\u2019s are labels (used later to annotate atomic event occurrences).\nAs usual, satisfaction of complex formulas is based on interpretations. These define what atoms are true in what paths, by mapping every path to a set of atoms. However, only the mappings compliant with the specified oracles are interpretations:\nDefinition 1 (Interpretation) An interpretation is a mapping M assigning a set of atoms (or >1) to every path, with the following restrictions (where Dis are states, and \u03d5 a formula):\n1. \u03d5 \u2208M(\u3008D\u3009) if \u03d5 \u2208 Od(D) 2. {\u03d5,o(\u03d5)} \u2286M(\u3008D1o(\u03d5)\u2192D2\u3009) if \u03d5 \u2208 Ot(D1, D2)\nIn point 2 we additionally (i.e., when compared to the original definition) force o(\u03d5) to belong to the same path where the primitive action \u03d5 is made true by the oracle, something that later (in Section 3) will help detect events associated with primitive actions, like \u201con insert/delete\u201d.\nNext, we define operations on paths, and satisfaction of complex formulas over general paths.\nDefinition 2 (Path Splits, Subpaths and Prefixes) Let \u03c0 be a k-path, i.e. a path of length k of the form \u3008D1 O1\u2192 . . .Ok\u22121\u2192Dk\u3009. A split of \u03c0 is any pair of subpaths, \u03c01 and \u03c02, such that \u03c01 = \u3008D1O1\u2192 . . .Oi\u22121\u2192Di\u3009 and \u03c02 = \u3008Di Oi\u2192 . . . Ok\u22121\u2192Dk\u3009 for some i (1 \u2264 i \u2264 k). In this case, we write \u03c0 = \u03c01 \u25e6 \u03c02. A subpath \u03c0\u2032 of \u03c0 is any subset of states and annotations of \u03c0 where both the order of the states and their annotations is preserved. A prefix \u03c01 of \u03c0 is any subpath of \u03c0 sharing the initial state.\n1 For not having to consider partial mappings, besides formulas, interpretations can also return the special symbol >. The interested reader is referred to (Bonner and Kifer 1993) for details.\nDefinition 3 (T R Satisfaction of Complex Formulas) Let M be an interpretation, \u03c0 a path and \u03c6 a formula. If M(\u03c0) = > then M,\u03c0 |=T R \u03c6; else:\n1. Base Case: M,\u03c0 |=T R \u03c6 iff \u03c6 \u2208M(\u03c0) for every event occurrence \u03c6 2. Negation: M,\u03c0 |=T R \u00ac\u03c6 iff it is not the case that M,\u03c0 |=T R \u03c6 3. Disjunction: M,\u03c0 |=T R \u03c6 \u2228 \u03c8 iff M,\u03c0 |=T R \u03c6 or M,\u03c0 |=T R \u03c8. 4. Serial Conjunction:M,\u03c0 |=T R \u03c6\u2297\u03c8 iff there exists a split \u03c01\u25e6\u03c02 of \u03c0 s.t.M,\u03c01 |=T R \u03c6\nand M,\u03c02 |=T R \u03c8 5. Executional Possibility: M,\u03c0 |=T R \u2666\u03c6 iff \u03c0 is a 1-path of the form \u3008D\u3009 for some state D\nand M,\u03c0\u2032 |=T R \u03c6 for some path \u03c0\u2032 that begins at D.\nModels and logical entailment are defined as usual. An interpretation models/satisfies a set of rules if each rule is satisfied in every possible path, and an interpretation models a rule in a path, if whenever it satisfies the antecedent, it also satisfies the consequent.\nDefinition 4 (Models, and Logical Entailment) An interpretation M is a model of a formula \u03c6 iff for every path \u03c0, M,\u03c0 |=T R \u03c6. M is a model of a set of rules P (denoted M |=T R P ) iff it is a model of every rule in P . \u03c6 is said to logically entail another formula \u03c8 iff every model of \u03c6 is also a model of \u03c8.\nLogical entailment is useful to define general equivalence and implication of formulas that express properties like \u201ctransaction \u03c6 is equivalent to transaction \u03c8\u201d or \u201cwhenever transaction \u03c8 is executed, \u03c8\u2032 is also executed\u201d. Moreover, if instead of transactions, we view the propositions as representing event occurrences, this entailment can be used to express complex events. For instance, imagine we want to state a complex event alarm, e.g. triggered whenever event ev1 occurs after both ev2 and ev3 occur simultaneously. This can be expressed in T R as:\no(alarm)\u2190 (o(e2) \u2227 o(e3));o(e1) (1)\nIn every model of this formula, whenever there is a (sub)path where both o(e2) and o(e3) are true, followed by a (sub)path where o(e1) holds, then o(alarm) is true in the whole path.\nOther complex event definitions are possible, and in fact we can encode most of SNOOP (Adaikkalavan and Chakravarthy 2006) operators in T R. This is shown in Theorem 1 where, for a given history of past event occurrences, we prove that if an event expression is true in SNOOP, then there is a translation into a T R formula which is also true in that history. Since a SNOOP history is a set of atomic events associated with discrete points in time, the first step is to build a T R path expressing such history. We construct it as a sequence of state identifiers labeled with time, where time point i takes place in the transition of states \u3008si, si+1\u3009, and only consider interpretations M over such a path that are compatible with SNOOP\u2019s history, i.e. such that, for every atomic event that is true in a time i, M makes the same event true in the path \u3008si, si+1\u3009.\nTheorem 1 (SNOOP Algebra and T R) Let E be a SNOOP algebra expression without periodic and aperiodic operators, H be a history containing the set of all SNOOP primitive events eij [t1] that have occurred over the time interval t1, tmax, and \u3008s1, . . . smax+1\u3009 be a path with size tmax\u2212 t1+1. Let \u03c4 be the following function:\nPrimitive: \u03c4(E) = o(E) where E is a primitive event Sequence: \u03c4(E1;E2) = \u03c4(E1)\u2297 path\u2297 \u03c4(E2) Or: \u03c4(E1OE2) = \u03c4(E1) \u2228 \u03c4(E2) AND: \u03c4(E14E2) = [(\u03c4(E1)\u2297 path) \u2227 (path\u2297 \u03c4(E2))] \u2228 [(\u03c4(E2)\u2297 path) \u2227 (path\u2297 \u03c4(E1))] NOT: \u03c4(\u00ac(E3)[E1, E2]) = \u03c4(E1)\u2297 \u00ac\u03c4(E3)\u2297 \u03c4(E2)\nThen, [ti, tf ] \u2208 E[H] \u21d2 \u2200M compatible with H , M, \u3008sti , . . . , stf+1\u3009 |=T R \u03c4(E), where, cf. (Adaikkalavan and Chakravarthy 2006), E[H] is the set of time intervals (ti, tf ) where E occurs over H in an unrestricted context, and where M is compatible with H if, for each eij [ti] \u2208 H: M, \u3008sti , sti+1\u3009 |=T R o(ej).\nBesides the logical entailment, T R also provides the notion of executional entailment for reasoning about properties of a specific execution path.\nDefinition 5 (Executional Entailment) Let P be a set of rules, \u03c6 a formula, and D0O1\u2192 . . .On\u2192Dn a path. P, (D0\nO1\u2192 . . .On\u2192Dn) |= \u03c6 (?) iff for every model M of P , M, \u3008D0O1\u2192 . . .On\u2192Dn\u3009 |= \u03c6. Additionally, P,D0\u2013 |= \u03c6 holds, if there is a path D0O1\u2192 . . .On\u2192Dn that makes (?) true.\nP, (D0 O1\u2192 . . .On\u2192Dn) |= \u03c6 says that a successful execution of transaction \u03c6 respecting the\nrules in P , can change the KB from stateD0 intoDn with a sequence of occurrencesO1, . . . , On. E.g., in the Example 1 (with obvious abbreviations), the statementP, ({cl(t), l(c, o)}o(l(c,o).del)\u2192 {cl(t)}o(l(c,t).ins)\u2192{cl(t), l(c, t)}o(cl(t).del)\u2192{l(c, t)}o(cl(o).ins)\u2192{l(c, t), cl(o)}) |= move(c, o, t) means that a possible result of executing the transactionmove(c, oven, table) starting in the state {clear(table), loc(c, oven)} is the path with those 5 states, ending in {loc(c, table), clear(oven)}.\nThis entailment has a corresponding proof theory (Bonner and Kifer 1993) which, for a subset of T R, is capable of constructing such a path given a program, a T R formula, and an initial state. I.e. a path where the formula can be executed. If no such path exists, then the transaction fails, and nothing is built after the initial state.\n3 T Rev: combining the execution of transactions with complex event detection\nReactive languages need to express behaviors like: \u201con alarm do action a1 followed by action a2\u201d, where the actions a1 \u2297 a2 may define a transaction, and alarm is e.g. the complex event in (1). Clearly, T R can individually express and reason about transaction a1 \u2297 a2, and its complex event. So, the question is whether it can deal with both simultaneously. For that, two important issues must be tackled: 1) how to model the triggering behavior of reactive systems, where the occurrence of an event drives the execution of a transaction in its response; 2) how to model the transaction behavior that prevents transactions to commit until all occurring events are responded.\nRegarding 1), (Bonner et al. 1993) shows that simple events can be triggered in T R as: p\u2190 body \u2297 ev ev \u2190 r(ev) (2)\nWith such rules, in all paths that make p true (i.e., in all executions of transaction p) the event ev is triggered/fired (after the execution of some arbitrary body), and ev\u2019s response, r(ev), is executed. Note that, both r(ev) and body can be defined as arbitrary formulas.\nBut, this is just a very simple and specific type of event: atomic events that are explicitly triggered by a transaction defined in the program. In general, atomic events can also arrive as external events, or because some primitive action is executed in a path (e.g. as the database triggers - \u201con insert/on delete\u201d). Triggering external events in T R can be done by considering the paths that make the external event true. E.g., if one wants to respond to an external event ev from an initial state, all we need to do is find the paths \u03c0 starting in that state, s.t. P, \u03c0 |= ev, where P includes the last rule from (2) plus the rules defining ev\u2019s response.\nThe occurrences of primitive actions can be tackled by Point 2 of Def. 1, and the occurrence of complex events can be defined as prescribed in Section 2. However, the above approach of\n(Bonner et al. 1993) does not help for driving the execution of an event response when such occurrences become true. For instance, the ECA-rule before could be stated as:\no(alarm)\u2190 (o(e2) \u2227 o(e3));o(e1) r(alarm)\u2190 a1 \u2297 a2\nBut this does not drive the execution of r(alarm) when o(alarm) holds; one has further to force that whenever o(alarm) holds, r(alarm) must be made true subsequently. Of course, adding a rule r(alarm) \u2190 o(alarm) would not work: such rule would only state that, one alternative way to satisfy the response of alarm is to make its occurrence true. And for that, it would be enough to satisfy o(alarm) to make r(alarm) true, which is not what is intended.\nClearly, this combination implies two different types of formulas with two very different behaviors: the detection of events which are tested for occurrence w.r.t. a past history; and the execution of transactions as a response to them, which intends to construct paths where formulas can succeed respecting transactional properties. This has to be reflected in the semantics and these formulas should be evaluated differently accordingly to their nature.\nRegarding 2), as in database triggers, transaction\u2019s execution must depend on the events triggered. Viz., an event occurring during a transaction execution can delay that transaction to commit/succeed until the event response is successfully executed, and the failure of such response should imply the failure of the whole transaction. Encoding this behavior requires that, if an event occurs during a transaction, then its execution needs to be expanded with the event response. Additionally, this also precludes transactions to succeed in paths where an event occurs and is not responded (even if the transaction would succeed in that path if the event did not existed).\nFor addressing these issues, below we define T Rev . This extension of T R evaluates event formulas and transaction formulas differently, using two distinct relations (respectively |=T R and |=), and occurrences and responses are syntactic represented w.r.t. a given event name e, as o(e) and r(e), respectively. In this context, |= requires transactions to be satisfied in expanded paths, where every occurring event (made true by |=T R) is properly responded.\n3.1 T Rev Syntax and Model Theory\nTo make possible a different evaluation of events and transactions, predicates in T Rev are partitioned into transaction names (Pt), event names (Pe), and oracle primitives (PO) and, as with T R, we work with the Herbrand instantiation of the language.\nFormulas in T Rev are partitioned into transaction formulas and event formulas. Event formulas denote formulas meant to be detected and are either an event occurrence, or an expression defined inductively as \u00ac\u03c6, \u03c6 \u2227 \u03c8, \u03c6 \u2228 \u03c8, \u03c6 \u2297 \u03c8, or \u03c6;\u03c8 where \u03c6 and \u03c8 are event formulas. An event occurrence is of the form o(\u03d5) s.t. \u03d5 \u2208 Pe or \u03d5 \u2208 PO. Note that, we preclude the usage of \u2666 in event formulas, as it would make little sense to detect occurrences based on what could possibly be executed.\nTransaction formulas are formulas that can be executed, and are either a transaction atom, or an expression defined inductively as \u00ac\u03c6, \u2666\u03c6, \u03c6 \u2227 \u03c8, \u03c6 \u2228 \u03c8, or \u03c6 \u2297 \u03c8. A transaction atom is either a transaction name (in Pt), an oracle defined primitive (in PO), the response to an event (r(\u03d5) where \u03d5 \u2208 PO \u222a Pe), or an event name (in Pe) The latter corresponds to the (trans)action of explicitly triggering an event directly in a transaction as in (2) or as an external event. As we shall see (Def. 7) explicitly triggering an event changes the path of execution (by asserting the information that the event has happened in the current state) and, as such, is different from simply inferring (or detecting) what events hold given a past path.\nFinally, rules have the form \u03d5 \u2190 \u03c8 and can be transaction or (complex) event rules. In a transaction rule \u03d5 is a transaction atom and \u03c8 a transaction formula; in an event rule \u03d5 is an event occurrence and \u03c8 is a event formula. A program is a set of transaction and event rules.\nImportantly, besides the data and transition oracles, T Rev is also parametric on a choice function defining what event should be selected at a given time in case of conflict. Since defining what event should be picked from the set of occurring events depends on the application in mind, T Rev does not commit to any particular definition, encapsulating it in function choice .\nAs a reactive system, T Rev receives a series of external events which may cause the execution of transactions in response. This is defined as P,D0\u2013 |= e1 \u2297 . . . \u2297 ek, where D0 is the initial KB state and e1 \u2297 . . .\u2297 ek is the sequence of external events that arrive to the system. Here, we want to find the pathD0O1\u2192 . . .On\u2192Dn encoding a KB evolution that responds to e1\u2297 . . .\u2297ek.\nAs mentioned, triggering explicit events is a transaction formula encoding the action of making an occurrence explicitly true. This is handled by the definition of interpretation, in a similar way to how atomic events defined by oracles primitives are made true:\nDefinition 6 (T Rev interpretations) A T Rev interpretation is a T R interpretation that additionally satisfies the restriction: 3) o(e) \u2208 M(\u3008Do(e)\u2192D\u3009) if e \u2208 Pe\nWe can now define the satisfaction of complex formulas, and then models of a program. Event formulas are evaluated w.r.t. the relation |=T R specified in Def. 3. Transaction formulas are evaluated w.r.t. the relation |= which requires formulas to be true in expanded paths, in which every occurring event is responded (something dealt by expM (\u03c0), defined below).\nDefinition 7 (Satisfaction of Transaction Formulas and Models) Let M be an interpretation, \u03c0 a path, \u03c6 transaction formula. If M(\u03c0) = > then M,\u03c0 |= \u03c6; else:\n1. Base Case: M,\u03c0 |= p iff \u2203\u03c0\u2032 prefix of \u03c0 s.t. p \u2208 M(\u03c0\u2032) and \u03c0 = expM (\u03c0\u2032), for every transaction atom p where p 6\u2208 Pe. 2. Event Case:M,\u03c0 |= e iff e \u2208 Pe, \u2203\u03c0\u2032 prefix of \u03c0 s.t.M,\u03c0\u2032 |=T R o(e) and \u03c0 = expM (\u03c0\u2032). 3. Negation: M,\u03c0 |= \u00ac\u03c6 iff it is not the case that M,\u03c0 |= \u03c6 4. Disjunction: M,\u03c0 |= \u03c6 \u2228 \u03c8 iff M,\u03c0 |= \u03c6 or M,\u03c0 |= \u03c8. 5. Serial Conjunction: M,\u03c0 |= \u03c6 \u2297 \u03c8 iff \u2203\u03c0\u2032 prefix of \u03c0 and some split \u03c01 \u25e6 \u03c02 of \u03c0\u2032 such\nthat M,\u03c01 |= \u03c6 and M,\u03c02 |= \u03c8 and \u03c0 = expM (\u03c0\u2032). 6. Executional Possibility: M,\u03c0 |= \u2666\u03c6 iff \u03c0 is a 1-path of the form \u3008D\u3009 for some state D and M,\u03c0\u2032 |= \u03c6 for some path \u03c0\u2032 that begins at D.\nAn interpretation M is a model of a transaction formula (resp. event formula) \u03c6 iff for every path \u03c0, M,\u03c0 |= \u03c6 (resp. M,\u03c0 |=T R \u03c6). M is a model of a program P (denoted M |= P ) iff it is a model of every (transaction and complex event) rule in P .\nexpM (\u03c0) is a function that, given a path with possibly unanswered events, expands it with the result of responding to those events. Its definition must perforce have some procedural nature: it must start by detecting which are the unanswered events; pick one of them, according to a given choice function; then expand the path with the response of the chosen event. The response to this event, computed by operatorRM defined below, may, in turn, generate the occurrence of further events. So,RM must be iterated until no more unanswered events exist.\nDefinition 8 (Expansion of a Path) For a path \u03c01 and an interpretation M , the response operatorRM (\u03c01) is defined as follows:\nRM (\u03c01) = { \u03c01 \u25e6 \u03c02 if choice(M,\u03c01) = e and M,\u03c02 |= r(e) \u03c01 if choice(M,\u03c01) =\nThe expansion of a path \u03c0 is expM (\u03c0) =\u2191 RM (\u03c0).\nIn general it may not be possible to address all events in a finite path, and thus, RM may not have a fixed-point. In fact, non-termination is a known problem of reactive systems, and is often undecidable for the general case (Bailey et al. 2004). However, if termination is possible, then a fixed-point exists and each iteration ofRM is an approximation of the expansion operator expM .\nThis definition leaves open the choice function, that is taken as a further parameter of T Rev , and specifies how to choose the next unanswered event to respond to. For its instantiation one needs to decide: 1) in which order should events be responded and 2) how should an event be responded. The former defines the handling order of events in case of conflict, e.g. based on when events have occurred (temporal order), on a priority list, or any other criteria. The latter defines the response policy of an ECA-language, i.e. when is an event considered to be responded. E.g., if an event occurs more than once before the system can respond to it, this specifies if such response should be issued only once or equally to the amount of occurrences. Choosing the appropriate operational semantics depends on the application in mind. In the following definition we exemplify how this choice function can be instantiated, for a case when events are responded in the (temporal) order in which they occurred, and events for which there was already a response are not responded again.\nDefinition 9 (Temporal choice function) Let M be an interpretation and \u03c0 be a path. The temporal choice function is choice(M,\u03c0) = firstUnans(M,\u03c0, order(M,\u03c0)) where:\n\u2022 order(M,\u03c0) = \u3008e1, . . . , en\u3009 iff \u2200ei 1 \u2264 i \u2264 n, \u2203\u03c0i subpath of \u03c0 where M,\u03c0 |=T R o(ei) and \u2200ej s.t. i < j then ej occurs after ei \u2022 e2 occurs after e1 w.r.t. \u03c0 and M iff there exists \u03c01, \u03c02 subpaths of \u03c0 such that \u03c01 = \u3008Di Oi\u2192 . . .Oj\u22121\u2192Dj\u3009, \u03c02 = \u3008DnOn\u2192 . . .Om\u22121\u2192Dm\u3009, M,\u03c01 |= o(e1), M,\u03c02 |= o(e2) and Dj \u2264 Dm w.r.t. the ordering in \u03c0. \u2022 firstUnans(M,\u03c0, \u3008e1, . . . , en\u3009) = ei iff ei is the first event in \u3008e1, . . . , en\u3009 where given \u03c0\u2032 subpath of \u03c0 and M,\u03c0\u2032 |=T R o(e) then \u00ac\u2203\u03c0\u2032\u2032 s.t. \u03c0\u2032\u2032 is also a subpath of \u03c0, \u03c0\u2032\u2032 is after \u03c0\u2032 and M,\u03c0\u2032\u2032 |= r(e).\nWe continue by exemplifying the semantics in examples.\nExample 2 p\u2190 a.ins r(e1)\u2190 c.ins\n(P3) p\u2190 a.ins r(e1)\u2190 c.ins o(e1)\u2190 o(a.ins)\n(P4)\nConsider the programs2 P3 and P4. In P3, p holds in the path \u3008{}o(a.ins)\u2192{a}\u3009. This is true since all interpretations must comply with the oracles and thus \u2200M : a.ins \u2208 M(\u3008{}o(a.ins)\u2192{a}\u3009)\n2 For brevity, in this and the following examples we assume the rule r(p)\u2190 true to appear in every program for every primitive action p defined in the signature of the oracles, unless when stated otherwise. I.e., we assume the responses of events inferred from primitive actions to hold trivially whenever their rules do not appear explicitly in the program.\nimplying M, \u3008{}o(a.ins)\u2192{a}\u3009 |= a.ins. Assuming that M is a model of P3, then it satisfies the rule p\u2190 a.ins, which means that p \u2208M(\u3008{}o(a.ins)\u2192{a}\u3009) and M, \u3008{}o(a.ins)\u2192{a}\u3009 |= p.\nHowever, since o(e1) \u2190 o(a.ins) \u2208 P4 and \u2200M.o(a.ins) \u2208 M(\u3008{}o(a.ins)\u2192{a}\u3009), for M to be a model of P4, then o(e1) \u2208 M(\u3008{}o(a.ins)\u2192{a}\u3009). Since e1 has a response defined, then in path \u3008{}o(a.ins)\u2192{a}\u3009 the occurrence e1 is unanswered and both the transactions p and a.ins cannot succeed in that path. Namely, o(e1) constrains the execution of every transaction in the path \u3008{}o(a.ins)\u2192{a}\u3009 and, for transaction formulas to succeed, such path needs to be expanded with e1\u2019s response. Since, expM (\u3008{} a.ins\u2192{a}\u3009) = \u3008{} o(a.ins)\u2192{a} o(c.ins)\u2192{a, c}\u3009 then, both transactions p and a.ins succeed in the longer path \u3008{}o(a.ins)\u2192{a}o(c.ins)\u2192{a, c}\u3009, i.e. for an M model of P4: M, \u3008{} o(a.ins)\u2192 {a} o(c.ins)\u2192 {a, c}\u3009 |= p and M, \u3008{} o(a.ins)\u2192 {a} o(c.ins)\u2192{a, c}\u3009 |= a.ins. Notice the non-monotonicity of T Rev , viz. that adding a new event rule to P3 falsifies the transaction formulas p and a.ins in paths where they were previously true.\nAs in T R, in T Rev every formula that is meant to be executed, is meant to be executed as a transaction. As such, the primitive a.ins in example P4 cannot succeed in the path \u3008{} o(a.ins)\u2192{a}\u3009 since there are unanswered events in that path. However, note that a.ins belongs to every interpretation M of that path (due to the restrictions in Def. 1). Thus the primitive a.ins is true in \u3008{}o(a.ins)\u2192{a}\u3009 although the transaction a.ins is not.\nExample 3\np\u2190 a.ins q \u2190 b.ins r(ex)\u2190 p\u2297 q r(e1)\u2190 d.ins r(a.ins)\u2190 c.ins o(e1)\u2190 o(a.ins)\u2297 o(b.ins)\n{a}\np\n{a, c}\nr(e1)\n{} {a, b, c} {a, b, c, d}\nq\no(e1)\no(a.ins) o(c.ins) o(b.ins)\nr(a.ins)\no(d.ins)\na.ins\nc.ins b.ins\nd.ins\nex\no(ex)\np\u2326 q\n{} The right-hand side figure illustrates a satisfaction of the external event ex. The occurrence of ex forces the satisfaction of the transaction p\u2297q, which is true if both its \u201csubformulas\u201d (p and q) are satisfied over smaller paths. Note that, by definition of the relation |=, all occurrences detected over the independent paths that satisfy p and q are already responded in those paths. Thus, we need only to cater for the events triggered due to the serial conjunction. Here, for a model M of the program, M, \u3008{}o(a.ins)\u2192{a}o(c.ins)\u2192{a, c}\u3009 |= p and M, \u3008{a, c}o(b.ins)\u2192{a, b, c}\u3009 |= q. Further, the rule o(e1) \u2190 o(a.ins) \u2297 o(b.ins) defines one pattern for the occurrence of e1 which constrains the execution of transaction p \u2297 q and forces the expansion of the path to satisfy r(e1). Consequently, M, \u3008{} o(a.ins)\u2192 {a} o(c.ins)\u2192 {a, c} o(b.ins)\u2192 {a, b, c} o(d.ins)\u2192 {a, b, c, d}\u3009 |= p \u2297 q, and M, \u3008{} o(ex)\u2192 {} o(a.ins)\u2192 {a} o(c.ins)\u2192 {a, c} o(b.ins)\u2192 {a, b, c} o(d.ins)\u2192{a, b, c, d}\u3009 |= ex"}, {"heading": "3.2 Entailment and Properties", "text": "The logical entailment defined in Def. 4 can be used to reason about properties of transaction and event formulas that hold for every possible path of execution. In T Rev , similarly to T R, we further define executional entailment, to talk about properties of a particular execution path. But, to reason about the execution of transactions over a specific path, care must be taken since, as described above, the satisfaction of a new occurrence in a path may invalidate transaction formulas that were previously true.\nTo deal with a similar behavior, non-monotonic logics rely on the concept of minimal or preferred models: instead of considering all possible models, non-monotonic theories restrict to the most skeptical ones. Likewise, T Rev uses the minimal models of a program to define entailment, whenever talking about a particular execution of a formula. As usual, minimality is defined by set inclusion on the amount of predicates that an interpretation satisfies, and a minimal model is a model that minimizes the set of formulas that an interpretation satisfies in a path.\nDefinition 10 (Minimal Model) Let M1 and M2 be interpretations. Then M1 \u2264M2 if \u2200\u03c0: M2(\u03c0) = > \u2228M1(\u03c0) \u2286M2(\u03c0) Let \u03c6 be a T Rev formula, and P a program. M is a minimal model of \u03c6 (resp. P ) if M is a model of \u03c6 (resp. P ) and M \u2264M \u2032 for every model M \u2032 of \u03c6 (resp. P ).\nThus, to know if a formula succeeds in a particular path, we need only to consider the event occurrences supported by that path, either because they appear as occurrences in the transition of states, or because they are a necessary consequence of the program\u2019s rules given that path. Because of this, executional entailment in T Rev is defined w.r.t. minimal models (cf. Def. 5).\nDefinition 11 (T Rev Executional Entailment) Let P be a program, \u03c6 a transaction formula and D1 O0\u2192 . . . On\u2192 Dn a path. Then P, (D1 O0\u2192 . . .On\u2192Dn) |= \u03c6 (?) iff for every minimal model M of P , M, \u3008D1O0\u2192 . . .On\u2192Dn\u3009 |= \u03c6. P,D1\u2013 |= \u03c6 is said to be true, if there is a path D1O0\u2192 . . .On\u2192Dn that makes (?) true.\nInterestingly, as in logic programs, formulas satisfied by this entailment have some support.\nLemma 1 (Support) Let P be a program, \u03c0 a path, \u03c6 a transaction atom. Then, if P, \u03c0 |= \u03c6 one of the following holds:\n1. \u03c6 is an elementary action and either \u03c6 \u2208 Od(\u03c0) or \u03c6 \u2208 Ot(\u03c0); 2. \u03c6 is the head of a transaction rule in P (\u03c6\u2190 body) and P, \u03c0 |= body;\nAs expected, T Rev extends T R. Precisely, if a program P has no complex event rules, and for every elementary action a defined by the oracles the only rule for r(a) in P is r(a)\u2190 true, then executional entailment in T Rev can be recast in T R if, T R executional entailment is also restricted to minimal models. It is worth noting that, for a large class of T R theories, and namely for the so-called serial-Horn theories, executional entailment in general coincides with that only using minimal models (cf. (Bonner and Kifer 1993)). As an immediate corollary, it follows that if P is event-free and serial-Horn, then executional entailment in T Rev and in T R coincide."}, {"heading": "4 Discussion and Related Work", "text": "Several solutions exist to reason about complex events. Complex event processing (CEP) systems as (Adaikkalavan and Chakravarthy 2004; Wu et al. 2006) can reason efficiently with large streams of data and detect (complex) events. These support a rich specification of events based on event pattern rules combining atomic events with some temporal constructs. As shown in Theorem 1, T R and T Rev can express most event patterns of SNOOP and, ETALIS (Anicic et al. 2012) CEP system even uses T R\u2019s syntax and connectives, although abandoning T R\u2019s model theory and providing a different satisfaction definition. However, in contrast to T Rev , CEP systems do not deal with the execution of actions in reaction to the events detected.\nExtensions of Situation Calculus, Event Calculus, Action Languages, etc. exist with the ability to react to events, and have some transactional properties (Baral et al. 1997; Bertossi et al. 1998).\nHowever, as in database triggers, these events are restricted to detect simple actions like \u201con insert/delete\u201d and thus have a very limited expressivity that fails to encode complex events, as defined in CEP systems and in T Rev . To simultaneously reason about actions and complex events, ECA (following the syntax \u201con event if condition do action\u201d) languages (Alferes et al. 2011; Bry et al. 2006; Chomicki et al. 2003) and logic programming based languages (Kowalski and Sadri 2012; Costantini and Gasperis 2012) exist. These languages normally do not allow the action component of the language to be defined as a transaction, and when they do, they lack from a declarative semantics as (Papamarkos et al. 2006); or they are based on active databases and can only detect atomic events defined as insertions/deletes (Zaniolo 1995; Lausen et al. 1998).\nIn contrast, T Rev can deal with arbitrary atomic and complex events, and make these events trigger transactions. This is done by a logic-programming like declarative language. We have also defined a procedure to execute these reactive transactions, which is built upon the complex event detection algorithm of ETALIS and the execution algorithm of T R, but is omitted for lack of space."}], "references": [{"title": "Formalization and detection of events over a sliding window in active databases using interval-based semantics", "author": ["R. ADAIKKALAVAN", "S. CHAKRAVARTHY"], "venue": "ADBIS", "citeRegEx": "ADAIKKALAVAN and CHAKRAVARTHY,? \\Q2004\\E", "shortCiteRegEx": "ADAIKKALAVAN and CHAKRAVARTHY", "year": 2004}, {"title": "Snoopib: Interval-based event specification and detection for active databases", "author": ["R. ADAIKKALAVAN", "S. CHAKRAVARTHY"], "venue": "Data Knowl. Eng. 59,", "citeRegEx": "ADAIKKALAVAN and CHAKRAVARTHY,? \\Q2006\\E", "shortCiteRegEx": "ADAIKKALAVAN and CHAKRAVARTHY", "year": 2006}, {"title": "Evolving reactive logic programs", "author": ["J.J. ALFERES", "F. BANTI", "A. BROGI"], "venue": "Intelligenza Artificiale", "citeRegEx": "ALFERES et al\\.,? \\Q2011\\E", "shortCiteRegEx": "ALFERES et al\\.", "year": 2011}, {"title": "Stream reasoning and complex event processing in etalis", "author": ["D. ANICIC", "S. RUDOLPH", "P. FODOR", "N. STOJANOVIC"], "venue": "Semantic Web", "citeRegEx": "ANICIC et al\\.,? \\Q2012\\E", "shortCiteRegEx": "ANICIC et al\\.", "year": 2012}, {"title": "On the decidability of the termination problem of active database systems", "author": ["J. BAILEY", "G. DONG", "K. RAMAMOHANARAO"], "venue": "Theor. Comput. Sci. 311,", "citeRegEx": "BAILEY et al\\.,? \\Q2004\\E", "shortCiteRegEx": "BAILEY et al\\.", "year": 2004}, {"title": "Formal characterizations of active databases: Part ii", "author": ["C. BARAL", "J. LOBO", "G. TRAJCEVSKI"], "venue": "In DOOD. LNCS,", "citeRegEx": "BARAL et al\\.,? \\Q1997\\E", "shortCiteRegEx": "BARAL et al\\.", "year": 1997}, {"title": "Specifying active databases in the situation calculus", "author": ["L.E. BERTOSSI", "J. PINTO", "R. VALDIVIA"], "venue": "In SCCC. IEEE Computer Society,", "citeRegEx": "BERTOSSI et al\\.,? \\Q1998\\E", "shortCiteRegEx": "BERTOSSI et al\\.", "year": 1998}, {"title": "Transaction logic programming", "author": ["A.J. BONNER", "M. KIFER"], "venue": "In ICLP", "citeRegEx": "BONNER and KIFER,? \\Q1993\\E", "shortCiteRegEx": "BONNER and KIFER", "year": 1993}, {"title": "Results on reasoning about updates in transaction logic", "author": ["A.J. BONNER", "M. KIFER"], "venue": "In Transactions and Change in Logic Databases", "citeRegEx": "BONNER and KIFER,? \\Q1998\\E", "shortCiteRegEx": "BONNER and KIFER", "year": 1998}, {"title": "Database programming in transaction logic", "author": ["A.J. BONNER", "M. KIFER", "M.P. CONSENS"], "venue": "In DBPL", "citeRegEx": "BONNER et al\\.,? \\Q1993\\E", "shortCiteRegEx": "BONNER et al\\.", "year": 1993}, {"title": "Reactivity on the web: Paradigms and applications of the language xchange", "author": ["F. BRY", "M. ECKERT", "PATRANJAN", "P.-L"], "venue": "J. Web Eng", "citeRegEx": "BRY et al\\.,? \\Q2006\\E", "shortCiteRegEx": "BRY et al\\.", "year": 2006}, {"title": "Conflict resolution using logic programming", "author": ["J. CHOMICKI", "J. LOBO", "S.A. NAQVI"], "venue": "IEEE Trans. Knowl. Data Eng", "citeRegEx": "CHOMICKI et al\\.,? \\Q2003\\E", "shortCiteRegEx": "CHOMICKI et al\\.", "year": 2003}, {"title": "Complex reactivity with preferences in rule-based agents", "author": ["S. COSTANTINI", "G.D. GASPERIS"], "venue": "In RuleML", "citeRegEx": "COSTANTINI and GASPERIS,? \\Q2012\\E", "shortCiteRegEx": "COSTANTINI and GASPERIS", "year": 2012}, {"title": "A logic-based framework for reactive systems", "author": ["R.A. KOWALSKI", "F. SADRI"], "venue": "In RuleML", "citeRegEx": "KOWALSKI and SADRI,? \\Q2012\\E", "shortCiteRegEx": "KOWALSKI and SADRI", "year": 2012}, {"title": "On active deductive databases: The statelog approach", "author": ["G. LAUSEN", "B. LUD\u00c4SCHER", "MAY"], "venue": "In Transactions and Change in Logic Databases", "citeRegEx": "LAUSEN et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LAUSEN et al\\.", "year": 1998}, {"title": "Event-condition-action rules on rdf metadata in p2p environments", "author": ["G. PAPAMARKOS", "A. POULOVASSILIS", "P.T. WOOD"], "venue": "Comp. Networks", "citeRegEx": "PAPAMARKOS et al\\.,? \\Q2006\\E", "shortCiteRegEx": "PAPAMARKOS et al\\.", "year": 2006}, {"title": "High-performance complex event processing over streams", "author": ["E. WU", "Y. DIAO", "S. RIZVI"], "venue": "In SIGMOD Conference", "citeRegEx": "WU et al\\.,? \\Q2006\\E", "shortCiteRegEx": "WU et al\\.", "year": 2006}, {"title": "Active database rules with transaction-conscious stable-model semantics. In DOOD", "author": ["Ana Sofia Gomes", "C. Jos\u00e9 J\u00falio Alferes ZANIOLO"], "venue": null, "citeRegEx": "Gomes and ZANIOLO,? \\Q1995\\E", "shortCiteRegEx": "Gomes and ZANIOLO", "year": 1995}], "referenceMentions": [], "year": 2014, "abstractText": "This work deals with the problem of combining reactive features, such as the ability to respond to events and define complex events, with the execution of transactions over general Knowledge Bases (KBs). With this as goal, we build on Transaction Logic (T R), a logic precisely designed to model and execute transactions in KBs defined by arbitrary logic theories. In it, transactions are written in a logic-programming style, by combining primitive update operations over a general KB, with the usual logic programming connectives and some additional connectives e.g. to express sequence of actions. While T R is a natural choice to deal with transactions, it remains the question whether T R can be used to express complex events, but also to deal simultaneously with the detection of complex events and the execution of transactions. In this paper we show that the former is possible while the latter is not. For that, we start by illustrating how T R can express complex events, and in particular, how SNOOP event expressions can be translated in the logic. Afterwards, we show why T R fails to deal with the two issues together, and to solve the intended problem propose Transaction Logic with Events, its syntax, model theory and executional semantics. The achieved solution is a non-monotonic extension of T R, which guarantees that every complex event detected in a transaction is necessarily responded. To appear in Theory and Practice of Logic Programming (TPLP)", "creator": "LaTeX with hyperref package"}}}