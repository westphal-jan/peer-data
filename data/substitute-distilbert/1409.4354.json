{"id": "1409.4354", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Sep-2014", "title": "A Binary Schema and Computational Algorithms to Process Vowel-based Euphonic Conjunctions for Word Searches", "abstract": "comprehensively speaking for items in sanskrit e - text is a non - trivial problem because somebody could change their forms in different contexts. one such context is sandhi or euphonic conjunctions, which cause a complete name change owing to the presence other adjacent letters or words. the change wrought onto these possible conjunctions can be so significant in sanskrit that a simple search for the word in its nearest speech alone can thereby reduce the success level of the search. numerical work presents a representational schema that represents letters in a binary format and reduces paninian before sending euphonic conjunctions to many bit set - unset operations. the figure presents an efficient algorithm to process vowel - based sandhis producing this schema. it further employs another algorithm that uses the sandhi processor to generate the possible transformed word forms of a given word to use in a comprehensive word search.", "histories": [["v1", "Mon, 15 Sep 2014 18:08:33 GMT  (438kb)", "http://arxiv.org/abs/1409.4354v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["s v kasmir raja", "v rajitha", "meenakshi lakshmanan"], "accepted": false, "id": "1409.4354"}, "pdf": {"name": "1409.4354.pdf", "metadata": {"source": "CRF", "title": "A Binary Schema and Computational Algorithms to Process Vowel-based Euphonic Conjunctions for Word Searches", "authors": ["Kasmir Raja S. V", "Meenakshi Lakshmanan"], "emails": ["warftrajitha@gmail.com"], "sections": [{"heading": null, "text": "Comprehensively searching for words in Sanskrit E-text is a non-trivial problem because words could change their forms in different contexts. One such context is sandhi or euphonic conjunctions, which cause a word to change owing to the presence of adjacent letters or words. The change wrought by these possible conjunctions can be so significant in Sanskrit that a simple search for the word in its given form alone can significantly reduce the success level of the search. This work presents a representational schema that represents letters in a binary format and reduces P\u0101\u1e47inian rules of euphonic conjunctions to simple bit set-unset operations. The work presents an efficient algorithm to process vowelbased sandhis using this schema. It further presents another algorithm that uses the sandhi processor to generate the possible transformed word forms of a given word to use in a comprehensive word search.\nKeywords: Sanskrit, euphonic conjunction, sandhi, linguistics, Panini, Sanskrit word search, e-text search."}, {"heading": "1. Introduction", "text": "Over the past decade, a large and increasing number of philosophical, grammatical, literary and other works in Sanskrit have become available for reference as E-texts in digital libraries [15-18]. Many of the old printed books that are the sources of the Sanskrit E-texts do not have extensive tables of contents or detailed word-indices. As such, a cumbrous manual search is usually needed to locate specific words or phrases\n7128 Kasmir Raja S. V. et al\nof interest in them. With the E-texts in Unicode, readers have the great advantage of being able to search rapidly and with ease for what they seek.\nComprehensively searching for and effectively locating specific Sanskrit words or phrases is important and useful in a variety of ways to modern researchers as well as to traditional Pundits. For instance, the presence or absence of certain phrases and the frequency of occurrence of specific words have been proposed and used as factors to investigate the authorship of several philosophical works. In a couple of instances, certitude about the position of the author on an issue of importance has been arrived at by examining whether anywhere in his work he has used two key words synonymously. Pundits are normally in a position to recall many words and phrases of the traditional, authoritative texts that they expound and often specify portions of texts by means of key words and phrases. Several scholarly debates and books have focussed on where and how some profound words have been used in scriptural texts. In view of the availability for reference of a large repertoire of Sanskrit E-texts and the aforesaid importance and usefulness of automated word-searches to researchers as well as to traditional Pundits, a computational algorithm is required for comprehensively and effectively locating in the Sanskrit E-texts, specified words and phrases. The reason for directing attention to Sanskrit E-texts is the extent of the complexity involved in comprehensively searching for Sanskrit words and phrases; it is demonstrably insufficient to search for just the specified word as is done in the case of English and as is generally being done at present even in the case of Sanskrit Etexts."}, {"heading": "2. The Problem", "text": "Unlike in the case of English E-texts, to search comprehensively for a word or phrase in a Sanskrit E-text, euphonic conjunctions (\u2018sandhis\u2019) need to be considered. A sandhi is a point in a word or between words, at which adjacent letters coalesce and transform. This is a common feature of Indian languages and is particularly elaborately dealt with and used in Sanskrit. For example, the compound word \u2018asamardhi\u1e25\u2019 (meaning unmatched affluence) can, owing to there being options with regard to a euphonic conjunction within it, also be written as \u2018asamarddhi\u1e25\u2019. Moreover, were it to be preceded in a sentence by a word ending with \u2018a\u2019 and followed by a word beginning with \u2018a\u2019, it could even be encountered as \u2018\u0101samarddhir\u2019. Decidedly, a simple search for \u2018asamardhi\u1e25\u2019 would not yield \u2018\u0101samarddhir\u2019, the equivalent form in which it may be present in the document. Existing search engines [19] do not provide such comprehensive search capabilities.\nThus, all the grammatically permissible euphonic conjunctions that are pertinent to the Sanskrit word or phrase of interest ought to be considered, the various resulting forms in which the word or phrase may be encountered in the text generated and all of them duly searched for.\nSince searching is itself a costly operation if the given source text is large, which is often the case with ancient Sanskrit works, the sandhi processing needs to be done"}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7129\nextremely quickly in spite of the complexity and number of sandhi rules required to be processed. Thus, the problem includes the performance parameter as well."}, {"heading": "2.1. Language Representation", "text": "The Unicode (UTF-8) standard is what has been adopted universally for the purpose of encoding Indian language texts into digital format. The Unicode Consortium has assigned the Unicode hexadecimal range 0900 - 097F for Sanskrit characters, i.e. the Devan\u0101gar\u012b script.\nAll characters including the diacritical characters used to represent Sanskrit letters in E-texts are found dispersed across the Basic Latin (0000-007F), Latin-1 Supplement (0080-00FF), Latin Extended-A (0100-017F) and Latin Extended Additional (1E00 \u2013 1EFF) Unicode ranges.\nThe Latin character set has been employed in this work to represent Sanskrit letters as E-text. The schema and algorithms presented do not use Devan\u0101gar\u012b script. To use the algorithms for text that is in Devan\u0101gar\u012b script, the text needs to be converted to Latin text that uses diacritical marks for the special letters in Sanskrit."}, {"heading": "2.2. The Basis of this Work", "text": "While working with or processing Sanskrit grammar, authenticity is acknowledged only if the work is based on the rules of Sanskrit grammar codified by the ancient grammarian P\u0101\u1e47ini in his celebrated work, \u2018A\u1e63\u1e6d\u0101dhy\u0101y\u012b\u2019 (which simply means \u2018work in eight chapters\u2019). The work contains comprehensive information codified in the form of terse s\u016b\u1e6dras or aphorisms and is saluted universally as the ultimate authority on Sanskrit grammar. The work is also hailed as the product of an extraordinarily sharp mind, for mastering it requires years of study along with commentaries such as the Mah\u0101bh\u0101\u1e63ya of Sage Pata\u00f1jali, the Siddh\u0101nta-kaumud\u012b of Bha\u1e6d\u1e6doji D\u012bk\u1e63ita and the K\u0101\u015bik\u0101 of V\u0101mana and Jay\u0101ditya.\nFor the current work that deals with the processing of euphonic conjunctions, the Siddh\u0101nta-kaumud\u012b [1] and the K\u0101\u015bik\u0101 [2] have been used as the bases. Both are recognized by scholars as authentic and unabridged commentaries on P\u0101\u1e47ini\u2019s work. The former has a different ordering of sutras in a convenient topic-wise categorization, while the latter preserves the crucial ordering inherent in the original work of P\u0101\u1e47ini."}, {"heading": "2.3. The M\u0101he\u015bvara-s\u016btras", "text": "The M\u0101he\u015bvara-s\u016btras, or the \u2018aphorisms of Mahe\u015bvara\u2019, are said to have emanated from a special drum called \u2018\u1e0damaru\u2019 (hourglass drum) held in the hand of Lord Mahe\u015bvara (a form of God in the Hindu pantheon). These sounds constitute the entire Sanskrit alphabet ordered in a specific sequence. The aphorisms of P\u0101\u1e47ini are framed using these M\u0101he\u015bvara aphorisms as basis, and cannot be understood without them. There are fourteen M\u0101he\u015bvara aphorisms and these are listed below:\n1. a-i-u-\u1e47 2. \u1e5b-\u1e37-k 3. e-o-\u1e45 4. ai-au-c\n7130 Kasmir Raja S. V. et al\n5. ha-ya-va-ra-\u1e6d 6. la-\u1e47 7. \u00f1a-ma-\u1e45a-\u1e47a-na-m 8. jha-bha-\u00f1 9. gha-\u1e0dha-dha-\u1e63 10. ja-ba-ga-\u1e0da-da-\u015b 11. kha-pha-cha-\u1e6dha-tha-ca-\u1e6da-ta-v 12. ka-pa-y 13. \u015ba-\u1e63a-sa-r 14. ha-l\nThe last letter in each of the above aphorisms is only a place-holder and is not counted as an actual letter of the aphorism. The first four aphorisms list the short forms of all the vowels, while the rest list the consonants. It must be noted that the letter \u2018a\u2019 added to each of the consonants is only to facilitate pronunciation and is not part of the consonant proper."}, {"heading": "3. The Approach", "text": "There are more than seventy aphorisms of P\u0101\u1e47ini that deal with sandhis. These aphorisms lay out the rules for sandhi transformations, giving the conditions under which they take place.\nThe challenge is to develop a computational algorithm to handle the entire range of sandhis. Such a computational algorithm would be useful to search for various forms of a given word in Sanskrit, thus enabling a thorough search of Unicode texts. The task of arriving at the resultant transformed word given two words may be an easy one for a human being thoroughly conversant with the grammatical rules of Sanskrit, but it is a computationally non-trivial task, given the complexity of the rules. Existing methods of sandhi processing are based on a derived understanding of the functioning of euphonic conjunctions and do not start from the P\u0101\u1e47ini-s\u016btras. Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them. There has been one work that has formulated a mathematical model of the original aphorisms that lends itself to speedy processing [14].\nThe present work too directly codifies P\u0101\u1e47ini\u2019s rules in a novel way using binary representations. A unique data representation has been devised in this work that simplifies rules to minimal binary set-unset operations. As such, this work presents an enhanced-efficiency alternative to the earlier methods. Furthermore, it simplifies the understanding of the entire grammar related to euphonic conjunctions."}, {"heading": "4. The Binary Schema", "text": "A point of sandhi is denoted by"}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7131\nwhere and denote the sandhi letters and the symbol \u2018+\u2019 denotes adjacency. The variable denotes the sequence of letters culminating in ; the variable denotes the sequence of letters starting with . The notations and are used to depict special conditions that pertain to an entire word or sequence of letters involved in the sandhi rule.\nSandhi rules often involve the letter immediately preceding and/or the letter immediately succeeding . Hence, we denote these letters as and respectively. As such, in cases where letters adjacent to the actual sandhi letters play a role in determining the outcome of the sandhi, we have\nA unique schematic has been developed in this work to represent the letters of the Sanskrit alphabet. Any letter of the alphabet is represented in two parts. Table 1 gives the scheme used in this representation.\n7132 Kasmir Raja S. V. et al\n# Letters 27 \u1e45,\u00f1,\u1e47,n,m 28 m\n29 k,kh,g,gh,\u1e45 30 c,ch,j,jh,\u00f1,\u015b 31 \u1e6d,\u1e6dh,\u1e0d,\u1e0dh,\u1e47,\u1e63 32 t,th,d,dh,n,s 33 p,ph,b,bh,m 34 k,kh,c,ch,\u1e6d,\u1e6dh,t,th,p,ph,\u015b,\u1e63,s\n35 g,gh,\u1e45,j,jh,\u00f1,\u1e0d,\u1e0dh,\u1e47,d,dh,n,b,bh,m,h 36 k,c,\u1e6d,t,p 37 kh,ch,\u1e6dh,th,ph 38 g,j,\u1e0d,d,b 39 gh,jh,\u1e0dh,dh,bh 40 g,gh,j,jh,\u1e0d,\u1e0dh,d,dh,b,bh\n41 k,kh,c,ch,\u1e6d,\u1e6dh,t,th,p,ph 42 \u1e41 43 \u1e25 44 f 45 x 46 ' 47 #\nPart 1 denotes the category (serial number in Table 1) to which a letter belongs, and Part 2 denotes the term number within the series that the letter is or fits into. In any letter representation, Part 1 is a binary string of fixed length 48, in which the set bit denotes the category number, while Part 2 is a binary string of variable length, the maximum length being 16.\nThe first four (shaded) rows of the table stand for overall category rows, viz. vowels, semi-vowels, consonants and special characters respectively. One of these four bits have to be set in any letter representation. There is no corresponding Part 2 value for the bits 0, 1, 2 and 3 of Part 1.\nClearly, one letter has many representations in this scheme. For example, the letter \u2018e\u2019 occurs in categories 13, 15 and 16, and is a vowel. Hence, the letter \u2018e\u2019 has the following three representations:\nRepresentation 1: Part 1:\nBit # 0 1 2 3 4 ... 13 14 15 16 17 18 ... 46 47 Bit value 1 0 0 0 0 ... 1 0 0 0 0 0 ... 0 0 Part 2:\nBit # 0 1 2 3 4 \u2026 14 15\nBit value 1 0 0 0 0 \u2026 0 0"}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7133\nRepresentation 2: Part 1: Bit # 0 1 2 3 4 ... 13 14 15 16 17 18 ... 46 47 Bit value 1 0 0 0 0 ... 0 0 1 0 0 0 ... 0 0 Part 2:\nBit # 0 1 2 3 4 \u2026 14 15\nBit value 0 0 1 0 0 \u2026 0 0\nRepresentation 3: Part 1: Bit # 0 1 2 3 4 ... 13 14 15 16 17 18 ... 47 48 Bit value 1 0 0 0 0 ... 0 0 0 1 0 0 ... 0 0 Part 2:\nBit # 0 1 2 3 4 \u2026 14 15\nBit value 1 0 0 0 0 \u2026 0 0\nThus the vowel\u2018e\u2019 is represented in three ways as:\n1. 1000 00000 00001 00000 00000 00100 00000 00000 00000 00000 | 10000 00000 00000 0 2. 1000 00000 00000 01000 00000 00100 00000 00000 00000 00000 | 00100 00000 00000 0 3. 1000 00000 00000 00100 00000 00100 00000 00000 00000 00000 | 10000 00000 00000 0 where the symbol \u2018|\u2019 depicts the boundary between the two parts and the space between sets of five bits has been used in the depiction only for the sake of clarity.\nAs can be gleaned from the scheme in Table 1, for Part 1 of any letter, bit 0 will be set if and only if exactly one bit from bits 4 to 19 is set, bit 1 if and only if exactly one of bits 20 and 21 is set, bit 2 if and only if exactly one of bits 22 to 41 is set, and bit 3 if and only if exactly one of bits 42 to 47 is set. Further, not more than one bit out of bits 0, 1, 2 and 3 can be set for any letter. Though most of the letters found in categories 17 to 19 are not vowels proper, they are included because vowel sandhi rules use them. A bit sequence with all 0s in Part 1, indicates a null letter.\nThe sequel contains sandhi rules codified under this scheme. It would be difficult to denote every letter in the rules as a series of 0s and 1s, and would be cumbersome to read and decipher. Hence the following notation has been adopted to represent rules: = 1 indicates that the th bit of Part of the letter is set, where = 1, 2. For example, = 1 means that bit 27 in Part 1 of is set to 1. Thus may be any of the five letters in category 27 of Table 1. For to denote the specific letter \u2018\u00f1\u2019, we would further have to specify, = 1; this would set bit 1 of Part 2 in . In Table 1, some categories have letters in sublists enclosed within [ ]. Only one bit of Part 2 is reserved for each such group in the list, and the bit for the sublist is set for any letter that is included in the sublist.\n7134 Kasmir Raja S. V. et al"}, {"heading": "5. Formation of Rules using the Schema", "text": "The above schema has been developed in order to simplify the rule processing. In the delineation of rules and in the presentation of the algorithms, the key to symbols is as follows:\n // means single-line explanatory comment\n { } are block or set indicators\n denotes  denotes  denotes  \u2a01 denotes  | denotes word concatenation\nFollowing is an example to show how the rule simplification has been achieved\nthrough this schema.\nConsider the sandhi aphorism 8.4.40 of P\u0101\u1e47ini, \u201csto\u1e25 \u015bcun\u0101\u1e25 \u015bcu\u1e25 ||\u201d. This aphorism means that if any dental (t, th, d, dh, n) or letter s is adjacent to a palatal (c, ch, j, jh, \u00f1) or letter \u015b, then the dental or s is replaced by the corresponding palatal or \u015b respectively. The aphorism 8.4.44, \u201c\u015b\u0101t ||\u201d, debars this rule from applying in the case of the specific palatal \u015b followed by a dental. The following examples illustrate how these rules are applied in practice:\nsat + cit = sac + cit \u015b\u0101r\u1e45gin + jaya = \u015b\u0101r\u1e45gi\u00f1 + jaya r\u0101mas + cinoti = r\u0101ma\u015b + cinoti pra\u015b + na\u1e25 = pra\u015b + na\u1e25 (no change)\nThe newly developed schema in this work would reduce the coding of these two\nrules to the following:\n) {\n; //bit unset in Part 1 ; //bit set in Part 1\n}\n{\n; //bit unset in Part 1 ; //bit set in Part 1\n}\nSince the change is to the \u2018corresponding\u2019 palatal, and the letters in categories 31 and 33 have been arranged appropriately in the schema, the rule realization requires only a simple bit set and unset in Part 1 and no change in Part 2. Further, the"}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7135\nconditions in the rule require only simple checks to see if the and belong to particular categories, i.e. if a particular bit is set in Part 1 for each of and ."}, {"heading": "6. The Vowel-Sandhi Processor", "text": "The following is the algorithm to process the main rules pertaining to vowel sandhis. It has been codified as per the above schema. Further, when Part 1 or Part 2 of a letter is altered by a bit set operation, it is assumed that all set bits in that part are first unset before the operation.\nAlgorithm VowelSandhiProcessor ( , ) {\n//1. ava\u1e45 spho\u1e6d\u0101yanasya || 6.1.123 || //Common name: ava\u1e45\u0101de\u015ba sandhi //If the word go is followed by a vowel //then the o of go is replaced by ava. = \u2018go\u2019 { ; } // further rules are processed\n//2. e\u1e45a\u1e25 pad\u0101nt\u0101dati || 6.1.109 || //Common name: p\u016brvar\u016bpa sandhi //If e or o at the end of a word is followed by a, //then e or o remains, and the avagraha (') replaces a.\n{\n; return ;\n}\n//3. aka\u1e25 savar\u1e47e d\u012brgha\u1e25 || 6.1.101 || //Common name: savar\u1e47ad\u012brgha sandhi //If one of a, i, u, \u1e5b or \u1e37 or their long //equivalents \u0101, \u012b, \u016b and \u1e5d is followed by the //short or long form of the same letter, //then the corresponding long letter replaces both. ) \u00ac( \u2a01 ) {\ndelete ; ;\n7136 Kasmir Raja S. V. et al\nreturn ; }\n//4. om\u0101\u1e45o\u015bca || 6.1.95 || //Common name: parar\u016bpa sandhi //If a or \u0101 is followed by o of the word om or o\u1e41, //then o replaces both. ) {\ndelete ; return ;\n}\n//5. etyedhaty\u016b\u1e6dhsu || 6.1.89 || //Common name: v\u1e5bddhi sandhi //Note: This rule clashes with rule 6.1.94 and Rule 6.1.87 and takes precedence. //For this rule, in all cases the resultant letter replaces x and y. //i) If a or \u0101 is followed by eti or edhati, then v\u1e5bddhi letter ai replaces both //ii) If the preposition pra is followed by e\u1e63a or e\u1e63y, then v\u1e5bddhi letter ai replaces //both //iii) If a or \u0101 is followed by \u016bh, then v\u1e5bddhi letter au replaces both //iv) If preposition pra is followed by \u016b\u1e0dh, then v\u1e5bddhi letter au replaces both //v) If word sva is followed by \u012br, then v\u1e5bddhi letter ai replaces both // is \u2018a\u2019 or \u2018\u0101\u2019 {\n// is \u2018e\u2019 {\nstarts with {et, edhat} //rule (i) {\ndelete ; = 1; return ;\n} = \u2018pra\u2019 starts with {e\u1e63, e\u1e63y} //rule (ii) {\ndelete ; = 1; return ;\n}\n} ) // is \u2018\u016b\u2019 {"}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7137\n//rule (iii) {\ndelete ; = 1; return ;\n} = \u2018pra\u2019 starts with {\u016b\u1e0dh} //rule (iv) {\ndelete ; = 1; return ;\n}\n} = \u2018sva\u2019 ) ) //rule (v) {\ndelete ; = 1; return ;\n}\n}\n//6. e\u1e45i parar\u016bpa\u1e41 || 6.1.94 || //Common name: parar\u016bpa sandhi //If a or \u0101 at the end of a preposition is followed by e or o, //then the e or o replaces both. //Note: The prepositions that qualify are: pra, ava, apa, upa, par\u0101. {pra, ava, apa, upa, par\u0101} {\ndelete ; return ;\n}\n//7. upasarg\u0101d\u1e5bti dh\u0101tau || 6.1.91 || //Common name: v\u1e5bddhi sandhi //i) If a or \u0101 at the end of a preposition is followed by \u1e5b, \u1e5d or \u1e37, //then v\u1e5bddhi letter \u0101r, \u0101r or \u0101l respectively replaces both. //The prepositions that qualify are: pra, par\u0101, apa, ava, upa //ii) If the word vatsara, kambala, vasana, da\u015ba, \u1e5b\u1e47a is followed by the word \u1e5b\u1e47a, //then v\u1e5bddhi letter \u0101r replaces both. //Note: This rule clashes with 6.1.87 (gu\u1e47a sandhi), and takes precedence. {pra, ava, apa, upa, par\u0101} {\n7138 Kasmir Raja S. V. et al\ndelete ; ; return ;\n} {vatsara, kambala, vasana, da\u015ba, \u1e5b\u1e47a} \u2018\u1e5b\u1e47a\u2019 {\ndelete ; ; return ;\n}\n//8. v\u1e5bddhireci || 6.1.88 || //Common name: v\u1e5bddhi sandhi //If a or \u0101 is followed by e, o, ai or au, //then the corresponding v\u1e5bddhi letter ai or au //replaces both. ) {\ndelete ; ; return ;\n}\n//9. \u0101dgu\u1e47a\u1e25 || 6.1.87 || // ura\u1e47 rapara\u1e25 || 1.1.51 || //Common name: gu\u1e47a sandhi //If a or \u0101 is followed by i, \u012b, u, \u016b, \u1e5b, \u1e5d or \u1e37, //then the corresponding gu\u1e47a letter e, o, ar or al //replaces both. ) {\ndelete ; ; return ;\n}\n//10. ecoyav\u0101y\u0101va\u1e25 || 6.1.78 || //Common name: ay\u0101y\u0101v\u0101v\u0101de\u015ba sandhi //If e, o, ai or au is followed by a vowel, //then ay, av, \u0101y, \u0101v replace the first respectively."}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7139\n{\n; return ;\n}\n//11. iko ya\u1e47aci || 6.1.77 || //Common name: ya\u1e47\u0101de\u015ba sandhi //If i, \u012b, u, \u016b, \u1e5b, \u1e5d or \u1e37 is followed by a vowel, //then the corresponding semi-vowel (y, v, r, l) //replaces the first.\n{\n; return ;\n}\n}"}, {"heading": "7. The Search Engine", "text": "Algorithm VowelSandhiProcessor can be used to generate alternative forms of a given search word, if the word starts and/or ends in a vowel. The following algorithm is used to effect the generation of all the possible alternative forms of the given word, which are then searched for in the given text.\nAlgorithm GenerateWordForms ( ) { // is the search word. //{WordForms} denotes the set of word forms generated by the //algorithm and is initially the null set.\nAdd to {WordForms}; = ; (each in {vowels}, = \u2018o\u2019 where in {om, o\u1e41}) {\nAdd VowelSandhiProcessor( , ) to {WordForms}; }\n(each {WordForms}) {\n(each in {go, pra, ava, apa, upa, par\u0101}, in {vowels}) {\nAdd VowelSandhiProcessor( , ) to {WordForms}; }\n}\n}\n7140 Kasmir Raja S. V. et al"}, {"heading": "8. Conclusion", "text": "The schema developed in this work is revolutionary on multiple counts. Firstly, the letter representation scheme is binary, and hence lends itself to speedy processing and also for implementation in an FPGA format. Secondly, the check involved in order to apply a P\u0101\u1e47inian rule has been reduced to merely a check to see whether a bit is set or not. Thirdly, the transformation of a letter into another according to a rule is effected by a maximum of one bit-unset and another bit-set. Fourthly, the efficiency achieved by the above division of a letter representation into two parts and effecting change-ofletter operations by simply changing the first part through minimal bit operations is unprecedented in the literature.\nThe representation schema and the results of the sandhi-processing algorithm represent an efficient computational model to process the vowel-based euphonic conjunctions in Sanskrit.\nThe proof of the efficiency of the sandhi processing algorithm and the optimality of the representational schema lies directly in the simplicity of the rule presentation that the schema facilitates.\nThe second algorithm presented in this work, which uses this sandhi processor to effect comprehensive word searches in texts is the first of its kind in the literature with regard to Sanskrit. The use of the sandhi processor for searching ensures comprehensiveness of the search, while the efficiency of the sandhi processing method presented in this work ensures that search speeds are not compromised due to the increase in the number of words to be searched for.\nThe schema devised in this work can be used as explained, to codify all consonant-based sandhi rules and other special sandhi rules of P\u0101\u1e47ini as well. Future work would include codification of all the non-vowel sandhi rules defined by P\u0101\u1e47ini, and expanding the conjoined word generation algorithm to include these sandhis as well."}, {"heading": "A Binary Schema and Computational Algorithms to Process Vowel-based", "text": "Euphonic Conjunctions for Word Searches 7141\n[5] Akshar Bharati, Vineet Chaitanya, Rajeev Sanghal, Natural Language Processing: A Paninian Perspective, Prentice-Hall of India, 1999.\n[6] Peter M. Scharf, Modeling P\u0101ninian Grammar, Sanskrit Computational Linguistics: First and Second International Symposia, Revised Selected and\nInvited Papers, ISBN:978-3-642-00154-3, Springer-Verlag, 2009.\n[7] Anand Mishra, \u201cSimulating the P\u0101ninian System of Sanskrit Grammar\u201d, Sanskrit Computational Linguistics: First and Second International Symposia,\nRevised Selected and Invited Papers, ISBN:978-3-642-00154-3, SpringerVerlag, 2009.\n[8] T. R. N. Rao, Subhash Kak, \u201cComputing Science in Ancient India\u201d, published by Center for Advanced Computer Studies, University of Southwestern\nLouisiana, 1998.\n[9] Rick Briggs, \"Knowledge Representation in Sanskrit and Artificial Intelligence\", RIACS, NASA Ames Research Center, AI Magazine 1985.\n[10] Gerard Huet, \u201cAutomata Mista\u201d, Festschrift in Honor of Zohar Manna for his 64th anniversary, Taormina, Sicily, July 2003. In \u201cVerification: Theory and\nPractice: Essays Dedicated to Zohar Manna on the Occasion of His 64th Birthday\", Ed. Nachum Dershowitz, Springer-Verlag LNCS vol. 2772, 2004, pp. 359-372.\n[11] G\u00e9rard Huet, \u201cLexicon-directed Segmentation and Tagging of Sanskrit\u201d, XIIth World Sanskrit Conference, Helsinki, Finland, Aug. 2003. Final version\nin Themes and Tasks in Old and Middle Indo-Aryan Linguistics, Eds. Bertil Tikkanen & Heinrich Hettrich. Motilal Banarsidass, Delhi, 2006, pp. 307-325.\n[12] Oliver Hellwig, \u201cSanskritTagger, a Stochastic Lexical and POS Tagger for Sanskrit\u201d, Peer-reviewed Proceedings of the First International Sanskrit\nComputational Linguistics Symposium, France, 2007.\n[13] Pavan Goyal, Vipul Arora, Laxmidhar Behera, \u201cAnalysis of Sanskrit Text: Parsing and Semantic Relations\u201d, Sanskrit Computational Linguistics:\nFirst and Second International Symposia, Revised Selected and Invited Papers, ISBN:978-3-642-00154-3, Springer-Verlag, 2009.\n[14] Rama N., Meenakshi Lakshmanan, A New Computational Schema for Euphonic Conjunctions in Sanskrit Processing, International Journal of\nComputer Science Issues, Vol. 5, 2009, pp 43-51.\nWebsites\n[15] G\u00f6ttingen Register of Electronic Texts in Indian Languages (GRETIL), gretil.sub.uni-goettingen.de/gretil.htm [16] Sanskrit Documents, sanskritdocuments.org [17] Indology: Resources for Indological Scholarship, indology.info/etexts/archive/\netext\n[18] TITUS, titus.uni-frankfurt.de/indexe.htm\n7142 Kasmir Raja S. V. et al\n[19] Muktabodha Indological Text Collection and Search Engine, muktalib5.org/digital_ library_secure_entry.htm"}], "references": [{"title": "Lexicon-directed Segmentation and Tagging of Sanskrit, XIIth World Sanskrit", "author": ["Huet G\u00e9rard"], "venue": "Final version in Themes and Tasks in Old and Middle Indo-Aryan Linguistics,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "From P\u0101ninian Sandhi to Finite State Calculus, Sanskrit Computational Linguistics: First and Second International Symposia, Revised Selected and Invited Papers, ISBN:978-3-642-00154-3, Springer-Verlag, 2009.  A Binary Schema and Computational Algorithms to Process Vowel-based Euphonic Conjunctions for Word Searches", "author": ["D. Hyman Malcolm"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Modeling P\u0101ninian Grammar, Sanskrit Computational Linguistics: First and Second International Symposia", "author": ["Peter M. Scharf"], "venue": "Revised Selected and Invited Papers,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2009}, {"title": "Simulating the P\u0101ninian System of Sanskrit Grammar\u201d, Sanskrit Computational Linguistics: First and Second International Symposia", "author": ["Anand Mishra"], "venue": "Revised Selected and Invited Papers,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Computing Science in Ancient India\u201d, published by Center for Advanced Computer Studies", "author": ["T.R.N. Rao", "Subhash Kak"], "venue": "University of Southwestern Louisiana,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1998}, {"title": "Knowledge Representation in Sanskrit and Artificial Intelligence", "author": ["Rick Briggs"], "venue": "RIACS, NASA Ames Research Center, AI Magazine", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1985}, {"title": "Automata Mista", "author": ["Gerard Huet"], "venue": "Festschrift in Honor of Zohar Manna for his 64th anniversary,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Lexicon-directed Segmentation and Tagging of Sanskrit", "author": ["G\u00e9rard Huet"], "venue": "XIIth World Sanskrit Conference,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "SanskritTagger, a Stochastic Lexical and POS Tagger for Sanskrit\u201d, Peer-reviewed", "author": ["Oliver Hellwig"], "venue": "Proceedings of the First International Sanskrit Computational Linguistics Symposium, France,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Analysis of Sanskrit Text: Parsing and Semantic Relations\u201d, Sanskrit Computational Linguistics: First and Second International Symposia", "author": ["Pavan Goyal", "Vipul Arora", "Laxmidhar Behera"], "venue": "Revised Selected and Invited Papers,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "A New Computational Schema for Euphonic Conjunctions in Sanskrit", "author": ["Rama N", "Meenakshi Lakshmanan"], "venue": "Processing, International Journal of Computer Science Issues,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 1, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 2, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 3, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 4, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 5, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 6, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 7, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 8, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 9, "context": "Further, finite automata, HMM or artificial intelligence methods [3-13] have been used in them.", "startOffset": 65, "endOffset": 71}, {"referenceID": 10, "context": "There has been one work that has formulated a mathematical model of the original aphorisms that lends itself to speedy processing [14].", "startOffset": 130, "endOffset": 134}], "year": 2014, "abstractText": "Comprehensively searching for words in Sanskrit E-text is a non-trivial problem because words could change their forms in different contexts. One such context is sandhi or euphonic conjunctions, which cause a word to change owing to the presence of adjacent letters or words. The change wrought by these possible conjunctions can be so significant in Sanskrit that a simple search for the word in its given form alone can significantly reduce the success level of the search. This work presents a representational schema that represents letters in a binary format and reduces P\u0101\u1e47inian rules of euphonic conjunctions to simple bit set-unset operations. The work presents an efficient algorithm to process vowelbased sandhis using this schema. It further presents another algorithm that uses the sandhi processor to generate the possible transformed word forms of a given word to use in a comprehensive word search.", "creator": "Microsoft\u00ae Word 2010"}}}