{"id": "1412.4972", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Dec-2014", "title": "Max-Product Belief Propagation for Linear Programming: Applications to Combinatorial Optimization", "abstract": "max - product belief propagation ( bp ) is a popular message - passing algorithm for computing a general series - posteriori ( map ) assignment having a joint distribution represented by a graphical model ( gm ). it was recently shown that bp can solve certain classes of linear programming ( lp ) formulations to combinatorial optimization problems including zero weight matching and shortest path, related. e., bp can be a distributed solver for certain contexts. however, those lps and cluster data analysis are very sensitive to underlying problem setups, and it has been not clear what approaches these tasks can be generalized to. in this paper, we obtain robust generic criteria such that bp converges to the correct solution of the larger lp. our survey result not only rediscovers prior known ones for maximum weight seeking and shortest path as special cases, but also continuously be applied to new problems including sparse salesman, minimal path and disk cover, i. e., bp is a distributed ( and parallel ) solver to the combinatorial optimization problems. we believe beyond our applications provide new insights on expected performances and new directions on distributed solvers for earlier classes of large - scale lps.", "histories": [["v1", "Tue, 16 Dec 2014 12:18:34 GMT  (21kb)", "http://arxiv.org/abs/1412.4972v1", null], ["v2", "Fri, 6 Mar 2015 01:43:00 GMT  (31kb)", "http://arxiv.org/abs/1412.4972v2", null], ["v3", "Sun, 4 Oct 2015 06:03:41 GMT  (31kb)", "http://arxiv.org/abs/1412.4972v3", null], ["v4", "Thu, 8 Dec 2016 10:37:48 GMT  (190kb,D)", "http://arxiv.org/abs/1412.4972v4", null], ["v5", "Wed, 28 Jun 2017 17:15:25 GMT  (189kb,D)", "http://arxiv.org/abs/1412.4972v5", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["sejun park", "jinwoo shin"], "accepted": false, "id": "1412.4972"}, "pdf": {"name": "1412.4972.pdf", "metadata": {"source": "CRF", "title": "Max-Product Belief Propagation for Linear Programming: Convergence and Correctness", "authors": ["Sejun Park", "Jinwoo Shin"], "emails": ["sejun.park@kaist.ac.kr,", "jinwoos@kaist.ac.kr"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 2.\n49 72\nv1 [\ncs .A\nI] 1\n6 D\nec 2\n01 4"}, {"heading": "1 Introduction", "text": "Graphical model (GM) has been one of powerful paradigms for succinct representations of joint probability distributions in variety of scientific fields [18, 10, 9, 15]. GM represents a joint distribution of some random vector to graph structured model where each vertex corresponds to random variable and each edge captures to a conditional independence between random variables. In many applications involving GMs, finding maximum a posteriori (MAP) assignment in GM is an important inference task, which is known to be computationally intractable (i.e., NP-hard) in general [2]. Max-product belief propagation (BP) is the most popular heuristic for approximating a MAP assignment of given GM, where its performance has been not well understood in loopy GMs. Nevertheless, BP often shows remarkable performances even on loopy GMs and distributed implementation, associated ease of programming and strong parallelization potential are the main reasons for the growing popularity of the BP algorithm. For example, several software architectures for implementing parallel BPs were recently proposed [7, 4, 8] by different research groups in machine learning communities.\nRecently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11]. The important common feature of these instances is that BP converges to a correct MAP assignment if the Linear Programming (LP) relaxation of the MAP inference problem is tight, i.e., it shows no integrality gap. In other words, BP can be used an efficient distributed solver for those LPs, and is presumably better than classical centralized LP solvers such as simplex methods [3], interior point methods [14] and ellipsoid methods [6] for large-scale inputs. However, these theoretical results on BP are very sensitive to underlying\nstructural properties depending on specific problems, e.g., the BP analysis for matching problems [12, 5] do not extend to even for perfect matching ones [1]. Therefore, it has been not clear what extent they can be generalized to.\nIn this paper, we establish generic conditions for GM formulations of LPs so that BP converges to the desired solution of LP. As one can naturally expect given prior results, one of our conditions requires the tightness of given LP. Our main contribution is finding other sufficient generic conditions so that BP converges to the correct MAP assignment in GMs. First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.e., we provide a unified framework on establishing the convergence and correctness on BPs in relation to associated LPs. Furthermore, we provide new examples under our framework, e.g., we show that BP can solve LP formulations of other combinatorial optimizations such as traveling salesman, longest path and vertex cover. In addition, while most prior known results on BP and LP focused on the case when LP has an integral solution, our result implies that BP can even solve LPs having fractional solutions (see Section 4.2 for details), which shows a possibility that BP can be a generic solver of LP. The main appeal of our framework is providing a generic guideline on BP design for its high performance, i.e., one can carefully design a GM given LP so that it satisfies our desired conditions. We believe that our unified framework on BP analysis provides new insights on BP performances and new directions on efficient distributed (and parallel) solvers for certain classes of large-scale LPs."}, {"heading": "1.1 Organization", "text": "In Section 2, we introduce the graphical model, belief propagation and general integer programming and its linear programming relaxation. In Section 3, we establish the main result of the paper. Finally, applications of the main result is in Section 4."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Graphical Model and Belief Propagation", "text": "A joint distribution of n (binary) random variables Z = [Zi] \u2208 {0, 1}n is called a Graphical Model (GM) if it factorizes as follows: for z = [zi] \u2208 \u2126n,\nPr[Z = z] \u221d \u220f\n\u03b1\u2208F\n\u03c8\u03b1(z\u03b1), (1)\nwhere {\u03c8\u03b1} are (given) non-negative functions, the so-called factors; F is a collection of subsets\nF = {\u03b11, \u03b12, ..., \u03b1k} \u2282 2 {1,2,...,n}\n(each \u03b1j is a subset of {1, 2, . . . , n}); z\u03b1 is the projection of z onto dimensions included in \u03b1. For example, if z = [0, 1, 0] and \u03b1 = {1, 3}, then z\u03b1 = [0, 0]. In particular, when |\u03b1| = 1, \u03c8\u03b1 is called a variable factor. Figure 1 depicts the the graphical relation between factors F and variables z.\nAssignment z\u2217 is called a maximum a posteriori (MAP) assignment if\nz\u2217 = arg max z\u2208{0,1}n Pr[z].\nThis means that computing a MAP assignment requires us to compare Pr[z] for all possible z, which is typically computationally intractable (i.e., NP-hard) unless the induced bipartite graph of factors F and variables z, so-called factor graph, has a bounded treewidth [2].\nThe (max-product) BP algorithms are popular heuristics for approximating the MAP assignment in a graphical model. BP is an iterative procedure; at each iteration t, there are four messages\n{mt\u03b1\u2192i(c),m t i\u2192\u03b1(c) : c \u2208 {0, 1}}\nbetween every variable zi and every associated factor \u03c8\u03b1 \u2208 Fi, where Fi := {\u03b1 \u2208 F : i \u2208 \u03b1}; that is, Fi is a subset of F such that all the \u03b1 in Fi include the ith position of z for any given z. Initially, we set m0\u03b1\u2192i(c) = m 0 i\u2192\u03b1(c) = 1, and messages are updated as follows:\nmt+1\u03b1\u2192i(c) = maxz\u03b1:zi=c \u03c8\u03b1(z\u03b1)\n\u220f\nj\u2208\u03b1\\i\nmtj\u2192\u03b1(zj) (2)\nmt+1i\u2192\u03b1(c) = \u220f\n\u03b1\u2032\u2208Fi\\\u03b1\nmt\u03b1\u2032\u2192i(c). (3)\nFirst, we note that each zi only sends messages to Fi; that is, zi sends messages to \u03b1j only if \u03b1j selects/includes i. The outer-term in the message computation (2) is a summation over all possible z\u03b1 \u2208 {0, 1}\n|\u03b1|. The inner-term is a product that only depends on the variables zj that are connected to \u03b1. The message-update (3) from variable zi to factor \u03c8\u03b1 is a product which considers all messages received by \u03c8\u03b1 in the previous iteration, except for the message sent by zi itself.\nFinally, given a set of messages {mi\u2192\u03b1(c), m\u03b1\u2192i(c) : c \u2208 {0, 1}}, the so-called BP marginal beliefs are computed as follows:\nbi[zi] = \u220f\n\u03b1\u2208Fi\nm\u03b1\u2192i(zi). (4)\nThen, the BP algorithm outputs zBP = [zBPi ] as\nzBPi =    1 if bi[1] > bi[0] ? if bi[1] = bi[0]\n0 if bi[1] < bi[0]\n.\nIt is known that zBP converges to a MAP assignment after a large enough number of iterations, if the factor graph is a tree and the MAP assignment is unique. However, if the graph has loops in it, the BP algorithm has no guarantee to find a MAP solution in general."}, {"heading": "2.2 Integer Programming and Linear Programming Relaxation", "text": "Integer programming (IP) is an optimization problem in which all variables are integer and its objective function and constraints are linear. We can formulate general IP as below:\nminimize w \u00b7 x\nsubject to Ax \u2264 b\nx = [xi] \u2208 Z n A \u2208 Rm\u00d7n, b \u2208 Rm.\n(5)\nHowever, solving IP is NP-Hard. Hence, we usually solve relaxed problem called linear programming (LP) rather than IP. In LP, we relax the integer constraint of variables as below.\nminimize w \u00b7 x\nsubject to Ax \u2264 b\nx = [xi] \u2208 R n A \u2208 Rm\u00d7n, b \u2208 Rm.\n(6)"}, {"heading": "3 Conditions on Convergence and Correctness of Belief Propagation", "text": "Consider the following GM (Graphical Model): for x = [xi] \u2208 {0, 1}n and w = [wi] \u2208 Rn,\nPr[X = x] \u221d \u220f\ni\ne\u2212wixi \u220f\n\u03b1\u2208F\n\u03c8\u03b1(x\u03b1), (7)\nwhere the factor function \u03c8\u03b1 is defined as\n\u03c8\u03b1(x\u03b1) = { 1 if A\u03b1x\u03b1 \u2265 b\u03b1, C\u03b1x\u03b1 = d\u03b1 0 otherwise ,\nfor some matrices A\u03b1, C\u03b1 and vectors b\u03b1, d\u03b1. Now we consider the IP (Integer Programming) corresponding the above GM:\nminimize w \u00b7 x\nsubject to \u03c8\u03b1(x\u03b1) = 1, \u2200\u03b1 \u2208 F\nx = [xi] \u2208 {0, 1} n.\n(8)\nOne can easily observe that the MAP assignments for GM (7) corresponds to the solutions of IP (8). To establish the performance of BP on GM (7) for solving IP (8), we also consider the following the LP (Linear Programming) relation to IP (8):\nminimize w \u00b7 x\nsubject to \u03c8\u03b1(x\u03b1) = 1, \u2200\u03b1 \u2208 F\nx = [xi] \u2208 [0, 1] n.\n(9)\nWe let P denote the polytope of feasible solutions of the above LP:\nP := {x \u2208 [0, 1]n : \u03c8\u03b1(x\u03b1) = 1, \u2200\u03b1 \u2208 F} .\nSimilarly, P\u03b1 is defined as P\u03b1 := { x \u2208 [0, 1]|\u03b1| : \u03c8\u03b1(x\u03b1) = 1 } . Now we are ready to state the main result of this paper.\nTheorem 1 The max-product BP on GM (7) converges to the solution of IP (8) if the following conditions hold:\nC1. LP (9) has unique integral solution x\u2217 \u2208 {0, 1}n , i.e., it is tight.\nC2. For every i \u2208 {1, 2, . . . , n}, the number of factors associated with xi is at most two, i.e.,\n|\u03b1 \u2208 F : i \u2208 \u03b1| \u2264 2.\nC3. For every factor \u03c8\u03b1, every x\u03b1 \u2208 {0, 1}|\u03b1| with \u03c8\u03b1(x\u03b1) = 1, and every i \u2208 \u03b1 with xi 6= x\u2217i , there exists j \u2208 \u03b1 with xj 6= x\u2217j such that\n\u03c8\u03b1(x \u2032 \u03b1) = 1, where x \u2032 k =\n{ xk if k 6= i, j\nx\u2217k otherwise .\n\u03c8\u03b1(x \u2032\u2032 \u03b1) = 1, where x \u2032\u2032 k =\n{ xk if k = i, j\nx\u2217k otherwise ."}, {"heading": "3.1 Proof of Theorem 1", "text": "Before start the proof, let us introduce a useful Lemma\nLemma 2 There exists a universal constant K for LP (9) such that if some \u03b3 \u2208 Zn and \u03b5 > 0 satisfying the followings:\n1. There exist (at most) two factors such that\nF (z) := {\u03b1 \u2208 F : z\u03b1 /\u2208 P\u03b1}, |F (z)| \u2264 2\nwhere z = x\u2217 + \u03b5\u03b3,\n2. For every \u03b1 \u2208 F (z), there exist i \u2208 \u03b1 such that\nz\u2020\u03b1 \u2208 P\u03b1,\nwhere z\u2020 = z + \u03b5ei or z\u2020 = z \u2212 \u03b5ei and ei \u2208 {0, 1}n is the unit vector whose i-th coordinate is 1,\nthen there exists z\u2021 \u2208 P such that \u2016z \u2212 z\u2021\u20161 \u2264 \u03b5K.\nThe proof of Lemma 2 is presented in appendix. To begin with, from Condition C1, there exists \u03b4 > 0 such that\n\u03b4 := inf x\u2208P\\x\u2217\nw \u00b7 x\u2212 w \u00b7 x\u2217\n\u2016x\u2212 x\u2217\u20161 > 0. (10)\nWe let x\u0302t \u2208 {0, 1, ?}n denote the BP estimate at the t-th iteration for the MAP computation. We will show that under Conditions C1-C3,\nx\u0302t = x\u2217, for t > K(wmax/\u03b4 + 1),\nwhere wmax = maxi |wi| and K is the universal constant in Lemma 2. Suppose the above statement is false, i.e., there exists i \u2208 {1, 2, . . . , n} such that x\u0302ti 6= x \u2217 i for t > K(wmax/\u03b4 + 1). Under the assumption, we will reach a contradiction, which completes the proof of Theorem 1. To this end, we further assume the case x\u2217i = 1 (i.e., x\u0302 t i \u2208 {0, ?}) where the case x \u2217 i = 0 can be argued similarly. Now we construct a tree-structured GM (also popularly known as the computational tree [17]), denoted by Ti(t), as follows:\n1. Add yi \u2208 {0, 1} as the root variable with variable factor function e\u2212wiyi .\n2. For each leaf variable yj and for each \u03b1 \u2208 F such that j \u2208 \u03b1 and \u03c8\u03b1 is not associated with yj in the current tree-structured GM, add a factor function \u03c8\u03b1 as a child of yj .\n3. For each leaf factor \u03c8\u03b1 and for each variable yk such that k \u2208 \u03b1 and yk is not associated with \u03c8\u03b1 in the current tree-structured GM, add a variable yk as a child of \u03c8\u03b1 with variable factor function e\u2212wjyj .\n4. Repeat Step 2, 3 t times.\nSince we assume x\u0302ti \u2208 {0, ?}, it is known from [16] that there exists a MAP configuration y MAP on Ti(t) with yMAPi = 0 at the root variable. Now we construct a new assignment y NEW on the computational tree Ti(t) as follows:\n1. Initially, set yNEW \u2190 yMAP .\n2. Update the value of the root variable of Ti(t) by yNEWi \u2190 x \u2217 i .\n3. For each child factor \u03c8\u03b1 of root i \u2208 \u03b1, choose j \u2208 \u03b1 according to Condition C3 and update the associated variable by yNEWj \u2190 x \u2217 j .\n4. Repeat Step 2,3 recursively by substituting Ti(t) by the subtree of Ti(t) of root j until the process stops (i.e., i = j) or the leaf of Ti(t) is reached (i.e., i does not have a child).\nOne can notice that the set of revised variables in Step 2 of the above procedure forms a path structure Q in the tree Ti(t). We first, consider the case that both ends of the path Q touch leaves of Ti(t), where other cases can be argued in a similar manner. Let define \u03b1 = [\u03b1i], \u03b2 = [\u03b2i] \u2208 Zn+ as follow\n\u03b1i = number of copies of xi in path Q with x\u2217i = 1 \u03b2i = number of copies of xi in path Q with x\u2217i = 0\nThen, from our construction of yNEW , one can observe that yNEW = yMAP + \u03b1 \u2212 \u03b2. Let define z = x\u2217 + \u03b5(\u03b2 \u2212 \u03b1) where 0 < \u03b5 < 1/2t. From C3, z violates at most two factors, say \u03b11, \u03b12, which are connected to the changed leaf variable. From C2, for each i = 1, 2 there is j \u2208 \u03b1i such that z \u2020 \u03b1i \u2208 P\u03b1i where z\u2020 = z+ \u03b5ej or z\u2020 = z\u2212 \u03b5ej . We will use Lemma 2 utilizing our construction of z. From Lemma 2, we have z\u2021 \u2208 P such that\n\u2016z\u2021 \u2212 z\u20161 \u2264 \u03b5K, \u2016z \u2021 \u2212 x\u2217\u20161 \u2265 \u03b5(\u2016\u03b1\u20161 + \u2016\u03b2\u20161 \u2212K) = \u03b5(2t \u2212K).\nwhere z = x\u2217 + \u03b5(\u03b2 \u2212 \u03b1). Hence, it follows that\n0 < \u03b4 \u2264 w(z\u2021)\u2212 w(x\u2217)\n\u2016z\u2021 \u2212 x\u2217\u20161\n\u2264 w(z) + \u03b5wmaxK \u2212 w(x\n\u2217)\n\u03b5(2t\u2212K)\n= \u03b5w(\u03b2 \u2212 \u03b1) + \u03b5wmaxK\n\u03b5(2t\u2212K)\n= w(\u03b2 \u2212 \u03b1) + wmaxK\n2t\u2212K\nTherefore, we can bound w(\u03b2 \u2212 \u03b1) as\nw(\u03b2 \u2212 \u03b1) \u2265 2\u03b4t \u2212 (wmax + \u03b4)K > 0, for t > K(wmax/\u03b4 + 1).\nThe above inequality leads to the contradiction to the fact that yMAP is a MAP configuration in Ti(t) since\nw \u00b7 yNEW = w(\u03b1\u2212 \u03b2) + w \u00b7 yMAP < w \u00b7 yMAP .\nThis completes the proof of Theorem 1."}, {"heading": "4 Applications of Theorem 1", "text": "In this section, we introduce applications that BP correctly converge to the solution if conditions of Theorem 1 are satisfied. We first show the shortest path problem [11]. Secondly, we show matching related applications including the results of [5, 12, 1, 13]. Final parts are the traveling salesman problem and the longest path problem. Our applications cover prior works and other problems such as the traveling salesman problem and solving the maximum weight matching linear programming."}, {"heading": "4.1 Shortest Path", "text": "Shortest path problem on a directed graph G = (V,E) and weight w = [we : e \u2208 E] \u2208 R|E| is to find a path from the source s to the destination t such that the path minimizes the edge weights of the path. One can naturally design the following LP for this problem.\nminimize \u2211\ne\u2208E\nwexe\nsubject to \u2211\ne\u2208\u03b4o(v)\nxe \u2212 \u2211\ne\u2208\u03b4i\nxe =    1 if u = s \u22121 if u = t\n0 otherwise\n\u2200 v \u2208 V\nx = [xe] \u2208 [0, 1] |E|.\n(11)\nwhere \u03b4i(v), \u03b4o(v) are the set of incoming, outgoing edges of v. We can construct GM from the shortest path problem LP (11) as below:\nPr[X = x] \u221d \u220f\ne\u2208E\ne\u2212wexe \u220f\nv\u2208V\n\u03c8v(x\u03b4(v)), (12)\nwhere the factor function \u03c8v is defined as\n\u03c8v(x\u03b4(v)) =    1 if \u2211 e\u2208\u03b4o(v) xe \u2212 \u2211 e\u2208\u03b4i(v) xe =    1 if u = s \u22121 if u = t 0 otherwise\n0 otherwise\n,\nFrom above GM (12), let us introduce a Corollary.\nCorollary 3 If the shortest path problem LP (11) has a unique and integral solution, then max-product BP on GM (12) converges to the solution of LP (11)\nThe proof of Corollary 3 is presented in the appendix."}, {"heading": "4.2 Maximum Weight Perfect Matching", "text": "Given graph G = (V,E) and weight w = [we : e \u2208 E] \u2208 R|E| on edges, the maximum weight perfect matching problem is to find a set of edges such that each vertex is connected to exactly one edge in the set and the sum of edge weights in the set is maximized. One can naturally design the following LP for this problem.\nmaximize w \u00b7 x subject to \u2211\ne\u2208\u03b4(v)\nxe = 1, \u2200 v \u2208 V\nx = [xe] \u2208 [0, 1] |E|.\n(13)\nwhere \u03b4(v) is a set of edges connected to a vertex v. If the above LP has an integral solution, it corresponds to the solution of the maximum weight perfect matching problem.\nIt is known that for each vertex x of feasible solution polytope of the maximum weight matching LP (13), each xe of x can only have a value from {0, 1/2, 1}. Lets duplicate each edge e to e1, e2 and define G\u2032 = (V,E\u2032) where E\u2032 = {e1, e2|e \u2208 E}. Then, we can make an LP on G\u2032 which always have non-fractional solution.\nmaximize \u2211\nei\u2208E\u2032\nw\u2032eixei\nsubject to \u2211\nei\u2208\u03b4(v)\nxei = 2 \u2200 v \u2208 V\nx = [xe1 , xe2 ] \u2208 [0, 1] 2|E|.\n(14)\nwhere w\u2032e1 = we/2 and w \u2032 e2 = we/2 \u2212 \u03b5. We introduce small enough \u03b5 to prevent the unnecessary multiple solutions due to the symmetry of e1, e2. Then, by setting xe = (xe1 + xe2)/2, the solution of LP (14) is a solution of LP (13) and LP (14) has unique integral solution if and only if LP (13) has unique solution. Now, construct the GM from LP (14) as below:\nPr[X = x] \u221d \u220f\ne\u2208E\new \u2032 e1 xe1+w \u2032 e2 xe2\n\u220f\nv\u2208V\n\u03c8v(x\u03b4(v)), (15)\nwhere the factor function \u03c8v is defined as\n\u03c8v(x\u03b4(v)) =\n{ 1 if \u2211 ei\u2208\u03b4(v) xei = 2\n0 otherwise .\nLet us introduce a Corollary from GM (15).\nCorollary 4 If the maximum weight perfect matching LP (13) has a unique solution, then max-product BP on GM (15) converges to the solution of LP (13)\nThe proof of Corollary 4 is presented in the appendix. We note that one can obtain a similar conclusion for the maximum (non-perfect) weight matching problem. We omit the details in this paper."}, {"heading": "4.3 Maximum Weight Perfect Matching with Odd Cycles", "text": "In previous section we prove that BP correctly converges to the solution of LP (13) if LP (13) has a unique solution. It is known that adding odd cycle constraint for every odd cycles makes LP tight i.e. LP has an integral solution. The constraint is as follows:\n\u2211\ne\u2208C\nxe \u2264 |C| \u2212 1\n2\nwhere C is an odd cycle. There is previous work on finding matching by using BP and adding disjoint odd cycle constraint [13]. We refer the following graphical transformation from [13]. Let C be a set of disjoint odd cycles in G. Lets construct the new graph G\u2032 = (V \u2032, E\u2032), w\u2032 where\nV \u2032 = V \u222a {vC |C \u2208 C}, E \u2032 = {(u, vC )|u \u2208 C,C \u2208 C} \u222a E \\ {e \u2208 C|C \u2208 C}\nw\u2032e =\n{ 1 2 \u2211 e\u2032\u2208E(C)(\u22121) dC(u,e \u2032)we\u2032 if e = (u, vC) for some C \u2208 C\nw\u2032e otherwise .\ndC(u, e \u2032) is the distance between u, e\u2032 in cycle C . We refer the maximum weight matching with odd cycles LP from [13] and slightly modify to make the maximum weight perfect matching with odd cycles LP.\nmaximize w\u2032 \u00b7 y subject to \u2211\ne\u2208\u03b4(v)\nye = 1, \u2200 v \u2208 V\n\u2211\nu\u2208V (C)\n(\u22121)dC(u,e)y(vC ,u) \u2208 [0, 2] \u2200e \u2208 E(C)\n\u2211\ne\u2208\u03b4(vC )\nye \u2264 |C| \u2212 1 \u2200C \u2208 C\ny = [ye] \u2208 [0, 1] |E\u2032|\n(16)\nAbove LP is equivalent to the LP (13) with odd cycle constraints. Now, construct GM from above LP.\nPr[Y = y] \u221d \u220f\ne\u2208E\neweye \u220f\nv\u2208V\n\u03c8v(y\u03b4(v)) \u220f\nC\u2208C\n\u03c8C(y\u03b4(vC )), (17)\nwhere the factor function \u03c8v, \u03c8C is defined as\n\u03c8v(y\u03b4(v)) =\n{ 1 if \u2211 e\u2208\u03b4(v) ye = 1\n0 otherwise ,\n\u03c8C(x\u03b4(vC )) =    1 if \u2211 u\u2208V (C)(\u22121) dC (u,e)y(vC ,u) \u2208 {0, 2}\u2211 e\u2208\u03b4(vC ) ye \u2264 |C| \u2212 1\n0 otherwise\n.\nLet us introduce a Corollary from GM (17).\nCorollary 5 If the maximum weight perfect matching with odd cycles LP (16) has a unique and integral solution, then max-product BP on GM (17) converges to the solution of LP (16)\nThe proof of Corollary 5 is presented in appendix. We note that one can obtain a similar conclusion for the maximum (non-perfect) weight matching with odd cycles problem. We omit the details in this paper."}, {"heading": "4.4 Traveling Salesman", "text": "Given a directed graphG = (V,E) and weight w = [we : e \u2208 E] \u2208 R|E|, the traveling salesman problem (TSP) is to find a cycle containing every vertices such that the cycle minimizes the sum of edge weights. To construct the TSP LP, let us introduce an auxiliary graph G\u2032 = (V,E\u2032) where E\u2032 = {e1, . . . , en|e \u2208 E}, n = |V | and ei is a duplications of e with edge index i. Then, finding a solution of TSP is equivalent to finding a Hamiltonian cycle of G\u2032 which minimizes the sum of edge weights such that at each vertex, (outgoing edge index - incoming edge index) mod n = 1. Then, we can formulate LP for TSP on the auxiliary graph G\u2032.\nminimize \u2211\ni\n\u2211\nei\u2208E\u2032\nweixei\nsubject to \u2211\nei+1\u2208\u03b4o(v)\nxei+1 \u2212 \u2211\nei\u2208\u03b4i(v)\nxei = 0\n\u2211\ne1\u2208\u03b4o(v)\nxe1 = \u2211\nen\u2208\u03b4i(v)\nxen = 0 i 6= n, v 6= s\n\u2211\ne1\u2208\u03b4o(s)\nxe1 = \u2211\nen\u2208\u03b4i(s)\nxen = 1\n\u2211\nei\u2208\u03b4o(s)\nxei = \u2211\nej\u2208\u03b4i(s)\nxej = 0 i 6= 1, j 6= n\nx = [xei ] \u2208 [0, 1] |V ||E|.\n(18)\nwhere \u03b4i(v), \u03b4o(v) are set of incoming, outgoing edges of v. We fixed a vertex s to prevent the unnecessary multiple solutions due to the symmetry of edge indices. From above LP (18), we can construct GM.\nPr[X = x] \u221d \u220f\ni\n\u220f\nei\u2208E\u2032\ne\u2212weixei \u220f\nv\u2208V\n\u03c8v(x\u03b4(v)), (19)\nwhere the factor function \u03c8v is defined as\n\u03c8v(x\u03b4(v)) =    1 if \u2211 ei+1\u2208\u03b4o(v) xei+1 \u2212 \u2211 ei\u2208\u03b4i(v) xei = 0\u2211 e1\u2208\u03b4o(v) xe1 = \u2211 en\u2208\u03b4i(v) xen = 0\n0 otherwise\nfor i 6= n, v 6= s\n\u03c8s(x\u03b4(s)) =    1 if \u2211 e1\u2208\u03b4o(s) xe1 = \u2211 en\u2208\u03b4i(s) xen = 1\u2211 ei\u2208\u03b4o(s) xei = \u2211 ej\u2208\u03b4i(s) xej = 0\n0 otherwise\nfor i 6= 1, j 6= n\nLet us introduce a Corollary from GM (19).\nCorollary 6 If the traveling salesman problem LP (18) has a unique and integral solution, then maxproduct BP on GM (19) converges to the solution of LP (18)\nThe proof of Corollary 6 is presented in the appendix."}, {"heading": "4.5 Longest Path", "text": "Given a directed graph G = (V,E) and weight w = [we : e \u2208 E] \u2208 R|E|, longest path problem is to to find a path from a source s to a destination t that maximizes the sum of weights of edges in the path. Longest path problem is known as NP-Hard. To construct the longest path problem LP, let us introduce an auxiliary graph G\u2032 = (V,E\u2032) where E\u2032 = {e1, . . . , en|e \u2208 E}, n = |V | and ei is a duplications of e with edge index i. Then, finding a solution of longest path problem is equivalent to finding a longest path of G\u2032 which maximizes the sum of edge weights such that at each vertex, (outgoing edge index - incoming edge index) mod n = 1. Then, we can formulate LP for longest path problem on the auxiliary graph G\u2032.\nmaximize \u2211\ni\n\u2211\nei\u2208E\u2032\nweixei\nsubject to \u2211\nei+1\u2208\u03b4o(v)\nxei+1 \u2212 \u2211\nei\u2208\u03b4i(v)\nxei = 0\n\u2211\ne1\u2208\u03b4o(v)\nxe1 = \u2211\nen\u2208\u03b4i(v)\nxen = 0 i 6= n, v 6= s, t\n\u2211\ne1\u2208\u03b4o(s)\nxe1 = 1, \u2211\nei\u2208\u03b4o(s)\nxei = \u2211\nej\u2208\u03b4i(s)\nxej = 0 i 6= 1,\u2200j\n\u2211\ni\n\u2211\nei\u2208\u03b4i(t)\nxei = 1, \u2211\nej\u2208\u03b4o(t)\nxej = 0 \u2200j\nx = [xei ] \u2208 [0, 1] |V ||E|.\n(20)\nwhere \u03b4i(v), \u03b4o(v) are set of incoming, outgoing edges of v. From above LP (20), we can construct GM.\nPr[X = x] \u221d \u220f\ni\n\u220f\nei\u2208E\u2032\neweixei \u220f\nv\u2208V\n\u03c8v(x\u03b4(v)), (21)\nwhere the factor function \u03c8v is defined as\n\u03c8v(x\u03b4(v)) =    1 if \u2211 ei+1\u2208\u03b4o(v) xei+1 \u2212 \u2211 ei\u2208\u03b4i(v) xei = 0\u2211 e1\u2208\u03b4o(v) xe1 = \u2211 en\u2208\u03b4i(v) xen = 0\n0 otherwise\nfor i 6= n, v 6= s, t\n\u03c8s(x\u03b4(s)) =\n{ 1 if \u2211 e1\u2208\u03b4o(s) xe1 = 1, \u2211 ei\u2208\u03b4o(s) xei = \u2211 ej\u2208\u03b4i(s) xej = 0\n0 otherwise for i 6= 1,\u2200j\n\u03c8t(x\u03b4(t)) =\n{ 1 if \u2211 i \u2211 ei\u2208\u03b4i(t) xei = 1, \u2211 ej\u2208\u03b4o(t) xej = 0\n0 otherwise for \u2200j\nLet us introduce a Corollary from GM (21).\nCorollary 7 If the longest path problem LP (20) has a unique and integral solution, then max-product BP on GM (21) converges to the solution of LP (20)\nThe proof of Corollary 7 is almost same as that of Corollary 6. We omit the proof in this paper."}, {"heading": "4.6 Vertex Cover", "text": "Given a graph G = (V,E) and positive integer weight b = [bv : v \u2208 V ] \u2208 R|V |, vertex cover problem is to find a set of vertices minimizes the sum of vertex weights of the set such that each edge is connected to at least one vertex in the set. The dual LP of the vertex cover problem is formulated as follows:\nmaximize \u2211\ne\u2208E\nxe\nsubject to \u2211\ne\u2208\u03b4(v)\nxe \u2264 bv, \u2200 v \u2208 V\nx = [xe] \u2208 [0,\u221e) |E|.\n(22)\nOne can notice that xe \u2264 maxv bv. To make an equivalent LP with binary variables, duplicate each edge e to e1, . . . , en where n = maxv bv. Let us introduce an auxiliary graph G\u2032 = (V,E\u2032) where E\u2032 = {e1, . . . , en|e \u2208 E}. Then, the following LP is equivalent with LP (22) by setting xe = \u2211 i xei .\nmaximize w \u00b7 x subject to \u2211\nei\u2208\u03b4(v)\nxei \u2264 bv, \u2200 v \u2208 V\nx = [xei ] \u2208 [0, 1] |E\u2032|\n(23)\nWhere, \u03b4(v) is a set of edges connected to a vertex v, w = [wei : ei \u2208 E \u2032] \u2208 [0, 1]|E \u2032| and wi = 1 \u2212 i\u03b5. We choose small enough \u03b5 to avoid unnecessary multiple solutions due to the symmetry of eis. From above LP, we can construct GM\nPr[X = x] \u221d \u220f\ne\u2208E\newexe \u220f\nv\u2208V\n\u03c8v(x\u03b4(v)), (24)\nwhere the factor function \u03c8v is defined as\n\u03c8v(x\u03b4(v)) =\n{ 1 if \u2211 ei\u2208\u03b4(v) xei \u2264 bv\n0 otherwise .\nLet us introduce Corollary from above GM.\nCorollary 8 If the vertex cover dual LP (22) has a unique and integral solution, then max-product BP on GM (24) converges to the solution of LP (22)\nThe proof of Corollary 8 is presented in the appendix."}, {"heading": "5 Conclusion", "text": "The BP algorithm has been the most popular algorithm for solving inference problems arising graphical models, where its distributed implementation, associated ease of programming and strong parallelization potential are the main reasons for its growing popularity. In this paper, we aim for designing BP algorithms solving Linear Programmings, and provide sufficient conditions for the purpose. We believe that our results provide new interesting directions on designing efficient distributed (and parallel) solvers for large-scale Linear Programmings.\nAcknowledgements. We would like to acknowledge the support of the AOARD project, FA2386-141-4058."}, {"heading": "A Proof of Lemma 2", "text": "let \u03b11, \u03b12 be violated factors. Then,\nz \u2208 {x \u2208 [0, 1]n|A\u03b1x\u03b1 \u2265 b\u03b1, A\u03b11x\u03b11 \u2265 b\u03b11 \u2212 \u03b5,A\u03b12x\u03b12 \u2265 b\u03b12 \u2212 \u03b5, \u03b1 6= \u03b11, \u03b12}\nTo help the proof, let us introduce a Claim.\nClaim 9 For any polytope {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x \u2265 d}\nwith A \u2208 Rm\u00d7n, b \u2208 Rm, c \u2208 Rn, d \u2208 R, there exists K such that for all \u03b5 > 0,\ndist(P,P\u01eb) := max x\u2208P\u01eb (min y\u2208P \u2016x\u2212 y\u20162) \u2264 \u03b5K\nwhere P = {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x = d}, P\u01eb = {x \u2208 [0, 1]n|Ax \u2265 b, d \u2265 c \u00b7 x \u2265 d\u2212 \u03b5}\nBy Claim 9 and the mathematical induction, we can find K such that there exists z\u2021 \u2208 P with \u2016z \u2212 z\u2021\u20161 \u2264 \u03b5K.\nThe proof of above Claim is following. For a polytope {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x \u2264 d}, there are finite number of vertices. Choose \u03b4 such that there is no vertex v of {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x \u2264 d} satisfying d\u2212 \u03b4 \u2264 c \u00b7 v < d. As P\u03b4 is bounded, we can choose K such that\nmax z\u2208P\u03b4,y\u2208P \u2016z \u2212 y\u20162 \u2264 \u03b4K\nConsider the case when \u03b5 > \u03b4. For any x \u2208 {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x = d \u2212 \u03b5}, y \u2208 P , set z = \u03b4\n\u03b5 x+ (1\u2212 \u03b4 \u03b5 )y Then, z \u2208 {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x = d\u2212 \u03b4},\n\u2016x\u2212 y\u20162 = \u03b5\n\u03b4 \u2016z \u2212 y\u20162 \u2264 \u03b5K\nand it implies dist(P,P\u01eb) \u2264 \u03b5K for \u03b5 > \u03b4 Now, consider the case when \u03b5 < \u03b4. From the choice of \u03b4, there is no vertex v of P\u03b4 satisfying d\u2212 \u03b4 < c \u00b7 v < d. Let v1, . . . , vm, u1, . . . , uk be vertices of P\u03b4 with c \u00b7 vi = d \u2212 \u03b4 and c \u00b7 uj = d. From the property of the polytope, for any x \u2208 {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x = d \u2212 \u03b5} \u2282 P\u03b4 can be expressed as a convex combination of v1, . . . , vm, u1, . . . , uk . It implies that there are y \u2208 P, z \u2208 {x \u2208 [0, 1]n|Ax \u2265 b, c \u00b7 x = d\u2212 \u03b4} such that x is a convex combination of y and z. Therefore,\n\u2016x\u2212 y\u20162 = \u03b5\n\u03b4 \u2016z \u2212 y\u20162 \u2264 \u03b5K\nand it implies dist(P,P\u01eb) \u2264 \u03b5K for \u03b5 < \u03b4."}, {"heading": "B Proof of Corollary 3", "text": "The proof of Corollary 3 can be done by using Theorem 1. From GM (12), each variable is connected to two factors (C2 of Theorem 1). Now, lets check C3 of Theorem 1. Suppose there are v and x\u03b4(v) with \u03c8v(x\u03b4(v)) = 1. Consider the case when there is e \u2208 \u03b4 i(v) with xe = 1 6= x\u2217e. If e \u2032 \u2208 \u03b4i(v) with xe\u2032 = 0 6= x \u2217 e\u2032 exists, choose such e\n\u2032. If not, choose e\u2032 \u2208 \u03b4o(v) with xe\u2032 = 1 6= x\u2217e\u2032 . On the other hand, consider when there is e \u2208 \u03b4i(v) with xe = 0 6= x\u2217e . If e\n\u2032 \u2208 \u03b4o(v) with xe\u2032 = 1 6= x\u2217e\u2032 exists, choose such e\u2032. If not, choose e\u2032 \u2208 \u03b4i(v) with xe\u2032 = 0 6= x\u2217e\u2032 . Then,\n\u03c8v(x \u2032 \u03b4(v)) = 1, where x \u2032 e\u2032\u2032 =\n{ xe\u2032\u2032 if k 6= e, e\u2032\nx\u2217e\u2032\u2032 otherwise .\n\u03c8v(x \u2032\u2032 \u03b4(v)) = 1, where x \u2032\u2032 e\u2032\u2032 =\n{ xe\u2032\u2032 if k = e, e\u2032\nx\u2217e\u2032\u2032 otherwise .\nWe can apply similar argument for the case when e \u2208 \u03b4o(v), v = s or t. From Theorem 1, we can conclude that if the solution of LP (11) is unique and integral, max-product BP on GM (12) converges to the solution of LP (11)."}, {"heading": "C Proof of Corollary 4", "text": "The proof of Corollary 4 can be done by using Theorem 1. From GM (15), each variable is connected to two factors (C2 of Theorem 1). Now, lets check C3 of Theorem 1. Suppose there are v and x\u03b4(v) with \u03c8v(x\u03b4(v)) = 1. Consider the case when there is ei \u2208 \u03b4(v) with xei = 1 6= x \u2217 ei\n. Then, there is e\u2032j \u2208 \u03b4(v) with xe\u2032j = 0 6= x \u2217 e\u2032j . Choose such e\u2032j . On the other hand, consider when there is ei \u2208 \u03b4(v) with xei = 0 6= x \u2217 ei . Then, there is e\u2032j \u2208 \u03b4(v) with xe\u2032j = 1 6= x \u2217 e\u2032j . Choose such e\u2032j . Then,\n\u03c8v(x \u2032 \u03b4(v)) = 1, where x \u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k 6= ei, e \u2032 j\nx\u2217 e\u2032\u2032 k\notherwise .\n\u03c8v(x \u2032\u2032 \u03b4(v)) = 1, where x \u2032\u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k = ei, e \u2032 j\nx\u2217 e\u2032\u2032 k\notherwise .\nFrom Theorem 1, we can conclude that if the solution of LP (13) is unique, max-product BP on GM (15) converges to the solution of LP (13)."}, {"heading": "D Proof of Corollary 5", "text": "From GM (17), each variable is connected to two factors (C2 of Theorem 1). Now, lets check C3 of Theorem 1. For v \u2208 V , we can apply same argument as the maximum weight matching case. Suppose there are vC and y\u03b4(vC) with \u03c8C(y\u03b4(vC )) = 1. Consider the case when there is (u1, vC) \u2208 \u03b4(vC ) with y(u1,vC) = 1 6= y \u2217 (u1,vC)\n. As a feasible solution y\u03b4(vC ) forms a disjoint even paths [13], check edges along the path contains u1. If there is u2 \u2208 V (C) in the path with y(u2,vC) = 1 6= y \u2217 (u2,vC)\nexists, choose such (u1, vC). If not, choose (u2, vC) \u2208 V (C) with y(u1,vC) = 0 6= y \u2217 (u1,vC)\nat the end of the path. On the other hand, consider the case when there is (u1, vC) \u2208 \u03b4(vC) with y(u1,vC) = 0 6= y \u2217 (u1,vC)\n. As a feasible solution y\u03b4(vC) form a disjoint even paths, check edges along the path contains u1. If there is u2 \u2208 V (C) in the path with y(u2,vC) = 0 6= y \u2217 (u2,vC)\nexists, choose such (u1, vC). If not, choose (u2, vC) \u2208 V (C) with y(u1,vC) = 1 6= y \u2217 (u1,vC)\nat the end of the path. Then, from disjoint even paths point of view, we can check that\n\u03c8C(y \u2032 \u03b4(vC ) ) = 1, where y\u2032(u,vC) = { y(u,vC) if u 6= u1, u2 y\u2217(u,vC) otherwise .\n\u03c8C(y \u2032\u2032 \u03b4(vC ) ) = 1, where y\u2032\u2032(u,vC) = { y(u,vC) if u = u1, u2 y\u2217(u,vC) otherwise .\nFrom Theorem 1, we can conclude that if the solution of LP (16) is unique and integral, max-product BP on GM (17) converges to the solution of LP (16)."}, {"heading": "E Proof of Corollary 6", "text": "The proof of Corollary 6 can be done by using Theorem 1. From GM (19), each variable is connected to two factors (C2 of Theorem 1). Now, lets check C3 of Theorem 1. Suppose there are v and x\u03b4(v) with \u03c8v(x\u03b4(v)) = 1. Consider the case when there is ei \u2208 \u03b4 i(v) with xei = 1 6= x \u2217 ei . If e\u2032i \u2208 \u03b4 i(v) with xe\u2032i = 0 6= x \u2217 e\u2032i exists, choose such e\u2032j . If not, choose e \u2032 i+1 such that xe\u2032i+1 = 1 6= x \u2217 e\u2032i+1 . On the other hand, consider when there is ei \u2208 \u03b4i(v) with xei = 0 6= x \u2217 ei . If e\u2032i \u2208 \u03b4 i(v) with xe\u2032i = 1 6= x \u2217 e\u2032i exists, choose such e\u2032j . If not, choose e \u2032 i+1 such that xe\u2032i+1 = 0 6= x \u2217 e\u2032i+1 . Then,\n\u03c8v(x \u2032 \u03b4(v)) = 1, where x \u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k 6= ei, e \u2032 i(or e \u2032 i+1)\nx\u2217 e\u2032\u2032 k\notherwise .\n\u03c8v(x \u2032 \u03b4(v)) = 1, where x \u2032\u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k = ei, e \u2032 i(or e \u2032 i+1)\nx\u2217 e\u2032\u2032 k\notherwise .\nWe can apply similar argument for the case when ei \u2208 \u03b4o(v). From Theorem 1, we can conclude that if the solution of LP (18) is unique and integral, max-product BP on GM (19) converges to the solution of LP (18)."}, {"heading": "F Proof of Corollary 8", "text": "The proof of Corollary can be done by using Theorem 1. From GM (24), each variable is connected to two factors (C2 of Theorem 1). Now, lets check C3 of Theorem 1. Suppose there are v and x\u03b4(v) with \u03c8v(x\u03b4(v)) = 1. Consider the case when there is ei \u2208 \u03b4(v) with xei = 1 6= x \u2217 ei\n. If there is e\u2032j \u2208 \u03b4(v) with xe\u2032j = 0 6= x \u2217 e\u2032j , choose such e\u2032j . If not, choose e \u2032 j = ei On the other hand, consider when there is ei \u2208 \u03b4(v) with xei = 0 6= x \u2217 ei . If there is e\u2032j \u2208 \u03b4(v) with xe\u2032j = 1 6= x \u2217 e\u2032j , choose such e\u2032j . If not, choose e\u2032j = ei Then,\n\u03c8v(x \u2032 \u03b4(v)) = 1, where x \u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k 6= ei, e \u2032 j\nx\u2217 e\u2032\u2032 k\notherwise .\n\u03c8v(x \u2032\u2032 \u03b4(v)) = 1, where x \u2032\u2032 e\u2032\u2032 k =\n{ xe\u2032\u2032\nk if e\u2032\u2032k = ei, e \u2032 j\nx\u2217 e\u2032\u2032 k\notherwise .\nFrom Theorem 1, we can conclude that if the solution of LP (22) is unique, max-product BP on GM (24) converges to the solution of LP (22)."}], "references": [{"title": "Belief-propagation for weighted b-matchings on arbitrary graphs and its relation to linear programs with integer solutions", "author": ["Mohsen Bayati", "Christian Borgs", "Jennifer Chayes", "Riccardo Zecchina"], "venue": "arXiv preprint arXiv:0709.1190,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Complexity of inference in graphical models", "author": ["Venkat Chandrasekaran", "Nathan Srebro", "Prahladh Harsha"], "venue": "arXiv preprint arXiv:1206.3240,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Linear programming and extensions", "author": ["George B Dantzig"], "venue": "Princeton university press,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1998}, {"title": "Parallel splash belief propagation", "author": ["Joseph Gonzalez", "Yucheng Low", "Carlos Guestrin"], "venue": "Technical report, DTIC Document,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2010}, {"title": "Loopy belief propagation for bipartite maximum weight bmatching", "author": ["Bert C Huang", "Tony Jebara"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "Polynomial algorithms in linear programming", "author": ["Leonid G Khachiyan"], "venue": "USSR Computational Mathematics and Mathematical Physics,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1980}, {"title": "Graphlab: A new framework for parallel machine learning", "author": ["Yucheng Low", "Joseph Gonzalez", "Aapo Kyrola", "Danny Bickson", "Carlos Guestrin", "Joseph M Hellerstein"], "venue": "arXiv preprint arXiv:1006.4990,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Task parallel implementation of belief propagation in factor graphs", "author": ["Nam Ma", "Yinglong Xia", "Viktor K Prasanna"], "venue": "In Parallel and Distributed Processing Symposium Workshops & PhD Forum (IPDPSW),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "Information, physics, and computation", "author": ["Marc Mezard", "Andrea Montanari"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}, {"title": "Modern coding theory", "author": ["Tom Richardson", "Ruediger Urbanke"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "st paths using the min-sum algorithm", "author": ["Nicholas Ruozzi", "Sekhar Tatikonda"], "venue": "In Communication, Control, and Computing,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "Belief propagation and lp relaxation for weighted matching in general graphs", "author": ["Sujay Sanghavi", "Dmitry Malioutov", "Alan Willsky"], "venue": "Information Theory, IEEE Transactions on,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "A graphical transformation for belief propagation: Maximum weight matchings and odd-sized cycles", "author": ["Jinwoo Shin", "Andrew E Gelfand", "Misha Chertkov"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Graphical models, exponential families, and variational inference", "author": ["Martin J Wainwright", "Michael I Jordan"], "venue": "Foundations and Trends R \u00a9 in Machine Learning,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Belief propagation and revision in networks with loops", "author": ["Yair Weiss"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1997}, {"title": "On the optimality of solutions of the max-product beliefpropagation algorithm in arbitrary graphs", "author": ["Yair Weiss", "William T Freeman"], "venue": "Information Theory, IEEE Transactions on,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2001}], "referenceMentions": [{"referenceID": 9, "context": "1 Introduction Graphical model (GM) has been one of powerful paradigms for succinct representations of joint probability distributions in variety of scientific fields [18, 10, 9, 15].", "startOffset": 167, "endOffset": 182}, {"referenceID": 8, "context": "1 Introduction Graphical model (GM) has been one of powerful paradigms for succinct representations of joint probability distributions in variety of scientific fields [18, 10, 9, 15].", "startOffset": 167, "endOffset": 182}, {"referenceID": 13, "context": "1 Introduction Graphical model (GM) has been one of powerful paradigms for succinct representations of joint probability distributions in variety of scientific fields [18, 10, 9, 15].", "startOffset": 167, "endOffset": 182}, {"referenceID": 1, "context": ", NP-hard) in general [2].", "startOffset": 22, "endOffset": 25}, {"referenceID": 6, "context": "For example, several software architectures for implementing parallel BPs were recently proposed [7, 4, 8] by different research groups in machine learning communities.", "startOffset": 97, "endOffset": 106}, {"referenceID": 3, "context": "For example, several software architectures for implementing parallel BPs were recently proposed [7, 4, 8] by different research groups in machine learning communities.", "startOffset": 97, "endOffset": 106}, {"referenceID": 7, "context": "For example, several software architectures for implementing parallel BPs were recently proposed [7, 4, 8] by different research groups in machine learning communities.", "startOffset": 97, "endOffset": 106}, {"referenceID": 11, "context": "Recently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11].", "startOffset": 180, "endOffset": 187}, {"referenceID": 4, "context": "Recently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11].", "startOffset": 180, "endOffset": 187}, {"referenceID": 0, "context": "Recently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11].", "startOffset": 206, "endOffset": 209}, {"referenceID": 12, "context": "Recently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11].", "startOffset": 236, "endOffset": 240}, {"referenceID": 10, "context": "Recently, it has been shown that BP converges to the correct answer for certain classes of loopy GM formulations of several combinatorial optimization problems, including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11].", "startOffset": 259, "endOffset": 263}, {"referenceID": 2, "context": "In other words, BP can be used an efficient distributed solver for those LPs, and is presumably better than classical centralized LP solvers such as simplex methods [3], interior point methods [14] and ellipsoid methods [6] for large-scale inputs.", "startOffset": 165, "endOffset": 168}, {"referenceID": 5, "context": "In other words, BP can be used an efficient distributed solver for those LPs, and is presumably better than classical centralized LP solvers such as simplex methods [3], interior point methods [14] and ellipsoid methods [6] for large-scale inputs.", "startOffset": 220, "endOffset": 223}, {"referenceID": 11, "context": ", the BP analysis for matching problems [12, 5] do not extend to even for perfect matching ones [1].", "startOffset": 40, "endOffset": 47}, {"referenceID": 4, "context": ", the BP analysis for matching problems [12, 5] do not extend to even for perfect matching ones [1].", "startOffset": 40, "endOffset": 47}, {"referenceID": 0, "context": ", the BP analysis for matching problems [12, 5] do not extend to even for perfect matching ones [1].", "startOffset": 96, "endOffset": 99}, {"referenceID": 11, "context": "First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.", "startOffset": 90, "endOffset": 97}, {"referenceID": 4, "context": "First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.", "startOffset": 90, "endOffset": 97}, {"referenceID": 0, "context": "First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.", "startOffset": 116, "endOffset": 119}, {"referenceID": 12, "context": "First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.", "startOffset": 146, "endOffset": 150}, {"referenceID": 10, "context": "First of all, our generic condition can rediscover previous BP results including matching [12, 5], perfect matching [1], matching with odd cycles [13] and shortest path [11], i.", "startOffset": 169, "endOffset": 173}, {"referenceID": 0, "context": "For example, if z = [0, 1, 0] and \u03b1 = {1, 3}, then z\u03b1 = [0, 0].", "startOffset": 20, "endOffset": 29}, {"referenceID": 1, "context": ", NP-hard) unless the induced bipartite graph of factors F and variables z, so-called factor graph, has a bounded treewidth [2].", "startOffset": 124, "endOffset": 127}, {"referenceID": 0, "context": "Then, the BP algorithm outputs z = [z i ] as z i = \uf8f1 \uf8f4\uf8f2 \uf8f4\uf8f3 1 if bi[1] > bi[0] ? if bi[1] = bi[0] 0 if bi[1] < bi[0] .", "startOffset": 66, "endOffset": 69}, {"referenceID": 0, "context": "Then, the BP algorithm outputs z = [z i ] as z i = \uf8f1 \uf8f4\uf8f2 \uf8f4\uf8f3 1 if bi[1] > bi[0] ? if bi[1] = bi[0] 0 if bi[1] < bi[0] .", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "Then, the BP algorithm outputs z = [z i ] as z i = \uf8f1 \uf8f4\uf8f2 \uf8f4\uf8f3 1 if bi[1] > bi[0] ? if bi[1] = bi[0] 0 if bi[1] < bi[0] .", "startOffset": 104, "endOffset": 107}, {"referenceID": 0, "context": "To establish the performance of BP on GM (7) for solving IP (8), we also consider the following the LP (Linear Programming) relation to IP (8): minimize w \u00b7 x subject to \u03c8\u03b1(x\u03b1) = 1, \u2200\u03b1 \u2208 F x = [xi] \u2208 [0, 1] .", "startOffset": 200, "endOffset": 206}, {"referenceID": 0, "context": "We let P denote the polytope of feasible solutions of the above LP: P := {x \u2208 [0, 1] : \u03c8\u03b1(x\u03b1) = 1, \u2200\u03b1 \u2208 F} .", "startOffset": 78, "endOffset": 84}, {"referenceID": 0, "context": "Similarly, P\u03b1 is defined as P\u03b1 := { x \u2208 [0, 1]|\u03b1| : \u03c8\u03b1(x\u03b1) = 1 } .", "startOffset": 40, "endOffset": 46}, {"referenceID": 15, "context": "Now we construct a tree-structured GM (also popularly known as the computational tree [17]), denoted by Ti(t), as follows:", "startOffset": 86, "endOffset": 90}, {"referenceID": 14, "context": "Since we assume x\u0302i \u2208 {0, ?}, it is known from [16] that there exists a MAP configuration y MAP on Ti(t) with y i = 0 at the root variable.", "startOffset": 47, "endOffset": 51}, {"referenceID": 10, "context": "We first show the shortest path problem [11].", "startOffset": 40, "endOffset": 44}, {"referenceID": 4, "context": "Secondly, we show matching related applications including the results of [5, 12, 1, 13].", "startOffset": 73, "endOffset": 87}, {"referenceID": 11, "context": "Secondly, we show matching related applications including the results of [5, 12, 1, 13].", "startOffset": 73, "endOffset": 87}, {"referenceID": 0, "context": "Secondly, we show matching related applications including the results of [5, 12, 1, 13].", "startOffset": 73, "endOffset": 87}, {"referenceID": 12, "context": "Secondly, we show matching related applications including the results of [5, 12, 1, 13].", "startOffset": 73, "endOffset": 87}, {"referenceID": 0, "context": "x = [xe] \u2208 [0, 1] .", "startOffset": 11, "endOffset": 17}, {"referenceID": 0, "context": "e\u2208\u03b4(v) xe = 1, \u2200 v \u2208 V x = [xe] \u2208 [0, 1] .", "startOffset": 34, "endOffset": 40}, {"referenceID": 0, "context": "ei\u2208\u03b4(v) xei = 2 \u2200 v \u2208 V x = [xe1 , xe2 ] \u2208 [0, 1] .", "startOffset": 43, "endOffset": 49}, {"referenceID": 12, "context": "There is previous work on finding matching by using BP and adding disjoint odd cycle constraint [13].", "startOffset": 96, "endOffset": 100}, {"referenceID": 12, "context": "We refer the following graphical transformation from [13].", "startOffset": 53, "endOffset": 57}, {"referenceID": 12, "context": "We refer the maximum weight matching with odd cycles LP from [13] and slightly modify to make the maximum weight perfect matching with odd cycles LP.", "startOffset": 61, "endOffset": 65}, {"referenceID": 1, "context": "u\u2208V (C) (\u22121)d(u,e)y(vC ,u) \u2208 [0, 2] \u2200e \u2208 E(C) \u2211", "startOffset": 29, "endOffset": 35}, {"referenceID": 0, "context": "y = [ye] \u2208 [0, 1] |E| (16)", "startOffset": 11, "endOffset": 17}, {"referenceID": 0, "context": "subject to \u2211 ei+1\u2208\u03b4(v) xei+1 \u2212 \u2211 ei\u2208\u03b4(v) xei = 0 \u2211 e1\u2208\u03b4(v) xe1 = \u2211 en\u2208\u03b4(v) xen = 0 i 6= n, v 6= s \u2211 e1\u2208\u03b4(s) xe1 = \u2211 en\u2208\u03b4(s) xen = 1 \u2211 ei\u2208\u03b4(s) xei = \u2211 ej\u2208\u03b4(s) xej = 0 i 6= 1, j 6= n x = [xei ] \u2208 [0, 1] |V .", "startOffset": 194, "endOffset": 200}, {"referenceID": 0, "context": "i \u2211 ei\u2208\u03b4(t) xei = 1, \u2211 ej\u2208\u03b4(t) xej = 0 \u2200j x = [xei ] \u2208 [0, 1] |V .", "startOffset": 55, "endOffset": 61}, {"referenceID": 0, "context": "ei\u2208\u03b4(v) xei \u2264 bv, \u2200 v \u2208 V x = [xei ] \u2208 [0, 1] |E| (23)", "startOffset": 39, "endOffset": 45}, {"referenceID": 0, "context": "Where, \u03b4(v) is a set of edges connected to a vertex v, w = [wei : ei \u2208 E \u2032] \u2208 [0, 1]|E | and wi = 1 \u2212 i\u03b5.", "startOffset": 78, "endOffset": 84}], "year": 2017, "abstractText": "Max-product belief propagation (BP) is a popular message-passing algorithm for computing a maximum a-posteriori (MAP) assignment in a joint distribution represented by a graphical model (GM). It was recently shown that BP can solve certain classes of Linear Programming (LP) formulations to combinatorial optimization problems including maximum weight matching and shortest path, i.e., BP can be a distributed solver for certain LPs. However, those LPs and corresponding BP analysis are very sensitive to underlying problem setups, and it has been not clear what extent these results can be generalized to. In this paper, we obtain a generic criteria such that BP converges to the correct solution of the desired LP. Our theoretical result not only rediscovers prior known ones for maximum weight matching and shortest path as special cases, but also can be applied to new problems including traveling salesman, longest path and vertex cover, i.e., BP is a distributed (and parallel) solver to the combinatorial optimization problems. We believe that our results provide new insights on BP performances and new directions on distributed solvers for certain classes of large-scale LPs.", "creator": "LaTeX with hyperref package"}}}