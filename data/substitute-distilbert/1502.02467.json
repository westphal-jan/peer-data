{"id": "1502.02467", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2015", "title": "Structural Decompositions for Problems with Global Constraints", "abstract": "a wide range of problems can result modelled as constraint satisfaction problems ( csps ), that is, a set of alternatives that must be satisfied simultaneously. constraints can either be accessed extensionally, by explicitly listing simple combinations of values, may indirectly, by special - purpose algorithms provided by a solver.", "histories": [["v1", "Mon, 9 Feb 2015 12:55:36 GMT  (123kb,D)", "http://arxiv.org/abs/1502.02467v1", "The final publication is available at Springer viathis http URL"]], "COMMENTS": "The final publication is available at Springer viathis http URL", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["evgenij thorstensen"], "accepted": false, "id": "1502.02467"}, "pdf": {"name": "1502.02467.pdf", "metadata": {"source": "META", "title": "Structural Decompositions for Problems with Global Constraints", "authors": ["Evgenij Thorstensen"], "emails": ["evgenit@ifi.uio.no"], "sections": [{"heading": null, "text": "Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances have been shown to yield tractable classes of CSPs. However, most such restrictions fail to guarantee tractability for CSPs with global constraints. We therefore study the applicability of structural restrictions to instances with such constraints.\nWe show that when the number of solutions to a CSP instance is bounded in key parts of the problem, structural restrictions can be used to derive new tractable classes. Furthermore, we show that this result extends to combinations of instances drawn from known tractable classes, as well as to CSP instances where constraints assign costs to satisfying assignments.\nKeywords Tractability \u00b7 Global constraints \u00b7 Structural restrictions"}, {"heading": "1 Introduction", "text": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28]. Constraints can either be represented explicitly, by a table of allowed assignments, or implicitly, by specialized algorithms provided by the constraint solver. These algorithms may take as a parameter a description that specifies exactly which kinds of assignments a particular instance of a constraint should allow. Such implicitly represented constraints are known\nE. Thorstensen Department of Informatics, University of Oslo, Norway E-mail: evgenit@ifi.uio.no\nA preliminary version of this paper appeared in Proceedings of the 19th International Conference on Principles and Practice of Constraint Programming (CP 2013).\nar X\niv :1\n50 2.\n02 46\n7v 1\n[ cs\n.A I]\n9 F\neb 2\n01 5\nas global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].\nThe theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33]. In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33]. However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints. This is the case even when the global constraints are fairly simple, such as overlapping difference constraints with acyclic hypergraphs [30].\nTheoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local consistency for individual constraints. This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37]. Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [7]. These techniques allow faster implementations of algorithms for individual constraints, but do not shed much light on the complexity of problems with multiple overlapping global constraints, which is something that practical problems frequently require.\nAs such, in this paper we investigate the properties of explicitly represented constraints that allow structural restrictions to guarantee tractability. Identifying such properties will allow us to find global constraints that also possess them, and lift structural restrictions to instances with such constraints.\nAs discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity. Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation. In contrast, we will use a definition of global constraints, used also in [14], that allows us to discuss different representations in a uniform manner. Armed with this definition, we obtain results that rely on a relationship between the size of a global constraint and the number of its satisfying assignments.\nFurthermore, as our definition is general enough to capture arbitrary problems in NP, we demonstrate how our results can be used to decompose a constraint problem into smaller constraint problems (as opposed to individual constraints), and when such decompositions lead to tractability. The results that we obtain on this topic extend previous research by Cohen and Green [10]. In addition to being more general, our results arguably use simpler theoretical machinery.\nFinally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution."}, {"heading": "2 Preliminaries", "text": "In this section, we define the basic concepts that we will use throughout the paper. In particular, we give a precise definition of global constraints and of structural decompositions.\n2.1 Global Constraints\nDefinition 1 (Variables and assignments) Let V be a set of variables, each with an associated finite set of domain elements. We denote the set of domain elements (the domain) of a variable v by D(v). We extend this notation to arbitrary subsets of variables, W , by setting D(W ) =\n\u22c3 v\u2208W D(v).\nAn assignment of a set of variables V is a function \u03b8 : V \u2192 D(V ) that maps every v \u2208 V to an element \u03b8(v) \u2208 D(v). We write V(\u03b8) for the set of variables V .\nWe denote the restriction of \u03b8 to a set of variablesW \u2286 V by \u03b8|W . We also allow the special assignment \u22a5 of the empty set of variables. In particular, for every assignment \u03b8, we have \u03b8|\u2205 = \u22a5.\nDefinition 2 (Projection) Let \u0398 be a set of assignments of a set of variables V . The projection of \u0398 onto a set of variables X \u2286 V is the set of assignments \u03c0X(\u0398) = {\u03b8|X | \u03b8 \u2208 \u0398}.\nNote that when \u0398 = \u2205 we have \u03c0X(\u0398) = \u2205, but when X = \u2205 and \u0398 6= \u2205, we have \u03c0X(\u0398) = {\u22a5}.\nDefinition 3 (Disjoint union of assignments) Let \u03b81 and \u03b82 be two assignments of disjoint sets of variables V1 and V2, respectively. The disjoint union of \u03b81 and \u03b82, denoted \u03b81 \u2295 \u03b82, is the assignment of V1 \u222a V2 such that (\u03b81 \u2295 \u03b82)(v) = \u03b81(v) for all v \u2208 V1, and (\u03b81 \u2295 \u03b82)(v) = \u03b82(v) for all v \u2208 V2.\nGlobal constraints have traditionally been defined, somewhat vaguely, as constraints without a fixed arity, possibly also with a compact representation of the constraint relation. For example, in [29] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.\nBelow, we offer a precise definition similar to the one in [6], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time. Our definition differs from this one in that we separate the general algorithm of a global constraint (which we call its type) from the specific description. This separation allows us a better way of measuring the size of a global constraint, which in turn helps us to establish new complexity results.\nDefinition 4 (Global constraints) A global constraint type is a parameterized polynomialtime algorithm that determines the acceptability of an assignment of a given set of variables.\nEach global constraint type, e, has an associated set of descriptions, \u2206(e). Each description \u03b4 \u2208 \u2206(e) specifies appropriate parameter values for the algorithm e. In particular, each \u03b4 \u2208 \u2206(e) specifies a set of variables, denoted by V(\u03b4). We write |\u03b4| for the number of bits used to represent \u03b4.\nA global constraint e[\u03b4], where \u03b4 \u2208 \u2206(e), is a function that maps assignments of V(\u03b4) to the set {0, 1}. Each assignment that is allowed by e[\u03b4] is mapped to 1, and each disallowed assignment is mapped to 0. The extension or constraint relation of e[\u03b4] is the set of assignments, \u03b8, of V(\u03b4) such that e[\u03b4](\u03b8) = 1. We also say that such assignments satisfy the constraint, while all other assignments falsify it.\nWhen we are only interested in describing the set of assignments that satisfy a constraint, and not in the complexity of determining membership in this set, we will sometimes abuse notation by writing \u03b8 \u2208 e[\u03b4] to mean e[\u03b4](\u03b8) = 1.\nAs can be seen from the definition above, a global constraint is not usually explicitly represented by listing all the assignments that satisfy it. Instead, it is represented by some description \u03b4 and some algorithm e that allows us to check whether the constraint relation of e[\u03b4] includes a given assignment. To stay within the complexity class NP, this algorithm is required to run in polynomial time. As the algorithms for many kinds of global constraints are built into modern constraint solvers, we measure the size of a global constraint\u2019s representation by the size of its description.\nExample 1 (EGC) A very general global constraint type is the extended global cardinality constraint type [37]. This form of global constraint is defined by specifying, for every domain element a, a finite set of natural numbers K(a), called the cardinality set of a. The constraint requires that the number of variables which are assigned the value a is in the set K(a), for each possible domain element a.\nUsing our notation, the description \u03b4 of an EGC global constraint specifies a functionK\u03b4 : D(V(\u03b4))\u2192 P(N) that maps each domain element to a set of natural numbers. The algorithm for the EGC constraint then maps an assignment \u03b8 to 1 if and only if, for every domain element a \u2208 D(V(\u03b4)), we have that |{v \u2208 V(\u03b4) | \u03b8(v) = a}| \u2208 K\u03b4(a).\nExample 2 (Table and negative constraints) A rather degenerate example of a a global constraint type is the table constraint.\nIn this case the description \u03b4 is simply a list of assignments of some fixed set of variables, V(\u03b4). The algorithm for a table constraint then decides, for any assignment of V(\u03b4), whether it is included in \u03b4. This can be done in a time which is linear in the size of \u03b4 and so meets the polynomial time requirement.\nNegative constraints are complementary to table constraints, in that they are described by listing forbidden assignments. The algorithm for a negative constraint e[\u03b4] decides, for any assignment of V(\u03b4), whether it is not included in \u03b4. Observe that disjunctive clauses, used to define propositional satisfiability problems, are a special case of the negative constraint type, as they have exactly one forbidden assignment.\nWe observe that any global constraint can be rewritten as a table or negative constraint. However, this rewriting will, in general, incur an exponential increase in the size of the description.\nAs can be seen from the definition above, a table global constraint is explicitly represented, and thus equivalent to the usual notion of an extensionally represented constraint.\nIn some cases, particularly for table constraints, we will make use of the standard notion of a relational join, which we define below.\nDefinition 5 (Constraint join) A global constraint ej [\u03b4j ] is the join of two global constraints e1[\u03b41] and e2[\u03b42] whenever V(\u03b4j) = V(\u03b41) \u222a V(\u03b42), and \u03b8 \u2208 ej [\u03b4j ] if and only if \u03b8|V(\u03b41) \u2208 e1[\u03b41] and \u03b8|V(\u03b42) \u2208 e2[\u03b42].\nDefinition 6 (CSP instance) An instance of the constraint satisfaction problem (CSP) is a pair \u3008V,C\u3009 where V is a finite set of variables, and C is a set of global constraints such that V = \u22c3 e[\u03b4]\u2208C V(\u03b4). In a CSP instance, we call V(\u03b4) the scope of the constraint e[\u03b4]. A classic CSP instance is one where every constraint is a table constraint. A solution to a CSP instance P = \u3008V,C\u3009 is an assignment \u03b8 of V which satisfies every global constraint, i.e., for every e[\u03b4] \u2208 C we have \u03b8|V(\u03b4) \u2208 e[\u03b4]. We denote the set of solutions to P by sol(P ).\nThe size of a CSP instance P = \u3008V,C\u3009 is |P | = |V |+ \u2211 v\u2208V |D(v)|+ \u2211 e[\u03b4]\u2208C |\u03b4|.\nNote that this definition disallows CSP instances with variables that are not in the scope of any constraint. Since a variable that is not in the scope of any constraint can be assigned any value from its domain, excluding such variables can be done without loss of generality. While this condition is strictly speaking not necessary, it will allow us to simplify some proofs later on. In particular, it entails that the set of solutions to a CSP instance is precisely the set of assignments satisfying the constraint obtained by taking the join of every constraint in the CSP instance.\nTo illustrate these definitions, consider the connected graph partition problem (CGP) [18, p. 209], formally defined below. Informally, the CGP is the problem of partitioning the vertices of a graph into bags of a given size while minimizing the number of edges that have endpoints in different bags.\nProblem 1 (Connected graph partition (CGP)) We are given an undirected and connected graph \u3008V,E\u3009, as well as \u03b1, \u03b2 \u2208 N. Can V be partitioned into disjoint sets V1, . . . , Vm, for some m, with |Vi| \u2264 \u03b1 such that the set of broken edges E\u2032 = {{u, v} \u2208 E | u \u2208 Vi, v \u2208 Vj , i 6= j} has cardinality \u03b2 or less?\nExample 3 (The CGP encoded with global constraints) Given a connected graph G = \u3008V,E\u3009, \u03b1, and \u03b2, we build a CSP instance \u3008A\u222aB,C\u3009 as follows. The set A will have a variable v for every v \u2208 V with domain D(v) = {1, . . . , |V |}, while the set B will have a boolean variable e for every edge in E.\nThe set of constraints C will have an EGC constraint C\u03b1 on A with K(i) = {0, . . . , \u03b1} for every 1 \u2264 i \u2264 |V |. Likewise, C will have an EGC constraint C\u03b2 on B with K(0) = {0, . . . , |E|} and K(1) = {0, . . . , \u03b2}.\nFinally, to connect A and B, the set C will have for every edge {u, v} \u2208 E, with corresponding variable e \u2208 B, a table constraint on {u, v, e} requiring \u03b8(u) 6= \u03b8(v) \u2192 \u03b8(e) = 1.\nAs an example, Figure 1 shows this encoding for the CGP on the graph C5, that is, a simple cycle on five vertices.\nThis encoding follows the definition of Problem 1 quite closely, and can be done in polynomial time.\n2.2 Structural Restrictions\nIn recent years, there has been a flurry of research into identifying tractable classes of classic CSP instances based on structural restrictions, that is, restrictions on the\nhypergraphs of CSP instances. Below, we present and discuss a few representative examples. In Sections 3 and 4, we will show how these techniques can be applied to CSP instance with global constraints. To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].\nDefinition 7 (Hypergraph) A hypergraph \u3008V,H\u3009 is a set of vertices V together with a set of hyperedges H \u2286 P(V ).\nGiven a CSP instance P = \u3008V,C\u3009, the hypergraph of P , denoted hyp(P ), has vertex set V together with a hyperedge V(\u03b4) for every e[\u03b4] \u2208 C.\nDefinition 8 (Tree decomposition) A tree decomposition of a hypergraph \u3008V,H\u3009 is a pair \u3008T, \u03c7\u3009 where T is a tree and \u03c7 is a labelling function from nodes of T to subsets of V , such that\n1. for every v \u2208 V , there exists a node t of T such that v \u2208 \u03c7(t), 2. for every hyperedge h \u2208 H, there exists a node t of T such that h \u2286 \u03c7(t), and 3. for every v \u2208 V , the set of nodes {t | v \u2208 \u03c7(t)} induces a connected subtree of T .\nDefinition 9 (Width function) Let G = \u3008V,H\u3009 be a hypergraph. A width function on G is a function f : P(V )\u2212 {\u2205} \u2192 R+ that assigns a positive real number to every nonempty subset of vertices of G. A width function f is monotone if f(X) \u2264 f(Y ) whenever X \u2286 Y .\nLet \u3008T, \u03c7\u3009 be a tree decomposition of G, and f a width function on G. The f-width of \u3008T, \u03c7\u3009 is max({f(\u03c7(t)) | t node of T}). The f-width of G is the minimal f -width over all its tree decompositions.\nIn other words, a width function on a hypergraph G tells us how to assign weights to nodes of tree decompositions of G.\nDefinition 10 (Treewidth) Let f(X) = |X| \u2212 1. The treewidth tw(G) of a hypergraph G is the f -width of G.\nLet G = \u3008V,H\u3009 be a hypergraph, and X \u2286 V . An edge cover of X is any set of hyperedges H \u2032 \u2286 H that satisfies X \u2286 \u22c3 H \u2032. The edge cover number \u03c1(X) of X is the size of the smallest edge cover of X. It is clear that \u03c1 is a width function.\nDefinition 11 ([1, Chapter 2]) The generalized hypertree width ghw(G) of a hypergraph G is the \u03c1-width of G.\nNext, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [27].\nDefinition 12 (Fractional edge cover) Let G = \u3008V,H\u3009 be a hypergraph, and X \u2286 V . A fractional edge cover for X is a function \u03b3 : H \u2192 [0, 1] such that \u2211 v\u2208h\u2208H \u03b3(h) \u2265 1\nfor every v \u2208 X. We call \u2211 h\u2208H \u03b3(h) the weight of \u03b3. The fractional edge cover number \u03c1\u2217(X) of X is the minimum weight over all fractional edge covers for X. It is known that this minimum is always rational [27]. We furthermore define \u03c1\u2217(G) = \u03c1\u2217(V ).\nDefinition 13 The fractional hypertree width fhw(G) of a hypergraph G is the \u03c1\u2217width of G.\nFor a class of hypergraphs H and a notion of width \u03b1, we write \u03b1(H) for the maximal \u03b1-width over the hypergraphs in H. If this is unbounded we write \u03b1(H) =\u221e; otherwise \u03b1(H) <\u221e.\nBounding any of the above width measures by a constant can be used to guarantee tractability for classes of CSP instances where all constraints are table constraints.\nTheorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs. For every \u03b1 \u2208 {tw, ghw, fhw}, any class of classic CSP instances whose hypergraphs are in H is tractable if \u03b1(H) <\u221e.\nTo go beyond fractional hypertree width, Marx [33] recently introduced the concept of submodular width. This concept uses a set of width functions satisfying a condition (submodularity), and considers the f -width of a hypergraph for every such function f .\nDefinition 14 (Submodular width function) Let G = \u3008V,H\u3009 be a hypergraph. A width function f on G is edge-dominated if f(h) \u2264 1 for every h \u2208 H.\nAn edge-dominated width function f on G is submodular if for every pair of sets X,Y \u2286 V , we have f(X) + f(Y ) \u2265 f(X \u2229 Y ) + f(X \u222a Y ).\nDefinition 15 (Submodular width) Let G be a hypergraph. The submodular width subw(G) of G is the supremum of the f -widths of G taken over all monotone, edgedominated, submodular width functions f on G.\nFor a class of hypergraphs H, we write subw(H) for the maximal submodular width over the hypergraphs in H. If this is unbounded we write subw(H) = \u221e; otherwise subw(H) <\u221e.\nUnlike for fractional hypertree width and every other structural restriction discussed so far, the running time of the algorithm given by Marx for classic CSP instances with bounded submodular width has an exponential dependence on the number of vertices in the hypergraph of the instance. The class of classic CSP instances with bounded submodular width is therefore not known to be tractable. However, this class is what is called fixed-parameter tractable [16,17].\nDefinition 16 (Fixed-parameter tractable) A parameterized problem instance is a pair \u3008k, P \u3009, where P is a problem instance, such as a CSP instance, and k \u2208 N a parameter.\nLet S be a class of parameterized problem instances. We say that S is fixedparameter tractable (in FPT) if there is a computable function f of one argument, as well as a constant c, such that every problem \u3008k, P \u3009 \u2208 S can be solved in time O(f(k)\u00d7 |P |c).\nThe function f can be arbitrary, but must only depend on the parameter k. For CSP instances, one possible parameterization is by the size of the hypergraph of an instance, measured by the number of vertices. Since the hypergraph of an instance has a vertex for every variable, for every CSP instance P = \u3008V,C\u3009 we consider the parameterized instance \u3008|V |, P \u3009.\nTheorem 2 ([33]) Let H be a class of hypergraphs. If subw(H) <\u221e, then a class of classic CSP instances whose hypergraphs are in H is in FPT.\nThe three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 ghw(G) \u2264 tw(G).\nAs the example below demonstrates, Theorem 1 does not hold for CSP instances with arbitrary global constraints, even if we have a fixed, finite domain. The only exception is the restriction of Theorem 1 to treewidth, as bounded treewidth implies bounded arity for every hyperedge.\nExample 4 The NP-complete problem of 3-colourability [18] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.\nWe may reduce this problem to a CSP with EGC constraints (cf. Example 1) as follows: Let V be the set of variables for our CSP instance, each with domain {r, g, b}. For every edge \u3008v, w\u3009 \u2208 E, we post an EGC constraint with scope {v, w}, parameterized by the function K such that K(r) = K(g) = K(b) = {0, 1}. Finally, we make the hypergraph of this CSP instance have low width by adding an EGC constraint with scope V parameterized by the function K\u2032 such that K\u2032(r) = K\u2032(g) = K\u2032(b) = {0, . . . , |V |}. This reduction clearly takes polynomial time, and the hypergraph G of the resulting instance has ghw(G) = fhw(G) = subw(G) = 1.\nAs the constraint with scope V allows all possible assignments, any solution to this CSP is also a solution to the 3-colourability problem, and vice versa.\nLikewise, Theorem 2 does not hold for CSP instances with arbitrary global constraints if we allow the variables unbounded domain size, that is, change the above example to allow each variable its own set of colours. In other words, the structural restrictions cannot yield tractable classes of CSP instances with arbitrary global constraints. With that in mind, in the rest of the paper we will identify properties of extensionally represented constraints that these structural restrictions exploit to guarantee tractability. Then, we are going to look for restricted classes of global constraints that possess these properties. To do so, we will use the following definitions.\nDefinition 17 (Constraint catalogue) A constraint catalogue is a set of global constraints. A CSP instance \u3008V,C\u3009 is said to be over a constraint catalogue \u0393 if for every e[\u03b4] \u2208 C we have e[\u03b4] \u2208 \u0393 .\nDefinition 18 (Restricted CSP class) Let \u0393 be a constraint catalogue, and let H be a class of hypergraphs. We define CSP(H, \u0393 ) to be the class of CSP instances over \u0393 whose hypergraphs are in H.\nDefinition 18 allows us to discuss classic CSP instances alongside instances with global constraints. Let Ext be the constraint catalogue containing all table global constraints. The classic CSP instances are then precisely those that are over Ext. In particular, we can now restate Theorems 1 and 2 as follows.\nTheorem 3 Let H be a class of hypergraphs. For every \u03b1 \u2208 {tw, ghw, fhw}, the class of CSP instances CSP(H,Ext) is tractable if \u03b1(H) <\u221e. Furthermore, if subw(H) <\u221e then CSP(H,Ext) is in FPT."}, {"heading": "3 Properties of Extensional Representation", "text": "We are going to start our investigation by considering fractional hypertree width in more detail. To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [27] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance. The following definition formalizes what we mean by \u201cparts\u201d, and is required to state the algorithm that Grohe and Marx use in their paper.\nDefinition 19 (Constraint projection) Let e[\u03b4] be a global constraint. The projection of e[\u03b4] onto a set of variables X \u2286 V(\u03b4) is the constraint pjX(e[\u03b4]) such that \u00b5 \u2208 pjX(e[\u03b4]) if and only if there exists \u03b8 \u2208 e[\u03b4] with \u03b8|X = \u00b5.\nFor a CSP instance P = \u3008V,C\u3009 and X \u2286 V we define pjX(P ) = \u3008X,C\u2032\u3009, where C\u2032 is the set containing for every e[\u03b4] \u2208 C such that X \u2229 V(\u03b4) 6= \u2205 the constraint pjX\u2229V(\u03b4)(e[\u03b4]).\n3.1 Algorithm for Enumerating All Solutions\nThe algorithm is given as Algorithm 1, and is essentially the usual recursive search algorithm for finding all solutions to a CSP instance by considering smaller and smaller sub-instances using constraint projections.\nTo show that Algorithm 1 does indeed find all solutions, we will use the following property of constraint projections.\nLemma 1 Let P = \u3008V,C\u3009 be a CSP instance. For every X \u2286 V , we have sol(pjX(P )) \u2287 \u03c0X(sol(P )).\nProof Given P = \u3008V,C\u3009, let X \u2286 V be arbitrary, and let C\u2032 = {e[\u03b4] \u2208 C | X \u2229 V(\u03b4) 6= \u2205}. For every \u03b8 \u2208 sol(P ) and constraint e[\u03b4] \u2208 C\u2032 we have that \u03b8|V(\u03b4) \u2208 e[\u03b4] since \u03b8 is a solution to P . By Definition 19, it follows that for every e[\u03b4] \u2208 C\u2032, \u03b8|X\u2229V(\u03b4) \u2208 pjX\u2229V(\u03b4)(e[\u03b4]). Since the set of constraints of pjX(P ) is the least set containing for each e[\u03b4] \u2208 C\u2032 the constraint pjX\u2229V(\u03b4)(e[\u03b4]), we have \u03b8|X \u2208 sol(pjX(P )), and hence sol(pjX(P )) \u2287 \u03c0X(sol(P )). Since X was arbitrary, the claim follows. ut\nTheorem 4 (Correctness of Algorithm 1) For every CSP instance P , we have that EnumSolutions(P ) = sol(P ).\nAlgorithm 1 Enumerate all solutions of a CSP instance procedure EnumSolutions(CSP instance P = \u3008V,C\u3009) . Returns sol(P )\nSolutions\u2190 \u2205 if V = \u2205 then\nreturn {\u22a5} . The empty assignment else\nw \u2190 chooseVar(V ) . Pick a variable from V \u0398 = EnumSolutions(pjV\u2212{w}(P )) for \u03b8 \u2208 \u0398 do\nfor a \u2208 D(w) do \u03b8\u2032(w) = a if \u03b8 \u2295 \u03b8\u2032 is a solution to P then\nSolutions.add(\u03b8 \u2295 \u03b8\u2032) end if \u03b8\u2032 \u2190 \u22a5\nend for end for\nend if return Solutions\nend procedure\nProof The proof is by induction on the set of variables V in P . For the base case, if V = \u2205, the empty assignment is the only solution.\nOtherwise, choose a variable w \u2208 V , and let X = V \u2212 {w}. By induction, we can assume that EnumSolutions(pjX(P )) = sol(pjX(P )). Since for every \u03b8 \u2208 sol(P ) there exists a \u2208 D(w) such that \u03b8 = \u03b8|X \u222a \u3008w, a\u3009, and furthermore \u03b8|X \u2208 \u03c0X(sol(P )), it follows by Lemma 1 that \u03b8|X \u2208 sol(pjX(P )). Since Algorithm 1 checks every assignment of the form \u00b5 \u222a \u3008w, a\u3009 for every \u00b5 \u2208 sol(pjX(P )) and a \u2208 D(w), it follows that EnumSolutions(P ) = sol(P ). ut\nThe time required for this algorithm depends on three key factors, which we are going to enumerate and discuss below. Let\n1. s(P ) be the maximum of the number of solutions to each of the instances pjW (P ), for W \u2286 V , 2. c(P ) be the maximum time required to check whether an assignment is a solution to pjW (P ), for W \u2286 V , and 3. b(P ) be the maximum time required to construct any instance pjW (P ), forW \u2286 V .\nThere are |V | calls to EnumSolutions. For each call, we need b(P ) time to construct the projection, while the double loop takes at most s(P )\u00d7|D(w)|\u00d7c(P ) time. Therefore, letting d = max({|D(w)| | w \u2208 V }), the running time of Algorithm 1 is bounded by O ( |V | \u00d7 (s(P )\u00d7 d\u00d7 c(P ) + b(P )) ) .\nSince constructing the projection of a classic CSP instance can be done in polynomial time, and likewise checking that an assignment is a solution, the whole algorithm runs in polynomial time if s(P ) is a polynomial in the size of P . For fractional edge covers, Grohe and Marx show the following.\nLemma 2 ([27]) A classic CSP instance P has at most |P |\u03c1 \u2217(hyp(P )) solutions.\nThe reason for Lemma 2 is that fractional edge covers require the hypergraph to be quite dense, and also that the hyperedges grow with the number of vertices in the hypergraph. This result has since been shown to be optimal \u2014 a classic CSP instance has polynomially many solutions in its size if and only if it has bounded fractional edge cover number [5].\nSince fractional edge cover number is a monotone width function, it follows that for any instance P = \u3008V,C\u3009 and X \u2286 V , \u03c1\u2217(hyp(pjX(P ))) \u2264 \u03c1\u2217(hyp(P )). This claim follows from the fact that pjX(P ) projects every constraint down to X, and hence every hyperedge of hyp(P ) down to X. Therefore, for classic CSP instances of bounded fractional edge cover number s(P ) is indeed polynomial in |P |. Grohe and Marx use this property to solve instances with bounded fractional hypertree width (and hence, bounded fractional edge cover number for every node in the corresponding tree decomposition) in polynomial time.\n3.2 CSP Instances with Few Solutions in Key Places\nAs we have seen above, having few solutions for every projection of a CSP instance is a property that can be used to obtain tractable classes of classic CSP instances. More importantly, we have shown that this property allows us to find all solutions to a CSP instance P , even with global constraints, if we can build arbitrary projections of P in polynomial time. In other words, with these two conditions we should be able to reduce instances with global constraints to classic instances in polynomial time. This, in turn, should allows us to apply the structural decomposition techniques discussed in Section 2.2 to such instances.\nHowever, on reflection there is no reason why we should need few solutions for every projection. Instead, consider the following reduction.\nDefinition 20 (Partial assignment checking) A global constraint catalogue \u0393 allows partial assignment checking if there exists a polynomial p(n) such that for any constraint e[\u03b4] \u2208 \u0393 we can decide in time O(p(|\u03b4|)) whether a given assignment \u03b8 to a set of variables W \u2286 V(\u03b4) is contained in an assignment that satisfies e[\u03b4], i.e. whether there exists \u00b5 \u2208 e[\u03b4] such that \u03b8 = \u00b5|W .\nAs an example, a catalogue that contains arbitrary EGC constraints (cf. Example 1) does not satisfy Definition 20, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [34]. On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 20 [35].\nIf a catalogue \u0393 satisfies Definition 20, we can for any constraint e[\u03b4] \u2208 \u0393 build arbitrary projections of it, that is, construct the global constraint pjX(e[\u03b4]) for any X \u2286 V(\u03b4), in polynomial time. In the case of Algorithm 1, where we build projections of projections, we can do so by keeping a copy of the original constraint, and projecting that each time.\nDefinition 21 (Intersection variables) Let \u3008V,C\u3009 be a CSP instance. The set of intersection variables of any constraint e[\u03b4] \u2208 P is iv(\u03b4) = \u22c3 {V(\u03b4) \u2229 V(\u03b4\u2032) | e\u2032[\u03b4\u2032] \u2208 C \u2212 {e[\u03b4]}}.\nIntersection variables are, in a sense, the only \u201cinteresting\u201d variables of a constraint, as they are the ones interacting with the rest of the problem.\nDefinition 22 (Table constraint induced by a global constraint) Let P = \u3008V,C\u3009 be a CSP instance. For every e[\u03b4] \u2208 C, let \u00b5\u2217 be the assignment to V(\u03b4)\u2212 iv(\u03b4) that assigns a special value \u2217 to every variable. The table constraint induced by e[\u03b4] is ic(e[\u03b4]) = e\u2032[\u03b4\u2032], where V(\u03b4\u2032) = V(\u03b4), and \u03b4\u2032 contains for every assignment \u03b8 \u2208 sol(pjiv(\u03b4)(P )) the assignment \u03b8 \u2295 \u00b5\u2217.\nIf every constraint in a CSP instance P = \u3008V,C\u3009 allows partial assignment checking, then building ic(e[\u03b4]) for any e[\u03b4] \u2208 C can be done in polynomial time when |sol(pjX(P ))| is itself polynomial in the size of P for every subset X of iv(\u03b4). To do so, we can invoke Algorithm 1 on the instance pjiv(\u03b4)(P ). The definition below expresses this idea.\nDefinition 23 (Sparse intersections) A class of CSP instances P has sparse intersections if there exists a constant c such that for every constraint e[\u03b4] in any instance P \u2208 P, we have that for every X \u2286 iv(\u03b4), |sol(pjX(P ))| < |P |c.\nIf a class of instances P has sparse intersections, and the instances are all over a constraint catalogue that allows partial assignment checking, then we can for every constraint e[\u03b4] of any instance from P construct ic(e[\u03b4]) in polynomial time. While this definition considers the instance as a whole, one special case of it is the case where every constraint has few solutions in the size of its description, that is, there is a constant c and the constraints are drawn from a catalogue \u0393 such that for every e[\u03b4] \u2208 \u0393 , we have that |{\u00b5 | \u00b5 \u2208 e[\u03b4]}| < |\u03b4|c.\nNote that the problem of checking whether a class of CSP instances satisfies Definition 23 for a given c is, in general, hard. To see this, consider the special case of checking whether a global constraint e[\u03b4] has any satisfying assignments at all. Letting \u03b4 be a SAT instance, that is, a propositional formula, and e an algorithm that checks whether an assignment to V(\u03b4) satisfies the formula makes this an NP-hard problem to solve.\nMore generally, consider an arbitrary problem in NP. By definition, there is a polynomial-time algorithm that can check if a proposed solution to such a problem is correct. By treating the algorithm as the constraint type e, and the problem instances as descriptions \u03b4, with a variable in V(\u03b4) for each bit of the solution, it becomes clear that every problem in NP corresponds to a class of global constraints. The fact that global constraints have this much expressive power will be explored further in Section 4.\nDespite such bad news, however, it is not always difficult to recognise constraints with polynomially many satisfying assignments. A trivial example would be table constraints. For a less trivial example, consider the constraint C\u03b2 from Example 3, where the number of satisfying assignments is bounded by a polynomial with exponent \u03b2 (cf. the discussion after Corollary 1 for a detailed analysis).\nFor a more general example, consider a family of constraints that satisfy Definition 20. To check whether the number of solutions to a constraint from such a family is bounded by |\u03b4|c for a fixed c in polynomial time, we can use Algorithm 1, stopping it if the number of partial assignments that extend to solutions exceeds the bound. Since we can check whether a partial assignment extends to a solution in polynomial time by Definition 20, we are also guaranteed an answer in polynomial time.\nArmed with these definitions, we can now state the following result.\nTheorem 5 Let P be a class of CSP instances over a catalogue that allows partial assignment checking. If P has sparse intersections, then we can in polynomial time\nreduce any instance P \u2208 P to a classic CSP instance PCL with hyp(P ) = hyp(PCL), such that PCL has a solution if and only if P does.\nProof Let P = \u3008V,C\u3009 be an instance from such a class P. For each e[\u03b4] \u2208 C, PCL will contain the table constraint ic(e[\u03b4]) from Definition 22. Since P is over a catalogue that allows partial assignment checking, and P has sparse intersections, computing ic(e[\u03b4]) can be done in polynomial time by invoking Algorithm 1 on pjiv(\u03b4)(P ).\nBy construction, hyp(P ) = hyp(PCL). All that is left to show is that PCL has a solution if and only if P does. Let \u03b8 be a solution to P = \u3008V,C\u3009. For every e[\u03b4] \u2208 C, we have that \u03b8|iv(\u03b4) \u2208 pjiv(\u03b4)(P ) by Definitions 19 and 21, and the assignment \u00b5 that assigns the value \u03b8(v) to each v \u2208\n\u22c3 e[\u03b4]\u2208C iv(\u03b4), and \u2217 to every other variable is therefore\na solution to PCL. In the other direction, if \u03b8 is a solution to PCL, then \u03b8 satisfies ic(e[\u03b4]) for every e[\u03b4] \u2208 C. By Definition 22, this means that \u03b8|iv(\u03b4) \u2208 sol(pjiv(\u03b4)(P )), and by Definition 19, there exists an assignment \u00b5e[\u03b4] with \u00b5e[\u03b4]|iv(\u03b4) = \u03b8|iv(\u03b4) that satisfies e[\u03b4]. By Definition 21, the variables not in iv(\u03b4) do not occur in any other constraint in P , so we can combine all the assignments \u00b5e[\u03b4] to form a solution \u00b5 to P such that for e[\u03b4] \u2208 C and v \u2208 V(\u03b4) we have \u00b5(v) = \u00b5e[\u03b4](v). ut\nFrom Theorem 5, we get tractable and fixed-parameter tractable classes of CSP instances with global constraints, in particular by applying Theorem 3.\nCorollary 1 Let H be a class of hypergraphs, and \u0393 a catalogue that allows partial assignment checking. If CSP(H, \u0393 ) has sparse intersections, then CSP(H, \u0393 ) is tractable or in FPT if CSP(H,Ext) is.\nProof Let H and \u0393 be given. By Theorem 5, we can reduce any P \u2208 CSP(H, \u0393 ) to an instance PCL \u2208 CSP(H,Ext) in polynomial time. Since PCL has a solution if and only if P does, tractability or fixed-parameter tractability of CSP(H,Ext) implies the same for CSP(H, \u0393 ). ut\nTo illustrate the above result, consider again the connected graph partition problem (Problem 1). This problem is NP-complete [18, p. 209], even for fixed \u03b1 \u2265 3. However, note that when \u03b2 is fixed, we can solve the problem in polynomial time, by successively guessing sets E\u2032, with |E\u2032| \u2264 \u03b2, of broken edges, and checking whether the connected components of the graph \u3008V,E \u2212E\u2032\u3009 all have \u03b1 or fewer vertices. The number of such\nsets E\u2032 is bounded by \u03b2\u2211 i=1 ( |E| i ) \u2264 (|E| + 1)\u03b2 , which is polynomial if \u03b2 is fixed. As we show below, this argument can be seen as a special case of Theorem 5. To simplify the analysis, we assume without loss of generality that \u03b1 < |V |, which means that any solution has at least one broken edge.\nWe claim that if \u03b2 is fixed, then the constraint C\u03b2 = e\u03b2 [\u03b4\u03b2 ] allows partial assignment checking, and has only a polynomial number of satisfying assignments. The latter implies that for any instance P of the CGP, |sol(pjiv(\u03b4\u03b2)(P ))| is polynomial in the size of P for every subset of iv(\u03b4\u03b2). Furthermore, we will show that for the constraint C\u03b1 = e\u03b1[\u03b4\u03b1], we also have that |sol(pjiv(\u03b4\u03b1)(P ))| is polynomial in the size of P . That C\u03b1 allows partial assignment checking can be seen by noting that each variable in V(\u03b4\u03b1) has a domain value for every vertex in the underlying graph. Therefore, given\na partial assignment to V(\u03b4\u03b1), we can check that no value is assigned more than \u03b1 times. If yes, this assignment can be extended to a full one by assigning each remaining variable a domain value not yet assigned to any variable.\nFirst, we show that the number of satisfying assignments to C\u03b2 is limited. Since C\u03b2 limits the number of ones in any solution to \u03b2, the number of satisfying assignments to this constraint is the number of ways to choose up to \u03b2 variables to be assigned\none. This is bounded by \u03b2\u2211 i=1 ( |E| i ) \u2264 (|E|+ 1)\u03b2 , and so we can generate them all in polynomial time. This argument also implies that we can perform partial assignment checking, simply by looking at the generated assignments.\nNow, let \u03b8 be such a solution. How many solutions to P contain \u03b8? Every constraint on {u, v, e} with \u03b8(e) = 1 allows at most |V |2 assignments, and there are at most \u03b2 such constraints. So far we therefore have at most (|E|+ 1)\u03b2 \u00d7 |V |2\u03b2 assignments.\nOn the other hand, a ternary constraint with \u03b8(e) = 0 requires \u03b8(u) = \u03b8(v). Consider the graph G0 containing for every constraint on {u, v, e} with \u03b8(e) = 0 the vertices u and v as well as the edge {u, v}. Since the original graph was connected, every connected component of G0 contains at least one vertex which is in the scope of some constraint with \u03b8(e) = 1. Therefore, since equality is transitive, each connected component of G0 allows at most one assignment for each of the (|E| + 1)\u03b2 \u00d7 |V |2\u03b2 assignments to the other variables of P . We therefore get a total bound of (|E|+1)\u03b2\u00d7 |V |2\u03b2 on the total number of solutions to P , and hence to pjiv(\u03b4\u03b1)(P ).\nThe hypergraph of any CSP instance P encoding the CGP has two hyperedges covering the whole problem, so the hypertree width of this hypergraph is two. Therefore, Corollary 1 and Theorem 1 apply and yield tractability for fixed \u03b2.\n3.3 Back Doors\nIf a class of CSP instances includes constraints from a catalogue that is not known to allow partial assignment checking, we may still obtain tractability in some cases by applying the notion of a back door set. A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve. Below, we are going to adapt this notion to individual constraints.\nDefinition 24 (Back door) Let \u0393 be a global constraint catalogue. A back door for a constraint e[\u03b4] \u2208 \u0393 is any set of variablesW \u2286 V(\u03b4) (called a back door set) such that we can decide in polynomial time whether a given assignment \u03b8 to a set of variables V(\u03b8) \u2287 W is contained in an assignment that satisfies e[\u03b4], i.e. whether there exists \u00b5 \u2208 e[\u03b4] such that \u00b5|V(\u03b8) = \u03b8.\nTrivially, for every constraint e[\u03b4] the set of variables V(\u03b4) is a back door set, since by Definition 4 we can always check in polynomial time if an assignment to V(\u03b4) satisfies the constraint e[\u03b4].\nThe key point about back doors is that given a catalogue \u0393 , adding to each e[\u03b4] \u2208 \u0393 with back door set W an arbitrary set of assignments to W produces a catalogue \u0393 \u2032 that allows partial assignment checking. Adding a set of assignments \u0398 means to add \u0398 to the description, and modify the algorithm e to only accept an assignment if it contains a member of \u0398 in addition to previous requirements. Furthermore, given a CSP instance P containing e[\u03b4], as long as \u0398 \u2287 \u03c0W (sol(P )), adding \u0398 to e[\u03b4] produces\nan instance that has exactly the same solutions. This point leads to the following definition.\nDefinition 25 (Sparse back door cover) Let \u0393PAC be a catalogue that allows partial assignment checking and \u0393BD a catalogue. For every instance P = \u3008V,C\u3009 over \u0393PAC \u222a \u0393BD, let P \u2229 \u0393PAC be the instance with constraint set C\u2032 = C \u2229 \u0393PAC and set of variables \u22c3 {V \u2229 V(\u03b4) | e[\u03b4] \u2208 C\u2032}.\nA class of CSP instances P over \u0393PAC \u222a \u0393BD has sparse back door cover if there exists a constant c such that for every instance P = \u3008V,C\u3009 \u2208 P and constraint e[\u03b4] \u2208 C, if e[\u03b4] 6\u2208 \u0393PAC , then there exists a back door setW for e[\u03b4], findable in time polynomial in |P |, such that |sol(pjX(P \u2229 \u0393PAC))| \u2264 |P |c for every X \u2286W .\nSparse back door cover means that for each constraint that is not from a catalogue that allows partial assignment checking, we can in polynomial time get a set of assignments \u0398 for its back door set using Algorithm 1, and so turn this constraint into one that does allow partial assignment checking. This operation preserves the solutions of the instance that contains this constraint.\nTheorem 6 If a class of CSP instance P has sparse back door cover, then we can in polynomial time reduce any instance P \u2208 P to an instance P \u2032 such that hyp(P ) = hyp(P \u2032) and sol(P ) = sol(P \u2032). Furthermore, the class of instances {P \u2032 | P \u2208 P} is over a catalogue that allows partial assignment checking.\nProof Let P = \u3008V,C\u3009 \u2208 P. We construct P \u2032 by adding to every e[\u03b4] \u2208 C such that e[\u03b4] 6\u2208 \u0393PAC , with back door setW , the set of assignments sol(pjW (P \u2229\u0393PAC)), which we can obtain using Algorithm 1. By Definition 25, we have for every X \u2286 W that |sol(pjW (P \u2229 \u0393PAC))| \u2264 |P |c, so Algorithm 1 takes polynomial time since \u0393PAC does allow partial assignment checking.\nIt is clear that hyp(P \u2032) = hyp(P ), and since sol(pjW (P \u2229 \u0393PAC)) \u2287 \u03c0W (sol(P )), the set of solutions stays the same, i.e. sol(P \u2032) = sol(P ). Finally, since we have replaced each constraint e[\u03b4] in P that was not in \u0393PAC by a constraint that does allow partial assignment checking, it follows that P \u2032 is over a catalogue that allows partial assignment checking. ut\nOne consequence of Theorem 6 is that we can sometimes apply Theorem 5 to a CSP instance that contains a constraint for which checking if a partial assignment can be extended to a satisfying one is hard. We can do so when the variables of that constraint are covered by the variables of other constraints that do allow partial assignment checking \u2014 but only if the instance given by those constraints has few solutions.\nAs a concrete example of this, consider again the encoding of the CGP that we gave in Example 3. The variables of constraint C\u03b1 are entirely covered by the instance P \u2032 obtained by removing C\u03b1. As the entire set of variables of a constraint is a back door set for it, and the instance P \u2032 has few solutions (cf. the discussion after Theorem 5), this class of instances has sparse back door cover. As such, the constraint C\u03b1 could, in fact, be arbitrary without affecting the tractability of this problem. In particular, the requirement that C\u03b1 allows partial assignment checking can be dropped."}, {"heading": "4 Subproblem Decompositions", "text": "To generalize Theorem 5, consider the fact that our definition of a global constraint allows us to view a CSP instance \u3008V,C\u3009 as a single constraint e[\u03b4], by letting \u03b4 contain the set of constraint C, and setting V(\u03b4) = V . The algorithm e then checks if an assignment satisfies all constraints. Of course, such a constraint encodes an NP-complete problem, but this is no different from e.g. the EGC constraint [34] (cf. Example 1). With this in mind, in this section we are going to investigate what happens if a CSP instance is split up into a set of smaller instances.\nSplitting up a (classic) CSP instance into smaller instances has previously been considered by Cohen and Green [10]. They use a very general framework of guarded decompositions [12] to define what they call \u201ctyped guarded decompositions\u201d. This notion allows them to obtain a tractability result for a CSP instance that can be split into smaller instances drawn from known tractable classes.\nIn this section, we are going to adapt the notions defined in Section 3.2 to work with CSP instances rather than single constraints. Then, in Section 4.1, we will show how the result of Cohen and Green can be derived as a special case of Corollary 2.\nDefinition 26 (CSP subproblem) Given two CSP instances P = \u3008V,C\u3009 and P \u2032 = \u3008V \u2032, C\u2032\u3009, we say that P \u2032 is a subproblem of P if C\u2032 \u2286 C.\nIn other words, a subproblem of a CSP instance is given by a subset of the constraints in that instance. In [10], Cohen and Green call a subproblem a component of P .\nDefinition 27 (CSP union) Let Q1 = \u3008V1, C1\u3009 and Q2 = \u3008V2, C2\u3009 be two CSP instances. The union of Q1 and Q2 is the instance Q1 tQ2 = \u3008V1 \u222a V2, C1 \u222a C2\u3009.\nDefinition 28 (Subproblem decomposition) Let P be a CSP instance. A set S of subproblems of P is a subproblem decomposition of P if \u2294 S = P .\nA subproblem decomposition of a CSP instance is proper if no element of the decomposition is a subproblem of any other.\nA subproblem decomposition of an instance P , then, is a set of subproblems that together contain all the constraints and variables of P . Note that a constraint may occur in more than one subproblem in a decomposition.\nBelow, we shall assume that all subproblem decompositions are proper. Since subproblems are given by subsets of constraints, the solutions to a CSP instance can be turned into solutions for any subproblem by projecting out the variables not part of the subproblem. Therefore, solving a subproblem P that contains another subproblem P \u2032 also solves P \u2032, making P \u2032 redundant.\nExample 5 Let P = \u3008V,C\u3009 be a CSP instance. A very simple subproblem decomposition of P would be {\u3008V(\u03b4), e[\u03b4]\u3009 | e[\u03b4] \u2208 C}, that is, every constraint of P is a separate subproblem. This subproblem decomposition is clearly proper.\nExample 6 Consider a family of CSP instances on the set of boolean variables {xi, yi, zi | 1 \u2264 i \u2264 n \u2208 {4, 6, 8, . . .}}, with the following constraints: An EGC constraint A on {x1, . . . , xn} with K(1) = 4 and K(0) = {0, . . . , n}. A second EGC constraint B, on {y1, . . . , yn, z1, . . . , zn} with K(1) = K(0) = {n}, and binary constraints on each pair {xi, yi} enforcing equality. A possible subproblem decomposition for an instance from\nthis family would be {P,Q}, where P contains A as well as the binary constraints, and Q contains the constraint B. This family is depicted in Figure 2, with P containing the constraints marked by solid lines, and Q the constraint marked by a dashed line.\nViewing subproblems as constraints and a subproblem decomposition S as a CSP instance \u3008V( \u2294 S), S\u3009, we have sol(\u3008V( \u2294 S), S\u3009) = sol( \u2294 S), since every constraint is in some subproblem. As such, we will treat S as a CSP instance when it is convenient to simplify notation.\nUsing Definition 28, we can treat any set of CSP instances S as a subproblem decomposition of the instance \u2294 S. With that in mind, whenever we say that S is a subproblem decomposition without specifying what it is a decomposition of, we mean that S is a decomposition of the CSP instance \u2294 S.\nDefinition 29 (CSP instances given by subproblem decompositions) Let F be a family of subproblem decompositions. We define CSP(F) to be the class of CSP instances { \u2294 S | S \u2208 F}.\nDefinition 30 (Hypergraph of a subproblem decomposition) Let S be a subproblem decomposition. The hypergraph of S, denoted hyp(S), has vertex set V( \u2294 S) and set of hyperedges {V(P ) | P \u2208 S}. For a family F of subproblem decompositions, let hyp(F) = {hyp(S) | S \u2208 F}.\nSince a CSP instance can be seen as a global constraint, Definition 20 (partial assignment checking) and Definition 23 (sparse intersections) carry over unchanged. To apply them to a family of subproblem decompositions F , we need only consider the catalogue \u22c3 F in both cases.\nOne way of interpreting Definition 20 for a catalogue of CSP instances is that every instance has been drawn from a tractable class \u2014 not necessarily the same one, as long as these classes all allow us to check in polynomial time whether a partial assignment extends to a solution. Most known tractable classes of CSP instances have this property; in particular, all the classes discussed in Section 2.2 have it. To see this, note that a partial assignment can be seen as a set of constraints on one variable each, and adding such hyperedges to a hypergraph does not change its tree, hypertree, or submodular width. On the other hand, tractable classes defined by restricting the allowed assignments of a constraint, rather than the hypergraph, are usually preserved by adding a constraint with only one assignment [11].\nTo illustrate how these definitions apply to subproblem decompositions, consider the following example.\nExample 7 Recall the family of subproblem decompositions in Example 6. For a decomposition S = {P,Q} from this family, the set of intersection vertices for both subproblems is {y1, . . . , yn}. Furthermore, the EGC constraint A requires that there are exactly 4 variables assigned 1 among {x1, . . . , xn}, so there are (n4) satisfying assignments for this constraint. The equality constraints ensure that this is the number of solutions to the whole subproblem P , so for every X \u2286 {y1, . . . , yn} we have that |sol(pjX(S))| \u2264 ( n 4). Therefore, this family of subproblem decompositions has sparse intersections.\nWe can now derive a straightforward generalization of Theorem 5.\nTheorem 7 Let F be a family of subproblem decompositions that allows partial assignment checking. If F has sparse intersections, then we can in polynomial time reduce any subproblem decomposition S \u2208 F to a classic CSP instance P with hyp(P ) = hyp(S), such that P has a solution if and only if S does.\nProof As subproblems can be seen as global constraints, the proof follows directly from Theorem 5. ut\nCorollary 2 Let F be a family of subproblem decompositions that allows partial assignment checking and has sparse intersections. If CSP(hyp(F),Ext) is tractable or in FPT, then so is CSP(F).\nProof Let F be given. By Theorem 7, we can reduce any subproblem decomposition S \u2208 F to an instance P \u2208 CSP(hyp(F),Ext) in polynomial time. Since P has a solution if and only if S does, tractability of CSP(hyp(F),Ext) implies the same for CSP(F). ut\nTo illustrate this result, recall Example 6. From Example 7, we know that this family of subproblem decompositions has sparse intersections. Furthermore, both subproblem allow partial assignment checking, as the EGC constraints both have interval cardinality sets [35], and the equality constraints of subproblem P can always be satisfied. Therefore, Corollary 2 applies to this problem.\n4.1 Applying Corollary 2\nWe are now ready to discuss the result of Cohen and Green mentioned at the beginning of Section 4, and to show how it can be derived as a special case of our result. First, we need to define guarded decompositions.\nDefinition 31 (Guarded decomposition) A guarded block of a hypergraph G is a pair \u3008\u03bb, \u03c7\u3009 where the guard \u03bb is a subset of the hyperedges of G, and the block, \u03c7, is a subset of \u22c3 \u03bb.\nFor every classic CSP instance P and every guarded block \u3008\u03bb, \u03c7\u3009 of hyp(P ), we define the constraint generated by P on \u3008\u03bb, \u03c7\u3009 to be the projection onto \u03c7 of the join of all the constraints of P whose scopes are in \u03bb.\nA set of of guarded blocks \u0398 of a hypergraph G is a guarded decomposition of G if for every P \u2208 CSP({G},Ext), the CSP instance over the same variables as P with constraints generated by the blocks in \u0398 has the same solutions as P .\nA guarded decomposition is acyclic if the hypergraph having the union of the blocks \u03c7 as vertices, and each \u03c7 as a hyperedge, is acyclic.\nCohen and Green then introduce a mapping \u00b5 from the constraints of a CSP instance P to nonempty sets of elements of a guarded decomposition of hyp(P ). They demand that\n1. For each guarded block \u3008\u03bb, \u03c7\u3009 and hyperedge in \u03bb, \u00b5 assigns at least one constraint with that scope to this guarded block, 2. that the set of guarded blocks \u00b5 assigns to a constraint c contains the scope of c in all the guards, and finally 3. that at least one of the guarded blocks assigned to c contains the variables of the scope of c in the block.\nNote that, taken together, the conditions above mean that the mapping \u00b5 turns each guarded block of the decomposition into a subproblem, and the whole decomposition into a subproblem decomposition, since each guarded block is assigned a set of constraints, and each constraint is assigned to a guarded block.\nFurthermore, they introduce two more notions. A type is a polynomial-time algorithm for solving a set of CSP instances. A typed guarded decomposition is one where each guarded block \u03b2 is assigned a type, and the CSP instance given by the set of constraints assigned to \u03b2 is a member of the assigned type. This is almost Definition 20, however, there is no provision for solving a problem with some variables assigned.\nFinally, a guarded decomposition \u0398 is k-separated if for every guarded block \u3008\u03bb, \u03c7\u3009 there exists a set of hyperedges , with | | \u2264 k, such that for each guarded block \u3008\u03bb2, \u03c72\u3009 \u2208 \u0398 \u2212 {\u03bb, \u03c7} we have that \u03c7 \u2229 \u03c72 \u2286 \u22c3 . Observe that when k is fixed, the intersection variables of each subproblem are covered by a fixed number of table constraints, and hence that the number of possible solutions is bounded by the size of the join of these constraints. It follows that the intersections are sparse as per Definition 23.\nThey then proceed to show that for fixed k, a CSP instance with a k-separated, acyclic typed guarded decomposition can be solved in polynomial time, under the condition that the types can handle problems with some variables assigned specific values.\nThe last condition is precisely what we need for partial assignment checking. Therefore, since the decomposition is required to be acyclic, their result satisfies the conditions of Corollary 2. Note, however, that since there are other ways to obtain sparse intersections, Corollary 2 is a more general result even for classic CSP instances."}, {"heading": "5 Weighted CSP", "text": "Having few solutions in key parts of a CSP instance has turned out to be a property we can exploit to obtain tractability. In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost. This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint. The reason for considering weighted, rather than valued, CSP, is that weighted (table) constraints list every satisfying assignment along with the costs, while a valued constraint is given by a function from assignments to values. The representation of a valued constraint is thus much more compact, and the notion of a satisfying assignment is no longer defined.\nDefinition 32 (Weighted constraint) A weighted global constraint e[\u03b4] is a global constraint that assigns to each \u03b8 \u2208 e[\u03b4] a value cost(e[\u03b4], \u03b8) from Q.\nThe size of a weighted global constraint e[\u03b4] is given by the sum of |\u03b4| and the size of the bit representation for each cost.\nIn other words, the number of bits needed to represent the costs of all the satisfying assignments is part of a weighted constraint\u2019s size.\nDefinition 33 (WCSP instance) A WCSP instance is a pair P = \u3008V,C\u3009, where V is a set of variables and C a set of weighted constraints. An assignment is a solution to P if it satisfies every constraint in C, and we denote the set of all solutions to P by sol(P ).\nFor every solution \u03b8 to P we define cost(P, \u03b8) = \u2211 e[\u03b4]\u2208C cost(e[\u03b4], \u03b8|V(\u03b4)). An assignment \u03b8 is an optimal solution to P if and only if it is a solution to P with the smallest cost, i.e. cost(P, \u03b8) = min({cost(P, \u03b8\u2032) | \u03b8\u2032 \u2208 sol(P )}).\nAs is commonly done with optimization problems in complexity theory, below we consider the decision problem associated with WCSP instances.\nDefinition 34 (WCSP decision problem) Given a WCSP instance P and k \u2208 Q, theWCSP decision problem is to decide whether P has a solution \u03b8 with cost(P, \u03b8) \u2264 k.\nAs for CSP instances, a classic WCSP instance is one where all constraints are table global constraints. As an example of known tractability results for classic WCSP instances, consider the theorem below.\nTheorem 8 ([22]) Let H be a class of hypergraphs. If ghw(H) < \u221e, then a class of classic WCSP instances whose hypergraphs are in H is tractable.\nSince we are free to ignore the costs a weighted constraint puts on assignments and treat it as an \u201cordinary\u201d constraint, definitions of subproblems and subproblem decompositions carry over unchanged. Note that since the WCSP decision problem is clearly in NP, we can view a WCSP instance as a weighted global constraint. Therefore, Definition 20 will now be subtly different.\nDefinition 35 (Weighted part. assignment checking) A weighted constraint catalogue \u0393 allows partial assignment checking if for any weighted constraint e[\u03b4] \u2208 \u0393 we can decide in polynomial time, given an assignment \u03b8 to a set of variables W \u2286 V(\u03b4) and k \u2208 Q, whether \u03b8 is contained in an assignment that satisfies e[\u03b4] and has cost at most k, i.e. whether there exists \u00b5 \u2208 e[\u03b4] such that \u03b8 = \u00b5|W and cost(e[\u03b4], \u00b5) \u2264 k.\nIn other words, given a partial assignment we need to be able to solve the WCSP decision problem for our constraint in polynomial time. Note also that doing so allows us to find the minimum cost among the assignments that contain our partial assignment by binary search. This will be needed in order to construct projections of a weighted global constraint. To define the projection of a weighted constraint, we need to alter Definition 19 to take costs into account.\nDefinition 36 (Weighted constraint projection) Let e[\u03b4] be a weighted constraint. The projection of e[\u03b4] onto a set of variables X \u2286 V(\u03b4) is the constraint pjX(e[\u03b4]) such that \u00b5 \u2208 pjX(e[\u03b4]) if and only if there exists \u03b8 \u2208 e[\u03b4] with \u03b8|X = \u00b5. The cost of an assignment \u03b8 \u2208 pjX(e[\u03b4]) is cost(pjX(e[\u03b4]), \u03b8) = min({cost(e[\u03b4], \u00b5) | \u00b5 \u2208 e[\u03b4] and \u00b5|X = \u03b8}).\nFor a WCSP instance P = \u3008V,C\u3009 and X \u2286 V we define pjX(P ) = \u3008X,C\u2032\u3009, where C\u2032 is the least set containing for every e[\u03b4] \u2208 C such that X \u2229 V(\u03b4) 6= \u2205 the constraint pjX\u2229V(\u03b4)(e[\u03b4]).\nDefinition 37 (Weighted table constraint induced by a subproblem) Let S be a subproblem decomposition. For every T \u2208 S, let \u00b5\u2217 be the assignment to V(T )\u2212iv(T ) that assigns a special value \u2217 to every variable. The weighted table constraint induced by T is ic(T ) = e[\u03b4], where V(\u03b4) = V(T ), and \u03b4 contains for every assignment \u03b8 \u2208 sol(pjiv(T )(S)) the assignment \u03b8 \u2295 \u00b5\u2217 with cost(ic(T ), \u03b8 \u2295 \u00b5\u2217) = cost(pjiv(T )(T ), \u03b8).\nSince the variables of a subproblem T \u2208 S not in iv(T ) occur only in T itself, if we have a solution to pjiv(T )(S), it doesn\u2019t matter what solution to T we extend it to. We should therefore pick the one that has the smallest cost, and that cost is precisely cost(pjiv(T )(T ), \u03b8) by Definition 36. The same as for CSP instances, if every subproblem in a weighted decomposition S allows weighted partial assignment checking, building ic(T ) for any T \u2208 S can be done in polynomial time when |sol(pjiv(T )(S))| is polynomial in the size of \u2294 S for every subset of iv(T ), again by using Algorithm 1. Since the definition of sparse intersections (Definition 23) carries over unchanged, we are ready to prove the following analogue of Theorem 5 for weighted subproblem decompositions.\nTheorem 9 Let F be a family of weighted subproblem decompositions that allows partial assignment checking. If F has sparse intersections, then we can in polynomial time reduce any weighted subproblem decomposition S \u2208 F to a classic weighted CSP instance P with hyp(P ) = hyp(S), such that P has a solution with cost at most k \u2208 Q if and only if S does.\nProof Let S be a subproblem decomposition from F . For each T \u2208 S, P will contain the table constraint ic(T ) from Definition 22. Since F allows partial assignment checking and has sparse intersections, computing ic(T ) can be done in polynomial time by invoking Algorithm 1 on pjiv(T )(S).\nIt is clear that hyp(P ) = hyp(S). All that is left to show is that P has a solution with cost at most k \u2208 N if and only if S does. Let \u03b8 be a solution to S. For every T \u2208 S, \u03b8|iv(T ) \u2208 pjiv(T )(S) by Definitions 21 and 36, so the assignment \u00b5 that assigns\nthe value \u03b8(v) to each v \u2208 \u22c3 T\u2208S iv(T ), and \u2217 to every other variable is a solution to P . Furthermore, for every T \u2208 S we have by Definition 37 that cost(ic(T ), \u00b5|V(T )) = cost(pjiv(T )(T ), \u00b5|iv(T )), so by Definition 36 cost(ic(T ), \u00b5|V(T )) \u2264 cost(T, \u03b8|V(T )) and therefore cost(P, \u00b5) \u2264 cost(S, \u03b8).\nIn the other direction, if \u03b8 is a solution to P , then \u03b8 satisfies ic(T ) for every T \u2208 S. By Definition 37, this means that \u03b8|iv(T ) \u2208 sol(pjiv(T )(S)), and by Definition 36, there exists an assignment \u00b5T with \u00b5T |iv(T ) = \u03b8|iv(T ) that satisfies T , such that cost(ic(T ), \u03b8|V(T )) = cost(T, \u00b5T ). By Definition 21, the variables not in iv(T ) do not occur in any other subproblem from S, so we can combine all the assignments \u00b5T to form a solution \u00b5 to S such that for T \u2208 S and v \u2208 V(T ) we have \u00b5(v) = \u00b5T (v), with cost(P, \u03b8) = cost(S, \u00b5). ut\nAs before, for a family of weighted subproblem decompositions F we defineWCSP(F) = { \u2294 S | S \u2208 F}, and for a class of hypergraphs H we let WCSP(H,Ext) be the class of classic WCSP instances whose hypergraphs are in H. With that in mind, we can use Theorem 9 to obtain new tractable and fixed-parameter tractable classes of weighted CSP instances with global constraints.\nCorollary 3 Let F be a family of weighted subproblem decompositions that allows partial assignment checking and has sparse intersections. If WCSP(hyp(F),Ext) is tractable or in FPT, then so is WCSP(F).\nProof Let F be given. By Theorem 9, we can reduce any weighted subproblem decomposition S \u2208 F to an instance P \u2208 WCSP(hyp(F),Ext) in polynomial time. Since P has a solution with cost k if and only if S does, tractability of WCSP(hyp(F),Ext) implies the same for WCSP(F). ut"}, {"heading": "6 Summary", "text": "We have studied the tractability of CSPs with global constraints under various structural restrictions such as tree and hypertree width. By exploiting the number of solutions to CSP instances in key places, we have identified new tractable classes of such problems, both in the ordinary and weighted case.\nFurthermore, we have shown how this technique can be used to combine CSP instances drawn from known tractable classes, extending a previous result by Cohen and Green [10]. We have also shown how the existence of back doors in CSP instances can be used to augment our results.\nMore work remains to be done on this topic. In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32]. Also of interest is the complexity of checking whether a constraint has few solutions, which ties into finding classes of CSP instances that satisfy Definition 23.\nAcknowledgements This work has been supported by the Research Council of Norway through the project DOIL (RCN project #213115). The author thanks the anonymous reviewers for their detailed feedback."}], "references": [{"title": "Width functions for hypertree decompositions", "author": ["I. Adler"], "venue": "Doctoral dissertation, AlbertLudwigs-Universit\u00e4t Freiburg", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2006}, {"title": "Hypertree width and related hypergraph invariants", "author": ["I. Adler", "G. Gottlob", "M. Grohe"], "venue": "European Journal of Combinatorics 28(8), 2167\u20132181", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Optimization methods for the partner units problem", "author": ["M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen"], "venue": "Proceedings of the 8th International Conference on Integration of Artificial Intelligence and Operations Research Techniques in Constraint Programming for Combinatorial Optimization Problems (CPAIOR\u201911), Lecture Notes in Computer Science, vol. 6697, pp. 4\u201319. Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Structural decomposition methods and what they are good for", "author": ["M. Aschinger", "C. Drescher", "G. Gottlob", "P. Jeavons", "E. Thorstensen"], "venue": "T. Schwentick, C. D\u00fcrr (eds.) Proceedings of the 28th International Symposium on Theoretical Aspects of Computer Science (STACS\u201911), Leibniz International Proceedings in Informatics, vol. 9, pp. 12\u2013 28", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Size bounds and query plans for relational joins", "author": ["A. Atserias", "M. Grohe", "D. Marx"], "venue": "SIAM J. Comput. 42(4), 1737\u20131767", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "The complexity of reasoning with global constraints", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "T. Walsh"], "venue": "Constraints 12(2), 239\u2013259", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2007}, {"title": "Decomposition of the NValue constraint", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "C.G. Quimper", "T. Walsh"], "venue": "Proceedings of the 16th International Conference on Principles and Practice of Constraint Programming (CP\u201910), Lecture Notes in Computer Science, vol. 6308. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2010}, {"title": "Classifying the complexity of constraints using finite algebras", "author": ["A. Bulatov", "P. Jeavons", "A. Krokhin"], "venue": "SIAM Journal on Computing 34(3), 720\u2013742", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Constraint satisfaction with succinctly specified relations", "author": ["H. Chen", "M. Grohe"], "venue": "Journal of Computer and System Sciences 76(8), 847\u2013860", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Typed guarded decompositions for constraint satisfaction", "author": ["D. Cohen", "M. Green"], "venue": "F. Benhamou (ed.) Proceedings of the 12th International Conference on the Principles and Practice of Constraint Programming (CP\u201906), Lecture Notes in Computer Science, vol. 4204, pp. 122\u2013136. Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "The complexity of constraint languages", "author": ["D. Cohen", "P. Jeavons"], "venue": "F. Rossi, P. van Beek, T. Walsh (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 245 \u2013 280. Elsevier", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "A unified theory of structural tractability for constraint satisfaction problems", "author": ["D. Cohen", "P. Jeavons", "M. Gyssens"], "venue": "Journal of Computer and System Sciences 74(5), 721\u2013743", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2008}, {"title": "Constraint representations and structural tractability", "author": ["D.A. Cohen", "M.J. Green", "C. Houghton"], "venue": "Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming (CP\u201909), Lecture Notes in Computer Science, vol. 5732, pp. 289\u2013303. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Tractable combinations of global constraints", "author": ["D.A. Cohen", "P.G. Jeavons", "E. Thorstensen", "S. \u017divn\u00fd"], "venue": "C. Schulte (ed.) Proceedings of the 19th International Conference on Principles and Practice of Constraint Programming (CP\u201913), Lecture Notes in Computer Science, vol. 8124, pp. 230\u2013246. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2013}, {"title": "Constraint satisfaction, bounded treewidth, and finite-variable logics", "author": ["V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi"], "venue": "Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming (CP\u201902), Lecture Notes in Computer Science, vol. 2470, pp. 223\u2013254. Springer", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2002}, {"title": "Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Monographs in Computer Science. Springer", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1999}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Texts in Theoretical Computer Science. Springer", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": "W. H. Freeman", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1979}, {"title": "Backdoors to satisfaction", "author": ["S. Gaspers", "S. Szeider"], "venue": "H.L. Bodlaender, R. Downey, F.V. Fomin, D. Marx (eds.) The Multivariate Algorithmic Revolution and Beyond, Lecture Notes in Computer Science, vol. 7370, pp. 287\u2013317. Springer", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "MINION: A fast, scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "Proceedings of the 17th European Conference on Artificial Intelligence (ECAI\u201906), pp. 98\u2013102. IOS Press", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "Exploiting Tree Decomposition and Soft Local Consistency in Weighted CSP", "author": ["S. de Givry", "T. Schiex", "G. Verfaillie"], "venue": "Proceedings of the 21st National Conference on Artificial Intelligence (AAAI\u201906), pp. 22\u201327", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2006}, {"title": "Tractable optimization problems through hypergraph-based structural restrictions", "author": ["G. Gottlob", "G. Greco", "F. Scarcello"], "venue": "S. Albers, A. Marchetti-Spaccamela, Y. Matias, S. Nikoletseas, W. Thomas (eds.) Proceedings of the 36th International Colloquium on Automata\u201a Languages and Programming (ICALP\u201909), Lecture Notes in Computer Science, vol. 5556, pp. 16\u201330. Springer", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "A comparison of structural CSP decomposition methods", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Artificial Intelligence 124(2), 243\u2013282", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2000}, {"title": "Hypertree decompositions and tractable queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences 64(3), 579\u2013627", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2002}, {"title": "Structural tractability of propagated constraints", "author": ["M.J. Green", "C. Jefferson"], "venue": "Proceedings of the 14th International Conference on Principles and Practice of Constraint Programming (CP\u201908), Lecture Notes in Computer Science, vol. 5202, pp. 372\u2013386. Springer", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2008}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM 54(1), 1\u201324", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2007}, {"title": "Constraint solving via fractional edge covers", "author": ["M. Grohe", "D. Marx"], "venue": "Proceedings of the 17th ACM-SIAM symposium on discrete algorithms (SODA\u201906), pp. 289\u2013298. ACM", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2006}, {"title": "Bin repacking scheduling in virtualized datacenters", "author": ["F. Hermenier", "S. Demassey", "X. Lorca"], "venue": "J. Lee (ed.) Proceedings of the 17th International Conference on Principles and Practice ofConstraint Programming (CP\u201911), Lecture Notes in Computer Science, vol. 6876, pp. 27\u201341. Springer", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2011}, {"title": "Global constraints", "author": ["W.J. van Hoeve", "I. Katriel"], "venue": "F. Rossi, P. van Beek, T. Walsh (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 169\u2013208. Elsevier", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2006}, {"title": "Simultaneous matchings: Hardness and approximation", "author": ["M. Kutz", "K. Elbassioni", "I. Katriel", "M. Mahajan"], "venue": "Journal of Computer and System Sciences 74(5), 884\u2013897", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2008}, {"title": "Approximating fractional hypertree width", "author": ["D. Marx"], "venue": "ACM Transactions on Algorithms 6(2), 29:1\u201329:17", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2010}, {"title": "Can you beat treewidth", "author": ["D. Marx"], "venue": "Theory of Computing", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2010}, {"title": "Tractable hypergraph properties for constraint satisfaction and conjunctive queries", "author": ["D. Marx"], "venue": "J. ACM 60(6), 42", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2013}, {"title": "Improved algorithms for the global cardinality constraint", "author": ["C.G. Quimper", "A. L\u00f3pez-Ortiz", "P. van Beek", "A. Golynski"], "venue": "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP\u201904), Lecture Notes in Computer Science, vol. 3258, pp. 542\u2013556. Springer", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2004}, {"title": "Generalized Arc Consistency for Global Cardinality Constraint", "author": ["J.C. R\u00e9gin"], "venue": "Proceedings of the 13th National Conference on Artificial Intelligence (AAAI\u201996), pp. 209\u2013215. AAAI Press", "citeRegEx": "35", "shortCiteRegEx": null, "year": 1996}, {"title": "The Handbook of Constraint Programming", "author": ["F. Rossi", "P. van Beek", "Walsh", "T. (eds."], "venue": "Elsevier", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2006}, {"title": "Tractable cases of the extended global cardinality constraint", "author": ["M. Samer", "S. Szeider"], "venue": "Constraints 16(1), 1\u201324", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2011}, {"title": "Valued Constraint Satisfaction Problems: Hard and Easy Problems", "author": ["T. Schiex", "H. Fargier", "G. Verfaillie"], "venue": "C. Mellish (ed.) Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI\u201995), pp. 631\u2013639", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1995}, {"title": "Practical applications of constraint programming", "author": ["M. Wallace"], "venue": "Constraints 1, 139\u2013168", "citeRegEx": "39", "shortCiteRegEx": null, "year": 1996}, {"title": "ECLiPSe: A platform for constraint logic programming", "author": ["M. Wallace", "S. Novello", "J. Schimpf"], "venue": "ICL Systems Journal 12(1), 137\u2013158", "citeRegEx": "40", "shortCiteRegEx": null, "year": 1997}, {"title": "Backdoors to typical case complexity", "author": ["R. Williams", "C.P. Gomes", "B. Selman"], "venue": "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI\u201903), pp. 1173\u20131178", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2003}, {"title": "The complexity and expressive power of valued constraints", "author": ["S. \u017divn\u00fd"], "venue": "Doctoral dissertation, University of Oxford", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 28, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].", "startOffset": 116, "endOffset": 123}, {"referenceID": 38, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].", "startOffset": 116, "endOffset": 123}, {"referenceID": 2, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].", "startOffset": 154, "endOffset": 160}, {"referenceID": 27, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].", "startOffset": 154, "endOffset": 160}, {"referenceID": 19, "context": "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].", "startOffset": 126, "endOffset": 136}, {"referenceID": 35, "context": "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].", "startOffset": 126, "endOffset": 136}, {"referenceID": 39, "context": "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].", "startOffset": 126, "endOffset": 136}, {"referenceID": 3, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 7, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 11, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 22, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 25, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 32, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].", "startOffset": 287, "endOffset": 304}, {"referenceID": 23, "context": "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].", "startOffset": 188, "endOffset": 198}, {"referenceID": 26, "context": "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].", "startOffset": 188, "endOffset": 198}, {"referenceID": 32, "context": "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].", "startOffset": 188, "endOffset": 198}, {"referenceID": 29, "context": "This is the case even when the global constraints are fairly simple, such as overlapping difference constraints with acyclic hypergraphs [30].", "startOffset": 137, "endOffset": 141}, {"referenceID": 5, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37].", "startOffset": 121, "endOffset": 127}, {"referenceID": 36, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37].", "startOffset": 121, "endOffset": 127}, {"referenceID": 6, "context": "Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [7].", "startOffset": 149, "endOffset": 152}, {"referenceID": 8, "context": "As discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity.", "startOffset": 16, "endOffset": 19}, {"referenceID": 24, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 118, "endOffset": 122}, {"referenceID": 12, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 145, "endOffset": 149}, {"referenceID": 8, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 177, "endOffset": 180}, {"referenceID": 13, "context": "In contrast, we will use a definition of global constraints, used also in [14], that allows us to discuss different representations in a uniform manner.", "startOffset": 74, "endOffset": 78}, {"referenceID": 9, "context": "The results that we obtain on this topic extend previous research by Cohen and Green [10].", "startOffset": 85, "endOffset": 89}, {"referenceID": 20, "context": "Finally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution.", "startOffset": 65, "endOffset": 72}, {"referenceID": 21, "context": "Finally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution.", "startOffset": 65, "endOffset": 72}, {"referenceID": 28, "context": "For example, in [29] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.", "startOffset": 16, "endOffset": 20}, {"referenceID": 5, "context": "Below, we offer a precise definition similar to the one in [6], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time.", "startOffset": 59, "endOffset": 62}, {"referenceID": 36, "context": "Example 1 (EGC) A very general global constraint type is the extended global cardinality constraint type [37].", "startOffset": 105, "endOffset": 109}, {"referenceID": 0, "context": "To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].", "startOffset": 114, "endOffset": 117}, {"referenceID": 26, "context": "Next, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [27].", "startOffset": 114, "endOffset": 118}, {"referenceID": 0, "context": "A fractional edge cover for X is a function \u03b3 : H \u2192 [0, 1] such that \u2211", "startOffset": 52, "endOffset": 58}, {"referenceID": 26, "context": "It is known that this minimum is always rational [27].", "startOffset": 49, "endOffset": 53}, {"referenceID": 1, "context": "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 26}, {"referenceID": 14, "context": "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 26}, {"referenceID": 23, "context": "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 26}, {"referenceID": 26, "context": "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 26}, {"referenceID": 30, "context": "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 26}, {"referenceID": 32, "context": "To go beyond fractional hypertree width, Marx [33] recently introduced the concept of submodular width.", "startOffset": 46, "endOffset": 50}, {"referenceID": 15, "context": "However, this class is what is called fixed-parameter tractable [16,17].", "startOffset": 64, "endOffset": 71}, {"referenceID": 16, "context": "However, this class is what is called fixed-parameter tractable [16,17].", "startOffset": 64, "endOffset": 71}, {"referenceID": 32, "context": "Theorem 2 ([33]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 15}, {"referenceID": 26, "context": "The three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 ghw(G) \u2264 tw(G).", "startOffset": 79, "endOffset": 87}, {"referenceID": 32, "context": "The three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 ghw(G) \u2264 tw(G).", "startOffset": 79, "endOffset": 87}, {"referenceID": 17, "context": "Example 4 The NP-complete problem of 3-colourability [18] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.", "startOffset": 53, "endOffset": 57}, {"referenceID": 26, "context": "To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [27] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance.", "startOffset": 103, "endOffset": 107}, {"referenceID": 26, "context": "Lemma 2 ([27]) A classic CSP instance P has at most |P | \u2217(hyp(P )) solutions.", "startOffset": 9, "endOffset": 13}, {"referenceID": 4, "context": "This result has since been shown to be optimal \u2014 a classic CSP instance has polynomially many solutions in its size if and only if it has bounded fractional edge cover number [5].", "startOffset": 175, "endOffset": 178}, {"referenceID": 33, "context": "Example 1) does not satisfy Definition 20, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [34].", "startOffset": 133, "endOffset": 137}, {"referenceID": 34, "context": "On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 20 [35].", "startOffset": 130, "endOffset": 134}, {"referenceID": 18, "context": "A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.", "startOffset": 25, "endOffset": 32}, {"referenceID": 40, "context": "A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.", "startOffset": 25, "endOffset": 32}, {"referenceID": 33, "context": "the EGC constraint [34] (cf.", "startOffset": 19, "endOffset": 23}, {"referenceID": 9, "context": "Splitting up a (classic) CSP instance into smaller instances has previously been considered by Cohen and Green [10].", "startOffset": 111, "endOffset": 115}, {"referenceID": 11, "context": "They use a very general framework of guarded decompositions [12] to define what they call \u201ctyped guarded decompositions\u201d.", "startOffset": 60, "endOffset": 64}, {"referenceID": 9, "context": "In [10], Cohen and Green call a subproblem a component of P .", "startOffset": 3, "endOffset": 7}, {"referenceID": 10, "context": "On the other hand, tractable classes defined by restricting the allowed assignments of a constraint, rather than the hypergraph, are usually preserved by adding a constraint with only one assignment [11].", "startOffset": 199, "endOffset": 203}, {"referenceID": 34, "context": "Furthermore, both subproblem allow partial assignment checking, as the EGC constraints both have interval cardinality sets [35], and the equality constraints of subproblem P can always be satisfied.", "startOffset": 123, "endOffset": 127}, {"referenceID": 20, "context": "In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost.", "startOffset": 120, "endOffset": 127}, {"referenceID": 21, "context": "In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost.", "startOffset": 120, "endOffset": 127}, {"referenceID": 37, "context": "This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint.", "startOffset": 83, "endOffset": 90}, {"referenceID": 41, "context": "This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint.", "startOffset": 83, "endOffset": 90}, {"referenceID": 21, "context": "Theorem 8 ([22]) Let H be a class of hypergraphs.", "startOffset": 11, "endOffset": 15}, {"referenceID": 9, "context": "Furthermore, we have shown how this technique can be used to combine CSP instances drawn from known tractable classes, extending a previous result by Cohen and Green [10].", "startOffset": 166, "endOffset": 170}, {"referenceID": 8, "context": "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].", "startOffset": 211, "endOffset": 220}, {"referenceID": 25, "context": "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].", "startOffset": 211, "endOffset": 220}, {"referenceID": 31, "context": "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].", "startOffset": 211, "endOffset": 220}], "year": 2015, "abstractText": "A wide range of problems can be modelled as constraint satisfaction problems (CSPs), that is, a set of constraints that must be satisfied simultaneously. Constraints can either be represented extensionally, by explicitly listing allowed combinations of values, or implicitly, by special-purpose algorithms provided by a solver. Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances have been shown to yield tractable classes of CSPs. However, most such restrictions fail to guarantee tractability for CSPs with global constraints. We therefore study the applicability of structural restrictions to instances with such constraints. We show that when the number of solutions to a CSP instance is bounded in key parts of the problem, structural restrictions can be used to derive new tractable classes. Furthermore, we show that this result extends to combinations of instances drawn from known tractable classes, as well as to CSP instances where constraints assign costs to satisfying assignments.", "creator": "LaTeX with hyperref package"}}}