{"id": "1502.04148", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Feb-2015", "title": "A Pseudo-Euclidean Iteration for Optimal Recovery in Noisy ICA", "abstract": "independent component analysis ( ica ) is a popular model for blind signal separation. the ica kernel assumes that a bundle of independent periodic signals are linearly mixed to manage the observed signal. traditional ica algorithms largely aim to recover the mixing frequencies, the inverse of which can be applied to noise in order to recover the latent independent signals. theoretically, in the presence of noise, this demixing process is non - optimal for signal assessment as termed by signal - to - interference - plus - noise ratio ( sinr ), even if the mixing rate is recovered exactly.", "histories": [["v1", "Fri, 13 Feb 2015 23:18:35 GMT  (80kb,D)", "https://arxiv.org/abs/1502.04148v1", "18 pages, 3 figures"], ["v2", "Thu, 1 Oct 2015 16:05:56 GMT  (54kb,D)", "http://arxiv.org/abs/1502.04148v2", "17 pages, 2 figures"]], "COMMENTS": "18 pages, 3 figures", "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["james r voss", "mikhail belkin", "luis rademacher"], "accepted": true, "id": "1502.04148"}, "pdf": {"name": "1502.04148.pdf", "metadata": {"source": "CRF", "title": "A Pseudo-Euclidean Iteration for Optimal Recovery in Noisy ICA", "authors": ["James Voss", "Mikhail Belkin", "Luis Rademacher"], "emails": ["vossj@cse.ohio-state.edu", "mbelkin@cse.ohio-state.edu", "lrademac@cse.ohio-state.edu"], "sections": [{"heading": null, "text": "Our second contribution is combining PEGI with the analysis of objectives for optimal recovery in the noisy ICA model. It has been observed that the direct approach of demixing with the inverse of the mixing matrix is suboptimal for signal recovery in terms of the natural Signal to Interference plus Noise Ratio (SINR) criterion. There have been several partial solutions proposed in the ICA literature. It turns out that any solution to the mixing matrix reconstruction problem can be used to construct an SINR-optimal ICA demixing, despite the fact that SINR itself cannot be computed from data. That allows us to obtain a practical and provably SINR-optimal recovery method for ICA with arbitrary Gaussian noise."}, {"heading": "1 Introduction", "text": "Independent Component Analysis refers to a class of methods aiming at recovering statistically independent signals by observing their unknown linear combination. There is an extensive literature on this and a number of related problems [7].\nSpecifically, in the ICA model, we observe n-dimensional realizations x(1), . . . ,x(N) of a latent variable model X = \u2211m k=1 SkAk = AS where Ak denotes the k\nth column of the n \u00d7 m mixing matrix A and S = (S1, . . . , Sm)\nT is the unseen latent random vector of \u201csignals\u201d. It is assumed that S1, . . . , Sm are independent and non-Gaussian. The source signals and entries of A may be either real- or complex-valued. For simplicity, we will assume throughout that S has zero mean, as this may be achieved in practice by centering the observed data.\nMany ICA algorithms use the preprocessing \u201cwhitening\u201d step whose goal is to orthogonalize the independent components. In the noiseless, case this is commonly done by computing the square root of the covariance matrix of X. Consider now the noisy ICA model X = AS+\u03b7 with additive 0- mean noise \u03b7 independent of S. It turns out that the introduction of noise makes accurate recovery of the signals significantly more involved. Specifically, whitening using the covariance matrix does not work in the noisy ICA model as the covariance matrix combines both signal and noise. For\n\u2217Department of Computer Science and Engineering, the Ohio State University\nar X\niv :1\n50 2.\n04 14\n8v 2\n[ cs\n.L G\n] 1\nO ct\n2 01\nthe case when the noise is Gaussian, matrices constructed from higher order statistics (specifically, cumulants) can be used instead of the covariance matrix. However, these matrices are not in general positive definite and thus the square root cannot always be extracted. This limits the applicability of several previous methods, such as [2, 9, 1]. The GI-ICA algorithm proposed in [21] addresses this issue by using a complicated quasi-orthogonalization step followed by an iterative method.\nIn this paper (section 2), we develop a simple and practical one-step algorithm, PEGI (for pseudo-Euclidean Gradient Iteration) for provably recovering A (up to the unavoidable ambiguities of the model) in the case when the noise is Gaussian (with an arbitrary, unknown covariance matrix). The main technical innovation of our approach is to formulate the recovery problem as a fixed point method in an indefinite \u201cinner product\u201d (pseudo-Euclidean) space.\nThe second contribution of the paper is combining PEGI with the analysis of objectives for optimal recovery in the noisy ICA model. In most applications of ICA (e.g., speech separation [18], MEG/EEG artifact removal [20] and others) one cares about recovering the signals s(1), . . . , s(N). This is known as the source recovery problem. This is typically done by first recovering the matrix A (up to an appropriate scaling of the column directions).\nAt first, source recovery and recovering the mixing matrix A appear to be essentially equivalent. In the noiseless ICA model, if A in invertible1 then s(t) = A\u22121x(t) recovers the sources. On the other hand, in the noisy model, the exact recovery of the latent sources s(t) becomes impossible even if A is known exactly. Part of the \u201cnoise\u201d can be incorporated into the \u201csignal\u201d preserving the form of the model. Even worse, neither A nor S are defined uniquely as there is an inherent ambiguity in the setting. There could be many equivalent decompositions of the observed signal as X = A\u2032S\u2032 + \u03b7\u2032 (see the discussion in section 3).\nWe consider recovered signals of the form S\u0302(B) := BX for a choice of m\u00d7n demixing matrix B. Signal recovery is considered optimal if the coordinates of S\u0302(B) = (S\u03021(B), . . . , S\u0302m(B)) maximize Signal to Interference plus Noise Ratio (SINR) within any fixed model X = AS + \u03b7. Note that the value of SINR depends on the decomposition of the observed data into \u201cnoise\u201d and \u201csignal\u201d: X = A\u2032S\u2032 + \u03b7\u2032.\nSurprisingly, the SINR optimal demixing matrix does not depend on the decomposition of data into signal plus noise. As such, SINR optimal ICA recovery is well defined given access to data despite the inherent ambiguity in the model. Further, it will be seen that the SINR optimal demixing can be constructed from cov(X) and the directions of the columns of A (which are also well-defined across signal/noise decompositions).\nOur SINR-optimal demixing approach combined with the PEGI algorithm provides a complete SINR-optimal recovery algorithm in the ICA model with arbitrary Gaussian noise. We note that the ICA papers of which we are aware that discuss optimal demixing do not observe that SINR optimal demixing is invariant to the choice of signal/noise decomposition. Instead, they propose more limited strategies for improving the demixing quality within a fixed ICA model. For instance, Joho et al. [14] show how SINR-optimal demixing can be approximated with extra sensors when assuming a white additive noise, and Koldovsky\u0300 and Tichavsky\u0300 [16] discuss how to achieve asymptotically low bias ICA demixing assuming white noise within a fixed ICA model. However, the invariance of the SINR-optimal demixing matrix appears in the array sensor systems literature [6].\nFinally, in section 4, we demonstrate experimentally that our proposed algorithm for ICA outperforms existing practical algorithms at the task of noisy signal recovery, including those specifically designed for beamforming, when given sufficiently many samples. Moreover, most existing practical algorithms for noisy source recovery have a bias and cannot recover the optimal demixing matrix even with infinite samples. We also show that PEGI requires significantly fewer samples\n1A\u22121 can be replaced with A\u2020 in the discussion below for over-determined ICA.\nthan GI-ICA [21] to perform ICA accurately."}, {"heading": "1.1 The Indeterminacies of ICA", "text": "Notation: We use M\u2217 to denote the entry-wise complex conjugate of a matrix M , MT to denote its transpose, and MH to denote its conjugate transpose.\nBefore proceeding with our results, we discuss the somewhat subtle issue of indeterminacies in ICA. These ambiguities arise from the fact that the observed X may have multiple decompositions into ICA models X = AS + \u03b7 and X = A\u2032S\u2032 + \u03b7\u2032.\nNoise-free ICA has two natural indeterminacies. For any nonzero constant \u03b1, the contribution of the kth component AkSk to the model can equivalently be obtained by replacing Ak with \u03b1Ak and Sk with the rescaled signal 1 \u03b1Sk. To lessen this scaling indeterminacy, we use the convention\n2 that cov(S) = I throughout this paper. As such, each source Sk (or equivalently each Ak) is defined up to a choice of sign (a unit modulus factor in the complex case). In addition, there is an ambiguity in the order of the latent signals. For any permutation \u03c0 of [m] (where [m] := {1, . . . ,m}), the ICA models X = \u2211m k=1 SkAk and X = \u2211m k=1 S\u03c0(k)A\u03c0(k) are indistinguishable. In the noise free setting, A is said to be recovered if we recover each column of A up to a choice of sign (or up to a unit modulus factor in the complex case) and an unknown permutation. As the sources S1, . . . , Sm are only defined up to the same indeterminacies, inverting the recovered matrix A\u0303 to obtain a demixing matrix works for signal recovery.\nIn the noisy ICA setting, there is an additional indeterminacy in the definition of the sources. Consider \u03be to be 0-mean axis-aligned Gaussian random vector. Then, the noisy ICA model X = A(S + \u03be) + \u03b7 in which \u03be is considered part of the latent source signal S\u2032 = S + \u03be, and the model X = AS + (A\u03be + \u03b7) in which \u03be is part of the noise are indistinguishable. In particular, the latent source S and its covariance are ill-defined. Due to this extra indeterminacy, the lengths of the columns of A no longer have a fully defined meaning even when we assume cov(S) = I. In the noisy setting, A is said to be recovered if we obtain the columns of A up to non-zero scalar multiplicative factors and an arbitrary permutation.\nThe last indeterminacy is the most troubling as it suggests that the power of each source signal is itself ill-defined in the noisy setting. Despite this indeterminacy, it is possible to perform an SINR-optimal demixing without additional assumptions about what portion of the signal is source and what portion is noise. In section 3, we will see that SINR-optimal source recovery takes on a simple form: Given any solution A\u0303 which recovers A up to the inherent ambiguities of noisy ICA, then A\u0303H cov(X)\u2020 is an SINR-optimal demixing matrix."}, {"heading": "1.2 Related Work and Contributions", "text": "Independent Component Analysis is probably the most used model for Blind Signal Separation. It has seen numerous applications and has generated a vast literature, including in the noisy and underdetermined settings. We refer the reader to the books [13, 7] for a broad overview of the subject.\nIt was observed early on by Cardoso [4] that ICA algorithms based soley on higher order cumulant statistics are invariant to additive Gaussian noise. This observation has allowed the creation of many algorithms for recovering the ICA mixing matrix in the noisy and often underdetermined settings. Despite the significant work on noisy ICA algorithms, they remain less efficient, more specialized, or less practical than the most popular noise free ICA algorithms.\n2Alternatively, one may place the scaling information in the signals by setting \u2016Ak\u2016 = 1 for each k.\nResearch on cumulant-based noisy ICA can largely be split into several lines of work which we only highlight here. Some algorithms such as FOOBI [4] and BIOME [1] directly use the tensor structure of higher order cumulants. In another line of work, De Lathauwer et al. [8] and Yeredor [23] have suggested algorithms which jointly diagonalize cumulant matrices in a manner reminiscent of the noise-free JADE algorithm [3]. In addition, Yeredor [22] and Goyal et al. [11] have proposed ICA algorithms based on random directional derivatives of the second characteristic function.\nEach line of work has its advantages and disadvantages. The joint diagonalization algorithms and the tensor based algorithms tend to be practical in the sense that they use redundant cumulant information in order to achieve more accurate results. However, they have a higher memory complexity than popular noise free ICA algorithms such as FastICA [12]. Moreover, the tensor methods (FOOBI and BIOME) require the latent source signals to have positive order 2k (k \u2265 2, a predetermined fixed integer) cumulants as they rely on taking a matrix square root. Finally, the methods based on random directional derivatives of the second characteristic function rely heavily upon randomness in a manner not required by the most popular noise free ICA algorithms.\nWe continue a line of research started by Arora et al. [2] and Voss et al. [21] on fully determined noisy ICA which addresses some of these practical issues by using a deflationary approach reminiscent of FastICA. Their algorithms thus have lower memory complexity and are more scalable to high dimensional data than the joint diagonalization and tensor methods. However, both works require a preprocessing step (quasi-orthogonalization) to orthogonalize the latent signals which is based on taking a matrix square root. Arora et al. [2] require each latent signal to have positive fourth cumulant in order to carry out this preprocessing step. In contrast, Voss et al. [21] are able to perform quasi-orthogonalization with source signals of mixed sign fourth cumulants; but their quase-orthogonalization step is more complicated and can run into numerical issues under sampling error. We demonstrate that quasi-orthogonalization is unnecessary. We introduce the PEGI algorithm to work within a (not necessarily positive definite) inner product space instead. Experimentally, this leads to improved demixing performance. In addition, we handle the case of complex signals.\nFinally, another line of work attempts to perform SINR-optimal source recovery in the noisy ICA setting. It was noted by Koldovsky\u0300 and Tichavsky\u0300 [15] that for noisy ICA, traditional ICA algorithms such as FastICA and JADE actually outperform algorithms which first recover A in the noisy setting and then use the resulting approximation of A\u2020 to perform demixing. It was further observed that A\u2020 is not the optimal demixing matrix for source recovery. Later, Koldovsky\u0300 and Tichavsky\u0300 [17] proposed an algorithm based on FastICA which performs a low SINR-bias beamforming."}, {"heading": "2 Pseudo-Euclidean Gradient Iteration ICA", "text": "In this section, we introduce the PEGI algorithm for recovering A in the \u201cfully determined\u201d noisy ICA setting where m \u2264 n. PEGI relies on the idea of Gradient Iteration introduced Voss et al. [21]. However, unlike GI-ICA Voss et al. [21], PEGI does not require the source signals to be orthogonalized. As such, PEGI does not require the complicated quasi-orthogonalization preprocessing step of GI-ICA which can be inaccurate to compute in practice. We sketch the Gradient Iteration algorithm in Section 2.1, and then introduce PEGI in Section 2.2. For simplicity, we limit this discussion to the case of real-valued signals. We show how to construct PEGI for complex-valued signals in Appendix A.\nIn this section we assume a noisy ICA model X = AS + \u03b7 such that \u03b7 is arbitrary Gaussian and independent of S. We also assume that m \u2264 n, that m is known, and that the columns of A\nare linearly independent."}, {"heading": "2.1 Gradient Iteration with Orthogonality", "text": "The gradient iteration relies on the properties of cumulants. We will focus on the fourth cumulant, though similar constructions may be given using other even order cumulants of higher order. For a zero-mean random variable X, the fourth order cumulant may be defined as \u03ba4(X) := E[X4] \u2212 3E[X2]2 [see 7, Chapter 5, Section 1.2]. Higher order cumulants have nice algebraic properties which make them useful for ICA. In particular, \u03ba4 has the following properties: (1) (Independence) If X and Y are independent, then \u03ba4(X +Y ) = \u03ba4(X) +\u03ba4(Y ). (2) (Homogeneity) If \u03b1 is a scalar, then \u03ba4(\u03b1X) = \u03b1\n4\u03ba4(X). (3) (Vanishing Gaussians) If X is normally distributed then \u03ba4(X) = 0. We consider the following function defined on the unit sphere: f(u) := \u03ba4(\u3008X,u\u3009). Expanding\nf(u) using the above properties we obtain:\nf(u) = \u03ba4 ( m\u2211 k=1 \u3008Ak,u\u3009Sk + \u3008u,\u03b7\u3009 ) = m\u2211 k=1 \u3008Ak,u\u30094\u03ba4(Sk) .\nTaking derivatives we obtain:\n\u2207f(u) = 4 m\u2211 k=1 \u3008Ak,u\u30093\u03ba4(Sk)Ak (1)\nHf(u) = 12 m\u2211 k=1 \u3008Ak,u\u30092\u03ba4(Sk)AkATk = AD(u)AT (2)\nwhere D(u) is a diagonal matrix with entries D(u)kk = 12\u3008Ak,u\u30092\u03ba4(Sk). Voss et al. [21] introduced GI-ICA as a fixed point algorithm under the assumption that the columns of A are orthogonal but not necessarily unit vectors. The main idea is that the update u\u2190 \u2207f(u)/\u2016\u2207f(u)\u2016 is a form of a generalized power iteration. From equation (1), each Ak may be considered as a direction in a hidden orthogonal basis of the space. During each iteration, the Ak coordinate of u is raised to the 3\nrd power and multiplied by a constant. Treating this iteration as a fixed point update, it was shown that given a random starting point, this iterative procedure converges rapidly to one of the columns of A (up to a choice of sign). The rate of convergence is cubic.\nHowever, the GI-ICA algorithm requires a somewhat complicated preprocessing step called quasi-orthogonalization to linearly transform the data to make columns of A orthogonal. Quasiorthogonalization makes use of evaluations of Hessians of the fourth cumulant function to construct a matrix of the form C = ADAT where D has all positive diagonal entries\u2014a task which is complicated by the possibility that the latent signals Si may have fourth order cumulants of differing signs\u2014and requires taking the matrix square root of a positive definite matrix of this form. However, the algorithm used for constructing C under sampling error is not always positive definite in practice, which can make the preprocessing step fail. We will show how our PEGI algorithm makes quasi-orthogonalization unnecessary, in particular, resolving this issue."}, {"heading": "2.2 Gradient Iteration in a Pseudo-Euclidean Space", "text": "We now show that the gradient iteration can be performed using in a pseudo-Euclidean space in which the columns of A are orthogonal. The natural candidate for the \u201cinner product space\u201d would be to use \u3008\u00b7, \u00b7\u3009\u2217 defined as \u3008u,v\u3009\u2217 := uT (AAT )\u2020v. Clearly, \u3008Ai, Aj\u3009\u2217 = \u03b4ij gives the desired\nAlgorithm 1 Recovers a column of A up to a scaling factor if u0 is generically chosen.\nInputs: Unit vector u0, C, \u2207f k \u2190 1 repeat\nuk \u2190 \u2207f(C\u2020uk\u22121)/\u2016\u2207f(C\u2020uk\u22121)\u2016 k \u2190 k + 1\nuntil Convergence (up to sign) return uk\northogonality property. However, there are two issues with this \u201cinner product space\u201d: First, it is only an inner product space when A is invertible. This turns out not to be a major issue, and we move forward largely ignoring this point. The second issue is more fundamental: We only have access to AAT in the noise free setting where cov(X) = AAT . In the noisy setting, we have access to matrices of the form Hf(u) = AD(u)AT from equation (2) instead. consider a pseudo-Euclidean inner product defined as follows: Let C = ADAT where D is a diagonal matrix with non-zero diagonal entries, and define \u3008\u00b7, \u00b7\u3009C by \u3008u,v\u3009C = uTC\u2020v. When D contains negative entries, this is not a proper inner product since C is not positive definite. In particular, \u3008Ak, Ak\u3009C = ATk (ADA T )\u2020Ak = d \u22121 kk may be negative. Nevertheless, when k 6= j, \u3008Ak, Aj\u3009C = A T k (ADA\nT )\u2020Aj = 0 gives that the columns of A are orthogonal in this space.\nWe define functions \u03b1k : Rn \u2192 R by \u03b1k(u) = (A\u2020u)k such that for any u \u2208 span(A1, . . . , Am), then u = \u2211m i=1 \u03b1i(u)Ai is the expansion of u in its Ai basis. Continuing from equation (1), for\nany u \u2208 Sn\u22121 we see \u2207f(C\u2020u) = 4 \u2211n k=1\u3008Ak, C\u2020u\u30093\u03ba4(Sk)Ak = 4 \u2211n\nk=1\u3008Ak,u\u30093C\u03ba4(Sk)Ak is the gradient iteration recast in the \u3008\u00b7, \u00b7\u3009C space. Expanding u in its Ak basis, we obtain\n\u2207f(C\u2020u) = 4 m\u2211 k=1 (\u03b1k(u)\u3008Ak, Ak\u3009C)3\u03ba4(Sk)Ak = 4 m\u2211 k=1 \u03b1k(u) 3(d\u22123kk \u03ba4(Sk))Ak , (3)\nwhich is a power iteration in the unseen Ak coordinate system. As no assumptions are made upon the \u03ba4(Sk) values, the d \u22123 kk scalings which were not present in eq. (1) cause no issues. Using this update, we obtain Alg. 1, a fixed point method for recovering a single column of A up to an unknown scaling.\nBefore proceeding, we should clarify the notion of fixed point convergence in Algorithm 1. We say that the sequence {uk}\u221ek=0 converges to v up to sign if there exists a sequence {ck}\u221ek=0 such that each ck \u2208 {\u00b11} and ckuk \u2192 v as k \u2192\u221e. We have the following convergence guarantee.\nTheorem 1. If u0 is chosen uniformly at random from S n\u22121, then with probability 1, there exists ` \u2208 [m] such that the sequence {uk}\u221ek=0 defined as in Algorithm 1 converges to A`/\u2016A`\u2016 up to sign. Further, the rate of convergence is cubic.\nDue to limited space, we omit the proof of Theorem 1. It is similar to the proof of [21, Theorem 4].\nIn practice, we test near convergence by checking if we are still making significant progress. In particular, for some predefined > 0, if there exists a sign value ck \u2208 {\u00b11} such that \u2016uk \u2212 ckuk\u22121\u2016 < , then we declare convergence achieved and return the result. As there are only two choices for ck, this is easily checked, and we exit the loop if this condition is met. Full ICA Recovery Via the Pseudo-Euclidean GI-Update. We are able to recover a single column of A up to its unknown scale. However, for full recovery of A, we would like (given recovered columns A`1 , . . . , A`j ) to be able to recover a column Ak such that k 6\u2208 {`1, . . . , `j} on demand.\nAlgorithm 2 Full ICA matrix recovery algorithm. Returns two matrices: (1) A\u0303 is the recovered mixing matrix for the noisy ICA model X = AS + \u03b7, and (2) B\u0303 is a running estimate of A\u0303\u2020.\n1: Inputs: C, \u2207f 2: A\u0303\u2190 0, B\u0303 \u2190 0 3: for j \u2190 1 to m do 4: Draw u uniformly at random from Sn\u22121. 5: repeat 6: u\u2190 u\u2212 A\u0303B\u0303u 7: u\u2190 \u2207f(C\u2020u)/\u2016\u2207f(C\u2020u)\u2016. 8: until Convergence (up to sign) 9: A\u0303j \u2190 u\n10: B\u0303j\u00b7 \u2190 [C\u2020Aj/((C\u2020Aj)TAj)]T 11: end for 12: return A\u0303, B\u0303\nThe idea behind the simultaneous recovery of all columns of A is two-fold. First, instead of just finding columns of A using Algorithm 1, we simultaneously find rows of A\u2020. Then, using the recovered columns of A and rows of A\u2020, we project u onto the orthogonal complement of the recovered columns of A within the \u3008\u00b7, \u00b7\u3009C pseudo-inner product space.\nRecovering rows of A\u2020. Suppose we have access to a column Ak (which may be achieved using Algorithm 1). Let A\u2020k\u00b7 denote the k th row of A\u2020. Then, we note that C\u2020Ak = (ADA T )\u2020Ak = d\u22121kk (A T )\u2020k = d \u22121 kk (A \u2020 k\u00b7) T recovers A\u2020k\u00b7 up to an arbitrary, unknown constant d \u22121 kk . However, the constant d\u22121kk may be recovered by noting that \u3008Ak, Ak\u3009C = (C \u2020Ak) TAk = d \u22121 kk . As such, we may estimate A\u2020k\u00b7 as [C \u2020Ak/((C \u2020Ak) TAk)]\nT . Enforcing Orthogonality During the GI Update. Given access to a vector u = \u2211m k=1 \u03b1k(u)Ak + PA\u22a5u (where PA\u22a5 is the projection onto the orthogonal complements of the range of A), some recovered columns A`1 , . . . , A`r , and corresponding rows of A \u2020, we may zero out the compo-\nnents of u corresponding to the recovered columns of A. Letting u\u2032 = u \u2212 \u2211r\nj=1A`jA \u2020 `j \u00b7u, then u\u2032 = \u2211\nk\u2208[m]\\{`1,...,`r} \u03b1k(u)Ak + PA\u22a5u. In particular, u \u2032 is orthogonal (in the \u3008\u00b7, \u00b7\u3009C space) to the\npreviously recovered columns of A. This allows the non-orthogonal gradient iteration algorithm to recover a new column of A.\nUsing these ideas, we obtain Algorithm 2, which is the PEGI algorithm for recovery of the mixing matrix A in noisy ICA up to the inherent ambiguities of the problem. Within this Algorithm, step 6 enforces orthogonality with previously found columns of A, guaranteeing that convergence to a new column of A. Practical Construction of C. In our implementation, we set C = 112 \u2211n k=1Hf(ek), as it can be\nshown from equation (2) that \u2211n\nk=1Hf(ek) = ADAT with dkk = \u2016Ak\u20162\u03ba4(Sk). This deterministically guarantees that each latent signal has a significant contribution to C."}, {"heading": "3 SINR Optimal Recovery in Noisy ICA", "text": "In this section, we demonstrate how to perform SINR optimal ICA within the noisy ICA framework given access to an algorithm (such as PEGI) to recover the directions of the columns of A. To this end, we first discuss the SINR optimal demixing solution within any decomposition of the ICA\nmodel into signal and noise as X = AS+\u03b7. We then demonstrate that the SINR optimal demixing matrix is actually the same across all possible model decompositions, and that it can be recovered. The results in this section hold in greater generality than in section 2. They hold even if m \u2265 n (the underdetermined setting) and even if the additive noise \u03b7 is non-Gaussian.\nConsider B an m \u00d7 n demixing matrix, and define S\u0302(B) := BX the resulting approximation to S. It will also be convenient to estimate the source signal S one coordinate at a time: Given a row vector b, we define S\u0302(b) := bX. If b = Bk\u00b7 (the k\nth row of B), then S\u0302(b) = [S\u0302(B)]k = S\u0302k(B) is our estimate to the kth latent signal Sk. Within a specific ICA model X = AS + \u03b7, signal to intereference-plus-noise ratio (SINR) is defined by the following equation:\nSINRk(b) := var(bAkSk)\nvar(bAS\u2212 bAkSk) + var(b\u03b7) =\nvar(bAkSk)\nvar(bAX)\u2212 var(bAkSk) . (4)\nSINRk is the variance of the contribution of k th source divided by the variance of the noise and interference contributions within the signal. Given access to the mixing matrix A, we define Bopt = A\nH(AAH + cov(\u03b7))\u2020. Since cov(X) = AAH +cov(\u03b7), this may be rewritten as Bopt = A\nH cov(X)\u2020. Here, cov(X)\u2020 may be estimated from data, but due to the ambiguities of the noisy ICA model, A (and specifically its column norms) cannot be estimated from data.\nKoldovsky\u0300 and Tichavsky\u0300 [15] observed that when \u03b7 is a white Gaussian noise, Bopt jointly maximizes SINRk for each k \u2208 [m], i.e., SINRk takes on its maximal value at (Bopt)k\u00b7. Below in Proposition 2, we generalize this result to include arbitrary non-spherical, potentially non-Gaussian noise.\nIt is interesting to note that even after the data is whitened, i.e. cov(X) = I, the optimal SINR solution is different from the optimal solution in the noiseless case unless A is an orthogonal matrix, i.e. A\u2020 = AH . This is generally not the case, even if \u03b7 is white Gaussian noise.\nProposition 2. For each k \u2208 [m], (Bopt)k\u00b7 is a maximizer of SINRk.\nThe proof of Proposition 2 is deferred to appendix B. Since SINR is scale invariant, Proposition 2 implies that any matrix of the form DBopt = DAH cov(X)\u2020 where D is a diagonal scaling matrix (with non-zero diagonal entries) is an SINRoptimal demixing matrix. More formally, we have the following result.\nTheorem 3. Let A\u0303 be an n\u00d7m matrix containing the columns of A up to scale and an arbitrary permutation. That is, there exists a permutation \u03c0 of [m] and non-zero constants \u03b11, . . . , \u03b1m such that \u03b1kA\u0303\u03c0(k) = Ak for each k \u2208 [m]. Then, (A\u0303H cov(X)\u2020)\u03c0(k)\u00b7 is a maximizer of SINRk.\nBy Theorem 3, given access to a matrix A\u0303 which recovers the directions of the columns of A, then A\u0303H cov(X)\u2020 is the SINR-optimal demixing matrix. For ICA in the presence of Gaussian noise, the directions of the columns of A are well defined simply from X, that is, the directions of the columns of A do not depend on the decomposition of X into signal and noise (see the discussion in section 1.1 on ICA indeterminacies). The problem of SINR optimal demixing is thus well defined for ICA in the presence of Gaussian noise, and the SINR optimal demixing matrix can be estimated from data without any additional assumptions on the magnitude of the noise in the data.\nFinally, we note that in the noise-free case, the SINR-optimal source recovery simplifies to be A\u0303\u2020.\nCorollary 4. Suppose that X = AS is a noise free (possibly underdetermined) ICA model. Suppose that A\u0303 \u2208 Rn\u00d7m contains the columns of A up to scale and permutation, i.e., there exists diagonal matrix D with non-zero entries and a permutation matrix \u03a0 such that A\u0303 = AD\u03a0. Then A\u0303\u2020 is an SINR-optimal demixing matrix.\nSINR Comparison (d=14, Noise Power=0.67, mixed distr)\nSINR Loss Comparison (d=14, Sample Size=106 , mixed distr)\nProof. By Theorem 3, (AD\u22121\u03a0)H cov(X)\u2020 is an SINR-optimal demixing matrix. Expanding, we obtain: (AD\u22121\u03a0)H cov(X)\u2020 = \u03a0HD\u22121AH(AAH)\u2020 = \u03a0HD\u22121A\u2020 = (AD\u03a0)\u2020 = A\u0303\u2020.\nCorollary 4 is consistent with known beamforming results. In particular, it is known that A\u2020 is an optimal (in terms of minimum mean squared error) beamforming matrix for underdetermined ICA [19, section 3B]."}, {"heading": "4 Experimental Results", "text": "We now compare the proposed PEGI algorithm with several existing ICA algorithms. In addition to qorth+GI-ICA (that is, GI-ICA with the quasi-orthogonalization preprocessing step), we use the following algorithmic baselines: JADE [3] is a popular fourth cumulant based ICA algorithm designed for the noise free setting. We use the implementation of Cardoso and Souloumiac [5]. FastICA [12] is a popular ICA algorithm designed for the noise free setting based on a deflationary approach of recovering one component at a time. We use the implementation of Ga\u0308vert et al. [10]. 1FICA [16, 17] is a variation of FastICA with the tanh contrast function designed to have low bias for performing SINR-optimal beamforming in the presence of Gaussian noise. Ainv is the oracle demixing algorithm which uses A\u2020 as the demixing matrix. SINR-opt is the oracle demixing algorithm which demixes using AH cov(X)\u2020 to achieve an SINRoptimal demixing.\nWe compare these algorithms on simulated data with n = m. We constructed mixing matrices A with condition number 3 via a reverse singular value decomposition (A = U\u039bV T ). The matrices U and V were random orthogonal matrices, and \u039b was chosen to have 1 as its minimum and 3 as its maximum singular values, with the intermediate singular values chosen uniformly at random. We drew data from a noisy ICA model X = AS+\u03b7 where cov(\u03b7) = \u03a3 was chosen to be malaligned with cov(AS) = AAT . We set \u03a3 = p(10I \u2212 AAT ) where p is a constant defining the noise power. It can be shown that p = maxv var(v\nT\u03b7) maxv var(vTAS) is the ratio of the maximum directional noise variance\nto the maximum directional signal variance. We generated 100 matrices A for our experiments with 100 corresponding ICA data sets for each sample size and noise power. When reporting\nSINR Comparison (d=14, Noise Power=0.67, mixed distr)\nresults, we apply each algorithm to each of the 100 data sets for the corresponding sample size and noise power and we report the mean performance. The source distributions used in our ICA experiments were the Laplace and Bernoulli distribution with parameters 0.05 and 0.5 respectively, the t-distribution with 3 and 5 degrees of freedom respectively, the exponential distribution, and the uniform distribution. Each distribution was normalized to have unit variance, and the distributions were each used twice to create 14-dimensional data. We compare the algorithms using either SINR or the SINR loss from the optimal demixing matrix (defined by SINR Loss = [Optimal SINR \u2212 Achieved SINR]).\nIn Figure 1b, we compare our proprosed ICA algorithm with various ICA algorithms for signal recovery. In the PEGI-\u03ba4+SINR algorithm, we use PEGI-\u03ba4 to estimate A, and then perform demixing using the resulting estimate of AH cov(X)\u22121, the formula for SINR-optimal demixing. It is apparent that when given sufficient samples, PEGI-\u03ba4+SINR provides the best SINR demixing. JADE, FastICA-tanh, and 1FICA each have a bias in the presence of additive Gaussian noise which keeps them from being SINR-optimal even when given many samples.\nn Figure 1a, we compare algorithms at various sample sizes. The PEGI-\u03ba4+SINR algorithm relies more heavily on accurate estimates of fourth order statistics than JADE, and the FastICAtanh and 1FICA algorithms do not require the estimation of fourth order statistics. For this reason, PEGI-\u03ba4+SINR requires more samples than the other algorithms in order to be run accurately. However, once sufficient samples are taken, PEGI-\u03ba4+SINR outperforms the other algorithms including 1FICA which is designed to have low SINR bias.\nIn order to avoid clutter, we did not include qorth+GI-ICA-\u03ba4+SINR (the SINR optimal demixing estimate constructed using qorth+GI-ICA-\u03ba4 to estimate A) in the figures 1b and 1a. It is also assymptotically unbiased in estimating the directions of the columns of A, and similar conclusions could be drawn using qorth+GI-ICA-\u03ba4 in place of PEGI-\u03ba4. However, in Figure 2, we see that PEGI-\u03ba4+SINR requires fewer samples than qorth+GI-ICA-\u03ba4+SINR to achieve good performance. This is particularly highlighted in the medium sample regime.\nOn the Performance of Traditional ICA Algorithms for Noisy ICA. An interesting observation [first made in 15] is that the popular noise free ICA algorithms JADE and FastICA perform reasonably well in the noisy setting. In Figures 1b and 1a, they significantly outperform\ndemixing using A\u22121 for source recovery. It turns out that this may be explained by a shared preprocessing step. Both JADE and FastICA rely on a whitening preprocessing step in which the data are linearly transformed to have identity covariance. It can be shown in the noise free setting that after whitening, the mixing matrix A is a rotation matrix. These algorithms proceed by recovering an orthogonal matrix A\u0303 to approximate the true mixing matrix A. Demixing is performed using A\u0303\u22121 = A\u0303H . Since the data is white (has identity covariance), then the demixing matrix A\u0303H = A\u0303H cov(X)\u22121 is an estimate of the SINR-optimal demixing matrix. Nevertheless, the traditional ICA algorithms give a biased estimate of A under additive Gaussian noise."}, {"heading": "A PEGI for Complex Signals", "text": "In Section 2, we showed how to perform gradient iteration ICA within a pseudo-Euclidean inner product space. In this appendix, we show how this PEGI algorithm can be extended to include complex valued signals. For clarity, we repeat the entire PEGI algorithmic construction from Section 2 with the necessary modifications to handle the complex setting.\nThroughout this appendix, we assume a noisy ICA model X = AS + \u03b7 where \u03b7 is an arbitrary Gaussian noise independent of S. We also assume that m \u2264 n, that m is known, and that the columns of A are linearly dependent.\nA.1 Fourth Cumulants of Complex Variables\nThe gradient iteration relies on the properties of cumulants. We will focus on the fourth cumulant, though similar constructions may be given using other even order cumulants of higher order. We will use two versions of the fourth cumulant which capture slightly different fourth order information. For a zero-mean random variable X, they may be defined as \u03ba4(X) := E[X4] \u2212 3E[X2]2 and \u03ba?4(X) := E[X2X\u22172] \u2212 2E[XX\u2217]2 \u2212 E[X2]E[X\u22172]. For real random variables, these two definitions are equivalent, and they come from two different conjugation schemes when constructing the fourth order cumulant [see 7, Chapter 5, Section 1.2]. However, in general, only \u03ba?4 is guaranteed to be real valued. The higher order cumulants have nice algebraic properties which make them useful for ICA:\n1. (Independence) If X and Y are independent random variables, then \u03ba4(X + Y ) = \u03ba4(X) + \u03ba4(Y ) and \u03ba ? 4(X + Y ) = \u03ba4(X + Y ).\n2. (Homogeneity) If \u03b1 is a scalar, then \u03ba4(\u03b1X) = \u03b1 4\u03ba4(X) and \u03ba ? 4(\u03b1X) = |\u03b1| 4\u03ba?4(X).\n3. (Vanishing Gaussians) If X is normally distributed then \u03ba4(X) = 0 and \u03ba ? 4(X) = 0.\nIn this appendix, we consider a noisy ICA model X = AS + \u03b7 where \u03b7 is a 0-mean (possibly complex) Gaussian and independent of S. We consider the following functions defined on the unit sphere: f(u) := \u03ba4(\u3008X,u\u3009) and f?(u) := \u03ba?4(\u3008X,u\u3009). Then, expanding using the above properties we obtain:\nf(u) = \u03ba4 ( m\u2211 k=1 \u3008Ak,u\u3009Sk + \u3008u,\u03b7\u3009 )\n= m\u2211 k=1 \u3008Ak,u\u30094\u03ba4(Sk)\nUsing similar reasoning, it can be seen that f?(u) = \u2211m k=1 |\u3008Ak,u\u3009| 4\u03ba?4(Sk).\nIt turns out that some slightly non-standard notions of derivatives are most useful in constructing the gradient iteration in the complex setting. We use real derivatives for the gradient and we use the complex Hessian. In particular, expanding uk = xk + iyk, we use the gradient operator \u2207 := \u2211n k=1 ek \u2202 \u2202xk . We make use of the operators \u2202uk := 1 2( \u2202 \u2202xk \u2212 i \u2202\u2202yk ) and \u2202u \u2217 k := 1 2( \u2202 \u2202xk + i \u2202\u2202yk ) to\ndefine H := \u2211n\nj=1 \u2211n k=1 eke T j \u2202uk\u2202u \u2217 j . Applying this version of the Hessian is different than using\nreal derivatives as in the gradient operation. Taking derivatives, we obtain:\n\u2207f(u) = 4 m\u2211 k=1 \u3008Ak,u\u30093\u03ba4(Sk)Ak (5)\nHf?(u) = 4 m\u2211 k=1 |\u3008Ak,u\u3009|2\u03ba?4(Sk)A\u2217kATk\n= A\u2217D(u)AT (6)\nwhere D(u) is a diagonal matrix with entries D(u)kk = 4|\u3008Ak,u\u3009|2\u03ba?4(Sk).\nAlgorithm 3 Recovers a column of A up to an unknown scaling factor when u0 is generically chosen.\nInputs: u0 (A unit vector), C, \u2207f k \u2190 1 repeat\nuk \u2190 \u2207f(C\u2020 \u2217 uk\u22121)/\u2016\u2207f(C\u2020 \u2217 uk\u22121)\u2016\nk \u2190 k + 1 until Convergence (up to a unit modulus factor) return uk\nA.2 Gradient Iteration in a Pseudo-Euclidean Space\nWe now demonstrate that the gradient iteration can be performed using a generalized notion of an inner product space in which the columns of A are orthogonal. The natural candidate for the \u201cinner product space\u201d would be to use \u3008\u00b7, \u00b7\u3009\u2217 defined as \u3008u,v\u3009\u2217 := uT (A\u2217AT )\u2020v\u2217. Clearly, \u3008Ai, Aj\u3009\u2217 = \u03b4ij gives the desired orthogonality property. However, there are two issues with this \u201cinner product space\u201d: First, it is only an inner product space when A is non-singular (invertible). This turns out not to be a major issue, and we will move forward largely ignoring this point. The second issue is more fundamental: We only have access to the matrix A\u2217AT in the noise free setting where cov(X)T = (AAH)T = A\u2217AT . In the noisy setting, we have access to matrices of the form Hf?(u) = A\u2217D(u)AT from equation (6) instead.\nWe consider a pseudo-Euclidean inner product defined as follows: Let C = A\u2217DAT where D is a diagonal matrix with non-zero diagonal entries, and define \u3008\u00b7, \u00b7\u3009C by \u3008u,v\u3009C = uTC\u2020v\u2217. When D contains negative entries, this is not a proper inner product since C is not positive definite. In particular, \u3008Ak, Ak\u3009C = ATk (A\u2217DAT )\u2020A\u2217k = d \u22121 kk may be negative. Nevertheless, when k 6= j, \u3008Ak, Aj\u3009C = ATk (A\u2217DAT )\u2020A\u2217j = 0 gives that the columns of A are orthogonal in this space. We define functions \u03b1k : Cn \u2192 C by \u03b1k(u) = (A\u2020u)k such that for any u \u2208 span(A1, . . . , Am),\nthen u = \u2211m\ni=1 \u03b1i(u)Ai is the expansion of u in its Ai basis. Continuing from equation (5), for any u \u2208 Sn\u22121 we see\n\u2207f(C\u2020\u2217u) = 4 n\u2211 k=1 \u3008Ak, C\u2020 \u2217 u\u30093\u03ba4(Sk)Ak\n= 4 n\u2211 k=1 \u3008Ak,u\u30093C\u03ba4(Sk)Ak\nis the gradient iteration recast in the \u3008\u00b7, \u00b7\u3009C space. Expanding u in its Ak basis, we obtain\n\u2207f(C\u2020\u2217u) = 4 m\u2211 k=1 (\u03b1k(u)\u3008Ak, Ak\u3009C)3\u03ba4(Sk)Ak\n= 4 m\u2211 k=1 \u03b1k(u) 3(d\u22123kk \u03ba4(Sk))Ak , (7)\nwhich is a power iteration in the unseen Ak coordinate system. As no assumptions are made upon the \u03ba4(Sk) values, the d \u22123 kk scalings which were not present in equation (5) cause no issues. Using this update, we obtain Algorithm 3, a fixed point method for recovering a single column of A up to an unknown scaling.\nBefore proceeding, we should clarify the notion of fixed point convergence in Algorithm 3. We say that the sequence {uk}\u221ek=0 converges to v up to a unit modulus factor if there exists a sequence of constants {ck}\u221ek=0 such that each |ck| = 1 and ckuk \u2192 v as k \u2192 \u221e. We have the following convergence guarantee.\nTheorem 5. If u0 is chosen uniformly at random from S n\u22121. Then with probability 1, there exists ` \u2208 [m] such that the sequence {uk}\u221ek=0 defined as in Algorithm 3 converges to a A`/\u2016A`\u2016 up to a unit modulus factor. Further, the rate of convergence is cubic.\nDue to space limitations, we omit the proof of Theorem 5. However, its proof is very similar that of an analogous result for the GI-ICA algorithm [21, Theorem 4].\nIn practice, we test near convergence by testing if we are still making significant progress. In particular, for some predefined > 0, if there exists a unit modulus constant ck such that \u2016uk\u2212 ckuk\u22121\u2016 < , then we declare convergence achieved and return the result. We may determine ck using the following fact. Fact 6. Suppose that u and v are non-orthogonal unit modulus vectors. The expression \u2016u\u2212ei\u03b8v\u2016 is minimized by the choice of \u03b8 = atan2(Im(\u3008u,v\u3009),Re(\u3008u,v\u3009)).\nLetting \u03b8 = atan2(Im(\u3008uk,uk\u22121\u3009),Re(\u3008uk,uk\u22121\u3009), we exit the loop if \u2016uk \u2212 ei\u03b8uk\u22121\u2016 < .\nA.3 Full ICA Recovery Via the Pseudo-Euclidean GI-Update\nWe are able to recover a single column of A in noisy ICA. However, for full matrix recovery, we would like (given recovered columns A`1 , . . . , A`j ) to be able to recover a column Ak such that k 6\u2208 {`1, . . . , `j} on demand.\nThe main idea behind the simultaneous recovery of all columns of A is two-fold. First, instead of just finding columns of A using Algorithm 3, we simultaneously find rows of A\u2020. Then, using the recovered columns of A and rows of A\u2020, we may project u onto the orthogonal complement of the recovered columns of A within the \u3008\u00b7, \u00b7\u3009C pseudo-Euclidean inner product space.\nRecovering rows of A\u2020. Suppose we have access to a column Ak (which may be achieved using Algorithm 3). Let A\u2020k\u00b7 denote the k th row of A\u2020. Then, we note that C\u2020A\u2217k = (A \u2217DAT )\u2020A\u2217k = d\u22121kk (A T )\u2020k = d \u22121 kk (A \u2020 k\u00b7) T recovers A\u2020k\u00b7 up to an arbitrary, unknown constant d \u22121 kk . However, the constant d\u22121kk may be recovered by noting that \u3008Ak, Ak\u3009C = (C \u2020Ak) TAk = d \u22121 kk . As such, we may estimate A\u2020k\u00b7 as [C \u2020Ak/((C \u2020Ak) TAk)] T . Enforcing Orthogonality During the GI Update. Given access to u = \u2211m\nk=1 \u03b1k(u)Ak + PA\u22a5u, some recovered columns A`1 , . . . , A`r , and corresponding rows of A \u2020, we may zero out the\ncomponents of u corresponding to the recovered columns of A. Letting u\u2032 = u \u2212 \u2211r\nj=1A`jA \u2020 `j \u00b7u, then u\u2032 = \u2211\nk\u2208[m]\\{`1,...,`r} \u03b1k(u)Ak + PA\u22a5u. In particular, u \u2032 is orthogonal (in the \u3008\u00b7, \u00b7\u3009C space)\nto the previously recovered columns of A. This allows us to modify the non-orthogonal gradient iteration algorithm to recover a new column of A.\nUsing these ideas, we obtain the Algorithm 4 for recovery of the ICA mixing matrix. Within this Algorithm, step 6 enforces orthogonality with previously found columns of A, guaranteeing that convergence is to a new column of A. Practical Construction of C We suggest the choice of C = 14 \u2211n\nk=1Hf?(ek), as it can be shown from equation (6) that \u2211n k=1Hf?(ek) = A\u2217DAT with dkk = \u2016Ak\u20162\u03ba?4(Sk). This deterministically guarantees that each latent signal has a significant contribution to C.\nAlgorithm 4 Full ICA matrix recovery algorithm. Estimates and returns two matrices: (1) A\u0303 is the recovered mixing matrix for the noisy ICA model X = AS+\u03b7, and (2) B\u0303 is a running estimate of A\u0303\u2020.\n1: Inputs: C, \u2207f 2: A\u0303\u2190 0, B\u0303 \u2190 0 3: for j \u2190 1 to m do 4: Draw u uniformly at random from Sn\u22121. 5: repeat 6: u\u2190 u\u2212 A\u0303B\u0303u 7: u\u2190 \u2207f(C\u2020\u2217u)/\u2016\u2207f(C\u2020\u2217u)\u2016. 8: until Convergence (up to a unit modulus factor) 9: A\u0303j \u2190 u\n10: B\u0303j\u00b7 \u2190 [C\u2020Aj/((C\u2020Aj)TAj)]T 11: end for 12: return A\u0303, B\u0303"}, {"heading": "B Proof of Proposition 2", "text": "Proof. This proof is based on the connection between two notions of optimality, minimum mean squared error and SINR. The mean squared error of the recovered signal S\u0302(b) from kth latent signal is defined as MSEk(b) := E[|Sk \u2212 S\u0302(b)| 2 ]. It has been shown [14, equation 39] that Bopt jointly minimizes the mean squared errors of the recovered signals. In particular, if b = (Bopt)k\u00b7, then b is a minimizer of MSEk(b).\nWe will first show that finding a matrix B which minimizes the mean squared error has the side effect of maximizing the magnitude of the Pearson correlations \u03c1Sk,S\u0302k(B) for each k \u2208 [m], where \u03c1Sk,S\u0302k(B) := E[SkS\u0302\u2217k(B)] \u03c3Sk\u03c3S\u0302k(B)\n. We will then demonstrate that if B is a maximizer of |\u03c1Sk,S\u0302k(B)|, then Bk\u00b7 is a maximizer of SINRk. These two facts imply the desired result. We will use the convention that \u03c1Sk,S\u0302k(B) is 0 if \u03c3S\u0302k(B) = 0.\nWe fix a k \u2208 [m]. We have:\nMSEk(b) = E[SkS\u2217k \u2212 2 Re(SkS\u0302\u2217(b)) + S\u0302(b)S\u0302\u2217(b)] = 1\u2212 2\u03c3S\u0302(b) Re(\u03c1Sk,S\u0302(b)) + \u03c3 2 S\u0302(b) .\nLetting \u03c9 = sgn(\u03c1Sk,S\u0302(b)), we obtain\n\u03c1Sk,S\u0302(\u03c9b) = E[SkS\u0302\u2217(\u03c9b)] \u03c3Sk\u03c3S\u0302(\u03c9b) = \u03c9\u2217 E[SkS\u0302\u2217(b)] \u03c3Sk\u03c3S\u0302(b) = |\u03c1Sk,S\u0302(b)| . (8)\nFurther, MSEk(\u03c9b) = 1\u2212 2\u03c3S\u0302(b)|\u03c1Sk,S\u0302(b)|+ \u03c3 2 S\u0302(b) \u2264 MSEk(b) with equality if and only if \u03c1Sk,S\u0302(b) is real and non-negative. As such, all global minima of MSEk are contained in the set A = {b | \u03c1Sk,S\u0302(b) \u2208 [0, 1]}, and we may restrict our investigation to this set.\nWe define a function g(x, y) := 1\u22122xy+y2 such that under the change of variable x(b) = \u03c3S\u0302(b) and y(b) = \u03c1Sk,S\u0302(b), we obtain MSEk(b) = g(x, y). Let M = maxb\u2208A \u03c1Sk,S\u0302(b) and let y0 \u2208 [0,M ] be fixed. Then, arg minx\u2208R g(x, y0) = y0 with the resulting value g(y0, y0) = 1 \u2212 y20. As such, the minimum of g(x, y) over the domain R \u00d7 [0,M ] occurs when x = y = M . If M = 0, then the\nchoice of \u03be = 0 satisfies that x(\u03be) = y(\u03be) = 0, making MSEk(\u03be) = g(x, y) the global minimum of MSEk. If M 6= 0, then we may choose \u03be such that y(\u03be) = \u03c1Sk,S\u0302(\u03be) = M . As \u03c3S\u0302(\u03be) > 0 must hold, it follows that there exists \u03b1 \u2208 (0,\u221e) such that setting \u03b6 = \u03b1\u03be, we obtain (\u03c3S\u0302(\u03b6) =)x(\u03b6) = y(\u03be). Since y(b) = \u03c1Sk,S\u0302(b) is scale invariant, we obtain that x(\u03b6) = y(\u03b6) = y(\u03be) = M , making \u03b6 a global minimum of MSEk. In both cases, it follows that if b minimizes MSEk(b), then b maximizes \u03c1Sk,S\u0302(b) over A.\nFrom equation (8), we see that maxb\u2208Cn |\u03c1Sk,S\u0302(b)| = maxb\u2208A \u03c1Sk,S\u0302(b). Thus if b is a minimizer of MSEk(\u03c9b), then b is also a maximizer of |\u03c1Sk,S\u0302(b)| as claimed.\nWe now demonstrate that b is a maximizer of |\u03c1Sk,S\u0302(b)| if and only if it is also a maximizer of SINRk(b). Under the conventions that x 0 = +\u221e when x > 0 and that 0 0 = s\u221e where s = \u22121 for maximization problems and s = +1 for minimization problems, the following problems have equivalent solution sets over choices of b:\nmax b SINRk(b) \u2261 max b E[|bAkSk|2] var(S\u0302(b))\u2212 E[|bAkSk|2] \u2261 max b\n|E[SkS\u0302\u2217(b)]| 2\nvar(S\u0302(b))\u2212 |E[SkS\u0302\u2217(b)]| 2\n\u2261 min b\nvar(S\u0302(b))\u2212 |E[SkS\u0302\u2217(b)]| 2\n|E[SkS\u0302\u2217(b)]| 2 \u2261 minb\nvar(S\u0302(b))\n|E[SkS\u0302\u2217(b)]| 2\n\u2261 max b\n|E[SkS\u0302\u2217(b)]| 2\nvar(S\u0302(b)) \u2261 max b |\u03c1Sk,S\u0302(b)| 2 .\nIn the above, the first equivalence is a rewriting of equation (4). To see the second equivalence, we note that |E[SkS\u0302\u2217(b)]| 2\n= |E[Sk(bAS + b\u03b7)\u2217]|2 = |bAk|2 using the independence of Sk from all other terms. Then, noting that |bAk|2 = E[|bAkSk|2] gives the equivalence. The fourth equivalence is only changing the problem by the additive constant \u22121."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "Independent Component Analysis (ICA) is a popular model for blind signal separation. The<lb>ICA model assumes that a number of independent source signals are linearly mixed to form the<lb>observed signals. We propose a new algorithm, PEGI (for pseudo-Euclidean Gradient Iteration),<lb>for provable model recovery for ICA with Gaussian noise. The main technical innovation of the<lb>algorithm is to use a fixed point iteration in a pseudo-Euclidean (indefinite \u201cinner product\u201d)<lb>space. The use of this indefinite \u201cinner product\u201d resolves technical issues common to several<lb>existing algorithms for noisy ICA. This leads to an algorithm which is conceptually simple,<lb>efficient and accurate in testing.<lb>Our second contribution is combining PEGI with the analysis of objectives for optimal re-<lb>covery in the noisy ICA model. It has been observed that the direct approach of demixing with<lb>the inverse of the mixing matrix is suboptimal for signal recovery in terms of the natural Signal<lb>to Interference plus Noise Ratio (SINR) criterion. There have been several partial solutions<lb>proposed in the ICA literature. It turns out that any solution to the mixing matrix reconstruc-<lb>tion problem can be used to construct an SINR-optimal ICA demixing, despite the fact that<lb>SINR itself cannot be computed from data. That allows us to obtain a practical and provably<lb>SINR-optimal recovery method for ICA with arbitrary Gaussian noise.", "creator": "LaTeX with hyperref package"}}}