{"id": "1506.02312", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Jun-2015", "title": "A Framework for Constrained and Adaptive Behavior-Based Agents", "abstract": "behavior trees are commonly used while model agents for robotics and games, where constrained mechanisms must be designed within human experts in order to guarantee ensure these agents will execute a specific chain of actions given at specific set of perceptions. in such important areas, learning is a desirable feature to provide competitors with the ability to adapt and improve interactions with humans and environment, but often discarded due to its unreliability. in this paper, we described organizational framework that uses reinforcement learning technology as part of behavior trees to address overall problem of adding learning capabilities in constrained agents. we show how this framework relates to options forming hierarchical reinforcement learning, reduces convergence of nested learning nodes, and helps empirically show that the learning nodes don't affect the execution of other stages in the tree.", "histories": [["v1", "Sun, 7 Jun 2015 20:52:31 GMT  (305kb,D)", "http://arxiv.org/abs/1506.02312v1", "2015; 15 pages"]], "COMMENTS": "2015; 15 pages", "reviews": [], "SUBJECTS": "cs.AI cs.LG cs.RO cs.SY", "authors": ["renato de pontes pereira", "paulo martins engel"], "accepted": false, "id": "1506.02312"}, "pdf": {"name": "1506.02312.pdf", "metadata": {"source": "CRF", "title": "A Framework for Constrained and Adaptive Behavior-Based Agents", "authors": ["Renato de Pontes Pereira", "Paulo Martins Engel"], "emails": ["rppereira@inf.ufrgs.br", "engel@inf.ufrgs.br"], "sections": [{"heading": null, "text": "Keywords: Behavior Trees, Reinforcement Learning, Hierarchical Reinforcement Learning, Agent Modeling, Robotics, Games"}, {"heading": "1 Introduction", "text": "Some applications require a strict control of autonomous agents, i.e., the agent must be reliable to perform the right action in the right moment to achieve its goals, with minimum (ideally zero) chance to fail. For example, consider a large robot that interacts with humans in an industry. This robot must operate very carefully in order not to damage other equipments neither harm humans.\nA Behavior Tree (BT) is a plan representation and decision making tool for modeling autonomous agents mainly used in the video games industry, but gaining attention in robotics, control theory and general agent modeling. BTs are appealing because they allow human experts to design constrained behaviors. We define a constrained behavior as a control block that guarantees the execution of a specific chain of actions given a specific set of perceptions.\nBehavior Trees provide several powerful features to model constrained agents, such as: reliability that the agent will perform exactly the behaviors designed by the expert; flexibility to reuse behaviors, and build and maintain large models without losing readability; and an easiness to debug and identify possible errors.\nar X\niv :1\n50 6.\n02 31\n2v 1\n[ cs\n.A I]\n7 J\nun 2\n01 5\nHowever, Behavior Trees also have limitations, for example: 1) in general, a good agent must have a large set of behaviors in order to respond differently to the events in the environment, but a BT model depends entirely on the expert manual work, therefore, creating good agents demands much time and effort from the expert to design and test this large set of behaviors; 2) the lack of variation in behaviors (due to the cost in terms of time or effort to make more behaviors) makes the agent predictive and repetitive, which can be a negative factor in applications where the agent interacts with humans; 3) the Behavior Tree does not have any adaptation mechanism, therefore, agents cannot adapt to changes in the environment neither improve the initial expert design, this can also be an issue when agents interact with humans.\nOne way to bring adaptiveness and avoid repetitiveness is using learning algorithms. Reinforcement Learning (RL), in particular, can be used to model learning agents that can adapt to unknown environments and optimize their performance in real time and in an online way. However, learning is often discarded in applications that require constrained agents because it can bring harmful problems to the agent and to the task, some problems include: it may not guarantee convergence or stability, making the agent unreliable; it may require too much data or time to be trained; large robots, for example, may bring danger to equipments or living beings; the robot itself can be damaged; characters controlled by computer in competitive games, for example, may learn bad actions from humans; it may not generalize, performing poorly in other environments than those presented on training; may converge to sub-optimal behaviors and never change again.\nIn this paper we address the problem of adding learning capabilities to constrained agents by using Reinforcement Learning together with Behavior Trees, keeping the advantages and features of BTs and RL while minimizing the risks of learning. To achieve this, we define a new node in the Behavior Tree, the learning node, which embeds a local Reinforcement Learning model without changing the overall tree structure. Based on this node, we propose a general framework for modeling constrained yet adaptive agents that is related to the Options framework in Hierarchical Reinforcement Learning.\nThe remainder of this paper is structured as follows. Section 2 presents an overview of Behavior Trees, together with the formal definition of this tool. Section 3 describes the basics of the Reinforcement Learning through Markov Decision Processes and expands it to Hierarchical Reinforcement Learning and Semi-Markov Decision Processes. Section 4 presents the basis of the proposed framework and a proof that it is related to the Options framework of Hierarchical Reinforcement Learning. The proposed framework is also validated empirically in Section 5 with two agent simulation experiments using a fire control scenario. Section 6 discusses the relation of this framework with other related works on Behavior Trees and Reinforcement Learning. Finally, Section 7 presents the final notes and discusses the future works."}, {"heading": "2 Behavior Trees", "text": "A Behavior Tree (BT) is a plan representation and decision making tool used to model and control autonomous agents. This tool was created in the game industry [7] with fast adoption by the game development community. BTs are commonly used to model NPCs (Non-Playable Characters or Characters Controlled by the Computer) and they are viewed as an alternative to FSMs (Finite State Machines), HFSMs (Hierarchical Finite State Machines) and hand-coded rules via scripting. Since 2012, there are some efforts to apply BTs on robotics, including modeling and controlling of UAVs [10], fault tolerance in hybrid and multi-robot systems [4][2] and an attempt to unify notation and formalize Behavior Trees as controller, proving the relation to CHDSs (Controlled Hybrid Dynamical Systems) [9]. We follow the description proposed by (Marzinotto et al., 2014), which is the most formal and coherent description of Behavior Trees in the current literature, but with a few minor changes (please refer to Section 6 for a comparison).\nBehavior Trees provide several features that are important for real-time, constrained and complex application:\n\u2013 readability: all information, transitions, connections, relations and conditions modeled by BTs are explicit and compact. This is especially useful for maintenance and collaborative work; \u2013 maintainability: because transitions in BT are defined by the structure in an explicit way (the model is not black box), nodes can be designed independently from one another, thus, when adding, modifying or removing nodes (or subtrees) it is not necessary to change other pieces of the model. \u2013 scalability: when a BT has many nodes, it can be decomposed into small subtrees saving the readability of the graphical model. \u2013 reusability: due to the independence provided by BT, the nodes and subtrees can be reused in other models and projects. \u2013 goal-oriented: although the nodes are independent from one another, they still are related by the structure of the model. This allows designers to build specific sub-trees for a given goal without losing flexibility of the model. \u2013 parallelization: parallelization is possible (and easy to do) because all worker processes are locally contained to the parallel node.\nWe define a Behavior Tree as a Directed Rooted Tree G(V, E) with |V| nodes and |E| directed edges. For a pair of connected nodes, the outgoing node is called parent and the incoming node is called child. The child-less nodes are called leaves while the parent-less node is called root, which must have only a single child. The nodes standing between the root and the leaves are called internal. Each subtree in the model defines a different behavior. A single leaf node is called a primitive behavior (also called trivial or atomic behavior). Composed behaviors use combinations of primitive behaviors and other composed ones, defining a behavior hierarchy.\nPeriodically, the root generates a tick signal and propagate it through the tree branches according to the algorithm defined by each node type. When the\ntick reaches a leaf node, a computation is made and the node returns a state value: SUCCESS, FAILURE or RUNNING1. Then the returned state value is propagated back and forth through the tree according to the algorithm defined by each node type. The tick signal stops when it reaches the root.\nEach node in the tree, except the root, belongs to one of the following categories: Composite, Decorator, Action or Condition. Figure 1 presents the visual example of them. Nodes of each one of these categories have a specific responsibility and constraints in the tree:\n\u2013 Composite: nodes of this category are commonly referred to as controlflow nodes, because their role is to propagate the tick signal to its children, respecting some defined order. Composite nodes must decide which child will be ticked and which state value will be returned. A composite node can have one or more children and preferably does not perform any computation more than the necessary to choose the children to tick. Composites are represented graphically by squares with a symbol or rectangles with text.\n\u2013 Decorator: the goal of decorator is to change the behavior of its child by manipulating the returned state value or changing the child ticking frequency. For example, the decorator may invert the result state of its child, similarly to the NOT operator, or it can repeat the execution of the child for a given number of times. Decorators have only a single child and are represented graphically by rhombuses.\n\u2013 Action: action nodes are obligatorily leaves, they do not propagate the tick signal. Instead, they perform some computation to change the environment or the internal state of the system, and return a state value. Actions of a robot may involve sending signals to the engines, playing sound through speakers or turning on lights, while the actions of a NPC may involve executing animations, performing spatial transformations, playing sounds, etc. Actions are represented graphically by rectangles.\n\u2013 Condition: like action nodes, conditions are obligatorily leaves and perform some computation instead of propagating the tick signal. The difference is that, a condition node does not change the environment or any internal variable in the system, it only checks whether a certain condition has been met or not. To accomplish that, the node commonly has a target variable and a criterion to base the decision. Examples of condition nodes: \u201cis obstacle close?\u201d, \u201cis other agent visible?\u201d, \u201cis battery low?\u201d or \u201cam I hungry?\u201d. Conditions are represented graphically by ellipses.\nAn action returns SUCCESS if it could be completed; it returns FAILURE if, for any reason, it could not be finished; or returns RUNNING if the action is still executing. A condition node returns SUCCESS if the condition has been met, otherwise it returns FAILURE. It never return RUNNING. Composite and\n1 We also use a special state called ERROR, which is always propagated immediately back to the root (similar to RUNNING). This state is not always described as part of BTs core, but sometimes is useful for debugging.\nDecorators handle SUCCESS and FAILURE differently, but, in general, they return RUNNING as soon as they receive it.\nThere are no common core decorator, action or condition node type, they depend on the task. However, there are five core composite node types: Sequence, Priority, MemSequence, MemPriority and Parallel. Figure 2 shows the visual of these nodes. There can be other types depending on the application of the model, but these are generic and necessary nodes to build a complete controller [9]. Each node type works in a specific way:\n\u2013 Sequence: when a Sequence node is ticked, it propagates the tick signal to its children sequentially. If any child returns FAILURE or RUNNING, the Sequence stops the propagation and returns the received state. However, if all Sequence children return SUCCESS, the Sequence also returns SUCCESS. This node is represented graphically by an arrow \u2192. \u2013 Priority: a Priority node (sometimes called Selector) also propagates the tick signal to its children sequentially when the node is ticked. If any child returns SUCCESS or RUNNING, the Priority stops the propagation and returns the received state. If all children return FAILURE, the Priority also returns FAILURE. This node is represented graphically by a question marker ?. \u2013 MemSequence: the MemSequence is a version of Sequence with memory. It works in a similar way to Sequence, but when a child i returns RUNNING, the MemSequence node will not propagate the next tick to nodes preceding i (i.e., it will only tick i, i+ 1, i+M). This node is represented graphically by an arrow \u2192 together with an asterisk \u2217. \u2013 MemPriority: MemPriority is the memory version of Priority. It does the same as MemSequence does for Sequence. This node is represented graphically by a question marker ? together with an asterisk \u2217. \u2013 Parallel: when a Parallel node is ticked, it propagates the tick to all its children at the same time. Then it returns SUCCESS if S children or more return SUCCESS ; it returns FAILURE if F or more return FAILURE. Otherwise, it returns RUNNING. This node is represented graphically by a double arrow \u21d2.\nNotice that, with the exception of Parallel, all composite nodes propagate the tick sequentially, creating the notion of priority among behaviors in the tree. There are two common ways to represent a Behavior Tree in a 2D layout: horizontally and vertically. A composite node ticks its children from left to right\nin a vertical view, or from top to bottom in a horizontal view. Expanding this idea, we can say that the left/top branch of the tree (starting from the root) is the behavior with the highest priority, while the right/bottom branch of the tree has the lowest priority. This characteristic is essential for a controller, e.g., avoiding collisions or falls is more important than exploring the environment. Please refer to the figures at Section 5 to real examples of a Behavior Tree model."}, {"heading": "3 Reinforcement Learning", "text": "We address the problem of adding capacity of learning to an agent that acts without supervision from experts (i.e., input-output pairs are never presented) in real-time applications (i.e., it must learn continuously) and preferably in an online fashion (i.e., update the model upon the arrival of a new piece of information). This problem can be formulated as a Markov Decision Process (MDP) problem, which is the common basis for the Reinforcement Learning task.\nIn an MDP problem, a learning agent interacts with an environment with discrete time steps t = 1, 2, 3, .... On each time step, the agent observes the system state st \u2208 S and performs and action at \u2208 Ast , where As is a finite and non-empty set of admissible actions for a state s. As consequence of the agent action, the system generates a reward rt+1 according to an expected immediate reward function R(s, a) = E{rt+1|st = s, at = a} and a next state st+1 with a transition probability of P (s\u2032|s, a) = P (st+1 = s\u2032|st = s, at = a). The goal of the agent is to learn a policy \u03c0 : S \u00d7 A \u2192 [0, 1], where A =\u22c3 s\u2208S As (the set of all actions), that maximizes the expected discounted future reward from each state s [15]:\nV \u03c0(s) = E{rt+1 + \u03b3rt+2 + \u03b32rt+3 + . . . |\u03c0, st = s} (1) = E{rt+1 + \u03b3V \u03c0(st+1)|\u03c0, st = s}\n= \u2211 a\u2208As \u03c0(s, a)\n[ R(s, a) + \u03b3\n\u2211 s\u2032 P (s\u2032|s, a)V \u03c0(s\u2032)\n] , (2)\nwhere \u03c0(s, a) is the probability of a policy \u03c0 choosing an action a in the state s, and \u03b3 \u2208 [0, 1] is a discount-rate parameter. V \u03c0(s) is called the value function for \u03c0, and denotes the value of the state s when following a policy \u03c0. An optimal\npolicy \u03c0\u2217 is any policy that corresponds to the unique optimal value function V \u2217(s), defined as:\nV \u2217(s) = max \u03c0 V \u03c0(s) (3)\n= max a\u2208As\nE{rt+1 + \u03b3V \u03c0(st+1)|st = s, at = a}\n= max a\u2208As\n[ R(s, a) + \u03b3\n\u2211 s\u2032 P (s\u2032|s, a)V \u2217(s\u2032)\n] . (4)\nUnfortunately, the only solutions to Equations 2 and 4 are the Equations 1 and 3 [14], respectively, which cannot be computed without knowing R(s, a) and P (s\u2032|s, a). Alternatively, we can define a state value function Q\u03c0(s, a) that works upon pairs of states and actions, rather than just states. Q\u03c0(s, a) denotes the value of taking an action a while in a state s under a policy \u03c0, therefore:\nQ\u03c0(s, a) = E{rt+1 + \u03b3rt+2 + \u03b32rt+3 + . . . |\u03c0, st = s, at = a} = R(s, a) + \u03b3 \u2211 s\u2032 P (s\u2032|s, a)V \u03c0(s\u2032)\n= R(s, a) + \u03b3 \u2211 s\u2032 P (s\u2032|s, a) \u2211 a\u2032 \u03c0(s\u2032, a\u2032)Q\u03c0(s\u2032, a\u2032),\nand its respectively optimal value Q\u2217(s, a):\nQ\u2217(s, a) = max \u03c0 Q\u03c0(s, a) = R(s, a) + \u03b3 \u2211 s\u2032 P (s\u2032|s, a) max a\u2032 Q\u2217(s\u2032, a\u2032).\nSupposing that at each state s, the agent performs an action a and receives a reward r, and then observes the new state s\u2032. We can approximate Q\u2217(s, a) by updating an estimate Qk(s, a):\nQk+1(s, a) = (1\u2212 \u03b1k)Qk(s, a) + \u03b1k [ r + \u03b3 max\na\u2032\u2208As\u2032 Qk(s\n\u2032, a\u2032) ] , (5)\nwhere \u03b1k is a time-varying learning-rate parameter. This process is called Qlearning, which is a classical and widely used Reinforcement Learning algorithm. With this update process, Qk converges to Q\n\u2217 with probability 1 if at the limit, all admissible state-action pairs are updated infinitely often, and \u03b1k decays with time, regardless of the policy being followed [14][1]."}, {"heading": "3.1 Hierarchical Reinforcement Learning", "text": "While most classical reinforcement learning relies on the configuration described by MDPs, Hierarchical Reinforcement Learning (HRL) models have their basis\non Semi Markov Decision Processes (SMDPs) [1]. Due to the generalization of SMDPs, these hierarchical models are able to explore the temporal aspects of the tasks and reduce the impact of the curse of dimensionality by splitting the task space into several subproblems.\nIn a SMDP, the learning agent considers the time during transition between states. This means that, when observing a state s, an agent performs an action a that takes \u03c4 time steps2 to move to a new state s\u2032. Now, the joint probability is rewritten to P (s\u2032, \u03c4 |s, a) and the expected immediate reward function R(s, a) now gives the amount of discounted reward expected to accumulate over the waiting time in s given a [1]. Equations for the optimal value function V \u2217 and the optimal state value function Q\u2217 are also rewritten to:\nV \u2217(s) = max a\u2208As R(s, a) +\u2211 s\u2032,\u03c4 \u03b3\u03c4P (s\u2032, \u03c4 |s, a)V \u2217(s\u2032)  , (6) and\nQ\u2217(s, a) = R(s, a) + \u2211 s\u2032,\u03c4 \u03b3\u03c4P (s\u2032, \u03c4 |s, a) max a\u2032 Q\u2217(s\u2032, a\u2032), (7)\nrespectively. One successful approach based on SMDPs is the Option framework proposed in (Sutton et al., 1999). An option is a generalization of an action in a way that it can call other options upon the execution, creating the idea of a hierarchy. When an option is initiated, it can call another option, then this new option can call another one, and so on until it finds a primitive option (the actions of the MDP framework). An option can be defined as 3-tuple \u3008I, \u00b5, \u03b2\u3009, consisting of an input set I \u2286 S, a semi-Markov policy \u00b5 : S \u00d7O \u2192 [0, 1] (where O = \u22c3 s\u2208S Os), and a termination condition \u03b2 : S \u2192 [0, 1]. A given option can only be initiated if, and only if, the current state s is an element of I. While executing, it chooses the next option o with probability \u00b5(s, o), the environment changes to state s\u2032, where the option terminates with probability \u03b2(s\u2032). Notice that \u00b5 is a semi-Markov policy over policies, i.e., it can choose the next option based on the entire history h of states, actions, and rewards since the option was initiated [1].\nWith this approach, the option-value function for \u00b5 is:\nQ\u00b5(s, o) = E{rt+1 + \u03b3rt+2 + . . .+ \u03b3\u03c4\u22121rt+\u03c4 + . . . |E(o\u00b5, s, t)}, (8) where E(o\u00b5, s, o) is the event of \u00b5 being initiated at time t in s, and o\u00b5 is the semi-Markov policy that follows o until it terminates after \u03c4 time steps and then continues according to \u00b5. Respectively, the optimal function are rewritten to:\nQ\u2217O(s, o) = R(s, o) + \u2211 s\u2032 P (s\u2032|s, o) max o\u2032\u2208Os\u2032 Q\u2217O(s \u2032, o\u2032), (9)\n2 Here, we assume \u03c4 to be discrete, but it can be extended to continuous without much impact [1]\nwhere:\nP (s\u2032|s, o) = \u221e\u2211 \u03c4=1 p(s\u2032, \u03c4)\u03b3\u03c4 (10)\nfor all s \u2208 S, where p(s\u2032, \u03c4) is the probability that o terminates in s\u2032 after \u03c4 steps when initiated in state s. The corresponding Q-learning update is:\nQk+1(s, o) = (1\u2212 \u03b1k)Qk(s, o) + \u03b1k [ r + \u03b3\u03c4 max\no\u2032\u2208Os\u2032 Qk(s\n\u2032, o\u2032) ] , (11)"}, {"heading": "4 Learning Framework", "text": "We propose a framework for modeling agents that follow behaviors strictly as modeled by a human expert, and still are able to learn from experience. This framework allows an expert to manually define which behaviors an agent will have, to specify when and in which order the behaviors will be executed, and to specify where learning can be applied. Behavior Trees are used as the base modeling tool for our framework, due to their advantages such as described in Section 2. In summary, BTs are compact, easy to understand, maintain and reuse, they scale well, have expressive power and can be easily parallelized. We also adopt Reinforcement Learning in order to support our modeling tool, providing the capacity to learn in real time with the agent experiences. With RL, agents can optimize actions in specific situations and be able to adapt to changes on the environment configuration and dynamics.\nIn order to make Reinforcement Learning work together with Behavior Trees we propose the use of Learning Nodes. Within this approach, Reinforcement Learning can be embedded into Behavior Trees in a modular and reusable way. We propose two uses of these custom nodes: as action and as composite.\nIn the Learning Action Node, the expert must choose how to represent the state s, the actions A, and the reward r, according to the task. Suppose, for example, a robot with an action node to \u201cgrab an object\u201d. This node can use RL in order to learn how to grab different kinds of objects or improve how to grab a known object in different positions. In this case, the state could be the position of the object relative to the robot\u2019s hand, the actions could be the different joint configurations in the robot\u2019s arm, and the reward function would return a positive value if the robot could grab the object, otherwise it would return a negative value.\nIn the Learning Composite Node, the expert must also choose how to represent the state s, but the actions A are the children of the composite node. So, given a state s, the Learning Composite Node selects among the N children c1, c2, . . . , cN . The reward function could be provided according to the task or it could use the state value returned from children ticks (i.e., positive reward for SUCCESS and negative reward for FAILURE ).\nAs an application example of a Learning Composite Node, consider an agent in a life simulation. The agent has 5 major behaviors (those which are connected\ndirectly to the root\u2019s unique child): \u201cfind food\u201d, \u201ceat\u201d, \u201crest\u201d, \u201chide\u201dand \u201crun from predators\u201d. These behaviors can be simple action nodes or complex subtrees with several other nodes. For this example, the goal of this agent is to learn when to use these behaviors in order to maximize the chance to survive. In this case, these behaviors would be children of a Learning Composite Node, thus being the actions A. The state s could be a series of variables, such as the presence of predator, distance from food, hungry level, health level, etc. The reward function of this example could the a combination of one or more variables, such as the hungry level, fatigue, health level, etc.\nTo make a formal definition of these two nodes, we exploit the Options approach for Hierarchical Reinforcement Learning. Reminding that an option \u3008I, \u00b5, \u03b2\u3009 is only initiated if the state s \u2208 I, and while executing the option uses the policy \u00b5 to decide which option o (action) will be executed, based on the history h of past states, actions and rewards since the beginning of execution of that option. After that, the environment generates a new state s\u2032 with probability P (s\u2032|s, o). We argue that, the Behavior Tree defined here can be modeled as a specialization of an Option-based Hierarchical Reinforcement Learning.\nTheorem 1. A Behavior Tree with core nodes is a specialization of Options in Hierarchical Reinforcement Learning.\nProof. Following the definition presented in Section 3, an option has the following characteristics: 1) it is a hierarchical combination of other options or it is a primitive option (action of MDP); 2) it has an input set I, a termination condition \u03b2 and a policy \u00b5; 3) the policy \u00b5 can choose other options based on the history h of past states, actions and rewards since the beginning of execution of that option. In Section 2, we defined a hierarchical behavior exactly as an option. All nodes in a BT have an input set I = S because they are not evaluated before the execution, thus the input set is equal to the whole state set. All nodes also have a termination condition \u03b2 defined by each node type (e.g., the termination condition of a Priority node is: one child returning SUCCESS or all children returning FAILURE ). Composite and decorator nodes have a fixed policy \u00b5 that always calls children sequentially, while actions and conditions are related to primitive options (does not have a policy, instead they perform some interaction with the environment). The core composite nodes depend on the temporal aspect of SMDPs, because their selection of a child ci depends the execution of all children c0, . . . , ci\u22122, ci\u22121.\nGiven this theorem, we can define:\nDefinition 1. A Learning Composite Node can be seen as an option with I = S, with children c1, c2, . . . , cN as possible actions, a termination condition \u03b2 = 1 if Tick(ci) \u2208 {SUCCESS, FAILURE}, and a policy \u00b5 to be learned.\nand\nDefinition 2. A Learning Action Node can be seen as an option with I = S, with actions a \u2208 As, a termination condition \u03b2, and a policy \u00b5 to be learned.\nAs result from Theorem 1, we can also exploit the features provided from the Options framework [14], such as: both learning nodes can be trained using Q-Learning; guarantee of convergence for nested nodes with the same conditions to a single Q-Learning model; due to the division of the space, the nodes can converge faster than a single learning model; nodes can be interrupted by prioritized behaviors without problem; intra-option learning can be used to speed up global convergence among the tree."}, {"heading": "5 Experimental Validation", "text": "In this Section, we present two simulated fire control scenarios to validate empirically the proposed framework. The following experiments use discrete state and action Q-Learning in the Learning Nodes. However, continuous versions of Q-Learning could be used. We also used the Behavior3 library and editor [13] for modeling the Behavior Trees. All experiments and custom code are available online3.\nBoth experiments execute 30 trials, each with 400 iterations. At the beginning of each trial the experiment is reset. All charts show the average results of the 30 trials. The environment is divided into infinite rooms. In each room, the agent can perform 3 possible actions: save victim, use extinguisher X and change room. Any given room has 50% of chance to have a victim in the wreckage; if there is a victim, the agent must save it first. A room also has 50% of chance to have one of 3 types of fire (types 1, 2 and 3, with 1/3 chance each); if there is a fire, the agent must extinguish it before leaving the room and after saving the victim. There are 3 types of extinguishers (types A,B and C), each extinguisher can extinguish only one type of fire, randomly chosen in the beginning of the trial; this map is unknown to the agent. If the room has no victim and no fire, the agent must go to the next room. If, at any moment, the wrong extinguisher is used, the room is lost and the agent must change to the next room."}, {"heading": "5.1 Scenario 1", "text": "In this scenario, all actions are instantly. Figure 3 shows the Behavior Tree that models the learning agent. Notice that, after the root child, there are three branches: the first, with highest priority, represents the behavior save victim; the second branch, represents use extinguisher X ; and the last branch, with lowest priority, represents change room.\nWe use a learning action node for use extinguisher X behavior. This node must learn which extinguisher can be used for each fire type; it is configured to receive the state s = \u3008fire type\u3009, where fire type = {1, 2, 3}, and with actions a = {A,B,C}; this node also receives the reward of +10 if it could extinguish the fire and \u221210 otherwise.\nTable 1 shows the ratio between the correct activations of the three main behaviors over the total expected activations (i.e., the accuracy for behavior\n3 All code will be available in http://renatopp.com/research after revision.\nusage). All behaviors are called correctly 100% of the time, this is due to the tree dynamics that allow the expert to model a strict sequence of behaviors. Notice that, this table also shows that the learning node (Use Extinguisher) does not affect the execution of other behaviors in the tree. Figure 4 shows the convergence of the node\u2019s accuracy during the experiment, compared with the random baseline."}, {"heading": "5.2 Scenario 2", "text": "In this scenario, we add more complexity to the task. The agent actions save victim and use extinguisher X now take time to complete, depending on the\nfire intensity. Any given fire has an intensity fire intensity \u2208 {1, 2, 3}, chosen randomly for each room. The fire intensity specifies how many ticks the agent needs to perform the actions (i.e., when fire intensity is 0, all actions are instantly; when it is 1, actions take 1 tick to be completed; and so on). The fire intensity is reduced by 1 each tick when the right extinguisher is being used. Notice that change room is always instantly and the use of the wrong extinguisher makes the agent lose the room.\nFigure 5 shows the Behavior Tree that models the learning agent for this scenario. Now, it uses 2 learning nodes. The first, similar to the one used in the first scenario, is a learning action using the state s = \u3008fire type\u3009, where fire type = {1, 2, 3}, and actions a = {A,B,C}; this node receives the reward of 10fire intensity while using the right extinguisher (i.e., +10 when the fire is extinguished), and \u221210 if the wrong extinguisher is used.\nThe second learning node is the root child, which must learn which behavior must be executed given the state s = \u3008has victim? , has fire? \u3009. The node\u2019s children are the actions a = {save victim, use extinguisher , change room}. This\nnode receives the rewards: \u221210 if the node tries to save and there is no victim, \u22121 while saving the victim, and +10 when the victim is saved; \u221210 if trying to extinguish a non-existing fire, \u22121 while extinguishing it, and +10 when the fire is extinguished; and +10 when the agent leaves the room at the right moment and \u221210 otherwise.\nAgain, Table 2 shows the accuracy of the behavior usage. In this case, behaviors are called correctly 97% to 99% of the time, differing from the previous result in scenario 1. This difference is because the learning process needs a step of trial and error to learn the most effective behavior. Figure 6 shows the convergence of both node\u2019s accuracy during the experiment compared with the random baseline."}, {"heading": "6 Related Work", "text": "Behavior Trees were created as alternative to Hierarchical Finite State Machines (HFSMs) and similar methods, aiming to provide more flexible controller for Non-Playable Characters (NPCs) in video games [7]. The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.\nWe base our developments on the work of (Marzinotto et al., 2014), where the authors prove the relation of Behaviors Trees to Controlled Hybrid Dynamical Systems (CHDSs). Our work has some differences to theirs. Firstly, we define the Behavior Tree as a Directed Rooted Tree (DRT) and not as a Directed Acyclic Graph (DAG) because we consider that multi parenting is only done in the\nimplementation level, not in the modeling level. We also prefer the term Priority over Selector, due to the similarity to the Sequence node. We also consider MemSequence and MemPriority as core nodes and not extension to core nodes. Different from almost all descriptions of BTs, we represent the model graphically in a horizontal layout due to legibility and space. In our layout, the priority is given from top to bottom.\nNaturally, this is not the first time a custom node is proposed to Behavior Trees. For example, (Johansson et al., 2012) proposed an emotional node which uses an \u201cemotion function\u201d to sort the node\u2019s children according to the agents feelings; (Palma et al., 2011) and (Florez-Puga et al., 2009) propose a query node that looks for possible subtrees in a Case-Based Reasoning (CBR) systems, resulting in dynamic trees. As far as we known, there is no use of a custom learning node neither the use of Reinforcement Learning with Behaviors Trees in the current literature.\nWe show that our framework has a close relation to the Options framework [15], but it has also similarities to other models of Hierarchical Reinforcement Learning, such as the Hierarchies of Abstract Machines [12] and the MAXQ model [5]. As a general case, authors in Hierarchical Reinforcement Learning area see the manual division of behaviors as a problem to be dealt while we use this as an intrinsic part of our approach, i.e., the manual definition of behaviors is viewed as a mean to use prior and expert knowledge of the problem."}, {"heading": "7 Conclusion", "text": "We have proposed a framework to use Reinforcement Learning in behavior-based agents, providing adaptiveness to physical or virtual agents while respecting the constraints modeled by the expert. Based on Behavior Trees, we proposed the creation of a new type of Composite and Action node, called Learning Node, in which we embed a Q-Learning algorithm to perform a local learning, without affecting how other nodes work. We show that this framework is related to Hierarchical Reinforcement Learning, being a specialization of the Options framework, thus ensuring convergence of nested learning nodes, allowing them to be interrupted before the task is completed and allowing the use of intraoption learning for more complex models.\nWe also validate our framework empirically using experiments in simulated fire control scenarios. The experiments show how to use the expert knowledge to model the behavior choices without interference of the learning nodes, and confirms that nested learning nodes can converge and work with temporal actions.\nThis framework provides the formalization needed to expand the research on adaptive and constrained behavior-based agents using Behavior Trees and Reinforcement Learning. We expect to further improve this framework by extending it with capabilities for working in non-stationary and continuous state space, allowing us to create agents for more complex environments."}, {"heading": "Acknowledgment", "text": "The authors thank Edigleison Carvalho and Thiago Rodrigues for their valuable input on this paper. This work is supported by CNPq, a Brazilian government entity for scientific and technological development."}], "references": [{"title": "Recent advances in hierarchical reinforcement learning", "author": ["A.G. Barto", "S. Mahadevan"], "venue": "Discrete Event Dynamic Systems 13(4), 341\u2013379", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2003}, {"title": "Adaptive fault tolerant execution of multi-robot missions using behavior trees", "author": ["M. Colledanchise", "A. Marzinotto", "D.V. Dimarogonas", "P. \u00d6gren"], "venue": "arXiv preprint arXiv:1502.02960", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "Performance analysis of stochastic behavior trees", "author": ["M. Colledanchise", "A. Marzinotto", "P. Ogren"], "venue": "Robotics and Automation (ICRA), 2014 IEEE International Conference on. pp. 3265\u20133272. IEEE", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "How behavior trees modularize robustness and safety in hybrid systems", "author": ["M. Colledanchise", "P. Ogren"], "venue": "Intelligent Robots and Systems (IROS 2014), 2014 IEEE/RSJ International Conference on. pp. 1482\u20131488. IEEE", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Hierarchical reinforcement learning with the maxq value function decomposition", "author": ["T.G. Dietterich"], "venue": "J. Artif. Intell. Res.(JAIR) 13, 227\u2013303", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Query-enabled behavior trees", "author": ["G. Fl\u00f3rez-Puga", "M.A. G\u00f3mez-Mart\u0301\u0131n", "P.P. G\u00f3mez-Mart\u0301\u0131n", "B. D\u0131\u0301az-Agudo", "P.A. Gonz\u00e1lez-Calero"], "venue": "Computational Intelligence and AI in Games, IEEE Transactions on 1(4), 298\u2013308", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2009}, {"title": "proceeding: Handling complexity in the halo 2 ai (March 2005), http://www.gamasutra.com/view/feature/130663/gdc_2005_ proceeding_handling_.php, last access", "author": ["D. Isla"], "venue": "Gdc", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2005}, {"title": "Emotional behavior trees", "author": ["A. Johansson", "P. Dell\u2019Acqua"], "venue": "Computational Intelligence and Games (CIG), 2012 IEEE Conference on. pp. 355\u2013362. IEEE", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Towards a unified behavior trees framework for robot control", "author": ["A. Marzinotto", "M. Colledanchise", "C. Smith", "P. Ogren"], "venue": "Robotics and Automation (ICRA), 2014 IEEE International Conference on. pp. 5420\u20135427. IEEE", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2014}, {"title": "Increasing modularity of uav control systems using computer game behavior trees", "author": ["P. Ogren"], "venue": "AIAA Guidance, Navigation and Control Conference, Minneapolis, MN", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Extending case-based planning with behavior trees", "author": ["R. Palma", "P.A. Gonz\u00e1lez-Calero", "M.A. G\u00f3mez-Mart\u0301\u0131n", "P.P. G\u00f3mez-Mart\u0301\u0131n"], "venue": "FLAIRS Conference", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2011}, {"title": "Reinforcement learning with hierarchies of machines", "author": ["R. Parr", "S. Russell"], "venue": "Advances in neural information processing systems pp. 1043\u20131049", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1998}, {"title": "http://behavior3.com/, last access on 201503-05", "author": ["Pereira", "R.d.P"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "Reinforcement learning: An introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": "MIT Press, Cambridge, MA, USA, 1st edn.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1998}, {"title": "Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning", "author": ["R.S. Sutton", "D. Precup", "S. Singh"], "venue": "Artificial intelligence 112(1), 181\u2013211", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}], "referenceMentions": [{"referenceID": 6, "context": "This tool was created in the game industry [7] with fast adoption by the game development community.", "startOffset": 43, "endOffset": 46}, {"referenceID": 9, "context": "Since 2012, there are some efforts to apply BTs on robotics, including modeling and controlling of UAVs [10], fault tolerance in hybrid and multi-robot systems [4][2] and an attempt to unify notation and formalize Behavior Trees as controller, proving the relation to CHDSs (Controlled Hybrid Dynamical Systems) [9].", "startOffset": 104, "endOffset": 108}, {"referenceID": 3, "context": "Since 2012, there are some efforts to apply BTs on robotics, including modeling and controlling of UAVs [10], fault tolerance in hybrid and multi-robot systems [4][2] and an attempt to unify notation and formalize Behavior Trees as controller, proving the relation to CHDSs (Controlled Hybrid Dynamical Systems) [9].", "startOffset": 160, "endOffset": 163}, {"referenceID": 1, "context": "Since 2012, there are some efforts to apply BTs on robotics, including modeling and controlling of UAVs [10], fault tolerance in hybrid and multi-robot systems [4][2] and an attempt to unify notation and formalize Behavior Trees as controller, proving the relation to CHDSs (Controlled Hybrid Dynamical Systems) [9].", "startOffset": 163, "endOffset": 166}, {"referenceID": 8, "context": "Since 2012, there are some efforts to apply BTs on robotics, including modeling and controlling of UAVs [10], fault tolerance in hybrid and multi-robot systems [4][2] and an attempt to unify notation and formalize Behavior Trees as controller, proving the relation to CHDSs (Controlled Hybrid Dynamical Systems) [9].", "startOffset": 312, "endOffset": 315}, {"referenceID": 8, "context": "There can be other types depending on the application of the model, but these are generic and necessary nodes to build a complete controller [9].", "startOffset": 141, "endOffset": 144}, {"referenceID": 0, "context": "The goal of the agent is to learn a policy \u03c0 : S \u00d7 A \u2192 [0, 1], where A = \u22c3 s\u2208S As (the set of all actions), that maximizes the expected discounted future reward from each state s [15]:", "startOffset": 55, "endOffset": 61}, {"referenceID": 14, "context": "The goal of the agent is to learn a policy \u03c0 : S \u00d7 A \u2192 [0, 1], where A = \u22c3 s\u2208S As (the set of all actions), that maximizes the expected discounted future reward from each state s [15]:", "startOffset": 179, "endOffset": 183}, {"referenceID": 0, "context": "where \u03c0(s, a) is the probability of a policy \u03c0 choosing an action a in the state s, and \u03b3 \u2208 [0, 1] is a discount-rate parameter.", "startOffset": 92, "endOffset": 98}, {"referenceID": 13, "context": "Unfortunately, the only solutions to Equations 2 and 4 are the Equations 1 and 3 [14], respectively, which cannot be computed without knowing R(s, a) and P (s\u2032|s, a).", "startOffset": 81, "endOffset": 85}, {"referenceID": 13, "context": "With this update process, Qk converges to Q \u2217 with probability 1 if at the limit, all admissible state-action pairs are updated infinitely often, and \u03b1k decays with time, regardless of the policy being followed [14][1].", "startOffset": 211, "endOffset": 215}, {"referenceID": 0, "context": "With this update process, Qk converges to Q \u2217 with probability 1 if at the limit, all admissible state-action pairs are updated infinitely often, and \u03b1k decays with time, regardless of the policy being followed [14][1].", "startOffset": 215, "endOffset": 218}, {"referenceID": 0, "context": "on Semi Markov Decision Processes (SMDPs) [1].", "startOffset": 42, "endOffset": 45}, {"referenceID": 0, "context": "Now, the joint probability is rewritten to P (s\u2032, \u03c4 |s, a) and the expected immediate reward function R(s, a) now gives the amount of discounted reward expected to accumulate over the waiting time in s given a [1].", "startOffset": 210, "endOffset": 213}, {"referenceID": 0, "context": "An option can be defined as 3-tuple \u3008I, \u03bc, \u03b2\u3009, consisting of an input set I \u2286 S, a semi-Markov policy \u03bc : S \u00d7O \u2192 [0, 1] (where O = \u22c3 s\u2208S Os), and a termination condition \u03b2 : S \u2192 [0, 1].", "startOffset": 113, "endOffset": 119}, {"referenceID": 0, "context": "An option can be defined as 3-tuple \u3008I, \u03bc, \u03b2\u3009, consisting of an input set I \u2286 S, a semi-Markov policy \u03bc : S \u00d7O \u2192 [0, 1] (where O = \u22c3 s\u2208S Os), and a termination condition \u03b2 : S \u2192 [0, 1].", "startOffset": 178, "endOffset": 184}, {"referenceID": 0, "context": ", it can choose the next option based on the entire history h of states, actions, and rewards since the option was initiated [1].", "startOffset": 125, "endOffset": 128}, {"referenceID": 0, "context": "2 Here, we assume \u03c4 to be discrete, but it can be extended to continuous without much impact [1]", "startOffset": 93, "endOffset": 96}, {"referenceID": 13, "context": "As result from Theorem 1, we can also exploit the features provided from the Options framework [14], such as: both learning nodes can be trained using Q-Learning; guarantee of convergence for nested nodes with the same conditions to a single Q-Learning model; due to the division of the space, the nodes can converge faster than a single learning model; nodes can be interrupted by prioritized behaviors without problem; intra-option learning can be used to speed up global convergence among the tree.", "startOffset": 95, "endOffset": 99}, {"referenceID": 12, "context": "We also used the Behavior3 library and editor [13] for modeling the Behavior Trees.", "startOffset": 46, "endOffset": 50}, {"referenceID": 6, "context": "Behavior Trees were created as alternative to Hierarchical Finite State Machines (HFSMs) and similar methods, aiming to provide more flexible controller for Non-Playable Characters (NPCs) in video games [7].", "startOffset": 203, "endOffset": 206}, {"referenceID": 9, "context": "The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.", "startOffset": 102, "endOffset": 106}, {"referenceID": 8, "context": "The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.", "startOffset": 107, "endOffset": 110}, {"referenceID": 2, "context": "The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.", "startOffset": 111, "endOffset": 114}, {"referenceID": 3, "context": "The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.", "startOffset": 115, "endOffset": 118}, {"referenceID": 1, "context": "The method had a quick acceptance in the game industry and, recently, it has been applied to robotics [10] [9] [3] [4] [2], where BTs received a more formal and standard definition.", "startOffset": 119, "endOffset": 122}, {"referenceID": 14, "context": "We show that our framework has a close relation to the Options framework [15], but it has also similarities to other models of Hierarchical Reinforcement Learning, such as the Hierarchies of Abstract Machines [12] and the MAXQ model [5].", "startOffset": 73, "endOffset": 77}, {"referenceID": 11, "context": "We show that our framework has a close relation to the Options framework [15], but it has also similarities to other models of Hierarchical Reinforcement Learning, such as the Hierarchies of Abstract Machines [12] and the MAXQ model [5].", "startOffset": 209, "endOffset": 213}, {"referenceID": 4, "context": "We show that our framework has a close relation to the Options framework [15], but it has also similarities to other models of Hierarchical Reinforcement Learning, such as the Hierarchies of Abstract Machines [12] and the MAXQ model [5].", "startOffset": 233, "endOffset": 236}], "year": 2015, "abstractText": "Behavior Trees are commonly used to model agents for robotics and games, where constrained behaviors must be designed by human experts in order to guarantee that these agents will execute a specific chain of actions given a specific set of perceptions. In such application areas, learning is a desirable feature to provide agents with the ability to adapt and improve interactions with humans and environment, but often discarded due to its unreliability. In this paper, we propose a framework that uses Reinforcement Learning nodes as part of Behavior Trees to address the problem of adding learning capabilities in constrained agents. We show how this framework relates to Options in Hierarchical Reinforcement Learning, ensuring convergence of nested learning nodes, and we empirically show that the learning nodes do not affect the execution of other nodes in the tree.", "creator": "LaTeX with hyperref package"}}}