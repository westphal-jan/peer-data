{"id": "1511.08205", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Nov-2015", "title": "Breaking Symmetries in Graph Search with Canonizing Sets", "abstract": "there are many complex combinatorial problems which involve searching for an undirected graph satisfying given constraints. such problems are often highly challenging with of the fewer number of isomorphic representations of their solutions. seminal paper covers effective and compact, complete symmetry breaking constraints for small graph search. enumerating for these symmetry breaks generates necessary and only non - isomorphic solutions. for small search problems, with up to $ 10 $ vertices, we compute instance independent carroll breaking systems. for small search problems with a larger number of vertices we demonstrate the relevance of page dependent constraints which are complete. we illustrate the application including complete symmetry breaking mechanisms to finding two known sequences from isolated oeis related to graph numeration.", "histories": [["v1", "Wed, 25 Nov 2015 06:26:33 GMT  (19kb,D)", "http://arxiv.org/abs/1511.08205v1", null], ["v2", "Thu, 4 Feb 2016 03:05:24 GMT  (25kb,D)", "http://arxiv.org/abs/1511.08205v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DM", "authors": ["avraham itzhakov", "michael codish"], "accepted": false, "id": "1511.08205"}, "pdf": {"name": "1511.08205.pdf", "metadata": {"source": "CRF", "title": "Breaking Symmetries in Graph Search with Canonizing Sets", "authors": ["Avraham Itzhakov", "Michael Codish"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Graph search problems are about the search for a graph which satisfies a given set of constraints, or to determine that no such graph exists. Often graph search problems are about the search for the set of all graphs, modulo graph isomorphism, that satisfy the given constraints. Graph search problems are typically invariant under graph isomorphism. Namely, if G is a solution, then any graph obtained by permuting the vertices of G is also a solution. When seeking solutions, the size of the search space is significantly reduced if symmetries are eliminated. The search space can be explored more efficiently when avoiding paths that lead to symmetric solutions and avoiding also those that lead to symmetric non-solutions.\nOne common approach to eliminate symmetries is to introduce symmetry breaking constraints [24,11,28,29] which rule out isomorphic solutions thus reducing the size of the search space while preserving the set of solutions. Ideally, a symmetry breaking constraint is satisfied by a single member of each equivalence class of solutions, thus drastically restricting the search space. However, computing such symmetry breaking constraints is, most likely, intractable in general [11]. In practice, symmetry breaking constraints typically rule out some, but not all of the symmetries in the search and, as noted in the survey by Walsh [30], often a few simple constraints rule out most of the symmetries.\nShlyakhter [28] notes that the core difficulty is to identify a symmetrybreaking predicate which is both effective (rules out a large portion of the search\nar X\niv :1\n51 1.\n08 20\n5v 1\n[ cs\n.A I]\n2 5\nN ov\n2 01\nspace) and compact (so that checking the additional constraints does not slow down the search). In [10], Codish et al. introduce a symmetry breaking constraint for graph search problems. Their constraint is compact, with size polynomial in the number of graph vertices, and shown to be effective but it does not eliminate all of the symmetries in the search.\nThere is a large body of research that concerns identifying symmetries in a given graph. In this setting, finding symmetries is about detecting graph automorphisms. A typical application is in the context of SAT solving as described for example in [4,2,13,15,14]. In this paper the setting is different as the graph is not given but rather is the subject of the search problem.\nIn this paper we adopt the following terminology. Symmetry breaking constraints that break all of the symmetries, or more precisely, that guarantee that no two solutions are isomorphic (graphs), are called complete. Symmetry breaking constraints which are not complete are called partial. If a symmetry breaking constraint guarantees that solutions are canonical then it is called canonizing. Note that canonizing symmetry breaking constraints are also complete.\nComputing all solutions to a graph search problem with partial symmetry breaking constraints is a two step process. First one generates the set S of solutions to the constraints, and then one applies a graph isomorphism tool, such as nauty [18] to reduce S modulo isomorphism. Often, the number of solutions in the first step is very large and then this method may fail to generate the initial set of solutions.\nThis paper is about the computation of canonizing (complete) symmetry breaking constraints for \u201csmall\u201d graph search problems. Consider for example the search for a graph with n = 10 vertices. The search space consists of 245 graphs, whereas, there are only 12 005 168 such graphs modulo isomorphism (see sequence A000088 of the OEIS [23]). In theory, to break all symmetries one could construct a symmetry breaking constraint that considers all 10! = 3,628,800 permutations of the vertices. We will show how to construct a compact canonizing (complete) symmetry breaking constraint for graph search problems on 10 vertices using only 7853 permutations.\nIn general, our first technique is, in the terminology of [3], \u201cinstance independent\u201d and applies to break all symmetries in graph search problems on up to 10 vertices. We also consider, \u201cinstance dependent\u201d canonizing symmetry breaking constraints which apply to break symmetries in larger graphs which are solutions of a given graph search problem. These are typically smaller and easier to compute. We illustrate the application of complete symmetry breaking constraints, both instance independent and instance dependent, to extend two known sequences from the OEIS related to graph enumeration.\nThe rest of this paper is structured as follows. Section 2 provides a motivating example. Section 3 presents preliminary definitions and notation. Section 4 describes how we compute complete and canonizing symmetry breaking constraints for (instance independent) graph search problems. Then in Section 5 we show how to compute complete and canonizing symmetry breaking constraints for a given graph search problem. Section 7 concludes."}, {"heading": "2 A Motivating Example", "text": "A classic example of a graph search problem relates to the search for Ramsey graphs [25]. The graph R(s, t;n) is a simple graph with n vertices, no clique of size s, and no independent set of size t. Figure 1 illustrates a R(3, 3; 5) graph. The graph contains no 3-clique and no 3-independent set. A Ramsey (s, t)-graph is a R(s, t;n) graph for some n. The set of all R(s, t;n) graphs, modulo graph isomorphism, is denoted R(s, t;n). Ramsey Theory tells us that there are only\na finite number of Ramsey (s, t)-graphs for each s and t, but finding all such graphs, or even determining the largest n for which they exist, is a famously difficult problem. It is unknown, for example, if there exists a R(5, 5; 43) graph and the set R(4, 5; 24) has yet to be been fully determined, although 350,904 nonisomorphic graphs are known to belong to R(4, 5; 24).\nSolving the graph search problem to find all R(3, 4; 8) graphs without any symmetry breaking constraint results in a set of 17,640 graphs. Applying nauty to these solutions identifies precisely 3 solutions modulo graph isomorphism. Introducing a partial symmetry breaking constraint as described in [9] in the search to enumerate all R(3, 4; 8) graphs computes only 11 graphs in a fraction of the time required to compute the full set of solutions. These too can then be reduced applying nauty to obtain the 3 canonical solutions. Application of a complete symmetry breaking constraint as proposed in this paper results in the exact set of 3 non-isomorphic solutions."}, {"heading": "3 Preliminaries", "text": "Throughout this paper we consider finite and simple graphs (undirected with no self loops). The set of simple graphs on n nodes is denoted Gn. We assume that the vertex set of a graph, G = (V,E), is V = {1, . . . , n} and represent G by its n\u00d7 n adjacency matrix A defined by\nAi,j = { 1 if (i, j) \u2208 E 0 otherwise\nAn n-vertices graph search problem is a pair (\u03d5,A) consisting of an n \u00d7 n matrix A of Boolean variables Ai,j ; and a propositional formula \u03d5 of the form\n\u03d5(A) = \u03d5nadj(A) \u2227 \u03d5\u2032(A) (1)\nwhere \u03d5nadj(A) = \u2227\n1\u2264i\u2264n (\u00acAi,i)\ufe38 \ufe37\ufe37 \ufe38 (a)\n\u2227 \u2227\n1\u2264i<j\u2264n (Ai,j \u2194 Aj,i)\ufe38 \ufe37\ufe37 \ufe38 (b)\n(2)\nand where \u03d5\u2032(A) is a formula on the variables in A (perhaps involving also other variables). In Constraint (2), the left part (a) states that there are no self loops and the right part (b) states that the edges are undirected. Note that any satisfying assignment of \u03d5(A) renders an instance of A which represents a simple graph which we call a solution of (\u03d5,A). The set of solutions is denoted sol(\u03d5,A). The following presents two example graph search problems which we will refer to in rest of the paper.\nExample 1. The Ramsey graph R(s, t;n) is a simple graph with n vertices, no clique of size s, and no independent set of size t. The set of all R(s, t;n) graphs, modulo graph isomorphism, is denoted R(s, t;n). The search for a Ramsey graph is a graph search problem where we take the following \u03d5R(s,t;n) instead of \u03d5\n\u2032 in Constraint (1). Here we denote by \u2118s[n] (respectively \u2118t[n]) the set of subsets of size s (respectively t) of { 1, . . . , n } . The left conjunct (a) states that there is no clique of size s in the graph, and the right conjunct (b) that there is no independent set of size t.\n\u03d5(s,t;n)(A) = \u2227\nI\u2208\u2118s[n]\n\u2228{ \u00acAi,j \u2223\u2223\u2223\u2223 i, j \u2208 I,i < j }\n\ufe38 \ufe37\ufe37 \ufe38 (a)\n\u2227 \u2227\nI\u2208\u2118t[n]\n\u2228{ Ai,j \u2223\u2223\u2223\u2223 i, j \u2208 I,i < j }\n\ufe38 \ufe37\ufe37 \ufe38 (b)\n(3)\nExample 2. A graph is claw-free if it does not contain the complete bipartite graph K1,3 (sometimes called a \u201cclaw\u201d) as a subgraph. The claw free graph search problem is formalized by taking the following \u03d5cf (n) instead of \u03d5\n\u2032 in Constraint (1). Each clause in the conjunction expresses for i, j, k, ` that there is no subgraph K1,3 between {i} and {j, k, `}.\n\u03d5cf (n)(A) = \u2227{ \u00acAi,j \u2228 \u00acAi,k \u2228 \u00acAi,`\n\u2228Aj,k \u2228Ak,` \u2228 \u2228Aj,` \u2223\u2223\u2223\u22231 \u2264 i \u2264 n, i 6= j, i 6= k,i 6= `, 1 \u2264 j < k < ` \u2264 n }\n(4)\nThe set of permutations \u03c0 : {1, . . . , n} \u2192 {1, . . . , n} is denoted Sn. For G = (V,E) \u2208 Gn and \u03c0 \u2208 Sn, we define \u03c0(G) = {V, {(\u03c0(u), \u03c0(v))|(u, v) \u2208 E)}. Permutations act on adjacency matrices in the natural way: If A is the adjacency matrix of a graph G, then \u03c0(A) is the adjacency matrix of \u03c0(G) obtained by simultaneously permuting with \u03c0 the rows and columns of A. We adopt the tuple notation [\u03c0(1), . . . , \u03c0(n)] for a permutation \u03c0 : {1, . . . , n} \u2192 {1, . . . , n}.\nTwo graphs G1, G2 \u2208 Gn are isomorphic, denoted G1 \u2248 G2, if there exists a permutation \u03c0 \u2208 Sn such that G1 = \u03c0(G2). Sometimes we write G1 \u2248\u03c0 G2 to emphasize that \u03c0 is the permutation such that G1 = \u03c0(G2). For sets of graphs H1, H2, we say that H1 \u2248 H2 if for every G1 \u2208 H1 (likewise in H2) there exists G2 \u2208 H2 (likewise in H1) such that G1 \u2248 G2.\nWe consider an ordering on graphs, defined viewing their adjacency matrices as strings. Because adjacency matrices are symmetric with zeroes on the diagonal, it suffices to focus on the upper triangle parts of the matrices [8].\nDefinition 1 (ordering graphs). Let G1, G2 \u2208 Gn and let s1, s2 be the strings obtained by concatenating the rows of the upper triangular parts of their adjacency matrices respectively. Then, G1 G2 if and only if s1 lex s2. We also write A1 A2 where A1, A2 are the respective adjacency matrices of G1, G2.\nOne way to define the canonical representation of a graph is to take the smallest graph in the lexicographic order (i.e lex leader) in each equivalence class of isomorphic graphs [26]. In this paper we follow this definition for canonicity.\nDefinition 2 (canonicity). Let G \u2208 Gn be a graph, \u03a0 \u2286 Sn, and denote the predicate min\u03a0(G) = \u2227{ G \u03c0(G) \u2223\u2223\u03c0 \u2208 \u03a0 }. We say that G is canonical if minSn(G). We say that \u03a0 is canonizing if \u2200G\u2208Gn .min\u03a0(G)\u2194 minSn(G).\nObserve that in Definitions 1 and 2, the order is defined on given graphs. Often, we consider the same relation, but between adjacency matrices that contain propositional variables (representing unknown graphs, as in the case for graph search problems). Then, the expressions A1 A2 and min\u03a0(A) are viewed as a Boolean constraints on the variables in the corresponding matrices.\nExample 3. Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] }\n. The interested reader can verify that \u03a0 is canonizing for G4. Note that with only three permutations we express the information present in 4! = 24.\nDefinition 3 (symmetry break). Let (\u03d5,A) be a graph search problem and \u03c8 a propositional formula on the variables in A. We say that \u03c8 is a symmetry break for (\u03d5,A) if sol(\u03d5,A) \u2248 sol(\u03d5 \u2227 \u03c8,A). If the graphs of sol(\u03d5 \u2227 \u03c8,A) are mutually non-isomorphic then we say that \u03c8 is complete. Otherwise we say that \u03c8 is partial. If the graphs of sol(\u03d5 \u2227 \u03c8,A) are canonical then we say that \u03c8 is canonizing.\nLemma 1. Let \u03a0 be a canonizing set of permutations for graphs of size n. Then min\u03a0 is a canonizing symmetry break for any graph search problem on n vertices.\nProof. Let A be a solution to a graph search problem on n vertices and let \u03a0 be a canonizing set for graphs with n vertices. In order to prove that min\u03a0 is a canonizing symmetry break it is sufficient to show that only the canonical member in iso(A) = {\u03c0(A)|\u2200\u03c0 \u2208 Sn} satisfies min\u03a0 . \u03a0 is a canonizing set thus by definition \u2200G \u2208 Gn : min\u03a0(G)\u2194 minSn(G). Since only the canonical graph in iso(A) satisfies minSn it follows that it is the only one which satisfies min\u03a0 .\nCorollary 1. minSn(A) is a canonizing symmetry break for any graph search problem on n vertices.\nExample 4. Consider the canonizing set \u03a0 from Example 3 and the following 4\u00d7 4 adjacency matrix A:\nA =  0 a b c a 0 d e b d 0 f\nc e f 0\n \u03a0 =  [2, 1, 3, 4],[1, 3, 2, 4],\n[1, 2, 4, 3]\n"}, {"heading": "Then, by Definition 2 and Lemma 1,", "text": "min\u03a0(A) = (abcdef lex adebcf ) \u2227 (abcdef lex bacdfe) \u2227 (abcdef lex acbdef )\nand this simplifies using properties of lexicographic orderings to:\nmin\u03a0(A) = (bc lex de) \u2227 (ae lex bf ) \u2227 (bd lex ce)\nClearly, for any set of permutations \u03a0 \u2282 Sn the predicate min\u03a0 is a partial symmetry break for graph search problems. In [9], Codish et al. introduce the following symmetry break for graph search problems where Ai denotes the i th row of the adjacency matrix A and {i,j} denotes the lexicographic comparison on strings after removing their ith and jth elements.\nDefinition 4 (lexicographic symmetry break, [9]). Let A be an n\u00d7 n adjacency matrix. Then,\nsb\u2217` (A) = \u2227\n1\u2264i<j\u2264n\nA[i] {i,j} A[j]\nIt is not difficult to observe that sb\u2217` is equivalent to the predicate min\u03a0 where \u03a0 is the set of permutations that swap a single pair (i, j) with 1 \u2264 i < j \u2264 n.\nThe experimental setting. In this paper all computations are performed using the Glucose 4.0 SAT solver [5]. Encodings to CNF are obtained using the finite-domain constraint compiler BEE [22]. BEE facilitates applications to find a single (first) solution, or to find all solutions for a constraint, modulo a specified set of variables. When solving for all solutions, BEE iterates with the SAT solver, adding so called blocking clauses each time another solution is found. This technique, originally due to McMillan [21], is simplistic but suffices for our purposes. All computations were performed on a cluster with a total of 228 Intel E8400 cores clocked at 2 GHz each, able to run a total of 456 parallel threads. Each of the cores in the cluster has computational power comparable to a core on a standard desktop computer. Each SAT instance is run on a single thread."}, {"heading": "4 Canonizing Symmetry Breaks", "text": "The observation made in Example 3: that a canonizing set for graphs with n vertices can be much smaller than n!, motivates us to seek \u201csmall\u201d canonizing sets that might be applied to introduce canonizing symmetry breaking constraints for graph search problems.In this section we describe an approach to compute such canonizing sets. Applying this approach we compute relatively small canonizing sets which apply for graph search problems with up to 10 vertices. We illustrate their application when breaking all breaking symmetries in the search for Ramsey and claw-free graphs."}, {"heading": "Computing Canonizing Sets", "text": "To compute a canonizing set of permutations for graph search problems on n vertices we start with some initial set of permutations \u03a0 (for simplicity, assume that \u03a0 = \u2205). Then, incrementally apply the step specified in lines 3\u20134 of Algorithm 1, as long as the stated condition holds.\nAlgorithm 1 Compute Canonizing Set\n1: procedure Compute-Canonizing-Set(n) 2: Init: \u03a0 = \u2205 3: while \u2203G \u2208 Gn \u2203\u03c0 \u2208 Sn such that min\u03a0(G) and \u03c0(G) \u227a G do 4: \u03a0 = \u03a0 \u222a {\u03c0} 5: end while 6: return \u03a0 7: end procedure\nLemma 2. Algorithm 1 terminates and returns a canonizing set \u03a0.\nProof. Each step in the algorithm adds a permutation (at Line 4) and the number of permutations is bound. When the algorithm terminates with \u03a0 then for G \u2208 Gn, if min\u03a0(G) holds then there is no \u03c0 \u2208 Sn such that \u03c0(G) \u227a G. So, G \u03c0(G) for all \u03c0 \u2208 Sn and therefore minSn(G) holds.\nDrawing on the discussion in [16,6,11] we do not expect to find a polynomial time algorithm to compute a canonical (or any other complete) symmetry breaking constraint for graph search problems based on Definition 2. Thus it is also unlikely to find an efficient implementation of Algorithm 1. Our implementation of Algorithm 1 is based on a SAT encoding. We repeatedly apply a SAT solver to find a counter example permutation which shows that \u03a0 is not a canonizing set yet and add it to \u03a0, until an UNSAT result is obtained. In the implementation\nof the algorithm, care is taken to use a single invocation of the SAT solver so that the iterated calls to the solver are incremental. The constraint model used is depicted as Figure 2 where A,B denote n\u00d7n matrices of propositional variables and \u03c0 denotes a length n vector of integer variables. Constraint 5 specifies that the parameter \u03c0 is a permutation on { 1, . . . , n } . Each element of the vector is a value 1 \u2264 \u03c0i \u2264 n and the elements are all different. Constraint 6 specifies that the parameters A,B represent isomorphic graphs via the parameter \u03c0. Constraint 7 specifies the condition of the while loop (line 3) of Algorithm 1: A and B are constrained B = \u03c0(A) to be isomorphic adjacency matrices (see Constraint (2)) via the permutation \u03c0. The constraint min\u03a0(A) is imposed and also A B. If \u03d5nalg1 (\u03a0) is satisfiable, then the permutation \u03c0 is determined by the satisfying assignment and added to \u03a0 as specified in (line 4) of Algorithm 1.\nWe say that a canonizing set \u03a0 of permutations is redundant if for some \u03c0 \u2208 \u03a0 the set \u03a0 \\{\u03c0} is also canonizing. Algorithm 1 may compute a redundant set. For example, if a permutation added at some point becomes redundant in view of permutations added later. Algorithm 2 iterates on the elements of a canonizing set to remove redundant permutations.\nAlgorithm 2 Reduce method\n1: procedure Reduce(\u03a0) 2: for each \u03c0 \u2208 \u03a0 do 3: if \u2200G \u2208 Gn: min\u03a0\\{\u03c0}(G) \u21d2 G \u03c0(G) then 4: \u03a0 = \u03a0 \\ {\u03c0} 5: end if 6: end for 7: return \u03a0 8: end procedure\nLemma 3. If \u03a0 is canonizing, then so is Reduce(\u03a0) computed by Algorithm 2.\nProof. Let \u03a0i be the set obtained after considering the i th permutation in Line 2 of Algorithm 2. The initial set \u03a00 is the input to the algorithm. We prove that min\u03a0i \u2194 min\u03a0i+1 and conclude that min\u03a0 \u2194 minReduce(\u03a0). If no permutation was removed in step i then \u03a0i+1 = \u03a0i and trivially min\u03a0i \u2194 min\u03a0i+1 . Otherwise \u03a0i+1 = \u03a0i \\ {\u03c0} for a permutation \u03c0 which satisfies \u2200G \u2208 Gn: min\u03a0i+1(G) \u21d2 G \u03c0(G). Thus \u03c0 is implied by the permutations in \u03a0i and can be removed. Therefore min\u03a0i+1(G)\u2194 min\u03a0i(G).\nOur implementation of Algorithm 2 is based on SAT encoding. The key is in the encoding for the test in Line 3. Here, for the given \u03a0 and \u03c0 \u2208 \u03a0, we encode the constraint\n\u03d5nalg2 (\u03a0) = \u03d5 n adj(A)\ufe38 \ufe37\ufe37 \ufe38 (a) \u2227 min\u03a0\\{\u03c0}(A) \u2227 \u03c0(A) A\ufe38 \ufe37\ufe37 \ufe38 (b)\n(8)\nwhere the left part (a) specifies that A is the n \u00d7 n adjacency matrix of some graph (see Constraint (2)), and the right part (b) is the negation of the condition in Line 3. If this constraint is unsatisfiable then \u03c0 is redundant and removed from \u03a0.\nTable 1 describes the computation of irredundant canonizing sets of permutations for n \u2264 10 by application of Algorithms 1 and 2. The first three columns indicate the number of graph vertices, n, the number of permutations on n, and the number of non-isomorphic graphs on n vertices as specified by sequence A000088 of the OEIS [23]. The forth and fifth columns indicate the size of the canonical set of permutations computed using Algorithm 1 and the time to perform this computation. Columns six and seven are the size of the reduced canonical set of permutations after application of Algorithm 2 and the corresponding computation time. Column seven is set in boldface. These numbers present the relatively small size of the computed canonizing sets in comparison to the value of n!. Using the symmetry breaks derived from these sets we have generated the sets of all non-isomorphic graphs with up to 10 vertices and verified that their numbers correspond to those in column 3. These are computed by solving Constraint (1) taking \u03d5\u2032 \u2261 true.\nThe numbers in Table 1 also indicate the limitation of complete symmetry breaks which apply to all graphs. We do not expect to succeed to compute a canonizing set of permutations for n = 11 and even if we did succeed, we expect that the number of constraints that would then need be added in applications would be too large to be effective."}, {"heading": "Computing Ramsey Graphs with Canonizing Symmetry Breaks", "text": "Recall Example 1 where we introduce the graph search problem for Ramsey graphs. Table 2 describes the computation of all R(4, 4;n) graphs for n \u2264 10 using a SAT solver. The table compares two configurations: one using the partial symmetry breaking predicate sb\u2217` defined in [9] and the other using a canonizing symmetry break min\u03a0 where \u03a0 is the canonizing set of permutations, the\ncomputation of which is described in Table 1. For each configuration we detail the size of the SAT encoding (clauses and variables), the time in seconds (except where indicated in hours) to find all solutions using a SAT solver, and the number of solutions found. Observe that the encodings using the canonizing symmetry breaks are much larger. However the sat solving time is much smaller. For n = 10 the configuration with sb\u2217` requires more than 33 hours where as the configuration using min\u03a0 completes in under 7 hours. Finally note that the computation with min\u03a0 computes the precise number of solutions modulo graph isomorphism as detailed for example in [20]. These are the numbers in the rightmost column set in boldface. The solutions computed using sb\u2217` contain many isomorphic solutions which need to be subsequently removed using nauty or a similar tool. One might argue that the real cost in applying the complete symmetry breaks should include their computation. To this end we note that these are general symmetry breaking predicates applicable to any graph search problem, and they are precomputed once."}, {"heading": "Computing Claw-Free Graphs with Canonizing Symmetry Breaks", "text": "Recall Example 2 where we introduce the graph search problem for claw-free graphs. The number of claw-free graphs for n \u2264 9 vertices is detailed as sequence A086991 on the OEIS [23]. Table 3 describes the search for claw free graphs as a graph search problem. Then we use a SAT solver to compute the set of all claw free graphs on n vertices. We illustrate that using canonizing symmetry breaks, and the results detailed in Table 1, we can compute the set of all claw free graphs modulo graph isomorphism for n \u2264 10 thus computing a new value for sequence A086991. The column descriptions are the same as those for Table 2. For each configuration we detail the size of the SAT encoding (clauses and variables), the time in seconds to find all solutions using a SAT solver, and the number of solutions found. For this example the computation with a complete symmetry break is more costly, but it does return the precise set of canonical graphs. The sequence in the right column are set in boldface. For n \u2264 9, these are the numbers of claw-free graphs as detailed in sequence A086991 of the OEIS [23]. It is no\ncoincidence that the number of variables indicated in the columns of Tables 2 and 3 are almost identical. These pertain to the variables in the adjacency graph and those introduced to express the instance independent symmetry breaks.\nClearly, as the number of vertices grows the process of finding a canonizing set become unfeasible. Even if we could compute them for n > 10 vertices, these canonizing sets would have limited applicability as a canonicity predicates due to their large size. Thus, we turn to consider instance dependent canonizing symmetry breaking where canonizing sets are computed per problem instance."}, {"heading": "5 Instance Dependent Canonizing Symmetry Breaks", "text": "Given a specific graph search problem (\u03d5,A) we can adapt Algorithm 1 to compute a set of permutations \u03a0(\u03d5,A) that induce a canonical symmetry break specific for this problem. Namely such that all solutions to (\u03d5,A) are obtained, and such that all are non-isomorphic. We call such a set instance dependent. The set \u03a0(\u03d5,A) is typically much smaller than a general canonizing set as the constraints in \u03d5 restrict the solution structure and hence also the symmetries within the solution space. In practice we can often compute instance dependent canonizing sets for larger graphs with n > 10 vertices. In this section we demonstrate the computation and application of instance dependent canonizing sets.\nLet P = (\u03d5,A) be a graph search problem. To adapt Algorithm 1 to compute an instance dependent canonizing set we need to make a single change in the algorithm: to apply the while loop at Line 4 not on all graphs in Gn but rather only on solutions to P . In the implementation we simply add \u03d5 to Constraint (7) to obtain:\n\u03d5nadj(A) \u2227 \u03d5nadj(B) \u2227 \u03d5nperm(\u03c0) \u2227 \u03d5niso(A,B, \u03c0) \u2227min \u03a0 (A) \u2227 \u03d5 (7\u2032)\nSimilarly, to reduce an instance dependent canonizing set, Algorithm 2 should be adapted by changing the if condition in Line 3 to consider only solutions to P , instead of all graphs in Gn. In the implementation \u03d5 is added to Constraint (8):\n\u03d5nadj(A) \u2227 min\u03a0\\{\u03c0}(A) \u2227 \u03c0(A) A \u2227 \u03d5 (8\u2032)\nWe illustrate an examples applying instance dependent canonizing symmetry breaks. here we consider a search problems for which we seek a graph that has a particular given degree sequence. A degree sequence is a monotonic nonincreasing sequence of the vertex degrees of a graph. Degree sequences are a natural way to break a graph search problem into independent cases (one for each possible degree sequence). Thus the search for a solution or all solutions can be done in parallel.\nSince a degree sequence induces a partition on the vertex set, in order to compute an instance dependent canonizing symmetry break with respect to a degree sequence, a constraint stating that B has the same degree sequence as A needs to be added to (7\u2032). The following specifies that an adjacency matrix complies to a given degree sequence. Here each conjunct is a cardinality constraint on a row of A.\n\u03d5 \u3008d1,...,dn\u3009 degSeq (A) = \u2227 1\u2264i\u2264n  n\u2211 j=1 Ai,j = di  (9)"}, {"heading": "Computing Highly Irregular Graphs Per Degree Sequence", "text": "A connected graph is called highly irregular if each of its vertices is adjacent only to vertices with distinct degrees [1]. The number of highly irregular graphs with n \u2264 15 vertices is detailed as sequence A217246 in the OEIS [23]. By application of instance dependent canonizing symmetry breaks we extend this sequence with 4 new values. The following constraint specifies that the graph represented by adjacency matrix A with degree sequence \u3008d1, . . . , dn\u3009 is highly irregular.\n\u03d5 \u3008d1,...,dn\u3009 hi (A) = \u2227 1\u2264i,j<k\u2264n s.t dj=dk (\u00acAi,j \u2228 \u00acAi,k) \u2227 \u03d5\u3008d1,...,dn\u3009degSeq (A) \u2227 \u03d5 n con(A) (10)\nHere, the formula \u03d5ncon(A) specifies that the graph represented by adjacency matrix A is connected. The following constraint introduces propositional variables pki,j to express that vertices i and j are connected by a path that consists of intermediate vertices from the set {1, . . . , k}.\n\u03d5ncon(A) = \u2227\n1\u2264i,j\u2264n\n(p0i,j \u2194 Ai,j) \u2227 \u2227\n1\u2264i,j,k\u2264n\npki,j \u2194 (pk\u22121i,j \u2228 (p k\u22121 i,k \u2227 p k\u22121 k,j )) \u2227\n\u2227 \u2227\n1\u2264i,j\u2264n\n(pni,j) (11)\nOur strategy is to compute all highly irregular graphs with n vertices in three steps: (1) We compute the set of degree sequences for all highly irregular graphs with n vertices; (2) For each degree sequence we compute an instance dependent canonizing symmetry break; (3) We apply per degree sequence, the instance dependent canonizing symmetry break to compute the corresponding set of graphs with the corresponding degree sequence.\nTo perform the first step we apply a result from [17] which states that any degree sequence of a highly irregular graph is of the form \u3008mnm , . . . , ini , . . . , 1n1\u3009 where:\n1. (1) ni \u2265 nm for 1 \u2264 i \u2264 m; and 2. (2) \u2211m i=1(ni \u2217 i) and nm are positive even numbers.\nIt is straightforward to enumerate all degree sequences for graphs with up to 20 vertices that satisfy this property. We then apply a SAT solver to determine which of these sequences is the degree sequence of some highly irregular graph. Step (2) is performed using a SAT solver, per degree sequence, by application of the above described adaptation of Algorithm 1 to compute an irredundant instance dependent canonizing set with respect to \u03d5 \u3008d1,...,dn\u3009 hi (A). In step (3) we enumerate all non isomorphic highly irregular graphs per degree sequence with respect to the corresponding canonizing symmetry breaking constraints. We compute the graphs with a simple backtrack based (exhaustive search) program written in Java in which the variables of the adjacency matrix are assigned one by one until a solution is found.\nTable 4 presents our results. The columns are divided into three pairs corresponding to the three steps described above: the first pair \u2013 computing degree sequences, the second pair \u2013 computing (instance dependent) canonizing permutation sets, and the third pair \u2013 computing solutions (using the derived canonizing symmetry breaks). Each pair presents the computation size and information on the solutions. For the first pair, the number of degree sequences. For the second pair, the average number of permutations in the canonizing permutation sets. In the third pair, the number of connected highly irregular graphs with n vertices (set in boldface). The values for n \u2264 15 vertices correspond to those detailed as sequence A217246 in the OEIS [23]. The values for n > 15 are new. Note that we succeed to compute canonizing symmetry breaks for more than 20 nodes. We have not included the results in Table 4 as the subsequent graph enumeration problems involve a humongous number of graphs. For 20 nodes the results are incomplete. For each of the 151 degree sequences we perform a separate enumeration of the corresponding highly irregular graphs (on one thread of the cluster). From these, 147 sub-enumerations have completed with aggregated time of 3 431.61 hours. The four remain cases are still running."}, {"heading": "6 More Related Work", "text": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19]. Methods that generate the canonical repre-\nsentatives of each equivalence class are sometimes classified as \u201corderly\u201d generation methods. This is a dynamic approach. Typically graphs are constructed by adding edges in iteration until a solution is found and backtracking when failing. In each such iteration the graph is checked to determine whether it can still be further extended: (a) to a solution of the graph search problem, and (b) to a canonical graph. Both of these tests consider only the fixed part of the partial graph. Initially, there are very few permutations that need to be considered for (b) as the partial graph is still small. However, as the number of edges grows this test becomes harder and consumes more time.\nOur method is in contrast static. We aim to compute, before applying search, a small set of permutations that apply to break the symmetries in solutions. Our approach does not rely on which parts of the graph have already been determined during search."}, {"heading": "7 Conclusion and Future Work", "text": "We have illustrated the applicability of canonizing symmetry breaking constraints for small graph search problems. Although any vertex permutation is potentially a symmetry, we compute compact canonizing symmetry breaks, much smaller than those which consider all permutations. Our strategy for graph search problems is two phase. First, symmetry breaking constraints are computed. Second, these constraints are added to the model and then a solver is applied to find (all) solutions which satisfy the model.\nWe have presented methods that generate both instance independent and instance dependent symmetry breaking constraints. While instance dependent symmetry breaks have limited applicability since they grow enormously for graphs with more than 10 vertices, instance dependent symmetry breaks have been successfully applied to compute new values in highly irregular graphs OEIS sequence for graphs with up to 19 vertices.\nAlthough our approach is applicable only for graphs with small numbers of vertices, there are many open small graph search problems. For example the set\nof all Ramsey R(4, 5; 24) graphs has not been determined yet. We are currently trying to extend our techniques to apply to compute symmetry breaks for this problem which involves only 24 vertices.\nFinally, we note that our approach will also apply to improve dynamic symmetry breaking techniques. Given a partially instantiated graph, to determine if it is extendable to a canonical graph, one need not consider all of the permutations related to the already instantiated part. This because some of those permutations are redundant."}], "references": [{"title": "Highly irregular graphs", "author": ["Y. Alavi", "G. Chartrand", "F.R. Chung", "P. Erd\u00f6s", "R.L. Graham", "O.R. Oellermann"], "venue": "Journal of Graph Theory, 11(2):235\u2013249,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1987}, {"title": "Symmetry in boolean satisfiability", "author": ["F.A. Aloul"], "venue": "Symmetry, 2(2):1121\u20131134,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2010}, {"title": "Breaking instanceindependent symmetries in exact graph coloring", "author": ["F.A. Aloul", "I.L. Markov", "A. Ramani", "K.A. Sakallah"], "venue": "CoRR, abs/1109.2347,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Efficient symmetry breaking for boolean satisfiability", "author": ["F.A. Aloul", "K.A. Sakallah", "I.L. Markov"], "venue": "IEEE Trans. Computers, 55(5):549\u2013558,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2006}, {"title": "Canonical labeling of graphs", "author": ["L. Babai", "E.M. Luks"], "venue": "In Proceedings of the fifteenth annual ACM symposium on Theory of computing, pages 171\u2013183. ACM,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1983}, {"title": "Fast generation of cubic graphs", "author": ["G. Brinkmann"], "venue": "Journal of Graph Theory, 23(2):139\u2013149,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1996}, {"title": "Cataloguing the graphs on 10 vertices", "author": ["R. Cameron", "C. Colbourn", "R. Read", "N.C. Wormald"], "venue": "Journal of Graph Theory, 9(4):551\u2013562,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1985}, {"title": "Breaking symmetries in graph representation", "author": ["M. Codish", "A. Miller", "P. Prosser", "P.J. Stuckey"], "venue": "In F. Rossi, editor, IJCAI 2013, Proceedings of the 23rd International Joint Conference on Artificial Intelligence, Beijing, China, August 3-9, 2013. IJCAI/AAAI,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Constraints for symmetry breaking in graph representation", "author": ["M. Codish", "A. Miller", "P. Prosser", "P.J. Stuckey"], "venue": "Full version of [9] (in preparation).,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Symmetry-breaking predicates for search problems", "author": ["J.M. Crawford", "M.L. Ginsberg", "E.M. Luks", "A. Roy"], "venue": "In L. C. Aiello, J. Doyle, and S. C. Shapiro, editors, Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning (KR\u201996), Cambridge, Massachusetts, USA, November 5-8, 1996., pages 148\u2013159. Morgan Kaufmann,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1996}, {"title": "Constructive enumeration of combinatorial objects", "author": ["I. Faradzev"], "venue": "Problmes Combinatoires et Thorie des Graphes Colloque Internat, Paris, pages 131\u2013135,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1978}, {"title": "Symmetry and satisfiability: An update", "author": ["H. Katebi", "K.A. Sakallah", "I.L. Markov"], "venue": "In O. Strichman and S. Szeider, editors, Theory and Applications of Satisfiability Testing - SAT 2010, 13th International Conference, SAT 2010, Edinburgh, UK, July 11-14, 2010. Proceedings, volume 6175 of Lecture Notes in Computer Science, pages 113\u2013127. Springer,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2010}, {"title": "Conflict anticipation in the search for graph automorphisms", "author": ["H. Katebi", "K.A. Sakallah", "I.L. Markov"], "venue": "In N. Bj\u00f8rner and A. Voronkov, editors, Logic for Programming, Artificial Intelligence, and Reasoning - 18th International Conference, LPAR-18, M\u00e9rida, Venezuela, March 11-15, 2012. Proceedings, volume 7180 of Lecture Notes in Computer Science, pages 243\u2013257. Springer,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Graph symmetry detection and canonical labeling: Differences and synergies", "author": ["H. Katebi", "K.A. Sakallah", "I.L. Markov"], "venue": "In A. Voronkov, editor, Turing-100 - The Alan Turing Centenary, Manchester, UK, June 22-25, 2012, volume 10 of EPiC Series, pages 181\u2013195. EasyChair,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "The complexity of symmetry-breaking formulas", "author": ["E.M. Luks", "A. Roy"], "venue": "Annals of Mathematics and Artificial Intelligence, 41(1):19\u201345,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "Degree sequences of highly irregular graphs", "author": ["Z. Majcher", "J. Michael"], "venue": "Discrete Mathematics, 164(1):225\u2013236,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1997}, {"title": "nauty user\u2019s guide (version 1.5)", "author": ["B. McKay"], "venue": "Technical Report TR-CS-90-02, Australian National University,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1990}, {"title": "Isomorph-free exhaustive generation", "author": ["B.D. McKay"], "venue": "Journal of Algorithms, 26(2):306\u2013324,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1998}, {"title": "R(4, 5) = 25", "author": ["B.D. McKay", "S.P. Radziszowski"], "venue": "Journal of Graph Theory, 19(3):309\u2013322,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1995}, {"title": "Applying SAT methods in unbounded symbolic model checking", "author": ["K.L. McMillan"], "venue": "In E. Brinksma and K. G. Larsen, editors, Computer Aided Verification, 14th International Conference, Proceedings, volume 2404 of Lecture Notes in Computer Science, pages 250\u2013264. Springer,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2002}, {"title": "Boolean equi-propagation for concise and efficient SAT encodings of combinatorial problems", "author": ["A. Metodi", "M. Codish", "P.J. Stuckey"], "venue": "J. Artif. Intell. Res. (JAIR), 46:303\u2013341,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "On the satisfiability of symmetrical constrained satisfaction problems", "author": ["J. Puget"], "venue": "In H. J. Komorowski and Z. W. Ras, editors, Methodologies for Intelligent Systems, 7th International Symposium, ISMIS \u201993, Trondheim, Norway, June 15-18, 1993, Proceedings, volume 689 of Lecture Notes in Computer Science, pages 350\u2013361. Springer,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1993}, {"title": "Small Ramsey numbers", "author": ["S.P. Radziszowski"], "venue": "Electronic Journal of Combinatorics, 1994. Revision #14: January,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2014}, {"title": "Every one a winner or how to avoid isomorphism search when cataloguing combinatorial configurations", "author": ["R.C. Read"], "venue": "Ann. Discrete Math., 2:107\u2013120,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1978}, {"title": "A survey of graph generation techniques", "author": ["R.C. Read"], "venue": "In Combinatorial Mathematics VIII, pages 77\u201389. Springer,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1981}, {"title": "Generating effective symmetry-breaking predicates for search problems", "author": ["I. Shlyakhter"], "venue": "Discrete Applied Mathematics, 155(12):1539 \u2013 1548, 2007. {SAT}", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2001}, {"title": "General symmetry breaking constraints", "author": ["T. Walsh"], "venue": "In F. Benhamou, editor, Principles and Practice of Constraint Programming - CP 2006, 12th International Conference, CP 2006, Nantes, France, September 25-29, 2006, Proceedings, volume 4204 of Lecture Notes in Computer Science, pages 650\u2013664. Springer,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2006}, {"title": "Symmetry breaking constraints: Recent results", "author": ["T. Walsh"], "venue": "In J. Hoffmann and B. Selman, editors, Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence, July 22-26, 2012, Toronto, Ontario, Canada. AAAI Press,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 21, "context": "One common approach to eliminate symmetries is to introduce symmetry breaking constraints [24,11,28,29] which rule out isomorphic solutions thus reducing the size of the search space while preserving the set of solutions.", "startOffset": 90, "endOffset": 103}, {"referenceID": 9, "context": "One common approach to eliminate symmetries is to introduce symmetry breaking constraints [24,11,28,29] which rule out isomorphic solutions thus reducing the size of the search space while preserving the set of solutions.", "startOffset": 90, "endOffset": 103}, {"referenceID": 25, "context": "One common approach to eliminate symmetries is to introduce symmetry breaking constraints [24,11,28,29] which rule out isomorphic solutions thus reducing the size of the search space while preserving the set of solutions.", "startOffset": 90, "endOffset": 103}, {"referenceID": 26, "context": "One common approach to eliminate symmetries is to introduce symmetry breaking constraints [24,11,28,29] which rule out isomorphic solutions thus reducing the size of the search space while preserving the set of solutions.", "startOffset": 90, "endOffset": 103}, {"referenceID": 9, "context": "However, computing such symmetry breaking constraints is, most likely, intractable in general [11].", "startOffset": 94, "endOffset": 98}, {"referenceID": 27, "context": "In practice, symmetry breaking constraints typically rule out some, but not all of the symmetries in the search and, as noted in the survey by Walsh [30], often a few simple constraints rule out most of the symmetries.", "startOffset": 149, "endOffset": 153}, {"referenceID": 25, "context": "Shlyakhter [28] notes that the core difficulty is to identify a symmetrybreaking predicate which is both effective (rules out a large portion of the search ar X iv :1 51 1.", "startOffset": 11, "endOffset": 15}, {"referenceID": 8, "context": "In [10], Codish et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 3, "context": "A typical application is in the context of SAT solving as described for example in [4,2,13,15,14].", "startOffset": 83, "endOffset": 97}, {"referenceID": 1, "context": "A typical application is in the context of SAT solving as described for example in [4,2,13,15,14].", "startOffset": 83, "endOffset": 97}, {"referenceID": 11, "context": "A typical application is in the context of SAT solving as described for example in [4,2,13,15,14].", "startOffset": 83, "endOffset": 97}, {"referenceID": 13, "context": "A typical application is in the context of SAT solving as described for example in [4,2,13,15,14].", "startOffset": 83, "endOffset": 97}, {"referenceID": 12, "context": "A typical application is in the context of SAT solving as described for example in [4,2,13,15,14].", "startOffset": 83, "endOffset": 97}, {"referenceID": 16, "context": "First one generates the set S of solutions to the constraints, and then one applies a graph isomorphism tool, such as nauty [18] to reduce S modulo isomorphism.", "startOffset": 124, "endOffset": 128}, {"referenceID": 2, "context": "In general, our first technique is, in the terminology of [3], \u201cinstance independent\u201d and applies to break all symmetries in graph search problems on up to 10 vertices.", "startOffset": 58, "endOffset": 61}, {"referenceID": 22, "context": "A classic example of a graph search problem relates to the search for Ramsey graphs [25].", "startOffset": 84, "endOffset": 88}, {"referenceID": 7, "context": "Introducing a partial symmetry breaking constraint as described in [9] in the search to enumerate all R(3, 4; 8) graphs computes only 11 graphs in a fraction of the time required to compute the full set of solutions.", "startOffset": 67, "endOffset": 70}, {"referenceID": 6, "context": "Because adjacency matrices are symmetric with zeroes on the diagonal, it suffices to focus on the upper triangle parts of the matrices [8].", "startOffset": 135, "endOffset": 138}, {"referenceID": 23, "context": "e lex leader) in each equivalence class of isomorphic graphs [26].", "startOffset": 61, "endOffset": 65}, {"referenceID": 1, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 10, "endOffset": 22}, {"referenceID": 0, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 10, "endOffset": 22}, {"referenceID": 2, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 10, "endOffset": 22}, {"referenceID": 3, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 10, "endOffset": 22}, {"referenceID": 0, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 24, "endOffset": 36}, {"referenceID": 2, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 24, "endOffset": 36}, {"referenceID": 1, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 24, "endOffset": 36}, {"referenceID": 3, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 24, "endOffset": 36}, {"referenceID": 0, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 38, "endOffset": 50}, {"referenceID": 1, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 38, "endOffset": 50}, {"referenceID": 3, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 38, "endOffset": 50}, {"referenceID": 2, "context": "Let \u03a0 = { [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] } .", "startOffset": 38, "endOffset": 50}, {"referenceID": 1, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 20, "endOffset": 32}, {"referenceID": 0, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 20, "endOffset": 32}, {"referenceID": 2, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 20, "endOffset": 32}, {"referenceID": 3, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 20, "endOffset": 32}, {"referenceID": 0, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 34, "endOffset": 46}, {"referenceID": 2, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 34, "endOffset": 46}, {"referenceID": 1, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 34, "endOffset": 46}, {"referenceID": 3, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 34, "endOffset": 46}, {"referenceID": 0, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 48, "endOffset": 60}, {"referenceID": 1, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 48, "endOffset": 60}, {"referenceID": 3, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 48, "endOffset": 60}, {"referenceID": 2, "context": "c e f 0 \uf8fa\uf8fa\uf8fa\uf8fb \u03a0 = \uf8f2\uf8f3 [2, 1, 3, 4], [1, 3, 2, 4], [1, 2, 4, 3] \uf8fd\uf8fe", "startOffset": 48, "endOffset": 60}, {"referenceID": 7, "context": "In [9], Codish et al.", "startOffset": 3, "endOffset": 6}, {"referenceID": 7, "context": "Definition 4 (lexicographic symmetry break, [9]).", "startOffset": 44, "endOffset": 47}, {"referenceID": 20, "context": "Encodings to CNF are obtained using the finite-domain constraint compiler BEE [22].", "startOffset": 78, "endOffset": 82}, {"referenceID": 19, "context": "This technique, originally due to McMillan [21], is simplistic but suffices for our purposes.", "startOffset": 43, "endOffset": 47}, {"referenceID": 14, "context": "Drawing on the discussion in [16,6,11] we do not expect to find a polynomial time algorithm to compute a canonical (or any other complete) symmetry breaking constraint for graph search problems based on Definition 2.", "startOffset": 29, "endOffset": 38}, {"referenceID": 4, "context": "Drawing on the discussion in [16,6,11] we do not expect to find a polynomial time algorithm to compute a canonical (or any other complete) symmetry breaking constraint for graph search problems based on Definition 2.", "startOffset": 29, "endOffset": 38}, {"referenceID": 9, "context": "Drawing on the discussion in [16,6,11] we do not expect to find a polynomial time algorithm to compute a canonical (or any other complete) symmetry breaking constraint for graph search problems based on Definition 2.", "startOffset": 29, "endOffset": 38}, {"referenceID": 7, "context": "The table compares two configurations: one using the partial symmetry breaking predicate sb` defined in [9] and the other using a canonizing symmetry break min\u03a0 where \u03a0 is the canonizing set of permutations, the", "startOffset": 104, "endOffset": 107}, {"referenceID": 18, "context": "Finally note that the computation with min\u03a0 computes the precise number of solutions modulo graph isomorphism as detailed for example in [20].", "startOffset": 137, "endOffset": 141}, {"referenceID": 0, "context": "A connected graph is called highly irregular if each of its vertices is adjacent only to vertices with distinct degrees [1].", "startOffset": 120, "endOffset": 123}, {"referenceID": 15, "context": "To perform the first step we apply a result from [17] which states that any degree sequence of a highly irregular graph is of the form \u3008mm , .", "startOffset": 49, "endOffset": 53}, {"referenceID": 23, "context": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19].", "startOffset": 102, "endOffset": 117}, {"referenceID": 10, "context": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19].", "startOffset": 102, "endOffset": 117}, {"referenceID": 24, "context": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19].", "startOffset": 102, "endOffset": 117}, {"referenceID": 5, "context": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19].", "startOffset": 102, "endOffset": 117}, {"referenceID": 17, "context": "Isomorphism free generation of combinatorial objects and particularly graphs, is a well studied topic [26,12,27,7,19].", "startOffset": 102, "endOffset": 117}], "year": 2017, "abstractText": "There are many complex combinatorial problems which involve searching for an undirected graph satisfying given constraints. Such problems are often highly challenging because of the large number of isomorphic representations of their solutions. This paper introduces effective and compact, complete symmetry breaking constraints for small graph search. Enumerating with these symmetry breaks generates all and only non-isomorphic solutions. For small search problems, with up to 10 vertices, we compute instance independent symmetry breaking constraints. For small search problems with a larger number of vertices we demonstrate the computation of instance dependent constraints which are complete. We illustrate the application of complete symmetry breaking constraints to extend two known sequences from the OEIS related to graph enumeration.", "creator": "LaTeX with hyperref package"}}}