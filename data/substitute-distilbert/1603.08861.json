{"id": "1603.08861", "review": {"conference": "icml", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Mar-2016", "title": "Revisiting Semi-Supervised Learning with Graph Embeddings", "abstract": "we present traditional semi - supervised linear system based and graph embeddings. given a graph between instances, volunteers train an embedding for each instance to jointly predict the class label and the neighborhood context in the graph. we develop both transductive and local variants of our method. in the transductive variant of our method, the class labels are determined by both the learned embeddings and assumed feature bundles, while in the inductive variant, the equations are defined as a parametric function of the feature vectors, so predictions can be made on instances not seen during training. on a large externally impressive set of benchmark systems, including text capture, distantly supervised entity extraction, and entity classification, i show improved performance over many but the existing models.", "histories": [["v1", "Tue, 29 Mar 2016 17:46:16 GMT  (534kb,D)", "http://arxiv.org/abs/1603.08861v1", null], ["v2", "Thu, 26 May 2016 23:57:09 GMT  (535kb,D)", "http://arxiv.org/abs/1603.08861v2", "ICML 2016"]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["zhilin yang", "william w cohen", "ruslan salakhutdinov"], "accepted": true, "id": "1603.08861"}, "pdf": {"name": "1603.08861.pdf", "metadata": {"source": "META", "title": "Revisiting Semi-Supervised Learning with Graph Embeddings", "authors": ["Zhilin Yang", "William Cohen", "Ruslan Salakhutdinov"], "emails": ["ZHILINY@CS.CMU.EDU", "WCOHEN@CS.CMU.EDU", "RSALAKHU@CS.CMU.EDU"], "sections": [{"heading": "1. Introduction", "text": "Semi-supervised learning aims to leverage unlabeled data to improve performance. A large number of semisupervised learning algorithms jointly optimize two training objective functions: the supervised loss over labeled data and the unsupervised loss over both labeled and unlabeled data. Graph-based semi-supervised learning defines the loss function as a weighted sum of the supervised loss over labeled instances and a graph Laplacian regularization term (Zhu et al., 2003; Zhou et al., 2004; Belkin et al., 2006; Weston et al., 2012). The graph Laplacian regularization is based on the assumption that nearby nodes in a graph are likely to have the same labels. Graph Laplacian regularization is effective because it constrains the labels to be consistent with the graph structure.\nRecently developed unsupervised representation learning\nmethods learn embeddings that predict a context, e.g. a word embedding might predict nearby context words (Mikolov et al., 2013; Pennington et al., 2014), or a node embedding might predict nearby nodes in a graph (Perozzi et al., 2014; Tang et al., 2015). In these approaches, the embeddings are jointly trained with the model parameters that predict the context from the embeddings, usually based on some variant of the softmax model. Embeddings trained with distributional information can be used to boost the performance of related tasks. For example, word embeddings trained from a language model can be applied to partof-speech tagging, chunking and named entity recognition (Collobert et al., 2011; Huang et al., 2015).\nIn this paper we consider not word embeddings but graph embeddings. Existing results show that graph embeddings are effective at classifying the nodes in a graph, such as user behavior prediction in a social network (Perozzi et al., 2014; Tang et al., 2015). However, the graph embeddings are usually learned separately from the supervised task, and hence do not leverage the label information in a specific task. Hence graph embeddings are in some sense complementary to graph Laplacian regularization that does not produce useful features itself and might not be able to fully leverage the distributional information encoded in the graph structure.\nThe main highlight of our work is to incorporate embedding techniques into the graph-based semi-supervised learning setting. We propose a novel graph-based semisupervised learning framework, Planetoid (Predicting Labels And Neighbors with Embeddings Transductively Or Inductively from Data). The embedding of an instance is jointly trained to predict the class label of the instance and the context in the graph. We then concatenate the embeddings and the hidden layers of the original classifier and feed them to a softmax layer when making the prediction.\nSince the embeddings are learned based on the graph structure, the above method is transductive, which means we can only predict instances that are already observed in the graph at training time. In many cases, however, it may be desirable to have an inductive approach, where predictions\nar X\niv :1\n60 3.\n08 86\n1v 1\n[ cs\n.L G\n] 2\n9 M\nar 2\n01 6\ncan be made on instances unobserved in the graph seen at training time. To address this issue, we further develop an inductive variant of our framework, where we define the embeddings as a parameterized function of input feature vectors; i.e., the embeddings can be viewed as hidden layers of a neural network.\nTo demonstrate the effectiveness of our proposed approach, we conducted experiments on five datasets for three tasks, including text classification, distantly supervised entity extraction, and entity classification. Our inductive method outperforms the second best inductive method by up to 18.7% and on average 7.8% in terms of accuracy. The best of our inductive and transductive methods outperforms the best of all the other compared methods by up to 8.5% and on average 4.1%.\nThe rest of the paper is organized as follows. In Section 2 we compare the difference between our method and previously-considered methods in semi-supervised learning and embedding learning. Section 3 describes our models, including both transductive and inductive variants. We report the experimental results in Section 4 and conclude the paper in Section 5."}, {"heading": "2. Related Work", "text": ""}, {"heading": "2.1. Semi-Supervised Learning", "text": "The main goal of semi-supervised learning is to leverage unlabeled data to improve prediction performance. Let L and U be the number of labeled and unlabeled instances. Let x1:L and xL+1:L+U denote the feature vectors of labeled and unlabeled instances respectively. The labels y1:L are also given.\nBased on both labeled and unlabeled instances, the problem of semi-supervised learning is defined as learning a classifier f : x \u2192 y. There are two learning paradigms, transductive learning and inductive learning. Transductive learning (Zhu et al., 2003; Zhou et al., 2004) only aims to apply the classifier f on the unlabeled instances observed at training time, and the classifier does not generalize to unobserved instances. In other words, transductive learning infers the labels of unlabeled instances yL+1:L+U . For instance, transductive support vector machine (TSVM) (Joachims, 1999) maximizes the \u201cunlabeled data margin\u201d based on the low-density separation assumption that a good decision hyperplane lies on a sparse area of the feature space. Inductive learning (Belkin et al., 2006; Weston et al., 2012), on the other hand, aims to learn a parameterized classifier f that is generalizable to unobserved instances."}, {"heading": "2.2. Graph-Based Semi-Supervised Learning", "text": "In addition to labeled and unlabeled instances, a graph, denoted as a (L + U) \u00d7 (L + U) matrix A, is also given to graph-based semi-supervised learning methods. Each entry aij indicates the similarity between instance i and j, which can be either labeled or unlabeled. The graph A can either be derived from distances between instances (Zhu et al., 2003), or be explicitly derived from external data, such as a knowledge graph (Wijaya et al., 2013) or a citation network between documents (Ji et al., 2010). In this paper, we mainly focus on the setting that a graph is explicitly given and represents additional information not present in the feature vectors (e.g., the graph edges correspond to hyperlinks between documents, rather than distances between the bag-of-words representation of a document).\nGraph-based semi-supervised learning is based on the assumption that nearby nodes tend to have the same labels. Graph-based methods incur a penalty when nearby nodes have different labels. Generally, the loss function of graphbased semi-supervised learning in the binary case can be written as\nL\u2211 i=1 l(yi, f(xi)) + \u03bb \u2211 i,j aij\u2016f(xi)\u2212 f(xj)\u20162\n= L\u2211 i=1 l(yi, f(xi)) + \u03bbf T\u2206f (1)\nIn Eq. (1), the first term is the standard supervised loss function, where l(\u00b7, \u00b7) can be log loss, squared loss or hinge loss. The second term is the graph Laplacian regularization, which incurs a large penalty when similar nodes with a large wij are predicted to have different labels f(xi) 6= f(xj). The graph Laplacian matrix \u2206 is defined as \u2206 = A \u2212 D, where D is a diagonal matrix with each entry defined as dii = \u2211 j aij . \u03bb is a constant weighting factor. (Note that we omit the parameter regularization terms for simplicity.)\nVarious graph-based semi-supervised learning algorithms define the loss functions as variants of Eq. (1). Label propagation (Zhu et al., 2003) forces f to agree with labeled instances y1:L; f is a label lookup table for unlabeled instances in the graph, and can be obtained with a closedform solution. Learning with local and global consistency (Zhou et al., 2004) defines l as squared loss and f as a label lookup table; it does not force f to agree with labeled instances. Modified Adsorption (MAD) (Talukdar & Crammer, 2009) is a variant of label propagation that allows prediction on labeled instances to vary and incorporates node uncertainty. Manifold regularization (Belkin et al., 2006) parameterizes f in the Reproducing Kernel Hilbert Space (RKHS) with l being squared loss or hinge loss. Since f\nis a parameterized classifier, manifold regularization is inductive and can naturally handle unobserved instances.\nSemi-supervised embedding (Weston et al., 2012) extends the regularization term in Eq. (1) to be \u2211 i,j aij\u2016g(xi) \u2212 g(xj)\u20162, where g represents embeddings of instances, which can be the output labels, hidden layers or auxiliary embeddings in a neural network. By extending the regularization from f to g, this method imposes stronger constraints on a neural network.\nIterative classification algorithm (ICA) (Sen et al., 2008) uses a local classifier that takes the labels of neighbor nodes as input; since not all neighbor labels are available at the beginning, ICA uses an iterative process between estimating the local classifier and assigning new labels."}, {"heading": "2.3. Learning Embeddings", "text": "Extensive research was done on learning graph embeddings. A probabilistic generative model was proposed to learn node embeddings that generate the edges in a graph (Snijders & Nowicki, 1997). A clustering method (Handcock et al., 2007) was proposed to learn latent social states in a social network to predict social ties.\nMore recently, a number of embedding learning methods are based on the Skipgram model, which is a variant of the softmax model. Given an instance and its context, the objective of Skipgram is usually formulated as minimizing the log loss of predicting the context using the embedding of an instance as input features. Formally, let {(i, c)} be a set of pairs of instance i and context c, the loss function can be written as \u2212 \u2211 (i,c) log p(c|i) = \u2212 \u2211 (i,c) ( wTc ei \u2212 log \u2211 c\u2032\u2208C exp(wTc\u2032ei) ) (2) where C is the set of all possible context, w\u2019s are parameters of the Skipgram model, and ei is the embedding of instance i. Skipgram was first introduced to learn representations of words, known as word2vec (Mikolov et al.,\n2013). In word2vec, for each training pair (i, c), the instance i is the current word whose embedding is under estimation; the context c is each of the surrounding words of i within a fixed window size in a sentence; the context space C is the vocabulary of the corpus.\nSkipgram was later extended to learn graph embeddings. Deepwalk (Perozzi et al., 2014) uses the embedding of a node to predict the context in the graph, where the context is generated by random walk. More specifically, for each training pair (i, c), the instance i is the current node whose embedding is under estimation; the context c is each of the neighbor nodes within a fixed window size in a generated random walk sequence; the context space C is all the nodes in the graph. LINE (Tang et al., 2015) extends the model to have multiple context spaces C for modeling both first and second order proximity.\nAlthough Skipgram-like models for graphs have received much recent attention, many other models exist. TransE (Bordes et al., 2013) learns the embeddings of entities in a knowledge graph jointly with their relations. Autoencoders were used to learn graph embeddings for clustering on graphs (Tian et al., 2014)."}, {"heading": "2.4. Comparison", "text": "We compare our approach in this paper with other methods in semi-supervised learning and embedding learning in Table 1. Unlike our approach, conventional graph Laplacian based methods, including label propagation (Zhu et al., 2003), manifold regularization (Belkin et al., 2006) and MAD (Talukdar & Crammer, 2009), impose regularization on the labels but do not learn embeddings. Semi-supervised embedding method (Weston et al., 2012) learns embeddings in a neural network, but our approach is different from this method in that instead of imposing regularization, we use the embeddings to predict the context in the graph. Graph embedding methods (Perozzi et al., 2014; Tian et al., 2014) encode the graph structure into embeddings; however, different from our approach, these meth-\nods are purely unsupervised and do not leverage label information for a specific task. Moreover, these methods are transductive and cannot be directly generalized to instances unseen at training time."}, {"heading": "3. Semi-Supervised Learning with Graph Embeddings", "text": "Following the notations in the previous section, the input to our method includes labeled instances x1:L, y1:L, unlabeled instances xL+1:L+U and a graph denoted as a matrix A. Each instance i has an embedding denoted as ei.\nWe formulate our framework based on feed-forward neural networks. Given the input feature vector x, the k-th hidden layer of the network is denoted as hk, which is a nonlinear function of the previous hidden layer hk\u22121 defined as:\nhk(x) = ReLU(Wkhk\u22121(x) + bk),\nwhere Wk and bk are parameters of the k-th layer, and h0(x) = x. We adopt rectified linear unit ReLU(x) = max(0, x) as the nonlinear function in this work.\nIn the following sections, we first introduce how to sample context from the graph, and then formulate our semisupervised learning framework."}, {"heading": "3.1. Sampling Context", "text": "It is usually intractable to directly optimize Eq. (2) due to normalization over the whole context space C. Negative sampling was proposed to address this issue (Mikolov\net al., 2013), which samples negative examples to approximate the normalization term. In our case, we are sampling (i, c, \u03b3) from a distribution, where i and c denote instance and context respectively, \u03b3 = +1 means (i, c) is a positive pair and \u03b3 = \u22121 means negative. Given (i, c, \u03b3), we minimize the cross entropy loss of classifying the pair (i, c) to a binary label \u03b3:\n\u2212I(\u03b3 = 1) log \u03c3(wTc ei)\u2212 I(\u03b3 = \u22121) log \u03c3(\u2212wTc ei),\nwhere \u03c3 is the sigmoid function defined as \u03c3(x) = 1/(1 + e\u2212x), and I(\u00b7) is an indicator function that outputs 1 when the argument is true, otherwise 0. Therefore, the loss function with negative sampling can be written as\n\u2212 E(i,c,\u03b3) log \u03c3(\u03b3wTc ei) (3)\nThe distribution p(i, c, \u03b3) is conditioned on labels y1:L and the graph A. However, since they are the input to our algorithm and kept fixed, we drop the conditioning in our notation.\nWe now define the distribution p(i, c, \u03b3) directly using a sampling process, which is illustrated in Algorithm 1. There are two types of context that are sampled in this algorithm. The first type of context is based on the graph A, which encodes the structure information, and the second type of context is based on the labels, which we use to inject label information into the embeddings. We use a parameter r1 \u2208 (0, 1) to control the ratio of positive and negative samples, and use r2 \u2208 (0, 1) to control the ratio of two types of context.\nWith probability r2, we sample the context based on the graph A. We first uniformly sample a random walk sequence S. More specifically, we uniformly sample the first instance S1 from the set 1 : L + U . Given the previous instance Sk\u22121 = i, the next instance Sk = j is sampled with probability aij/ \u2211L+U j\u2032=1 aij\u2032 . With probability r1, we sample a positive pair (i, c) from the set {(Sj , Sk) : |j \u2212 k| < d}, where d is another parameter determining the window size. With probability (1 \u2212 r1), we uniformly corrupt the context c to sample a negative pair.\nWith probability (1\u2212 r2), we sample the context based on the class labels. Positive pairs have the same labels and negative pairs have different labels. Only labeled instances 1 : L will be sampled.\nOur random walk based sampling method is similar to Deepwalk (Perozzi et al., 2014). However, different from their method, we extend it to real-valued A, incorporate negative sampling, and explicitly sample from labels with probability (1\u2212 r2) to inject supervised information.\nAn example of sampling when \u03b3 = 1 is shown in Figure 1.\nAlgorithm 1 Sampling Context Distribution p(i, c, \u03b3) Input: graph A, labels y1:L, parameters r1, r2, q, d Initialize triplet (i, c, \u03b3) if random < r1 then \u03b3 \u2190 +1 else \u03b3 \u2190 \u22121 if random < r2 then\nUniformly sample a random walk S of length q Uniformly sample (Sj , Sk) with |j \u2212 k| < d i\u2190 Sj , c\u2190 Sk if \u03b3 = \u22121 then uniformly sample c from 1 : L+ U\nelse if \u03b3 = +1 then\nUniformly sample (i, c) with yi = yc else\nUniformly sample (i, c) with yi 6= yc end if\nend if return (i, c, \u03b3)"}, {"heading": "3.2. Transductive Formulation", "text": "In this section, we present a method that infers the labels of unlabeled instances yL+1:L+U without generalizing to unobserved instances. Transductive learning usually performs better than inductive learning because transductive learning can leverage the unlabeled test data when training the model (Joachims, 1999).\nWe apply k layers on the input feature vector x to obtain hk(x), and l layers on the embedding e to obtain hl(e), as illustrated in Figure 2(a). The two hidden layers are concatenated, and fed to a softmax layer to predict the class label of the instance. More specifically, the probability of predicting the label y is written as:\np(y|x, e) = exp[h k(x)T ,hl(e)T ]wy\u2211\ny\u2032 exp[h k(x)T ,hl(e)T ]wy\u2032\n, (4)\nwhere [\u00b7, \u00b7] denotes concatenation of two row vectors, the super script hT denotes the transpose of vector h, and w represents the model parameter.\nCombined with Eq. (3), the loss function of transductive learning is defined as:\n\u2212 1 L L\u2211 i=1 log p(yi|xi, ei)\u2212 \u03bbE(i,c,\u03b3) log \u03c3(\u03b3wTc ei),\nwhere the first term is defined by Eq. (4), and \u03bb is a constant weighting factor. The first term is the loss function of class label prediction and the second term is the loss function of context prediction. This formulation is transductive because the prediction of label y depends on the embedding e, which can only be learned for instances observed in the graph A during training time."}, {"heading": "3.3. Inductive Formulation", "text": "In many cases, it is desirable to learn a classifier that can generalize to unobserved instances, so we also consider an inductive learning paradigm. To make the method inductive, the prediction of label y should only depend on the input feature vector x. Therefore, we define the embedding e as a parameterized function of feature x, as shown in Figure 2(b).\nSimilar to the transductive formulation, we apply k layers on the input feature vector x to obtain hk(x). However, rather than using a \u201cfree\u201d embedding, we apply l1 layers on the input feature vector x and define it as the embedding e = hl1(x). Then another l2 layers are applied on the embedding hl2(e) = hl2(hl1(x)), denoted as hl(x) where l = l1 + l2. The embedding e in this formulation can be viewed as a hidden layer that is a parameterized function of the feature x.\nWith the above formulation, the label y only depends on the feature x. More specifically,\np(y|x) = exp[h k(x)T ,hl(x)T ]wy\u2211\ny\u2032 exp[h k(x)T ,hl(x)T ]wy\u2032\n(5)\nReplacing ei in Eq. (3) with hl1(xi), the loss function of inductive learning is\n\u2212 1 L L\u2211 i=1 log p(yi|xi)\u2212 \u03bbE(i,c,\u03b3) log \u03c3(\u03b3wTc hl1(xi))\nAlgorithm 2 Model Training (Transductive) Input: A, x1:L+U , y1:L, \u03bb, batch sizes T1, T2 repeat\n\u2211\nDATASET #CLASSES #NODES #EDGES\nCITESEER 6 3,327 4,732 CORA 7 2,708 5,429\nPUBMED 3 19,717 44,338 DIEL 4 4,373,008 4,464,261 NELL 210 65,755 266,144\nwhere the first term is defined by Eq. (5)."}, {"heading": "3.4. Training", "text": "We adopt stochastic gradient descent (SGD) (Bottou, 2010) to train our model in the mini-batch mode. For each iteration, we first sample a batch of labeled instances and take a gradient step to optimize the loss function of class label prediction. We then sample a batch of context (i, c, \u03b3) and take another gradient step to optimize the loss function of context prediction. Algorithm 2 illustrates the SGD-based training algorithm for the transductive formulation. Similarly, we can replace p(yi|xi, ei) with p(yi|xi) in L1 to obtain the training algorithm for the inductive formulation. Let \u03b8 denote all model parameters. We update both embeddings e and parameters \u03b8 in transductive learning, and update only parameters \u03b8 in inductive learning."}, {"heading": "4. Experiments", "text": "In our experiments, Planetoid-T and Planetoid-I denote the transductive and inductive formulation of our approach. We compare our approach with label propagation (LP) (Zhu et al., 2003), semi-supervised embedding (SemiEmb) (Weston et al., 2012), manifold regularization (ManiReg) (Belkin et al., 2006), TSVM (Joachims, 1999), and graph embeddings (GraphEmb) (Perozzi et al., 2014). Another baseline method, denoted as Feat, is a linear softmax model that takes only the feature vectors x as input. We also derive a variant Planetoid-G that learns embeddings to jointly predict class labels and graph context without use of feature vectors. The architecture of Planetoid-G is similar to Figure 2(a) except that the input feature and the corresponding\nhidden layers are removed.\nAmong the above methods, LP, GraphEmb and PlanetoidG do not use the features x, while TSVM and Feat do not use the graph A. We include these methods into our experimental settings to better evaluate our approach.\nWe did preliminary experiments with different architectures of Planetoid on the text classification datasets, and found the ones in Figure 2 give the best performance1.\nFor each dataset, we split all instances into three parts, labeled data, unlabeled data, and test data. Inductive methods are trained on the labeled and unlabeled data, and tested on the test data. Transductive methods, on the other hand, are trained on the labeled, unlabeled data, and test data without labels.\nThe statistics for five of our benchmark datasets are reported in Table 2. For each dataset, we list the number of classes for classification, and the number of nodes and\n1We note that it is possible to develop other architectures for different applications, such as using a shared hidden layer for feature vectors and embeddings.\nedges in the graph.\nWe adapt the implementation of GraphEmb2 to our Skipgram implementation. We use the Junto library (Talukdar & Crammer, 2009) for label propagation, and SVMLight3 for TSVM. We also use our own implementation of ManiReg and SemiEmb by modifying the symbolic objective function in Planetoid. In all of our experiments, we set the model hyper-parameters to r1 = 5/6, q = 10, d = 3, T1 = 200 and T2 = 200 for Planetoid. In general, we found that our model is not very sensitive to these hyperparameters. We use the same r1, q and d for GraphEmb, and the same T1 and T2 for ManiReg and SemiEmb. We tune r2, \u03bb, the learning rate and hyper-parameters in other models based on an additional data split with a different random seed."}, {"heading": "4.1. Text Classification", "text": "We first considered three text classification datasets4, including Citeseer, Cora and Pubmed (Sen et al., 2008). Each\n2https://github.com/phanein/deepwalk 3http://svmlight.joachims.org/ 4http://linqs.umiacs.umd.edu/projects/\n/projects/lbc/\ndataset contains bag-of-words representation of documents and citation links between the documents. We treat the bagof-words as feature vectors x. We construct the graph A based on the citation links; if document i cites j, then we set aij = aji = 1. The goal is to classify each document into one class.\nWe randomly sample 20 instances for each class as labeled data, 1, 000 instances as test data, and the rest are used as unlabeled data. The same data splits are used for different methods, and we compute the average accuracy for comparison.\nThe experimental results are reported in Table 3. Among the inductive methods, Planetoid-I achieves the best performance on all the three datasets with the improvement of up to 6.1% on Pubmed, which indicates that our embedding techniques are more effective than graph Laplacian regularization.\nAmong the transductive methods, Planetoid-T achieves the best performance on Cora and Pubmed, while TSVM performs the best on Citeseer. However, TSVM does not perform well on Cora and Pubmed. Planetoid-I slightly outperforms Planetoid-T on Citeseer and Pubmed, while Planetoid-T gets up to 14.5% improvement over PlanetoidI on Cora. We conjecture that in Planetoid-I, the feature vectors impose constraints on the learned embeddings, since they are represented by a parameterized function of the input feature vectors. If such constraints are appropriate, as is the case on Citeseer and Pubmed, it improves the non-convex optimization of embedding learning and leads to better performance. However, if such constraints rule out the optimal embeddings, the inductive model will suffer.\nPlanetoid-G consistently outperforms GraphEmb on all three datasets, which indicates that joint training with label information can improve the performance over training the supervised and unsupervised objectives separately.\nFigure 3 displays the 2-D embedding spaces on the Cora\ndataset using t-SNE (Van der Maaten & Hinton, 2008). Note that different classes are better separated in the embedding space of Planetoid-T than that of GraphEmb and SemiEmb, which is consistent with our empirical findings. We also observe similar results for the other two datasets."}, {"heading": "4.2. Distantly-Supervised Entity Extraction", "text": "We next considered the DIEL (Distant Information Extraction using coordinate-term Lists) dataset5. The DIEL dataset contains pre-extracted features for each entity mention in text, and a graph that connects entity mentions to coordinate lists (Bing et al., 2015). The goal is to extract medical entities from text given feature vectors and the graph.\nWe follow the exact experimental setup as in the original DIEL paper (Bing et al., 2015), including data splits of different runs, preprocessing of entity mentions and coordinate lists, and evaluation. We treat the top-k entities given by a model as positive instances, and compute recall@k for evaluation (k is set to 240, 000 following the DIEL paper). We report the average result of 10 runs in Table 4, where Feat refers to a result obtained by SVM (referred to as DS-Baseline in the DIEL paper). The result of LP was also taken from (Bing et al., 2015). DIEL in Table 4 refers to the method proposed by the original paper, which is an improved version of label propagation that trains classifiers on feature vectors based on the output of label propagation. We did not include TSVM into the comparison since it does not scale.\nSince we use Freebase as ground truth and some entities are not present in text, the upper bound of recall as shown in Table 4 is 0.617.\nBoth Planetoid-I and Planetoid-T significantly outperform all other methods. Each of Planetoid-I and Planetoid-T achieves the best performance in 5 out of 10 runs, and they give a similar recall on average, which indicates that there is no significant difference between these two methods on this dataset. Planetoid-G clearly outperforms GraphEmb, which again shows the benefit of joint training."}, {"heading": "4.3. Entity Classification", "text": "We sorted out an entity classification dataset from the knowledge base of Never Ending Language Learning (NELL)6 (Carlson et al., 2010) and a hierarchical entity classification dataset7 that links NELL entities to text in ClueWeb09 (Dalvi & Cohen, 2016). We extracted the en-\n5http://www.cs.cmu.edu/\u02dclbing/data/ emnlp-15-diel/emnlp-15-diel.tar.gz\n6http://rtw.ml.cmu.edu/rtw/resources 7http://rtw.ml.cmu.edu/wk/WebSets/\nhierarchical_ExploratoryLearning_WSDM2016/ index.html\ntities and the relations between entities from the NELL knowledge base, and then obtained text description by linking the entities to ClueWeb09. We use text bag-of-words representation as feature vectors of the entities.\nWe next describe how to construct the graph based on the knowledge base. We first remove relations that are not populated in NELL, including \u201cgeneralizations\u201d, \u201chaswikipediaurl\u201d, and \u201catdate\u201d. In the knowledge base, each relation is denoted as a triplet (e1, r, e2), where e1, r, e2 denote head entity, relation, and tail entity respectively. We treat each entity e as a node in the graph, and each relation r is split as two nodes r1 and r2 in the graph. For each (e1, r, e2), we add two edges in the graph, (e1, r1) and (e2, r2).\nWe removed all classes with less than 10 entities. The goal is to classify the entities in the knowledge base into one of the 210 classes given the feature vectors and the graph. Let \u03b2 be the labeling rate. We set \u03b2 to 0.1, 0.01, and 0.001. max(\u03b2N, 1) instances are labeled for a class with N entities, so each class has at least one entity in the labeled data.\nWe report the results in Table 5. We did not include TSVM since it does not scale to such a large number of classes with the one-vs-rest scheme. Adding feature vectors does not improve the performance of Planetoid-T, so we set the feature vectors for Planetoid-T to be all empty, and therefore Planetoid-T is equivalent to Planetoid-G in this case.\nPlanetoid-I significantly outperforms the best of the other compared inductive methods\u2014i.e., SemiEmb\u2014by 4.8%, 16.0%, and 18.7% respectively with three labeling rates. As the labeling rate decreases, the improvement of Planetoid-I over SemiEmb becomes more significant.\nGraph structure is more informative than features in this dataset, so inductive methods perform worse than transductive methods. Planetoid-G outperforms GraphEmb by 5.0%, 3.2% and 3.8%."}, {"heading": "5. Conclusion", "text": "In this paper, we developed a semi-supervised learning framework based on graph embeddings. We presented both transductive and inductive variants of our framework. In the transductive variant, we learn an embedding for each instance to jointly predict the class label and the graph context. In the inductive variant, we learn a hidden layer as an embedding for predicting the graph context.\nOur experimental results on five benchmark datasets show that a) joint training gives improvement over unsupervised learning; b) predicting graph context is more effective than graph Laplacian regularization; c) the performance of the inductive variant depends on the informativeness of feature vectors. Planetoid significantly outperforms other\npreviously-considered methods on all of the considered datasets.\nOne direction of future work would be to apply our framework to more complex networks, including recurrent networks. It would also be interesting to experiment with datasets where a graph is computed based on distances between feature vectors."}], "references": [{"title": "Manifold regularization: A geometric framework for learning from labeled and unlabeled examples", "author": ["Belkin", "Mikhail", "Niyogi", "Partha", "Sindhwani", "Vikas"], "venue": null, "citeRegEx": "Belkin et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Belkin et al\\.", "year": 2006}, {"title": "Improving distant supervision for information extraction using label propagation through lists", "author": ["Bing", "Lidong", "Chaudhari", "Sneha", "Wang", "Richard C", "Cohen", "William W"], "venue": "In EMNLP,", "citeRegEx": "Bing et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Bing et al\\.", "year": 2015}, {"title": "Translating embeddings for modeling multi-relational data", "author": ["Bordes", "Antoine", "Usunier", "Nicolas", "Garcia-Duran", "Alberto", "Weston", "Jason", "Yakhnenko", "Oksana"], "venue": "In NIPS,", "citeRegEx": "Bordes et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bordes et al\\.", "year": 2013}, {"title": "Large-scale machine learning with stochastic gradient descent", "author": ["Bottou", "L\u00e9on"], "venue": "In COMPSTAT,", "citeRegEx": "Bottou and L\u00e9on.,? \\Q2010\\E", "shortCiteRegEx": "Bottou and L\u00e9on.", "year": 2010}, {"title": "Toward an architecture for never-ending language learning", "author": ["Carlson", "Andrew", "Betteridge", "Justin", "Kisiel", "Bryan", "Settles", "Burr", "Hruschka Jr.", "Estevam R", "Mitchell", "Tom M"], "venue": "In AAAI,", "citeRegEx": "Carlson et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Carlson et al\\.", "year": 2010}, {"title": "Natural language processing (almost) from scratch", "author": ["Collobert", "Ronan", "Weston", "Jason", "Bottou", "L\u00e9on", "Karlen", "Michael", "Kavukcuoglu", "Koray", "Kuksa", "Pavel"], "venue": null, "citeRegEx": "Collobert et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2011}, {"title": "Hierarchical semisupervised classification with incomplete class hierarchies", "author": ["Dalvi", "Bhavana", "Cohen", "William W"], "venue": "In WSDM,", "citeRegEx": "Dalvi et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Dalvi et al\\.", "year": 2016}, {"title": "Model-based clustering for social networks", "author": ["Handcock", "Mark S", "Raftery", "Adrian E", "Tantrum", "Jeremy M"], "venue": "Journal of the Royal Statistical Society: Series A (Statistics in Society),", "citeRegEx": "Handcock et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Handcock et al\\.", "year": 2007}, {"title": "Bidirectional lstm-crf models for sequence tagging", "author": ["Huang", "Zhiheng", "Xu", "Wei", "Yu", "Kai"], "venue": "arXiv preprint arXiv:1508.01991,", "citeRegEx": "Huang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2015}, {"title": "Graph regularized transductive classification on heterogeneous information networks", "author": ["Ji", "Ming", "Sun", "Yizhou", "Danilevsky", "Marina", "Han", "Jiawei", "Gao", "Jing"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "Ji et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Ji et al\\.", "year": 2010}, {"title": "Transductive inference for text classification using support vector machines", "author": ["Joachims", "Thorsten"], "venue": "In ICML,", "citeRegEx": "Joachims and Thorsten.,? \\Q1999\\E", "shortCiteRegEx": "Joachims and Thorsten.", "year": 1999}, {"title": "Distributed representations of words and phrases and their compositionality", "author": ["Mikolov", "Tomas", "Sutskever", "Ilya", "Chen", "Kai", "Corrado", "Greg S", "Dean", "Jeff"], "venue": "In NIPS,", "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Glove: Global vectors for word representation", "author": ["Pennington", "Jeffrey", "Socher", "Richard", "Manning", "Christopher D"], "venue": null, "citeRegEx": "Pennington et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pennington et al\\.", "year": 2014}, {"title": "Deepwalk: Online learning of social representations", "author": ["Perozzi", "Bryan", "Al-Rfou", "Rami", "Skiena", "Steven"], "venue": "In KDD,", "citeRegEx": "Perozzi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Perozzi et al\\.", "year": 2014}, {"title": "Collective classification in network data", "author": ["Sen", "Prithviraj", "Namata", "Galileo", "Bilgic", "Mustafa", "Getoor", "Lise", "Galligher", "Brian", "Eliassi-Rad", "Tina"], "venue": "AI magazine,", "citeRegEx": "Sen et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Sen et al\\.", "year": 2008}, {"title": "Estimation and prediction for stochastic blockmodels for graphs with latent block structure", "author": ["Snijders", "Tom AB", "Nowicki", "Krzysztof"], "venue": "Journal of classification,", "citeRegEx": "Snijders et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Snijders et al\\.", "year": 1997}, {"title": "New regularized algorithms for transductive learning", "author": ["Talukdar", "Partha Pratim", "Crammer", "Koby"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "Talukdar et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Talukdar et al\\.", "year": 2009}, {"title": "Line: Large-scale information network embedding", "author": ["Tang", "Jian", "Qu", "Meng", "Wang", "Mingzhe", "Zhang", "Ming", "Yan", "Jun", "Mei", "Qiaozhu"], "venue": "In WWW, pp. 1067\u20131077. International World Wide Web Conferences Steering Committee,", "citeRegEx": "Tang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Tang et al\\.", "year": 2015}, {"title": "Learning deep representations for graph clustering", "author": ["Tian", "Fei", "Gao", "Bin", "Cui", "Qing", "Chen", "Enhong", "Liu", "Tie-Yan"], "venue": "In AAAI,", "citeRegEx": "Tian et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Tian et al\\.", "year": 2014}, {"title": "Visualizing data using t-sne", "author": ["Van der Maaten", "Laurens", "Hinton", "Geoffrey"], "venue": "JMLR, 9(2579-2605):85,", "citeRegEx": "Maaten et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Maaten et al\\.", "year": 2008}, {"title": "Deep learning via semi-supervised embedding", "author": ["Weston", "Jason", "Ratle", "Fr\u00e9d\u00e9ric", "Mobahi", "Hossein", "Collobert", "Ronan"], "venue": "In Neural Networks: Tricks of the Trade,", "citeRegEx": "Weston et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Weston et al\\.", "year": 2012}, {"title": "Pidgin: ontology alignment using web text as interlingua", "author": ["Wijaya", "Derry", "Talukdar", "Partha Pratim", "Mitchell", "Tom"], "venue": "In CIKM,", "citeRegEx": "Wijaya et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Wijaya et al\\.", "year": 2013}, {"title": "Learning with local and global consistency", "author": ["Zhou", "Dengyong", "Bousquet", "Olivier", "Lal", "Thomas Navin", "Weston", "Jason", "Sch\u00f6lkopf", "Bernhard"], "venue": null, "citeRegEx": "Zhou et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Zhou et al\\.", "year": 2004}, {"title": "Revisiting Semi-Supervised Learning with Graph", "author": ["Zhu", "Xiaojin", "Ghahramani", "Zoubin", "Lafferty", "John"], "venue": "In ICML,", "citeRegEx": "Zhu et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Zhu et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 23, "context": "Graph-based semi-supervised learning defines the loss function as a weighted sum of the supervised loss over labeled instances and a graph Laplacian regularization term (Zhu et al., 2003; Zhou et al., 2004; Belkin et al., 2006; Weston et al., 2012).", "startOffset": 169, "endOffset": 248}, {"referenceID": 22, "context": "Graph-based semi-supervised learning defines the loss function as a weighted sum of the supervised loss over labeled instances and a graph Laplacian regularization term (Zhu et al., 2003; Zhou et al., 2004; Belkin et al., 2006; Weston et al., 2012).", "startOffset": 169, "endOffset": 248}, {"referenceID": 0, "context": "Graph-based semi-supervised learning defines the loss function as a weighted sum of the supervised loss over labeled instances and a graph Laplacian regularization term (Zhu et al., 2003; Zhou et al., 2004; Belkin et al., 2006; Weston et al., 2012).", "startOffset": 169, "endOffset": 248}, {"referenceID": 20, "context": "Graph-based semi-supervised learning defines the loss function as a weighted sum of the supervised loss over labeled instances and a graph Laplacian regularization term (Zhu et al., 2003; Zhou et al., 2004; Belkin et al., 2006; Weston et al., 2012).", "startOffset": 169, "endOffset": 248}, {"referenceID": 11, "context": "a word embedding might predict nearby context words (Mikolov et al., 2013; Pennington et al., 2014), or a node embedding might predict nearby nodes in a graph (Perozzi et al.", "startOffset": 52, "endOffset": 99}, {"referenceID": 12, "context": "a word embedding might predict nearby context words (Mikolov et al., 2013; Pennington et al., 2014), or a node embedding might predict nearby nodes in a graph (Perozzi et al.", "startOffset": 52, "endOffset": 99}, {"referenceID": 13, "context": ", 2014), or a node embedding might predict nearby nodes in a graph (Perozzi et al., 2014; Tang et al., 2015).", "startOffset": 67, "endOffset": 108}, {"referenceID": 17, "context": ", 2014), or a node embedding might predict nearby nodes in a graph (Perozzi et al., 2014; Tang et al., 2015).", "startOffset": 67, "endOffset": 108}, {"referenceID": 5, "context": "For example, word embeddings trained from a language model can be applied to partof-speech tagging, chunking and named entity recognition (Collobert et al., 2011; Huang et al., 2015).", "startOffset": 138, "endOffset": 182}, {"referenceID": 8, "context": "For example, word embeddings trained from a language model can be applied to partof-speech tagging, chunking and named entity recognition (Collobert et al., 2011; Huang et al., 2015).", "startOffset": 138, "endOffset": 182}, {"referenceID": 13, "context": "Existing results show that graph embeddings are effective at classifying the nodes in a graph, such as user behavior prediction in a social network (Perozzi et al., 2014; Tang et al., 2015).", "startOffset": 148, "endOffset": 189}, {"referenceID": 17, "context": "Existing results show that graph embeddings are effective at classifying the nodes in a graph, such as user behavior prediction in a social network (Perozzi et al., 2014; Tang et al., 2015).", "startOffset": 148, "endOffset": 189}, {"referenceID": 23, "context": "Transductive learning (Zhu et al., 2003; Zhou et al., 2004) only aims to apply the classifier f on the unlabeled instances observed at training time, and the classifier does not generalize to unobserved instances.", "startOffset": 22, "endOffset": 59}, {"referenceID": 22, "context": "Transductive learning (Zhu et al., 2003; Zhou et al., 2004) only aims to apply the classifier f on the unlabeled instances observed at training time, and the classifier does not generalize to unobserved instances.", "startOffset": 22, "endOffset": 59}, {"referenceID": 0, "context": "Inductive learning (Belkin et al., 2006; Weston et al., 2012), on the other hand, aims to learn a parameterized classifier f that is generalizable to unobserved instances.", "startOffset": 19, "endOffset": 61}, {"referenceID": 20, "context": "Inductive learning (Belkin et al., 2006; Weston et al., 2012), on the other hand, aims to learn a parameterized classifier f that is generalizable to unobserved instances.", "startOffset": 19, "endOffset": 61}, {"referenceID": 23, "context": "The graph A can either be derived from distances between instances (Zhu et al., 2003), or be explicitly derived from external data, such as a knowledge graph (Wijaya et al.", "startOffset": 67, "endOffset": 85}, {"referenceID": 21, "context": ", 2003), or be explicitly derived from external data, such as a knowledge graph (Wijaya et al., 2013) or a citation network between documents (Ji et al.", "startOffset": 80, "endOffset": 101}, {"referenceID": 9, "context": ", 2013) or a citation network between documents (Ji et al., 2010).", "startOffset": 48, "endOffset": 65}, {"referenceID": 23, "context": "Label propagation (Zhu et al., 2003) forces f to agree with labeled instances y1:L; f is a label lookup table for unlabeled instances in the graph, and can be obtained with a closedform solution.", "startOffset": 18, "endOffset": 36}, {"referenceID": 22, "context": "Learning with local and global consistency (Zhou et al., 2004) defines l as squared loss and f as a label lookup table; it does not force f to agree with labeled instances.", "startOffset": 43, "endOffset": 62}, {"referenceID": 0, "context": "Manifold regularization (Belkin et al., 2006) parameterizes f in the Reproducing Kernel Hilbert Space (RKHS) with l being squared loss or hinge loss.", "startOffset": 24, "endOffset": 45}, {"referenceID": 23, "context": "TSVM (Joachims, 1999) \u221a \u221a Transductive \u00d7 \u00d7 Label propagation (Zhu et al., 2003) \u00d7 \u221a Transductive \u00d7 Regularization Manifold Reg (Belkin et al.", "startOffset": 61, "endOffset": 79}, {"referenceID": 0, "context": ", 2003) \u00d7 \u221a Transductive \u00d7 Regularization Manifold Reg (Belkin et al., 2006) \u221a \u221a Inductive \u00d7 Regularization ICA (Sen et al.", "startOffset": 55, "endOffset": 76}, {"referenceID": 14, "context": ", 2006) \u221a \u221a Inductive \u00d7 Regularization ICA (Sen et al., 2008) \u00d7 \u221a Transductive \u00d7 Features MAD (Talukdar & Crammer, 2009) \u00d7 \u221a Transductive \u00d7 Regularization Semi Emb (Weston et al.", "startOffset": 43, "endOffset": 61}, {"referenceID": 20, "context": ", 2008) \u00d7 \u221a Transductive \u00d7 Features MAD (Talukdar & Crammer, 2009) \u00d7 \u221a Transductive \u00d7 Regularization Semi Emb (Weston et al., 2012) \u221a \u221a Inductive \u221a Regularization Graph Emb (Perozzi et al.", "startOffset": 110, "endOffset": 131}, {"referenceID": 13, "context": ", 2012) \u221a \u221a Inductive \u221a Regularization Graph Emb (Perozzi et al., 2014) \u00d7 \u00d7 Transductive \u221a Context Planetoid (this paper) \u221a \u221a Both \u221a Context", "startOffset": 49, "endOffset": 71}, {"referenceID": 20, "context": "Semi-supervised embedding (Weston et al., 2012) extends the regularization term in Eq.", "startOffset": 26, "endOffset": 47}, {"referenceID": 14, "context": "Iterative classification algorithm (ICA) (Sen et al., 2008) uses a local classifier that takes the labels of neighbor nodes as input; since not all neighbor labels are available at the beginning, ICA uses an iterative process between estimating the local classifier and assigning new labels.", "startOffset": 41, "endOffset": 59}, {"referenceID": 7, "context": "A clustering method (Handcock et al., 2007) was proposed to learn latent social states in a social network to predict social ties.", "startOffset": 20, "endOffset": 43}, {"referenceID": 11, "context": "Skipgram was first introduced to learn representations of words, known as word2vec (Mikolov et al., 2013).", "startOffset": 83, "endOffset": 105}, {"referenceID": 13, "context": "Deepwalk (Perozzi et al., 2014) uses the embedding of a node to predict the context in the graph, where the context is generated by random walk.", "startOffset": 9, "endOffset": 31}, {"referenceID": 17, "context": "LINE (Tang et al., 2015) extends the model to have multiple context spaces C for modeling both first and second order proximity.", "startOffset": 5, "endOffset": 24}, {"referenceID": 2, "context": "TransE (Bordes et al., 2013) learns the embeddings of entities in a knowledge graph jointly with their relations.", "startOffset": 7, "endOffset": 28}, {"referenceID": 18, "context": "Autoencoders were used to learn graph embeddings for clustering on graphs (Tian et al., 2014).", "startOffset": 74, "endOffset": 93}, {"referenceID": 23, "context": "Unlike our approach, conventional graph Laplacian based methods, including label propagation (Zhu et al., 2003), manifold regularization (Belkin et al.", "startOffset": 93, "endOffset": 111}, {"referenceID": 0, "context": ", 2003), manifold regularization (Belkin et al., 2006) and MAD (Talukdar & Crammer, 2009), impose regularization on the labels but do not learn embeddings.", "startOffset": 33, "endOffset": 54}, {"referenceID": 20, "context": "Semi-supervised embedding method (Weston et al., 2012) learns embeddings in a neural network, but our approach is different from this method in that instead of imposing regularization, we use the embeddings to predict the context in the graph.", "startOffset": 33, "endOffset": 54}, {"referenceID": 13, "context": "Graph embedding methods (Perozzi et al., 2014; Tian et al., 2014) encode the graph structure into embeddings; however, different from our approach, these meth-", "startOffset": 24, "endOffset": 65}, {"referenceID": 18, "context": "Graph embedding methods (Perozzi et al., 2014; Tian et al., 2014) encode the graph structure into embeddings; however, different from our approach, these meth-", "startOffset": 24, "endOffset": 65}, {"referenceID": 11, "context": "Negative sampling was proposed to address this issue (Mikolov et al., 2013), which samples negative examples to approximate the normalization term.", "startOffset": 53, "endOffset": 75}, {"referenceID": 13, "context": "Our random walk based sampling method is similar to Deepwalk (Perozzi et al., 2014).", "startOffset": 61, "endOffset": 83}, {"referenceID": 23, "context": "We compare our approach with label propagation (LP) (Zhu et al., 2003), semi-supervised embedding (SemiEmb) (Weston et al.", "startOffset": 52, "endOffset": 70}, {"referenceID": 20, "context": ", 2003), semi-supervised embedding (SemiEmb) (Weston et al., 2012), manifold regularization (ManiReg) (Belkin et al.", "startOffset": 45, "endOffset": 66}, {"referenceID": 0, "context": ", 2012), manifold regularization (ManiReg) (Belkin et al., 2006), TSVM (Joachims, 1999), and graph embeddings (GraphEmb) (Perozzi et al.", "startOffset": 43, "endOffset": 64}, {"referenceID": 13, "context": ", 2006), TSVM (Joachims, 1999), and graph embeddings (GraphEmb) (Perozzi et al., 2014).", "startOffset": 64, "endOffset": 86}, {"referenceID": 1, "context": "Results marked with \u2217 are taken from the original DIEL paper (Bing et al., 2015) with the same data splits.", "startOffset": 61, "endOffset": 80}, {"referenceID": 14, "context": "We first considered three text classification datasets4, including Citeseer, Cora and Pubmed (Sen et al., 2008).", "startOffset": 93, "endOffset": 111}, {"referenceID": 1, "context": "The DIEL dataset contains pre-extracted features for each entity mention in text, and a graph that connects entity mentions to coordinate lists (Bing et al., 2015).", "startOffset": 144, "endOffset": 163}, {"referenceID": 1, "context": "We follow the exact experimental setup as in the original DIEL paper (Bing et al., 2015), including data splits of different runs, preprocessing of entity mentions and coordinate lists, and evaluation.", "startOffset": 69, "endOffset": 88}, {"referenceID": 1, "context": "The result of LP was also taken from (Bing et al., 2015).", "startOffset": 37, "endOffset": 56}, {"referenceID": 4, "context": "We sorted out an entity classification dataset from the knowledge base of Never Ending Language Learning (NELL)6 (Carlson et al., 2010) and a hierarchical entity classification dataset7 that links NELL entities to text in ClueWeb09 (Dalvi & Cohen, 2016).", "startOffset": 113, "endOffset": 135}], "year": 2016, "abstractText": "We present a semi-supervised learning framework based on graph embeddings. Given a graph between instances, we train an embedding for each instance to jointly predict the class label and the neighborhood context in the graph. We develop both transductive and inductive variants of our method. In the transductive variant of our method, the class labels are determined by both the learned embeddings and input feature vectors, while in the inductive variant, the embeddings are defined as a parametric function of the feature vectors, so predictions can be made on instances not seen during training. On a large and diverse set of benchmark tasks, including text classification, distantly supervised entity extraction, and entity classification, we show improved performance over many of the existing models.", "creator": "LaTeX with hyperref package"}}}