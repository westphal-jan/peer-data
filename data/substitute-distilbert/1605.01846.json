{"id": "1605.01846", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-May-2016", "title": "The KB paradigm and its application to interactive configuration", "abstract": "the knowledge acquisition paradigm aims to express domain knowledge in a rich formal language, and to use this domain view as a knowledge base to solve various problems and tasks that arise in the domain by applying multiple forms of inference. as such, the paradigm applies a strict collection of concerns between information and problem solving. in this paper, we analyze the effectiveness and feasibility of the knowledge base paradigm targeting the context of an important class of applications : interactive configuration problems. in interactive access problems, a configuration of interrelated objects within query is searched, lest the system assists the user in reaching an intended configuration. it is widely recognized in industry that good software solutions for these problems ( notably difficult to develop. we investigate such problems from the premise of the kb paradigm. we show that multiple functionalities in open domain can be achieved by applying different forms than logical inferences on a formal specification of one configuration domain. we report below a proof of compliance of this approach in facilitating real - life consultancy with a banking company. empirical advances in theory and practice of logic programming ( tplp ).", "histories": [["v1", "Fri, 6 May 2016 07:39:19 GMT  (56kb)", "http://arxiv.org/abs/1605.01846v1", "To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["pieter van hertum", "ingmar dasseville", "gerda janssens", "marc denecker"], "accepted": false, "id": "1605.01846"}, "pdf": {"name": "1605.01846.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Pieter Van Hertum", "Ingmar Dasseville", "Gerda Janssens", "Marc Denecker"], "emails": ["first.lastname@cs.kuleuven.be"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 5.\n01 84\n6v 1\n[ cs\n.A I]\nKEYWORDS: Interactive Configuration, Knowledge Base Paradigm, Inferences, Applications of Declarative Systems"}, {"heading": "1 Introduction", "text": "In this paper, we investigate the application of knowledge representation and reasoning (KRR) to the problem of interactive configuration. In the past decades enormous progress in many different areas of computational logic was obtained. This resulted in a complex landscape with many declarative paradigms, languages and communities. One issue that fragments computational logic more than anything else\nThis is an extended version of a paper presented at the international symposium on Practical Aspects of Declarative Languages (PADL 2016), invited as a rapid communication in TPLP. The authors acknowledge the assistance of the conference program chairs Marco Gavanelli and John Reppy. This research was supported by the project GOA 13/010 Research Fund KU Leuven and projects G.0489.10, G.0357.12, and G.0922.13 of the Research Foundation - Flanders.\nis the reasoning/inference task. Computational logic is divided in different declarative paradigms, each with its own syntactical style, terminology and conceptuology, and designated form of inference (e.g, deductive logic, logic programming, abductive logic programming, databases (query inference), answer set programming (answer set generation), constraint programming, etc.). Yet, in all of them declarative propositions need to be expressed. Take, e.g., \u201ceach lecture takes place at some time slot\u201d. This proposition could be an expression to be deduced from a formal specification if the task was a verification problem, or to be queried in a database, or it could be a constraint for a scheduling problem. It is, in the first place, just a piece of information and we see no reason why depending on the task to be solved, it should be expressed in a different formalism (classical logic, SQL, ASP, MiniZinc, etc.).\nThe Knowledge Base (KB) paradigm (Denecker and Vennekens 2008) was proposed as an answer to this. The KB paradigm applies a strict separation of concerns to information and problem solving. A KB system allows information to be stored in a knowledge base, and provides a range of inference methods. With these inference methods various types of problems and tasks can be solved using the same knowledge base. As such the knowledge base is neither a program nor a description of a problem, it cannot be executed or run. It is nothing but information. However, this information can be used to solve multiple sorts of problems. Many declarative problem solving paradigms are mono-inferential: they are based on one form of inference. In comparison, the KB-paradigm is multi-inferential. We believe that this implements a more natural, pure view of what declarative logic is aimed to be. The FO(\u00b7) KB project (Denecker and Vennekens 2008) is a research project that runs now for a number of years. Its aim is to integrate different useful language constructs and forms of inference from different declarative paradigms in one rich declarative language and a KB system. So far, it has led to the KB language FO(\u00b7) (Denecker and Ternovska 2008) and the KB system IDP (De Cat et al. 2016) which were used in the configuration experiment described in this paper.\nAn interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989;\nFleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem. One or more users search for a configuration of objects and relations between them that satisfies a set of constraints. Industry abounds with interactive configuration problems: configuring composite physical systems such as cars and computers, insurances, loans, schedules involving human interaction, webshops (where clients choose composite objects), etc. However, building such software is renowned in industry as difficult and no broadly accepted solution methods are available (Felfernig et al. 2014; Axling and Haridi 1996). Building software support using standard imperative programming is often a nightmare (Barker and O\u2019Connor 1989; Piller et al. 2014), due to the fact that (1) many functionalities need to be provided, (2) they are complex to implement, and (3) constraints on the configuration tend to get duplicated and spread out over the application, in the form of snippets of code performing various computations relative to the constraint (e.g., context dependent checks\nor propagations) which often leads to an unacceptable maintenance cost. This makes interactive configuration an excellent domain to illustrate the advantages of declarative methods over standard imperative or object-oriented programming.\nOur research question is: can we express the constraints of correct configurations in a declarative logic and provide the required functionalities by applying inference on this domain knowledge? This is a KRR question albeit a difficult one. In the first place, some of the domain knowledge may be complex. For an example in the context of a computer configuration problem, take the following constraint: the total memory usage of different software processes that needs to be in main memory simultaneously, may not exceed the available RAM memory. It takes an expressive knowledge representation language with aggregates to (compactly and naturally) express such a constraint. Many interactive configuration problems include complex constraints: various sorts of quantification, aggregates, definitions (sometimes inductive), etc. Moreover, an interactive configuration system needs to provide many functionalities: checking the validity of a fully specified configuration, correct and safe reasoning on a partially specified configuration (this involves reasoning on incomplete knowledge, sometimes with infinite or unknown domains), computing impossible values or forced values for attributes, generating sensible questions to the user, providing explanation why certain values are impossible, backtracking if the user regrets some choices, supporting the user by filling in his don\u2019t-cares while potentially taking into account a cost function, etc.\nThat declarative methods are particularly suitable for solving this type of problem has been acknowledged before, and several systems and languages have been developed (Hadzic 2004; Schneeweiss and Hofstedt 2011; Tiihonen et al. 2013; Vlaeminck et al. 2009). A first contribution of this paper is the analysis of IC problems from a Knowledge Representation point of view. We show that multiple functionalities in this domain can be achieved by applying different forms of logical inference on the same formal specification of the configuration domain. We define various sorts of inference and analyse them in terms of which different functionalities can be supplied. The second contribution is the reverse: we study the feasibility and usefulness of the KB paradigm in this important class of applications. The logic used in this experiment is the logic FO(\u00b7) (Denecker and Ternovska 2008), an extension of first-order logic (FO), and the system is the IDP system (De Cat et al. 2016). We discuss the complexity of (the decision problems of) the inference problems and why they are solvable, despite the high expressivity of the language and the complexity of inference. This research has its origin in an experimental IC system we developed in collaboration with industry. We evaluated our approach using the evaluation criteria of the knowledge-based configuration research (Felfernig et al. 2014). We conclude this paper with a discussion of related work in using knowledge-based systems for configuration and a comparison of our approach with these systems."}, {"heading": "2 The FO(.) KB project", "text": "The language. FO(\u00b7) refers to the class of extensions of first order logic (FO) as is common in logic, e.g. FO(LFP) stands for the extension of FO with a least fixpoint\nconstruction (Immerman and Vardi 1997). Currently, the language of the IDP system in the project is FO(T, ID, Agg, arit, PF) (Denecker and Ternovska 2008; Pelov et al. 2007): FO extended with types, definitions, aggregates, arithmetic and partial functions. Abusing notation, we will use FO(\u00b7) as an abbreviation for this language. Below, we introduce the aspects of the logic and its syntax on which this paper relies.\nA specification. A vocabulary is a set \u03a3 of type (denoted as \u03a3T ), predicate (denoted as \u03a3P ) and function symbols (denoted as \u03a3F ). Variables x, y, atoms A, FO-formulas \u03d5 are defined as usual. A predicate P of arity n has a type [\u03c41, . . . , \u03c4n], a n-tuple of type symbols. A function of arity n has a type [\u03c41, . . . , \u03c4n] \u2192 \u03c4n+1, a (n + 1)-tuple of type symbols. Aggregate terms are of the form Agg(E), with Agg an aggregate function symbol and E an expression {(x, F (x))|\u03d5(x)}, where \u03d5 is any FO-formula, F a function symbol and x a tuple of variables. Examples are the cardinality, sum, product, maximum and minimum aggregate functions. For example sum{(x, F (x))|\u03d5(x)} is read as \u03a3x\u2208{y|\u03d5(y)}F (x). A term in FO(\u00b7) can be an aggregate term or a term as defined in FO. A theory is a set of FO(\u00b7) formulas.\nA partial set on domain D is a function from D to {t,u, f}. A partial set is twovalued (or total) if u does not belong to its range. A (partial) structure S consists of a domain D\u03c4 for all types \u03c4 in \u03a3T and an assignment of a partial set \u03c3 S to each predicate or function symbol \u03c3 \u2208 (\u03a3P \u222a\u03a3F ), called the interpretation of \u03c3 in S. The interpretation PS of a predicate symbol P with type [\u03c41, . . . , \u03c4n] in S is a partial set on domain D\u03c41 \u00d7 . . .\u00d7D\u03c4n . For a function F with type [\u03c41, . . . , \u03c4n] \u2192 \u03c4n+1, the interpretation FS of F in S is a partial set on domain D\u03c41 \u00d7 . . .\u00d7D\u03c4n \u00d7D\u03c4n+1. In case the interpretation of (a predicate or function symbol) \u03c3 in S is a two-valued set, we abuse notation and use \u03c3S as shorthand for {d|\u03c3S(d) = t}. The precision-order on the truth values is given by u <p f and u <p t. It can be extended pointwise to partial sets and partial structures, denoted S \u2264p S \u2032. Informally, this means that an interpretation has become more precise if tuples of domain elements that were previously mapped to unknown now map to true or false. Notice that total structures are the maximally precise ones. We will illustrate this precision relation in Example 2.1. We say that S \u2032 extends S if S \u2264p S \u2032. We will sometimes use \u03c3Sx as shorthand for the set {d|d \u2208 D\u03c41 \u00d7 . . .\u00d7D\u03c4n \u2227 \u03c3 S(d) = x}, with x \u2208 {t, f ,u}.\nThe associated theory TS of a partial structure S is a representation of the information contained in S as a theory, which will be used in Section 4. It is defined by the following collection of constraints. For every predicate symbol P , this collection contains two sets of constraints:\n{P (d)|d \u2208 PS t } {\u00acP (d)|d \u2208 PS f }\nand two sets of constraints for every function symbol F :\n{F (d) = e|(d, e) \u2208 FSt } {\u00acF (d) = e|(d, e) \u2208 FS f }\nGiven a partial structure S, the domain structure SD is the structure containing only the domains of S. It is easy to see that S contains the same information as TS \u222a SD. A total structure1 S is called functionally consistent if for each function F with type [\u03c41, . . . , \u03c4n] \u2192 \u03c4n+1, the interpretation FS is the graph of a function D\u03c41 \u00d7 . . . \u00d7 D\u03c4n 7\u2192 D\u03c4n+1. A partial structure S is functionally consistent if it has a functionally consistent two-valued extension. Unless stated otherwise, we will assume for the rest of this paper that all (partial) structures are functionally consistent.\nA domain atom (domain term) is a tuple of a predicate symbol P (a function symbol F ) and a tuple of domain elements (d1, . . . , dn). We will denote it as P (d1, . . . , dn) (respectively F (d1, . . . , dn)). We say a domain term t of type \u03c4 is uninterpreted in S if {d|d \u2208 D\u03c4 \u2227 (t = d)S = u} is non-empty.\nTo define the satisfaction relation on theories, we extend the interpretation of symbols to arbitrary terms and formulas using the Kleene truth assignments (Kleene 1952). For a theory T and a partial structure S, we say that S is a model of T (or in symbols S T ) if T S = t and S is two-valued. We sometimes abuse notation and write T \u03d5 for the entailment relation, as a shorthand for \u201cFor every structure S such that S T , we have S \u03d5.\u201d.\nExample 2.1. To illustrate some of the concepts introduced above, assume a situation where we have some knowledge about printers, that have some type of connection. A vocabulary to model such knowledge can look as follows:\n\u03a3 = {\n\u03a3T = {printer, connection}\n\u03a3P = {PrinterConnection(printer, connection)}\n\u03a3F = {}\n}\nA structure S0 in which we have 2 printers P1 and P2 and 2 possible connections: USB and LAN , where we have no additional information, looks like:\nS0 = {\nprinter = {P1, P2}\nconnection = {USB,LAN}\nPrinterConnection = {(P1, USB) \u2192 u, (P2, USB) \u2192 u,\n(P1, LAN) \u2192 u, (P2, LAN) \u2192 u}\n}\nA more precise structure S1 \u2265p S0, containing the partial information that P1 has\n1 Note the difference in typography between a partial structure S and a total structure S.\nUSB and P2 certainly has no LAN connection looks like:\nS1 = {\nprinter = {P1, P2}\nconnection = {USB,LAN}\nPrinterConnection = {(P1, USB) \u2192 t, (P2, USB) \u2192 u,\n(P1, LAN) \u2192 u, (P2, LAN) \u2192 f}\n}\nA total structure S2 \u2265p S1 containing full information can look like:\nS2 = {\nprinter = {P1, P2}\nconnection = {USB,LAN}\nPrinterConnection = {(P1, USB) \u2192 t, (P2, USB) \u2192 t,\n(P1, LAN) \u2192 f , (P2, LAN) \u2192 f}\n}\nInference tasks. In the KB paradigm, a specification is a bag of information. This information can be used for solving various problems by applying a suitable form of inference on it.\nFO is standardly associated with deduction inference: a deductive inference task takes as input a pair of theory T and sentence \u03d5, and returns t if T |= \u03d5 and f otherwise. This is well-known to be undecidable for FO, and by extension for FO(\u00b7). However, to provide the required functionality of an interactive configuration system we can use simpler forms of inference. Indeed, in many such domains a fixed finite domain is associated with each unknown configuration parameter.\nA natural format in logic to describe these finite domains is by a partial structure with a finite domain. Also other data that are often available in such problems can be represented in that structure. As such various inference tasks are solvable by finite domain reasoning and become decidable. Below, we give the base forms of inference for our KB system and recall their complexity when using finite domain reasoning. We assume a fixed vocabulary \u03a3 and theory T and query. Our complexities are given in function of the domain size.\nModelexpand(T,S): input: theory T and partial structure S; output: a\nmodel I of T such that S \u2264p I or UNSAT if there is no such I. Modelexpand (Wittocx et al. 2008) is a generalization for FO(\u00b7) theories of the modelexpansion task as defined in Mitchell et al. (Mitchell and Ternovska 2005). Complexity of deciding the existence of a modelexpansion is in NP. Structure S2 in Example 2.1 is the output of Modelexpand(T,S1), with S1 as in Example 2.1, and T a theory consisting of the constraint that every printer has exactly one connection. Modelcheck(T, S): input: a total structure S and theory T over the vocabulary\ninterpreted by S; output is the boolean value S |= T . Note that Modelcheck\nis a degenerate case of the Modelexpand inference, with S a total structure. Complexity is in P. Minimize(T,S, t): input: a theory T , a partial structure S and a term t of nu-\nmerical type; output: a model I \u2265p S of T such that the value tI of t is minimal. The term t represents a numerical expression whose value has to be minimized. This is an extension to the modelexpand inference. The complexity of deciding that a certain tI is minimal, is in \u2206P2 . Propagate(T,S): input: theory T and partial structure S; output: the most pre-\ncise partial structure Sr such that for every model I \u2265p S of T it is true that I \u2265p Sr. The complexity of deciding that a partial structure S \u2032 is Sr is in \u2206P2 . Note that we assume that all partial structures are functionally consistent, which implies that we also propagate functional integrity constraints. Query(S, E): input: a (partial) structure S and a set expression E = {x | \u03d5(x)};\noutput: the set AQ = {x | \u03d5(x)S = t}. Complexity of deciding that a set A is AQ is in P.\nApproximative versions exist for some of these inferences, with lower complexity (Vlaeminck et al. 2009). More inferences exist, such as simulation of temporal theories in FO(\u00b7) (Bogaerts et al. 2014), but were not used in the experiment."}, {"heading": "3 Interactive Configuration", "text": "In an IC problem, one or more users search for a configuration of objects and relations between them that satisfies a set of constraints.\nTypically, the user is not aware of all constraints. There may be too many of them to keep track of. Even if the human user can oversee all constraints that he needs to satisfy, he is not a perfect reasoner and cannot comprehend all consequences of his choices. This in its own right makes such problems hard to solve. The problems get worse if the user does not know about the relevant objects and relations or the constraints on them, or if the class of involved objects and relations is large, if the constraints get more complex and more \u201cirregular\u201d (e.g., exceptions), if more users are involved, etc. On top of that, the underlying constraints in such problems tend to evolve quickly. All these complexities occur frequently, making the problem difficult for a human user. In such cases, computer assistance is needed: the human user chooses and the system assists by guiding him through the search space.\nFor a given IC problem, an IC system has information on that problem. There are a number of stringent rules to which a configuration should conform, and besides this there is a set of parameters. Parameters are the open fields in the configuration that need to be filled in by the user or decided by the system."}, {"heading": "3.1 Running example: Domain knowledge", "text": "A simplified version of the application in Section 5.1 is used in Section 4 as running example. We introduce the domain knowledge of this example here.\nExample 3.1. Software on a computer has to be configured for different employees.\nTable 1 contains the information on the software, the requirements, the budgets of the employees and the prices of software. Available software is Windows, Linux, LATEX, Office and a DualBoot system. Each software item has a price, which can be seen in column PriceOf. Column PreReq specifies which software is required for other software. Every type of employee has a budget, provided in columnMaxCost. IsOs lists the pieces of software that are operating systems. Next to the information in the table, we know that if more than one OS is installed, a DualBoot System is required."}, {"heading": "3.2 Subtasks of an interactive configuration system", "text": "Any system assisting a user in interactive configuration must be able to perform a set of subtasks. We look at important subtasks that an interactive configuration system should support.\nSubtask 1: Acquiring information from the user\nThe first task of an IC system is acquiring information from the user. The system needs to get a value for a number of parameters of the configuration from the user. There are several options: the system can ask questions to the user, it can make the user fill in a form containing open text fields, dropdown-menus, checkboxes, etc. Desirable aspects would be to give the user the possibility to choose the order in which he gives values for parameters and to omit filling in certain parameters (because he does not know or does not care). For example, in the running example a user might need a LATEX-package, but he does not care about which OS he uses. In that case the system will decide in his place that a Linux system is required. Since a user is not fully aware of all constraints, it is possible that he inputs conflicting information. This needs to be handled or avoided.\nSubtask 2: Generating consistent values for a parameter\nAfter a parameter is selected (by the user or the system) for which a value is needed, the system can assist the user in choosing these values. A possibility is that the system presents the user with a list of all possible values, given the values for other parameters and the constraints of the configuration problem. Limiting the user with this list makes that the user is unable to input inconsistent information.\nSubtask 3: Propagation of information\nAssisting the user in choosing values for the parameters, a system can use the constraints to propagate the information that the user has communicated. This can be used in several ways. A system can communicate propagations through a GUI, for example by coloring certain fields red or graying out certain checkboxes. Another way is to give a user the possibility to explicitly ask \u201cwhat if\u201d-questions to the system. In Example 3.1, a user can ask the system what the consequences are if he was a secretary choosing an Office installation. The system answers that in this case a Windows installation is required, which results in a Linux installation becoming impossible (due to budget constraints) and as a consequence it also derives the impossibility of installing LATEX.\nSubtask 4: Checking the consistency for a value\nWhen it is not possible/desirable to provide a list of possible values, the system checks that the value the user has provided is consistent with the known data and the constraints.\nSubtask 5: Checking a configuration\nIf a user makes manual changes to a configuration, the system provides him with the ability to check if his updated version of the configuration still conforms to all constraints.\nSubtask 6: Autocompletion\nIf a user has finished communicating all his preferences, the system autocompletes the partial configuration to a full configuration. This can be done arbitrarily (a value for each parameter such that the constraints are satisfied) or the user can have some other parameters like total cost, that have to be optimized.\nSubtask 7: Explanation\nIf a supplied value for a parameter is not consistent with other parameters, the system can explain this inconsistency to the user. This can be done by showing minimal sets of parameters with their values that are inconsistent, by showing (visualizations of) constraints that are violated or by combinations of both. It can also explain to the user why certain automatic choices are made, or why certain choices are impossible.\nSubtask 8: Backtracking\nIt is not unthinkable that a user makes a mistake, or changes his mind after seeing consequences of choices he made. Backtracking is an important subtask for a configuration system, and can be supported in numerous ways. The simplest way is\na simple back button, which reverts the last choice a user made. A more involved option is a system where a user can select any parameter and erase his value for that parameter. The user can then decide this parameter at a later timepoint. Even more complex is a system where a user can supply a value for a parameter and if it is not consistent with other parameters the system shows him which parameters are in conflict and proposes other values for these parameters such that consistency can be maintained."}, {"heading": "4 Interactive Configuration in the KB paradigm", "text": "To analyze the IC problem from the KB point of view, we aim at formalizing the subtasks of Section 3 as inferences. In this paper we do not deal with user interface aspects. For a given application, our knowledge base consists of a vocabulary \u03a3, a theory T expressing the configuration constraints and a partial structure S. Initially, S0 is the partial structure that contains the domains of the types and the input data. During IC, S0 will become more and more precise partial structures Si due to choices made by the user. For IC, the KB also contains LS0 , the set of all uninterpreted domain atoms/terms2 in S0. These domain terms are the logical formalization of the parameters of the IC problem. \u03a3 and T are fixed. As will be shown in this section, all subtasks can be formalized by (a combination of) inferences on this knowledge base consisting of \u03a3, T,S0, LS0 and information gathered from the user.\nExample 4.1. Continuing Example 3.1, use vocabulary \u03a3:\n\u03a3 =\n\u03a3T = {software, employee, int}\n\u03a3P = {Install(software), IsOS(software), P reReq(software, software)}\n\u03a3F = {PriceOf(software) : int, MaxCost(employee) : int,\nCost : int, Requester : employee}\nThe initial partial structure S0 consists of:\nemployee \u2192 {Secretary,Manager}\nsoftware \u2192 {Windows, Linux, LaTeX,Office,DualBoot}\nand interpretations for MaxCost (employee):int, IsOs(software), PriceOf(software): int and PreReq(software, software) as can be seen in Table 1. All symbols from \u03a3 that are not specified above are assumed to be fully unknown in S0. The set of parameters LS0 is:\n{Requester, Install(Windows), Install(Linux),\nInstall(Office), Install(LaTeX), Install(DualBoot), Cost}\n2 In the rest of this paper, a domain atom is treated as a term that evaluates to true or false.\nThe theory T consists of the following constraints:\n\u2200s1 s2 : Install(s1) \u2227 PreReq(s1, s2) \u21d2 Install(s2).\n// The total cost is the sum of the prices of all installed software.\nCost = sum{(s, PriceOf(s))|Install(s)}. Cost \u2264 MaxCost(Requester). \u2203s : Install(s) \u2227 IsOS(s). Install(Windows) \u2227 Install(Linux) \u21d2 Install(DualBoot).\nSubtask 1: Acquiring information from the user\nKey in IC is collecting information from the user on the parameters. During the run of the system, the set of parameters that are still open changes. In our KB system a derived inference (a combination of the inferences as introduced in Section 2) is used to calculate this set of parameters. Complexity results of derived inferences stem from basic results formulated by Mitchell and Ternovska (2005) and the observation that modelchecking is polynomial in the size of the domain.\nDefinition 4.2. Calculating uninterpreted terms. GetOpenTerms(T,S) is the derived inference with input a theory T , a partial structure S \u2265p S0 and the set LS0 of terms. Output is a set of terms such that for every term t in that set, there exist models I1 and I2 of T that extend S (I1, I2 \u2265p S) for which tI1 6= tI2 . Or formally:\n{l|l \u2208 LS0 \u2227 {d|(l = d) S\u2032 = u} 6= \u2205 \u2227 S \u2032 = Propagate(T,S)}\nThe complexity of deciding whether a given set of terms A is the set of uninter-\npreted terms is in \u2206P 2 .\nAn IC system can use this set of terms in a number of ways. It can use a metric to select a specific term, which it can pose as a direct question to the user. It can also present a whole list of these terms at once and let the user pick one to supply a value for. In Section 5.1, we discuss two different approaches we implemented for this project.\nExample 4.3. In Example 4.1, the parameters and domains are already given. Assume that the user has chosen the value Manager for Requester, true for Install(Windows) and false for Install(Linux). The system will return GetOpenTerms(T,S) = {Install(Office), Install(DualBoot), Cost}.\nSubtask 2: Generating consistent values for a parameter\nA domain element d is a possible value for term t if there is a model I \u2265p S such that (t = d)I = t.\nDefinition 4.4. Calculating consistent values. GetConsistentValues(T,S, t) is the derived inference with input a theory T , a partial structure S and a term t \u2208 GetOpenTerms(T,S). Output is the set\n{tI | I is a model of T extending S}\nThe complexity of deciding that a set P is the set of consistent values for t is in\n\u2206P 2 .\nExample 4.5. The consistent values for Requester given T and the initial partial structure S0 from Example 4.1 is:\nGetConsistentV alues(T,S, Requester) = {Secretary,Manager}\nConsistent values for other terms are the integers for Cost and {true, false} for the others.\nSubtask 3: Propagation of information\nIt is informative for the user that he can see the consequences of assigning a particular value to a parameter.\nDefinition 4.6. Calculating Consequences. PosConsequences(T,S, t, a) and NegConsequences(T,S, t, a) are derived inferences with input a theory T , a partial structure S, an uninterpreted term t \u2208 GetOpenTerms(T,S) and a domain element a \u2208 GetConsistentValues(T,S, t). As output it has a set C+, respectively C\u2212 of tuples (q, b) of uninterpreted terms and domain elements. (q, b) \u2208 C+, respectively C\u2212 means that the choice a for t entails that q will be forced, respectively prohibited to be b. Formally,\nC+ = {(q, b) | (q = b)S \u2032 = t \u2227 (q = b)S = u\n\u2227 S \u2032 = Propagate(T,S \u222a {t = a})\n\u2227 q \u2208 GetOpenTerms(T,S) \\ {t} }\nC\u2212 = {(q, c) | (q = c)S \u2032 = f \u2227 (q = c)S = u\n\u2227 S \u2032 = Propagate(T,S \u222a {t = a})\n\u2227 q \u2208 GetOpenTerms(T,S) \\ {t} }\nThe complexity of deciding whether a set P is C+ or C\u2212 is in \u2206P 2 .\nExample 4.7. Say the user has chosen Requester = Secretary and wants to know the consequences of making Install(Windows) true. The output in this case contains (Install(LaTeX), f) in PosConsequences(T,S, t, a) and (Install(LaTeX), t) in NegConsequences(T,S, t, a) since this combination is too expensive for a secretary. Note that there is not always such a correspondence between the positive and negative consequences. For example, when deriving a negative consequence for Cost, this does not necessarily imply a positive consequence.\nSubtask 4: Checking the consistency for a value\nA value d for a term t is consistent if there exists a model of T in which t = d that extends the partial structure representing the current state.\nDefinition 4.8. Consistency Checking. CheckConsistency(T,S, t, d) is the derived inference with input a theory T , a partial structure S, an uninterpreted term t and a domain element d. Output is a boolean b that represents whether S extended with t = d still satisfies T . Formally we return t if\n(S \u222a {tS = d}) T\nand f otherwise. Complexity of deciding if a value d is consistent for a term t is in NP.\nExample 4.9. If a user has chosen Install(Windows) and Install(LaTeX) to be true, then Manager will and Secretary will not be a consistent answer for Requester.\nSubtask 5: Checking a configuration\nOnce the user has constructed a 2-valued structure S and makes manual changes to it, he may need to check if all constraints are still satisfied. A theory T is checked on a total structure S by calling Modelcheck(T, S), with complexity in P.\nSubtask 6: Autocompletion\nIf a user is ready communicating his preferences (Subtask 1) and there are undecided terms left which he does not know or care about, the user may want to get a full configuration (i.e. a total structure). This is computed by modelexpand. In particular:\nI = Modelexpand(T,S)\nIn many of those situations the user wants to have a total structure with, for example, a minimal cost (given some term representing the cost t). This is computed by minimize:\nI = Minimize(T,S, t)\nExample 4.10. Assume the user is a secretary and all he knows is that he needs Office. He chooses Secretary for Requester and true for Install(Office) and calls autocompletion. A possible output is a structure S where for the remaining parameters, a choice is made that satisfies all constraints, e.g., Install(Windows)S = t, Install(DualBoot)S = t and the other Install atoms false. This is not a cheapest solution (lowest cost). By calling minimize using cost-term Cost, the DualBoot is dropped.\nSubtask 7: Explanation\nIt is clear that a whole variety of options can be developed to provide different kinds of explanations to a user. If a user supplies an inconsistent value for a parameter, options can range from calculating an inconsistent subset of the theory T (1) to giving a proof of inconsistency as in (Pontelli and Son 2006) (2), to calculating a\npartial subconfiguration that has this inconsistency (3). UnsatSubstructure is a logical inference for option 3.\nDefinition 4.11. Calculating inconsistent structures. UnsatSubstructure(T,S) is a derived inference with input a theory T and a partial structure S that cannot be extended to a model of T and as output all (partial) structures S \u2032 \u2264p S such that S \u2032 cannot be extended to a model I of T . Formally, we return:\n{S \u2032|S \u2032 \u2264p S \u2227 \u00ac(\u2203I \u2265p S \u2032 \u2227 I T )}\nComplexity of deciding if a set is an inconsistent substructure is in co\u2212NP.\nThe inference in Definition 4.12 calculates an inconsistent subtheory.\nDefinition 4.12. Calculating inconsistent theories. UnsatSubtheory(T,S) is a derived inference with input theory T and a partial structure S such that there does not exist a model I, extending S, satisfying T . The inference has as output all theories T \u2032 such that T \u2032 \u2286 T and there is no model satisfying T , extending S. Formally, we return:\n{T \u2032|T \u2032 \u2286 T \u2227 \u00ac(\u2203I \u2265p S \u2227 I T \u2032)}\nComplexity of deciding if a theory is such an inconsistent theory is in co\u2212NP.\nNote that Definition 4.11 and 4.12 do not make any statements of minimality. Using the associated theory TS and domains structure SD of a partial structure S, it is possible to consider calculating minimally precise partial configurations as a special case of calculating a minimal inconsistent subset of the theory. As in (Shchekotykhin et al. 2014), we can introduce a \u201cbackground theory\u201d B \u2282 T \u222a TS (a subset of the theory in which there are assumed to be no conflicts). We define multiple derived logical inferences, with different degrees of minimality (notminimal, subset-minimal and minimal in size) of increasing complexity, able to provide explanations to the user.\nDefinition 4.13. Calculating inconsistent theories with a background. UnsatSubtheory(T,S, B) is a derived inference with input theory T , a partial structure S and a background theory B \u2286 T \u222a TS such that there does not exist a model I, with the domains as in SD satisfying T \u222a TS (or equivalently: extending S and satisfying T ), but there is a model satisfying B. The inference has as output all theories T \u2032 such that B \u2286 T \u2032 \u2286 T \u222a TS and there is no model satisfying T . Formally, we return:\n{T \u2032|B \u2286 T \u2032 \u2286 (T \u222a TS) \u2227 \u00ac(\u2203I \u2265p SD \u2227 I T \u2032)}\nComplexity of deciding if a theory is such an inconsistent theory is in co\u2212NP.\nDefinition 4.14. Calculating minimal inconsistent theories with a background. MinimalUnsatTheory(T,S, B) is a derived inference with input theory T , a partial structure S and a background theory B as above. Output is the subset of subset\nminimal theories from UnsatSubtheory(T,S, B). Complexity of deciding if a set is a subset minimal inconsistent theory is in \u2206P2 .\nDefinition 4.15. Calculating minimum inconsistent theories with a background. MinimumUnsatTheory(T,S, B) is a derived inference with input theory T , a partial structure S and a background theory B as above. Output is the subset of cardinality minimal theories from MinimalUnsatTheory(T,S, B). Complexity of deciding if a set is a cardinality minimal inconsistent theory is \u03a0P2 .\nNote that Definition 4.11 is equivalent to calculating a minimal inconsistent subset of a theory T \u222a TS , with B = T , if you translate the output back to a pair of a theory and a structure. Definition 4.12 is equivalent to calculating a minimal inconsistent subset of a theory T \u222a TS , with B = TS , if you translate the output back to a pair of a theory and a structure.\nIn recent literature multiple approaches are discussed, all mapping to one of our explanation-related inferences. QuickXPlain (Junker 2004) is an algorithm that implements Definition 4.13. The Hitting Set Directed Acyclic Graph (HSDAG) (Reiter 1987) algorithm calculates subset minimal inconsistent theories (Definition 4.14, as in different ASP solvers (Shlyakhter et al. 2003; Syrja\u0308nen 2006). Implementations of Definition 4.15 have been described in (Lynce and Silva 2004) and (Zhang et al. 2006). In our experiment, we have an implementation of Definition 4.14 (Wittocx et al. 2009), where we do however do not calculate the entire set of subset minimal theories. We only calculate one, which gives one explanation of the inconsistency. If the user resolves that problem, he can ask for a new explanation which will point to another reason of inconsistency. This process is reiterated untill all problems are resolved.\nExample 4.16. We show a minimal inconsistent subtheory in a situation with T as in Example 4.1 and Si, a partial structure representing an intermediate configuration where a user started with S0 and has chosen Secretary for Requester, and wants to Install Office and Linux. This is not possible, and as such, the user asks the system for an explanation in the form of a minimal inconsistent theory. A possible minimal inconsistent theory with B = \u2205, is:\n(Install(Office) \u2227 PreReq(Office,Windows)) \u21d2 Install(Windows).\nCost = sum{(s, PriceOf(s))|Install(s)}.\nCost \u2264 MaxCost(Requester).\nThis means that there is no valid configuration because Windows needs to be installed as prerequisite for Office, and the total cost then exceeds the budget of a Secretary.\nSubtask 8: Backtracking\nIf a value for a parameter is not consistent, the user has to choose a new value for this parameter, or backtrack to revise a value for another parameter. In Section 3.2\nwe discussed three options of increasing complexity for implementing backtracking functionality. Erasing a value for a parameter is easy to provide in our KB system, and since this is a generalization of a back button (erasing the last value) we have a formalization of the first two options. Erasing a value d for parameter t in a partial structure S is simply modifying S such that (t = d)S = u. As with explanation, a number of more complex options can be developed. We look at one possibility. Given a partial configuration S, a parameter p and a value d that is inconsistent for that parameter, calculate a minimal set of previous choices that need to be undone such that this value is possible for this parameter. The converse of this problem is very well known under the name of maximum satisfiability problems. In other words, you want to hold on to as much of the structure as possible while ensuring satisfiability.\nThis problem is closely related to the explanation subtask (Heras et al. 2011; Marques-Silva and Planes 2008). You can imagine the explanation problem as asking the system to point out a mistake in your reasoning. However, solving this mistake will not guarantee you have not made any other mistake in the rest of the problem. What we actually need is a minimal set of things we can remove, so every problem is solved simultaneously.\nSo more formally, we can use Definition 4.11 and calculate UnsatStructure(T \u2227 (t = d),S). This inference calculates a set A of sets of previous choices that together are inconsistent. Undoing an arbitrary choice in all of these sets results in a partial subconfiguration S \u2032 of S such that d is a possible value for t in S \u2032. To find the maximal partial subconfiguration S \u2032 that satisfies that property, the minimal hitting set (Reiter 1987) of all sets in A has to be calculated."}, {"heading": "5 Proof of Concept", "text": ""}, {"heading": "5.1 Implementation", "text": "In this section we will describe the developed application and implementation. Our application has a simple client-server architecture. The server plays the role of the reasoning engine, which is mainly a thin wrapper around the IDP system. The client consists of a GUI made in QML (QML 2015) as front-end.\nThe server converts IDP into a stateless server which is accessible through the web. The client application sends the necessary information, consisting of theories, partial structures and choices, to this server and the server executes the needed inferences. This is a design which involves repeatedly sending over the choices a user has made, but it allows for a very simple architecture to show the feasibility of our design.\nThis implementation was done in cooperation with Adaptive Planet, a consulting company (Adaptive Planet 2015) that developed the user interface, and an international banking company that provided us with a substantial configuration problem for testing purposes. More practical information about this implementation, some screenshots, a downloadable demo and another example of a configuration system\ndeveloped with IDP as a reasoning engine (a simpler course configuration demo) can be found at: http://www.configuration.tk."}, {"heading": "5.1.1 The Reasoning Engine", "text": "As explained before, the application we developed was built on the knowledge base system IDP, which was not developed specifically with configuration problems in mind. It provides the basic inferences listed at the end of Section 2. The goal of this experiment was to check if this general infrastructure could be readily applied to applications such as configuration.\nIn Section 4 we showed how the tasks which are needed for configuration relate to the infrastructure provided by IDP. Our main implementation task was to convert these specifications to code. Some subtasks such as autocompletion did not require any extra work, as this functionality is directly available as the modelexpand inference. Some functionality, e.g. calculating consequences, did require some work but the existing functionality provided almost all needed components.\nWe mainly use the existing forms of inference that are readily available in the IDP system. No dedicated or specialized algorithms are used for the configuration subtasks. This proves the point that the KB-paradigm is very flexible but this also means that we had relatively little impact upon the efficiency of our server. However, the system ended up being quite responsive and we could conclude that IDP (and by extension the KB-paradigm) passed the test for usefulness in this application."}, {"heading": "5.1.2 User Interface", "text": "Apart from a reasoning engine, it is also necessary to have an accessible front end so the user has easy access to the multitude of functionalities which are available. The front end consists of an application written in the Qt framework using QML (QML 2015) and connects to a configuration engine over the web. For the purposes of our demo, we developed two different graphical interfaces:\nWizard In the wizard interface, the user is interrogated and he answers on subsequent questions selected by the system, using the GetOpenTerms inference. An important side note here is that the user can choose not to answer a specific question, for instance because he cannot decide as he is missing relevant information or because he is not interested in the actual value (at this point). These parameters can be filled in at a later timepoint by the user, or by the system, using propagation, or in case the user calls autocompletion.\nDrill-Down In the drill-down interface, the user sees a list of the still open parameters, and can pick which one he wants to fill in next. This interface is useful if the user is a bit more knowledgeable about the specific configuration and wants to give the values in a specific order.\nIn both interfaces the user is assisted in the same way when he enters data. When\nhe or the system selects a parameter, he is provided with a dropdown list of the possible values, using the GetConsistentV alues inference. Before committing to a choice, he is presented with the consequences of his choice, using the calculate consequences inference. The nature of the system guarantees a correct configuration and will automatically give the user support using all information it has (from the knowledge base, or received from the user)."}, {"heading": "5.2 Evaluation", "text": ""}, {"heading": "5.2.1 Evaluation Criteria", "text": "When evaluating the quality of software (especially when evaluating declarative methods), scalability (data complexity) is often seen as the most important quality metric. Naturally when using an interactive configuration system, performance is important. However, in the configuration community it is known that reasoning about typical configuration problems is relatively easy and does not exhibit real exponential behavior (Tiihonen et al. 2013). Also, depending on the application, it is reasonable to expect the number of parameters to be limited, since humans need to fill in the configuration in the end. When developing a configuration system, challenges lie in the complexity of the knowledge, its high volatility and the complex functionalities to be built. To get a more complete view of the performance of a configuration system, we chose to evaluate on a larger set of different evaluation criteria. In recent literature (Felfernig et al. 2014) nine evaluation criteria are used to differentiate between different paradigms used for configuration. In Section 6, ten other approaches will be discussed and compared to our solution using the same nine criteria.\nGrapical Modeling Concepts (C1) is supported if there are standard graphi-\ncal modeling techniques available that visualize configuration knowledge. They improve understandability, development time and maintenance of new knowledge bases. Component Oriented modeling (C2) is a criterion that states that the mod-\neling language is a natural language that allows knowledge base design on the basis of real-world concepts: types, relations, hierarchies, etc. Automated Consistency Maintenance (C3) can be broken down to two cat-\negories. Firstly, a system can have support for a priori automated consistency maintenance. This helps a developer write consistent constraints and verifying correctness while writing the knowledge base. Secondly, runtime automated consistency maintenance supports the end user, by guaranteeing that every intermediate configuration he can make, can be extended to a valid configuration. Modularization concepts are available (C4) if the modeling language is\nmodular and has support for adding additional structure to the knowledge base, for example by organizing the constraints in blocks or groups. Maintainability (C5) relates to the adaptability of the knowledge base if the\nbackground information changes. This background information is volatile, it is for example depending on ever-changing company policies. As such, it is vital\nthat when that information changes, the system can be easily adapted. When using custom software, all tasks using domain knowledge (like rules and policies) need their own program code. The domain knowledge is scattered all over the program. If this policy changes, a programmer has to find all snippets of program code that are relevant for guarding this policy and modify them. This results in a system that is hard to maintain, hard to adapt and error-prone. Every time the domain knowledge changes, a whole development cycle has to be run through again. Some systems have support for intelligent knowledge base navigation tools for complex knowledge spaces. Model-based (C6) means that a knowledge base in the system expresses exactly\nwhat it means for a configuration to be valid. This in contrast to rule-based configuration, where a knowledge base also contains problem solving knowledge (i.e. information on how the rules should be used/fired).\nEfficiency (C7) relates to efficiency and scalability of the reasoning engine. Ability to solve generative problem settings (C8) means that the language\nsupports talking about component types instead of specific objects. A system supports generic constraints if it allows for constraints that apply to every instance of a component type on which the constraint is defined. For example, the first constraint of Theory T in Example 4.1 is a generic constraint about all software, without explicitly naming the individual pieces of software. Ability to provide explanations (C9) means that the system is able to\ncommunicate reasons for inconsistencies or explain why certain choices are forced/prohibited."}, {"heading": "5.2.2 Evaluation", "text": "The criteria discussed in previous section are a good way to evaluate the KB implementation of a configuration system. We evaluate our implementation and the IDP system with these criteria.\nGrapical Modeling Concepts (C1). IDP has no support for graphical model-\ning of domain knowledge and we did not develop any tools for this experiment. However, it must be noted, that a highly expressive and readable modeling language often makes graphical modeling obsolete. Component Oriented modeling (C2). The FO(\u00b7) language used in this exper-\niment is an extension of typed first-order logic. First-order logic is about a small set of connectives: \u2227,\u2228,\u00ac,\u21d2,\u21d4, \u2203, \u2200. These connectives are also the basic connectives of information used by humans. Classical logic is a good KR language because it has a very clear informal semantics. It does however not suffice for knowledge representation. FO(\u00b7) extends classical logic with a number of extensions that arise from research in AI and KR, such as aggregates, inductive definitions, types, . . . This makes FO(\u00b7) a suited modeling language for a configuration system. Automated Consistency Maintenance (C3). A priori consistency mainte-\nnance is supported in the implementation by using the explanation inferences. If the developer has a collection of constraints that is consistent, it is possible\nto evaluate if a new constraint leads to an inconsistency and ask the system what other constraints it conflicts with, using for example definition 4.14. At runtime consistency maintenance is partially supported, by using the inferences in subtask 2, 3 and 4. These inferences are theoretically able to guarantee consistency, but due to computational limitations, approximate versions can be used. These are not always able to give the same guarantees.\nModularization concepts are available (C4). The implemented configura-\ntion system is modular, since a knowledge base can consist of multiple theories and structures, that together make up the specification. The explanation inference allows that a user selects background constraints, as in definition 4.14, and in this way he can choose about which constraints he needs feedback.\nMaintainability (C5). The development of a KB system with a centrally main-\ntained knowledge base makes the knowledge directly available, readable and adaptable. A well-known advantage of this approach is in maintainability: if domain information changes, the developer can easily modify the knowledge base. The current implementation does however have no additional support for knowledge base navigation tools.\nModel-based (C6). The FO(\u00b7) modeling methodology is based on formulating\nthe properties of a correct configuration in a natural way, such that the models of a specification correspond with configurations. This is inherently a model-based approach.\nEfficiency (C7). As explained in Section 5.1, we have only written a thin layer\nupon existing software which did not target configuration problems specifically. The performance of the IDP system has been tested extensively in other contexts (Jansen et al. 2014; Bruynooghe et al. 2015). The reasoning engine for IDP is very similar in performance to mainstream ASP solvers (Calimeri et al. 2014). Their performance was tested more extensively in the context of configuration by Tiihonen et al. (2013). It is also very difficult to reliably compare the response times for interactive systems. Standard benchmarking techniques in software engineering traditionally use instances which need multiple minutes to solve. In this setting we aim for subsecond response times, for which no standard benchmarks are available as far as we are aware. In this experiment (a configuration task with 300 parameters and 650 constraints), our users reported a response time of a half second on average with outliers up to 2 seconds. Note that the provided implementation was a naive prototype and optimizing the efficiency of the implemented algorithms is still possible in a number of ways.\nAbility to solve generative problem settings (C8). FO(\u00b7) is an extension of\nfirst-order logic, and as such has native support for quantification which is needed for generative problem settings.\nAbility to provide explanations (C9). Subtask 7 and 8 in Section 4 are infer-\nences that are used to support giving explanations. The implemented configuration system has an implementation of definition 4.14."}, {"heading": "6 Related Work", "text": ""}, {"heading": "6.1 Other approaches", "text": "In different branches of AI research, people have been focusing on configuration software in different settings. The following discussion of knowledge-based approaches is based on a book in recent literature (Felfernig et al. 2014). After the discussion we will compare the ten approaches with our approach (IDP).\nHistorically, the first knowledge-based configuration systems were rule-based (RBS) (McDermott 1982; Barker and O\u2019Connor 1989). These systems operate on a working memory and if the condition of a rule is fulfilled, it fires and modifies the working memory, applying the conclusion of that rule. Rule-based systems are sensitive to rule orderings. This complicates modification of the rule-base. More importantly, inclusion of problem solving knowledge in the rule-base, makes a rule-base problem specific and focused towards one specific task. This leads to the same problems as in imperative languages. To solve different tasks, more rule-bases have to be built, leading to duplication and fanning out of knowledge, giving issues in maintainability.\nConstraint Satisfaction Problems are widely used for tackling configuration problems (Mittal and Frayman 1989; Fleischanderl et al. 1998). A (static3) constraint satisfaction problem (SCSP) is a triple (V,D,C) of a set of domain variables V = {v1, v2, . . . , vn}, a set of domains {dom(v1), dom(v2), . . . , dom(vn)} and set of constraints C. A solution for a SCSP is an assignment S of domain elements di \u2208 dom(vi) to variables vi, such that each variable has a value in S and constraints C are satisfied by S. A configuration task in SCSP is searching for a solution for a SCSP (V,D,C), where C contains the configuration constraints together with the user preferences. To make efficient CSP configuration systems, different techniques have been used, such as local search (Li et al. 2005), symmetry breaking (Kiziltan et al. 2001) and knowledge compilation techniques such as binary decision diagrams (Hadzic and Andersen 2005). In response to limitations of SCSP in configuration, extensions have been developed. Dynamic Constraint Satisfaction Problems (DCSP) (Mittal and Falkenhainer 1990) allow for variables to be inactive or irrelevant. If a variable is inactive, it does not need a value in a solution (for example, when configuring a smartphone, no camera resolution is needed if no camera is present). Generative Constraint Satisfaction Problems (GCSP) (Fleischanderl et al. 1998) extends SCSP with component types and generative constraints.\nJanota (2008) studied a mapping of CSP to SAT to use a SAT solver to provide\nfunctionality for a configuration system.\nThere exist many graphical approaches for doing knowledge configuration, and visualizing a configuration model. Kang (1990) used feature models (FM) for modeling these concepts, while UML was proposed in (Falkner and Haselbo\u0308ck 2013). FM and UML configuration approaches have no reasoning algorithms, they need\n3 In constrast to dynamic and generative constraint satisfaction problem.\nto be used with external algorithms. Karatas et al. (2010) for example combined feature models with constraint logic programming (CLP) to provide reasoning and automated analysis.\nDecidable subsets of first-order logic, description logics (DL) are used often in context of the semantic web. They have also been used for the development of configuration systems (Hotz et al. 2006; McGuinness and Wright 1998). The trade-off for having decidable subsets of first-order logic is that they are limited in expressivity. This make domain knowledge in these systems less readable, less natural and harder to maintain. An ontology based method was also proposed by Vanden Bossche et al. (2007) using OWL.\nTiihonen et al. developed a configuration systemWeCoTin (Tiihonen et al. 2013), based on Answer Set Programming (ASP). WeCoTin uses Smodels, an ASP system, as inference engine, for propagating consequences of choices. Answer set programming (ASP) is a form of declarative programming based on the stablemodel semantics (Gelfond and Lifschitz 1988) for logic programs. The architecture of their reasoning engine is closely related to the reasoning engine we use. Also, in language, many similarities can be identified (Denecker et al. 2012), as they both have their roots in extended logic programming.\nCombinations of the above approaches are also proposed in literature, called hybrid (HB) configuration systems. Typically, they use a DL-based representation for the ontology, together with constraints. They combine reasoning engines from these fields to provide inference (Hotz et al. 2006)."}, {"heading": "6.2 Comparison of approaches", "text": "Felfernig et al. (2014) evaluated all these paradigms with respect to the evaluation criteria from Section 5.2.1. In Table 2, we show this evaluation, together with scores for our implementation in the IDP column, based on the discussion of Section 5.2.2.\nAll these approaches are focused towards one specific inference: ontologies are focused on deduction, rule systems are focused on backward/forward chaining, etc.\nThese approaches are less general then the KB paradigm, which is specifically designed to reuse the knowledge for different reasoning tasks. The contributions of this paper are different from previously discussed approaches: we analyzed IC problems from a Knowledge Representation point of view. This paper is a discussion of possible approaches and the importance of this point of view. We made a study of desired functionalities for an IC system and how we can define logical reasoning tasks to supply these functionalities. As far as we are aware, the language we used in this experiment is more expressive than earlier approaches.\nThe expressivity of the language is crucial for the usability of the approach. It allows us to address a broader range of applications, moreover it is easier to formalize and maintain the domain knowledge. Not discussed by Felfernig et al. (2014) et al is work by Vlaeminck et al. (2009). They did a preliminary experiment using the KB approach for interactive configuration, also using the FO(\u00b7) IDP project. It is on this work that we continue in this paper by analyzing a real-life application of a larger scale and discussing new functionalities and inferences. This theoretical approach benefits from (1) the expressive language to express domain knowledge adequately and (2) the general basic inferences that realise derived inferences in an easy way, supporting the discussed functionalities, resulting in a IC system that scores very well with relation to the evaluation criteria (Table 2).\nAn interesting remark in Table 2 is that the IDP column resembles the GCSP column, a generalisation of CSP, developed for configuration. The IDP-system has better support for C5 (maintainability), due to the high level modeling language and the strict seperation between domain knowledge and reasoning. GCSP has better efficiency results. This can be partly explained by the fact that CSP uses dedicated algorithms for reasoning over global constraints such as alldifferent. The goal of reusing knowledge makes that we typically do not make use of this kind of specific algorithms, since a dedicated algorithm can only be developed with one specific inference in mind."}, {"heading": "7 Challenges and Future Work", "text": "Interactive configuration problems are part of a broader kind of problems, namely service provisioning problems. Service provisioning is the problem domain of coupling service providers with end users, starting from the request until the delivery of the service. Traditionally, such problems start with designing a configuration system that allows users to communicate their wishes, for which we provided a knowledge-based solution. Once all the information is gathered from a user, it is still necessary to make a plan for the production and delivery of the selected configuration. Hence the configuration problem is followed by a planning problem that shares domain knowledge with the configuration problem but that also has its own domain knowledge about providers of components, production processes, etc. This planning problem then leads to a monitoring problem. Authorizations could be required, payments need to be checked, or it could be that the configuration becomes invalid mid-process. In this case the configuration needs to be redone, but preferably without losing much of the work that is already done. Companies need software\nthat can manage and monitor the whole chain, from initial configuration to final delivery and this without duplication of domain knowledge. This is a problem area where the KB approach holds great promise but where further research is needed to integrate the KB system with the environment that the company uses to follow up its processes.\nOther future work may include language extensions to better support configuration-like tasks. A prime example of this are templates (Dasseville et al. 2015). Oftentimes the theory of a configuration problem contains lots of constraints which are similar in structure. It seems natural to introduce a language construct to abstract away the common parts. Another useful language extension is reification, to talk about the symbols in a specification rather than about their interpretation. Reification allows the system to reason on a meta level about the symbol and for example assign symbols to a category like \u201cTechnical\u201d or \u201cAdministrative\u201d."}, {"heading": "8 Conclusion", "text": "The KB paradigm, in which a strict separation between knowledge and problem solving is proposed, was analyzed in a class of knowledge intensive problems: interactive configuration problems. As we discussed why solutions for this class are hard to develop, we proposed a novel approach to the configuration problem based on an existing KB system. We analyzed the functional requirements of an IC system and investigated how we can provide these, using logical inferences on a knowledge base. We identified interesting new inference methods and applied them to the interactive configuration domain. We studied this approach in context of a large application, for which we built a proof of concept, using the KB system as an engine, which we extended with the new inferences. As proof of concept, we solved a configuration problem for a large banking company. Results are convincing and open perspectives for further research in service provisioning."}], "references": [{"title": "Adaptive planet", "author": ["Adaptive Planet"], "venue": "http://www.adaptiveplanet.com/.", "citeRegEx": "Planet,? 2015", "shortCiteRegEx": "Planet", "year": 2015}, {"title": "A tool for developing interactive configuration applications", "author": ["T. Axling", "S. Haridi"], "venue": "Journal of Logic Programming 26, 2, 147\u2013168.", "citeRegEx": "Axling and Haridi,? 1996", "shortCiteRegEx": "Axling and Haridi", "year": 1996}, {"title": "Expert systems for configuration at digital: XCON and beyond", "author": ["V.E. Barker", "D.E. O\u2019Connor"], "venue": "Commun. ACM 32,", "citeRegEx": "Barker and O.Connor,? \\Q1989\\E", "shortCiteRegEx": "Barker and O.Connor", "year": 1989}, {"title": "Simulating dynamic systems using linear time calculus theories", "author": ["B. Bogaerts", "J. Jansen", "M. Bruynooghe", "B. De Cat", "J. Vennekens", "M. Denecker"], "venue": "TPLP 14, 4\u20135 (7), 477\u2013492.", "citeRegEx": "Bogaerts et al\\.,? 2014", "shortCiteRegEx": "Bogaerts et al\\.", "year": 2014}, {"title": "Predicate logic as a modeling language: modeling and solving some machine learning and data mining problems with IDP3", "author": ["M. Bruynooghe", "H. Blockeel", "B. Bogaerts", "B. De Cat", "S. De Pooter", "J. Jansen", "A. Labarre", "J. Ramon", "M. Denecker", "S. Verwer"], "venue": "TPLP 15, 783\u2013817.", "citeRegEx": "Bruynooghe et al\\.,? 2015", "shortCiteRegEx": "Bruynooghe et al\\.", "year": 2015}, {"title": "The third open answer set programming competition", "author": ["F. Calimeri", "G. Ianni", "F. Ricca"], "venue": "TPLP 14, 1, 117\u2013135.", "citeRegEx": "Calimeri et al\\.,? 2014", "shortCiteRegEx": "Calimeri et al\\.", "year": 2014}, {"title": "Semantics of templates in a compositional framework for building logics", "author": ["I. Dasseville", "M. van der Hallen", "G. Janssens", "M. Denecker"], "venue": "TPLP 15,", "citeRegEx": "Dasseville et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dasseville et al\\.", "year": 2015}, {"title": "Predicate logic as a modelling language: The IDP system", "author": ["B. De Cat", "B. Bogaerts", "M. Bruynooghe", "G. Janssens", "M. Denecker"], "venue": "CoRR abs/1401.6312v2.", "citeRegEx": "Cat et al\\.,? 2016", "shortCiteRegEx": "Cat et al\\.", "year": 2016}, {"title": "A Tarskian informal semantics for answer set programming", "author": ["M. Denecker", "Y. Lierler", "M. Truszczy\u0144ski", "J. Vennekens"], "venue": "ICLP (Technical Communications), A. Dovier and V. S. Costa, Eds. LIPIcs, vol. 17. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 277\u2013289.", "citeRegEx": "Denecker et al\\.,? 2012", "shortCiteRegEx": "Denecker et al\\.", "year": 2012}, {"title": "A logic of nonmonotone inductive definitions", "author": ["M. Denecker", "E. Ternovska"], "venue": "ACM Trans. Comput. Log. 9, 2 (Apr.), 14:1\u201314:52.", "citeRegEx": "Denecker and Ternovska,? 2008", "shortCiteRegEx": "Denecker and Ternovska", "year": 2008}, {"title": "Building a knowledge base system for an integration of logic programming and classical logic", "author": ["M. Denecker", "J. Vennekens"], "venue": "ICLP, M. Gar\u0107\u0131a de la Banda and E. Pontelli, Eds. LNCS, vol. 5366. Springer, 71\u201376.", "citeRegEx": "Denecker and Vennekens,? 2008", "shortCiteRegEx": "Denecker and Vennekens", "year": 2008}, {"title": "Challenges of knowledge evolution in practice", "author": ["A.A. Falkner", "A. Haselb\u00f6ck"], "venue": "AI Communications 26, 1, 3\u201314.", "citeRegEx": "Falkner and Haselb\u00f6ck,? 2013", "shortCiteRegEx": "Falkner and Haselb\u00f6ck", "year": 2013}, {"title": "Knowledge-based Configuration: From Research to Business Cases, 1st ed", "author": ["A. Felfernig", "L. Hotz", "C. Bagley", "J. Tiihonen"], "venue": "Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.", "citeRegEx": "Felfernig et al\\.,? 2014", "shortCiteRegEx": "Felfernig et al\\.", "year": 2014}, {"title": "Configuring large systems using generative constraint satisfaction", "author": ["G. Fleischanderl", "G. Friedrich", "A. Haselb\u00f6ck", "H. Schreiner", "M. Stumptner"], "venue": "IEEE Intelligent Systems 13, 4, 59\u201368.", "citeRegEx": "Fleischanderl et al\\.,? 1998", "shortCiteRegEx": "Fleischanderl et al\\.", "year": 1998}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "ICLP/SLP, R. A. Kowalski and K. A. Bowen, Eds. MIT Press, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "A BDD-based approach to interactive configuration", "author": ["T. Hadzic"], "venue": "Principles and Practice of Constraint Programming - CP 2004, 10th International Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings, M. Wallace, Ed. LNCS, vol. 3258. Springer, 797.", "citeRegEx": "Hadzic,? 2004", "shortCiteRegEx": "Hadzic", "year": 2004}, {"title": "Interactive reconfiguration in power supply restoration", "author": ["T. Hadzic", "H.R. Andersen"], "venue": "Principles and Practice of Constraint Programming - CP 2005, 11th International Conference, CP 2005, Sitges, Spain, October 1-5, 2005, Proceedings, P. van Beek, Ed. Lecture Notes in Computer Science, vol. 3709. Springer, 767\u2013771.", "citeRegEx": "Hadzic and Andersen,? 2005", "shortCiteRegEx": "Hadzic and Andersen", "year": 2005}, {"title": "Core-guided binary search algorithms for maximum satisfiability", "author": ["F. Heras", "A. Morgado", "J. Marques-Silva"], "venue": "Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence, AAAI 2011, San Francisco, California, USA, August 7-11, 2011.", "citeRegEx": "Heras et al\\.,? 2011", "shortCiteRegEx": "Heras et al\\.", "year": 2011}, {"title": "Configuration in industrial product families - the ConIPF methodology", "author": ["L. Hotz", "T. Krebs", "S. Deelstra", "M. Sinnema", "J. Nijhuis"], "venue": "IOS Press, Inc.", "citeRegEx": "Hotz et al\\.,? 2006", "shortCiteRegEx": "Hotz et al\\.", "year": 2006}, {"title": "Model checking and transitive-closure logic", "author": ["N. Immerman", "M.Y. Vardi"], "venue": "Computer Aided Verification, 9th International Conference, CAV \u201997, Haifa, Israel, June 22-25, 1997, Proceedings, O. Grumberg, Ed. Lecture Notes in Computer Science, vol. 1254. Springer, 291\u2013302.", "citeRegEx": "Immerman and Vardi,? 1997", "shortCiteRegEx": "Immerman and Vardi", "year": 1997}, {"title": "Do SAT solvers make good configurators? In Software Product Lines, 12th International Conference, SPLC 2008, Limerick, Ireland, September 8-12, 2008, Proceedings", "author": ["M. Janota"], "venue": "Second Volume (Workshops), S. Thiel and K. Pohl, Eds. Lero Int. Science Centre, University of Limerick, Ireland, 191\u2013195.", "citeRegEx": "Janota,? 2008", "shortCiteRegEx": "Janota", "year": 2008}, {"title": "Experimental evaluation of a state-of-the-art grounder", "author": ["J. Jansen", "I. Dasseville", "J. Devriendt", "G. Janssens"], "venue": "Proceedings of the 16th International Symposium on Principles and Practice of Declarative Programming, Kent, Canterbury, United Kingdom, September 8-10, 2014, O. Chitil, A. King, and O. Danvy, Eds. ACM, 249\u2013258.", "citeRegEx": "Jansen et al\\.,? 2014", "shortCiteRegEx": "Jansen et al\\.", "year": 2014}, {"title": "QUICKXPLAIN: preferred explanations and relaxations for overconstrained problems", "author": ["U. Junker"], "venue": "Proceedings of the Nineteenth National Conference on Artificial Intelligence, Sixteenth Conference on Innovative Applications of Artificial Intelligence,", "citeRegEx": "Junker,? 2004", "shortCiteRegEx": "Junker", "year": 2004}, {"title": "Preference programming: Advanced problem solving for configuration", "author": ["U. Junker", "D. Mailharro"], "venue": "AI EDAM 17, 1, 13\u201329.", "citeRegEx": "Junker and Mailharro,? 2003", "shortCiteRegEx": "Junker and Mailharro", "year": 2003}, {"title": "Feature-oriented Domain Analysis (FODA): Feasibility Study ; Technical Report CMU/SEI-90-TR-21 - ESD-90-TR-222", "author": ["K. Kang"], "venue": "Software Engineering Inst., Carnegie Mellon Univ.", "citeRegEx": "Kang,? 1990", "shortCiteRegEx": "Kang", "year": 1990}, {"title": "Mapping extended feature models to constraint logic programming over finite domains", "author": ["A.S. Karatas", "H. Oguzt\u00fcz\u00fcn", "A.H. Dogru"], "venue": "Software Product Lines: Going Beyond - 14th International Conference, SPLC 2010, Jeju Island, South Korea, September 13-17, 2010. Proceedings, J. Bosch and J. Lee, Eds. Lecture Notes in Computer Science, vol. 6287. Springer, 286\u2013299.", "citeRegEx": "Karatas et al\\.,? 2010", "shortCiteRegEx": "Karatas et al\\.", "year": 2010}, {"title": "Towards inferring labelling heuristics for CSP application domains", "author": ["Z. Kiziltan", "P. Flener", "B. Hnich"], "venue": "KI 2001: Advances in Artificial Intelligence, Joint German/Austrian Conference on AI, Vienna, Austria, September 19-21, 2001, Proceedings, F. Baader, G. Brewka, and T. Eiter, Eds. LNCS, vol. 2174. Springer, 275\u2013289.", "citeRegEx": "Kiziltan et al\\.,? 2001", "shortCiteRegEx": "Kiziltan et al\\.", "year": 2001}, {"title": "Introduction to Metamathematics", "author": ["S.C. Kleene"], "venue": "Van Nostrand.", "citeRegEx": "Kleene,? 1952", "shortCiteRegEx": "Kleene", "year": 1952}, {"title": "Product configuration optimization using a multiobjective genetic algorithm", "author": ["B. Li", "L. Chen", "Z. Huang", "Y. Zhong"], "venue": "The International Journal of Advanced Manufacturing Technology 30, 1, 20\u201329.", "citeRegEx": "Li et al\\.,? 2005", "shortCiteRegEx": "Li et al\\.", "year": 2005}, {"title": "On computing minimum unsatisfiable cores", "author": ["I. Lynce", "J.P.M. Silva"], "venue": "SAT 2004 - The Seventh International Conference on Theory and Applications of Satisfiability Testing, 10-13 May 2004, Vancouver, BC, Canada, Online Proceedings.", "citeRegEx": "Lynce and Silva,? 2004", "shortCiteRegEx": "Lynce and Silva", "year": 2004}, {"title": "Algorithms for maximum satisfiability using unsatisfiable cores", "author": ["J. Marques-Silva", "J. Planes"], "venue": "Design, Automation and Test in Europe, DATE 2008, Munich, Germany, March 10-14, 2008. 408\u2013413.", "citeRegEx": "Marques.Silva and Planes,? 2008", "shortCiteRegEx": "Marques.Silva and Planes", "year": 2008}, {"title": "R1: A rule-based configurer of computer systems", "author": ["J.P. McDermott"], "venue": "Artif. Intell. 19, 1, 39\u201388.", "citeRegEx": "McDermott,? 1982", "shortCiteRegEx": "McDermott", "year": 1982}, {"title": "An industrial-strength description-logicsbased configurator platform", "author": ["D.L. McGuinness", "J.R. Wright"], "venue": "IEEE Intelligent Systems 13, 4, 69\u201377.", "citeRegEx": "McGuinness and Wright,? 1998", "shortCiteRegEx": "McGuinness and Wright", "year": 1998}, {"title": "A framework for representing and solving NP search problems", "author": ["D.G. Mitchell", "E. Ternovska"], "venue": "AAAI, M. M. Veloso and S. Kambhampati, Eds. AAAI Press / The MIT Press, 430\u2013435.", "citeRegEx": "Mitchell and Ternovska,? 2005", "shortCiteRegEx": "Mitchell and Ternovska", "year": 2005}, {"title": "Dynamic constraint satisfaction problems", "author": ["S. Mittal", "B. Falkenhainer"], "venue": "Proceedings of the 8th National Conference on Artificial Intelligence. Boston, Massachusetts, July 29 - August 3, 1990, 2 Volumes., T. Dieterich and W. Swartout, Eds. AAAI/MIT Press, 25\u201332.", "citeRegEx": "Mittal and Falkenhainer,? 1990", "shortCiteRegEx": "Mittal and Falkenhainer", "year": 1990}, {"title": "Towards a generic model of configuraton tasks", "author": ["S. Mittal", "F. Frayman"], "venue": "Proceedings of the 11th International Joint Conference on Artificial Intelligence. Detroit, MI, USA, August 1989, N. S. Sridharan, Ed. Morgan Kaufmann, 1395\u20131401.", "citeRegEx": "Mittal and Frayman,? 1989", "shortCiteRegEx": "Mittal and Frayman", "year": 1989}, {"title": "Well-founded and stable semantics of logic programs with aggregates", "author": ["N. Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "TPLP 7, 3, 301\u2013353.", "citeRegEx": "Pelov et al\\.,? 2007", "shortCiteRegEx": "Pelov et al\\.", "year": 2007}, {"title": "Strategic capabilities of mass customization based e-commerce: Construct development and empirical test", "author": ["F.T. Piller", "T. Harzer", "C. Ihl", "F. Salvador"], "venue": "47th Hawaii International Conference on System Sciences, HICSS 2014, Waikoloa, HI, USA, January 6-9, 2014. IEEE, 3255\u20133264.", "citeRegEx": "Piller et al\\.,? 2014", "shortCiteRegEx": "Piller et al\\.", "year": 2014}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. Pontelli", "T.C. Son"], "venue": "ICLP, S. Etalle and M. Truszczy\u0144ski, Eds. LNCS, vol. 4079. Springer, 196\u2013210.", "citeRegEx": "Pontelli and Son,? 2006", "shortCiteRegEx": "Pontelli and Son", "year": 2006}, {"title": "Qml", "author": ["QML"], "venue": "http://qmlbook.org/.", "citeRegEx": "QML,? 2015", "shortCiteRegEx": "QML", "year": 2015}, {"title": "A theory of diagnosis from first principles", "author": ["R. Reiter"], "venue": "Artif. Intell. 32, 1, 57\u201395.", "citeRegEx": "Reiter,? 1987", "shortCiteRegEx": "Reiter", "year": 1987}, {"title": "Fdconfig: A constraint-based interactive product configurator", "author": ["D. Schneeweiss", "P. Hofstedt"], "venue": "Applications of Declarative Programming and Knowledge Management - 19th International Conference, INAP 2011, and 25th Workshop on Logic Programming, WLP 2011, Vienna, Austria, September 28-30, 2011, Revised Selected Papers, H. Tompits, S. Abreu, J. Oetsch, J. P\u00fchrer, D. Seipel, M. Umeda, and A. Wolf,", "citeRegEx": "Schneeweiss and Hofstedt,? 2011", "shortCiteRegEx": "Schneeweiss and Hofstedt", "year": 2011}, {"title": "Interactive ontology debugging using direct diagnosis", "author": ["K.M. Shchekotykhin", "G. Friedrich", "P. Rodler", "P. Fleiss"], "venue": "Proceedings of the Third International Workshop on Debugging Ontologies and Ontology Mappings, WoDOOM 2014, co-located with 11th Extended Semantic Web Conference (ESWC 2014), Anissaras/Hersonissou, Greece, May 26, 2014., P. Lambrix, G. Qi, M. Horridge, and B. Parsia, Eds. CEUR", "citeRegEx": "Shchekotykhin et al\\.,? 2014", "shortCiteRegEx": "Shchekotykhin et al\\.", "year": 2014}, {"title": "Debugging overconstrained declarative models using unsatisfiable cores", "author": ["I. Shlyakhter", "R. Seater", "D. Jackson", "M. Sridharan", "M. Taghdiri"], "venue": "ASE. IEEE Computer Society, 94\u2013105.", "citeRegEx": "Shlyakhter et al\\.,? 2003", "shortCiteRegEx": "Shlyakhter et al\\.", "year": 2003}, {"title": "Debugging inconsistent answer set programs", "author": ["T. Syrj\u00e4nen"], "venue": "Proceedings of the Eleventh International Workshop on Non-Monotonic Reasoning, NMR 2006, Lake District, UK, 30 May - 1 June, J. Dix and A. Hunter, Eds. 77\u201384.", "citeRegEx": "Syrj\u00e4nen,? 2006", "shortCiteRegEx": "Syrj\u00e4nen", "year": 2006}, {"title": "Wecotin - A practical logic-based sales configurator", "author": ["J. Tiihonen", "M. Heiskala", "A. Anderson", "T. Soininen"], "venue": "AI Commun. 26, 1, 99\u2013131.", "citeRegEx": "Tiihonen et al\\.,? 2013", "shortCiteRegEx": "Tiihonen et al\\.", "year": 2013}, {"title": "Ontology driven software engineering for real life applications", "author": ["M. Vanden Bossche", "P. Ross", "I. MacLarty", "B. Van Nuffelen", "N. Pelov"], "venue": "3rd International Workshop on Semantic Web Enabled Software Engineering (SWESE).", "citeRegEx": "Bossche et al\\.,? 2007", "shortCiteRegEx": "Bossche et al\\.", "year": 2007}, {"title": "A logical framework for configuration software", "author": ["H. Vlaeminck", "J. Vennekens", "M. Denecker"], "venue": "Proceedings of the 11th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming, September 7-9, 2009, Coimbra, Portugal, A. Porto and F. J. L\u00f3pez-Fraguas, Eds. ACM, 141\u2013148.", "citeRegEx": "Vlaeminck et al\\.,? 2009", "shortCiteRegEx": "Vlaeminck et al\\.", "year": 2009}, {"title": "The idp system: A model expansion system for an extension of classical logic", "author": ["J. Wittocx", "M. Mari\u00ebn", "M. Denecker"], "venue": null, "citeRegEx": "Wittocx et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wittocx et al\\.", "year": 2008}, {"title": "Debugging for model expansion", "author": ["J. Wittocx", "H. Vlaeminck", "M. Denecker"], "venue": "Eds. LNCS,", "citeRegEx": "Wittocx et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Wittocx et al\\.", "year": 2009}, {"title": "Extracting minimum unsatisfiable cores with a greedy genetic algorithm", "author": ["J. Zhang", "S. Li", "S. Shen"], "venue": "AI 2006: Advances in Artificial Intelligence, 19th Australian Joint Conference on Artificial Intelligence, Hobart, Australia, December 4-8, 2006, Proceedings. 847\u2013856.", "citeRegEx": "Zhang et al\\.,? 2006", "shortCiteRegEx": "Zhang et al\\.", "year": 2006}], "referenceMentions": [{"referenceID": 10, "context": "The Knowledge Base (KB) paradigm (Denecker and Vennekens 2008) was proposed as an answer to this.", "startOffset": 33, "endOffset": 62}, {"referenceID": 10, "context": "The FO(\u00b7) KB project (Denecker and Vennekens 2008) is a research project that runs now for a number of years.", "startOffset": 21, "endOffset": 50}, {"referenceID": 9, "context": "So far, it has led to the KB language FO(\u00b7) (Denecker and Ternovska 2008) and the KB system IDP (De Cat et al.", "startOffset": 44, "endOffset": 73}, {"referenceID": 31, "context": "An interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989; Fleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem.", "startOffset": 42, "endOffset": 150}, {"referenceID": 35, "context": "An interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989; Fleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem.", "startOffset": 42, "endOffset": 150}, {"referenceID": 13, "context": "An interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989; Fleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem.", "startOffset": 42, "endOffset": 150}, {"referenceID": 23, "context": "An interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989; Fleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem.", "startOffset": 42, "endOffset": 150}, {"referenceID": 15, "context": "An interactive configuration (IC) problem (McDermott 1982; Mittal and Frayman 1989; Fleischanderl et al. 1998; Junker and Mailharro 2003; Hadzic 2004) is an interactive version of a constraint solving problem.", "startOffset": 42, "endOffset": 150}, {"referenceID": 12, "context": "However, building such software is renowned in industry as difficult and no broadly accepted solution methods are available (Felfernig et al. 2014; Axling and Haridi 1996).", "startOffset": 124, "endOffset": 171}, {"referenceID": 1, "context": "However, building such software is renowned in industry as difficult and no broadly accepted solution methods are available (Felfernig et al. 2014; Axling and Haridi 1996).", "startOffset": 124, "endOffset": 171}, {"referenceID": 2, "context": "Building software support using standard imperative programming is often a nightmare (Barker and O\u2019Connor 1989; Piller et al. 2014), due to the fact that (1) many functionalities need to be provided, (2) they are complex to implement, and (3) constraints on the configuration tend to get duplicated and spread out over the application, in the form of snippets of code performing various computations relative to the constraint (e.", "startOffset": 85, "endOffset": 131}, {"referenceID": 37, "context": "Building software support using standard imperative programming is often a nightmare (Barker and O\u2019Connor 1989; Piller et al. 2014), due to the fact that (1) many functionalities need to be provided, (2) they are complex to implement, and (3) constraints on the configuration tend to get duplicated and spread out over the application, in the form of snippets of code performing various computations relative to the constraint (e.", "startOffset": 85, "endOffset": 131}, {"referenceID": 15, "context": "That declarative methods are particularly suitable for solving this type of problem has been acknowledged before, and several systems and languages have been developed (Hadzic 2004; Schneeweiss and Hofstedt 2011; Tiihonen et al. 2013; Vlaeminck et al. 2009).", "startOffset": 168, "endOffset": 257}, {"referenceID": 41, "context": "That declarative methods are particularly suitable for solving this type of problem has been acknowledged before, and several systems and languages have been developed (Hadzic 2004; Schneeweiss and Hofstedt 2011; Tiihonen et al. 2013; Vlaeminck et al. 2009).", "startOffset": 168, "endOffset": 257}, {"referenceID": 45, "context": "That declarative methods are particularly suitable for solving this type of problem has been acknowledged before, and several systems and languages have been developed (Hadzic 2004; Schneeweiss and Hofstedt 2011; Tiihonen et al. 2013; Vlaeminck et al. 2009).", "startOffset": 168, "endOffset": 257}, {"referenceID": 47, "context": "That declarative methods are particularly suitable for solving this type of problem has been acknowledged before, and several systems and languages have been developed (Hadzic 2004; Schneeweiss and Hofstedt 2011; Tiihonen et al. 2013; Vlaeminck et al. 2009).", "startOffset": 168, "endOffset": 257}, {"referenceID": 9, "context": "The logic used in this experiment is the logic FO(\u00b7) (Denecker and Ternovska 2008), an extension of first-order logic (FO), and the system is the IDP system (De Cat et al.", "startOffset": 53, "endOffset": 82}, {"referenceID": 12, "context": "We evaluated our approach using the evaluation criteria of the knowledge-based configuration research (Felfernig et al. 2014).", "startOffset": 102, "endOffset": 125}, {"referenceID": 19, "context": "construction (Immerman and Vardi 1997).", "startOffset": 13, "endOffset": 38}, {"referenceID": 9, "context": "Currently, the language of the IDP system in the project is FO(T, ID, Agg, arit, PF) (Denecker and Ternovska 2008; Pelov et al. 2007): FO extended with types, definitions, aggregates, arithmetic and partial functions.", "startOffset": 85, "endOffset": 133}, {"referenceID": 36, "context": "Currently, the language of the IDP system in the project is FO(T, ID, Agg, arit, PF) (Denecker and Ternovska 2008; Pelov et al. 2007): FO extended with types, definitions, aggregates, arithmetic and partial functions.", "startOffset": 85, "endOffset": 133}, {"referenceID": 27, "context": "To define the satisfaction relation on theories, we extend the interpretation of symbols to arbitrary terms and formulas using the Kleene truth assignments (Kleene 1952).", "startOffset": 156, "endOffset": 169}, {"referenceID": 48, "context": "Modelexpand (Wittocx et al. 2008) is a generalization for FO(\u00b7) theories of the modelexpansion task as defined in Mitchell et al.", "startOffset": 12, "endOffset": 33}, {"referenceID": 33, "context": "(Mitchell and Ternovska 2005).", "startOffset": 0, "endOffset": 29}, {"referenceID": 47, "context": "Approximative versions exist for some of these inferences, with lower complexity (Vlaeminck et al. 2009).", "startOffset": 81, "endOffset": 104}, {"referenceID": 3, "context": "More inferences exist, such as simulation of temporal theories in FO(\u00b7) (Bogaerts et al. 2014), but were not used in the experiment.", "startOffset": 72, "endOffset": 94}, {"referenceID": 33, "context": "Complexity results of derived inferences stem from basic results formulated by Mitchell and Ternovska (2005) and the observation that modelchecking is polynomial in the size of the domain.", "startOffset": 79, "endOffset": 109}, {"referenceID": 38, "context": "If a user supplies an inconsistent value for a parameter, options can range from calculating an inconsistent subset of the theory T (1) to giving a proof of inconsistency as in (Pontelli and Son 2006) (2), to calculating a", "startOffset": 177, "endOffset": 200}, {"referenceID": 42, "context": "As in (Shchekotykhin et al. 2014), we can introduce a \u201cbackground theory\u201d B \u2282 T \u222a TS (a subset of the theory in which there are assumed to be no conflicts).", "startOffset": 6, "endOffset": 33}, {"referenceID": 22, "context": "QuickXPlain (Junker 2004) is an algorithm that implements Definition 4.", "startOffset": 12, "endOffset": 25}, {"referenceID": 40, "context": "The Hitting Set Directed Acyclic Graph (HSDAG) (Reiter 1987) algorithm calculates subset minimal inconsistent theories (Definition 4.", "startOffset": 47, "endOffset": 60}, {"referenceID": 43, "context": "14, as in different ASP solvers (Shlyakhter et al. 2003; Syrj\u00e4nen 2006).", "startOffset": 32, "endOffset": 71}, {"referenceID": 44, "context": "14, as in different ASP solvers (Shlyakhter et al. 2003; Syrj\u00e4nen 2006).", "startOffset": 32, "endOffset": 71}, {"referenceID": 29, "context": "15 have been described in (Lynce and Silva 2004) and (Zhang et al.", "startOffset": 26, "endOffset": 48}, {"referenceID": 50, "context": "15 have been described in (Lynce and Silva 2004) and (Zhang et al. 2006).", "startOffset": 53, "endOffset": 72}, {"referenceID": 49, "context": "14 (Wittocx et al. 2009), where we do however do not calculate the entire set of subset minimal theories.", "startOffset": 3, "endOffset": 24}, {"referenceID": 17, "context": "This problem is closely related to the explanation subtask (Heras et al. 2011; Marques-Silva and Planes 2008).", "startOffset": 59, "endOffset": 109}, {"referenceID": 30, "context": "This problem is closely related to the explanation subtask (Heras et al. 2011; Marques-Silva and Planes 2008).", "startOffset": 59, "endOffset": 109}, {"referenceID": 40, "context": "To find the maximal partial subconfiguration S \u2032 that satisfies that property, the minimal hitting set (Reiter 1987) of all sets in A has to be calculated.", "startOffset": 103, "endOffset": 116}, {"referenceID": 39, "context": "The client consists of a GUI made in QML (QML 2015) as front-end.", "startOffset": 41, "endOffset": 51}, {"referenceID": 39, "context": "The front end consists of an application written in the Qt framework using QML (QML 2015) and connects to a configuration engine over the web.", "startOffset": 79, "endOffset": 89}, {"referenceID": 45, "context": "However, in the configuration community it is known that reasoning about typical configuration problems is relatively easy and does not exhibit real exponential behavior (Tiihonen et al. 2013).", "startOffset": 170, "endOffset": 192}, {"referenceID": 12, "context": "In recent literature (Felfernig et al. 2014) nine evaluation criteria are used to differentiate between different paradigms used for configuration.", "startOffset": 21, "endOffset": 44}, {"referenceID": 21, "context": "The performance of the IDP system has been tested extensively in other contexts (Jansen et al. 2014; Bruynooghe et al. 2015).", "startOffset": 80, "endOffset": 124}, {"referenceID": 4, "context": "The performance of the IDP system has been tested extensively in other contexts (Jansen et al. 2014; Bruynooghe et al. 2015).", "startOffset": 80, "endOffset": 124}, {"referenceID": 5, "context": "The reasoning engine for IDP is very similar in performance to mainstream ASP solvers (Calimeri et al. 2014).", "startOffset": 86, "endOffset": 108}, {"referenceID": 4, "context": "2014; Bruynooghe et al. 2015). The reasoning engine for IDP is very similar in performance to mainstream ASP solvers (Calimeri et al. 2014). Their performance was tested more extensively in the context of configuration by Tiihonen et al. (2013). It is also very difficult to reliably compare the response times for interactive systems.", "startOffset": 6, "endOffset": 245}, {"referenceID": 12, "context": "The following discussion of knowledge-based approaches is based on a book in recent literature (Felfernig et al. 2014).", "startOffset": 95, "endOffset": 118}, {"referenceID": 31, "context": "Historically, the first knowledge-based configuration systems were rule-based (RBS) (McDermott 1982; Barker and O\u2019Connor 1989).", "startOffset": 84, "endOffset": 126}, {"referenceID": 2, "context": "Historically, the first knowledge-based configuration systems were rule-based (RBS) (McDermott 1982; Barker and O\u2019Connor 1989).", "startOffset": 84, "endOffset": 126}, {"referenceID": 35, "context": "Constraint Satisfaction Problems are widely used for tackling configuration problems (Mittal and Frayman 1989; Fleischanderl et al. 1998).", "startOffset": 85, "endOffset": 137}, {"referenceID": 13, "context": "Constraint Satisfaction Problems are widely used for tackling configuration problems (Mittal and Frayman 1989; Fleischanderl et al. 1998).", "startOffset": 85, "endOffset": 137}, {"referenceID": 28, "context": "To make efficient CSP configuration systems, different techniques have been used, such as local search (Li et al. 2005), symmetry breaking (Kiziltan et al.", "startOffset": 103, "endOffset": 119}, {"referenceID": 26, "context": "2005), symmetry breaking (Kiziltan et al. 2001) and knowledge compilation techniques such as binary decision diagrams (Hadzic and Andersen 2005).", "startOffset": 25, "endOffset": 47}, {"referenceID": 16, "context": "2001) and knowledge compilation techniques such as binary decision diagrams (Hadzic and Andersen 2005).", "startOffset": 76, "endOffset": 102}, {"referenceID": 34, "context": "Dynamic Constraint Satisfaction Problems (DCSP) (Mittal and Falkenhainer 1990) allow for variables to be inactive or irrelevant.", "startOffset": 48, "endOffset": 78}, {"referenceID": 13, "context": "Generative Constraint Satisfaction Problems (GCSP) (Fleischanderl et al. 1998) extends SCSP with component types and generative constraints.", "startOffset": 51, "endOffset": 78}, {"referenceID": 11, "context": "Kang (1990) used feature models (FM) for modeling these concepts, while UML was proposed in (Falkner and Haselb\u00f6ck 2013).", "startOffset": 92, "endOffset": 120}, {"referenceID": 2, "context": "Historically, the first knowledge-based configuration systems were rule-based (RBS) (McDermott 1982; Barker and O\u2019Connor 1989). These systems operate on a working memory and if the condition of a rule is fulfilled, it fires and modifies the working memory, applying the conclusion of that rule. Rule-based systems are sensitive to rule orderings. This complicates modification of the rule-base. More importantly, inclusion of problem solving knowledge in the rule-base, makes a rule-base problem specific and focused towards one specific task. This leads to the same problems as in imperative languages. To solve different tasks, more rule-bases have to be built, leading to duplication and fanning out of knowledge, giving issues in maintainability. Constraint Satisfaction Problems are widely used for tackling configuration problems (Mittal and Frayman 1989; Fleischanderl et al. 1998). A (static) constraint satisfaction problem (SCSP) is a triple (V,D,C) of a set of domain variables V = {v1, v2, . . . , vn}, a set of domains {dom(v1), dom(v2), . . . , dom(vn)} and set of constraints C. A solution for a SCSP is an assignment S of domain elements di \u2208 dom(vi) to variables vi, such that each variable has a value in S and constraints C are satisfied by S. A configuration task in SCSP is searching for a solution for a SCSP (V,D,C), where C contains the configuration constraints together with the user preferences. To make efficient CSP configuration systems, different techniques have been used, such as local search (Li et al. 2005), symmetry breaking (Kiziltan et al. 2001) and knowledge compilation techniques such as binary decision diagrams (Hadzic and Andersen 2005). In response to limitations of SCSP in configuration, extensions have been developed. Dynamic Constraint Satisfaction Problems (DCSP) (Mittal and Falkenhainer 1990) allow for variables to be inactive or irrelevant. If a variable is inactive, it does not need a value in a solution (for example, when configuring a smartphone, no camera resolution is needed if no camera is present). Generative Constraint Satisfaction Problems (GCSP) (Fleischanderl et al. 1998) extends SCSP with component types and generative constraints. Janota (2008) studied a mapping of CSP to SAT to use a SAT solver to provide functionality for a configuration system.", "startOffset": 101, "endOffset": 2220}, {"referenceID": 2, "context": "Historically, the first knowledge-based configuration systems were rule-based (RBS) (McDermott 1982; Barker and O\u2019Connor 1989). These systems operate on a working memory and if the condition of a rule is fulfilled, it fires and modifies the working memory, applying the conclusion of that rule. Rule-based systems are sensitive to rule orderings. This complicates modification of the rule-base. More importantly, inclusion of problem solving knowledge in the rule-base, makes a rule-base problem specific and focused towards one specific task. This leads to the same problems as in imperative languages. To solve different tasks, more rule-bases have to be built, leading to duplication and fanning out of knowledge, giving issues in maintainability. Constraint Satisfaction Problems are widely used for tackling configuration problems (Mittal and Frayman 1989; Fleischanderl et al. 1998). A (static) constraint satisfaction problem (SCSP) is a triple (V,D,C) of a set of domain variables V = {v1, v2, . . . , vn}, a set of domains {dom(v1), dom(v2), . . . , dom(vn)} and set of constraints C. A solution for a SCSP is an assignment S of domain elements di \u2208 dom(vi) to variables vi, such that each variable has a value in S and constraints C are satisfied by S. A configuration task in SCSP is searching for a solution for a SCSP (V,D,C), where C contains the configuration constraints together with the user preferences. To make efficient CSP configuration systems, different techniques have been used, such as local search (Li et al. 2005), symmetry breaking (Kiziltan et al. 2001) and knowledge compilation techniques such as binary decision diagrams (Hadzic and Andersen 2005). In response to limitations of SCSP in configuration, extensions have been developed. Dynamic Constraint Satisfaction Problems (DCSP) (Mittal and Falkenhainer 1990) allow for variables to be inactive or irrelevant. If a variable is inactive, it does not need a value in a solution (for example, when configuring a smartphone, no camera resolution is needed if no camera is present). Generative Constraint Satisfaction Problems (GCSP) (Fleischanderl et al. 1998) extends SCSP with component types and generative constraints. Janota (2008) studied a mapping of CSP to SAT to use a SAT solver to provide functionality for a configuration system. There exist many graphical approaches for doing knowledge configuration, and visualizing a configuration model. Kang (1990) used feature models (FM) for modeling these concepts, while UML was proposed in (Falkner and Haselb\u00f6ck 2013).", "startOffset": 101, "endOffset": 2449}, {"referenceID": 18, "context": "They have also been used for the development of configuration systems (Hotz et al. 2006; McGuinness and Wright 1998).", "startOffset": 70, "endOffset": 116}, {"referenceID": 32, "context": "They have also been used for the development of configuration systems (Hotz et al. 2006; McGuinness and Wright 1998).", "startOffset": 70, "endOffset": 116}, {"referenceID": 45, "context": "developed a configuration systemWeCoTin (Tiihonen et al. 2013), based on Answer Set Programming (ASP).", "startOffset": 40, "endOffset": 62}, {"referenceID": 14, "context": "Answer set programming (ASP) is a form of declarative programming based on the stablemodel semantics (Gelfond and Lifschitz 1988) for logic programs.", "startOffset": 101, "endOffset": 129}, {"referenceID": 8, "context": "Also, in language, many similarities can be identified (Denecker et al. 2012), as they both have their roots in extended logic programming.", "startOffset": 55, "endOffset": 77}, {"referenceID": 18, "context": "They combine reasoning engines from these fields to provide inference (Hotz et al. 2006).", "startOffset": 70, "endOffset": 88}, {"referenceID": 22, "context": "Karatas et al. (2010) for example combined feature models with constraint logic programming (CLP) to provide reasoning and automated analysis.", "startOffset": 0, "endOffset": 22}, {"referenceID": 16, "context": "They have also been used for the development of configuration systems (Hotz et al. 2006; McGuinness and Wright 1998). The trade-off for having decidable subsets of first-order logic is that they are limited in expressivity. This make domain knowledge in these systems less readable, less natural and harder to maintain. An ontology based method was also proposed by Vanden Bossche et al. (2007) using OWL.", "startOffset": 71, "endOffset": 395}, {"referenceID": 12, "context": "2 as in (Felfernig et al. 2014).", "startOffset": 8, "endOffset": 31}, {"referenceID": 12, "context": "Not discussed by Felfernig et al. (2014) et al is work by Vlaeminck et al.", "startOffset": 17, "endOffset": 41}, {"referenceID": 12, "context": "Not discussed by Felfernig et al. (2014) et al is work by Vlaeminck et al. (2009). They did a preliminary experiment using the KB approach for interactive configuration, also using the FO(\u00b7) IDP project.", "startOffset": 17, "endOffset": 82}, {"referenceID": 6, "context": "A prime example of this are templates (Dasseville et al. 2015).", "startOffset": 38, "endOffset": 62}], "year": 2016, "abstractText": "The knowledge base paradigm aims to express domain knowledge in a rich formal language, and to use this domain knowledge as a knowledge base to solve various problems and tasks that arise in the domain by applying multiple forms of inference. As such, the paradigm applies a strict separation of concerns between information and problem solving. In this paper, we analyze the principles and feasibility of the knowledge base paradigm in the context of an important class of applications: interactive configuration problems. In interactive configuration problems, a configuration of interrelated objects under constraints is searched, where the system assists the user in reaching an intended configuration. It is widely recognized in industry that good software solutions for these problems are very difficult to develop. We investigate such problems from the perspective of the KB paradigm. We show that multiple functionalities in this domain can be achieved by applying different forms of logical inferences on a formal specification of the configuration domain. We report on a proof of concept of this approach in a real-life application with a banking company. To appear in Theory and Practice of Logic Programming (TPLP).", "creator": "LaTeX with hyperref package"}}}