{"id": "1605.06996", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-May-2016", "title": "Extracting Higher-Order Goals from the Mizar Mathematical Library", "abstract": "certain constructs allowed in mizar articles cannot be represented in pre - order logic but can be utilized in higher - order logic. we describe a way to obtain higher - order theorem database problems from multiple articles that make use of these constructs. in laboratories, medium - order logic is used to call schemes, a global choice construct and set level binders. the higher - order automated theorem provers satallax and leo - ii have partly run on collections of these problems and the situation publicly discussed.", "histories": [["v1", "Mon, 23 May 2016 12:37:54 GMT  (31kb)", "http://arxiv.org/abs/1605.06996v1", "Accepted to CICM 2016. The final publication will be available at Springer"]], "COMMENTS": "Accepted to CICM 2016. The final publication will be available at Springer", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["chad brown", "josef urban"], "accepted": false, "id": "1605.06996"}, "pdf": {"name": "1605.06996.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Chad E. Brown", "Josef Urban"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 5.\n06 99\n6v 1\n[ cs\n.L O\n] 2\n3 M\nay 2\n01 6\nKeywords: Formalized Mathematics, Set Theory, Higher-Order Logic, Automated Theorem Proving"}, {"heading": "1 Introduction", "text": "The Mizar Problems for Theorem Proving (MPTP) system has been developed and used to extract first-order theorem proving problems from the Mizar Mathematical Library (MML) [15,16,14]. However, some aspects of the Mizar language cannot be directly represented in first-order. In particular, Mizar provides supports for Schemes (allowing some degree of quantification over predicates and functions), Fraenkel terms (allowing sets to be specified using term level binders such as {f(x)|x \u2208 A, p(x)}) and a global choice operator the on types [6]. In order to obtain first-order problems, the MPTP has dealt with schemes used in a proof by exporting the first-order instances of the scheme used in the proof. Additionally, Fraenkel terms and global choice have been made first-order by a process of deanonymization [14].\nWe describe an extension of MPTP targeting higher-order logic. Schemes can be represented directly in higher-order logic since quantifiers over predicates and functions are allowed. Instead of giving the instances of schemes used in a proof, schemes are exported as second-order formulas (relying on the problem solver to find appropriate instances). Global choice can be represented by a selection operator on the type of individuals and a corresponding choice axiom. We also give a method for representing Fraenkel terms, though these are more challenging both to represent and to reason about.\nThe resulting system has been used to extract a collection of higher-order theorem proving problems in THF0 format [9]. As in [14] we can partition the\n\u22c6 This work was supported by ERC Consolidator grant nr. 649043 AI4REASON.\nproblem set into simple justifications (the Mizar by steps \u2013 or sometimes no explicit justification), scheme justifications (the Mizar from steps indicating application of a scheme) and theorems (including schemes proven in the MML). There are roughly 10192 scheme justifications throughout Mizar proofs in the MML, and we consider the higher-order problems corresponding to all of them. For simple justifications, we focus only on those involving global choice or Fraenkel terms and restrict ourselves to such steps in only four Mizar articles, giving 245 higher-order problems involving Fraenkel terms and 47 problems involving the global choice operator. For theorems, we focus only on 610 proven schemes whose proof in the MML requires a scheme justification. We describe some examples and results from running the higher-order automated theorem provers Satallax [3] and LEO-II [2] on some collections of these problems.\nIn Section 2 we give a short description of the syntax of higher-order logic. In Section 3 we define M-types, M-terms and M-propositions corresponding to an idealized version of the Mizar language. In Section 4 we describe the mapping of M-types, M-terms and M-propositions into higher-order terms, with a focus on the higher-order aspects. Section 5 describes experiments using Satallax and LEO-II on the resulting higher-order problems."}, {"heading": "2 Syntax of Higher-Order Logic", "text": "We give a short introduction to the syntax of higher-order logic (in the form of Church\u2019s simple type theory [4]) so that we can describe the mapping in Section 4. In order to present higher-order problems to theorem provers, the THF0 format is used [9], but we mostly restrict ourselves to mathematical presentations of higher-order terms here.\nThere are two base types o (for propositions) and \u03b9 (for individuals, which will always be sets for us). The remaining types are function types \u03b1\u03b2 where \u03b1 and \u03b2 are types. The type \u03b1\u03b2 is the type of functions from \u03b1 to \u03b2 (and is sometimes written \u03b1 \u2192 \u03b2).\nWe assume there are infinitely many variables x at each type \u03b1. We sometimes write the type as a subscript to make it clear, as in x\u03b1. Likewise, there may be arbitrarily many constants c at each type \u03b1. We freely generate the set of typed terms as follows:\n\u2013 A variable x of type \u03b1 is a term of type \u03b1. \u2013 A constant c of type \u03b1 is a term of type \u03b1. \u2013 If s is a term of type \u03b1\u03b2 and t is a term of type \u03b1, then (st) is a term of\ntype \u03b2. \u2013 If x is a variable of type \u03b1 and s is a term of type \u03b2, then (\u03bbx.s) is a term\nof type \u03b1\u03b2. \u2013 \u22a4 is a term of type o. \u2013 If s and t are terms of type \u03b1, then (s =\u03b1 t) is a term of type o. \u2013 If s is a term of type o, then (\u00acs) is a term of type o. \u2013 If s and t are terms of type o, then (s \u2227 t), (s \u2228 t), (s \u2192 t) and (s \u2194 t) are\nterms of type o.\n\u2013 If x is a variable of type \u03b1 and s is a term of type o, then (\u2200x.s) and (\u2203x.s) are terms of type o.\nTerms of type o are also called propositions. We omit parentheses with the following conventions:\n\u2013 Application associates to the left, e.g., stu means ((st)u). \u2013 Binders have as large a scope as possible, e.g., both x are bound in \u2200xo.x\u2228\u00acx. \u2013 The connectives \u2192, \u2227 and \u2228 are considered right associative. \u2013 The precedence of the binary and unary connectives are =\u03b1, \u00ac, \u2227, \u2228, \u2192 and\nfinally \u2194.\nIn addition, we omit the type subscript on = when it is clear, and we write s 6= t for \u00ac(s = t). Likewise we may write several binders together, as in \u2200xyz\u03b1.s for \u2200x.\u2200y.\u2200z.s where x, y and z should all have type \u03b1."}, {"heading": "3 Idealized Mizar", "text": "In order to describe the translation from Mizar to Higher-Order Logic we first give a short presentation of an idealized subset of the Mizar language. For a full presentation of the Mizar language, we direct the reader to [6].\nTo simplify the presentation, we assume that some variables and constants of higher-order logic are also variables and constants of Mizar, and that the translation will simply map variables and constants to themselves. The language of Mizar is restricted in a way that only variables and constants of certain types can be used:\n\u2013 We call variables of type \u03b9 object variables and call constants of type \u03b9 object constants . \u2013 For each n \u2265 1, we call variables of simple type \u03b9 . . . \u03b9 \ufe38 \ufe37\ufe37 \ufe38\nn\n\u03b9 function variables (of\narity n). Likewise, we call constants of this type function constants (of arity n). We use F and G to range over function variables and f and g to range over function constants.\n\u2013 For each n \u2265 0, we call variables of simple type \u03b9 . . . \u03b9 \ufe38 \ufe37\ufe37 \ufe38\nn\no predicate variables\n(of arity n). Likewise, we call constants of this type predicate constants (of arity n). We use P and Q to range over predicate variables and p and q to range over predicate constants.\nMizar quantifiers only bind object variables. Predicate variables and function variables only appear in schemes and are listed (with typing information) in the prefix of a scheme.\nMizar articles typically consist of definitions and theorems (some of which are schemes). A definition may be of an object constant, a function constant or a predicate constant. Predicate constants are sometimes defined as modes or attributes , which can then be used to construct Mizar types. Mizar types can\nbe thought of as predicates over the universe of discourse. Mizar insists that types are nonempty and that all types, terms and propositions are well-typed (in Mizar\u2019s typing system).\nIn our idealized version of Mizar, we can ignore these restrictions and define more liberal sets of M-types, M-terms and M-propositions by mutual recursion. The intention is that Mizar types, terms and propositions (at least within the subset of Mizar considered in this article) will give M-types, M-terms and Mpropositions, although not all M-types, M-terms and M-propositions would be accepted by Mizar.\nM-types A,B, . . . are generated as follows:\n\u2013 set is an M-type. \u2013 If p is an n + 1-ary predicate constant and T1, . . . Tn are M-terms, then\np(\u00b7, T1, . . . , Tn) is an M-type. (Here p is playing the role of a Mizar mode.) \u2013 If q is a unary predicate constant and A is an M-type, then q A and non q A\nare M-types. (Here q is playing the role of a Mizar attribute.)\nM-terms S, T, . . . are generated as follows:\n\u2013 An object variable x is an M-term. \u2013 An object constant c is an M-term. \u2013 If F is a function variable of arity n and T1, . . . Tn are M-terms, then\nF (T1, . . . , Tn) is an M-term. \u2013 If f is a function constant of arity n and T1, . . . Tn are M-terms, then\nf(T1, . . . , Tn) is an M-term. \u2013 If A is an M-type, then (the A) is an M-term. (The the is called a global\nchoice operator .) \u2013 If x1, . . . , xn are object variables, A1, . . . , An are M-types, T is an M-term\nand \u03a6 is an M-proposition, then {T where x1 is A1, . . . xn is An : \u03a6} is an M-term. (These are called Fraenkel terms .)\nM-propositions \u03a6, \u03a8, . . . are generated as follows:\n\u2013 If P is an n-ary predicate variable of arity n and T1, . . . Tn are M-terms, then P (T1, . . . , Tn) is an M-proposition. \u2013 If p is an n-ary predicate constant of arity n and T1, . . . Tn are M-terms, then p(T1, . . . , Tn) is an M-proposition. \u2013 If S and T are M-terms, then (S = T ) and (S in T ) are M-propositions. \u2013 If \u03a6 is an M-proposition, then (not \u03a6) is an M-proposition. \u2013 If \u03a6 and \u03a8 are M-propositions, then (\u03a6 & \u03a8), (\u03a6 or \u03a8), (\u03a6 implies \u03a8) and\n(\u03a6 iff \u03a8) are M-propositions. \u2013 If x is an object variable, A is an M-type and \u03a6 is an M-proposition, then\n(for x being A holds \u03a6) and (ex x being A st \u03a6) are M-propositions.\nMost Mizar theorems correspond to M-propositions. However, in some cases (namely, schemes) there are function variables or predicate variables which cannot be bound by quantifiers. We now define the notion of a prefix to list such variables. When translating to higher-order propositions, the prefix will determine the outermost quantifiers.\nA variable declaration is one of the following:\n\u2013 x : A where x is an object variable and A is an M-type. \u2013 F (A1, . . . , An) : B where F is a function variable of arity n andA1, . . . , An, B\nare M-types. \u2013 P [A1, . . . , An] where P is a predicate variable of arity n and A1, . . . , An are\nM-types.\nA prefix is a list of variable declarations. An M-statement (\u0393, \u03a6) is a prefix \u0393 and an M-proposition \u03a6. For Mizar theorems other than schemes, the prefix \u0393 will always be empty. Some Mizar schemes will declare what appears to be a function variable of arity 0. In such a case, we use object variables instead. (This is why object variable declarations are allowed in a prefix.)\nAn example of a scheme is Separation: for each set A and predicate P , there is a set X such that x \u2208 X iff x \u2208 A and P (x) [5].\nscheme Separation { A()-> set, P[set] } :\nex X being set st for x being set holds x in X iff x in A() & P[x]\nThe M-statement in this case is (\u0393, \u03a6) where \u0393 is the prefix A : set, P [set] (declaring an object variable A of type set and a predicate variable P of arity 1) and \u03a6 is the M-proposition\nex X being set st for x being set holds x in X iff x in A & P (x)\ncorresponding to the body of the scheme."}, {"heading": "4 Mapping Mizar to Higher-Order Logic", "text": "We now describe a mapping from M-types, M-terms, M-propositions and Mstatements to higher-order terms, concentrating on the aspects that require higher-order constructs. The base type \u03b9 will correspond to Mizar objects (sets). We will use p\u2212q to denote the image of an M-type, M-term, M-proposition or Mstatement as a term in higher-order logic under the translation. The intention is that mapping p\u2212q should send M-statements corresponding to Mizar theorems to provable propositions in higher-order logic. To be precise about this would require giving details about the proof theory of Mizar, which is beyond the scope of this paper.\nIn order to specify the translation, we need to declare a family of constants the higher-order problems may make use of. A special relation in Mizar is set membership (in), translated as r2 hidden by the MPTP system. For this reason, we include a declared constant r2 hidden of type \u03b9\u03b9o in the higher-order setting. For readability, we will write s \u2208 t for the term r2 hidden s t. (We will also write s 6\u2208 t for \u00ac(s \u2208 t).) This allows us to translate an M-proposition S in T simply as pSq \u2208 pT q. We also declare a constant \u03b5 of type (\u03b9o)\u03b9. This allows use to translate an M-term (the A) as \u03b5pAq. Finally, we need a family of constants for translating Fraenkel terms. For this purpose we declare a constant replSep\nn\nof type (\u03b9o)(\u03b9\u03b9o) \u00b7 \u00b7 \u00b7 (\u03b9 \u00b7 \u00b7 \u00b7 \u03b9\n\ufe38 \ufe37\ufe37 \ufe38\nn\no)(\u03b9 \u00b7 \u00b7 \u00b7 \u03b9 \ufe38 \ufe37\ufe37 \ufe38\nn\n\u03b9)(\u03b9 \u00b7 \u00b7 \u00b7 \u03b9 \ufe38 \ufe37\ufe37 \ufe38\nn\no)\u03b9\nfor each n. (In practice only a finite number of these can be declared in a single problem, and we declare them up to the maximum n required to translate the problem. When translating the MML the maximum required n was 6.) We can use replSep\nn to translate {T where x1 is A1, . . . xn is An : \u03a6} as\nreplSep n pA1q(\u03bbx1.pA2q) \u00b7 \u00b7 \u00b7 (\u03bbx1 \u00b7 \u00b7 \u00b7xn\u22121.pAnq)(\u03bbx1 \u00b7 \u00b7 \u00b7xn.pT q)(\u03bbx1 \u00b7 \u00b7 \u00b7xn.p\u03a6q).\nBefore giving the translation, let us also remark on the intended semantics of these new constants. The constant \u03b5 is a choice operator so that \u03b5p satisfies p unless p is empty. The remaining constants are set theory related, and are required since the Mizar language targets set theory. In particular, the MML is based on Tarski-Grothendieck Set Theory (TG). For this reason, we take the intended interpretation of \u03b9 as a model of TG. The constant r2 hidden is intended to be membership on this model. The replSep\nn constants give ways to\nspecify sets. For simplicity, we consider only the n = 1 case. A first approximation would be to think of replSep\n1 s (\u03bbx.t) (\u03bbx.u) as a set {t|x \u2208 s, u}. However, s\nhas type \u03b9o, not type \u03b9, so we should write {t|x : sx \u2227 u}. In general, if s is a predicate that corresponds to a class instead of a set, {t|x : sx \u2227 u} will not be a set. Mizar avoids this problem by enforcing an extra condition when Fraenkel terms are used: all the types A1, . . . , An must satisfy a \u201csethood\u201d condition: that the collection of all elements of the type are contained in a bounding set. In the higher-order problems we define a corresponding constant sethood of type (\u03b9o)o as follows:\n\u03bbp\u03b9o.\u2203y\u03b9.\u2200x\u03b9.px \u2192 x \u2208 y.\nThen we can interpret replSep 1 s (\u03bbx.t) (\u03bbx.u) to be {t|x : sx\u2227u} if sethood s holds and interpret replSep 1 s (\u03bbx.t) (\u03bbx.u) to be the empty set otherwise. The new constants and corresponding axioms for the higher-order problems are given in Figure 1. For each n there are two axioms for replSep\nn : an introduction\naxiom replSepI n and an elimination axiom replSepE n . The sethood conditions are only required for replSepI n since the intended interpretation of replSep n is the empty set when applied to an argument for which the sethood condition is violated. In practice, sethood and replSep\nn (for n \u2265 1) are only included if\nthe problem contains a Fraenkel term. Each M-type A will map to a term pAq of type \u03b9o (a predicate or class), each M-term T will map to a term pT q of type \u03b9 (a set) and each M-proposition \u03a6 will map to a term p\u03a6q of type o (a proposition). Note that Mizar has dependent types and so an M-type A and the corresponding predicate pAq may contain free variables. The mapping is defined by recursion as given in Figure 2. Note that while we take pxq = x and pcq = c in principle, variables and constants are mapped to THF0 compliant names in practice. In order to map Mizar schemes we define p(\u0393, \u03a6)q for M-statements by a final recursion over the prefix \u0393 :\n\u2013 p(\u00b7, \u03a6)q = p\u03a6q. \u2013 p((x : A,\u0393 ), \u03a6)q = \u2200x.pAq x \u2192 p(\u0393, \u03a6)q. \u2013 p((F (A1, . . . , An) : B,\u0393 ), \u03a6)q = \u2200F.(\u2200x1.pA1q x1 \u2192 . . . \u2192 \u2200xn.pAnq xn \u2192\npBq (Fx1 \u00b7 \u00b7 \u00b7xn)) \u2192 p(\u0393, \u03a6)q.\n\u2013 p((P [A1, . . . , An], \u0393 ), \u03a6)q = \u2200P.p(\u0393, \u03a6)q.\nAs a Mizar development is processed, new definitions are processed and the corresponding higher-order information must be declared in the problems which use this new information. We consider a few examples from early in the MML.\nA simple example of a definition of an attribute is empty given in xboole 0 [5]:\ndefinition\nlet X be set; attr X is empty means :Def1: not ex x being set st x in X;\nend;\nMPTP creates a name v1 xboole 0 of type \u03b9o. Note that simply due to its type, v1 xboole 0 can be used as an attribute and mode to form M-types. It can also be used to form M-propositions. In the Mizar development, empty the proposition X is empty corresponds to the M-proposition v1 xboole 0(X) which translates to the higher-order proposition v1 xboole 0 X . For particular problems, MPTP also exports relevant axioms about v1 xboole 0. For example, its definition translates to \u00ac\u2203x.\u22a4 \u2227 x \u2208 X (or, equivalently, \u00ac\u2203x.x \u2208 X).\nThe most common example of a mode used in this paper is Element of from the Mizar article subset 1 [13]:\ndefinition\nlet X; mode Element of X means :Def1: it in X if X is non empty otherwise it is empty; ...\nSince this is the first mode definition in the article, the corresponding name created by MPTP is m1 subset 1, declared to have type \u03b9\u03b9o. That is, m1 subset 1 expects two arguments of type \u03b9 and yields a proposition. The Mizar type Element of X corresponds to the M-type m1 subset 1(\u00b7, X) which maps to the term \u03bbx\u03b9.m1 subset 1 x X . Note that the dependent Mizar type Element of X maps to a term of type \u03b9o with a free variable X (making the dependency explicit). For the sake of readability, we will write s\u2208\u0302t for m1 subset 1 s t. Note that since Mizar requires all types to be nonempty, the Element of mode is defined so that x\u2208\u0302X if and only if either X is nonempty and x \u2208 X or both X and x are empty. That is, if X is nonempty, then x\u2208\u0302X if and only if x \u2208 X , as expected. However, x\u2208\u0302\u2205 if and only if x = \u2205, which may be surprising when it is first encountered.\nFinally, we examine examples of schemes to see how M-statements are translated in practice.\nThe MML includes Fraenkel\u2019s Replacement axiom scheme as an axiom of TG. As formulated in Mizar, the scheme asserts that for each set A and each binary relation P on sets, if P is functional, then there is a set X such that x \u2208 X iff there is a y \u2208 A such that P (y, x) [11]. In Mizar\u2019s syntax, the scheme is specified as follows:\nscheme Fraenkel { A()-> set, P[set, set] }:\nex X st for x holds x in X iff ex y st y in A() & P[y,x] provided for x,y,z st P[x,y] & P[x,z] holds y = z\nThis can be seen as an M-statement with prefix A : set, P [set, set] and an M-proposition corresponding to the body. The M-statement translates to the higher-order proposition\n\u2200A\u03b9.\u2200P\u03b9\u03b9o.(\u2200xyz\u03b9.Pxy \u2227 Pxz \u2192 y = z) \u2192 \u2203X\u03b9.\u2200x\u03b9.x \u2208 X \u2194 \u2203y.y \u2208 A \u2227 Pyx.\nAn early application of the Fraenkel scheme is to prove Zermelo\u2019s Separation scheme discussed at the end of Section 3, where the corresponding M-statement is given. The M-statement translates to the following higher-order proposition:\n\u2200A\u03b9.\u2200P\u03b9o.\u2203X\u03b9.\u2200x\u03b9.x \u2208 X \u2194 x \u2208 A \u2227 Px.\nFor each scheme proven in the MML, the MPTP system has generated a corresponding higher-order problem in THF0 format [9]. For example, the problem corresponding to the separation scheme is s1 xboole 0. In order to prove s1 xboole 0 automatically, a prover would need to synthesize the appropriate relation to use with Replacement, e.g., \u03bbxy\u03b9.x = y\u2227Py where P is the predicate from Separation. At the moment, neither Satallax nor LEO-II can prove this automatically.\nThe Mizar proof begins by defining a predicate Q and then applying Replacement with Q.\ndefpred Q[set,set] means $1 = $2 & P[$2];\nA1: for x,y,z st Q[x,y] & Q[x,z] holds y = z;\nconsider X such that\nA2: for x holds x in X iff ex y st y in A() & Q[y,x]\nfrom TARSKI:sch 1(A1);\nIn \u03bb-notation, the definition of Q is \u03bbxy\u03b9.x = y \u2227 Py. Line A1 justifies y = z whenever Qxy and Qxz. When schemes are used to justify Mizar proof steps, the keyword from is used. These are the steps we classify as scheme justifications . In this case, the Replacement scheme is used to justify the existence of a set X such that x \u2208 X iff \u2203y.y \u2208 A \u2227 Qyx. A higher-order problem can be extracted from each such scheme justification. For this particular example, the conjecture to prove is \u2203X.\u2200x.x \u2208 X \u2194 \u2203y.y \u2208 A\u2227 y = x\u2227Px. This follows from Replacement and A1, but requires instantiating the higher-order variable in the Replacement axiom with Q. Note that Q is not explicitly given in the problem, but can easily be recovered using pattern unification [7], as we now demonstrate. Suppose we replace the outermost quantifiers in the Replacement axiom with existential variables A of type \u03b9 and R of type \u03b9\u03b9o. The conclusion of the implication has the following form:\n\u2203X\u03b9.\u2200x\u03b9.x \u2208 X \u2194 \u2203y.y \u2208 A \u2227Ryx.\nSince the subterm Ryx is the higher-order existential variable R applied to distinct bound variables (y and x), we can use pattern unification (in this case pattern matching) to obtain solutions for A and R. That is, when we match against\n\u2203X.\u2200x.x \u2208 X \u2194 \u2203y.y \u2208 A \u2227 y = x \u2227 Px\nwe obtain the disagreement pairs X, x, y|A =? A and X, x, y|Ryx =? y = x\u2227Px which has the unique (desired) solution: A for A and \u03bbyx.y = x \u2227 Px for R. Neither Satallax nor LEO-II re-prove this scheme justification within 5 minutes with the default strategy schedule. However, Satallax is able to prove the problem corresponding to this scheme justification under certain flag settings that encourage pattern unification."}, {"heading": "5 Experiments", "text": "We now report on the results of running two higher-order automated theorem provers (Satallax and LEO-II) on some of the problems resulting from the translation described in the previous section. We consider four problem sets:1\n\u2013 SimpGC: Simple justifications where the conclusion includes a global choice operator. From four Mizar articles [13,10,12,1] 47 problems were extracted. \u2013 SimpFr: Simple justifications where the problem contains a Fraenkel term. We consider 245 such problems arising from three Mizar articles [10,12,1]. Since these proved to be surprisingly difficult, we also considered \u201cpruned\u201d versions of the problems in which the first-order theorem prover E [8] indicated which axioms it used to find a corresponding first-order proof. \u2013 SchJust: For each scheme justifications (using from) in a Mizar proof in the MML, a corresponding problem was created. There are 10192 such problems. \u2013 SchPfs: Out of 787 schemes proven in the MML, 610 have a proof making use of a scheme justification. For each of these 610 we have created a corresponding problem. Note that solving these problems requires finding a full proof, not justifying a single Mizar step in a proof. Hence these should be harder than the previous problem sets.\nThe results of running Satallax and LEO-II on the problem sets with the default settings and a time limit of 5 minutes are shown in Table 1. In addition, we note the number of problems both provers solved. For the remainder of the section, we discuss the results and describe some concrete examples.\nOne of the first uses of the global choice operator in Mizar is to define a (first-order) choice operator on sets called choose [13].\ndefinition\nlet S be set; func choose S -> Element of S equals"}, {"heading": "1 The THF versions of the problems discussed here are available from", "text": "http://147.32.69.25/~chad/mptp_thf.tgz\nthe Element of S; correctness;\nend;\nNote that no proof is given for correctness, as Mizar recognizes that the Element of S has type Element of S. Let us consider the corresponding higherorder simple justification problem. The higher-order problem would include the declaration of \u03b5 from Figure 1. In addition, the fact that types of the form Element of A are nonempty is given: \u2200A\u03b9.\u2203B\u03b9.B\u2208\u0302A. The conjecture to justify is\n\u03b5(\u03bbA\u03b9.A\u2208\u0302c)\u2208\u0302c\nfor a fixed c. This, of course, follows immediately from the two axioms and both Satallax and LEO-II can easily re-prove this simple justification.\nNote that simply because a simple justification has a conclusion with a global choice operator does not mean that the choice axiom plays a role in the justification. Indeed, for the two examples from the problem set SimpGC Satallax proves but LEO-II does not, the proofs Satallax finds do not use the axiom about \u03b5. Furthermore, upon inspection it became clear that some problems neither prover could solve also do not require the axiom about \u03b5. Consider the following fragment of a Mizar proof about group theory [12].\nset a = the Element of G; ... consider b such that\nA4: H * a = {b} by A1;\nh * a in H * a by A3,Th104; then\nA5: h * a = b by A4,TARSKI:def 1;\nThe final justification is essentially the definition of singleton. The only reason the corresponding higher-order problem falls into class SimpGC is because a is \u03b5(\u03bbx.x\u2208\u0302(c G)) (where c is a function taking a group to its carrier set, left implicit in the Mizar text). The fact that neither Satallax nor LEO-II could solve this problem was due to the fact that there are too many extra (unnecessary) axioms given in the generated problem. After pruning away the unnecessary axioms (with the help of E prover on a corresponding first-order problem), both Satallax and LEO-II can prove the pruned problem. LEO-II proves the pruned\nproblem within 8 seconds and Satallax proves the pruned problem in less than a second.\nWe now turn to the problem set SimpFr: simple justifications involving at least one Fraenkel term, either in the conclusion or in one of the assumptions MPTP included in the problem. There were 640 such examples in the four Mizar articles we considered, but with experimentation it became clear that often the Fraenkel term was in an assumption that was unnecessary for the proof. In order to obtain a reasonable problem set, we used E on corresponding firstorder problems to obtain pruned versions of the 640 problems. (In cases where E could not find the proof, we omitted the problem.) After pruning, there were 245 problems that still included a Fraenkel term. On each of these 245 problems, we ran Satallax and LEO-II on both the original and pruned problems. On the original versions, only 20% of the problems could be solved by both provers, whereas on the pruned versions, 50% could be solved by both provers. This suggests that better relevance filtering would be one of the most important potential improvements.\nWe briefly examine two small examples involving Fraenkel terms. Consider the following proof fragment from [10].\nassume a in { x1 : x1 in A1 & not x1 in B1 or not x1 in A1 & x1 in B1 }; then ex x1 st a = x1 &\n(x1 in A1 & not x1 in B1 or not x1 in A1 & x1 in B1);\nIn the context of this fragment, x1 ranges over elements of a nonempty set X1. Mizar is able to verify the correctness of the last line from the first line without any explicit references as this is simply the property of membership in a Fraenkel term. In the corresponding higher-order problem, the elimination principle replSepE\n1 is required for the justification. Satallax can prove the cor-\nresponding problem in less than a second. The first mode in the default strategy schedule that finds the proof is one making use of pattern unification. In particular, after replacing the outermost quantifiers of replSepE\n1 with existential\nvariables A, F , P and Y, the proposition has the form:\nY \u2208 replSep 1 A F P \u2192 \u2203x\u03b9.Ax \u2227 Px \u2227 Y = Fx.\nAll the occurrences of the existential variables are pattern occurrences, and so pattern matching can be used to find the appropriate instances. In particular, one axiom of the problem is\na \u2208 replSep 1 (\u03bbx\u03b9.x\u2208\u0302X) (\u03bbx\u03b9.x) (\u03bbx\u03b9.x \u2208 A \u2227 x /\u2208 B \u2228 x /\u2208 A \u2227 x \u2208 B).\nWhen the antecedent of the implication above is matched against this axiom, the following instantiations result:\n\u2013 Y := a \u2013 A := \u03bbx\u03b9.x\u2208\u0302X \u2013 F := \u03bbx\u03b9.x \u2013 P := \u03bbx\u03b9.x \u2208 A \u2227 x /\u2208 B \u2228 x /\u2208 A \u2227 x \u2208 B\nGiven these instantiations, the solution is immediate. Satallax can prove both the pruned and unpruned version of this example in less than a second. LEO-II timed out after five minutes on both versions.\nWe consider a simple justification requiring the replSepI 1 . Consider the\nfollowing proof fragment from [10]:"}, {"heading": "A2: a = x1 and", "text": ""}, {"heading": "A3: P[x1];", "text": "Q[x1] by A1,A3; hence thesis by A2;\nwhere the thesis in the last step is\na in { z1 where z1 is Element of X1: Q[z1] }\nAs in the previous example, x1 ranges over elements of a nonempty set X1. In the higher-order problem corresponding to the final simple justification (by A2), the conjecture has the form a \u2208 replSep\n1 (\u03bbx\u03b9.x\u2208\u0302X) (\u03bbx\u03b9.x) (\u03bbx\u03b9.Qx).\nIn addition replSepI 1 , the axioms needed for the proof are x1\u2208\u0302X (using the type of x1 in the Mizar article), a = x1 (from A2 in the proof fragment above), Qx1 (from the previous step in the proof fragment above) and the extra axiom \u2200X\u03b9.sethood (\u03bbx\u03b9.x\u2208\u0302X). Satallax requires roughly 6 seconds before reaching a mode in the default strategy schedule that can solve this problem. The successful mode requires less than a second to find the proof. Again, the mode makes use of pattern unification to find the proper instantiations. LEO-II can also find the proof in this example, and takes just under 6 seconds.\nLastly we turn to scheme justifications (SchJust) and full proofs of schemes (SchPfs). In Section 4 we have already discussed an example of a scheme that cannot be automatically proven (Separation from Replacement) by either prover. In addition we saw that neither prover could even re-prove the relevant scheme justification in the Mizar proof of Separation from Replacement within 5 minutes using the default settings.\nSatallax performed significantly better than LEO-II on scheme justifications, while LEO-II performed significantly better than Satallax on proofs of full schemes. We consider one example of a scheme justification that Satallax solved but LEO-II did not. We then consider an example of a full scheme that LEO-II solved but Satallax did not.\nThe set operation X \\ Y is defined in an early Mizar article [5], and the following required existence proof is given:\ndefpred P[set] means not $1 in Y; thus ex Z being set st for x holds x in Z iff x in X & P[x]\nfrom Separation;\nNote that the scheme justification makes use of the Separation scheme using the set X and the predicate \u03bbx.x 6\u2208 Y . Again, the higher-order instantiation \u03bbx.x 6\u2208 Y can be determined using pattern matching, and Satallax can re-prove this in a fraction of a second using such a mode. With the default strategy\nschedule, Satallax tries such a mode and solves the problem in 37 seconds. LEOII times out after 5 minutes.\nA scheme LEO-II can fully prove but Satallax cannot is the following Mizar scheme [13]:\nscheme SubsetEx { A() -> non empty set, P[set] } :\nex B being Subset of A() st for x being Element of A() holds x in B iff P[x]\nThis is again a form of Separation and is proven using the Separation scheme already considered. The primary difference between the schemes is that the new scheme SubsetEx asserts that the set has type Subset of A (notation for Element of \u2118A) and restricts the inner universal quantifier to Element of A. In the corresponding higher-order problem, we must prove the formula\n\u2203B.B\u2208\u0302\u2118A \u2227 \u2200x.x\u2208\u0302A \u2192 (x \u2208 B \u2194 Px)\nfrom the higher-order formula\n\u2200Q\u03b9\u2200X\u03b9.\u2203B.\u2200x.x \u2208 B \u2194 x \u2208 X \u2227Qx.\nThe solution is simple: instantiate the assumption with the Q := P and X := A giving an appropriate witness B for the conjecture. Some minor first-order reasoning completes the proof. LEO-II can find the proof by doing some clause normalization and calling E. It is E that does the \u201chigher-order\u201d instantiation of P for Q and completes the proof. This is possible since the higher-order problem, after being encoded into first-order, is still provable. (In particular, the proof does not require \u03b2-reductions.) Satallax, on the other hand, does not solve the problem and times out after 5 minutes. The minor structural differences between the assumption and conclusion prevents pattern matching from suggesting the instantiation P for Q. While P is among the possible instantiations considered for Q, other possible instantiations are considered as well. The combination of multiple possible instantiations and required first-order reasoning makes the problem out of reach for the current version of Satallax."}, {"heading": "6 Conclusion", "text": "We have described an extension of MPTP that creates higher-order theorem proving problems from the MML. The resulting problems seem to present challenges for higher-order theorem provers. For example, even some of the easiest problems become difficult if there are too many axioms, so better relevance filtering is necessary. Even simple reasoning about Fraenkel terms seems to be more difficult than one would expect, and so these examples may provide insights into improvements that can be made to automated provers.\nThere are multiple possibilities for the translation of Fraenkel terms that bind more than one set variable. We have implemented one way and suggested\nanother. Further experimentation will likely be helpful for determining a good way to handle these cases.\nThe problems generated from scheme justifications and full proofs of schemes turned out to show the different strengths and weaknesses of Satallax and LEOII. Hopefully such problem sets will lead to improvements in higher-order automated theorem provers. Given enough improvement on such problems, perhaps higher-order automated provers could provide help to Mizar authors who make use of the features of Mizar that go beyond first-order. In order to serve this purpose, care would have to be taken that the automated provers do not search for proofs that go beyond Mizar\u2019s logic (e.g., make use of higher-order quantifiers within instantiations). We leave such concerns to future work."}], "references": [{"title": "On the characteristic and weight of a topological space", "author": ["G. Bancerek"], "venue": "Formalized Mathematics 13(1), 163\u2013169", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "The higher-order prover LEO-II", "author": ["C. Benzm\u00fcller", "L.C. Paulson", "N. Sultana", "F. Thei\u00df"], "venue": "Journal of Automated Reasoning 55(4), 389\u2013404", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2015}, {"title": "Reducing higher-order theorem proving to a sequence of SAT problems", "author": ["C.E. Brown"], "venue": "Journal of Automated Reasoning 51(1), 57\u201377", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "A formulation of the simple theory of types", "author": ["A. Church"], "venue": "Journal of Symbolic Logic 5, 56\u201368", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1940}, {"title": "Boolean properties of sets \u2014 definitions (April 2002)", "author": ["L. Committee"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "Mizar in a nutshell", "author": ["A. Grabowski", "A. Kornilowicz", "A. Naumowicz"], "venue": "Journal of Formalized Reasoning 3(2), 153\u2013245", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "A logic programming approach to manipulating formulas and programs", "author": ["D. Miller", "G. Nadathur"], "venue": "IEEE Symposium on Logic Programming. Salt Lake City", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1987}, {"title": "E \u2013 A Brainiac Theorem Prover", "author": ["S. Schulz"], "venue": "Journal of AI Communications 15(2/3), 111\u2013126", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2002}, {"title": "Automated reasoning in higher-order logic using the TPTP THF infrastructure", "author": ["G. Sutcliffe", "C. Benzm\u00fcller"], "venue": "Journal of Formalized Reasoning 3(1), 1\u201327", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Domains and their Cartesian products", "author": ["A. Trybulec"], "venue": "Formalized Mathematics 1(1), 115\u2013122", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1990}, {"title": "Tarski Grothendieck set theory", "author": ["A. Trybulec"], "venue": "Formalized Mathematics 1(1), 9\u201311", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1990}, {"title": "Subgroup and cosets of subgroups", "author": ["W.A. Trybulec"], "venue": "Formalized Mathematics 1(5), 855\u2013864", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1990}, {"title": "Properties of subsets", "author": ["Z. Trybulec"], "venue": "Formalized Mathematics 1(1), 67\u201371", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1990}, {"title": "MPTP 0.2: Design, Implementation, and Initial Experiments", "author": ["J. Urban"], "venue": "Journal of Automated Reasoning 37(1-2),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2006}, {"title": "Translating Mizar for first order theorem provers", "author": ["J. Urban"], "venue": "Mathematical Knowledge Management: Second International Conference, MKM 2003 Bertinoro, Italy, February", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2003}, {"title": "MPTP \u2013 motivation, implementation, first experiments", "author": ["J. Urban"], "venue": "Journal of Automated Reasoning 33(3),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}], "referenceMentions": [{"referenceID": 14, "context": "The Mizar Problems for Theorem Proving (MPTP) system has been developed and used to extract first-order theorem proving problems from the Mizar Mathematical Library (MML) [15,16,14].", "startOffset": 171, "endOffset": 181}, {"referenceID": 15, "context": "The Mizar Problems for Theorem Proving (MPTP) system has been developed and used to extract first-order theorem proving problems from the Mizar Mathematical Library (MML) [15,16,14].", "startOffset": 171, "endOffset": 181}, {"referenceID": 13, "context": "The Mizar Problems for Theorem Proving (MPTP) system has been developed and used to extract first-order theorem proving problems from the Mizar Mathematical Library (MML) [15,16,14].", "startOffset": 171, "endOffset": 181}, {"referenceID": 5, "context": "In particular, Mizar provides supports for Schemes (allowing some degree of quantification over predicates and functions), Fraenkel terms (allowing sets to be specified using term level binders such as {f(x)|x \u2208 A, p(x)}) and a global choice operator the on types [6].", "startOffset": 264, "endOffset": 267}, {"referenceID": 13, "context": "Additionally, Fraenkel terms and global choice have been made first-order by a process of deanonymization [14].", "startOffset": 106, "endOffset": 110}, {"referenceID": 8, "context": "The resulting system has been used to extract a collection of higher-order theorem proving problems in THF0 format [9].", "startOffset": 115, "endOffset": 118}, {"referenceID": 13, "context": "As in [14] we can partition the", "startOffset": 6, "endOffset": 10}, {"referenceID": 2, "context": "We describe some examples and results from running the higher-order automated theorem provers Satallax [3] and LEO-II [2] on some collections of these problems.", "startOffset": 103, "endOffset": 106}, {"referenceID": 1, "context": "We describe some examples and results from running the higher-order automated theorem provers Satallax [3] and LEO-II [2] on some collections of these problems.", "startOffset": 118, "endOffset": 121}, {"referenceID": 3, "context": "We give a short introduction to the syntax of higher-order logic (in the form of Church\u2019s simple type theory [4]) so that we can describe the mapping in Section 4.", "startOffset": 109, "endOffset": 112}, {"referenceID": 8, "context": "In order to present higher-order problems to theorem provers, the THF0 format is used [9], but we mostly restrict ourselves to mathematical presentations of higher-order terms here.", "startOffset": 86, "endOffset": 89}, {"referenceID": 5, "context": "For a full presentation of the Mizar language, we direct the reader to [6].", "startOffset": 71, "endOffset": 74}, {"referenceID": 4, "context": ") An example of a scheme is Separation: for each set A and predicate P , there is a set X such that x \u2208 X iff x \u2208 A and P (x) [5].", "startOffset": 126, "endOffset": 129}, {"referenceID": 4, "context": "A simple example of a definition of an attribute is empty given in xboole 0 [5]:", "startOffset": 76, "endOffset": 79}, {"referenceID": 12, "context": "The most common example of a mode used in this paper is Element of from the Mizar article subset 1 [13]:", "startOffset": 99, "endOffset": 103}, {"referenceID": 10, "context": "As formulated in Mizar, the scheme asserts that for each set A and each binary relation P on sets, if P is functional, then there is a set X such that x \u2208 X iff there is a y \u2208 A such that P (y, x) [11].", "startOffset": 197, "endOffset": 201}, {"referenceID": 8, "context": "For each scheme proven in the MML, the MPTP system has generated a corresponding higher-order problem in THF0 format [9].", "startOffset": 117, "endOffset": 120}, {"referenceID": 6, "context": "Note that Q is not explicitly given in the problem, but can easily be recovered using pattern unification [7], as we now demonstrate.", "startOffset": 106, "endOffset": 109}, {"referenceID": 12, "context": "From four Mizar articles [13,10,12,1] 47 problems were extracted.", "startOffset": 25, "endOffset": 37}, {"referenceID": 9, "context": "From four Mizar articles [13,10,12,1] 47 problems were extracted.", "startOffset": 25, "endOffset": 37}, {"referenceID": 11, "context": "From four Mizar articles [13,10,12,1] 47 problems were extracted.", "startOffset": 25, "endOffset": 37}, {"referenceID": 0, "context": "From four Mizar articles [13,10,12,1] 47 problems were extracted.", "startOffset": 25, "endOffset": 37}, {"referenceID": 9, "context": "We consider 245 such problems arising from three Mizar articles [10,12,1].", "startOffset": 64, "endOffset": 73}, {"referenceID": 11, "context": "We consider 245 such problems arising from three Mizar articles [10,12,1].", "startOffset": 64, "endOffset": 73}, {"referenceID": 0, "context": "We consider 245 such problems arising from three Mizar articles [10,12,1].", "startOffset": 64, "endOffset": 73}, {"referenceID": 7, "context": "Since these proved to be surprisingly difficult, we also considered \u201cpruned\u201d versions of the problems in which the first-order theorem prover E [8] indicated which axioms it used to find a corresponding first-order proof.", "startOffset": 144, "endOffset": 147}, {"referenceID": 12, "context": "One of the first uses of the global choice operator in Mizar is to define a (first-order) choice operator on sets called choose [13].", "startOffset": 128, "endOffset": 132}, {"referenceID": 11, "context": "Consider the following fragment of a Mizar proof about group theory [12].", "startOffset": 68, "endOffset": 72}, {"referenceID": 9, "context": "Consider the following proof fragment from [10].", "startOffset": 43, "endOffset": 47}, {"referenceID": 9, "context": "Consider the following proof fragment from [10]:", "startOffset": 43, "endOffset": 47}, {"referenceID": 4, "context": "The set operation X \\ Y is defined in an early Mizar article [5], and the following required existence proof is given:", "startOffset": 61, "endOffset": 64}, {"referenceID": 12, "context": "A scheme LEO-II can fully prove but Satallax cannot is the following Mizar scheme [13]:", "startOffset": 82, "endOffset": 86}], "year": 2016, "abstractText": "Certain constructs allowed in Mizar articles cannot be represented in first-order logic but can be represented in higher-order logic. We describe a way to obtain higher-order theorem proving problems from Mizar articles that make use of these constructs. In particular, higherorder logic is used to represent schemes, a global choice construct and set level binders. The higher-order automated theorem provers Satallax and LEO-II have been run on collections of these problems and the results are discussed.", "creator": "LaTeX with hyperref package"}}}