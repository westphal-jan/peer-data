{"id": "1606.09274", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Jun-2016", "title": "Compression of Neural Machine Translation Models via Pruning", "abstract": "neural machine translation ( nmt ), like many other deep computational domains, typically suffers from over - parameterization, resulting in large storage sizes. this paper examines three simple magnitude - based pruning schemes to compress nmt models, effectively class - blind, class - sensitive, and set - distribution, which differ in terms given how pruning thresholds are computed for the different classes of weights in the nmt architecture. we demonstrate systematic efficacy of weight pruning creating a pilot technique for a state - since - the - art nmt system. improvements show that hybrid nmt model having over 200 million parameters can be pruned on 93 % with very little performance loss as documented on the wmt'36 english - german translation task. this sheds light on the distribution of redundancy in the nmt architecture. our main result is that with retraining, we can lower and even surpass the original performance near an 80 % - pruned frame.", "histories": [["v1", "Wed, 29 Jun 2016 20:36:23 GMT  (5605kb,D)", "http://arxiv.org/abs/1606.09274v1", "Accepted to CoNLL 2016. 9 pages plus references"]], "COMMENTS": "Accepted to CoNLL 2016. 9 pages plus references", "reviews": [], "SUBJECTS": "cs.AI cs.CL cs.NE", "authors": ["abigail see", "minh-thang luong", "christopher d manning"], "accepted": false, "id": "1606.09274"}, "pdf": {"name": "1606.09274.pdf", "metadata": {"source": "CRF", "title": "Compression of Neural Machine Translation Models via Pruning", "authors": ["Abigail See", "Minh-Thang Luong", "Christopher D. Manning"], "emails": ["abisee@stanford.edu", "lmthang@stanford.edu", "manning@stanford.edu"], "sections": [{"heading": "1 Introduction", "text": "Neural Machine Translation (NMT) is a simple new architecture for translating texts from one language into another (Sutskever et al., 2014; Cho et al., 2014). NMT is a single deep neural network that is trained end-to-end, holding several advantages such as the ability to capture long-range dependencies in sentences, and generalization to unseen texts. Despite being relatively new, NMT has already achieved state-of-the-art translation results for several language pairs including EnglishFrench (Luong et al., 2015b), English-German (Jean et al., 2015a; Luong et al., 2015a; Luong and\n\u2217Both authors contributed equally.\nManning, 2015; Sennrich et al., 2016), EnglishTurkish (Sennrich et al., 2016), and English-Czech (Jean et al., 2015b; Luong and Manning, 2016). Figure 1 gives an example of an NMT system.\nWhile NMT has a significantly smaller memory footprint than traditional phrase-based approaches (which need to store gigantic phrase-tables and language models), the model size of NMT is still prohibitively large for mobile devices. For example, a recent state-of-the-art NMT system requires over 200 million parameters, resulting in a storage size of hundreds of megabytes (Luong et al., 2015a). Though the trend for bigger and deeper neural networks has brought great progress, it has also introduced over-parameterization, resulting in long running times, overfitting, and the storage size issue discussed above. A solution to the overparameterization problem could potentially aid all three issues, though the first (long running times) is outside the scope of this paper.\nOur contribution. In this paper we investigate the efficacy of weight pruning for NMT as a means of compression. We show that despite\nar X\niv :1\n60 6.\n09 27\n4v 1\n[ cs\n.A I]\n2 9\nJu n\n20 16\nits simplicity, magnitude-based pruning with retraining is highly effective, and we compare three magnitude-based pruning schemes \u2014 class-blind, class-uniform and class-distribution. Though recent work has chosen to use the latter two, we find the first and simplest scheme \u2014 class-blind \u2014 the most successful. We are able to prune 40% of the weights of a state-of-the-art NMT system with negligible performance loss, and by adding a retraining phase after pruning, we can prune 80% with no performance loss. Our pruning experiments also reveal some patterns in the distribution of redundancy in NMT. In particular we find that higher layers, attention and softmax weights are the most important, while lower layers and the embedding weights hold a lot of redundancy. For the Long Short-Term Memory (LSTM) architecture, we find that at lower layers the parameters for the input are most crucial, but at higher layers the parameters for the gates also become important."}, {"heading": "2 Related Work", "text": "Pruning the parameters from a neural network, referred to as weight pruning or network pruning, is a well-established idea though it can be implemented in many ways. Among the most popular are the Optimal Brain Damage (OBD) (Le Cun et al., 1989) and Optimal Brain Surgeon (OBS) (Hassibi and Stork, 1993) techniques, which involve computing the Hessian matrix of the loss function with respect to the parameters, in order to assess the saliency of each parameter. Parameters with low saliency are then pruned from the network and the remaining sparse network is retrained. Both OBD and OBS were shown to perform better than the so-called \u2018naive magnitude-based approach\u2019, which prunes parameters according to their magnitude (deleting parameters close to zero). However, the high computational complexity of OBD and OBS compare unfavorably to the computational simplicity of the magnitude-based approach, especially for large networks (Augasta and Kathirvalavakumar, 2013).\nIn recent years, the deep learning renaissance has prompted a re-investigation of network pruning for modern models and tasks. Magnitudebased pruning with iterative retraining has yielded strong results for Convolutional Neural Networks (CNN) performing visual tasks. Collins and Kohli (2014) prune 75% of AlexNet parameters with small accuracy loss on the ImageNet task, while\nHan et al. (2015b) prune 89% of AlexNet parameters with no accuracy loss on the ImageNet task.\nOther approaches focus on pruning neurons rather than parameters, via sparsity-inducing regularizers (Murray and Chiang, 2015) or \u2018wiring together\u2019 pairs of neurons with similar input weights (Srinivas and Babu, 2015). These approaches are much more constrained than weight-pruning schemes; they necessitate finding entire zero rows of weight matrices, or near-identical pairs of rows, in order to prune a single neuron. By contrast weight-pruning approaches allow weights to be pruned freely and independently of each other. The neuron-pruning approach of Srinivas and Babu (2015) was shown to perform poorly (it suffered performance loss after removing only 35% of AlexNet parameters) compared to the weightpruning approach of Han et al. (2015b). Though Murray and Chiang (2015) demonstrates neuronpruning for language modeling as part of a (nonneural) Machine Translation pipeline, their approach is more geared towards architecture selection than compression.\nThere are many other compression techniques for neural networks, including approaches based on on low-rank approximations for weight matrices (Jaderberg et al., 2014; Denton et al., 2014), or weight sharing via hash functions (Chen et al., 2015). Several methods involve reducing the precision of the weights or activations (Courbariaux et al., 2015), sometimes in conjunction with specialized hardware (Gupta et al., 2015), or even using binary weights (Lin et al., 2016). The \u2018knowledge distillation\u2019 technique of Hinton et al. (2015) involves training a small \u2018student\u2019 network on the soft outputs of a large \u2018teacher\u2019 network. Some approaches use a sophisticated pipeline of several techniques to achieve impressive feats of compression (Han et al., 2015a; Iandola et al., 2016).\nMost of the above work has focused on compressing CNNs for vision tasks. We extend the magnitude-based pruning approach of Han et al. (2015b) to recurrent neural networks (RNN), in particular LSTM architectures for NMT, and to our knowledge we are the first to do so. There has been some recent work on compression for RNNs (Lu et al., 2016; Prabhavalkar et al., 2016), but it focuses on other, non-pruning compression techniques. Nonetheless, our general observations on the distribution of redundancy in a LSTM, detailed in Section 4.5, are corroborated by Lu et al.\n(2016)."}, {"heading": "3 Our Approach", "text": "We first give a brief overview of Neural Machine Translation before describing the model architecture of interest, the deep multi-layer recurrent model with LSTM. We then explain the different types of NMT weights together with our approaches to pruning and retraining."}, {"heading": "3.1 Neural Machine Translation", "text": "Neural machine translation aims to directly model the conditional probability p(y|x) of translating a source sentence, x1, . . . , xn, to a target sentence, y1, . . . , ym. It accomplishes this goal through an encoder-decoder framework (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014). The encoder computes a representation s for each source sentence. Based on that source representation, the decoder generates a translation, one target word at a time, and hence, decomposes the log conditional probability as:\nlog p(y|x) = \u2211m\nt=1 log p (yt|y<t, s) (1)\nMost NMT work uses RNNs, but approaches differ in terms of: (a) architecture, which can\nbe unidirectional, bidirectional, or deep multilayer RNN; and (b) RNN type, which can be Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997) or the Gated Recurrent Unit (Cho et al., 2014).\nIn this work, we specifically consider the deep multi-layer recurrent architecture with LSTM as the hidden unit type. Figure 1 illustrates an instance of that architecture during training in which the source and target sentence pair are input for supervised learning. During testing, the target sentence is not known in advance; instead, the most probable target words predicted by the model are fed as inputs into the next timestep. The network stops when it emits the end-of-sentence symbol \u2014 a special \u2018word\u2019 in the vocabulary, represented by a dash in Figure 1."}, {"heading": "3.2 Understanding NMT Weights", "text": "Figure 2 shows the same system in more detail, highlighting the different types of parameters, or weights, in the model. We will go through the architecture from bottom to top. First, a vocabulary is chosen for each language, assuming that the top V frequent words are selected. Thus, every word in the source or target vocabulary can be represented by a one-hot vector of length V .\nThe source input sentence and target input sentence, represented as a sequence of one-hot vectors, are transformed into a sequence of word embeddings by the embedding weights. These embedding weights, which are learned during training, are different for the source words and the target words. The word embeddings and all hidden layers are vectors of length n (a chosen hyperparameter).\nThe word embeddings are then fed as input into the main network, which consists of two multilayer RNNs \u2018stuck together\u2019 \u2014 an encoder for the source language and a decoder for the target language, each with their own weights. The feedforward (vertical) weights connect the hidden unit from the layer below to the upper RNN block, and the recurrent (horizontal) weights connect the hidden unit from the previous time-step RNN block to the current time-step RNN block.\nThe hidden state at the top layer of the decoder is fed through an attention layer, which guides the translation by \u2018paying attention\u2019 to relevant parts of the source sentence; for more information see Bahdanau et al. (2015) or Section 3 of Luong et al. (2015a). Finally, for each target word, the top layer hidden unit is transformed by the softmax weights into a score vector of length V . The target word with the highest score is selected as the output translation.\nWeight Subgroups in LSTM \u2013 For the aforementioned RNN block, we choose to use LSTM as the hidden unit type. To facilitate our later discussion on the different subgroups of weights within LSTM, we first review the details of LSTM as formulated by Zaremba et al. (2014) as follows: i f o\nh\u0302\n = \nsigm sigm sigm tanh\nT4n,2n(hl\u22121thlt\u22121 )\n(2)\nclt = f \u25e6 clt\u22121 + i \u25e6 h\u0302 (3) hlt = o \u25e6 tanh(clt) (4)\nHere, each LSTM block at time t and layer l computes as output a pair of hidden and memory vectors (hlt, c l t) given the previous pair (h l t\u22121, c l t\u22121) and an input vector hl\u22121t (either from the LSTM block below or the embedding weights if l = 1). All of these vectors have length n.\nThe core of a LSTM block is the weight matrix T4n,2n of size 4n\u00d72n. This matrix can be decomposed into 8 subgroups that are responsible for the\ninteractions between {input gate i, forget gate f , output gate o, input signal h\u0302} \u00d7 {feed-forward input hl\u22121t , recurrent input h l t\u22121}."}, {"heading": "3.3 Pruning Schemes", "text": "We follow the general magnitude-based approach of Han et al. (2015b), which consists of pruning weights with smallest absolute value. However, we question the authors\u2019 pruning scheme with respect to the different weight classes, and experiment with three pruning schemes. Suppose we wish to prune x% of the total parameters in the model. How do we distribute the pruning over the different weight classes (illustrated in Figure 2) of our model? We propose to examine three different pruning schemes:\n1. Class-blind: Take all parameters, sort them by magnitude and prune the x% with smallest magnitude, regardless of weight class. (So some classes are pruned proportionally more than others).\n2. Class-uniform: Within each class, sort the weights by magnitude and prune the x% with smallest magnitude. (So all classes have exactly x% of their parameters pruned).\n3. Class-distribution: For each class c, weights with magnitude less than \u03bb\u03c3c are pruned. Here, \u03c3c is the standard deviation of that class and \u03bb is a universal parameter chosen such that in total, x% of all parameters are pruned. This is used by Han et al. (2015b).\nAll these schemes have their seeming advantages. Class-blind pruning is the simplest and adheres to the principle that pruning weights (or equivalently, setting them to zero) is least damaging when those weights are small, regardless of their locations in the architecture. Class-uniform pruning and classdistribution pruning both seek to prune proportionally within each weight class, either absolutely, or relative to the standard deviation of that class. We find that class-blind pruning outperforms both other schemes (see Section 4.1)."}, {"heading": "3.4 Retraining", "text": "In order to prune NMT models aggressively without performance loss, we retrain our pruned networks. That is, we continue to train the remaining weights, but maintain the sparse structure introduced by pruning. In our implementation, pruned\nweights are represented by zeros in the weight matrices, and we use binary \u2018mask\u2019 matrices, which represent the sparse structure of a network, to ignore updates to weights at pruned locations. This implementation has the advantage of simplicity as it requires minimal changes to the training and deployment code, but we note that a more complex implementation utilizing sparse matrices and sparse matrix multiplication could potentially yield speed improvements. However, such an implementation is beyond the scope of this paper."}, {"heading": "4 Experiments", "text": "We evaluate the effectiveness of our pruning approaches on a state-of-the-art NMT model.1 Specifically, an attention-based English-German NMT system from Luong et al. (2015a) is considered. Training data was obtained from WMT\u201914 consisting of 4.5M sentence pairs (116M English words, 110M German words). For more details on training hyperparameters, we refer readers to Section 4.1 of Luong et al. (2015a). All models are tested on newstest2014 (2737 sentences). The model achieves a perplexity of 6.1 and a BLEU score of 20.5 (after unknown word replacement).2\nWhen retraining pruned NMT systems, we use the following settings: (a) we start with a smaller learning rate of 0.5 (the original model uses a learning rate of 1.0), (b) we train for fewer epochs, 4 instead of 12, using plain SGD, (c) a simple learning rate schedule is employed; after 2 epochs, we begin to halve the learning rate every half an epoch, and (d) all other hyperparameters are the\n1We thank the authors of Luong et al. (2015a) for providing their trained models and assistance in using the codebase at https://github.com/lmthang/nmt.matlab.\n2The performance of this model is reported under row global (dot) in Table 4 of Luong et al. (2015a).\nsame, such as mini-batch size 128, maximum gradient norm 5, and dropout with probability 0.2."}, {"heading": "4.1 Comparing pruning schemes", "text": "Despite its simplicity, we observe in Figure 3 that class-blind pruning outperforms both other schemes in terms of translation quality at all pruning percentages. In order to understand this result, for each of the three pruning schemes, we pruned each class separately and recorded the effect on performance (as measured by perplexity). Figure 4 shows that with class-uniform pruning, the overall performance loss is caused disproportionately by a few classes: target layer 4, attention and softmax weights. Looking at Figure 5, we see that the most damaging classes to prune also tend to be those with weights of greater magnitude \u2014 these classes have much larger weights than others at the same percentile, so pruning them under the classuniform pruning scheme is more damaging. The situation is similar for class-distribution pruning.\nBy contrast, Figure 4 shows that under classblind pruning, the damage caused by pruning softmax, attention and target layer 4 weights is greatly decreased, and the contribution of each class towards the performance loss is overall more uniform. In fact, the distribution begins to reflect the number of parameters in each class \u2014 for example, the source and target embedding classes have larger contributions because they have more weights. We use only class-blind pruning for the rest of the experiments.\nFigure 4 also reveals some interesting information about the distribution of redundancy in NMT architectures \u2014 namely it seems that higher layers are more important than lower layers, and that attention and softmax weights are crucial. We will explore the distribution of redundancy further in Section 4.5."}, {"heading": "4.2 Pruning and retraining", "text": "Pruning has an immediate negative impact on performance (as measured by BLEU) that is exponential in pruning percentage; this is demonstrated by the blue line in Figure 6. However we find that up to about 40% pruning, performance is mostly unaffected, indicating a large amount of redundancy and over-parameterization in NMT.\nWe now consider the effect of retraining pruned models. The orange line in Figure 6 shows that after retraining the pruned models, baseline performance (20.48 BLEU) is both recovered and im-\nproved upon, up to 80% pruning (20.91 BLEU), with only a small performance loss at 90% pruning (20.13 BLEU). This may seem surprising, as we might not expect a sparse model to significantly out-perform a model with five times as many parameters. There are several possible explanations, two of which are given below.\nFirstly, we found that the less-pruned models perform better on the training set than the validation set, whereas the more-pruned models have closer performance on the two sets. This indicates that pruning has a regularizing effect on the retraining phase, though clearly more is not always better, as the 50% pruned and retrained model has better validation set performance than the 90%\npruned and retrained model. Nonetheless, this regularization effect may explain why the pruned and retrained models outperform the baseline.\nAlternatively, pruning may serve as a means to escape a local optimum. Figure 7 shows the loss function over time during the training, pruning and retraining process. During the original training process, the loss curve flattens out and seems to converge (note that we use early stopping to obtain our baseline model, so the original model was trained for longer than shown in Figure 7). Pruning causes an immediate increase in the loss function, but enables further gradient descent, allowing the retraining process to find a new, better local optimum. It seems that the disruption caused by\npruning is beneficial in the long-run."}, {"heading": "4.3 Starting with sparse models", "text": "The favorable performance of the pruned and retrained models raises the question: can we get a shortcut to this performance by starting with sparse models? That is, rather than train, prune, and retrain, what if we simply prune then train? To test this, we took the sparsity structure of our 50%\u201390% pruned models, and trained completely new models with the same sparsity structure. The purple line in Figure 6 shows that the \u2018sparse from the beginning\u2019 models do not perform as well as the pruned and retrained models, but they do come close to the baseline performance. This shows that while the sparsity structure alone contains useful information about redundancy and can therefore produce a competitive compressed model, it is important to interleave pruning with training.\nThough our method involves just one pruning stage, other pruning methods interleave pruning with training more closely by including several iterations (Collins and Kohli, 2014; Han et al., 2015b). We expect that implementing this for NMT would likely result in further compression and performance improvements."}, {"heading": "4.4 Storage size", "text": "The original unpruned model (a MATLAB file) has size 782MB. The 80% pruned and retrained model is 272MB, which is a 65.2% reduction. In this work we focus on compression in terms of number of parameters rather than storage size, be-\ncause it is invariant across implementations."}, {"heading": "4.5 Distribution of redundancy in NMT", "text": "We visualize in Figure 8 the redundancy structore of our NMT baseline model. Black pixels represent weights near to zero (those that can be pruned); white pixels represent larger ones. First we consider the embedding weight matrices, whose columns correspond to words in the vocabulary. Unsurprisingly, in Figure 8, we see that the parameters corresponding to the less common words are more dispensable. In fact, at the 80% pruning rate, for 100 uncommon source words and 1194 uncommon target words, we delete all parameters corresponding to that word. This is not quite the same as removing the word from the vocabulary \u2014 true out-of-vocabulary words are mapped to the embedding for the \u2018unknown word\u2019 symbol, whereas these \u2018pruned-out\u2019 words are mapped to a zero embedding. However in the original unpruned model these uncommon words already had near-zero embeddings, indicating that the model was unable to learn sufficiently distinctive representations.\nReturning to Figure 8, now look at the eight weight matrices for the source and target connections at each of the four layers. Each matrix corresponds to the 4n \u00d7 2n matrix T4n,2n in Equation (2). In all eight matrices, we observe \u2014 as does Lu et al. (2016) \u2014 that the weights connecting to the input h\u0302 are most crucial, followed by the input gate i, then the output gate o, then the forget gate f . This is particularly true of the lower layers, which focus primarily on the input h\u0302. However for higher layers, especially on the target side, weights connecting to the gates are as important as those connecting to the input h\u0302. The gates represent the LSTM\u2019s ability to add to, delete from or retrieve information from the memory cell. Figure 8 therefore shows that these sophisticated memory cell abilities are most important at the end of the NMT pipeline (the top layer of the decoder). This is reasonable, as we expect higher-level features to be learned later in a deep learning pipeline.\nWe also observe that for lower layers, the feedforward input is much more important than the recurrent input, whereas for higher layers the recurrent input becomes more important. This makes sense: lower layers concentrate on the low-level information from the current word embedding (the feed-forward input), whereas higher layers make\nuse of the higher-level representation of the sentence so far (the recurrent input).\nLastly, on close inspection, we notice several white diagonals emerging within some subsquares of the matrices in Figure 8, indicating that even without initializing the weights to identity matrices (as is sometimes done (Le et al., 2015)), an identity-like weight matrix is learned. At higher pruning percentages, these diagonals become more pronounced."}, {"heading": "5 Generalizability of our results", "text": "To test the generalizability of our results, we also test our pruning approach on a smaller, nonstate-of-the-art NMT model trained on the WIT3 Vietnamese-English dataset (Cettolo et al., 2012), which consists of 133,000 sentence pairs. This model is effectively a scaled-down version of the state-of-the-art model in Luong et al. (2015a), with fewer layers, smaller vocabulary size, smaller hidden layer size, no attention mechanism, and about 11% as many parameters in total. It achieves a BLEU score of 9.61 on the validation set.\nAlthough this model and its training set are on a different scale to our main model, and the language pair is different, we found very similar results. For this model, it is possible to prune 60% of parameters with no immediate performance loss, and with retraining it is possible to prune 90%, and regain original performance. Our main observations from Sections 4.1 to 4.5 are also replicated; in particular, class-blind pruning is most successful, \u2018sparse from the beginning\u2019 models are less successful than pruned and retrained models, and we observe the same patterns as seen in Figure 8."}, {"heading": "6 Future Work", "text": "As noted in Section 4.3, including several iterations of pruning and retraining would likely improve the compression and performance of our pruning method. If possible it would be highly valuable to exploit the sparsity of the pruned models to speed up training and runtime, perhaps through sparse matrix representations and multiplications (see Section 3.4). Though we have found magnitude-based pruning to perform very well, it would be instructive to revisit the original claim that other pruning methods (for example Optimal Brain Damage and Optimal Brain Surgery) are more principled, and perform a comparative study."}, {"heading": "7 Conclusion", "text": "We have shown that weight pruning with retraining is a highly effective method of compression and regularization on a state-of-the-art NMT system, compressing the model to 20% of its size with no loss of performance. Though we are the first to apply compression techniques to NMT, we obtain a similar degree of compression to other current work on compressing state-of-the-art deep neural networks, with an approach that is simpler than most. We have found that the absolute size of parameters is of primary importance when choosing which to prune, leading to an approach that is extremely simple to implement, and can be applied to any neural network. Lastly, we have gained insight into the distribution of redundancy in the NMT architecture."}, {"heading": "8 Acknowledgment", "text": "This work was partially supported by NSF Award IIS-1514268 and partially supported by a gift from Bloomberg L.P. We gratefully acknowledge the support of the Defense Advanced Research Projects Agency (DARPA) Communicating with Computers (CwC) program under ARO prime contract no. W911NF-15-1-0462. Lastly, we acknowledge NVIDIA Corporation for the donation of Tesla K40 GPUs."}], "references": [{"title": "Pruning algorithms of neural networks - a comparative study", "author": ["M. Gethsiyal Augasta", "Thangairulappan Kathirvalavakumar."], "venue": "Central European Journal of Computer Science, 3(3):105\u2013115.", "citeRegEx": "Augasta and Kathirvalavakumar.,? 2013", "shortCiteRegEx": "Augasta and Kathirvalavakumar.", "year": 2013}, {"title": "Neural machine translation by jointly learning to align and translate", "author": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."], "venue": "ICLR.", "citeRegEx": "Bahdanau et al\\.,? 2015", "shortCiteRegEx": "Bahdanau et al\\.", "year": 2015}, {"title": "Wit: Web inventory of transcribed and translated talks", "author": ["Mauro Cettolo", "Christian Girardi", "Marcello Federico."], "venue": "EAMT.", "citeRegEx": "Cettolo et al\\.,? 2012", "shortCiteRegEx": "Cettolo et al\\.", "year": 2012}, {"title": "Compressing neural networks with the hashing trick", "author": ["Wenlin Chen", "James T Wilson", "Stephen Tyree", "Kilian Q Weinberger", "Yixin Chen."], "venue": "ICML.", "citeRegEx": "Chen et al\\.,? 2015", "shortCiteRegEx": "Chen et al\\.", "year": 2015}, {"title": "Learning phrase representations using RNN encoder-decoder for statistical machine translation", "author": ["Kyunghyun Cho", "Bart van Merrienboer", "Caglar Gulcehre", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio."], "venue": "EMNLP.", "citeRegEx": "Cho et al\\.,? 2014", "shortCiteRegEx": "Cho et al\\.", "year": 2014}, {"title": "Memory bounded deep convolutional networks", "author": ["Maxwell D. Collins", "Pushmeet Kohli."], "venue": "arXiv preprint arXiv:1412.1442.", "citeRegEx": "Collins and Kohli.,? 2014", "shortCiteRegEx": "Collins and Kohli.", "year": 2014}, {"title": "Training deep neural networks with low precision multiplications", "author": ["Matthieu Courbariaux", "Yoshua Bengio", "Jean-Pierre David."], "venue": "ICLR workshop.", "citeRegEx": "Courbariaux et al\\.,? 2015", "shortCiteRegEx": "Courbariaux et al\\.", "year": 2015}, {"title": "Exploiting linear structure within convolutional networks for efficient evaluation", "author": ["Emily L. Denton", "Wojciech Zaremba", "Joan Bruna", "Yann LeCun", "Rob Fergus."], "venue": "NIPS.", "citeRegEx": "Denton et al\\.,? 2014", "shortCiteRegEx": "Denton et al\\.", "year": 2014}, {"title": "Deep learning with limited numerical precision", "author": ["Suyog Gupta", "Ankur Agrawal", "Kailash Gopalakrishnan", "Pritish Narayanan."], "venue": "ICML.", "citeRegEx": "Gupta et al\\.,? 2015", "shortCiteRegEx": "Gupta et al\\.", "year": 2015}, {"title": "Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding", "author": ["Song Han", "Huizi Mao", "William J Dally."], "venue": "ICLR.", "citeRegEx": "Han et al\\.,? 2015a", "shortCiteRegEx": "Han et al\\.", "year": 2015}, {"title": "Learning both weights and connections for efficient neural network", "author": ["Song Han", "Jeff Pool", "John Tran", "William Dally."], "venue": "NIPS.", "citeRegEx": "Han et al\\.,? 2015b", "shortCiteRegEx": "Han et al\\.", "year": 2015}, {"title": "Second order derivatives for network pruning: Optimal brain surgeon", "author": ["Babak Hassibi", "David G. Stork."], "venue": "Morgan Kaufmann.", "citeRegEx": "Hassibi and Stork.,? 1993", "shortCiteRegEx": "Hassibi and Stork.", "year": 1993}, {"title": "Distilling the knowledge in a neural network", "author": ["Geoffrey Hinton", "Oriol Vinyals", "Jeff Dean."], "venue": "NIPS Deep Learning Workshop.", "citeRegEx": "Hinton et al\\.,? 2015", "shortCiteRegEx": "Hinton et al\\.", "year": 2015}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber."], "venue": "Neural computation, 9(8):1735\u20131780.", "citeRegEx": "Hochreiter and Schmidhuber.,? 1997", "shortCiteRegEx": "Hochreiter and Schmidhuber.", "year": 1997}, {"title": "Squeezenet: Alexnet-level accuracy with 50x fewer parameters and< 0.5MB model size. arXiv preprint arXiv:1602.07360", "author": ["Forrest N. Iandola", "Matthew W. Moskewicz", "Khalid Ashraf", "Song Han", "William J. Dally", "Kurt Keutzer"], "venue": null, "citeRegEx": "Iandola et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Iandola et al\\.", "year": 2016}, {"title": "Speeding up convolutional neural networks with low rank expansions", "author": ["Max Jaderberg", "Andrea Vedaldi", "Andrew Zisserman."], "venue": "NIPS.", "citeRegEx": "Jaderberg et al\\.,? 2014", "shortCiteRegEx": "Jaderberg et al\\.", "year": 2014}, {"title": "On using very large target vocabulary for neural machine translation", "author": ["S\u00e9bastien Jean", "Kyunghyun Cho", "Roland Memisevic", "Yoshua Bengio."], "venue": "ACL.", "citeRegEx": "Jean et al\\.,? 2015a", "shortCiteRegEx": "Jean et al\\.", "year": 2015}, {"title": "Montreal neural machine translation systems for WMT\u201915", "author": ["S\u00e9bastien Jean", "Orhan Firat", "Kyunghyun Cho", "Roland Memisevic", "Yoshua Bengio."], "venue": "WMT.", "citeRegEx": "Jean et al\\.,? 2015b", "shortCiteRegEx": "Jean et al\\.", "year": 2015}, {"title": "Recurrent continuous translation models", "author": ["Nal Kalchbrenner", "Phil Blunsom."], "venue": "EMNLP.", "citeRegEx": "Kalchbrenner and Blunsom.,? 2013", "shortCiteRegEx": "Kalchbrenner and Blunsom.", "year": 2013}, {"title": "A simple way to initialize recurrent networks of rectified linear units", "author": ["Quoc V. Le", "Navdeep Jaitly", "Geoffrey E. Hinton."], "venue": "arXiv preprint arXiv:1504.00941.", "citeRegEx": "Le et al\\.,? 2015", "shortCiteRegEx": "Le et al\\.", "year": 2015}, {"title": "Optimal brain damage", "author": ["Yann Le Cun", "John S. Denker", "Sara A. Solla."], "venue": "NIPS.", "citeRegEx": "Cun et al\\.,? 1989", "shortCiteRegEx": "Cun et al\\.", "year": 1989}, {"title": "Neural networks with few multiplications", "author": ["Zhouhan Lin", "Matthieu Courbariaux", "Roland Memisevic", "Yoshua Bengio."], "venue": "ICLR.", "citeRegEx": "Lin et al\\.,? 2016", "shortCiteRegEx": "Lin et al\\.", "year": 2016}, {"title": "Learning compact recurrent neural networks", "author": ["Zhiyun Lu", "Vikas Sindhwani", "Tara N. Sainath."], "venue": "ICASSP.", "citeRegEx": "Lu et al\\.,? 2016", "shortCiteRegEx": "Lu et al\\.", "year": 2016}, {"title": "Stanford neural machine translation systems for spoken language domain", "author": ["Minh-Thang Luong", "Christopher D. Manning."], "venue": "IWSLT.", "citeRegEx": "Luong and Manning.,? 2015", "shortCiteRegEx": "Luong and Manning.", "year": 2015}, {"title": "Achieving open vocabulary neural machine translation with hybrid word-character models", "author": ["Minh-Thang Luong", "Christopher D. Manning."], "venue": "ACL.", "citeRegEx": "Luong and Manning.,? 2016", "shortCiteRegEx": "Luong and Manning.", "year": 2016}, {"title": "Effective approaches to attentionbased neural machine translation", "author": ["Minh-Thang Luong", "Hieu Pham", "Christopher D. Manning."], "venue": "EMNLP.", "citeRegEx": "Luong et al\\.,? 2015a", "shortCiteRegEx": "Luong et al\\.", "year": 2015}, {"title": "Addressing the rare word problem in neural machine translation", "author": ["Minh-Thang Luong", "Ilya Sutskever", "Quoc V. Le", "Oriol Vinyals", "Wojciech Zaremba."], "venue": "ACL.", "citeRegEx": "Luong et al\\.,? 2015b", "shortCiteRegEx": "Luong et al\\.", "year": 2015}, {"title": "Auto-sizing neural networks: With applications to n-gram language models", "author": ["Kenton Murray", "David Chiang."], "venue": "EMNLP.", "citeRegEx": "Murray and Chiang.,? 2015", "shortCiteRegEx": "Murray and Chiang.", "year": 2015}, {"title": "On the compression of recurrent neural networks with an application to LVCSR acoustic modeling for embedded speech recognition", "author": ["Rohit Prabhavalkar", "Ouais Alsharif", "Antoine Bruguier", "Ian McGraw."], "venue": "ICASSP.", "citeRegEx": "Prabhavalkar et al\\.,? 2016", "shortCiteRegEx": "Prabhavalkar et al\\.", "year": 2016}, {"title": "Improving neural machine translation models with monolingual data", "author": ["Rico Sennrich", "Barry Haddow", "Alexandra Birch."], "venue": "ACL.", "citeRegEx": "Sennrich et al\\.,? 2016", "shortCiteRegEx": "Sennrich et al\\.", "year": 2016}, {"title": "Datafree parameter pruning for deep neural networks", "author": ["Suraj Srinivas", "R. Venkatesh Babu."], "venue": "BMVC.", "citeRegEx": "Srinivas and Babu.,? 2015", "shortCiteRegEx": "Srinivas and Babu.", "year": 2015}, {"title": "Sequence to sequence learning with neural networks", "author": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le."], "venue": "NIPS.", "citeRegEx": "Sutskever et al\\.,? 2014", "shortCiteRegEx": "Sutskever et al\\.", "year": 2014}, {"title": "Recurrent neural network regularization", "author": ["Wojciech Zaremba", "Ilya Sutskever", "Oriol Vinyals."], "venue": "arXiv preprint arXiv:1409.2329.", "citeRegEx": "Zaremba et al\\.,? 2014", "shortCiteRegEx": "Zaremba et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 31, "context": "Neural Machine Translation (NMT) is a simple new architecture for translating texts from one language into another (Sutskever et al., 2014; Cho et al., 2014).", "startOffset": 115, "endOffset": 157}, {"referenceID": 4, "context": "Neural Machine Translation (NMT) is a simple new architecture for translating texts from one language into another (Sutskever et al., 2014; Cho et al., 2014).", "startOffset": 115, "endOffset": 157}, {"referenceID": 26, "context": "Despite being relatively new, NMT has already achieved state-of-the-art translation results for several language pairs including EnglishFrench (Luong et al., 2015b), English-German (Jean et al.", "startOffset": 143, "endOffset": 164}, {"referenceID": 29, "context": ", 2016), EnglishTurkish (Sennrich et al., 2016), and English-Czech (Jean et al.", "startOffset": 24, "endOffset": 47}, {"referenceID": 17, "context": ", 2016), and English-Czech (Jean et al., 2015b; Luong and Manning, 2016).", "startOffset": 27, "endOffset": 72}, {"referenceID": 24, "context": ", 2016), and English-Czech (Jean et al., 2015b; Luong and Manning, 2016).", "startOffset": 27, "endOffset": 72}, {"referenceID": 25, "context": "For example, a recent state-of-the-art NMT system requires over 200 million parameters, resulting in a storage size of hundreds of megabytes (Luong et al., 2015a).", "startOffset": 141, "endOffset": 162}, {"referenceID": 11, "context": ", 1989) and Optimal Brain Surgeon (OBS) (Hassibi and Stork, 1993) techniques, which involve computing the Hessian matrix of the loss function with respect to the parameters, in order to assess the saliency of each parameter.", "startOffset": 40, "endOffset": 65}, {"referenceID": 0, "context": "However, the high computational complexity of OBD and OBS compare unfavorably to the computational simplicity of the magnitude-based approach, especially for large networks (Augasta and Kathirvalavakumar, 2013).", "startOffset": 173, "endOffset": 210}, {"referenceID": 5, "context": "Collins and Kohli (2014) prune 75% of AlexNet parameters with small accuracy loss on the ImageNet task, while Han et al.", "startOffset": 0, "endOffset": 25}, {"referenceID": 5, "context": "Collins and Kohli (2014) prune 75% of AlexNet parameters with small accuracy loss on the ImageNet task, while Han et al. (2015b) prune 89% of AlexNet parameters with no accuracy loss on the ImageNet task.", "startOffset": 0, "endOffset": 129}, {"referenceID": 27, "context": "Other approaches focus on pruning neurons rather than parameters, via sparsity-inducing regularizers (Murray and Chiang, 2015) or \u2018wiring together\u2019 pairs of neurons with similar input weights (Srinivas and Babu, 2015).", "startOffset": 101, "endOffset": 126}, {"referenceID": 30, "context": "Other approaches focus on pruning neurons rather than parameters, via sparsity-inducing regularizers (Murray and Chiang, 2015) or \u2018wiring together\u2019 pairs of neurons with similar input weights (Srinivas and Babu, 2015).", "startOffset": 192, "endOffset": 217}, {"referenceID": 25, "context": "Other approaches focus on pruning neurons rather than parameters, via sparsity-inducing regularizers (Murray and Chiang, 2015) or \u2018wiring together\u2019 pairs of neurons with similar input weights (Srinivas and Babu, 2015). These approaches are much more constrained than weight-pruning schemes; they necessitate finding entire zero rows of weight matrices, or near-identical pairs of rows, in order to prune a single neuron. By contrast weight-pruning approaches allow weights to be pruned freely and independently of each other. The neuron-pruning approach of Srinivas and Babu (2015) was shown to perform poorly (it suffered performance loss after removing only 35% of AlexNet parameters) compared to the weightpruning approach of Han et al.", "startOffset": 102, "endOffset": 582}, {"referenceID": 9, "context": "The neuron-pruning approach of Srinivas and Babu (2015) was shown to perform poorly (it suffered performance loss after removing only 35% of AlexNet parameters) compared to the weightpruning approach of Han et al. (2015b). Though Murray and Chiang (2015) demonstrates neuronpruning for language modeling as part of a (nonneural) Machine Translation pipeline, their approach is more geared towards architecture selection than compression.", "startOffset": 203, "endOffset": 222}, {"referenceID": 9, "context": "The neuron-pruning approach of Srinivas and Babu (2015) was shown to perform poorly (it suffered performance loss after removing only 35% of AlexNet parameters) compared to the weightpruning approach of Han et al. (2015b). Though Murray and Chiang (2015) demonstrates neuronpruning for language modeling as part of a (nonneural) Machine Translation pipeline, their approach is more geared towards architecture selection than compression.", "startOffset": 203, "endOffset": 255}, {"referenceID": 15, "context": "There are many other compression techniques for neural networks, including approaches based on on low-rank approximations for weight matrices (Jaderberg et al., 2014; Denton et al., 2014), or weight sharing via hash functions (Chen et al.", "startOffset": 142, "endOffset": 187}, {"referenceID": 7, "context": "There are many other compression techniques for neural networks, including approaches based on on low-rank approximations for weight matrices (Jaderberg et al., 2014; Denton et al., 2014), or weight sharing via hash functions (Chen et al.", "startOffset": 142, "endOffset": 187}, {"referenceID": 3, "context": ", 2014), or weight sharing via hash functions (Chen et al., 2015).", "startOffset": 46, "endOffset": 65}, {"referenceID": 6, "context": "Several methods involve reducing the precision of the weights or activations (Courbariaux et al., 2015), sometimes in conjunction with specialized hardware (Gupta et al.", "startOffset": 77, "endOffset": 103}, {"referenceID": 8, "context": ", 2015), sometimes in conjunction with specialized hardware (Gupta et al., 2015), or even using binary weights (Lin et al.", "startOffset": 60, "endOffset": 80}, {"referenceID": 21, "context": ", 2015), or even using binary weights (Lin et al., 2016).", "startOffset": 38, "endOffset": 56}, {"referenceID": 9, "context": "Some approaches use a sophisticated pipeline of several techniques to achieve impressive feats of compression (Han et al., 2015a; Iandola et al., 2016).", "startOffset": 110, "endOffset": 151}, {"referenceID": 14, "context": "Some approaches use a sophisticated pipeline of several techniques to achieve impressive feats of compression (Han et al., 2015a; Iandola et al., 2016).", "startOffset": 110, "endOffset": 151}, {"referenceID": 3, "context": ", 2014), or weight sharing via hash functions (Chen et al., 2015). Several methods involve reducing the precision of the weights or activations (Courbariaux et al., 2015), sometimes in conjunction with specialized hardware (Gupta et al., 2015), or even using binary weights (Lin et al., 2016). The \u2018knowledge distillation\u2019 technique of Hinton et al. (2015) involves training a small \u2018student\u2019 network on the soft outputs of a large \u2018teacher\u2019 network.", "startOffset": 47, "endOffset": 357}, {"referenceID": 22, "context": "There has been some recent work on compression for RNNs (Lu et al., 2016; Prabhavalkar et al., 2016), but it focuses on other, non-pruning compression techniques.", "startOffset": 56, "endOffset": 100}, {"referenceID": 28, "context": "There has been some recent work on compression for RNNs (Lu et al., 2016; Prabhavalkar et al., 2016), but it focuses on other, non-pruning compression techniques.", "startOffset": 56, "endOffset": 100}, {"referenceID": 9, "context": "We extend the magnitude-based pruning approach of Han et al. (2015b) to recurrent neural networks (RNN), in particular LSTM architectures for NMT, and to our knowledge we are the first to do so.", "startOffset": 50, "endOffset": 69}, {"referenceID": 18, "context": "It accomplishes this goal through an encoder-decoder framework (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014).", "startOffset": 63, "endOffset": 137}, {"referenceID": 31, "context": "It accomplishes this goal through an encoder-decoder framework (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014).", "startOffset": 63, "endOffset": 137}, {"referenceID": 4, "context": "It accomplishes this goal through an encoder-decoder framework (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014).", "startOffset": 63, "endOffset": 137}, {"referenceID": 13, "context": "Most NMT work uses RNNs, but approaches differ in terms of: (a) architecture, which can be unidirectional, bidirectional, or deep multilayer RNN; and (b) RNN type, which can be Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997) or the Gated Recurrent Unit (Cho et al.", "startOffset": 207, "endOffset": 241}, {"referenceID": 4, "context": "Most NMT work uses RNNs, but approaches differ in terms of: (a) architecture, which can be unidirectional, bidirectional, or deep multilayer RNN; and (b) RNN type, which can be Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997) or the Gated Recurrent Unit (Cho et al., 2014).", "startOffset": 270, "endOffset": 288}, {"referenceID": 1, "context": "The hidden state at the top layer of the decoder is fed through an attention layer, which guides the translation by \u2018paying attention\u2019 to relevant parts of the source sentence; for more information see Bahdanau et al. (2015) or Section 3 of Luong et al.", "startOffset": 202, "endOffset": 225}, {"referenceID": 1, "context": "The hidden state at the top layer of the decoder is fed through an attention layer, which guides the translation by \u2018paying attention\u2019 to relevant parts of the source sentence; for more information see Bahdanau et al. (2015) or Section 3 of Luong et al. (2015a). Finally, for each target word, the top layer hidden unit is transformed by the softmax weights into a score vector of length V .", "startOffset": 202, "endOffset": 262}, {"referenceID": 1, "context": "The hidden state at the top layer of the decoder is fed through an attention layer, which guides the translation by \u2018paying attention\u2019 to relevant parts of the source sentence; for more information see Bahdanau et al. (2015) or Section 3 of Luong et al. (2015a). Finally, for each target word, the top layer hidden unit is transformed by the softmax weights into a score vector of length V . The target word with the highest score is selected as the output translation. Weight Subgroups in LSTM \u2013 For the aforementioned RNN block, we choose to use LSTM as the hidden unit type. To facilitate our later discussion on the different subgroups of weights within LSTM, we first review the details of LSTM as formulated by Zaremba et al. (2014) as follows: \uf8ec\uf8ec\uf8ed i f", "startOffset": 202, "endOffset": 739}, {"referenceID": 9, "context": "We follow the general magnitude-based approach of Han et al. (2015b), which consists of pruning weights with smallest absolute value.", "startOffset": 50, "endOffset": 69}, {"referenceID": 9, "context": "This is used by Han et al. (2015b).", "startOffset": 16, "endOffset": 35}, {"referenceID": 25, "context": "1 Specifically, an attention-based English-German NMT system from Luong et al. (2015a) is considered.", "startOffset": 66, "endOffset": 87}, {"referenceID": 25, "context": "1 Specifically, an attention-based English-German NMT system from Luong et al. (2015a) is considered. Training data was obtained from WMT\u201914 consisting of 4.5M sentence pairs (116M English words, 110M German words). For more details on training hyperparameters, we refer readers to Section 4.1 of Luong et al. (2015a). All models are tested on newstest2014 (2737 sentences).", "startOffset": 66, "endOffset": 318}, {"referenceID": 25, "context": "We thank the authors of Luong et al. (2015a) for providing their trained models and assistance in using the codebase at https://github.", "startOffset": 24, "endOffset": 45}, {"referenceID": 25, "context": "We thank the authors of Luong et al. (2015a) for providing their trained models and assistance in using the codebase at https://github.com/lmthang/nmt.matlab. The performance of this model is reported under row global (dot) in Table 4 of Luong et al. (2015a). same, such as mini-batch size 128, maximum gradient norm 5, and dropout with probability 0.", "startOffset": 24, "endOffset": 259}, {"referenceID": 5, "context": "Though our method involves just one pruning stage, other pruning methods interleave pruning with training more closely by including several iterations (Collins and Kohli, 2014; Han et al., 2015b).", "startOffset": 151, "endOffset": 195}, {"referenceID": 10, "context": "Though our method involves just one pruning stage, other pruning methods interleave pruning with training more closely by including several iterations (Collins and Kohli, 2014; Han et al., 2015b).", "startOffset": 151, "endOffset": 195}, {"referenceID": 22, "context": "In all eight matrices, we observe \u2014 as does Lu et al. (2016) \u2014 that the weights connecting to the input \u0125 are most crucial, followed by the input gate i, then the output gate o, then the forget gate f .", "startOffset": 44, "endOffset": 61}, {"referenceID": 19, "context": "Lastly, on close inspection, we notice several white diagonals emerging within some subsquares of the matrices in Figure 8, indicating that even without initializing the weights to identity matrices (as is sometimes done (Le et al., 2015)), an identity-like weight matrix is learned.", "startOffset": 221, "endOffset": 238}, {"referenceID": 2, "context": "To test the generalizability of our results, we also test our pruning approach on a smaller, nonstate-of-the-art NMT model trained on the WIT3 Vietnamese-English dataset (Cettolo et al., 2012), which consists of 133,000 sentence pairs.", "startOffset": 170, "endOffset": 192}, {"referenceID": 2, "context": "To test the generalizability of our results, we also test our pruning approach on a smaller, nonstate-of-the-art NMT model trained on the WIT3 Vietnamese-English dataset (Cettolo et al., 2012), which consists of 133,000 sentence pairs. This model is effectively a scaled-down version of the state-of-the-art model in Luong et al. (2015a), with fewer layers, smaller vocabulary size, smaller hidden layer size, no attention mechanism, and about 11% as many parameters in total.", "startOffset": 171, "endOffset": 338}], "year": 2016, "abstractText": "Neural Machine Translation (NMT), like many other deep learning domains, typically suffers from over-parameterization, resulting in large storage sizes. This paper examines three simple magnitude-based pruning schemes to compress NMT models, namely class-blind, class-uniform, and class-distribution, which differ in terms of how pruning thresholds are computed for the different classes of weights in the NMT architecture. We demonstrate the efficacy of weight pruning as a compression technique for a state-of-the-art NMT system. We show that an NMT model with over 200 million parameters can be pruned by 40% with very little performance loss as measured on the WMT\u201914 EnglishGerman translation task. This sheds light on the distribution of redundancy in the NMT architecture. Our main result is that with retraining, we can recover and even surpass the original performance with an 80%-pruned model.", "creator": "TeX"}}}