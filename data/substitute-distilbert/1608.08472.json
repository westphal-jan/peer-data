{"id": "1608.08472", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Aug-2016", "title": "ALLSAT compressed with wildcards. Part 1: Converting CNF's to orthogonal DNF's", "abstract": "for most branching algorithms in boolean logic \" neumann \" means \" absolute - value branching \". we present the apparently novel technique of clause - wise probing, which is used to solve the allsat problem for arbitrary boolean functions in cnf format. typically, arithmetic converts a cnf into corresponding orthogonal dnf, ch. e. into an exclusive sum of products. our method is enhanced by two ingredients : the use of a good branching - vector and wildcards beyond the common don't - care symbol.", "histories": [["v1", "Tue, 30 Aug 2016 14:32:41 GMT  (2015kb,D)", "http://arxiv.org/abs/1608.08472v1", "26 pages, 4 figures, 10 Tables"], ["v2", "Fri, 17 Mar 2017 15:57:49 GMT  (88kb,D)", "http://arxiv.org/abs/1608.08472v2", "27 pages, 3 figures, 10 Tables"]], "COMMENTS": "26 pages, 4 figures, 10 Tables", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["marcel wild"], "accepted": false, "id": "1608.08472"}, "pdf": {"name": "1608.08472.pdf", "metadata": {"source": "CRF", "title": "ALLSAT compressed with wildcards. Part 1: Converting CNF\u2019s to orthogonal DNF\u2019s", "authors": ["Marcel Wild"], "emails": [], "sections": [{"heading": null, "text": "solve the ALLSAT problem for arbitrary Boolean functions in CNF format. Specifically, it converts\na CNF into an orthogonal DNF, i.e. into an exclusive sum of products. Our method is enhanced\nby two ingredients: The use of a good SAT-solver and wildcards beyond the common don\u2019t-care\nsymbol."}, {"heading": "1 Introduction", "text": "In his 1979 landmark paper [V] Leslie Valiant shifted attention from the SAT problem to the #SAT problem, i.e. to the task of calculating the exact cardinality of the model set Mod(\u03d5) \u2286 {0, 1}w of a given Boolean function \u03d5 = \u03d5(x1, \u00b7 \u00b7 \u00b7 , xw). He showed that many #SAT problems are so-called #P -hard which implies they are at least as difficult as NP-hard problems. Even problems for which SAT is trivial can be #P-hard, such as #DNFSAT. Solving #SAT e.g. has applications for approximate reasoning as pointed out in [R].\nThe ALLSAT problem for \u03d5, our article\u2019s main topic, extends #SAT in so far that not just the number |Mod(\u03d5)| is required but the models themselves. In the literature often the underlying Boolean function (or formula) \u03d5 is not pointed out explicitely. In fact one may be interested in a subset SpMod(\u03d5) of \u201cspecial\u201d models which would be hard or impossible to capture by a Boolean formula. In the last fifty years a variety of such \u201cenumeration problems\u201d have been considered [Was]. The motivations for doing so (e.g. optimization beyond the scope of linear programming) are nicely laid out e.g. in Foreword 2 of [M]. We won\u2019t dwell on that in the sequel, except briefly in 8.4. Rather the present article sticks to theory (algorithmics), and to a strictly Boolean function framework.\nSince |Mod(\u03d5)| can be exponential in the length |\u03d5| := w, one commonly regards the ALLSAT problem as solvable when the enumeration of Mod(\u03d5) can be achieved in output-polynomial time. It turns out that many classes C of Boolean functions whose #SAT problem is #P-hard nevertheless have a solvable ALLSAT-problem, e.g. the class of all Boolean DNF\u2019s. A sufficient condition for a solvable ALLSAT problem is formulated in the somewhat hidden Fact 7 of [V]. Our Corollary 2 with its hereditary classes C resembles Fact 7. Roughly speaking Corollary 2 states that tackling the ALLSAT problem for a hereditary class C scales proportional to the best SAT-solver available for C. In particular, a polynomial-time SAT-solver triggers a solvable ALLSAT problem for C. Unfortunately, from a practical point of view a one-by-one enumeration\nar X\niv :1\n60 8.\n08 47\n2v 1\n[ cs\n.A I]\n3 0\nA ug\n2 01\nof Mod(\u03d5), output-polynomial or not, gets tiresome when |Mod(\u03d5)| goes into the trillions. How we mend this state of affairs is surveyed in the remainder of the introduction. The detailed section break-up follows in 1.2.\n1.1 Enumerating a set of objects usually means that they are listed one-by-one. Thus, if the Boolean function \u03d50 : {0, 1}w \u2192 {0, 1} has w = 9 and is defined by \u03d50(x1, \u00b7 \u00b7 \u00b7 , x9) = x2\u2228x6 then enumerating the model set Mod(\u03d50) in this strict sense forces us to list 384 length 9 bitstrings. Since it is more economic to write\n(1) Mod(\u03d50) = (2,1, 2, 2, 2,2, 2, 2, 2) ] (2,0, 2, 2, 2,0, 2, 2, 2),\nwe henceforth mean by an enumeration of Mod(\u03d5) a partition of Mod(\u03d5) into such disjoint 012-rows. Here comes some handy notation right away: zeros(r), ones(r), and twos(r) are the sets of positions i \u2208 [w] := {1, 2, \u00b7 \u00b7 \u00b7 , w} where the 0\u2019s, 1\u2019s, and the don\u2019t-care symbols 2 occur. Thus zeros(r) = {2, 6} for the second 012-row r in (1). Intervals in the Boolean lattice {0, 1}w and 012-rows1 are the same thing. For instance the interval of all eight bitstrings u with (0, 1, 0, 0, 0) \u2264 u \u2264 (1, 1, 0, 1, 1) equals the 012-row (2, 1, 0, 2, 2). Bitstrings can either be viewed as singleton intervals or as 012-rows r with twos(r) = \u2205.\nAs mentioned above, an enumeration of Mod(\u03d5) (in the one-by-one sense) is commonly called the ALLSAT problem; we extend that concept by allowing disjoint 012-rows as well. It is evident that this wider concept of enumerating Mod(\u03d5) amounts to find an orthogonal DNF of \u03d5. At first we treat the ALLSAT problem in an abstract setting which e.g. comprises the usual variable-wise branching. The main thrust of the article however occurs in the second half which is dedicated to clause-wise branching, which often brings about better compression than variable-wise branching.\n1.2 Theorem 1 in Section 2 states that when \u03d5 is a Boolean function with a \u201crow-splitting mechanism\u201d then Mod(\u03d5) can be enumerated in a natural way. Corollary 2 shows that (a) common variable-wise branching fits the framework of Theorem 1, and (b) that the existence of a good row-splitting mechanism for a class C of functions requires a good SAT-solver for C. We then go on to replace Mod(\u03d5) by the set Mod(\u03d5, k) of all cardinality k models. This leads to the enumeration of all k-hitting sets of a hypergraph, and to all k-models of a DNF. Restricted to Section 2 the concept of a row-splitting mechanism may seem a bit far-fetched but it will be appreciated in Section 5 as a common hat for two or (prospectively) more quite distinct ways of branching.\nThe brief Sections 3 and 4 can be viewed as intermezzos preparing for Section 7. Section 3 presents some tests for Boolean functions in CNF format. And Section 4 is dedicated to Binary Decision Diagrams (BDD\u2019s), which serve two purposes. On the one hand they illustrate the inner workings of Theorem 1, on the other hand we prepare the reappearance of BDD\u2019s later on.\nSection 5 starts by recalling a well known propositional tautology. Its 2-dimensional visualization looks like the Flag of Papua and accompanies us throughout the remainder of the article. The Flag of Papua underlies the clause-wise branching introduced in 5.1. We call our method the\n1In previous publications the clumsier name, \u201c{0, 1, 2}-valued rows\u201d was used. While intervals or subcubes or terms occur frequently in the Boolean logic literature, our equivalent concept of a 012-row goes the extra (half) mile to make things more visual. That will particularly benefit us in Sections 5 and 6.\nclause-wise ALLSAT 012-algorithm. Fed with a CNF \u03d5 it returns Mod(\u03d5) as a disjoint union of 012-rows.\nIn Section 6 we add the e-wildcard which is surprisingly powerful notwithstanding its innocent definition: e \u00b7 \u00b7 \u00b7 e means \u201cat least one 1 here\u201d. Correspondingly the clause-wise ALLSAT ealgorithm, when fed with a CNF \u03d5, returns Mod(\u03d5) as a disjoint union of 012e-rows. While 012-rows match familiar exclusive sums of products (ESOP), their enhancement to 012e-rows can be viewed as an \u201cexclusive sum of fancy terms\u201d (ESOFT). Some immediate relations among ESOP, ESOFT, CNF, DNNF (see [D]) and BDD are discussed in 6.1, 6.2. More technical details concerning ESOFT follow in 6.3 to 6.5.\nSection 7 features numerical experiments carried out with Mathematica implementations of several ALLSAT algorithms (be it variable-wise or clause-wise, be it 012-level or 012e-level). We also add BDD\u2019s to the picture in the form of Mathematica\u2019s hardwired command SatisfiabilityCount, and consider weighted Boolean functions.\nSection 8, with the title \u201cHistory and envisaged future\u201d, mainly focuses on the ALLSAT ealgorithm. As to history, we e.g. acknowledge the ro\u0302le of Redelinghuys and Geldenhuys [RG]. As to the future of the ALLSAT e-algorithm, its main \u201ccompetitor\u201d seems to be binary decision diagrams (BDDs). Specifically we compare ESOFT and BDD with respect to these criteria: Their ability to compress Mod(\u03d5) (and also Mod(\u03d5, k)), and their ability to settle the equivalence of two Boolean functions. In Subsection 8.4 we briefly review what specific CNF\u2019s have already been tackled by the author with wildcards (e.g. Horn CNF\u2019s), and try to forecast what the future has in store."}, {"heading": "2 A comprehensive ALLSAT branching scheme", "text": "Let \u03d5 : {0, 1}w \u2192 {0, 1} be any Boolean function. Call any 012-row r of length w feasible (with respect to \u03d5) if r \u2229 Mod(\u03d5) 6= \u2205. In other words, the partial variable assignment defined by zeros(r) and ones(r) extends to a model of \u03d5. It will sometimes be useful to look at this condition from a slightly different angle. Namely, each 012-row r matches a unique term T (r) as follows: If say r = (2, 1, 2, 0, 0) then T (r) = x2 \u2227 x4 \u2227 x5. Conversely each term T matches a 012-row r(T ). The above condition r \u2229Mod(\u03d5) 6= \u2205 thus amounts to say that the Boolean function T (r)\u2227\u03d5 is satisfiable. A feasibility test is a subroutine which, when fed with a 012-row r, produces an answer yes or no. The feasibility test is weak if (\u201cno\u201d \u21d2 r is infeasible), and it is perfect2 if additionally (\u201cyes\u201d \u21d2 r is feasible). It will be convenient to call a 012-row r final if r \u2286 Mod(\u03d5).\nThroughout the article we tackle ALLSAT (independent of how \u03d5 is given) by constructing a search tree rooted at {0, 1}w = (2, 2, \u00b7 \u00b7 \u00b7 , 2) in a preorder depth-first manner, such that all nodes are 012-rows and such that the union of leaves equals Mod(\u03d5). Our search tree needs not be binary, thus a branching node (= non-leaf) may have more than two nodes.\n2.1 Specificially, a Boolean function \u03d5 : {0, 1}w \u2192 {0, 1} enjoys a row-splitting mechanism with 2For simplicity we disregard a third option \u201cdon\u2019t know\u201d. Consequently a \u201cyes\u201d of a weak feaiblity test must not be trusted. Of course, the better the test, the more likely \u201cyes\u201d is correct.\nrespect to positive integers h = h(\u03d5), d = d(\u03d5), s = s(\u03d5) (the latter \u2265 w for convenience) if the following takes place. First, coupled to each 012-row r (always of length w) is an integer deg(r) \u2208 [0, h], called the degree of r. We postulate that deg(r) can be calculated in \u2264 d time. Second, each feasible 012-row of degree h is final. Third, each feasible 012-row r of degree < h splits (whenever desired) in \u2264 s time into \u03c4 many disjoint 012-rows (its sons). Here \u03c4 \u2265 1 and the sons can uniquely be classified as first (r1), second (r2), . . . , last (r\u03c4 ). Furthermore it holds that\n(2a) all sons ri are feasible and of length w;\n(2b) all sons ri have deg(ri) > deg(r);\n(2c) (r1 ] \u00b7 \u00b7 \u00b7 ] r\u03c4 ) \u2229Mod(\u03d5) = r \u2229Mod(\u03d5).\nTheorem 1: There is an algorithm which for each satisfiable Boolean function \u03d5 with a row-splitting mechanism enumerates Mod(\u03d5), using R many disjoint 012-rows, in time O(Rh(d+ s)).\nProof: Our search tree T has the root (2, 2, \u00b7 \u00b7 \u00b7 , 2) which has degree 0. Its preorder depth-first construction is uniquely determined by the ordering of sons of splitting rows, and by declaring the degree h rows as leaves. More specifically, after each row splitting we update a labelling of the temporary leaves with their degrees, investing \u2264 d(\u03d5) time per updated labelling. Temporary leaves of degree h by assumption are final and need not be processed further. Due to (2a) the splitting mechanism can be continued on each temporary leaf of degree < h. It further follows from (2c) and induction that the union of all temporary leaves is always disjoint and contains Mod(\u03d5). From (2b) follows that eventually all temporary leaves have degree h, i.e. are leaves of T . Because all leaves (having degree h) are contained in Mod(\u03d5), the union of all leaves equals Mod(\u03d5).\nAs to the cost analysis, since there are |T | \u2212 R many nonleaves, and they are bijective to the occured row splittings, the cost of the latter amounts to O((|T | \u2212 R)s) = O(|T |s). There is no other hidden cost such as pruning infeasible rows. Because the depth of T is \u2264 h we get |T | \u2264 Rh. By the above the total cost of calculating degrees is O(Rhd). Furthermore, stacking or outputting a (final) length w bitstring costs O(w). Hence, in view of w \u2264 s, the overall cost is O(Rhd) +O(Rhs) +O(Rhw) = O(Rh(d+ s)).\nUnfortunately, all that can be proven about the number R of 012-rows is that R \u2264 |Mod(\u03d5)| due to the disjointness of rows. However, practise shows (Section 7) that R |Mod(\u03d5)| occurs frequently. In our applications of Theorem 1 it will always be that r1]\u00b7 \u00b7 \u00b7] rt in (2c) is actually a subset of r. Yet this is not required in the proof of Theorem 1. Subsection 2.2 gives some prerequisites for the first of five Corollaries stated in 2.3.\n2.2 Each set system F \u2286 P[w] invites two kinds of complementation. The global complement Fc := P[w] \\ F , and the member-wise complement Fc := {[w] \\ X : X \u2208 F}. Each F equals Mod(\u03d5) for a suitable (not unique) Boolean function \u03d5 : {0, 1}w \u2192 {0, 1}. Hence Fc = Mod(\u03d5c) for \u03d5c(x1, \u00b7 \u00b7 \u00b7 , xn) := \u03d5(x1, \u00b7 \u00b7 \u00b7 , xn); and Fc = Mod(\u03d5c) for \u03d5c := \u03d5(x1, \u00b7 \u00b7 \u00b7 , xn). For instance, if \u03d5 = \u03d5(x1, x2, x3) = x1\u2227(x2\u2228x3) then \u03d5c = x1 \u2227 (x2 \u2228 x3) = x1\u2228(x2\u2227x3) and \u03d5c = x1\u2227(x2\u2228x3).\nEvidently (\u03d5c)c = (\u03d5c)c = \u03d5.\nConsider the enumeration Mod(\u03d5) = r1]\u00b7 \u00b7 \u00b7]rt. Defining ri by ones(ri) := zeros(ri), zeros(ri) := ones(ri), twos(ri) := twos(ri), evidently yields the enumeration Mod(\u03d5c) = r1 ] \u00b7 \u00b7 \u00b7 ] rt. What about Mod(\u03d5c)? Getting the cardinality is easy:\n|Mod(\u03d5c)| = 2w \u2212 |Mod(\u03d5)| = 2w \u2212 |r1| \u2212 |r2| \u2212 \u00b7 \u00b7 \u00b7 \u2212 |rt|,\nyet finding an enumeration of Mod(\u03d5c) (even just one-by-one) is harder. Of course the naive approach to pick all U \u2208 P[w] and check whether or not U \u2208 Mod(\u03d5), does not yield an outputpolynomial enumeration of Mod(\u03d5c). The issue will be tackled in Corollary 1 (with the ro\u0302les of \u03d5 and \u03d5c switched).\n2.3 Let us see how usual variable-wise branching for Boolean functions \u03d5 : {0, 1}w \u2192 {0, 1} (in arbitrary format) fits the bill of Theorem 1. Here h = w and the row-splitting mechanism works as follows. By definition the degree of a 012-row r is deg(r) := min(twos(r)) \u2212 1. For instance r = (0, 1, 1, 0, 1, 2, 1, 0, 2, 1) has deg(r) = 5, and deg((2, 0, 2)) = 0. Thus d(\u03d5) = O(w) and feasible 012-rows of degree w (i.e. bitstrings) are indeed final. Suppose r is feasible and q := deg(r) < w. Let \u03c10 and \u03c11 be the 012-rows arising from r by substituting the 2 at position q + 1 by 0 and 1 respectively. The fact that deg(\u03c10) = deg(\u03c11) > deg(r) is akin to (2b), and r = \u03c10 ] \u03c11 is akin to (2c). However, either \u03c10 or \u03c11 (but not both since r is feasible) may be infeasible, which would clash with (2a). We thus need3 a satisfiability subroutine which decides matters. If say only \u03c10 is feasible then (2a) holds with \u03c4 = 1 and r1 := \u03c10. Obviously r1 \u2229Mod(\u03d5) = r \u2229Mod(\u03d5), and so (2b) and (2c) hold as well.\nIf the branching is variable-wise and the definition of deg(r) as above then clearly only 012-rows of type (\u2217, \u00b7 \u00b7 \u00b7 , \u2217, 2, \u00b7 \u00b7 \u00b7 , 2) with \u2217 \u2208 {0, 1} will ever be subject to row-splitting. Our first scenario to enumerate Mod(\u03d5) occurs if an enumeration of Mod(\u03d5c) happens to be known. As to how this \u201chappens\u201d, if e.g. \u03d5 is a CNF then a DNF of \u03d5c is readily obtained using De Morgan\u2019s laws. This DNF then needs to morph into an equivalent \u201cdisjoint sum of products\u201d. (This is a well researched problem, see also Section 8.4.2.)\nCorollary 1: Suppose that for the Boolean function \u03d5 : {0, 1}w \u2192 {0, 1} an enumeration of Mod(\u03d5c) is known which uses t many disjoint 012-rows. Then Mod(\u03d5) can be enumerated, using R many disjoint 012-rows, in time O(Rtwh).\nProof: In view of Theorem 1 it suffices to exhibit a row-splitting algorithm for \u03d5 of complexity s(\u03d5) = O(wt) because then O(Rh(d + s)) = O(Rh(w + wt)) = O(Rhwt). Suppose that our given enumeration is Mod(\u03d5c) = r\u20321 ] \u00b7 \u00b7 \u00b7 ] r\u2032t. Recall that above we considered a feasible r and a decomposition r = \u03c10 ] \u03c11 induced by variable-wise branching. The feasiblity of \u03c10 (similarly \u03c11) is equivalent to \u03c10\u2229Mod(\u03d5) 6= \u2205, which amounts to \u03c10 6\u2286 Mod(\u03d5c), which amounts to |\u03c10 \u2229 Mod(\u03d5c)| < |\u03c10|. This inequality can be tested because we have |\u03c10| = 2\u03b3 where \u03b3 := |twos(\u03c10)|, and\n\u03c10 \u2229Mod(\u03d5c) = (\u03c10 \u2229 r\u20321) ] (\u03c10 \u2229 r\u20322) ] \u00b7 \u00b7 \u00b7 ] (\u03c10 \u2229 r\u2032t). 3Whether the row-splitting mechanism is induced by variable-wise branching or something else, in order to fulfil (2a) one always needs a SAT-solver. More precisely, (2a) is essential for any theoretic cost analysis. In practise it may be affordable or even beneficial (see 7.2.1) to carry along infeasible rows for a while, they being detected at a later stage.\nIf zeros(\u03c10)\u2229ones(r\u2032i) 6= \u2205 or ones(\u03c10)\u2229zeros(r\u2032i) 6= \u2205 then \u03c10\u2229r\u2032i = \u2205. Otherwise \u03c10\u2229r\u2032i can again be written as a 012-row. For instance (0, 1, 2, 2, 1, 2)\u2229 (2, 1, 2, 0, 2, 2) = (0, 1, 2, 0, 1, 2). It follows that |\u03c10\u2229Mod(\u03d5c)| can be calculated in O(wt) time. A notable special case of \u03c10 being feasible, i.e. satisfying |\u03c10 \u2229Mod(\u03d5c)| < |\u03c10|, is that |\u03c10 \u2229Mod(\u03d5c)| = 0. This amounts to \u03c10 \u2286 Mod(\u03d5), i.e. to the finality of \u03c10.\nAs we shall see in 4.1, Boolean functions \u03d5 given by a BDD provide another example where a row-splitting mechanism for \u03d5 is readily obtained.\n2.3.1 In the remainder of 2.3 we switch from individual \u03d5\u2019s to classes C of Boolean functions. Albeit things possibly generalize, we demand that each \u03c8 \u2208 C is given by a Boolean formula and not by some other gadget. Further we view \u03c8(x1, x2, x4) := (x1 \u2192 x2)\u2227 x4 as distinct from \u03c80(x1, x2, x3, x4) := (x1 \u2192 x2)\u2227x4 because they are of type {0, 1}3 \u2192 {0, 1} and {0, 1}4 \u2192 {0, 1} respectively. Accordingly we have lengths |\u03c8| = 3 and |\u03c80| = 4. We call a class C of Boolean functions hereditary if for each \u03d5 \u2208 C the substitution4 of variables with 0 or 1 yields again a function from C.\nCorollary 2: Let C be a hereditary class of Boolean functions and suppose the satisfiability of each \u03c8 \u2208 C with |\u03c8| = w can be tested in time \u2264 sat(w), where sat is a monotone function. Then for each \u03d5 \u2208 C with |\u03d5| = w one can use variable-wise branching to enumerate Mod(\u03d5) in O(Rwsat(w)) time as a disjoint union of R many 012-rows.\nProof: In view of Theorem 1 and h = w and d + s = O(w + s) = O(s) it suffices to show that each \u03d5 \u2208 C possesses a row-splitting mechanism with s(\u03d5) = O(sat(w)). As seen above, splitting rows r amounts to checking the feasiblity of rows \u03c1, and this in turn reduces to the satisfiability of \u03d5 \u2227 T (\u03c1). Since C is hereditary, \u03c8 = \u03d5 \u2227 T (\u03c1) belongs to C. Because of |\u03c8| \u2264 |\u03d5| = w its satisfiability is testable in time sat(w).\nIt is a false impression that only rows r with deg(r) = w (i.e. bitstrings) can be final; see the end of the proof of Corollary 1. Another scenario admitting \u201cfat\u201d final 012-rows occurs when the \u03d5\u2019s are CNF\u2019s (Section 3). Generally speaking, a finality test is a subroutine which, when fed with a 012-row r, produces an answer yes or no. the finality test is weak if (\u201cno\u201d \u21d2 r is not final), and it is perfect if additionally (\u201cyes\u201d\u21d2 r is final). Whatever the \u201cnormal\u201d procedure for computing degrees of 012-rows, one can augment it by putting deg(r) := h whenever r is final. Hence finality testing merely inflates the parameter d(\u03d5) in Theorem 1.\n2.3.2 Let us slightly alter the definition of a row-splitting mechanism by replacing (2c) with\n(2c\u2032) (r1 ] \u00b7 \u00b7 \u00b7 ] r\u03c4 ) \u2229 SpMod(\u03d5) = r \u2229 SpMod(\u03d5)\nwhere SpMod(\u03d5) \u2286 Mod(\u03d5) is some well defined subset of \u201cspecial\u201d models. From the proof of Theorem 1 it is clear that Theorem 1 still holds when Mod(\u03d5) is replaced by SpMod(\u03d5). In practise of course the row-splitting mechanism may get complicated. For instance, for any given hypergraph H \u2286 {0, 1}w it is easy to write down a Boolean formula \u03d5 such the Mod(\u03d5)\n4For instance, take \u03d5(x1, x2, x3, x4, x5) = (x2 \u2228 x4) \u2227 (x1 \u2228 x4 \u2228 x5) \u2227 x3. Then (say) the substitution {x2 \u2192 1, x5 \u2192 0} yields the 3-variable function \u03c8(x1, x3, x4) = (x1 \u2228 x4) \u2227 x3. The substitution {x3 \u2192 0} yields the 4-variable zero function \u03c80(x1, x2, x4, x5) = 0.\ncontains exactly the hitting sets (= transversals) of H. For the subset SpMod(\u03d5) of all exact hitting sets, an elegeant row-splitting mechanism can be designed based on Donald Knuth\u2019s \u201cDancing links\u201d algorithm. On a general level, often SpMod(\u03d5 \u2286 Mod(\u03d5) arises by focusing on the inclusion-minimal (or maximal) models. In the sequel we content ourselves to consider SpMod(\u03d5) = Mod(\u03d5, k) := {u \u2208 Mod(\u03d5) : |u| = k}. Here the cardinality of a bitstring u \u2208 {0, 1}w is the number of 1\u2019s, thus |u| := |{i \u2208 [w] : ui = 1}|. A Boolean function \u03d5 is ksatisfiable if Mod(\u03d5, k) 6= \u2205.\nCorollary 3: Let C be a hereditary class of Boolean functions and suppose the k-satisfiability of each \u03c8 \u2208 C can be tested in time sat(w, k). If sat is monotone in each component then for each \u03d5 \u2208 C with |\u03d5| = w and each fixed k > 0 one can enumerate Mod(\u03d5, k) in O(Rwsat(w, k)) time where R = |Mod(\u03d5, k)|.\nProof: A row \u03c1 is k-feasible if \u03c1\u2229Mod(\u03d5, k) 6= \u2205. Fine-tuning the previous proof we need to show that checking the k-feasiblity of a 012-row \u03c1 can be done in time sat(w, k). If \u03ba := |ones(\u03c1)| is > k then \u03c1 is not k-feasible. Otherwise consider \u03c8 = \u03d5 \u2227 T (\u03c1). Because (|\u03c8|, k \u2212 \u03ba) \u2264 (w, k) one can check in time sat(|\u03c8|, k \u2212 \u03ba) \u2264 sat(w, k) whether \u03c8 is (k \u2212 \u03ba)-satisfiable. If yes then \u03c1 is k-feasible, otherwise not.\nAs opposed to r \u2286 Mod(\u03d5) obviously r \u2286 Mod(\u03d5, k) is only possible when twos(r) = \u2205. Hence the enumeration in Corollary 3 is necessarily5 one-by-one, i.e. R = |Mod(\u03d5, k)|. The same remark applies to Corollaries 4 and 5 (and to Corollary 1 where mutatis mutandis Mod(\u03d5, k) can also be substituted for Mod(\u03d5)).\nCorollary 4: Let k \u2265 0 be fixed. If \u03d5 : {0, 1}w \u2192 {0, 1} is given as DNF with t terms then Mod(\u03d5, k) can be enumerated in O(Rtw2) time where R = |Mod(\u03d5, k)|.\nProof: In view of Corollary 3 it suffices to show that for DNF\u2019s \u03d5 the time sat(w, k) to test for r \u2229 Mod(\u03d5, k) = \u2205 is O(tw). For starters, if {T1, \u00b7 \u00b7 \u00b7 , Tt} is the set of terms of \u03d5 then Mod(\u03d5) = r(T1)\u222a \u00b7 \u00b7 \u00b7 \u222a r(Tt). Hence r\u2229Mod(\u03d5, k) 6= \u2205 iff some set r\u2229 r(Ti) contains a bitstring u with |u| = k. Now r \u2229 r(Ti) = \u2205 iff ones(r) \u2229 zeros(r(Ti)) 6= \u2205 or zeros(r) \u2229 ones(r(Ti)) 6= \u2205. If r \u2229 r(Ti) 6= \u2205 then \u03c1i := r \u2229 r(Ti) can be written as 012-row (as seen in the proof of Corollary 1). Evidently \u03c1i contains at least one u with |u| = k iff |ones(\u03c1i)| \u2264 k \u2264 |ones(\u03c1i)|+ |twos(\u03c1i)|. It follows that sat(w, k) = O(tw).\nAs an application of Corollary 4 it follows at once that the k-faces of a simplicial complex given by its facets can be enumerated in output-polynomial time [W11].\nRecall that a k-hitting set of a hypergraph H is a k-element set X such that X \u2229 Y 6= \u2205 for all hyperedges Y \u2208 H. A hypergraph is of rank d if |Y | \u2264 d for all Y \u2208 H.\n5Although we won\u2019t dwell on it in the present article, the verdict \u201cnecessarily\u201d is a bit too harsh: There is a way to compress Mod(\u03d5, k) using suitable wildcards. This is particularly tempting [W10] when \u03d5 is given by a BDD. See also 8.3.3.\nCorollary 5: All R many k-hitting sets of a rank 3 hypergraph H \u2286 P[w] can be enumerated in time O(Rw(1.6316k + kw)).\nProof: Coupled to H \u2286 P[w] consider the Boolean function \u03d5 : {0, 1}w \u2192 {0, 1} in CNF whose h clauses match the edges of H. Thus the edge Y = {1, 3, 4} \u2208 H matches the clause x1 \u2228 x3 \u2228 x4. The class C of all such (positive) CNF\u2019s is hereditary, as is illustrated in footnote 4. According to [Wa] one can test in time sat(w, k) = O(1.6316k + kw) whether a rank 3 hypergraph H \u2286 P[w] has a k-hitting set. Since sat is monotone the claim follows from Corollary 3.\nIt is interesting to compare Corollary 5 with this fixed-parameter result which doesn\u2019t use feasibility checks in its proof and which follows at once from Lemma 1.7 in [FG]: All R many k-hitting sets of a rank 3 hypergraph H can be enumerated in time O(3k \u00b7 k \u00b7 ||H||) where ||H|| := w + \u03a3{|X| : X \u2208 H}. Notice that possibly R 3k.\nSome readers may wish to skip Section 3 and 4 (which are less important and only used in the experiments Section 7) at a first reading and turn right away to Section 5 where we switch from variable-wise to clause-wise branching."}, {"heading": "3 One finality and two feasiblity tests for CNF\u2019s", "text": "The concepts of finality and feasibility apply to 012-rows r with respect to Boolean functions \u03d5 in arbitrary format. Here we specialize to the common CNF format: Subsection 3.1 is about a perfect finality test and some probabilistic analysis, and 3.2 presents two weak feasiblity tests.\n3.1 Say clause C is x3 \u2228 x5 \u2228 x6 \u2228 x9. If r is a 012-row of length w \u2265 9 that either satisfies ones(r) \u2229 {3, 5} 6= \u2205 or zeros(r) \u2229 {6, 9} 6= \u2205 then r \u2286 Mod(C). Generally, if \u03d5 is a CNF with clause set {C1, \u00b7 \u00b7 \u00b7 , Ch} such that the (index sets of) clauses Ci behave as C above then r \u2286 Mod(C1)\u2229\u00b7 \u00b7 \u00b7\u2229Mod(Ch) = Mod(\u03d5). Conversely, suppose some clause Cj , say x3\u2228x5\u2228x6\u2228x9, misbehaves in that ones(r) \u2229 {3, 5} = \u2205 = zeros(r) \u2229 {6, 9} for some row r. To fix ideas, assume 3 \u2208 zeros(r), 5 \u2208 twos(r), 6 \u2208 ones(r), 9 \u2208 twos(r). Then there is u \u2208 r with u5 = 0 and u9 = 1, which automatically violates Cj (since u3 \u2228u5 \u2228u6 \u2228u9 = 0\u2228 0\u2228 0\u2228 0 = 0). Hence r 6\u2286 Mod(\u03d5). To summarize, r \u2286 Mod(\u03d5) if and only if all clauses of \u03d5 behave well in the sense defined above. This yields a perfect finality test of cost O(hw) per row.\n3.1.1 As to probability, let \u03d5 = \u03d5(x1, \u00b7 \u00b7 \u00b7 , xw) be a random CNF with h clauses of length \u03bb. Given w and \u03b3, for a random 012-row of length w with |twos(r)| = \u03b3 we denote by prob(w, \u03b3, h, \u03bb) the probability that r is final with respect to \u03d5. In order to show\n(3) prob(w, \u03b3, h, \u03bb) = [1\u2212 (0.5) \u03bb w (w\u2212\u03b3)]h\nfix an arbitrary clause C of \u03d5. Then the probability that a random i \u2208 [w] both belongs to [w] \\ twos(r), and is an index of a literal of C, is q = w\u2212\u03b3w . \u03bb w . (Clearly the two events are independent.) It follows that the expected overlap of C with ones(r) \u222a zeros(r) has length qw. So the probability that at least one bit satisfies C is p = 1\u2212 (0.5)qw. Hence ph is the probability that all clauses behave well, which (as seen before) is equivalent to r \u2286 Mod(\u03d5).\n3.2 Consider the Boolean function \u03d5 : {0, 1}w \u2192 {0, 1} and some 012-row r of length w. When \u03d5 is given as a CNF with clauses C1, \u00b7 \u00b7 \u00b7 , Ch then instead of labelling the positions of r with 1, 2, \u00b7 \u00b7 \u00b7 , w it may at times be more convenient to label them with the variables x1, x2, \u00b7 \u00b7 \u00b7 , xw. Thus if w = 7 and r = (2, 0, 0, 1, 1, 2, 0) it holds that {x2, x3} \u2286 zeros(r). As to the clauses, let us identify Ci with the set of literals appearing in it. More subtly, we write C + i for the set of positive literals occuring in Ci, and C \u2212 i for the set of negated negative literals occuring in Ci. Thus if Ci \u201cwas\u201d x3 \u2228 x5 \u2228 x6 \u2228 x9 then C+i = {x3, x5} and C \u2212 i = {x6, x9} (not {x6, x9}).\nSuppose now Ci and r are such that\n(4) C+i \u2286 zeros(r) and C \u2212 i \u2286 ones(r).\nThen obviously r is infeasible (with respect to \u03d5). But r can be infeasible without there being a clause Ci (1 \u2264 i \u2264 h) satifying (4). We thus get a weak feasibility test, which we call Test 1. (It appears to be \u201cvery weak\u201d but if always C\u2212i = \u2205 as in 6.4, it becomes perfect.)\nConsider now clauses Ci and Cj(i 6= j) such that xp \u2208 C+i \u2229 C \u2212 j and\n(5) (C+i \\ {xp}) \u222a C + j \u2286 zeros(r) and (C \u2212 j \\ {xp}) \u222a C \u2212 i \u2286 ones(r).\nThen each bitstring u \u2208 r that wants to satisfy Ci must have 1 at position xp because by (5) no other literal in Ci can satisfy Ci. Likewise, if u wants to satisfy Cj then it needs to have 0 at position xp. It follows again that row r is infeasible. The ensuing weak feasibility test we call Test 2. Other weak feasibility tests along the same lines can be designed but for us Test 1 and (to lesser extent) Test 2 will suffice."}, {"heading": "4 A brief look at BDD\u2019s", "text": "We assume a basic familiarity with binary decision diagrams (BDD\u2019s), as e.g. provided by [K]. In this subsection BDDs serve to illustrate Theorem 1; but more importantly we prepare for the reoccurence of BDD\u2019s in Sections 6 to 8. Consider thus the Boolean function \u03d51 : {0, 1}5 \u2192 {0, 1} that is defined by the BDD in Figure 1. Whether a bitstring u belongs to Mod(\u03d51) can be decided as follows. The dashed and solid lines descending from a node labelled xi are chosen according to whether the i-th component ui of u is 0 or 1. Thus, in order to decide whether u = (u1, u2, u3, u4, u5) = (0, 1, 0, 1, 0) belongs to Mod(\u03d51) we follow the dashed line from the root (= top node) x1 to the node x2 (since u1 = 0). Then from x2 with the solid line to x4 (since u2 = 1), then from x4 with the solid line to x5 (since u4 = 1), then from x5 with the dashed line to \u22a5 (since u5 = 0). The value of u3 is irrelevant in all of this.\n4.1 Recall from 2.3 that with variable-wise branching only 012-rows of type r = (\u2217, \u00b7 \u00b7 \u00b7 , \u2217, 2, \u00b7 \u00b7 \u00b7 , 2) with \u2217 \u2208 {0, 1} are ever subject to row-splitting, i.e. to a feasibility check of (\u2217, \u00b7 \u00b7 \u00b7 , \u2217,0, \u00b7 \u00b7 \u00b7 , 2) and (\u2217, \u00b7 \u00b7 \u00b7 , \u2217,1, \u00b7 \u00b7 \u00b7 , 2). How these feasibility checks are performed in the case of BDD\u2019s is clear from the above. Hence Theorem 1 applies. Nevertheless, let us walk through the proof of Theorem 1 using the BDD of Figure 1.\nx1 3\u00ea16\n3\u00ea16 x2 x2 3\u00ea16\n1\u00ea8 x3 x3 1\u00ea8\nx3 1\u00ea4 x4 1\u00ea4 x4 1\u00ea4\nx5 1\u00ea2\n\u00a6 \u00a7\nFigure 1: Defining yHx1,...,x5L by a BDD\n22222\n02222 12222\n00222 01222\n00022 02112\n10222\n00012\n12 10122 11122\n01211 10102 11121\n10101\n11222\n00011\nFigure 2: Search tree for ModHyL\nSuppose we are at node 12222 := (1, 2, 2, 2, 2) in Figure 2. Thus in Figure 1 we find ourselves at the rightmost node x2. Setting this x2 to 0 or 1 delivers 10222 respectively 11222. Row 10222 is feasible because there is a path from the medium x3 node to > in Figure 1; and 11222 is feasible because there is a path from the rightmost x3 to >. Because of preorder we continue with 10222. Consulting the BDD shows that only its son 10122 (and not 10022) is feasible. And so it continues way down to the leaf (= model) 10101. Then one returns to 11222, and ends up with the leaf 11121. The fact that 11121 is a proper 012-row is due to the fact that there is a solid line from x3 to x5 in Figure 1, thus skipping x4. The leaves of the tree in Figure 2 show that |Mod(\u03d51)| = 6 because\n(6) Mod(\u03d51) = (0, 0, 0, 1, 1) ] (0, 1, 2, 1, 1) ] (1, 0, 1, 0, 1) ] (1, 1, 1, 2, 1)\nGenerally the degree of compression in the enumeration of Mod(\u03d5), i.e. the number of don\u2019t cares 2 in the 012-rows, depends on the index gaps j \u2212 i of directed edges xi \u2192 xj . In the worst case, when all index gaps are 1, there is no compression, i.e. all rows are bitstrings.\n4.2 As is well known, the two main advantages of the BDD format over other Boolean formats are fast equivalence testing (see 8.3.2) and fast calculation of |Mod(\u03d5)|. As to the latter, there is a standard bottom-up way to calculate for each nonleaf node u the probability pu that a random bitstring fed to u (viewed as the root of an induced BDD) triggers a path to >. Namely, pu is simply the arithmetic mean of the probabilities attached to the sons of u. This is carried out in Figure 1. In particular pu = 3 16 for the root u = x1 implies that 3 16 \u00b7 2\n5 = 6 bitstrings from {0, 1}5 are models of \u03d51. This matches the number obtained in 4.1. Of course if only |Mod(\u03d5)| as opposed to Mod(\u03d5) is required, the method just shown is much faster. As to enumerating Mod(\u03d5), there is a faster method than the row-splitting of Theorem 1 because it avoids the feasibility tests. Like the probability method it works bottom-up but in the end yields the same deomposition into disjoint 012-rows as Theorem 1; see [W10] for details."}, {"heading": "5 CNF-ALLSAT using clause-wise branching", "text": "There is an alternative to the variable-wise branching we applied so far. But it applies only to CNF-ALLSAT, i.e. the Boolean function \u03d5 = {0, 1}w \u2192 {0, 1} comes as CNF with h clauses Ci. Then we can build a search tree such that each node r (= 012-row) has its own particular \u201cpending\u201d clause Ci that needs to be \u201cimposed\u201d. The potentially more than two sons \u03c1j of r are constructed in a way that they all satisfy Ci. This novel kind branching has been programmed by the author in various6 settings. One benefit of clause-wise branching is that it often delivers fat 012-leaves due to a gratuitous finality test: A node is final (i.e. a leaf) if and only if all constraints Ci have been imposed on it. All of this fits the hat of Theorem 1.\n5.1 It has previously been useful, and will be in 5.2, to split the model set of any single clause y1 \u2228 y2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 ym as follows into a disjoint union of m many 012-rows (here m = 5):\nAs introduced in [W4, Sec.3], we shall refer to the pattern in Table 1 as the Flag of Papua with its three colors upon, below, and above the diagonal. It matches this familiar tautology (using concatenation instead of \u2227):\n(7) y1 \u2228 y2 \u2228 y3 \u2228 y4 \u2228 y5 \u2194 y1 \u2228 y1y2 \u2228 y1y2y3 \u2228 y1y2y3y4 \u2228 y1y2y3y4y5\n5.2 To develop the details of clause-wise branching, consider the CNF\n(8) \u03d52 := (x1\u2228x2\u2228x3)(x2\u2228x3\u2228x4)(x3\u2228x5)(x1\u2228x3\u2228x5)(x1\u2228x4\u2228x5)(x1\u2228x2\u2228x3)(x2\u2228x4\u2228x5).\nIt will pay to introduce some redundancy in that our 012-rows r are indexed by x1, x1, \u00b7 \u00b7 \u00b7 , x5, x5 rather than just x1, \u00b7 \u00b7 \u00b7 , x5 as in 3.2. Hence it suffices to speak of Ci (omitting C+i , C \u2212 i ), but it entails that when in r the xi-component is 1, its xi-component is 0, and vice versa. An entry 2 at the xi-component forces the xi-component to be 2 as well. Thus such entries are free to be 0 or 1, but in coordination.\nLet us denote by Cj the j-th clause in (8). We identify Cj with the set of its literals, thus C2 = {x2, x3, x4}. Let Modi be the set of all length 10 bitstrings that satisfy C1, C2, \u00b7 \u00b7 \u00b7 , Ci, i.e. the simultaneous models of these clauses. Following the principle of exclusion (footnote 5), starting with Mod0 = {0, 1}10 we shall inductively sieve Modi+1 from Modi (thus exclude the duds from Modi) until we arrive at the model set Mod7 of \u03d52(x1, \u00b7 \u00b7 \u00b7 , x5). We say a 012-row r satisfies a clause Ci if all bitstrings u \u2208 r satisfy Ci, and r violates Ci if at least one u \u2208 r violates Ci.\n6More details follow in Section 8.4 but we mention that in previous publications the author spoke of a \u201cprinciple of exclusion\u201d instead of the more telling clause-wise (or constraint-wise) branching.\nIn Table 2 below Mod0 is encoded by row r1, and Mod1 is displayed as the disjoint union of r2, r3, r4. The columns of the boldface Flag of Papua match the literals x1, x2, x3 of C1. The rows r2 to r4 constitute our working stack, of which always the top row will be treated\n7. To do so we keep track of which clause is pending for each row. For instance PC = 3 for r4 since besides C1 (by construction) r4 also happens to satisfy C2, and so the \u201cpending clause\u201d is C3. Next the top row r2 is split into three Flag of Papua candidate sons r5 to r7 according to clause C2. The new top row is r5 which in view of PC = 3 gives way to the candidate sons r8 and r9. Imposing C4 = {x1, x3, x5} upon r8 results in r10 = (0, 1, 1, 0, 0, 1, 2, 2, 1, 0), which has PC = 5. Imposing C5 = {x1, x4, x5} upon r10 yields r11 = {0, 1, 1, 0, 0, 1, 1, 0, 1, 0} which happens to be final, i.e. r11 also satisfies C6, C7. We thus remove r11, which condenses to (x1, x2, x3, x4, x5) = (0, 1, 0, 1, 1), from the working stack and continue in this manner until all leaves of the search tree have been pruned. The 012-rows matching the leaves partition Mod(\u03d52).\nThe reader may wish to carry on like this, though the enhancement in Section 6 will be more exciting. One can notice already that the indicated method begs for a SAT-solver (as in Section 2) in order to immediately get rid of infeasible 012-rows. We dub our procedure the clause-wise ALLSAT 012-algorithm, as opposed to the variable-wise ALLSAT 012-algorithm from 2.3.\n7That method amounts, as in Section 4, to a preorder depth-first search of a search tree (Fig.4). But for clause-wise (as opposed to variable-wise) branching the equivalent last-in-first-out (LIFO) stack framework is more appealing.\nProof: We first show that s(\u03d5) = O(wsat(w)), and then that d(\u03d5) = O(hw). In view of Theorem 1 the complexity then becomes O(Rh(d+ s)) = O(Rhw(h+ sat(w)) as claimed.\nAs to s(\u03d5), the row-splitting mechanism illustrated above works in time s(\u03d5) = O(w2 + wsat(w)) = O(wsat(w)). Indeed, imposing a clause of length \u03c4 \u2264 w upon a 012-row r of length w (i.e. raising the Flag of Papua) costs O(w\u03c4) = O(w2). Each of the \u03c4 many candidate sons \u03c1 needs to be tested for feasibility. Testing the feasibility of \u03c1 amounts to testing the satisfiability of \u03c8 = \u03d5 \u2227 T (\u03c1). Since C is hereditary, \u03c8 belongs to C and whence its satisfiability\nis testable in time sat(|\u03c8|) \u2264 sat(w). As to d(\u03d5), the degree of a 012-row r is calculated by scanning the h clauses Ci until Ci \u2229 ones(r) = \u2205. Hence d(\u03c8) = O(hw).\nWe mention that for the class C of Horn CNF\u2019s the bound in Theorem 2 reduces to O(Rh2w2). This is established in [W2], though in a framework more clumsy than Theorem 1 with its row-splitting mechanism. While one could also enumerate C in output-polynomial time using variable-wise branching, the high compression achieved by clause-wise branching would virtually disappear.\n6 Extension to 012e-rows\nWe now trim the clause-wise ALLSAT 012-algorithm of Section 5 by moving beyond the don\u2019t care symbol 2. The basic idea is to replace any Flag of Papua, as in in Table 2, by the wildcard or e-bubble (e, e, e, e, e) which by definition means \u201cat least one 1 here\u201d. Let us jump into medias res and impose C1 to C7 of \u03d52 anew, starting with row r \u2032 1 = (2, 2, \u00b7 \u00b7 \u00b7 , 2) in Table 3. Imposing C1 upon r \u2032 1 yields r \u2032 2. Imposing C2 upon r \u2032 2 yields r \u2032 3 which features a new, disjoint e-bubble. The two are distinguished by subscripts. Generally any row featuring the symbols 0, 1, 2 and possibly e-bubbles will be called8 an 012e-row. In order to impose C3 upon r \u2032 3 we first partition r\u20323 = r \u2032 4 ] r\u20325 as indicated. Notice that the 0 in r\u20325 forces the 1 on its left. Furthermore the 0 in r\u20325 turns the (e2, e2, e2) in r \u2032 3 to (e2, 0, e2), and the 1 in r \u2032 5 turns the (e1, e1, e1) in r \u2032 3 to (2, 2, 1). Similar remarks appy to r\u20324. The advantage of r \u2032 4, r \u2032 5 over r \u2032 3 is that r \u2032 4 satisfies C3 = {x3, x5} (whence PC = 4), and imposing C3 upon r \u2032 5 immediately yields r \u2032 6. Notice that r \u2032 6 happens to satisfy C4, and so has PC = 5. Imposing C4 upon r \u2032 4 yields r \u2032 7.\n8This renames the \u201c{0, 1, 2, e}-valued rows\u201d in previous publications. Of course each 012-row is a 012e-row but not conversely.\nNow things get interesting. In order to impose C5 = (x1, x4, x5} upon r\u20327 we first partition r\u20327 = r \u2032 8 ] r\u20329. Here r\u20328 must be deleted since it violates C6 = {x1, x2, x3}, whereas r\u20329 turns to r\u203210 upon imposing C5. Actually r \u2032 10 happens to be final (i.e. satisfies C6, C7 as well) and thus is removed from the working stack. Imposing C5 upon r \u2032 6 yields r \u2032 11 which again happens to be final. Pinning x4 in r \u2032 11 to 1 and 0 respectively shows that\n(9) r\u203211 = r \u2032 12 ] r\u203213 = (2, 2, 1, 0, 1, 0,1, 0, 1, 0) ] (1, 0, 2, 2, 1, 0,0, 1, 1, 0).\nThe by construction mutually disjoint rows r\u203210, r \u2032 12, r \u2032 13, when shrunk back to length 5, yield\n(10) Mod(\u03d52) = (0, 2, 0, 1, 1) ] (2, 1, 1, 1, 1) ] (1, 2, 1, 0, 1)\nComparing (7) and (10) we see that Mod(\u03d51) = Mod(\u03d52), and so the BDD in Figure 1 yields the same Boolean function as the CNF in(8).\nThe illustrated method will be dubbed the ALLSAT e-algorithm, which sounds better than ALLSAT 012e-algorithm. The adjective \u201cclause-wise\u201d is superfluous since the e-formalism does not apply to variable-wise branching. Subsections 6.1 and 6.2 are straightforward whereas 6.3 to 6.5 are more technical in nature.\n6.1 Speaking of 012e-rows is good and well, but occasionally alternative terminology is helpful, e.g. for comparison with some standard formats of Boolean functions. Generalizing ordinary terms like x1 \u2227 x2 \u2227 x3 we hence introduce fancy terms like\n(11) (x1 \u2228 x4) \u2227 (x2 \u2228 x4) \u2227 x3 \u2227 x5\nwhich by definition are (literal-wise) disjoint conjunctions of clauses of any length, except that complementary length 1 clauses xi and xi are forbidden. We shall see in 6.3 that each fancy term is satisfiable. The fancy term in (11) matches r\u203211 in Table 4. Further we call \u03c8 an exclusive sum of fancy terms (ESOFT) if \u03c8 = \u03c81 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c8m is such that\n(a) all \u03c8i\u2019s are fancy terms;\n(b) Mod(\u03c8i) \u2229Mod(\u03c8j) = \u2205 for all 1 \u2264 i < j \u2264 m.\nFor instance, using (11) the ESOFT corresponding to r\u203210 ] r\u203211 in Table 3 is\n(12) \u03d53 = \u03d531 \u2228 \u03d532 := (x1 \u2227 x3 \u2227 x4 \u2227 x5) \u2228 ((x1 \u2228 x4) \u2227 (x2 \u2228 x4) \u2227 x3 \u2227 x5).\nHere the meet of the disjuncts is zero. We claim that the law \u03d52 \u2261 \u03d53 holds in all Boolean algebras B. As is well known, it suffices to establish \u03d52 \u2261 \u03d53 in the 2-element Boolean algebra. This is true because of \u03d52(u) = 1 \u21d4 u \u2208 Mod(\u03d52) \u21d4 u \u2208 Mod(\u03d53) \u21d4 \u03d53(u) = 1, where the second \u21d4 holds since\nMod(\u03d52) = r \u2032 10 \u222a r\u203211 = Mod(\u03d531) \u222aMod(\u03d532) = Mod(\u03d53).\nFor instance if A1, \u00b7 \u00b7 \u00b7 , A5 \u2208 B = P[S] are any subsets of some set S then \u03d52 \u2261 \u03d53 translates, upon putting Ai := S \\Ai, to:\n(13) (A1 \u222aA2 \u222aA3) \u2229 (A2 \u222aA3 \u222aA4) \u2229 (A3 \u222aA5) \u2229 (A1 \u222aA3 \u222aA5) \u2229 (A1 \u222aA4 \u222aA5) \u2229 (A1 \u222aA2 \u222aA3) \u2229 (A2 \u222aA4 \u222aA5) = (A1 \u2229A3 \u2229A4 \u2229A5) ] ((A1 \u222aA4) \u2229 (A2 \u222aA4) \u2229A3 \u2229A5)\nFormula (13) and [SSK] may share some common ground but that needs further investigation.\n6.2 We saw that the ALLSAT e-algorithm turns each CNF into an ESOFT. Let us briefly relate ESOFT to ESOP, DNNF and BDD. First, ESOFT is a powerful generalization of ESOP (see also 6.5 and 7.2). Second, ESOFT is a special case of Decomposable Negation Normal Form (DNNF). That follows9 at once from the definition [D] of DNNF which postulates a disjointness property akin to the definition of \u201cfancy term\u201d in (a). In contrast ESOFT links to BDDs rather by the other disjointness property (b). Indeed, as seen in 4.1, BDDs induce a partition of Mod(\u03d5) into a disjoint union of 012-rows, which hence is a special type of ESOFT. A more thorough discussion of ESOFT versus BDD follows in Section 8.3.\n6.3 In order to show that each fancy term (viewed as 012e-row) is satisfiable, we introduce some notation. Given a 012e-row we call a complementary pair {xi, xi} bad if it is covered by distinct\n9Actually ESOFT implies DNNF even if we dropped (but we won\u2019t) the crucial property (b). Similar reasoning shows that DNF implies DNNF.\ne-bubbles; otherwise it is good. A 012e-row r\u2032 is purified if all complementary pairs are good. Such rows r\u2032 are nonempty since all e-bubbles can be put to 1 without conflict; indeed, e \u2192 1 merely forces 2\u2192 0 for some 2 elsewhere. In order to show that each 012e-row r contains some purified row r\u2032 and whence is satisfiable, it suffices by induction to show that r contains a row r\u2032 with one less bad pair {xi, xi}. Therefore, say e1e1 \u00b7 \u00b7 \u00b7 , e1 (its first e1) covers xi and e2e2 \u00b7 \u00b7 \u00b7 e2 (its first e2) covers xi. Then r\n\u2032 arises from r by substituting 12 \u00b7 \u00b7 \u00b7 2 for e1e1 \u00b7 \u00b7 \u00b7 e1 and 0e2 \u00b7 \u00b7 \u00b7 e2 for e2e2 \u00b7 \u00b7 \u00b7 e2. The case that e2e2 is of length two however requires special attention.\nThen 0e2 \u00b7 \u00b7 \u00b7 e2 boils down to 01. Suppose this 1 occupies xj and there is a bubble e3e3 that covers xj . Then e2e2 = 01 forces e3e3 = 01, and this pattern may further repeat. However, the number of length two bubbles being finite, one eventually reaches a state where the produced 0 falls upon a 2, or upon a bubble etet \u00b7 \u00b7 \u00b7 et of length \u2265 3, which then becomes 0et \u00b7 \u00b7 \u00b7 et. A concrete example of a 012e-row r which contains10 the purified row r\u2032\u2032 \u2286 r\u2032 \u2286 r is shown in Table 4.\n6.3.1 For any purified 012e-valued row \u03c1 it\u2019s easy to calculate |Mod(\u03c1)|. If say\nthen |Mod(\u03c1)| = (22 \u2212 1) \u00b7 (24 \u2212 1) \u00b7 22. Indeed, for all 24 \u2212 1 legal (i.e. 6= (0, 0, 0, 0)) choices of (e2, e2, e2, e2) the coupled 2\u2019s adapt accordingly. Thus if (e2, e2, e2, e2) = (x5, x6, x7, x8) = (0, 1, 1, 0) then (x5, x6, x7, x8) = (1, 0, 0, 1). The 2\u2019s at x3 and x4 are free (only coupled to x3, x4) and thus can be chosen in 22 many ways. Generally, if \u03c1 is a purified 012e-row with e-bubbles of length \u03b51, \u00b7 \u00b7 \u00b7 , \u03b5s and t many free 2\u2019s then\n(14) |\u03c1| = (2\u03b51 \u2212 1)(2\u03b52 \u2212 1) \u00b7 \u00b7 \u00b7 (2\u03b5s \u2212 1) \u00b7 2t\n6.3.2 In order for formula (14) to be useful we need to show how any 012e-row \u03c1 can be written as a disjoint union of purified rows. An example will do. For \u03c1 as in Table 6 we pick all t bad pairs, here {x1, x1}, {x2, x2}, and consider all 2t = 4 {0, 1}-instantiations \u03c11, \u00b7 \u00b7 \u00b7 , \u03c14 of \u03c1. Obviously \u03c1 = \u03c11 ] \u03c12 ] \u03c13 ] \u03c14, but some \u03c1i (despite appearances) may be empty since an e-bubble falls into zeros(\u03c1i); in our case \u03c12 = \u2205 since e2e2 falls into zeros(\u03c12).\n10The boldface entries 10 indicate \u201cactively diffused\u201d bad pairs (going from left to right), whereas the other 0 and 1 in r\u2032\u2032 are consquences thereof.\nAs proven previously at least one of the 2t many instantiation of \u03c1 will yield a nonempty purified 012e-row \u03c1j . Getting these \u03c1j \u2019s can be achieved in smarter ways than listing 2\nt rows and discarding the bad ones. But we won\u2019t dwell on this here.\n6.4 The technicalities of the ALLSAT e-algorithm simplify if the CNF for \u03d5 features only positive literals. To start with, all arising 012e-rows are purified since all components indexed by negative literals carry don\u2019t-care 2\u2019s. In fact, we may consider in the first place short 012e-rows labelled only by the positive literals x1 to xw. The satisfiability test becomes straightforward in this scenario: Such a 012e-row r is feasible with respect to a CNF \u03d5 with clauses C1, C2, \u00b7 \u00b7 \u00b7 , Ch if Ci 6\u2286 zeros(r) for all 1 \u2264 i \u2264 h. Indeed, if this condition holds, let u be the length w bitstring defined by zeros(u) := zeros(r) and ones(u) := [w] \\ zeros(r). Then u \u2208 r and \u03d5(u) = 1. Thus the weak feasibility Test 1 from Section 3 becomes a perfect feasibility test when restricted to positive Boolean functions.\n6.4.1 As is well known, models of a positive Boolean function \u03d5 and transversals of a hypergraph are \u201cthe same thing\u201d. That\u2019s why the trimming of the ALLSAT e-algorithm in the case of positive Boolean functions was called transversal e-algorithm in [W5]. It is shown in detail in [W5, Sec.2] how the Flag of Papua (see Table 1) is lifted from the 012-level to the 012e-level in the transversal e-algorithm. The author is confident that the Flag of Papua further carries over to the ALLSAT e-algorithm but this has not yet been implemented into Mathematica. We expand further on the past and future of the ALLSAT e-alogithm in Section 8.\n6.4.2 We note in passing that for positive Boolean function the following compression advantage of ESOFT against ESOP can be proven. There are 3n many 012-rows of length n, but Be``(n+ 2)\u2212 Be``(n+ 1) many 012e-rows [W5]. Here the Be`` number Be``(n) gives the number of set partitions of [n]. For instance 310 = 59049 whereas Be``(12)\u2212 Be``(10) = 4097622.\n6.5 For later purpose consider the task to represent the intersection of two 012e-rows r and \u03c1. For simplicity we stick to the case of positive Boolean functions but the arguments readily carry over. One option is to take the row with the fewer and shorter e-bubbles, say it is \u03c1 with e-bubbles of lengths \u03b51, \u00b7 \u00b7 \u00b7 , \u03b5s, and to expand it into N := \u03b51, \u03b52 \u00b7 \u00b7 \u00b7 \u03b5s many 012-rows \u03c1i by \u201cmultiplying out\u201d s many Flags of Papua. It then follows that\nr \u2229 \u03c1 = (r \u2229 \u03c11) ] (r \u2229 \u03c12) ] \u00b7 \u00b7 \u00b7 ] (r \u2229 \u03c1N )\nwhere each r\u2229\u03c1i is either empty (when 0\u2019s clash wih 1\u2019s) or can readily be written as a 012e-row (akin to the intersection of two 012-rows in the proof of Corollary 1). The crucial words above are \u201cfewer and shorter\u201d. Thus if \u03c1 has e-bubbles of lengths \u03b51 = \u03b52 = \u00b7 \u00b7 \u00b7 = \u03b56 = 10 then it induces N = 106 many 012-rows \u03c1i! In such a case one is better off picking the row with the fewer e-bubbles, say again \u03c1, and impose them on the other row by virtue of the transversal\ne-algorithm. For illustration see Table 7 where the five 012e-rows below r have a disjoint union that equals r \u2229 \u03c1. In particular |r \u2229 \u03c1| = 63 + 12 + 6 + 42 + 18 = 141. If only the cardinality of r \u2229 \u03c1 is required (as in 8.3.4) one may be better off using inclusion-exclusion. Namely, consider the property p1 of a bitstring u \u2208 r to satisfy eeee (thus |ones(u) \u2229 {1, 2, 3, 4}| \u2265 1). Similarly p2 holds if e e e e is satisfied. If say N(p1) is defined as the number of u \u2208 r not satisfying p1 we get\n|r \u2229 \u03c1| = |r| \u2212N(p1)\u2212N(p2) +N(p1p2)\n= 3 \u00b7 7 \u00b7 7\u2212 |(0, 0, 0, 0, e1, e1, 1, 1)| \u2212 |(1, 1, e3e3, 0, 0, 0, 0)|+ 0\n= 147\u2212 3\u2212 3 + 0 = 141\nwhich matches the number obtained above."}, {"heading": "7 Numerical experiments", "text": "In brief, 7.1 compares the variable-wise ALLSAT 012-algorithm of Section 2 with the clause-wise ALLSAT 012-algorithm of Section 5. In 7.2 the clause-wise ALLSAT 012-algorithm is pitted against the (clause-wise) ALLSAT e-algorithm on positive Boolean functions. In 7.3 the clausewise ALLSAT 012-algorithm is pitted against BDD\u2019s. Finally 7.4 adds weight functions to the picture.\n7.1 We pitted the variable-wise ALLSAT 012-algorithm against the clause-wise ALLSAT 012- algorithm on Boolean functions \u03d5 : {0, 1}w \u2192 {0, 1} with h random clauses, each of cardinality \u03bb (for simplicity). For each triplet (w, h, \u03bb) we only11 produced few \u03d5\u2019s. For \u03d5 we record |Mod(\u03d5)| and the times in sec (unless stated otherwise) it took to enumerate Mod(\u03d5) (with disjoint 012- rows) using the variable-wise, respectively clause-wise ALLSAT 012-algorithm. Furthermore, for both algorithm |twos(r)| gives the average number of 2\u2019s per row. Thus the higher \u03b3 = |twos(r)| the better the compression. Finally for both algorithms we record prob = prob(w, \u03b3, h, \u03bb) as defined in Section 3.1. Hence prob is the probability that a random 012-row r (independent of any algorithm) with parameters (w, \u03b3, h, \u03bb) also happens to satisfy r \u2286 Mod(\u03d5). We wrote \u2248 0 for probabilities < 10\u22126. The (25, 50, 10) and (100, 5, 30) and (500, 3300, 4) instances show\n11It turns out that random \u03d5\u2019s sharing the same parameters (w, h, k) behave very much alike.\nthat variable-wise badly trails behind clause-wise when |Mod(\u03d5)| is large. Here \u201c68/sec\u201d means that during the first hour in the average 68 models were produced per second. When |Mod(\u03d5)| is small then both algorithms finish in reasonable time due to the fact that the number R of 012-rows produced is \u2264 |Mod(\u03d5)|. As h gets very large the variable-wise approach slightly wins out as seen in the (25, 50000, 12) instance. As to the expression \u201creasonable time\u201d, this should be seen in relation to the Mathematica-command SatisfiabilityCount which is based on BDD\u2019s and which e.g. in the (100, 900, 4) instance was aborted after one hour.\n7.2 When comparing the (cut short) Table 2 with Table 3 it becomes plausible that introducing the e-symbol can speed up things further. While the clause-wise ALLSAT 012-algorithm has been programmed with MATHEMATICA, recall from 6.4 that this is pending for the ALLSAT e-algorithm. However, the two algorithms can be compared for the special case of positive Boolean functions. Specifically, as pointed out in 6.4, the ALLSAT e-algorithm, fed with a positive Boolean function \u03d5, behaves exactly as the transversal e-algorithm when fed with \u03d5.\nLet us hence compare the (clause-wise) transversal e-algorithm with the (clause-wise) transversal 012-algorithm. Without further mention, all \u03d5\u2019s in 7.2 are positive. For starters, when \u03d5 is given by h mutually disjoint clauses of lengths \u03b51, . . . , \u03b5h the difference in compression is dramatic: While just one 012e-row suffices to represent Mod(\u03d5), it takes \u03b51\u03b52 \u00b7 \u00b7 \u00b7 \u03b5h many 012-rows to achieve the same thing. Also for \u03d5(x1, \u00b7 \u00b7 \u00b7 , xw) with h random clauses, each of length k (for simplicity), the numerical evidence in favor of the transversal e-algorithm is compelling, as shown in Table 9. Here Te and T012 are the times in seconds needed by the transversal e-, respectively 012-algorithm. Similarly Re and R012 are the respective numbers of final 012e-rows and 012-rows.\n(w, h, k) |Mod(\u03d5)| Re Te R012 T012 200 10 150 \u2248 2200 802 0.2 8\u00d7 105 61 60, 40, 30 \u2248 1018 134392 56 9\u00d7 106 563 60, 25, 7 \u2248 1018 841531 292 6\u00d7 109 106 20 10 4 650 024 37 0.03 218 0.05\n20 50 4 243 632 2036 1.4 11 669 1.8 20 100 4 129 206 4961 5.7 15909 3.8 20 3000 4 4717 2365 132 3220 18\n20 3000 15 1039831 3972 177 16879 6.3 40 50000 4 107957 - - 87833 10662\nTable 9: Transversal e-algorithm against transversal 012-algorithm (for positive functions)\nFor the (200, 10, 150), the (60, 40, 30) and the (60, 25, 7) instances one has Re R012 and whence Te T012. In fact for (60, 25, 7) the ALLSAT 012-algorithm was stopped after 21 hours and the values of T012 and R012 are only extrapolated. Letting h = 10, 50, 100, 3000 in the (20, h, 4) instances one still has Re < R012 but these gaps get proportionally smaller and are eventually time-wise more than compensated by the simpler row-splitting mechanism on the 012-level. Even more so in the (20, 3000, 15) and (40, 50000, 4) instances.\n7.2.1 If condition (2a) is not maintained by the row-splitting algorithm then some of the rows r in the working stack will be infeasible, and they may trigger infeasible sons. However, eventually infeasibility will be detected. To fix ideas, if say the clause x2 \u2228 x4 \u2228 x7 is to be imposed on the top row r, and {2, 4, 7} \u2286 zeros(r), then r is detected as infeasible and must be deleted. Such a deletion we call harmful (as opposed to the deletion of a feasible row when it is replaced by its sons). Recall that Test 1 in Section 3 becomes a perfect feasiblity test for positive Boolean functions. However, the extra time to run the test (and hence avoid harmful deletions of rows) doesn\u2019t always pay off. In the instances above it only paid off for h \u2265 3000. Thus if we don\u2019t use Test 1 for the (20, 3000, 4) instance then the transversal e-algorithm suffers 11384 harmful row deletions and the time jumps from 132 to 243 seconds. For h < 3000 we were better off with accepting harmful deletions.\n7.2.2 One may think that for small values w checking all u \u2208 {0, 1}w individually may be faster than imposing a large number h of constraints. Thus we implemented this \u201cnaive way\u201d to scan12 the modest size powerset {0, 1}20 and found that the (20, 3000, 15)-instance in Table 9 took a hefty 12830 sec. The problem is that a small powerset doesn\u2019t help because, in view of k = 15, most u \u2208 {0, 1}20 pass all 3000 intersection tests (ones[u] \u2229 clause[i] ?=\u2205). We hence also ran the (20, 3000, 4)-instance in the naive way. Indeed the time boiled down to 344 sec since most u \u2208 {0, 1}20 dropped out after few intersection tests. The joy is short: Increasing w to 40 (as in the (40, 50000, 4)-instance) puts a mere scanning of {0, 1}40 (without extra fuzz) out of question.\n7.3 Now we pit the clause-wise ALLSAT 012-algorithm against the MATHEMATICA command SatisfiabilityCount[\u03d5]. The latter works by constructing the BDD of \u03d5, which then yields |Mod(\u03d5)| at once (see 4.2). Hence timing SatisfiabilityCount in effect means timing the construction of a BDD. Unfortunately this is only half the task we wish to time. Since the underlying BDD seems to be inaccessible to the user, we cannot13 assess getting an ESOP from the BDD, neither time-wise nor compression-wise. This constitutes on \u201cunfair advantage\u201d in the timing of SatisfiabilityCount. The other advantage is the fact that it is a \u201chardwired\u201d MATHEMATICA command whereas the clausewise ALLSAT 012-algorithm is written in high-level MATHEMATICA code. As a perfect feasibility test we use the hardwired MATHEMATICA command SatisfiabilityInstances. It is based on a search tree (not DPLL) and either offers a model for any Boolean function \u03d5 or it returns the empty set, in which case \u03d5 is provably unsatisfiable. Different from 7.1 the groundset induced by our Boolean functions \u03d5(x1, \u00b7 \u00b7 \u00b7 , xw), which are conjunctions of h random clauses of cardinality k, is now {x1, x1, \u00b7 \u00b7 \u00b7 , xw, xw}.\nIn Table 10 on the left TSC is the time for SatisfiabilityCount, T012 the time for the clausewise ALLSAT 012-algorithm, and R012 the number of final 012-rows it produces. If we compare the (60, 10, k) instances for k \u2208 {3, 7}, SatisfiabilityCount is way ahead (keeping in mind\n12This is easily established with the Mathematica command Subsets[\u00b7 \u00b7 \u00b7]. 13Mending this state of affairs is a major task of a planned follow-up paper.\nits unfair advantage). The time T012 is essentially proportional to the number R012 of final rows, which in turn depends on how often the \u201cFlag of Papua gets raised\u201d. If we push h = 10 to 50 then TSC = 78 sec, and for h = 80 we stopped SatisfiabilityCount after 50 fruitless hours. Admittedly, also T012 and R012 are astronomic for h = 50, 80, \u00b7 \u00b7 \u00b7 but, different from SatisfiabilityCount, not forever! Namely, if say h = 4600 then this sheer number of clauses allows only for 143 models which the ALLSAT 012-algorithm found in 6191 seconds. Observe that SatisfiabilityInstances took 83 sec to find just one model, while the ALLSAT 012-algorithm required 6191/143 \u2248 43sec per model on average, despite the fact that SatisfiabilityInstances is an essential ingredient of it.\n7.3.1 A few words about the weak feasibility tests in Section 3 are in order. While Test 1 becomes a perfect feasibility test for positive Boolean functions, it performs poorly for arbitrary Boolean functions. Interestingly the conjunction (Test 1 + Test 2) yields a decent weak feasibility test, i.e. with few harmful deletions of intermediate 012-rows. Time-wise however (Test 1 + Test 2) couldn\u2019t compete with SatisfiabilityInstances. Thus the former needed 4755 sec to find the two models of some (50, 490, 4) instance and suffered 431059 harmful deletions, while the latter did the job in 0.5 sec. Whether this state of affairs changes when other weak feasibility tests are added, or when the hardwire-advantage of SatisfiabilityInstances is taken into account, remains to be seen. As to SatsifiabilityCount, we aborted it after 16 hours.\n7.4 Consider now weight functions f : {0, 1}2w \u2192 Z+ induced by random functions [2w]\u2192 [20]. While the whole BDD needs to be available in order to sieve all models of small weight (say \u2264 b), this is not the case for the clause-wise ALLSAT 012-algorithm. Namely, along with the perfect feasibility test applied to an intermediate row r one can check fast whether r contains any bitstrings (thus possibly models) of weight \u2264 b. If no, then r is deleted. Of course this idea beats first producing all models and then throwing most of them away (which essentially the BDD approach is doomed to do). For each instance (w, h, k) binary search quickly14 yields values b0 \u2208 Z+ which are large enough to trigger a nonempty set Mod(\u03d5, f, b0) of models of weight \u2264 b0, yet small enough to keep |Mod(\u03d5, f, b0)| at bay.\nIn this light of weight functions let us return to the (60, 50, 7) instance where TSC is a hefty 78 sec and both T021 and R012 are astronomic. Here the time to enumerate only all models of weight \u2264 b0 was a mere T \u2032012 = 0.4 sec (see Table 10 on the right). For this particular b0 there where exactly R\u2032012 = 8 final 012-rows which contained at least one small weight model. In the process del = 228 times an intermediate 012-row r was deleted because all u \u2208 r had weight > b0. For h = 80 all of TSC , T012, R012 are astronomic yet for suitable small b0 one gets T \u2032012 = 0.2 and R \u2032 012 = 4. Raising b0 a bit yields T \u2032 012 = 81 and R \u2032 012 = 4446. When R012 is small already, as in the (60, 4600, 7) instance, then T \u2032012 can\u2019t be pushed much below T012.\n(w, h, k) |Mod(\u03d5)| TSC T012 R012 T \u2032012 R\u2032012 del 60 10 3 \u2248 3\u00d7 1017 0 7 6318 0.1 10 63 60 10 7 \u2248 1018 0 69 71470 0.7 52 313 60 50 7 \u2248 8\u00d7 1017 78 - - 0.4 8 228 60 80 7 \u2248 6\u00d7 1017 - - - 0.2 4 156 60 80 7 \u2248 6\u00d7 1017 - - - 81 4446 32953 60 4600 7 143 - 6191 139 6154 2 122\n14We didn\u2019t time this preprocessing part.\nTable 10: SatisfiabilityCount (= BDD) against the clause-wise ALLSAT 012-algorithm"}, {"heading": "8 History and envisaged future", "text": "History and intended future of the ALLSAT e-algorithm will be addressed in 8.1 to 8.3. In particular, Subsection 8.3 dwells on BDD\u2019s and draws part of its optimism from the computer experiments in Section 7. Subsection 8.4 is still about history and future but zooms away from the ALLSAT e-algorithm to specific types of ALLSAT problems susceptible to wildcards.\n8.1 In 2005 I gave a talk about the transversal e-algorithm [W5]. This inspired Gideon Redelinghuys and Jaco Geldenhuys [RG] to carry over the e-framework from positive to arbitrary Boolean CNF\u2019s, in order to determine their satisfiability; they called their method SATEalgorithm. In the last 10 years I didn\u2019t persue that road but turned to clause-wise15 branching in more specific scenarios as mentioned in 8.4. These experiences led to the conviction that clause-wise branching should not be abused to challenge taylor-made satisfiability tests. Rather the purpose of clause-wise branching should be ALLSAT. The reason is two-fold. First, as opposed to variable-wise branching a node in the clause-wise search tree can have more than two sons, which in itself makes branching more efficient. Second (Section 5), once all clauses are imposed on a multivalued row, it is automatically final and may pack a great many models. Here multivalued means that apart from 0,1 one has the don\u2019t-care symbol 2 and possibly further wildcards such as (e, e, \u00b7 \u00b7 \u00b7 , e) and others that proved to be useful.\n8.2 I recently returned to the SATE algorithm and now regard the extension of the e-symbolism from {x1, \u00b7 \u00b7 \u00b7 , xw} to {x1, x1, \u00b7 \u00b7 \u00b7 , xw, xw} as its crucial idea. However, the attempt to challenge Chaff, one of the leading SAT-solvers [MMZZM], is misguided as argued in 8.1. Not knowing any technical details16 of the C implementation of the SATE algorithm in [RG], I went back to the drawing board. After some deliberation I settled for the 012-level, thus programming the clausewise ALLSAT 012-algorithm in high-level Mathematica code. The comparison of the transversal 012-algorithm with the transversal e-algorithm in 7.2, as well as the comparison of Tables 2 and 3, strongly indicate that the ALLSAT e-algorithm, once programmed17, will exhibit a further leap in compression. Predictably ALLSAT-algorithms that output their models one-by-one will trail when the number of models gets large.\n8.3 Probably the main competitor of the ALLSAT e-algorithm is the BDD framework since, as seen in Section 4, a BDD for \u03d5 allows an enumeration of Mod(\u03d5) by 012-rows (ESOP). But there are several issues that need to be investigated; in 8.3 we only glimpse at them.\n8.3.1 For starters, there is the conversion time from CNF to BDD. Then there is the often denied fact that the average size of the BDD of a Boolean function \u03d5(x1, \u00b7 \u00b7 \u00b7 , xn) is about 2n/n, thus a hefty 1n times the length of the full truth table of \u03d5. True, changing the variable order 18\n15Perhaps \u201cconstraint-wise\u201d would be a better word since some of the constraints (as in [W1]) cannot be recast as clauses of a Boolean CNF. However \u201cconstraint-wise\u201d evokes unwanted proximity to Constraint Programming. The precise relation between the two remains to be unravelled.\n16Whatever they are, a glimpse at [RG] shows that e.g. the issue of purified rows has been glossed over. 17I leave that noble task to others. It would be nice if Chaff was used as satisfiability subroutine. If coded in Mathematica, SatisfiabilityInstances is a decent substitute. 18The order in which one feeds the clauses to the ALLSAT e-algorithm similarly influences the size of the resulting ESOFT but this has not been researched yet.\noften shrinks the BDD, but that costs time. On an aesthetic level, the construction algorithms for BDD\u2019s are rather awkward. In contrast the ALLSAT e-algorithm is easier to understand. But then again this assessment may be due to the author\u2019s misconception that nobody has yet topped Knuth\u2019s lovely (though not on the discussed issue) introduction [K] to BDD\u2019s.\n8.3.2 Assume we have (in whatever way obtained) a BDD and also an ESOFT of some Boolean function \u03d5. Using the BDD calculating |Mod(\u03d5)| is fast, and enumerating Mod(\u03d5) is straightforward. Straightforward it may be, but if the index gaps (4.1) are small, many 012-rows may be bitstrings. Concerning the ESOFT, after \u201cpurification\u201d as in 6.3.2, we have a representation of Mod(\u03d5) as disjoint union of purified 012e-rows, which have more compression potential than 012-rows (see 6.4.1).\n8.3.3 What about fixed cardinality models? Calculating |Mod(\u03d5, k)| from a purified ESOFT of \u03d5 is readily reduced to calculating the coefficient at xk of some associated polynomial p(x), exactly as in [W5. p.124]. Enumerating Mod(\u03d5, k) from a purified ESOFT can be done with wildcards in a manner similar to [W11]. As to BDDs, calculating |Mod(\u03d5, k)| from a BDD of \u03d5 is little known: A nice method of Knuth [K, Exercise 25] is reviewed (with slightly trimmed notation) in [W10]. The enumeration of Mod(\u03d5, k) from a BDD of \u03d5, as handled in [W10], seems to be new. As opposed to ESOFT it can actually be done in output-polynomial time (and again with wildcards). Output-polynomial or not, how ESOFT compares to BDD in practise remains to be seen.\n8.3.4 One major benefit of BDDs is equivalence testing: Given Boolean formulas \u03d5 and \u03c8 it holds that \u03d5\u2194 \u03c8 if and only if the corresponding BDD\u2019s are isomorphic. This fails for ESOFT since \u03d5 has many different ESOFTs. However things aren\u2019t too bad. If \u03d5 and \u03c8 are in purified ESOFT format then N(\u03d5) := |Mod(\u03d5)| and N(\u03c8) := |Mod(\u03c8)| are readily computed, and if N(\u03d5) 6= N(\u03c8) then \u03d5 6\u2194 \u03c8. Conversely, if N(\u03d5) = N(\u03c8) then chances are high that \u03d5 \u2194 \u03c8. Even more so if |Mod(\u03d5, k)| = |Mod(\u03c8, k)| for all k (see 8.3.3).\nIn order to sketch a waterproof equivalence test, let Mod(\u03d5) and Mod(\u03c8) be given as purified ESOFTs, say r1 ] \u00b7 \u00b7 \u00b7 ] rs and r\u20321 ] \u00b7 \u00b7 \u00b7 ] r\u2032t respectively. Suppose we checked that N(\u03d5) = N(\u03c8) and we managed to prove for all 1 \u2264 i \u2264 s that\n(15) Card(ri) = t\u2211 j=1 Card(ri \u2229 r\u2032j).\nThen (15) implies that all ri \u2286 r\u20321 ] \u00b7 \u00b7 \u00b7 ] r\u2032t, whence r1 ] \u00b7 \u00b7 \u00b7 ] rs \u2286 r\u20321 ] \u00b7 \u00b7 \u00b7 ] r\u2032t, whence Mod(\u03d5) = Mod(\u03c8) in view of N(\u03d5) = N(\u03c8). Conversely, if (15) fails for some i \u2208 [s] then Mod(\u03d5) 6= Mod(\u03c8). As to calculating Card(ri \u2229 r\u2032j), we mention that the inclusion-exclusion method of 6.5 can be sped up (work in progress). Even so, the ensuing equivalence test is wanting when compared to the one provided by a BDD.\nThis suggests a hybrid method for checking whether \u03d5 \u2194 \u03c8 : If N(\u03d5) 6= N(\u03c8) (as swiftly calculated with the ALLSAT e-algorithm), then \u03d5 6\u2194 \u03c8. Otherwise invest calculating BDD\u2019s of \u03d5 and \u03c8 to settle the question. Of course, if the likelihood for \u03d5\u2194 \u03c8 somehow is high beforehand then use BDD\u2019s right away.\n8.4 In the last ten years the author found compressed representations of specific types of set\nsystems by employing the don\u2019t-care \u201c2\u201d and various wildcards apart from ee \u00b7 \u00b7 \u00b7 e. Let us briefly take stock. Article [W2] enumerates the model set of a Horn formula \u03d5 as a disjoint union of 012n-rows. Here the wildcard nn \u00b7 \u00b7 \u00b7n means (dually to ee \u00b7 \u00b7 \u00b7 e) \u201cat least one 0 here\u201d. The method of [W2] can be fine-tuned for three special types of Horn formula. First, the noncover n-algorithm applies to negative Boolean functions and was successfullly applied to stack filters, i.e. tools used in nonlinear digital filtering [W3]. Second, pure Horn functions, aka known as implications A \u2192 B, enjoy many applications in Data Mining and elsewhere [W7], [W8]. Third, particularly pleasant implications are the ones with singleton premises A = {a}. The corresponding (a, b)-algorithm calculates all order ideals of a poset in a compressed fashion [W4]. Note that both for stack filters and for Coupon Collecting [W6] it is essential not merely to calcluate |Mod(\u03d5)| but also |Mod(\u03d5, k)| for all k \u2208 [w]. Article [W1] was the wildcard pioneer. While wildcards are used during the algorithms, all final rows are bitstrings. This is not due to deficient programming but forced by the inherent structure of the models (= cycles). Hence \u201ctraditional\u201d one-by-one algorithms become competitive, and actually have proven superior for chordless cycles. With hindsight it is clear that the employed wildcards could be used more efficiently if the target was optimization of models rather than their exhaustive enumeration. The compression of Mod(\u03d5) for 2-CNF\u2019s [W9] is a bit of an outsider in that it is achieved using variable-wise branching and nothing fancier than don\u2019t-care 2\u2019s. The fact that all mentioned Mod(\u03d5) can be compressed in output-polynomial time is due to the fact that the corresponding formulas \u03d5 allow for a polynomial-time satisfiability test.\n8.4.1 The present article is conceived as a hinge between past and future. We just reviewed the past, and Theorem 1 is intended to be a hat for several future results. What is more, their inner and (more so) interdependent structure presumably will be, with the benefit of hindsight, a bit better organised than for [W1] to [W6]. Specifically the present article is Part 1 in a planned series \u201cALLSAT compressed with wildcards\u201d. Part 1 tackled arbitrary Boolean functions, mainly CNF\u2019s. In contrast, for DNF\u2019s enumeration is easy (even cardinality-wise, Corollary 4) but making DNF\u2019s orthogonal is hard. Solving19 this problem with a small number t of multivalued rows would have quite a few applications, e.g. in view of Corollary 1. The author\u2019s ideas in this regard must stand back in favor of more thought-through topics appearing earlier in the planned mini-series. These topics concern set systems F whose matching Boolean functions \u03d5 (i.e. F = Mod(\u03d5)) have, as in the past, polynomial-time satisfiability tests. Promising types of F include: All faces of a simplicial complex (given by its facets or otherwise); all shellings of a simplicial complex; all subgraphs of a graph (of various types such as all anticliques); all k-models of a BDD, all closed sets of a convex geometry."}], "references": [{"title": "Proc", "author": ["A. Darwiche", "New advances in compiling CNF to decomposable negation normal form"], "venue": "of the European Conference on Artificial Intelligence", "citeRegEx": "D", "shortCiteRegEx": null, "year": 2004}, {"title": "Parametrized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Springer", "citeRegEx": "FG", "shortCiteRegEx": null, "year": 2006}, {"title": "the Art of Computer Programming", "author": ["D. Knuth"], "venue": "Volume 4 (Preprint), Section 7.14: Binary decision diagrams, Addison-Wesley", "citeRegEx": "K", "shortCiteRegEx": null, "year": 2008}, {"title": "Analysis and enumeration. Algorithms for biological graphs", "author": ["A. Marino"], "venue": "This pricewinning Thesis appeared als Vol.6 of Atlantis Studies in Computing", "citeRegEx": "Marino,? \\Q2015\\E", "shortCiteRegEx": "Marino", "year": 2015}, {"title": "Chaff: Engineering an efficient SAT Solver, 39th Design Automaton", "author": ["M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": null, "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Art. Intelligence", "citeRegEx": "Roth,? \\Q1996\\E", "shortCiteRegEx": "Roth", "year": 1996}, {"title": "A new and complete refinement-based approach to Boolean satisfiability", "author": ["G. Redelinghuys", "J. Geldenhuys"], "venue": "unpublished manuscript", "citeRegEx": "RG", "shortCiteRegEx": null, "year": 2005}, {"title": "Sets with cardinality constraints in satisfiability modulo theories", "author": ["SSK] P. Suter", "R. Steiger", "V. Kuncak"], "venue": "LNCS 6538,", "citeRegEx": "Suter et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Suter et al\\.", "year": 2011}, {"title": "The complexity of enumeration and reliability problems", "author": ["L.G. Valiant"], "venue": "SIAM J. Comput", "citeRegEx": "Valiant,? \\Q1979\\E", "shortCiteRegEx": "Valiant", "year": 1979}, {"title": "Exact algorithms for finding minimum transversals in rank 3 hypergraphs", "author": ["M. Wahlstr\u00f6m"], "venue": "Journal of Algorithms", "citeRegEx": "Wahlstr\u00f6m,? \\Q2004\\E", "shortCiteRegEx": "Wahlstr\u00f6m", "year": 2004}, {"title": "Enumeration of Enumeration Algorithms", "author": ["K. Wasa"], "venue": "arXiv: 1605.05102vl", "citeRegEx": "Was", "shortCiteRegEx": null, "year": 2016}, {"title": "Generating all cycles, chordless cycles and Hamiltonian cycles with the principle of exclusion", "author": ["M. Wild"], "venue": "J. Discrete Algorithms", "citeRegEx": "Wild,? \\Q2008\\E", "shortCiteRegEx": "Wild", "year": 2008}, {"title": "Compactly generating all satisfying truth assignments of a Horn formula", "author": ["M. Wild"], "venue": "J. Satisf. Boolean Model. Comput", "citeRegEx": "Wild,? \\Q2012\\E", "shortCiteRegEx": "Wild", "year": 2012}, {"title": "Computing the output distribution and selection probabilities of a stack filter from the DNF of its positive Boolean function", "author": ["M. Wild"], "venue": "J. Math. Imaging Vision", "citeRegEx": "Wild,? \\Q2013\\E", "shortCiteRegEx": "Wild", "year": 2013}, {"title": "Output-polynomial enumeration of all fixed-cardinality ideals of a poset, respectively all fixed-cardinality subtrees of a tree. Order", "author": ["M. Wild"], "venue": null, "citeRegEx": "Wild,? \\Q2014\\E", "shortCiteRegEx": "Wild", "year": 2014}, {"title": "Counting or producing all fixed cardinality transversals", "author": ["M. Wild"], "venue": "Algorithmica", "citeRegEx": "Wild,? \\Q2014\\E", "shortCiteRegEx": "Wild", "year": 2014}, {"title": "Coupon collecting and transversals of hypergraphs", "author": ["M. Wild", "S. Janson", "S. Wagner", "D. Laurie"], "venue": "Discrete Math. Theor. Comput. Sci", "citeRegEx": "Wild et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Wild et al\\.", "year": 2013}], "referenceMentions": [{"referenceID": 10, "context": "In the last fifty years a variety of such \u201cenumeration problems\u201d have been considered [Was].", "startOffset": 86, "endOffset": 91}, {"referenceID": 0, "context": "Some immediate relations among ESOP, ESOFT, CNF, DNNF (see [D]) and BDD are discussed in 6.", "startOffset": 59, "endOffset": 62}, {"referenceID": 6, "context": "acknowledge the r\u00f4le of Redelinghuys and Geldenhuys [RG].", "startOffset": 52, "endOffset": 56}, {"referenceID": 1, "context": "7 in [FG]: All R many k-hitting sets of a rank 3 hypergraph H can be enumerated in time O(3k \u00b7 k \u00b7 ||H||) where ||H|| := w + \u03a3{|X| : X \u2208 H}.", "startOffset": 5, "endOffset": 9}, {"referenceID": 2, "context": "provided by [K].", "startOffset": 12, "endOffset": 15}, {"referenceID": 0, "context": "That follows9 at once from the definition [D] of DNNF which postulates a disjointness property akin to the definition of \u201cfancy term\u201d in (a).", "startOffset": 42, "endOffset": 45}, {"referenceID": 6, "context": "This inspired Gideon Redelinghuys and Jaco Geldenhuys [RG] to carry over the e-framework from positive to arbitrary Boolean CNF\u2019s, in order to determine their satisfiability; they called their method SATEalgorithm.", "startOffset": 54, "endOffset": 58}, {"referenceID": 6, "context": "Not knowing any technical details16 of the C implementation of the SATE algorithm in [RG], I went back to the drawing board.", "startOffset": 85, "endOffset": 89}, {"referenceID": 6, "context": "Whatever they are, a glimpse at [RG] shows that e.", "startOffset": 32, "endOffset": 36}, {"referenceID": 2, "context": "But then again this assessment may be due to the author\u2019s misconception that nobody has yet topped Knuth\u2019s lovely (though not on the discussed issue) introduction [K] to BDD\u2019s.", "startOffset": 163, "endOffset": 166}], "year": 2016, "abstractText": "For most branching algorithms in Boolean logic \u201cbranching\u201d means \u201cvariable-wise branching\u201d. We present the apparently novel technique of clause-wise branching, which is used to solve the ALLSAT problem for arbitrary Boolean functions in CNF format. Specifically, it converts a CNF into an orthogonal DNF, i.e. into an exclusive sum of products. Our method is enhanced by two ingredients: The use of a good SAT-solver and wildcards beyond the common don\u2019t-care symbol.", "creator": "LaTeX with hyperref package"}}}