{"id": "1609.05367", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Sep-2016", "title": "Solving the Wastewater Treatment Plant Problem with SMT", "abstract": "in this paper we introduce the wastewater treatment plant problem, a single - world scheduling problem, and compare the performance of several tools on it. we show that, for a naive modeling, state - of - the - art smt solvers produce other tools akin on scoring techniques to constraint programming. we use realistic real and randomly generated benchmarks.", "histories": [["v1", "Sat, 17 Sep 2016 17:17:15 GMT  (21kb)", "http://arxiv.org/abs/1609.05367v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["miquel bofill", "v\\'ictor mu\\~noz", "javier murillo"], "accepted": false, "id": "1609.05367"}, "pdf": {"name": "1609.05367.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["miquel.bofill@udg.edu,", "victor.munoz@newronia.com", "javier.murillo@newronia.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n05 36\n7v 1\n[ cs\n.A I]\n1 7\nSe p\n20 16\nFrom this and similar results, we claim for the convenience of developing compiler front-ends being able to translate from constraint programming languages to the SMT-LIB standard language."}, {"heading": "1 Introduction", "text": "Most state-of-the-art satisfiability checkers for propositional logic, also known as SAT solvers, are based on variations of the Davis-Putnam-Logemann-Loveland (DPLL) procedure [DP60, DLL62]. During the last ten years, SAT solvers have spectacularly progressed in performance thanks to better implementation techniques and conceptual enhancements, such as non-chronological backtracking and conflict-driven lemma learning, which in many instances of real problems are able to reduce the size of the search space significantly. Thanks to those advances, nowadays best SAT solvers can tackle problems with hundreds of thousands of variables and millions of clauses.\nThese techniques have been adapted for more expressive (yet decidable) logics. For instance, in hardware and software verification applications, decision procedures for checking the satisfiability of quantifier-free first-order formulas with respect to background theories (such as the integer or real numbers, arrays, bit vectors, etc) have been developed. This is known as the SAT Modulo Theories (SMT) problem for a theory T : given a formula F , determine whether there is a model of T \u222a{F}. Hence, an SMT instance is a generalization of a Boolean SAT instance in which some propositional variables have been replaced by predicates from the underlying theories, and can contain clauses like, e.g., p\u2228 q\u2228 x+ 2 \u2264 y\u2228 x = y+ z, providing a much richer modeling language than is possible with SAT formulas.\nAlthough an SMT instance can be solved by encoding it into an equisatisfiable SAT instance and feeding it to a SAT solver, currently most successful SMT solvers are based on the integration of a SAT solver and a T -solver, that is, a decision procedure for the given theory T . In this so-called lazy approach, while the SAT solver is in charge of the Boolean component of reasoning, the T -solver deals with sets of atomic constraints in T . The main idea is that the T -solver analyzes the partial model that the SAT solver is building, and warns it about conflicts with theory T (T -inconsistency). See [Seb07] for a survey on this approach.\nLeveraging the advances made in SAT solvers in the last decade, SMT solvers have proved to be competitive with classical decision methods in many areas. See, e.g., [NO06] for an application of an SMT solver on an optimization problem, being competitive with the best weighted CSP solver with its best heuristic on that problem. In the spirit of bringing SMT technology to other communities, in this paper we show how a non-trivial scheduling problem can be efficiently solved by using state-of-theart SMT solvers, and compare their performance to other approaches. The problem we deal with is a real-world cumulative scheduling problem, namely, the Wastewater Treatment Plant Problem (WWTPP). This problem turns out to be a generalization of the preemptive CuSP.\nThe rest of the paper is organized as follows. In Section 2 we give some preliminaries on cumulative scheduling. In Section 3 we define the WWTPP and, in Section 4 we encode it by translation into SAT modulo Linear Integer Arithmetic and also into Integer Programming (IP). In Section 5 we give computational results comparing the performance of different tools on the problem, both for real and random instances, which suggest that state-of-the-art SMT solvers are competitive with best IP tools, and even better on difficult instances of this problem. For the sake of completeness, in Section 6 the problem is encoded into many Constraint Programming (CP) dialects, preserving as much as possible the encoding given for SMT. We give computational results showing that SMT tools have far much better performance than CP tools on this problem. After this, in Section 7, a different encoding of the problem is discussed for the CP tools supporting the global cumulative constraint. Overall conclusions and ideas for future work are given in Section 8."}, {"heading": "2 Cumulative Scheduling", "text": "Scheduling problems are prototypical NP-complete real-world problems. Roughly speaking, scheduling is the process of assigning scarce resources to tasks over time. It is not surprising, hence, that those problems have been addressed in a wide variety of research areas, and that they have been divided into different subclasses. Many real-world scheduling problems fall into the cumulative scheduling class, where each resource may be shared between a bounded number of tasks [AB93], in contrast with the disjunctive scheduling class, where each resource can execute at most one task at a time. Another frequent differentiation is between preemptive and non-preemptive scheduling, depending on whether a task can be interrupted (i.e., subdivided) or not.\nA very general problem in the cumulative scheduling class is the resource-constrained project scheduling problem (RCPSP). In its non-preemptive version, we have (1) a set of resources of given capacities, (2) a set of tasks of given durations, (3) an acyclic graph of precedence constraints between the tasks, and (4) for each task and each resource the amount of the resource required by the task over its execution. The objective is to find a start time assignment to the tasks that satisfies the precedences and resource capacity constraints, and minimizes the makespan (i.e., the time at which all tasks are completed). As a generalization of the job-shop scheduling problem, the decision variant of the RCPSP (where what is required is to find an assignment whose makespan does not exceed a given deadline) is NP-complete in the strong sense and, hence, the RCPSP is NP-hard in the strong sense [GJ79, BLRK83]. See [HD02, BK06] for surveys.\nDue to the generality of the RCPSP, many problems in the cumulative scheduling class are particular cases of it. This is the case for the so-called cumulative scheduling problem (CuSP), where we have (1) a single resource of given capacity and (2) a set of tasks, each one with a given duration, release time, deadline and resource capacity requirement, and we are asked to find an schedule satisfying all timing constraints and the resource capacity constraint [BLN99]. As an extension of the parallel machine problem [Car84], this problem is also NP-hard in the strong sense.\nMost of the work on the RCPSP and the CuSP has been devoted to the non-preemptive case (note that the introduction of preemption increases the number of possible solutions). Some relaxations of the CuSP involving elastic tasks (where, roughly, each task is only given a global amount of processing, and its duration and consumption is not fixed) have been considered in [CL96, BLN99], but little work on the preemptive case can be found in the literature. See, e.g., [Kap88, DH96] for the preemptive RCPSP and [CN00] for the preemptive CuSP.\nIn this paper we deal with the Wastewater Treatment Plant Problem (WWTPP), a real-world cumulative scheduling problem which is a generalization of the preemptive CuSP."}, {"heading": "3 The Wastewater Treatment Plant Problem (WWTPP)", "text": "The treatment of the wastewater discharged by industries into the rivers is vital for environmental quality. For this purpose, the wastewater is treated in wastewater treatment plants (WWTP). A WWTP receives the polluted wastewater discharges coming from the city and different industries. Nowadays the most common wastewater treatment is the activated sludge process. The system consists in an aeration tank in which the microorganisms responsible for treatment (i.e. removal of carbon, nitrogen and phosphorous) are kept in suspension and aerated followed by a liquid-solids separation, usually called secondary settler. Finally a recycle system is responsible for returning a fraction of solids removed from the liquid-solids separation unit back to the reactor, whereas the other fraction is wasted from the system [TBS03].\nThe treatment capacity of the plant is limited, and therefore all pollutants arriving at the WWTP should be under certain limits; otherwise, the wastewater could not be fully treated and the river would be polluted. The hydraulic and contaminants capacity constraints that are defined according to its expected use (industries and cities in the surroundings that generate the waste). Currently, there exist regulations intended to achieve this goal by assigning a fixed amount of authorized discharges to each industry. However, they are not sufficient to guarantee the proper treatment of the wastewater. The problem is that, although these regulations enforce industries to respect the WWTP capacity thresholds, they do not take into account that simultaneous discharges by different industries may exceed the WWTP\u2019s thresholds. In such a case, no industry would be breaking the rules, but the effect would be to exceed the WWTP capacity.\nThe scheduling problem faced in this domain is to distribute the industrial discharges over time so that all the water entering the WWTP can be treated. If the discharges are done without any coordination, the amount of water arriving at the WWTP can exceed its incoming water flow threshold, and cause the overflow to go directly to the river without being treated. Moreover, if the contamination level of the water is too high, the microorganisms used in the cleaning process die, and the process has to stop until they are regenerated. Thus, in order to prevent such dangerous situations, the industrial discharges should be temporally distributed so that all of them can be fully treated.\nIn this paper we address this problem, but taking into account only the water flow (i.e., without taking into account the contaminants). Therefore we assume having a single resource of given capacity (the WWTP) and a set of tasks, each one with a given duration, release time, deadline and resource capacity requirement (the discharges).\nNote that we are asked to find a start time of each discharge between its release time and its deadline, such that, at any time, the sum of resource requirements of the discharges scheduled at that time does not exceed the WWTP capacity. One must assume, however, that there is some precedence relation (presumably, a chain) between the tasks of each single industry. Hence, this problem is a generalization of the CuSP, and a particular case of the RCPSP.\nWe will focus on the decision variant of the problem, i.e., in finding a feasible solution not exceeding an overall deadline, instead of in minimizing the makespan. This is because, in the real problem we address, it is sufficient that all discharges are rescheduled within the same day for which they were originally scheduled (and, in fact, the minimization of the makespan may not be good for the WWTP, as it is preferably, for the microorganisms\u2019 functioning, that the discharges are homogeneously distributed along the time). Then we have that the problem is NP-complete, as it is in NP (as a particular case of the decision variant of the RCPSP) and it is NP-hard (as a generalization of the decision variant of the CuSP). Let us mention that a relaxed version of the WWTPP, where there is no deadline and conflicts are solved by a recurrent auction mechanism, has been addressed in [MMBL07].\nSince the delays introduced in the discharges (in order to find a feasible schedule) should not stop or delay the production processes of the industries, the idea is to keep those discharges temporarily in a retention tank in the industry itself, and to throw them to the river later on. This approach, however,\nbrings us to a preemptive framework, since one can reasonably assume that a discharge coming from a tank can be interrupted (i.e., the tank can be emptied at disjoint intervals). Hence, that problem has the preemptive CuSP as a particular case (where, in the CuSP, each task corresponds to a discharge from a different industry, having a retention tank of sufficient capacity to hold the discharge and an output rate equivalent to the one of the discharge), and is NP-hard as well. Therefore, we define the Wastewater Treatment Plant Problem as follows."}, {"heading": "3.1 Problem statement", "text": "An instance of the Wastewater Treatment Plant Problem (WWTPP) is given by (1) a single resource of given capacity, (2) a set of tasks, each one with a given duration, release time and resource capacity requirement, (3) a chain-like precedence relation between the tasks, (4) for any such chain of tasks, a buffer (or retention tank) of given capacity and output rate (we assume that the input rate is flexible) and (5) an overall deadline (greater than all release times).\nThe question is to find an schedule where (1) each task is either scheduled at its release time (and does not exceed the deadline), or else it is redirected to its corresponding buffer with a volume equal to its resource capacity requirement multiplied by its duration, (2) the capacity of each buffer is not exceeded at any time, (3) each buffer is emptied, preemptively, at its corresponding rate, (4) each buffer is empty at the deadline, and (5) at any time, the sum of required capacities of the tasks scheduled at that time, together with the required capacities of the emptying of the buffers at that time, does not exceed the capacity of the single resource.\nNotice that nothing prevents a buffer from being emptied and filled at the same time, and also from being emptied at the same time at which one of the tasks is scheduled."}, {"heading": "4 Modeling the WWTPP", "text": "In this section we give an encoding of a WWTPP instance into a SAT modulo unquantified Linear Integer Arithmetic (LIA) instance. As we will see, SAT modulo LIA nicely captures all constraints. Afterwards we translate this encoding into an Integer Programming problem, with the aim of comparing the performance of state-of-the-art solvers on both approaches."}, {"heading": "4.1 SMT modeling", "text": "A WWTPP instance can be easily codified as a SAT modulo unquantified Linear Integer Arithmetic instance as follows."}, {"heading": "4.1.1 Constants", "text": "We have the following non-negative integer constants:\n\u2022 PlantCapacity denotes the capacity of the wastewater treatment plant at each time period.\n\u2022 Given a set of k industries, TankCapacityi and TankFlowi denote respectively the capacity and the emptying rate of the buffer associated to industry i, \u2200i \u2208 1 . . .k.\n\u2022 Given a set of discharges from k industries to be scheduled within m time periods, di j denotes the scheduled flow of discharge for industry i during time period j, \u2200i \u2208 1 . . .k, j \u2208 1 . . .m."}, {"heading": "4.1.2 Variables", "text": "Given a set of discharges from k industries to be scheduled within m time periods, we have the following integer variables \u2200i \u2208 1 . . .k, j \u2208 1 . . .m:\n\u2022 For every di j > 0, ci j denotes the actual \u201ccapacity requirement\u201d of industry i during time period j, corresponding to a scheduled discharge. That is, for every di j > 0, either ci j = di j, or ci j = 0 and the discharge is redirected to that industry\u2019s buffer.\n\u2022 Bouti j denotes the flow discharged from buffer (of industry) i during time period j.\n\u2022 Buf i j denotes the flow stored in buffer i at the end of time period j."}, {"heading": "4.1.3 Constraints", "text": "\u2200 j \u2208 1 . . .m : k\n\u2211 i=1 ci j +Bouti j \u2264 PlantCapacity (1)\n\u2200i \u2208 1 . . .k : Buf i1 = di1 \u2212 ci1 (2)\n\u2200i \u2208 1 . . .k, j \u2208 2 . . .m : Buf i j = Buf i j\u22121 \u2212Bouti j +di j \u2212 ci j (3)\n\u2200i \u2208 1 . . .k, j \u2208 2 . . .m\u22121 : Buf i j \u2264 TankCapacityi (4)\n\u2200i \u2208 1 . . .k : Buf im = 0 (5)\nIn constraints 2 and 3, the difference di j \u2212 ci j is replaced by 0 if di j = 0 (recall that variables ci j have been defined only for corresponding constants di j > 0).\n\u2200i \u2208 1 . . .k : Bouti1 = 0 (6)\n\u2200i \u2208 1 . . .k, j \u2208 2 . . .m : Bouti j = 0 (7)\n\u2228 (Bouti j = TankFlowi \u2227Buf i j\u22121 \u2265 TankFlowi) (8)\n\u2228 (Bouti j = Buf i j\u22121 \u2227Buf i j\u22121 \u2264 TankFlowi) (9)\nFor every discharge from an industry i, spanning from time period a to time period b, we state:\n(cia = 0\u2227 \u00b7\u00b7 \u00b7\u2227 cib = 0)\u2228 (cia = dia \u2227 \u00b7\u00b7 \u00b7\u2227 cib = dib)1 (10)\nFinally, the following (obvious) redundant constraints can be added in order to help orienting the search:\n\u2200i \u2208 1 . . .k, j \u2208 2 . . .m : 0 \u2264 Bouti j \u2264 TankFlowi (11)\n\u2200i \u2208 1 . . .k, j \u2208 2 . . .m : Bouti j \u2264 Buf i j\u22121 (12)\nConstraints 1 state that the capacity of the WWTP is not exceeded at any time. Constraints 2 and 3 define the amount of water inside every buffer at every time interval, taking into account the amount of water inside each buffer at the previous time interval, and the current output and input flows for this buffer. Constraints 4 require the capacity of each buffer not being exceeded at any time, and constraints 5\n1Notice that dia = \u00b7 \u00b7 \u00b7= dib > 0.\nimpose all buffers being empty at the deadline. Constraints from 6 to 9 are restrictions on the output flow from the buffers (or retention tanks): the output flow at the first time interval must be zero (as the buffer is empty) and, at subsequent time intervals, it can be either zero, or it can be equal to the tank flow (provided that there is enough water inside the buffer) or it can be equal to the remaining water inside the buffer if this is less or equal than the tank flow. Constraints 10 express the dichotomy of throwing each discharge to the river or redirecting it to a buffer.\nConstraints 11 and 12 are unnecessary, but have proved to be helpful in our experiments. Notice that, although the value of the Bout variables is perfectly defined by constraints 6 to 9, restricting the domain of the Bout variables can help in the search for solutions."}, {"heading": "4.2 IP modeling", "text": "In order to obtain an IP instance from the previous SMT instance, we need to convert logical combinations of linear constraints into conjunctions of linear constraints. We use standard transformations like the ones of [Wil78].\nWe define, \u2200i \u2208 1 . . .k, j \u2208 1 . . .m, zero-one variables ri j denoting whether discharge from industry i at time period j is actually scheduled or else redirected to a buffer. Then we replace ci j with ri j \u00b7 di j inside constraints 1, 2 and 3. Constraints 4, 5 and 6 remain the same. The zero-one variables ri j allow constraint 10 to be translated into\nria + \u00b7 \u00b7 \u00b7+ rib = 0\u2228 ria + \u00b7 \u00b7 \u00b7+ rib = b\u2212a+1.\nThis can then be encoded as a conjunction of linear constraints by defining additional zero-one variables \u03b4iab for every discharge from an industry i spanning from time period a to time period b, and stating:\nria + \u00b7 \u00b7 \u00b7+ rib +(b\u2212a+1) \u00b7\u03b4iab \u2264 b\u2212a+1 (13) \u2212(ria + \u00b7 \u00b7 \u00b7+ rib)\u2212 (b\u2212a+1) \u00b7\u03b4iab \u2264\u2212(b\u2212a+1) (14)\nThe disjunction of constraints 7, 8 and 9 can be expressed as\n\u03b4 \u20321i j \u2192 Bouti j = 0 (15) \u03b4 \u20322i j \u2192 Bouti j = TankFlowi \u2227Buf i j\u22121 \u2265 TankFlowi (16) \u03b4 \u20323i j \u2192 Bouti j = Buf i j\u22121 \u2227Buf i j\u22121 \u2264 TankFlowi (17)\nwhere \u03b4 \u20321i j, \u03b4 \u20322i j and \u03b4 \u20323i j are again zero-one variables, and\n\u03b4 \u20321i j +\u03b4 \u20322i j +\u03b4 \u20323i j \u2265 1 (18)\nThen constraints 15, 16 and 17 can be transformed into a conjunction of linear constraints by using Big\u2212M like constraints.2 This way, constraint 15 becomes\nBouti j +TankFlowi \u00b7\u03b4 \u20321i j \u2264 TankFlowi (19)\nand constraint 16 becomes\nTankFlowi \u00b7\u03b4 \u20322i j \u2212Bouti j \u2264 0 (20) \u2212Buf i j\u22121 +TankFlowi \u00b7\u03b4 \u20322i j \u2264 0 (21)\n2The idea of Big\u2212M constraints is the following: a disjunction like, e.g., (x \u2264 0)\u2228 b, where b is a propositional variable, can be converted into x \u2264 ubound(x)b, where ubound(x) denotes an upper bound of x.\nNotice that these constraints work in conjunction with constraints 11, which are mandatory here: on the one hand, from 19 we get Bouti j \u2264 0 whenever \u03b4 \u20321i j = 1, which together with 0 \u2264 Bouti j (from 11) gives us Bouti j = 0 as we need; on the other hand, from 20 we get TankFlowi \u2264 Bouti j whenever \u03b4 \u20322i j = 1, which together with Bouti j \u2264 TankFlowi (from 11) gives us Bouti j = TankFlowi as we need.\nFinally, constraint 17 becomes\nBuf i j\u22121 \u2212Bouti j +TankCapacityi \u00b7\u03b4 \u20323i j \u2264 TankCapacityi (22) Buf i j\u22121 +TankCapacityi \u00b7\u03b4 \u20323i j \u2264 TankCapacityi +TankFlowi (23)\nConstraints 12 are mandatory for similar reasons as before, since they work in conjunction with 22."}, {"heading": "5 Benchmarking", "text": "Here we comment on some benchmarking we did, showing that state-of-the-art SMT solvers outperform best IP solvers with the previous modeling of the WWTPP. We worked with two sets of benchmarks, one coming from real data and another coming from randomly generated data.3\nIn the real set of benchmarks we used data coming from 8 industries (each one having its own retention tank), with a total of 94 discharges planned within a period of 24 hours. We took a time discretization of one hour and an overall deadline of 24 hours for the schedule. Different problem instances were generated with different capacities of the wastewater treatment plant, ranging from 2000 units to 10000, at increments of 20. This way, an easy-hard-easy transition was observed (as already noted by [CL96, HDR99] for similar scheduling problems) with a transition from unsatisfiability to satisfiability taking place at 5000 units of capacity.\nFor the random set of benchmarks we considered a total of 114 discharges from 10 industries (having again each one an associated retention tank), all of them being planned within a period of 24 hours. Although randomly generated, both the magnitude and duration of the discharges and the size of the retention tanks was restricted to be within reasonable limits. We took a time discretization of one hour and an overall deadline of 26 hours for the schedule. From this data different problem instances were generated, with a capacity of the wastewater treatment plant ranging from 5000 to 30000 units, at increments of 100, resulting into a transition from unsatisfiability to satisfiability at 14500 units.\nAll the benchmarks, written according to the modeling of Subsection 4.1 in the SMT-LIB standard language, were submitted the last year to the SMT library,4 and some of them were chosen for the annual SMT competition5 in the corresponding category.\nTable 1 shows the percentage of solved benchmarks and the total time spent by IBM ILOG CPLEX 11, Z3.2\u03b1 (SMT-COMP\u201908 QF LIA division winner) and Yices 2 (SMT-COMP\u201909 QF LIA division winner), with a time out of 1800 seconds for each instance in the real set, and of 300 seconds in the random set. All benchmarks were executed on a 3.80 GHz Intel Xeon machine with 3.5 GB of RAM running under GNU/Linux 2.6. The modeling given in Subsection 4.2 was used for CPLEX.\nAs it can be seen, state-of-the-art SMT solvers clearly outperform CPLEX on this benchmarks. It is specially remarkable that Yices solves all the benchmarks, and Z3 only fails in solving one from the real set around the phase transition. Moreover, Yices is able to solve all the 251 benchmarks from the random set in only 5.15 seconds, being almost insensitive to the phase transition. W.r.t. CPLEX, although it has very good performance in many instances, it fails to solve some of them around the phase transition. Since SMT solvers, like it does CPLEX, use a simplex procedure for handling atomic linear constraints,\n3The data used in both sets of benchmarks can be found in http://imae.udg.edu/~mbofill/wwtpp.tar 4http://www.smt-lib.org 5http://www.smt-comp.org\nother elements of SMT technology such as conflict-driven lemma learning, backjumping or restarts can be playing a central role in this problem.\nIt is worth noting that worse results are obtained by CPLEX if no objective function is used. After trying with several objective functions, we obtained the best results by minimizing the sum of buffer contents. This somehow corresponds to an eager strategy consisting in avoiding the use of buffers if possible (and hence prioritizing discharges of wastewater at their preliminarily scheduled times) and emptying the buffers as soon as possible. Notice however that no objective function or user-given search strategy is possible with SMT solvers, which are completely black-box for the user and, still, better results are obtained."}, {"heading": "6 Comparison with Constraint Programming", "text": "For the sake of completeness, in this section we detail the results obtained with several Constraint Programming (CP) tools on our benchmarks.\nIn order to do the benchmarking, our modeling needs to be translated into several CP dialects. For the comparison to be fair, in all cases we must choose an encoding as similar as possible to the one described in Subsection 4.1. This implies avoiding the use of global constraints and sophisticated search strategies that can be available in CP tools. For this reason, we have only used labeling strategies.6 Results on a different encoding, using the cumulative global constraint, are given in the next section.\nSince the translation of the encoding described in Subsection 4.1 into a CP program over finite domains is almost direct, the encodings obtained for each CP tool are very similar and hence we do not detail them here. Moreover, for solvers providing a FlatZinc front-end, we have used the same MiniZinc model: MiniZinc [NSB+07] proposes to be a standard CP modeling language that can be translated into an intermediate language called FlatZinc. FlatZinc instances can be obtained from MiniZinc instances by using the MiniZinc-to-FlatZinc translator mzn2fzn, and then can be plugged into any solver providing an specialized front-end for FlatZinc.\nTable 2 shows the results obtained by several CP solvers on the benchmarks described in Section 5, except for the last two entries, which show the results obtained by the same SMT solvers used in Section 5, but where SMT instances have been obtained from FlatZinc instances through an experimental compiler fzn2smt.7 The table refers only to the solving time (we do not include translation times since we are interested in comparing solving times, regardless of the input language). All benchmarks were executed on a 3 GHz Intel Core 2 Duo machine with 1 GB of RAM running under GNU/Linux 2.6.\n6Notice that there is always a default labeling strategy in these tools and, hence, trying with some labeling options does not imply doing any change in the encoding.\n7Available at http://imae.udg.edu/recerca/lap\nAt a first glance we can observe that SMT solvers are far better than other tools on these benchmarks. It is remarkable that, after the two step translation from MiniZinc-to-FlatZinc-to-SMT, we obtain similar (and in some case even better) results to the ones in Section 5.\nWe tried different labeling strategies with CP solvers, but almost identical results were obtained. Hence, unless contrarily indicated, the results in Table 2 are for the default strategy, which is usually first-fail: selecting the leftmost variable with smallest domain next, in order to detect infeasibility early. This is often a good strategy. However, with SICStus Prolog we obtained significantly better results when using the max and down options: selecting the leftmost variable with the greatest upper bound next, and exploring its domain in descending order. In our program, this translates to a strategy consisting in giving priority to the biggest discharges, and keeping them in buffers as least as possible. Notice that this roughly coincides with the objective function giving best results in the IP approach of Section 5.\nThe concrete versions of the CP solvers we used are: SICStus Prolog 4.0.1 (for the first entry in the table), SICStus Prolog 4.1.1 (with FlatZinc support, for the MiniZinc case), Comet 2.0, Minion 0.9, G12 MiniZinc 1.0.3, Gecode 3.2.2, and ECLiPSe 6.0. For the case of Minion, we used Tailor as a translator from the ESSENCE [FHJ+08] high-level language to the Minion language, in the same spirit of using the Minizinc-to-Flatzinc translator mzn2fzn. This allowed us to use an almost identical model. Comet already supports a high-level language which allowed us to express the constraints in a very similar way. Moreover, for the case of Comet we tried both the CP engine and the LP engine, with no clear winner. We want to remark that we are aware of IBM ILOG CP Optimizer, which uses constraint programming to solve detailed scheduling problems and combinatorial problems not easily solved using mathematical programming methods. Unfortunately we were not able to test this tool on our benchmarks, since the trial version has severe limitations in the number of variables and in the number of allowed constraints."}, {"heading": "7 A different approach for Constraint Programming", "text": "An alternative approach is to solve the WWTPP by exploiting the use of the cumulative constraint within a CP system, since this constraint is closely related to our problem. Many CP systems, such as CHIP V5, ECLiPSe, B-Prolog and SICStus Prolog, include the cumulative global constraint in their\nfinite domain library. This constraint was originally introduced into the CHIP programming system to describe and solve complex scheduling problems [AB93]. Its habitual syntax is cumulative(Starts,Durations,Resources,Limit), where Starts, Durations, and Resources are lists of integer domain variables or integers of the same length, and Limit is an integer. The declarative meaning is: if the lists denote respectively the start times, durations and resource capacity requirements of a set of tasks, then the sum of resource usage of all the tasks does not exceed Limit at any time. One should expect that, by using this constraint adequately, the performance of a CP system on the previous problem will be better (or, at least, not worse) than if not using it.\nOur modeling using the cumulative constraint goes as follows. Given a discharge i of duration di and resource capacity requirement ci, since it can either go directly to the river or be redirected to a retention tank of certain output rate r, we create a set of new n discharges of duration 1 and capacity requirement r, and one discharge of duration 1 and non-negative requirement capacity r\u2032 \u2264 r (the remainder), such that dici = rn+ r\u2032. Observe that by dividing the discharges into a number of discharges of duration 1 we get rid of preemption. Then, by using reified constraints, we state that the capacity requirements of those n+1 new discharges is actually 0 if and only if the associated original discharge i goes to the river.\nNotice that a set of remainders (each of them coming from a different original discharge of the same industry) could eventually be redistributed, forming a new set of discharges of resource capacity r plus one single remainder. However, such redistribution should be made for the remainders being available at each time, i.e., dynamically, and this does not go in the direction of an encoding using the cumulative constraint, which requires a fixed set of resources. Therefore, here we do not consider the possibility of redistributing the remainders. Although this is a inexact formulation of the problem, in practice it results a very few times in a smaller set of solutions than with the encoding used in the previous sections. And, in any case, since this simplification results in a smaller search space, it is likely to favour this approach.\nThen, apart from stating the obvious release time, precedence and finishing time constraints, we use the cumulative constraint two-fold. On the one hand, we use it in order to assure that the WWTP capacity is not exceeded. On the other hand, we use it in order to assure that the output rate and capacity of every retention tank is not exceeded. This second use implies stating two cumulative constraints for each industry, in the following way:\nLet [I1,...,In] be a list with the initial times of the discharges kept in the retention tank of a industry, let [H1,...,Hn] be the times at which they are respectively flushed out from the tank, let [C1,...,Cn] be their resource capacity requirements, let r be the output rate of the tank, and let c be the capacity of the tank. Then we state\ncumulative([H1,...,Hn],[1,...,1],[C1,...,Cn],r)\nin order that the output rate of the tank is not exceeded, and\ncumulative([I1,..., In],[H1-I1,...,Hn-In],[C1,...,Cn],c)\nin order that the capacity of the tank is not exceeded. Finally, for symmetry breaking, we state ordering constraints between (indistinguishable) discharges from each retention tank. Since all these discharges are of duration 1, this improvement dramatically reduces the search space.\nTable 3 shows the results obtained by the CP solvers supporting the cumulative global constraint on the same benchmarks as in the previous sections. Again, we used the possibility of sharing a unique MiniZinc model, except for the first entry, where we directly built a Prolog program. We can observe that, in general, the results are better than with the previous encoding for the same CP solvers (with the only exception of G12 in the random set). However, these results are still far from the ones obtained by\nSMT solvers. This can be due to the fact that we are using two cumulative constraints for each industry (for assuring, respectively, that the output rate and the capacity of each retention tank is not exceeded), plus one cumulative global constraint (for assuring that the WWTP capacity is not exceeded) and, moreover, we are using many reified constraints (for the dichotomy of sending the discharges either to the river or to a retention tank), making thus difficult for the CP solvers to take profit of their algorithms for the cumulative constraint."}, {"heading": "8 Conclusion and future work", "text": "In this paper we have presented the Wastewater Treatment Plant Problem (WWTPP), a real problem in the cumulative scheduling class, and have compared several techniques for solving it. The encoding of the WWTPP into SAT modulo linear integer arithmetic, and using a high-performance SMT solver as a black-box for solving it, has turned out to be one of the best approaches. Specifically, we have seen that state-of-the-art SMT solvers are competitive with current best IP solvers, en even better on difficult instances of this problem (i.e., the ones around the phase transition). We think that this is a new result in the direction of showing that current SMT solvers are ready to solve real problems outside the verification area, and that they provide a nice compromise between expressivity and efficiency for scheduling problems.\nLet us recall that SMT solvers, like IP tools, use a simplex procedure for handling atomic linear constraints. However, the particular treatment of bound constraints of the form x \u2264 k or x \u2265 k inside a simplex procedure like the one of Yices, must be a key ingredient for the good results obtained in this problem by this solver (notice that many constraints in this problem are of this form). Also, we think that usual SMT techniques such as backjumping, restarts, and conflict-driven lemma learning must be a key ingredient for the good results obtained around the phase transition.\nMoreover, in our point of view, the encoding of the WWTPP as an SMT problem is simpler than as an IP problem (where logical combinations of linear constraints must be translated into conjunctions of linear constraints, with the addition of zero-one variables). Compared to CP, the SMT approach is not that simple (since most CP tools provide a high-level language front-end), but far more efficient. The performance of SMT solvers on this problem is still more significant if we take into account that they are completely black-box, and one cannot provide neither labeling strategies nor local search algorithms for guiding the search.\nIt was not our aim to find specialized algorithms for this problem, but to solve it from a non-expert perspective. In this sense, from our result it follows that compilers translating from a high-level language to SMT would be desirable, especially for people having no experience with constraint satisfaction problems. Let us recall, that, after a two step translation from MiniZinc-to-FlatZinc-to-SMT, we obtained\nsimilar (and in some case even better) results to the ones with a direct SMT encoding.8 Hence, we think that user-friendly and at the same time competitive CP tools could arise from such or similar combinations. In fact, some research has already been done in this direction. For instance, in [BPSV09], excellent results have been obtained on benchmarks from the CSPLib [GW99], after modeling them in a high-level language and automatically translating them into SAT modulo unquantified linear integer arithmetic. The fzn2smt9 compiler is a new tool in the same direction.\nOn the other hand, as pointed out in [NORCR07], for dense difference logic problems such as the ones coming from scheduling, there is still room for improvement in the context of SMT. Although such an improvement could be done in the solvers for the usual SMT theories, an alternative interesting thing to do would be to implement, e.g., a solver for the theory of cumulative, to be used with a modular SMT solver like the ones based on the DPLL(X) approach [NOT06]. Notice that this combination would give us a framework similar to the one of constraint programming, but with backjumping and learning. In fact, excellent results have been recently obtained in [SFSW09] by modeling the cumulative constraint by descomposition, and by exploiting the autonomous search and learning capabilities of a SAT solver in a way which resembles what is done in SMT. This makes us expect good performance results for SMT solvers in constraint satisfaction problems if backtrackable and incremental solvers for theories like cumulative, alldifferent, etc, are developed. In this sense, we totally agree with challenge 12 in [NORCR07]: to develop an SMT system with the advantages of one of CP\u2019s sophisticated global constraint propagation algorithms and the robustness and efficiency of SAT\u2019s backjumping, lemmas and heuristics, by expressing the global constraints as a theory."}], "references": [{"title": "Extending CHIP in order to solve complex scheduling and placement problems", "author": ["A. Aggoun", "N. Beldiceanu"], "venue": "Mathematical Computer Modelling,", "citeRegEx": "Aggoun and Beldiceanu.,? \\Q1993\\E", "shortCiteRegEx": "Aggoun and Beldiceanu.", "year": 1993}, {"title": "Complex Scheduling (GOR-Publications)", "author": ["Peter Brucker", "Sigrid Knust"], "venue": null, "citeRegEx": "Brucker and Knust.,? \\Q2006\\E", "shortCiteRegEx": "Brucker and Knust.", "year": 2006}, {"title": "Satisfiability tests and time-bound adjustments for cumulative scheduling problems", "author": ["Ph. Baptiste", "C. Le Pape", "W. Nuijten"], "venue": "Annals of Operations Research,", "citeRegEx": "Baptiste et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Baptiste et al\\.", "year": 1999}, {"title": "Scheduling subject to resource constraints: Classification and complexity", "author": ["J. Blazewicz", "J.K. Lenstra", "A.H.G. Rinnooy Kan"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "Blazewicz et al\\.,? \\Q1983\\E", "shortCiteRegEx": "Blazewicz et al\\.", "year": 1983}, {"title": "SIMPLY: a Compiler from a CSP Modeling Language to the SMT-LIB Format", "author": ["Miquel Bofill", "Miquel Palah\u0131", "Josep Suy", "Mateu Villaret"], "venue": "In 8th International Workshop on Constraint Modelling and Reformulation,", "citeRegEx": "Bofill et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bofill et al\\.", "year": 2009}, {"title": "Probl\u00e8mes d\u2019ordonnancement \u00e0 contraintes de ressources: Algorithmes et complexit\u00e9", "author": ["J. Carlier"], "venue": "The\u0300se de Doctorat d\u2019Etat, University of Paris VI,", "citeRegEx": "Carlier.,? \\Q1984\\E", "shortCiteRegEx": "Carlier.", "year": 1984}, {"title": "Cumulative scheduling with task intervals", "author": ["Yves Caseau", "Francois Laburthe"], "venue": "In Joint International Conference and Symposium on Logic Programming,", "citeRegEx": "Caseau and Laburthe.,? \\Q1996\\E", "shortCiteRegEx": "Caseau and Laburthe.", "year": 1996}, {"title": "A new LP-based lower bound for the cumulative scheduling problem", "author": ["Jacques Carlier", "Emmanuel Neron"], "venue": "European Journal of Operational Research,", "citeRegEx": "Carlier and Neron.,? \\Q2000\\E", "shortCiteRegEx": "Carlier and Neron.", "year": 2000}, {"title": "An efficient optimal solution procedure for the preemptive resource-constrained project scheduling problem", "author": ["Erik L. Demeulemeester", "Willy S. Herroelen"], "venue": "European Journal of Operational Research,", "citeRegEx": "Demeulemeester and Herroelen.,? \\Q1996\\E", "shortCiteRegEx": "Demeulemeester and Herroelen.", "year": 1996}, {"title": "A machine program for theorem-proving", "author": ["Martin Davis", "George Logemann", "Donald Loveland"], "venue": "Communications of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A computing procedure for quantification theory", "author": ["Martin Davis", "Hilary Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam.,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam.", "year": 1960}, {"title": "Essence: A constraint language for specifying combinatorial problems", "author": ["Alan M. Frisch", "Warwick Harvey", "Chris Jefferson", "Bernadette Mart\u0131\u0301nez-Hern\u00e1ndez", "Ian Miguel"], "venue": null, "citeRegEx": "Frisch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Frisch et al\\.", "year": 2008}, {"title": "Computers and Intractability. A Guide to the Theory of NP-Completeness", "author": ["Michael R. Garey", "David S. Johnson"], "venue": null, "citeRegEx": "Garey and Johnson.,? \\Q1979\\E", "shortCiteRegEx": "Garey and Johnson.", "year": 1979}, {"title": "CSPLIB: A benchmark library for constraints", "author": ["Ian P. Gent", "Toby Walsh"], "venue": "In 5th International Conference on Principles and Practice of Constraint Programming, CP\u201999,", "citeRegEx": "Gent and Walsh.,? \\Q1999\\E", "shortCiteRegEx": "Gent and Walsh.", "year": 1999}, {"title": "Phase transitions in project scheduling", "author": ["W. Herroelen", "B. De Reyck"], "venue": "Journal of the Operational Research Society,", "citeRegEx": "Herroelen and Reyck.,? \\Q1999\\E", "shortCiteRegEx": "Herroelen and Reyck.", "year": 1999}, {"title": "Resource-constrained project scheduling with preemption of jobs", "author": ["L.A. Kaplan"], "venue": "Unpublished Ph.D. Thesis, University of Michigan,", "citeRegEx": "Kaplan.,? \\Q1988\\E", "shortCiteRegEx": "Kaplan.", "year": 1988}, {"title": "Improving water quality by coordinating industries schedules and treatment plants", "author": ["V. Mu\u00f1oz", "J. Murillo", "D. Busquets", "B. L\u00f3pez"], "venue": "In AAMAS workshop on Coordinating Agents\u2019 Plans and Schedules (CAPS),", "citeRegEx": "Mu\u00f1oz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Mu\u00f1oz et al\\.", "year": 2007}, {"title": "On SAT Modulo Theories and Optimization Problems", "author": ["Robert Nieuwenhuis", "Albert Oliveras"], "venue": "In 9th International Conference on Theory and Applications of Satisfiability Testing, SAT\u201906,", "citeRegEx": "Nieuwenhuis and Oliveras.,? \\Q2006\\E", "shortCiteRegEx": "Nieuwenhuis and Oliveras.", "year": 2006}, {"title": "Challenges in Satisfiability Modulo Theories", "author": ["Robert Nieuwenhuis", "Albert Oliveras", "Enric Rodr\u0131\u0301guez-Carbonell", "Albert Rubio"], "venue": "In 18th International Conference on Rewriting Techniques and Applications, RTA\u201907,", "citeRegEx": "Nieuwenhuis et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2007}, {"title": "Solving SAT and SAT Modulo Theories: From an abstract Davis\u2013Putnam\u2013Logemann\u2013Loveland procedure to DPLL(T)", "author": ["Robert Nieuwenhuis", "Albert Oliveras", "Cesare Tinelli"], "venue": "Journal of the ACM,", "citeRegEx": "Nieuwenhuis et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "Minizinc: Towards a standard CP modelling language", "author": ["Nicholas Nethercote", "Peter J. Stuckey", "Ralph Becket", "Sebastian Brand", "Gregory J. Duck", "Guido Tack"], "venue": "In 13th International Conference on Principles and Practice of Constraint Programming, CP\u201907,", "citeRegEx": "Nethercote et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nethercote et al\\.", "year": 2007}, {"title": "Lazy satisfiability modulo theories", "author": ["Roberto Sebastiani"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "Sebastiani.,? \\Q2007\\E", "shortCiteRegEx": "Sebastiani.", "year": 2007}, {"title": "Why cumulative decomposition is not as bad as it sounds", "author": ["Andreas Schutt", "Thibaut Feydy", "Peter J. Stuckey", "Mark Wallace"], "venue": "In 15th International Conference on Principles and Practice of Constraint Programming, CP\u201909,", "citeRegEx": "Schutt et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Schutt et al\\.", "year": 2009}, {"title": "Wastewater Engineering. Treatment and Reuse, Metcalf and Eddy, Inc., 4th edition", "author": ["G. Tchobanoglous", "F.L. Burton", "H.D. Stensel"], "venue": null, "citeRegEx": "Tchobanoglous et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Tchobanoglous et al\\.", "year": 2003}, {"title": "Model Building in Mathematical Programming", "author": ["H.P. Williams"], "venue": null, "citeRegEx": "Williams.,? \\Q1978\\E", "shortCiteRegEx": "Williams.", "year": 1978}], "referenceMentions": [], "year": 2016, "abstractText": "In this paper we introduce the Wastewater Treatment Plant Problem, a real-world scheduling problem, and compare the performance of several tools on it. We show that, for a naive modeling, state-of-the-art SMT solvers outperform other tools ranging from mathematical programming to constraint programming. We use both real and randomly generated benchmarks. From this and similar results, we claim for the convenience of developing compiler front-ends being able to translate from constraint programming languages to the SMT-LIB standard language.", "creator": "LaTeX with hyperref package"}}}