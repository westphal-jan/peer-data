{"id": "1610.09996", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Oct-2016", "title": "End-to-End Answer Chunk Extraction and Ranking for Reading Comprehension", "abstract": "this paper proposes dynamic chunk reader ( dcr ), an end - to - end neural reading coding ( rc ) model that is able to associate and rank a set of answer candidates from closely given document to understand questions. dcr is able to predict answers of variable lengths, whereas recent neural rc models primarily focused on predicting single samples or errors. dcr encodes a document and an input question with recurrent neural networks, and then applies rapid syllable - by - word attention mechanism to acquire question - aware representations for the sample, accelerated by the generation of chunk representations and a ranking module to propose the top - ranked chunk as the answer. experimental results show that dcr achieves state - with - the - art exact signatures and f1 implementations on xml squad dataset.", "histories": [["v1", "Mon, 31 Oct 2016 16:14:08 GMT  (1507kb,D)", "http://arxiv.org/abs/1610.09996v1", "Submitted to AAAI"], ["v2", "Wed, 2 Nov 2016 17:55:32 GMT  (1507kb,D)", "http://arxiv.org/abs/1610.09996v2", "Submitted to AAAI"]], "COMMENTS": "Submitted to AAAI", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["yang yu", "wei zhang", "kazi hasan", "mo yu", "bing xiang", "bowen zhou"], "accepted": false, "id": "1610.09996"}, "pdf": {"name": "1610.09996.pdf", "metadata": {"source": "CRF", "title": "End-to-End Answer Chunk Extraction and Ranking for Reading Comprehension", "authors": ["Yang Yu", "Wei Zhang", "Kazi Hasan", "Mo Yu", "Bing Xiang", "Bowen Zhou"], "emails": ["zhou}@us.ibm.com"], "sections": [{"heading": "Introduction", "text": "Reading comprehension-based question answering (RCQA) is the task of answering a question with a chunk of text taken from related document(s). A variety of neural models have been proposed recently either for extracting a single entity or a single token as an answer from a given text (Hermann et al. 2015; Kadlec et al. 2016; Trischler et al. 2016b; Dhingra et al. 2016; Chen, Bolton, and Manning 2016; Sordoni, Bachman, and Bengio 2016; Cui et al. 2016a); or for selecting the correct answer by ranking a small set of human-provided candidates (Yin, Ebert, and Schu\u0308tze 2016; Trischler et al. 2016a). In both cases, an answer boundary is either easy to determine or already given.\nDifferent from the above two assumptions for RCQA, in the real-world QA scenario, people may ask questions about both entities (factoid) and non-entities such as explanations and reasons (non-factoid) (see Table 1 for examples). In this regard, RCQA has the potential to complement other QA approaches that leverage structured data (e.g., knowledge bases) for both the above question types. This is because RCQA can exploit the textual evidences to ensure increased answer coverage, which is particularly helpful for non-factoid answers. However, it is also challenging for RCQA to identify answer in arbitrary position\n\u2217Both authors contribute equally Copyright c\u00a9 2017, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nin the passage with arbitrary length, especially for nonfactoid answers which might be clauses or sentences. As a result, apart from a few exceptions (Rajpurkar et al. 2016; Wang and Jiang 2016), this research direction has not been fully explored yet.\nCompared to the relatively easier RC task of predicting single tokens/entities1, predicting answers of arbitrary lengths and positions significantly increase the search space complexity: the number of possible candidates to consider is in the order of O(n2), where n is the number of passage words. In contrast, for previous works in which answers are single tokens/entities or from candidate lists, the complexity is in O(n) or the size of candidate lists l (usually l \u22645), respectively. To address the above complexity, Rajpurkar et al. (2016) used a two-step chunk-and-rank approach that employs a rule-based algorithm to extract answer candidates from a passage, followed by a ranking approach with hand-crafted features to select the best answer. The rule-based chunking approach suffered from low coverage (\u2248 70% recall of answer chunks) that cannot be improved during training; and candidate ranking performance depends greatly on the quality of the hand-crafted features. More recently, Wang and Jiang (2016) proposed two endto-end neural network models, one of which chunks a candidate answer by predicting the answer\u2019s two boundary indices and the other classifies each passage word into answer/notanswer. Both models improved significantly over the method proposed by Rajpurkar et al. (2016).\nOur proposed model, called dynamic chunk reader (DCR), not only significantly differs from both the above systems in the way that answer candidates are generated and ranked, but also shares merits with both works. First, our model uses deep networks to learn better representations for candidate answer chunks, instead of using fixed feature representations as in (Rajpurkar et al. 2016). Second, it represents answer candidates as chunks, as in (Rajpurkar et al. 2016), instead of word-level representations (Wang and Jiang 2016), to make the model aware of the subtle differences among candidates (importantly, overlapping candidates).\nThe contributions of this paper are three-fold. (1) We pro-\n1State-of-the-art RC models have a decent accuracy of \u223c70% on the widely used CNN/DailyMail dataset (Hermann et al. 2015).\nar X\niv :1\n61 0.\n09 99\n6v 1\n[ cs\n.C L\n] 3\n1 O\nct 2\n01 6\npose a novel neural network model for joint candidate answer chunking and ranking, where the candidate answer chunks are dynamically constructed and ranked in an endto-end manner. (2) we propose a new question-attention mechanism to enhance passage word representation, which is subsequently used to construct chunk representations. (3) We also propose several simple but effective features to strengthen the attention mechanism, which fundamentally improves candidate ranking, with the by-product of higher exact boundary match accuracy. The experiments on the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al. 2016), which contains a variety of human-generated factoid and non-factoid questions, have shown the effectiveness of above three contributions.\nOur paper is organized as follows. We formally define the RCQA problem first. Next, we describe our baseline with a neural network component. We present the end-to-end dynamic chunk reader model next. Finally, we analyze our experimental results and discuss the related work."}, {"heading": "Problem Definition", "text": "Table 1 shows an example of our RC setting where the goal is to answer a question Qi, factoid (Q1) or non-factoid (Q2 and Q3), based on a supporting passage Pi, by selecting a continuous sequence of text Ai \u2286 Pi as answer. Qi, Pi, and Ai are all word sequences, where each word is drawn from a vocabulary, V . The i-th instance in the training set is a triple in the form of (Pi, Qi, Ai), where Pi = (pi1, . . . , pi|Pi|), Qi = (qi1, . . . , qi|Qi|), and Ai = (ai1, . . . , ai|Ai|) (pi\u00b7, qi\u00b7, ai\u00b7 \u2208 V ). Owing to the disagreement among annotators, there could be more than one correct answer for the same question; and the k-th answer to Qi is denoted by Aki = {aki1, . . . , aki|Aki |}. An answer candidate for the i-th training example is defined as cm,ni , a sub-sequence in Pi, that spans from position m to n (1 \u2264 m \u2264 n \u2264 |Pi|). The ground truth answer Ai could be included in the set of all candidates Ci = {cm,ni |\u2200m,n \u2208 N+, subj(m,n, Pi) and 1 \u2264 m \u2264 n \u2264 |Pi|}, where subj(m,n, Pi) is the constraint put on the candidate chunk\nfor Pi, such as, \u201cc m,n i can have at most 10 tokens\u201d, or \u201cc m,n i must have a pre-defined POS pattern\u201d. To evaluate a system\u2019s performance, its top answer to a question is matched against the corresponding gold standard answer(s).\nRemark: Categories of RC Tasks Other simpler variants of the aforementioned RC task were explored in the past. For example, quiz-style datasets (e.g., MCTest (Richardson, Burges, and Renshaw 2013), MovieQA (Tapaswi et al. 2015)) have multiple-choice questions with answer options. Cloze-style datesets(Hermann et al. 2015; Hill et al. 2015; Onishi et al. 2016), usually automatically generated, have factoid \u201cquestion\u201ds created by replacing the answer in a sentence from the text with blank. For the answer selection task this paper focuses on, several datasets exist, e.g. TREC-QA for factoid answer extraction from multiple given passages, bAbI (Weston, Chopra, and Bordes 2014) designed for inference purpose, and the SQuAD dataset (Rajpurkar et al. 2016) used in this paper. To the best of our knowledge, the SQuAD dataset is the only one for both factoid and nonfactoid answer extraction with a question distribution more close to real-world applications."}, {"heading": "Baseline: Chunk-and-Rank Pipeline with Neural RC", "text": "In this section we modified a state-of-the-art RC system for cloze-style tasks for our answer extraction purpose, to see how much gap we have for the two type of tasks, and to inspire our end-to-end system in the next section. In order to make the cloze-style RC system to make chunk-level decision, we use the RC model to generate features for chunks, which are further used in a feature-based ranker like in (Rajpurkar et al. 2016). As a result, this baseline can be viewed as a deep learning based counterpart of the system in (Rajpurkar et al. 2016). It has two main components: 1) a standalone answer chunker, which is trained to produce overlapping candidate chunks, and 2) a neural RC model, which is used to score each word in a given passage to be used thereafter for generating chunk scores. Answer Chunking To reduce the errors generated by the rule-based chunker in (Rajpurkar et al. 2016), first, we capture the part-of-speech (POS) pattern of all answer subsequences in the training dataset to form a POS pattern trie tree, and then apply the answer POS patterns to passage Pi to acquire a collection of all subsequences (chunk candidates) Ci whose POS patterns can be matched to the POS pattern trie. This is equivalent to putting an constraint subj(m,n, Pi) to candidate answer chunk generation process that only choose the chunk with a POS pattern seen for answers in the training data. Then the sub-sequences Ci are used as answer candidates for Pi. Note that overlapping chunks could be generated for a passage, and we rely on the ranker to choose the best candidate based on features from the cloze-style RC system. Experiments showed that for > 90% of the questions on the development set, the ground truth answer is included in the candidate set constructed in such manner.\nFeature Extraction and Ranking For chunk ranking, we (1) use neural RCQA model to annotate each pij in passage Pi to get score sij , then (2) for every chunk c m,n i in passage i, collect scores (sim, . . . , sin) for all the (pim, ..., pin) contained within cm,ni , and (3) extract features on the sequence of scores (sim, . . . , sin) to characterize its scale and distribution information, which serves as the feature representation of cm,ni . In step (1) to acquire sij we train and apply a word-level single-layer Gated Attention Reader 2 (Dhingra et al. 2016), which has state-of-the-art performance on CNN/DailyMail cloze-style RC task. In step (3) for chunk cm,ni , we designed 5 features, including 4 statistics on (sim, . . . , sin): maximum, minimum, average and sum; as well as the count of matched POS pattern within the chunk, which serves as an answer prior. We use these 5 features in a state-of-the-art ranker (Ganjisaffar, Caruana, and Lopes 2011)."}, {"heading": "Dynamic Chunk Reader", "text": "The dynamic chunk reader (DCR) model is presented in Figure 1. Inspired by the baseline we built, DCR is deemed to be superior to the baseline for 3 reasons. First, each chunk has a representation constructed dynamically, instead of having a set of pre-defined feature values. Second, each passage word\u2019s representation is enhanced by word-by-word attention that evaluates the relevance of the passage word to the question. Third, these components are all within a single, end-to-end model that can be trained in a joint manner.\n2We tried using more than one layers in Gated Attention Reader, but no improvement was observed.\nDCR works in four steps. First, the encoder layer encodes passage and question separately, by using bidirectional recurrent neural networks (RNN). Second, the attention layer calculates the relevance of each passage word to the question. Third, the chunk representation layer dynamically extracts the candidate chunks from the given passage, and create chunk representation that encodes the contextual information of each chunk. Fourth, the ranker layer scores the relevance between the representations of a chunk and the given question, and ranks all candidate chunks using a softmax layer. We describe each step in details below. Encoder Layer We use bi-directional RNN encoder to encode Pi and Qi of example i, and get hidden state for each word position pij and qik.3 As RNN input, a word is represented by a row vector x \u2208 Rn. x can be the concatenation of word embedding and word features (see Fig. 1). The word vector for the t-th word is xt. A word sequence is processed using an RNN encoder with gated recurrent units (GRU) (Bengio, Goodfellow, and Courville 2015), which was proved to be effective in RC and neural machine translation tasks (Bahdanau, Cho, and Bengio 2015; Kadlec et al. 2016; Dhingra et al. 2016). For each position t, GRU computes ht with input xt and previous state ht\u22121, as:\nrt = \u03c3(Wrxt + Urht\u22121) (1) ut = \u03c3(Wuxt + Uuht\u22121) (2) h\u0304t = tanh(Wxt + U(rt ht\u22121)) (3) ht = (1\u2212 ut) \u00b7 ht\u22121 + ut \u00b7 h\u0304t (4)\nwhere ht, rt, and ut \u2208 Rd are d-dimensional hidden state, reset gate, and update gate, respectively; W{r,u}, W \u2208 Rn\u00d7d and U{r,u}, U \u2208 Rd\u00d7d are the parameters of the GRU; \u03c3 is the sigmoid function, and denotes elementwise production. For a word at t, we use the hidden state \u2212\u2192 h t from the forward RNN as a representation of the preceding context, and the\u2190\u2212h t from a backward RNN that encodes text reversely, to incorporate the context after t. Next, ht = [ \u2212\u2192 ht ; \u2190\u2212 ht ], the bi-directional contextual encoding of xt, is formed. [\u00b7; \u00b7] is the concatenation operator. To distinguish hidden states from different sources, we denote the hj of jth word in P and the hk of k-th word in Q as h p j and h q k respectively. Attention Layer Attention mechanism in previous RC tasks (Kadlec et al. 2016; Hermann et al. 2015; Sordoni, Bachman, and Bengio 2016; Dhingra et al. 2016; Cui et al. 2016a; Cui et al. 2016b) enables question-aware passage representations. We propose a novel attention mechanism inspired by word-by-word style attention methods (Rockta\u0308schel et al. 2015; Wang and Jiang 2015; Santos et al. 2016). For each pj , a question-attended representation vj is computed as follows (example index i is omitted for simplicity):\n\u03b1jk = h p j \u00b7 h q k, (5)\n\u03b2j = |Q|\u2211 k=1 \u03b1jkh q k (6)\n3We can have separated parameters for question and passage encoders but a single shared encoder for both works better in the experiments.\nvj = [h p j ;\u03b2j ] (7)\nwhere hpj and h q k are hidden states from the bi-directional RNN encoders (see Figure 1). An inner product, \u03b1jk, is calculated between hpj and every question word h q k. It indicates how well the passage word pj matches with every question word qk. \u03b2j is a weighted pooling of |Q| question hidden states, which serves as a pj-aware question representation. The concatenation of hpj and \u03b2j leads to a passage-question joint representation, vj \u2208 R4d.4 Next, we apply a second biGRU layer taking the vjs as inputs, and obtain forward and backward representations \u2212\u2192\u03b3j and\u2190\u2212\u03b3j \u2208 Rd, and in turn their concatenation, \u03b3j = [\u2212\u2192\u03b3j ;\u2190\u2212\u03b3j ]. Chunk Representation Layer A candidate answer chunk representation is dynamically created given attention layer output. We first decide the text boundary for the candidate chunk, and then form a chunk representation using all or part of those \u03b3j outputs inside the chunk. To decide a candidate chunk (boundary): we tried two ways: (1) adopt the POS trie-based approach used in our baseline, and (2) enumerate all possible chunks up to a maximum number of tokens. For (2), we create up to N (max chunk length) chunks starting from any position j in Pj . Approach (1) can generate candidates with arbitrary lengths, but fails to recall candidates whose POS pattern is unseen in training set; whereas approach (2) considers all possible candidates within a window and is more flexible, but over-generates invalid candidates.\nFor a candidate answer chunk cm,n spanning from position m to n inclusively, we construct chunk representation \u03b3m,n \u2208 R2d using every \u03b3j within range [m,n], with a function g(\u00b7). Formally,\n\u03b3m,n = g(\u03b3m, . . . , \u03b3n)\nWe experimented with several pooling functions (e.g., max, average) for g(\u00b7), and found out that, instead of pooling, the best function is to concatenate the hidden state of the first word in a chunk in forward RNN and that of the last word in backward RNN. Formally,\n\u03b3m,n = g(\u03b3m, . . . , \u03b3n) = [ \u2212\u2192\u03b3m;\u2190\u2212\u03b3n] (8)\nWe hypothesize that the hidden states at that two ends can better represent the chunk\u2019s contexts, which is critical for this task, than the states within the chunk. This observation also agrees with (Kobayashi et al. 2016). Ranker Layer Each chunk cm,n is evaluated on its context similarity to the question, by taking the cosine similarity between the chunk context representation \u03b3\u0304m,n acquired from chunk representation layer, and the question representation which is the concatenation of the last hidden state in forward RNN and the first hidden state in backward RNN. Thus, for training example i, we have the probability of the chunk cm,ni as\nP(cm,ni |Pi, Qi) = softmax(\u03b3 i m,n \u00b7 [ \u2212\u2212\u2192 hQi|Qi|; \u2190\u2212\u2212 hQi1 ]) (9)\n4We tried another word-by-word attention methods as in (Santos et al. 2016), which has similar passage representation input to question side. However, this does not lead to improvement due to the confusion caused by long passages in RC. Consequently, we used the proposed simplified version of word-by-word attention on passage side only.\nwhere \u03b3\u0304im,n denotes representation of the chunk c m,n i , \u2212\u2212\u2192 hQik or \u2190\u2212\u2212 hQik is the k-th hidden state output from question Qi\u2019s forward and backward RNN encoder, respectively. In runtime, the chunk with the highest probability is taken as the answer. In training, the following negative log likelihood is minimized:\nL = \u2212 N\u2211 i=1 logP(Ai|Pi, Qi) (10)\nNote that the i-th training instance is only used when Ai is included in the corresponding candidate chunk set Ci, i.e. \u2203m,nAi = cm,ni . The softmax in the final layer serves as the list-wise ranking module similar in spirit to (Cao et al. 2007)."}, {"heading": "Experiments", "text": "Dataset We used the Stanford Question Answering Dataset (SQuAD) (Rajpurkar et al. 2016) for the experiment. SQuAD came into our sight because it is a mix of factoid and non-factoid questions, a real-world data (crowd-sourced), and of large scale (over 100K question-answer pairs collected from 536 Wikipedia articles). Answers range from single words to long, variable-length phrase/clauses. It is a relaxation of assumptions by the cloze-style and quiz-style RC datasets in the Problem Definition section. Features The input vector representation of each word w to encoder RNNs has six parts including a pre-trained 300- dimensional GloVe embedding (Pennington, Socher, and Manning 2014) and five features (see Figure 1): (1) a onehot encoding (46 dimensions) for the part-of-speech (POS) tag of w; (2) a one-hot encoding (14 dimensions) for named entity (NE) tag of w; (3) a binary value indicating whether w\u2019s surface form is the same to any word in the quesiton; (4) if the lemma form of w is the same to any word in the question; and (5) if w is caplitalized. Feature (3) and (4) are designed to help the model align the passage text with question. Note that some types of questions (e.g., \u201cwho\u201d, \u201cwhen\u201d questions) have answers that have a specific POS/NE tag pattern. For instance, \u201cwho\u201d questions mostly have proper nouns/persons as answers and \u201cwhen\u201d questions may frequently have numbers/dates (e.g., a year) as answers. Thus, we believe that the model could exploit the co-relation between question types and answer POS/NE patterns easier with POS and NE tag features. Implementation Details We pre-processed the SQuAD dataset using Stanford CoreNLP tool5 (Manning et al. 2014) with its default setting to tokenize the text and obtain the POS and NE annotations. To train our model, we used stochastic gradient descent with the ADAM optimizer (Kingma and Ba 2014), with an initial learning rate of 0.001. All GRU weights were initialized from a uniform distribution between (-0.01, 0.01). The hidden state size, d, was set to 300 for all GRUs. The question bi-GRU shared parameters with the passage bi-GRU, while the attention-based passage bi-GRU had its own parameters. We shuffled all training examples at the beginning of each epoch and adopted a\n5 stanfordnlp.github.io/CoreNLP/\ncurriculum learning approach (Bengio et al. 2009), by sorting training instances by length in every 10 batches, to enable the model start learning from relatively easier instances and to harder ones. We also applied dropout of rate 0.2 to the embedding layer of input bi-GRU encoder, and gradient clipping when the norm of gradients exceeded 10. We trained in mini-batch style (mini-batch size is 180) and applied zero-padding to the passage and question inputs in each batch. We also set the maximum passage length to be 300 tokens, and pruned all the tokens after the 300-th token in the training set to save memory and speed up the training process. This step reduced the training set size by about 1.6%. During test, we test on the full length of passage, so that we don\u2019t prune out the potential candidates. We trained the model for at most 30 epochs, and in case the accuracy did not improve for 10 epochs, we stopped training.\nFor the feature ranking-based system, we used jforest ranker (Ganjisaffar, Caruana, and Lopes 2011) with LambdaMART-RegressionTree algorithm and the ranking metric was NDCG@10. For the Gated Attention Reader in baseline system, we replicated the method and use the same configurations as in (Dhingra et al. 2016). Results Table 2 shows our main results on the SQuAD dataset. Compared to the scores reported in (Wang and Jiang 2016), our exact match (EM) and F1 on the development set and EM score on the test set are better, and F1 on the test set is comparable. We also studied how each component in our model contributes to the overall performance. Table 3 shows the details as well as the results of the baseline ranker. As the first row of Table 3 shows, our baseline system improves 10% (EM) over Rajpurkar et al. (2016) (Table 2, row 1), the feature-based ranking system. However when compared to our DCR model (Table 3, row 2), the baseline (row 1) is more than 12% (EM) behind even though it is based on the state-of-the-art model for cloze-style RC tasks. This can be attributed to the advanced model structure and end-to-end\nmanner of DCR. We also did ablation tests on our DCR model. First, replacing the word-by-word attention with Attentive Reader style attention (Hermann et al. 2015) decreases the EM score by about 4.5%, showing the strength of our proposed attention mechanism. Second, we remove the features in input to see the contribution of each feature. The result shows that POS feature (1) and question-word feature (3) are the two most important features. Finally, combining the DCR model with the proposed POS-trie constraints yields a score similar to the one obtained using the DCR model with all possible n-gram chunks. The result shows that (1) our chunk representations are powerful enough to differentiate even a huge amount of chunks when no constraints are applied; and (2) the proposed POS-trie reduces the search space at the cost of a small drop in performance. Analysis To better understand our system, we calculated the accuracy of the attention mechanism of the gated attention reader used in our deep learning-based baseline. We found that it is 72% accurate i.e., 72% of the times a word with the highest attention score is inside the correct answer span. This means that, if we could accurately detect the boundary around the word with the highest attention score to form the answer span, we could achieve an accuracy close to 72%. In addition, we checked the answer recall of our candidate chunking approach. When we use a window size of 10, 92% of the time, the ground truth answer will be included in the extracted Candidate chunk set. Thus the upper bound of the exact match score of our baseline system is around 66% (92% (the answer recall) \u00d7 72%). From the results, we see our DCR system\u2019s exact match score is at 62%. This shows that DCR is proficient at differentiating answer spans dynamically.\nTo further analyze the system\u2019s performance while predicting answers of different lengths, we show the exact match (EM) and F1 scores for answers with lengths up to 10 tokens in Figure 2(a). From the graph, we can see that, with the increase of answer length, both EM and F1 drops, but in different speed. The gap between F1 and exact match also widens as answer length increases. However, the model\nstill yields a decent accuracy when the answer is longer than a single word. Additionally, Figure 2(b) shows that the system is better at \u201cwhen\u201d and \u201cwho\u201d questions, but performs poorly on \u201cwhy\u201d questions. The large gap between exact match and F1 on \u201cwhy\u201d questions means that perfectly identifying the span is harder than locating the core of the answer span.\nSince \u201cwhat\u201d, \u201cwhich\u201d, and \u201chow\u201d questions contain a broad range of question types, we split them further based on the bigram a question starts with, and Figure 3 shows the breakdown for \u201cwhat\u201d questions. We can see that \u201cwhat\u201d questions asking for explanations such as \u201cwhat happens\u201d and \u201cwhat happened\u201d have lower EM and F1 scores. In contrast, \u201cwhat\u201d questions asking for year and numbers have much higher scores and, for these questions, exact match scores are close to F1 scores, which means chunking for these questions are easier for DCR."}, {"heading": "Related Work", "text": "Attentive Reader was the first neural model for factoid RCQA (Hermann et al. 2015). It uses Bidirectional RNN (Cho et al., 2014; Chung et al.,2014) to encode document and query respectively, and use query representation to match with every token from the document. Attention Sum Reader (Kadlec et al. 2016) simplifies the model to just predicting positions of correct answer in the document and the training speed and test accuracy are both greatly improved on the CNN/Daily Mail dataset. (Chen, Bolton, and Manning 2016) also simplified Attentive Reader and reported higher accuracy. Window-based Memory Networks (MemN2N) is introduced along with the CBT dataset (Hill et al. 2015), which does not use RNN encoders, but embeds contexts as memory and matches questions with embedded contexts. Those models\u2019 mechanism is to learn the match between answer context with question/query representation. In contrast, memory enhanced neural networks like Neural Turing Machines (Graves, Wayne, and Danihelka 2014) and its variants (Zhang, Yu, and Zhou 2015; Gulcehre et al. 2016; Zaremba and Sutskever 2015) were also potential candidates for the task, and Gulcehre et al. (2016) reported results on the bAbI task, which is worse than memory networks. Similarly, sequence-to-sequence models were also used (Yu et\nal. 2015; Hermann et al. 2015), but they did not yield better results either.\nRecently, several models have been proposed to enable more complex inference for RC task. For instance, gated attention model (Dhingra et al. 2016) employs a multi-layer architecture, where each layer encodes the same document, but the attention is updated from layer to layer. EpiReader (Trischler et al. 2016b) adopted a joint training model for answer extractor and reasoner, where the extractor proposes top candidates, and the reasoner weighs each candidate by examining entailment relationship between question-answer representation and the document. An iterative alternating attention mechanism and gating strategies were proposed in (Sordoni, Bachman, and Bengio 2016) to optimize the attention through several hops. In contrast, Cui et al. (2016a; 2016b) introduced fine-grained document attention from each question word and then aggregated those attentions from each question token by summation with or without weights. This system achieved the state-of-the-art score on the CNN dataset. Those different variations all result in roughly 3-5% improvement over attention sum reader, but none of those could achieve higher than that. Other methods include using dynamic entity representation with maxpooling (Kobayashi et al. 2016) that aims to change entity representation with context, and Weissenborn\u2019s (2016) system, which tries to separate entity from the context and then matches the question to context, scoring an accuracy around 70% on the CNN dataset.\nHowever, all of those models assume that the answers are single tokens. This limits the type of questions the models can answer. Wang and Jiang (2016) proposed a matchlstm and achieved good results on SQuAD. However, this approach predicts a chunk boundary or whether a word is part of a chunk or not. In contrast, our approach explicitly constructs the chunk representations and similar chunks are compared directly to determine correct answer boundaries."}, {"heading": "Conclusion", "text": "In this paper we proposed a novel neural reading comprehension model for question answering. Different from the previously proposed models for factoid RCQA, the proposed model, dynamic chunk reader, is not restricted to predicting a single named entity as an answer or selecting an answer from a small, pre-defined candidate list. Instead, it is capable of answering both factoid and non-factoid questions as it learns to select answer chunks that are suitable for an input question. DCR achieves this goal with a joint deep learning model enhanced with a novel attention mechanism and five simple yet effective features. Error analysis shows that the DCR model achieves good performance, but still needs to improve on predicting longer answers, which are usually non-factoid in nature."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "This paper proposes dynamic chunk reader (DCR), an end-toend neural reading comprehension (RC) model that is able to extract and rank a set of answer candidates from a given document to answer questions. DCR is able to predict answers of variable lengths, whereas previous neural RC models primarily focused on predicting single tokens or entities. DCR encodes a document and an input question with recurrent neural networks, and then applies a word-by-word attention mechanism to acquire question-aware representations for the document, followed by the generation of chunk representations and a ranking module to propose the top-ranked chunk as the answer. Experimental results show that DCR achieves stateof-the-art exact match and F1 scores on the SQuAD dataset (Rajpurkar et al. 2016).", "creator": "LaTeX with hyperref package"}}}