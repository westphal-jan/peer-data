{"id": "1702.05383", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Feb-2017", "title": "Theorem Proving Based on Semantics of DNA Strand Graph", "abstract": "because of several technological limitations of traditional - based computing, for past few years a paradigm shift, from silicon assisted carbon, is occurring in computational world. dna computing has been considered to be quite promising in solving computational and reasoning problems together using simple strands. biotechnology, an important aspect of automated theorem proving and mathematical logic, is a rule of inference which leads to proof by contradiction technique for sentences in propositional logic and first - approximation logic. this can also be called refutation theorem - discovery. throughout your paper we have shown if the theorem proving high resolution refutation by dna computation can be guided by the semantics of process calculus and strand graph.", "histories": [["v1", "Wed, 15 Feb 2017 11:12:34 GMT  (386kb)", "http://arxiv.org/abs/1702.05383v1", "25 pages,12 figures"]], "COMMENTS": "25 pages,12 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["kumar s ray", "mandrita mondal"], "accepted": false, "id": "1702.05383"}, "pdf": {"name": "1702.05383.pdf", "metadata": {"source": "CRF", "title": "Theorem Proving Based on Semantics of DNA Strand Graph", "authors": ["KUMAR S. RAY"], "emails": ["ksray@isical.ac.in", "mandritamondal@gmail.com"], "sections": [{"heading": null, "text": "years a paradigm shift, from silicon to carbon, is occurring in computational world. DNA computing has been considered to be quite promising in solving computational and reasoning problems by using DNA strands. Resolution, an important aspect of automated theorem proving and mathematical logic, is a rule of inference which leads to proof by contradiction technique for sentences in propositional logic and first-order logic. This can also be called refutation theoremproving. In this paper we have shown how the theorem proving with resolution refutation by DNA computation can be represented by the semantics of process calculus and strand graph.\nKeywords: theorem proving, resolution refutation, strand graph, process calculus, DNA computing, propositional logic, proof by contradiction, strand displacement."}, {"heading": "1. Introduction", "text": "Though traditional silicon based computing has widely been used for past several\ndecades, it has a number of technological challenges in terms of requirement of memory, energy consumption, density and heat dissipation. In spite of the flexibility of this conventional technology, in some aspect, it has reached its limitations of design complexity and processing power. For miniaturization of the disadvantages, in modern age several alternatives to traditional silicon based technology have been proposed. In recent past DNA computing has been considered to be quite promising in solving computational and reasoning problems by using DNA strands which is a powerful tool for engineering at nano-scale [Adleman, 1994; Winfree et al., 1998; Benenson et al., 2001; Chang and Gou, 2003; Green et al., 2006; Akerkar and Sajja, 2009]. Thus, it can be said that a paradigm shift, from silicon to carbon, is occurring in computational world. The behaviour of DNA strands can be manipulated by standard DNA\noperations, and by setting up the strands of DNA in the right way, logical reasoning and decision making can be predicted [Yeung and Tsang, 1997; Ray and Mondal, 2011a; Ray and Mondal, 2011b; Ray and Mondal, 2016].\nIn this paper we have shown how the theorem proving with resolution refutation by DNA\ncomputation can be presented by the semantics of DNA strand graph.\nResolution, an important aspect of automated theorem proving and mathematical logic,\ncan be defined as a rule of inference which leads to proof by contradiction technique for sentences in propositional logic and first-order logic. Proof by contradiction can also be called refutation theorem-proving. When two clauses contains complementary literals, a valid rule of resolution generates a new clause from these two clauses. A propositional variable or its negation (i.e., P, \u00acP) is called a literal. Resolution is the only interference rule which needs to build a complete theorem prover, based on proof by contradiction and usually called resolution refutation [Chang and Lee, 1997].\nIn this paper we will use formal language theory as a tool of modeling and analysis of\nDNA operations performed for theorem proving in propositional logic. Though computing language is a complex task, formal language theory has taken the advantage of the idea of defining semantics and formalizing architecture of the wet lab procedure. In their research work Petersen, Lakin and Phillips [Petersen et. al., 2016] developed a domain-specific DNA strand displacement (DSD) language for modeling, simulating and analyzing DNA strand displacement systems. Different types of DNA structures are used for computation and reasoning. Thus, more general formal language is required which can encode arbitrary secondary structures of DNA strands and their interactions. Petersen et. al. [Petersen et. al., 2016] again redefine the syntax and semantic of the DSD language to extend the scope of the language. The proposed reformulated language is termed as process calculus. The expressive syntax and formal semantics of process calculus can model, simulate and analyze the mechanism of strand displacement of DNA strands with rich secondary structures such as branches and loops. The complex formal models used to solve reasoning and computation problems can have corresponding graphical representation which is defined as strand graph [Petersen et. al., 2016]."}, {"heading": "2. The Resolution Principle in Propositional Logic", "text": "Theorem proving, a subfield is of automated reasoning and mathematical logic, is used to\ndevelop computer programs. It shows that some statement, i.e. conjecture, is a logical consequence of a set of hypotheses. Theorem proving is applicable for several domains. In this paper we will perform theorem proving with resolution refutation in propositional logic [Chang and Lee, 1997].\nA proposition is an assertion which is either true or false but not both. Propositional\nvariable denotes arbitrary propositions with unspecified truth value such as P, Q, R. These variables can be connected with logical connectives, for example, and (conjunction \u2227), or (disjunction \u2228), not (negation \u00ac). A propositional variable or its negation is called a literal. For example, if P is a propositional variable, then P and \u00acP are both literals. An assertion which\ncontains at least one propositional variable is called to be in propositional form. Propositional logic, the branch of logic, is the study of propositions that are formed by other propositions by logical connectives. Propositional logic is also concerned on how their value depends on the truth value of their components. Apart from the above mentioned logical operators there are two more operators which are used in logic. One is called implication (\u21d2) and other is equivalence (\u21d4).\nPropositional resolution which is a rule of inference, is capable to generate theorem\nprover in the domain of propositional logic. Before the application of resolution principle in propositional logic, the premises and conclusions must be expressed in clausal form. A clausal sentence is either a literal or a disjunction of literals. If P and Q are propositional variable, then the clausal sentences are:\nP\n\u00acP\n\u00acP \u2228 Q A clause is the set of literals in a clausal sentence. The clauses of above mentioned\nclausal sentences are:\n{P}\n{\u00acQ}\n{\u00acP, Q}\nThe empty set {} is also a clause. It is equivalent to an empty disjunction and, therefore,\nis unsatisfiable. Thus, the clausal form and clauses in propositional logic can be defined as follows:\n(clausal form) := (clause) \u2227 (clause) \u2227 \u00b7 \u00b7 \u00b7 \u2227 (clause) (clause) := (literal) \u2228 (literal) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (literal)\nThe rules for conversion of arbitrary set of propositional logic sentences to equivalent set\nof clauses are given below:\n1. Implications:\nP \u21d2 Q \u2192 \u00acP \u2228 Q P \u21d0 Q \u2192 P \u2228 \u00acQ P \u21d4 Q \u2192 (\u00acP \u2228 Q) \u2227 (P \u2228 \u00acQ)\n2. Negations:\n\u00ac\u00acP \u2192 P \u00ac(P \u2227 Q) \u2192 \u00acP \u2228 \u00acQ \u00ac(P \u2228 Q) \u2192 \u00acP \u2227 \u00acQ\n3. Distribution:\nP \u2228 (Q \u2227 R) \u2192 (P \u2228 Q) \u2227 (P \u2228 R) (P \u2227 Q) \u2228 R \u2192 (P \u2228 R) \u2227 (Q \u2228 R) P \u2228 (P1 \u2228 ... \u2228 Pn) \u2192 P \u2228 P1 \u2228 ... \u2228 Pn (P1 \u2228 ... \u2228 Pn) \u2228 P \u2192 P1 \u2228 ... \u2228 Pn \u2228P\nP\u2227 (P1 \u2227 ... \u2227 Pn) \u2192 P \u2227 P1 \u2227 ... \u2227 Pn (P1 \u2227 ... \u2227 Pn) \u2227 P \u2192 P1 \u2227 ... \u2227 Pn \u2227 P\n4. Operators (O):\nP1 \u2228 ... \u2228 Pn \u2192 {P1, ... , Pn} P1 \u2227 ... \u2227 Pn \u2192 {P1}, ... , {Pn}\nResolution principle states that: \"For any two clauses C1 and C2, if there is a literal L1 in\nC1 that is complementary to a literal L2 in C2, then delete L1 and L2 from C1 and C2, respectively, and construct the disjunction of the remaining clauses. The constructed clause is a resolvent of C1 and C2.\" [Chang and Lee, 1997] For example, let,\nC1: P\nC2: \u00acP \u2228 Q. According to the resolution principle, the complementary pair of literal, i.e. P in C1 and \u00acP in C2, should be deleted to construct the resolventC3. The resolvent C3 is:\nC3: Q.\nAnother example is given below,\nC1: \u00acQ \u2228 R C2: \u00acP \u2228 Q \u2228 \u00acS\nThe resolvent of C1 and C2 is: C3: R \u2228 \u00acP \u2228 \u00acS If there is no complementary literal in C1 and C2, the no resolvent can be constructed from given clauses. For example,\nC1: \u00acR \u2228S C2: \u00acR \u2228 Q \u2228 T\nAnother property of resolution principle is, \"if two clauses C1 and C2 are given, a resolvent C of C1 and C2 is a logical consequence of C1 and C2\".[ Chang and Lee, 1997]\nWe have previously mentioned that, if the resolution principle generate empty clause {}\nfrom a set of clauses S, then it can be said that S is unsatisfiable. The following definition can be drawn from the principle of resolution:\n\"Given a set of clauses S, a (resolution) deduction of C from S is a finite sequence C1, C2,\n..., Ck of clauses such that each Ci, either is a clause in S or a resolvent of clauses preceding Ci, and Ck = C. A deduction of {} from S is called a refutation, or a proof of S.\" [Chang and Lee, 1997]\nThus, the resolution principle can be used to prove the unsatisfiability of a set of clauses.\nThis can be explained by the following examples.\nLet S is a set containing six clauses,\n\u2228 \u00ac \u2228 \u00ac \u2228 \u2228 \u00ac \u00ac \u00ac\nFrom (i) and (iii), the generated resolvent is,\n\u2228\nFrom (ii) and (iv), the generated resolvent is,\n\u00ac \u2228 \u00ac\nFrom (vii) and (viii), the generated resolvent is,\n\u2228 \u00ac\nFrom (ix) and (v), the generated resolvent is,\n\u00ac\nFrom (x) and (vi), the generated resolvent is,\n{}\nSince {} is derived from the set of clauses S by resolution, it can be said that the empty\nclause {} is the logical consequence of S. {} can only be a logical consequence of an unsatisfiable set of clauses. Hence, it is proved that S is unsatisfiable. Fig. 1 shows the deduction tree of the above deduction.\nThus, it can be said that resolution refutation or proof by contradiction proves a theorem\nby negating the statement to be proved. The negated statement is added to the set of premises which are known to be true. The theorem prover, generated by propositional resolution, proves the consistency of the negated goal. The inconsistency of the negated goal with the given set of premises implies that the original goal is consistent.\nLet, we want to prove a premise or axiom X from a set of axioms Z. The general steps of\nresolution refutation for proving X is given below:\nStep 1. All the premises or axioms of Z are expressed in clausal form. The set of clauses are denoted by S. Step 2. In the set of axioms expressed in clausal form negation of what is to be proved is added. Here, negation of X is added. Step 3. All these clauses are resolved together, producing new clauses, i.e. resolvents, which logically follow from them. Step 4. If the resolvent is an empty clause, a contradiction is generated. The process should be stopped as X is proved to be true. Step 5. Else if no resolvent can be generated, again stop the process; as X is proved to be false. Step 6. Else the resolvent is added to S and step 3 is repeated.\nIn this paper the theorem proving with resolution refutation by DNA strands are\nrepresented by the formal language of process calculus and strand graph semantics. The next section shows the syntax and semantics of process calculus and strand graph. [Petersen et. al., 2016]"}, {"heading": "3. Syntax and Semantics of Process Calculus and Strand Graph", "text": "In DNA computing DNA strands are used to perform computation. DNA strands are the\nstrings containing four DNA bases i.e. A, T, G, C. Formal language theory, which deals with the DNA strands, is used to model, simulate and analyze the concurrent communicating processes of DNA computation. There is a resemblance between generative grammar of formal language theory and the self-assembly and ligation of the DNA strands. Both generate new strings from previous string following some pre-defined rule. Thus, to represent the architecture of a model of DNA computation formal language is widely appreciated. The mechanism of strand displacements in DNA strands with rich secondary structures can be modeled, simulated and analyzed by a newly defined language by Petersen, Lakin and Phillips [Petersen et. al., 2016], termed as process calculus. Now we will discuss the formal syntax and semantics of process calculus to formulate the architectures of DNA models.\nA language is a set of valid sentences. The validity of language can be broken down into\ntwo things: syntax and semantics. The term syntax refers to grammatical structure of a language and the term semantics is concerned to the meaning of the vocabulary symbols arranged with that structure, often in relation to their truth and falsehood. Grammatical (syntactically) valid does not imply sensible (semantically) valid. In mathematics, computer science and linguistics, a formal language is a set of strings of symbols that may be constrained by rules that are specific to it [Ray and Mondal, 2016].\nIn process calculus, a process or program P is defined as a multiset of DNA strands <S>.\nProcess or program P ::= <S1> |...| <Si> where, i \u2265 0\nEach strand <S> contains one or more domains d. Domain is actually a sequence of DNA\nbases or nucleotides i.e. A, T, G, C.\nStrand S ::= d1 \u2026.. di where, i \u2265 0\nA domain d in a DNA strand is either free or bound with the complementary domain of\nany other DNA strand or to the same strand. A free domain is denoted by d. If the domain is bound by bond x them the bound domain is denoted by d!x. Let, an arbitrary domain is named r, then r* is the complementary domain to which r can bind by Watson-Crick base pairing. A domain is called toehold t^ if it is short enough to spontaneously unbind from its complement t^*.\nThe semantics of process calculus depends on some functions which determine whether a\nrule can be applied on a program. The functions are listed below;\n\u2022 The function comp(r) returns the complementary domain of domain r. Thus, it can be\nsaid that, comp(r) = r* and comp(r*) = r.\n\u2022 The function toehold(r) returns true if r is a toehold domain. Then we can also represent\ndomain r by r^.\n\u2022 The function adjacent(x, P) returns the set of bonds that are adjacent to bond x in\nprogram P.\n\u2022 The function hidden(x, P) returns true if one end of bond x occurs within a closed loop.\nThus, the specific domain cannot bind to its complementary sequence.\n\u2022 The function anchored(x, P) returns true if both ends of bond x are held \u201cclose\u201d to each\nother. Thus, bond x is a part of a stable junction.\n\u2022 The context C(S1, ..., Si) is defined as a process P containing sequences S1, ..., Si. \u2022 The function permute(S1, ..., Si) returns any possible permutation of sequences S1, ..., Si.\nNow, we will define the semantics of some rules of process calculus by the following figures\nand corresponding expression.\nFigure 2. Rule (RB)\nThe semantics of rule (RB) as shown in Fig. 2 can be presented as,\n\u00ac\u210e !, # $, $\u2217 &',{(})**+ # $! !, $\u2217! ! =\nThe semantics of rule (RU) as shown in Fig. 3 can be presented as,\n\u00ac. /\u210e0$ !, 10 \u210e02 $ = # $! !, $\u2217! ! &3,{4})**+ # $, $\u2217\nThe semantics of rule (R3) as shown in Fig. 4 can be presented as,\n. /\u210e0$ !, # $, $! !, $\u2217! ! &5,{(})**+ # $! !, $, $\u2217! ! =\nThe semantics of rule (RM) as shown in Fig. 5 can be presented as,\n6 . /\u210e0$ !7, \u2032 \u2026 \u2026 . /\u210e0$ !4, \u2032 # $! !7, $:! !7, $! !;, $:! !;, \u2026 . . $! !4 , $:! !4 &=,{(>\u2026..(?})*******+ # $! !7, $:! !;, $! !;, $:! !5, \u2026 . . $! !4, $:! !7 = \u2032\nNow we will illustrate the reduction rules of process calculus by the help of an example.\nWe take hairpin toehold exchange program with two invader strands as the example. The pictorial representation of the program is shown in Fig. 6.\nIn the illustrated example there are two invader strands and one template strands. One of\nthe two single stranded invader strands has two domains (t^, p) and the other has three domains (r*, q*, p*). The template strand with secondary hairpin structure contains five domains (p, q, r, q*, p*, t^*). The program codes of the strands are given below;\n. $ = < 1^ B > | . $ = < $\u2217 E\u2217 B\u2217 >| 1 FB2.1 = < B! G7 E! H7 $ E\u2217! H7 B\u2217! G7 1^\u2217 > The function toehold(t) returns true for the single stranded invader strand. Thus, the domain at 5\u2019 end of the strand is denoted by t^. This domain has a free complementary domain t^* in the template strand as the program matches the context C(t, t*). It can be written that P=C(t^!x, t^*!x) as one end of the bond x is not in closed loop, i.e. hidden(x, P) returns false. Thus, the program P' can be produced by the rule (RB) which forms the new bond x between the single stranded invader strand and the template. The program code is shown below;\n< I^ B > | < $\u2217 E\u2217 B\u2217 >| < B! G7 E! H7 $ E\u2217! H7 B\u2217! G7 I^\u2217 > &' )*+ < I^! J B > | < $\u2217 E\u2217 B\u2217 >| < B! G7 E! H7 $ E\u2217! H7 B\u2217! G7 I^\u2217! J > As domain t is toehold, it is short enough to unbind spontaneously. Here the program\nanchored(x, P) returns false as the bond x is not a part of a junction that holds both ends of the bond close to each other. Thus, the rule (RU) can also occur which breaks the bond x between the single stranded invader strand and the template to produce the program C(t, t*). It is reversible of rule (RB). The program code is shown below;\n< I^! J B > | < $\u2217 E\u2217 B\u2217 >| < B! G7 E! H7 $ E\u2217! H7 B\u2217! G7 I^\u2217! J > &3 )*+ < I^ B > | < $\u2217 E\u2217 B\u2217 >| < B! G7 E! H7 $ E\u2217! H7 B\u2217! G7 I^\u2217 > In the next step toehold mediated branch migration and strand displacement occurs.\nStrand displacement is the process through which two DNA strands with partial or full complementarity hybridize to each other, displacing one or more pre-hybridized strands [Zhang and Seelig, 2011]. The free domain p of the invader strand has a complementary domain p* in the template strand which is already bound by the bond y1. In this step the program matches the context C(p, p!y1, p*!y1). We have to check if an anchored bond can be formed between the invader strand and the template to produce the program P\u2019 = C(p!y2, p, p*! y2). The formation of the new bond y2 is possible by applying rule (R3) as there is a bond x that is immediately adjacent to y2 in P\u2019, holding both ends of bond y2 close to each other.\n< 1^! K > | < $\u2217 E\u2217 B\u2217 >| < K! LM E! H7 $ E\u2217! H7 K\u2217! LM 1^\u2217! > &5 )*+ < 1^! K! LN > | < $\u2217 E\u2217 B\u2217 >| < K E! H7 $ E\u2217! H7 K\u2217! LN 1^\u2217! > Next, the other invader strand comes in action. There is a free domain p* at 3\u2019 end of the\ninvader strand. This domain has a free complementary domain p in the 5\u2019 end of the template strand. The formation of a new bond y3 is possible as one end of the bond does not occur in closed loop, i.e. the bond is not hidden. The formation of the bond according the rule (RB) is shown in the following program code;\n< 1^! B! G; > | < $\u2217 E\u2217 K\u2217 >| < K E! H7 $ E\u2217! H7 B\u2217! G; 1^\u2217! > &' )*+ < 1^! B! G; > | < $\u2217 E\u2217 K\u2217! LO >| < K! LO E! H7 $ E\u2217! H7 B\u2217! G; 1^\u2217! > This reaction is a reversible reaction. The previous step can be restored by rule (RU).\n< 1^! B! G; > | < $\u2217 E\u2217 K\u2217! LO >| < K! LO E! H7 $ E\u2217! H7 B\u2217! G; 1^\u2217! > &3 )*+ < 1^! B! G; > | < $\u2217 E\u2217 K\u2217 >| < K E! H7 $ E\u2217! H7 B\u2217! G; 1^\u2217! > The p* domain of the invader strand is not a toehold as it is a long domain and does not\nunbind spontaneously. But, when p* hybridize to the template strand; it leads to brand migration and strand displacement. This process breaks the unanchored bond z1 and opens the hairpin of the template strand to produce the program C(q, q*). The anchored bonds, first z2 then u, can be formed between the invader strand and the template. There is a bond y3 immediately adjacent to z2 in this process, holding the both ends of z2 close to each other. Again after formation of z2 between q* domain of the invader strand and its complementary domain in the template strand, it holds the both ends of bond u close to each other. Thus, new bond u is formed between r* domain of the invader strand and its complementary domain r in the template strand. This process occurs by applying rule (R3).\n< 1^! B! G; > | < P\u2217 Q\u2217 B\u2217! G5 >| < B! G5 Q! RM P Q\u2217! RM B\u2217! G; 1^\u2217! > &5 )*+ < 1^! B! G; > | < P\u2217! S Q\u2217! RN B\u2217! G5 >| < B! G5 Q! RN P! S Q\u2217 B\u2217! G; 1^\u2217! >"}, {"heading": "3.1. Strand Graph", "text": "In the previous section we have described the syntax and semantics of process calculus\nwhich is used to model, simulate and analyze the concurrent communicating processes of DNA computation. This formal language is widely appreciated for dealing with strand displacements in DNA sequences having secondary structures, like, branches, loops etc. But there are some limitations of process calculus in implementation of different rules, because of the complexity of pattern matching on arbitrary process contexts. To overcome this problem Petersen et. al. [Petersen et. al., 2016] introduces the concept of strand graph.\nGraphs are mathematical structures which are used to model pair-wise relations between\nobjects. The graphical structures are formed by vertices or nodes which are connected by edges. In a graph if there is no distinction between the two nodes associated with each edge, the graph is said to be undirected. In directed graph each edge has a specific direction from one node to another. In strand graph the expressive power of graph theory can represent rich secondary structures of DNA strands and implement the complex rules. Now we will summarize the notation for strand graph theory as demonstrated in the paper [Petersen et. al., 2016].\nStrand graph is defined by G = (V, length, colour, A, toehold, E), where, V = {1,\u2026\u2026, N} denotes the set of vertices of the graph. Each vertex, shown by natural\nnumber, represents a DNA strand. There are different sites in a vertex. Each site s denotes a specific domain of that strand. The vertices are drawn as circular arrow with a specific direction\ni.e. from 5\u2019 to 3\u2019 of a DNA strand. The sites are placed in a vertex according to the occurrences of the corresponding domain in the specific strand. Site is represented as s = (s, n), where v is a vertex and n is the position of site s in vertex v. Both v and n are natural numbers.\nlength: denotes a function which assigns a specific length to each vertex. Lengths are\nrepresented by natural numbers.\ncolour: denotes a function which assigns a specific colour to each vertex. Colours are\nalso represented by natural numbers. Thus, it would be easier to identify a particular vertex representing a specific DNA strand. Colour is actually a function of the length. If v1 and v2 are two vertices of a strand graph, then, length(v1) = length(v2) \u21d2 colour(v1) = colour(v2). A is the set of admissible edges of the strand graph. If two domains of the DNA strands are complementary, they are able to hybridize with each other by forming a bond. Then an edge can be drawn between the sites of the vertices representing those domains. Throughout the performance of the whole program, all bonds those are allowed to be formed are represented by the set of admissible edges. Edge is represented as e = {s1, s2} where s1 and s2 are two sites and s1 \u2260 s2. Again, we can write that, e = {(v1, n1), (v2, n2)}.\nToehold is a function that returns true if admissible edges exist between the short\ndomains i.e. toehold domains and returns false for admissible edges between the long domains. E is the set of current edges of the strand graph which is expressed as {e1, \u2026.., eI}\u2286 A. In the contrary of other above mentioned information to define strand graph, E is non-static information. During the execution of the program the set of current edges changes with the change in reduction rules. A domain in a DNA strand cannot bind with more than one domain at any given instant i.e. only one edge can be drawn from a given site at that point of time. This is can be expressed as, (i \u2260 j) \u21d2 ei \u2229 ej = \u2205. Now, we will illustrate the representation of DNA strand graph by an example. Fig. 7 shows the mechanism of toehold-mediated four-way strand displacement and branch migration. This mechanism consists of four DNA strands. In this program two partially double stranded DNA sequences simultaneously exchange the strands. Four-way strand displacement method is initiated by unhybridized toehold domains. The intermediate structure of this program is called Holliday junction.\nThe program codes of the DNA strands of the above described mechanism in the initial\nstate are formed by process calculus. The codes of four strands are given below;\nStrand 1 < 7 > : < .^! V! !7 /^\u2217 > Strand 2 < ; > : < ^\u2217 V\u2217! !7 .^\u2217! > Strand 3 < 5 > : < /^ V\u2217! !; ^! W > Strand 4 < X > : < ^\u2217! W V! !; ^ > The DNA strand graph representing the initial state of toehold-mediated four-way strand\ndisplacement and branch migration mechanism is shown in Fig. 8.\nEach DNA strand in the program of toehold-mediated four-way strand displacement and\nbranch migration (Fig. 7) is represented by vertex in the DNA strand graph as shown in Fig. 8. The arrowheads of the vertices which are drawn as circular arrows indicate the 3\u2019 end of the DNA strand. Different arbitrary colours are assigned for the vertices in the graph. For example, vertex 1 which represents the strand type < .^! V! !7 /^\u2217 > is assigned the colour pink. The domains of the DNA strands are presented by the sites which are placed on the vertices according to their occurrences. All the admissible edges are drawn in the strand graph. The current edges are represented by red lines and rests of the edges are represented by blue lines. The toehold edges are drawn by dashed lines.\nThe strand graph as shown in Fig. 8 is defined by G = (V, length, colour, A, toehold, E),\nwhere,"}, {"heading": "V = {1, 2, 3, 4}.", "text": "length = {1 \u2192 3, 2 \u2192 3, 3\u2192 3, 4 \u2192 3}. colour = {1 \u2192 1, 2 \u2192 2, 3\u2192 3, 4 \u2192 4}. A = {(1, 1), (2, 3)}, {(1, 2), (2, 2)}, {(1, 2), (3, 2)}, {(1, 3), (3, 1)}, {(2,\n1), (4, 3)}, {(2, 2), (4, 2)}, {(3, 2), (4, 2)}, {(3, 3), (4, 1)}.\ntoehold = {{(1, 1), (2, 3)} \u2192 true, {(1, 3), (3, 1)} \u2192 true, {(2, 1), (4, 3)} \u2192\ntrue, {(3, 3), (4, 1)} \u2192 true, other \u2192 false}."}, {"heading": "E = {(1, 1), (2, 3)}, {(1, 2), (2, 2)}, {(3, 2), (4, 2)}, {(3, 3), (4, 1)}.", "text": "Now, we will illustrate some functions which are used to define DNA strand graph. Let,\nthe program of toehold-mediated four-way strand displacement and branch migration is denoted by P. P = < 7 > | < ; > | < 5 > | < X > = < .^! V! !7 /^\u2217 > | < ^\u2217 V\u2217! !7 .^\u2217! > | < /^ V\u2217! !; ^! W > | < ^\u2217! W V! !; ^ >\nThe DNA strand graph representing program P is G = (V, length, colour, A, toehold, E).\nThe function tp omits all the bonds from a specific domain. For example tp(V! !7) = b. The first strand, < 7 > = < .^! V! !7 /^\u2217 > has three domains. It can be written that the type tp( 7) = tp(.^! ), tp(V! !7), tp(/^\u2217) = .^, V, /^\u2217. The function representing the length of 7 is len( 7) = 3. The strand types are numbered according to their appearance in the given program (for example, t1, t2, t3, t4) depending on which the colour function is defined.\nThe domain function dom indicates a specific domain of the strand graph. For the DNA\nstrand graph G corresponding to program P, dom(2, 3) indicates the 3 rd domain of ;. Another domain function ndom(2, 3) indicates the name of dom(2, 3) after omitting all bonds.\nThe toehold function toe defines the toehold of a specific DNA strand. For strand graph\nG, toe(3, 1) returns true which indicates ndom(3, 1) is a toehold domain.\nA is the set of admissible edges of G. {(3, 3), (4, 1)} is the edge joining the 3 rd domain of\n5 and the 1st domain of X and {(3, 3), (4, 1)} \u2208 A. Then, it can be written that, 3, 3 [\u2194 4, 1 . The following definition can be written to define a DNA strand graph [Petersen et. al.,\n2016] using the above explained function;\nV = {1, ....., N} where, N is natural number length(v) = len(Sv) colour(v) = i \u21d4 tp(Sv) =ti 7, 7 [\u2194 ;, ; \u21d4 ndom( 7, 7) = comp(ndom( ;, ;)) toehold({_7, _;}) \u21d4 toe(_7) 7, 7 \u2194\u0300 ;, ; \u21d4 \u2203d, j. dom( 7, 7) = d!j \u2227 dom( ;, ;) = comp(d)!j\nwhere, d denotes the domain and j denotes the bond between ( 7, 7) and ( ;, ;).\nIn the next section we will illustrate the semantics of reduction rules."}, {"heading": "3.1.1. Semantics of reduction rules", "text": "DNA strand graph transits from one state to another by following the reduction rules. The\nchange in state of the strand graph is indicated by the change in colours of the edges among vertices. The semantics of the reduction rules need definitions of few functions [Petersen et. al., 2016].\nThe function sites(E) returns the set of sites in set of current edges E which can be\nexpressed by {_|\u2203 \u2208 b. _ \u2208 }. If two edges in a strand graph not only exist between the same pair of vertices but also the corresponding sites are adjacent to each other, the two edges are said to be adjacent. The function adjacent(e, E) returns the set of adjacent edges to edge e from the set E.\nThe function hidden(e, E) returns true if one of the ends of edge e from the set E occurs\nwithin a closed loop.\nThe function anchored(e, E) returns true if the edge e from the set E is a part of a stable\njunction by holding the corresponding sites close to each other.\nNow we will describe the semantics of reduction rules through which the program occurs\nand reaches to its final state.\nRule (GB)\nLet the sites of two vertices of a DNA strand graph is joined by admissible edge x which\nis not current at that instant. If those two sites are not preoccupied and open to each other, according to rule (GB) x can be converted into current edge. The semantics of rule (GB) is given below;\nc \u2208 d\\b \u2229 _ 1 _ b = \u2205 \u00ac\u210e , b b g',{h})**+ b \u222a { }\nRule (GU)\nLet the sites of two vertices of a DNA strand graph is joined by admissible edge e and the\nsites represent toehold domain. Toehold domains are short enough to spontaneously unbind from its complement. Thus according to rule (GU) if the toehold domains are not anchored, the edge e can be removed from the current set E of the corresponding strand graph. The semantics of rule (GU) is given below;\nc \u2208 b 10 \u210e02 \u00ac. /\u210e0$ , b b g3,{j})**+ b\\{ }\nRule (G3)\nLet the sites of two vertices of a DNA strand graph is joined by admissible edge x\nwhich is not current at that instant. x can be joined to the set of current edges E even though one of the end sites is preoccupied by some other site forming a current edge e. x becomes current edge by removing e if the function anchored(x, E) returns true. This mechanism is termed as displacing path. The swapping of single bonds can form a long chain through the whole program. This mechanism is performed by reduction rule (G3). The semantics of rule (G3) is given below;\nc3 \u2208 b \u2208 d\\b = {_, _:} = {_, _::} _:: \u2209 _ 1 _ b . /\u210e0$ , b b g5,{h})**+ b{ } \u222a { }\nRule (GM)\nBy the reduction rule (GM) the mechanism of displacing path i.e. swapping of single\nbonds makes a loop. The semantics of rule (GM) is given below;\nc6 \u2208 {1, \u2026 , l} 4 \u2208 b 4 \u2208 d\\b 4 = {_4, _4:} 4 = {_4m7: , _4} _n: = _o: . /\u210e0$ 4 , b b g=,{h>,\u2026., hp})********+ b\\{ 7, \u2026 . , o} \u222a { 7, \u2026 . , o}"}, {"heading": "3.1.2. Graphical illustration of reduction rules", "text": "In Fig. 7 the entire mechanism of toehold-mediated four-way strand displacement and\nbranch migration, which is graphically interpreted in Fig. 8, is shown. In this section we will pictorially describe (Fig. 9) how the reduction rules work in DNA strand graph G as shown in Fig. 8.\nIn section 2 of this paper we have discussed theorem proving with resolution refutation in\npropositional logic. Section 3 illustrates the syntax and semantic of process calculus and DNA strand graph. In next section we will show how theorem proving with resolution refutation can be performed by DNA computation. We will implement process calculus and strand graph in the domain of theorem proving."}, {"heading": "4. Theorem Proving Based on Process Calculus and DNA Strand Graph Semantics", "text": "Resolution refutation or proof by contradiction proves a theorem by negating the\nstatement to be proved. If the theorem prover, generated by propositional resolution, proves the inconsistency of the negated goal with the given set of premises, this implies that the original goal is consistent. Thus, the principle of resolution refutation is used to prove the unsatisfiability of a set of clauses. In Fig. 1 of section 2 we have shown the deduction tree of a set S containing six clauses.\n\u2228 \u00ac \u2228 \u00ac \u2228 \u2228 \u00ac \u00ac \u00ac\nIn the subsection 4.1 we will encode the above mentioned set of clauses in terms of DNA\nstrands. We will show how theorem proving by resolution refutation can be performed in DNA computation using DNA strands and elementary operations to manipulate the strands. In subsection 4.2 the theorem proving is coded by process calculus. Subsection 4.3 shows the representation of the entire program by DNA strand graph and reduction rules."}, {"heading": "4.1. Theorem proving by resolution refutation in DNA computation", "text": "Lee, Park, Jang, Chai and Zhang [Lee et. al., 2002] performed theorem proving by\nresolution refutation using DNA strands with the help of some elementary operations to manipulate the strands. To prove the unsatisfiability of the set of clauses S by resolution refutation in DNA computation, few steps should be followed.\nStep 1.\nThe clauses of set S contain five propositional variables or literals. Each literal is encoded\nby arbitrarily chosen ten bases long single-stranded DNA oligonucleotide. The negation of each literal is encoded by the complementary sequence of the corresponding DNA strand. The encoded single-stranded DNA oligonucleotides are listed in Table 1.\nStep 2.\nAll the clauses are encoded in terms single-stranded DNA oligonucleotides. To encode\nthe clauses, the DNA strands representing literals of the corresponding clause are concatenated. The encoded clauses are listed in Table 2.\nStep 3.\nAll the single-stranded DNA oligonucleotides as shown in Table 2 are mixed in a test\ntube and allowed to hybridize with each other. In this step the principle of resolution refutation is implemented by DNA strand hybridization. The DNA strands encoding the clauses hybridize with each other to generate resolvent. The resolvent may be partially double-stranded or full double-stranded DNA sequence. Fully double-stranded DNA sequence denotes empty clause {}.\nStep 4.\nThe resultant hybridized DNA strands are allowed to be ligated using specific ligase\nenzyme.\nStep 5.\nThe ligated sequences obtained from step 4 are amplified using specific primers by\npolymerase chain reaction. The primers are chosen specifically so that unwanted sequences are not amplified.\nStep 6.\nGel electrophoresis is performed to verify whether fully double-stranded DNA sequence\nis present in the resultant amplified sequences. Fully double-stranded DNA sequence denotes empty clause {}.\nIf an empty clause {} is derived from the set of clauses S by resolution, it is proved that S\nis unsatisfiable. Thus, the fully double-stranded resultant DNA sequence (resolvent) establishes the unsatisfiability of S. The given theorem is proved by contradiction. If all the resultant sequences are single-stranded or partially double-stranded, then it is proved that S is satisfiable.\nFig. 10 is the pictorial representation of the process of theorem proving by resolution\nrefutation with DNA strands. We also compare the process with deduction tree shown in Fig. 1 of section 2."}, {"heading": "4.2. Theorem proving by resolution refutation coded by process calculus", "text": "In this section we will code theorem proving by resolution refutation by process calculus\nusing the syntax and semantics described in section 3. We have to prove the unsatisfiability of the set of clauses S.\nLet the entire program is denoted by P. The program P consists of six clauses which are\nencoded by single-stranded DNA oligonucleotides. P is defined as the multiset of six DNA strands.\nP = <S1> | <S2> | <S3> | <S4> | <S5> | <S6>\nTherefore,\nP = < \u2217 > | < \u2217 \u2217 > | < > | < \u2217 > | < \u2217 > | < >\nEvery literal is encoded by arbitrarily chosen ten bases long single-stranded DNA\nsequence. The DNA strand encoding the negation of each literal is the Watson-Crick complement of the corresponding literal. Thus, the DNA strand encoding the negation of literal\nP, i.e. \u00acP, is named as P*. For all the literals the same rule has been followed. Each of the strands <S1> and <S2> contains three domains as given by the program code. The remaining strands, i.e. <S3>, <S4>, <S5> and <S6>, contain one domain each. From the program code it is clear that at the initial state of the program all the domains of the strands are free. As the domain Q* of <S1> and the domain Q of <S3> are not bound with any other domain, the program matches the context C(Q, Q*). It can be written that P=C(Q!i, Q*!i) as one end of the bond i is not in closed loop, i.e. hidden(i, P) returns false. Thus, the program P' can be produced by the rule (RB) which forms the new bond i between the second domain of <S1> and the only domain of <S3>. The program code is given below;\n< \u2217 > | < \u2217 \u2217 > | < > | < \u2217 > | < \u2217 > | < > &' )*+ < \u2217! > | < \u2217 \u2217> | < ! > | < \u2217> | < \u2217> | < >\nAs the domains V of <S2> and V* of <S4> are free, the program matches the context C(V,\nV*). The new bond j can be formed joining these two domains by the rule (RB) as one end of the bond is not hidden. The program code is given below;\n< \u2217! > | < \u2217 \u2217 > | < ! > | < \u2217 > | < \u2217 > | < > &' )*+ < \u2217! > | < \u2217 ! ! \u2217> | < ! > | < \u2217! ! > | < \u2217> | < >\nNow, the second domains of the strands <S1> and <S2> are bound. The domains R and R*\nat 3\u2019 ends of the strands <S1> and <S2> are free. Thus, the program matches the context C(R, R*). The new bond k can be formed between these domains by rule (RB). The ends of the bond do not occur in closed loop. The program code is given below;\n< \u2217! > | < \u2217 ! ! \u2217 > | < ! > | < \u2217! ! > | < \u2217 > | < > &' )*+ < \u2217! ! W> | < \u2217 ! ! \u2217! W > | < ! > | < \u2217! ! > | < \u2217> | < >\nAgain, rule (RB) comes into action and a new bond l is formed between the free domains\nP of <S1> and P* of <S5> as one end of the l is not hidden. The program code is given below;\n< \u2217! ! W > | < \u2217 ! ! \u2217! W > | < ! > | < \u2217! ! > | < \u2217 > | < > &' )*+ < ! 2 \u2217! ! W> | < \u2217 ! ! \u2217! W > | < ! > | < \u2217! ! > | < \u2217! 2 > | < >\nExcept the domains U* of <S2> and U of <S6>, all the domains of program P is bound.\nThe program matches the context C(U, U*). New bond m can be formed between these two domains by rule (RB). The program code is given below;\n< ! 2 \u2217! ! W > | < \u2217 ! ! \u2217! W > | < ! > | < \u2217! ! > | < \u2217! 2 > | < > &' )*+ < ! 2 \u2217! ! W> | < \u2217! F ! ! \u2217! W > | < ! > | < \u2217! ! > | < \u2217! 2 > | < ! F>\nForm the program code it is clear that all the domains of the given program are bound.\nThus, the resultant strand is complete double stranded DNA sequence which indicates empty clause {}. This proves the unsatisfiability of the set of clauses S."}, {"heading": "4.3. Theorem proving by resolution refutation using DNA strand graph and reduction rules", "text": "This section is the graphical representation of program P which has been described by\nprocess calculus using program codes in the previous section. The unsatisfiablity of the set of clauses S is demonstrated using DNA strand graph T. Initially the code of program P is represented by the expression, P = < \u2217 > | < \u2217 \u2217 > | < > | < \u2217 > | < \u2217 > | < > Graphical depiction of program P is shown in Fig. 11.\nSix strands of P is represented by six vertices in T (Fig. 11). Different arbitrary colours\nare assigned for the vertices in the graph. The domains of the DNA strands are presented by the sites which are placed on the arrow-headed vertices according to their occurrences. All the edges of the strand graph T are admissible edges. Since, at the starting point of the program all the DNA sequences are single stranded i.e. initially the set of current edges is empty i.e. E = \u2205. The admissible edges are drawn by blue lines.\nThe initial state of DNA strand graph as shown in Fig. 11 is defined by T = (V, length,\ncolour, A, toehold, E), where,\nV = {1, 2, 3, 4, 5, 6}. length = {1 \u2192 3, 2 \u2192 3, 3\u2192 1, 4 \u2192 1, 5 \u2192 1, 6 \u2192 1}. colour = {1 \u2192 1, 2 \u2192 2, 3\u2192 3, 4 \u2192 4, 5 \u2192 5, 5 \u2192 6}."}, {"heading": "A = {(1, 1), (5, 1)},{(1, 2), (3, 1)},{(1, 3), (2, 3)},{(2, 1), (6, 1)},{(2,", "text": "2), (4, 1)}.\ntoehold = \u2205. E = \u2205.\nIn Fig. 12 the entire mechanism of theorem proving by resolution refutation using DNA\nstrands is represented by strand graph T and reduction rules.\nIn Fig. 12, the admissible edges are drawn by blue lines. Initially the set of current edges\nE is empty, thus, all the edges are admissible. The 2nd site (domain Q*) of vertex 1 and the only site (Q) of vertex 3 are not preoccupied and open to each other. Thus, according to rule (GB) in the first step of the program the admissible edge joining these two sites is converted into current edge. The current edge is drawn by red lines. All the remaining admissible edges of the strand graph are converted into current edges in next few steps following the reduction rule (GB). Finally, all the edges of the graph are included in set E. No sites in graph is free in the resultant graphical structure. This indicates that, the final strand is complete double stranded DNA sequence which implies empty clause {}. Thus, the unsatisfiability of the set of clauses S has been proved."}, {"heading": "5. Conclusion", "text": "In this paper we have shown how the theorem proving with resolution refutation by DNA\ncomputation can be presented by the semantics of DNA strand graph. The chemical potential and flexibility of DNA strands have been exploited to model theorem proving by resolution refutation. Formal language theory in form of process calculus has been successfully used as a tool for modeling and analyzing DNA operations performed for theorem proving in propositional logic. The model based on formal language theory is efficiently interpreted by DNA strand graph\nfor better simulation. This new approach can be further extended for designing and modeling other expert systems based on first-order logic and fuzzy propositional logic."}], "references": [{"title": "Molecular computation of solutions to combinatorial problems", "author": ["L. Adleman"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1994}, {"title": "Bio-inspired computing: constituents and challenges", "author": ["R. Akerkar", "P.S. Sajja"], "venue": "International Journal of Bio-inspired Computation,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Programmable and autonomous computing machine made of biomolecules", "author": ["Y. Benenson", "T. Paz-Elizur", "R. Adar", "E. Keinan", "Z. Livneh", "E. Shapiro"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "Symbolic logic and mechanical theorem proving", "author": ["C.L. Chang", "R.C.T. Lee"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1997}, {"title": "Molecular Solutions for the Subset-sum Problem on DNA-based Supercomputing", "author": ["W.L. Chang", "M. Ho", "M. Guo"], "venue": "BioSystems, Vol. 73,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "DNA hairpins: Fuel for autonomous DNA devices", "author": ["S.J. Green", "D. Lubrich", "A.J. Turberfield"], "venue": "Biophysical Journal,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2006}, {"title": "DNA Implementation of Theorem Proving with Resolution Refutation in Propositional Logic. Revised Papers from the 8th International Workshop on DNA Based Computers: DNA Computing (DNA8)", "author": ["I.H. Lee", "J.Y. Park", "H.M. Jang", "Y.G. Chai", "Zhang B. T"], "venue": "Masami Hagiya and Azuma Ohuchi (Eds.). Springer-Verlag,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "A strand graph semantics for DNAbased computation", "author": ["R.L. Petersen", "M.R. Lakin", "A. Phillips"], "venue": "Theoretical Computer Science", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2016}, {"title": "Similarity-based Fuzzy Reasoning by DNA Computing", "author": ["K.S. Ray", "M. Mondal"], "venue": "International Journal of Bio-inspired Computation,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Classification of SODAR data by DNA computing", "author": ["K.S. Ray", "M. Mondal"], "venue": "New Mathematics and Natural Computation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Logical inference by DNA strand algebra", "author": ["K.S. Ray", "M. Mondal"], "venue": "New Mathematics and Natural Computation,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2016}, {"title": "Design and self-assembly of two-dimensional DNA", "author": ["E. Winfree", "F. Liu", "L.A. Wenzler", "N.C. Seeman"], "venue": "crystals. Nature,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1998}, {"title": "A comparative study on Similarity based fuzzy reasoning method", "author": ["D.S. Yeung", "E.C.C. Tsang"], "venue": "IEEE Transactions on Systems, Man, and Cybernetics, Part B: Cybernetics,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1997}, {"title": "Dynamic DNA nanotechnology using stranddisplacement reactions", "author": ["D.Y. Zhang", "G. Seelig"], "venue": "Nature Chemistry,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}], "referenceMentions": [], "year": 2017, "abstractText": "Because of several technological limitations of traditional silicon based computing, for past few years a paradigm shift, from silicon to carbon, is occurring in computational world. DNA computing has been considered to be quite promising in solving computational and reasoning problems by using DNA strands. Resolution, an important aspect of automated theorem proving and mathematical logic, is a rule of inference which leads to proof by contradiction technique for sentences in propositional logic and first-order logic. This can also be called refutation theoremproving. In this paper we have shown how the theorem proving with resolution refutation by DNA computation can be represented by the semantics of process calculus and strand graph.", "creator": "PDF24 Creator"}}}