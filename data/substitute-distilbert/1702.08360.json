{"id": "1702.08360", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Feb-2017", "title": "Neural Map: Structured Memory for Deep Reinforcement Learning", "abstract": "a critical component to finding deeper reasoning in partially observable environments is memory. despite this importance, deep reinforcement study ( drl ) agents have so far used relatively simple memory architectures, with often main methods to overcome partial observability being either a cognitive convolution over the past a frames or generalized lstm layer. more recent work ( oh et al., 2016 ) has went beyond these architectures by using memory networks though can allow more sophisticated addressing schemes over the past k frames. but even these architectures are incomplete due to the discovery that they are limited to still remembering information from the later k frames. in this paper, researcher develop a memory system with an adaptable write operator that is customized by the sorts of 3d environments that drl agents typically interact with. this architecture, called naive neural map, uses a spatially structured numerical scanning algorithm to learn to store explicit information about the environment over long time lags. trials demonstrate empirically that the neural map surpasses previous drl memories on in set of challenging 2d dynamics 3d maze environments and show that it is capable of generalizing to environments that were not seen regarding training.", "histories": [["v1", "Mon, 27 Feb 2017 16:32:27 GMT  (671kb,D)", "http://arxiv.org/abs/1702.08360v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["emilio parisotto", "ruslan salakhutdinov"], "accepted": false, "id": "1702.08360"}, "pdf": {"name": "1702.08360.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Emilio Parisotto"], "emails": ["eparisot@cs.cmu.edu", "rsalakhu@cs.cmu.edu"], "sections": [{"heading": "1 INTRODUCTION", "text": "Memory is a crucial aspect of an intelligent agent\u2019s ability to plan and reason in partially observable environments. Without memory, agents must act reflexively according only to their immediate percepts and cannot execute plans that occur over an extended time interval. Recently, Deep Reinforcement Learning agents have been capable of solving many challenging tasks such as Atari Arcade Games (Mnih et al., 2015), robot control (Levine et al., 2016) and 3D games such as Doom (Lample & Chaplot, 2016), but successful behaviours in these tasks have often only been based on a relatively short-term temporal context or even just a single frame. On the other hand, many tasks require long-term planning, such as a robot gathering objects or an agent searching a level to find a key in a role-playing game.\nNeural networks that utilized external memories have recently had an explosion in variety, which can be distinguished along two main axis: memories with write operators and those without. Writeless external memory systems, often referred to as \u201cMemory Networks\u201d (Sukhbaatar et al., 2015; Oh et al., 2016), typically fix which memories are stored. For example, at each time step, the memory network would store the past M states seen in an environment. What is learnt by the network is therefore how to access or read from this fixed memory pool, rather than what contents to store within it.\nThe memory network approach has been successful in language modeling, question answering (Sukhbaatar et al., 2015) and was shown to be a sucessful memory for deep reinforcement learning agents in complex 3D environments (Oh et al., 2016). By side-steping the difficulty involved in learning what information is salient enough to store in memory, the memory network introduces two main disadvantages. The first disadvantage is that a potentially significant amount of redundant information could be stored. The second disadvantage is that a domain expert must choose what to store in the memory, e.g. for the DRL agent, the expert must set M to a value that is larger than the time horizon of the currently considered task.\nar X\niv :1\n70 2.\n08 36\n0v 1\n[ cs\n.L G\n] 2\n7 Fe\nb 20\n17\nOn the other hand, external neural memories having write operations are potentially far more efficient, since they can learn to store salient information for unbounded time steps and ignore any other useless information, without explicitly needing any a priori knowledge on what to store. One prominent research direction within write-based architectures has been neural memories based on the types of memory structures that are found in computers, such as tapes (Graves et al., 2014), RAM (Kurach et al., 2016), and GPUs (Kaiser & Sutskever, 2016). In contrast to typical recurrent neural networks, these neural computer emulators have far more structured memories which follow many of the same design paradigms that digital computers have traditionally utilized. One such model, the Differentiable Neural Computer (DNC) (Graves et al., 2016) and its predecessor the Neural Turing Machine (NTM) (Graves et al., 2014), structure the architecture to explicitly separate memory from computation. The DNC has a recurrent neural controller that can access an external memory resource by executing differentiable read and write operations. This allows the DNC to act and memorize in a structured manner resembling a computer processor, where read and write operations are sequential and data is store distinctly from computation. The DNC has been used sucessfully to solve complicated algorithmic tasks, such as finding shortest paths in a graph or querying a database for entity relations.\nBuilding off these previous external memories, we introduce a new architecture called the Neural Map, a structured memory designed specifically for reinforcement learning agents in 3D environments. The Neural Map architecture overcomes some of the shortcomings of the previously mentioned neural memories. First, it uses an adaptable write operation and so its size and computational cost does not grow with the time horizon of the environment as it does with memory networks. Second, we impose a particular inductive bias on the write operation so that it is 1) well suited to 3D environments where navigation is a core component of sucessful behaviours, and 2) uses a sparse write operation that prevents frequent overwriting of memory locations that can occur with NTMs and DNCs. To accomplish this, we structure a DNC-style external memory in the form of a 2-dimensional map, where each position in the map is a distinct memory.\nTo demonstrate the effectiveness of the neural map, we run it in on variety of 2D partially-observable maze-based environments and test it against LSTM and memory network policies. Finally, to establish its scalability, we run a Neural Map agent on a challenging 3D maze environment based on the video game Doom."}, {"heading": "2 BACKGROUND", "text": "A Markov Decision Process (MDP) is defined as a tuple (S,A, T , \u03b3,R) where S is a finite set of states, A is a finite set of actions, T (s\u2032|s, a) is the transition probability of arriving in state s\u2032 when executing action a in initial state s, \u03b3 is a discount factor, and R(s, a, s\u2032) is the reward function of executing action a in state s and ending up at state s\u2032. We define a policy \u03c0(\u00b7|s) as a mapping from a state s to a distribution over actions, where \u03c0(ai|s) denotes the probability of action ai given that we are in state s. The value of a policy V \u03c0(s) is the expected discounted cumulative reward when starting from state s and sampling actions according to \u03c0, i.e.:\nV \u03c0(s) = E\u03c0 [ \u221e\u2211 t=0 \u03b3tRt|s0 = s ] (1)\nAn optimal value function, denoted V \u2217(s), is the maximum value we can get from state s according to any policy, i.e. V \u2217(s) = max\u03c0 V \u03c0(s). An optimal policy \u03c0\u2217 is defined as a policy which achieves optimal value at each state, i.e. V \u03c0 \u2217 (s) = V \u2217(s). An optimal policy is guaranteed to exist (Sutton & Barto, 1998).\nThe REINFORCE algorithm (Williams, 1992) iteratively updates a given policy \u03c0 in the direction of the optimal policy. This update direction is defined by\u2207\u03c0 log \u03c0(at|st)Gt withGt = \u2211\u221e k=0 \u03b3\nkRt+k being the future cumulated reward for a particular episode rollout. The variance of this update is typically high but can be reduced by using a \u201cbaseline\u201d bt(st), which is a function of the current state. Therefore the baseline-augmented update equation is \u2207\u03c0 log \u03c0(at|st)(Gt \u2212 bt(st)). The typically used baseline is the value function, bt(st) = V \u03c0(st). This combination of REINFORCE with value function baseline is commonly termed the \u201cActor-Critic\u201d algorithm.\nIn this paper, we utilize a modified Asynchronous Advantage Actor-Critic (A3C) (Mnih et al., 2016), which can be seen as a specialization of the actor-critic framework when using deep networks to\nparameterize the policy and value function. The policy is a function of the state, parameterized as a deep neural network: \u03c0(a|s) = f\u03b8(s, a), where f is a deep neural network with parameter vector \u03b8. We make a modification to the A3C framework where instead of executing and updating a policy asynchronously in several concurrent environments and then occasionally synchronizing network parameters after several updates, we execute and update the policy synchronously at each time step across several concurrent environments, meaning that the network parameters never require synchronization. Other than this modification, the algorithm is identical to the one used in A3C, including the methods used to update the value and policy networks (refer to (Mnih et al., 2016) for details)."}, {"heading": "3 NEURAL MAP", "text": "In this section, we will describe the details of the neural map. We assume we want our agent to act within some 2- or 3-dimensional environment. The neural map is the agent\u2019s internal memory storage that can be read from and written to during interaction with its environment, but where the write operator is selectively limited to affect only the part of the neural map that represents the area where the agent is currently located. For this paper, we assume for simplicity that we are dealing with a 2-dimensional map. This can easily be extended to 3-dimensional or even higher-dimensional maps (i.e. a 4D map with a 3D sub-map for each cardinal direction the agent can face).\nLet the agent\u2019s position be (x, y) with x \u2208 R and y \u2208 R and let the neural map M be a C \u00d7H \u00d7W feature block, where C is the feature dimension, H is the vertical extent of the map and W is the horizontal extent. Assume there exists some coordinate normalization function \u03c8(x, y) such that every unique (x, y) can be mapped into (x\u2032, y\u2032), where x\u2032 \u2208 {0, . . . ,W} and y\u2032 \u2208 {0, . . . ,H}. For ease of notation, suppose in the sequel that all coordinates have been normalized by \u03c8 into neural map space.\nLet st be the current state embedding, Mt be the current neural map, and (xt, yt) be the current position of the agent within the neural map. The Neural Map is defined by the following set of equations:\nrt = read(Mt) (2) ct = context(Mt, st, rt) (3)\nw (xt,yt) t+1 = write(st, rt, ct,M (xt,yt) t ) (4)\nMt+1 = update(Mt, w (xt,yt) t+1 ) (5)\not = [rt, ct, w (xt,yt) t+1 ] (6)\n\u03c0t(a|s) = Softmax(f(ot)), (7)\nwhere w(xt,yt)t represents the feature at position (xt, yt) at time t, [x1, . . . , xk] represents a concatenation operation, and ot is the output of the neural map at time t which is then processed by another deep network f to get the policy outputs \u03c0t(a|s). We will now separately describe each of the above operations in more detail."}, {"heading": "3.1 GLOBAL READ OPERATION", "text": "The read operation passes the current neural map Mt through a deep convolutional network and produces a C-dimensional feature vector rt. The global read vector rt summarizes information about the entire map."}, {"heading": "3.2 CONTEXT READ OPERATION", "text": "The context operation performs context-based addressing to check whether certain features are stored in the map. It takes as input the current state embedding st and the current global read vector rt and first produces a query vector qt. The inner product of the query vector and each feature M\n(x,y) t in the neural map is then taken to get scores a (x,y) t at all positions (x, y). The scores are then normalized to get a probability distribution \u03b1(x,y)t over every position in the map, also known as \u201csoft attention\u201d (Bahdanau et al., 2015). This probability distribution is used to compute a weighted\naverage ct over all features M (x,y) t . To summarize:\nqt =W [st, rt] (8)\na (x,y) t = qt \u00b7M (x,y) t (9)\n\u03b1 (x,y) t = ea (x,y) t\u2211\n(w,z) e a (w,z) t\n(10)\nct = \u2211 (x,y) \u03b1 (x,y) t M (x,y) t , (11)\nwhere W is a weight matrix. The context read operation allows the neural map to operate as an associative memory: the agent provides some possibly incomplete memory (the query vector qt) and the operation will return the completed memory that most closely matches qt. So, for example, the agent can query whether it has seen something similar to a particular landmark that is currently within its view."}, {"heading": "3.3 LOCAL WRITE OPERATION", "text": "Given the agent\u2019s current position (xt, yt) at time t, the write operation takes as input the current state embedding st, the global read output rt, the context read vector ct and the current feature at position (xt, yt) in the neural map M (xt,yt) t and produces, using a deep neural network f , a new C-dimensional vector w(xt,yt)t+1 . This vector functions as the new local write candidate vector at the current position (xt, yt):\nw (xt,yt) t+1 = f([st, rt, ct,M (xt,yt) t ]) (12)"}, {"heading": "3.4 MAP UPDATE OPERATION", "text": "The update operation creates the neural map for the next time step. The new neural map Mt+1 is equal to the old neural map Mt, except at the current agent position (xt, yt), where the current write candidate vector w(xt,yt)t+1 is stored:\nM (a,b) t+1 =\n{ w\n(xt,yt) t+1 , for (a, b) = (xt, yt) M (a,b) t , for (a, b) 6= (xt, yt)\n(13)"}, {"heading": "3.5 OPERATION VARIANTS", "text": "There are several modifications that can be made to the standard operations as defined above. Below we discuss some variants."}, {"heading": "3.5.1 LOCALIZED READ OPERATION", "text": "Instead of passing the entire neural map through a deep convolutional network, a spatial subset of the map can be passed instead. For example, a Spatial Transformer Network (Jaderberg et al., 2015) can be used to attentively subsample the neural map at particular locations and scales. This can be helpful when the environment requires a large high-resolution map which can be computationally expensive to process in its entirety at each time step."}, {"heading": "3.5.2 KEY-VALUE CONTEXT READ OPERATION", "text": "We can impose a stronger bias on the context addressing operation by splitting each feature of the neural map into two parts M (x,y)t = [k (x,y) t , v (x,y) t ], where k (x,y) t is the (C/2)-dimensional \u201ckey\u201d feature and v(x,y)t is the (C/2)-dimensional \u201cvalue\u201d feature Miller et al. (2016). The key features are matched against the query vector (which is now a (C/2)-dimensional vector) to get the probability distribution \u03b1(x,y)t , and the weighted average is taken over the value features. Concretely:\nqt =W [st, rt] (14)\nM (x,y) t = [k (x,y) t , v (x,y) t ] (15)\na (x,y) t = qt \u00b7 k (x,y) t (16)\n\u03b1 (x,y) t = ea (x,y) t\u2211\n(w,z) e a (w,z) t\n(17)\nct = \u2211 (x,y) \u03b1 (x,y) t v (x,y) t (18)\nHaving distinct key-value features allows the network to more explicitly separate the addressing feature space from the content feature space."}, {"heading": "3.5.3 GRU-BASED LOCAL WRITE OPERATION", "text": "As previously defined, the write operation simply replaces the vector at the agent\u2019s current position with a new feature produced by a deep network. Instead of this hard rewrite of the current position\u2019s feature vector, we can use a gated write operation based on the recurrent update equations of the Gated Recurrent Unit (GRU) (Chung et al., 2014). Gated write operations have a long history in unstructured recurrent networks and they have shown a superior ability to maintain information over long time lags versus ungated networks. The GRU-based write operation is defined as:\nr (xt,yt) t+1 = \u03c3(Wr[st, rt, ct,M (xt,yt) t ])\nw\u0302 (xt,yt) t+1 = tanh(Wh\u0302[st, rt, ct] + Uh\u0302(r (xt,yt) t+1 M (xt,yt) t ))\nz (xt,yt) t+1 = \u03c3(Wz[st, rt, ct,M (xt,yt) t ])\nw (xt,yt) t+1 = (1\u2212 z (xt,yt) t+1 ) M (xt,yt) t + z (xt,yt) t+1 w\u0302 (xt,yt) t+1 ,\nwhere x y is the Hadamard product between vectors x and y, \u03c3(\u00b7) is the sigmoid activation function and W\u2217 and U\u2217 are weight matrices. Using GRU terminology, r (xt,yt) t+1 is the reset gate, w\u0302 (xt,yt) t+1 is the candidate activation and z(xt,yt)t+1 is the update gate. By making use of the reset and update gates, the GRU-based update can modulate how much the new write vector should differ from the currently stored feature."}, {"heading": "4 EXPERIMENTS", "text": "To demonstrate the effectiveness of the Neural Map, we run it on 2D and 3D maze-based environments where memory is crucial to optimal behaviour. We compare to previous memory-based DRL agents, namely a simple LSTM-based agent which consists of a single pre-output LSTM layer as well as MemNN (Oh et al., 2016) agents. Of the agents presented in Oh et al. (2016), we use the MQN version, i.e. the stand-alone memory network without an LSTM layer."}, {"heading": "4.1 2D GOAL-SEARCH ENVIRONMENT", "text": "The \u201cGoal-Search\u201d environment is adapted from Oh et al. (2016). Here the agent starts in a fixed starting position within some randomly generated maze with two randomly positioned goal states. It then observes an indicator at a fixed position near the starting state (i.e. the green tile at the top of the maze in Fig. 2a). This indicator will tell the agent which of the two goals it needs to go to (blue indicator\u2192teal goal, green indicator\u2192red goal). If the agent goes to the correct goal, it gains a positive reward while if it goes to the incorrect goal it gains a negative reward. Therefore the agent needs to remember the indicator as it searches for the correct goal state.\nThe mazes during training are generated using a random generator. A held-out set of 1000 random mazes is kept for testing. This test set therefore represents maze geometries that have never been seen during training, and measure the agent\u2019s ability to generalize to new environments. The mazes sampled during training range from a size of 5 \u00d7 5 to 15 \u00d7 15. In the maze generation process, we first sample maze sizes uniformly and then generate the maze. Sampling different maze sizes from easy to difficult during training is similar to a style of curriculum learning. The episode is terminated early if the agent goes 100 steps without reaching a goal.\nThe agent\u2019s state observations are a 5 \u00d7 15 \u00d7 3 subsample of the complete maze so that the agent is able to see 15 pixel forward and 3 pixels on the side (center pixel + one pixel on each side of the agent) which is depicted in Fig.2b. This view is obscured so the agent is prevented from seeing the identity of anything behind walls. The 5 binary channels in the observation represent object identities: channel 1 represents presence of walls, 2 represents the green indicator, 3 the blue indicator, 4 the red goal, and 5 the teal goal.\nThe first baseline agent we evaluate is a recurrent network with 128 LSTM units. The other baseline is the MQN, which is a memory-network-based architecture that performs attention over the past\n32 states it has seen. In more detail, the MQN stores all previous 32 states in memory and passes them all through a deep network to get an embedding, then performs a context-based lookup on this memory pool using a query vector computed from the current state. Finally, we test two Neural Map architectures, one with the standard update and one with the GRU-based update. The Neural Map architectures have an internal map size of 15 \u00d7 15 with a feature channel size of 32. To get rt, the global read operation passes the neural map first through a 3-layer convolutional network, with each convolution having filter size 3 \u00d7 3 and 8 channels, followed by a 256 unit linear layer and then a final 32 unit linear layer. Both Neural Maps are identical minus the difference in write operations. All agents are trained using a synchronized Advantage Actor-Critic with 16 concurrent environments trained for 10 million steps per environment (160 million total).\nThe results are reported in Table 1. During testing, we extend the maximum episode length from 100 to 500 steps so that the agent is given more time to solve the maze. From the results we can see that the Neural Map solves the most mazes in both the training and test distributions. The results show that the Neural Map based architectures can better succeed at finding the correct goal over all other methods. In particular, the GRU-based Neural Map solves almost all of the train/test mazes. One thing to note is that the accuracy on the training distribution is slightly lower than the test set. This is because the training set encompases almost all random mazes except the 1000 of the test set thus it is likely that the agent sees each training map only once.\nBeyond train/test splits, the results are further separated by maze size, which will give an idea of whether the agent is limited by the amount of time it can store information since larger mazes will require remembering information over longer time steps. We split the 1000 test mazes into 572 small mazes (sizes between 7 \u00d7 7 to 11 \u00d7 11) and 428 large mazes (sizes between 13 \u00d7 13 to 15 \u00d7 15). Table 1 shows that the memory network and LSTM agents have significant difficulty learning how to solve longer maze sizes. On the other hand, the neural map with either standard or GRU-based updates is capable of solving larger maze sizes at a much higher rate.\nThe training curves are plotted in Fig. 3. We can see that the Neural Map agents get the highest final reward, but both initially learn slower than the LSTM and the MemNN. It is not surprising that the MemNN learns faster because it is a feedforward network that does not need to maintain a recurrent state. The LSTM initially learns quickly but plateaus at a pretty low average reward. Results in Table 1 suggest that this relatively higher initial score might be due to the LSTM quickly learning how to solve the small mazes. For the Neural Maps, the GRU-based update was observed to learn much faster as well as surpass the final score of the standard update. Another benefit of the GRU-based write operation was that it typically made the Neural Map much more stable during training.\nTo gain some insight into what the neural map learned to do internally, we ran it on an example maze shown in Figure 4. In this figure, the top row of images are the agent observations, the center row are the fully observable mazes and the bottom row are the probability distributions over locations from the context operation, e.g. the \u03b1(x,y)t values defined by Eq. 10. In this maze, the indicator is blue, which indicates that the teal goal should be visited. We can see that once the agent sees the incorrect red goal, the context distribution faintly focuses on the map location where the agent had observed the indicator. On the other hand, when the agent first observes the correct teal goal, the\nlocation where the agent observed the indicator lights up brightly. This means that the agent is using its context retrieval operation to keep track of the landmark (the indicator) that it has previously seen."}, {"heading": "4.2 3D DOOM ENVIRONMENT", "text": "To demonstrate that our method can work in much more complicated 3D environments with longer time lags, we implemented the 2D maze environment in 3D using the ViZDoom (Kempka et al., 2016) environment and a random maze generator. In the Doom environment, the indicator is a torch of either red or green color that is always at a fixed location in view of the player\u2019s starting state. The goals are red/green towers that are randomly positioned throughout the maze. The corresponding torch indicators and goal towers are illustrated in Figure 5. We terminate an episode if more than 420 steps are taken.\nTo train the agent, we used a deep network as a state embedding. The state observations were the 5 previous 100 \u00d7 75 RGB colour images. The network was pre-initialized with the weights from a\nnetwork trained to play Doom taken from Lample & Chaplot (2016). We used an action repeat of 5. To map from 3D positions to neural map space, we rescaled the coordinates provided from the game and did nearest neighbor quantization. The mazes consisted of 3 \u00d7 3 rooms, where a wall could be generated between any adjacent room and a tower can be located at the center. For the Neural Map agent, we used an internal map size of 32\u00d7 9\u00d7 9. The agents we tested on are an LSTM baseline and an LSTM + Neural Map with GRU-based updates. Due to the large size of the state embedding network, the memory network implementation quickly ran out of memory with more than 16 states so we only trained an agent with a memory size of 16. Additionally, it was observed that because the Neural Map has coarse granularity in the 3D maze (several positions in the maze occupy the same \u201cpixel\u201d position in the map), the neural map agents that lacked an LSTM added to the top often repeated the same actions. So, for example, when the agent would face a wall it would often start turning but the next frame it did not remember which direction it started turning towards. Therefore the agent would sometimes be stuck facing the wall and oscillate between turning left or right. To get around this, the LSTM pre-output layer keeps track of what actions were done in previous frames and so can enable the agent to more easily turn in a consistent direction. Due to this behaviour, we do not present results for stand-alone Neural Map agents.\nWe trained all agents on a single training maze (i.e. the wall geometry was constant for all training episodes) for up to 7 million frames. For testing, we used a held-out set of 6 mazes to see whether the agents were capable of zero-shot learning. In both training and testing settings, for every episode we sample new random goal tower locations. The results are shown in Table 2. For each agent, we chose the best performing network that was seen during the 7 million training frames, where performance was measured with respect to the training map. We can see LSTM + Neural Map (GRU) surpasses all other methods on both the training map and on the 6 unseen maps. On the training map, the LSTM does almost as well as the memory network which is limited to the past 16 frames. This suggests that the LSTM is potentially only learning to solve the scenarios where the goal towers are closer to the indicator. Figure 6 shows an example episode where the Neural Map agent successfully backtracks."}, {"heading": "5 EXTENSION: EGO-CENTRIC NEURAL MAP", "text": "A major disadvantage of the neural map as previously described is that it requires some oracle to provide the current (x, y) position of the agent. This is a difficult problem in and of itself, and, despite being well studied, it is far from solved. The alternative to using absolute positions within the map is to use relative positions. That is, whenever the agent moves between time steps with some velocity (u, v), the map is counter-transformed by (\u2212u,\u2212v), i.e. each feature in the map is shifted in the H and W dimensions. This will mean that the map will be ego-centric, i.e. the agent\u2019s position will stay stationary in the center of the neural map while the world as defined by the map moves around them. Therefore in this setup we only need some way of extracting the agent\u2019s velocity, which is typically a simpler task in real environments. Here we assume that there is some function \u03be(u\u2032, v\u2032) that discretizes the agent velocities (u\u2032, v\u2032) so that they represent valid velocities within the neural map (u, v). In the sequel, we assume that all velocities have been properly normalized by \u03be into neural map space.\nLet (pw, ph) be the center position of the neural map. The ego-centric neural map operations are shown below:\nM t = CounterTransform(Mt, (ut, vt))\nrt = read(M t), ct = context(M t, st, rt)\nw (pw,ph) t+1 = write(st, rt, ct,M\n(pw,ph) t )\nMt+1 = egoupdate(M t, w (pw,ph) t+1 )\not = [rt, ct, w (pw,ph) t+1 ],\n\u03c0t = Softmax(f(ot)) (19)\nwhere M t is the current neural map reverse transformed by the current velocity (ut, vt) so that the agents map position remains in the center (pw, ph).\nCounter Transform Operation: The CounterTransform operation transforms the current neural map Mt by the inverse of the agent\u2019s current velocity (ut, vt). Written formally:\nM (a,b)\nt =\n{ M\n(a\u2212u,b\u2212v) t+1 , for (a\u2212u)\u2208{1,...,W}\u2227 (b\u2212v)\u2208{1,...,H}\n0, else (20)\nWhile here we only deal with reverse translation, it is possible to handle rotations as well if the agent can measure it\u2019s angular velocity.\nMap Egoupdate Operation: The egoupdate operation is functionally equivalent to the update operation except only the center position (pw, ph) is only ever written to:\nM (a,b) t+1 =\n{ w\n(pw,ph) t+1 , for (a, b) = (pw, ph)\nM (a,b) t , for (a, b) 6= (pw, ph) (21)"}, {"heading": "6 RELATED WORK", "text": "Other than the straightforward architectures of combining an LSTM with Deep Reinforcement Learning (DRL) (Mnih et al., 2016; Hausknecht & Stone, 2015), there has also been work on using more advanced external memory systems with DRL agents to handle partial observability. Oh et al. (2016) used a memory network (MemNN) to solve maze-based environments similar to the ones presented in this paper. MemNN keeps the last M states in memory and encodes them into (key, value) feature pairs. It then queries this memory using a soft attention mechanism similar to the context operation of the Neural Map, except in the Neural Map the key/value features were written by the agent and aren\u2019t just a stored representation of the last M frames seen. Oh et al. (2016) tested a few variants of this basic model, including ones which combined both LSTM and memory-network style memories.\nIn contrast to memory networks, another research direction is to design recurrent architectures that mimic computer memory systems. These architectures explicitly separate computation and memory\nin a way anagolous to a modern digital computer, in which some neural controller (akin to a CPU) interacts with an external memory (RAM). One recent model is similar to the Neural Map, called the Differentiable Neural Computer (DNC) (Graves et al., 2016), which combines a recurrent controller with an external memory system that allows several types of read/write access. In addition to defining an unconstrained write operator (in contrast to the neural map\u2019s write location being fixed), the DNC has a selective read operation that reads out the memory either by content or in the order that it was written. While the DNC is more specialized to solving algorithmic problems, the Neural Map can be seen as an extension of this Neural Computer framework to 3D environments, with a specific inductive bias on its write operator that allows sparse writes. Recently work has also been done toward sparsifying the read and write operations of the DNC (Rae et al., 2016). This work was not focused on 3D environments and did not make any use of task-specific biases like agent location, but instead used more general biases like \u201cLeast-Recently-Used\u201d memory addresses to force sparsity.\nAdditionally, a recent paper has used the idea of augmenting the state of an agent with an internal map when acting in 3D environments (Bhatti et al., 2016). Their approach uses a sophisticated pipeline of hard-coded sub-modules, such as SLAM (Simultaneous Localization And Mapping), image segmentation, etc., to augment the image inputs that are typically fed to DRL agents. In contrast, the Neural Map is trained fully end-to-end without even weak supervision and therefore it can learn by itself what currently relevant information it should store within in its internal knowledge map of the environment.\nA similar paper that also had a 2D map structured memory was recently made public concurrently with our submission. Gupta et al. (2017) designed a spatial memory that was used to do robot navigation in 3D environments. These environments were based off image scans of real office buildings, and they were preprocessed into a grid-world by quantizing the possible positions and orientations the agent could assume. In contrast to our paper, which presents the Neural Map more as a general memory architecture for DRL agents, Gupta et al. (2017) focuses mainly on solving the task of robot navigation. More concretely, the task in these environments was to navigate to a goal state, with the goal position either stated semantically (find a chair) or stated in terms of the position relative to the robot\u2019s coordinate frame. Owing to this focus on navigation, they force their internal map representation (e.g. Mt) to be a prediction of free space around the robot. Finally, their method used DAGGER (Ross et al., 2011), an imitation learning algorithm, to train their agent. Since Doom actions affect translational/rotational accelerations, training using imitation learning is more difficult since a search algorithm cannot be used as supervision. An interesting addition they made was the use of a multi-scale map representation and a Value Iteration network (Tamar et al., 2016) to do better path planning."}, {"heading": "7 CONCLUSION", "text": "In this paper we developed a neural memory architecture that organizes the spatial structure of its memory in the form of a 2D map, and allows sparse writes to this memory where the memory address of the write is in a correspondence to the agent\u2019s current position in the environment. We showed its ability to learn, using a reinforcement signal, how to behave within a challenging 2D maze task that required storing information over long time steps. The results demonstrated that our architecture surpassed baseline memories used in previous work. They also revealed that the GRU-based update equation we defined was crucial to improving both learning speed and training stability. Finally, to show that our method can scale up to more difficult 3D environments, we reimplemented the maze environment in Doom. Using a hybrid Neural Map + LSTM model, we were able to solve most of the scenarios, surpassing both LSTM and MemNN baseline agents."}], "references": [{"title": "Neural machine translation by jointly learning to align and translate", "author": ["D. Bahdanau", "K.H. Cho", "Y. Bengio"], "venue": "In Proceedings of the 3rd International Conference on Learning Representations", "citeRegEx": "Bahdanau et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Bahdanau et al\\.", "year": 2015}, {"title": "Playing doom with slam-augmented deep reinforcement learning", "author": ["S. Bhatti", "A. Desmaison", "O. Miksik", "N. Nardelli", "N. Siddharth", "P.H.S. Torr"], "venue": "CoRR, abs/1612.00380,", "citeRegEx": "Bhatti et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bhatti et al\\.", "year": 2016}, {"title": "Empirical evaluation of gated recurrent neural networks on sequence modeling", "author": ["J. Chung", "C. Gulcehre", "K. Cho", "Y. Bengio"], "venue": "CoRR, abs/1412.3555,", "citeRegEx": "Chung et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Chung et al\\.", "year": 2014}, {"title": "Hybrid computing using a neural network", "author": ["A. Graves", "G. Wayne", "M. Reynolds", "T. Harley", "I. Danihelka", "A. Grabska-Barwiska", "S.G. Colmenarejo", "E. Grefenstette", "T. Ramalho", "J. Agapiou", "A.P. Badia", "K.M. Hermann", "Y. Zwols", "G. Ostrovski", "A. Cain", "H. King", "C. Summerfield", "P. Blunsom", "K. Kavukcuoglu", "D. Hassabis"], "venue": null, "citeRegEx": "Graves et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Graves et al\\.", "year": 2016}, {"title": "Cognitive mapping and planning for visual navigation", "author": ["S. Gupta", "J. Davidson", "S. Levine", "R. Sukthankar", "J. Malik"], "venue": "CoRR, abs/1702.03920,", "citeRegEx": "Gupta et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Gupta et al\\.", "year": 2017}, {"title": "Deep recurrent q-learning for partially observable mdps", "author": ["M. Hausknecht", "P. Stone"], "venue": "CoRR, abs/1507.06527,", "citeRegEx": "Hausknecht and Stone.,? \\Q2015\\E", "shortCiteRegEx": "Hausknecht and Stone.", "year": 2015}, {"title": "Spatial transformer networks", "author": ["M. Jaderberg", "K. Simonyan", "A. Zisserman"], "venue": "In Advances in Neural Information Processing Systems, pp. 2017\u20132025,", "citeRegEx": "Jaderberg et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Jaderberg et al\\.", "year": 2015}, {"title": "Neural gpus learn algorithms", "author": ["L. Kaiser", "I. Sutskever"], "venue": "In Proceedings of the 4th International Conference on Learning Representations", "citeRegEx": "Kaiser and Sutskever.,? \\Q2016\\E", "shortCiteRegEx": "Kaiser and Sutskever.", "year": 2016}, {"title": "ViZDoom: A Doom-based AI research platform for visual reinforcement learning", "author": ["Micha\u0142 Kempka", "Marek Wydmuch", "Grzegorz Runc", "Jakub Toczek", "Wojciech Ja\u015bkowski"], "venue": "In IEEE Conference on Computational Intelligence and Games,", "citeRegEx": "Kempka et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Kempka et al\\.", "year": 2016}, {"title": "Neural random-access machines", "author": ["K. Kurach", "M. Andrychowicz", "I. Sutskever"], "venue": "In Proceedings of the 4th International Conference on Learning Representations", "citeRegEx": "Kurach et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Kurach et al\\.", "year": 2016}, {"title": "Playing fps games with deep reinforcement learning", "author": ["G. Lample", "D.S. Chaplot"], "venue": "CoRR, abs/1609.05521,", "citeRegEx": "Lample and Chaplot.,? \\Q2016\\E", "shortCiteRegEx": "Lample and Chaplot.", "year": 2016}, {"title": "End-to-end training of deep visuomotor policies", "author": ["Sergey Levine", "Chelsea Finn", "Trevor Darrell", "Pieter Abbeel"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Levine et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Levine et al\\.", "year": 2016}, {"title": "Key-value memory networks for directly reading", "author": ["A. Miller", "A. Fisch", "J. Dodge", "A. Karimi", "A. Bordes", "J. Weston"], "venue": "documents. CoRR,", "citeRegEx": "Miller et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Miller et al\\.", "year": 2016}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski", "S. Petersen", "C. Beattie", "A. Sadik", "I. Antonoglou", "H. King", "D. Kumaran", "D. Wierstra", "S. Legg", "D. Hassabis"], "venue": "Nature, 518:529\u2013533,", "citeRegEx": "Mnih et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2015}, {"title": "Asynchronous methods for deep reinforcement learning", "author": ["V. Mnih", "A.P. Badia", "M. Mirza", "A. Graves", "T. Harley", "T.P. Lillicrap", "D. Silver", "K. Kavukcuoglu"], "venue": "In Proceedings of the 33rd International Conference on Machine Learning (ICML),", "citeRegEx": "Mnih et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2016}, {"title": "Control of memory, active perception, and action in minecraft", "author": ["J. Oh", "V. Chockalingam", "S. Singh", "H. Lee"], "venue": "In Proceedings of the 33rd International Conference on Machine Learning (ICML),", "citeRegEx": "Oh et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Oh et al\\.", "year": 2016}, {"title": "Scaling memory-augmented neural networks with sparse reads and writes", "author": ["J.W. Rae", "J.J. Hunt", "T. Harley", "I. Danihelka", "A. Senior", "G. Wayne", "A. Graves", "T. Lillicrap"], "venue": "CoRR, abs/1610.09027,", "citeRegEx": "Rae et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Rae et al\\.", "year": 2016}, {"title": "A reduction of imitation learning and structured prediction to no-regret online learning", "author": ["St\u00e9phane Ross", "Geoffrey J Gordon", "Drew Bagnell"], "venue": "In AISTATS,", "citeRegEx": "Ross et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ross et al\\.", "year": 2011}, {"title": "End-to-end memory networks", "author": ["S. Sukhbaatar", "A. Szlam", "J. Weston", "R. Fergus"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Sukhbaatar et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Sukhbaatar et al\\.", "year": 2015}, {"title": "Reinforcement Learning: an Introduction", "author": ["R. Sutton", "A. Barto"], "venue": null, "citeRegEx": "Sutton and Barto.,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto.", "year": 1998}, {"title": "Value iteration networks", "author": ["Aviv Tamar", "Yi Wu", "Garrett Thomas", "Sergey Levine", "Pieter Abbeel"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Tamar et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Tamar et al\\.", "year": 2016}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Machine Learning,", "citeRegEx": "Williams.,? \\Q1992\\E", "shortCiteRegEx": "Williams.", "year": 1992}], "referenceMentions": [{"referenceID": 15, "context": "More recent work (Oh et al., 2016) has went beyond these architectures by using memory networks which can allow more sophisticated addressing schemes over the past k frames.", "startOffset": 17, "endOffset": 34}, {"referenceID": 13, "context": "Recently, Deep Reinforcement Learning agents have been capable of solving many challenging tasks such as Atari Arcade Games (Mnih et al., 2015), robot control (Levine et al.", "startOffset": 124, "endOffset": 143}, {"referenceID": 11, "context": ", 2015), robot control (Levine et al., 2016) and 3D games such as Doom (Lample & Chaplot, 2016), but successful behaviours in these tasks have often only been based on a relatively short-term temporal context or even just a single frame.", "startOffset": 23, "endOffset": 44}, {"referenceID": 18, "context": "Writeless external memory systems, often referred to as \u201cMemory Networks\u201d (Sukhbaatar et al., 2015; Oh et al., 2016), typically fix which memories are stored.", "startOffset": 74, "endOffset": 116}, {"referenceID": 15, "context": "Writeless external memory systems, often referred to as \u201cMemory Networks\u201d (Sukhbaatar et al., 2015; Oh et al., 2016), typically fix which memories are stored.", "startOffset": 74, "endOffset": 116}, {"referenceID": 18, "context": "The memory network approach has been successful in language modeling, question answering (Sukhbaatar et al., 2015) and was shown to be a sucessful memory for deep reinforcement learning agents in complex 3D environments (Oh et al.", "startOffset": 89, "endOffset": 114}, {"referenceID": 15, "context": ", 2015) and was shown to be a sucessful memory for deep reinforcement learning agents in complex 3D environments (Oh et al., 2016).", "startOffset": 113, "endOffset": 130}, {"referenceID": 9, "context": ", 2014), RAM (Kurach et al., 2016), and GPUs (Kaiser & Sutskever, 2016).", "startOffset": 13, "endOffset": 34}, {"referenceID": 3, "context": "One such model, the Differentiable Neural Computer (DNC) (Graves et al., 2016) and its predecessor the Neural Turing Machine (NTM) (Graves et al.", "startOffset": 57, "endOffset": 78}, {"referenceID": 21, "context": "The REINFORCE algorithm (Williams, 1992) iteratively updates a given policy \u03c0 in the direction of the optimal policy.", "startOffset": 24, "endOffset": 40}, {"referenceID": 14, "context": "In this paper, we utilize a modified Asynchronous Advantage Actor-Critic (A3C) (Mnih et al., 2016), which can be seen as a specialization of the actor-critic framework when using deep networks to", "startOffset": 79, "endOffset": 98}, {"referenceID": 14, "context": "Other than this modification, the algorithm is identical to the one used in A3C, including the methods used to update the value and policy networks (refer to (Mnih et al., 2016) for details).", "startOffset": 158, "endOffset": 177}, {"referenceID": 0, "context": "The scores are then normalized to get a probability distribution \u03b1 t over every position in the map, also known as \u201csoft attention\u201d (Bahdanau et al., 2015).", "startOffset": 132, "endOffset": 155}, {"referenceID": 6, "context": "For example, a Spatial Transformer Network (Jaderberg et al., 2015) can be used to attentively subsample the neural map at particular locations and scales.", "startOffset": 43, "endOffset": 67}, {"referenceID": 12, "context": "We can impose a stronger bias on the context addressing operation by splitting each feature of the neural map into two parts M (x,y) t = [k (x,y) t , v (x,y) t ], where k (x,y) t is the (C/2)-dimensional \u201ckey\u201d feature and v t is the (C/2)-dimensional \u201cvalue\u201d feature Miller et al. (2016). The key features are matched against the query vector (which is now a (C/2)-dimensional vector) to get the probability distribution \u03b1 t , and the weighted average is taken over the value features.", "startOffset": 267, "endOffset": 288}, {"referenceID": 2, "context": "Instead of this hard rewrite of the current position\u2019s feature vector, we can use a gated write operation based on the recurrent update equations of the Gated Recurrent Unit (GRU) (Chung et al., 2014).", "startOffset": 180, "endOffset": 200}, {"referenceID": 15, "context": "We compare to previous memory-based DRL agents, namely a simple LSTM-based agent which consists of a single pre-output LSTM layer as well as MemNN (Oh et al., 2016) agents.", "startOffset": 147, "endOffset": 164}, {"referenceID": 15, "context": "We compare to previous memory-based DRL agents, namely a simple LSTM-based agent which consists of a single pre-output LSTM layer as well as MemNN (Oh et al., 2016) agents. Of the agents presented in Oh et al. (2016), we use the MQN version, i.", "startOffset": 148, "endOffset": 217}, {"referenceID": 15, "context": "The \u201cGoal-Search\u201d environment is adapted from Oh et al. (2016). Here the agent starts in a fixed starting position within some randomly generated maze with two randomly positioned goal states.", "startOffset": 46, "endOffset": 63}, {"referenceID": 8, "context": "To demonstrate that our method can work in much more complicated 3D environments with longer time lags, we implemented the 2D maze environment in 3D using the ViZDoom (Kempka et al., 2016) environment and a random maze generator.", "startOffset": 167, "endOffset": 188}, {"referenceID": 14, "context": "Other than the straightforward architectures of combining an LSTM with Deep Reinforcement Learning (DRL) (Mnih et al., 2016; Hausknecht & Stone, 2015), there has also been work on using more advanced external memory systems with DRL agents to handle partial observability.", "startOffset": 105, "endOffset": 150}, {"referenceID": 13, "context": "Other than the straightforward architectures of combining an LSTM with Deep Reinforcement Learning (DRL) (Mnih et al., 2016; Hausknecht & Stone, 2015), there has also been work on using more advanced external memory systems with DRL agents to handle partial observability. Oh et al. (2016) used a memory network (MemNN) to solve maze-based environments similar to the ones presented in this paper.", "startOffset": 106, "endOffset": 290}, {"referenceID": 13, "context": "Other than the straightforward architectures of combining an LSTM with Deep Reinforcement Learning (DRL) (Mnih et al., 2016; Hausknecht & Stone, 2015), there has also been work on using more advanced external memory systems with DRL agents to handle partial observability. Oh et al. (2016) used a memory network (MemNN) to solve maze-based environments similar to the ones presented in this paper. MemNN keeps the last M states in memory and encodes them into (key, value) feature pairs. It then queries this memory using a soft attention mechanism similar to the context operation of the Neural Map, except in the Neural Map the key/value features were written by the agent and aren\u2019t just a stored representation of the last M frames seen. Oh et al. (2016) tested a few variants of this basic model, including ones which combined both LSTM and memory-network style memories.", "startOffset": 106, "endOffset": 759}, {"referenceID": 3, "context": "One recent model is similar to the Neural Map, called the Differentiable Neural Computer (DNC) (Graves et al., 2016), which combines a recurrent controller with an external memory system that allows several types of read/write access.", "startOffset": 95, "endOffset": 116}, {"referenceID": 16, "context": "Recently work has also been done toward sparsifying the read and write operations of the DNC (Rae et al., 2016).", "startOffset": 93, "endOffset": 111}, {"referenceID": 1, "context": "Additionally, a recent paper has used the idea of augmenting the state of an agent with an internal map when acting in 3D environments (Bhatti et al., 2016).", "startOffset": 135, "endOffset": 156}, {"referenceID": 17, "context": "Finally, their method used DAGGER (Ross et al., 2011), an imitation learning algorithm, to train their agent.", "startOffset": 34, "endOffset": 53}, {"referenceID": 20, "context": "An interesting addition they made was the use of a multi-scale map representation and a Value Iteration network (Tamar et al., 2016) to do better path planning.", "startOffset": 112, "endOffset": 132}, {"referenceID": 1, "context": "Additionally, a recent paper has used the idea of augmenting the state of an agent with an internal map when acting in 3D environments (Bhatti et al., 2016). Their approach uses a sophisticated pipeline of hard-coded sub-modules, such as SLAM (Simultaneous Localization And Mapping), image segmentation, etc., to augment the image inputs that are typically fed to DRL agents. In contrast, the Neural Map is trained fully end-to-end without even weak supervision and therefore it can learn by itself what currently relevant information it should store within in its internal knowledge map of the environment. A similar paper that also had a 2D map structured memory was recently made public concurrently with our submission. Gupta et al. (2017) designed a spatial memory that was used to do robot navigation in 3D environments.", "startOffset": 136, "endOffset": 744}, {"referenceID": 1, "context": "Additionally, a recent paper has used the idea of augmenting the state of an agent with an internal map when acting in 3D environments (Bhatti et al., 2016). Their approach uses a sophisticated pipeline of hard-coded sub-modules, such as SLAM (Simultaneous Localization And Mapping), image segmentation, etc., to augment the image inputs that are typically fed to DRL agents. In contrast, the Neural Map is trained fully end-to-end without even weak supervision and therefore it can learn by itself what currently relevant information it should store within in its internal knowledge map of the environment. A similar paper that also had a 2D map structured memory was recently made public concurrently with our submission. Gupta et al. (2017) designed a spatial memory that was used to do robot navigation in 3D environments. These environments were based off image scans of real office buildings, and they were preprocessed into a grid-world by quantizing the possible positions and orientations the agent could assume. In contrast to our paper, which presents the Neural Map more as a general memory architecture for DRL agents, Gupta et al. (2017) focuses mainly on solving the task of robot navigation.", "startOffset": 136, "endOffset": 1152}], "year": 2017, "abstractText": "A critical component to enabling intelligent reasoning in partially observable environments is memory. Despite this importance, Deep Reinforcement Learning (DRL) agents have so far used relatively simple memory architectures, with the main methods to overcome partial observability being either a temporal convolution over the past k frames or an LSTM layer. More recent work (Oh et al., 2016) has went beyond these architectures by using memory networks which can allow more sophisticated addressing schemes over the past k frames. But even these architectures are unsatisfactory due to the reason that they are limited to only remembering information from the last k frames. In this paper, we develop a memory system with an adaptable write operator that is customized to the sorts of 3D environments that DRL agents typically interact with. This architecture, called the Neural Map, uses a spatially structured 2D memory image to learn to store arbitrary information about the environment over long time lags. We demonstrate empirically that the Neural Map surpasses previous DRL memories on a set of challenging 2D and 3D maze environments and show that it is capable of generalizing to environments that were not seen during training.", "creator": "LaTeX with hyperref package"}}}