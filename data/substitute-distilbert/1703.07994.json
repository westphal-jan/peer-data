{"id": "1703.07994", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2017", "title": "Containment for Rule-Based Ontology-Mediated Queries", "abstract": "many efforts have been dedicated to identifying restrictions on ontologies expressed as tuple - state dependencies ( tgds ), et. k. a. existential rules, that lead to the decidability for knowledge problem of answering computation - mediated queries ( omqs ). security has given rise to three concepts of formalisms : coherent, non - recursive, and sticky sets of properties. in laboratory work, we obtain the containment problem for omqs expressed in such formalisms, which is a key ingredient for solving static analysis tasks associated with them. our main strategy is the development of specially tailored techniques for omq designs under the subject of containment description above. this enables us to obtain sharp complexity bounds for the problems at hand. they also apply our techniques to improve the complexity of problems associated with two emerging fields of omq containment : distribution over components and infinite rewritability of omqs.", "histories": [["v1", "Thu, 23 Mar 2017 10:44:18 GMT  (174kb)", "http://arxiv.org/abs/1703.07994v1", null], ["v2", "Sun, 2 Apr 2017 16:13:16 GMT  (176kb)", "http://arxiv.org/abs/1703.07994v2", null], ["v3", "Wed, 19 Apr 2017 00:26:02 GMT  (176kb)", "http://arxiv.org/abs/1703.07994v3", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["pablo barcelo", "gerald berger", "reas pieris"], "accepted": false, "id": "1703.07994"}, "pdf": {"name": "1703.07994.pdf", "metadata": {"source": "CRF", "title": "Containment for Rule-Based Ontology-Mediated Queries", "authors": ["Pablo Barcel\u00f3", "Andreas Pieris"], "emails": ["pbarcelo@dcc.uchile.cl", "gberger@dbai.tuwien.ac.at", "apieris@inf.ed.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 3.\n07 99\n4v 1\n[ cs\n.D B\n] 2\n3 M\nar 2\n01 7\nMany efforts have been dedicated to identify restrictions on ontologies expressed as tuple-generating dependencies (tgds), a.k.a. existential rules, that lead to the decidability for the problem of answering ontology-mediated queries (OMQs). This has given rise to three families of formalisms: guarded, non-recursive, and sticky sets of tgds. In this work, we study the containment problem for OMQs expressed in such formalisms, which is a key ingredient for solving static analysis tasks associated with them. Our main contribution is the development of specially tailored techniques for OMQ containment under the classes of tgds stated above. This enables us to obtain sharp complexity bounds for the problems at hand.\nWe start with OMQs based on linear (a core fragment of guarded tgds), non-recursive and sticky sets of tgds, which share the property of UCQ rewritability. By exploiting this property, we obtain a small witness property for non-containment that allows us to devise standard \u201cguessand-check\u201d algorithms. Based on this, we prove that OMQ containment for linear tgds is PSpace-complete, but \u03a0P2 - complete if the arity of the schema is fixed, while for sticky sets of tgds it is coNExpTime-complete, and \u03a0P2 -complete in the case of fixed arity. For non-recursive sets of tgds, the problem is in ExpSpace and PNEXP-hard even for fixed-arity schemas. Hence, in all the cases the containment problem is harder (under widely accepted complexity assumptions) than query evaluation, with the exception of linear tgds over schemas of unbounded arity, where both problems are complete for PSpace. For OMQs based on guarded tgds, which are not UCQ rewritable in general, we establish a tree witness property, and use it in combination with tree automata techniques to prove that OMQ containment has the same complexity as query evaluation, i.e., 2ExpTimecomplete. Unlike query evaluation, though, OMQ containment for guarded tgds remains 2ExpTime-hard over fixedarity schemas. Lastly, we apply our techniques to pinpoint the complexity of problems associated with two emerging\napplications of OMQ containment: distribution over components and UCQ rewritability of OMQs."}, {"heading": "1. INTRODUCTION", "text": "Motivation and goals. The novel application of knowledge representation tools for handling incomplete and heterogeneous data is giving rise to a new field, recently coined as knowledge-enriched data management [5]. A crucial problem in this field is ontology-based data access (OBDA) [42], which refers to the utilization of ontologies (basically, logical theories) for providing a unified conceptual view of various data sources. Users can then pose their queries solely in the schema provided by the ontology, abstracting away from the specifics of the individual sources. In OBDA, one interprets the ontology \u03a3 and the user query q, which is typically a union of conjunctive queries (UCQ), as two components of one composite query Q = (S,\u03a3, q) known as ontologymediated query (OMQ). Here, S is the data schema, indicating that Q will be posed on databases over S [18]. Thus, OBDA is often realized as the problem of answering OMQs.\nWhile in this setting description logics (DLs) are often used for modeling ontologies, it is widely accepted that for handling arbitrary arity relations in relational databases it is convenient to use tuple-generating dependencies (tgds), a.k.a. existential rules or Datalog\u00b1 rules; cf. [33]. Several aspects of OMQs in which the ontology corresponds to a set of tgds and the actual query is a UCQ (simply called OMQs from now on) have been studied in the data management literature; most notably (a) query evaluation [7, 22, 23, 24], i.e., given an OMQ Q = (S,\u03a3, q), a database D over S, and a tuple of constants c\u0304, does c\u0304 belong to the evaluation of q over every extension of D that satisfies \u03a3, or, equivalently, is c\u0304 a certain answer for Q over D? and (b) relative expressiveness [18, 35, 36]: how does the expressiveness of OMQs compare to the one of other query languages?\nThis work focuses on another crucial task for OMQs; namely, containment: for two OMQs Q1 and Q2 with data schema S, does Q1(D) \u2286 Q2(D) hold for every (finite) database D over S (where Q(D) denotes the certain answers for Q overD)? Apart from the traditional applications of containment, such as query optimization or view-based query answering, it has been recently shown that OMQ containment has applications on other important static analysis tasks, namely, distribution over components [14], and UCQ rewritability [15]. Surprisingly, despite its prominence, no work to date has carried out an in-depth investigation of containment for OMQs based on tgds.\nAs one might expect, when considered in its full generality, i.e., without any restrictions on the set of tgds, the OMQ containment problem is undecidable. To understand, on the other hand, which restrictions lead to decidability, it is important to recall the two main reasons that render the general containment problem undecidable. These are:\nUndecidability of query evaluation: OMQ evaluation is, in general, undecidable [11], and it can be reduced to OMQ containment. More precisely, OMQ containment is undecidable whenever query evaluation for at least one of the involved languages (i.e., the language of the left-hand or the right-hand side query) is undecidable.\nUndecidability of containment for Datalog: decidability of query evaluation does not ensure decidability of query containment. A prime example is Datalog, or, equivalently, the OMQ language based on full tgds. Datalog containment is undecidable [45], and thus, OMQ containment is undecidable if the involved languages extend Datalog.\nIn view of the above observations, we focus on languages that (a) have a decidable query evaluation, and (b) do not extend Datalog. The main classes of tgds, which give rise to OMQ languages with the desirable properties, can be classified into three main families depending on the syntactic restrictions imposed on them: (i) guarded tgds [22], which contain inclusion and linear dependencies, (ii) non-recursive sets of tgds [31], and (iii) sticky sets of tgds [24].\nWhile the decidability of containment for the above OMQ languages can be established via translations into query languages with a decidable containment problem, such translations do not lead to optimal complexity upper bounds (details are given below). Therefore, the main goal of our paper is to develop specially tailored decision procedures for the containment problem under the OMQ languages in question, and ideally obtain precise complexity bounds. Our second goal is to exploit such techniques in the study of distribution over components and UCQ rewritability of OMQs.\nOur contributions. The complexity of OMQ containment for the languages in question is given in Table 1. Using small fonts, we recall the complexity of OMQ evaluation in order to stress that containment is, in general, harder than evaluation. We divide our contributions as follows:\nLinear, non-recursive and sticky sets of tgds. The OMQ languages based on linear, non-recursive, and sticky sets of tgds share a useful property: they are UCQ rewritable (implicit in [33]), that is, an OMQ can be rewritten into a UCQ. This property immediately yields decidability for their associated containment problems, since UCQ containment is decidable [44]. However, the obtained complexity bounds are not optimal, since the UCQ rewritings are unavoidably very large [33]. To obtain more precise bounds, we reduce containment to query evaluation, an idea that is often applied in query containment; see, e.g., [26, 27, 44].\nConsider a UCQ rewritable OMQ language O. If Q1 and Q2 belong to O, both with data schema S, then we can establish a small witness property, which states that noncontainment of Q1 in Q2 can be witnessed via a database over S whose size is bounded by an integer k \u2265 0, the maximal size of a disjunct in a UCQ rewriting of Q1. For linear tgds, such an integer k is polynomial, but for non-recursive and sticky sets of tgds it is exponential (implicit in [33]).\nThe above small witness property allows us to devise a simple non-deterministic algorithm, which makes use of query evaluation as a subroutine for checking non-containment of Q1 in Q2: guess a database D over S of size at most k, and then check if there is a certain answer for Q1 over D that is not a certain answer for Q2 over D. This algorithm allows us to obtain optimal upper bounds for OMQs based on linear and sticky sets of tgds; however, the exact complexity of OMQs based on non-recursive sets of tgds remains open:\n\u2022 For OMQs based on linear tgds, the containment problem is in PSpace, and in \u03a0P2 if the arity of the schema is fixed. The PSpace-hardness is shown by reduction from query evaluation [39], while the \u03a0P2 -hardness is inherited from [16].\n\u2022 For OMQs based on sticky sets of tgds, the problem is in coNExpTime, and in \u03a0P2 if the arity of the schema is fixed. The coNExpTime-hardness is shown by exploiting the standard tiling problem for the exponential grid, while the \u03a0P2 -hardness is inherited from [16].\n\u2022 Finally, for OMQs based on non-recursive sets of tgds, containment is in ExpSpace and hard for PNEXP, even for fixed arity. The lower bound is shown by exploiting a recently introduced tiling problem [30].\nWe conclude that in all these cases OMQ containment is harder than evaluation, with one exception: the OMQs based on linear tgds over schemas of unbounded arity, where both problems are PSpace-complete.\nGuarded tgds. The OMQ language based on guarded tgds is not UCQ rewritable, which forces us to develop different tools to study its containment problem. Let us remark that guarded OMQs can be rewritten as guarded Datalog queries (by exploiting the translations devised in [8, 36]), for which containment is decidable in 2ExpTime [19]. But, again, the known rewritings are very large [36], and hence the reduction of containment for guarded OMQs to containment for guarded Datalog does not yield optimal upper bounds.\nTo obtain optimal bounds for the problem in question, we exploit two-way alternating parity automata on trees (2WAPA) [28]. We first show that if Q1 and Q2 are guarded OMQs such that Q1 is not contained in Q2, then this is witnessed over a class of \u201ctree-like\u201d databases that can be represented as the set of trees accepted by a 2WAPA A. We then build a 2WAPA B with exponentially many states that recognizes those trees accepted by A that represent witnesses to non-containment of Q1 in Q2. Hence, Q1 is contained in Q2 iff B accepts no tree. Since the emptiness problem for 2WAPA is feasible in exponential time in the number of states [28], we obtain that containment for guarded OMQs is in 2ExpTime. A matching lower bound, even for fixed arity schemas, follows from [15].\nSimilar ideas based on 2WAPA have been recently used to show that containment for OMQs based on expressive DLs is in 2ExpTime [15]. As usual in the DL context, schemas consist only of unary and binary relations. Our automata construction, however, is different from the one in [15] for two reasons: (a) we need to deal with higher arity relations, and (b) even for schemas of unary and binary relations, our OMQ language allows to express properties that are not expressible by the DL-based OMQ languages studied in [15].\nCombining languages. The above complexity results refer to the containment problem relative to a certain OMQ language O, i.e., both queries fall in O. However, it is natural to consider the version of the problem where the involved OMQs fall in different languages. Unsurprisingly, if the lefthand side query is expressed in a UCQ rewritable OMQ language (based on linear, non-recursive or sticky sets of tgds), we can use the algorithm that relies on the small witness property discussed above, which provides optimal upper bounds for almost all the considered cases (the only exception is the containment of sticky in non-recursive OMQs over schemas of unbounded arity). Things are more interesting if the ontology of the left-hand side query is expressed using guarded tgds, while the ontology of the right-hand side query is not guarded. By exploiting automata techniques, we show that containment of guarded in non-recursive OMQs is in 3ExpTime, while containment of guarded in sticky OMQs is in 2ExpTime. We establish matching lower bounds, even over schemas of fixed arity, by refining techniques from [27].\nApplications. Our techniques and results on containment for guarded OMQs can be applied to other important static analysis tasks, in particular, distribution over components and UCQ rewritability.\nThe notion of distribution over components has been introduced in [2], in the context of declarative networking, and it states that the answer to an OMQ Q can be computed by parallelizing it over the (maximally connected) components of the database. If this is the case, then Q can always be evaluated in a distributed and coordination-free manner. The problem of deciding distribution over components for OMQs has been recently studied in [14]. However, the exact complexity of the problem for guarded OMQs has been left open. By exploiting our results on containment, we can show that it is 2ExpTime-complete.\nIt is well-known that the OMQ language based on guarded tgds is not UCQ rewritable. In view of this fact, it is important to study when a given guarded OMQQ can be rewritten as a UCQ. This has been studied for OMQs based on central Horn DLs [15, 17]. Interestingly, our automata-based techniques for guarded OMQ containment can be adapted to decide in 2ExpTime whether an OMQ based on guarded tgds over unary and binary relations is UCQ rewritable; a matching lower bound is inherited from [15]. Our result generalizes the result that deciding UCQ rewritability for OMQs based on ELHI, one of the most expressive members of the EL-family of DLs, is 2ExpTime-complete [15].\nOrganization. Preliminaries are in Section 2. In Section 3 we introduce the OMQ containment problem. Containment for UCQ rewritable OMQs is studied in Section 4, and for\nguarded OMQs in Section 5. In Section 6 we consider the case where the involved queries fall in different languages. In Section 7 we discuss the applications of our results on guarded OMQ containment and we conclude in Section 8. Full proofs and details can be found in the appendix."}, {"heading": "2. PRELIMINARIES", "text": "Databases and conjunctive queries. Let C, N, and V be disjoint countably infinite sets of constants, (labeled) nulls and (regular) variables (used in queries and dependencies), respectively. A schema S is a finite set of relation symbols (or predicates) with associated arity. We write R/n to denote that R has arity n. A term is a either a constant, null or variable. An atom over S is an expression of the form R(v\u0304), where R \u2208 S is of arity n > 0 and v\u0304 is an n-tuple of terms. A fact is an atom whose arguments consist only of constants. An instance over S is a (possibly infinite) set of atoms over S that contain constants and nulls, while a database over S is a finite set of facts over S. We may call an instance and a database over S an S-instance and S-database, respectively. The active domain of an instance I , denoted dom(I), is the set of all terms occurring in I .\nA conjunctive query (CQ) over S is a formula of the form:\nq(x\u0304) := \u2203y\u0304 ( R1(v\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rm(v\u0304m) ) , (1)\nwhere each Ri(v\u0304i) (1 \u2264 i \u2264 m) is an atom without nulls over S, each variable mentioned in the v\u0304i\u2019s appears either in x\u0304 or y\u0304, and x\u0304 are the free variables of q. If x\u0304 is empty, then q is a Boolean CQ. As usual, the evaluation of CQs is defined in terms of homomorphisms. Let I be an instance and q(x\u0304) a CQ of the form (1). A homomorphism from q to I is a mapping h, which is the identity on C, from the variables that appear in q to the set of constants and nulls C \u222a N such that Ri(h(v\u0304i)) \u2208 I , for each 1 \u2264 i \u2264 m. The evaluation of q(x\u0304) over I , denoted q(I), is the set of all tuples h(x\u0304) of constants such that h is a homomorphism from q to I . We denote by CQ the class of conjunctive queries.\nA union of conjunctive queries (UCQ) over S is a formula of the form q(x\u0304) := q1(x\u0304)\u2228 \u00b7 \u00b7 \u00b7 \u2228 qn(x\u0304), where each qi(x\u0304) is a CQ of the form (1). The evaluation of q(x\u0304) over I , denoted q(I), is the set of tuples \u22c3\n1\u2264i\u2264n qi(I). We denote by UCQ the class of union of conjunctive queries.\nTgds and the chase procedure. A tuple-generating dependency (tgd) is a first-order sentence of the form:\n\u2200x\u0304\u2200y\u0304 ( \u03c6(x\u0304, y\u0304) \u2192 \u2203z\u0304 \u03c8(x\u0304, z\u0304) ) , (2)\nwhere \u03c6 and \u03c8 are conjunctions of atoms without nulls. For brevity, we write this tgd as \u03c6(x\u0304, y\u0304) \u2192 \u2203z\u0304 \u03c8(x\u0304, z\u0304) and use comma instead of \u2227 for conjoining atoms. Notice that \u03c6\ncan be empty, in which case the tgd is called fact tgd and is written as \u22a4 \u2192 \u2203z\u0304 \u03c8(x\u0304, z\u0304). We assume that each variable in x\u0304 is mentioned in some atom of \u03c8. We call \u03c6 and \u03c8 the body and head of the tgd, respectively. The tgd in (2) is logically equivalent to the expression \u2200x\u0304(q\u03c6(x\u0304) \u2192 q\u03c8(x\u0304)), where q\u03c6(x\u0304) and q\u03c8(x\u0304) are the CQs \u2203y\u0304 \u03c6(x\u0304, y\u0304) and \u2203z\u0304 \u03c8(x\u0304, z\u0304), respectively. Thus, an instance I over S satisfies this tgd iff q\u03c6(I) \u2286 q\u03c8(I). We say that an instance I satisfies a set \u03a3 of tgds, denoted I |= \u03a3, if I satisfies every tgd in \u03a3. We denote by TGD the class of (finite) sets of tgds.\nThe chase is a useful algorithmic tool when reasoning with tgds [22, 31, 39, 41]. We start by defining a single chase step. Let I be an instance over a schema S and \u03c4 = \u03c6(x\u0304, y\u0304) \u2192 \u2203z\u0304 \u03c8(x\u0304, z\u0304) a tgd over S. We say that \u03c4 is applicable w.r.t. I if there exists a tuple (a\u0304, b\u0304) of terms in I such that \u03c6(a\u0304, b\u0304) holds in I . In this case, the result of applying \u03c4 over I with (a\u0304, b\u0304) is the instance J that extends I with every atom in \u03c8(a\u0304, \u22a5\u0304), where \u22a5\u0304 is the tuple obtained by simultaneously replacing each variable z \u2208 z\u0304 with a fresh distinct null not occurring in I . For such a single chase step we write I \u03c4,(a\u0304,b\u0304) \u2212\u2212\u2212\u2212\u2192 J .\nLet us assume now that I is an instance and \u03a3 a finite set of tgds. A chase sequence for I under \u03a3 is a sequence:\nI0 \u03c40,c\u03040\u2212\u2212\u2212\u2192 I1 \u03c41,c\u03041\u2212\u2212\u2212\u2192 I2 \u00b7 \u00b7 \u00b7\nof chase steps such that: (1) I0 = I ; (2) for each i \u2265 0, \u03c4i is a tgd in \u03a3; and (3) \u22c3\ni\u22650 Ii |= \u03a3. We call \u22c3\ni\u22650 Ii the result of this chase sequence, which always exists. Although the result of a chase sequence is not necessarily unique (up to isomorphism), each such result is equally useful for our purposes, since it can be homomorphically embedded into every other result. Thus, from now on, we denote by chase(I,\u03a3) the result of an arbitrary chase sequence for I under \u03a3.\nOntology-mediated queries. An ontology-mediated query (OMQ) is a triple (S,\u03a3, q), where S is a schema, \u03a3 is a set of tgds (the ontology), and q is a (U)CQ over S\u222a sch(\u03a3) (and possibly other predicates), with sch(\u03a3) the set of predicates occurring in \u03a3.1 We call S the data schema. Notice that the set of tgds can introduce predicates not in S, which allows us to enrich the schema of the UCQ q. Moreover, the tgds can modify the content of a predicate R \u2208 S, or, in other words, R can appear in the head of a tgd of \u03a3. We have explicitly included S in the specification of the OMQ to emphasize that it will be evaluated over S-databases, even though \u03a3 and q might use additional relational symbols.\nThe semantics of an OMQ is given in terms of certain answers. The certain answers to a UCQ q(x\u0304) w.r.t. a database D and a set \u03a3 of tgds is the set of tuples:\ncert(q,D,\u03a3) = \u22c2\nI\u2287D,I|=\u03a3\n{c\u0304 \u2208 dom(I)|x\u0304| | c\u0304 \u2208 q(I)}.\nConsider an OMQ Q = (S,\u03a3, q). The evaluation of Q over an S-database D, denoted Q(D), is defined as cert(q,D,\u03a3). It is well-known that cert(q,D,\u03a3) = q(chase(D,\u03a3)); see, e.g., [22]. Thus, Q(D) = q(chase(D,\u03a3)).\nOntology-mediated query languages. We write (C,Q) for the OMQ language that consists of all OMQs of the form (S,\u03a3, q), where \u03a3 falls in the class C of tgds, i.e., C \u2286 TGD (concrete classes of tgds are discussed below), and the query\n1OMQs can be defined for arbitrary first-order theories, not only tgds, and first-order queries, not only UCQs [18].\n(a)\nT(x,y,z) \u2192 \u2203w S(x,w)\nR(x,y), P(y,z) \u2192 \u2203w T(x,y,w)\n(b)\n\u00d7\nT(x,y,z) \u2192 \u2203w S(y,w)\nR(x,y), P(y,z) \u2192 \u2203w T(x,y,w)\nT(x,y,z) \u2192 \u2203w S(x,w)\nR(x,y), P(y,z) \u2192 \u2203w T(x,y,w)\ntechniques (more details on query rewriting are given in Section 4). The goal of stickiness is to capture joins among variables that are not expressible via guarded tgds, but without forcing the chase to terminate. The key property underlying this condition can be described as follows: during the chase, terms that are associated (via a homomorphism) with variables that appear more than once in the body of a tgd (i.e., join variables) are always propagated (or \u201cstick\u201d) to the inferred atoms. This is illustrated in Figure 1(a); the left set of tgds is sticky, while the right set is not. The formal definition is based on an inductive marking procedure that marks the variables that may violate the semantic property of the chase described above [24]. Roughly, during the base step of this procedure, a variable that appears in the body of a tgd \u03c4 but not in every head-atom of \u03c4 is marked. Then, the marking is inductively propagated from head to body as shown in Figure 1(b). Finally, a finite set of tgds \u03a3 is sticky if no tgd in \u03a3 contains two occurrences of a marked variable. Let S be the class of sticky (finite) sets of tgds. Then:\nProposition 4. [24] Eval(S,CQ) and Eval(S,UCQ) are ExpTime-complete, and NP-complete for fixed arity."}, {"heading": "3. OMQ CONTAINMENT: THE BASICS", "text": "The goal of this work is to study in depth the problem of checking whether an OMQ Q1 is contained in an OMQ Q2, both over the same data schema S, or, equivalently, whether Q1(D) \u2286 Q2(D) over every (finite) S-database D. In this case we write Q1 \u2286 Q2; we write Q1 \u2261 Q2 if Q1 \u2286 Q2 and Q2 \u2286 Q1. The OMQ containment problem in question is defined as follows; O1 and O2 are OMQ languages (C,Q), where C is a class of tgds (e.g., linear, non-recursive, sticky, etc.), and Q \u2208 {CQ,UCQ}:\nPROBLEM : Cont(O1,O2) INPUT : Two OMQs Q1 \u2208 O1 and Q2 \u2208 O2. QUESTION : Does Q1 \u2286 Q2?\nWhenever O1 = O2 = O, we refer to the containment problem by simply writing Cont(O).\nIn what follows, we establish some simple but fundamental results, which help to better understand the nature of our problem. We first investigate the relationship between evaluation and containment, which in turn allows us to obtain an initial boundary for the decidability of our problem, i.e., we can obtain a positive result only if the evaluation problem for the involved OMQ languages is decidable (e.g., those introduced in the previous section). We then focus on the OMQ languages introduced in Section 2 and observe that, once we fix the class of tgds, it does not make a difference whether we consider CQs or UCQs. In other words, we show that an OMQ in (C,UCQ), where C \u2208 {G,L,NR, S}, can be rewritten as an OMQ in (C,CQ). This fact simplifies our later complexity analysis since for establishing upper (resp., lower) bounds it suffices to focus on CQs (resp., UCQs)."}, {"heading": "3.1 Evaluation vs. Containment", "text": "As one might expect, OMQ evaluation and OMQ containment are strongly connected. In fact, as we explain below, the former can be easily reduced to the latter. But let us first introduce some auxiliary notation. Consider a database D and a tuple c\u0304 = (c1, . . . , cn) \u2208 dom(D)\nn, where n \u2265 0. We denote by qD,c\u0304(x\u0304), where x\u0304 = (xc1 , . . . , xcn), the CQ\nobtained from the conjunction of atoms occurring in D after replacing each constant c with the variable xc. Consider now an OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 (C,CQ), where C is some class of tgds, an S-database D, and a tuple c\u0304 \u2208 dom(D)|x\u0304|. It is not difficult to show that\nc\u0304 \u2208 Q(D) \u21d0\u21d2 (sch(\u03a3),\u2205, qD,c\u0304) \ufe38 \ufe37\ufe37 \ufe38\nQ1\n\u2286 (sch(\u03a3),\u03a3, q) \ufe38 \ufe37\ufe37 \ufe38\nQ2\n.\nLet O\u2205 be the OMQ language that consists of all OMQs of the form (S,\u2205, q), i.e., the set of tgds is empty, where q is a CQ. It is clear that Q1 \u2208 O\u2205 and Q2 \u2208 (C,CQ). Therefore, for every OMQ language O = (C,CQ), where C is a class of tgds, we immediately get that:\nProposition 5. Eval(O) can be reduced in polynomial time into Cont(O\u2205,O).\nWe now show that the problem of evaluation is reducible to the complement of containment. Let us say that, for technical reasons which will be made clear in a while, we focus our attention on classes C of tgds that are closed under fact tgd extension, i.e., for every set \u03a3 \u2208 C, a set obtained from \u03a3 by adding a (finite) set of fact tgds is still in C. This is not an unnatural assumption since every reasonable class of tgds, such as the ones introduced above, enjoy this property. Consider now an OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 (C,CQ), where C is some class of tgds, an S-database D, and a tuple c\u0304 \u2208 dom(D)|x\u0304|. It is easy to see that\nc\u0304 \u2208 Q(D) \u21d0\u21d2 (S,\u03a3\u22c6D, q \u22c6 c\u0304 )\n\ufe38 \ufe37\ufe37 \ufe38 Q1\n6\u2286 (S,\u2205, \u2203xP (x)) \ufe38 \ufe37\ufe37 \ufe38\nQ2\n,\nwhere \u03a3\u22c6D is obtained from \u03a3 by renaming each predicate R in \u03a3 into R\u22c6 6\u2208 S and adding the set of fact tgds\n{\u22a4 \u2192 R\u22c6(c1, . . . , ck) | R(c1, . . . , ck) \u2208 D},\nq\u22c6c\u0304 is obtained from q(c\u0304) by renaming each predicate R into R\u22c6 6\u2208 S, and the predicate P does not occur in S. Indeed, the above equivalence holds since P 6\u2208 S implies that Q2(D) = \u2205, for every S-database D. Since C is closed under fact tgd extension, Q1 \u2208 (C,CQ), while Q2 \u2208 O\u2205. We write coCont(O1,O2) for the complement of Cont(O1,O2). Hence, for every OMQ language O = (C,CQ), where C is a class of tgds (closed under fact tgd extension), it holds that:\nProposition 6. Eval(O) can be reduced in polynomial time into coCont(O,O\u2205).\nBy definition, O\u2205 is contained in every OMQ language (C,CQ), where C is a class of tgds. Therefore, as a corollary of Propositions 5 and 6, we obtain an initial boundary for the decidability of OMQ containment: we can obtain a positive result only if the evaluation problem for the involved OMQ languages is decidable. More formally:\nCorollary 7. Cont(O1,O2) is undecidable if Eval(O1) is undecidable or Eval(O2) is undecidable.\nCan we prove the converse of Corollary 7: Cont(O1,O2) is decidable if both Eval(O1) and Eval(O2) are decidable? The answer to this question is negative. This is due to the fact that containment of Datalog queries is undecidable [45]. Since Datalog queries can be directly encoded in the OMQ language based on the class F of full tgds, i.e., those without existentially quantified variables, we obtain the following:\nProposition 8. [45] Cont((F,CQ)) is undecidable.\nThis result, combined with the fact that Eval(F) is decidable (since the chase under full tgds always terminates), implies that the converse of Corollary 7 does not hold. Proposition 8 also rules out the OMQ languages that are based on classes of tgds that extend F; e.g., the weak versions of the ones introduced in Section 2, called weakly guarded [22], weakly acyclic [31], and weakly sticky [24] that guarantee the decidability of OMQ evaluation.2 The question that comes up concerns the decidability and complexity of containment for the OMQ languages that are based on the non-weak versions of the above classes, i.e., guarded, non-recursive, and sticky. This will be the subject of the next two sections."}, {"heading": "3.2 From UCQs to CQs", "text": "Before we proceed with the complexity analysis of containment for the OMQ languages in question, let us state the following useful result:\nProposition 9. Given an OMQ Q \u2208 (C,UCQ), where C \u2208 {G,L,NR, S}, we can construct in polynomial time an OMQ Q\u2032 \u2208 (C,CQ) such that Q \u2261 Q\u2032.\nThe proof of Proposition 9 relies on the idea of encoding boolean operations (in our case the \u2018or\u2019 operator) using a set of atoms; this idea has been used in several other works (see, e.g., [13, 20, 34]). Proposition 9 allows us to focus on OMQs that are based on CQs; in fact, Cont((C1,CQ), (C2,CQ)) is C-complete, where C1,C2 \u2208 {G,L,NR, S} and C is a complexity class that is closed under polynomial time reductions, iff Cont((C1,UCQ), (C2,UCQ)) is C-complete."}, {"heading": "3.3 Plan of Attack", "text": "We are now ready to proceed with the complexity analysis of containment for the OMQ languages in question. Our plan of attack can be summarized as follows:\n\u2022 We consider, in Section 4, Cont((C,CQ)), for C \u2208 {L,NR, S}. These languages enjoy a crucial property, called UCQ rewritability, which is very useful for our purposes. This property allows us to show the following result: if the containment does not hold, then this is witnessed via a \u201csmall\u201d database, which in turn allows us to devise simple guess-and-check algorithms. \u2022 We then proceed, in Section 5, with Cont((G,CQ)). This OMQ language does not enjoy UCQ rewritability, and the task of establishing a small witness property as above turned out to be challenging. However, we show the following: if the containment does not hold, then this is witnessed via a \u201ctree-shaped\u201d database, which allows us to devise a decision procedure based on two-way alternating parity automata on finite trees. \u2022 In Section 6, we study the case where the OMQ containment problem involves two different languages. If the left-hand side language is UCQ rewritable, then we can devise a guess-and-check algorithm by exploiting the above small witness property. The challenging case is when the left-hand side language is (G,CQ), where again we employ techniques based on tree automata.\n2The idea of those classes is the same: relax the conditions in the definition of the class, so that only those positions that receive null values during the chase are taken into account."}, {"heading": "4. UCQ REWRITABLE LANGUAGES", "text": "We now focus on OMQ languages that enjoy the crucial property of UCQ rewritability.\nDefinition 1. (UCQ Rewritability) An OMQ language (C,CQ), where C \u2286 TGD, is UCQ rewritable if, for each OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 (C,CQ) we can construct a UCQ q\u2032(x\u0304) such that Q(D) = q\u2032(D) for every S-database D.\nWe proceed to establish our desired small witness property, based on UCQ rewritability. By the definition of UCQ rewritability, for each language O that is UCQ rewritable, there exists a computable function fO from O to the natural numbers such that the following holds: for every OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 O, and UCQ rewriting q1(x\u0304)\u2228 \u00b7 \u00b7 \u00b7 \u2228 qn(x\u0304) of Q, it is the case that max1\u2264i\u2264n{|qi|} \u2264 fO(Q), where |qi| denotes the number of atoms occurring in qi. Then:\nProposition 10. Consider a UCQ rewritable language O, and two OMQs Q \u2208 O and Q\u2032 \u2208 (TGD,CQ), both with data schema S. If Q 6\u2286 Q\u2032, then there exists an S-database D, where |D| \u2264 fO(Q), such that Q(D) 6\u2286 Q \u2032(D).\nIn Proposition 10 we assume that the left-hand side query falls in a UCQ rewritable language, be we do not pose any restriction on the language of the right-hand side query. Thus, we immediately get a decision procedure for Cont(O1,O2) if O1 is UCQ rewritable and Eval(O2) is decidable. Given Q1 = (S,\u03a31, q1(x\u0304)) \u2208 O1 and Q2 = (S,\u03a32, q2(x\u0304)) \u2208 O2:\n1. Guess an S-database D such that |D| \u2264 fO1(Q1), and\na tuple c\u0304 \u2208 dom(D)|x\u0304|; and\n2. Verify that c\u0304 \u2208 Q1(D) and c\u0304 6\u2208 Q2(D).\nWe immediately get that:\nTheorem 11. Cont(O1,O2) is decidable if O1 is UCQ rewritable and Eval(O2) is decidable.\nThis general result shows that Cont((C,CQ)) is decidable for every C \u2208 {L,NR, S}, but it says nothing about its complexity. This will be the subject of the rest of the section."}, {"heading": "4.1 Linearity", "text": "The problem of computing UCQ rewritings for OMQs in (L,CQ) has been studied in [33], where a resolution-based procedure, called XRewrite, has been proposed. This rewriting algorithm accepts a query Q = (S,\u03a3, q(x\u0304)) \u2208 (L,CQ) and constructs a UCQ rewriting q\u2032(x\u0304) over S by starting from q and exhaustively applying rewriting steps based on resolution. Let us illustrate this via a simple example:\nExample 1. Assume that S = {P, T}. Consider the set \u03a3 consisting of the linear tgds\nP (x) \u2192 \u2203y R(x, y), R(x, y) \u2192 P (y), T (x) \u2192 P (x),\nand the CQ q(x\u0304) := \u2203y(R(x, y) \u2227 P (y)). XRewrite will first resolve the atom P (y) in q using the second tgd, and produce the CQ \u2203y(R(x, y)\u2227R(x, z)), which is equivalent to the CQ \u2203y R(x, y). Then, \u2203y R(x, y) will be resolved using the first tgd, and the CQ P (x) will be obtained, which in turn will be resolved using the third tgd in order to produce the CQ T (x). The UCQ rewriting q\u2032(x\u0304) is P (x) \u2228 T (x).\nIt is easy to see that, whenever the input OMQ consists of linear tgds, during the execution of XRewrite it is not possible to obtain a CQ that has more atoms than the original one. This is an immediate consequence of the fact that linear tgds have only one atom in their body. Then:\nProposition 12. f(L,CQ) ( (S,\u03a3, q) ) \u2264 |q|.\nHaving the above result in place, it can be shown that the algorithm underlying Theorem 11 guesses a polynomially sized witness to non-containment, and then calls a C-oracle for solving query evaluation under linear OMQs, where C is PSpace in general, and NP if the arity is fixed; these complexity classes are obtained from Proposition 2. Therefore, coCont((L,CQ)) is in PSpace in general, and in \u03a3P2 in case of fixed arity. Regarding the lower bounds, Proposition 5 allows us to inherit the PSpace-hardness of Eval(L,CQ); this holds even for constant-free tgds. Unfortunately, in the case of fixed arity, we can only obtain NP-hardness, while Proposition 6 allows to obtain coNP-hardness. Nevertheless, it is implicit in [16] (see the proof of Theorem 9), where the containment problem for OMQ languages based on description logics is considered, that Cont((L,CQ)) is \u03a0P2 -hard, even for tgds of the form P (x) \u2192 R(x). Then:\nTheorem 13. Cont((L,CQ)) is PSpace-complete, and \u03a0P2 -complete if the arity of the schema is fixed. The lower bounds hold even for tgds without constants."}, {"heading": "4.2 Non-Recursiveness", "text": "Although the OMQ language (NR,CQ) is not explicitly considered in [33], where the algorithm XRewrite is defined, the same algorithm can deal with (NR,CQ). By analyzing the UCQ rewritings constructed by XRewrite, whenever the input query falls in (NR,CQ), we can establish the following result; here, body(\u03c4 ) denotes the body of the tgd \u03c4 :\nProposition 14. It holds that\nf(NR,CQ) ( (S,\u03a3, q) ) \u2264 |q| \u00b7\n(\nmax \u03c4\u2208\u03a3 {|body(\u03c4 )|}\n)|sch(\u03a3)|\n.\nProposition 14 implies that non-containment for queries that fall in (NR,CQ) is witnessed via a database of at most exponential size. We show next that this bound is optimal:\nProposition 15. There are sets of (NR,CQ) OMQs\n{Qn1 = (S,\u03a3 n 1 , q1)}n>0 and {Q n 2 = (S,\u03a3 n 2 , q2)}n>0,\nwhere |sch(\u03a3n1 )| = |sch(\u03a3 n 2 )| = n + 2, such that for every S-database D, if Qn1 (D) 6\u2286 Q n 2 (D) then |D| \u2265 2 n\u22121.\nLet us now focus on the complexity of Cont((NR,CQ)). The algorithm underlying Theorem 11, together with the exponential bound provided by Proposition 14, implies that coCont((NR,CQ)) is feasible in non-deterministic exponential time with access to a NExpTime oracle, which immediately implies that Cont((NR,CQ)) is in ExpSpace. Unfortunately, the exact complexity of Cont((NR,CQ)) is still an open problem, and we conjecture that is PNEXP-complete; recall that NExpTime \u2286 PNEXP \u2286 ExpSpace. In what follows, we briefly explain how the PNEXP-hardness is obtained. To this end, we exploit a tiling problem that has been recently introduced in [30]. Roughly speaking, an instance of\nthis tiling problem is a triple (m,T1, T2), where m is an integer in unary representation, and T1, T2 are standard tiling problems for the exponential grid 2n \u00d7 2n. The question is whether, for every initial condition w of length m, T1 has no solution with w or T2 has some solution with w. The initial condition w simply fixes the first m tiles of the first row of the grid. We construct in polynomial time two (NR,CQ) queries Q1 and Q2 such that (m,T1, T2) has a solution iff Q1 \u2286 Q2. The idea is to force every input database to store an initial condition w of length m, and then encode the problem whether Ti has a solution with w into Qi, for each i \u2208 {1, 2}. From the above discussion we get that:\nTheorem 16. Cont((NR,CQ)) is in ExpSpace, and PNEXP-hard. The lower bound holds even if the arity of the schema is fixed and the tgds are without constants."}, {"heading": "4.3 Stickiness", "text": "We now focus on (S,CQ). As shown in [33], given a query (S,\u03a3, q), there exists an execution of XRewrite that constructs a UCQ rewriting q1(x\u0304)\u2228 \u00b7 \u00b7 \u00b7 \u2228 qn(x\u0304) over S with the following property: for each i \u2208 {1, . . . , n}, if a variable v occurs in qi in more than one atom, then v already occurs in q. This property has been used in [33] to bound the number of atoms that can appear in a single CQ qi. We write T (q) for the set of terms (constants and variables) occurring in q, C(\u03a3) for the set of constants occurring in \u03a3, and ar(S) for the maximum arity over all predicates of S.\nProposition 17. It holds that\nf(S,CQ)((S,\u03a3, q)) \u2264 |S| \u00b7 (|T (q)|+ |C(\u03a3)|+ 1) |ar(S)| .\nProposition 17 implies that non-containment for (S,CQ) queries is witnessed via a database of at most exponential size. As for (NR,CQ) queries, we can show that this bound is optimal; here, for a set \u03a3 of tgds, we denote by ||\u03a3|| the number of symbols occurring in \u03a3:\nProposition 18. There exists a set of (S,CQ) OMQs\n{Qn = ({S/n},\u03a3n, q(x\u0304))}n>0, where ||\u03a3 n|| \u2208 O(n2),\nsuch that for every Q = ({S},\u03a3\u2032, q\u2032(x\u0304)) \u2208 (TGD,CQ) and {S}-database D, if Qn(D) 6\u2286 Q(D) then |D| \u2265 2n\u22122.\nWe now study the complexity of Cont((S,CQ)). We first focus on schemas of unbounded arity. Proposition 17 implies that the algorithm underlying Theorem 11 runs in exponential time assuming access to a C-oracle, where C is a complexity class powerful enough for solving Eval(S,CQ) and its complement. But, since Eval(S,CQ) is in ExpTime (see Proposition 4), both Eval(S,CQ) and its complement are in NExpTime, and thus, the oracle call is not really needed. Consequently, coCont((C,CQ)) is in NExpTime.\nA matching lower bound is obtained by a reduction from the standard tiling problem for the exponential grid 2n\u00d72n. In fact, the same lower bound has been recently established in [14]; however, our result is stronger as it shows that the problem remains hard even if the right-hand side query is a linear OMQ of a simple form \u2013 this is also discussed in Section 6, where containment of queries that fall in different OMQ languages is studied. Regarding schemas of fixed arity, Proposition 17 provides a witness for non-containment of polynomial size, which implies that the algorithm underlying\nTheorem 11 runs in polynomial time with access to an NPoracle. Therefore, coEval(S,CQ) is in \u03a3P2 , while a matching lower bound is implicit in [16]. Then:\nTheorem 19. Cont((S,CQ)) is coNExpTime-complete, even if the set of tgds uses only two constants. In the case of fixed arity, it is \u03a0P2 -complete, even for constant-free tgds."}, {"heading": "5. GUARDEDNESS", "text": "We proceed with the problem of containment for guarded OMQs, and we establish the following result:\nTheorem 20. Cont((G,CQ)) is 2ExpTime-complete. The lower bound holds even if the arity of the schema is fixed, and the tgds are without constants.\nThe lower bound is immediately inherited from [15], where it is shown that containment for OMQs based on the description logic ELI is 2ExpTime-hard. Recall that a set of ELI axioms can be equivalently rewritten as a constant-free set of guarded tgds using only unary and binary predicates, which implies the lower bound stated in Theorem 20. However, we cannot immediately inherit the desired upper bound since the DL-based OMQ languages considered in [15] are either weaker than or incomparable to (G,CQ). Nevertheless, the technique developed in [15] was extremely useful for our analysis. Actually, our automata-based procedure exploits a combination of ideas from [15, 37]. The rest of this section is devoted to providing a high-level explanation of this procedure.\nFor the sake of technical clarity, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, for simplicity, we focus on Boolean CQs. In other words, we study the problem for (G,BCQ), where BCQ denotes the class of Boolean CQs. This does not affect the generality of our proof since it is known that Cont((G,CQ)) can be reduced in polynomial time to Cont((G,BCQ)) [15].\nA first glimpse. As already said, (G,CQ) is not UCQ rewritable and, therefore, we cannot employ Proposition 10 in order to establish a small witness property as for the languages considered in Section 4. We have tried to establish a small witness property for (G,CQ) by following a different route, but it turned out to be a difficult task. Nevertheless, we can show a tree witness property, which states that non-containment for (G,CQ) is witnessed via a treelike database. This allows us to devise a procedure based on alternating tree automata. Summing up, the proof for the 2ExpTime membership of (G,CQ) proceeds in three steps:\n1. Establish a tree witness property;\n2. Encode the tree-like witnesses as trees that can be accepted by an alternating tree automaton; and\n3. Construct an automaton that decides Cont((G,CQ)); in fact, we reduce Cont((G,CQ)) into emptiness for two-way alternating parity automata on finite trees.\nEach one of the above three steps is discussed in more details in the following three sections."}, {"heading": "5.1 Tree Witness Property", "text": "From the above informal discussion, it is clear that treelike databases are crucial for our analysis. Let us make this notion more precise using guarded tree decompositions. A tree decomposition of a database D is a labeled rooted tree T = (V,E, \u03bb), where \u03bb : V \u2192 2dom(D), such that: (i) for each atom R(t1, . . . , tn) \u2208 D, there exists v \u2208 V such that \u03bb(v) \u2287 {t1, . . . , tn}, and (ii) for every term t \u2208 dom(D), the set {v \u2208 V | t \u2208 \u03bb(v)} induces a connected subtree of T . The tree decomposition T is called [U ]-guarded, where U \u2286 V , if, for every node v \u2208 V \\ U , there exists an atom R(t1, . . . , tn) \u2208 D such that \u03bb(v) \u2286 {t1, . . . , tn}. We write root(T ) for the root node of T , and DT (v), where v \u2208 V , for the subset of D induced by \u03bb(v). We are now ready to formalize the notion of the tree-like database:\nDefinition 2. An S-database D is a C-tree, where C \u2286 D, if there is a tree decomposition T of D such that:\n1. DT (root(T )) = C and\n2. T is [{root(T )}]-guarded.\nRoughly, whenever a database D is a C-tree, C is the cyclic part ofD, while the rest ofD is tree-like. Interestingly, for deciding Cont((G,BCQ)) it suffices to focus on databases that are C-trees and |dom(C)| depends only on the left-hand side OMQ. Recall that for a schema S we write ar(S) for the maximum arity over all predicates of S. Then:\nProposition 21. Let Qi = (S,\u03a3i, qi) \u2208 (G,BCQ), for i \u2208 {1, 2}. The following are equivalent:\n1. Q1 \u2286 Q2.\n2. Q1(D) \u2286 Q2(D), for every C-tree S-database D such that |dom(C)| \u2264 (ar(S \u222a sch(\u03a31)) \u00b7 |q1|).\nThe fact that (1) \u21d2 (2) holds trivially, while (2) \u21d2 (1) is shown by using a variant of the notion of guarded unravelling and compactness. Let us clarify that the above result does not provide a decision procedure for Cont((G,BCQ)), since we have to consider infinitely many databases that are Ctrees with |dom(C)| \u2264 (ar(S \u222a sch(\u03a31)) \u00b7 |q1|)."}, {"heading": "5.2 Encoding Tree-like Databases", "text": "It is generally known that a database D whose treewidth3 is bounded by an integer k can be encoded into a tree over a finite alphabet of double-exponential size in k that can be accepted by an alternating tree automaton; see, e.g., [12]. Consider an alphabet \u0393, and let N\u2217 be the set of finite sequences of natural numbers, including the empty sequence. A \u0393-labeled tree is a pair L = (T, \u03bb), where T \u2286 N\u2217 is closed under prefixes, and \u03bb : T \u2192 \u0393 is the labeling function. The elements of T identify the nodes of L. It can be shown that D and a tree decomposition T of D with width k can be encoded as a \u0393-labeled tree L, where \u0393 is an alphabet of double-exponential size in k, such that each node of T corresponds to exactly one node of L and vice versa.\nConsider now a C-tree S-database D, and let T be the tree decomposition that witnesses that D is a C-tree. The width of T is at most k = (|dom(C)| + ar(S) \u2212 1), and thus, the\n3Recall that the treewidth of a database D is the minimum width among all possible tree decompositions T = (V,E, \u03bb) of D, while the width of T is defined as maxv\u2208V {|\u03bb(v)|}\u22121.\ntreewidth of D is bounded by k. Hence, from the above discussion, D and T can be encoded as a \u0393-labeled tree, where \u0393 is of double-exponential size in k. In general, given an Sdatabase D that is a C-tree due to the tree decomposition T , we show that D and T can be encoded as a \u0393S,l-labeled tree, with |dom(C)| \u2264 l and |\u0393S,l| being double-exponential in ar(S) and exponential in |S| and l.\nAlthough every C-tree S-database D can be encoded as a \u0393S,l-labeled tree, the other direction does not hold. In other words, it is not true that every \u0393S,l-labeled tree encodes a C-tree S-database D and its corresponding tree decomposition. In view of this fact, we need the additional notion of consistency. A \u0393S,l-labeled tree is called consistent if it satisfies certain syntactic properties \u2013 we do not give these properties here since they are not vital in order to understand the high-level idea of the proof. Now, given a consistent \u0393S,l-labeled tree L, we can show that L can be decoded into an S-database JLK that is a C-tree with |dom(C)| \u2264 l. From the above discussion and Proposition 21, we obtain the following technical lemma:\nLemma 22. Let Qi = (S,\u03a3i, qi) \u2208 (G,BCQ), for i \u2208 {1, 2}. The following are equivalent:\n1. Q1 \u2286 Q2.\n2. Q1(JLK) \u2286 Q2(JLK), for every consistent \u0393S,l-labeled tree L, where l = (ar(S \u222a sch(\u03a31)) \u00b7 |q1|)."}, {"heading": "5.3 Constructing Tree Automata", "text": "Having the above result in place, we can now proceed with our automata-based procedure. We make use of twoway alternating parity automata (2WAPA) that run on finite labeled trees. Two-way alternating automata process the input tree while branching in an alternating fashion to successor states, and thereby moving either down or up the input tree; the detailed definition can be found in [10]. Our goal is to reduce Cont((G,BCQ)) to the emptiness problem for 2WAPA. As usual, given a 2WAPA A, we denote by L(A) the language of A, i.e., the set of labeled trees it accepts. The emptiness problem is defined as follows: given a 2WAPA A, does L(A) = \u2205? Thus, given Q1, Q2 \u2208 (G,BCQ), we need to construct a 2WAPA A such that Q1 \u2286 Q2 iff L(A) = \u2205. It is well-known that deciding whether L(A) = \u2205 is feasible in exponential time in the number of states, and in polynomial time in the size of the input alphabet [28]. Therefore, in order to obtain the desired 2ExpTime upper bound, we should construct A in double-exponential time, while the number of states must be at most exponential.\nWe first need a way to check consistency of labeled trees. It is not difficult to devise an automaton for this task.\nLemma 23. Consider a schema S and an integer l > 0. There is a 2WAPA CS,l that accepts a \u0393S,l-labeled tree L iff L is consistent. The number of states of CS,l is logarithmic in the size of \u0393S,l. Furthermore, CS,l can be constructed in polynomial time in the size of \u0393S,l.\nNow, the crucial task is, given an OMQ Q \u2208 (G,BCQ), to devise an automaton that accepts labeled trees which correspond to databases that make Q true. We write ||Q|| for the number of symbols that appear in Q.\nLemma 24. Let Q = (S,\u03a3, q) \u2208 (G,BCQ). There is a 2WAPA AQ,l, where l > 0, that accepts a consistent \u0393S,llabeled tree L iff Q(JLK) 6= \u2205. The number of states of\nAQ,l is exponential in ||Q|| and l. Furthermore, AQ,l can be constructed in double-exponential time in ||Q|| and l.\nThe intuition underlying AQ,l can be described as follows. AQ,l tries to identify all the possible ways the CQ q can be mapped to chase(D,\u03a3), for any C-tree S-database D such that |dom(C)| \u2264 l. It then arrives at possible ways how the input tree can satisfy Q. These \u201cpossible ways\u201d correspond to squid decompositions, a notion introduced in [22] that indicates which part of the query is mapped to the cyclic part C ofD, and which to the tree-like part of D. The automaton exhaustively checks all squid decompositions by traversing the input tree and, at the same time, explores possible ways how to match the single parts of the squid decomposition at hand. The automaton finally accepts if it finds a squid decomposition that can be mapped to chase(D,\u03a3).\nHaving the above automata in place, we can proceed with our main technical result, which shows that Cont(G,BCQ) can be reduced to the emptiness problem for 2WAPA. But let us first recall some key results about 2WAPA, which are essential for our final construction. It is well-known that languages accepted by 2WAPAs are closed under intersection and complement. Given two 2WAPAs A1 and A2, we write A1 \u2229 A2 for a 2WAPA, which can be constructed in polynomial time, that accepts the language L(A1) \u2229 L(A2). Moreover, for a 2WAPA A, we write A for the 2WAPA, which is also constructible in polynomial time, that accepts the complement of L(A). We can now show the following:\nProposition 25. Consider Q1, Q2 \u2208 (G,BCQ). We can construct in double-exponential time a 2WAPA A, which has exponentially many states, such that\nQ1 \u2286 Q2 \u21d0\u21d2 L(A) = \u2205.\nProof (sketch). Let Qi = (S,\u03a3i, qi), for i \u2208 {1, 2}, and l = (ar(S \u222a sch(\u03a31)) \u00b7 |q1|). Then A is defined as:\n(CS,l \u2229 AQ1,l) \u2229 AQ2,l.\nSince \u0393S,l has double-exponential size, Lemmas 23 and 24 imply that A can be constructed in double-exponential time, while it has exponentially many states. Lemma 22 implies that Q1 \u2286 Q2 iff L(A) = \u2205, and the claim follows.\nProposition 25 implies that Cont((G,BCQ)) is in 2ExpTime, and Theorem 20 follows."}, {"heading": "6. COMBINING LANGUAGES", "text": "In the previous two sections, we studied the containment problem relative to a language O, i.e., both OMQs fall in O. However, it is natural to consider the version of the problem where the involved OMQs fall in different languages. This is the goal of this section. Our analysis proceeds by considering the two cases where the left-hand side (LHS) query falls in a UCQ rewritable OMQ language, or it is guarded."}, {"heading": "6.1 The LHS Query is UCQ Rewritable", "text": "As an immediate corollary of Theorem 11 we obtain the following result: Cont((C1,CQ), (C2,CQ)), for C1 6= C2, C1 \u2208 {L,NR, S} and C2 \u2208 {L,NR, S,G}, is decidable. By exploiting the algorithm underlying Theorem 11, we establish optimal upper bounds for all the problems at hand with the only exception of Cont((S,CQ), (NR,CQ)). For the latter, we obtain an ExpSpace upper bound, by providing\na similar analysis as for Cont((NR,CQ)), while a NExpTime lower bound is inherited from query evaluation by exploiting Proposition 5. It is rather tedious, and not very interesting from a technical point of view, to go through all the containment problems in question4 and explain in details how the exact upper bounds are obtained; a summarization of those complexity results can be found in [10].\nRegarding the matching lower bounds, in most of the cases they are inherited from query evaluation or its complement by exploiting Propositions 5 and 6, respectively. There are, however, some exceptions:\n\u2022 Cont((S,CQ), (L,CQ)) in the case of unbounded arity, where the problem is coNExpTime-hard, even for sets of tgds that use only two constants. This is shown by a reduction from the standard tiling problem for the exponential grid 2n \u00d7 2n.\n\u2022 Cont((L,CQ), (S,CQ)) and Cont((S,CQ), (L,CQ)) in the case of bounded arity, where both problems are \u03a0P2 -hard even for constant-free tgds; implicit in [16]."}, {"heading": "6.2 The LHS Query is Guarded", "text": "We proceed with the case where the LHS query is guarded, and we show the following result:\nTheorem 26. Cont((G,CQ), (C,CQ)) is C-complete:\nC =\n \n\n2ExpTime, C \u2208 {L, S},\n3ExpTime, C = NR.\nThe lower bounds hold even if the arity of the schema is fixed. Moreover, for C = L (resp., C \u2208 {NR, S}) it holds even for tgds with one constant (resp., without constants).\nUpper bounds. The 2ExpTime membership when C = L is an immediate corollary of Theorem 20. This is not true when C \u2208 {NR, S} since the right-hand side query is not guarded. But in this case, since (NR,CQ) and (S,CQ) are UCQ rewritable, one can rewrite the right-hand side query as a UCQ, and then apply the machinery developed in Section 5 for solving Cont((G,CQ)). More precisely, given OMQs Q1 \u2208 (G,CQ) and Q2 \u2208 (C,CQ), where C \u2208 {NR, S}, Q1 \u2286 Q2 iff Q1 \u2286 q, where q is a UCQ rewriting of Q2. Thus, an immediate decision procedure, which exploits the algorithm XRewrite, is the following:\n1. Let q = XRewrite(Q2);\n2. For each q\u2032 \u2208 q: if Q1 \u2286 q \u2032, then proceed; otherwise,\nreject; and\n3. Accept.\nThe above procedure runs in triple-exponential time. The first step is feasible in double-exponential time [33]. Now, for a single CQ q\u2032 \u2208 q (which is a guarded OMQ with an empty set of tgds) the check whether Q1 \u2286 q\n\u2032 can be done by using the machinery developed in Section 5, which reduces our problem to checking whether the language of a 2WAPA A is empty. However, it should not be forgotten\n4There are eighteen different cases obtained by considering all the possible pairs (O1,O2) of OMQ languages, where O1 6= O2 and O1 is UCQ rewritable, and the two cases whether the arity of the schema is fixed or not.\nthat q\u2032 is of exponential size, and thus, the automaton A has double-exponentially many states. This in turn implies that checking whether L(A) = \u2205 is in 3ExpTime, as claimed.\nAlthough the above algorithm establishes an optimal upper bound for non-recursive OMQs, a more refined analysis is needed for sticky OMQs. In fact, we need a more refined complexity analysis for the problem Cont((G,CQ),UCQ), that is, to decide whether a guarded OMQ is contained in a UCQ. To this end, we provide an automata construction different from the one employed in Section 5, which allows us to establish a refined complexity upper bound for the problem in question. Consider a (G,CQ) query Q, and a UCQ q = q1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 qn. As usual, we write ||Q|| and ||qi|| for the number of symbols that occur in Q and qi, respectively, and we write var\u22652(qi) for the set of variables that appear in more than one atom of qi. By exploiting our new automata-based procedure, we show that the problem of checking if Q \u2286 q is feasible in double-exponential time in (||Q|| + max1\u2264i\u2264n{|var\u22652(qi)|}), exponential time in max1\u2264i\u2264n{||qi||}, and polynomial time in n.\nThis result allows us to show that the above procedure establishes 2ExpTime-membership when the right-hand side OMQ is sticky. But first we need to recall the following key properties of the UCQ rewriting q = XRewrite(Q2), constructed during the first step of the algorithm:\n1. q consists of double-exponentially many CQs,\n2. each CQ of q is of exponential size, and\n3. for each q\u2032 \u2208 q, var\u22652(q \u2032) is a subset of the variables\nof the original CQ that appears in Q2.\nBy combining these key properties with the complexity analysis performed above, it is now straightforward to show that Cont((G,CQ), (S,CQ)) is in 2ExpTime.\nLower Bounds. We establish matching lower bounds by refining techniques from [27], where it is shown that containment of Datalog in UCQ is 2ExpTime-complete, while containment of Datalog in non-recursive Datalog is 3ExpTimecomplete; the lower bounds hold for fixed-arity predicates, and constant-free rules. Interestingly, the LHS query can be transformed into a Datalog query such that each rule has a body-atom that contains all the variables, i.e., is guarded. This is achieved by increasing the arity of some predicates in order to have enough positions for all the bodyvariables. However, for each rule, the number of unguarded variables that we need to guard is constant, and thus, the arity of the schema remains constant. We conclude that Cont((G,CQ), (NR,CQ)) is 3ExpTime-hard. Moreover, containment of guarded OMQs in UCQs is 2ExpTime-hard, which in turn allows us to show, by exploiting the construction underlying Proposition 9, that Cont((G,CQ), (L,CQ)) is 2ExpTime-hard, even if the set of linear tgds uses only one constant, while Cont((G,CQ), (S,CQ)) is 2ExpTime-hard, even for tgds without constants."}, {"heading": "7. APPLICATIONS", "text": "Interestingly, our results on Cont((G,CQ)) can be applied to other important static analysis tasks, in particular, distribution over components and UCQ rewritability. Each one of those tasks is considered in the following two sections."}, {"heading": "7.1 Distribution Over Components", "text": "The notion of distribution over components has been introduced in [2], and it states that the answer to a query can be computed by parallelizing it over the (maximally connected) components of the input database. But let us first make precise what a component is. A set of atoms A is connected if for all c, d \u2208 dom(A), there exists a sequence \u03b11, . . . , \u03b1n of atoms in A such that c \u2208 dom(\u03b11), d \u2208 dom(\u03b1n), and dom(\u03b1i) \u2229 dom(\u03b1i+1) 6= \u2205, for each i \u2208 {1, . . . , n \u2212 1}. We call B \u2286 A a component of A if (i) B is connected, and (ii) for every \u03b1 \u2208 A \\ B, B \u222a {\u03b1} is not connected.5 Let co(A) be the set of components of A. We are now ready to introduce the notion of distribution over components. Consider an OMQ Q = (S,\u03a3, q) \u2208 (TGD,CQ). We say that Q distributes over components if Q(D) = Q(D1)\u222a\u00b7 \u00b7 \u00b7\u222aQ(Dn), where co(D) = {D1, . . . , Dn}, for every S-database D. In this case, Q(D) can be computed without any communication over a network using a distribution where every computing node is assigned some of the components of the database, and every component is assigned to at least one computing node. In other words, Q can be evaluated in a distributed and coordination-free manner; for more details on coordination-free evaluation see [2, 3, 4]. Therefore, it would be quite beneficial if we can decide whether an OMQ distributes over components, and thus, we obtain the following interesting static analysis task:\nPROBLEM : Dist(C,CQ) INPUT : An OMQ Q \u2208 (C,CQ). QUESTION : Does Q distributes over components?\nThe above problem has been studied in [14], where tight complexity bounds for (L,CQ) and (S,CQ) have been established. However, its exact complexity for guarded OMQs has been left open. Our results on containment for guarded OMQs allow us to close this problem. But first we need to recall a key result that semantically characterizes distribution over components. An OMQ Q with data schema S is unsatisfiable if there is no S-database D such that Q(D) 6= \u2205. Moreover, for a CQ q, we write co(q) for its components. The next result has been shown in [14]:\nProposition 27. Let Q = (S,\u03a3, q(x\u0304)) \u2208 (G,CQ). The following are equivalent:\n1. Q distributes over components.\n2. Q is unsatisfiable or there exists q\u0302(x\u0304) \u2208 co(q) such that (S,\u03a3, q\u0302(x\u0304)) \u2286 Q.\nChecking unsatisfiability can be easily reduced to containment. Thus, the above result, together with Theorem 20, implies that Dist(G,CQ) is in 2ExpTime, while a matching lower bound is implicit in [14]. Then:\nTheorem 28. Dist(G,CQ) is 2ExpTime-complete."}, {"heading": "7.2 Deciding UCQ Rewritability", "text": "Query rewriting is a well-studied method for evaluating OMQs using standard database technology. The key idea is the following: given an OMQ Q = (S,\u03a3, q(x\u0304)), combine \u03a3\n5For technical clarity, the notion of component is defined only for sets of atoms that do not contain 0-ary atoms.\nand q into a new query q\u03a3(x\u0304), the so-called rewriting, which can then be evaluated over D yielding the same answer as Q over D, for every S-database D. For this approach to be realistic, though, it is essential that the rewriting is expressed in a language that can be handled by standard database systems. The typical language that is considered in this setting is first-order (FO) queries [25]. Notice, however, that due to Rossman\u2019s Theorem [43], and the fact that OMQs are closed under homomorphisms, FO and UCQ rewritability coincide. Recall that some OMQ languages are UCQ rewritable, such as the ones based on linear, non-recursive and sticky sets of tgds, while others are not, e.g., guarded OMQs. For those languages O that are not UCQ rewritable, it is important to be able to check whether a query Q \u2208 O can be rewritten as a UCQ, in which case we say that it is UCQ rewritable. This gives rise to the following fundamental static analysis task for an OMQ language (C,CQ), where C \u2286 TGD:\nPROBLEM : UCQRew(C,CQ) INPUT : An OMQ Q \u2208 (C,CQ). QUESTION : Is it the case that Q is UCQ rewritable?\nBienvenu et al. have recently carried out an in-depth study of the above problem for OMQ languages based on central Horn-DLs [15]. One of their main results is that the above problem for the OMQ language based on ELHI, one of the most expressive members of the EL-family of DLs, is 2ExpTime-complete. Interestingly, by adapting the tree automata techniques developed in Section 5, we can generalize the above result: deciding UCQ rewritability for the OMQ language based on guarded tgds over unary and binary relations is in 2ExpTime. Let G2 be the class of (finite) sets of guarded tgds over unary and binary relations. Then:\nTheorem 29. UCQRew(G2,CQ) is 2ExpTime-complete.\nSince the lower bound is inherited from [15], we concentrate on the upper bound. As in Section 5, we can focus on BCQs, i.e., it suffices to show that UCQRew(G2,BCQ) is in 2ExpTime. Our proof proceeds in two steps:\n1. We semantically characterize UCQ rewritability for queries in (G2,CQ) in terms of a certain boundedness property for the set of C-trees defined in Section 5.\n2. We extend the techniques developed in Section 5 and construct in double-exponential time a 2WAPA A that has exponentially many states, such that the aforementioned boundedness property does not hold iff L(A) is infinite. (Such an infinity problem for tree automata has been used to obtain the decidability of the boundedness problem for monadic Datalog [28, 46]).\nOur 2ExpTime upper bound then follows since the infinity problem for a 2WAPA A, i.e., checking if L(A) is infinite, is feasible in exponential time in the number of states, and in polynomial time in the size of the alphabet. This follows from two known results: (a) The 2WAPA A can be converted into an equivalent non-deterministic tree automata B with a single-exponential blow up in the number of states [47], and (b) solving the infinity problem for non-deterministic tree automata is feasible in polynomial time; cf. [46].\nIt is worth contrasting our proof with the one in [15] for ELHI, which does not make use of the infinity problem for\n2WAPA, but applies a different argument based on pumping. This leads to a finer complexity analysis in terms of the size of the different components of the OMQ, but, in our opinion, makes the proof conceptually harder.\nThe semantic characterization. To establish the semantic characterization from step 1, we need to define the notion of distance from the root for an element u in a C-tree database D. Intuitively, this corresponds to the minimal distance between a node that contains u and the root of a tree decomposition T of D that witnesses the fact that D is a C-tree. We do not consider all such tree decompositions, however, but concentrate on a well-behaved subclass, which we call the lean tree decompositions of the C-tree D; the formal definition can be found in [10], as it does not add much to the explanation we provide here. Due to the fact that we focus on unary and binary relations, such lean tree decompositions ensure the invariance of the notion of distance from the root, by severely limiting the level of redundancy allowed in a tree representation of D. Therefore, it does not matter which lean tree decomposition we choose, since in all of them the distance of an element u from the root will be the same. Let D\u2264k be the subinstance of D induced by the set of elements whose distance from the root is at most k, and let D>k be the subinstance of D induced by the set of elements whose distance from the root is at least k + 1.\nAnother useful notion is the branching degree of a tree decomposition T , that is, the maximum number of child nodes over all nodes of T . Again, lean tree decompositions ensure the invariance of the branching degree. This allows us to define the branching degree of a C-tree database D as the branching degree of a lean tree decomposition that witnesses the fact that D is a C-tree.\nIt follows from [15] that being able to decide containment for the OMQ language (G2,BCQ) (as we have done in Section 5) allows us to concentrate on connected CQs when deciding UCQ rewritability. This simplifies technicalities considerably and, in turn, allows us to obtain our desired semantic characterization of UCQ rewritability:\nProposition 30. Let Q = (S,\u03a3, q) \u2208 (G2,BCQ), where q is connected. The following are equivalent:\n1. Q is UCQ rewritable.\n2. There exist k,m \u2265 0 (which depend only on Q) s.t.\nQ(D) 6= \u2205 =\u21d2 ( Q(D\u2264k) 6= \u2205 or Q(D>0) 6= \u2205 ) ,\nfor each C-tree S-database D with |dom(C)| \u2264 2 \u00b7 |q| and branching degree at most m.\nThe reduction to the infinity problem. We now proceed with step 2, and we explain how the boundedness property established in item (2) of Proposition 30 can be reduced to the infinity problem for 2WAPAs. As in Section 5, we do not reason with C-tree databases directly, but we deal with their encodings as consistent \u0393S,l-labeled trees. In fact, using the same ideas as in Lemma 22, we can show by exploiting Proposition 30 that the following are equivalent:\n(i) Q is UCQ rewritable.\n(ii) There are k,m \u2265 0 such that\nQ(JLK) 6= \u2205 =\u21d2 ( Q(JLK\u2264k) 6= \u2205 or Q(JLK>0) 6= \u2205 ) ,\nfor every consistent \u0393S,l-labeled tree L with l = 2 \u00b7 |q| and whose branching degree is bounded by m.\nLet us write Boundedness for the property expressed in item (ii) above, which can be reduced to the problem of checking whether some tree language is finite. Let LQ be the set of all \u0393S,l-labeled trees L of branching degree at most m such that: (1) Q(JLK) = \u2205 and (2) there is some \u201cextension\u201d L\u2032 of L, with branching degree m, such that Q(JL\u2032K) 6= \u2205 and Q(JL\u2032K>0) = \u2205. Notice that L\n\u2032 can increase the depth but not the branching degree of L. It is not difficult to show that Boundedness holds iff LQ is finite. We then devise in double-exponential time a 2WAPA CQ,l, which has exponentially many states, such that LQ = L(CQ,l). Therefore, the following holds:\nProposition 31. Consider Q \u2208 (G2,BCQ). We can construct in double-exponential time a 2WAPA A, which has exponentially many states, such that\nQ is UCQ rewritable \u21d0\u21d2 L(A) is finite.\nSince checking whether L(A) is infinite is feasible in exponential time in the number of states and in polynomial time in the size of the alphabet, Proposition 31 implies that UCQRew(G2,CQ) is in 2ExpTime, as needed."}, {"heading": "8. CONCLUSIONS", "text": "We have concentrated on the fundamental problem of containment for OMQ languages based on the main decidable classes of tgds. We have developed specially tailored techniques for OMQ containment that allowed us to obtain a relatively complete picture for the complexity of the problem at hand. Our main conclusion is that for the OMQ languages in question, i.e., those based on linear, sticky, non-recursive and guarded tgds, the containment problem is harder (under widely accepted complexity assumptions) than query evaluation, with the exception of linear OMQs over schemas of unbounded arity, where both problems are complete for PSpace. We have also used our techniques to close problems related to distribution over components and UCQ rewritability. In particular, it is shown that the problem of deciding whether a guarded OMQ distributes over components is 2ExpTime-complete, while the problem of deciding whether a guarded OMQ that mentions only unary and binary relations is UCQ rewritable is also 2ExpTimecomplete. We believe that our techniques for solving containment under guarded OMQs can be extended to frontierguarded OMQs, an interesting extension of guardedness [7]. We are also convinced that our solution to the problem of deciding UCQ rewritability of guarded OMQs over unary and binary relations can be extended to guarded (or even frontier-guarded) OMQs over arbitrary schemas. We are currently investigating these challenging problems."}, {"heading": "APPENDIX", "text": ""}, {"heading": "PRELIMINARIES Definition of Non-recursiveness", "text": "In the main body of the paper, we define non-recursive sets of tgds via the notion of predicate graph. Here, we give an alternative definition, based on the well-known notion of stratification, which is more convenient for the combinatorial analysis that we are going to perform in the proof of Proposition 14.\nDefinition 3. Consider a set \u03a3 of tgds. A stratification of \u03a3 is a partition {\u03a31, . . . ,\u03a3n}, where n > 0, of \u03a3 such that, for some function \u00b5 : sch(\u03a3) \u2192 {0, . . . , n}, the following hold:\n1. For each predicate R \u2208 sch(\u03a3), all the tgds with R in their head belong to \u03a3\u00b5(R), i.e., they belong to the same set of the partition.\n2. If there exists a tgd in \u03a3 such that the predicate R appears in its body, while the predicate P appears in its head, then \u00b5(R) < \u00b5(P ).\nWe say that \u03a3 is stratifiable if it admits a stratification.\nIt is an easy exercise to show that the predicate graph of a set \u03a3 of tgds is acyclic iff \u03a3 is stratifiable. Then:\nLemma 32. \u03a3 is non-recursive iff \u03a3 is stratifiable."}, {"heading": "Definition of Stickiness", "text": "In the main body of the paper, we provide an intuitive explanation of stickiness. Here, we recall the formal definition of sticky sets of tgds, introduced in [24]. Fix a set \u03a3 of tgds; w.l.o.g., we assume that, for every pair (\u03c3, \u03c3\u2032) \u2208 \u03a3\u00d7 \u03a3, \u03c3 and \u03c3\u2032 do not share variables. For notational convenience, given an atom \u03b1 and a variable x occurring in \u03b1, pos(\u03b1, x) is the set of positions in \u03b1 at which x occurs; a position P [i] identifies the i-th attribute of the predicate P . The definition of stickiness hinges on the notion of marked variables in a set of tgds.\nDefinition 4. Consider a tgd \u03c3 \u2208 \u03a3, and a variable x occurring in the body of \u03c3. We inductively define when x is marked in \u03a3 as follows:\n1. If there exists an atom \u03b1 in the head of \u03c3 such that x does not occur in \u03b1, then x is marked in \u03a3; and\n2. Assuming that there exists an atom \u03b1 in the head of \u03c3 such that x occurs in \u03b1, if there exists \u03c3\u2032 \u2208 \u03a3 (not necessarily different than \u03c3) and an atom \u03b2 in the body of \u03c3\u2032 such that (i) \u03b1 and \u03b2 have the same predicate and, (ii) each variable in \u03b2 that occurs at a position of pos(\u03b1, x) is marked in \u03a3, then x is marked in \u03a3.\nWe are now ready to recall when a set of tgds is sticky:\nDefinition 5. A set \u03a3 of tgds is sticky if, for each \u03c3 \u2208 \u03a3, and for each variable x occurring in the body of \u03c3, the following holds: if x is marked in \u03a3, then x occurs only once in the body of \u03c3."}, {"heading": "PROOFS OF SECTION 3 Proof of Proposition 5", "text": "Consider an OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 (C,CQ), where C is a class of tgds, an S-database D, and a tuple c\u0304 \u2208 dom(D)|x\u0304|. We show that:\nc\u0304 \u2208 Q(D) \u21d0\u21d2 (sch(\u03a3),\u2205, qD,c\u0304) \ufe38 \ufe37\ufe37 \ufe38\nQ1\n\u2286 (sch(\u03a3),\u03a3, q) \ufe38 \ufe37\ufe37 \ufe38\nQ2\n.\n(\u21d2) Assume that Q1 6\u2286 Q2. This implies that there exists a sch(\u03a3)-database D \u2032, and a tuple t\u0304 of constants such that\nt\u0304 \u2208 qD,c\u0304(D \u2032) and t\u0304 6\u2208 q(chase(D\u2032,\u03a3)). Due to the monotonicity of CQs, t\u0304 \u2208 qD,c\u0304(chase(D \u2032,\u03a3)). Since, by construction, the instance chase(D\u2032,\u03a3) satisfies \u03a3, we conclude that qD,c\u0304 6\u2286\u03a3 q.\n6 By exploiting the well-known characterization of CQ containment in terms of the chase, we get that c\u0304 6\u2208 q(chase(D,\u03a3)), which is equivalent to c\u0304 6\u2208 Q(D), as needed.\n(\u21d0) Conversely, assume that c\u0304 6\u2208 Q(D), or, equivalently, c\u0304 6\u2208 q(chase(D,\u03a3)). This implies that c\u0304 6\u2208 Q2(D). Observe that c\u0304 \u2208 qD,c\u0304(D) holds trivially, which in turn implies that c\u0304 \u2208 Q1(D). Therefore, Q1 6\u2286 Q2, and the claim follows.\n6This is the standard notation for the fact that qD,c\u0304(I) 6\u2286 q(I), for every (possibly infinite) instance I that satisfies \u03a3."}, {"heading": "Proof of Proposition 9", "text": "The construction underlying Proposition 9 relies on the idea of encoding boolean operations (in our case the \u2018or\u2019 operator) using a set of atoms; this idea has been exploited in several other works; see, e.g., [13, 20, 34]. Let Q = (S,\u03a3, q) \u2208 (C,UCQ). Our goal is to construct in polynomial time Q\u2032 = (S,\u03a3\u2032, q\u2032) \u2208 (C,CQ) such that Q \u2261 Q\u2032. We assume, w.l.o.g., that the predicates of S do not appear in the head of a tgd of \u03a3; we can copy the content of a relation R/k \u2208 S into an auxiliary predicate R\u22c6/k, using the tgd R(x1, . . . , xk) \u2192 R\n\u22c6(x1, . . . , xk), while staying inside C, and then rename each predicate P in \u03a3 and q with P \u22c6. The set \u03a3\u2032 consists of the following tgds:\n1. For every R/k \u2208 S:\nR(x1, . . . , xk) \u2192 R \u2032(x1, . . . , xk, 1),True(1).\nThese tgds are annotating the database atoms with the truth constant true, indicating that these are true atoms.\n2. Assuming that q = \u2203y\u0304 \u03c6(x\u0304, y\u0304), a tgd:\nTrue(t) \u2192 \u2203x\u0304\u2203y\u0304\u2203f \u03c6\u2032\u2227(x\u0304, y\u0304, f), \u03c8(t, f),\nwhere \u03c6\u2032\u2227 is the conjunction of atoms in \u03c6, after replacing each atom R(v1, . . . , vk) with R \u2032(v1, . . . , vk, f), and \u03c8 is the conjunction of atoms\nOr(t, t, t),Or(t, f, t),Or(f, t, t),Or(f, f, f).\nThis tgd generates a \u201ccopy\u201d of the atoms in q, while annotating them with a null value that represents the truth constant false, indicating that are not necessarily true atoms. Moreover, the truth table of \u2018or\u2019 is generated.\n3. Finally, for each tgd \u03c6(x\u0304, y\u0304) \u2192 \u2203z\u0304 \u03c8(x\u0304, x\u0304) in \u03a3, a tgd\n\u03c6\u2032(x\u0304, y\u0304, w) \u2192 \u2203z\u0304 \u03c8\u2032(x\u0304, z\u0304, w),\nwhere \u03c6\u2032 and \u03c8\u2032 are obtained from \u03c6 and \u03c8, respectively, by replacing each atom R(v1, . . . , vk) with R \u2032(v1, . . . , vk, w). In fact, this is the actual set of tgds \u03a3, with the difference that the value at the last position of each atom (which indicates whether it is true or false) is propagated to the inferred atoms.\nNow, assuming that q = q1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 qn, the CQ q \u2032 is defined as follows; let x\u0304 = x1 . . . xn and y\u0304 = y1 . . . yn+1:\n\u2203x\u0304\u2203y\u0304 (False(y1) \u2227 \u2227\n1\u2264i\u2264n\n(q\u2032i[xi] \u2227Or(yi, xi, yi+1)) \u2227 True(yn+1)),\nwhere x\u0304 and y\u0304 are fresh variables not in q, and q\u2032i[xi] is obtained from qi by replacing each atom R(v1, . . . , vk) with R\u2032(v1, . . . , vk, xi). This completes our construction.\nIt is not difficult to show that Q \u2261 Q\u2032, or, equivalently, for every S-database D, q(chase(D,\u03a3)) = q\u2032(chase(D,\u03a3\u2032)). The key observation is that in order to satisfy True(yn+1) in the CQ q\n\u2032, at least one of the x\u0304i\u2019s must be mapped to 1, which means that at least one qi is satisfied by chase(D,\u03a3). Finally, it is easy to verify that, for each C \u2208 {G,L,NR, S}, \u03a3 \u2208 C implies \u03a3\u2032 \u2208 C, and Proposition 9 follows."}, {"heading": "PROOFS OF SECTION 4 Proof of Proposition 10", "text": "We assume that q(x\u0304) = \u2228n\ni=1 qi(x\u0304) is a UCQ rewriting of Q. Since, by hypothesis, Q 6\u2286 Q \u2032, we conclude that q 6\u2286 Q\u2032, which\nin turn implies that there exists i \u2208 {1, . . . , n} such that qi 6\u2286 Q \u2032. Let c(x\u0304) be a tuple of constants obtained by replacing each variable x in x\u0304 with the constant c(x), and Dqi the S-database obtained from qi after replacing each variable x in qi with the constant c(x). We show that:\nLemma 33. c(x\u0304) 6\u2208 Q\u2032(Dqi).\nProof. Since qi 6\u2286 Q \u2032, there exists an S-database D, and a tuple of constants t\u0304 such that t\u0304 \u2208 qi(D) and t\u0304 6\u2208 Q \u2032(D). Clearly, there exists a homomorphism h such that h(qi) \u2286 D and h(x\u0304) = t\u0304. Observe also that \u03c1(Dqi) \u2286 D, where \u03c1 = h \u25e6 c\n\u22121. Towards a contradiction, assume that c(x\u0304) \u2208 Q\u2032(Dqi). This implies that there exists a homomorphism \u03b3 such that \u03b3(q\n\u2032) \u2286 chase(Dqi ,\u03a3) and \u03b3(y\u0304) = c(x\u0304), where Q\n\u2032 = (S,\u03a3, q\u2032(y\u0304)). It is not difficult to see that there exists an extension \u03c1\u2032 of \u03c1 such that \u03c1\u2032(chase(Dqi ,\u03a3)) \u2286 chase(D,\u03a3) and \u03c1\n\u2032(x\u0304) = t\u0304. Hence, \u03c1\u2032(\u03b3(q\u2032)) \u2286 chase(D,\u03a3), which implies that t\u0304 \u2208 q\u2032(chase(D,\u03a3)); thus, t\u0304 \u2208 Q\u2032(D). But this contradicts the fact that t\u0304 6\u2208 Q\u2032(D), and the claim follows.\nObserve that c(x\u0304) \u2208 q(Dqi), which immediately implies that c(x\u0304) \u2208 Q(Dqi). Consequently, by Lemma 33, Q(Dqi) 6\u2286 Q \u2032(Dqi).\nThe claim follows since, by construction, Dqi is an S-database such that |Dqi | \u2264 fO(Q).\nAlgorithm 1: The algorithm XRewrite\nInput: An OMQ Q = (S,\u03a3, q(x\u0304)) \u2208 (TGD,CQ) Output: A UCQ q\u2032(x\u0304) such that Q(D) = q\u2032(D), for every S-database D\ni := 0; Qrew := {\u3008q, r, u\u3009}; repeat\nQtemp := Qrew; foreach \u3008q, x, u\u3009 \u2208 Qtemp, where x \u2208 {r, f} do\nforeach \u03c3 \u2208 \u03a3 do /* rewriting step */ foreach S \u2286 body(q) such that \u03c3 is applicable to S do\ni := i+ 1; q\u2032 := \u03b3S,\u03c3i(q[S/body(\u03c3 i)]); if there is no (q\u2032\u2032, r, \u22c6) \u2208 Qrew such that q\u2032 \u2243 q\u2032\u2032 then Qrew := Qrew \u222a {\u3008q\u2032, r, u\u3009}; end\nend /* factorization step */ foreach S \u2286 body(q) that is factorizable w.r.t. \u03c3 do\nq\u2032 := \u03b3S(q); if there is no (q\u2032\u2032, \u22c6, \u22c6) \u2208 Qrew such that q\u2032 \u2243 q\u2032\u2032 then\nQrew := Qrew \u222a {\u3008q\u2032, f, u\u3009}; end\nend\nend /* query q is now explored */ Qrew := (Qrew \\ {(q, x, u)}) \u222a {(q, x, e)};\nend\nuntil Qtemp = Qrew; Qfin := {q | \u3008q, r, e\u3009 \u2208 Qrew, and q contains only predicates of S}; return Qfin\nThe Algorithm XRewrite\nIn view of the fact that the rewriting algorithm XRewrite is heavily used in our complexity analysis, we would like to recall its definition. This algorithm is based on resolution, and thus, before we proceed further, we need to recall the crucial notion of unification. A set of atoms A = {\u03b11, . . . , \u03b1n}, where n > 2, unifies if there exists a substitution \u03b3, called unifier for A, such that \u03b3(\u03b11) = \u00b7 \u00b7 \u00b7 = \u03b3(\u03b1n). A most general unifier (MGU) for A is a unifier for A, denoted as \u03b3A, such that for each other unifier \u03b3 for A, there exists a substitution \u03b3\u2032 such that \u03b3 = \u03b3\u2032 \u25e6 \u03b3A. Notice that if a set of atoms unify, then there exists a MGU. Furthermore, the MGU for a set of atoms is unique (modulo variable renaming).\nThe algorihtm proceeds by exhaustively applying two steps: rewriting and factorization, which in turn rely on the technical notions of applicability and factorizability, respectively. We assume, w.l.o.g., that tgds and CQs do not share variables. Given a CQ q, a variable x is called shared in q if x is a free variable of q, or it occurs more than once in q. In what follows, we assume, w.l.o.g., that tgds are in normal form, i.e., they have only one atom in the head, and only one occurrence of an existentially quantified variable [24]. We write \u03c0\u2203(\u03c3) for the position at which the existentially quantified variable of \u03c3 occurs; in case \u03c3 does not mention an existentially quantified variable, then \u03c0\u2203(\u03c3) = \u03b5. (Recall that a position P [i] identifies the i-th attribute of a predicate P .) We are now ready to recall applicability and factorizability; in what follows, we write body(q) for the set of atoms occurring in q, and head(\u03c3) for the head-atom of \u03c3.\nDefinition 6. (Applicability) Consider a CQ q and a tgd \u03c3. Given a set of atoms S \u2286 body(q), we say that \u03c3 is applicable to S if the following conditions are satisfied:\n1. the set S \u222a {head(\u03c3)} unifies, and\n2. for each \u03b1 \u2208 S, if the term at position \u03c0 in \u03b1 is either a constant or a shared variable in q, then \u03c0 6= \u03c0\u2203(\u03c3).\nRoughly, whenever \u03c3 is applicable to S, this means that the atoms of S may be generated during the chase procedure by applying \u03c3. Therefore, we are allowed to apply a rewriting step (which is essentially a resolution step) that resolves S using \u03c3, i.e., S is replaced by body(\u03c3), and a new CQ that is closer to the input database is obtained.\nIf we start applying rewriting steps blindly, without checking for applicability, then the soundness of the rewriting procedure is not guaranteed. However, it is possible that the applicability condition is not satisfied, but still we should apply a rewriting step. This may happen due to the presence of redundant atoms in a query. For example, given the CQ\nq = \u2203x\u2203y\u2203z (R(x, y) \u2227 R(x, z))\nand the tgd\n\u03c3 = P (u, v) \u2192 \u2203wR(w,u)\nthe applicability condition fails since the shared variable x in q occurs at the position \u03c0\u2203(\u03c3) = R[1]. However, q is essentially the CQ q = \u2203x\u2203yR(x, y), and now the applicability condition is satisfied. From the above informal discussion, we conclude that the applicability condition may prevent the algorithm from being complete since some valid rewriting steps are blocked. Because of this reason, we need the so-called factorization step, which aims at converting some shared variables into nonshared variables, and thus, satisfy the applicability condition. In general, this can be achieved by exhaustively unifying all the atoms that unify in the body of a CQ. However, some of these unifications do not contribute in any way to satisfying the applicability condition, and, as a result, many superfluous CQs are generated. It is thus better to apply a restricted form of factorization that generates a possibly small number of CQs that are vital for the completeness of the rewriting algorithm. This corresponds to the identification of all the atoms in the query whose shared existential variables come from the same atom in the chase, and they can be unified with no loss of information. Summing up, the key idea underlying the notion of factorizability is as follows: in order to apply the factorization step, there must exist a tgd that can be applied to its output.7\nDefinition 7. (Factorizability) Consider a CQ q and a tgd \u03c3. Given a set of atoms S \u2286 body(q), where |S| > 2, we say that S is factorizable w.r.t. \u03c3 if the following conditions are satisfied:\n1. S unifies,\n2. \u03c0\u2203(\u03c3) 6= \u03b5, and\n3. there exists a variable x 6\u2208 var(body(q) \\ S) that occurs in every atom of S only at position \u03c0\u2203(\u03c3).\nHaving the above key notions in place, we are now ready to recall the algorithm XRewrite, which is depicted in Algorithm 1. As said above, the UCQ rewriting of an OMQ q = (S,\u03a3, q) is computed by exhaustively applying (i.e., until a fixpoint is reached) the rewriting and the factorization steps. Notice that the CQs that are the result of the factorization step, are nothing else than auxiliary queries which are critical for the completeness of the final rewriting, but are not needed in the final rewriting. Thus, during the iterative procedure, the queries are labeled with r (resp., f) in order to keep track which of them are generated by the rewriting (resp., factorization) step. The CQ that is part of the input OMQ, although is not a result of the rewriting step, is labeled by r since it must be part of the final rewriting. Moreover, once the two crucial steps have been exhaustively applied on a CQ q, it is not necessary to revisit q since this will lead to redundant queries. Hence, the queries are also labeled with e (resp., u) indicating that a query has been already explored (resp., is unexplored). Let us now describe the two main steps of the algorithm. In the sequel, consider a triple (q, x, y), where (x, y) \u2208 {r, f} \u00d7 {e, u} (this is how we indicate that q is labeled by x and y), and a tgd \u03c3 \u2208 \u03a3. We assume that q is of the form \u2203x\u0304 \u03d5(x\u0304, y\u0304).\nRewriting Step. For each S \u2286 body(q) such that \u03c3 is applicable to S, the i-th application of the rewriting step generates the query q\u2032 = \u03b3S,\u03c3i(q[S/body(\u03c3 i)]), where \u03c3i is the tgd obtained from \u03c3 by replacing each variable x with xi, \u03b3S,\u03c3i\nis the MGU for the set S \u222a {head(\u03c3i)} (which is the identity on the variables that appear in the body but not in the head of \u03c3i), and q[S/body(\u03c3i)] is obtained from q be replacing S with body(\u03c3i). By considering \u03c3i (instead of \u03c3) we basically rename, using the integer i, the variables of \u03c3. This renaming step is needed in order to avoid undesirable clutters among the variables introduced during different applications of the rewriting step. Finally, if there is no (q\u2032\u2032, r, \u22c6) \u2208 Qrew, i.e., an (explored or unexplored) query that is the result of the rewriting step, such that q\n\u2032 and q\u2032\u2032 are the same (modulo bijective variable renaming), denoted q\u2032 \u2243 q\u2032\u2032, then (q\u2032, r, u) is added to Qrew.\nFactorization Step. For each S \u2286 body(q) that is factorizable w.r.t. \u03c3, the factorization step generates the query q\u2032 = \u03b3S(q), where \u03b3S is the MGU for S. If there is no (q\n\u2032\u2032, \u22c6, \u22c6) \u2208 Qrew, i.e., a query that is the result of the rewriting or the factorization step, and is explored or unexplored, such that q\u2032 \u2243 q\u2032\u2032, then (q\u2032, f, u) is added to Qrew."}, {"heading": "Proof of Proposition 14", "text": "We assume, w.l.o.g., that the predicates of S do not appear in the head of a tgd of \u03a3. Since \u03a3 \u2208 NR, by Lemma 32, \u03a3 admits a stratification {\u03a31, . . . ,\u03a3n} with stratification function \u00b5 : sch(\u03a3) \u2192 {0, . . . , n}. Let us briefly explain how the rewriting tree TQ of the OMQ Q = (S,\u03a3, q) is defined. TQ is a rooted tree with q being its root. The i-th level of TQ consists of the CQs obtained from the CQs of the (i\u2212 1)-th level by applying rewriting steps (see the algorithm XRewrite for details on the rewriting step) using only tgds from \u03a3n\u2212i+1. It is easy to verify that the CQs of the i-th level contain only predicates P such that \u00b5(P ) < n\u2212 i+1. It is now clear that the n-th level of TQ (i.e., the leaves of TQ) consists only of CQs obtained during the execution of XRewrite(Q) that contain only predicates of S. Thus, in order to obtained the desired upper bound, it suffices to show that the number of atoms that occur in a CQ that is a leaf of TQ is at most |q| \u00b7 (max\u03c4\u2208\u03a3{|body(\u03c4 )|}) |sch(\u03a3)|. To this end, let us focus on one branch B of TQ from the root q to a leaf q \u2032. Such a branch can be naturally represented as a k-ary forest FBQ , where the root nodes are the atoms of q, and whenever an atom \u03b1 is resolved during the rewriting step using a tgd \u03c4 , the atoms of body(\u03c4 ), after applying the appropriate MGU, are the child nodes of \u03b1. Therefore, to obtain the desired upper bound, it suffices to show that the number of leaves of FBQ is at most |q| \u00b7 (max\u03c4\u2208\u03a3{|body(\u03c4 )|}) |sch(\u03a3)|. By construction, FBQ consists, in general, of |q| k-ary rooted trees, where k = max\u03c4\u2208\u03a3{|body(\u03c4 )|}, of depth n. Hence, the number of leaves of FBQ is at most |q| \u00b7 (max\u03c4\u2208\u03a3{|body(\u03c4 )|}) n. Since n \u2264 |sch(\u03a3)|, the claim follows. 7Let us clarify that for the purposes of the present work we can rely on the naive approach of exhaustively unifying all the atoms that unify in the body of a CQ. However, we would like to be consistent with [33], where the algorithm XRewrite is proposed, and thus, we stick on the slightly more involved notion of factorizability."}, {"heading": "Proof of Theorem 16", "text": "A proof sketch for the coNExpTimeNP upper bound is given in the main body of the paper. We proceed to establish the PNEXP-hardness. Our proof is by reduction from a tiling problem that has been recently introduced in [30], which in turn relies on the standard Exponential Tiling Problem. Let us first recall the latter problem.\nAn instance of the Exponential Tiling Problem is a tuple (n,m,H, V, s), where n,m are numbers (in unary), H,V are subsets of {1, . . . ,m} \u00d7 {1, . . . ,m}, and s is a sequence of numbers of {1, . . . ,m}. Such a tuple specifies that we desire a 2n \u00d7 2n grid, where each cell is tiled with a tile from {1, . . . ,m}. H (resp., V ) is the horizontal (resp., vertical) compatibility relation, while s represents a constraint on the initial part of the first row of the grid. A solution to such an instance of the Exponential Tiling Problem is a function f : {0, . . . , 2n \u2212 1} \u00d7 {0, . . . , 2n \u2212 1} \u2192 {1, . . . ,m} such that:\n1. f(i, 0) = s[i], for each 0 \u2264 i \u2264 (|s| \u2212 1);\n2. (f(i, j), f(i+ 1, j)) \u2208 H , for each 0 \u2264 i \u2264 2n \u2212 2 and 0 \u2264 j \u2264 2n \u2212 1; and\n3. (f(i, j), f(i, j + 1)) \u2208 V , for each 0 \u2264 i \u2264 2n \u2212 1 and 0 \u2264 j \u2264 2n \u2212 2.\nWe will refer to {0, . . . , 2n\u22121}\u00d7{0, . . . , 2n\u22121} as a grid, with the pairs in it being cells. A cell consists of two coordinates, the column-coordinate (for short col-coordinate) and the row-coordinate, and any function on a grid is a tiling. The Exponential Tiling Problem is defined as follows: given an instance T as above, decide whether T has a solution. It is known that this problem is NExpTime-hard (see, e.g., Section 3.2 of [38]).\nWe are now ready to recall the tiling problem introduced in [30], called Extended Tiling Problem (ETP), which is PNEXPhard. An instance of this problem is a tuple (k, n,m,H1, V1,H2, V2), where k, n,m are numbers (in unary), and H1, V1,H2, V2 are subsets of {1, . . . ,m} \u00d7 {1, . . . , m}. The question is as follows: is it the case that for every sequence s, where |s| = k, of numbers of {1, . . . ,m}, (n,m,H1, V1, s) has no solution or (n,m,H2, V2, s) has a solution?\nWe give a reduction from the ETP to Cont(NR,CQ). More precisely, given an instance T = (k, n,m,H1, V1, H2, V2) of the ETP, our goal is to construct in polynomial time two queries Qi = (S,\u03a3i, qi) \u2208 (NR,CQ), for i \u2208 {1, 2}, such that T has a solution iff Q1 \u2286 Q2."}, {"heading": "Data Schema S", "text": "The data schema S consists of:\n\u2022 0-ary predicates Cji , for each i \u2208 {0, . . . , k \u2212 1} and j \u2208 {1, . . . ,m}; the atom C j i indicates that si = j."}, {"heading": "The Query Q1", "text": "The goal of the query Q1 is twofold: (i) to check that the so-called existence property of the input database, i.e., for every i \u2208 {0, . . . , k\u2212 1}, there exists at least one atom of the form Cji , is satisfied, and (ii) to check whether (n,m,H1, V1, s), where s is the sequence of tilings encoded in the input database, has a solution. To this end, the query Q1 will mention the following predicates:\n\u2022 0-ary predicate Ci, indicating that there exists at least one atom of the form C j i in the input database.\n\u2022 0-ary predicate Existence, indicating that the input database enjoys the existence property.\n\u2022 Unary predicate Tilei, for each i \u2208 {1, . . . ,m}; the atom Tilei(x) states that x is the tile i.\n\u2022 Binary predicate H ; the atom H(x, y) encodes the fact that (x, y) \u2208 H1.\n\u2022 Binary predicate V ; the atom V (x, y) encodes the fact that (x, y) \u2208 V1.\n\u2022 5-ary predicate Ti, for each i \u2208 {1, . . . , n}; the atom Ti(x, x1, x2, x3, x4) states that x is a 2 i \u00d7 2i tiling obtained from\nthe 2i\u22121 \u00d7 2i\u22121 tilings x1, . . . , x4 \u2013 details on the inductive construction of 2 i \u00d7 2i tilings from 2i\u22121 \u00d7 2i\u22121 tilings are given below.\n\u2022 Unary predicate Initiali, for each i \u2208 {0, . . . , k\u2212 1}; the atom Initiali(x) states that s[i] = x, i.e., the i-th element of the sequence s is x.\n\u2022 Binary predicate Topji , for each i \u2208 {1, . . . , n} and j \u2208 {0, . . . , k\u22121}; the atom Top j i (x, y) states that in the 2 i\u00d72i tiling x the tile at position (j, 0) is y.\n\u2022 0-ary predicate Tiling, indicating that there exists a 2n \u00d7 2n tiling that is compatible with the initial tiling s encoded in the input database.\n\u2022 0-ary predicate Goal, which is derived whenever the predicates Existence and Tiling are derived.\nQ1 is defined as the query (S,\u03a31,Goal), where \u03a31 consists of the following tgds:\n(a) (b)\nX1\nX3\nX2\nX4\nX2\nX4\nY1\nY3\nY1\nY3\nY2\nY4\nX3\nZ1\nX4\nZ2\nX4\nZ2\nY3\nW1\nY3\nW1\nY4\nW2\nZ1\nZ3\nZ2\nZ4\nZ2\nZ4\nW1\nW3\nW1\nW3\nW2\nW4\nX1\nX3\nX2\nX4\nY1\nY3\nY2\nY4\nZ1\nZ3\nZ2\nZ4\nW1\nW3\nW2\nW4\n\u2022 Check whether there exists a 2n \u00d7 2n tiling that is compatible with the sequence of tilings s\nFor each i \u2208 {0, . . . , k \u2212 1} and j \u2208 {1, . . . ,m}:\nCji ,Tilej(x) \u2192 Initiali(x)\nand the tgd\nTop0n(x, y0), Initial0(y0), \u00b7 \u00b7 \u00b7 ,Top k\u22121 n (x, yk\u22121), Initialk\u22121(yk\u22121) \u2192 Tiling\n\u2022 Finally, we have the output tgd\nExistence,Tiling \u2192 Goal\nThis concludes the construction of Q1."}, {"heading": "The Query Q2", "text": "The goal of the query Q2 is twofold: (i) to check that the so-called uniqueness property of the input database, i.e., for every i \u2208 {0, . . . , k\u2212 1}, there exists at most one atom of the form Cji , is satisfied, and (ii) to check whether (n,m,H2, V2, s), where s is the sequence of tilings encoded in the input database, has a solution. The query Q2 mentions the same predicates as Q1, and is defined as (S,\u03a32,Goal), where \u03a32 consists of the following tgds:\n\u2022 Checking the uniqueness property\nFor each i \u2208 {0, . . . , k \u2212 1} and j, \u2113 \u2208 {1, . . . , m} with j < \u2113:\nCji , C \u2113 i \u2192 Goal\n\u2022 The rest of \u03a32 encodes the tiling problem (n,m,H2, V2, s) in exactly the same way as \u03a31 encodes (n,m,H1, V1, s).\nThis concludes the construction of Q2."}, {"heading": "Proof of Proposition 18", "text": "The set \u03a3n consists of the following tgds; for brevity, we write x\u0304ji for xi, xi+1, . . . , xj : 8\nS(x1, . . . , xn) \u2192 Pn(x1, . . . , xn)\nPi(x\u0304 i\u22121 1 , z, x\u0304 n i+1, z, o), Pi(x\u0304 i\u22121 1 , o, x\u0304 n i+1, z, o) \u2192 Pi\u22121(x\u0304 i\u22121 1 , z, x\u0304 n i+1, z, o), 1 \u2264 i \u2264 n,\nP0(z, . . . , z \ufe38 \ufe37\ufe37 \ufe38\nn\n, z, o) \u2192 Ans(z, o),\nwhile q = Ans(0, 1). It can be verified that, for every {S}-database D, Qn(D) 6= \u2205 implies that\nD \u2287 {S(c1, . . . , cn\u22122, 0, 1) | (c1, . . . , cn\u22122) \u2208 {0, 1} n\u22122},\nand thus, |D| \u2265 2n\u22122. Let Q = ({S},\u03a3\u2032, q\u2032), where \u03a3\u2032 is a set of tgds and q\u2032 a Boolean CQ, and D an {S}-database. Clearly, Qn(D) 6\u2286 Q(D) iff Qn(D) 6= \u2205 and Q(D) = \u2205. This implies that |D| \u2265 2n\u22122, and the claim follows."}, {"heading": "Proof of Theorem 19", "text": "The coNExpTime upper bound, as well as the \u03a0P2 -hardness in case of fixed-arity predicates, are discussed in the main body of the paper. Here, we show the coNExpTime-hardness. The proof proceeds in two steps:\n1. First, we show that Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, where FNR denotes the class of full non-recursive sets of tgds, i.e., non-recursive sets of tgds without existentially quantified variables.\n2. Then, we reduce Cont((FNR,CQ), (L,UCQ)) to Cont((S,CQ), (L,UCQ)) by showing that (under some assumptions that are explained below) every query in (FNR,CQ) can be rewritten as an (S,CQ) query.\nBy Proposition 9, we immediately get that Cont((S,CQ), (L,CQ)) is coNExpTime-hard, as needed.\nStep 1: Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard\nWe show that Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, even if we focus on 0-1 queries, that is, queries Q with following property: for every database D, Q(D) = Q(D01), where D01 \u2286 D is the restriction of D on the binary domain {0, 1}, i.e., D01 = {R(c\u0304) \u2208 D | c\u0304 \u2286 {0, 1}}. The proof is by reduction from the Exponential Tiling Problem, and is a non-trivial adaptation of the one given in [13] for showing that containment of non-recursive Datalog queries is coNExpTime-hard.\nTheorem 34. Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, even for 0-1 queries.\nProof. Given an instance T = (n,m,H,V, s) of the Exponential Tiling Problem, we are going to construct a (FNR,CQ) 0-1 query QT = (S,\u03a3, q) and a (L,UCQ) 0-1 query Q \u2032 T = (S,\u03a3T , qT ) such that T has a solution iff QT 6\u2286 Q \u2032 T . 8A similar construction has been used in [33] for showing a lower bound on the size of a CQ in the UCQ rewriting of a (S,CQ) OMQ."}, {"heading": "Data Schema S", "text": "The data schema S consists of:\n\u2022 2n-ary predicates TiledByi, for each i \u2264 m; the atom TiledByi(x1, . . . , xn, y1, . . . , yn) indicates that the cell with coordinates ((x1, . . . , xn), (y1, . . . , yn)) \u2208 {0, 1}\nn \u00d7 {0, 1}n is tiled by tile i. Notice that we use n-bit binary numbers to represent a coordinate; this is the key difference between our construction and the one of [13]."}, {"heading": "The Query QT", "text": "The goal of the query QT is to assert whether the input database encodes a candidate tiling, i.e., whether the entire grid is tiled, without taking into account the constraints, that is, the compatibility relations and the constraint on the initial part of the first row. To this end, the query QT will mention the following predicates:\n\u2022 Unary predicate Bit; the atom Bit(x) simply says that x is a bit, i.e., x \u2208 {0, 1}.\n\u2022 2n-ary predicate TiledAboveColi, for each i \u2264 n; the atom TiledAboveColi(x\u0304, y\u0304) says that for the row-coordinate y\u0304 there are tiled cells with coordinates (x\u0304\u2032, y\u0304) for every col-coordinate x\u0304\u2032 that agrees with x\u0304 on the first i \u2212 1 bits. In other words, for the row corresponding to y\u0304, every column extending the first i \u2212 1 bits of x\u0304 is tiled. In particular, TiledAboveCol1(x\u0304, y\u0304) says that the entire row y\u0304 is tiled.\n\u2022 2n-ary predicate TiledAboveRowi, for each i \u2264 n; the atom TiledAboveRowi(y\u0304) says that for every y\u0304 \u2032 that agrees with\ny\u0304 on the first i\u2212 1 bits, the row y\u0304\u2032 is fully tiled.\n\u2022 n-ary predicate RowTiled; the atom RowTiled(y\u0304) says that the row y\u0304 is fully tiled.\n\u2022 0-ary predicate AllTiled, which asserts that the entire grid is tiled.\n\u2022 0-ary predicate Goal, which is derived whenever the predicate AllTiled is derived.\nQT is defined as the query (S,\u03a3,Goal), where \u03a3 consists of the following rules:\n\u2022 Generate Bit atoms\n\u2192 Bit(0)\n\u2192 Bit(1).\n\u2022 RowTiled\nFor each j, k \u2264 m:\nTiledByj(x1, . . . , xn\u22121, 1, y1, . . . , yn),TiledByk(x1, . . . , xn\u22121, 0, y1, . . . , yn),\nBit(x1), . . . ,Bit(xn\u22121),Bit(y1), . . . ,Bit(yn),Bit(w) \u2192\nTiledAboveColn(x1, . . . , xn\u22121, w, y1, . . . , yn)\nFor each 2 \u2264 i \u2264 n:\nTiledAboveColi(x1, . . . , xi\u22121, 1, xi+1, . . . , xn, y1, . . . , yn),\nTiledAboveColi(x1, . . . , xi\u22121, 0, x \u2032 i+1, . . . , x \u2032 n, y1, . . . , yn),\nBit(wi), . . . ,Bit(wn) \u2192\nTiledAboveColi\u22121(x1, . . . , xi\u22121, wi, . . . , wn, y1, . . . , yn)\nA row is fully tiled:\nTiledAboveCol1(x1, . . . , xn, y1, . . . , yn) \u2192 RowTiled(y1, . . . , yn)\n\u2022 AllTiled\nRowTiled(y1, . . . , yn\u22121, 1),RowTiled(y1, . . . , yn\u22121, 0),Bit(w) \u2192 TiledAboveRown(y1, . . . , yn\u22121, w)\nFor each 2 \u2264 i \u2264 n:\nTiledAboveRowi(y1, . . . , yi\u22121, 1, yi+1, . . . , yn),\nTiledAboveRowi(y1, . . . , yi\u22121, 0, y \u2032 i+1, . . . , y \u2032 n),\nBit(wi), . . . ,Bit(wn) \u2192\nTiledAboveRowi\u22121(y1, . . . , yi\u22121, wi, . . . , wn)\nThe entire grid is tiled:\nTiledAboveRow1(y1, . . . , yn) \u2192 AllTiled\nAllTiled \u2192 Goal\nThis concludes the construction of the query QT ."}, {"heading": "The Query Q\u2032T", "text": "Q\u2032T is defined in such a way that Q \u2032 T (D) is non-empty exactly when the input database D encodes an invalid tiling, i.e., when one of the constraints on the tiles is violated. The query Q\u2032T will mention the following intensional predicates:\n\u2022 Unary predicate Bit; as above, Bit(x) says that x is a bit.\n\u2022 2i-ary predicate LastFirsti, for each 1 \u2264 i \u2264 n; the atom LastFirsti(x1, . . . , xi, y1, . . . , yi) says that (x1, . . . , xi) = (1, . . . , 1) and (y1, . . . , yi) = (0, . . . , 0).\n\u2022 2i-ary predicate Succi, for each 1 \u2264 i \u2264 n; the atom Succi(x\u0304, y\u0304) says that the i-bit binary number y\u0304 is the successor of the i-bit binary number x\u0304.\n\u2022 0-ary predicate Goal.\nQ\u2032T is defined as the query (S,\u03a3 \u2032, q\u2032). The set \u03a3\u2032 consists of the following linear tgds:\n\u2022 Generate Bit atoms:\n\u2192 Bit(0)\n\u2192 Bit(1).\n\u2022 Generate the successor predicates:\n\u2192 Succ1(0, 1)\n\u2192 LastFirst1(1, 0).\nFor each 1 \u2264 i \u2264 n\u2212 1:\nSucci(x1, . . . , xi, y1, . . . , yi) \u2192 Succi+1(0, x1, . . . , xi, 0, y1, . . . , yi)\nSucci(x1, . . . , xi, y1, . . . , yi) \u2192 Succi+1(1, x1, . . . , xi, 1, y1, . . . , yi)\nLastFirsti(x1, . . . , xi, y1, . . . , yi) \u2192 Succi+1(0, x1, . . . , xi, 1, y1, . . . , yi)\nLastFirsti(x1, . . . , xi, y1, . . . , yi) \u2192 LastFirsti+1(1, x1, . . . , xi, 0, y1, . . . , yi).\nThe UCQ q\u2032 consists of the following (Boolean) CQs; for brevity, the existential quantifiers in front of the CQs are omitted:\n\u2022 Tile Consistency\nFor each i 6= j \u2264 m:\nTiledByi(x1, . . . , xn, y1, . . . , yn),TiledByj(x1, . . . , xn, y1, . . . , yn),\nBit(x1), . . . ,Bit(xn),Bit(y1), . . . ,Bit(yn)\n\u2022 Tile Compatibility\nFor each (i, j) 6\u2208 V :\nSuccn(x1, . . . , xn, y1, . . . , yn),\nTiledByi(w1, . . . , wn, x1, . . . , xn),TiledByi(w1, . . . , wn, y1, . . . , yn),\nBit(w1), . . . ,Bit(wn)\nFor each (i, j) 6\u2208 H :\nSuccn(x1, . . . , xn, y1, . . . , yn),\nTiledByi(x1, . . . , xn, w1, . . . , wn),TiledByi(y1, . . . , yn, w1, . . . , wn),\nBit(w1), . . . ,Bit(wn)\n\u2022 Tiling of First Row\nFor each j \u2264 n, let fj be the function from {1, . . . , n} into {0, 1} such that fj(1) . . . fj(n) is the number j in binary representation, and let k \u2208 {1, . . . ,m} other than s[j]; recall that s is a sequence of numbers of {1, . . . ,m} that represents a constraint on the initial part of the first row of the grid. Then, we have the CQ:\nTiledByk(x1, . . . , xn, z, . . . , z \ufe38 \ufe37\ufe37 \ufe38\nn\n),Succ1(z, o)\nwhere, for each i \u2208 {1, . . . , n}, xi = z if fj(i) = 0, and xi = o if fj(i) = 1.\nThis concludes the definition of the query Q\u2032T .\nStep 2: Cont((S,CQ), (L,UCQ)) is coNExpTime-hard\nOur goal is show that every 0-1 query (S,\u03a3, q) \u2208 (F,CQ) can be equivalently rewritten as a 0-1 query (S,\u03a3\u2032, q\u2032), where all the tgds of \u03a3\u2032 are lossless, i.e., all the body-variables appear also in the head, which in turn implies that \u03a3\u2032 is sticky.\nProposition 35. Consider a 0-1 query Q \u2208 (F,CQ). We can construct in polynomial time a 0-1 query Q\u2032 \u2208 (S,CQ) such that Q \u2261 Q\u2032.\nProof. Let Q = (S,\u03a3, q), and assume that n is the maximum number of variables occurring in the body of a tgd of \u03a3. We are going to construct in polynomial time a 0-1 query Q\u2032 = (S,\u03a3\u2032, q\u2032) \u2208 (S,CQ) such that Q \u2261 Q\u2032.\nThe set \u03a3\u2032 consists of the following tgds:\n\u2022 Initialization Rules\nWe first transform every database atom of the form R(c\u0304) into an atom R\u2032(c\u0304, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n, 0, 1). This is done as follows:\n\u2192 Bit(0)\n\u2192 Bit(1)\nand, for each k-ary predicate R \u2208 S, we have the lossless tgd\nR(x1, . . . , xk),Bit(x1), . . . ,Bit(xk) \u2192 R \u2032(x1, . . . , xk, 0, . . . , 0\n\ufe38 \ufe37\ufe37 \ufe38 n\n)\nNotice that we can safely force the variables x1, . . . , xk to take only values from {0, 1} due to the 0-1 property.\n\u2022 Transformation into Lossless Tgds\nFor each tgd \u03c3 \u2208 \u03a3 of the form\nR1(x\u03041), . . . , Rk(x\u0304k) \u2192 R0(x\u03040)\nwe have the lossless tgd\nR\u20321(x\u03041, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n), . . . , R\u2032k(x\u0304k, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n) \u2192 R\u20320(x\u03040, y1, . . . , yn),\nwhere, if {v1, . . . , v\u2113}, for \u2113 \u2208 {1, . . . , n}, is the set of variables occurring in the body of \u03c3 (the order is not relevant), then yi = vi, for each i \u2208 {1, . . . , \u2113}, and yj = v1, for each j \u2208 {\u2113+ 1, . . . , n}.\n\u2022 Finalization Rules\nObserve that each atom obtained during the chase due to one of the lossless tgds introduced above is of the form R\u2032(x\u0304, y\u0304), where y\u0304 \u2208 {0, 1}n. If y\u0304 6= (0, . . . , 0), then we need to ensure that eventually the atom\nR\u2032(x\u0304, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n)\nwill be inferred. This is achieved by adding to \u03a3\u2032 the following tgds: For each k-ary predicate R occurring in \u03a3, and for each 1 \u2264 i \u2264 n, we have the rule:\nR\u2032(x1, . . . , xk, y1, . . . , yi\u22121, 1, yi+1, . . . , yn) \u2192 R \u2032(x1, . . . , xk, y1, . . . , yi\u22121, 0, yi+1, . . . , yn).\nThis concludes the definition of \u03a3\u2032.\nThe CQ q\u2032 is defined analogously. More precisely, assuming that q is of the form (the existential quantifiers are omitted)\nR1(x\u03041), . . . , Rk(x\u0304k)\nthe CQ q\u2032 is defined as\nR\u20321(x\u03041, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n), . . . , R\u2032k(x\u0304k, 0, . . . , 0 \ufe38 \ufe37\ufe37 \ufe38\nn\n).\nIt is easy to verify that \u03a3\u2032 consists of lossless tgds, and thus, Q\u2032 \u2208 (S,CQ). It also not difficult to see that, for every database D over S, Q(D01) = Q \u2032(D01); thus, by the 0-1 property, Q(D) = Q \u2032(D), and the claim follows.\nBy Theorem 34 and Proposition 35, we immediately get that Cont((S,CQ), (L,UCQ)) is coNExpTime-hard, as needed."}, {"heading": "PROOFS OF SECTION 5", "text": "Recall that, for the sake of technical clarity, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, we assume that tgds have only one atom in the head. This does not affect the generality of our proof since every set of guarded tgds can be transformed in polynomial time into a set of guarded tgds with the above property; see, e.g., [22]. Finally, for convenience of presentation, we also assume that the body of a tgd is non-empty, i.e., the body of a tgd is always an atom and not the symbol \u22a4."}, {"heading": "Proof of Proposition 21", "text": "Let us start by recalling the key notion of tree decomposition. Notice that the definition of the tree decomposition that we give here is slightly different than the one in the main body of the paper. The reason is because, for convenience of presentation, we prefer to employ a slightly different notation.\nDefinition 8. Let I be an instance. A tree decomposition of I that omits V , where V \u2286 dom(I), is a pair \u03b4 = (T , (Xt)t\u2208T ),\nwhere T = (T,ET ) is a tree and (Xt)t\u2208T a family of subsets of dom(I) (called the bags of the decomposition) such that:\n1. For every v \u2208 dom(I) \\ V , the set {t \u2208 T | v \u2208 Xt} is non-empty and connected.\n2. For every atom P (s1, . . . , sn) \u2208 I , there is a t \u2208 T such that {s1, . . . , sn} \u2286 Xt.\nThe width of a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) omitting V is max{|Xt| : t \u2208 T} \u2212 1. The tree-width of I is the minimum among the widths of all tree decompositions of I that omit V . We call a tree decomposition omitting \u2205 simply tree decomposition of I . For v \u2208 T , we denote by I\u03b4(v) the subinstance of I induced by Xv.\nNotation. We usually denote the strict partial order among the nodes of a tree T of a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) by \u227a. Accordingly, we write v w iff v \u227a w or v = w. For brevity, \u03b5 will usually denote the root of a tree decomposition at hand. If ambiguities could possibly arise, we shall use subscripts in these notations. Furthermore, when \u03b4 is clear from context, we shall omit it from the expression I\u03b4(v).\nLet \u03b4 = (T , (Xt)t\u2208T ) be a tree decomposition of I and V \u2286 T . Recall that \u03b4 is [V ]-guarded (or guarded except for V ), if for every node v \u2208 T \\ V , there is an atom P (s1, . . . , sn) \u2208 I such that Xv \u2286 {s1, . . . , sn}. A [\u2205]-guarded tree decomposition of I is simply called guarded tree decomposition.\nAlso recall the crucial notion of C-tree:\nDefinition 9. An S-instance I is a C-tree, where C \u2286 I , if there is a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) of I such that\n1. I\u03b4(\u03b5) = C, i.e., the subinstance of I induced by X\u03b5 equals C.\n2. \u03b4 is guarded except for {\u03b5}.\nIf \u03b4 or C is clear from context, we shall often refer to |dom(C)| as the diameter of D and to C as the core of D.\nRemark. The notion of C-tree defined here refers to both instances and databases, i.e., a C-tree may be a (finite) database or an instance. We often do not explicitly mention whether a C-tree at hand is a database or an instance. However, it will be clear from context whether a C-tree is a database or an instance.\nWe proceed to establish the following technical lemma, which in turn allows us to show Proposition 21. It is an adaption of a result in [6] to the case of guarded tgds. Henceforth, for brevity, given a query Q = (S,\u03a3, q) \u2208 (G,BCQ) and an S-database D, we write D |= Q for the fact that Q(D) 6= \u2205.\nLemma 36. Let Q = (S,\u03a3, q) be an OMQ from (G,BCQ). Let D be an S-database and suppose D |= Q. Then there is a\nfinite S-instance I\u0302 such that I\u0302 |= Q and:\n1. I\u0302 is a C-tree such that |dom(C)| \u2264 ar(S \u222a sch(\u03a3)) \u00b7 |q|.\n2. There is a homomorphism from I\u0302 to D.\nBefore we proceed with its formal proof, let us explain why Proposition 21 is an easy consequence of Lemma 36. The fact that the first item implies the second is trivial. Conversely, suppose that Q1 6\u2286 Q2, which implies that there exists an S-database D such that D |= Q1 and D 6|= Q2. By Lemma 36, there exists a C-tree I\u0302, where |dom(C)| \u2264 ar(S\u222asch(\u03a31)) \u00b7 |q1|, such that I\u0302 |= Q1. Moreover, there is a homomorphism from I\u0302 to D; hence, since Q2 is closed under homomorphisms, it immediately follows that I\u0302 6|= Q2. Consequently, the S-database D\u0302 obtained from I\u0302 after replacing each null z with a distinct constant cz is a C-tree such that Q1(D\u0302) 6\u2286 Q2(D\u0302), and Proposition 21 follows.\nWe now proceed with the proof of Lemma 36 which is our main task in this section. Before that, we introduce some additional auxiliary concepts."}, {"heading": "The Guarded Chase Forest", "text": "Given a database D and a set \u03a3 of guarded tgds, the guarded chase forest for D and \u03a3 is a forest (whose edges and nodes are labeled) constructed as follows:\n1. For each fact R(a\u0304) in D, add a node labeled with R(a\u0304).\n2. For each node v labeled with \u03b1 \u2208 chase(D,\u03a3) and for every atom \u03b2 resulting from a one-step application of a rule \u03c4 \u2208 \u03a3, if \u03b1 is the image of the guard in this application of \u03c4 , then add a node w labeled with \u03b2 and introduce an arc from v to w labeled with \u03c4 .\nWe can assume that the guarded chase forest is always built inductively according to a fixed, deterministic version of the chase procedure. The non-root nodes are then totally ordered by a relation \u227a that reflects their order of generation. Furthermore, we can extend \u227a to database atoms by picking a lexicographic order among them. Notice that one atom can be the label of multiple nodes. Using the order \u227a we can, however, always refer to the \u227a-least node."}, {"heading": "Guarded Unraveling", "text": "Let I be an instance over S. We say that X \u2286 dom(I) is guarded in I , if there are a1, . . . , as \u2208 dom(I) such that\n\u2022 X \u2286 {a1, . . . , as} and\n\u2022 there is an R/s \u2208 S such that I |= R(a1, . . . , as).\nA tuple t\u0304 is guarded in I if the set containing the elements of t\u0304 is guarded in I . In the following paragraph, we largely follow the notions introduced in [1, 12]. Fix an S-instance I and some X0 \u2286 dom(I). Let \u03a0 be the set of finite sequences of the form X0X1 \u00b7 \u00b7 \u00b7Xn, where, for i > 0, Xi is a guarded set in I , and, for i \u2265 0, Xi+1 = Xi \u222a {a} for some a \u2208 dom(I) \\Xi, or Xi \u2287 Xi+1. The sequences from \u03a0 can be arranged in a tree by their natural prefix order and each sequence \u03c0 = X0X1 \u00b7 \u00b7 \u00b7Xn identifies a unique node in this tree. In this context, we say that a \u2208 dom(I) is represented at \u03c0 whenever a \u2208 Xn. Two sequences \u03c0, \u03c0\n\u2032 are a-equivalent, if a is represented at each node on the unique shortest path between \u03c0 and \u03c0\u2032. For a represented at \u03c0, we denote by [\u03c0]a the a-equivalence class of \u03c0. The guarded unraveling around X0 is the instance I \u2217 over the elements {[\u03c0]a | a is represented at \u03c0}, where\nI\u2217 |= R([\u03c01]a1 , . . . , [\u03c0n]an) \u21d0\u21d2df I |= R(a1, . . . , an) and\n\u2203\u03c0 \u2208 \u03a0,\u2200i \u2208 {1, . . . , n} : [\u03c0]ai = [\u03c0i]ai ,\nfor all R/n \u2208 S.\nLemma 37. For every S-instance I and any X0 \u2286 dom(I), the guarded unraveling I \u2217 around X0 is a C-tree over S, where\nC is the subinstance of I\u2217 induced by the elements {[X0]a | a \u2208 X0}.\nProof. Let \u03b4 = (T , (Xt)t\u2208T ), where T is the natural tree that arises from ordering the sequences in \u03a0 by their prefixes. For \u03c0 \u2208 T , let X\u03c0 := {[\u03c0]a | a is represented at \u03c0}. Let \u03b5 denote the root of T . We need to show that \u03b4 is an appropriate tree decomposition witnessing that I\u2217 is a C-tree. First, note that it is clear that I(\u03b5) = {[X0]a | a \u2208 X0} by construction. Let [\u03c0]a \u2208 dom(I) and consider the set A := {t \u2208 T | [\u03c0]a \u2208 Xt}. This set is certainly non-empty. Moreover, for t1, t2 \u2208 A, we know that [t1]a = [t2]a, hence t1 and t2 are a-connected in T . Suppose I\n\u2217 |= R([\u03c01]a1 , . . . , [\u03c0n]an) for some R/n \u2208 S. Then there is a \u03c0 \u2208 T such that [\u03c0]ai = [\u03c0i]ai , for all i = 1, . . . , n. Hence, a1, . . . , an are all represented at \u03c0 and so {[\u03c01]a1 , . . . , [\u03c0n]an} \u2286 X\u03c0. It remains to show that \u03b4 is guarded except for {\u03b5}. Let \u03c0 6= \u03b5 and consider the set Xt. Since \u03c0 is a sequence of length greater than one, its last element Y is a guarded set in I . Hence, there are a1, . . . , as such that Y \u2286 {a1, . . . , as} and I |= R(a1, . . . , as) for some R/s \u2208 S. Let {a1, . . . , as} \\ Y = {b1, . . . , bm} and define \u03c1 := \u03c0 \u00b7 (Y \u222a {b1}) \u00b7 (Y \u222a {b1, b2}) \u00b7 \u00b7 \u00b7 (Y \u222a {b1, . . . , bm}). Then I\u2217 |= R([\u03c1]a1 , . . . , [\u03c1]as), as desired.\nNotice that this lemma implies that the tree-width of I\u2217 is bounded by |X0|+ ar(S)\u2212 1. We are now ready to prove Lemma 36:\nProof of Lemma 36. Let q = \u2203y\u0304 \u03d5(y\u0304) and \u00b5 a homomorphism mapping \u03d5(y\u0304) to chase(D,\u03a3). Let R1(b\u03041), . . . , Rk(b\u0304k) exhaust all facts from D that are the roots of those \u227a-least facts from \u00b5(\u03d5(y\u0304)) in the guarded chase forest of D and \u03a3 that have an element from dom(D) as argument. Let G\u00b5 := \u22c3 1\u2264i\u2264k{b\u0304i} and let I \u2217 be the unraveling of D around G\u00b5, regarding all elements from dom(I\u2217) as labeled nulls. Henceforth, for every a \u2208 G\u00b5, we denote by \u03bba the element [G\u00b5]a. We say that \u03bba represents a. Let C be the substructure of I \u2217 induced by the set {\u03bba | a \u2208 G\u00b5}. Notice that I \u2217 is an infinite instance that is a C-tree by Lemma 37. We will show later how to get a finite instance from I\u2217 that satisfies our constraints. We proceed to show that I\u2217 \u222a \u03a3 logically entails q, denoted I\u2217,\u03a3 |= q:\nLemma 38. I\u2217,\u03a3 |= q.\nProof. We will first construct a universal model J of I\u2217 and \u03a3. Recall that an instance U is a universal model of I and \u03a3, if it can be homomorphically mapped to every model of I \u222a \u03a3; in particular, it is well-known and easy to prove that chase(I,\u03a3) is always a universal model of I and \u03a3. Before constructing J , we introduce some additional notions. In the following, given a guarded set G = {a1, . . . , ak} in D, a copy of G in I \u2217 is a set \u0393 = {\u03b11, . . . , \u03b1k} which is guarded in I \u2217 such\nthat, for i = 1, . . . , k, we have that \u03b1i = [\u03c0i]ai for some sequences \u03c0i and D |= R(ai1 , . . . , aim) iff I \u2217 |= R(\u03b1i1 , . . . , \u03b1im ) for all R \u2208 S and ij \u2208 {1, . . . , k}. Copies of guarded tuples are defined accordingly. Consider the structure chase(D,\u03a3). Let G be a guarded set in D and D \u21be G denote the subinstance of D induced by G. It is well-known and easy to prove that chase(D \u21be G,\u03a3) is acyclic (cf., e.g., [21]). Henceforth, we loosely call chase(D \u21be G,\u03a3) the tree attached to G. The model J is constructed as follows. Let J0 be the instance C. Furthermore, for each guarded set G = {a1, . . . , ak} in D and each copy \u0393 = {\u03b11, . . . , \u03b1k} of G in I\n\u2217, construct a new instance J\u0393 that is isomorphic to the tree attached to G such that (i) the elements ai of G are renamed to \u03b1i in J\u0393, (ii) dom(J0) \u2229 dom(J\u0393) = {\u03b11, . . . , \u03b1k}, and (iii) \u0393 \u2229 \u0398 = dom(J\u0393) \u2229 dom(J\u0398), for every copy \u0398 of G in I\u2217. The model J is the union of J0 and all the J\u0393. If a guarded set X in J\u0393 arises from renaming elements of a guarded set Y in chase(D \u21be G,\u03a3), we also say that X is a copy of Y in J . Furthermore, the copies of D that are contained in I\u2217 (i.e., in J0) are also called copies in J . Observe that J is a model of I\n\u2217 by construction. We show that it is a model of \u03a3. To this end, we show the following claim.\nClaim 39. Let t\u0304 be a guarded tuple in J and let q(x\u0304) be a guarded conjunctive query9 over S\u222a sch(\u03a3). Suppose t\u0304 is a copy of s\u0304 in J, where s\u0304 is over dom(chase(D,\u03a3)) and |t\u0304| = |s\u0304|. Then J |= q(t\u0304) iff chase(D,\u03a3) |= q(s\u0304).\nProof. Suppose J |= q(t\u0304). Let {t\u0304} = {\u03b11, . . . , \u03b1k} be a copy of {s\u0304} = {a1, . . . , ak} in J . Since q(x\u0304) is guarded, there is a \u0393 \u2287 ({\u03b11, . . . , \u03b1k}\u2229 dom(J0)) such that J\u0393 |= q(t\u0304). Let G \u2287 {s\u0304} be the guarded set in D of which \u0393 is a copy in J0. It clearly holds that chase(D \u21be G,\u03a3) |= q(s\u0304), whence chase(D,\u03a3) |= q(s\u0304) follows.\nSuppose that chase(D,\u03a3) |= q(s\u0304). Let t\u0304 = \u03b11, . . . , \u03b1k and s\u0304 = a1, . . . , ak and suppose that \u03b1i = [\u03c0i]ai (i = 1, . . . , k). The set {a1, . . . , ak} is guarded in chase(D,\u03a3). Hence, there is a guarded G \u2287 {a1, . . . , ak} \u2229 dom(D) in D such that chase(D \u21be G,\u03a3) |= q(s\u0304). We show that there is a \u0393 \u2287 {\u03b11, . . . , \u03b1k} \u2229 dom(I\n\u2217) which is a copy of G in I\u2217. Suppose G = {b1, . . . , bl}. Let \u03c0 = X0X1 \u00b7 \u00b7 \u00b7Xm be such that [\u03c0]ai = [\u03c0i]ai for all i = 1, . . . , k. For i = 1, . . . , l, define\n\u03c1i := \u03c0 \u00b7 (Xm \u222a {b1}) \u00b7 (Xm \u222a {b1, b2}) \u00b7 \u00b7 \u00b7 (Xm \u222a {b1, . . . , bi}).\nThen bi is represented at \u03c1i. For i = 1, . . . , l, let \u03b2i := [\u03c1i]bi . We claim that \u0393 := {\u03b21, . . . , \u03b2l} is a copy of G in I \u2217. Let R/s \u2208 S and suppose I\u2217 |= R([\u03c1i1 ]bi1 , . . . , [\u03c1is ]bis ). Then we immediately obtain D |= R(bi1 , . . . , bis ). Conversely, if D |= R(bi1 , . . . , bis), let \u03c1 := \u03c1\u2113, where \u2113 := max{i1, . . . , is}. Take any j \u2208 {i1, . . . , is}. It is easy to see that \u03c1 and \u03c1j are bj-equivalent. Hence, [\u03c1j ]bj = [\u03c1]bj and it follows that I \u2217 |= R([\u03c1i1 ]bi1 , . . . , [\u03c1is ]bis ), as required. It follows that \u0393 is a copy of G in I\u2217 and so there is a structure J\u0393 contained in J that is isomorphic to chase(D \u21be G,\u03a3) with b1, . . . , bl respectively renamed to \u03b21, . . . , \u03b2l. Hence, J |= q(t\u0304) as required.\nNow let \u03c3 : \u03d5(x\u0304, y\u0304) \u2192 \u2203z\u0304 \u03b1(x\u0304, z\u0304) be a guarded rule from \u03a3. Suppose that J |= \u2203y\u0304 \u03d5(t\u0304, y\u0304). Since every guarded tuple in J is a copy of some guarded tuple in chase(D,\u03a3), there is an s\u0304, of which t\u0304 is a copy, such that chase(D,\u03a3) |= \u2203y\u0304 \u03d5(s\u0304, y\u0304). Since chase(D,\u03a3) is a model of \u03a3, we know that chase(D,\u03a3) |= \u2203z\u0304 \u03b1(s\u0304, z\u0304). It follows that J |= \u2203z\u0304 \u03b1(s\u0304, z\u0304) by the above claim, as required. It remains to show that J is universal:\nClaim 40. J is universal.\nProof. It suffices to show that J can be homomorphically mapped to chase(I\u2217,\u03a3) via a homomorphism \u03b7. We let \u03b70 be the homomorphism that maps every element of J0 to itself. It remains to treat the structures J\u0393. Consider a copy \u0393 = {\u03b11, . . . , \u03b1k} in I\n\u2217 of a set G = {b1, . . . , bk} which is guarded in D. It suffices to show that J\u0393 can be mapped to chase(I\u2217,\u03a3). To this end, it we show how to map chase(D \u21be G,\u03a3) to chase(I\u2217,\u03a3). We do so by induction on the number of rule applications of chase(D \u21be G,\u03a3). For the base case, we map D \u21be G to I\u2217 as follows. Let \u03b70G(bi) := \u03b1i, for i = 1, . . . , k. Suppose D \u21be G |= R(bi1 , . . . , bil) for some R \u2208 S and ij \u2208 {1, . . . , k}, where j = 1, . . . , l. Recall that \u0393 is guarded in I\n\u2217. Reviewing the construction of I\u2217, it is easy to see that this holds iff I\u2217 |= R(\u03b1i1 , . . . , \u03b1il ). Hence, \u03b7 0 G is indeed a homomorphism from D \u21be G to I\u2217. The induction step is obvious\u2014we can easily obtain a homomorphism \u03b7iG that maps chase k(D \u21be G,\u03a3) to chase(I\u2217,\u03a3). The desired homomorphism \u03b7G is the union of the \u03b7 i G (i \u2265 0). We then obtain a homomorphism \u03b7\u0393 from \u03b7G by appropriately renaming the elements from the domain of the latter as we did in the construction of J\u0393\u2014which is nothing else than an isomorphic copy of chase(D \u21be G,\u03a3). Furthermore, each of these homomorphisms maps each element of \u0393 to itself. The desired homomorphism \u03b7 that witnesses that J is universal is the union of \u03b70 and the \u03b7\u0393.\nIn order to prove I\u2217,\u03a3 |= q, it remains to show that there is a homomorphism \u00b5\u0302 that maps q to J . There are guarded sets G1, . . . , Gl in D such that \u00b5 can be understood to map q to chase( \u22c3\n1\u2264i\u2264l(D \u21be Gi),\u03a3). By construction, we know\nthat G1, . . . , Gl can be chosen in such a way that G\u00b5 \u2286 \u22c3l\ni=1 Gi. Since \u03a3 is guarded, \u00b5 can be understood to map q to \u22c3\n1\u2264i\u2264l chase(D \u21be Gi,\u03a3)\u2014assuming that the labeled nulls occurring in these instances are mutually new. Let C\u00b5 :=\n{{b\u03041}, . . . , {b\u0304k}}. For every X \u2208 C\u00b5, let \u0393X := {\u03bbb | b \u2208 X}. Notice that \u0393X is a copy of X in I \u2217. By construction, all the facts from q that are mapped via \u00b5 to chase(D,\u03a3) and which have an element from dom(D) in their image under \u00b5 are already mapped to \u22c3\nX\u2208C\u00b5 chase(D \u21be X,\u03a3). For the other facts, the names of the constants in the databases do not matter.10\nLet \u03981, . . . ,\u0398s be arbitrary copies of the sets {G1, . . . , Gl} \\ C\u00b5 in I \u2217. It follows that we can find our desired match \u00b5\u0302 in the\n9By a guarded conjunctive query we mean here a CQ that contains an atom that contains all the variables occurring in the CQ as argument.\n10Here, it is of course essential to assume constant-free rules.\nunion of \u22c3\nX\u2208C\u00b5 J\u0393X and\n\u22c3 1\u2264i\u2264s J\u0398i . Notice that \u22c3 X\u2208C\u00b5 J\u0393X is isomorphic to \u22c3 X\u2208C\u00b5 chase(D \u21be X,\u03a3) with each b \u2208 G\u00b5\nrepresented by \u03bbb.\nNow the database I\u2217 has the desired form with C being its core. However, I\u2217 is infinite. Since I\u2217,\u03a3 |= q due to Lemma 38, by compactness, there is a finite B\u0302 \u2286 I\u2217 such that B\u0302,\u03a3 |= q. Consider a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) witnessing that I\u2217 is a C-tree. There is a maximum \u2113 such that B\u0302 contains all the subinstances induced by the bags of depth less or equal \u2113. Let I\u0302 be the instance that actually contains all the subinstances induced by the bags of level up to \u2113. Hence, I\u0302 is itself a C-tree and I\u0302 ,\u03a3 |= q, since B\u0302 \u2286 I\u0302 .\nNow there is a natural homomorphism mapping I\u0302 to D: we simply specify [\u03c0]a 7\u2192 a for all a \u2208 dom(D). The instance I\u0302 is the one we are looking for."}, {"heading": "Proof of Lemma 22", "text": "One can naturally encode instances of bounded tree-width into trees over a finite alphabet such that the alphabet\u2019s size depends only on the tree-width. Our goal here is to appropriately encode C-trees in order to make them accessible to tree automata techniques. Since the tree-width of a C-tree over S depends only on the size of dom(C) and the maximum arity of S, the alphabet of the encoding will depend on the same.\nLabeled trees. Let \u0393 be an alphabet and (N \\ {0})\u2217 be the set of finite sequences of positive integers, including the empty sequence \u03b5.11 Let us recall that a \u0393-labeled tree is a pair t = (T, \u00b5), where \u00b5 : T \u2192 \u0393 is the labeling function and T \u2286 (N\\{0})\u2217 is closed under prefixes, i.e., x \u00b7 i \u2208 T implies x \u2208 T , for all x \u2208 (N \u222a {0})\u2217 and i \u2208 (N \u222a {0}). The elements contained in T identify the nodes of t. For i \u2208 N \\ {0}, nodes of the form x \u00b7 i \u2208 T are the children of x. A path of length n in T from x to y is a sequence of nodes x = x1, . . . , xn = y such that xi+1 is a child of xi. A branch is a path from the root to a leaf node. For x \u2208 T , we set x \u00b7 i \u00b7 \u22121 := x, for all i \u2208 N, and x \u00b7 0 := x\u2014notice that \u03b5 \u00b7 \u22121 is not defined.\nEncoding. Let l \u2265 0 and fix a schema S. Let US,l be the disjoint union of two sets Cl and TS, respectively containing l and 2 \u00b7 ar(S) elements. The elements from US,l will be called names. Elements from the set Cl will describe core elements, while those of TS will describe the others. Furthermore, neighboring nodes may describe overlapping pieces of the instance. In particular, if one name is used in neighboring nodes, this means that the name at hand refers to the same element\u2014this is why we use 2w elements for the non-root bags. Let KS,l be the finite schema capturing the following information:\n\u2022 For all a \u2208 US,l, there is a unary relation Da \u2208 KS,l.\n\u2022 For all a \u2208 Cl, there is a unary relation Ca \u2208 KS,l.\n\u2022 For each R \u2208 S and every n-tuple a\u0304 \u2208 UnS,l, there is a unary relation Ra\u0304 \u2208 KS,l.\nLet \u0393S,l := 2 KS,l be an alphabet and suppose that D is a (finite) C-tree over S such that |dom(C)| \u2264 l. Consider a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) witnessing that D is indeed a C-tree and let \u03b5 be the root of T . Fix a function f : dom(D) \u2192 US,l such that (i) f \u21be dom(C) is injective and (ii) different elements that occur in neighboring bags of \u03b4 are always assigned different names from US,l. Using f , we can encode D and \u03b4 into a \u0393S,l-labeled tree t = (T\u0302 , \u00b5) such that each node from T corresponds to exactly one node in T\u0302 and vice versa. For a node v from T , we denote the corresponding node of T by v\u0302 in the following and vice versa. In this light, the symbols from KS,l have the following intended meaning:\n\u2022 Da \u2208 \u00b5(v\u0302) means that a is used as a name for some element of the bag Xv.\n\u2022 Ca \u2208 \u00b5(v\u0302) indicates that a is used as name for an element of the bag Xv that also occurs in X\u03b5, i.e., a names an element from the core of D.\n\u2022 Ra\u0304 \u2208 \u00b5(v\u0302) indicates that R holds in D for the elements named by a\u0304 in bag Xv .\nUnder certain assumptions, we can decode a \u0393S,l-labeled tree t = (T, \u00b5) into a C-tree whose width is bounded by ar(S)\u2212 1. Let names(v) := {a | Da \u2208 \u00b5(v)}. We say that t is consistent, if it satisfies the following properties:\n1. For all nodes v it holds that |names(v)| \u2264 ar(S), except for the root whose number of names are accordingly bounded by l. Furthermore, names(\u03b5) \u2286 Cl.\n2. For all Ra\u0304 \u2208 KS,l and all v \u2208 T it holds that Ra\u0304 \u2208 \u00b5(v) implies that {a\u0304} \u2286 names(v).\n3. For all a \u2208 Cl and all v \u2208 T it holds that Da \u2208 \u00b5(v) iff Ca \u2208 \u00b5(v).\n4. If Ca \u2208 \u00b5(v), then Ca \u2208 \u00b5(w) for all w \u2208 T on the unique shortest path between v and the root.\n5. For all nodes v 6= \u03b5, there is an Ra\u0304 \u2208 KS,l and a node w such that Ra\u0304 \u2208 \u00b5(w), names(v) \u2286 {a\u0304}, and, for all b \u2208 names(v), v and w are b-connected.\n11We specify that 0 is included in N as well.\nDecoding trees. Suppose now that t is consistent. We show how we can decode t into a database JtK which is a C-tree whose diameter is bounded by l. Let a be a name used in t. We say that two nodes v, w of t are a-equivalent if Da \u2208 \u00b5(u) for all nodes u on the unique shortest path between v and w. Clearly, a-equivalence defines an equivalence relation and we let [v]a := {(w, a) | w is a-equivalent to v} and [v] \u2217 a := {w | (w, a) \u2208 [v]a}. The domain of JtK is the set {[v]a | v \u2208 T, a \u2208 \u00b5(v)} and, for R/n \u2208 S, we define\nJtK |= R([v1]a1 , . . . , [vn]an) \u21d0\u21d2df there is some v \u2208 [v1] \u2217 a1 \u2229 \u00b7 \u00b7 \u00b7 \u2229 [vn] \u2217 an such that Ra1,...,an \u2208 \u00b5(v).\nLemma 41. Let t be a consistent \u0393S,l-labeled tree with root node \u03b5. Then JtK is well-defined and a C-tree over S, where C is the subinstance of JtK induced by the set {[\u03b5]a | a \u2208 names(\u03b5)}. Moreover, |dom(C)| is bounded by l.\nProof. Let t = (T, \u00b5) be a consistent, \u0393S,l-labeled tree. The fact that JtK is well-defined is left to the reader. We are going to construct an appropriate decomposition \u03b4 = (T , (Xt)t\u2208T ) for JtK. The tree T has the same structure as t. Furthermore, for v \u2208 T , we set Xv := {[v]a | a \u2208 names(v)}. We need to show that \u03b4 is indeed a tree decomposition that satisfies the desired properties.\nLet [v]a \u2208 dom(JtK) and consider two nodes v1, v2 \u2208 T such that [v]a \u2208 Xv1 and [v]a \u2208 Xv2 . Then v1, v2 \u2208 [v]a and so v1 and v2 are a-connected. Hence, w \u2208 [v]a for all w \u2208 T which lie on the unique shortest path between v1 and v2. Since a \u2208 names(w) for all such w, it follows that [v]a \u2208 Xw , and so [v]a is contained in all bags on the unique path between v1 and v2. Suppose JtK |= R([v1]a1 , . . . , [vn]an). Then there is a v \u2208 [v1] \u2217 a1 \u2229 \u00b7 \u00b7 \u00b7 \u2229 [vn] \u2217 an such that Ra1,...,an \u2208 \u00b5(v). By consistency, {a1, . . . , an} \u2286 names(v). Moreover, we know that [vi]ai = [v]ai , for i = 1, . . . , n. It follows that {[v1]a1 , . . . , [vn]an} \u2286 Xv . Now let v \u2208 T \\ {\u03b5}. By consistency, there is an Ra1,...,an \u2208 KS,l and a w \u2208 T such that names(v) := {ai1 , . . . , ais} \u2286 {a1, . . . , an} \u2286 names(w), Ra1,...,an \u2208 \u00b5(w), and v and w are bij -connected for j = 1, . . . , s. By construction, Xv = {[v]ai1 , . . . , [v]ais } and {[w]a1 , . . . , [w]an} \u2286 Xw. The claim follows now since [v]aij = [w]aij for j = 1, . . . , s. It is immediate that |dom(C)| is bounded by l.\nNotation. Given a consistent \u0393S,l-labeled tree t = (T, \u00b5) and a label \u03c1 \u2208 \u00b5(T ), in order to ease notation we often regard \u03c1 as a database consisting of the facts {R(a\u0304) | Ra\u0304 \u2208 \u03c1}. Furthermore, we let names(\u03c1) := {a | Da \u2208 \u03c1}.\nProof of Lemma 22. The lemma is an easy consequence of Lemma 41 and the fact that, when encoding a C-tree D over S, together with a tree decomposition witnessing that D is a C-tree, into a consistent \u0393S,l-labeled tree t, then JtK and D are isomorphic.\nRoughly, Lemma 22 states that containment among OMQs from (G,BCQ) can be semantically characterized via the decodings of consistent \u0393S,l-labeled trees. This makes the problem of deciding containment amenable to tree automata techniques."}, {"heading": "Proof of Lemma 23", "text": "Before proceeding to the proof of Lemma 23, we first introduce the relevant automata model."}, {"heading": "Automata Techniques", "text": "For a set of propositional variables X, we denote by B+(X) the set of Boolean formulas using variables from X, the connectives \u2227,\u2228, and the constants true, false. Let us now introduce our automata model.\nDefinition 10. A two-way alternating parity automaton (2WAPA) on trees is a tuple A = (S,\u0393, \u03b4, s0,\u2126), where S is a finite set of states, \u0393 an alphabet (the input alphabet of A), \u03b4 : S \u00d7 \u0393 \u2192 B+(tran(A)) the transition function, where we set tran(A) := {\u3008\u03b1\u3009s, [\u03b1]s | s \u2208 S, \u03b1 \u2208 {\u22121, 0, \u2217}}, s0 \u2208 S the initial state, and \u2126: S \u2192 N the parity condition that assigns to each s \u2208 S a priority \u2126(s). Elements from tran(A) are called transitions.\nIntuitively, a transition of the form \u30080\u3009s means that a copy of the automaton should change to state s and stay at the current node. A transition of the form \u3008\u22121\u3009s means that a copy should be sent to the parent node, which is then required to exist, and proceed in state s, while one of the form \u3008\u2217\u3009s means that a copy of the automaton that assumes state s is sent to some child node. The transition [0]s means the same as \u30080\u3009s, while [\u22121]s means that a copy of the automaton that assumes state s should be sent to the parent node which is there not required to exist at all. Likewise, [\u2217]s means that a copy of the automaton assuming state s should be sent to all child nodes.\nNotation. We write \u2738s for \u2228 {\u3008\u03b1\u3009s | \u3008\u03b1\u3009s \u2208 tran(A), s \u2208 S}, \u2737s for \u2227 {[\u03b1]s | [\u03b1]s \u2208 tran(A), s \u2208 S}, and simply s for \u30080\u3009s.\nFurthermore, for \u03b1 \u2208 N \u222a {\u22121, \u2217}, we define\nT\u03b1(x) :=\n \n\n{x \u00b7 \u03b1}, if \u03b1 = \u22121 and x \u00b7 \u03b1 \u2208 T ,\n{x \u00b7 i | x \u00b7 i \u2208 T, i \u2208 N \\ {0}}, if \u03b1 = \u2217,\n\u2205, otherwise.\nDefinition 11. A run of a 2WAPA A = (S,\u0393, \u03b4, s0,\u2126) on a \u0393-labeled tree (T, \u03b7) is a T \u00d7 S-labeled tree (Tr, \u03b7r) such that the following holds:\n1. \u03b7r(\u03b5) = (\u03b5, s0),\n2. if y \u2208 Tr, \u03b7r(y) = (x, s), and \u03b4(s, \u03b7(x)) = \u03d5, then there is an I \u2286 tran(A) such that I |= \u03d5 holds and the following conditions are satisfied:\n\u2022 If \u3008\u03b1\u3009s\u2032 \u2208 I then there is a node x\u2032 \u2208 T\u03b1(x) and a child node y \u2032 \u2208 Tr of y such that \u03b7r(y \u2032) = (x\u2032, s\u2032). \u2022 If [\u03b1]s\u2032 \u2208 I then for all x\u2032 \u2208 T\u03b1(x), there is a child node y \u2032 \u2208 Tr of y such that \u03b7r(y \u2032) = (x\u2032, s\u2032).\nWe say that a run (Tr, \u03b7r) is accepting on A, if on all infinite paths (\u03b5, s0), (x1, s1), (x2, s2), . . . in Tr, the maximum priority among \u2126(s0),\u2126(s1),\u2126(s2), . . . that appears infinitely often is even. A accepts a \u0393-labeled tree (T, \u03b7), if there is an accepting run on (T, \u03b7). We denote by L(A) the set of \u0393-labeled trees A accepts, i.e., the language accepted by A.\nRemark. The automaton model defined above resembles that in [48]. However, we explicitly provide transitions that allow the automaton move to the parent node, while the model defined in [48] provides transitions for moving to some neighboring node, including the parent node. Therefore, the automata in [48] offer transitions of the form s, \u2738s, and \u2737s with their intended meaning as defined above. Using techniques as employed in [47, 48], for a 2WAPA A, one can show that the problem of deciding whether L(A) = \u2205 is feasible in exponential time with respect to the number of states of A and in polynomial time with respect to the size of the input alphabet of A.\nProof of Lemma 23. We only give an intuitive explanation for the construction of the desired 2WAPA. To check whether a \u0393S,l-labeled tree is consistent, we can check each condition for consistency separately by a dedicated 2WAPA and then take the intersection of all of them. Most of the consistency conditions are easy to check. We give here a more detailed verbal explanation for condition (5). A 2WAPA checking this condition can be constructed as follows. At the beginning of its run, the automaton branches universally to all nodes (except the root) in a state whose intended purpose is to find appropriate guards in the input tree for the names available at the current node. To this end, the automaton has to do a reachability analysis on the input tree and store, using exponentially many states in ar(S), the tuple it seeks to guard. By a guard for the node v here, we mean a node w with an Ra\u0304 \u2208 \u00b5(w) such that (i) {a\u0304} contains all the names present at w and (ii) is b-connected to v for all b \u2208 names(v). Notice that such a reachability analysis can be easily performed once we have the means to store the information contained in names(v) in a single state. This is, however, possible since for this task we need somewhat O((ar(S)+ l)ar(S)) states, i.e., polynomially many in the size of \u0393S,l."}, {"heading": "Proof of Lemma 24", "text": "We first need to introduce some additional auxiliary notions."}, {"heading": "Strictly Acyclic Queries", "text": "Let q be a CQ over a schema S. We denote by free(q) the free variables of q; the same notation is used for first-order formulas in general. We can naturally view q as an instance [q] whose domain is the set of variables of q and contains the body atoms of q as facts. In the following, we will often overload notation and write q for both the query q and the instance [q]. The notions of tree-width, acyclicity, etc. then immediately extend to CQs. Given a tree decomposition \u03b4 of q (i.e., of [q]), we say that \u03b4 is strict, if some bag of \u03b4 contains all variables that are free in q (cf. also [32]). Accordingly, q is called strictly acyclic if it has a guarded tree decomposition that is strict.\nStrictly acyclic queries have the convenient property to be equivalent to guarded formulas of a special form. Recall that the set of guarded formulas over a schema S is built inductively by including all atomic formulas, relativizing quantifiers by atomic formulas, and closing under Boolean connectives. More precisely, all quantifier occurrences have one of the forms\n\u2200y\u0304 (\u03b1(x\u0304, y\u0304) \u2192 \u03d5) and \u2203y\u0304 (\u03b1(x\u0304, y\u0304) \u2227 \u03d5),\nsuch that the free variables of \u03d5 are among {x\u0304, y\u0304}. We are interested in the guarded formulas that are build up using conjunction and existential quantification; we restrict ourselves to such formulas in the following. We call a formula from this class strictly guarded, if it is of the form \u2203y\u0304 (\u03b1(x\u0304, y\u0304)\u2227\u03d5). We explicitly include the case where y\u0304 is the empty sequence of variables, i.e., if to formulas of the form \u03b1(x\u0304) \u2227 \u03d5 with free(\u03d5) \u2286 {x\u0304}. Notice that every guarded sentence \u03d5 (i.e., a formula having no free variables) is strictly guarded, since it is equivalent to \u2203y (y = y \u2227 \u03d5). Furthermore, notice that every usual guarded formula that uses only existential quantifiers and conjunction is equivalent to a conjunction of strictly guarded formulas. The following lemma is proved in [32].\nLemma 42. Every strictly acyclic CQ can be rewritten in polynomial time into an equivalent strictly guarded formula that is built up using conjunction and existential quantification only. The converse holds as well."}, {"heading": "Squid Decompositions", "text": "Let q be a BCQ over a schema S having n body atoms. An S-cover of q is a BCQ q+ that contains all the atoms from q and may additionally contain 2n other body atoms over S. It is pretty straightforward that, for an S-instance I , it holds that I |= q iff there is an S-cover q+ of q such that I |= q+.\nDefinition 12. Let I be an instance. For V \u2286 dom(I), we say that I is [V ]-acyclic, if it has a guarded tree decomposition that omits V .\nDefinition 13. Let q be a BCQ over S. A squid decomposition of q is a tuple \u03b4 = (q+, \u00b5,H,T, V ), where q+ is an S-cover of q, \u00b5 : var(q+) \u2192 var(q+) a mapping, V \u2286 var(\u00b5(q+)), and (H,T ) a partition of the atoms \u00b5(q+) such that\n\u2022 H is the set of atoms of \u00b5(q+) induced by V ,\n\u2022 T = \u00b5(q+) \\H and T is [V ]-acyclic.\nIntuitively, a squid decomposition specifies a way how a BCQ can be mapped to an instance that contains some \u201ccyclic parts\u201d\u2014the set H specifies those atoms that are mapped to such cyclic parts, while A declares those atoms that are mapped to the acyclic parts of the instance at hand. We will make this more precise in Lemma 43 below, where we analyze matches in C-trees.\nGiven a CQ q and a set of variables V \u2286 var(q), the V -reduct of q, denoted qV , is the conjunctive query that arises from q by dropping all the existential quantifiers that bind variables in V .\nLemma 43. Let J be a C-tree over S and q a BCQ over S. Let (T , (Xt)t\u2208T ) be a witnessing tree decomposition of J. It holds that J |= q iff there is a squid decomposition \u03b4 = (q+, \u00b5,H,A, V := {x\u0304}) of q and a homomorphism \u03b7 : \u00b5(q+) \u2192 J such that\n1. C |= H is witnessed by \u03b7,\n2. \u22c3\n\u03b5\u227av J(v) |= A V (\u03b7(x\u0304)) is witnessed by \u03b7, and\n3. there are strictly guarded formulas \u03d51, . . . , \u03d5l such that A V (x\u0304) \u2261 \u03d51 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d5l.\nProof. For the direction from right to left, consider such a given squid decomposition \u03b4 and a homomorphism \u03b7 as in the hypothesis of the lemma. It is immediate that \u03b7 \u25e6 \u00b5 is a homomorphism mapping q+ to J . Since q+ is an S-cover of q, we obtain J |= q as required.\nFor the other direction, suppose that J |= q is witnessed by a homomorphism \u03b8. For each v \u2208 T \\ {\u03b5}, let \u03b2v be an atom of J such that J(v) |= \u03b2v and \u03b2v contains all domain elements from J(v) as arguments. Notice that the \u03b2v exist, since \u03b4 is guarded except for {\u03b5}. Since \u03b8 maps q to J , for each atom \u03b1 of q, there is a node v\u03b1 such that \u03b8(\u03b1) \u2208 J(v\u03b1). Let W be the set of all these nodes and their closure under greatest lower bounds with respect to , excluding the root node \u03b5 of T . Consider the set of atoms Q+ := \u03b8(q) \u222a {\u03b2v | v \u2208 W }. Notice that at least half of the nodes of W are of the form v\u03b1\u2014hence, |Q+| \u2264 3|q|. Let q+ be a BCQ constructed as follows. Take the conjunction of q and for each \u03b2v(a1, . . . , an) (v \u2208 W ), add an atom \u03b2v(x1, . . . , xn), where each xi is a newly chosen variable. Then q\n+ is obviously an S-cover of q. Furthermore, by construction, there is a mapping \u00b5 : var(q+) \u2192 var(q+) and an isomorphism \u03b7 : \u00b5(q+) \u2192 Q+ such that (\u03b7 \u25e6 \u00b5)(q+) = Q+. Now let H be the greatest set of atoms of \u00b5(q+) such that \u03b7(H) \u2286 J(\u03b5). Moreover, let V := var(H) and A := \u00b5(q+) \\ H . We claim that \u03b4 := (q+, \u00b5, H,A, V ) is a squid decomposition of q that satisfies together with \u03b7 the points mentioned in the statement of the lemma.\nTo see that \u03b4 is a squid decomposition of q, the only nontrivial point to prove is that A is indeed [V ]-acyclic. We will prove this below in the course of establishing the third item.\nThe first two items are immediate by construction. We prove the third item. Suppose V = {x\u0304} and consider the V -reduct AV (x\u0304) of A. By construction, the atoms \u03b7(A) are contained in \u22c3\n\u03b5\u227av J(v). Now the set W together with the order T gives rise to a forest consisting of trees T1, . . . , Tl whose roots are descendants of \u03b5, i.e., the root of T (recall that \u03b5 is not contained in W ). Moreover, we have (i) \u22c3l\ni=1 Ti = W , (ii) Ti \u2229 Tj = \u2205, for i 6= j, and (iii) \u22c3 v\u2208Ti Xv \u2229 \u22c3 v\u2208Tj Xv \u2286 dom(C), for i 6= j.\nFor v \u2208 T , let Q+(v) := {\u03b1 \u2208 Q+ | J(v) |= \u03b1} and, for i = 1, . . . , l, let Q+(Ti) be the set of atoms \u22c3\nv\u2208Ti Q+(v). Now it is\neasy to check using the facts stated before that each Q+(Ti) is acyclic and, hence, so is \u03b7 \u22121(Q+(Ti)). Furthermore, denoting by \u03b5i the root of Ti, it holds that dom(Q +(Ti)) \u2229 \u03b7(V ) \u2286 dom(Q +(\u03b5i))\u2014indeed, if a \u2208 dom(Q +(v)) \u2229 \u03b7(V ) for some v \u03b5i, then, since \u03b5i \u227b \u03b5 and a \u2208 X\u03b5, it must be the case that a \u2208 dom(Q +(\u03b5i)) by connectivity. It follows that the V -reduct of \u03b7\u22121(Q+(Ti)) (viewed as Boolean query), henceforth denoted q + Ti , is strictly acyclic and is therefore equivalent to a strictly guarded formula \u03d5i. Hence, the query A V (x\u0304) is equivalent to \u2227l i=1 \u03d5i. Moreover, it follows that A itself is [V ]-acyclic\u2014notice that A \u2261 \u2203x\u0304 \u2227l\ni=1 q + Ti and that dom(Q+(Ti)) \u2229 dom(Q +(Tj)) \u2286 \u03b7(V ), for i 6= j. Hence, var(q + Ti ) \u2229 var(q+Tj ) \u2286 V , for i 6= j.\nThe claim now follows since every q+Ti is acyclic."}, {"heading": "Derivation trees", "text": "Let D be an S-database and \u03a3 a set of guarded rules. Let q0(x\u0304) be a strictly acyclic query whose free variables are exactly those from x\u0304 := x1, . . . , xn and let a\u0304 := a1, . . . , an be a tuple from dom(D). A derivation tree for (a\u0304, q0(x\u0304)) with respect to D and \u03a3 is a finite tree T whose nodes are labeled via a function \u00b5 with pairs of the form (b1, . . . , bk; q(y1, . . . , yk)), where b1, . . . , bk are constants from dom(D) and q(y1, . . . , yk) is a strictly acyclic query over S \u222a sch(\u03a3) having exactly y1, . . . , yk free, such that the following conditions are satisfied:\n1. \u00b5(\u03b5) = (a\u0304, q0(x\u0304)), where \u03b5 is the root node of T .\n2. If \u00b5(v) = (c1, . . . , cm; q(z1, . . . , zm)) for some node v, then one of the following conditions holds (let c\u0304 := c1, . . . , cm and z\u0304 := z1, . . . , zm):\n(a) v is a leaf node and q(z\u0304) \u2261 \u03b2(z\u0304), for some atomic formula \u03b2(z\u0304) such that D |= \u03b2(c\u0304).\n(b) The node v has a successor labeled by (c\u0304, b\u0304; p(z\u0304, y\u0304)) and it holds that\n\u03a3 |= \u2200z\u0304, y\u0304 (p(z\u0304, y\u0304) \u2192 q(z\u0304)).\n(c) The query q(z\u0304) is logically equivalent to q1(zi1,1 , . . . , zi1,k1 )\u2227\u00b7 \u00b7 \u00b7\u2227ql(zil,1 , . . . , zil,kl ) and v has l successors v1, . . . , vl respectively labeled by (ci1,1 , . . . , ci1,k1 ; q1(zi1,1 , . . . , zi1,ki )), . . . , (cil,1 , . . . , ci1,kl ; ql(zil,1 , . . . , zi1,kl )).\nLemma 44. Let \u03b1(x1, . . . , xn) be an atomic formula. Then D,\u03a3 |= \u03b1(a1, . . . , an) iff there is a derivation tree for (a1, . . . , an;\u03b1(x1, . . . , xn)) with respect to D and \u03a3.\nProof (sketch). Let a\u0304 := a1, . . . , an and x\u0304 := x1, . . . , xn. The direction from right to left is an easy induction on the construction of the derivation tree. We sketch the other direction. Consider the guarded chase forest (F , \u03b7) for D and \u03a3, where \u03b7 is a function labeling the nodes and edges of F . We construct a derivation tree for (a\u0304, \u03b1(x\u0304)) by induction on the number of chase steps required to derive \u03b1(a\u0304) from D and \u03a3.\nFor the base case, if D |= \u03b1(a\u0304), the claim is obvious since we can apply rule 2.(a). Assume that \u03b1(a\u0304) is derived using a rule\n\u03c3 : \u03b20(x\u0304, y\u0304), \u03b21, . . . , \u03b2k \u2192 \u03b1(x\u0304),\nand a homomorphism \u00b5 such that \u00b5(x\u0304) = a\u0304, where \u03b20(x\u0304, y\u0304) is the guard of \u03c3. If \u00b5({x\u0304, y\u0304}) \u2286 dom(D), the result immediately follows by the induction hypothesis. Otherwise, the image of \u03b20(x\u0304, y\u0304) under \u00b5 contains some labeled nulls as arguments. Assume that all the \u03b21, . . . , \u03b2k contain nulls as their arguments\u2014for those that do not, the induction hypothesis would yield appropriate derivation trees again. Notice that all the nulls occurring in \u03b21, . . . , \u03b2k appear in \u00b5({y\u0304}). By construction of F , there is a node v0 that is an ancestor of the nodes having the atoms \u00b5(\u03b20), \u00b5(\u03b21), . . . , \u00b5(\u03b2k) as labels and which has a label of the form \u03b20(a\u0304, b\u0304) which contains no nulls at all as arguments. There is a corresponding atomic formula \u03b30(x\u0304, z\u0304) whose image under an appropriate homomorphism equals \u03b20(a\u0304, b\u0304). Furthermore, there are atoms \u03b31, . . . , \u03b3l such that dom({\u03b31, . . . , \u03b3l}) \u2286 {a\u0304, b\u0304} and\n\u03a3 |= \u03b20(a\u0304, b\u0304) \u2227 \u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3l \u2192 \u2203y\u0304 (\u03b20(a\u0304, y\u0304) \u2227 \u03b21 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b2k).\nNow regard the \u03b3i (i = 1, . . . , l) as atomic formulas with free variables among {x\u0304, z\u0304}. The formula p(x\u0304, z\u0304) := \u03b30(x\u0304, z\u0304)\u2227\u03b31\u2227\u00b7 \u00b7 \u00b7\u2227\u03b3l is then a strictly acyclic query that satisfies \u03a3 |= \u2200x\u0304, z\u0304 (p(x\u0304, z\u0304) \u2192 \u03b1(x\u0304)). An application of rule 2.(b) then requires us to find a derivation tree for (a\u0304, b\u0304; p(x\u0304, y\u0304)), whence an application of rule 2.(c) reduces this task to finding derivation trees for the atoms \u03b30, \u03b31, . . . , \u03b3l and their corresponding tuples of constants. These trees exist by induction hypothesis and we can simply concatenate them appropriately in order to arrive at a derivation tree for (a\u0304, \u03b1(x\u0304)).\nGiven a guarded formula \u03d5(x\u0304) built up from conjunctions and existential quantification, we define the nesting depth of \u03d5(x\u0304), denoted nd(\u03d5(x\u0304)), inductively:\n\u2022 If \u03d5(x\u0304) is an atomic formula, then nd(\u03d5(x\u0304)) := 0.\n\u2022 If \u03d5(x\u0304) = (\u03c81 \u2227 \u03c82), then nd(\u03d5(x\u0304)) := max{nd(\u03c81),nd(\u03c82)}.\n\u2022 If \u03d5(x\u0304) = \u2203y\u0304 (\u03b1(x\u0304, y\u0304) \u2227 \u03c8) and y\u0304 6= \u2205, then nd(\u03d5(x\u0304)) := nd(\u03c8) + 1.\nLemma 45. Let D be a database, \u03a3 a set of guarded rules, and q(x\u0304) a strictly acyclic conjunctive query. Then D,\u03a3 |= q(a\u0304) iff there is a derivation tree for (a\u0304, q(x\u0304)) with respect to D and \u03a3.\nProof (sketch). We again sketch only the direction from left to right. Let \u03d5(x\u0304) be the strictly guarded formula corresponding to q(x\u0304). We proceed by induction on the nesting depth of \u03d5(x\u0304). If nd(\u03d5(x\u0304)) = 0, then \u03d5(x\u0304) is quantifier free and thus a conjunction of atoms \u03b10(x\u0304) \u2227 \u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1k, where var(\u03b1i) \u2286 {x\u0304} for i = 1, . . . , k. An application of rule 2.(c) reduces the problem of building a derivation tree for (a\u0304, \u03d5(x\u0304)) to the problem of building corresponding trees for the \u03b1i and their corresponding constants from a\u0304. The existence of these trees is guaranteed by Lemma 44.\nNow suppose that nd(\u03d5(x\u0304)) = n+ 1. Let \u03d5(x\u0304) = \u2203y\u0304 (\u03b1(x\u0304, y\u0304) \u2227 \u03c8) and y\u0304 := y1, . . . , yk. Assume, without loss of generality, that all the bound variables from \u03d5(x\u0304) are pairwise distinct. In the following, we will describe how to construct a derivation tree for (a\u0304, q(x\u0304)). If D,\u03a3 |= q(a\u0304), then there is a homomorphism \u00b5 mapping each atom of q(x\u0304) to chase(D,\u03a3) such that \u00b5(x\u0304) = a\u0304. Furthermore, \u00b5 maps each atom of q(x\u0304) to a node of the guarded chase forest F of D and \u03a3. Let \u03b1\u00b5(a\u0304, \u03bb1, . . . , \u03bbk) denote the atom labeling the node of F where \u03b1(x\u0304, y\u0304) is mapped to via \u00b5. Let \u03bbi1 , . . . , \u03bbil exhaust all elements from \u03bb1, . . . , \u03bbk that are not from dom(D) and b\u0304 := \u03bbj1 , . . . , \u03bbjm exhaust those from \u03bb1, . . . , \u03bbk that are from dom(D). Let \u03d5\n\u2032(x\u0304, yj1 , . . . , yjm ) be the formula \u2203yi1 , . . . , yil (\u03b1(x\u0304, y\u0304) \u2227 \u03c8). Clearly, \u03a3 |= \u2200x\u0304, yj1 , . . . , yjm (\u03d5\n\u2032(x\u0304, yj1 , . . . , yjm) \u2192 \u03d5(x\u0304)). Hence, we can create a successor of (a\u0304, \u03d5(x\u0304)) that is labeled by (a\u0304, b\u0304;\u03d5\u2032(x\u0304, yj1 , . . . , yjm)). Assume now that none of the \u03bb1, . . . , \u03bbk is from dom(D). Furthermore, assume that k \u2265 1, since otherwise we can just simply apply rule 2.(c) to reduce q(x\u0304) to a conjunction of queries of the desired form. As in the proof of Lemma 44, there is a node v0 in F whose label \u03b20(a\u0304, b\u0304) contains only values from dom(D) as arguments and such that v0 is an ancestor of the node labeling \u03b1\u00b5(a\u0304, \u03bb1, . . . , \u03bbk). Furthermore, all the atoms from\n\u00b5(q(x\u0304)) that contain an element from \u03bb1, . . . , \u03bbk as argument are also located in the subtree rooted at v0. Let p be the query that results from deleting all atoms from q(x\u0304) which are mapped via \u00b5 into the subtree rooted at v0. Notice that p may be empty and has free variables among x\u0304. Furthermore p is equivalent to a conjunction p1\u2227\u00b7 \u00b7 \u00b7\u2227pl of strictly acyclic queries. Let \u03b20(x\u0304, z\u0304) be the atomic formula whose image under an appropriate homomorphism equals \u03b20(a\u0304, b\u0304). A similar line of reasoning as in the proof of Lemma 44 shows that there are atomic formulas \u03b21, . . . , \u03b2m such that var(\u03b2i) \u2286 {x\u0304, z\u0304} and\n\u2200x\u0304, z\u0304 (\u03b20(x\u0304, z\u0304) \u2227 \u03b21 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b2m \u2227 p \u2192 \u03d5(x\u0304)),\nwhence an application of rule 2.(b) and rule 2.(c) reduces the problem of constructing a derivation tree for (a\u0304, \u03d5(x\u0304)) to that of constructing corresponding trees for \u03b20, . . . , \u03b2m and p. Notice that p is a conjunction of strictly guarded formulas of nesting depth at most n. Hence, the induction hypothesis guarantees the existence of such derivation trees.\nHaving the above results in place, it is easy to show the following statement:\nLemma 46. Let D be a C-tree over S and Q = (S,\u03a3, q) an OMQ where \u03a3 is guarded and q a BCQ. Then D |= Q iff there is a squid decomposition \u03b4 = (q+, \u00b5, H,A, V := {x\u0304}) of q and a homomorphism \u03b7 : \u00b5(q+) \u2192 chase(D,\u03a3) such that:\n1. F |= H is witnessed by \u03b7, where F is the subinstance of chase(D,\u03a3) induced by dom(C).\n2. There are strictly acyclic queries q1, . . . , ql such that\n(a) AV (x\u0304) \u2261 q1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 ql and\n(b) for i = 1, . . . , l and free(qi) = {x\u0304i}, there are derivation trees for (\u03b7(x\u0304i), qi) with respect to D and \u03a3.\nProof. We can easily prove by induction on the number of chase steps that chase(D,\u03a3) is an F -tree, where F is the subinstance of chase(D,\u03a3) induced by dom(C). Now the lemma at hand is immediate by combining this fact with Lemma 43 and Lemma 45.\nWe are now ready to proceed with the proof of Lemma 24:\nProof of Lemma 24. Lemma 46 will guide the construction of the 2WAPA we are now going to construct. Suppose Q = (S,\u03a3, q) is an OMQ from (G,BCQ) and let l \u2265 1. We are going to construct a 2WAPA AQ,l = (S,\u0393S,l, \u03b4, s0,\u2126) that accepts a consistent \u0393S,l-labeled tree t iff JtK |= Q. In particular, the number of states of AQ,l will be at most exponential in the size of Q and at most polynomial in l, while the construction of AQ,l will be feasible in 2ExpTime.\nThe state set. Let \u039b denote the set of all Boolean acyclic queries over S \u222a sch(\u03a3) that are of size at most 3|q|. Notice that each of these queries is equivalent to a strictly guarded formula. Furthermore, assume that \u039b is closed under V -reducts, for V \u2286 var(q), provided that they are strictly acyclic as well, i.e., if p \u2208 \u039b and V \u2286 var(q), then also pV \u2208 \u039b provided pV is strictly acyclic. For {a\u0304} \u2286 US,l, let\nS\u0302(a\u0304) := {p(x\u0304/a\u0304) | p \u2208 \u039b, free(p) = {x\u0304}, |a\u0304| = |x\u0304|}\nand let S\u0302 be the union of all the sets S\u0302(a\u0304). Now the set of states S consists of an initial state, denoted s0, plus the set S\u0302 factorized modulo logical equivalence. We denote by [p] the equivalence class of a query p \u2208 S\u0302. Furthermore, for a strictly\nguarded formula \u03d5, we may abuse notation and write [\u03d5] for the equivalence class of the strictly acyclic query p \u2208 S\u0302 that is equivalent to \u03d5. Notice that the size of S is exponential in the size of Q, since there are only exponentially many CQs of size at most 3|q| that are mutually non-equivalent (cf. [9]).\nThe parity condition. We set \u2126(s) := 1, for all s \u2208 S. This means that only finite trees are accepted.\nThe transition function. In the following, for each \u03c1 \u2208 \u0393S,l, we denote by \u0398\u0302(\u03c1) the set of all pairs that are of the form (\u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1n, p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pm) for which there is a squid decomposition of the form (q\n+, \u00b5, H,T, {x\u0304}) and a function \u03b8 : {x\u0304} \u2192 names(\u03c1) such that:\n\u2022 H{x\u0304}(\u03b8(x\u0304)) \u2261 \u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1n, where all the \u03b1i are relational ground atoms.\n\u2022 T {x\u0304}(\u03b8(x\u0304)) \u2261 p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pm, where the pi are strictly acyclic queries.\nCall two pairs (\u03d51, \u03c81) and (\u03d52, \u03c82) as above equivalent if \u03d51 \u2261 \u03d52 and \u03c81 \u2261 \u03c82. Let \u0398(\u03c1) be the set of equivalence classes under this relation and denote by [\u03d5, \u03c8] the equivalence of a pair (\u03d5,\u03c8) under this relation. Now we fix for each [p] \u2208 S \\ {s0} a strictly guarded formula \u03c7[p] that is equivalent to all queries from [p]. Likewise, we fix a function \u03d1\u03c1 : \u0398(\u03c1) \u2192 \u0398\u0302(\u03c1) such that \u03d1\u03c1([\u03d5, \u03c8]) \u2208 [\u03d5,\u03c8], i.e., which picks a representative for each equivalence class [\u03d5,\u03c8].\nNow let \u03c1 \u2208 \u0393S,l. Specify \u03b4(\u00b7, \u03c1) as follows:\n1. For the initial state s0, set\n\u03b4(s0, \u03c1) := \u2228 { n\u2227\ni=1\n[\u03b1i] \u2227 m\u2227\ni=1\n[pi] | (\u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1n, p1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pm) \u2208 \u03d1\u03c1(\u0398(\u03c1))}.\nIntuitively, the automaton selects a squid decomposition where its components are instantiated by names occurring in the root node of the input tree. The automaton tries to verify the single compartments of the squid decomposition, i.e., it tries to match them to the chase expansion of the input database under \u03a3.\n2. Let [p] \u2208 S \\ {s0}. We define \u03b4([p], \u03c1) according to a case distinction:\n(a) Suppose that p \u2261 \u22a4. Then \u03b4([p], \u03c1) := true.\n(b) Suppose \u03c7[p] = \u2203y\u0304 (\u03b1(a\u0304, y\u0304) \u2227 \u03d5), where \u03b1(a\u0304, y\u0304) is an atomic formula (including equality), free(\u03d5) \u2286 {y\u0304}, and a\u0304 exhausts all names occuring in \u03b1. If {a\u0304} 6\u2286 names(\u03c1) then \u03b4([p], \u03c1) := false. Otherwise,\n\u03b4([p], \u03c1) := \u2228 {[\u03d5(y\u0304/b\u0304)] | \u03c1 |= \u03b1(a\u0304, b\u0304), {b\u0304} \u2286 names(\u03c1)} \u2228 \u2738[p] \u2228 \u2228 impl(p, \u03c1),\nwhere\nimpl(p, \u03c1) := {[p1] \u2227 \u00b7 \u00b7 \u00b7 \u2227 [pn] | [p1], . . . , [pn] \u2208 S \\ {s0}, {b\u0304} \u2286 names(\u03c1),\np1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 pn \u2261 q,\n\u03a3 |= \u2200x\u0304, y\u0304 (q(a\u0304/x\u0304, b\u0304/y\u0304) \u2192 p(a\u0304/x\u0304))}.\nWe provide some intuitive explanation for this second case.\n(a) If p is the empty query, it can be satisfied at any input node and, hence, the automaton accepts unconditionally on this computation branch.\n(b) Otherwise, we first inspect the strictly guarded formula \u03c7[p] at hand. If the names occurring in the guard \u03b1(a\u0304, y\u0304) are not present at the current node, it rejects. Otherwise, it tries to satisfy \u03b1(a\u0304, y\u0304) with all possible assignments for y\u0304 at the current node and then proceed in state [\u03d5(y\u0304/b\u0304)]. Apart from these possibilities, the automaton can decide to move to any neighboring node (i.e., the parent or a child) while remaining in state [p]. This amounts to an exhaustive search of the input tree that tries to satisfy p in the input tree. Furthermore, the automaton may choose to construct derivation trees for p. There, it uses the information provided by \u03a3 in order to find strictly acyclic queries p1, . . . , pn that imply p. Consequently, it tries to proceed its search with [p1], . . . , [pn].\nWe shall now briefly comment on the running time needed to construct AQ,l. The interesting part of the construction concerns the transition function \u03b4, in particular point 2.(b) involving impl(p, \u03c1). We have seen that in the proofs of Lemma 44 and Lemma 45 that there are double-exponentially many candidates for the query q(a\u0304/x\u0304, b\u0304/y\u0304) that (possibly) implies p(a\u0304/x\u0304) under \u03a3. Furthermore, q(a\u0304/x\u0304, b\u0304/y\u0304) consists of at most exponentially many atoms. Each check whether such a query q at hand implies p requires at most double-exponential time in the size of p. This follows from the well-known fact that checking query implication under a set of guarded rules is feasible in 2ExpTime with respect to the size of the right-hand side query, and in polynomial time with respect to the size of the left-hand side query (cf. [21]), i.e., the data complexity of query answering under guarded tgds is polynomial time."}, {"heading": "PROOFS OF SECTION 6 Proof of Theorem 26", "text": "A proof sketch is given in the main body of the paper. However, the fact that Cont((G,CQ), (S,CQ)) is in 2ExpTime deserves a formal proof. Recall that to establish the latter result we need a more refined complexity analysis of the problem of deciding whether a guarded OMQ is contained in a UCQ; this is discussed in the main body of the paper. In fact, it suffices to show the following result. As in the previous section, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, we assume that tgds have only one atom in the head. Recall that we write var\u22652(q) for the variables of q that appear in more than one atom, and we also write var=1(q) for the variables of q that appear only in one atom. Then:\nProposition 47. Consider Q \u2208 (G,BCQ) and a Boolean CQ q. The problem of deciding whether Q \u2286 q is feasible in\n1. double-exponential time in (||Q||+ |var\u22652(q)|); and\n2. exponential time in |var=1(q)|.\nIt is easy to verify that the above result, together with the algorithm devised in the main body of the paper, implies that Cont((G,CQ), (S,CQ)) is in 2ExpTime. The rest of this section is devoted to show the above proposition. Our crucial task is, given a CQ q, to devise an automaton that accepts consistent labeled trees which correspond to databases that make q true.\nLemma 48. Let q be a Boolean CQ over S. There is a 2WAPA Aq,l, where l > 0, that accepts a consistent \u0393S,l-labeled tree t iff JtK |= q. The number of states of Aq,l is exponential in |var\u22652(q)| and polynomial in (|var=1(q)|+ ar(S)+ l). Furthermore, Aq,l can be constructed in exponential time.\nProof. We are going to construct Aq,l = (S,\u0393S,l, \u03b4, s0,\u2126). Let x1, . . . , xn be the variables of var=1(q) and fix a total order x1 \u227a x2 \u227a \u00b7 \u00b7 \u00b7 \u227a xn among them. Define the state set S to be\nS := {sy,\u03b8 | \u03b8 : V \u2192 US,l, V \u2286 var\u22652(q), y \u2208 var=1(q) \u222a {\u266f}}.\nNotice that |S| = O(|var=1(q)| \u00b7 (ar(S) + l) |var\u22652(q)|). We set s0 := s\u266f,\u2205, where \u2205 denotes the empty substitution. In the following, we treat q as a set of relational atoms and let X = var\u22652(q). For \u03c1 \u2208 \u0393S,l and sy,\u03b8 \u2208 S, define \u03b4(sy,\u03b8, \u03c1) as follows:\n\u2022 If y = \u266f, distinguish the following cases:\n1. If there is an atom \u03b1 \u2208 \u03b8(q) such that var(\u03b1) \u2229X 6= \u2205 and dom(\u03b1) \u2229 US,l 6\u2286 names(\u03c1), then \u03b4(s\u266f,\u03b8, \u03c1) := false.\n2. Otherwise, let\n\u03b4(s\u266f,\u03b8, \u03c1) :=\n{\u2228 {s\u266f,\u03b7 | \u03b7 \u2287 \u03b8, \u03c1 |= \u2203x\u0304 \u2227 (\u03b7(q) \\ \u03b8(q))} \u2228 \u2738s\u266f,\u03b8, if X \u2229 var(\u03b8(q)) 6= \u2205,\nsx1,\u03b8 , otherwise.\n\u2022 Suppose y = xi, for some i = 1, . . . , n. Let \u03b1i,\u03b8 denote the unique atom \u03b1 \u2208 \u03b8(q) such that xi \u2208 var(\u03b1). Set\n\u03b4(sxi,\u03b8, \u03c1) :=\n \n\nsxi+1,\u03b8, if \u03c1 |= \u2203x\u0304 \u03b1i,\u03b8 and i < n,\ntrue, if \u03c1 |= \u2203x\u0304 \u03b1i,\u03b8 and i = n,\n\u2738sxi,\u03b8, otherwise.\nSet the parity condition \u2126 to be \u2126(s) := 1 for all s \u2208 S. Intuitively, the automaton works in two passes. The first pass consists of the runs working on states of the form s\u266f,\u03b8. In this pass, the automaton tries to find an assignment for the variables in the query that appear in at least two distinct atoms. When a candidate assignment \u03b8 is found, the automaton changes to state sx1,\u03b8 which is the beginning of the second pass. A state of the form sxi,\u03b8 means that the assignment \u03b8 can be extended to all variables x \u227a xi and, in this state, the automaton tries to extend \u03b8 to cover the variable xi. The automaton accepts if it is able to extend the candidate assignment \u03b8 to all x1, . . . , xn.\nHaving the above result in place, we can now reduce the problem in question to the emptiness problem for 2WAPA.\nLemma 49. Consider Q \u2208 (G,BCQ) and a Boolean CQ q. We can construct in double-exponential time in ||Q|| and in exponential time in ||q|| a 2WAPA A, which has exponentially many states in (||Q|| + |var\u22652(q)|) and polynomially many states in |var=1(q)|, such that\nQ \u2286 q \u21d0\u21d2 L(A) = \u2205.\nProof. Let Q = (S,\u03a3, q\u2032) and l = ar(S \u222a sch(\u03a3)) \u00b7 |q\u2032|. Then A is defined as:\n(CS,l \u2229 AQ,l) \u2229 Aq,l.\nIt is an easy task to verify that the claim follows from Lemmas 22, 23, 24, and 48.\nIt is clear that Proposition 47 is an easy consequence of Lemma 49."}, {"heading": "PROOFS OF SECTION 7", "text": "Recall that we focus on unary and binary predicates. Moreover, we consider constant-free tgds and CQs, and we assume that tgds have only one atom in the head."}, {"heading": "Proof of Proposition 30", "text": "Basics. Let D be a C-tree of width two. We say that a tree decomposition \u03b4 = (T , (Xt)t\u2208T ) witnessing that D is a C-tree is lean, if it satisfies the following conditions:\n\u2022 The elements from dom(C) occur only in the root of T and its immediate successors.\n\u2022 If w is a child of v in T , then there are unique c, d \u2208 dom(D) such that Xv \u2229Xw = {c} and Xw \\Xv = {d}. The element d is called new at w.\n\u2022 It follows from the previous item that every node v 6= \u03b5 in T has a unique new element c \u2208 dom(D). We additionally require that c appears in the bag of each child of v.\nIntuitively, C-trees D that have lean tree decomposition represent the actual tree structure of D. It is fairly straightforward to see that every C-tree has a lean tree decomposition.\nRecall that the Gaifman graph of D is the graph G(D) = (V, E) with V := dom(D) and (a, b) \u2208 E if a and b coexist in some atom of D. Given two nodes a, b from G(D), the distance from a to b in G(D), denoted dG(D)(a, b), is the minimum length of a path between a and b, and \u221e if such a path does not exist. For a, b \u2208 dom(D), we denote by d\u03b4(a, b) the minimum distance among two nodes of T that respectively have a and b in their bags. We call d\u03b4(a, b) the distance from a to b in \u03b4.\nNotice that in a tree decomposition \u03b4 witnessing that D is a C-tree, any element a \u2208 dom(D), if a appears in the bag of v, then it occurs only at v, at v and its children, or at v and its parent. Since furthermore the bag of the root node is uniquely determined by C, each node in the tree has a uniquely determined set of child nodes whose bags are determined by the structure of D alone. Therefore, the following two lemmas follow immediately.\nLemma 50. Let \u03b4 = (T , (Xt)t\u2208T ) be a lean tree decomposition witnessing that D is a C-tree. Then d\u03b4(a, b) \u2264 dG(D)(a, b) for all a, b \u2208 dom(D).\nLemma 51. Let \u03b4 and \u03b4\u2032 be two lean tree decompositions witnessing that D is a C-tree. Then d\u03b4(a, b) = d\u03b4\u2032(a, b) for all a, b \u2208 dom(D).\nIn the following, we denote byD\u2264k the subinstance of D induced by the set of elements whose distance from any a \u2208 dom(C) in any lean tree decomposition \u03b4 is bounded by k. The subinstance D>k is defined analogously.The branching degree of a lean tree decomposition is the maximum number of child nodes of any node contained in the tree of \u03b4. Notice that two lean tree decompositions of a C-tree D always have the same branching degree; the argument is similar as for the two lemmas above. Hence, we can simply speak about the branching degree of D.\nEncodings. Recall that a consistent \u0393S,l-labeled tree t = (T, \u00b5) encodes information on an S-database D and an appropriate tree decomposition \u03b4 of D. It is clear that JtK has a lean tree decomposition, but it is not guaranteed that this is reflected in \u03b4 as well. We call (the consistent) t lean, if the tree decomposition \u03b4t = (T := (T,E), (Xv)v\u2208T ) is, where xEy iff y = x \u00b7 i for some i \u2208 N \\ {0} and Xv := {[v]a | a \u2208 names(v)}. The following is easy to prove:\nLemma 52. There is a 2WAPA on trees LS,l that accepts a consistent \u0393S,l-labeled tree iff it is lean. The number of states of LS,l is bounded logarithmically in the size of \u0393S,l and LS,l can be constructed in polynomial time in the size of \u0393S,l.\nLet t = (T, \u00b5) be a labeled tree. The branching degree of a node x \u2208 T is the cardinality of {i | x \u00b7 i \u2208 T, i \u2208 N \\ {0}}; the branching degree of t is the maximum over all branching degrees of its nodes and \u221e is this maximum does not exist. We also say that t is m-ary if the branching degree of t is bounded by m. A node x \u2208 T is a leaf node of t if it has branching degree zero. The depth of T is the maximum length among the lengths of all branches and \u221e if this maximum does not exist. Let us remark that the branching degree of the lean \u0393S,l-labeled tree t as defined for labeled trees equals the branching degree of JtK as defined above.\nLemma 53. Let Q = (S,\u03a3, q) be an OMQ from (G2,BCQ). There is an m \u2265 0 such that the following are equivalent:\n1. There is an S-database D such that D |= Q.\n2. There is a C-tree D\u0302 with |dom(C)| \u2264 2|q| and branching degree at most m such that D\u0302 |= Q.\nProof. Let l := 2|q| and, let AQ,l be the 2WAPA from Lemma 24. Take the intersection of AQ,l with (i) the 2WAPA CS,l from Lemma 23 and (ii) the 2WAPA from Lemma 52 that checks leanness. Call the resulting automaton B. Then B accepts a \u0393S,l-labeled tree t iff t is lean and consistent and JtK |= Q. We let m be the number of states of B and claim that this is the required bound on the branching degree.\nFirst of all, notice that the first item of the lemma trivially implies the second independently from the choice of m. For the other direction, suppose that D |= Q for some S-database D. Then there is a C-tree B such that dom(C) \u2264 2|q| and B |= Q. Being a C-tree, B has a lean tree decomposition \u03b4 and the encoding of B together with \u03b4 corresponds to a lean \u0393S,l-labeled tree t. It follows that t \u2208 L(B). By the results of [37], it follows that there is a t\u2032 \u2208 L(B) whose branching degree is bounded by the number of states of B, i.e., by m. The tree t\u2032 is lean and consistent, therefore Jt\u2032K is a C\u2032-tree of branching degree at most m for some C\u2032 \u2286 JtK such that |dom(C\u2032)| \u2264 2|q|. Furthermore, Jt\u2032K |= Q, as required.\nWe are now ready to prove Proposition 30:\nProof of Proposition 30. We largely follow [15] here. Choose m as in Lemma 53 above. Suppose first that Q is UCQ rewritable. Let p := p1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn be a corresponding UCQ rewriting. Since the query q is connected, we can assume that p is as well. We choose k > max{|pi| : i = 1, . . . , n} and suppose that D |= Q for some C-tree D. Since p is a UCQ rewriting, D |= pi for some i = 1, . . . , n. Fix a homomorphism \u00b5 witnessing that D |= pi. We distinguish cases. Suppose first that \u00b5(var(pi)) \u2229 dom(C) 6= \u2205. Since p is connected, it follows D\u2264k |= pi by Lemma 50 and so D\u2264k |= p. On the other hand, if \u00b5(var(p)) \u2229 dom(C) = \u2205, then it is also easy to check that D>0 |= p.\nFor the other direction, suppose that the second item of the proposition\u2019s statement holds, i.e., there is a k \u2265 0 such that for all C-trees D over S with |dom(C)| \u2264 2|q| and branching degree at most m it holds that D |= Q implies D\u2264k |= Q or D>0 |= Q. Let \u039b be the set of all C-trees such that |dom(C)| \u2264 2|q| and that have branching degree at most m such that D |= Q. We regard \u039b as a set of BCQs and regard it as factorized modulo logical equivalence. It is clear that \u039b is finite then and we claim that p :=\n\u2228n i=1 pi is a UCQ rewriting of Q. We explicitly include the case where \u039b is empty, in which case\np is equivalent to the empty disjunction \u22a5 and there is no database D at all such that D |= Q. To see that p is indeed a UCQ rewriting of Q, let D be an S-database such that D |= p. Then there is an i = 1, . . . , n such that D |= pi. Furthermore, [pi] |= Q and so D |= Q as well, since Q is closed under homomorphisms. Suppose now D |= Q. We know that there is a C-tree D\u0302 with |dom(C)| \u2264 l := 2|q| and branching degree at most m such that D\u0302 |= Q and\u2014when we regard D\u0302 as an instance\u2014there is a homomorphism from D\u0302 to D. Let D\u2032 \u2286 D\u0302 be a minimal connected subset of D\u0302 such that D\u2032 |= Q. D\u2032 is again a C\u2032-tree for some C\u2032 \u2286 D\u2032. Therefore D\u2032\u2264k |= Q or D \u2032 >0 |= Q. The latter is impossible by minimality of D\n\u2032. Hence, D\u2032\u2264k |= Q and so there is a (logically equivalent) copy of D \u2032 \u2264k contained in \u039b. Hence, D \u2032 \u2264k |= p, therefore D \u2032 |= p, and hence D\u0302 |= p. Recall that, when D\u0302 is regarded as an instance, there is a homomorphism from D\u0302 toD. Therefore, D |= p."}, {"heading": "Proof of Proposition 31", "text": "Let Q = (S,\u03a3, q) be an OMQ from (G2,BCQ) such that q is connected. We are going to show that the desired 2WAPA A can be constructed in 2ExpTime. Notice that, using similar results as in [15], this gives us a decision procedure for deciding UCQRew(G2,CQ) also for non-connected queries. Let us first introduce some auxiliary notions.\n2WAPAs on m-ary trees. A 2WAPA B on m-ary trees is just defined as a 2WAPA, except that its transitions tran(B) are {\u3008k\u3009s, [k]s | \u22121 \u2264 k \u2264 m, s \u2208 S}, where S is the state set of B. The notion of run is then defined on m-ary trees only and its definition is modified in the obvious way so as to deal with the transitions \u3008k\u3009s, [k]s. Intuitively, for k = 1, . . . ,m, a transition \u3008k\u3009s means that the automaton should move to the k-th child of the current node (which is then required to exist) and assume state s. Correspondingly, [k]s means that the automaton should move to the k-th child and assume state s provided that this k-th child exists at all. We remark that all 2WAPAs constructed in this paper so far can easily be modified to work on m-ary trees as well and we shall assume in the following that they do so. Furthermore, deciding whether L(B) is feasible in exponential time in the number of states of B and in polynomial time in the size of the input alphabet of B (cf. [47]).\nLet m be as in Proposition 30. In the following, we shall regard all trees mentioned in the following as m-ary and let l := 2|q|. Before proceeding to a proof of Proposition 31, we must make the notion of being an \u201cextension\u201d of a labeled tree more precise.\nExtensions of trees. Let BQ be a 2WAPA that accepts a \u0393S,l-labeled tree t iff (i) t is lean and consistent, (ii) JtK |= Q, and (iii) JtK>0 6|= Q. Notice that a 2WAPA A >0 Q that accepts a lean and consistent \u0393S,l-labeled tree iff JtK>0 6|= Q can be easily constructed using the construction in Lemma 24. Hence, BQ can be constructed intersecting several 2WAPAs we have already encountered.\nLet \u03a0 be the set of all tuples of the form (s, s\u2032), where s and s\u2032 are states of BQ. We define a new alphabet \u039b := 2 KS,l\u222a\u03a0. Notice that \u039b is of double-exponential size in the size of Q. For \u03c1 \u2208 \u039b, we denote by \u03c1 \u21be \u0393S,l the restriction of \u03c1 to \u0393S,l, that is, \u03c1\u2229KS,l. The restriction of a \u039b-labeled tree t to \u0393S,l, denoted t \u21be \u0393S,l, is the tree that arises from t when we restrict the label of each node of t to \u0393S,l. We say that a \u039b-labeled tree is consistent if (i) its restriction to \u0393S,l is consistent and (ii) symbols \u03c1 \u2208 \u039b such that \u03c1 \u2229 \u03a0 6= \u2205 appear only in leaf nodes of t. Likewise, we say that a consistent t is lean if t \u21be \u0393S,l is. The decoding JtK of t is naturally extended to consistent \u039b-labeled trees by setting JtK := Jt \u21be \u0393S,lK. The following lemma is a straightforward extension of Lemmas 23 and 52.\nLemma 54. There are 2WAPAs C\u039b and L\u039b that respectively accept a \u039b-labeled tree iff it is consistent and lean. Both have logarithmically many states in the size of \u039b and can be constructed in polynomial time in the size of \u039b.\nLet t be a lean and consistent \u039b-labeled tree. We say that t\u2032 is an extension of t if t\u2032 is a \u0393S,l-labeled tree that arises from t by attaching \u0393S,l-labeled trees to those leaves of t that contain elements from \u03a0. Furthermore, for such nodes, the labels of the corresponding nodes in t\u2032 are those of t restricted to \u0393S,l.\nDefinition 14. Let LQ be the set of all lean and consistent \u039b-labeled trees t such that JtK 6|= Q, yet there is an extension t \u2032\nof t such that Jt\u2032K |= Q and Jt\u2032K>0 6|= Q.\nLemma 55. LQ is infinite iff Q is not UCQ rewritable.\nProof. Suppose LQ is infinite. Since the trees at hand have bounded branching degree, for every k \u2265 0, there is a t \u2208 LQ such that JtK is a C-tree (for some C \u2286 JtK) that contains individuals whose distance from any a \u2208 dom(C) is greater than or equal to k and JtK 6|= Q, yet for some extension t\u2032 of t, we have Jt\u2032K |= Q but Jt\u2032K>0 6|= Q. Suppose now that Q is UCQ rewritable. Let \u2113 be such that for all C\u2032-trees D (of the appropriate dimensions), D |= Q implies D\u2264\u2113 |= Q or D>0 |= Q. Choose k > \u2113 and t, t\u2032 such that (i) t\u2032 is an extension of t, (ii) t has depth greater than k, and (iii) JtK 6|= Q but Jt\u2032K |= Q and Jt\u2032K>0 6|= Q. Since Jt \u2032K |= Q, we know that Jt\u2032K\u2264\u2113 |= Q or Jt \u2032K>0 |= Q. The latter is impossible by assumption, the former contradicts the fact JtK 6|= Q, since k > \u2113. This proves the direction from left to right. The other direction is immediate.\nWe are now ready to establish Proposition 31:\nProof of Proposition 31. We are now going to describe the construction of a 2WAPA A such that L(A) = LQ, which will prove the claim by virtue of Lemma 55. This automaton is the intersection of several ones. First of all, we ensure that all the accepted \u039b-trees are lean and consistent (cf. Lemma 54). We additionally intersect the automaton with the complement of AQ,l from Lemma 23 (more precisely, the version of it running on \u039b-labeled trees) and another automaton DQ = (S,\u039b, \u03b4, s0,\u2126) whose construction we shall describe in more detail here. On a high level, DQ will be constructed so as to accept a lean and consistent \u039b-labeled tree if and only if there is an extension t\u2032 of t such that BQ accepts t \u2032. Let S\u0302 be the set of states of BQ, \u03b4\u0302 its transition function, and \u2126\u0302 its parity function. For \u03c3 \u2208 \u0393S,l, let B\u0302(\u03c3) be the set of tuples (s, s \u2032) \u2208 S\u0302 \u00d7 (S\u0302 \u222a {true}) such that the following holds:\n\u2022 There is a \u0393S,l-labeled tree t = (T, \u03b7) such that \u03b7(\u03b5) = \u03c3 and a run tr = (Tr, \u03b7r) of BQ on t such that\n1. \u03b7r(\u03b5) = (\u03b5, s), i.e., tr starts from s; 12\n12Strictly speaking, tr is, of course, not a run since it does not start in the initial state.\n2. s\u2032 = true and tr is accepting on BQ, or there is a node v \u2208 Tr such that \u03b7r(v) = (\u03b5, s \u2032).\nNow the set of states of DQ is the same as of BQ, i.e., S := S\u0302. Accordingly, the initial state of DQ is that of BQ. Furthermore \u2126(s) := \u2126\u0302(s), for every s \u2208 S. Given s \u2208 S and \u03c1 \u2208 \u039b, we let\n\u03b4(s, \u03c1) := \u2228 {s\u2032 | (s, s\u2032) \u2208 \u03c1 \u2229 B\u0302(\u0393S,l \u21be \u03c1)} \u2228 \u03b4\u0302(s,\u0393S,l \u21be \u03c1).\nWe are going to give an intuitive explanation of this construction in the following. Roughly, a pair (s, s\u2032) \u2208 B\u0302(\u03c3) indicates that there is a \u0393S,l-labeled tree t and run of BQ on t such that the root of t is labeled with \u03c3, the run starts in state s, and either BQ accepts t, or it traverses the root again at some point, then being in state s \u2032. The set B\u0302(\u03c3) can be computed a priori in 2ExpTime; considering that \u0393S,l is of double-exponential size in the size of Q, it follows that the collection {B\u0302(\u03c3)}\u03c3\u2208\u0393S,l can be computed in 2ExpTime. Now the input tree for DQ comes with labels from \u03a0 of the form (s, s\u2032) in its leaves. These \u201ctypes\u201d amount to guesses of possible extensions of the input tree. Utilizing the sets B\u0302(\u03c3), DQ thus explores the possible ways how the given input tree can be extended to a \u0393S,l-labeled tree t \u2032 that is accepted byBQ."}, {"heading": "9. REFERENCES", "text": "[1] A. Amarilli, M. Benedikt, P. Bourhis, and M. Vanden Boom. Query answering with transitive and linear-ordered data.\nIn IJCAI, pages 893\u2013899, 2016.\n[2] T. J. Ameloot, B. Ketsman, F. Neven, and D. Zinn. Weaker forms of monotonicity for declarative networking: A more fine-grained answer to the calm-conjecture. In PODS, pages 64\u201375, 2014.\n[3] T. J. Ameloot, B. Ketsman, F. Neven, and D. Zinn. Datalog queries distributing over components. In ICDT, pages 308\u2013323, 2015.\n[4] T. J. Ameloot, F. Neven, and J. V. den Bussche. Relational transducers for declarative networking. J. ACM, 60(2):15, 2013.\n[5] M. Arenas, R. Hull, W. Martens, T. Milo, and T. Schwentick. Foundations of Data Management (Dagstuhl perspectives workshop 16151). Dagstuhl Reports, 6(4):39\u201356, 2016.\n[6] F. Baader, M. Bienvenu, C. Lutz, and F. Wolter. Query and predicate emptiness in ontology-based data access. J. Artif. Intell. Res. (JAIR), 56:1\u201359, 2016.\n[7] J.-F. Baget, M. Lecle\u0300re, M.-L. Mugnier, and E. Salvat. On rules with existential variables: Walking the decidability line. Artif. Intell., 175(9-10):1620\u20131654, 2011.\n[8] V. Ba\u0301ra\u0301ny, M. Benedikt, and B. ten Cate. Rewriting guarded negation queries. In MFCS, pages 98\u2013110, 2013.\n[9] V. Ba\u0301ra\u0301ny, G. Gottlob, and M. Otto. Querying the guarded fragment. Logical Methods in Computer Science, 10(2), 2014.\n[10] P. Barcelo\u0301, G. Berger, and A. Pieris. Containment for rule-based ontology-mediated queries. 2017.\n[11] C. Beeri and M. Y. Vardi. The implication problem for data dependencies. In ICALP, pages 73\u201385, 1981.\n[12] M. Benedikt, P. Bourhis, and M. Vanden Boom. A step up in expressiveness of decidable fixpoint logics. In LICS, pages 817\u2013826, 2016.\n[13] M. Benedikt and G. Gottlob. The impact of virtual views on containment. PVLDB, 3(1):297\u2013308, 2010.\n[14] G. Berger and A. Pieris. Ontology-mediated queries distributing over components. In IJCAI, pages 943\u2013949, 2016.\n[15] M. Bienvenu, P. Hansen, C. Lutz, and F. Wolter. First order-rewritability and containment of conjunctive queries in horn description logics. In IJCAI, pages 965\u2013971, 2016.\n[16] M. Bienvenu, C. Lutz, and F. Wolter. Query containment in description logics reconsidered. In KR, 2012.\n[17] M. Bienvenu, C. Lutz, and F. Wolter. First-order rewritability of atomic queries in horn description logics. In IJCAI, pages 754\u2013760, 2013.\n[18] M. Bienvenu, B. ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: a study through disjunctive datalog, csp, and MMSNP. In PODS, pages 213\u2013224, 2013.\n[19] P. Bourhis, M. Kro\u0308tzsch, and S. Rudolph. Reasonable highly expressive query languages. In IJCAI, pages 2826\u20132832, 2015.\n[20] P. Bourhis, M. Manna, M. Morak, and A. Pieris. Guarded-based disjunctive tuple-generating dependencies. ACM Trans. Database Syst., 41(4), 2016.\n[21] A. Cal\u0300\u0131, G. Gottlob, and M. Kifer. Taming the infinite chase: Query answering under expressive relational constraints. In KR, pages 70\u201380, 2008.\n[22] A. Cal\u0300\u0131, G. Gottlob, and M. Kifer. Taming the infinite chase: Query answering under expressive relational constraints. J. Artif. Intell. Res., 48:115\u2013174, 2013.\n[23] A. Cal\u0300\u0131, G. Gottlob, and T. Lukasiewicz. A general Datalog-based framework for tractable query answering over ontologies. J. Web Sem., 14:57\u201383, 2012.\n[24] A. Cal\u0300\u0131, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artif. Intell., 193:87\u2013128, 2012.\n[25] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. Autom. Reasoning, 39(3):385\u2013429, 2007.\n[26] A. K. Chandra and P. M. Merlin. Optimal implementation of conjunctive queries in relational data bases. In STOC, pages 77\u201390, 1977.\n[27] S. Chaudhuri and M. Y. Vardi. On the equivalence of recursive and nonrecursive datalog programs. J. Comput. Syst. Sci., 54(1):61\u201378, 1997.\n[28] S. S. Cosmadakis, H. Gaifman, P. C. Kanellakis, and M. Y. Vardi. Decidable optimization problems for database logic programs (preliminary report). In STOC, pages 477\u2013490, 1988.\n[29] E. Dantsin and A. Voronkov. Complexity of query answering in logic databases with complex values. In LFCS, pages 56\u201366, 1997.\n[30] T. Eiter, T. Lukasiewicz, and L. Predoiu. Generalized consistent query answering under existential rules. In KR, pages 359\u2013368, 2016.\n[31] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data exchange: Semantics and query answering. Theor. Comput. Sci., 336(1):89\u2013124, 2005.\n[32] J. Flum, M. Frick, and M. Grohe. Query evaluation via tree-decompositions. J. ACM, 49(6):716\u2013752, 2002.\n[33] G. Gottlob, G. Orsi, and A. Pieris. Query rewriting and optimization for ontological databases. ACM Trans. Database Syst., 39(3):25:1\u201325:46, 2014.\n[34] G. Gottlob and C. H. Papadimitriou. On the complexity of single-rule datalog queries. Inf. Comput., 183(1):104\u2013122, 2003.\n[35] G. Gottlob, A. Pieris, and M. Simkus. The impact of active domain predicates on guarded existential rules. In RR, pages 94\u2013110, 2016.\n[36] G. Gottlob, S. Rudolph, and M. Simkus. Expressiveness of guarded existential rule languages. In PODS, pages 27\u201338, 2014.\n[37] E. Gra\u0308del and I. Walukiewicz. Guarded fixed point logic. In LICS, pages 45\u201354, 1999.\n[38] D. S. Johnson. A catalog of complexity classes. In Handbook of Theoretical Computer Science, pages 67\u2013161. 1990.\n[39] D. S. Johnson and A. C. Klug. Testing containment of conjunctive queries under functional and inclusion dependencies. J. Comput. Syst. Sci., 28(1):167\u2013189, 1984.\n[40] T. Lukasiewicz, M. V. Martinez, A. Pieris, and G. I. Simari. From classical to consistent query answering under existential rules. In AAAI, pages 1546\u20131552, 2015.\n[41] D. Maier, A. O. Mendelzon, and Y. Sagiv. Testing implications of data dependencies. ACM Trans. Database Syst., 4(4):455\u2013469, 1979.\n[42] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. J. Data Semantics, 10:133\u2013173, 2008.\n[43] B. Rossman. Homomorphism preservation theorems. J. ACM, 55(3), 2008.\n[44] Y. Sagiv and M. Yannakakis. Equivalences among relational expressions with the union and difference operators. J. ACM, 27(4):633\u2013655, 1980.\n[45] O. Shmueli. Equivalence of DATALOG queries is undecidable. J. Log. Program., 15(3):231\u2013241, 1993.\n[46] M. Y. Vardi. Automata theory for database theoreticans. In Theoretical Studies in Computer Science, pages 153\u2013180, 1992.\n[47] M. Y. Vardi. Reasoning about the past with two-way automata. In ICALP, pages 628\u2013641, 1998.\n[48] T. Wilke. Alternating tree automata, parity games, and modal \u00b5-calculus. Bull. Belg. Math. Soc. Simon Stevin, 8(2):359\u2013391, 2001."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Many efforts have been dedicated to identify restrictions<lb>on ontologies expressed as tuple-generating dependencies<lb>(tgds), a.k.a. existential rules, that lead to the decidabil-<lb>ity for the problem of answering ontology-mediated queries<lb>(OMQs). This has given rise to three families of formalisms:<lb>guarded, non-recursive, and sticky sets of tgds. In this work,<lb>we study the containment problem for OMQs expressed in<lb>such formalisms, which is a key ingredient for solving static<lb>analysis tasks associated with them. Our main contribu-<lb>tion is the development of specially tailored techniques for<lb>OMQ containment under the classes of tgds stated above.<lb>This enables us to obtain sharp complexity bounds for the<lb>problems at hand.<lb>We start with OMQs based on linear (a core fragment<lb>of guarded tgds), non-recursive and sticky sets of tgds,<lb>which share the property of UCQ rewritability. By exploit-<lb>ing this property, we obtain a small witness property for<lb>non-containment that allows us to devise standard \u201cguess-<lb>and-check\u201d algorithms. Based on this, we prove that OMQ<lb>containment for linear tgds is PSpace-complete, but<lb>\u03a02 -<lb>complete if the arity of the schema is fixed, while for sticky<lb>sets of tgds it is coNExpTime-complete, and<lb>\u03a02 -complete<lb>in the case of fixed arity. For non-recursive sets of tgds, the<lb>problem is in ExpSpace and P-hard even for fixed-arity<lb>schemas. Hence, in all the cases the containment problem<lb>is harder (under widely accepted complexity assumptions)<lb>than query evaluation, with the exception of linear tgds<lb>over schemas of unbounded arity, where both problems are<lb>complete for PSpace. For OMQs based on guarded tgds,<lb>which are not UCQ rewritable in general, we establish a<lb>tree witness property, and use it in combination with tree<lb>automata techniques to prove that OMQ containment has<lb>the same complexity as query evaluation, i.e., 2ExpTime-<lb>complete. Unlike query evaluation, though, OMQ contain-<lb>ment for guarded tgds remains 2ExpTime-hard over fixed-<lb>arity schemas. Lastly, we apply our techniques to pinpoint<lb>the complexity of problems associated with two emerging<lb>applications of OMQ containment: distribution over com-<lb>ponents and UCQ rewritability of OMQs.", "creator": "LaTeX with hyperref package"}}}