{"id": "1705.04712", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-May-2017", "title": "Progression of Decomposed Local-Effect Action Theories", "abstract": "in many tasks related to reasoning about consequences of a logical theory, it is optimal to decompose the theory surrounding a number of weakly - related or unstable components. however, a theory may represent knowledge that is subject to change, changing a result whilst executing beliefs that have effects on some object whatever initial properties mentioned in the theory. having once computed a decomposition of structural theory, it is advantageous - know whether a decomposition has to be computed again in the newly - changed theory ( obtained from taking into account changes resulting from execution of an action ). addressing the paper, we address this problem in special scope of the situation calculus, where a problem that an initial theory is related to the notion of progression. progression provides a form of forward reasoning ; it looks on evolving values of those properties, which are subject to change, inadvertently building new values for them. we consider decomposability and inseparability, two component properties known from historical literature, only contribute by 1 ) studying the similarities when these properties are preserved and ( ) when they are true wrt progression undergoes the related operation of forgetting. to show the latter, arguments demonstrate certain boundaries using a number of negative examples. to show the former, we identify cases when these properties are consistent under forgetting and progression of initial theories in local - effect basic action theories of the situation calculus. our paper contributes to bridging two different communities describing knowledge representation, namely research on modularity is research on reasoning about actions.", "histories": [["v1", "Fri, 12 May 2017 18:36:21 GMT  (56kb)", "http://arxiv.org/abs/1705.04712v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["denis ponomaryov", "mikhail soutchanski"], "accepted": false, "id": "1705.04712"}, "pdf": {"name": "1705.04712.pdf", "metadata": {"source": "CRF", "title": "Progression of Decomposed Local-Effect Action Theories", "authors": ["Denis Ponomaryov", "Mikhail Soutchanski"], "emails": ["ponom@iis.nsk.su,", "mes@scs.ryerson.ca"], "sections": [{"heading": null, "text": "ar X\niv :1\n70 5.\n04 71\n2v 1\n[ cs\n.A I]\n1 2\nM ay"}, {"heading": "1 Introduction", "text": "Modularity of theories has been established as an important research topic in knowledge representation. It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few. Surprisingly, this research topic is little explored in the context of reasoning about actions. More specifically, it is natural to decompose a large heterogeneous theory covering several loosely-coupled application domains into components that have little or no intersection in terms of signatures. Potentially, such decomposition can facilitate solving the projection problem, which requires answering whether a given logical formula is true after executing a sequence of actions (events). In cases, when a query is a logical formula composed from symbols occurring in only one of the components, the query can be answered more easily than in the case when the whole theory is required. This decomposition can help in solving other reasoning problems (e.g. planning or high-level program execution) that require a solution to the projection problem as a prerequisite. To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2]. These papers investigate decomposition in the situation calculus\n[34,43], a well-known logical formalism for representation of actions and their effects. The author proposed reasoning procedures for a situation calculus theory by dividing the whole theory syntactically into weakly-related partitions. Specifically, he developed algorithms that use local computation inside syntactically-identified partitions and message passing between partitions. We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only. Our components are not necessarily syntactic subsets of the initial theory. We concentrate on foundations, and explore properties of components produced by our decomposition. Whenever possible, we try to formulate these properties in a general logical language L, that is a fragment of second order logic; however, when necessary, we focus on a specific logic.\nThis paper considers the decomposability and inseparability properties of logical theories. These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus. Both properties are concerned with subdividing theories into components to facilitate reasoning. Informally, decomposability of a theory means that the theory can be equivalently represented as a union of two (or several) theories sharing a given set (\u2206) of signature symbols. Inseparability of theories wrt some signature\u2206 means that the theories have the same set of logical consequences in the signature\u2206. If a theory (T ) is\u2206\u2013decomposable into\u2206\u2013inseparable components, then (under certain restrictions on the underlying logic) each component of the decomposition contains all information from T in its own signature. This is an ideal case of decomposition, since in this case the problem of entailment from T can be reduced to entailment from components, which are potentially smaller than the theory T .\nIn the area of reasoning about actions, an initial logical theory represents knowledge that is subject to change due to the effects of actions on some of the properties mentioned in the theory. It can be updated with new information caused by actions, while some other knowledge should be forgotten, as it is no longer true in the next situation. We consider two types of update operators: 1) forgetting in arbitrary theories and 2) progression of theories in the situation calculus. Forgetting is a well-known operation on theories first introduced by Fangzhen Lin and Ray Reiter in their seminal paper [25]. Forgetting a signature \u03c3 in a theory T means obtaining a theory indistinguishable from T in the rest of the signature symbols sig (T )\\\u03c3. In this sense, forgetting a signature is close to the well-known notion of uniform interpolation. Forgetting a ground atom P (t\u0304) in a theory T results in a theory that implies all the consequences of T \u201cmodulo\u201d the truth value of P (t\u0304). The operation of forgetting is closely related to progression in basic action theories in the situation calculus.\nThe situation calculus [43] is a knowledge representation logical formalism, which has been designed for axiomatization of problems in planning and high-level program execution. The idea is to 1) axiomatize a set of initial states (as an initial theory), 2) axiomatize preconditions telling when actions can be performed, and then 3) add the axioms about the effects of actions on situationdependent properties. After these steps, one can reason about the consequences of sequences of actions to determine whether properties of interest hold in a given situation resulting from executing a sequence of actions and whether a certain sequence of actions is consecutively executable. In the situation calculus, the so-called basic action theories represent such axiomatizations [43]. Each basic action theory contains an initial theory that represents incomplete knowledge about an initial situation S0. In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8]. Roughly, a basic action theory D is a union of an initial theory DS0 with some theory T , defining\ntransitions among situations, and a set of \u201ccanonical\u201d axioms assumed to be true for all application problems represented in the situation calculus. Informally speaking, an update of the initial theory after execution of an action is called \u201cprogression of the initial theory wrt an action\u201d. More precisely, progression of DS0 wrt some action \u03b1 is a logical consequence of D which contains all information from D about the situation resulting from the execution of \u03b1 in the situation S0. Ideally, it is computed as updating DS0 with some logical consequences of T , once all information in DS0 , which is no longer true in the resulting situation, has been forgotten. Progression is important for practical agents with indefinite horizon since progression is the only feasible way of maintaining knowledge about the world. Exploiting modularity in the vast agent\u2019s knowledge is important to guarantee that progression of the agent\u2019s knowledge will be computationally feasible.\nHistorically, the \u201csituation calculus\u201d (earlier referred to as \u201csituational logic\u201d) is the earliest logical framework developed in the area of artificial intelligence (AI). Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI. It is worth mentioning that there are both conceptual and technical differences between the situation calculus, designed for reasoning about arbitrary actions, and the Floyd\u2013Hoare logic, Dijkstra\u2019s predicate transformers, and dynamic logic, and other related formalisms, which have been developed for reasoning about the correctness of computer programs. For example, the latter category of formalisms would consider the operator assigning a new value to a variable in a program as a primitive action, while the former would consider as primitive the actions on higher level of abstraction, such as moving a book from its current location to the table. For this reason, the situation calculus is chosen as foundation for high-level programming languages in cognitive robotics [22]. In our paper, when we refer to the \u201csituation calculus\u201d, we are following the axiomatic approach and notation proposed by R.Reiter [43] who developed a general approach to axiomatizing direct effects and non-effects of actions. It has been observed for a long time that in practical applications, real-world actions have no effect on most properties. However, it was Reiter who first proposed an elegant axiomatization that represents compactly non-effects of actions. Reiter\u2019s book covers several extensions of the situation calculus to reasoning about concurrent actions, instantaneous actions, processes extended in time, interaction between action and knowledge, stochastic actions, as well as high-level programming languages based on the situation calculus. In our paper, we will focus on the cases of situation calculus when actions are sequential, atemporal, and deterministic. Despite this focus, our results can be subsequently adapted to characterize more general classes of actions. The main limitation of our work is in concentrating on direct effects only. Indirect effects of actions are beyond the scope of the present study and will be considered in future work.\nIn this paper, we are interested in the case when the initial theory is decomposed into inseparable components, studying which conditions guarantee preservation of decomposability and inseparability of components after forgetting or progression. We would like to avoid recomputing a decomposition of an updated initial theory after executing an action. Moreover, we would like to know whether the components remain inseparable after progression. Such invariance of decomposability and inseparability wrt progression is important since progression may continue indefinitely as long as new actions are being executed. If decomposability and inseparability are always preserved, then it would suffice to compute a decomposition of the initial theory once \u2013 this decomposition will remain \u201cstable\" after progression wrt any arbitrary sequence of actions. Additionally, if an executed action has effects only on one component of the initial theory, then we would like to be able to compute progression using only this part instead of the whole initial theory. This leads to the question of\nwhen the decomposability and inseparability properties are preserved under progression and under forgetting. To answer this question we have to better understand the properties of these two operations. In our study, for brevity, when we refer to \u201cdecomposability\u201d and \u201cinseparability\u201d properties of components, we will use the phrase component properties.\nThis paper contributes to the general understanding of forgetting and progression in the literature, since new results on them are needed for the purposes of our investigation.Not surprisingly, both forgetting and progression have intricate interactions with properties of decomposed components. We will demonstrate that, in general, it is very difficult to guarantee the preservation of decomposability and inseparability, because there is a certain conceptual distance between these notions on one hand, and forgetting and progression on the other \u2013 we provide examples witnessing this. Nevertheless, we will identify cases when these properties remain invariant. Our results show that some of these cases have a practically important formulation. An important contribution of the paper is in formulating clear negative examples that demonstrate cases when decomposability and inseparability are lost under progression. Thus, the paper contributes to understanding the limits of the component approach based on these properties. In particular, our examples demonstrate that there is little hope to preserve inseparability if the different components share a fluent. Decomposability turns out to be also a fragile property that can be easily lost after executing just one action in a simple basic action theory. Overall, this paper contributes by advancing the study of forgetting and progression, and also by carrying out a thorough and comprehensive study of when decomposability and inseparability are preserved and when they are lost.\nWe start in Section 2 by introducing basic notations and then provide a survey on decomposability and inseparability, the two component properties of theories considered in this paper. Then in Section 3 we introduce the basics of the situation calculus, proceeding to the component properties of forgetting in Section 3 and progression in Section 4. The last section, Section 5, includes a summary of the obtained results. A preliminary shorter version of this paper (without proofs) appeared in the proceedings of AAAI-13 conference [40]. This extended version of our paper includes new results not mentioned in the conference version as well as proofs and a detailed backgroundmaterial and discussion of previously published results about forgetting and progression, in order to make this paper self-contained."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 Conventions and Notations", "text": "Let L be a logic (possibly many-sorted), which is a fragment (a set of sentences) of second-order logic (either by syntax or by translation of formulas), and has the standard model-theoretic Tarskian semantics. We call the signature a subset of non-logical symbols of L (and treat equality as a logical symbol). If M1 and M2 are two many\u2013sorted structures and \u2206 is a signature then we say that M1 and M2 agree on \u2206 if they have the same domains for each sort and the same interpretation of every symbol from\u2206. If M is a structure and \u03c3 is a subset of predicate and function symbols from M, then we denote by M|\u03c3 the reduct of M to \u03c3, i.e., the structure with predicate and function names from \u03c3, where every symbol of \u03c3 names the same entity as in M. The structure M is called expansion of M|\u03c3 . For a set of formulas T in L, we denote by sig (T ) the signature of T , i.e. the set of all non-logical symbols which occur in T . We will use the same notation sig (\u03d5) for the signature of a formula \u03d5 in L. If t is a term in the logic L then the same notation sig (t) will be used for the set of all non-logical symbols occurring in t. Throughout this paper, we use the notion\nof theory as a synonym for a set of formulas in L, which are sentences when translated into secondorder logic. Whenever we mention a set of formulas, it is assumed that this set is in L, if the context is not specified. For two theories, T1 and T2, the notation T1 \u2261 T2 will be the abbreviation for the semantic equivalence. If T is a set of formulas in L and \u2206 is a signature, then Cons (T , \u2206) will denote the set of semantic consequences of T (in L) in the signature \u2206, i.e. Cons (T , \u2206) = {\u03d5 \u2208 L | T |= \u03d5 and sig (\u03d5) \u2286 \u2206}. We emphasize that this is a notation for a set of formulas in L, because T may semantically entail formulas that are outside of L."}, {"heading": "2.2 Basic Facts about Decomposability and Inseparability", "text": "In the area of theory modularization, a module (or component) is usually understood as a set of theory consequences that satisfy certain properties. The latter are determined by requirements to a module in the context of application. Some approaches follow the idea that a module should be a syntactic subset of the axioms of a given theory. For instance, a theory can be partitioned into subsets of axioms meeting certain requirements of balance among the partition. Thereafter, reasoning wrt the initial theory can be reduced to reasoning within the obtained components via a message passing algorithm, which communicates between the partitions to find information needed to answer a query [3]. As a rule, the information to be communicated relates to the signatures shared between the partitions. The advantage of this approach is that the partitioning algorithm can be relatively simple and rely on syntactic analysis of theory axioms, thereby circumventing semantics. On the other hand, it may not be possible to eliminate some dependences between the partitions, if they are induced by syntactic form of the axioms. For instance, if a theory T consists of the axioms {\u2200x P (x), \u2200x (P (x) \u2194 Q(x))}, then it may not be possible to infer that it can be represented as the union of two components {\u2200xP (x)} and {\u2200xQ(x)}, which do not share any signature symbols. In other words, a theory with syntactic dependencies may have an axiomatization that yields a partitioning into components, which either do not have symbols in common, or in a more general case, share a fixed signature (given as a parameter of decomposition).\nIn our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].\nDefinition 2.1 (\u2206\u2013decomposability property) Let T be a theory in L and\u2206 \u2286 sig (T ) a subsignature. We call T \u2206\u2013decomposable, if there are theories T1 and T2 in L such that\n\u2013 sig (T1) \u2229 sig (T2) = \u2206, but sig (T1) 6= \u2206 6= sig (T2); \u2013 sig (T1) \u222a sig (T2) = sig (T ); \u2013 T \u2261 T1 \u222a T2.\nThe pair \u3008T1, T2\u3009 is called \u2206\u2013decomposition of T and the theories T1 and T2 are called \u2206\u2013 decomposition components of T . We will sometimes omit the word \u201cdecomposition\" and call the sets T1 and T2 simply components of T , when the signature \u2206 is clear from the context. The sets sig (T1) \\\u2206 and sig (T2) \\\u2206 are called signature (\u2206\u2013decomposition) components of T .\nThe notion of\u2206\u2013decomposition is defined using a pair of theories, but it can be easily extended to the case of a family of theories. It is important to realize that T1 and T2 are not necessarily subsets of axioms of T in the above definition. We only require that T \u2261 T1 \u222a T2. Clearly, if L satisfies compactness and T is a finite \u2206\u2013decomposable theory in L for a signature \u2206, then there is a \u2206\u2013 decomposition \u3008T1, T2\u3009 of T , where T1 and T2 are finite.\nNote that the axioms of theory T given beforeDefinition 2.1 can not be (syntactically) partitioned into subsets having no signature symbols in common. However T has a different axiomatization given by \u2200xP (x) and \u2200xQ(x) and hence, is \u2205-decomposable. Thus, in general \u2206-decomposition can be finer than a syntactic partitioning based on a particular axiomatization of a theory.\nAccording to the definition of decomposability, computing a decomposition means finding another (equivalent) representation of a theory, which defines the required components. This means that a decomposition procedure must employ logical reasoning. Therefore, potentially it is more computationally complex than syntactic partitioning, which splits a theory into syntactic subsets of axioms. However, the research on algorithmic properties of decomposability (see e.g., [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic. Studying the complexity of decomposability in different logics is an ongoing research topic. An algorithm for computing decomposition components can be obtained, e.g., from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-\u2206-symbols from the axioms of a theory. The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics. Using any form of equivalent rewriting means that the obtained axiomatization may be of a size larger than the set of axioms of the original theory. In particular, finding a decomposition may imply computing explicit definitions, in which case the size of the components depends on the complexity of such definitions in the underlying logic. For instance, a decomposition component may be of size exponentially larger than the original theory, which is evidenced by Example 28 in [17]. It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.g. [44]). On the other hand, one can take control over the growth of the component sizes by carefully choosing which signature \u2206 can be shared between the components. Using Example 28 from [17], for instance, it possible to describe a situation when tuning up \u2206 can exponentially reduce the component sizes. In general however, this question motivates research on the succinctness of explicit definitions and uniform interpolants in different logics.\nAn important requirement often considered in the literature is that a module must contain all information about a signature of interest\u2206, which is typically a subset of the signature of the module. In other words, it is required that a module must entail the same consequences in signature \u2206, as the source theory. Having fixed a signature \u2206, the ability to see differences between two theories strongly depends on the logic being used as \u201clens\u201d for their examination: the more expressive power the logic employed has, the more differences it is possible to see. Probably the most powerful tool in measuring similarity of theories is the language of second-order logic. If two theories have the same sets of second-order consequences in a signature\u2206, then the classes of reducts of their models onto \u2206 coincide, i.e. both theories \u201cdefine\u201d the same semantics for \u2206-symbols. Keeping in mind that a module is usually understood as a set of consequences of a source theory, it is important to note the following model-theoretic fact, which will be helpful for grasping the results of this paper. It says that if a logic L is weaker than second-order, then in general, a set of consequences of a theory T in L may not be able to capture the intended semantics of symbols from a subsignature \u2206, as defined by T .\nFact 2.2 If T is a theory in L and \u2206 a signature, then some models of Cons (T , \u2206) may not have an expansion to a model of T .\nIndeed, let L be first-order logic and {P, f} be a signature, where P is a unary predicate and f is a unary function. Let T be a theory saying that f is a bijection between the interpretation of"}, {"heading": "P and its complement. Thus, T axiomatizes the class of models, where the interpretation of P and its complement are of the same cardinality. Let M be a model from this class and let N be a model", "text": "of the same signature {P} in which the interpretation of P is a countable set, but the complement is uncountable. The modelsM and N are elementary equivalent, i.e., no formula in signature {P} can distinguish between these two models. For instance, this can be shown by using the fact (e.g., see [10]) that every sentence in signature {P} is equivalent to a boolean combination of formulas \u2203>mP and \u2203>m\u00acP , where an integerm > 0, which mean \u201cP (respectively, \u00acP ) holds on at least m distinct elements\u201d. Therefore,N is a model of Cons (T , {P}), but clearly, it has no expansion to a model of T .\nAs will be noted in Section 3, forgetting is an operation, which gives a set of (second-order) consequences axiomatizing the same class of models, as the original theory, modulo forgotten signature/ground atom.\nIt is known that in general, a set of consequences of a theory may not be finitely axiomatizable in the logic, in which the theory is formulated. For instance, the following example is widely known in the literature on Description Logics (e.g., see Section 3.2 in [31]).\nFact 2.3 If T is a theory inL and\u2206 a signature, then Cons (T , \u2206)may not be finitely axiomatizable in L.\nLet T be the first-order theory axiomatized by the following two axioms: \u2200x [A(x) \u2192 B(x) ] \u2200x [B(x) \u2192 \u2203y(R(x, y) \u2227B(y)) ]\nConsider the signature \u2206 = {A,R}. Then it is not hard to verify that Cons (T , \u2206) is equivalent to the following infinite set of formulas:\n\u2200xA(x) \u2192 \u2203yR(x, y) \u2200xA(x) \u2192 \u2203y\u2203u[R(x, y) \u2227R(y, u) ] \u2200xA(x) \u2192 \u2203y\u2203u\u2203v[R(x, y) \u2227R(y, u) \u2227R(u, v) ] ..."}, {"heading": "By compactness, this theory is not finitely axiomatizable in first-order logic.", "text": "A well-known concept used to characterize similarity of two theories wrt a signature is inseparability. This notion has also appeared in the context of entailment in Description Logics, e.g., see [18,32].\nDefinition 2.4 (\u2206\u2013inseparability) Theories T1 and T2 in L are called \u2206\u2013inseparable, for a signature \u2206, if Cons (T1, \u2206) = Cons (T2, \u2206).\nIn other words, T1 and T2 are \u2206\u2013inseparable if for any L-formula \u03c8 in signature \u2206, T1 entails \u03c8 iff T2 does. That is, in the language L, no query in signature \u2206 separates T1 and T2 from each other. If Cons () is augmented with the third parameter specifying a logic, in which consequences are taken, then inseparability gives rise to a variety of notions of similarity between theories. As informally noted, two theories may be inseparable wrt a logic L, but entail different consequences wrt a language more expressive than L. For the purpose of this paper, we consider the non-parametrized notion of inseparability, assuming that the language of interest is the underlying logic L, in which\nthe theories are formulated. This assumption is natural if one is only interested in entailment of L-formulas.\nInseparability plays an important role for decompositions. Assume that we have a theory T that is \u2206-decomposable into some components T1 and T2. Although, the union T1 \u222a T2 must entail all consequences of T in the signature \u2206, the components T1 and T2 may not be \u2206\u2013inseparable, if we demand them to be finite. For example, the set of\u2206\u2013consequences of T2 may not be finitely axiomatizable in L by axioms of T1. This easily follows from Fact 2.3 which shows that this phenomenon is already possible in weak languages such as the sub-boolean description logic EL. On the other hand,\u2206\u2013inseparability of decomposition components can always be obtained if the underlying logic L has uniform interpolation (cf. Proposition 2 in [38]). Both\u2206\u2013decomposition and\u2206\u2013inseparability are required to achieve modularity. Without\u2206\u2013inseparability the components are not self-sufficient, since a component may not entail some of the consequences in the shared vocabulary\u2206. The ideal case is when a theory T has \u2206-decomposition into finite \u2206\u2013inseparable components, as noted in Fact 2.6 further in this section.\nIn contrast to decomposability, deciding \u2206-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12]. However, there are practical cases in which this property is guaranteed to hold for any decomposition components of a given theory wrt a certain signature \u2206. For example, if the theory without equality is a set of ground atoms, then such theory is\u2206-decomposable iff there exist two subsets of atoms having only \u2206-symbols in common and containing at least one non-\u2206-symbol. This property is easy to check by computing syntactic connectedness of the signature symbols. It is straightforward to verify that if \u2206 does not contain predicate symbols, then the obtained decomposition components are guaranteed to be \u2206-inseparable. In other words, a set of ground atoms can be easily decomposed into inseparable components, if they share constants only with no common predicate symbols. A practically important generalization of theories consisting of ground atoms is proper+ theories [21,27]. Developing computationally tractable techniques for decomposition of proper+ theories into inseparable components is of particular interest. We note the importance of having inseparable decomposition components below.\nThe well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].\nDefinition 2.5 (Parallel Interpolation Property) A logicL is said to have the parallel interpolation property (PIP) if for any theories T1, T2 in L with sig (T1) \u2229 sig (T2) = \u2206 and any formula \u03d5 in L, the condition T1 \u222a T2 |= \u03d5 yields the existence of sets of formulas T \u20321 and T \u2032 2 in L such that:\n\u2013 Ti |= T \u2032i , for i = 1, 2, and T \u2032 1 \u222a T \u2032 2 |= \u03d5; \u2013 sig (T \u2032i ) \\\u2206 \u2286 (sig (Ti) \u2229 sig (\u03d5)) \\\u2206.\nNote that PIP is closely related to Craig\u2019s interpolation [5,6]. In fact, PIP can be understood as an iterated version of Craig\u2019s interpolation in the logics that have compactness and deduction theorem (see Lemma 1 in [38]). Many logics known to have Craig interpolation \u2013 e.g., second- and first-order logics, numerous modal logics, and some description logics, also have PIP. It is easy to note that, in the presence of PIP, decomposing a set T of formulas into inseparable components wrt a signature \u2206 gives a family of theories that imply all the consequences of T in their own subsignatures.\nFact 2.6 Let L have PIP, T be a theory in L, and\u2206 a signature. Let \u3008T1, T2\u3009 be a\u2206\u2013decomposition of T , with T1 and T2 being \u2206\u2013inseparable. Then for any formula \u03d5 with sig (\u03d5) \u2286 sig (Ti), for some i = 1, 2, we have T |= \u03d5 iff Ti |= \u03d5.\nProof. Assume sig (\u03d5) \u2286 sig (T1). If T1 |= \u03d5 then T |= \u03d5 by definition of\u2206\u2013decomposability. If T |= \u03d5 then T1\u222aT2 |= \u03d5 and by PIP, there are T \u20321 and T \u2032 2 such that T1 |= T \u2032 1 , T2 |= T \u2032 2 , T \u2032 1 \u222aT \u2032 2 |= \u03d5, and sig (T \u20322 ) \u2286 \u2206. As T1 and T2 are\u2206\u2013inseparable, we obtain T1 |= T \u2032 2 and conclude that T1 |= \u03d5.\nIn other words, in the presence of PIP, inseparable decomposition components can be used instead of the original theory for checking the entailment of formulas in the corresponding subsignatures. This is the reason for our interest in the inseparability property in connection with decompositions. As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components. However, if components are inseparable, then the reasoner can avoid message passing completely."}, {"heading": "2.3 Basics of the Situation Calculus", "text": "The language of the situation calculus Lsc has the first-order syntax over three sorts action, situation, object. It is provided with the standard model-theoretic semantics. It is defined over the countably infinite alphabet Asc = {do, , S0, Poss} \u222a A \u222a F \u222a O \u222a P , where do is a binary function symbol of sort situation; is a binary relation on situations; S0 is the constant of sort situation; Poss(a, s) is a binary predicate (saying whether a is possible in s) with the first argument of sort action and the second one of sort situation; A is a set of action functions with arguments of sort object, F is a set of so-called fluents, i.e., predicates having as arguments a tuple (vector) of sort object and one last argument of sort situation; O is a set of constants of sort object; and P is a set of static predicates and functions, i.e., those that only have objects as arguments. A symbol v \u2208 Asc (predicate or function) is called situation-independent if v \u2208 A \u222aO \u222a P . A ground term is of sort situation iff it is either the constant S0 or a term do(A(t\u0304), S), where A(t) is a ground action term and S is a ground situation term. For instance, a term do(A2(t\u03042), do(A1(t\u03041), S0)) denotes the situation resulting from executing actions A1(t\u03041) andA2(t\u03042) consecutively from the initial situation S0. Informally, static predicates specify object properties that never change no matter what actions are executed and fluents describe those object properties that are situation\u2013dependent. The language of the situation calculus is used to formulate basic action theories (BAT s); they may serve as the formal specifications of planning problems. Every BAT consists of a set of foundational axioms \u03a3, which specify constraints on how the function do and fluents must be understood, a theoryDuna stating the unique name assumption for action functions and objects, an initial theoryDS0 describing knowledge about the initial situation S0, a theoryDap specifying preconditions of action execution, and a theory Dss (the set of successor-state axioms, SSAs for short) which contains definitions of fluents in the next situation in terms of static predicates and the values of fluents in the previous situation. A detailed example of a BAT is given at the end of this section.\nExample 1 (The Blocks World).We illustrate some of the syntactic definitions using the well-known BlocksWorld example. The domain of objects in this example consists of blocks that can form towers such that a block can be on the top of only one other block and conversely only one block can be staying on the top of another block. The unary predicate Block holds for objects. The towers of blocks\ncan be described using the fluents On(x, y, s), a block x is on y in situation s, and Clear(x, s), a block x is clear in s meaning that there is no block on top of x in situation s. The first fluent applies to pairs of blocks in a tower, while the second fluent characterizes the top block. An initial theory DS0 may include axioms about the initial configuration of blocks named using object constants A,B,C, e.g.,On(A,B, S0), the blockA is onB initially, \u00ac\u2203xOn(x,A, S0) and \u00ac\u2203xOn(x,C, S0), i.e., there are no blocks on top of blocks A and C. Notice that both fluents are predicates with situation as the last argument. A theoryDuna includes axioms saying that all blocksA,B,C are pairwise distinct. The function move(x, y, z) maps blocks x, y, z into a separate sort action that represents moving block x staying on top of block y from block y onto another block z. The precondition axioms Dap characterize when this action is possible, e.g.,move(A,B,C) is possible in the initial situation S0, because both A and C are clear, but move(B,A,C) is not possible in S0, because the block B is not clear, and it is not staying on A in S0. The situation do(move(A,B,C), S0) results from executing action move(A,B,C) in the initial situation S0. This action has effects on the fluents in the sense that the fluent predicates about S0 may change their truth values in the situation do(move(A,B,C), S0). Observe however that in do(move(A,C,B), do(move(A,B,C), S0)) fluents are true iff they are true in S0, sincemove(A,C,B) is inverse wrt move(A,B,C) when these actions executed consecutively. The following successor state axiom characterizes all effects of all actions on the fluent On:\n\u2200x, y, z, a, s On(x,z, do(a,s)) \u2194 \u2203y(a=move(x,y,z)) \u2228On(x,z,s)\u2227\u00ac\u2203y(a=move(x,z,y))\nMore specifically, block x is on block z after doing an action a in situation s iff the last action a was moving x from some other block y to z, or if x was already on z in s, and the last action a did not move it elsewhere. Subsequently, we do not write the \u2200-quantifiers explicitly at front of the axioms.\nIn every basic action theory D over a signature \u03c3 \u2286 Asc, the set of foundational axioms \u03a3 consists of the following formulas [42] (note the axiom schema for induction):\n\u2200 a1, a2, s1, s2 [do(a1, s1) = do(a2, s2) \u2192 a1 = a2 \u2227 s1 = s2] \u2200 s \u00ac(s S0 \u2227 s 6= S0) \u2200 s1, s2 [s1 s2 \u2194 \u2203a (do(a, s1) s2) \u2228 s1 = s2] \u2200P P (S0) \u2227 \u2200a, s[P (s) \u2192 P (do(a, s))] \u2192 \u2200sP (s)\nReiter observed in [42] that foundational axioms \u03a3 generalize a single successor function over natural numbers to the case of multiple successors over situations. The second order induction axiom serves to exclude non-standard trees as models.\nFor every pair of distinct action functions {A,A\u2032} \u2286 \u03c3 and every pair \u3008a, b\u3009 of distinct object constants from \u03c3, a theoryDuna contains axioms of the form:\na 6= b \u2200 x\u0304, y\u0304 A(x\u0304) 6= A\u2032(y\u0304) \u2200 x\u0304, y\u0304 A(x1, . . . , xn) = A(y1, . . . , yn) \u2192 x1 = y1 \u2227 . . . \u2227 xn = yn if A is n\u2013ary.\nNo other axioms are inDuna. To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).\nDefinition 2.7 A formula \u03d5 in language Lsc is called uniform in a situation term S if:\n1. it does not contain quantifiers over variables of sort situation;\n2. it does not contain equalities between situation terms; 3. the predicates Poss, do not occur in \u03d5: {Poss, } \u2229 sig (\u03d5) = \u2205; 4. for every fluent F \u2208 sig (\u03d5), the term in the situation argument of F is S.\nA set T of formulas in Lsc is called uniform in a situation term S if every formula of T is uniform in S.\nBy definition, a set T of formulas uniform in a situation term S either does not contain any situation terms (and hence, fluents), or the only situation term is S which occurs as the situation argument of each fluent from sig (T ). In the example above, the formula on the right hand side of the SSA is a formula uniform in s. If T is a set of sentences uniform in situation term S, i.e., T has no free variables, and S occurs in formulas of T , then by items (1), (2) of the definition, S must be ground and thus, it must either be the constant S0, or have the form do(A(t\u0304), S\u2032), where S\u2032 is a ground situation term. Note that if the constant S0 or the binary function symbol do is present in sig (T ) and T is uniform in S, then necessarily S0 \u2208 sig (S), or do \u2208 sig (S), respectively. By items (1) and (2), such theory T does not restrict the interpretation of the term S and the cardinality of the sort situation, so the observations above lead to the following property of uniform theories, which informally can be summarized by saying that in sentences of a theory T uniform in a ground situation term S, we can understand this situation term as playing a role of an index that can remain implicit. Whenever we change the interpretation of S (e.g., by choosing a different interpretation for do and S0) in a model of T , it suffices to \u201cmove\u201d interpretations of fluents to this new point to obtain again a model for T .\nLemma 2.8 Let T be a set of sentences uniform in a ground situation term S. Let M = \u3008Act \u222a Sit \u222a Obj, do,S0,F1, . . . ,Fn, I \u3009 be a model of T , where Act, Sit, and Obj are domains for the corresponding sorts action, situation, and object, do and S0 are the interpretations of the function do and constant S0, respectively, F1, . . . ,Fn are the interpretations of fluents from sig (T ), and I is the interpretation of the rest of symbols from sig (T ). For example, Fi is a set of tuples \u3008u1, . . . , um\u22121,S\u3009, where S is the interpretation of the ground term S inM.\nConsider the structure M\u2032 = \u3008Act \u222a Sit\u2032 \u222a Obj, do\u2032,S0 \u2032,F1 \u2032, . . . ,Fn \u2032, I \u3009, where Sit\u2032 is an arbitrary set, the domain for sort situation, do\u2032 and S0 \u2032 are arbitrary interpretations of do and S0 on Sit\u2032, respectively, and for i 6 n, Fi \u2032 denotes the interpretation of the fluent Fi as a set of tuples \u3008u1, . . . , um\u22121,S\u2032\u3009, with S\u2032 being the interpretation of term S inM\u2032 and \u3008u1, . . . , um\u22121,S\u3009 \u2208 Fi. Then, M\u2032 is a model of T . By definition, the interpretation of situation\u2013independent predicates and functions is the same inM\u2032 andM.\nThis lemma can be easily proved by induction over possible syntactic form of sentences in T . If S and S\u2032 are two situation terms and T is a set of formulas uniform in S, then we denote by T (S\u2032/S) the set of formulas obtained from T by replacing every occurrence of S with S\u2032. This notation will be extensively used in Section 4. Obviously, T (S\u2032/S) is uniform in S\u2032.\nThe initial theory DS0 of D is defined as an arbitrary set of sentences in the signature \u03c3 that are uniform in the situation constant S0. Throughout the paper, we assume that DS0 is a theory in (any fragment of) second-order logic that can be translated into a set of sentences of first-order logic uniform in S0. In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].\nNext, for every n-ary action functionA \u2208 \u03c3, a theory Dap includes an axiom of the form\n\u2200 x\u0304, s ( Poss(A(x\u0304), s) \u2194 \u03a0A(x\u0304, s) ) ,\nwhere \u03a0A(x\u0304, s) is a formula uniform in s with free variables among x\u0304 and s. Informally,\u03a0A(x\u0304, s) characterizes preconditions for executing the action A in the situation s. No other formulas are in Dap.\nExample 1 (continuation). The following is the precondition axiom formove(x, y, z):\nPoss(move(x, y, z), s) \u2194 Block(x) \u2227Block(y) \u2227Block(z) \u2227On(x, y, s)\u2227 Clear(x, s) \u2227 Clear(z, s) \u2227 x 6= z\nThe action move(x, y, z) is possible iff x, y, z are blocks, x is located on y in situation s, and both the block x that is to be moved, and a destination block z are not occupied by any other blocks. Notice the preconditions do not allow moving a block back to the same location where it was before.\nFinally, for every fluent F \u2208 \u03c3, a theoryDss contains an axiom of the form\n\u2200 x\u0304, a, s ( F (x\u0304, do(a, s)) \u2194 \u03b3+F (x\u0304, a, s) \u2228 F (x\u0304, s) \u2227 \u00ac\u03b3 \u2212 F (x\u0304, a, s) ) (\u2020),\nspecifying a condition \u03b3+F (x\u0304, a, s) when fluent F becomes true in situation do(a, s), or when F remains true in situation do(a, s) if it is true in s, unless another condition \u03b3\u2212F (x\u0304, a, s)] holds. Here, \u03b3+F is a disjunction of formulas of the form [\u2203y\u0304](a = A\n+(t\u0304) \u2227 \u03c6+(x\u0304, y\u0304, s)), where A+ is an action function, t\u0304 is a (possibly empty) vector of object terms with variables at most among x\u0304 and y\u0304, and \u03c6+ is a formula uniform in s with variables at most among x\u0304, y\u0304, and s. We write [\u2203y\u0304] to show that \u2203y\u0304 is optional; it is present only if t\u0304 includes y\u0304 or if \u03c6 has an occurrence of y\u0304. The formula \u03c6+ is called a positive context condition meaning that A+(t\u0304) makes the fluent F true if this context condition holds in s, but otherwise, A+(t\u0304) has no effect on F . Similarly, \u03b3\u2212F is a disjunction of formulas of the form [\u2203z\u0304](a = A\u2212(t\u0304\u2032) \u2227 \u03c6\u2212(x\u0304, z\u0304, s)), where A\u2212 is an action function, t\u0304\u2032 is a (possibly empty) vector of object terms with variables at most among x\u0304 and z\u0304, and \u03c6\u2212 is a formula uniform in s with variables at most among x\u0304, z\u0304, and s. The formula \u03c6\u2212 is called a negative context conditionmeaning that A\u2212(t\u0304) makes the fluent F false if this context condition holds in s, but otherwise, A\u2212(t\u0304) has no effect on F . In the definition above, we assume that the empty disjunction is equal to false. No other formulas are in Dss. This completes the definition of Dss. Subsequently, the following will be useful.\nDefinition 2.9 (SSA and active position of an action) The axioms of Dss in the form above are called successor state axioms (SSAs) of a basic action theory D.\nAn action function f is said to be in active position of some SSA \u03d5 \u2208 Dss if f occurs either as A+, or A\u2212 in the definition of Dss above.\nWe say that \u03d5 \u2208 Dss is SSA for the fluent F if F is the fluent from the left-hand side of \u03d5.\nExample 1 (continuation). The following is the SSA for the fluentEH(x, s)meaning the height of a block x is even, i.e., the number of blocks under x is odd:\nEH(x, do(a, s)) \u2194 \u2203y, z ( a=move(x, y, z) \u2227 \u00acEH(z, s) ) \u2228\nEH(x, s) \u2227 \u00ac\u2203y, z ( a=move(x, y, z) \u2227 EH(z, s) ) .\nThen formula \u00acEH(z, s) is a positive context condition. If it holds in s, i.e., if the height of block z is not even in a situation s, then in the situation that results from moving x from y to a block z, the height of x becomes even. But if the positive context condition does not hold in s, then move(x, y, z) does not make the height of block x even. Also, if the height of x is even in s, then it remains even unless a block x is moved from y on top of z and the height of z is even in s. The\nformula EH(z, s) is a negative context condition, i.e., if the height of block z is even in s, then the action move(x, y, z) has a negative conditional effect on the fluent EH(x, s) in the sense that this fluent becomes false in the situation that results from doingmove(x, y, z) in s. In this SSA, an action functionmove occurs both as A+ and A\u2212 on the right hand side of this SSA.\nFollowing the consistency requirement on SSAs by Reiter (see Proposition 3.2.6 in [43]), we require that if an action function f occurs in active position in some SSA for a fluent F , then f is not in active position in either \u03b3+F , or \u03b3 \u2212 F . Informally, this means that an action cannot have both positive and negative effects on F . Each SSA for a fluent F completely defines the truth value of F in the situation do(a, s) in terms of what holds in situation s. Also, SSA compactly represents non-effects by quantifying \u2200a over variables of sort action. Only action terms that occur explicitly on the right-hand side of SSA for a fluent F have effects on this fluent, while all other actions have no effect.\nWe note that the original version of Reiter\u2019s situation calculus admits functional fluents, e.g. functions having a vector of arguments of sort object and one last argument of sort situation. Reiter defines the notion of SSA for functional fluents [43]. Without loss of generality, we omit functional fluents in this paper.\nThe following fundamental result, which will be used in our Theorem 4.4, says that the initial theory together with the UNA is the core of any basic action theory, while the rest of the constituent theories may be considered as add-ons.\nProposition 2.10 (Theorem 1 in [37]) A basic action theory \u03a3 \u222a Duna \u222a DS0 \u222a Dap \u222a Dss is satisfiable iffDuna \u222aDS0 is satisfiable.\nSuppose A1, \u00b7 \u00b7 \u00b7 ,An is a sequence of ground action terms, and \u03d5(s) is a formula with one free variable s of sort situation which is uniform in s. One of the most important reasoning tasks in the situation calculus is the projection problem: that is, to determine whether D |= \u03d5(do(An, do(An\u22121, do(\u00b7 \u00b7 \u00b7 , do(A1, S0))))). Informally,\u03d5 represents some property of interest and entailment holds iff this property is true in the situation resulting from performing the sequence of actionsA1, \u00b7 \u00b7 \u00b7 ,An starting from S0.\nAnother basic reasoning task is the executability problem. Let executable(do(An, do(An\u22121, do(\u00b7 \u00b7 \u00b7 , do(A1, S0)))))\nbe an abbreviation of the formula Poss(A1, S0) \u2227 \u2227n i=2 Poss(Ai, do(A1, do(\u00b7 \u00b7 \u00b7 , do(Ai\u22121, S0))). Then, the executability problem is to determine whether D |= executable(do(An, do(An\u22121, do(\u00b7 \u00b7 \u00b7 , do(A1, S0))))), i.e. whether it is possible to perform the sequence of actions starting from S0. Planning and high-level program execution are two important settings, where the executability and projection problems arise naturally. Regression is a central computational mechanism that forms the basis for an automated solution to the executability and projection tasks in the situation calculus ([43]). Regression requires reasoning backwards: a given formula \u03d5(do(An, do(An\u22121, do(\u00b7 \u00b7 \u00b7 , do(A1, S0))))) is recursively transformed into a logically equivalent formula by using SSAs until the resulting formula has only occurrences of the situation term S0. It is easy to see that regression becomes computationally intractable if the sequence of actions grows indefinitely [16]. In this case, an alternative to regression is progression, which provides forward-style reasoning. The initial theoryDS0 is updated to take into account the effects of an executed action. Computing the progression of a given theory\nDS0 requires forgetting facts in DS0 which are no longer true after executing an action. The closely related notions of progression and forgetting are discussed in the next sections.\nDefinition 2.11 (local-effect SSA and BAT ) An SSA\u03d5 \u2208 Dss for the fluentF is called local-effect if the set of arguments of every action function in active position of \u03d5 contains all object variables from F . A basic action theory is said to be local-effect if every axiom of Dss is a local-effect SSA.\nLocal-effect BAT s are a well-known3 class of theories, for which the operation of progression (Section 4) can be computed effectively [27], without regard to decidability of the underlying theory DS0 . They are special in the sense that the truth value of each fluent defined by a local-effect SSA can change only for objects explicitly named as arguments of the executed action. Therefore, in local-effect BAT s, each action can change only finitely many ground fluent atoms. This allows for computing forgetting (the operation considered in Section 3) efficiently. Informally speaking, forgetting erases fromDS0 those finitely many fluent atoms which changed after executing an action.\nExample 1 (continuation). Observe that in the Blocks World example considered above, the actionmove has only local effects on the fluentsOn andClear. As an informal example of an action that has global effects, consider the action drive(t, l1, l2) of driving a truck t loaded with boxes from one location l1 to another location l2. Consider also the fluent At(x, l, s) that holds if an object x is at a location l in s. Observe that this action would have a global effect on location of all boxes loaded on the truck since these boxes are not named explicitly in the action function drive(t, l1, l2), but the SSA for At(x, l, s) would have a \u2200-quantifier over the object argument x. Therefore, the truth value of At(x, l, s) changes not only for t, but also for other objects not mentioned in drive(t, l1, l2). It would be awkward to include all the boxes loaded in t as arguments of this action. For this reason, axioms for the logistics domain should include actions with global effects on the fluents.\nBefore we proceed to a discussion of component properties under forgetting (Section 3) and to progression of initial theories (Section 4), we consider an example that helps to illustrate the notion of BAT and the advantages of decomposition of its initial theory. Our example combines the simplified Blocks World (BW) with a kind of Stacks World. A complete axiomatization of BW modelled as a finite collection of finite chains can be found in [4]. In this example, and subsequently, we resort to the common situation calculus convention that free variables in BAT axioms are implicitly taken to be universally quantified at front.\nExample 2 (A running example of BAT ). The blocks-and-stacks-world consists of a finite set of blocks and a finite set of other entities. Blocks can be located on top of each other, while other entities can be either in a heap of unlimited capacity, or can be organized in stacks. There is an unnamed manipulator that can move a block from one block to another, provided that there is nothing on the top of the blocks. It can also put an entity from the heap upon a stack with a named top element, or move the top element of a stack into the heap. For stacking/unstacking operations we adopt the push/pop terminology and use the unary predicate Block to distinguish between blocks and other entities. We use the following action functions and relational fluents to axiomatize this example as a local-effect BAT in SC.\nActions\n\u2013 move(x, y, z): Move block x from block y onto block z, provided both x and z are clear.\n3 The phrase local-effect actions first appeared in [28], but it was motivated by actions with simple effects defined in the paper [24], where simple effects are understood similar to the Def. 2.11.\n\u2013 push(x,y): Stack entity x from the heap on top of entity y. \u2013 pop(x): Unstack entity x into the heap, provided x is the top element and is not in the heap.\nFluents\n\u2013 On(x, z, s): Block x is on block z, in situation s. \u2013 Clear(x, s): Block x has no other blocks on top of it in s. \u2013 Top(x, s): Entity x is the top element of a stack in s. \u2013 Inheap(x, s): Entity x is in the heap in situation s. \u2013 Under(x, y, s): Entity y is directly under x in a stack in situation s.\nThe sub-theories of the basic action theory are defined as follows.\nSuccessor state axioms (theory Dss) On(x, z, do(a, s)) \u2194 \u2203y(a=move(x, y, z)) \u2228On(x, z, s) \u2227 \u00ac\u2203y(a=move(x, z, y))\nClear(x, do(a, s)) \u2194 \u2203y, z(a=move(y, x, z)\u2227 On(y, x, s)) \u2228 Clear(x, s)\u2227 \u00ac\u2203y,z(a=move(y, z, x))\nInheap(x, do(a, s)) \u2194 a=pop(x) \u2228 Inheap(x, s) \u2227 \u00ac\u2203y(a=push(x, y))\nTop(x, do(a, s)) \u2194 \u2203y( a=push(x, y) ) \u2228 \u2203y( a=pop(y) \u2227 Under(y, x, s) ) \u2228 Top(x, s) \u2227 a 6=pop(x) \u2227 \u00ac\u2203y(a=push(y, x))\nUnder(x, y, do(a, s)) \u2194 a=push(x, y) \u2228 Under(x, y, s) \u2227 a 6=pop(x)\nThe first axiom is saying that a block x will be on top of a block z after moving x from another block y onto z, or if x was already on z and it was not moved elsewhere. The second axiom is saying that x will become clear, i.e., there will be no blocks on top of x after moving the block y that was previously on top of x onto another block z. Otherwise, if a block x was already clear, it remains clear unless some block y will be moved from the block z onto the block x. The third axiom asserts that an entity x is in a heap once it has been removed from a stack, or if it was already in a heap, and it was not stacked on top of another entity y. In the fourth axiom, when an entity x is stacked upon an entity y, x become the new top. Also, it becomes the top, when x was located under some y that was removed into a heap. Otherwise, an entity x remains on the top unless it was unstacked or buried under by stacking another entity y onto x. In the last fifth axiom, an entity y will be under another entity x after stacking x on top of y, or y remains under x after any action that does not remove x into a heap. It is easy to observe that all these SSAs are local-effect, and we will exploit this fact later in our paper.\nAction precondition axioms (theoryDap) Poss(move(x, y, z), s) \u2194 Block(x) \u2227Block(y) \u2227Block(z) \u2227On(x, y, s)\u2227\nClear(x, s) \u2227 Clear(z, s) \u2227 x 6= z\nPoss(push(x, y), s) \u2194 \u00acBlock(x) \u2227 \u00acBlock(y) \u2227 Top(y, s) \u2227 Inheap(x, s)\nPoss(pop(x), s) \u2194 \u00acBlock(x) \u2227 Top(x, s)\nThe precondition axioms are self-explanatory. The actionmove(x, y, z) is possible in any situation s where a block x is located on top of a block y, both x and a destination block z are clear (i.e., not obstructed by any blocks on top of them) and x is different from z. The last condition precludes moving x on top of itself. According to the second precondition axiom, it is possible to stack x on y in any situation s, if x and y are entities which are not blocks, y is the top of a stack, and x is in a heap. The opposite operation of unstacking x is possible if and only if x is a top entity in situation s.\nInitial Theory (DS0) is defined as the set of axioms 4 using object constants {A,B,C}:\n\u00ac\u2203yOn(y, x, S0) \u2227 \u2203yOn(x, y, S0) \u2227 \u00acInheap(x, S0)\u2192Clear(x, S0) \u2203y On(x, y, S0) \u2192 Block(x) (Top(x, S0) \u2228 Inheap(x, S0)) \u2192 \u00acBlock(x) On(A,B, S0)\u2227Block(B)\u2227Block(C)\u2227 Clear(A,S0)\u2227 Clear(C, S0)\nUnique names axioms for actions and objects (theory Duna) is the set of unique names axioms for all pairs of object constants and action functions used above.\nThen \u03a3 \u222a Duna \u222aDap \u222a Dss \u222a DS0 is the resulting local-effect basic action theory.\nNotice that all fluents are syntactically related in DS0 , so purely syntactic techniques fail to decomposeDS0 into components sharing no fluents. However,Dss is the union of two theories with the intersection of signatures equal to {do}. The set of precondition axioms is also union of two theories \u2013 the first axiom by itself is one of them, and the conjunction of the second and third axioms is another one \u2013 with the intersection of signatures equal to {Poss,Block}. At the same time, the initial theory DS0 is \u2206\u2013decomposable for \u2206 = {Block, S0} into two distinct \u2206\u2013inseparable components:\n\u00ac\u2203y On(y, x, S0) \u2227 \u2203y On(x, y, S0) \u2192 Clear(x, S0) \u2203y On(x, y, S0) \u2192 Block(x) On(A,B, S0)\u2227Block(B)\u2227Block(C)\u2227Clear(A,S0)\u2227 Clear(C, S0)\nand (Top(x, S0) \u2228 Inheap(x, S0)) \u2192 \u00acBlock(x) \u2203x Block(x)\nThis example is continued after Theorem 4.5 in Section 4, where we will show that the progression for BAT s of this kind preserves both decomposability and inseparability of the decomposition components."}, {"heading": "3 Properties of Forgetting", "text": "There are two basic types of forgetting considered in the literature: forgetting a signature and forgetting a ground atom. As will be explained in Section 4, progression of BAT s is closely related to forgetting. In particular, computing progression of a local-effect BAT involves forgetting a set of ground atoms representing facts that are no longer true after an action execution. Thus, in order to understand the behavior of the component properties of theories under progression, one needs to first examine their relationship to forgetting, which is the purpose of this section. Although we are focused on forgetting ground atoms, the counterpart results for signature forgetting often come for free and are therefore included into this section. Moreover, they help to see the difference between the two types of forgetting, which contributes to a better understanding of this operation wrt the component properties, which we believe would be of interest to a broader audience in the literature. To emphasize broader applicability of these results, we consider a general first- and second-order logic setting in the remainder of this section.\n4 Some of these axioms, e.g., the second axiom, remain true after executing any of the possible actions, but this fact is irrelevant to the purposes of this example.\nLet us define a relation on structures as follows. Let \u03c3 be a signature or a ground atom and M, M\u2032 be two many\u2013sorted structures. Then we set M \u223c\u03c3 M\u2032 if:\n\u2013 M andM\u2032 have the same domain for each sort; \u2013 M andM\u2032 interpret all symbols which do not occur in \u03c3 identically; \u2013 if \u03c3 is a ground atom P (t\u0304) then M and M\u2032 agree on interpretation u\u0304 of t\u0304 and for every vector of elements v\u0304 6= u\u0304, we haveM |= P (v\u0304) iffM\u2032 |= P (v\u0304).\nObviously,\u223c\u03c3 is an equivalence relation.\nThe following notion summarizes the well-known Definitions 1 and 7 in [25].\nDefinition 3.1 (Forgetting an atom or signature) Let T be a theory in L and \u03c3 be either a signature, or some ground atom. A set T \u2032 of formulas in a fragment of second-order logic is called the result of forgetting \u03c3 in T (denoted by forget (T , \u03c3)) if for any structure M\u2032, we have M\u2032 |= T \u2032 iff there is a modelM |= T such thatM \u223c\u03c3 M\u2032.\nIt is known that forget (T , \u03c3) always exists, i.e. it is second-order definable, for a finite set of formulas T in L and a finite signature or a ground atom \u03c3 (see [25], or Section 2.1 in [27]). On the other hand, the definition yields T |= forget (T , \u03c3); thus, forget (T , \u03c3) is a set of second-order consequences of T which suggests that it may not always be definable in the logic, where T is formulated, and it may not be finitely axiomatizable in this logic, even if T is so.\nFact 3.2 (Basic properties of forgetting) If \u03c3 and \u03c0 are signatures or ground atoms and T , T \u2032 are theories in L then:\n\u2013 forget (T , \u03c3 \u222a \u03c0) \u2261 forget (forget (T , \u03c3), \u03c0) (if \u03c3 and \u03c0 are signatures) \u2013 forget (forget (T , \u03c3), \u03c0) \u2261 forget (forget (T , \u03c0), \u03c3) \u2013 forget (forget (T , \u03c3), \u03c3) \u2261 forget (T , \u03c3) \u2013 forget (T , \u03c3) \u2261 T if \u03c3 is a signature with \u03c3 \u2229 sig (T ) = \u2205, or a ground atom with predicate not contained in sig (T ) \u2013 forget (T \u222a T \u2032, \u03c3) 6\u2261 forget (T , \u03c3) \u222a forget (T \u2032, \u03c3) (see Example 5) \u2013 forget (\u03d5 \u2228 \u03c8, \u03c3) \u2261 forget (\u03d5, \u03c3) \u2228 forget (\u03c8, \u03c3) (if \u03d5, \u03c8 are formulas inL).\nThese properties either follow immediately from the definition, or from the results proven in [25].\nProposition 3.3 (Signature of forget(T ,\u03c3)) Let T be a theory in L, \u03c3 a signature (or a ground atom) and let forget (T , \u03c3) be a set of formulas in a language L\u2032, a fragment of second-order logic with PIP. Then forget (T , \u03c3) is logically equivalent in L\u2032 to a set of formulas in the signature sig (T ) \\ \u03c3 (sig (T ), respectively).\nProof. We consider the case when \u03c3 is a signature; the case of a ground atom being proved analogously. Assume that \u03c3 \u2229 sig (forget (T , \u03c3)) 6= \u2205. Denote by forget (T , \u03c3)\u2217 a \u201ccopy\" of the set of formulas forget (T , \u03c3), where each symbol from \u03c3\u222a[sig (forget (T , \u03c3))\\sig (T )] is uniquely replacedwith a fresh symbol, not present in sig (forget (T , \u03c3)). We claim that forget (T , \u03c3)\u2217 |=L\u2032 forget (T , \u03c3). There is nothing to prove if forget (T , \u03c3)\u2217 is unsatisfiable. Note that, by definition of forgetting, forget (T , \u03c3)\u2217 and forget (T , \u03c3) are satisfiable iff T is. Let us assume that T is satisfiable. Take an arbitrary model M\u2217 |= forget (T , \u03c3)\u2217; then there exists a model M\u2032 |= forget (T , \u03c3) which agrees on sig (forget (T , \u03c3)\u2217) with M\u2217 and interprets symbols\nfrom \u03c3 \u222a [sig (forget (T , \u03c3)) \\ sig (T )] equally to the interpretation of the corresponding fresh symbols in M\u2217. Therefore, we may assume that M\u2217 \u223c\u03c3 M\u2032. By definition of forgetting, there is a model M |= T such that M\u2032 \u223c\u03c3 M, hence M\u2217 \u223c\u03c3 M and M\u2217 |= forget (T , \u03c3). We have forget (T , \u03c3)\u2217 |=L\u2032 forget (T , \u03c3) and sig (forget (T , \u03c3)\u2217)\u2229sig ( forget (T , \u03c3))\u2286 sig (T )\\ \u03c3. By PIP, there is a set of formulas\u0398 in signature sig (T )\\\u03c3 such that forget (T , \u03c3)\u2217 |=L\u2032 \u0398 and \u0398 |=L\u2032 forget (T , \u03c3). Note that forget (T , \u03c3)\u2217 |=L\u2032 \u0398 yields forget (T , \u03c3) |=L\u2032 \u0398, because every model of forget (T , \u03c3) can be expanded to a model of forget (T , \u03c3)\u2217 and the reduct of this model onto (a subset of) sig (T ) \\ \u03c3 suffices to satisfy \u0398. Thus, we conclude that forget (T , \u03c3) is equivalent to \u0398.\nCorollary 3.4 Let T be a theory in L having PIP and \u03c3 a signature. Then T \u2261 forget (T , \u03c3) iff T is equivalent to a set of formulas in the signature sig (T ) \\ \u03c3.\nWe note that the similar statement does not hold when \u03c3 is a ground atom. It follows from Proposition 3.3 that in case \u03c3 is a signature, forget (T , \u03c3) axiomatizes the class of reducts of models of T onto the signature sig (T ) \\ \u03c3. Clearly, if T is a theory in language L, then forget (T , \u03c3) may not be in L, however it is always expressible in second-order logic if T is finitely axiomatizable (we note that second-order logic has PIP). For the case when \u03c3 is a signature, forget (T , \u03c3) is known as sig (T ) \\ \u03c3\u2013uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification. In other words, T and forget (T , \u03c3) semantically entail the same second-order formulas in signature T \\ \u03c3.\nIf \u03c3 is a ground atom P (t\u0304) then, by definition, for any modelM |= T , forget (T , \u03c3) must have two \u201ccopies\u201d ofM: a model with the value of P (t\u0304) false and a model where this value is true. Let L be first-order logic. In contrast to forgetting a signature, for any recursively axiomatizable theory T in L and a ground atom \u03c3, one can effectively construct the set of formulas forget (T , \u03c3) in L such that forget (T , \u03c3) is finitely axiomatizable iff T is. This follows from Theorem 4 in [25], where it is shown that forgetting a ground atom P (t\u0304) in a theory T can be computed by simple syntactic manipulations:\n\u2013 for an axiom \u03d5 \u2208 T , denote by \u03d5[P (t\u0304)] the result of replacing every occurrence of atom P (t\u0304\u2032) (with t\u0304\u2032 a term) by formula [t\u0304 = t\u0304\u2032 \u2227 P (t\u0304)] \u2228 [t\u0304 6= t\u0304\u2032 \u2227 P (t\u0304\u2032)] \u2013 denote by \u03d5+[P (t\u0304)] the formula \u03d5[P (t\u0304)] with every occurrence of the ground atom P (t\u0304) replaced with true and similarly, denote by \u03d5\u2212[P (t\u0304)] the formula\u03d5[P (t\u0304)] with P (t\u0304) replaced with false \u2013 then forget (T , P (t\u0304)) is equivalent to ( \u2227\n\u03d5\u2208T \u03d5 +[P (t\u0304)])\n\u2228 ( \u2227\n\u03d5\u2208T \u03d5 \u2212[P (t\u0304)]).\nThe disjunction corresponds to the union of two classes of models obtained from models of T , with the ground atom P (t\u0304) interpreted as true and false, respectively. This fact is important for effective computation of progression for local-effect BAT s mentioned in Section 4.\nExample 3 (Forgetting a ground atom).Consider a theory T = {\u03d5}, where \u03d5 = \u00acP (c), i.e., P (c) is false in every model of T . Consider forgetting P (c) in T . By the (semantic) definition of forgetting, the set of models of forget (T , P (c)) consists of models of T and those models, in which P (c) is true. Therefore, any structure is a model of forget (T , P (c)). Now consider the syntactic definition of forgetting given above. We have\n\u03d5[P (c)] = \u00ac([c = c \u2227 P (c)] \u2228 [c 6= c \u2227 P (c)])\nthus, \u03d5+[P (c)] \u2261 false, \u03d5\u2212[P (c)] \u2261 true and hence, forget (T , P (c)) \u2261 \u03d5+[P (c)] \u2228 \u03d5\u2212[P (c)] is a tautology.\nNow consider forgetting P (c) in the theory T = {\u03d5}, where \u03d5 = \u2200xP (x). By the (semantic) definition of forgetting, any structure, in which P is true on every element, except possibly, the interpretation of c, is a model of forget (T , P (c)). By the syntactic definition of forgetting we have:\n\u03d5[P (c)] = \u2200x ( [x = c \u2227 P (c)] \u2228 [x 6= c \u2227 P (x)] )\nthus, \u03d5+[P (c)] = \u2200x ( x = c \u2228 [x 6= c \u2227 P (x)] ), \u03d5\u2212[P (c)] = \u2200x ( x 6= c \u2227 P (x) ). Since \u03d5\u2212[P (c)] \u2261 false, we obtain forget (T , P (c)) \u2261 \u03d5+[P (c)] and hence, forget (T , P (c)) \u2261 \u2200x ( x 6= c \u2192 P (x) ).\nWe note that in case a theory T is finitely axiomatizable, computing forget (T , P (t\u0304)) in the way above doubles the size of theory in the worst case, due to the disjunction. It is sometimes necessary to consider forgetting of some set S of ground atoms in a theory T . This is equivalent to iterative computation of forgetting of atoms from S starting from the theory T (the order on atoms can be chosen arbitrary as noted in Fact 3.2). However, it is important to note that the size of the resulting theory is O(2|S| \u00d7 |T |), where |S| is the number of atoms in S and |T | is the size of T .\nProposition 3.5 (Interplay of forgetting and entailment) Let T and T1 be two sets of formulas in L, with T |= T1, and \u03c3 be a signature or a ground atom. Then the following holds:\nT |=\n|=\nT1\n|= |=\nforget (T , \u03c3) forget (T1, \u03c3)\nProof. Follow the diagram starting from the top-left column. By definition of forgetting, everymodel of T is a model of forget (T , \u03c3), so we have T |= forget (T , \u03c3) as shown in the left column of the diagram. Similarly, T1 |= forget (T1, \u03c3) in the right column of the diagram. To prove entailment at the bottom we rely on entailments in the columns and on the given entailment at the top, i.e., we navigate the diagram up from the bottom-left corner, then move right, and finally go down to the bottom-right expression. Let M\u2032 be an arbitrary model of forget (T , \u03c3). Then there is a model M |= T such that M \u223c\u03c3 M\u2032. Since T |= T1, we have M |= T1, so we conclude that M\u2032 |= forget (T1, \u03c3), because M is a model satisfying the conditions of Definition 3.1 for T1 and M\u2032. Thus, we proved entailment shown in the bottom row of the diagram.\nProposition 3.6 (Preservation of consequences under forgetting) Let T be a theory in L and \u03c3 be either a signature or a ground atom. Let \u03d5 be a formula such that either sig (\u03d5) \u2229 \u03c3 = \u2205 (in case \u03c3 is a signature), or which does not contain the predicate from \u03c3 (if \u03c3 is a ground atom). Then T |= \u03d5 iff forget (T , \u03c3) |= \u03d5.\nProof. From Proposition 3.5, we have T |= forget (T , \u03c3), thus forget (T , \u03c3) |= \u03d5 yields T |= \u03d5. Now let T |= \u03d5 and assume there is a modelM\u2032 of forget (T , \u03c3) such thatM\u2032 6|= \u03d5. By definition of forgetting, there exists a model M of T such that M \u223c\u03c3 M\u2032, i.e. M and M\u2032 have the same universe and may differ only on interpretation of signature \u03c3 (ground atom \u03c3). By the condition on signature of \u03d5, thenM is not a model of \u03d5, which contradicts T |= \u03d5.\nNow we answer the question when inseparability is preserved under forgetting. This is important for our research, since we are interested in preservation of inseparability under progression, the operation which relies on forgetting in local-effect BAT s. We demonstrate that it is important to distinguish between forgetting something in \u2206 (the common symbols of theories) or outside of the shared signature. While Proposition 3.6 shows that the situation is simple in the latter case, it is apriory unclear, whether the same holds in the former. Example 4 demonstrates that this is not true, while the accompanying Propositions 3.7, 3.8 describe the cases when this situation can be recovered. We believe that giving the accompanying positive results is important in order to provide a big picture to the reader. Proposition 3.7 shows that signature forgetting (the arguably more frequently used type of forgetting in the literature) preserves inseparability, while Proposition 3.8 tackles this question from another perspective. It shows that semantic inseparability, the property also well studied in the literature, is the stronger form of inseparability, which is invariant under forgetting.\nObserve that by Proposition 3.6 and the first item of Fact 3.2, when studying preservation of \u2206\u2013inseparability of two sets of formulas for a signature \u2206, it is sufficient to consider the case of forgetting a subset of\u2206 or a ground atom with the predicate from\u2206, respectively.\nProposition 3.7 (Preservation of\u2206\u2013insep. under signature forgetting) Let L have PIP and T1 and T2 be two \u2206\u2013inseparable sets of formulas in L with sig (T1) \u2229 sig (T2) = \u2206, for a signature \u2206. Let \u03c3 be a subsignature of \u2206 and forget (T1, \u03c3) and forget (T2, \u03c3) be sets of formulas of L. Then forget (T1, \u03c3) and forget (T2, \u03c3) are \u2206\u2013inseparable.\nProof. Let \u03d5 be a formula with sig (\u03d5) \u2286 \u2206 such that forget (T1, \u03c3) |= \u03d5. By Proposition 3.3, we may assume that for i = 1, 2 the signature of forget (Ti, \u03c3) is a subset of sig (Ti) \\ \u03c3. We depict the direction of the proof in the figure below.\nT1 |= T \u20321 \u21d2 T2 |= T \u2032 1\n\u21d2 \u21d2\nforget (T1, \u03c3) |= T \u20321 |= \u03d5 forget (T2, \u03c3) |= T \u2032 1 |= \u03d5\nWe start with the lower-left corner of the diagram and navigate up, then right, and finally down. As forget (T1, \u03c3) |= \u03d5, by PIP, there is a set of formulas T \u20321 with sig (T \u2032 1 ) \u2286 sig (forget (T1, \u03c3)) \u2229 sig (\u03d5) \u2286 \u2206 \\ \u03c3 such that forget (T1, \u03c3) |= T \u20321 and T \u2032 1 |= \u03d5. Then, by Proposition 3.6, we have T1 |= T \u20321 . This proves entailment in the top-left corner. Since T1 and T2 are \u2206\u2013 inseparable and sig (T \u20321 ) \u2286 \u2206, we obtain T2 |= T \u2032 1 . Therefore, the top-right entailment holds. Again, since sig (T \u20321 ) \u2229 \u03c3 = \u2205, by Proposition 3.6, we conclude that forget (T2, \u03c3) |= T \u2032 1 and thus, forget (T2, \u03c3) |= \u03d5.\nThe following example demonstrates that a similar result does not hold under forgetting a ground atom with the predicate from\u2206.\nExample 4 (\u2206\u2013inseparability lost under forgetting a ground atom). We give an example of a logic L, sets of formulas T1, T2 in L, and a signature \u2206 = sig (T1) \u2229 sig (T2) such that T1 and T2 are \u2206\u2013inseparable, but forget (T1, R(c, c)) and forget (T2, R(c, c)) are not, for a ground atom R(c, c) with a predicate R \u2208 \u2206. Let L be Description Logic ELO\u22a5, i.e. the sub-boolean logic EL augmented with nominals and the bottom concept \u22a5. Let \u03a3 = {R, a, c} be signature, where R is\na role name (binary predicate) and a, c are nominals (i.e. constants). Define a set of formulas T1 in the signature \u03a3 as {{a} \u2293 {c} \u2291 \u22a5, {c} \u2291 \u2203R.{a}, \u22a4 \u2291 \u2203R.\u22a4}. Set \u2206 = {R, c} and consider the set of formulas T2 = {\u22a4 \u2291 \u2203R.\u22a4, T aut(c)}, where Taut(c) is a tautology with the nominal c (e.g., the formula {c} \u2291 \u22a4). We have sig (T1) \u2229 sig (T2) = \u2206 and it is easy to check that T2 is equivalent to Cons (T1, \u2206) in the logic ELO\n\u22a5; thus, T1 and T2 are \u2206\u2013inseparable. Now consider forget (T1, R(c, c)) and forget (T2, R(c, c)) as sets of formulas in second-order logic (we assume the standard translation of formulas of ELO\u22a5 into the language of second-order logic). We verify that they are not \u2206\u2013inseparable and the formula \u22a4 \u2291 \u2203R.\u22a4 is the witness for this. By definition of T1, we have forget (T1, R(c, c)) |= T1, since any model of T1 with a changed truth value of the predicate R on the pair \u3008c, c\u3009 is still a model of T1. On the other hand, forget (T2, R(c, c)) 6|= \u22a4 \u2291 \u2203R.\u22a4, because T2 has the one\u2013element model M, where R is reflexive (on the sole element corresponding to c). Hence, by definition of forgetting, the one-element model M\u2032 with R false on the pair \u3008c, c\u3009 must be a model of forget (T2, R(c, c)), but obviously,M\u2032 6|= \u22a4 \u2291 \u2203R.\u22a4.\nIt turns out that the preservation of inseparability under forgetting a ground atom requires rather strong model-theoretic conditions like (*) in Proposition 3.8 below. Specialists might notice that (*) is equivalent to semantic \u2206\u2013inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]). Nevertheless, there are practically useful restrictions under which the complexity becomes feasible [19]. Semantic\u2206\u2013inseparability is stronger than the notion of inseparability given in Definition 2.4: it means that the theories are indistinguishable by second-order formulas. On the other hand, Proposition 3.8 says that whenever there is a chance to satisfy (*) for two given sets of formulas, one does not need to check it again after forgetting something in their common signature. To compare condition (*) with Example 4, note that the aforementioned one-element model of T2 does not expand to a model of T1 \u222a T2.\nProposition 3.8 (Preservation of\u2206\u2013inseparability under forgetting) Let T1 and T2 be two sets of formulas in L, with sig (T1) \u2229 sig (T2) = \u2206, for a signature \u2206, which satisfy the following condition (*): for i = 1, 2, any model of Ti can be expanded to a model of T1 \u222a T2. Then:\n\u2013 T1 and T2 are \u2206\u2013inseparable; \u2013 for \u03c3 a signature or a ground atom, forget (T1, \u03c3) and forget (T2, \u03c3) satisfy (*) as well.\nProof. \u2206\u2013inseparability is the immediate consequence of (*): if \u03d5 is a formula with sig (\u03d5) \u2286 \u2206, T1 |= \u03d5, but T2 6|= \u03d5, then there is a modelM2 of T2 such thatM2 6|= \u03d5. Then there is an expansion M ofM2 such thatM |= T1\u222aT2,M|sig (T1) |= T1, butM|sig (T1) 6|= \u03d5, a contradiction. Now let us verify that for i = 1, 2, any model of forget (Ti, \u03c3) can be expanded to a model of forget (T1, \u03c3)\u222a forget (T2, \u03c3). For instance, let M\u20322 be a model of forget (T2, \u03c3). Consider a model M2 of T2, such that M2 \u223c\u03c3 M\u20322, and expand it to a model M of T1 \u222a T2. Then by definition of forgetting, there must be a modelM\u2032 |= forget (T1, \u03c3) with M\u2032 \u223c\u03c3 M, which agrees withM\u20322 on \u03c3 (if \u03c3 is a signature), or on the predicate of \u03c3 (if \u03c3 is a ground atom). By construction,M\u2032 is an expansion ofM\u20322 and thus a model for forget (T1, \u03c3) \u222a forget (T2, \u03c3).\nLet T1 and T2 be two sets of formulas in L, with sig (T1) \u2229 sig (T2) = \u2206, for a signature \u2206, and let \u03c3 be either a subsignature of \u2206 or a ground atom with the predicate from \u2206. It is known that in general, forgetting \u03c3 may not be distributive over union of sets of formulas. The entailment forget (T1 \u222a T2, \u03c3) |= forget (T1, \u03c3) \u222a forget (T2, \u03c3) holds by Proposition 3.5, but Example\n5 below easily shows that even strong semantic conditions related to modularity do not guarantee the reverse entailment. On the other hand, forgetting something outside of the common signature of T1 and T2 is distributive over union, as formulated in Corollary 3.10 which is a consequence of the criterion in Proposition 3.9 and is used in the proof of one of our main results, Theorem 4.5.\nExample 5 (Failure of componentwise forgetting in \u2206). Let L be first-order logic and \u2206 = {P, c} be the signature consisting of a unary predicateP and a constant c. Define theories T1 and T2 as: T1 = {A \u2192 P (c)}, T2 = {P (c) \u2192 B}, where A,B are nullary predicate symbols. We have sig (T1) \u2229 sig (T2) = \u2206 and for i = 1, 2, any model of Ti can be expanded to a model of T1 \u222a T2. Clearly, T1 and T2 are\u2206\u2013inseparable and for i = 1, 2, Cons (Ti, \u2206) is the set of tautologies in \u2206. By definition of forgetting, for i = 1, 2, forget (Ti, P (c)) is a set of tautologies and thus, forget (T1, P (c)) \u222a forget (T2, P (c)) 6|= forget (T1 \u222a T2, P (c)), because forget (T1 \u222a T2, P (c)) |= A \u2192 B (by Proposition 3.6). For the case of forgetting a signature, say a nullary predicate P , it suffices to consider \u2206 = {P} and theories T1 = {A \u2192 P}, T2 = {P \u2192 B}, where A,B are nullary predicates.\nProposition 3.9 (A criterion for componentwise forgetting) Let T1 and T2 be two sets of formulas and \u03c3 either a signature or a ground atom. Then the following statements are equivalent:\n\u2013 forget (T1, \u03c3) \u222a forget (T2, \u03c3) |= forget (T1 \u222a T2, \u03c3) \u2013 for any two models M1 |= T1 and M2 |= T2, with M1 \u223c\u03c3 M2, there exists a model M |= T1 \u222a T2 such thatM \u223c\u03c3 Mi, for some i = 1, 2.\nProof. Note in the second condition, the requirementM \u223c\u03c3 Mi for some i = 1, 2 is equivalent to M \u223c\u03c3 Mi for all i = 1, 2, by transitivity of\u223c\u03c3 . (\u21d2): LetM1 |= T1 andM2 |= T2 be models with M1 \u223c\u03c3 M2. Then there are modelsM\u20321 andM \u2032 2 such that for i = 1, 2,M \u2032 i |= forget (Ti, \u03c3) and M\u2032i \u223c\u03c3 Mi. Then, by transitivity of \u223c\u03c3 , for all i, j = 1, 2 we have M \u2032 i \u223c\u03c3 Mj and thus, M \u2032 i |= forget (Tj , \u03c3). ThenM\u20321 |= forget (T1 \u222a T2, \u03c3), so there exists a modelM |= T1 \u222a T2 such that M \u223c\u03c3 M\u20321 and hence,M \u223c\u03c3 M1. (\u21d0): Let M\n\u2032 be a model of forget (T1, \u03c3) \u222a forget (T2, \u03c3). There exist models M1 and M2 such that for i = 1, 2, Mi |= Ti and Mi \u223c\u03c3 M\u2032. Then M1 \u223c\u03c3 M2, hence, there must be a modelM of T1\u222aT2 withM \u223c\u03c3 Mi for some i = 1, 2. Then we obtain that M \u223c\u03c3 M\u2032 and thus, by definition of forgetting,M\u2032 is a model of forget (T1 \u222a T2, \u03c3).\nTo compare this criterion with Example 5, observe that there exist modelsM1 |= T1 andM2 |= T2 with common domain such that M1 |= A \u2227 P (c) \u2227 \u00acB and M2 |= A \u2227 \u00acP (c) \u2227 \u00acB. Thus, M1 \u223cP (c) M2, however, there does not exist a model M of T1 \u222a T2 such that M \u223cP (c) Mi, for some i = 1, 2. NeitherM1, norM2 is a model for T1 \u222a T2.\nCorollary 3.10 (Forgetting in the scope of one component) Let T1 and T2 be two sets of formulas, with sig (T1)\u2229sig (T2) = \u2206, for a signature\u2206, and \u03c3 be either a subsignature of sig (T1)\\\u2206 or a ground atom with the predicate from sig (T1) \\\u2206. Then forget (T1 \u222a T2, \u03c3) is equivalent to forget (T1, \u03c3)\u222aT2. Moreover, if T1 and T2 are\u2206\u2013inseparable, then so are forget (T1, \u03c3) and T2.\nProof. Note that by the choice of \u03c3, T2 is equivalent to forget (T2, \u03c3) and thus, by Proposition 3.5, it suffices to verify the entailment forget (T1, \u03c3)\u222a forget (T2, \u03c3) |= forget (T1 \u222aT2, \u03c3). If there are modelsM1 |= T1 andM2 |= T2, withM1 \u223c\u03c3 M2, then in fact,M1 |= T1 \u222a T2, by the choice of \u03c3 and definition of \u223c\u03c3. Thus, the criterion from Proposition 3.9 obviously yields the required entailment. It remains to note that \u2206\u2013inseparability of forget (T1, \u03c3) and forget (T2, \u03c3) follows from the choice of \u03c3, Proposition 3.6, and\u2206\u2013inseparability of T1 and T2.\nIn general, the results of this section prove that the operation of forgetting does not behave well wrt the modularity properties of the input, since they are logic-dependent. Stronger model-theoretic conditions on the input are needed due to the model-theoretic nature of forgetting."}, {"heading": "4 Properties of Progression", "text": "We have considered some component properties of forgetting. It turns out that the operation of progression is closely related to forgetting in initial theories. However, in case of progression, we can not restrict ourselves to working with initial theories only; we need also to take into account information from successor state axioms. The aim of this section is to study component properties of progression wrt different forms of SSAs and common signatures \u2206s (deltas) of components of initial theories. We will consider local-effect SSAs discussed in [27] and deltas, which do not contain fluents.\nWe use the following notations further in the paper. For a ground action term \u03b1 in the language of the situation calculus, we denote by S\u03b1 the situation term do(\u03b1, S0). To define progression, we introduce an equivalence relation on many-sorted structures in the situation calculus signature. For two structuresM, M\u2032 and a ground action \u03b1, we set M \u223cS\u03b1 M \u2032 if:\n\u2013 M andM\u2032 have the same sorts for action and object; \u2013 M andM\u2032 interpret all situation-independent predicate and function symbols identically; \u2013 M andM\u2032 agree on interpretation of all fluents at S\u03b1, i.e., for every fluent F and every variable assignment \u03b8, we haveM, \u03b8 |= F (x\u0304, S\u03b1) iffM\u2032, \u03b8 |= F (x\u0304, S\u03b1).\nThat is, ifM \u223cS\u03b1 M \u2032 then the structuresM andM\u2032 are allowed to differ in sorts for situation and interpretations of fluents at situation terms, not equal to S\u03b1. Note that a similar notation with \u223c is used to denote the equivalence relation on models from Definition 3.1 of forgetting. The two notations are easily distinguished depending on the context and are standard in the literature, therefore we adopt both of them in our paper.\nDefinition 4.1 (Progression, modified Definition 9.1.1 in [43]) LetD be a basic action theory with unique name axioms Duna and the initial theoryDS0 , and let \u03b1 be a ground action term. A set DS\u03b1 of formulas in a fragment of second-order logic is called progression ofDS0 wrt \u03b1 if it is uniform in the situation term S\u03b1 and for any structure M, M is a model of \u03a3 \u222a Dss \u222a Dap \u222a Duna \u222a DS\u03b1 iff there is a modelM\u2032 of D such thatM \u223cS\u03b1 M \u2032.\nBelow, we use DS\u03b1 to denote progression of the initial theory wrt the action term \u03b1, if the context of BAT is clear. We sometimes abuse terminology and call progression not only the theory DS\u03b1 , but also the operation of computing this theory (when the existence of an effective operation is implicitly assumed). It can be seen (Theorem 2 in [26] and Theorem 2.10 in [27]) that progression always exists, i.e., is second-order definable, if the signature of BAT is finite and the initial theory DS0 is finitely axiomatizable. On the other hand, by the definition, for any BAT D, we have D |= DS\u03b1 and, similarly to the operation of forgetting, it is possible to provide an example (see Definition 2, Conjecture 1, and Theorem 2 in [45]), when the progression DS\u03b1 is not definable (even by an infinite set of formulas) in the logic in which D is formulated.\nTo understand the notion of progression intuitively, note the following. The progression DS\u03b1 is a set of consequences of BAT that are uniform in the situation term S\u03b1; it can be viewed as\nthe strongest postcondition of the precondition DS0 wrt the action \u03b1. Thus, informally, DS\u03b1 is all the information about the situation S\u03b1 implied by BAT . This is guaranteed by the model-theoretic property with the relation \u223cS\u03b1 in the definition. Recall that the initial theory of BAT describes information in the initial situation S0 and SSAs are essentially the rules for computing the new truth values of fluents that change after performing actions. Thus, progression DS\u03b1 can be viewed as minimal \u201cmodification\u201d of the initial theory obtained after executing the action \u03b1. In particular, the initial theory of BAT can be replaced with DS\u03b1(S\u03b1/S0) (recall the notation from Section 2.3) which gives a new BAT , with S\u03b1 as the new initial situation. Let \u03d5(s) be a formula uniform in a situation variable s. To solve the projection problem for \u03d5(S\u03b1), i.e., to find whether \u03d5(S\u03b1) holds in the situation S\u03b1 wrt BAT D, one might wish to compute progression DS\u03b1 and then check whether Duna \u222a DS\u03b1 |= \u03d5(S\u03b1) holds (or equivalently, whether Duna \u222a DS\u03b1(S0/S\u03b1) |= \u03d5(S0) holds). By Proposition 2.10, this is equivalent to D |= \u03d5(S\u03b1), so this progression-based approach solves the projection problem for \u03d5(S\u03b1). This helps to demonstrate why progression may be useful.\nConsequently, of interest are cases when progression can be computed effectively as a theory in the same logic that is used to formulate underlyingDS0 . The well-known approach is to consider the local-effect BAT s (recall Definition 2.11) in which progression can be obtained by just a syntactic modification of the initial theory DS0 with respect to SSAs. This approach is based on effective forgetting of a finite set of ground atoms (extracted from SSAs) in the initial theory of BAT . Recall the well\u2013known observation from Section 3 that, given a theory T (in an appropriate logic L), forgetting a finite set of ground atoms in T can be computed effectively by straightforward syntactic manipulations with the axioms of T . Thus, the cornerstone of computing progression in the localeffect case is to extract effectively the set of ground atoms from SSAs that need to be forgotten. Subsequently, inDS\u03b1 , they are replaced with new values of fluents, which are computed from SSAs. An interested reader may consult the whole paper [27], while here we only introduce necessary notations from Definition 3.4 of [27], which will be used in Theorem 4.5.\nLet D be a BAT with a set Dss of SSAs, an initial theory DS0 , and a unique name theory Duna, and let \u03b1 be a ground action term. Take a generic SSA (\u2020) for the fluent F (see Section 2.3) and replace there an action variable a with the action term \u03b1. Then, use unique name axioms for actions to replace equalities (or negations of equalities) between action functions with equalities (or negations of equalities, respectively) between object arguments. After that, apply the usual FO logic equivalences to eliminate existential quantifiers inside \u03b3+F (x\u0304, \u03b1, s), \u03b3 \u2212 F (x\u0304, \u03b1, s), if any. Recall these are formulas uniform in s that appear on the right-hand side of a generic SSA (\u2020). Observe that in a local-effect SSA, when one substitutes a ground action termA(b\u0304x, b\u0304z) for a variable a in the formula [\u2203z\u0304].a=A(x\u0304, z\u0304) \u2227 \u03c6(x\u0304, z\u0304, s), applying UNA for actions yields [\u2203z\u0304].x\u0304= b\u0304x \u2227 z\u0304= b\u0304z \u2227 \u03c6(x\u0304, z\u0304, s), and applying \u2203z(z = b \u2227 \u03c6(z)) \u2261 \u03c6(b) repeatedly results in the logically equivalent formula x\u0304= b\u0304x \u2227 \u03c6(x\u0304, b\u0304z, s). In a transformed SSA that is obtained after doing all these simplifications, it is convenient to consider all object constants appearing in equalities between object variables and constants. These represent values where the fluent F changes. To compute the new value of the fluent it is sufficient to instantiate object variables of F with the corresponding constants. Denote\n\u2206F = {t\u0304 | x\u0304 = t\u0304 appears in \u03b3 + F (x\u0304, \u03b1, s) or \u03b3 \u2212 F (x\u0304, \u03b1, s) in a transformed SSA for F instantiated with \u03b1 and equivalently rewritten wrt Duna}, \u2126(s) = {F (t\u0304, s) | t\u0304 \u2208 \u2206F }.\nConsider \u2126(s) and notice that \u2126(S0) is a finite set of ground atoms to be forgotten. According to Fact 3.2, forgetting several ground atoms can be accomplished consecutively in any order.\nAn instantiation of Dss wrt \u2126(S0), denoted by Dss[\u2126(S0)], is the set of formulas of the form:\nF (t\u0304, do(\u03b1, S0)) \u2194 \u03b3 + F (t\u0304, \u03b1, S0) \u2228 F (t\u0304, S0) \u2227 \u00ac\u03b3 \u2212 F (t\u0304, \u03b1, S0).\nThese formulas represent instantiations of the transformed SSAs with object constants where the fluents change. Observe that Dss[\u2126(S0)] effectively defines new values for those fluents, which are affected by the action \u03b1. However, these definitions use fluents wrt S0, which may include fluents to be forgotten. For this reason, forgetting should be performed not only in DS0 , but in Dss[\u2126(S0)] as well.\nProposition 4.2 (Theorem 3.6 in [27]) In the notations above, the following is a progression of DS0 wrt \u03b1 in the sense of Definition 4.1:\nDS\u03b1 = forget ( Dss[\u2126(S0)] \u222a DS0 , \u2126(S0) ) (S\u03b1/S0).\nThis formula demonstrates that progression is a set of formulas obtained after forgetting old values of fluents in the initial theory and in instantiation of transformed SSAs that provide new values of fluents, and then replacing S0 with S\u03b1. Thus, computing a progression in a local-effect BAT is an effective syntactic transformation of the initial theory, which leads to the unique form of the updated theory DS\u03b1 . This fact will be used in Theorem 4.5. It is important to realize that this transformation can lead to an exponential blow-up of the initial theory, as noted after Theorem 3.6 in [27], due to the possible exponential blow-up after forgetting a set of ground atoms. This is not a surprise, because even in propositional logic, forgetting a symbol in a formula is essentially the elimination of a \u201cmiddle term\" (introduced by Boole), which results in the disjunction of two instances of the input formula [23]. As a consequence, forgetting may result in a formula that is roughly twice as long as the input formula. It is important to realize that the exponential blowup is not inevitable in the case of progression. As shown in [27], there are practical classes of the initial theories for which there is no blow-up and the size of the progressed theory is actually linear wrt the size of the initial theory.\nExample 1 (continuation). As was discussed before, all SSAs in this example are local effect. Instantiate the action variable a in the SSAs with a ground actionmove(C1, C2, C3). Then, we get:\nClear(x, do(move(C1 , C2, C3), s)) \u2194 \u2203y, z ( move(C1, C2, C3)=move(y, x, z) ) \u2228 Clear(x, s) \u2227 \u00ac\u2203y, z(move(C1, C2, C3)=move(y, z, x)), On(x, y, do(move(C1, C2, C3), s)) \u2194 \u2203z ( move(C1, C2, C3)=move(x, z, y) ) \u2228\nOn(x, y, s) \u2227 \u00ac\u2203z ( move(C1, C2, C3)=move(x, y, z) ) .\nApplying UNA for actions yields the following axioms:\nClear(x, do(move(C1, C2, C3), s)) \u2194 \u2203y, z ( y=C1 \u2227 x=C2 \u2227 z=C3 ) \u2228 Clear(x, s) \u2227 \u00ac\u2203y, z(y=C1 \u2227 z=C2 \u2227 x=C3), On(x, y, do(move(C1, C2, C3), s)) \u2194 \u2203z(x=C1 \u2227 z=C2 \u2227 y=C3)\u2228\nOn(x, y, s) \u2227 \u00ac\u2203z(x=C1 \u2227 y=C2 \u2227 z=C3).\nDoing the equivalent first order simplifications yields the transformed SSAs:\nClear(x, do(move(C1 , C2, C3), s)) \u2194 (x=C2) \u2228 Clear(x, s) \u2227 \u00ac(x=C3), On(x, y, do(move(C1 , C2, C3), s)) \u2194 (x=C1 \u2227 y=C3) \u2228On(x, y, s) \u2227 \u00ac(x=C1 \u2227 y=C2).\nThe argument set\u2206F for the fluent F wrt a ground action \u03b1 is a set of constants appearing in the transformed SSA for F instantiated with \u03b1. For example, the set \u2206clear for the fluent Clear(x, s) wrt a ground actionmove(C1, C2, C3) is {C2, C3}. For the fluentOn(x, y, s) this argument set\u2206on is {\u3008C1, C3\u3009, \u3008C1, C2\u3009}. The characteristic set \u2126 of a ground action move(C1, C2, C3) is a set of all ground atoms subject to change by this action. Therefore \u2126(s) = {Clear(C2, s), Clear(C3, s), On(C1, C3, s), On(C1, C2, s)}. Notice that if block C3 is clear at s, it no longer remains clear after doingmove(C1, C2, C3) action, but blockC2 will become clear. However, this action has no effect on the property of C1 being clear, and for this reason, C1 is not in\u2206clear and not in the characteristic set \u2126.\nUsing these atoms to instantiate the transformed SSA, i.e., by replacing object arguments with constants from\u2206F , we obtain the set Dss[\u2126] of formulas representing new values of fluents, e.g.,\nOn(C1, C3, do(move(C1, C2, C3), S0)) \u2194 C1=C1 \u2227 C3=C3 \u2228 On(C1, C3, S0) \u2227 \u00ac(C2=C3 \u2227C3=C2).\nAfter the equivalent simplifications using UNA, the instantiated SSAs wrt \u2126(S\u03b1), where S\u03b1 = do(move(C1, C2, C3), S0) will be the following set:\n{Clear(C2, S\u03b1),\u00acClear(C3, S\u03b1), On(C1, C3, S\u03b1),\u00acOn(C1, C2, S\u03b1)}.\nNote that in this example Dss[\u2126] are very simple, but in a general case, if a SSA includes context conditions, these axioms may include fluents wrt S0. Finally, according to Proposition 4.2, to compute a progression DS\u03b1 of an initial theory DS0 for BW, we have to forget all old values of the fluents from \u2126(S0) in the theory Dss[\u2126] \u222aDS0 , and subsequently replace the situation S\u03b1 with S0.\nNow we are ready to formulate the results on component properties of progression in terms of decomposability and inseparability. We start with negative examples in which every BAT is localeffect and the initial theories are formulated in first-order logic. As the progression DS\u03b1 is a set of formulas uniform in some situation term S\u03b1, which may occur in every formula of DS\u03b1 (thus potentially spoiling decomposability), we consider the mentioned decomposability and inseparability properties regarding the theory DS\u03b1(S0/S\u03b1) instead of DS\u03b1 . Otherwise, in every result we would have to speak of\u2206\u222asig (S\u03b1)\u2013decomposability of progression, since the symbols from sig (S\u03b1)= sig (do(\u03b1, S0))={do, S0} \u222a sig (\u03b1) may occur in all components.\nConsider a BAT D with \u2206\u2013decomposable initial theory DS0 for a signature \u2206. The general definition of a successor state axiom gives enough freedom to design examples showing (non)preservation of the decomposability property of DS0 or inseparability of its components. Note that an SSA may contain symbols that are not even present in sig (DS0), or symbols from both components of DS0 (if decomposition exists). Therefore, it makes sense to restrict our study to those BAT s, where SSAs have one of the well-studied forms, e.g., to local-effect theories. It turns out that this form is still general enough to easily formulate negative results demonstrating that the aforementioned properties are not preserved without stipulations.\nFirst, we provide an example showing that the decomposability property of the initial theory can be easily lost under progression. Next, we show that \u2206\u2013inseparability of components of the initial theory DS0 can be easily lost when fluents are present in \u2206 (see Example 7). The third observation is that even if there are no fluents in \u2206, some components of DS0 can split after progression into theories which are no longer inseparable (see Example 8). All observations hold already for localeffect BAT s and follow from the fact that some new information from SSAs can be added to the initial theory after progression, which spoils its component properties. We only need to provide a\ncombination of an initial theory with a set of SSAs that are appropriate for this purpose. The aim of Theorem 4.4 following these negative examples is to prove that if \u2206 does not contain fluents and the components of DS0 do not split after progression, then \u2206\u2013inseparability is preserved after progression under a slight stipulation which is caused only by generality of the theorem and the nonuniqueness of progression in the general case. This stipulation is avoided in Theorem 4.5, where we consider the class of local-effect BAT s. Recall that all free variables in axioms of BAT s are assumed to be universally quantified.\nExample 6 (Decomposability lost under progression).Consider basic action theoryD, with {F, P,A, c} \u2286 sig (D), where F is a fluent, P a predicate, A an action function, and c an object constant. Let the theory Dss consist of the single axiom\nF (x, do(a, s)) \u2194 (a = A(x)) \u2227 P (x) \u2228 F (x, s)\nand let the initial theory DS0 consist of two axioms \u00acF (c, S0) and \u2203xP (x). Clearly, DS0 is a \u2205\u2013 decomposable.\nConsider action \u03b1 = A(c) and let us compute progression of DS0 wrt \u03b1. We apply Proposition 4.2, since D is local-effect. The instantiation of the SSA from Dss with \u03b1 has the form\nF (x, do(A(c), s)) \u2194 (A(c) = A(x)) \u2227 P (x) \u2228 F (x, s)\nfor which equivalent rewriting wrt Duna gives\nF (x, do(A(c), s)) \u2194 (x = c) \u2227 P (x) \u2228 F (x, s)\nHence, we have \u2126(S0) = {F (c, S0)} and Dss[\u2126(S0)] = F (c, S\u03b1) \u2194 P (c) \u2228 F (c, S0). Since \u00acF (c, S0) \u2208 DS0 , the theory Dss[\u2126(S0)] \u222a DS0 is equivalent to {F (c, S\u03b1) \u2194 P (c)} \u222a DS0 . By Proposition 4.2, forgetting the ground atom F (c, S0) in this theory and substituting S0 with S\u03b1 gives the theory DS\u03b1 , the progression of DS0 wrt \u03b1. By using the definition of forgetting, it is easy to confirm that DS\u03b1 is equivalent to {F (c, S\u03b1) \u2194 P (c), \u2203xP (x)}. One can verify that DS\u03b1 (and also DS\u03b1(S0/S\u03b1)) is not \u2206\u2013decomposable theory, for any \u2206. Notice that decomposability is lost, because fluent F and predicate P from different components of DS0 become related to each other after progression.\nFor a signature \u2206, with S0 \u2208 \u2206, and an action A(c), we now give an example of a local-effect basic action theoryD withDS0 , an initial theory\u2206\u2013decomposable into finite\u2206\u2013inseparable components. This example shows that progressionDS\u03b1(S0/S\u03b1) ofDS0 wrtA(c) (with term S\u03b1 substituted with S0) is finitely axiomatizable and \u2206\u2013decomposable, but the decomposition components are no longer\u2206\u2013inseparable, unless we allow them to be infinite.\nExample 7 (\u2206\u2013inseparability is lost when fluents are in \u2206). Consider a basic action theory D with {F, P,R,A, b, c} \u2286 sig (D), where F is a fluent, P,R are predicates,A an action function, and b, c object constants. Let\u2206 = {F,R, S0, c} and define subtheories of D as follows:\nDss = {F (x, do(a, s)) \u2194 (a = A(x)) \u2227 P (x) \u2228 F (x, s)} (i.e. as in the previous example)\nDS0 = D1 \u222a D2,with\nD1 = {Taut(F,R, S0, b), \u00acF (c, S0)}, where Taut(F,R, S0, b, c) is a tautological formula in the signature {F,R, S0, b, c},which is uniform in S0\nD2 = {P (x) \u2192 \u2203y(R(x, y) \u2227 P (y)), \u00acF (c, S0)}.\nBy the syntactic form,DS0 is\u2206\u2013decomposable:we haveDS0 = D1\u222aD2, sig (D1)\u2229sig (D2) = \u2206, sig (D1) \\ \u2206 = {b}, and sig (D2) \\ \u2206 = {P}. It is also easy to confirm that D1 and D2 are \u2206\u2013inseparable.\nBy Proposition 4.2 it is easy to verify that the union of {Taut(F,R, S0, b, c)} and D\u20322 = (D2 \\ {\u00acF (c, S0)}) \u222a {\u03d5}, where \u03d5 = F (c, S\u03b1) \u2194 P (c) is a progression (DS\u03b1) of DS0 wrt \u03b1 = A(c).\nBy the syntactic form, DS\u03b1(S0/S\u03b1) is a \u2206\u2013decomposable theory. On the other hand, we have \u03d5 |= F (c, S\u03b1) \u2192 P (c), thus\nD\u20322(S0/S\u03b1) |= {F (c, S0) \u2192 \u2203yR(c, y) , F (c, S0) \u2192 \u2203y\u2203z[R(c, y) \u2227R(y, z)] , . . .}\nThis is an infinite set of formulas in signature \u2206. It follows from Fact 2.3 that this theory is not finitely axiomatizable by formulas of first-order logic in signature \u2206 and it is easy to verify that DS\u03b1(S0/S\u03b1) can not have a decomposition into finite \u2206\u2013inseparable components.\nNote that in the example above, the initial theory DS0 is in fact \u2205\u2013decomposable with one signature component equal to {b} and the other component containing the rest of the symbols. It is easy to see that the progression of DS0 wrt A(c) is \u2205\u2013decomposable as well. We use tautologies in the example just to illustrate the idea that information from SSA can propagate to the initial theory after progression, thus making the components lose the inseparability property. There is a plenty of freedom to formulate similar examples with the help of non-tautological formulas which syntactically \u201cbind\u201d symbols F,R, S0, b in the theory D1. We appeal to a similar observation in Example 8.\nExample 8 (Split of a component and loss of \u2206\u2013inseparability). Consider BAT D, with {F1, F2, D,B, P,R,A, c} \u2286 sig (D), where F1, F2 are fluents, D,B, P,R predicates, A an action function, and c an object constant. Let \u2206 = {D,R, S0} and define the subtheories of D as follows:\nDss = {F1(x, do(a, s)) \u2194 F1(x, s) \u2227 \u00ac(a = A(x)), F2(x, do(a, s)) \u2194 F2(x, s)}\nDS0 = D1 \u222a D2,where D1 is the set of formulas with occurrences ofD,R, S0:\nD(x) \u2228R(x, y) \u2192 F1(c, S0)\nD(x) \u2192 P (x)\nP (x) \u2192 \u2203y(R(x, y) \u2227 P (y))\nand D2 consists of the following three formulas (which also mentionD,R, S0):\nD(x) \u2192 B(x)\nB(x) \u2192 \u2203y(R(x, y) \u2227B(y))\nTaut(F2, S0), a tautology in the signature {F2, S0}, uniform in S0. Here, F2 is an auxiliary fluent introduced to have an occurrence of S0 in D2.\nBy definition, DS0 is \u2206\u2013decomposable into \u2206\u2013inseparable components D1 and D2. Note that Dss |= \u00acF1(c, do(A(c), S0)), which is the result of substitution of the ground actionA(c), situation constant S0, and object constant c in SSA.\nConsider progression of DS0 wrt the action \u03b1 = A(c). By Proposition 4.2, it is equivalent to the theory DS\u03b1 = D \u2032 1 \u222a D \u2032\u2032 1 \u222a D \u2032 2, where D \u2032 1 is the set of the following formulas:\n\u00acF1(c, do(A(c), S0))\nTaut(D,R), a tautological formula in the signature {D,R} which is uniform in S\u03b1,\nD\u2032\u20321 is the set of formulas:\nD(x) \u2192 P (x)\nP (x) \u2192 \u2203y(R(x, y) \u2227 P (y))\nTaut(F2, S\u03b1), a tautological formula in the signature {F2, do, A, c, S0} which is uniform in S\u03b1\nand D\u20322 is the theory D2 with every occurrence of S0 substituted with S\u03b1.\nClearly, DS\u03b1(S0/S\u03b1) is \u2206\u2013decomposable. Note that after progression the component D1 is \u201csplit\u201d intoD\u20321(S0/S\u03b1) andD \u2032\u2032 1 (S0/S\u03b1) and these theories are not\u2206\u2013inseparable (similarly,D \u2032 1(S0/S\u03b1) and D\u20322(S0/S\u03b1)). By Fact 2.3, it can be shown that they can not be made \u2206\u2013inseparable while remaining finitely axiomatizable.\nTo formulate the theorems below, we let D denote a BAT with the initial theory DS0 , the set of successor state axioms Dss, and the unique name axioms Duna. Example 7 has resulted in the following definition.\nDefinition 4.3 (Fluent\u2013free signature) A signature \u2206 is called fluent\u2013free if no fluent (from the alphabet of situation calculus) is contained in\u2206.\nTheorem 4.2 complements Examples 4.3 and 4.4, which identify properties of decomposed actions theories causing loss of inseparability of components after progression. The theorem shows that if these properties are absent then inseparability is preserved. As we have already seen in Example 7, the initial theory and progression may differ in consequences involving symbols of fluents. Thus in general, preservation of \u2206\u2013inseparability can be guaranteed only for fluent-free signatures \u2206, which is reflected in the conditions of the theorem. Besides, by the model-theoretic Definition 4.1, progression is not uniquely defined \u2013 there is no restriction on occurrences of the unique name axioms in progression, which may easily lead to loss of inseparability of the components. In other words, progression may logically imply unique name axioms even if the initial theory did not imply them. Some decomposition components of progression may imply such formulas, while the others may not. For this reason, we speak of inseparability \u201cmodulo\u201d theory Duna in the first point of the theorem below. In particular, we have to make the assumption that not only the components {Di}i\u2208I\u2286\u03c9 of the initial theory are pairwise\u2206\u2013inseparable, but so are the theories {Duna\u222aDi}i\u2208I .\nFor fluent-free deltas, the progression entails exactly those \u2206-formulas, which are entailed already by the initial theory (together with UNA-axioms), and the question is how these formulas can be \u201cdistributed\u201d between the components. The second point of the theorem rules out the case (described in Example 8), when \u2206-consequences are split between the components of progression. Note that in the theorem we do not specify how the progression was obtained (cf. Theorem 4.5) and the only condition that relates the components of progression with those of the initial theory says about containment of\u2206\u2013consequences.\nTheorem 4.4 (Preservation of\u2206-insep. for fluent-free\u2206) Let L have PIP and D be a BAT in which DS0 and Duna are theories in L. Let \u03c3 \u2286 sig (DS0) be a fluent\u2013free signature and denote \u2206 = sig (Duna) \u222a \u03c3. Suppose the following:\n\u2013 DS0 is \u03c3\u2013decomposable with some components {Di}i\u2208I\u2286\u03c9 such that the theories from {Duna\u222a Di}i\u2208I are pairwise \u2206\u2013inseparable; \u2013 DS\u03b1(S0/S\u03b1) is equivalent to the union of theories {D \u2032 j}j\u2208J\u2286\u03c9 such that for every j \u2208 J and\nsome i \u2208 I , Cons (Duna \u222aD\u2032j, \u2206) \u2287 Cons (Duna \u222aDi, \u2206).\nThen the theories from {Duna \u222aD\u2032j}j\u2208J\u2286\u03c9 are pairwise \u2206\u2013inseparable.\nProof. Let us demonstrate that for all j \u2208 J we have Cons (Duna \u222a D\u2032j , \u2206) = Cons (Duna \u222a DS0 , \u2206), from which the statement of the theorem obviously follows. Essentially, we prove the following inclusions (the corresponding points of the proof are marked with circles):\nCons (Duna \u222a DS\u03b1(S0/S\u03b1),\u2206) \u2286 Cons (Duna \u222a DS\u03b1 ,\u2206) \u2286 Cons (Duna \u222a DS0 ,\u2206)\n\u27652\u27653\n\u27651\n\u2286\n\u2287 \u27654\nTheorem conditions\n\u2286\u27654 Theorem conditions\nCons (Duna \u222a Di,\u2206)Cons (Duna \u222a D \u2032 j ,\u2206)\n1) Note that for any i \u2208 I , DS0 is \u03c3\u2013decomposable with componentsDi and \u22c3 k\u2208I\\{i}Dk. We\nclaim thatDuna\u222aDi andDuna\u222a \u22c3 k\u2208I\\{i}Dk are\u2206\u2013inseparable. Let\u03d5 be a formula in signature\u2206.\nIf Duna \u222aDi |= \u03d5 then clearly, Duna \u222a \u22c3 k\u2208I\\{i}Dk |= \u03d5 by \u2206\u2013inseparability from the condition\nof the theorem. On the other hand, if Duna \u222a \u22c3\nk\u2208I\\{i}Dk |= \u03d5 then by PIP we have Tuna \u222a\u22c3 k\u2208I\\{i} Tk |= \u03d5, where Duna |= Tuna, sig (Tuna) \u2286 sig (Duna) and Dk |= Tk for k \u2208 I \\ {i}, sig (Tk) \u2286 \u2206. Again, by\u2206\u2013inseparability, for each k \u2208 I \\ {i}we haveDuna \u222aDi |= Tk and thus, Duna \u222aDi |= \u03d5.\nTherefore, if \u03d5 \u2208 Cons (Duna\u222aDS0 , \u2206), then for every i \u2208 I , [Duna\u222a \u22c3 k\u2208I\\{i}Dk] \u222a [Duna\u222a\nDi] |= \u03d5 and then by PIP and inseparability shown above, Duna \u222aDi |= \u03d5. Since DS0 |= \u22c3\ni\u2208I Di by decomposability, we obtain Cons (Duna \u222a DS0 , \u2206) = Cons (Duna \u222aDi, \u2206) for all i \u2208 I .\n2) Let us show that Cons (Duna \u222aDS\u03b1 , \u2206) \u2286 Cons (Duna \u222aDS0 , \u2206). First, take a formula \u03c8 \u2208 Cons (Duna \u222a DS\u03b1 , \u2206), which does not contain situation terms. From the definition of progression, every model of D is a model of Duna \u222a DS\u03b1 , so D |= Duna \u222a DS\u03b1 and hence, D |= \u03c8. If Duna \u222a DS0 6|= \u03c8, then Duna \u222a DS0 \u222a {\u00ac\u03c8} is satisfiable and since \u03c8 is a uniform formula, by Proposition 2.10, D \u222a {\u00ac\u03c8} is satisfiable, which contradictsD |= \u03c8. Therefore,Duna \u222a DS0 |= \u03c8.\nIt remains to verify that the set Cons (Duna \u222a DS\u03b1 , \u2206) is axiomatized by sentences which do not contain situation terms. We have \u2206 = sig (Duna) \u222a \u03c3 \u2286 sig (Duna) \u222a sig (DS0), so {do, , Poss}\u2229\u2206 = \u2205, by definition ofDuna andDS0 . As \u03c3 if fluent-free by the condition of the theorem (and sig (Duna) is fluent-free by definition of BAT ), \u2206 may contain only situation\u2013independent predicates and functions. Thus, any formula\u03d5 \u2208 Cons (Duna\u222aDS\u03b1 , \u2206)may contain situation terms only in equalities, where each term is either the constant S0 (in case S0 \u2208 \u03c3) or a bound variable of sort situation. Suppose that this is the case and there is no \u03c8 \u2208 Cons (Duna \u222a DS\u03b1 , \u2206) such that \u03c8 |= \u03d5 and \u03c8 does not contain situation terms. By the syntax of Lsc and the choice of\u2206, then \u03d5 is a boolean combination of formulas without situation terms and sentences over signature {S0} stating that \u03d5 has a model with cardinality |Sit| of sort situation lying in the interval [n,m] for n \u2208 \u03c9 and m \u2208 \u03c9 \u222a {\u221e}. We denote sentences of this form by \u2203[n,m]\u03b8=. We may assume that \u03d5 is in conjunctive normal form and that there is a formula \u03be, a boolean combination of \u2203[n,m]\u03b8= such that 6|= \u03be, 6|= \u00ac\u03be, either \u03be or \u03be \u2228 \u03b7 is a conjunct of \u03d5, and \u03b7 6\u2208 Cons (Duna \u222a DS\u03b1 , \u2206), sig (\u03b7) \u2286 \u2206, is\na formula without situation terms. As 6|= \u03be and 6|= \u00ac\u03be, there are n,m \u2208 \u03c9 such that \u03be does not have a model with |Sit| = n and \u00ac\u03be does not have a model with |Sit| = m. Then by Lemma 2.8, we conclude thatDuna\u222aDS\u03b1 6|= \u03be andDuna\u222aDS\u03b1 6|= \u00ac\u03be. In particular, \u03be can not be a conjunct of \u03d5. If \u03be\u2228\u03b7 is a conjunct, then there exists a modelM ofDuna\u222aDS\u03b1 such thatM |= \u03be andM 6|= \u03b7. Then, by applying Lemma 2.8 again, there must be a modelM\u2032 of Duna \u222aDS\u03b1 with |Sit| = n where the interpretation of situation\u2013independent predicates and functions is the same as inM. Thus,M\u2032 6|= \u03be and since \u03b7 does not contain situation terms,M\u2032 6|= \u03b7, which contradictsDuna \u222a DS\u03b1 |= \u03d5.\n3) Now let us demonstrate that Cons (Duna \u222a DS\u03b1(S0/S\u03b1), \u2206) \u2286 Cons (Duna \u222a DS\u03b1 , \u2206). Note that Duna \u222a DS\u03b1(S0/S\u03b1) is uniform in S0. Following the above proved, assume that there is a formula \u03d5 \u2208 Cons (Duna \u222a DS\u03b1(S0/S\u03b1), \u2206) such that \u03d5 does not contain situation terms and Duna \u222aDS\u03b1 6|= \u03d5. Take a modelM of Duna \u222aDS\u03b1 such thatM 6|= \u03d5. Then, by Lemma 2.8, there exists a modelM\u2032 ofDuna\u222aDS\u03b1 such that the domain for sort situation inM\n\u2032 is a singleton set (i.e., the interpretation of terms S0 and S\u03b1 coincide inM\u2032) and the interpretation of situation\u2013independent symbols is the same in M and M\u2032. ThenM\u2032 6|= \u03d5, but clearly M\u2032 |= Duna \u222a DS\u03b1(S0/S\u03b1) which contradicts the assumption Duna \u222aDS\u03b1 6|= \u03d5.\n4) Finally, by the condition of the theorem, for all j \u2208 J , we have Duna \u222a D\u2032j \u2286 Duna \u222a DS\u03b1 (S0/S\u03b1) and from points 1\u20133 above we obtain Cons (Duna \u222a DS\u03b1(S0/S\u03b1), \u2206) \u2286 Cons (Duna \u222a DS0 , \u2206). Hence, for all j \u2208 J we have Cons (Duna \u222a D \u2032 j , \u2206) \u2286 Cons (Duna \u222a DS0 , \u2206). On the other hand, we also have Cons (Duna \u222a Di, \u2206) \u2286 Cons (Duna \u222a D\u2032j, \u2206) from the condition of the theorem. Therefore from the inclusion \u2200 i \u2208 I Cons (Duna \u222a DS0 , \u2206) \u2286 Cons (Duna \u222aDi, \u2206) of point 1 we conclude that Cons (Duna \u222aD\u2032j, \u2206) = Cons (Duna \u222a DS0 , \u2206) for all j \u2208 J .\nThe next theorem provides a result on local-effect BAT s with initial theories in first-order logic for which progression becomes more concrete, since it can be computed by syntactic manipulations. In contrast to Theorem 4.4, this allows us to judge about inseparability without the theory Duna in background. Recall that, in general, a BAT includes non-trivial precondition axioms. On the righthand side of each precondition axiom, there is a formula\u03a0A(x\u0304, s) that is a formula uniform in swith free variables among x\u0304 and s. However, any BAT can be transformed into an action theory without precondition axioms by introducing the right hand side formulas from the precondition axioms as conjuncts of context conditions for each corresponding active position of an action term in a SSA. Therefore, without loss of generality, and for simplicity of presentation, we subsequently consider the BAT s where all precondition axioms are trivial.\nEssentially, the conditions of the theorem are defined to guarantee componentwise computation of progression for a decomposable initial theory. A finite set Dss of the SSAs is considered to be syntactically divided into the union of |I| sub-theories sharing some fluent-free signature\u22061 (which may include actions, static predicates, and object constants), as well as function do (which occurs in every SSA). Informally, each of |I| sub-theories is about a different set of properties, e.g., one of them could be about the blocks world, while another could be about the logistics world, with the two theories possibly sharing some constants, such as a box name, and situation-independent predicates, such as shapes of the boxes. The initial theory DS0 is\u22062\u2013decomposable, for a fluent-free signature \u22062, into |J | components. To distinguish visually componentsD\u2032j ofDS0 from the componentsDi of Dss, we write D\u2032j with apostrophe when we mean components of DS0 , and Di without apostrophe when we mean groups of SSAs. Informally, each component D\u2032j is about a separate aspect of the initial theory. The syntactic form of the initial theory may not reveal the components readily, but they can be discovered through decomposition. Naturally, it is expected that independent components of\nthe initial theory should remain independent after doing any actions. This imposes a condition that each component from the initial theory should be related with its own group of SSAs.\nThe last two conditions of the theorem enforce that the subtheories of Dss are aligned with the components ofDS0 via syntactic occurrences of fluents. The second to last condition says that every fluent mentioned in a SSA must also occur in the initial theory DS0 . It is easy to satisfy by adding tautologies with the corresponding fluents to DS0 . Together with the last condition it guarantees that for every SSA \u03d5 containing fluents F1, . . . , Fn there is a corresponding component of DS0 , which describes the initial interpretation of these fluents, and this is the component that must be updated upon executing an action mentioned in active position of \u03d5. The last condition also enforces that actions, static predicates, or object constants separated by the decomposition of DS0 must be also separated by the subtheories of Dss, whenever they occur in SSAs. This guarantees that these symbols do not become connected after progression (as opposed to the situation presented in Example 6). Thus, the theory Dss \u222a DS0 can be divided into parts (consisting of successor-state axioms and statements about the initial situation) which may mention common actions, static predicates and constants, but talk about different fluents. In other words, these subtheories define independent sets of situation-related properties, which is natural for a composite action theory describing a single domain of objects from a number of different perspectives. Note that it is allowed for a single action to have effects on groups of fluents (possibly, all the fluents at once, without regard to distribution of the fluents between the subtheories), which is reflected in the theorem condition that \u22061 is just fluent-free, but not action free. We impose stronger restriction in Corollary 4.6, which describes a class of BAT s representing composite subject domains, like the one mentioned in the running example from Section 2.3.\nFor the reader\u2019s convenience, we stress that in the formulation of the theorem, the indices i and j vary over components of Dss and DS0 , respectively. The signatures \u22061 and \u22062 are the sets of allowed common symbols between the components of Dss and DS0 , respectively. We recall that A (F , respectively) denotes the set of action functions (the set of fluents, respectively) from the alphabet of the language of the situation calculus.\nTheorem 4.5 (Preservation of components in local-effect BAT ) Let D be a local-effect BAT , with DS0 an initial theory in first-order logic. Let \u22061, \u22062 be fluent-free signatures, do 6\u2208 \u22061, \u22062, and \u03b1 = A(c\u0304) a ground action term. Denote\u2206 = \u22061 \u222a\u22062 \u222a {c1, . . . , ck}, if c\u0304 = \u3008c1, . . . , ck\u3009, and suppose the following:\n\u2013 Dss is the union of theories {Di}i\u2208I , with sig (Dn) \u2229 sig (Dm) \u2286 \u22061 \u222a {do} for all n,m \u2208 I 6= \u2205, n 6= m; \u2013 DS0 is \u22062\u2013decomposable into finite components {D \u2032 j}j\u2208J uniform in S0 such that sig (D \u2032 j) \\\n\u2206 6= \u2205, for all j \u2208 J; \u2013 sig (Dss) \u2229 F \u2286 sig (DS0); \u2013 for every i \u2208 I , there is j \u2208 J such that sig (Di) \u2229 sig (DS0) \u2286 sig (D \u2032 j).\nThenDS\u03b1(S0/S\u03b1) is\u2206\u2013decomposable. If the components {D \u2032 j}j\u2208J are pairwise\u2206\u2013inseparable,\nthen so are the components of DS\u03b1(S0/S\u03b1) in the corresponding decomposition.\nProof. The proof consists of two parts, both of which rely on the constructive definition of progression for local-effect BAT s from Section 4 and component properties of forgetting discussed in Section 3. In the first part, we show\u2206-decomposability ofDS\u03b1(S0/S\u03b1) by constructing its components explicitly and in the second part we prove that these components are \u2206-inseparable.\n1) By definition of BAT , for every i \u2208 I , we have sig (Di) \u2229 F 6= \u2205 and thus, from the conditions of the theorem, sig (Di) \u2229 sig (DS0) 6= \u2205, sig (Dss) \u2229 F = sig (DS0) \u2229 F . Hence, for every i \u2208 I there is j \u2208 J such that sig (Di) \u2229 F \u2286 sig (D\u2032j). Moreover, such j \u2208 J is unique for every i \u2208 I , because otherwise there would exist n,m \u2208 J , n 6= m, such that sig (D\u2032n) \u2229 sig (D\u2032m)\u2229F 6= \u2205, which contradicts the condition that\u22062 is fluent-free. Therefore, there is a map f : I \u2192 J such that for every i \u2208 I , sig (Di) \u2229 F \u2286 sig (D\u2032f(i)). Note that there may exist j \u2208 J such that sig (D\u2032j) \u2229 F = \u2205 and in this case j is the image of no i \u2208 I . Let us denote the image of f by J\u0303 (so, J\u0303 \u2286 J). Now, for every i \u2208 I , consider the set of formulas Di[\u2126], the instantiation of Di w.r.t. \u2126(S0), and for each j \u2208 J\u0303 , denote D\u0303j = [ \u22c3 i\u2208f\u22121(j)(Di[\u2126]) ]\u222aD \u2032 j . Then, by Proposition 4.2,DS\u03b1(S0/S\u03b1) (progression of DS0 wrt \u03b1, with term S\u03b1 substituted with S0) is logically equivalent to\n[ forget ( \u22c3\nj\u2208J\u0303\nD\u0303j , \u2126(S0)) \u222a \u22c3\nj\u2208J\\J\u0303\nD\u2032j ] (S0/S\u03b1).\nAs \u22061 and \u22062 are fluent-free, the signatures {sig (D\u0303j)}j\u2208J\u0303 do not have fluents in common and thus, by Corollary 3.10, DS\u03b1(S0/S\u03b1) is equivalent to\n[ \u22c3\nj\u2208J\u0303\nforget (D\u0303j , \u2126(S0) |j) \u222a \u22c3\nj\u2208J\\J\u0303\nD\u2032j ] (S0/S\u03b1),\nwhere for j \u2208 J\u0303 , \u2126(S0) |j is the subset of ground atoms from \u2126(S0) with fluents from sig (D\u2032j). For all j \u2208 J \\ J\u0303 , we have sig (D\u2032j) \u2229 F = \u2205 and D \u2032 j is uniform in S0, so it follows that S0 6\u2208 sig (D\u2032j) and thus, DS\u03b1(S0/S\u03b1) is equivalent to the union\n[ \u22c3\nj\u2208J\u0303\nforget (D\u0303j , \u2126(S0) |j) ] (S0/S\u03b1) \u222a \u22c3\nj\u2208J\\J\u0303\nD\u2032j.\nFor every j \u2208 J , let D\u2032\u2032j be the set of formulas (forget (D\u0303j , \u2126(S0) |j))(S0/S\u03b1) (in case j \u2208 J\u0303) or the set of formulas D\u2032j (if j \u2208 J \\ J\u0303). So DS\u03b1(S0/S\u03b1) is equivalent to \u22c3 j\u2208J D \u2032\u2032 j . By the definition of forgetting a set of ground atoms one can assume that sig (D\u2032j) \u2286 sig (D \u2032\u2032 j ) and sig (D \u2032\u2032 j ) \\ sig (D\u2032j) \u2286 sig (Dss) \u222a {c1, . . . , ck}, for all j \u2208 J . Let us show that [sig (D\u2032\u2032i )\u2229 sig (D \u2032\u2032 j )] \u2286 \u2206, for all distinct i, j \u2208 J . Assume there are distinct i, j \u2208 J such that [sig (D\u2032\u2032i ) \u2229 sig (D \u2032\u2032 j )] \\ \u2206 = \u03a3 6= \u2205, for a signature \u03a3. Then do 6\u2208 \u03a3, since both D\u2032\u2032i and D \u2032\u2032 j are uniform in S0. If there is a single subtheory Dm of Dss, m \u2208 I , such that \u03a3 \u2286 sig (Dm), then the last two conditions of the theorem yield\u03a3 \u2286 \u22062, which is a contradiction, because we have assumed \u03a3 \u2229\u2206 = \u2205. If there are distinct subtheoriesDm andDn of Dss,m,n \u2208 I , such that \u03a3 \u2286 sig (Dm) \u2229 sig (Dn), then \u03a3 \u2286 \u22061, and we again arrive at contradiction.\nIt follows that the pairwise intersection of any signatures from {sig (D\u2032\u2032j )}j\u2208J is a subset of \u2206 and it follows from the second condition of the theorem that sig (D\u2032\u2032j ) \\ \u2206 6= \u2205. Then {D \u2032\u2032 j \u222a Taut(\u2206, j)}j\u2208J is\u2206\u2013decomposition of DS\u03b1(S0/S\u03b1), where for each j \u2208 J , Taut(\u2206, j) is a set of tautologies in signature\u2206 \\ sig (D\u2032\u2032j ) which are uniform in S0.\n2) Now let us verify that the sets of formulas from {D\u2032\u2032j }j\u2208J are pairwise \u2206\u2013inseparable, if so are the components of DS0 .\na) First, consider the sets from the union\n\u22c3\nj\u2208J\u0303\nD\u0303j \u222a \u22c3\nj\u2208J\\J\u0303\nD\u2032j . (\u2021)\nThe pairwise intersection of their signatures is contained in \u2206 \u222a sig (S\u03b1). We claim that the sets from this union are pairwise\u2206\u2013inseparable.\nBy our definition, for all j \u2208 J\u0303 we have D\u2032j \u2286 D\u0303j and hence, Cons (D \u2032 j , \u2206) \u2286 Cons (D\u0303j , \u2206), so let us check that Cons (D\u0303j , \u2206) \u2286 Cons (D\u2032j , \u2206) for every j \u2208 J\u0303 . Each formula in Di[\u2126], for i \u2208 f\u22121(j), j \u2208 J\u0303 , has the form\nF (c\u0304, do(A(c1, . . . , ck), S0)) \u2194 (\u03b51 \u2227 \u03c6 +) \u2228 (F (c\u0304, S0) \u2227 \u03b52 \u2227 \u03c6 \u2212), (\u2217)\nwhere F is a fluent from sig (D\u2032j), c\u0304 is a vector of constants from {c1, . . . , ck}, \u03c6 +, \u03c6\u2212 are sentences uniform in S0, and each \u03b51, \u03b52 equals true or false (the parameters to summarize different cases of this formula). This is a definition of ground atom F (c\u0304, do(A(c1, . . . , ck), S0) via fluents at situation S0 and situation-independent predicates and functions. Therefore, since \u2206 is fluent-free and for all j \u2208 J\u0303 , D\u2032j is uniform in S0, every model M of D \u2032 j can be transformed into a model M\n\u2032 of D\u0303j which agrees with M on \u2206. The model M\u2032 is obtained in two steps. First, we expand M with an arbitrary interpretation of function do and situation-independent predicates and functions from sig (Di[\u2126]) \\ sig (D\u2032j) for every i \u2208 f\n\u22121(j). Then we continue with this expanded model and modify the truth value of each fluent F at the interpretation of the tuple \u3008c\u0304, do(A(c1, . . . , ck), S0)\u3009 according to the obtained truth value of the formula in the definition of F (c\u0304, do(A(c1, . . . , ck), S0) above. This gives us the modelM\u2032. Hence, if \u03d5 \u2208 Cons (D\u0303j , \u2206) and \u03d5 6\u2208 Cons (D\u2032j , \u2206), then there is a modelM ofD\u2032j such thatM 6|= \u03d5, but thenM \u2032 |= D\u0303j andM\u2032 6|= \u03d5, a contradiction. Therefore, we conclude that for all j \u2208 J\u0303 , Cons (D\u0303j , \u2206) = Cons (D\u2032j , \u2206) and, by pairwise\u2206\u2013inseparability of the components of DS0 , the sets from the union (\u2021) are \u2206\u2013inseparable.\nb) Since \u2206 is fluent-free and \u2126(S0) consists only of ground atoms with fluents, from Corollary 3.10 we conclude that the sets from the following union are\u2206\u2013inseparable:\n\u22c3\nj\u2208J\u0303\nforget (D\u0303j , \u2126(S0) |j) \u222a \u22c3\nj\u2208J\\J\u0303\nD\u2032j .\nNow we are ready to prove that the sets from {D\u2032\u2032j }j\u2208J are pairwise \u2206\u2013inseparable. For every j \u2208 J\u0303 , let us denote Gj = forget (D\u0303j , \u2126(S0) |j). We will demonstrate that for every j \u2208 J\u0303 it holds Cons (Gj(S0/S\u03b1), \u2206) = Cons (Gj , \u2206), from which the statement follows. First, let us verify that Cons (Gj (S0/S\u03b1), \u2206) \u2286 Cons (Gj , \u2206). Assume that for some j \u2208 J\u0303 (we fix this j for the following) there is a formula \u03d5 \u2208 Cons (Gj(S0/S\u03b1), \u2206) and a model M of Gj such that M 6|= \u03d5, and arrive at contradiction.\nBy the syntactic definition of forgetting a ground atom, the term S\u03b1 occurs in Gj only in subformulas obtained from the definitions (\u2217), so let us consider such a definition for a ground atom F (c\u0304, S\u03b1) with some fluent F . Let us recall that Gj is the result of forgetting a set of ground atoms with fluents having S0 as situation argument. Since c\u0304 is the vector of object arguments in the definition of F (c\u0304, S\u03b1) in (\u2217), we have F (c\u0304, S0) \u2208 \u2126(S0) |j . Therefore, ifM |= \u03b5F (c\u0304, S0) (\u03b5 denotes the optional negation in front of atom), then there is a model M\u2032 |= \u00ac\u03b5F (c\u0304, S0) such that M\u2032 \u223c\u03c3 M,\nwith \u03c3 = F (c\u0304, S0), and hence, M\u2032 6|= \u03d5 (since \u2206 is fluent\u2013free) and the truth value of F (c\u0304, S\u03b1) in M and M\u2032 is the same. Hence, either in M or M\u2032 the truth values of F (c\u0304, S\u03b1) and F (c\u0304, S0) coincide. The similar argument applies to the whole set of definitions (\u2217) from D\u0303j under forgetting the set \u2126(S0) |j . Therefore we may assume that in M or M\u2032, for each fluent F \u2208 sig (Gj) the values of F (c\u0304, S\u03b1) and F (c\u0304, S0) coincide. So M |= Gj(S0/S\u03b1) or M\u2032 |= Gj(S0/S\u03b1) which is a contradiction, because \u03d5 holds in neither of these models.\nTo prove the reverse inclusion Cons (Gj , \u2206) \u2286 Cons (Gj(S0/S\u03b1), \u2206), observe thatGj(S0/S\u03b1) is uniform in S0. Hence, by an observation similar to Lemma 2.8, every model M of Gj(S0/S\u03b1) can be expanded to a model M\u2032, where the interpretation of function do is such that the values of terms S\u03b1 and S0 in M\u2032 coincide. ThenM\u2032 |= Gj and thus, there is no formula \u03d5 \u2208 Cons (Gj , \u2206) such that \u03d5 6\u2208 Cons (Gj(S0/S\u03b1), \u2206).\nWe note that a result similar to Theorem 4.5 can be proved in a more general case, for progression of not-necessarily local-effect BAT s, by considering progression as a set of consequences of Duna \u222a Dss \u222a DS0 uniform in S\u03b1 or using the second-order definition of progression from Theorem 2.10 in [27]. Since both definitions of progression are non-constructive, one would have to deal with background theories such as Duna, when reasoning about decomposition of the initial theory. Although it would be possible to define a more general notion of decomposability wrt a background theory by following this direction, this study would take us too far away from the goals of this paper, and it would not be illuminating.\nThe proof of the theorem uses Proposition 4.2 and the component properties of forgetting from Section 3. The important observation behind this result is that in order to compute progression of an initial theory wrt an action having effects only on fluents from one decomposition component, it suffices to compute forgetting only in this component. Given a decomposition of the initial theory into inseparable components, the rest of the conditions in the theorem are purely syntactical and easy to check. For example, these conditions would naturally hold if one merges weakly-related action theories, as illustrated in the running example (continued below). SSAs can be grouped into |I| components by drawing a graph with fluent names as vertices, and an edge from the fluent on the left-hand side of each SSA going to each fluent occurring on the right-hand side of the same SSA. Similarly, it is easy to check the last condition of the Theorem that guarantees alignment of groups of axioms in SSAs with decomposition components of DS0 .\nIn the above conditions, observe that if an action A occurs in active position of SSAs from two different sub-theories of Dss, then computing progression may involve forgetting in two corresponding components of DS0 . This can potentially lead to appearance of new common\u22061\u2013symbols in the components of progression. As a consequence, \u22062\u2013decomposability of progression may be destroyed, but it is desirable to preserve it. A practically important class of BAT s, for which this interference can be avoided, is described in the corollary below. Note the first condition in the corollary that every action mentioned in BAT can have effects on fluents only from one component of Dss. Together with the second condition this guarantees preservation of \u22062-decomposability and inseparability of the initial theory after progression. The third condition in the corollary guarantees preservation of all the conditions of Theorem 4.5 for the BAT obtained after progression and thus, one can compute progression for arbitrary long sequences of actions while preserving decomposability of DS\u03b1(S0/S\u03b1) and inseparability of its components.\nCorollary 4.6 (Strong preservation of components in local-effect BAT s) In the conditions and notations of Theorem 4.5, let \u03b1 = A(c\u0304) be a ground action term, where c\u0304 = \u3008c1, . . . , ck\u3009 is a tuple of constants, and let the following conditions hold:\n\u2013 no action function is in\u22061; \u2013 {c1, . . . , ck} \u2286 sig (D\u2032j), for some j \u2208 J , whenever A is in active position in a SSA for a fluent F \u2208 sig (D\u2032j); \u2013 it holds that\u22061 \u2286 \u22062.\nThen DS\u03b1(S0/S\u03b1) is \u22062\u2013decomposable into \u22062\u2013inseparable components. Moreover, all the conditions of Theorem 4.5 hold for the BAT with the initial theory DS\u03b1(S0/S\u03b1) obtained after progression.\nProof. By the first condition, action A can be in active position of SSAs of a single subtheoryDi of Dss. Then, due to the componentwise computation of progression shown in the proof of Theorem 4.5, progression can affect the single corresponding componentD\u2032f(i) of DS0 . The second condition of the corollary guarantees that {c1, . . . , ck} \u2286 sig (D\u2032f(i)) and together with the third condition this yields that DS\u03b1(S0/S\u03b1) is \u22062\u2013decomposable into \u22062\u2013inseparable components, just like DS0 is.\nComputing the progression of DS0 wrt \u03b1 is essentially a syntactic modification of D \u2032 f(i) which may introduce signature symbols from context conditions of Di only into D\u2032f(i) and into no other components of DS0 . Denote byD \u2032\u2032 f(i) the theory obtained fromD \u2032 f(i) in this way.\nLet us verify that all the conditions of Theorem 4.5 are preserved for the BAT with the initial theory DS\u03b1(S0/S\u03b1) obtained after progression. The first condition of the theorem holds by default. By the definition of forgetting ground atoms, one can assume that sig (D\u2032f(i)) \u2286 sig (D \u2032\u2032 f(i)). Since DS\u03b1(S0/S\u03b1) is\u22062\u2013decomposable and, by the definition ofDS\u03b1(S0/S\u03b1), all the components ofDS0 except D\u2032\nf(i) remain unchanged after progression, the second and third conditions of the theorem hold. To show the last condition suppose the opposite, i.e. there is k \u2208 I , for which the condition does not hold. Then k 6= i, since sig (D\u2032\nf(i)) \u2286 sig (D \u2032\u2032 f(i)), and there is a subsignature \u03a3 \u2286\nsig (D\u2032\u2032 f(i)) \\ sig (D \u2032 f(i)) such that \u03a3 \u2286 sig (Dk). By the definition ofD \u2032\u2032 f(i), we may assume that \u03a3 \u2286 sig (Di). As DS\u03b1(S0/S\u03b1) is a set of formulas uniform in S0, we have do 6\u2208 \u03a3 and thus, \u03a3 \u2286 \u22061 \u2286 \u22062. Let D\u2032j be the component of DS0 , for which the condition sig (Dk) \u2229 DS0 \u2286 sig (D \u2032 j) holds. Since \u03a3 \u2286 \u22062 and DS0 is \u22062\u2013decomposable, we have \u03a3 \u2286 sig (D \u2032 j) and thus D \u2032 j is the required component forDk, a contradiction.\nExample 2 (continuation). Note that theBAT considered in the example satisfies the conditions of the corollary with fluent-free signatures\u22061=\u2205 and\u22062={Block, S0}. The theoryDss is a union of two theories, with the intersection of signatures equal to {do}. As already noted in the example, the initial theory DS0 is \u22062\u2013decomposable into \u22062\u2013inseparable components. Now, consider the ground action \u03b1=move(A,B,C). By Corollary 3.10 and Proposition 4.2, in order to compute the theoryDS\u03b1(S0/S\u03b1) (the progression ofDS0 wrt \u03b1, with the term S\u03b1 substituted with S0), it suffices to forget the ground atomsOn(A,B, S0) andClear(C, S0) in the first decomposition component of DS0 and update it with the ground atoms On(A,C, S0) and Clear(B,S0). The second component of DS0 remains unchanged. One can check that DS\u03b1(S0/S\u03b1) is the union of the following theories:\n\u03d5 \u2227 \u03c8 \u2227 (x 6= C) \u2192 Clear(x, S0) \u03c8 \u2192 Block(x) Block(B)\u2227Block(C)\u2227On(A,C,S0)\u2227 \u00acOn(A,B,S0) Clear(A,S0) \u2227Clear(B,S0) \u2227 \u00acClear(C, S0)\nand\n(Top(x, S0) \u2228 Inheap(x, S0)) \u2192 \u00acBlock(x) \u2203x Block(x),\nwhere \u03d5 and \u03c8, respectively, stand for\n(x 6= B) \u2227 \u00ac\u2203y ((y 6= A \u2228 x 6= B) \u2227On(y, x, S0)), (x = A) \u2228 \u2203y ((x 6= A \u2228B 6= y) \u2227On(x, y, S0)).\nThe theoryDS\u03b1(S0/S\u03b1) is\u22062\u2013decomposable by the syntactic form and there is no need to compute a decomposition again after progression. Corollary 4.6 guarantees that the obtained components are \u22062\u2013inseparable. It is important that in this case we can compute progression for arbitrary long sequences of actions while preserving both decomposability of DS\u03b1(S0/S\u03b1) and inseparability of its components."}, {"heading": "5 Summary and Future Work", "text": "We have considered the impact of the theory update operations, such as forgetting and progression on preserving the component properties of theories, such as decomposability and inseparability. Forgetting and progression have a \u201csemantic nature\u201d, since the input and the output of these transformations are related to each other by using restrictions on the classes of models. On the contrary, the decomposability and inseparability properties are defined using entailment in a particular logic. As logics (weaker than second-order) may not distinguish the needed classes of models, the conceptual \u201cdistance\u201d between these two kinds of notions is potentially immense. This can be somewhat bridged by the choice of either an appropriate logic, or appropriate theories in the input. We have identified conditions that should be imposed on the components of input theories to match these notions more closely. Also, the Parallel Interpolation Property (PIP) was shown to be a relevant property of logics in our investigations. The results can be briefly summarized in the tables below. For brevity, we use \u03c3 to denote a signature or a ground atom.We slightly abuse notation and consider \u03c3 as a set of symbols even in the case of a ground atom implying that in the latter case \u03c3 consists of the single predicate symbol from the atom. We assume that the input of operations of forgetting and progression is a union of theories T1 and T2, with sig (T1) \u2229 sig (T2) = \u2206, for a signature\u2206.\nProperty Condition Result Reference\nPreservation of \u2206\u2013inseparability of T1 and T2 under forgetting \u03c3\n\u03c3 \u2229\u2206 = \u2205 YES Corollary 3.10 \u03c3 \u2286 \u2206 and \u03c3 is a ground atom NO Example 4 \u03c3 \u2286 \u2206 and \u03c3 is a signature YES, if logic has PIP Proposition 3.7 \u03c3 \u2286 \u2206 and T1, T2 are semantically inseparable YES Proposition 3.8\nDistributivity of forgetting \u03c3 over union of T1 and T2\n\u03c3 \u2229\u2206 = \u2205 YES Corollary 3.10\n\u03c3 \u2286 \u2206\nNO, even if T1 and T2 are semantically inseparable Example 5\nT1 and T2 are semantically inseparable \u201cmodulo \u03c3\u201d YES Proposition 3.9\nProperty Condition Preservation Reference\n\u2206\u2013 inseparability of components of initial theory under progression\nat least one fluent is present in \u2206 NO\nExample 7\n\u2206 is fluent-free and some components of initial theory split under progression NO Example 8\n\u2206 is fluent-free and components of initial theory do not split under progression YES, modulo the unique name assumption theory\nTheorem 4.4\nBAT is local\u2013effect, \u2206 is fluent-free and components of initial theory do not split under progression\nYES Theorem 4.5\n\u2206\u2013 decomposability and preservation of signature components of an initial theory under progression wrt action term \u03b1\nUnconditionally, in particular for local-effect BAT s and fluent-free\u2206\u2019s NO Example 6\nBAT is local\u2013effect, \u2206 is fluent-free, and components of DS0 are aligned with components of Dss YES, modulo common symbols of the components of Dss and constants in term \u03b1\nTheorem 4.5\nif additionally the constants in term \u03b1 are contained in a single \u2206-decomposition component of DS0\nYES Corollary 4.6\nThe examples and Lemmas given in the paper demonstrate that the sufficient conditions for invariance of decomposability and inseparability wrt progression in local-effect action theories cannot be relaxed. Our research has required new understanding of progression and the related notion of forgetting wrt modularity of theories. The new results about forgetting are general and may find applicability outside of reasoning about actions. Given a decomposition of the initial theory into inseparable components, the rest of the conditions in Theorem 4.5 and Corollary 4.6 are purely syntactical and therefore are easy to check. The important practical observation behind these results is that in order to compute the progression of an initial theory wrt an action having effects only on fluents from one decomposition component, it suffices to compute forgetting only in this component. As illustrated by the running example, non-interacting dynamic systems may share only some common names or static entities, such as location. The fact that the dynamic systems share no fluents can be obscured by the way they are presented, whereas decomposition would make it explicit. We believe that our positive results are applicable to a large and general class of basic action theories. The significant contribution of the paper is in exploring the important connections between research on\nmodularity and reasoning about action. The paper starts bridging the gap between these two different research communities in knowledge representation.\nThere are several directions where future work may proceed. In this paper, we concentrate on local-effect action theories only. However, recently [7] defined a new broad class of action theories called bounded situation calculus action theories, in which actions may have non-local, but bounded effects. Moreover, for these action theories, one can find cases when progression is effectively computable [46]. Therefore, it is natural to explore when decomposability and inseparability remain invariant wrt progression in bounded action theories. Additionally, we noted that there is a realistic case of initial theories, for which the size of a progressed theory with local effects does not grow exponentially. The initial theories of this kind are known as proper+ theories [21,27]. Therefore, it is worth while to develop computationally tractable techniques for decomposition of proper+ theories."}, {"heading": "6 Acknowledgements", "text": "The first author was supported by the German Research Foundation within the Transregional Collaborative Research Centre SFB/ TRR 62 \u201cCompanion-Technology for Cognitive Technical Systems\u201d and by Russian Ministry of Science and Education under the 5-100 Excellence Programme, and Russian Foundation for Basic Research, Project No. 15-07-03410A.\nThe authors would like to thank the Natural Sciences and Engineering Research Council of Canada and the Dept. of Computer Science of the Ryerson University for providing partial financial support."}], "references": [{"title": "De)composition of situation calculus theories", "author": ["Eyal Amir"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Projection in decomposed situation calculus", "author": ["Eyal Amir"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2002}, {"title": "Partition-based logical reasoning for first-order and propositional theories", "author": ["Eyal Amir", "Sheila A. McIlraith"], "venue": "Artif. Intell.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "A complete axiomatization for blocks world", "author": ["Stephen A. Cook", "Yongmei Liu"], "venue": "J. Log. Comput.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "Three uses of the Herbrand-Gentzen theorem in relating model theory and proof theory", "author": ["William Craig"], "venue": "J. Symb. Log.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1957}, {"title": "The road to two theorems of logic. Synthese", "author": ["William Craig"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "Bounded situation calculus action theories and decidable verification", "author": ["Giuseppe De Giacomo", "Yves Lesp\u00e9rance", "Fabio Patrizi"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Scaling up reasoning about actions using relational database technology", "author": ["Giuseppe De Giacomo", "Toni Mancini"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2004}, {"title": "Algorithmic issues of and-decomposition of boolean formulas", "author": ["Pavel Emelyanov", "Denis Ponomaryov"], "venue": "Programming and Computer Software,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Decision problems and constructive models. (in Russian) [\u041f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u043c\u043e\u0441\u0442\u0438 \u0438 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u043c\u043e\u0434\u0435\u043b\u0438", "author": ["Yu. L. Ershov"], "venue": "Nauka, Moscow,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1980}, {"title": "The complexity of explicit definitions", "author": ["Harvey Friedman"], "venue": "Advances in Mathematics,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1976}, {"title": "Conservative extensions in modal logics", "author": ["Silvio Ghilardi", "Carsten Lutz", "FrankWolter", "Michael Zakharyaschev"], "venue": "Proceedings of AiML-6,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2006}, {"title": "Modular reuse of ontologies: Theory and practice", "author": ["Bernardo Cuenca Grau", "Ian Horrocks", "Yevgeny Kazakov", "Ulrike Sattler"], "venue": "J. Artif. Int. Res.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Application of theorem proving to problem solving", "author": ["C. Cordell Green"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1969}, {"title": "Modular first-order ontologies via repositories", "author": ["Michael Gr\u00fcninger", "Torsten Hahmann", "Ali Hashemi", "Darren Ong", "Atalay \u00d6zg\u00f6vde"], "venue": "Applied Ontology,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "A description logic based situation calculus", "author": ["Yilan Gu", "Mikhail Soutchanski"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "Decomposing description logic ontologies", "author": ["Boris Konev", "Carsten Lutz", "Denis Ponomaryov", "Frank Wolter"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2010}, {"title": "Formal properties of modularisation", "author": ["Boris Konev", "Carsten Lutz", "Dirk Walther", "FrankWolter"], "venue": "editors,Modular Ontologies,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2009}, {"title": "Model-theoretic inseparability and modularity of description logic ontologies", "author": ["Boris Konev", "Carsten Lutz", "Dirk Walther", "Frank Wolter"], "venue": "Artif. Intell.,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Parallel interpolation, splitting, and relevance in belief change", "author": ["George Kourousias", "David Makinson"], "venue": "J. Symb. Log.,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2007}, {"title": "Evaluation-based reasoning with disjunctive information in first-order knowledge bases", "author": ["Gerhard Lakemeyer", "Hector J. Levesque"], "venue": "In Proc. of KR-02,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2002}, {"title": "Cognitive robotics (chapter 24)", "author": ["Hector Levesque", "Gerhard Lakemeyer"], "venue": "Handbook of Knowledge Representation,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2007}, {"title": "On strongest necessary and weakest sufficient conditions", "author": ["Fangzhen Lin"], "venue": "Artif. Intell.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2001}, {"title": "Discovering state invariants", "author": ["Fangzhen Lin"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2004}, {"title": "How to progress a database", "author": ["Fangzhen Lin", "Raymond Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1997}, {"title": "On first-order definability and computability of progression for local-effect actions and beyond", "author": ["Yongmei Liu", "Gerhard Lakemeyer"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "Tractable reasoning with incomplete first-order knowledge in dynamic systems with context-dependent actions", "author": ["Yongmei Liu", "Hector J. Levesque"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2005}, {"title": "Conservative extensions in expressive description logics", "author": ["Carsten Lutz", "Dirk Walther", "Frank Wolter"], "venue": "In In Proc. of IJCAI-2007,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}, {"title": "Conservative extensions in expressive description logics", "author": ["Carsten Lutz", "Dirk Walther", "Frank Wolter"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2007}, {"title": "Mathematical logic for life science", "author": ["Carsten Lutz", "Frank Wolter"], "venue": "editors, WoLLIC,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2009}, {"title": "Deciding inseparability and conservative extensions in the description logic EL", "author": ["Carsten Lutz", "Frank Wolter"], "venue": "J. Symb. Comput.,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2010}, {"title": "Situations, actions and causal laws", "author": ["John McCarthy"], "venue": "Memo 2, Stanford University, Department of Computer Science,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1963}, {"title": "Some philosophical problems from the standpoint of artificial intelligence", "author": ["John McCarthy", "Patrick Hayes"], "venue": "Machine Intelligence,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1990}, {"title": "On decidability of the decomposability problem for finite theories", "author": ["Andrey Morozov", "Denis Ponomaryov"], "venue": "Siberian Mathematical Journal,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2010}, {"title": "Complexity of craig\u2019s interpolation", "author": ["Daniele Mundici"], "venue": "Fundamenta Informaticae,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 1982}, {"title": "Some contributions to the metatheory of the situation calculus", "author": ["Fiora Pirri", "Ray Reiter"], "venue": "Journal of the ACM,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1999}, {"title": "On decomposibility in logical calculi", "author": ["Denis Ponomaryov"], "venue": "Bulletin of the Novosibirsk Computing Center,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2008}, {"title": "The algorithmic complexity of decomposability in fragments of first-order logic. Manuscript", "author": ["Denis Ponomaryov"], "venue": "Abstract to appear in the Bulletin of Symbolic Logic. http://persons.iis.nsk.su/files/persons/pages/sigdecomp.pdf,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2014}, {"title": "Progression of decomposed situation calculus theories", "author": ["Denis Ponomaryov", "Mikhail Soutchanski"], "venue": null, "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2013}, {"title": "Concept definability and interpolation in enriched models of eltboxes", "author": ["Denis Ponomaryov", "Dmitry Vlasov"], "venue": "Description Logics,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2013}, {"title": "Proving properties of states in the situation calculus", "author": ["Raymond Reiter"], "venue": "Artif. Intell.,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 1993}, {"title": "Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems", "author": ["Raymond Reiter"], "venue": null, "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2001}, {"title": "Beth definability in expressive description logics", "author": ["Balder ten Cate", "Enrico Franconi", "Inan\u00e7 Seylan"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2013}, {"title": "On the progression of situation calculus basic action theories: Resolving a 10-year-old conjecture", "author": ["Stavros Vassos", "Hector J. Levesque"], "venue": null, "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2008}, {"title": "A classification of first-order progressable action theories in situation calculus", "author": ["Stavros Vassos", "Fabio Patrizi"], "venue": null, "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2013}, {"title": "The modular structure of an ontology: Atomic decomposition", "author": ["Chiara Del Vescovo", "Bijan Parsia", "Ulrike Sattler", "Thomas Schneider"], "venue": "Proceedings of the 22nd International Joint Conference on Artificial Intelligence,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2011}, {"title": "Experimental results on solving the projection problem in action formalisms based on description logics", "author": ["Wael Yehia", "Hongkai Liu", "Marcel Lippmann", "Franz Baader", "Mikhail Soutchanski"], "venue": "Description Logics,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2012}], "referenceMentions": [{"referenceID": 12, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 14, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 16, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 17, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 36, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 45, "context": "It includes both theoretical and practical aspects of modularity of theories formulated in different logical languages (L), ranging from weak (but practical) description logics (DLs) such as EL and DL-Lite to more expressive logics [13,15,17,18,38,47], to cite a few.", "startOffset": 232, "endOffset": 251}, {"referenceID": 0, "context": "To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2].", "startOffset": 167, "endOffset": 172}, {"referenceID": 1, "context": "To the best of our knowledge, the only previous work that explored decomposition of logical theories for the purposes of solving the projection problem are the papers [1,2].", "startOffset": 167, "endOffset": 172}, {"referenceID": 32, "context": "[34,43], a well-known logical formalism for representation of actions and their effects.", "startOffset": 0, "endOffset": 7}, {"referenceID": 41, "context": "[34,43], a well-known logical formalism for representation of actions and their effects.", "startOffset": 0, "endOffset": 7}, {"referenceID": 0, "context": "We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only.", "startOffset": 110, "endOffset": 115}, {"referenceID": 1, "context": "We take a different approach in our paper: instead of decomposing the whole action theory into subsets, as in [1,2], we consider signature decompositions of an initial theory only.", "startOffset": 110, "endOffset": 115}, {"referenceID": 16, "context": "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.", "startOffset": 102, "endOffset": 115}, {"referenceID": 36, "context": "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.", "startOffset": 102, "endOffset": 115}, {"referenceID": 17, "context": "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.", "startOffset": 102, "endOffset": 115}, {"referenceID": 30, "context": "These properties are well known in research on modularization in the area of knowledge representation [17,38,18,32], but have not been studied previously in the scope of the situation calculus.", "startOffset": 102, "endOffset": 115}, {"referenceID": 41, "context": "The situation calculus [43] is a knowledge representation logical formalism, which has been designed for axiomatization of problems in planning and high-level program execution.", "startOffset": 23, "endOffset": 27}, {"referenceID": 41, "context": "In the situation calculus, the so-called basic action theories represent such axiomatizations [43].", "startOffset": 94, "endOffset": 98}, {"referenceID": 41, "context": "In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8].", "startOffset": 173, "endOffset": 179}, {"referenceID": 7, "context": "In a special case, when there is complete knowledge about a finite number of individuals having unique names, the initial theory can be implemented as a relational database [43,8].", "startOffset": 173, "endOffset": 179}, {"referenceID": 31, "context": "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.", "startOffset": 71, "endOffset": 81}, {"referenceID": 32, "context": "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.", "startOffset": 71, "endOffset": 81}, {"referenceID": 13, "context": "Having been developed in the 1960s by John McCarthy and his colleagues [33,34,14], it is one of the most popular logical frameworks for reasoning about actions; it is presented in most well-known textbooks on AI.", "startOffset": 71, "endOffset": 81}, {"referenceID": 21, "context": "For this reason, the situation calculus is chosen as foundation for high-level programming languages in cognitive robotics [22].", "startOffset": 123, "endOffset": 127}, {"referenceID": 41, "context": "Reiter [43] who developed a general approach to axiomatizing direct effects and non-effects of actions.", "startOffset": 7, "endOffset": 11}, {"referenceID": 38, "context": "A preliminary shorter version of this paper (without proofs) appeared in the proceedings of AAAI-13 conference [40].", "startOffset": 111, "endOffset": 115}, {"referenceID": 2, "context": "Thereafter, reasoning wrt the initial theory can be reduced to reasoning within the obtained components via a message passing algorithm, which communicates between the partitions to find information needed to answer a query [3].", "startOffset": 224, "endOffset": 227}, {"referenceID": 36, "context": "In our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].", "startOffset": 67, "endOffset": 71}, {"referenceID": 16, "context": "In our paper, we adopt the following notion that was introduced in [38] and applied to the study of modularity in [17].", "startOffset": 114, "endOffset": 118}, {"referenceID": 37, "context": ", [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic.", "startOffset": 2, "endOffset": 17}, {"referenceID": 8, "context": ", [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic.", "startOffset": 2, "endOffset": 17}, {"referenceID": 16, "context": ", [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic.", "startOffset": 2, "endOffset": 17}, {"referenceID": 33, "context": ", [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic.", "startOffset": 2, "endOffset": 17}, {"referenceID": 36, "context": ", [39,9,17,35,38]) shows that deciding whether a theory is \u2206-decomposable turns out to be not harder than deciding the entailment in the underlying logic.", "startOffset": 2, "endOffset": 17}, {"referenceID": 36, "context": ", from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-\u2206-symbols from the axioms of a theory.", "startOffset": 128, "endOffset": 132}, {"referenceID": 33, "context": ", from a procedure of computing uniform interpolants (if the logic enjoys efficient uniform interpolation, see Proposition 2 in [38] and [35]), or by applying the technique of eliminating non-\u2206-symbols from the axioms of a theory.", "startOffset": 137, "endOffset": 141}, {"referenceID": 16, "context": "The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics.", "startOffset": 30, "endOffset": 34}, {"referenceID": 39, "context": "The technique is described in [17] for the logics EL and DL-Lite, which is further studied in [41] and can be extended to more expressive Description Logics.", "startOffset": 94, "endOffset": 98}, {"referenceID": 16, "context": "For instance, a decomposition component may be of size exponentially larger than the original theory, which is evidenced by Example 28 in [17].", "startOffset": 138, "endOffset": 142}, {"referenceID": 10, "context": "It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.", "startOffset": 115, "endOffset": 122}, {"referenceID": 34, "context": "It is known that in general there is no upper bound on the complexity of explicit definitions in first-order logic [11,36] and computing them is usually harder than entailment in FOL fragments (see e.", "startOffset": 115, "endOffset": 122}, {"referenceID": 42, "context": "[44]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "Using Example 28 from [17], for instance, it possible to describe a situation when tuning up \u2206 can exponentially reduce the component sizes.", "startOffset": 22, "endOffset": 26}, {"referenceID": 9, "context": "see [10]) that every sentence in signature {P} is equivalent to a boolean combination of formulas \u2203P and \u2203\u00acP , where an integerm > 0, which mean \u201cP (respectively, \u00acP ) holds on at least m distinct elements\u201d.", "startOffset": 4, "endOffset": 8}, {"referenceID": 29, "context": "2 in [31]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 17, "context": ", see [18,32].", "startOffset": 6, "endOffset": 13}, {"referenceID": 30, "context": ", see [18,32].", "startOffset": 6, "endOffset": 13}, {"referenceID": 36, "context": "Proposition 2 in [38]).", "startOffset": 17, "endOffset": 21}, {"referenceID": 17, "context": "In contrast to decomposability, deciding \u2206-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].", "startOffset": 193, "endOffset": 197}, {"referenceID": 30, "context": "In contrast to decomposability, deciding \u2206-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].", "startOffset": 199, "endOffset": 203}, {"referenceID": 27, "context": "In contrast to decomposability, deciding \u2206-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].", "startOffset": 275, "endOffset": 282}, {"referenceID": 11, "context": "In contrast to decomposability, deciding \u2206-inseparability of theories is usually harder, than deciding entailment in the logic in which the theories are formulated, as proved by the results in [18], [32], and the results on the complexity of deciding conservative extensions [29,12].", "startOffset": 275, "endOffset": 282}, {"referenceID": 20, "context": "A practically important generalization of theories consisting of ground atoms is proper theories [21,27].", "startOffset": 97, "endOffset": 104}, {"referenceID": 25, "context": "A practically important generalization of theories consisting of ground atoms is proper theories [21,27].", "startOffset": 97, "endOffset": 104}, {"referenceID": 19, "context": "The well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].", "startOffset": 165, "endOffset": 169}, {"referenceID": 16, "context": "The well-known property of logics related to signature decompositions of theories is the Parallel Interpolation Property (PIP) first considered in a special form in [20] and studied later in a more general form in [17].", "startOffset": 214, "endOffset": 218}, {"referenceID": 4, "context": "Note that PIP is closely related to Craig\u2019s interpolation [5,6].", "startOffset": 58, "endOffset": 63}, {"referenceID": 5, "context": "Note that PIP is closely related to Craig\u2019s interpolation [5,6].", "startOffset": 58, "endOffset": 63}, {"referenceID": 36, "context": "In fact, PIP can be understood as an iterated version of Craig\u2019s interpolation in the logics that have compactness and deduction theorem (see Lemma 1 in [38]).", "startOffset": 153, "endOffset": 157}, {"referenceID": 0, "context": "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.", "startOffset": 12, "endOffset": 19}, {"referenceID": 1, "context": "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.", "startOffset": 12, "endOffset": 19}, {"referenceID": 2, "context": "As shown in [1,2,3], a decomposition of a theory can be beneficial even without inseparability thanks to applying the known methods of distributed reasoning via message passing between components.", "startOffset": 12, "endOffset": 19}, {"referenceID": 40, "context": "In every basic action theory D over a signature \u03c3 \u2286 Asc, the set of foundational axioms \u03a3 consists of the following formulas [42] (note the axiom schema for induction):", "startOffset": 125, "endOffset": 129}, {"referenceID": 40, "context": "Reiter observed in [42] that foundational axioms \u03a3 generalize a single successor function over natural numbers to the case of multiple successors over situations.", "startOffset": 19, "endOffset": 23}, {"referenceID": 35, "context": "To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).", "startOffset": 109, "endOffset": 116}, {"referenceID": 41, "context": "To define the remaining subtheories of BAT , we need to introduce the following syntactic notion (taken from [37,43]).", "startOffset": 109, "endOffset": 116}, {"referenceID": 15, "context": "In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].", "startOffset": 103, "endOffset": 110}, {"referenceID": 46, "context": "In particular,DS0 can include both an ABox and a TBox in an appropriateDescription Logic, as argued in [16,48].", "startOffset": 103, "endOffset": 110}, {"referenceID": 41, "context": "6 in [43]), we require that if an action function f occurs in active position in some SSA for a fluent F , then f is not in active position in either \u03b3 F , or \u03b3 \u2212 F .", "startOffset": 5, "endOffset": 9}, {"referenceID": 41, "context": "Reiter defines the notion of SSA for functional fluents [43].", "startOffset": 56, "endOffset": 60}, {"referenceID": 35, "context": "10 (Theorem 1 in [37]) A basic action theory \u03a3 \u222a Duna \u222a DS0 \u222a Dap \u222a Dss is satisfiable iffDuna \u222aDS0 is satisfiable.", "startOffset": 17, "endOffset": 21}, {"referenceID": 41, "context": "Regression is a central computational mechanism that forms the basis for an automated solution to the executability and projection tasks in the situation calculus ([43]).", "startOffset": 164, "endOffset": 168}, {"referenceID": 15, "context": "It is easy to see that regression becomes computationally intractable if the sequence of actions grows indefinitely [16].", "startOffset": 116, "endOffset": 120}, {"referenceID": 25, "context": "Local-effect BAT s are a well-known3 class of theories, for which the operation of progression (Section 4) can be computed effectively [27], without regard to decidability of the underlying theory DS0 .", "startOffset": 135, "endOffset": 139}, {"referenceID": 3, "context": "A complete axiomatization of BW modelled as a finite collection of finite chains can be found in [4].", "startOffset": 97, "endOffset": 100}, {"referenceID": 26, "context": "3 The phrase local-effect actions first appeared in [28], but it was motivated by actions with simple effects", "startOffset": 52, "endOffset": 56}, {"referenceID": 23, "context": "defined in the paper [24], where simple effects are understood similar to the Def.", "startOffset": 21, "endOffset": 25}, {"referenceID": 25, "context": "1 in [27]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 17, "context": "For the case when \u03c3 is a signature, forget (T , \u03c3) is known as sig (T ) \\ \u03c3\u2013uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification.", "startOffset": 214, "endOffset": 218}, {"referenceID": 30, "context": "For the case when \u03c3 is a signature, forget (T , \u03c3) is known as sig (T ) \\ \u03c3\u2013uniform interpolant of T wrt the language L and second-order queries, that is, wrt the pair (L, second-order logic), see Definition 13 in [18] and Lemma 39 in [32] for a justification.", "startOffset": 235, "endOffset": 239}, {"referenceID": 17, "context": "Specialists might notice that (*) is equivalent to semantic \u2206\u2013inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).", "startOffset": 131, "endOffset": 135}, {"referenceID": 28, "context": "Specialists might notice that (*) is equivalent to semantic \u2206\u2013inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).", "startOffset": 221, "endOffset": 225}, {"referenceID": 30, "context": "Specialists might notice that (*) is equivalent to semantic \u2206\u2013inseparability of the initial sets of formulas (see Definition 11 in [18]) which is very hard to decide from the computational point of view (see Theorem 3 in [30], Lemma 40 in [32]).", "startOffset": 239, "endOffset": 243}, {"referenceID": 18, "context": "Nevertheless, there are practically useful restrictions under which the complexity becomes feasible [19].", "startOffset": 100, "endOffset": 104}, {"referenceID": 25, "context": "We will consider local-effect SSAs discussed in [27] and deltas, which do not contain fluents.", "startOffset": 48, "endOffset": 52}, {"referenceID": 41, "context": "1 in [43]) LetD be a basic action theory with", "startOffset": 5, "endOffset": 9}, {"referenceID": 24, "context": "It can be seen (Theorem 2 in [26] and Theorem 2.", "startOffset": 29, "endOffset": 33}, {"referenceID": 25, "context": "10 in [27]) that progression always exists, i.", "startOffset": 6, "endOffset": 10}, {"referenceID": 43, "context": "On the other hand, by the definition, for any BAT D, we have D |= DS\u03b1 and, similarly to the operation of forgetting, it is possible to provide an example (see Definition 2, Conjecture 1, and Theorem 2 in [45]), when the progression DS\u03b1 is not definable (even by an infinite set of formulas) in the logic in which D is formulated.", "startOffset": 204, "endOffset": 208}, {"referenceID": 25, "context": "An interested reader may consult the whole paper [27], while here we only introduce necessary notations from Definition 3.", "startOffset": 49, "endOffset": 53}, {"referenceID": 25, "context": "4 of [27], which will be used in Theorem 4.", "startOffset": 5, "endOffset": 9}, {"referenceID": 25, "context": "6 in [27]) In the notations above, the following is a progression of", "startOffset": 5, "endOffset": 9}, {"referenceID": 25, "context": "6 in [27], due to the possible exponential blow-up after forgetting a set of ground atoms.", "startOffset": 5, "endOffset": 9}, {"referenceID": 22, "context": "This is not a surprise, because even in propositional logic, forgetting a symbol in a formula is essentially the elimination of a \u201cmiddle term\" (introduced by Boole), which results in the disjunction of two instances of the input formula [23].", "startOffset": 238, "endOffset": 242}, {"referenceID": 25, "context": "As shown in [27], there are practical classes of the initial theories for which there is no blow-up and the size of the progressed theory is actually linear wrt the size of the initial theory.", "startOffset": 12, "endOffset": 16}, {"referenceID": 25, "context": "10 in [27].", "startOffset": 6, "endOffset": 10}, {"referenceID": 6, "context": "However, recently [7] defined a new broad class of action theories called bounded situation calculus action theories, in which actions may have non-local, but bounded effects.", "startOffset": 18, "endOffset": 21}, {"referenceID": 44, "context": "Moreover, for these action theories, one can find cases when progression is effectively computable [46].", "startOffset": 99, "endOffset": 103}, {"referenceID": 20, "context": "The initial theories of this kind are known as proper theories [21,27].", "startOffset": 63, "endOffset": 70}, {"referenceID": 25, "context": "The initial theories of this kind are known as proper theories [21,27].", "startOffset": 63, "endOffset": 70}], "year": 2017, "abstractText": "In many tasks related to reasoning about consequences of a logical theory, it is desirable to decompose the theory into a number of weakly-related or independent components. However, a theory may represent knowledge that is subject to change, as a result of executing actions that have effects on some of the initial properties mentioned in the theory. Having once computed a decomposition of a theory, it is advantageous to know whether a decomposition has to be computed again in the newly-changed theory (obtained from taking into account changes resulting from execution of an action). In the paper, we address this problem in the scope of the situation calculus, where a change of an initial theory is related to the notion of progression. Progression provides a form of forward reasoning; it relies on forgetting values of those properties, which are subject to change, and computing new values for them. We consider decomposability and inseparability, two component properties known from the literature, and contribute by 1) studying the conditions when these properties are preserved and 2) when they are lost wrt progression and the related operation of forgetting. To show the latter, we demonstrate the boundaries using a number of negative examples. To show the former, we identify cases when these properties are preserved under forgetting and progression of initial theories in local-effect basic action theories of the situation calculus. Our paper contributes to bridging two different communities in Knowledge Representation, namely research on modularity and research on reasoning about actions.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}