{"id": "1006.5896", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2010", "title": "Counterexample Guided Abstraction Refinement Algorithm for Propositional Circumscription", "abstract": "Circumscription actually a representative example important in nonmonotonic reasoning variational synthesis. Circumscription an often been studied including ten order doctrines, did limited propositional version an major partly end not since material research, having been shown person way closing market australia assumption (ECWA ). Moreover, contraposition in propositional circumscription one own well - well typical similar entire decision problem well given 17 well has the polynomial realm. This box push means for Boolean Satisfiability (SAT) - part algorithm for fictionalization 2002 lagrangian paginated be topics main relationship though lagrangian statuses came continuous models. The new algorithm \u201d singing as ideas most used been SAT - based model checking, countries presupposes guided abstraction fluidity. In small, the part codice_1 is refined giving compute full theory breach for cosmological hold successful assumption (GCWA ). Experimental results actually that 's new risc else inevitably nothing instances to mostly innovative are their with any.", "histories": [["v1", "Wed, 30 Jun 2010 16:00:08 GMT  (65kb)", "http://arxiv.org/abs/1006.5896v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["mikol\\'a\\v{s} janota", "joao marques-silva", "radu grigore"], "accepted": false, "id": "1006.5896"}, "pdf": {"name": "1006.5896.pdf", "metadata": {"source": "META", "title": "Counterexample Guided Abstraction Refinement Algorithm for Propositional Circumscription", "authors": ["Joao Marques-Silva"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n00 6.\n58 96\nv1 [\ncs .A\nI] 3\n0 Ju"}, {"heading": "1 Introduction", "text": "Closed world reasoning (CWR) and circumscription (CIRC) are well-known nonmonotonic reasoning techniques, that find a wide range of practical applications. Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16]. While these techniques have been studied in the context of both first-order and propositional logic, this paper addresses the propositional case. Research directions that have characterized the study of nonmonotonic reasoning techniques include expressiveness, computational complexity, applications and algorithms. The different CWR rules proposed in the late 70s and 80s illustrate the evolution in terms of expressive power in first-order and propositional logics. The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being \u03a0P2 -complete [6]. Nonmonotonic reasoning finds a wide range of applications in Artificial Intelligence (AI), but also in description logics [7]\nand in interactive configuration [13], among many others. Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].\nThe main contribution of this paper is to propose a new algorithm for solving the deduction problem for the propositional version of some CWR rules and for propositional circumscription. The new algorithm is based on iterative calls to a SAT solver, and is motivated by the practical success of modern SAT solvers. However, given the complexity class of entailment for CWR rules, a SAT solver can be expected to be called an exponential number of times in the worst case, or be required to process an exponentially large input. To cope with this issue, we utilize a technique inspired in counterexample guided abstraction refinement (CEGAR), widely used in model checking [3]. One of the key ideas of the new algorithm is that we try to prove a stronger formula, which is weakened if it turns out to be too strong. Based on this idea we develop an algorithm that decides entailment in circumscription. Further, we refine the algorithm to compute the closure of a formula defined by one of the variants of CWR, namely GCWA. As a result, the main contributions of the paper can be summarized as follows: (i) A novel algorithm for propositional circumscription that does not require an enumeration of all minimal models or prime implicates; (ii) Specialization of this algorithm to compute variables that are 0 in all minimal models; and (iii) Computing the closure of GCWA.\nThe paper is organized as follows. The next section introduces the notation and concepts used in the remainder of the paper. Section 3 introduces the computational problems addressed in the paper. The new algorithms are described in Sections 4, 5, and 6. The new algorithms are compared to alternative algorithms in Section 7. The paper concludes with directions for future research work."}, {"heading": "2 Preliminaries", "text": "All variables are propositional, and represented by a finite set V . A Conjunctive Normal Form (CNF) formula \u03c6 is a conjunction of clauses, which are disjunctions of literals, which are possibly negated variables. A formula \u03c6 can also be viewed as a set of sets of literals. The two representations are used interchangeably in this paper. A clause is called positive, if it contains only positive literals. Arbitrary Boolean formulas will also be considered, for which the standard definitions apply. A variable assignment \u03bd is a total function from V to {0, 1}. In the text, a variable assignment is represented as {xv11 , . . . , x vn n } where V = {x1, . . . , xn} and vi \u2208 {0, 1}, i \u2208 1..n. For a variable assignment \u03bd and a formula \u03c6 we write \u03bd |= \u03c6 to denote that \u03bd satisfies \u03c6. In this case, \u03bd is called a model of \u03c6. We write \u03c6 |= \u03c8 if the models of \u03c6 are also models of \u03c8. Given a set of variables S \u2286 V and v \u2208 {0, 1}, the expression \u03c6[S 7\u2192 v] denotes the formula \u03c6 with all variables in S replaced with v."}, {"heading": "2.1 Minimal Models", "text": "Minimal models are widely used in nonmonotonic reasoning and AI in general. To introduce minimal models, we consider the bitwise ordering on variable assignments. For variable assignments \u03bd and \u00b5 we write \u03bd \u2264 \u00b5 and say that \u03bd is smaller than \u00b5 iff (\u2200x \u2208 V )(\u03bd(x) \u2264 \u00b5(x)). We write \u03bd < \u00b5 and say that \u03bd is strictly smaller than \u00b5 iff \u03bd \u2264 \u00b5 and \u03bd 6= \u00b5. A model \u03bd of \u03c6 is a minimal model iff there is no model of \u03c6 strictly smaller than \u03bd. Finally, we write \u03c6 |=min \u03c8 if \u03c8 holds in all minimal models of \u03c6.\nProposition 1. The models of formula \u03c6 that are strictly smaller than some variable assignment \u03bd are the models of the formula\n\u03c6 \u2227 \u2227\n\u03bd(x)=0 \u00acx \u2227\n\u2228\n\u03bd(x)=1 \u00acx (1)"}, {"heading": "2.2 Closed World Reasoning", "text": "The intuition behind closed world assumption (CWA) reasoning is that facts are not considered to be true unless they were specifically stated. This is motivated by the type of reasoning humans use on an everyday basis. For instance, if Alice asks Bob to buy eggs, Bob will clearly buy eggs. However, he will not buy bread even though Alice has not specified that the bread should not be bought. Traditional mathematical logic behaves differently in this respect: the fact buy-eggs trivially entails buy-eggs but does not entail the fact \u00acbuy-bread.\nThis intuition has been realized by several different formalisms. Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].\nThe standard formulation of CWA rules partitions set V into three sets: P , Q and Z, where P denotes the variables to be minimized, Z are the variables that can change when minimizing the variables in P , andQ represents all other (fixed) variables. For any set R, R+ and R\u2212 denote, respectively, the sets of positive and negative literals from variables in R. Following [1,6], a closure operation is defined for CWR rules as follows:\nDefinition 1. Let \u03c6 be a propositional formula, \u3008P ;Q;Z\u3009 a partition of V , and \u03b1 a CWR-rule. Then, the closure of \u03c6 with respect to \u03b1 is defined by,\n\u03b1(\u03c6;P ;Q;Z) = \u03c6 \u222a {\u00acK | K is free for negation in \u03c6 w.r.t. \u03b1} (2)\nEach CWR rule considers a different set of formulas that are free for negation. For each CWR rule below, a formula K is free for negation if and only if the corresponding condition holds:\nGCWA (Generalized CWA [17]): K is a positive literal and for every positive clause B such that \u03c6 2 B it holds that \u03c6 2 B \u2228K.\nEGCWA (Extended GCWA [24]): K is a conjunction of positive literals and for every positive clause B such that \u03c6 2 B it holds that \u03c6 2 B \u2228K.\nECWA (Extended CWA [24]): K is an arbitrary formula not involving literals from Z, and for every positive clause B whose literals belong to P+\u222aQ+\u222aQ\u2212, such that \u03c6 2 B, it holds that \u03c6 2 B \u2228K.\nWe consider only a subset of existing CWR rules. A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].\nObserve that a single positive literal is free for negation in both GCWA and EGCWA under the same conditions. Since a positive literal corresponds to some variable, we extend the terminology for variables accordingly.\nDefinition 2. A variable x is free for negation in \u03c6 iff for every positive clause B such that \u03c6 2 B it holds that \u03c6 2 B \u2228 v.\nAnother concept closely related to closed world assumption is circumscription. Originally, McCarthy defined circumscription in the context of first order logic as a closure of the given theory that considers only predicates with minimal extension [15]. In propositional logic, circumscription of a formula yields a formula whose models are the minimal models of the original one.\nDefinition 3. Consider the sets of variables P , Q and Z introduced above. The circumscription of a formula \u03c6 is defined as follows:\nCIRC(\u03c6;P ;Q;Z) = \u03c6 \u2227 (\u2200P \u2032,Z\u2032)((\u03c6(P \u2032;Q;Z \u2032) \u2227 (P \u2032 \u21d2 P )) \u21d2 (P \u21d2 P \u2032)) (3)\nWhere P \u2032, Z \u2032 are sets of variables s.t. X \u2032 = {x\u2032 | x \u2208 X}; \u03c6(P \u2032, Q, Z \u2032) is obtained from \u03c6(P,Q,Z) by replacing the variables in P and Z by the corresponding variables in P \u2032 and Z \u2032; finally, P \u2032 \u21d2 P stands for \u2227\nx\u2208P (x \u2032 \u21d2 x).\nIn the remainder of the paper the sets Z and Q are assumed to be empty. The extension to the general case where these sets are not empty is simple, and is outlined in Appendix B.\nIt is well-known that for the propositional case, circumscription is equivalent to ECWA [9]. Another well-known relationship is the one of both CWR rules and circumscription to minimal models (e.g. [17,1,6]). In particular variables free for negation take value 0 in all minimal models. And, both EGCWA and circumscription entail the same set of facts as the set of minimal models. These relations are captured by the following propositions (adapted from [17,1,6]):\nProposition 2. A variable x is free for negation in a formula \u03c6 iff x is assigned value 0 in all minimal models of \u03c6.\nProposition 3. Let \u03c6 and \u03c8 be formulas. It holds that EGCWA(\u03c6) |= \u03c8 iff \u03c6 |=min \u03c8. And, it holds that CIRC(\u03c6) |= \u03c8 iff \u03c6 |=min \u03c8."}, {"heading": "3 Problems", "text": "The CWR rules yield the two following problems. The first problem consists of computing the closure of the theory, as defined by the CWR rule. The second problem is that of computing whether a certain fact is entailed by that closure.\nIf the closure has been computed, standard satisfiability algorithms can be used to solve the entailment problem. However, whereas the closure of GCWA increases the size of the formula by at most a linear number of literals, the closure of both ECWA and EGCWA may increase the size of the formula by an exponential number of conjuncts of literals. The circumscription of a formula can be constructed easily but gives rise to a QBF formula and our objective is to stay within propositional logic with the ultimate goal of developing purely SAT-based solutions. Hence, this paper focuses on the following problems.\nEntails-Min instance: formulas \u03c6 and \u03c8 question: Does the formula \u03c8 hold in all minimal models of \u03c6?\nFree-For-Negation instance: formula \u03c6 and variable x \u2208 V question: Does x take value 0 in all minimal models of \u03c8?\nFree-For-Negation-All instance: formula \u03c6 and a variable v \u2208 V question: What is the set of variables with value 0 in all minimal models of \u03c6?\nNote that solving Entails-Min enables answering whether a fact is entailed by ECWA or by circumscription due to Proposition 3. Clearly, the problem Free-For-Negation is a special case of Entails-Min with \u03c8 set to \u00acx. Solving Free-For-Negation-All gives us the closure of GCWA.\nInterestingly, in terms of complexity, the problem Free-For-Negation is not easier than the problem Entails-Min. Both Entails-Min and Free-ForNegation are \u03a0P2 -complete [6, Lemma 3.1].\n4 Computing Entails-Min\nThe algorithm we wish to develop will be using a SAT solver. This gives us two objectives. One objective is to construct a propositional formula that corresponds to the validity of \u03c6 |=min \u03c8. The second objective is to avoid constructing an exponentially large formula. We begin by observing that if \u03c6 |=min \u03c8 is to hold, then any model of \u03c6 that violates \u03c8 must not be a minimal model.\nProposition 4. \u03c8 holds in all minimal models of \u03c6 iff any model \u03bd of \u03c6 where \u00ac\u03c8 holds is not a minimal model of \u03c6.\n[\u03c6 |=min \u03c8] \u21d4 [(\u2200\u03bd) ((\u03bd |= \u03c6 \u2227 \u00ac\u03c8) \u21d2 (\u2203\u03bd \u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6))]\nProposition 4 tells us that whether \u03c6 |=min \u03c8 holds or not can be decided by deciding whether the following formula is valid:\n(\u2200\u03bd) ((\u03bd |= \u03c6 \u2227 \u00ac\u03c8) \u21d2 (\u2203\u03bd\u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6)) (4)\nSince our first objective is to find a propositional formula, we need to eliminate \u00b7 |= \u00b7 and quantifiers from (4). First, let us focus on the subformula (\u2203\u03bd\u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6), which expresses that \u03bd is not a minimal model.\nProposition 5. A model \u03bd of \u03c6 is not minimal iff there exists a set S of variables such that \u03bd is a model of \u03c6[S 7\u2192 0], and \u03bd(x) = 1 for some x \u2208 S.\n(\u2203\u03bd\u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6) \u21d4 (\u2203S \u2286 V ) (\u03bd |= \u03c6[S 7\u2192 0] \u2227 (\u2203x \u2208 S)(\u03bd(x) = 1)) (5)\nExample 1. Let \u03c6 = \u00acx \u2228 y. The model \u00b5 = {x0, y0} is minimal and the righthand side of (5) is invalid since there is no set S satisfying the condition (\u2203x \u2208 S)(\u03bd(x) = 1). Let \u03bd = {x0, y1} and let us choose S = {x, y}, which yields \u03c6[S 7\u2192 0] = 1. \u03bd is not minimal and the right-hand side of (5) is valid since \u03bd |= 1 and \u03bd(y) = 1.\nReplacing the left-hand side of (5) with the right-hand side of (5) in (4) yields the following formula:\n(\u2200\u03bd) ((\u03bd |= \u03c6 \u2227 \u00ac\u03c8) \u21d2 (\u2203S \u2286 V ) (\u03bd |= \u03c6[S 7\u2192 0] \u2227 (\u2203x \u2208 S)(\u03bd(x) = 1))) (6)\nRemoving the universal quantifier and replacing existential quantifiers with the Boolean operator \u2228 in (6), gives us that (6) holds iff the following formula is a tautology:\n(\u03c6 \u2227 \u00ac\u03c8) \u21d2 \u2228\nS\u2208P(V )\n(\n\u03c6[S 7\u2192 0] \u2227 \u2228\nx\u2208S\nx\n)\n(7)\nIntuitively, (7) expresses that if \u03c8 is violated in a model of \u03c6, then a different model of \u03c6 is obtained by flipping a set of variables to 0. That this model is indeed different is guaranteed by the condition \u2228\nx\u2208S x. The model obtained by the flipping serves as a witness of that the model violating \u03c8 is not minimal.\nIf (7) is constructed, its validity can be decided by calling a SAT solver on its negation. However, the formula is too large to construct since it requires considering all subsets of V . Therefore, we construct a stronger version of it that considers only some subsets of V . This stronger version is referred to as the abstraction of (7) and always has the following form:\n(\u03c6 \u2227 \u00ac\u03c8) \u21d2 \u2228\nS\u2208W\n(\n\u03c6[S 7\u2192 0] \u2227 \u2228\nx\u2208S\nx\n)\nwhere W \u2286 P(V ) (8)\nEach abstraction is determined by a set of sets of variables W . For any W , if the abstraction (8) is shown to be a tautology, then (7) is also a tautology and we are done because we have shown that \u03c6 |=min \u03c8. If the abstraction is not a tautology, it is either because \u03c6 |=min \u03c8 does not hold or the abstraction is overly strong\u2014it is too coarse. If the abstraction is shown to be too coarse, a different abstraction must be considered.\ninput : formulas \u03c6 and \u03c8 output: true iff \u03c6 |=min \u03c8\n1 \u03c9 \u2190 \u03c6 \u2227 \u00ac\u03c8 2 while true do 3 (outc1, \u03bd) \u2190 SAT(\u03c9) 4 if outc1 = false then 5 return true // no counterexample was found\n6 (outc2, \u03bd \u2032) \u2190 SAT\n(\n\u03c6 \u2227 \u2227 \u03bd(x)=0 \u00acx \u2227 \u2228 \u03bd(x)=1 \u00acx )\n// find \u03bd\u2032 < \u03bd\n7 if outc2 = false then // \u03bd is minimal 8 return false // abstraction cannot be refined\n9 S \u2190 {x \u2208 V | \u03bd(x) = 1 \u2227 \u03bd\u2032(x) = 0} 10 \u03c9 \u2190 \u03c9 \u2227 (\u00ac\u03c6[S 7\u2192 0] \u2228 \u2227\nx\u2208S \u00acx) // refine\nAlgorithm 1: Refining\nExample 2. Let us show that \u00acx \u2228 y |=min \u00acy. First, let us try W1 = {{y}}, which yields the abstraction ((\u00acx \u2228 y) \u2227 y) \u21d2 \u00acx. This abstraction is not a tautology. In particular, it is violated by the assignment {x1, y1}, which means that flipping y to value 0 in this assignment does not yield a model. Now, let us try W2 = {{x, y}}, which yields the abstraction ((\u00acx \u2228 y) \u2227 y) \u21d2 1. This abstraction is a tautology, which means that any model where y is 1 can be turned into another model by flipping both x and y to 0. Therefore, \u00acx \u2228 y |=min \u00acy.\nExample 3. Let \u03c6 = \u00acx \u2228 \u00acy \u2228 \u00acz and \u03c8 = (\u00acx \u2228 \u00acy) \u2227 (\u00acx \u2228 \u00acz) \u2227 (\u00acz \u2228 \u00acy) Let us show that \u03c6 |=min \u03c8. Let us choose the abstraction defined by the set W = {{x}, {y}}. The following diagram demonstrates that each model violating \u03c8 has a witness corresponding to one of the sets in W .\n000\n100 010 001\n110 101 011 {y}\n{x} {y}\n111\n\u03c6\n\u03c6\u2227\u00ac\u03c8 Each triple represents a variable assignment\nwhere the elements represent the values of x,\ny, and z, respectively. Models and their per-\ntaining witnesses are connected by an edge,\nwhich is labeled by the set of variables S whose\nvalues are flipped to 0 to obtain the witness.\nThe approach of searching for the right abstraction follows the CounterExample Guided Abstract Refinement (CEGAR) loop [3]. If the abstraction is a tautology, the search terminates. If the abstraction is not a tautology, it is weakened by adding some set of variables S to the set W . This weakening is referred to as refinement and is done by investigating the counterexample that shows that the current abstraction is not a tautology. If it cannot be refined, (7) is not a tautology and \u03c6 |=min \u03c8 does not hold.\nAlgorithm 1 realizes the idea outlined above. The algorithm maintains the negation of the abstraction in variable \u03c9 and starts with W being the empty set. Therefore the initial abstraction is (\u03c6 \u2227 \u00ac\u03c8) \u21d2 0 with the negation being \u03c6 \u2227 \u00ac\u03c8 (line 1). The test whether the abstraction is a tautology or not is done\nby calling a SAT solver on its negation (line 2). If the negation is unsatisfiable\u2014 the abstraction is a tautology\u2014then the algorithm terminates and returns true (line 4). If a model \u03bd is found showing that the abstraction is not a tautology, it means that for any assignment that is obtained from \u03bd by flipping some set of variables in S \u2208 W to 0 is not a model of \u03c6. The algorithm looks for a model \u03bd\u2032 that is strictly smaller than \u03bd applying Proposition 1 (line 7). If there is no model strictly smaller than \u03bd then the algorithm terminates and returns false since \u03bd is a minimal model and violates \u03c8 (line 9). If there is a model \u03bd\u2032 that is strictly smaller than \u03bd, there is some set of variables that are 1 in \u03bd but are 0 in \u03bd\u2032. This set of variables is added to the sets determining the abstraction (line 9). Observe that a set S will be used at most once to refine the abstraction since once the set is added to W , an assignment for which flipping 1 to 0 for variables in S yields a model cannot satisfy the negation of the abstraction. Consequently, the algorithm is terminating and will perform at most as many iterations as there are subsets of the set V .\n5 Computing Free-For-Negation\nThis section specializes Algorithm 1 to compute variables free for negation\u2014 variables that take value 0 in all minimal models. As mentioned earlier, this problem is a special case of the problem Entails-Min, studied in the previous section: x is free for negation in \u03c6 iff \u03c6 |=min \u00acx. However, focusing on this type of formulas enables a more efficient implementation of the algorithm.\nThe abstractions used in the previous section have to contain the condition that at least one of the variables being flipped to 0 is 1 to guarantee the corresponding witnesses is strictly smaller (see (7)). For variables free for negation these conditions will not be needed thanks to the following proposition.\nProposition 6. Let \u03bd be a model of \u03c6 s.t. \u03bd(x) = 1 for a variable x. If x is free for negation, then there exists a model \u03bd\u2032 of \u03c6 s.t. \u03bd\u2032 < \u03bd and \u03bd\u2032(x) = 0.\nProposition 6 tells us that if \u03bd(x) = 1 and x is free for negation, there must be a witness \u03bd\u2032 that flips x to 0 (and possibly some other variables). This ensures that \u03bd and \u03bd\u2032 are different. This observation enables us to compute \u03c6 |=min \u00acx by determining the validity of a stronger and more concise formula than before.\nProposition 7. A variable x is free for negation in \u03c6 iff the following formula is a tautology.\n(\u03c6 \u2227 x) \u21d2 \u2228\nS\u2286V \u2227x\u2208S \u03c6[S 7\u2192 0] (9)\nThe abstraction of (9) is analogous to the one used in the previous section with the difference that only sets of variables containing x are considered. Hence, the abstraction always has the following form.\n(\u03c6 \u2227 x) \u21d2 \u2228\nS\u2208W \u03c6[S 7\u2192 0], where W \u2286 P(V ) and (\u2200S \u2208W )(x \u2208 S) (10)\ninput : CNF formula \u03c6 and a variable x output: true iff \u03c6 |=min \u00acx\n1 \u03c60 \u2190 \u03c6[x 7\u2192 0] 2 \u03c6\u20320 \u2190 {\u00acrc \u2228 c | c \u2208 \u03c60} \u222a {\u00acl \u2228 rc | c \u2208 \u03c60, l \u2208 c} \u222a { \u2228\nc\u2208\u03c60 \u00acrc\n}\n3 \u03c9 \u2190 \u03c6 \u2227 x \u2227 \u03c6\u20320 4 while true do 5 (outc1, \u03bd) \u2190 SAT(\u03c9) 6 if outc1 = false then 7 return true // no counterexample was found\n8 (outc2, \u03bd \u2032) \u2190 SAT\n(\n\u03c6 \u2227 \u00acx \u2227 \u2227 \u03bd(z)=0 \u00acz )\n// find \u03bd\u2032 < \u03bd and \u03bd\u2032(x) = 0\n9 if outc2 = false then 10 return false // abstraction cannot be refined\n11 S \u2190 {z \u2208 V | \u03bd(z) = 1 \u2227 \u03bd\u2032(z) = 0} 12 Cp \u2190 {c \u2208 \u03c60 | (c \u2229 S) 6= \u2205} // clauses with some y \u2208 S 13 Cn \u2190 {c \u2208 \u03c60 | (c \u2229 \u00acS) 6= \u2205} // clauses with some \u00acy \u2208 S 14 C \u2190 {c\u2032 | c \u2208 (Cp r Cn) \u2227 c\n\u2032 = c[S 7\u2192 0]} // new clauses 15 \u03c9 \u2190 \u03c9 \u222a {\u00acrc \u2228 c | c \u2208 C} \u222a {\u00acl \u2228 rc | c \u2208 C, l \u2208 c} // representation 16 \u03c9 \u2190 \u03c9 \u222a { \u2228\nc\u2208\u03c6r(Cn\u222aCp) \u00acrc \u2228\n\u2228\nc\u2208C \u00acrc\n}\n// negation of clauses\nAlgorithm 2: Deciding whether a variable is free for negation"}, {"heading": "5.1 Constructing and Refining Abstraction", "text": "Whenever the abstraction is being refined (weakened) the size of the formula representing the negation of the abstraction increases. Since the abstraction is refined in the worst case exponentially many times, it is warranted to pay attention to the size of the formula representing the negation of the abstraction.\nThe negation of an abstraction is a conjunct of the left-hand side of the implication and formulas capturing the substitutions.\n(\u03c6 \u2227 x) \u2227 \u2227\nS\u2208W \u00ac\u03c6[S 7\u2192 0], where W \u2286 P(V ) and (\u2200S \u2208 W )(x \u2208 S) (11)\nWhen the abstraction is being refined, a new set of variables S is added to the set W , therefore, the negation of the abstraction is strengthened by conjoining it with \u00ac\u03c6[S 7\u2192 0]. We aim to implement this strengthening without duplicating those parts of the formula that are already present.\nAlgorithm 2 outlines this procedure. Since all the sets S must contain x, the algorithm starts with the abstraction determined by W = {{x}}. In the initialization phase, the negation of this abstraction is \u03c6 \u2227 x \u2227 \u00ac\u03c6[x 7\u2192 0] and is computed using the Tseitin transformation [23]. Each clause c in \u03c6[x 7\u2192 0] is represented by a fresh variable rc and a clause is added that expresses that at least one of these variables must be 0 (line 2). As in the previous section, variable \u03c9 represents the negation of the abstraction (see (11)).\nWhen the abstraction is being refined, the formula in variable \u03c9 is conjoined with \u00ac\u03c6[S 7\u2192 0]. Since \u03c9 already contains clauses from \u00ac\u03c6[x 7\u2192 0], we need to\nconsider only those clauses that contain literals on the variables in S. Clauses containing negative literals on variables from S are skipped, positive literals are removed. Each of the affected clauses is represented by a fresh Tseitin variable. Finally, a clause is added to express that one of the clauses in \u03c6[S 7\u2192 0] is 0. Note that this clause is referring to the original Tseitin variables for the clauses that are not affected by the substitution besides the freshly created ones. Note that when looking for a model \u03bd\u2032 < \u03bd, the algorithm requires that x has value 0 in \u03bd\u2032 since the set S must contain x (line 8)."}, {"heading": "5.2 Finding Models", "text": "An abstraction is refined according to two responses from the underlying SAT solver (\u03bd and \u03bd\u2032). This enables us to devise heuristics that prefer some responses of the solver to another. The motivation for these heuristics is to find abstractions where the set W determining the abstraction contains few sets S. Dually, this means that each of S \u2208W yields a witness for many models. The heuristics used in the current implementation are motivated by the two following examples.\nExample 4. Let \u03c6 = (x\u21d2 y) \u2227 (w \u2228 z). The abstraction defined byW = {{x, y}} shows that \u03c6 |=min \u00acy since flipping both x and y in any model yields a model (a witness). The abstraction determined by W = {{x, y, z}} is not sufficient. This abstraction provides a witness for models with w having value 1 but not for the others. Intuitively, variable z is irrelevant to the relation x\u21d2 y and therefore it is better to choose a small S.\nExample 5. Let \u03c6 = x \u21d2 (y \u2228 w1 \u2228 . . . wn) and let us prove that \u03c6 |=min \u00acy. The abstraction determined by W = {{x, y}} is sufficient. However, if \u03bd is not minimal, it may be that \u03bd = x1, y1, w11 , . . . w 1 n which gives us an exponential number of possibilities for \u03bd\u2032 while only one of them is desirable. Intuitively, if \u03bd is not minimal and there is some set S that yields a witness for both \u03bd and some \u03bd1 < \u03bd, then the set S is more likely to be found when \u03bd1 is inspected.\nBased on this last observation, the model \u03bd is required to be minimal. To make the difference between \u03bd and \u03bd\u2032 small, and therefore make this set S small, the solution \u03bd\u2032 is required to be a maximal model.\nTo obtain a minimal, respectively maximal, model from a SAT solver is done by specifying the phase\u2014the value that the solver prefers when making decisions when traversing the search space. Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].\n6 Computing Free-For-Negation-All\nTo calculate the set of variables that are free for negation, we invoke the algorithm described in the previous section for each variable. This procedure is optimized by conjoining the negations of the variables that have already been shown to be free for negation, which is justified by the following proposition.\ninput : CNF formula \u03c6 and a set of variables V output: subset of V that are free for negation\n1 F \u2190 \u2205 2 X \u2190 V 3 timeout \u2190 initial-timeout 4 while X 6= \u2205 do 5 G \u2190 \u2205 6 foreach x in X do 7 (success, outc) \u2190 Free-For-Negation(\u03c6, x, timeout) 8 if success = true then 9 G \u2190 G \u222a {x}\n10 if outc = true then 11 F = F \u222a {x} 12 \u03c6 = \u03c6 \u2227 \u00acx\n13 X \u2190 X rG 14 timeout \u2190 k \u00d7 timeout 15 return F\nAlgorithm 3: Computing the set of variables that are free for negation\nProposition 8. Let \u03c6 and \u03c8 be formulas such that \u03c6 |=min \u03c8. The formula \u03c6\u2227\u03c8 has the same set of minimal models as \u03c6. In particular, if \u03c6 |=min \u00acx then (\u03c6 \u2227 \u00acx) |=min \u00acy iff \u03c6 |=min \u00acy.\nThe motivation for conjoining negations of variables free for negation is to give more information to subsequent inferences. The effectiveness of this technique, however, depends on the ordering of the variables. Hence, the approach we use is to set timeouts for testing a single variable and if a test times out, the variable is tested again but with information gained from the other tests.\nAlgorithm 3 summarizes these ideas in pseudocode. The algorithm described in the previous section is represented by the function Free-For-Negation, which returns a pair of values. The first value in the pair indicates whether the algorithm terminated before the given timeout or not. The second value of the pair indicates whether the given variable is free for negation or not. The timeout is gradually multiplied by some constant coefficient k. In the actual implementation there is a maximum timeout for which the algorithm stops and returns an approximation of the set of variables free for negation."}, {"heading": "7 Evaluation", "text": "Algorithm 3 was implemented in Java using SAT4j as the underlying SAT solver while availing of its incremental interface [22]. The implementation was evaluated on a benchmark of 260 tests4. A majority of these are valid software configurations (motivated by [13]). A few tests are from the SAT \u201909 competition\u2014\n4 Available at http://logos.ucd.ie/confs/jelia10/jelia10-bench.tgz\nrelatively easy instances were chosen as the computed problem is significantly harder than satisfiability. The results appear in Table 1. An instance is considered solved if the answer is given in less than 30 s. The time given in the table is the average for the solved instances.\nThe alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program. From the list of models it is easy and fast to construct the set of variables that are free for negation. We also tried using a QBF solver along with (3), but that implementation solved none of the 260 tests."}, {"heading": "8 Summary and Future Work", "text": "This paper proposes an algorithm for deduction under the set of minimal models of a propositional formula. This algorithm enables us to reason under the propositional versions of close world assumption or circumscription. The algorithm hinges on an application of a SAT solver but more importantly on counterexample guided abstraction refinement (CEGAR). While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.\nThe deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12]. The experimental results suggest that current QBF solvers are not practical for this problem. The comparison to the DLP-based solution indicates that our dedicated algorithm enables solving more instances. Nevertheless, the DLP-based solution was faster for some instances.\nThe promising experimental results indicate that the ideas behind the presented algorithms have potential for further work. The evaluation was performed for the computation of variables free for negation defining the closure of a theory in GCWA, hence, further evaluations should be performed on other types of problems in this domain. On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21]. This opens possibilities to investigate generalizations of the presented algorithms for different orderings than the one used for minimal models. Last but not least, the comparison with the DLP-based solution indicates that it would be beneficial to investigate approaches tackling the problem with hybrid techniques."}, {"heading": "A Proofs", "text": "Proposition 1. The models of formula \u03c6 that are strictly smaller than some variable assignment \u03bd are the models of the formula\n\u03c6 \u2227 \u2227\n\u03bd(x)=0\n\u00acx \u2227 \u2228\n\u03bd(x)=1\n\u00acx (1)\nProof. Let \u03bd\u2032 be a model of (1). The assignment \u03bd\u2032 is a model of \u03c6 because (1) is stronger than \u03c6. The model \u03bd\u2032 is smaller than \u03bd because whenever \u03bd(x) = 0 holds, \u03bd\u2032(x) = 0 holds as well due to the condition \u2227\n\u03bd(x)=0 \u00acx. The model \u03bd \u2032 is\nstrictly smaller than \u03bd because there must be at least one variable x for which \u03bd(x) = 1 and \u03bd\u2032(x) = 0 due to the condition \u2228\n\u03bd(x)=1 \u00acx. \u2293\u2294\nProposition 4. A formula \u03c8 holds in all minimal models of the formula \u03c6 iff any model \u03bd of \u03c6 where \u00ac\u03c8 holds is not a minimal model of \u03c6.\n[\u03c6 |=min \u03c8] \u21d4 [(\u2200\u03bd) ((\u03bd |= \u03c6 \u2227 \u00ac\u03c8) \u21d2 (\u2203\u03bd \u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6))]\nProof. In classical logic, for any assignment \u03bd either \u03bd |= \u03c8 or \u03bd |= \u00ac\u03c8 but not both. Let \u03c6 |=min \u03c8 and let \u03bd be a model \u03c6 such that \u03bd |= \u03c6\u2227 \u00ac\u03c8. Then \u03bd must not be minimal because \u03bd |= \u00ac\u03c8 and therefore \u03bd would be a minimal model of \u03c6 not satisfying \u03c8.\nIf any model of \u03c6 that satisfies \u00ac\u03c8 is not minimal, then all the minimal models of \u03c6 must satisfy \u03c8. \u2293\u2294\nProposition 5. Let \u03bd be a model of a formula \u03c6. The model \u03bd is not a minimal model of \u03c6 iff there exists a set of variables S such that \u03bd is a model of the formula \u03c6[S 7\u2192 0], and, \u03bd(x) = 1 for some x \u2208 S.\n(\u2203\u03bd\u2032)(\u03bd\u2032 < \u03bd \u2227 \u03bd\u2032 |= \u03c6) \u21d4 (\u2203S \u2286 V ) (\u03bd |= \u03c6[S 7\u2192 0] \u2227 (\u2203x \u2208 S)(\u03bd(x) = 1)) (5)\nProof. If \u03bd is not a minimal model of \u03c6, then there exists some model \u03bd\u2032 such that \u03bd\u2032 < \u03bd. By definition, there exists some set of variables S such that \u03bd\u2032(x) = 0 and \u03bd(x) = 1 for x \u2208 S, and, \u03bd\u2032(x) = \u03bd(x) for x /\u2208 S. Then \u03bd is a model of \u03c6[S 7\u2192 0] because \u03bd\u2032 is a model of \u03c6 and \u03bd\u2032 assigns 0 to all variables in S.\nLet S be a a set of variables such that \u03bd |= \u03c6[S 7\u2192 0] and (\u2203x \u2208 S)(\u03bd(x) = 1). Let us define the assignment \u03bd\u2032 such that \u03bd\u2032(x) = 0 if x \u2208 S and \u03bd\u2032(x) = \u03bd(x) otherwise. Then \u03bd\u2032 is a model of \u03c6 because \u03c6[S 7\u2192 0] corresponds to a partial evaluation of \u03c6. The model \u03bd\u2032 is smaller than \u03bd because it differs only on the variables in S, where \u03bd\u2032 is 0. The model \u03bd\u2032 is strictly smaller than \u03bd because at least one of the variables from S are assigned the value 1 by \u03bd due to the condition (\u2203x \u2208 S)(\u03bd(x) = 1). Hence, \u03bd\u2032 < \u03bd and therefore \u03bd is not minimal. \u2293\u2294\nProposition 6. Let \u03bd be a model of a formula \u03c6 such that \u03bd(x) = 1 for a variable x. If the variable x is free for negation, then there exists a model \u03bd\u2032 of \u03c6 such that \u03bd\u2032 < \u03bd an \u03bd\u2032(x) = 0.\nProof. Since the set of considered variables V is finite, there are no infinitely decreasing chains in the ordering < and therefore for the model \u03bd there must be a model \u03bd\u2032 \u2264 \u03bd that is minimal. Since x is free for negation, it must have the value 0 in such model \u03bd\u2032. \u2293\u2294\nProposition 8. Let \u03c6 and \u03c8 be formulas such that \u03c6 |=min \u03c8. The formula \u03c6 \u2227 \u03c8 has the same set of minimal models as the formula \u03c6. In particular, if \u03c6 |=min \u00acx then (\u03c6 \u2227 \u00acx) |=min \u00acy iff \u03c6 |=min \u00acy.\nProof. Since the formula \u03c8 holds in all minimal models of \u03c6, all the minimal models of \u03c6 are models of \u03c6\u2227\u03c8. Since models of the formula \u03c6\u2227\u03c8 form a subset of the models of the formula \u03c8, the minimal models of \u03c6 are also minimal in \u03c6 \u2227 \u03c8. To show that any minimal model of \u03c6 \u2227 \u03c8 is also a minimal model of \u03c6, consider for contradiction that there is an assignment \u03bd such that \u03bd is a minimal model of \u03c6\u2227\u03c8 but is not a minimal model of \u03c6. Since \u03bd is not minimal in \u03c6 and there are no infinitely decreasing chains in <, there must be a minimal model \u03bd\u2032 of \u03c6 such that \u03bd\u2032 < \u03bd. Since \u03bd is minimal in \u03c6\u2227\u03c8, \u03bd\u2032 is not a model of \u03c6\u2227\u03c8 but that is a contradiction because all minimal models of \u03c6 are also models of \u03c8. \u2293\u2294"}, {"heading": "B Deciding Entailment in Full ECWA", "text": "The article presents an algorithm that enables us to decide whether a formula holds in all minimal models of another formula. This enables us to decide entailment for ECWA and circumscription with Q = Z = \u2205 (see section 2). To provide a semantic characterization supporting arbitrary Q and Z, the concept of minimality of models is extended.\nDefinition 4. Let P , Q, and Z be a partitioning of the variables V . For variable assignments \u03bd and \u00b5, we write \u03bd \u2264(P,Z) \u00b5 if \u03bd(x) = \u00b5(x) for all x \u2208 Q, and, \u03bd(x) \u2264 \u00b5(x) for all x \u2208 P . We write \u03bd <(P,Z) \u00b5 if \u03bd \u2264(P,Z) \u00b5 and not \u00b5 \u2264(P,Z) \u03bd.\nWe write \u03c6 |=(P,Z) \u03c8 iff \u03c8 holds in all models that are minimal with respect to the ordering <(P,Z).\nThe entailment |=(P,Z) corresponds to deduction from the closure defined by ECWA and analogously for circumscription [1]. So we focus on deciding \u03c6 |=(P,Z) \u03c8. Observe that \u03c6 |=(P,Z) \u03c8 coincides with \u03c6 |=min \u03c8 when Q = Z = \u2205. In terms of computational complexity, deciding \u03c6 |=(P,Z) \u03c8 is not more difficult than deciding \u03c6 |=min \u03c8 since both problems are \u03a0P2 -complete [6].\nWe show that Algorithm 1 can be easily modified to decide \u03c6 |=(P,Z) \u03c8. The structure of the algorithm remains the same, hence here we focus on the form of the abstraction and how it is refined. Recall that the abstraction captures the statement that any model of \u03c6 that violates \u03c8 is not a minimal model. In particular, a smaller model can be found (see (8)). The following formula replicates the same idea for the minimality defined by <(P,Z).\n(\u03c6 \u2227 \u00ac\u03c8) \u21d2 \u2228\n(S,Z0,Z1)\u2208W\n(\n\u03c6[S 7\u2192 0, Z0 7\u2192 0, Z1 7\u2192 1] \u2227 \u2228 x\u2208S x ) ,\nwhere W \u2286 {(S,Z0, Z1) | S \u2286 P,Z0 \u2286 Z,Z1 \u2286 Z} (12)\nIn this case, the abstraction is defined by a set of triples for each of the triples determines which variables are flipped to 0 and which are flipped to 1. Since variables from P can only be flipped to 0 and variables from Q cannot be flipped at all, the right-hand side of the abstraction is indeed permitting only models smaller in the sense of <(P,Z).\nWhen the algorithm tries to refine the abstraction, it needs to find a model \u03bd\u2032 <(P,Z) \u03bd, where \u03bd is a model of the negation of the abstraction. We observe that \u03bd\u2032 must be a model of the following formula.\n\u03c6 \u2227 \u2227\n\u03bd(x)=0\u2227x\u2208P\n\u00acx \u2227 \u2228\n\u03bd(x)=1\u2227x\u2208P\n\u00acx \u2227 \u2227\n\u03bd(x)=0\u2227x\u2208Q\n\u00acx \u2227 \u2227\n\u03bd(x)=1\u2227x\u2208Q\nx (13)\nThe abstraction is refined by adding a triple into the set W . The triple is defined by the following elements.\nS = {x | x \u2208 P \u2227 \u03bd(x) = 1 \u2227 \u03bd\u2032(x) = 0} Z0 = {x | x \u2208 Z \u2227 \u03bd(x) = 1 \u2227 \u03bd\u2032(x) = 0} Z1 = {x | x \u2208 Z \u2227 \u03bd(x) = 0 \u2227 \u03bd\u2032(x) = 1}\n(14)"}], "references": [{"title": "The complexity of closed world reasoning and circumscription", "author": ["M. Cadoli", "M. Lenzerini"], "venue": "AAAI Conference on Artificial Intelligence. pp. 550\u2013555", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1990}, {"title": "Using the Davis and Putnam procedure for an efficient computation of preferred models", "author": ["T. Castell", "C. Cayrol", "M. Cayrol", "D.L. Berre"], "venue": "European Conference on Artificial Intelligence. pp. 350\u2013354", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1996}, {"title": "Counterexample-guided abstraction refinement", "author": ["E.M. Clarke", "O. Grumberg", "S. Jha", "Y. Lu", "H. Veith"], "venue": "Computer Aided Verification. pp. 154\u2013169", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2000}, {"title": "Nonmonotonic reasoning: Towards efficient calculi and implementations", "author": ["J. Dix", "U. Furbach", "I. Niemel\u00e4"], "venue": "Voronkov, A., Robinson, A. (eds.) Handbook of Automated Reasoning, chap. 19, pp. 1241\u20131354. North Holland", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "Solving advanced reasoning tasks using quantified boolean formulas", "author": ["U. Egly", "T. Eiter", "H. Tompits", "S. Woltran"], "venue": "AAAI Conference on Artificial Intelligence. pp. 417\u2013422", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Propositional circumscription and extended closed-world reasoning are \u03a0  2 -complete", "author": ["T. Eiter", "G. Gottlob"], "venue": "Theor. Comput. Sci. 114(2), 231\u2013245", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1993}, {"title": "Combining answer set programming with description logics for the Semantic Web", "author": ["T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits"], "venue": "Artif. Intell. 172(12-13), 1495\u20131539", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2008}, {"title": "Predicate abstraction for software verification", "author": ["C. Flanagan", "S. Qadeer"], "venue": "Principles of programming languages (POPL). pp. 191\u2013202. ACM", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2002}, {"title": "On the relationship between circumscription and negation as failure", "author": ["M. Gelfond", "H. Przymusinska", "T.C. Przymusinski"], "venue": "Artif. Intell. 38(1), 75\u201394", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1989}, {"title": "Solving optimization problems with DLL", "author": ["E. Giunchiglia", "M. Maratea"], "venue": "European Conference on Artificial Intelligence. pp. 377\u2013381", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "Unfolding partiality and disjunctions in stable model semantics", "author": ["T. Janhunen", "I. Niemel\u00e4", "D. Seipel", "P. Simons", "J.H. You"], "venue": "ACM Trans. Comput. Log. 7(1), 1\u201337", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "Capturing parallel circumscription with disjunctive logic programs", "author": ["T. Janhunen", "E. Oikarinen"], "venue": "European Conf. on Logics in Artif. Intell. pp. 134\u2013146", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "How to complete an interactive configuration process? In: Conference on Current Trends in Theory and Practice of Computer Science", "author": ["M. Janota", "G. Botterweck", "R. Grigore", "J. Marques-Silva"], "venue": "pp. 528\u2013539", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2010}, {"title": "Foundations of logic programming", "author": ["V. Lifschitz"], "venue": "Principles of Knowledge Representation pp. 69\u2013127", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1996}, {"title": "Circumscription - a form of non-monotonic reasoning", "author": ["J. McCarthy"], "venue": "Artif. Intell. 13(1-2), 27\u201339", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1980}, {"title": "Applications of circumscription to formalizing common-sense knowledge", "author": ["J. McCarthy"], "venue": "Artif. Intell. 28(1), 89\u2013116", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1986}, {"title": "On indefinite databases and the closed world assumption", "author": ["J. Minker"], "venue": "Conference on Automated Deduction. pp. 292\u2013308", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1982}, {"title": "Implementing circumscription using a tableau method", "author": ["I. Niemel\u00e4"], "venue": "European Conference on Artificial Intelligence. pp. 80\u201384", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1996}, {"title": "circ2dlp - translating circumscription into disjunctive logic programming", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Logic Programming and Nonmonotonic Reasoning. pp. 405\u2013409", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "An algorithm to compute circumscription", "author": ["T.C. Przymusinski"], "venue": "Artif. Intell. 38(1), 49\u201373", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1989}, {"title": "Solving satisfiability problems with preferences", "author": ["E.D. Rosa", "E. Giunchiglia", "M. Maratea"], "venue": "Constraints, An International Journal", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2010}, {"title": "On the complexity of derivation in propositional calculus", "author": ["G.S. Tseitin"], "venue": "Studies in constructive mathematics and mathematical logic 2(115-125), 10\u201313", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1968}, {"title": "Deduction in non-Horn databases", "author": ["A.H. Yahya", "L.J. Henschen"], "venue": "Journal of Automated Reasoning 1(2), 141\u2013160", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1985}], "referenceMentions": [{"referenceID": 14, "context": "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].", "startOffset": 91, "endOffset": 101}, {"referenceID": 16, "context": "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].", "startOffset": 91, "endOffset": 101}, {"referenceID": 15, "context": "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].", "startOffset": 91, "endOffset": 101}, {"referenceID": 0, "context": "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being \u03a0 2 -complete [6].", "startOffset": 85, "endOffset": 90}, {"referenceID": 5, "context": "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being \u03a0 2 -complete [6].", "startOffset": 85, "endOffset": 90}, {"referenceID": 5, "context": "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being \u03a0 2 -complete [6].", "startOffset": 243, "endOffset": 246}, {"referenceID": 6, "context": "Nonmonotonic reasoning finds a wide range of applications in Artificial Intelligence (AI), but also in description logics [7]", "startOffset": 122, "endOffset": 125}, {"referenceID": 12, "context": "and in interactive configuration [13], among many others.", "startOffset": 33, "endOffset": 37}, {"referenceID": 19, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 116, "endOffset": 120}, {"referenceID": 17, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 139, "endOffset": 143}, {"referenceID": 4, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 186, "endOffset": 189}, {"referenceID": 13, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 230, "endOffset": 240}, {"referenceID": 11, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 230, "endOffset": 240}, {"referenceID": 18, "context": "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].", "startOffset": 230, "endOffset": 240}, {"referenceID": 2, "context": "To cope with this issue, we utilize a technique inspired in counterexample guided abstraction refinement (CEGAR), widely used in model checking [3].", "startOffset": 144, "endOffset": 147}, {"referenceID": 0, "context": "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].", "startOffset": 145, "endOffset": 152}, {"referenceID": 5, "context": "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].", "startOffset": 145, "endOffset": 152}, {"referenceID": 3, "context": "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].", "startOffset": 145, "endOffset": 152}, {"referenceID": 0, "context": "Following [1,6], a closure operation is defined for CWR rules as follows:", "startOffset": 10, "endOffset": 15}, {"referenceID": 5, "context": "Following [1,6], a closure operation is defined for CWR rules as follows:", "startOffset": 10, "endOffset": 15}, {"referenceID": 16, "context": "For each CWR rule below, a formula K is free for negation if and only if the corresponding condition holds: GCWA (Generalized CWA [17]): K is a positive literal and for every positive clause B such that \u03c6 2 B it holds that \u03c6 2 B \u2228K.", "startOffset": 130, "endOffset": 134}, {"referenceID": 22, "context": "EGCWA (Extended GCWA [24]): K is a conjunction of positive literals and for every positive clause B such that \u03c6 2 B it holds that \u03c6 2 B \u2228K.", "startOffset": 21, "endOffset": 25}, {"referenceID": 22, "context": "ECWA (Extended CWA [24]): K is an arbitrary formula not involving literals from Z, and for every positive clause B whose literals belong to P\u222aQ\u222aQ, such that \u03c6 2 B, it holds that \u03c6 2 B \u2228K.", "startOffset": 19, "endOffset": 23}, {"referenceID": 0, "context": "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].", "startOffset": 74, "endOffset": 81}, {"referenceID": 5, "context": "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].", "startOffset": 74, "endOffset": 81}, {"referenceID": 3, "context": "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].", "startOffset": 74, "endOffset": 81}, {"referenceID": 14, "context": "Originally, McCarthy defined circumscription in the context of first order logic as a closure of the given theory that considers only predicates with minimal extension [15].", "startOffset": 168, "endOffset": 172}, {"referenceID": 8, "context": "It is well-known that for the propositional case, circumscription is equivalent to ECWA [9].", "startOffset": 88, "endOffset": 91}, {"referenceID": 16, "context": "[17,1,6]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 0, "context": "[17,1,6]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 5, "context": "[17,1,6]).", "startOffset": 0, "endOffset": 8}, {"referenceID": 16, "context": "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.", "startOffset": 73, "endOffset": 81}, {"referenceID": 0, "context": "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.", "startOffset": 73, "endOffset": 81}, {"referenceID": 5, "context": "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.", "startOffset": 73, "endOffset": 81}, {"referenceID": 2, "context": "The approach of searching for the right abstraction follows the CounterExample Guided Abstract Refinement (CEGAR) loop [3].", "startOffset": 119, "endOffset": 122}, {"referenceID": 21, "context": "In the initialization phase, the negation of this abstraction is \u03c6 \u2227 x \u2227 \u00ac\u03c6[x 7\u2192 0] and is computed using the Tseitin transformation [23].", "startOffset": 133, "endOffset": 137}, {"referenceID": 9, "context": "Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].", "startOffset": 86, "endOffset": 93}, {"referenceID": 20, "context": "Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].", "startOffset": 86, "endOffset": 93}, {"referenceID": 12, "context": "A majority of these are valid software configurations (motivated by [13]).", "startOffset": 68, "endOffset": 72}, {"referenceID": 18, "context": "The alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program.", "startOffset": 56, "endOffset": 60}, {"referenceID": 10, "context": "The alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program.", "startOffset": 137, "endOffset": 141}, {"referenceID": 2, "context": "While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.", "startOffset": 57, "endOffset": 62}, {"referenceID": 7, "context": "While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.", "startOffset": 57, "endOffset": 62}, {"referenceID": 4, "context": "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].", "startOffset": 79, "endOffset": 82}, {"referenceID": 13, "context": "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].", "startOffset": 95, "endOffset": 102}, {"referenceID": 11, "context": "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].", "startOffset": 95, "endOffset": 102}, {"referenceID": 1, "context": "On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21].", "startOffset": 124, "endOffset": 130}, {"referenceID": 20, "context": "On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21].", "startOffset": 124, "endOffset": 130}], "year": 2013, "abstractText": "Circumscription is a representative example of a nonmonotonic reasoning inference technique. Circumscription has often been studied for first order theories, but its propositional version has also been the subject of extensive research, having been shown equivalent to extended closed world assumption (ECWA). Moreover, entailment in propositional circumscription is a well-known example of a decision problem in the second level of the polynomial hierarchy. This paper proposes a new Boolean Satisfiability (SAT)-based algorithm for entailment in propositional circumscription that explores the relationship of propositional circumscription to minimal models. The new algorithm is inspired by ideas commonly used in SAT-based model checking, namely counterexample guided abstraction refinement. In addition, the new algorithm is refined to compute the theory closure for generalized close world assumption (GCWA). Experimental results show that the new algorithm can solve problem instances that other solutions are unable to solve.", "creator": "LaTeX with hyperref package"}}}