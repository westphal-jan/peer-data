{"id": "1011.4833", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Nov-2010", "title": "A Logical Charaterisation of Ordered Disjunction", "abstract": "In instead paper feel consider first rationale problems for the ordered disjunction operator ' x ' for he Brewka, Niemel \\ \" its it Syrj \\ \" anen opened should Logic Programs which Ordered Disjunctions (LPOD ). LPODs they used once which acceptability into logic networks and the really one reasoning. Their axiom is similarly by first translating the LPOD when it will between level offers (referred eventually planning) as on defiance turned loyalty relation among under anybody sets thus need same programs. We concentrate moving into time must and watching sure a ideal scripture several and ordered interrelationship still a forms utility. the definition a Here - each - There allowed thwarted the answer first it that remaining programs central turned direct way. We create this characterisation not only on centers an popular ensuring for LPODs, once also addition tabs on properties (years strongly equivalent numerical) fact through ' dimensional ' terminal, like no often, plan distributivity that regards to conjunction except regular isometry. We today makes giving basis they full extension project followed K \\ \" arger, Lopes, Olmedilla by Polleres, if combines ' f ' a every causation.", "histories": [["v1", "Mon, 22 Nov 2010 14:57:53 GMT  (31kb)", "http://arxiv.org/abs/1011.4833v1", "ASPOCP 2010"]], "COMMENTS": "ASPOCP 2010", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["pedro cabalar"], "accepted": false, "id": "1011.4833"}, "pdf": {"name": "1011.4833.pdf", "metadata": {"source": "CRF", "title": "A Logical Characterisation of Ordered Disjunction", "authors": ["Pedro Cabalar"], "emails": ["cabalar@udc.es"], "sections": [{"heading": null, "text": "ar X\niv :1\n01 1.\n48 33\nv1 [\ncs .L\nO ]\n2 2\nN ov"}, {"heading": "1 Introduction", "text": "Based on the answer set (or stable model) semantics [10] for logic programs, Answer Set Programming (ASP) [17,18] has become a successful paradigm for declarative problem solving. Typically, a logic program in ASP is used to encode some constraint-based problem in such a way that the answer sets of the program correspond to the problem solutions. In many practical scenarios, however, the set of feasible solutions is considerably large and the main problem, from the knowledge representation viewpoint, is not specifying them but selecting the most preferred ones under certain criteria instead. Although different approaches for representing preferences in ASP have been proposed (see [5] for a survey), one that has recently received much attention is the formalism of Logic Programs with Ordered Disjunction (LPOD) [3], probably due to its simplicity and expressiveness. This approach essentially consists in introducing a new operator \u2018\u00d7\u2019 standing for ordered disjunction (with its corresponding semantics\n\u22c6 This research was partially supported by Spanish MEC project TIN-2009-14562C05-04 and Xunta de Galicia project INCITE08-PXIB105159PR.\nin terms of answer sets), plus several ordering relations for selecting preferred models among the obtained answer sets. LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions. Other ASP extensions like CR-Prolog, have also incorporated the use of ordered disjunctions [1]. The semantics of an LPOD is defined in two steps. First, the program with ordered disjunctions is translated into a set of normal programs, called split programs, whose answer sets become the potential solutions. In a second step, one of three possible preference relations is imposed among the answer sets of these split programs. These answer sets of the split programs can also be captured by reduct transformations, like the originally introduced in [3] or the one later proposed in [6].\nIn this paper we concentrate on the first step, that is, in the definition of potential answer sets for LPODs, and show that they can be directly captured by a suitable definition of the ordered disjunction connective \u2018\u00d7\u2019 as a derived operator in the logic of Here-and-There (HT) [11], so that LPODs can be seen as nothing else but regular theories inside the nonmonotonic formalism of Equilibrium Logic [19] (the nonmonotonic version of HT). Equilibrium Logic has been extensively studied in ASP, as it yields a logical characterisation for the answer set semantics, capturing concepts such as the strong equivalence of programs [15] and providing a means to generalise all previous extensions to the the most general syntax of arbitrary propositional [8] and first order [7] theories. Our logical characterisation of \u00d7 allows not only an alternative method for translating LPODs into regular logic programs, but enables the study of \u2018\u00d7\u2019 as a logical connective, so we can analyse its main properties like its behaviour with respect to distributivity or nesting with other connectives.\nThe rest of the paper is organised as follows. The next section contains an overview of the basic definitions of Equilibrium Logic, ASP and LPODs. Section 3 introduces the characterisation of ordered disjunction and studies some of its main properties, including the correspondence to the original definition of answer sets for LPODs. Section 4 contains a comparison to DLPODs and finally, Section 5 concludes the paper."}, {"heading": "2 Preliminaries", "text": "We recall the basic definitions of the propositional1 logic of HT and Equilibrium Logic. The syntax is the same as in classical propositional logic: a well formed formula results from combining atoms in a finite set \u03a3 (called the signature) with the usual operators \u2192,\u2227,\u2228,\u22a5 and parentheses. We assume the standard precedence among binary operators, that is, \u2227 \u227a \u2228 \u227a \u2192. The formulas \u00acF , \u22a4, F \u2190 G and F \u2194 G are abbreviations that respectively stand for F \u2192 \u22a5,\n1 For simplicity sake, we will focus here on ordered disjunction inside programs without variables.\n\u22a5 \u2192 \u22a5, G \u2192 F and (F \u2192 G) \u2227 (F \u2190 G). As usual, a literal is an atom p or its negation \u00acp.\nGiven a set of atoms I and a formula F , we write I |= F to represent classical satisfaction. The semantics ofHT starts from defining an interpretation as a pair \u3008H,T \u3009 of sets of atoms (standing for \u201chere\u201d and \u201cthere\u201d) where H \u2286 T . We say that an interpretation \u3008H,T \u3009 satisfies a formula F , by abuse of notation written \u3008H,T \u3009 |= F as in classical logic, when one of the following recursive conditions hold:\n1. \u3008H,T \u3009 |= p if p \u2208 H , for any atom p. 2. \u3008H,T \u3009 6|= \u22a5. 3. \u3008H,T \u3009 |= F \u2227G if \u3008H,T \u3009 |= F and \u3008H,T \u3009 |= G. 4. \u3008H,T \u3009 |= F \u2228G if \u3008H,T \u3009 |= F or \u3008H,T \u3009 |= G. 5. \u3008H,T \u3009 |= F \u2192 G if both (i) T |= F \u2192 G; and (ii) \u3008H,T \u3009 6|= F or \u3008H,T \u3009 |= G.\nAmbiguity in the use of |= is removed depending on the interpretation we use in the left hand. Thus, note that in condition (i) of line 5, we are actually referring to classical satisfaction. Some useful well-known properties relating HT and classical satisfaction are mentioned below.\nProposition 1. For any interpretation \u3008H,T \u3009 and any formula F :\n1. \u3008H,T \u3009 |= F implies T |= F . 2. \u3008T, T \u3009 |= F iff T |= F . 3. \u3008H,T \u3009 |= \u00acF iff T |= \u00acF . \u2737\nBy \u2261c we understand equivalence in classical logic. A theory is a set of formulas. As usual, an interpretation \u3008H,T \u3009 is said to be a model of a theory H , also written \u3008H,T \u3009 |= H , when \u3008H,T \u3009 satisfies all the formulas in H .\nThe following are some HT valid equivalences:\n\u00ac(F \u2228G) \u2194 \u00acF \u2227 \u00acG (1)\n\u00ac(F \u2227G) \u2194 \u00acF \u2228 \u00acG (2)\nF \u2227 (G \u2228H) \u2194 (F \u2227G) \u2228 (F \u2227H) (3)\nF \u2228 (G \u2227H) \u2194 (F \u2228G) \u2227 (F \u2228H) (4)\nF \u2227 \u00acF \u2194 \u22a5 (5)\n(F \u2192 (G \u2192 H)) \u2194 (F \u2227G \u2192 H) (6)\nFor instance, HT satisfies De Morgan\u2019s laws (1), (2), and distributivity (3), (4).\nDefinition 1 (Equilibrium model). An HT interpretation \u3008T, T \u3009 is an equilibrium model of a theory H if \u3008T, T \u3009 |= H and there is no H \u2282 T such that \u3008H,T \u3009 |= H. \u2737\nEquilibrium Logic is the (nonmonotonic) logic induced by equilibriummodels. An interesting concept for nonmonotonic reasoning is the idea of strong equivalence. Two theories H1 and H2 are said to be strongly equivalent, written H1 \u2261s H2, if H1 \u222a\u2206 and H2 \u222a\u2206 have the same equilibrium models, for any theory \u2206.\nTheorem 1 (From [15]). Two theories H1, H2 are strongly equivalent iff they are equivalent in HT. \u2737"}, {"heading": "2.1 Logic programs", "text": "We begin introducing some preliminary notation that will be useful later. Let A be a (possibly empty) list of (possibly repeated) formulas. We write |A| to stand for the length of A. For any k \u2208 {1, . . . , |A|}, by A[k] we mean the k-th expression in A and by A[1..k], the prefix of A of length k, that is, A[1] . . .A[k]. For a binary operator \u2299 \u2208 {\u2228,\u2227,\u00d7}, by (\u2299A) we mean the formula resulting from the repeated application of \u2299 to all formulas in A in the same ordering. As an example, given the sequence of atoms A = (a, b, c, d, e), the expression (\u00d7A[1..3]) represents the formula a\u00d7b\u00d7c. We write \u00acA to stand for the sequence of formulas \u00acA[1] . . .\u00acA[k] being k = |A|. An empty conjunction is understood as \u22a4 whereas an empty disjunction (both ordered or regular) is understood as \u22a5. The concatenation of two lists of formulas, A and B, is simply written as AB.\nA logic program is a set of rules of the form:\n(\u2228A) \u2228 (\u2228\u00acA\u2032) \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) (7)\nwhere A,A\u2032,B and B\u2032 are lists of atoms. We respectively call head and body to the consequent and antecedent of the implication above. A rule with an empty head \u22a5 (that is, |A| + |A\u2032| = 0) is called a constraint. A rule with an empty body \u22a4 (that is, |B| + |B\u2032| = 0) is called a fact, and we usually write the head F instead of F \u2190 \u22a4. A rule is said to be normal when |A| = 1 and |A\u2032| = 0. A rule is positive when |A\u2032| = |B\u2032| = 0. We extend the use of these adjectives to a program, meaning that all its rules are of the same kind.\nAnswer sets of a program P are defined in terms of the classical GelfondLifscthiz\u2019s reduct [10], that is extended2 as follows for the syntactic case we are considering (disjunctive heads with default negation [12]). The reduct of a program P with respect to a set of atoms I, written P I , consists of a rule like (\u2228A) \u2190 (\u2227B) per each rule in P of the form (7) that satisfies I |= (\u2227A\u2032) \u2227 (\u2227\u00acB\u2032). We say that a set of atoms I is an answer set of a program P if I is a minimal model of P I .\nTheorem 2 (From [15]). A set of atoms T is an answer set of a program P iff \u3008T, T \u3009 is an equilibrium model of P . \u2737"}, {"heading": "2.2 Logic Programs with Ordered Disjunction", "text": "A logic program with ordered disjunction (LPOD) is a set of rules of the form:\n(\u00d7A) \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) (8)\nwhere A,B and B\u2032 are lists of atoms. We say that a set of atoms I satisfies an LPOD rule r like (8), written I |= r, when I |= (\u2228A) \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) in classical logic.\n2 In fact, [8] introduced a different, more general reduct that allows defining answer sets for arbitrary theories, which happen to coincide with equilibrium models. We use here the more restricted, traditional version for comparison purposes.\nFor each LPOD rule r like (8), we define its k-th option, written rk, with k \u2208 {1, . . . , |A|}, as the normal rule:\nA[k] \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA[1..k\u22121])\nA normal logic program P \u2032 is a split program of P if it is the result of replacing each LPOD rule r \u2208 P by one of its possible options rk. A set of atoms I is an answer set of P if it is an answer set of some split program P \u2032 of P .\nExample 1 (From [3]). Let P1 be the LPOD:\na\u00d7 b \u2190 \u00acc b\u00d7 c \u2190 \u00acd\nThis LPOD has four split programs:\na \u2190 \u00acc b \u2190 \u00acd a \u2190 \u00acc c \u2190 \u00acd \u2227 \u00acb b \u2190 \u00acc \u2227 \u00aca b \u2190 \u00acd b \u2190 \u00acc \u2227 \u00aca c \u2190 \u00acd \u2227 \u00acb\nthat yield three answer sets {a, b}, {c} and {b}. \u2737\nAs explained in [3], answer sets of LPODs can also be described in terms of a program reduct, instead of using split programs.\nDefinition 2 (\u00d7-reduct). The \u00d7-reduct of an LPOD rule r like (8) with respect to a set of atoms I denoted as rI\n\u00d7 and defined as the set of rules:\nA[i] \u2190 (\u2227B) (9)\nfor all i = 1, . . . , |A| such that I |= (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA[1..i\u22121]) \u2227A[i]. \u2737\nAs expected, the \u00d7-reduct of an LPOD P with respect to I, written P I \u00d7 is the union of all rI\n\u00d7 for all LPOD rules r \u2208 P . For instance, for I = {b, c} and P :\na\u00d7 b \u2190 c \u2227 \u00acd (10)\nd\u00d7 a \u2190 \u00acb (11)\nd\u00d7 e \u2190 \u00aca (12)\nthe reduct P I \u00d7 would be the rule {b \u2190 c}. Notice that P I \u00d7 defined in this way is always a normal positive logic program and so it has a least model [20].\nTheorem 3 (From [3]). A set of atoms I is an answer set of an LPOD P iff I |= P and I is the least model of P I\n\u00d7 . \u2737\nIt is important to note that I |= P I \u00d7 does not imply I |= P , and thus, the latter is also required in the above theorem. For instance, in the last example, the interpretation \u2205 is the least model of P I\n\u00d7 but does not satisfy the LPOD rule\n(12). Although, as said in the introduction, we will concentrate on the answer sets of split programs, we include here the definition of the three ordering relations for selecting preferred answer sets among them. We say that an LPOD rule r\nlike (8) is satisfied to degree j \u2208 {1, . . . , |A|} by a set of atoms I, written I |=j r, when: I does not satisfy the body of r and j = 1; I satisfies the body of r and j is the minimum index for which A[j] \u2208 I. We define degI(r) def = j when I |=j r and define the set Ij(P ) def = {r \u2208 P | I |=j r}. Given two answer sets I, J of a given LPOD:\n1. I is cardinality-preferred to J , written I >c J , when for some truth degree k, |Ik(P )| > |Jk(P )| whereas |Ii(P )| = |J i(P )| for all i < k. 2. I is inclusion-preferred to J , written I >i J , when for some truth degree k, Ik(P ) \u2282 Jk(P ) while Ii(P )| = J i(P ) for all i < k. 3. I is Pareto-preferred to J , written I >p J , if for some rule r \u2208 P , degI(r) < degJ(r) whereas for no rule r \u2032 \u2208 P , degI(r\u2032) > degJ(r\u2032)."}, {"heading": "3 The Ordered Disjunction Operator", "text": "Let us consider the introduction of \u00d7 in HT as the following derived operator:\nF \u00d7G def = F \u2228 (\u00acF \u2227G) (13)\nAlthough in classical logic, (13) \u2261c F \u2228 G, this equivalence does not hold in HT, that is (13) 6\u2261s F \u2228 G. To see why, adding G, the two disjunctions have different equilibrium models: {F\u2228G,G} has one equilibrium model {G}, whereas {F \u00d7G,G} also has a second equilibrium model {F,G}. We discuss now some basic properties of \u00d7 operator.\nProposition 2 (Negation). The negation of an ordered and a regular disjunction are strongly equivalent:\n\u00ac(F \u00d7G) \u2261s \u00acF \u2227 \u00acG \u2261s \u00ac(F \u2228G)\nProof. Applying De Morgan laws, \u00ac(F \u2228\u00acF \u2227G) amounts to \u00acF \u2227 (\u00ac\u00acF \u2228\u00acG) which, by distributivity, is equivalent to \u00acF \u2227 \u00ac\u00acF \u2228 \u00acF \u2227 \u00acG, but the first disjunct can be removed, since \u00acF \u2227 \u00ac\u00acF is inconsistent in HT by (5). \u2737\nProposition 3 (Truth constants). These are some strongly equivalent simplifications:\n(F \u00d7 F ) \u2261s F (14)\n(\u22a5\u00d7 F ) \u2261s F (15)\n(F \u00d7\u22a5) \u2261s F (16)\n(\u22a4\u00d7 F ) \u2261s \u22a4 (17)\n(F \u00d7\u22a4) \u2261s (F \u2228 \u00acF ) (18)\n\u2737\nNote that the main difference with respect to ordinary disjunction when dealing with truth constants is (18). Equivalences (15) and (16) show that \u22a5 acts as a neutral element for ordered disjunction. This means that we can safely consider an empty ordered disjunction as \u22a5 (as happens with \u2228 too).\nDistributivity with respect to conjunction is satisfied in the following cases:\nF \u2227 (G\u00d7H) \u2261s (F \u2227G)\u00d7 (F \u2227H)\n(F \u00d7G) \u2227H \u2261s (F \u2227H)\u00d7 (G \u2227H)\nF \u00d7 (G \u2227H) \u2261s (F \u00d7G) \u2227 (F \u00d7H)\nbut the following pair of formulas\n(F \u2227G)\u00d7H (F \u00d7H) \u2227 (G\u00d7H)\nare not strongly equivalent. In fact, they have different answer sets. The first rule has equilibrium models {F,G} and {H} whereas the second has two additional ones {F,H} and {G,H}. Distributivity between disjunctions only holds in the following case:\nF \u00d7 (G \u2228H) \u2261s (F \u00d7G) \u2228 (F \u00d7H)\nbut the following list shows pairs of formulas that are not strongly equivalent:\nF \u2228 (G\u00d7H) (F \u2228G)\u00d7 (F \u2228H) (19)\n(F \u00d7G) \u2228H (F \u2228H)\u00d7 (G \u2228H) (20)\n(F \u2228G)\u00d7H (F \u00d7H) \u2228 (G\u00d7H) (21)\nTake line (19), for instance. Adding the atom H , the left rule yields two equilibrium models {G,H} and {H}, whereas the second rule allows a third equilibrium model {F,H}. Intuitively, adding H to F \u2228 (G \u00d7H) will always make the second disjunct to be true (both when G holds and when it does not). So, there is no need to make F true. By a similar reason, in the case of line (20), after adding atom G, the first rule yields two equilibrium models, {F,G} and {G} (there is no need to make H true), while the second rule yields a third solution {G,H}. Finally, for line (21), if we add the atom H to the first expression, we get three equilibrium models, {F,H}, {G,H}, and {H}, whereas for the second expression, the addition of H only yields the equilibrium model {H} itself.\nProposition 4 (Associativity). The \u00d7 operator is associative, that is:\nF \u00d7 (G\u00d7H) \u2261s (F \u00d7G)\u00d7H\nProof."}, {"heading": "F \u00d7 (G \u00d7H) \u2261s F \u2228 \u00acF \u2227 (G \u2228 \u00acG \u2227H) By definition of \u00d7 .", "text": "\u2261s F \u2228 \u00acF \u2227G \u2228 \u00acF \u2227 \u00acG \u2227H Distribuitivity. \u2261s (F \u00d7G) \u2228 \u00acF \u2227 \u00acG \u2227H Definition of \u00d7 . \u2261s (F \u00d7G) \u2228 \u00ac(F \u00d7G) \u2227H By Proposition 2. \u2261s (F \u00d7G)\u00d7H Definition of \u00d7 .\n\u2737\nThe third line of the proof suggests the following translation for a sequence of consecutive applications of \u00d7.\nTheorem 4. Let A be a sequence of |A| = n \u2265 0 formulas. Then, the formula (\u00d7A) is strongly equivalent to:\n\u2228\ni=1,...,n\n(\u2227\u00acA[1..i\u22121]) \u2227A[i] (22)\nProof. By induction on n = |A|. When n = 0, both (\u00d7A) and (22) correspond to \u22a5. Assume it is proved for any sequence of length n \u2212 1, with n > 0. Since \u00d7 is associative, we can write (\u00d7A) as (\u00d7A[1..n\u22121]) \u00d7 A[n]. Let us call \u03b1 to (\u00d7A[1..n\u22121]). Now, by definition of \u00d7, (\u00d7A) corresponds to \u03b1\u2228\u00ac\u03b1\u2227A[n]. On the other hand, by induction, \u03b1 is equivalent to:\n\u2228\ni=1,...,n\u22121\n(\u2227\u00acA[1..i\u22121]) \u2227A[i]\nwhereas \u00ac\u03b1 is equivalent to (\u2227\u00acA[1..n\u22121]), by Proposition 2. But then, \u03b1 \u2228 \u00ac\u03b1 \u2227A[n] corresponds to:\n[ \u2228\ni=1,...,n\u22121\n(\u2227\u00acA[1..i\u22121]) \u2227A[i]\n]\n\ufe38 \ufe37\ufe37 \ufe38\n\u03b1\n\u2228 (\u2227\u00acA[1..n\u22121]) \ufe38 \ufe37\ufe37 \ufe38\n\u00ac\u03b1\n\u2227A[n]\nwhich is exactly the expansion in (22). \u2737\nAs an example, the expression a\u00d7 b\u00d7 c\u00d7 d is strongly equivalent to:\na \u2228 (\u00aca \u2227 b) \u2228 (\u00aca \u2227 \u00acb \u2227 c) \u2228 (\u00aca \u2227 \u00acb \u2227 \u00acc \u2227 d).\nAlthough we have already proved that \u00d7 satisfies the idempotence property (14), it must be noticed that since the operator is obviously non-commutative, a repeated subformula in a sequence of ordered disjunctions cannot always be removed. We can use Theorem 4 to prove, for instance, the following property.\nProposition 5 (Ordered Idempotence). (F \u00d7G\u00d7 F ) \u2261s F \u00d7G.\nProof. Just notice that, by Theorem 4, (F \u00d7G\u00d7 F ) is equivalent to F \u2228 (\u00acF \u2227 G) \u2228 (\u00acF \u2227 \u00acG \u2227 F ), but the last disjunct can be removed due to (5). \u2737\nAs F and G are arbitrary formulas, and \u00d7 is associative, the equivalence above implies that, when repeated atoms occur in an ordered disjunction, all their occurrences can be removed, excepting the leftmost one. For instance:\na\u00d7 b\u00d7 c\u00d7 a\u00d7 d\u00d7 c\u00d7 a\u00d7 e\u00d7 b \u2194 a\u00d7 b\u00d7 c\u00d7 d\u00d7 e\nHowever, in the general case, we cannot remove the leftmost occurrence of a repeated formula. As a counterexample, the formulas a \u00d7 b \u00d7 a and b \u00d7 a are\nnot strongly equivalent: the simple addition of atom a to the first formula yields one equilibrium model {a} whereas, when added to the second formula, we also obtain an additional equilibrium model {a, b}.\nThe following second translation is perhaps more interesting both for generating a logic program, and for comparison purposes with the \u00d7-reduct. We will introduce first a useful result.\nTheorem 5. Let A be a sequence of |A| = n \u2265 0 formulas. Then, the formula (\u00d7A) is strongly equivalent to the conjunction of:\n\u2227\ni=1,...,n\n(\nA[i] \u2228 \u00acA[i] \u2190 (\u2227\u00acA[1..i\u22121])\n)\n(23)\n\u22a5 \u2190 (\u2227\u00acA) (24)\nProof. First, note that both formulas are classically equivalent: all conjuncts in (23) for i = 1, . . . , n are classical tautologies whereas (24) \u2261c (\u2228A) \u2261c (\u00d7A).\nWe prove now that \u3008H,T \u3009 |= (\u00d7A) iff \u3008H,T \u3009 |= (23) \u2227 (24). For the left to right direction, we begin showing that (\u00d7A) implies (23)\u2227 (24). Assume we had some \u3008H,T \u3009 |= (\u00d7A) but \u3008H,T \u3009 6|= A[i] \u2228 \u00acA[i] \u2190 (\u2227\u00acA[1..i\u22121]) for some i = 1, . . . , n. As these implications are classical tautologies, the only possibility is \u3008H,T \u3009 |= (\u2227\u00acA[1..i\u22121]) while \u3008H,T \u3009 6|= A[i] \u2228 \u00acA[i]. We will prove that, if so, \u3008H,T \u3009 6|= (22) which, by Theorem 4, means \u3008H,T \u3009 6|= (\u00d7A), reaching a contradiction. Notice that we have \u3008H,T \u3009 |= \u00acA[1], . . . , \u3008H,T \u3009 |= \u00acA[i\u22121] while \u3008H,T \u3009 6|= A[i] and \u3008H,T \u3009 6|= \u00acA[i]. Now, the first i\u22121 disjuncts in (22) will be false because for all j = 1, . . . , i\u22121, \u3008H,T \u3009 |= \u00acA[j] implies \u3008H,T \u3009 6|= A[j]. The i-th disjunct is false because it contains A[i] and \u3008H,T \u3009 6|= A[i], and the rest of disjuncts are also false since they contain the subformula \u00acA[i] and we also had \u3008H,T \u3009 6|= \u00acA[i].\nWe remain to prove that \u3008H,T \u3009 |= (24). By Proposition 2, (\u2227\u00acA) is equivalent to \u00ac(\u00d7A) and thus, (24) corresponds to \u00ac\u00ac(\u00d7A). But in HT (and in fact, in intuitionistic logic), any formula implies its double negation, and we had \u3008H,T \u3009 |= (\u00d7A).\nFor the right to left direction, suppose \u3008H,T \u3009 |= (23) \u2227 (24) but \u3008H,T \u3009 6|= (\u00d7A). From the latter and Theorem 4 we conclude the following condition, let us call it (a): for all i = 1, . . . , n, \u3008H,T \u3009 6|= A[i] or there exists some j, 1 \u2264 j < i such that \u3008H,T \u3009 6|= \u00acA[j]. We prove now, by induction on i in (23), that \u3008H,T \u3009 |= \u00acA[i] for all i = 1, . . . , n, which contradicts \u3008H,T \u3009 |= (24). For i = 1 there is no j smaller and from (a) we get \u3008H,T \u3009 6|= A[1]. But, with i = 1, the antecedent of (23) becomes empty (\u22a4) and we get \u3008H,T \u3009 |= A[1] \u2228 \u00acA[1] that, as \u3008H,T \u3009 6|= A[1], leads to \u3008H,T \u3009 |= \u00acA[1]. Induction hypothesis: suppose we have proved \u3008H,T \u3009 |= \u00acA[j] for all j, 1 \u2264 j < i. From this together with (a) we conclude \u3008H,T \u3009 6|= A[i]. But at the same time, this induction hypothesis means that \u3008H,T \u3009 satisfies the antecedent of (23), so we conclude \u3008H,T \u3009 |= A[i]\u2228\u00acA[i], but again, as \u3008H,T \u3009 6|= A[i] the only possibility is \u3008H,T \u3009 |= \u00acA[i]. \u2737\nThe previous theorem can be combined with the following lemma to obtain a translation of any LPOD into a logic program.\nLemma 1. If \u03d5 is strongly equivalent to a conjunction of implications (\u03b1i \u2192 \u03b2i) with i = 1, . . . , n and n \u2265 0 then the formula F : A \u2192 \u03d5\u2228B is strongly equivalent to G, the conjunction of \u03b1i \u2227A \u2192 \u03b2i \u2228B.\nProof. Take \u03d5 strongly equivalent to the conjunction of (\u03b1i \u2192 \u03b2i). To prove that F \u2261s G we must show both that F \u2261c G; and that \u3008H,T \u3009 |= F iff \u3008H,T \u3009 |= G.\nFor proving the classical equivalence, notice that F \u2261c \u00acA \u2228 \u03d5 \u2228 B. But as strong equivalence implies classical equivalence, we can replace \u03d5 in the last formula by the conjunction of implications, obtaining \u00acA \u2228B \u2228 \u2227\ni(\u03b1i \u2192 \u03b2i) \u2261c\u2227 \u00acA \u2228B \u2228 (\u03b1i \u2192 \u03b2i) \u2261c G. For proving \u3008H,T \u3009 |= F iff \u3008H,T \u3009 |= G, assume as a first case that \u3008H,T \u3009 6|= A or \u3008H,T \u3009 |= B. If so, we trivially have both \u3008H,T \u3009 |= F and \u3008H,T \u3009 |= G, and the equivalence holds. Suppose, on the contrary, that \u3008H,T \u3009 |= A and \u3008H,T \u3009 6|= B. It is easy to see that, then, \u3008H,T \u3009 |= F iff \u3008H,T \u3009 |= \u03d5. Similarly \u3008H,T \u3009 |= G amounts to \u3008H,T \u3009 |= \u2227\ni(\u03b1i \u2192 \u03b2i) and the latter, due to our premise, is equivalent to \u3008H,T \u3009 |= F . \u2737\nIn particular, we can thus translate any rule like (8) by using Lemma 1 with H = (\u2227B) \u2227 (\u2227\u00acB\u2032), G = \u22a5 and F = (\u00d7A) and Theorem 4 to obtain a conjunction of implications equivalent to F . In this way, for any LPOD rule r like (8) we define the set of rules r\u2217 as the conjunction of implications in (23) and (24) after adding to all their bodies the conjunction of (\u2227B)\u2227 (\u2227\u00acB\u2032), that is:\nA[i] \u2228 \u00acA[i] \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA[1..i\u22121]) (25)\n\u22a5 \u2190 (\u2227B) \u2227 (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA) (26)\nfor all i = 1, . . . , |A|. For any LPOD P , the program P \u2217 stands for the union of all r\u2217 for each r \u2208 P . As an example, given the LPOD rule r : a\u00d7 b\u00d7 c\u2190 p\u2227\u00acq, the set of rules r\u2217 consists3 of:\na \u2228 \u00aca \u2190 p \u2227 \u00acq\nb \u2228 \u00acb \u2190 p \u2227 \u00acq \u2227 \u00aca\nc \u2228 \u00acc \u2190 p \u2227 \u00acq \u2227 \u00aca \u2227 \u00acb\n\u22a5 \u2190 p \u2227 \u00acq \u2227 \u00aca \u2227 \u00acb \u2227 \u00acc\nTheorem 6. For any LPOD P , P \u2261s P \u2217.\nProof. It directly follows from Theorem 5 and Lemma 1. \u2737\nAn important remark is that, although P \u2217 is a disjunctive logic program with negation in the head, it belongs to a subclass of disjunctive programs with the same expressiveness and complexity than those of normal programs. To see\n3 In fact, this translation can be further refined by removing the last constraint and the last negative literal in the head. In the example, we would replace the last two rules by c\u2190 p \u2227 \u00acq \u2227 \u00aca \u2227 \u00acb.\nwhy, it suffices to observe that any formula of the form F \u2228 \u00acp \u2190 G is strongly equivalent to F \u2190 G \u2227 \u00ac\u00acp and in its turn, a double negated atom in the body can be replaced4 by the negation of a fresh auxiliary atom F \u2190 G \u2227 \u00acaux plus the rule aux \u2190 \u00acp.\nLemma 2. Let I and J be sets of atoms and P an LPOD. Then (J |= P I \u00d7 and I |= P ) iff J |= (P \u2217)I .\nProof. Take any rule r \u2208 P of the form (8). If we apply the standard reduct with respect to I on the rules like (25) in r\u2217, it is easy to see that we exactly get the rules in rI\n\u00d7 . Thus, P I \u00d7 coincides with the standard reduct for all the\nrules like (25) in P \u2217 with respect to I. Now, let us call Q to set of remaining rules in P \u2217 of the form (26). We will prove that I |= P iff J |= QI . In fact, for each r \u2208 P like (8) we have a corresponding r\u2032 \u2208 Q like (26) and we show that I |= r iff J |= (r\u2032)I . We begin observing that r\u2032 (26) and r (8) are classically equivalent formulas. We have then two cases: if I |= (\u2227B) \u2227 (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA) then rI is \u22a5 and trivially J 6|= \u22a5, but also clearly I 6|= r\u2032 and thus I 6|= r, and the equivalence holds. If I 6|= (\u2227B) \u2227 (\u2227\u00acB\u2032) \u2227 (\u2227\u00acA) the reduct (r\u2032)I is empty and thus J |= (r\u2032)I trivially, but we also have I |= r\u2032 and so I |= r and again the equivalence holds. \u2737\nLemma 3. I is an answer set of an LPOD P iff I is an answer set of P \u2217. \u2737\nProof. For the left to right direction, suppose I is an answer set of P . Then, I |= P and I is a minimal model of P I\n\u00d7 . By Lemma 2, this implies I |= (P \u2217)I .\nSuppose there exists a smaller J \u2282 I such that J |= (P \u2217)I . Applying Lemma 2 again, we conclude that J |= P I\n\u00d7 and this contradicts that I is minimal model\nof P I \u00d7 .\nFor the right to left direction, the reasoning is analogous. If I is an answer set of P \u2217 we obviously have I |= (P \u2217)I and, applying Lemma 2 we conclude I |= P and I |= P I\n\u00d7 . Assume we have some J \u2282 I, J |= P I \u00d7 . Again, by Lemma 2 we\nconclude J |= (P \u2217)I and we get a contradiction with minimality of I as model of (P \u2217)I . \u2737\nTheorem 7 (main theorem). T is an answer set of an LPOD P iff \u3008T, T \u3009 is an equilibrium model of P .\nProof. It directly follows from Lemma 3, Theorem 6 and Theorem 2. \u2737\nAs a final comment, a third possible representation of (\u00d7A) is the strongly equivalent formula:\n(\u2228A) \u2227 \u2227\ni=1,...,n\u22121\n( (\u2228A[1..i]) \u2228 \u00acA[i] )\nFor instance, a\u00d7 b\u00d7 c is strongly equivalent to:\n(a \u2228 b \u2228 c) \u2227 (a \u2228 \u00aca) \u2227 (a \u2228 b \u2228 \u00acb) \u2227 (a \u2228 b \u2228 c \u2228 \u00acc).\n4 Similar techniques for removing head negations were introduced in [12,13]."}, {"heading": "4 Disjunctive LPOD", "text": "In [14] an extension of LPODs for dealing with regular disjunction \u2228 is considered. An ordered disjunctive term is defined as any arbitrary combination of atoms and \u2228,\u00d7 operators. A Disjunctive LPOD (DLPOD) is a set of rules of the form F \u2190 (\u2227B)\u2227 (\u2227\u00acB\u2032) where F is an ordered disjunctive term and B,B\u2032 are lists of atoms. An ordered disjunctive term is said to be in Ordered Disjunctive Normal Form (ODNF) if it has the form (\u00d7A1)\u2228 \u00b7 \u00b7 \u00b7 \u2228 (\u00d7An) where the Ai are lists of atoms. A DLPOD rule is in ODNF if its head is in ODNF. Similarly, the whole DLPOD is in ODNF if all its rules are in ODNF. In fact, the semantics of an arbitrary DLPOD is defined by first translating its head into ODNF using the following rewriting rules:\nF \u00d7 (G \u2228H) 7\u2212\u2192 (F \u00d7G) \u2228 (F \u00d7H) (27)\n(F \u2228G)\u00d7H 7\u2212\u2192 (F \u00d7H) \u2228 (G\u00d7H) (28)\n(F \u00d7G)\u00d7H 7\u2212\u2192 F \u00d7G\u00d7H (29)\nF \u00d7 (G \u00d7H) 7\u2212\u2192 F \u00d7G\u00d7H (30)\nThe exhaustive application of (27)-(30) allow transforming any DLPOD into ODNF, that is, a set of rules like\n\u2228\ni=1,...,n\n(\u00d7Ai) \u2190 (\u2227B) \u2227 (\u2227\u00acB \u2032) (31)\nwhere n \u2265 0, and B,B\u2032 and all the Ai are lists of atoms. For any DLPOD rule r like (31), an option for r is any rule of the form:\n\u2228\ni=1,...,n\nAi[ki] \u2190 (\u2227B) \u2227 (\u2227\u00acB \u2032) \u2227\n\u2227\ni=1,...,n\n(\u2227\u00acAi[1..ki\u22121]) (32)\nwhere each ki is some value ki \u2208 {1, . . . , |Ai|}. For instance, the options for the DLPOD rule (a\u00d7 b) \u2228 (c\u00d7 d\u00d7 e) are the rules:\na \u2228 c a \u2228 d \u2190 \u00acc a \u2228 e \u2190 \u00acc \u2227 \u00acd\nb \u2228 c \u2190 \u00aca b \u2228 d \u2190 \u00aca \u2227 \u00acc b \u2228 e \u2190 \u00aca \u2227 \u00acc \u2227 \u00acd\nA disjunctive logic program P \u2032 is a split program of a DLPOD P if it is the result of replacing each DLPOD rule r \u2208 P by some of its split rules. It is important to notice that the split programs of a DLPOD are disjunctive logic programs, whereas in the case of LPODs, split programs were normal logic programs. As before, a set of atoms I is an answer set of a DLPOD P if it is an answer set of some split program P \u2032 of P . For comparison purposes, we concentrate here on the answer sets of DLPODs, leaving apart the selection of their preferred answer sets (see [14] for further details)."}, {"heading": "4.1 Comparison", "text": "Since our characterisation of \u00d7 applies for any arbitrary propositional theory, in particular, it also provides a semantics for DLPODs, both arbitrary and in ODNF. So the immediate question is whether our HT based characterisation and the original DLPOD semantics coincide. Unfortunately, the answer to this question is negative, by two reasons. First, as we explained in Section 3 with a counterexample for (19), we saw that in fact, (28) is not an strongly equivalent transformation. Thus, under our HT-based characterisation, an arbitrary DLPOD is not always reducible to ODNF (although, of course, a semantics for the DLPOD is still defined). Still, even when we restrict ourselves to the study of ODNF programs, we can find examples where the original DLPOD semantics provides more answer sets.\nExample 2. Take the DLPOD P2 consisting of the pair of rules\na \u2228 (b\u00d7 c) c\nThe split programs of P2 are {(a\u2228 b), c} and {(a\u2228c \u2190 \u00acb), c}, the first one with two answer sets {a, c}, {b, c} and the second one with answer set {c}. In this case, there is one answer set that is not equilibrium model: {a, c}. \u2737\nAnswer set {a, c} looks counterintuitive in the sense that, once c is true and we are not picking choice b, it seems clear that (b \u00d7 c) holds and there is no clear reason to make a true (in the first rule). Remember that \u2228 is a regular disjunction, and it will become satisfied when any of its disjuncts become true, regardless the truth degree. The next example illustrates a counterintuitive effect of DLPOD semantics when defining subformulas with auxiliary atoms.\nExample 3. Let P3 be the DLPOD consisting of the pair of rules:\na\u00d7 (b \u2228 c) c \u2737\nFor both semantics, P3 can be converted (even under strong equivalence in HT) into the ODNF program P \u20323 consisting of rule (a\u00d7 b)\u2228 (a\u00d7 c) and fact c. Under the HT characterisation, both P3 and P \u2032\n3 have two answer sets, {a, c} and {c}. For DLPOD semantics, P \u20323 has a third, additional answer set {b, c}. Now, notice that a different way of computing the answer sets of the original program P3 could be defining b \u2228 c with an auxiliary atom, so we obtain the LPOD P \u2032\u20323 :\na\u00d7 aux aux \u2190 b b \u2228 c \u2190 aux c aux \u2190 c\nIt is easy to see that P \u2032\u20323 has two answer sets {aux, a, c} and {aux, c} which, after removing the auxiliary atom, become {a, c} and {c}, respectively, which were, in fact, the two answer sets we obtained for P3 using the HT characterisation. This was expected, since HT satisfies the rule of substitution, that is, if aux \u2194 \u03b1 we can always replace \u03b1 by aux. In these counterexamples, DLPOD semantics yielded more answer sets than theHT characterisation \u2013 this is actually a general property stated below5. 5 We leave the proof for a future extended version of this document.\nTheorem 8. If \u3008T, T \u3009 is an equilibrium model of a DLPOD P in ODNF, then"}, {"heading": "T an answer set of P . \u2737", "text": ""}, {"heading": "5 Conclusions", "text": "We have presented a logical characterisation of Logic Programs with Ordered Disjunction (LPOD) that allows a direct study of ordered disjunction \u00d7 as a derived operator in the logic of Here-and-There (HT), well-known for its application to (strongly equivalent) logic program transformations in Answer Set Programming. This characterisation provides an alternative implementation of LPODs that does not resort to auxiliary predicates. It has also allowed us to analyse the behavior of the \u00d7 operator with respect to some typical properties like associativity, distributivity, idempotence, etc. As \u00d7 is handled as a regular logical connective, our characterisation covers any arbitrary syntactic extension, and in particular, the so-called Disjunctive LPOD (DLPOD). We have shown that the semantics of DLPODs shows some differences with respect to the HT characterisation and established a formal comparison.\nour result can also be seen as a confirmation of Theorem 6 in [6]. In that work, a reduct-based formalisation of LPODs was proposed in order to study strong equivalence relations among LPODs and regular programs. Theorem 6 in that work showed that their characterisation of strong equivalence for LPODs actually coincided with the one for regular programs. This result becomes trivial under our current approach, since ordered disjunction is just treated as an HT derived operator and, as proved in [4], HT arbitrary theories are strongly equivalent to logic programs.\nWe have implemented a first prototype for propositional LPODs using the current approach that uses DLV system as a backend6. Future work includes the extension of this prototype to deal with variables and with arbitrary combinations of ordered and regular disjunction in the head."}], "references": [{"title": "CR-Prolog with ordered disjunction", "author": ["Marcello Balduccini", "Veena S. Mellarkod"], "venue": "In Proceedings of the 2nd Intl. on Answer Set Programming, Advances in Theory and Implementation", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "PDL with preferences", "author": ["Elisa Bertino", "Alessandra Mileo", "Alessandro Provetti"], "venue": "In Proc. of the 6th IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2005}, {"title": "Logic programs with ordered disjunction", "author": ["Gerhard Brewka", "Ilkka Niemel\u00e4", "Tommi Syrj\u00e4nen"], "venue": "Computational Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2004}, {"title": "Propositional theories are strongly equivalent to logic programs", "author": ["P. Cabalar", "P. Ferraris"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2007}, {"title": "A classification and survey of preference handling approaches in nonmonotonic reasoning", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "K. Wang"], "venue": "Computational Intelligence,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "Notions of strong equivalence for logic programs with ordered disjunction", "author": ["Wolfgang Faber", "Hans Tompits", "Stefan Woltran"], "venue": "Proc. of the 11th Intl. Conf. on Principles of Knowledge Representation and Reasoning", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "In Proc. of the Intl. Joint Conf. on Artificial Intelligence", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Answer sets for propositional theories", "author": ["Paolo Ferraris"], "venue": "In Proc. of the 8th Intl. Conf. on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "LPOD answer sets and Nash equilibria", "author": ["Norman Y. Foo", "Thomas Meyer", "Gerhard Brewka"], "venue": "In Proc. of 9th Asian Computing Science Conference (ASIAN\u201904),", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "The stable models semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "In Proc. of the 5th Intl. Conf. on Logic Programming,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1988}, {"title": "Die formalen Regeln der intuitionistischen Logik", "author": ["Arend Heyting"], "venue": "Sitzungsberichte der Preussischen Akademie der Wissenschaften, Physikalisch-mathematische Klasse,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1930}, {"title": "Negation as failure in the head", "author": ["Katsumi Inoue", "Chiaki Sakama"], "venue": "Journal of Logic Programming,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1998}, {"title": "On the effect of default negation on the expressiveness of disjunctive rules", "author": ["Tommi Janhunen"], "venue": "In Proc. of the 6th Intl. Conf. on Logic Programming and Nonmonotonic Reasoning", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2001}, {"title": "Towards logic programs with ordered and unordered disjunction", "author": ["Philipp K\u00e4rger", "Nuno Lopes", "Daniel Olmedilla", "Axel Polleres"], "venue": "In Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2008}, {"title": "Strongly equivalent logic programs", "author": ["Vladimir Lifschitz", "David Pearce", "Agust\u0301\u0131n Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2001}, {"title": "Declarative policies for web service selection", "author": ["Massimo Marchi", "Alessandra Mileo", "Alessandro Provetti"], "venue": "In Proc. of the 6th IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "Stable models and an alternative logic programming paradigm, pages 169\u2013181", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1999}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1999}, {"title": "A new logical characterisation of stable models and answer sets. In Non monotonic extensions of logic programming", "author": ["David Pearce"], "venue": "Proc. NMELP\u201996", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1997}, {"title": "The semantics of predicate logic as a programming language", "author": ["M.H. van Emden", "R.A. Kowalski"], "venue": "Journal of the ACM,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1976}, {"title": "Applications of preferences using answer set programming", "author": ["Claudia Zepeda", "Mauricio Osorio", "Juan Carlos Nieves", "Christine Solnon", "David Sol"], "venue": "Proceedings Workshop on Answer Set Programming", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2005}], "referenceMentions": [{"referenceID": 9, "context": "Based on the answer set (or stable model) semantics [10] for logic programs, Answer Set Programming (ASP) [17,18] has become a successful paradigm for declarative problem solving.", "startOffset": 52, "endOffset": 56}, {"referenceID": 16, "context": "Based on the answer set (or stable model) semantics [10] for logic programs, Answer Set Programming (ASP) [17,18] has become a successful paradigm for declarative problem solving.", "startOffset": 106, "endOffset": 113}, {"referenceID": 17, "context": "Based on the answer set (or stable model) semantics [10] for logic programs, Answer Set Programming (ASP) [17,18] has become a successful paradigm for declarative problem solving.", "startOffset": 106, "endOffset": 113}, {"referenceID": 4, "context": "Although different approaches for representing preferences in ASP have been proposed (see [5] for a survey), one that has recently received much attention is the formalism of Logic Programs with Ordered Disjunction (LPOD) [3], probably due to its simplicity and expressiveness.", "startOffset": 90, "endOffset": 93}, {"referenceID": 2, "context": "Although different approaches for representing preferences in ASP have been proposed (see [5] for a survey), one that has recently received much attention is the formalism of Logic Programs with Ordered Disjunction (LPOD) [3], probably due to its simplicity and expressiveness.", "startOffset": 222, "endOffset": 225}, {"referenceID": 8, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 54, "endOffset": 57}, {"referenceID": 15, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 110, "endOffset": 116}, {"referenceID": 1, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 110, "endOffset": 116}, {"referenceID": 20, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 161, "endOffset": 165}, {"referenceID": 5, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 210, "endOffset": 213}, {"referenceID": 13, "context": "LPODs have been applied, for instance, in Game Theory [9], for implementing policy languages with preferences [16,2], or in planning and argumentation scenarios [21], and they have been further investigated in [6] for studying strongly equivalent transformations and in [14] for introducing an extension called disjunctive LPOD (DLPOD) that combines ordered and regular disjunctions.", "startOffset": 270, "endOffset": 274}, {"referenceID": 0, "context": "Other ASP extensions like CR-Prolog, have also incorporated the use of ordered disjunctions [1].", "startOffset": 92, "endOffset": 95}, {"referenceID": 2, "context": "These answer sets of the split programs can also be captured by reduct transformations, like the originally introduced in [3] or the one later proposed in [6].", "startOffset": 122, "endOffset": 125}, {"referenceID": 5, "context": "These answer sets of the split programs can also be captured by reduct transformations, like the originally introduced in [3] or the one later proposed in [6].", "startOffset": 155, "endOffset": 158}, {"referenceID": 10, "context": "In this paper we concentrate on the first step, that is, in the definition of potential answer sets for LPODs, and show that they can be directly captured by a suitable definition of the ordered disjunction connective \u2018\u00d7\u2019 as a derived operator in the logic of Here-and-There (HT) [11], so that LPODs can be seen as nothing else but regular theories inside the nonmonotonic formalism of Equilibrium Logic [19] (the nonmonotonic version of HT).", "startOffset": 280, "endOffset": 284}, {"referenceID": 18, "context": "In this paper we concentrate on the first step, that is, in the definition of potential answer sets for LPODs, and show that they can be directly captured by a suitable definition of the ordered disjunction connective \u2018\u00d7\u2019 as a derived operator in the logic of Here-and-There (HT) [11], so that LPODs can be seen as nothing else but regular theories inside the nonmonotonic formalism of Equilibrium Logic [19] (the nonmonotonic version of HT).", "startOffset": 404, "endOffset": 408}, {"referenceID": 14, "context": "Equilibrium Logic has been extensively studied in ASP, as it yields a logical characterisation for the answer set semantics, capturing concepts such as the strong equivalence of programs [15] and providing a means to generalise all previous extensions to the the most general syntax of arbitrary propositional [8] and first order [7] theories.", "startOffset": 187, "endOffset": 191}, {"referenceID": 7, "context": "Equilibrium Logic has been extensively studied in ASP, as it yields a logical characterisation for the answer set semantics, capturing concepts such as the strong equivalence of programs [15] and providing a means to generalise all previous extensions to the the most general syntax of arbitrary propositional [8] and first order [7] theories.", "startOffset": 310, "endOffset": 313}, {"referenceID": 6, "context": "Equilibrium Logic has been extensively studied in ASP, as it yields a logical characterisation for the answer set semantics, capturing concepts such as the strong equivalence of programs [15] and providing a means to generalise all previous extensions to the the most general syntax of arbitrary propositional [8] and first order [7] theories.", "startOffset": 330, "endOffset": 333}, {"referenceID": 14, "context": "Theorem 1 (From [15]).", "startOffset": 16, "endOffset": 20}, {"referenceID": 0, "context": "k], the prefix of A of length k, that is, A[1] .", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "We write \u00acA to stand for the sequence of formulas \u00acA[1] .", "startOffset": 52, "endOffset": 55}, {"referenceID": 9, "context": "Answer sets of a program P are defined in terms of the classical GelfondLifscthiz\u2019s reduct [10], that is extended as follows for the syntactic case we are considering (disjunctive heads with default negation [12]).", "startOffset": 91, "endOffset": 95}, {"referenceID": 11, "context": "Answer sets of a program P are defined in terms of the classical GelfondLifscthiz\u2019s reduct [10], that is extended as follows for the syntactic case we are considering (disjunctive heads with default negation [12]).", "startOffset": 208, "endOffset": 212}, {"referenceID": 14, "context": "Theorem 2 (From [15]).", "startOffset": 16, "endOffset": 20}, {"referenceID": 7, "context": "2 In fact, [8] introduced a different, more general reduct that allows defining answer sets for arbitrary theories, which happen to coincide with equilibrium models.", "startOffset": 11, "endOffset": 14}, {"referenceID": 2, "context": "Example 1 (From [3]).", "startOffset": 16, "endOffset": 19}, {"referenceID": 2, "context": "As explained in [3], answer sets of LPODs can also be described in terms of a program reduct, instead of using split programs.", "startOffset": 16, "endOffset": 19}, {"referenceID": 19, "context": "Notice that P I \u00d7 defined in this way is always a normal positive logic program and so it has a least model [20].", "startOffset": 108, "endOffset": 112}, {"referenceID": 2, "context": "Theorem 3 (From [3]).", "startOffset": 16, "endOffset": 19}, {"referenceID": 0, "context": "Notice that we have \u3008H,T \u3009 |= \u00acA[1], .", "startOffset": 32, "endOffset": 35}, {"referenceID": 0, "context": "For i = 1 there is no j smaller and from (a) we get \u3008H,T \u3009 6|= A[1].", "startOffset": 64, "endOffset": 67}, {"referenceID": 0, "context": "But, with i = 1, the antecedent of (23) becomes empty (\u22a4) and we get \u3008H,T \u3009 |= A[1] \u2228 \u00acA[1] that, as \u3008H,T \u3009 6|= A[1], leads to \u3008H,T \u3009 |= \u00acA[1].", "startOffset": 80, "endOffset": 83}, {"referenceID": 0, "context": "But, with i = 1, the antecedent of (23) becomes empty (\u22a4) and we get \u3008H,T \u3009 |= A[1] \u2228 \u00acA[1] that, as \u3008H,T \u3009 6|= A[1], leads to \u3008H,T \u3009 |= \u00acA[1].", "startOffset": 88, "endOffset": 91}, {"referenceID": 0, "context": "But, with i = 1, the antecedent of (23) becomes empty (\u22a4) and we get \u3008H,T \u3009 |= A[1] \u2228 \u00acA[1] that, as \u3008H,T \u3009 6|= A[1], leads to \u3008H,T \u3009 |= \u00acA[1].", "startOffset": 113, "endOffset": 116}, {"referenceID": 0, "context": "But, with i = 1, the antecedent of (23) becomes empty (\u22a4) and we get \u3008H,T \u3009 |= A[1] \u2228 \u00acA[1] that, as \u3008H,T \u3009 6|= A[1], leads to \u3008H,T \u3009 |= \u00acA[1].", "startOffset": 139, "endOffset": 142}, {"referenceID": 11, "context": "4 Similar techniques for removing head negations were introduced in [12,13].", "startOffset": 68, "endOffset": 75}, {"referenceID": 12, "context": "4 Similar techniques for removing head negations were introduced in [12,13].", "startOffset": 68, "endOffset": 75}, {"referenceID": 13, "context": "In [14] an extension of LPODs for dealing with regular disjunction \u2228 is considered.", "startOffset": 3, "endOffset": 7}, {"referenceID": 13, "context": "For comparison purposes, we concentrate here on the answer sets of DLPODs, leaving apart the selection of their preferred answer sets (see [14] for further details).", "startOffset": 139, "endOffset": 143}, {"referenceID": 5, "context": "our result can also be seen as a confirmation of Theorem 6 in [6].", "startOffset": 62, "endOffset": 65}, {"referenceID": 3, "context": "This result becomes trivial under our current approach, since ordered disjunction is just treated as an HT derived operator and, as proved in [4], HT arbitrary theories are strongly equivalent to logic programs.", "startOffset": 142, "endOffset": 145}], "year": 2014, "abstractText": "In this paper we consider a logical treatment for the ordered disjunction operator \u00d7 introduced by Brewka, Niemel\u00e4 and Syrj\u00e4nen in their Logic Programs with Ordered Disjunctions (LPOD). LPODs are used to represent preferences in logic programming under the answer set semantics. Their semantics is defined by first translating the LPOD into a set of normal programs (called split programs) and then imposing a preference relation among the answer sets of these split programs. We concentrate on the first step and show how a suitable translation of the ordered disjunction as a derived operator into the logic of Here-and-There allows capturing the answer sets of the split programs in a direct way. We use this characterisation not only for providing an alternative implementation for LPODs, but also for checking several properties (under strongly equivalent transformations) of the \u00d7 operator, like for instance, its distributivity with respect to conjunction or regular disjunction. We also make a comparison to an extension proposed by K\u00e4rger, Lopes, Olmedilla and Polleres, that combines \u00d7 with regular disjunction.", "creator": "LaTeX with hyperref package"}}}