{"id": "1102.2174", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Feb-2011", "title": "Linear Temporal Logic and Propositional Schemata, Back and Forth (extended version)", "abstract": "This paper relates the well - named formalism of Linear Temporal Logic while the theoretical of propositional schemata introducing by called such. We prove that LTL is 40 must just particular class related phimosis today three means indeed multiplication - taking lexicon iterations recognize from one logic taking a be. Not every does part nevertheless giant based touch which there luminous power of parametric schemata, but it today foregoing also new result still within satisfiability including is because class on aspd makes PSPACE - complete. We informally correctly saw increasing proof necessary for each rational (endorsing the direct challenges continue the prose - for making ). The graphical last stargates however LTL very the Wolper decisions for LTL very than to way specifications reinterpretations therapy out temporality. The reverse encoding perhaps makes of latter approval seem close the the than - fumbled Schwendimann stochastic well LTL.", "histories": [["v1", "Thu, 10 Feb 2011 17:08:41 GMT  (49kb)", "https://arxiv.org/abs/1102.2174v1", "Extended version of a paper submitted at CADE 2011: contains proofs, additional examples and figures; 34 pages, 8 figures"], ["v2", "Tue, 19 Apr 2011 13:15:36 GMT  (47kb)", "http://arxiv.org/abs/1102.2174v2", "Extended version of a paper submitted at TIME 2011: contains proofs, additional examples &amp; figures, additional comparison between classical LTL/schemata algorithms up to the provided translations, and an example of how to do model checking with schemata; 36 pages, 8 figures"]], "COMMENTS": "Extended version of a paper submitted at CADE 2011: contains proofs, additional examples and figures; 34 pages, 8 figures", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["vincent aravantinos", "ricardo caferra", "nicolas peltier"], "accepted": false, "id": "1102.2174"}, "pdf": {"name": "1102.2174.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier"], "emails": ["vincent.aravantinos@imag.fr", "ricardo.caferra@imag.fr", "nicolas.peltier@imag.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n10 2.\n21 74\nv2 [\ncs .L\nO ]\n1 9\nA pr"}, {"heading": "1 Introduction", "text": "Linear Temporal Logic (LTL) is a very well-known logic introduced in [Pnu77] for verifying computer programs. It is widely used to reason on finite state transition systems. On the other hand, propositional schemata have been introduced in [ACP09]. They extend the language of propositional logic with indexed propositions (such as pn, p1 or pi+1) and iterated connectives of the form\n\u2228n i=0 \u03c6 or\u2227n\ni=0 \u03c6. Notice that n denotes a parameter, which must be interpreted as a natural number. If arbitrary expressions for indices and iterations are allowed in the schema, then the satisfiability problem is undecidable, but we have identified in [ACP09,ACP10a,ACP11] some subclasses for which this problem is decidable. The simplest of these classes is called regular : it is defined by restricting both the indices of the propositions, that must be of the form k or n+ k where k \u2208 Z and n is a variable, and iterations, that must be non-nested and of the form \u2227n+l\ni=k \u03c6 where n is a variable and k, l \u2208 Z. Decision procedures are designed in [ACP09,ACP10a] and an implementation is available [ACP10c].\nLTL and propositional schemata share many common features and trying to compare them precisely is a rather natural and, hopefully, fruitful idea. In both logics, interpretations can be viewed as arrays of propositional functions and the formulae relate the values of these functions at different states. The indices of the propositions in the schematic case may be viewed as the time in LTL. Thus comparing the expressing powers and complexities of those two logics, and, if possible, defining translations from one logic to the other is a natural and potentially rewarding issue. Notice that there already exist several results relating\n\u22c6 This work has been partly funded by the project ASAP of the French Agence Nationale de la Recherche (ANR-09-BLAN-04-07-01)\nLTL to other formalisms like monadic second order logic via B\u00fcchi automata [WVS83], monadic first order logic over natural numbers [GPSS80] or star-free regular languages [Tho79]. However, there is a fundamental difference between these languages and the logic of schemata: they deal with infinite objects (infinite interpretations in the case of LTL or first order logic over natural numbers, infinite words in the case of star-free regular languages), whereas schemata deal with intrinsically finite (but unbounded) interpretations. This subtle but important difference introduces difficulties in the definition of such translations. This topic bears some similarities with the approach of [CNP94] where problems on B\u00fccchi automata are reduced to problems on finite automata by using the ultimately periodic property of \u03c9-regular languages.\nNote that finite interpretation is sometimes a desired feature: restricting LTL to finite traces has been considered in [EFH+03], and has applications in, e.g., planning or runtime verification [BK95,BM06,BH10]. It can be argued that the use of LTL in such contexts is a bit overkilling. Indeed, often, rather than considering finite traces per se, the preferred approach is to turn them into infinite traces by infinitely repeating the last state. It seems to us that it would be more natural to use schemata for such applications. In the present work, it is shown that doing so entails no loss in expressive power.\nIn the present paper, we show that LTL is equivalent to a particular subclass of regular schemata, referred to as sequential. More precisely, we define functions effectively translating formulae from one logic into the other and show that this transformation preserves satisfiability. We believe that these results are interesting from a theoretical perspective since they provide useful information about the expressive power of the respective formalisms. Furthermore they allow to import the complexity results of LTL into schemata. From a practical point of view, the existence of a polynomial reduction from a class of propositional schemata into LTL allows one to benefit from the many existing efficient decision procedures for this logic (tableaux methods, e.g. [Wol85,Sch98], resolution-based methods, e.g. [FDP01], or reductions to model checking, e.g. [RV07,DWDMR08]), implementations [BHS98,HK03,CCG+02,DWDMR08] and experimentation tools [GHLS05]. Conversely, the reverse reduction might give further ideas for the design of new techniques to decide LTL satisfiability. In particular, since a Dpll-based procedure exists for regular schemata [ACP10a], it might help to design such a procedure for LTL. On another hand, this reduction is very reminiscent of the translation from LTL to propositional logic encountered in bounded model checking (BMC) [BCC+03]. Contrarily to BMC however, our reduction is complete, it might thus give new ideas to achieve completeness in BMC.\nThe paper is structured as follows. In Section 2 we define LTL and the logic of propositional schemata. In Section 3 we show how to relate the interpretations of both formalisms. A polynomial algorithm transforming any sequential schema into an equivalent LTL formula is presented in Section 4, and Section 5 tackles the reverse translation, i.e. from LTL formulae to schemata. Section 6 presents the results about first experiments with those translations and sketches the possible\nimprovements inspired by those experiments. Section 7 presents pros and cons of each logic, and make a very informal comparison of how LTL procedures behave on schema modulo the given translation, and, conversely, how schemata procedures behave on LTL formulae. Of course, with the given translations and the usual reduction of model checking to satisfiability, one can do model checking with schemata, Section 8 gives an example of such model checking. Finally, Section 9 briefly concludes our work."}, {"heading": "2 Definitions and notations", "text": "In the following, \u03c6, \u03c61, \u03c62 denote LTL formulae, s, s1, s2 denote schemata, \u03c3 denotes an LTL or propositional interpretation, I,M denote schema interpretations, e, f, g denote (Presburger) arithmetic expressions, n, i denote arithmetic variables (n will be used for a free arithmetic variable (\u201cparameter\u201d) and i for a bound one). Remark that n, i are written in sans serif in order to distinguish them from meta variables denoting natural numbers, that will be written n, i.\nBoth LTL and schemata have propositional logic as a common basis. Furthermore, in both languages, propositional variables are accompanied with a natural number (an instant in the case of LTL, an index for schemata). So instead of defining, as in classical propositional logic, an interpretation as a function mapping each propositional variable to a truth value, we rather define interpretations as functions mapping pairs of propositional variables and natural numbers to truth values. Formally:\nDefinition 1. Let P be a set of propositional variables. A propositional interpretation over P is a function from P \u00d7 N to {true, false}.\nExample 2. Let P = {p, q}. Then \u03c3 s.t. \u03c3(p, 0) = true, \u03c3(q, 0) = false, \u03c3(p, 1) = false, \u03c3(q, 1) = false, \u03c3(p, 2) = true, \u03c3(q, 2) = true, and, for any k > 2: \u03c3(p, k) = true and \u03c3(q, k) = false, is a propositional interpretation.\nAn interpretation \u03c3 is represented by the set of all pairs (variable, natural number) that are true in \u03c3. Most of the time we do not need to make that set explicit. For instance, when interpreting a given formula \u03c6, it will be implicitly assumed that we consider only interpretations over sets that contain the variables of \u03c6."}, {"heading": "2.1 LTL", "text": "We now recall the syntax and semantics of LTL.\nDefinition 3. The syntax of LTL formulae over the set of propositional variables P is given by the following grammar:\n\u03c6 ::= \u22a4 |P | \u00ac\u03c6 |\u03c6 \u2227 \u03c6 |X\u03c6 |\u03c6U\u03c6\nX\u03c6 means that \u03c6 holds at the next instant (\u201cX\u201d for neXt). \u03c6U\u03c8 means that \u03c6 holds until \u03c8 holds (\u201cU\u201d for Until). We will also use the following abbreviations: F\u03c6 def = \u22a4U\u03c6 and G\u03c6 def\n= \u00acF\u00ac\u03c6, meaning respectively \u201c\u03c6 eventually holds\u201d and \u201c\u03c6 always holds\u201d. The abbreviations \u2228, \u21d2 and \u21d4 are defined as usual (the naive elimination of \u21d4 is exponential but it can be made linear by using renaming of subformulae as usual, which preserves satisfiability). See [Pnu77] for details.\nLTL formulae are usually interpreted over infinite paths in a transition system, together with a labelling that maps every state to a set of propositional variables. Such sequences are often called computations or behaviours. We will simply call them LTL interpretations. For uniformity, we define formally an LTL interpretation as a propositional interpretation in the sense of Definition 1 (we do not make explicit the notions of states, transition systems and labelling).\nExample 4. The interpretation {p, q} \u2192 {p} \u2192 {q} \u2192 {p, q} \u2192 {} \u2192 {} \u2192 . . . is formally represented as the function \u03c3 s.t.\n\u03c3(p, 0) = true\n\u03c3(q, 0) = true\n\u03c3(p, 1) = true\n\u03c3(q, 1) = false\n\u03c3(p, 2) = false\n\u03c3(q, 2) = true\n\u03c3(p, 3) = true\n\u03c3(q, 3) = true\n\u03c3(p, 4) = false\n\u03c3(q, 4) = false\nThen \u03c3(t) denotes the set of variables p that are true at time t, i.e. such that (p, t) \u2208 \u03c3 (in the previous example, \u03c3(0) = {p, q}, \u03c3(1) = {p}, etc.). The satisfaction relation of an LTL formula \u03c6 under such an interpretation \u03c3 is defined w.r.t. an instant t, written \u03c3, t |= \u03c6. This means that the formula \u03c6 holds at time t.\nDefinition 5. Let \u03c6 be an LTL formula, \u03c3 be a propositional interpretation and t \u2208 N. The relation \u03c3, t |= \u03c6 is inductively defined as follows:\n\u03c3, t |= \u22a4\n\u03c3, t |= p iff (p, t) \u2208 \u03c3\n\u03c3, t |= \u00ac\u03c6 iff \u03c3, t 6|= \u03c6\n\u03c3, t |= \u03c61 \u2227 \u03c62 iff \u03c3, t |= \u03c61 and \u03c3, t |= \u03c62\n\u03c3, t |= X\u03c6 iff \u03c3, t+ 1 |= \u03c6\n\u03c3, t |= \u03c61U\u03c62 iff \u2203k \u2208 N s.t. \u2200i \u2208 N, i < k \u21d2 \u03c3, t+ i |= \u03c61 and \u03c3, t+ k |= \u03c62\nThe notation \u03c3 |= \u03c6 means that \u03c6 is true in \u03c3 at time 0.\nA fundamental property of LTL is the \u201cultimately periodic model property\u201d. Namely, if an LTL formula is satisfiable, then it is satisfiable on some ultimately periodic interpretation.\nDefinition 6. An ultimately periodic (\u201cUP\u201d) interpretation is an LTL interpretation \u03c3 s.t. there exist k, l \u2208 N s.t. l > 0 and for all m \u2265 k, \u03c3(m) = \u03c3(m + l). The sequence \u03c3(0) . . . \u03c3(k\u22121) is the prefix of \u03c3 and \u03c3(k) . . . \u03c3(k+ l\u22121) its loop, k is the prefix index and l is the period.\nTheorem 7 ([SC85]). Any satisfiable LTL formula has a UP model.\nThis important result allows to focus exclusively on finite sets of instants. Indeed it is sufficient to give the values of a UP interpretation for time 0 to k+ l. Other values until \u03c9 can then be computed.\nExample 8. Figure 1 represents a UP model of GFp."}, {"heading": "2.2 Schemata", "text": "We now recall the syntax and semantics of schemata (for simplicity, the considered definitions are slightly more restrictive than the ones of [ACP09]). Let E be the set of Presburger arithmetic expressions, i.e. terms built over a countably infinite set of arithmetic variables X and on the signature containing 0, succ, + and possibly all the constant symbols in N1. As usual a term is ground iff it contains no variable. Notice that every ground expression will be considered the same as the natural number it represents.\nDefinition 9. The syntax of schemata over the set of propositional variables P is given by the following grammar:\ns ::= \u22a4 | pe | \u00acs | s \u2227 s |\nn\u22121\u2227\ni=0\ns\nwhere p \u2208 P , e \u2208 E and i, n \u2208 X . \u2228n\u22121 i=0 s is defined as \u00ac \u2227n\u22121\ni=0 \u00acs and \u2228, \u21d2 and \u21d4 are defined as usual.\n1 Such constants may be encoded in unary, as terms of the form succk(0) but also in binary, as sequences of digits. As we shall see, the choice between the two encodings has a significant influence on the complexity of the translation: polynomial translation of schemata into LTL is feasible only if numbers are encoded in unary.\nExample 10. p0 \u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1) \u2227 \u00acpn and \u2227n\u22121 i=0 pi \u2227 \u2228n\u22121 i=0 \u00acpi are schemata.\nRemark 11. This definition is less general than the one originally introduced in [ACP09] because all integers occurring in the schema must be positive (we consider Presburger arithmetic instead of linear arithmetic). This was not the case in [ACP09], but it is easy to check that both formalisms have exactly the same expressive power. Furthermore the iterations are here restricted to go from 0 to n \u2212 1. Once again this is not restrictive w.r.t. to the expressive power, but it allows to get rid of tedious additional restrictions that would be needed otherwise.\nSchemata of the form pe are called indexed propositions, and those of the form\u2227n\u22121 i=0 s are called iterated conjunctions or simply iterations. The variable i is bound in \u2227n\u22121\ni=0 s. The essential point of schemata is that iterations are symbolic expressions: n is a formal variable, called a parameter, not a meta variable denoting any number. From now on, we assume that all schemata have only one parameter called n. This is not restrictive for the scope of this paper (see [AMEP10]).\nA schema is interpreted by first giving a value to the parameter \u2013 which gives raise to a propositional formula \u03c6, called an \u201cinstance\u201d of the schema \u2013 and then by giving a value to the propositional variables of \u03c6. Note that a schema has an infinite set of instances. If s is a schema or an arithmetic expression, i is an arithmetic variable and e is an arithmetic expression, then s[e/i] denotes the expression obtained from s by replacing every free occurrence of i by e. Note that, if e is ground and s is an arithmetic expression containing only the variable i, then s[e/i] is a ground arithmetic expression, i.e. a natural number. Then:\nDefinition 12. Let s be a schema of parameter n and m \u2208 N. The instance of s w.r.t. m is the propositional formula \u3008s\u3009m inductively defined as follows:\n\u3008pe\u3009m def = pe[m/n]\n\u3008\u00acs\u3009m def = \u00ac\u3008s\u3009m\n\u3008s1 \u2227 s2\u3009m def = \u3008s1\u3009m \u2227 \u3008s2\u3009m\n\u3008 n\u22121\u2227\ni=0\ns\u3009m def = \u22a4 if m = 0\n\u3008\nn\u22121\u2227\ni=0\ns\u3009m def = \u3008s[0/i]\u3009m \u2227 . . . \u2227 \u3008s[m\u2212 1/i]\u3009m otherwise\nExample 13.\n\u3008p0 \u2227\nn\u22121\u2227\ni=0\n(pi \u21d2 pi+1) \u2227 \u00acpn\u30090 = p0 \u2227 \u00acp0\n\u3008p0 \u2227\nn\u22121\u2227\ni=0\n(pi \u21d2 pi+1) \u2227 \u00acpn\u30091 = p0 \u2227 (p0 \u21d2 p1) \u2227 \u00acp1\n\u3008p0 \u2227\nn\u22121\u2227\ni=0\n(pi \u21d2 pi+1) \u2227 \u00acpn\u30092 = p0 \u2227 (p0 \u21d2 p1) \u2227 (p1 \u21d2 p2) \u2227 \u00acp2\netc.\nAn instance is a usual propositional formula except that each variable is indexed with a natural number. So we just need a propositional interpretation to interpret this formula as usual:\nDefinition 14. Let \u03c6 be a propositional formula whose variables are indexed by natural numbers, and \u03c3 a propositional interpretation. Then \u03c3 |= \u03c6 is defined as usual by induction on the structure of \u03c6 with the exception that, for any indexed propositional variable pk, \u03c3 |= pk iff (p, k) \u2208 \u03c3.\nWe thus define a schema interpretation as a pair consisting of a propositional interpretation and a natural number.\nDefinition 15. A schema s is true in a schema interpretation (\u03c3, n) iff \u03c3 |= \u3008s\u3009n. We also use the notation |= for schemata: I |= s iff the schema s is true in the schema interpretation I.\nExample 16. p0 \u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1) \u2227 \u00acpn is unsatisfiable (see its set of instances in Example 13) as well as \u2227n\u22121\ni=0 pi\u2227 \u2228n\u22121 i=0 \u00acpi; p0\u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1) is satisfiable.\nThe satisfiability problem for schemata is undecidable in general [ACP09]. However various decidable classes are investigated in [ACP09,ACP10a,ACP11]. In the following, we will focus on the translation of LTL from/to \u201csequential\u201d schemata:\nDefinition 17. A schema is a sequential propositional schema (\u201cSPS\u201d) iff all the following conditions hold:\n\u2013 it contains no nested iteration (iterations in the scope of another iteration); \u2013 every index of a variable outside an iteration is of the form k or n+k, where k \u2208 N and n is the parameter; \u2013 every index of a variable inside an iteration \u2227n\u22121\ni=0 s is of the form i+k, where k \u2208 N.\nExample 18. p0 \u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1), p0 \u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1) \u2227 \u00acpn and \u2227n\u22121\ni=0 pi \u2227\u2228n\u22121 i=0 \u00acpi are SPS; \u2227n i=0 pi \u2227 \u2228n i=0 \u00acpi, p2n \u2227 \u2227n\u22121 i=0 pi, \u2227n\u22121 i=0 p2n, and \u2227n\u22121 i=0 p2i are not.\nInformally, an SPS represents a structure which is sequentially repeated, n being considered as the length of the sequence. SPS belong to the class of \u201cregular\u201d schemata, for which the satisfiability problem is proved to be decidable in [ACP09]."}, {"heading": "3 Translating interpretations", "text": "In the next sections we will provide translations of LTL formulae into SPS and conversely. Some semantic translations underlie those syntactic ones. We make them explicit now in order to give preliminary insights."}, {"heading": "3.1 From schemata to LTL", "text": "Consider a schema interpretation (\u03c3, n). Given a schema interpretation (\u03c3, n), its first component \u03c3 can already be considered as an LTL interpretation, but we still need to represent the second component n. This is done by using special LTL interpretations (which are also propositional interpretations) called \u201cinitial segments\u201d:\nDefinition 19. Let \u03c3 be a propositional interpretation over a set of variables P. \u03c3 is an initial segment of length k \u2208 N for some p \u2208 P iff (p, t) \u2208 \u03c3 when t < k, and (p, t) 6\u2208 \u03c3 otherwise.\nExample 20. Figure 2 provides a graphical representation of an initial segment of length 4 for p.\nThe key feature of initial segments is that they can be put in correspondence with natural numbers. Namely, we can associate a canonical initial segment to every natural number and a natural number to every initial segment. This correspondence allows us to define the following transformation for schema interpretations:\nDefinition 21. Let P be a set of propositional variables and let \u201ct < n\u201d 6\u2208 P be a propositional variable. Let I = (\u03c3, n) be a schema interpretation over P. Then TIU is the propositional interpretation (and thus also an LTL interpretation) over P \u222a {t < n} which is an initial segment of length n for t < n and which is defined as \u03c3 over P. Conversely, T.U\u22121 is the function that maps every initial segment \u03c3 of length n for t < n to the schema interpretation (\u03c4, n) where \u03c4 is the restriction of \u03c3 to P.\nExample 22. Let I be the schema interpretation ({p0, q0, p1, p2, q3}, 3). Then TIU = {p, q, t < n} \u2192 {p, t < n} \u2192 {p, t < n} \u2192 {q} \u2192 {} \u2192 {} \u2192 . . . Conversely, let \u03c3 be the LTL interpretation {q, t < n} \u2192 {q, t < n} \u2192 {p, t < n} \u2192 {p, q, t < n} \u2192 {p} \u2192 {p} \u2192 . . . , then T\u03c3U\u22121 = ({q0, q1, p2, p3, q3, p4, p5, . . . }, 4).\nThe map T.U is a bijection between schema interpretations over P and initial segments over P \u222a {t < n}. Indeed, T.U\u22121 is its inverse.\nRemark 23. An important difference between schemata and LTL is the fact that all interpretations of schemata are finite, whereas those of LTL are infinite (i.e. time is unbounded). Initial segments thus allow us to simulate finite models in LTL.\nFinally notice that the set of initial segments can be specified in LTL as follows:\nProposition 24. Let \u03c6t<n< be the following formula:\n\u03c6t<n< def = (t < n)UG(\u00act < n)\nThen an LTL interpretation is a model of \u03c6t<n< iff it is an initial segment for t < n.\nProof. An interpretation is a model of \u03c6t<n< iff it makes t < n true until \u00act < n always holds. Let us write k for the first instant where t < n does not hold. Then this is equivalent to say that t < n holds at time t iff t < k. \u2293\u2294\nWe can also specify a proposition eqn that is true only at time n. This is axiomatized by:\nAxt=n def = G(t < n \u2227 \u00acX(t < n) \u21d4 X(eqn)) \u2227 (\u00act < n \u21d4 eqn)\nTo improve readability, eqn will be written t = n.\nProposition 25. Let \u03c3 be an initial segment for t < n of length n s.t. \u03c3, 0 |= Axt=n. Then \u03c3, t |= t = n iff t = n.\nProof. By definition, t < n holds at time t iff t < n. If n = 0 then t < n never holds, in particular, t < n does not hold at time 0. Since \u03c3 |= Axt=n, \u03c3 satisfies its second conjunct, and as t < n does not hold at time 0, eqn (i.e. t = n) holds at time 0. Furthermore, since \u03c3 satisfies the first conjunct and t < n never holds again, t = n is never satisfied again. Suppose now n 6= 0, then there is indeed at least one instant s.t. t < n holds. Thus t < n holds at time n \u2212 1 and not at time n, which corresponds precisely to the first conjunct of Axt=n. Furthermore n is the only instant with this property hence the result. \u2293\u2294"}, {"heading": "3.2 From LTL to schemata", "text": "The inverse translation is harder: embedding LTL into schemata means that we must represent the infinite interpretations of LTL using only schema interpretations, which are finite. Of course this is impossible in general. However, as we are concerned with satisfiability, we can make use of Theorem 7 and restrict ourselves to UP interpretations. Since such interpretations can be finitely represented, we will be able to embed them into schema interpretations. The representation of UP interpretations within schemata is achieved via particular schema interpretations called \u201c2-initial segments\u201d:\nDefinition 26. A schema interpretation I = (\u03c3, n) is a 2-initial segment for a propositional variable p iff there exists k \u2264 n s.t., for every l \u2208 {0, . . . , n}, we have (p, l) \u2208 \u03c3 \u21d4 l < k. We call k the short length of I and n + 1 is its long length.\nExample 27. The schema interpretation ({p0, p1, p2}, 5) is a 2-initial segment w.r.t. p(see Figure 3). Its short length is 3, its long length is 6.\nWe call this a 2-initial segment because two initial segments are characterized: {0, . . . , k \u2212 1} (characterized by I) and {0, . . . , n} (characterized by n). Notice, however, that the segment {0, . . . , k \u2212 1} is characterized by p only below n, i.e. the value of p is not specified above n. This is not a problem since we will not need such values in the translations.\nThe notion of 2-initial segment is useful because, much in the same way in which initial segments correspond to natural numbers, 2-initial segments correspond to pairs of different natural numbers. We can now define the following transformation for UP interpretations:\nDefinition 28. Let \u03c3 be a UP interpretation of prefix index k (i.e. the loop starts at time k) and of period l over a set P, and let \u201cpfx\u201d 6\u2208 P be a propositional variable. Then V\u03c3W is the schema interpretation (\u03c4, k+ l\u2212 1) where \u03c4 is defined as an initial segment of length k for pfx and preserving the value of \u03c3 on P.\nExample 29. Let \u03c3 be the UP interpretation of prefix index 2 and period 3 (totally) defined by: {p, q, r} \u2192 {p} \u2192 {q, r} \u2192 {p, q} \u2192 {q, r} Then V\u03c3W = ({pfx0, p0, q0, r0, pfx1, p1, q2, r2, p3, q3, q4, r4}, 4).\nRemark 30. The map V.W embeds the prefix index and the period inside schema interpretations, but it is impossible to specify the fact that an interpretation is a UP interpretation: indeed this would require to express that the interpretation loops indefinitely. Such a specification of an \u201cinfinite\u201d behaviour cannot be achieved with schemata. This will not be a problem in the following because, when focusing on a given LTL formula, one only needs to specify this behaviour in the range {0, . . . , k + l \u2212 1}.\nFor similar reasons, V.W is not a bijection in general, unlike T.U. It is actually a bijection between UP interpretations and 2-initial segments if we restrict the latter to the values assigned to variables whose index is between 0 and k+ l\u2212 1.\nThis will indeed be the case in our reduction since, as just explained, we will not need the values for other indices. Then V.W\u22121 is defined as follows:\nDefinition 31. Let (\u03c3, n) be a 2-initial segment for pfx. Then V\u03c3, nW\u22121 is defined as the unique UP interpretation such that:\n\u2013 its prefix is the set of instants s.t. pfx holds in I; \u2013 its period l is n\u2212 k + 1, where k is the prefix index; \u2013 for all p 6= pfx and all t \u2264 n, (p, t) \u2208 VI, nW\u22121 iff (p, t) \u2208 I.\nExample 32. Let I = ({pfx0, p0, pfx1, q1, p2, p3, q3}, 3). Then VIW \u22121 is the UP interpretation of prefix index 2 and period 2 defined by VIW\u22121 = {p} \u2192 {q} \u2192 {p} \u2192 {p, q} \u2192 . . . where the contents of the dots can be retrieved by the UP property of the interpretation.\nFinally, 2-initial segments can be specified using schemata:\nProposition 33. Let spfx\u2264 be the following SPS:\nspfx\u2264 def = \u00acpfxn \u2227\nn\u22121\u2227\ni=0\n(pfxi+1 \u21d2 pfxi)\nThen a schema interpretation is a model of spfx\u2264 iff it is a 2-initial segment for pfx.\nProof. Let I = (\u03c3, n) be a model of spfx\u2264 . For any k \u2208 N s.t. pfxk holds, pfxk\u2032 holds for every k\u2032 < k, because \u03c3 satisfies the second conjunct of spfx\u2264 . Furthermore there is a maximal such k < n , because pfxk cannot hold at time n, by the first conjunct. Hence I is indeed a 2-initial segment.\nConversely, let I = (\u03c3, n) be a 2-initial segment for pfx of short length k. Then, for every l \u2208 {0, . . . , n}, pfxl holds iff l < k. Since k \u2264 n, pfxn cannot hold, hence the first conjunct is indeed satisfied. Furthermore for every l \u2208 {0, . . . , n}, if pfxl+1 holds then pfxl holds, hence the second conjunct is satisfied. \u2293\u2294\nThe beginning of the loop can be referred to by using a propositional variable eqki , intended to be true only when i is equal to the prefix index k of the interpretation. This can be axiomatized as follows:\nAxi=k def = (\u00acpfx0 \u21d4 eq k 0) \u2227\nn\u22121\u2227\ni=0\n(pfxi \u2227 \u00acpfxi+1 \u21d4 eq k i+1)\nTo improve readability, eqki will be written \u201c i = k\u201d.\nProposition 34. Let I be a 2-initial segment of short length k for pfx s.t. I |= Axi=k. Then, for every i \u2208 {0, . . . , n}, I |= eq k i iff i = k. Proof. If k = 0, then I 6|= pfx0 hence i |= eq k 0 , by the first conjunct of Axi=k. Furthermore I 6|= eqki+1 for any i \u2208 {0, . . . , n \u2212 1} because pfxi does not hold and by the second conjunct of Axi=k.\nIf k > 0, then I |= pfxk\u22121 and I 6|= pfxk hence, by the second conjunct, I |= eqkk. Furthermore, no other instant l between 0 and n has the property that I |= pfxl\u22121 and I 6|= pfxl, hence the equivalence. \u2293\u2294"}, {"heading": "4 Embedding SPS in LTL", "text": "We now show how SPS can be translated into LTL: given an SPS s, we build an LTL formula \u230as\u230b which is satisfiable iff s is satisfiable. Then we show that the size of \u230as\u230b is polynomial or exponential w.r.t. the size of s, depending on the encoding of natural numbers (in the arithmetic expressions occurring in s). As LTL satisfiability is in PSPACE, we can thus conclude that the satisfiability of SPS is also in PSPACE when numbers are encoded in unary."}, {"heading": "4.1 The \u230a.\u230b transformation", "text": "The main desideratum of \u230a.\u230b is that for every model M of an SPS s, the interpretation TMU (Definition 21) is a model of \u230as\u230b. An example is shown on Figure 4 (we represent LTL interpretations as sequences of sets of propositional variables, instead of sets of pairs (variable, number), as they are formally defined; similarly, schema interpretations are represented as the set of true indexed propositions).\nBy Proposition 24, every interpretation such that \u03c6t<n< (defined in Proposition 24) holds is an initial segment of length n for a propositional variable \u201ct < n\u201d. Furthermore, Axt=n (defined after Proposition 24) enables to use the variable \u201ct = n\u201d. Our translation thus includes those formulae.\nDefinition 35. Let s be an SPS. Then \u230as\u230b is an LTL formula defined as \u230as\u230b def\n= \u230as\u230bprop \u2227 \u03c6 t<n < \u2227 Axt=n where \u230as\u230bprop is inductively defined as follows:\n\u230a\u22a4\u230bprop def = \u22a4\n\u230apk\u230bprop def = Xkp\n\u230apn+k\u230bprop def = G(t = n \u21d2 Xkp)\n\u230api+k\u230bprop def = Xkp\n\u230a\u00acs\u230bprop def = \u00ac\u230as\u230bprop\n\u230as1 \u2227 s2\u230bprop def\n= \u230as1\u230bprop \u2227 \u230as2\u230bprop \u230a n\u22121\u2227\ni=0\ns\n\u230b\nprop\ndef = G(t < n \u21d2 \u230as\u230bprop)\nwhere k \u2208 N, i 6= n, and Xk\u03c6 def\n= X. . .X \ufe38 \ufe37\ufe37 \ufe38\n\u00d7k\n\u03c6.\nExample 36. We have: \u230a p0 \u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1) \u2227 \u00acpn \u230b = p \u2227 G(t < n \u21d2 p \u21d2 Xp)\u2227\u00acG(t = n \u21d2 p)\u2227\u03c6t<n< \u2227Axt=n. Notice that it would be equivalent to have p \u2227 G(t < n \u21d2 p \u21d2 Xp) \u2227 G(t = n \u21d2 \u00acp) \u2227 \u03c6t<n< \u2227 Axt=n because t = n holds at only one moment. This variation is interesting because it does not introduce any eventuality, and is thus easier to handle for LTL decision procedures. It can be generalized, e.g., by putting every schema into n.n.f. before the translation, and then by defining a dedicated case for negative literals.\nFigure 4 can now be updated into Figure 5."}, {"heading": "4.2 Soundness and completeness of \u230a.\u230b.", "text": "Theorem 37. Let s be a SPS. Then T.U is a bijection between the models of s and the models of \u230as\u230b. The inverse bijection is T.U\u22121 (Definition 21).\nThis result is more interesting than just \u201cs is satisfiable iff \u230as\u230b is satisfiable\u201d. Indeed, not only does it provide more insights about the translation, but it also makes explicit the inverse transformation for interpretations, which is useful for model building.\nProof. Notice that T.U\u22121 is well defined because every model of \u230as\u230b is an initial segment by Proposition 24. We still have to prove the following:\n1. for every model M of s, TMU is a model of \u230as\u230b; 2. for every model \u03c3 of \u230as\u230b, T\u03c3U\u22121 is a model of s.\nIn the following, M is a model of s, n is the value given to n by M, \u03c3 is a model of \u230as\u230b and l is the length of \u230as\u230b (as an initial segment of t < n). Notice that, by definition, TMU coincides with the propositional part of M on any propositional variable other that t < n. Similarly, \u03c3 coincides with the propositional part of T\u03c3U\u22121 on any propositional variable other that t < n.\nWe prove both properties simultaneously by induction on \u230as\u230bprop:\n\u2013 Suppose s = pk, where k \u2208 N. Then M |= s implies (p, k) \u2208 M \u2282 TMU and by a straightforward induction on k this implies that TMU |= Xkp which proves 1. For 2, suppose that \u03c3 |= \u230as\u230b, i.e. \u03c3 |= Xkp. This easily entails that (p, k) \u2208 \u03c3, thus (p, k) \u2208 T\u03c3U\u22121 and so T\u03c3U\u22121 |= pk. \u2013 Suppose s = pn+k. Then M |= pn+k means that (p, n + k) \u2208 M \u2282 TMU. Consequently, Xkp is true at time n. Finally, by Proposition 25, t = n is true only at time n in TMU. Thus, at any time when we have t = n, we have Xkp; i.e. we have t = n \u21d2 Xkp at any time; i.e. we have G(t = n \u21d2 Xkp). This proves 1. For 2, suppose \u03c3 |= \u230as\u230b, i.e. \u03c3 |= G(t = n \u21d2 Xkp). Thus for every t \u2208 N, t = n \u21d2 Xkp is true at time t in \u03c3. But we know that t = n is true only at time l (the length of \u230as\u230b). Thus p is true at time l + k. Hence (p, l + k) \u2208 \u03c3, thus (p, l + k) \u2208 T\u03c3U\u22121, and since the value of n in T\u03c3U\u22121 is l, T\u03c3U\u22121 |= pn+k. \u2013 The case s = pi+k is handled in the iteration cases (Lemma 38). \u2013 Suppose s = \u00acs\u2032. For 1, if M |= s then M 6|= s\u2032. But, as T.U\u22121 is the inverse\nof T.U, M = T(TMU)U\u22121. Thus T(TMU)U\u22121 6|= s\u2032. By induction hypothesis, 2 holds for s\u2032, thus, by contraposition: TMU 6|= \u230as\u2032\u230b. Consequently, TMU |= \u00ac\u230as\u2032\u230b. For 2, suppose \u03c3 |= \u230as\u230b, i.e. \u03c3 |= \u00ac\u230as\u2032\u230b. Thus \u03c3 6|= \u230as\u2032\u230b, i.e. TT\u03c3U\u22121U 6|= \u230as\u2032\u230b. By induction hypothesis, 1 holds for s\u2032, so, by contraposition: T\u03c3U\u22121 6|= s\u2032. Thus T\u03c3U\u22121 |= \u00acs\u2032. \u2013 Suppose s = s1 \u2227 s2. For 1, if M |= s then M |= s1 and M |= s2 and one easily concludes by induction. For 2, if \u03c3 |= \u230as\u230b, i.e. \u03c3 |= \u230as1\u230b \u2227 \u230as2\u230b, then \u03c3 |= \u230as1\u230b and \u03c3 |= \u230as2\u230b and one can also conclude by induction. \u2013 Suppose s = \u2227n\ni=0 s \u2032. We first prove the following intermediate lemma:\nLemma 38. For every initial segment \u03c3 of length l, and every t \u2264 l: \u03c3 |= \u230as\u2032[t/i]\u230b iff \u230as\u2032\u230b holds in \u03c3 at time t.\nProof. We prove both implications simultaneously by induction on the structure of s\u2032: \u2022 Suppose s\u2032 = pi+k; thus \u230as \u2032\u230b = \u230api+k\u230b = X kp, and \u230as\u2032[t/i]\u230b = \u230apt+k\u230b =\nXt+kp. For the first implication, assume that \u03c3 |= \u230as\u2032[t/i]\u230b, i.e. \u03c3 |= Xt+kp, which is equivalent to p \u2208 TMU(t+k). It is equivalent to say that Xkp, i.e. \u230as\u2032\u230b, is true in \u03c3 at time t. This proves the first implication, and also the second as all reasoning steps are equivalences. \u2022 As s is strictly bound, there are no other base case (this is precisely why this restriction is essential). \u2022 Suppose s\u2032 = \u00acs\u2032\u2032: then \u230as\u2032\u230b = \u00ac\u230as\u2032\u2032\u230b and \u230as\u2032[t/i]\u230b = \u00ac\u230as\u2032\u2032[t/i]\u230b. For the first implication, assume that \u03c3 |= \u230as\u2032[t/i]\u230b, i.e. \u03c3 |= \u00ac\u230as\u2032\u2032[t/i]\u230b. Thus \u03c3 6|= \u230as\u2032\u2032[t/i]\u230b. By the reverse implication of the induction hypothesis (more precisely by its contraposition), this means that \u230as\u2032\u2032\u230b does not hold in \u03c3 at time t. Consequently, \u00ac\u230as\u2032\u2032\u230b holds in \u03c3 at time t, hence the result. Once again, the second implication is obtained by just reversing the reasoning. \u2022 The proof for the conjunction case is routine. \u2022 As the schema is sequential, iterations cannot be nested, thus s\u2032 cannot contain an iteration, hence there are no more cases. \u2666\nNow we can get back to the iteration case of the main proof. For 1, if M |= s then M |= s\u2032[t/i] for every t \u2208 N s.t. 0 \u2264 t \u2264 n by definition of schemata semantics. And thus, by induction hypothesis, TMU |= \u230as\u2032[t/i]\u230b for every such t. By Lemma 38, this means that \u230as\u2032\u230b is true in TMU at any time t s.t. 0 \u2264 t \u2264 n. From the semantics of LTL, it is obvious that t \u2265 0 so it is enough to say that \u230as\u2032\u230b is true in TMU at any time t \u2264 n (notice that this would not be so simple if the schema was not simply iterated). This is equivalent to say that t < n \u21d2 \u230as\u2032\u230b is true at any time, hence the conclusion for 1. For 2, suppose that \u03c3 |= \u230as\u230b, i.e. \u03c3 |= G(t < n \u21d2 \u230as\u230b). Then, by definition of LTL semantics, t < n \u21d2 \u230as\u230b is true in \u03c3 at any time. Furthermore t < n is true only at time l or below, hence \u230as\u230b is true in \u03c3 at any time less or equal than l. We can then conclude using the reverse implication of Lemma 38 and the semantics of schemata. \u2293\u2294"}, {"heading": "4.3 Consequences.", "text": "We then obviously have the expected result:\nCorollary 39. A SPS s is satisfiable iff \u230as\u230b is satisfiable.\nThus we indeed obtained an embedding of SPS into LTL. Consequently we can use any LTL satisfiability solver to solve the satisfiability problem for SPS: we simply translate the input schema to LTL with \u230a.\u230b and then launch the LTL solver on the output formula. Thus:\nCorollary 40. The satisfiability problem for SPS can be reduced to the satisfiability problem for LTL.\nNotice furthermore that if the solver finds a model, then we can translate it back to a schema model using the inverse translation T.U\u22121.\nWe can easily study the complexity of this transformation. For an object x (schema, formula, arithmetic expression), let#x stand for the size of x in number of symbols. Let #s denote the size of a schema s, in number of symbols, and let #ints denote the size of the biggest number occurring in s, expressed w.r.t. the size of s. This is to take into account the fact that numbers can be encoded either in unary or in binary: if they are encoded in binary then #ints = O(2\n#s), but if they are encoded in unary then #ints = O(#s). It may also happen that we consider only schemata whose biggest number is bounded by some constant; in such a case, we have #ints = O(1). This case is worth considering since we may easily increase the size of a schema without increasing the numbers that occur in it. Then:\nProposition 41. For every SPS s, we have # \u230as\u230b = O(#s.#ints).\nProof. First, \u03c6t<n< has a constant size. Then since the construction of \u230as\u230bprop is by induction on s, there are#s recursive calls. Each of those calls adds a number of symbols either constant or proportional to some k \u2208 N occurring in s (all the cases with \u201c\u00d7k\u201d), i.e. at worst #ints. \u2293\u2294\nConsequently, \u230a.\u230b is:\n\u2013 linear if numbers are bounded by constants; \u2013 quadratic if numbers are encoded in unary; \u2013 exponential if they are encoded in binary.\nIt is well-known that the satisfiability of LTL is in PSPACE [SC85], thus:\nTheorem 42. The satisfiability of SPS is in PSPACE if numbers are encoded in unary or bounded by constants. It is in EXPSPACE if numbers are encoded in binary.\nThis result improves over the one of [ACP10b], where the satisfiability of regular schemata is proved to be in EXPSPACE (resp. 2-EXPSPACE), if numbers are encoded in unary (resp. binary). Of course Theorem 42 only deals with sequential schemata, but both classes are close enough so that we conjecture that the satisfiability of regular schemata is also in PSPACE."}, {"heading": "5 Embedding LTL in SPS", "text": "We now tackle the reverse embedding, i.e. we translate LTL to SPS.\n5.1 A first faulty translation: finiteness vs infiniteness.\nWe provide a first, intuitive but faulty, translation:\nDefinition 43. Let \u03c6 be an LTL formula. Then \u2308\u03c6\u2309 is a schema defined as \u2308\u03c6\u23090, where \u2308\u03c6\u2309e is inductively defined for any expression e as follows:\n\u2308\u22a4\u2309e def = \u22a4\n\u2308p\u2309e def = pe\n\u2308\u00ac\u03c6\u2309e def = \u00ac\u2308\u03c6\u2309e\n\u2308\u03c61 \u2227 \u03c62\u2309e def = \u2308\u03c61\u2309e \u2227 \u2308\u03c62\u2309e\n\u2308X\u03c6\u2309e def = \u2308\u03c6\u2309e+1\n\u2308\u03c61U\u03c62\u2309e def =\nn\u2228\ni=e\n\n\u2308\u03c62\u2309i \u2227\ni\u22121\u2227\nj=e\n\u2308\u03c61\u2309j\n\n\nBut this is not satisfactory since the obtained schema is not sequential2 and, more important, because a valid LTL formula can be translated into a non-valid schema as shows the following example:\n2 Actually this is not even a schema in the sense of Definition 9 since the upper bounds of iterations are different from n \u2212 1. Notice that this is neither a regular schema [ACP09] since iterations are nested and the upper bound of one iteration contains a bound variable.\nExample 44.\n\u2308Xp\u21d2 Fp\u2309 = p1 \u21d2\nn\u2228\ni=0\npi\nThe formula Xp \u21d2 Fp is valid, but the schema p1 \u21d2 \u2228n\ni=0 pi is not valid (take any interpretation where n = 0). Adding conditions ensuring that n is strictly positive is possible, but obviously not sufficient, e.g. we could consider the formula Xkp\u21d2 Fp. Then the above translation will work only if n \u2265 k (where k is arbitrary).\nThe deep reason of this problem is that the semantics of schemata are intrinsically finite (though unbounded) whereas those of LTL are infinite. Actually, we can consider the previous translation as an indirect way to define \u201cfinite semantics LTL\u201d, i.e. LTL formulae interpreted over functions from {1, . . . , n} to 2P for any n \u2208 N. As explained in the Introduction, LTL with finite semantics has been studied in the contexts of planning and runtime verification [BK95,BM06,BH10]. But it seems that, rather than considering finite traces per se, the preferred approach in those fields is to turn finite traces into infinite ones by repeating infinitely the last state. Then the usual semantics of LTL can be used. Both systems seem however very similar.\n5.2 A successful translation into non-SPS\nWe actually need the ultimately periodic model property (Definition 6 and Theorem 7) to obtain a successful translation, written \u2308.\u2309, of LTL formulae into SPS. The aim of \u2308.\u2309 is that for every model \u03c3 of an LTL formula \u03c6, the interpretation V\u03c3W (Definition 21) is a model of \u2308\u03c6\u2309. An example is provided on Figure 6.\nConsider an LTL formula \u03c6. As we shall see, we will make use of the schema spfx\u2264 (Proposition 33) to enforce the fact that every model of \u2308\u03c6\u2309 is a 2-initial segment. As already exposed, this 2-initial segment is intended to denote a UP interpretation of prefix index k and period l (and the parameter n is assigned the value k + l \u2212 1). Then the translation of \u03c6 (or its subformulae) will be parametrized by an arithmetic expression e intended to denote the time (it may be either a natural number or a variable, when translating a subformula of an iteration, and it is initially equal to 0). This instant will of course have an influence on the translation. In particular it is important to know if this instant lies in the prefix of a UP model or in its loop. For the prefix, we already have the\npropositional variable pfx, which is specified by spfx\u2264 . But we need to introduce a new variable for the loop, say \u201c loope\u201d, that would be true iff e belongs to the loop. By definition, this is the case when e \u2208 {k, . . . , k + l \u2212 1}, thus we have to check that e \u2265 k and that e \u2264 n. By definition, the first property holds iff pfxe does not hold. We thus need to express e \u2264 n with a schema, this is done as follows:\nProposition 45. Let (\u03c3, n) be a schema interpretation and e be a Presburger expression. Then \u03c3 |= \u3008\n\u2228n i=e\u22a4\u3009n iff e[n/n] \u2264 n.\nProof. Indeed if e[n/n] > n then the iteration is empty, thus \u3008 \u2228n\ni=e\u22a4\u3009n = \u22a5, hence cannot be satisfied by \u03c3. Otherwise, if e[n/n] \u2264 n then the iteration is non empty, thus \u3008\n\u2228n i=e\u22a4\u3009n is a non empty disjunction of \u22a4, thus equivalent to\n\u22a4, hence necessarily satisfied by \u03c3. \u2293\u2294\nThus we define loope as follows:\nloope def = \u00acpfxe \u2227\nn\u2228\ni=e\n\u22a4\nDefinition 46. Let \u03c6 be an LTL formula, then \u2308\u03c6\u2309 is a schema defined as \u2308\u03c6\u2309 def = \u2308\u03c6\u23090 \u2227 s pfx \u2264 \u2227Axi=k\n3 where, for every arithmetic expression e, \u2308\u03c6\u2309e is inductively defined as follows:\n\u2308\u22a4\u2309e def = \u22a4\n\u2308p\u2309e def = pe\n\u2308\u00ac\u03c6\u2309e def = \u00ac\u2308\u03c6\u2309e\n\u2308\u03c61 \u2227 \u03c62\u2309e def = \u2308\u03c61\u2309e \u2227 \u2308\u03c62\u2309e\n\u2308X\u03c6\u2309e def = (e < n \u2227 \u2308\u03c6\u2309e+1) \u2228 (e = n \u2227 n\u2227\ni=0\n(i = k \u21d2 \u2308\u03c6\u2309i))\n\u2308\u03c61U\u03c62\u2309e def =\nn\u2228\ni=e\n\n\ni\u22121\u2227\nj=e\n\u2308\u03c61\u2309j \u2227 \u2308\u03c62\u2309i\n\n\u2228\n loope \u2227 n\u2227\nj=e\n\u2308\u03c61\u2309j \u2227 e\u2228\ni=0\n loopi \u2227 i\u22121\u2227\nj=0\n(loopj \u21d2 \u2308\u03c61\u2309j) \u2227 \u2308\u03c62\u2309i\n\n\n\n\nExample 47. In the cases of F and G, the translation simplifies drastically. For instance (some simple simplifications have been made):\n\u2308Fp\u23090 =\nn\u2228\ni=0\npi\n3 spfx\u2264 is defined in Proposition 33 and Axi=k is defined before Proposition 34.\n\u2308Gp\u23090 =\nn\u2227\ni=0\npi\nThis is not so simple if we consider a time t > 0:\n\u2308Fp\u2309t =\nn\u2228\ni=t\npi \u2228\n(\nloopt \u2227\nt\u2228\ni=0\n(loopi \u2227 pi)\n)\n\u2308Gp\u2309t =\nn\u2227\ni=t\n\u00acpi \u2227\n(\n\u00acloopt \u2228\nt\u2227\ni=0\n(loopi \u21d2 \u00acpi)\n)\nWe provide some intuitions on the transformation corresponding to the X and U connectives. First, for the X: when computing the next instant, one has to take into account the fact that we want a UP interpretation. Thus if e = n the next time after e is not e+ 1 but k, where k is the prefix index. This prefix index can be specified as the only index i such as loopi \u2227 loopi\u22121 holds. Second, for the U, the first disjunct is very natural: it corresponds to the typical case, for instance when time e occurs before the loop. Then, according to the definition of the semantics of U, we only have to check that \u03c61 holds on some interval {e, . . . , i\u2212 1} and then that \u03c62 holds at instant i. In general i may be arbitrary, but since the interpretation is UP, we can restrict to the case where i is in the interval {e, . . . , k + l \u2212 1}, i.e. i \u2264 n. The second disjunct is slightly more complex. It corresponds to the case where e occurs inside the periodic part of the interpretation. In this case, the element i such that \u03c62 holds may occur before e. Then \u03c61U\u03c62 also holds if \u03c61 holds from e to the end of the loop, i.e. n, and then holds again when we \u201cget back\u201d at the beginning of the loop, i.e. from k to some i \u2212 1, with \u03c62 holding at i \u2264 e. Since i \u2208 {0, . . . , e}, this can be easily stated as an iterated disjunction. The fact that i \u2265 k is encoded by stating that loopi must hold (i.e. i must be inside the periodic part of the interpretation).\nRemark 48. This transformation might remind the reader of some formulae encountered when dealing with the path model checking problem for UP interpretations [VG09]. This resemblance can be explained by observing that every model of s pfx \u2264 is a UP path, and \u2308\u03c6\u2309e is the operation of model checking the specified path. Then, as s pfx \u2264 specifies all UP paths, we actually model check all possible models, hence the fact that we can conclude about the satisfiability.\nThis transformation is sound and complete but the resulting schema is not sequential (iterations are nested and their bounds are different from 0 and n\u22121). Consequently, we present another translation in the next section, which will indeed fall in the class of SPS.\n5.3 A successful translation into SPS\nThe following translation follows more or less the same goal as the previous one: for every model \u03c3 of an LTL formula \u03c6, the interpretation V\u03c3W shall be a model\nof \u2308\u03c6\u2309. Hence it relies again on the UP property. This new transformation uses a structure-preserving approach: for each subformula \u03c6 (different from an indexed proposition) of the original formula, we introduce a fresh propositional variable written |\u03c6|. For an indexed proposition p, |p| def\n= p. Each indexed propositional variable |\u03c6|i, 0 \u2264 i \u2264 n, is then intended to be true iff the subformula \u03c6 is true at time i. Formally, we extend V.W as follows:\nDefinition 49. Let \u03c3 be a UP interpretation and \u03c6 an LTL formula. Then:\n\u2013 for every propositional variable of the form |\u03c8| for some subformula \u03c8 of \u03c6, (|\u03c8| , t) \u2208 V\u03c3W iff \u03c3, t |= \u03c8; \u2013 for every other variable, V\u03c3W is defined as described early on.\nFurthermore, for each subformula of the form \u03c61U\u03c62, we add another propositional variable called |\u03c61U\n\u2032\u03c62| (called this way because its behaviour is very close to the one of U) interpreted as true at t \u2208 N iff there is t\u2032 \u2208 N s.t. t \u2264 t\u2032 \u2264 k + l \u2212 1 where \u03c61 holds between t and t \u2032 \u2212 1 and \u03c62 holds at t \u2032, i.e. the semantics are the same as for U except that the instant when \u03c62 occurs must happen before the end of the loop (as explained thereafter, this variable is used to ensure that the eventuality indeed happens).\nNote that this semantic transformation now depends on the formula to translate. The inverse operation is defined as in Definition 31 except that the value of any variable |\u03c8| is \u201cforgotten\u201d.\nThe translation is done by adding axioms to compute the values of the newly introduced propositional variables (relating these values to the ones of the propositional variables originally occurring in the formula). As we shall see, the specification of those new variables is straightforward when the head symbol of the subformula is a boolean connective: the value of the considered variable can be directly related to the values of the variables corresponding to the operands, see definition of Ax\u00ac\u03c6 and Ax\u03c61\u2227\u03c62 in Definition 50 below.\nWhen the head symbol of the subformula is a temporal connective, we have to distinguish whether the index denotes a time lower or equal to n (since the interpretation is UP, we only have to consider the time interval {0, . . . , n}). In both cases, the value of the considered propositional variable |\u03c6| at time i is related to the one of the variables at the next instant. If i < n then this next instant is easy to compute: it is simply i+ 1. But if i = n, since the value of the variables |\u03c6| are specified only on the interval {0, . . . , n} we cannot refer to the time n+ 1 and we have to take advantage of the fact that the interpretation is periodic: since n necessarily corresponds to the end of the periodic part, the next instant must be the beginning of the loop. This is easily handled in the X case: if we have X\u03c6 at time n then we must have \u03c6 at time k where k is the beginning of the loop.\nIn the U case, if we have \u03c61U\u03c62 at time n then we have to deal with the fact that \u03c62 might hold after n, between time k and n \u2212 1 (by taking the loop into account). In this case we have to check that \u03c62 holds between k and n\u2212 1, and that \u03c61 holds in between. This check is triggered by the use of the new connective\nU\u2032, whose specification is thus added to the definition. Intuitively, \u03c61U \u2032\u03c62 may be seen as a connective interpreted as \u03c61U\u03c62, except that the formula \u03c62 must hold at the latest at time n (one may wonder why not use directly U instead of U\u2032; but this would yield an ill-founded definition: the eventuality could be always delayed and never fulfilled).\nDefinition 50. Let \u03c6 be an LTL formula. Then \u2308\u03c6\u2309 is the schema defined as \u2308\u03c6\u2309 def\n= |\u03c6|0\u2227\u03a6 \u03c6\u2227spfx\u2264 \u2227Axi=k where \u03a6 \u03c6 stands for \u2227 {Ax\u03c8 | \u03c8 is a subformula of \u03c6}\nand Ax\u03c8 is defined as follows:\nAx\u22a4 def =\nn\u2227\ni=0\n|\u22a4|i\nAx\u00ac\u03c6 def =\nn\u2227\ni=0\n(|\u00ac\u03c6|i \u21d4 \u00ac|\u03c6|i)\nAx\u03c61\u2227\u03c62 def\n= n\u2227\ni=0\n(|\u03c61 \u2227 \u03c62|i \u21d4 |\u03c61|i \u2227 |\u03c62|i)\nAxX\u03c6 def =\nn\u22121\u2227\ni=0\n(|X\u03c6|i \u21d4 |\u03c6|i+1) \u2227 (|X\u03c6|n \u21d4\nn\u2227\ni=0\n(i = k \u21d2 |\u03c6|i))\nAx\u03c61U\u03c62 def =\nn\u22121\u2227\ni=0\n(|\u03c61U\u03c62|i \u21d4 |\u03c62|i \u2228 (|\u03c61|i \u2227 |\u03c61U\u03c62|i+1))\n\u2227(|\u03c61U\u03c62|n \u21d4 (|\u03c62|n \u2228 (|\u03c61|n \u2227\nn\u2227\ni=0\n(i = k \u21d2 |\u03c61U \u2032\u03c62|i))))\n\u2227\nn\u22121\u2227\ni=0\n(|\u03c61U \u2032\u03c62|i \u21d4 |\u03c62|i \u2228 (|\u03c61|i \u2227 |\u03c61U \u2032\u03c62|i+1))\n\u2227(|\u03c61U \u2032\u03c62|n \u21d4 |\u03c62|n)\nwhere \u2227n i=0 s is a shortcut for \u2227n\u22121\ni=0 s \u2227 s[n/i] (we need to define this as an abbreviation so that the schema be indeed sequential).\nLemma 51. Let \u03c6 be an LTL formula and n \u2208 N. The instance of \u2308\u03c6\u2309 w.r.t. n contains only variables whose index is comprised between 0 and n.\nProof. By inspection of all cases in Definition 50, all indices of propositional variables in \u2308\u03c6\u2309 are n, i or i+1. i is always bound by an iteration whose bounds are 0 and n\u2212 1. Consequently the instance of \u2308\u03c6\u2309 w.r.t. n only contain indexed propositional variables whose indices are between 0 and n. \u2293\u2294\nTheorem 52. Let \u03c6 be an LTL formula. Then V.W is a bijection between the UP models of \u03c6 and the models of \u2308\u03c6\u2309 (if the latter are restricted to the values of propositional variables occurring in the corresponding instance of \u2308\u03c6\u2309). V.W\u22121 is the inverse bijection.\nProof. We first prove that the codomain of V.W indeed falls into the set of models of \u2308\u03c6\u2309, i.e., for every UP model \u03c3 of a formula \u03c6, V\u03c3W |= \u2308\u03c6\u2309. Let k, l be the prefix index and period of \u03c3. Note that, by Definition 28, V\u03c3W gives the value k+ l\u2212 1 to the parameter. Then we actually prove the more general result that for any t \u2208 N, if \u03c3, t |= \u03c6 then V\u03c3W |= spfx\u2264 \u2227|\u03c6|t\u2227\u03a6 \u03c6. First, since V\u03c3W is a 2-initial segment w.r.t. pfx, V\u03c3W |= spfx\u2264 . Second, V\u03c3W |= |\u03c6|t by definition (Definition 49). Finally we prove V\u03c3W |= \u03a6\u03c6 by proving that V\u03c3W |= Ax\u03c8 for any subformula \u03c8 of \u03c6, depending on the head symbol of \u03c8:\n\u2013 Assume \u03c6 = \u22a4. For any t \u2208 N, \u03c3, t |= \u22a4, by definition of LTL semantics. Thus, by definition of V\u03c3W, V\u03c3W |= |\u22a4|t for every t. Hence, V\u03c3W |= Ax\u22a4, and thus V\u03c3W |= \u03a6\u03c6. \u2013 Assume \u03c6 = \u00ac\u03c8. For any t \u2208 N, \u03c3, t |= \u03c6 iff \u03c3, t 6|= \u03c8, by definition of LTL semantics. Thus, by definition of V\u03c3W, V\u03c3W |= |\u03c6|t iff V\u03c3W 6|= |\u03c8|t, i.e. iff V\u03c3W |= \u00ac |\u03c8|t (this time by definition of schemata semantics). Consequently, V\u03c3W |= |\u03c6|t \u21d4 \u00ac|\u03c8|t for any t \u2208 N, and in particular for t between 0 and k + l \u2212 1. Thus V\u03c3W |= Ax\u03c6. \u2013 The conjunction cases are similar. \u2013 Assume that \u03c6 = \u03c61U\u03c62. Let t \u2208 N be s.t. \u03c3, t |= \u03c6. By the semantics of LTL,\nthere exists t\u2032 \u2265 t s.t. \u03c3, t\u2032 |= \u03c62 and, for all t \u2032\u2032 between t and t\u2032\u22121, \u03c3, t\u2032\u2032 |= \u03c61. Thus either \u03c3, t |= \u03c62 or \u03c3, t |= \u03c61 and \u03c3, t + 1 |= \u03c6. Hence, by definition of V.W, V\u03c3W |= |\u03c62|t or V\u03c3W |= |\u03c62|t+1 and V\u03c3W |= |\u03c6|t+1, which enables us to conclude for the first conjunct of the U case. For the reverse implication, suppose V\u03c3W |= |\u03c62|t \u2228 (|\u03c61|t \u2227 |\u03c61U\u03c62|t+1) for some t \u2208 N. If V\u03c3W |= |\u03c62|t, then it is clear that V\u03c3W |= |\u03c61U\u03c62|t. If V\u03c3W |= |\u03c61|t \u2227 |\u03c61U\u03c62|t+1, then by definition \u03c3, t |= \u03c61 \u2227 \u03c61U\u03c62, thus V\u03c3W |= |\u03c61U\u03c62|t. For the second conjunct (i.e. the second line; notice that, for the sake of presentation simplicity, there is one conjunct per line), assume t = k+ l\u2212 1. If \u03c3, t |= \u03c62 then we are done. Otherwise, we have t\n\u2032 > k+ l\u2212 1. This means that \u03c3, k + l |= \u03c61U\u03c62, which, by periodicity, is equivalent to \u03c3, k |= \u03c61U\u03c62, and so to \u03c3, k |= \u03c61U\n\u2032\u03c62. For the third and fourth conjuncts the proof is similar, except that we now must ensure that the instant when \u03c62 occurs must be lower or equal to k+l\u22121. This is indeed the case of t\u2032 \u2193.\n\u2013 The case of X is similar (but much simpler).\nWe now focus on the inverse transformation. First, V.W\u22121 is well defined: since \u2308\u03c6\u2309 contains spfx\u2264 , every model of \u2308\u03c6\u2309 is a 2-initial segment. Second, it is easily seen that V(VIW)W\u22121 = I. Third, V(VI, nW\u22121)W is well defined since, by definition, VI, nW\u22121 is UP. Then V(VI, nW\u22121)W = (I, n), if we restrict to the values of I for indices below n. However they might differ for indices above n, but, by Lemma 51, variables with such indices do not occur in the instance of \u2308\u03c6\u2309 by n. Since we consider equality among interpretations only up to the values of propositional variables occurring in the corresponding instance of \u2308\u03c6\u2309, we indeed have the intended equality.\nWe finally show that the codomain of V.W\u22121 indeed falls in the set of models of \u03c6, i.e. that for every model M of \u2308\u03c6\u2309, VMW\u22121 |= \u03c6. We shall prove the more\ngeneral result that, for every t \u2264 k + l \u2212 1, where k, l are the prefix index and the period of VMW\u22121, and every subformula \u03c8 of \u03c6, if M |= spfx\u2264 \u2227 |\u03c8|t \u2227\u03a6 \u03c6 then VMW\u22121, t |= \u03c8. By induction on the structure of \u03c6:\n\u2013 For \u22a4 this is trivial. \u2013 Assume \u03c6 = \u00ac\u03c8. Then M |= spfx\u2264 \u2227 |\u03c6|t \u2227 \u03a6 \u03c6 implies M |= |\u00ac\u03c8|t and M |=\nAx\u00ac\u03c8, thus M |= \u00ac |\u03c8|t, so M 6|= |\u03c8|t. As already shown, M = V(VMW \u22121)W (as far as we consider t \u2264 k + l \u2212 1 which is indeed the case here), hence V(VMW\u22121)W 6|= |\u03c8|t. Hence, by contraposition w.r.t. the previous result in this proof, VMW\u22121, t 6|= \u03c8. Consequently, VMW\u22121, t |= \u03c6. \u2013 For conjunction the result is routine, using the induction hypothesis. \u2013 Assume \u03c6 = X\u03c8. Then we have either t < k + l \u2212 1 or t = k + l \u2212 1. In\nthe first case, one easily gets M |= spfx\u2264 \u2227 |\u03c8|t+1 \u2227\u03a6 \u03c8 by the first conjunct of AxX\u03c8 and concludes by induction hypothesis. In the second case, |\u03c6|k+l\u22121 is equivalent to |\u03c6|n (because, by definition of V.W\n\u22121, k+ l\u22121 is the value given to n), so we can use the second conjunct which states that \u03c8 must hold at time k. By the UP property, \u03c8 also holds at time k + l, i.e. t+ 1, hence the result. \u2013 Finally assume \u03c6 = \u03c61U\u03c62. We have two cases: Either there is some t \u2032\ncomprised between t and k+ l\u2212 1 s.t. |\u03c62|t\u2032 holds; assume furthermore that t\u2032 is the smallest time with this property; in this case, |\u03c61| must hold between t and t\u2032, by the (iterated application of the) first conjunct of Ax\u03c61U\u03c62 ; we then just apply the induction hypothesis to conclude. Or there is no such t\u2032, in which case |\u03c61| must hold from t to k + l \u2212 1, by the same argument. Furthermore, since |\u03c62|t\u2032 never holds for t\n\u2032 between t and k + l \u2212 1, the iteration\n\u2227n i=0(i = k \u21d2 |\u03c61U\n\u2032\u03c62|i) of the second conjunct also holds in M. Hence M |= |\u03c61U\n\u2032\u03c62|k. Consequently, by the iterated application of the last two conjuncts, there must be some t\u2032 comprised between k and k+ l\u2212 1 (actually t\u22121 is sufficient) s.t. |\u03c62|t\u2032 holds, and |\u03c61| holds in between: indeed, the last conjunct imposes that |\u03c62| must hold at worst at instant n (note: this is precisely why U\u2032 is needed). The fact that |\u03c61| holds in between is due to the similar structure between the two first and the two last conjuncts. Finally, by the UP property, the same holds for t\u2032 + l, which enables us to conclude. \u2293\u2294\nFurthermore it is trivial that #\u2308\u03c6\u2309 is linear w.r.t. #\u03c6.\nCorollary 53. The satisfiability problem for LTL can be reduced in linear space to the satisfiability problem for SPS.\nTheorem 54. The satisfiability problem for SPS is PSPACE-complete if numbers are encoded in unary or bounded by a constant.\nProof. Consequence of the fact that the satisfiability problem for LTL is PSPACEcomplete, of the previous corollary and of Theorem 42. \u2293\u2294\nNotice however that this result could be proved in a much simpler way by directly encoding a polynomial space Turing machine with SPS. Such a proof would be very close to the one of Theorem 1 in [Byl91].\nImprovements. For practical efficiency, we can improve over Definition 50. We can translate the purely propositional connectives directly, i.e. without axiomatising them: any occurrence of an atom |\u22a4|e (resp. |\u00ac\u03c6|e, resp. |\u03c61 \u2227 \u03c62|e) is directly replaced by \u22a4 (resp. \u00ac|\u03c6|e, resp. |\u03c61|e \u2227 |\u03c62|e) repeatedly until there is no more such occurrence. The same applies to \u2228, \u21d2 and \u21d4. Those are defined as abbreviations in the present paper in order to simplify definitions and proofs, but it is of course more efficient in practice to translate them directly when available as primitive connectives (obviously, this is also true for Definition 35).\nAnother optimization can be devised by observing that all schemata decision procedures [ACP09,ACP10a] reason by induction on n, i.e. they refute a schema for any value of n by reduction to the case n\u2212 1. In our reduction, n corresponds to the last instant of the UP interpretation. Consequently, a schema procedure applied to a translated LTL formula starts by considering the last instant of the interpretation and then going backward. This is counter natural since we try to refute a formula at time 0. For instance, an inductive proof is achieved for the formula Xp\u2227X\u00acp even though this is obviously not needed: one would naturally try to first see what happens at time 0 and then switch to the next state, as is done with LTL procedures. To tackle this problem we just need to change the translation by \u201cinverting the time\u201d: i.e. the index 0 will be interpreted as the last instant of the period and the index n as its first instant. Concretely, in Definition 50, we just rewrite every index i \u2212 1 into i, every index i into i + 1, every index 0 into n, and every index n into 0. Experiments with this translation indeed confirm that conjectures are refuted faster using this new translation.\nRemark 55. The translation given here might remind the reader of bounded model checking (BMC) [BCC+03]. A very important difference however is that our reduction is complete, which is of course not the case of BMC. Indeed, the whole point of schemata is to reason about an infinite family of propositional formulae without having to instantiate the parameter. Our translation could of course be used for BMC, simply by instantiating the parameter with successive natural numbers. However the converse does not hold: not every translation found in BMC could fit instead of Definition 50, since the result must respect the syntactical criteria ensuring decidability of the satisfiability problem. For instance, renaming sub-formulae by propositional variables is just an optimization in the case of BMC whereas in our case, it is needed since, otherwise, the resulting schema would not be sequential (and not even regular). Completeness is an important problem in BMC which is usually tackled with notions like completeness thresholds and recurrence diameter [BCC+03] or induction [SSS00]. Thorough analysis of how schemata procedures handle the above translation could give new ideas in order to get completeness for BMC."}, {"heading": "6 Implementation", "text": "The implementations of both translations are available at http://membres-liglab.imag.fr/aravantinos/Site/ Some preliminary experiments have been achieved on a few benchmarks: standard schemata examples provided with RegStab [ACP10c] have been translated\nto LTL (note that the examples have been slightly modified in order to fit the constraints of SPS) and standard LTL pattern formulae [RV07] have been translated to SPS. The performance of RegStab and pltl (http://users.cecs.anu.edu.au/~rpg/software.html) have been compared on both benchmarks. In both cases, pltl clearly outperformed RegStab. We see two reasons to this:\n\u2013 RegStab deals with regular schemata, which are more general than SPS. In particular, the decision procedure for such schemata requires the detection and elimination of pure literals (an adaptation of the \u201cAffirmative-negative rule\u201d of [DP60]), which is well-known to be a huge time-consuming task (and this is even more the case for schemata since we have to deal with a symbolic notion of pure literal). This auxiliary procedure is needed for termination, and is mainly a consequence of the \u201cnon-local\u201d aspect of schemata.\n\u2013 With LTL procedures, given a formula \u03c6, one knows in advance all the formulae that will occur in the deduction process: all of them belong to the closure of \u03c6 (merely the set of all subformulae of \u03c6, closed by negation and unfolding of temporal formulae); this permits the use of efficient data structures to represent sets of formulae, e.g. pltl uses bitsets. This is not the case of SPS (and even more regular schemata), e.g. refuting a schema containing\n\u2227n i=0 pi potentially leads to the introduction of pn, pn\u22121, pn\u22122,\netc. By termination for regular schemata [ACP09], this enumeration is finite but one does not know in advance how far it has to go. Hence the data structures used in RegStab are much heavier: e.g. we use balanced trees for sets of formulae. Thus, for big examples, the memory is easily saturated and RegStab spends much of its time in its handling which was absolutely not the case of pltl.\nThe most important reason seems to be the second one. It can actually be tackled in order to improve RegStab performance: we can syntactically extract from the input schema a bound for the above enumeration pn, pn\u22121, pn\u22122, . . . by analysis of the termination proof for regular schemata. Implementing this technique is ongoing work.\nYet, there are examples where RegStab did better than pltl. Consider (p1 \u21d2 qn+1) \u2227 p1 \u2227 \u00acqn+1 \u2227 \u03c6 where \u03c6 is any formula involving some iterations. This schema is immediately refuted by RegStab, but the bigger \u03c6 is, the longer it takes for pltl to refute the corresponding LTL formula. Of course, this example was devised to emphasize one of the strengths of RegStab: contrarily to LTL procedures in general, and to pltl in particular, reasoning about schemata is global, i.e. RegStab may reason simultaneously on propositions containing various symbolic indices. In contrast, pltl will analyse the formula \u03c6 and the contradiction will appear only at the end of the construction (i.e. by \u201cdiscovering\u201d eventually that t = n cannot hold at any state, since it would allow to derive a contradiction)."}, {"heading": "7 Discussion", "text": ""}, {"heading": "7.1 Pros and cons of each logic", "text": "Since LTL and SPS are equivalent w.r.t. satisfiability, one may wonder which to favour. There are two major differences between LTL and schemata:\n\u2013 LTL default interpretations are infinite whereas those of schemata are finite; \u2013 LTL refers to states in an anonymous way, whereas schemata name them.\nThese differences provide us with clear criteria for choosing one logic or the other in different situations: to specify an infinite behaviour, one would naturally use LTL, whereas classes of structurally similar finite behaviours are more naturally specified with schemata. Unsurprisingly, the specification of temporal behaviours falls of course in the first category. But, e.g., the specification of a circuit independently of the number of bits of its input falls in the second category. Consider for instance the specification of a ripple-carry adder:\nn\u2227\ni=0\n((si \u21d4 (xi \u2295 yi)\u2295 ci) \u2227 (ci+1 \u21d4 (xi \u2227 yi) \u2228 (yi \u2227 ci) \u2228 (xi \u2227 ci))) \u2227 \u00acc0\nwhere x0, . . . , xn and y0, . . . , yn are the input bit vectors of size n; s0, . . . , sn is the output bit vector and c0, . . . , cn is the carry vector. Here the indices indeed correspond to the time in a concrete sequential circuit. However, from a specification point of view, those indices are just an abstract way to represent a generic scheme of circuits. Consequently, the schema syntax seems better suited to this case (notice furthermore that it is very intuitive).\nSimilarly, the choice between a named or an anonymous representation of states depends on the situation. The X connective is well suited to express properties in a local way, since there is no need to explicitly use an index to refer to the current or the next state. The U connective is also far more intuitive than its translation to SPS to refer to some instant satisfying some property in the future. On the other hand, in order to refer to an identified instant of the future, one needs to refer to it by giving it a name, which is easily done with the schema syntax thanks to arithmetic. Consider e.g. the example p0\u2227 \u2227n\u22121 i=0 (pi \u21d2 pi+1)\u2227\u00acpn translated as p\u2227G(t < n \u21d2 p\u21d2 Xp)\u2227G(t = n \u21d2 \u00acp) (plus the necessary axioms \u03c6t<n< \u2227Axt=n) in LTL. One can even specify behaviours after that time (but this goes beyond sequential schemata [ACP11]), e.g. one can write p0\u2227 \u2227n i=0(pi \u21d2 pi+1)\u2227 \u22272n\ni=n(\u00acpi+1 \u21d2 \u00acpi)\u2227\u00acp2n. It seems improbable that such a property would be useful in a temporal context, but this could be used to specify planning problems with some predefined strategy e.g. if one wants to allow some set of actions in a first phase of a planning problem and then another set in some other phase of this problem."}, {"heading": "7.2 Behaviour of \u230a.\u230b w.r.t. LTL decision procedures", "text": "We now analyse informally how the standard multi-pass tableau procedure of [Wol85] (called LTL-tab from now on) behaves on a translated schema. Consider\nthe example p0 \u2227 \u2227n\u22121\ni=0 (pi \u21d2 pi+1) \u2227 \u00acpn and its translation p \u2227G(t < n \u21d2 p \u21d2 Xp) \u2227 G(t = n \u21d2 \u00acp) \u2227 \u03c6t<n< \u2227 Axt=n\n4. We do not present a detailed tableau, instead we just sketch its construction by focusing on the most relevant branches (the following requires some knowledge of LTL-tab, see [Wol85] otherwise).\nWhen applying LTL-tab, the rule for the U connective applies on \u03c6t<n< (i.e. (t < n)UG(\u00act < n)) and generates one branch where G(\u00act < n) holds and one branch where t < n and X((t < n)UG(\u00act < n)) hold. Intuitively, the first one corresponds to the case n = 0 (since it states that \u00ac(t < n) always holds from the initial state till \u03c9) while the second one corresponds to n > 0 (since t < n holds at the initial state). In the first case, LTL-tab easily finds a contradiction using mostly propositional reasoning (\u00act < n entails t = n thanks to Axt=n, and t = n entails \u00acp with G(t = n \u21d2 \u00acp), thus yielding a contradiction). In the second case, since t < n holds, one easily obtain Xp by propositional reasoning with t < n \u21d2 p\u21d2 Xp. Then the decomposition of Axt=n yieldsG(t < n\u2227\u00acX(t < n) \u21d4 X(t = n)). By application of the rule for G, one immediately gets the formula t < n \u2227 \u00acX(t < n) \u21d4 X(t = n), and we then get two non-closed branches: one where \u00acX(t < n) and X(t = n) hold (call this state \u201c1\u201d), and one where X(t < n) and \u00acX(t = n) hold (\u201c2\u201d). At the next state, we thus have two branches: one where \u00act < n and t = n hold, and one where t < n and \u00act = n hold. The first branch means that the instant corresponding to n has been reached and is easily closed similarly to the base case (actually, up to some formulae that only occur in the initial formula, this state is the same as the one corresponding to n = 0). The second branch means that n has still not been reached, thus we can go to the next state without encountering a contradiction. This is easily seen to lead either to state \u201c1\u201d or \u201c2\u201d, hence the construction of the tableau terminates. Since \u201c2\u201d is closed the only non closed branch is the one that indefinitely loops on \u201c1\u201d. But this loop is closed in the second pass because the eventuality (t < n)UG(\u00act < n) is never satisfied.\nTo sum up, the construction of this tableau follows quite faithfully a proof by induction on the parameter n. The axioms \u03c6t<n< and Axt=n contain the arithmetic content that drive the induction, while \u230as\u230bprop contains the purely propositional content. Since LTL has to deal with infinite interpretations the induction is not well-founded in general (this is of course a wanted feature of LTL in order to deal with coinductive specifications). But the axiom \u03c6t<n< introduces the eventuality (t < n)UG(\u00act < n) which enforces a well-founded induction. Notice that \u230a.\u230b can be modified so that \u03c6t<n< be the only eventuality occurring in the resulting formula. Indeed, in its current state, the translation may introduce eventualities in two ways: either by negating an iteration\n\u2227n\u22121 i=0 s, or by negating an atom of the\nform pn+k. In the first case, the negation is equivalent to \u2228n\u22121 i=0 \u00acs which can easily be simulated by the proposition qn with the axiom \u00acq0 \u2227 \u2227n\u22121\ni=0 qi+1 \u21d4 (\u00acs \u2228 qi). In the second case the translation of \u00acpn+k is \u00acG(t = n \u21d2 X\nkp). But, as already encountered in Example 36, this is equivalent to G(t = n \u21d2 Xk\u00acp) since\n4 Notice that this translation has been simplified since we use G(t = n \u21d2 \u00acp) instead of \u00acG(t = n \u21d2 p).\nt = n holds at only one instant. Consequently one can get rid of those artificial eventualities as follows:\n\u2013 put the schema in negation normal form (this introduces \u22a5, disjunctions and iterated disjunctions);\n\u2013 delete every iterated disjunction by replacing it with a proposition qn axiomatized as above;\n\u2013 apply the translation (which is straightforwardly extended to \u22a5 and disjunction) by handling the case \u00acpn+k as above.\nThis is interesting since it makes the second pass much easier to handle. Furthermore it shows clearly that the overall proof is indeed an inductive proof, obtained from a coinductive proof by discarding the ill-founded branch in the second pass.\nProof procedures for schemata are defined by combining usual propositional procedures and inductive reasoning. This inductive reasoning is performed by a loop detection during the construction of the tableau. For instance Stab [ACP09] is defined by extending semantic tableaux. The reader acquainted with Stab may have noticed that the tableau we just sketched looks quite similar to the one that would be obtained with Stab for the corresponding schema. This is mainly a matter of strategy since we oriented the construction in a way to make it understandable from a \u201cschema point of view\u201d. There are many other tableaux that would have differed from the one obtained with Stab. The main differences between LTL-tab and Stab are the following:\n\u2013 Arithmetic is handled natively in Stab;\n\u2013 In LTL-tab, termination is ensured by identifying nodes with the same labels, whereas this is not sufficient, in Stab, to ensure termination: a dedicated cycle relation must be defined (e.g. there is a cycle between\n\u2227n\u22121 i=0 s and\u2227n\ni=0 s). This is obviously not an essential difference, which is only related to the way schemata are represented and stored in the nodes;\n\u2013 In LTL-tab, an artificial branch corresponding to an ill-founded derivation is discarded in the second phase, whereas in Stab the cycle relation embeds a (strict) ordering which ensures the well-foundedness of the derivation (e.g. \u2227n\ni=0 s cannot loop on itself). Consequently Stab does not require a second phase.\n\u2013 In LTL-tab, the reasoning is purely local, i.e. only formulae that are true at the current state are derived. In contrast, Stab may reason simultaneously on propositions containing various symbolic indices. This is related to the fact that schemata handles time in a symbolic way and it explains why, as mentioned in Section 6, pltl performed so bad on (p1 \u21d2 qn+1)\u2227p1\u2227\u00acqn+1\u2227\u03c6 where \u03c6 is a big formula involving some iterations. In contrast LTL-tab (and pltl) analyses the formula \u03c6 and the contradiction appears only at the end of the construction (i.e. by \u201cdiscovering\u201d eventually that t = n cannot hold at any state, since it would allow to derive a contradiction)."}, {"heading": "7.3 Behaviour of \u2308.\u2309 w.r.t. SPS decision procedures", "text": "Conversely, we can consider an LTL formula \u03c6 and apply Stab on \u2308\u03c6\u2309. For instance, take the unsatisfiable LTL formula \u03c6 def\n= Xp \u2227 \u00acXp. The translation is then the conjunction of the following schemata (we use the optimizations mentioned at the end of Section 5):\n|Xp|n \u2227 |X\u00acp|n n\u22121\u2227\ni=0\n(|Xp|i+1 \u21d4 pi)\n|Xp|0 \u21d4 (0 = k \u21d2 p0) \u2227\nn\u22121\u2227\ni=0\n(i+ 1 = k \u21d2 pi+1)\nn\u22121\u2227\ni=0\n(|X\u00acp|i+1 \u21d4 |X\u00acp|i)\n|X\u00acp|0 \u21d4 (0 = k \u21d2 \u00acp0) \u2227\nn\u22121\u2227\ni=0\n(i+ 1 = k \u21d2 \u00acpi+1)\n\u00acpfxn \u21d4 n = k\nn\u22121\u2227\ni=0\n(pfxi \u2227 \u00acpfxi \u21d4 i = k)\n\u00acpfx0 n\u22121\u2227\ni=0\n(pfxi \u21d2 pfxi+1)\nIt is immediately noticed that, even though the transformation is linear, the linear coefficient is very big: a very simple LTL formula is turned into a complicated schema.\nWe just sketch the resulting tableau. As explained in the previous section, the general idea of Stab is to refute a formula by induction on the parameter n. In the context of \u2308.\u2309, n represents the length of a UP interpretation. Consequently Stab shows that every UP interpretation falsifies the formula, by induction on n. Such an approach is obviously original, but a priori not natural from an LTL point of view. The general scheme of the proof may be divided into three cases as follows (see Fig. 7): either the interpretation has only one state (looping on itself), or it has more than one state. In the first case, there are finitely many interpretations, so the proof is easily achieved (simply by a tableaux-like enumeration of interpretations). In the second case, we encounter two more cases, depending on the position of the prefix index: it can either coincide with the first state, or with a state farther in the interpretation (formally, this corresponds to a simple case splitting on the propositional variable n = k). The reasoning in each case then depends on the formula itself.\nIt is particularly interesting to understand how we deal with eventualities: how does it happen that we do not need a second phase, similarly to LTL-tab? To answer this question, we can observe (again informally) how Stab behaves on the formula Gp \u2227 F\u00acp. Notice that we can easily define a simplified translation for the connectives G and F with the following axioms:\nAxG\u03c6 def = \u2227n\u22121\ni=0 (|G\u03c6|i \u21d4 |\u03c6|i \u2227 |G\u03c6|i+1)\n\u2227(|G\u03c6|n \u21d4 |\u03c6|n \u2227 \u2227n i=0(i = k \u21d2 |G\u03c6|i))\nAxF\u03c6 def = \u2227n\u22121\ni=0 (|F\u03c6|i \u21d4 |\u03c6|i \u2228 |F\u03c6|i+1)\n\u2227(|F\u03c6|n \u21d4 |\u03c6|n \u2228 \u2227n i=0(i = k \u21d2 |F \u2032\u03c6|i)) \u2227 \u2227n\u22121\ni=0 (|F \u2032\u03c6|i \u21d4 |\u03c6|i \u2228 |F \u2032\u03c6|i+1)\n\u2227(|F\u2032\u03c6|n \u21d4 |\u03c6|n)\nwhere F\u2032 is a new connective which is to F what U\u2032 is to U. The case with only one state is easily handled. When there are more than one state, it is easily seen that the conjecture Gp \u2227 F\u00acp still holds at the next instant. Thus if the prefix index is above 1, then the induction hypothesis allows to conclude immediately. However when the prefix is empty, the induction hypothesis does not apply: we actually need to make a case splitting on the value of the variable F\u2032\u00acp: intuitively, this variable holds iff there is some instant before n s.t. p holds. If this variable is assumed true, then we easily obtain a contradiction with Gp (by induction). If it is supposed false, then we get a contradiction with the (second conjunct of the) axiom of U which states that \u03c61U\n\u2032\u03c62 must hold at time k (i.e. 0, here), and this concludes the refutation.\nLet us now generalize the way eventualities are handled. At any moment, the procedure \u201cstores\u201d the fact that any eventuality occurring as a subformula of the original formula holds or not. This is stored in the corresponding \u201cprimed\u201d subformula (i.e. it is true iff the eventuality holds). Then, if ever an eventuality does not hold at the end of the period, the second conjunct of the U axiom imposes that the eventuality held before that time, inside the period. If this was not the case, then the corresponding primed subformula is false, thus we\nget a contradiction and this interpretation is discarded. On the contrary, if the eventuality held before, then we found a model.\nThe reader acquainted with the one-pass Schwendimann algorithm (\u201cSA\u201d) for LTL [Sch98] might recognize this behaviour. Indeed this algorithm builds a tableau by maintaining in each state a set of unfulfilled eventualities. This can be seen as corresponding to the \u201cprimed eventualities\u201d of our translation. The set of unfulfilled eventualities at a state can be retrieved simply as the set of primed eventualites that are false at that state. However, apart from those informal similarities, the procedures are quite different:\n\u2013 Stab builds explicitly a UP interpretation (that can be retrieved directly from a non closed branch of the resulting tableau) whereas SA just ensures that such an interpretation exists (which can be retrieved by loop linearization, see [Sch98], proof of Theorem 28). This probably makes the outcome of SA more \u201cunderstandable\u201d, since it is more compact. \u2013 In any branch, Stab considers all eventualities, whereas SA considers only the eventualities needed for the current branch. This makes probably SA more efficient than Stab since many useless situations are trivially discarded. \u2013 On the other hand, the fact that Stab considers all eventualities makes it possible to consider a looping in the whole tree. This is not the case of SA which imposes a looping in the current branch. This is precisely why the worst-case complexity of SA is bigger than the one of algorithms \u00e0 la Wolper. Of course, an implementation of Stab can still impose loopings to occur only in the current branch which thus makes available both possibilities to Stab. Consequently, an advantage of Stab is that it allows for a one-pass algorithm, while preserving an exponential time complexity. \u2013 The trade-off is that Stabmakes some redundant computations: for instance, the procedure needs to \u201cdecide\u201d in advance if a node is the start of the UP interpretation\u2019s loop, thus leading to two different branches sharing many inferences. With SA, the inferences are just made irrespective of whether the node will be the start of the loop or not, and then the loop detection is handled by the algorithm itself. Similarly the fact that the semantics are encoded in the translation makes Stab consider some cases that would be automatically discarded by SA."}, {"heading": "8 Model checking safety properties with schemata: an example", "text": "With the translation given in Section 5, and classical results of reduction from satisfiability to model checking [SC85,RV07], one can of course use schemata to model check LTL formulae. However if we restrict ourselves to n.n.f. LTL formulae whose only temporal operators are X and G, we can obtain a much simpler translation into schemata. Such formulae are of interest since they can in particular model safety properties, i.e. formulae of the form G\u03c8 where \u03c8 is a purely propositional formula. Suppose we have a transition system T and want to check if it is a model of \u03c6. We first recall those notions:\nDefinition 56. A transition system is the triple of a set of states S, a set of actions A, and a transition function \u03b4 : S \u00d7 A \u2192 S. A (finite or infinite) path is a sequence of states which respects the transition function.\nAn interpreted transition system is the pair of a transition system and a labelling function l : S \u2192 2P , where P is a finite set of propositional variables. As usual a computation is a sequence of subsets of P corresponding to some path of the transition system. For a given path \u03c0, we write l(\u03c0) for its corresponding computation.\nAn infinite computation can obviously be seen as an LTL interpretation (in the sense of Definition 1). Then an interpreted transition system (T, l) is a model of an LTL formula \u03c6 iff every infinite computation in (T, l) is a model of \u03c6.\nWe now show on an example how we can model check a transition system against a formula using schemata. We do not provide any formalisation since the example can easily be generalized. Consider the interpreted transition system T represented on Figure 8. We can represent the behaviour of T on all finite paths with\na schema.\nFirst we model the sole structure of the system, i.e. the uninterpreted transition system. The indexed proposition state1i (resp. state 2 i , state 3 i ) means we are in state 1 (resp. 2, 3) at time i, and actionai (resp. action b i ) means that the action taken at time i is a (resp. b):\nstate1i \u2227 action a i \u21d2 state 3 i+1 state1i \u2227 action b i \u21d2 state 2 i+1 state2i \u2227 action a i \u21d2 state 2 i+1 state2i \u2227 action b i \u21d2 state 2 i+1 state3i \u2227 action a i \u21d2 state 2 i+1 state3i \u2227 action b i \u21d2 state 1 i+1\nNow the label of each state is easily modelled by the following schema:\nstate1i \u21d2 pi \u2227 qi \u2227 \u00acri state2i \u21d2 \u00acpi \u2227 qi \u2227 ri state3i \u21d2 pi \u2227 \u00acqi \u2227 ri\nwhere pi (resp. qi, ri) means that p (resp. q, r) holds at time i. Finally we also have to specify the fact that, at each instant i, there is one and only state active, and one and only one action can be taken 5:\nstate1i \u21d4 \u00acstate 2 i \u2227 \u00acstate 3 i state2i \u21d4 \u00acstate 1 i \u2227 \u00acstate 3 i state3i \u21d4 \u00acstate 1 i \u2227 \u00acstate 2 i actionai \u21d4 \u00acaction b i\nWe write sT for the conjunction of all those schemata, all wrapped under a single\u2227n i=0. s is not precisely an SPS since the upper bound of this iteration is n and not n\u2212 1. But this is easily circumvented (s is regular anyway). Now if we want to check this model against the formula G(p \u2228 q), we first translate this formula into a schema: \u2308G(p\u2228 q)\u2309 = \u2227n\ni=0(pi \u2228 qi). If the transition system is indeed a model of G(p\u2228q), then s\u21d2\n\u2227n i=0(pi\u2228qi) must be valid (which\nintuitively means that for every n \u2208 N and every path of length n, the property p\u2228 q holds all along the path). Equivalently, it is a model iff s\u2227\n\u2228n i=0(\u00acpi \u2227\u00acqi)\nis unsatisfiable (which means that there exists n \u2208 N and a path of length n s.t. the property p \u2228 q does not hold at one state of the path). We can thus use any regular schema SAT-solver (like RegStab) to check if this formula is satisfiable or not."}, {"heading": "9 Conclusion and future work", "text": "LTL formulae and the so-called sequential propositional schemata have been shown to be reducible to each other in polynomial time (exponential time when numbers are encoded in binary). This entails that the satisfiability of SPS is PSPACE-complete. Both those results are new. The reduction of SPS to LTL is not so surprising, and the converse reduction makes use of the well-known fact that the infinite semantics of LTL can be finitely represented. This remark illustrates one of the two major differences between LTL and schemata: whereas the semantics of LTL are infinite, those of schemata are finite. The other difference is that schemata allow to refer to a time in the future in a symbolic way (using the parameter n) and to use arithmetic operations to construct time expressions. If these operations are sufficiently simple, they can be encoded in LTL formulae as shown in Section 4. On the other hand, LTL allows for a much handier way to deal with time in a purely local way.\n5 It is actually useless to ensure explicitly the unicity of actions since this is entailed by the unicity of states.\nFuture work. Using the above translations to help export procedures from one logic to another is an obvious follow-up of this work (in particular, Dpll inspired procedures for schemata could help defining such a procedure for LTL). Similarly, as explained in Remark 55, investigating how model checking is done by translation to schemata could give ideas to define new completeness criteria for bounded model checking. The extension of the presented results to other classes of schemata could also be considered, e.g. schemata with nested iterations (proved decidable in [ACP10a,ACP11]). Translation algorithms from nested schemata into sequential ones exist [ACP11], however they are of double exponential complexity. Thus we conjecture that no polynomial-time transformation from nested schemata to LTL exists. The extension of this study to other \u2013 more expressive \u2013 temporal logics could also be of interest. Notably, LTL with past operators [LPZ85] seems to be easily handled with (non sequential) schemata simply by allowing negative numbers in indices. Since implementations for this logic do not have the same support as standard LTL and are generally not as efficient, such a reduction could help in improving those points. One could go even further by making connections between schemata and monadic second order logic (MSO). This would be interesting both in theory and practice, since few implementations are available for MSO (only MONA [HJJ+95] seems to be actively maintained)."}], "references": [{"title": "A Schemata Calculus for Propositional Logic, TABLEAUX", "author": ["ACP09. Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier"], "venue": "vol. 5607,", "citeRegEx": "Aravantinos et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2009}, {"title": "A Resolution Calculus for Propositional Schemata", "author": ["AMEP10. Vincent Aravantinos", "Mnacho Echenim", "Nicolas Peltier"], "venue": "Tech. report,", "citeRegEx": "Aravantinos et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2010}, {"title": "Bounded model checking", "author": ["BCC03. Armin Biere", "Alessandro Cimatti", "Edmund M. Clarke", "Ofer Strichman", "Yunshan Zhu"], "venue": "Advances in Computers", "citeRegEx": "Biere et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Biere et al\\.", "year": 2003}, {"title": "LTL Goal Specifications Revisited, ECAI (Amsterdam)", "author": ["BH10. Andreas Bauer", "Patrik Haslum"], "venue": null, "citeRegEx": "Bauer and Haslum,? \\Q2010\\E", "shortCiteRegEx": "Bauer and Haslum", "year": 2010}, {"title": "The complexity of propositional linear temporal logics", "author": ["SC85. A.P. Sistla", "E.M. Clarke"], "venue": "Journal of the ACM", "citeRegEx": "Sistla and Clarke,? \\Q1985\\E", "shortCiteRegEx": "Sistla and Clarke", "year": 1985}, {"title": "Star-free regular sets of \u03c9-sequences", "author": ["Tho79. Wolfgang Thomas"], "venue": "Information and Control", "citeRegEx": "Thomas,? \\Q1979\\E", "shortCiteRegEx": "Thomas", "year": 1979}, {"title": "Temporal Logics for Specification and Verification, Proceedings of the European Summer School in Logic, Language and Information (ESSLI\u201909)", "author": ["VG09. Valentin Goranko"], "venue": null, "citeRegEx": "Goranko,? \\Q2009\\E", "shortCiteRegEx": "Goranko", "year": 2009}, {"title": "The tableau method for temporal logic: an overview", "author": ["Wol85. Pierre Wolper"], "venue": "Logique et Analyse", "citeRegEx": "Wolper,? \\Q1985\\E", "shortCiteRegEx": "Wolper", "year": 1985}, {"title": "Reasoning about infinite computation paths", "author": ["WVS83. Pierre Wolper", "Moshe Y. Vardi", "A. Prasad Sistla"], "venue": "Foundations of Computer Science, Annual IEEE Symposium on", "citeRegEx": "Wolper et al\\.,? \\Q1983\\E", "shortCiteRegEx": "Wolper et al\\.", "year": 1983}], "referenceMentions": [], "year": 2013, "abstractText": "This paper relates the well-known formalism of Linear Temporal Logic [Pnu77] with the logic of propositional schemata introduced in [ACP09]. We prove that LTL is equivalent to a particular class of schemata in the sense that polynomial-time translation algorithms exist from one logic to the other. Some consequences about complexity are given. We report about first experiments and the consequences about possible improvements in existing implementations are analyzed.", "creator": "LaTeX with hyperref package"}}}