{"id": "1104.5362", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Apr-2011", "title": "Selected Operations, Algorithms, and Applications of n-Tape Weighted Finite-State Machines", "abstract": "A weighted integral - districts machine with width tapes (formula_5 - WFSM) defines just theory regardless take ar tuning. It is takes implies of seng busfield (up images) which separators (making reel-to-reel ).", "histories": [["v1", "Thu, 28 Apr 2011 11:44:33 GMT  (43kb)", "https://arxiv.org/abs/1104.5362v1", "15 pages, 7 figures, LaTeX (+ .eps)"], ["v2", "Fri, 29 Apr 2011 09:38:16 GMT  (42kb)", "http://arxiv.org/abs/1104.5362v2", "15 pages, 7 figures, LaTeX (+ .eps)"]], "COMMENTS": "15 pages, 7 figures, LaTeX (+ .eps)", "reviews": [], "SUBJECTS": "cs.FL cs.CL", "authors": ["andr\\'e kempe"], "accepted": false, "id": "1104.5362"}, "pdf": {"name": "1104.5362.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Andr\u00e9 Kempe"], "emails": ["a.kempe@free.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n10 4.\n53 62\nv2 [\ncs .F\nL ]\n2 9\nA pr"}, {"heading": "1 Introduction", "text": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings. It is a generalization of weighted acceptors (one tape) and transducers (two tapes).\nThis paper investigates the potential of n-ary rational relations (resp. nWFSMs) compared to languages and binary relations (resp. acceptors and transducers), in practical tasks. All described operations and applications have been implemented with Xerox\u2019s WFSC tool [17].\nThe paper is organized as follows: Section 2 recalls some basic definitions about n-ary weighted rational relations and n-WFSMs. Section 3 summarizes some central operations on these relations and machines, such as join and autointersection. Unfortunately, due to Post\u2019s Correspondence Problem, there cannot exist a fully general auto-intersection algorithm. Section 4 recalls a restricted algorithm for a class of n-WFSMs. Section 5 demonstrates the augmented descriptive power of n-WFSMs through a series of practical applications, namely the morphological analysis of Semitic languages (5.1), the preservation of intermediate results in transducer cascades (5.2), the induction of morphological rules from corpora (5.3), the alignment of lexicon entries (5.4), the automatic extraction of acronyms and their meaning from corpora (5.5), and the search for cognates in a bilingual lexicon (5.6).\n\u22c6 Sections 2\u20134 are based on published results [18,19,20,4], obtained at Xerox Research Centre Europe (XRCE), Meylan, France, through joint work between Jean-Marc Champarnaud (Rouen Univ.), Jason Eisner (Johns Hopkins Univ.), Franck Guingne and Florent Nicart (XRCE and Rouen Univ.), and the author."}, {"heading": "2 Definitions", "text": "We recall some definitions about n-ary weighted relations and their machines, following the usual definitions for multi-tape automata [7,6], with semiring weights added just as for acceptors and transducers [24,27]. For more details see [18].\nA weighted n-ary relation is a function from (\u03a3\u2217)n to K, for a given finite alphabet \u03a3 and a given weight semiring K = \u3008K,\u2295,\u2297, 0\u0304, 1\u0304\u3009. A relation assigns a weight to any n-tuple of strings. A weight of 0\u0304 can be interpreted as meaning that the tuple is not in the relation. We are especially interested in rational (or regular) n-ary relations, i.e. relations that can be encoded by n-tape weighted finite-state machines, that we now define.\nWe adopt the convention that variable names referring to n-tuples of strings include a superscript (n). Thus we write s(n) rather than \u2192 s for a tuple of strings \u3008s1, . . . sn\u3009. We also use this convention for the names of objects that contain n-tuples of strings, such as n-tape machines and their transitions and paths.\nAn n-tape weighted finite-state machine (n-WFSM) A(n) is defined by a sixtuple A(n) = \u3008\u03a3,Q,K, E(n), \u03bb, \u033a\u3009, with \u03a3 being a finite alphabet, Q a finite set of states, K=\u3008K,\u2295,\u2297, 0\u0304, 1\u0304\u3009 the semiring of weights, E(n)\u2286 (Q\u00d7 (\u03a3\u2217)n\u00d7K\u00d7Q) a finite set of weighted n-tape transitions, \u03bb : Q \u2192 K a function that assigns initial weights to states, and \u033a : Q \u2192 K a function that assigns final weights to states.\nAny transition e(n) \u2208 E(n) has the form e(n) = \u3008y, \u2113(n), w, t\u3009. We refer to these four components as the transition\u2019s source state y(e(n)) \u2208 Q, its label \u2113(e(n))\u2208 (\u03a3\u2217)n, its weight w(e(n))\u2208K, and its target state t(e(n))\u2208Q. We refer by E(q) to the set of out-going transitions of a state q\u2208Q (with E(q)\u2286E(n)).\nA path \u03b3(n) of length k \u2265 0 is a sequence of transitions e (n) 1 e (n) 2 \u00b7 \u00b7 \u00b7 e (n) k such\nthat t(e (n) i )=y(e (n) i+1) for all i\u2208 [1, k\u22121]. The label of a path is the element-wise concatenation of the labels of its transitions. The weight of a path \u03b3(n) is\nw(\u03b3(n)) =def \u03bb(y(e (n) 1 ))\u2297\n  \u2297\nj\u2208[1,k]\nw (\ne (n) j\n)\n\n\u2297 \u033a(t(e (n) k )) (1)\nThe path is said to be successful, and to accept its label, if w(\u03b3(n)) 6= 0\u0304."}, {"heading": "3 Operations", "text": "We now recall some central operations on n-ary weighted relations and n-WFSMs [21]. The auto-intersection operation was introduced, with the aim of simplifying the computation of the join operation. The notation is inspired by relational databases. For mathematical details of simple operations see [18]."}, {"heading": "3.1 Simple Operations", "text": "Any n-ary weighted rational relation can be constructed by combining the basic rational operations of union, concatenation and closure. Rational operations can\nbe implemented by simple constructions on the corresponding non-deterministic n-tape WFSMs [34]. These n-tape constructions and their semiring-weighted versions are exactly the same as for acceptors and transducers, since they are indifferent to the n-tuple transition labels.\nThe projection operator \u03c0\u3008j1,...jm\u3009, with j1, . . . jm \u2208 [1, n], maps an n-ary relation to an m-ary one by retaining in each tuple components specified by the indices j1, . . . jm and placing them in the specified order. Indices may occur in any order, possibly with repeats. Thus the tapes can be permuted or duplicated: \u03c0\u30082,1\u3009 inverts a 2-ary relation. The complementary projection operator \u03c0{j1,...jm} removes the tapes j1, . . . jm and preserves the order of other tapes."}, {"heading": "3.2 Join operation", "text": "The n-WFSM join operator differs from database join in that database columns are named, whereas our tapes are numbered. Since tapes must explicitly be selected by number, join is neither associative nor commutative.\nFor any distinct i1, . . . ir \u2208 [1, n] and any distinct j1, . . . jr \u2208 [1,m], we define a join operator \u2736{i1=j1,...ir=jr}. It combines an n-ary and an m-ary relation into an (n+m\u2212 r)-ary relation defined as follows:1\n(\nR (n) 1 \u2736{i1=j1,...ir=jr} R (m) 2\n)\n(\u3008u1, . . . un, s1, . . . sm\u2212r\u3009) =def R (n) 1 (u (n))\u2297R (m) 2 (v (m)) (2)\nv(m) being the unique tuple s. t. \u03c0{j1,...jr}(v (m)) = s(m\u2212r) and (\u2200k \u2208 [1, r]) vjk = uik .\nImportant special cases of join are crossproductR (n) 1 \u00d7R (m) 2 = R (n) 1 \u2736 6\u00a9 R (m) 2 ,\nintersection R (n) 1 \u2229R (n) 2 = R (n) 1 \u2736{1=1,...n=n} R (n) 2 , and transducer composition R (2) 1 \u25e6 R (2) 2 = \u03c0{2}(R (2) 1 \u2736{2=1} R (2) 2 ).\nUnfortunately, rational relations are not closed under arbitrary joins [18]. Since the join operation is very useful in practical applications (Sec. 5), it is helpful to have even a partial algorithm: hence our motivation for studying autointersection."}, {"heading": "3.3 Auto-Intersection", "text": "For any distinct i1, j1, . . . ir, jr \u2208 [1, n], we define an auto-intersection operator \u03c3{i1=j1,i2=j2,...ir=jr}. It maps a relation R (n) to a subset of that relation, preserving tuples s(n) whose elements are equal in pairs as specified, but removing other tuples from the support of the relation.2 The formal definition is:\n( \u03c3{i1=j1,...ir=jr}(R (n)) ) (\u3008s1, . . . sn\u3009) =def\n{\nR(n)(\u3008s1, . . . sn\u3009) if (\u2200k\u2208 [1, r])sik =sjk 0\u0304 otherwise (3)\n1 For example the tuples \u3008abc, def, \u01eb\u3009 and \u3008def, ghi, \u01eb, jkl\u3009 combine in the join \u2736{2=1,3=3} and yield the tuple \u3008abc, def, \u01eb, ghi, jkl\u3009, with a weight equal to the product of their weights. 2 The requirement that the 2r indices be distinct mirrors the similar requirement on join and is needed in (5). But it can be evaded by duplicating tapes: the illegal operation \u03c3{1=2,2=3}(R) can be computed as \u03c0{3}(\u03c3{1=2,3=4}(\u03c0\u30081,2,2,3\u3009(R))).\nIt is easy to check that auto-intersecting a relation is different from joining the relation with its own projections. Actually, join and auto-intersection are related by the following equalities:\nR (n) 1 \u2736{i1=j1,...ir=jr} R (m) 2 = \u03c0{n+j1,...n+jr}\n(\n\u03c3{i1=n+j1,...ir=n+jr}( R (n) 1 \u00d7R (m) 2 )\n)\n(4)\n\u03c3{i1=j1,...ir=jr}(R (n)) = R(n) \u2736{i1=1,j1=2,...ir=2r\u22121,jr=2r}\n\n (\u03c0\u30081,1\u3009(\u03a3 \u2217)\u00d7\u00b7 \u00b7 \u00b7\u00d7\u03c0\u30081,1\u3009(\u03a3 \u2217)\n\ufe38 \ufe37\ufe37 \ufe38\nr times\n\n  (5)\nThus, for any class of difficult join instances whose results are non-rational or have undecidable properties [18], there is a corresponding class of difficult auto-intersection instances, and vice-versa. Conversely, a partial solution to one problem would yield a partial solution to the other.\nAn auto-intersection on a single pair of tapes is said to be a single-pair one. An auto-intersection on multiple pairs of tapes can be defined in terms of multiple single-pair auto-intersections:\n\u03c3{i1=j1,...ir=jr}( R (n) ) =def \u03c3{ir=jr}( \u00b7 \u00b7 \u00b7\u03c3{i1=j1}( R (n) ) \u00b7 \u00b7 \u00b7 ) (6)"}, {"heading": "4 Compilation of Auto-Intersection", "text": "We now briefly recall a single-pair auto-intersection algorithm and the class of bounded delay auto-intersections that this algorithm can handle. For a detailed exposure see [19]."}, {"heading": "4.1 Post\u2019s Correspondence Problem", "text": "Unfortunately, auto-intersection (and hence join) can be reduced to Post\u2019s Correspondence Problem (PCP) [31]. Actually, any PCP instance can be represented as an unweighted 2-FSM, and the set of all solutions to the instance equals the auto-intersection of the 2-FSM [18].\nSince it can generally not be decided whether any solution exists to an arbitrary PCP instance, it is also undecidable whether the result of auto-intersection is empty. Therefore, no partial auto-intersection algorithm can be \u201ccomplete\u201d in the sense that it always returns a correct n-FSM if it is rational, and always terminates with an error code otherwise. Such an algorithm would make PCP generally decidable since a returned n-FSM can always be tested for emptiness, and an error code indicates non-rationality and hence non-emptiness."}, {"heading": "4.2 A class of rational auto-intersections", "text": "Although there cannot exist a fully general algorithm, A(n)=\u03c3{i=j}(A (n) 1 ) can be compiled for a class of triples \u3008A (n) 1 , i, j\u3009 whose definition is based on the notion of delay [8,26]. The delay \u03b4\u3008i,j\u3009(s (n)) is the difference of length of the strings si\nand sj of the tuple s (n) : \u03b4\u3008i,j\u3009(s (n)) = |si|\u2212|sj| (i, j\u2208 [1, n]). We call the delay bounded if its absolute value does not exceed some limit. The delay of a path \u03b3(n) results from its labels on tapes i and j: \u03b4\u3008i,j\u3009(\u03b3 (n)) = |(\u2113(\u03b3(n)))i|\u2212|(\u2113(\u03b3\n(n)))j |. A path has bounded delay if all its prefixes have bounded delay,3 and an nWFSM has bounded delay if all its successful paths have bounded delay.\nAs earlier reported [19], if an n-WFSM A (n) 1 does not contain a path traversing both a cycle with positive and a cycle with negative delay w.r.t. tapes i and j,4 then the delay of all paths of its auto-intersection A(n)=\u03c3{i=j}(A (n) 1 ) is bounded by some \u03b4max\u3008i,j\u3009, and this bound can be compiled from A (n) 1 ."}, {"heading": "4.3 An auto-intersection algorithm", "text": "Our algorithm for the above mentioned class of rational auto-intersections proceeds in three steps [19,20] :\n1. Test whether the triple \u3008A (n) 1 , i, j\u3009 fulfills the above conditions. If not, then the algorithm exits with an error code. 2. Calculation of the bound \u03b4max\u3008i,j\u3009 for the delay of the auto-intersection\nA(n)=\u03c3{i=j}(A (n) 1 ).\n3. Construction of the auto-intersection within the bound.\nFigure 1 illustrates step 3 of the algorithm: State 0, the initial state of A (3) 1 , is copied as initial state 10 to A(3). Its annotation, \u30080, \u3008\u03b5, \u03b5\u3009\u3009, indicates that it is a copy of state 0 and has leftover strings \u3008\u03b5, \u03b5\u3009. Then, all out-going transitions of state 0 and their target states are copied to A(3), as states 11 and 13. A transitions is copied with its original label and weight. The annotation of state 11\n3 Any finite path has bounded delay (since its label is of finite length). An infinite path (traversing cycles) may have bounded or unbounded delay. For example, the delay of a path labeled with (\u3008ab, \u03b5\u3009\u3008\u03b5, xz\u3009)h is bounded by 2 for any h, whereas that of a path labeled with \u3008ab, \u03b5\u3009h\u3008\u03b5, xz\u3009h is unbounded for h \u2212\u2192 \u221e. 4 Note that the n-WFSM may have cycles of both types, but not on the same path.\nindicates that it is a copy of state 0 and has leftover strings \u3008a, \u03b5\u3009. These leftover strings result from concatenating the leftover strings of state 10, \u3008\u03b5, \u03b5\u3009, with the relevant components, \u3008a, \u03b5\u3009, of the transition label a:\u03b5:x. For each newly created state q \u2208 QA, we access the corresponding state q1 \u2208 QA1 , and copy q1\u2019s outgoing transitions with their target states to A(3), until all states of A(3) have been processed.\nState 12 is not created because the delay of its leftover strings \u3008aa, \u03b5\u3009 exceeds the pre-calculated bound of \u03b4max\u30081,2\u3009 = 1. The longest common prefix of the two leftover strings of a state is removed. Hence state 14 has leftover strings \u3008\u03b5, \u03b5\u3009 instead of \u3008a, \u03b5\u3009\u3008\u03b5, a\u3009= \u3008a, a\u3009. A final state is copied with its original weight if it has leftover strings \u3008\u03b5, \u03b5\u3009, and with weight 0\u0304 otherwise. Therefore, state 14 is final and state 13 is not.\nThe construction is proven to be correct and to terminate [19,20]. It can be performed simultaneously on multiple pairs of tapes."}, {"heading": "5 Applications", "text": "This section focuses on demonstrating the augmented descriptive power n-WFSMs, w.r.t. to 1- and 2-WFSMs (acceptors and transducers), and on exposing the practical importance of the join operation. It also aims at illustrating how to use n-WFSMs, in practice. Indeed, some of the applications are not feasible with 1- and 2-WFSMs. The section does not focus on the presented applications per se."}, {"heading": "5.1 Morphological Analysis of Semitic Languages", "text": "n-WFSMs have been used in the morphological analysis of Semitic languages [14,22,23, e.g.].\nTable 1 by Kiraz [22] shows the \u201csynchronization\u201d of the quadruple s(4) = \u3008aa, ktb,waCVCVC,wakatab\u3009 in a 4-WFSM representing an Arabic morphological lexicon. Its first tape encodes a word\u2019s vowels, its second the consonants (representing the root), its third the affixes and the templatic pattern (defining how to combine consonants and vowels), and its fourth the word\u2019s surface form.\nAny of the tapes can be used for input or output. For example, for a given root and vowel sequence, we can obtain all existing surface forms and templates. For a given root and template, we can obtain all existing vowel sequences and surface forms, etc."}, {"heading": "5.2 Intermediate Results in Transduction Cascades", "text": "Transduction cascades have been extensively used in language and speech processing [1,29,25, e.g.].\nIn a classical weighted transduction cascade (Figure 2), consisting of trans-\nducers T (2) 1 . . . T (2) r , a weighted input language L (1) 0 , consisting of one or more words, is composed with the first transducer, T (2) 1 , on its input tape. The output projection of this composition is the first intermediate result, L (1) 1 . It is further composed with the second transducer, T (2) 2 , which leads to the second intermediate result, L (1) 2 , etc.. Generally, L (1) i = \u03c0\u30082\u3009(L (1) i\u22121 \u22c4T (2) i ) (i\u2208 [1, r]). The output projection of the last transducer is the final result, L (1) r .\nAt any point in the cascade, previous intermediate results cannot be accessed. This holds also if the cascade is composed into a single transducer: T (2) = T (2) 1 \u22c4 \u00b7 \u00b7 \u00b7 \u22c4 T (2) r . None of the \u201cincorporated\u201d sub-relations of T (2) can refer to a sub-relation other than its immediate predecessor.\nIn multi-tape transduction cascade, consisting of n-WFSMs A (n1) 1 . . . A (nr) r , any intermediate results can be preserved and used by subsequent transductions. Figure 3 shows an example where two previous results are preserved at each point, i.e., each intermediate result, L (2) i , has two tapes. The projection of the output tape of the last n-WFSM is the final result, L (1) r :\nL (2) 1 = L (1) 0 \u2736{1=1} A (2) 1 (7) L (2) i = \u03c0\u30082,3\u3009( L (2) i\u22121 \u2736{1=1,2=2} A (3) i ) (i\u2208 [2, r \u2212 1]) (8) L(1)r = \u03c0\u30083\u3009( L (2) r\u22121 \u2736{1=1,2=2} A (3) r ) (9)\nThis augmented descriptive power is also available if the whole cascade is joined into a single 2-WFSM, A(2), although A(2) has only two tapes (in this example), for input and output, respectively. A(2) can be iteratively constructed (Any B (m) i is the join of A (2) 1 to A (3) i ) :\nB (2) 1 = A (2) 1 (10) B (3) i = \u03c0\u30081,n\u22121,n\u3009( B (m) i\u22121 \u2736{n\u22121=1,n=2} A (3) i ) (i\u2208 [2, r] , m\u2208{2, 3}) (11) A(2) = \u03c0\u30081,n\u3009( Br ) (12)\nEach (except the first) of the \u201cincorporated\u201d multi-tape sub-relations in A(2) will still refer to its two predecessors."}, {"heading": "5.3 Induction of Morphological Rules", "text": "Induction of morphemes and morphological rules from corpora, both supervised and unsupervised, is a subfield of NLP on its own [3,9,5, e.g.]. We do not propose a new method for inducing rules, but rather demonstrate how known steps can be conveniently performed in the framework of n-ary relations.\nLearning morphological rules from a raw corpus can include, among others: (1) generating the least costly rule for a given word pair, that rewrites one word to the other, (2) identifying the set of pairs over all corpus words where a given rule applies, and (3) rewriting a given word by means of one or several rules.\nConstruction of a rule generator For any word pair, such as \u3008parler, parlons\u3009 (French, [to] speak, [we] speak), the generator shall provide a rule, such as \u201c.er:ons\u201d, suitable for rewriting the first to the second word at minimal cost. In a rule, a dot shall mean that one or more letters remain unmodified, and an x:y-part that substring x is replaced by substring y.\nWe begin with a 4-WFSM that defines rewrite operations:\nA (4) 1 = ( \u3008\u3008?, ?, . ,K\u3009{1=2}, 0\u3009 \u222a \u3008\u3008?, \u03b5, ?,D\u3009{1=3}, 0\u3009 \u222a \u3008\u3008\u03b5, ?, ?, I\u3009{2=3}, 0\u3009 \u222a \u3008\u3008\u03b5, \u03b5, : , S\u3009, 0\u3009 )\u2217 (13)\nwhere ? can be instantiated by any symbol, \u03b5 is the empty string, {i=j} a constraint requiring the ?\u2019s on tapes i and j to be instantiated by the same symbol [28],5 and 0 a weight over the tropical semiring.\nFigure 4 shows the graph of A (4) 1 and Figure 5 (rows 1\u20134) the purpose of its tapes: Tapes 1 and 2 accept any word pair, tape 3 generates a preliminary form of the rule, and tape 4 generates a sequence of preliminary operation codes. The following four cases can occur when A (4) 1 reads a word pair (cf. Eq. 13) :\n5 Deviating from [28], we denote symbol constraints similarly to join and autointersection constraints.\n\u03b5(?, ,?,D) {1=3} /0 {1=2} /0(?,?,.,K)\n( , ,:,S)\u03b5 \u03b5 /0 ( ,?,?,I)\u03b5 {2=3} /0\nFig. 4. Initial form A (4) 1 of the rule generator\nword 1 s w u m word 2 s w i m preliminary rule . . u m : i m preliminary op. codes K K D D S I I\nfinal rule . u m : i m final operation codes K k D d S I i\nweights 1 0 4 2 0 4 2\nFig. 5. Mapping from the word pair \u3008swum, swim\u3009 to various sequences\n1. \u3008?, ?, . ,K\u3009{1=2}: two identical letters are accepted, meaning a letter is kept from word 1 to word 2, which is represented by a \u201c.\u201d in the rule and K (keep) in the operation codes,\n2. \u3008?, \u03b5, ?,D\u3009{1=3}: a letter is deleted from word 1 to 2, expressed by this letter in the rule and D (delete) in the operation codes,\n3. \u3008\u03b5, ?, ?, I\u3009{2=3}: a letter is inserted from word 1 to 2, expressed by this letter in the rule and I (insert) in the operation codes\n4. \u3008\u03b5, \u03b5, : , S\u3009: no letter is matched in either word, a \u201c:\u201d is inserted in the rule, and a S (separator) in the operation codes.\nNext, we compile C (1) 1 that constrains the order of operation codes. For example, D must be followed by S, I must be preceded by S, etc. The constraints are enforced through join (Fig. 5 row 4) : A (4) 2 = A (4) 1 \u2736{4=1} C (1).\nThen, we create B (2) 1 that maps temporary rules to their final form by replacing a sequence of dots (longest match) by a single dot. We join B (2) 1 with the previous result (Fig. 5 rows 3, 5) : A (5) 3 = A (4) 2 \u2736{3=1} B (2) 1 .\nNext, we compile B (2) 2 that creates more fine-grained operation codes. In a sequence of equal capital letters, it replaces each but the first one with its small form. For example, DDD becomes Ddd. B (2) 1 is joined with the previous result (Fig. 5 rows 4, 6) : A (6) 4 = A (5) 3 \u2736{4=1} B (2) 2 .\nC (1) 1 , B (2) 1 , and B (2) 2 can be compiled as unweighted automata with a tool\nsuch as Xfst [13,2] and then be enhanced with neutral weights.\nFinally, we assigns weights to the fine-grained operation codes by joining\nB (1) 3 = (\u3008K, 1\u3009 \u222a \u3008k, 0\u3009 \u222a \u3008D, 4\u3009 \u222a \u3008d, 2\u3009 \u222a \u3008I, 4\u3009 \u222a \u3008i, 2\u3009 \u222a \u3008S, 0\u3009) \u2217 with the previous result (Fig. 5 rows 6, 7) : A (6) 5 = A (6) 4 \u2736{6=1} B (1) 3 .\nWe keep only the tapes of the word pair and of the final rule in the generator (Fig. 5 rows 1, 2, 5). All other tapes are of no further use:\nG(3) = \u03c0\u30081,2,5\u3009\n(\nA (6) 5\n)\n(14)\nThe rule generator G(3) maps any word pair to a finite number of rewrite rules with different weight, expressing the cost of edit operations. The optimal rule (with minimal weight) can be found through n-tape best-path search [16].\nUsing rewrite rules We suppose that the rules generated from random word pairs undergo some statistical selection process that aims at retaining only meaningful rules.\nTo facilitate the following operations, a rule\u2019s representation can be changed from a string, such as s(1)=\u201c.er:ons\u201d, to a 2-WFSM r(2) encoding the same relation. This is done by joining the rule with the generator: r(2) = \u03c0\u30081,2\u3009 ( G(3) \u2736{3=1} s (1) ) . An r(2) resulting from \u201c.er:ons\u201d, accepts (on tape 1) only words ending in \u201cer\u201d and changes (on tape 2) their suffix to \u201cons\u201d. Similarly, a 2-WFSM R(2) that encodes all selected rules can be generated by joining the set of all rules (represented as strings) S(1) with the generator: R(2) = \u03c0\u30081,2\u3009 ( G(3) \u2736{3=1} S (1) ) .\nTo find all pairs P (2) of words from a corpus where a particular rule applies, we compile the automaton W (1) of all corpus words, and compose it on both tapes of r(2) : P (2) = W (1) \u25e6 r(2) \u25e6 W (1). Similarly, identifying all word pairs P \u2032 (2) over the whole corpus where any of the rules applies (i.e., the set of \u201cvalid\u201d pairs) can be obtained through: P \u2032 (2) = W (1) \u25e6R(2) \u25e6W (1)\nRewriting a word w(1) with a single rule r(2) is done by w (1) 2 = \u03c0\u30082\u3009(w (1) 1 \u25e6 r (2))\nand w (1) 1 = \u03c0\u30081\u3009(r (2) \u25e6 w (1) 2 ). Similarly, rewriting a word w (1) with all selected rules is done by W (1) 2 = \u03c0\u30082\u3009(w (1) 1 \u25e6R (2)) and W (1) 1 = \u03c0\u30081\u3009(R (2) \u25e6 w (1) 2 )."}, {"heading": "5.4 String Alignment for Lexicon Construction", "text": "Suppose, we want to create a (non-weighted) transducer, D(2), from a list of word pairs s(2) of the form \u3008inflected form, lemma\u3009, e.g., \u3008swum, swim\u3009, such that each path of the transducer is labeled with one of the pairs. We want to use only transition labels of the form \u3008\u03c3, \u03c3\u3009, \u3008\u03c3, \u03b5\u3009, or \u3008\u03b5, \u03c3\u3009 (\u2200\u03c3 \u2208 \u03a3), while keeping paths as short as possible. For example, \u3008swum, swim\u3009 should be encoded either by the sequence \u3008s, s\u3009\u3008w,w\u3009\u3008u, \u03b5\u3009\u3008\u03b5, i\u3009\u3008m,m\u3009 or by \u3008s, s\u3009\u3008w,w\u3009\u3008\u03b5, i\u3009\u3008u, \u03b5\u3009\u3008m,m\u3009, rather than by the ill-formed \u3008s, s\u3009\u3008w,w\u3009\u3008u, i\u3009\u3008m,m\u3009, or the sub-optimal \u3008s, \u03b5\u3009\u3008w, \u03b5\u3009\u3008u, \u03b5\u3009\u3008m, \u03b5\u3009 \u3008\u03b5, s\u3009\u3008\u03b5,w\u3009\u3008\u03b5, i\u3009\u3008\u03b5,m\u3009.\nWe start with a 5-WFSM over the real tropical semiring [11] :\nA (5) 1 = ( \u3008\u3008?, ?, ?, ?,K\u3009{1=2=3=4}, 0\u3009 \u222a \u3008\u3008\u03b5, ?,@, ?, I\u3009{2=4}, 1\u3009 \u222a \u3008\u3008?, \u03b5, ?,@,D\u3009{1=3}, 1\u3009 )\u2217 (15)\nwhere @ is a special symbol representing \u03b5 in an alignment, {1=2=3=4} a constraint requiring the ?\u2019s on tapes 1 to 4 to be instantiated by the same symbol [28], and 0 and 1 are weights.\nFigure 6 shows the graph of A (5) 1 and Figure 7 (rows 1\u20135) the purpose of its tapes: Input word pairs s(2)= \u3008s1, s2\u3009 will be matched on tape 1 and 2, and aligned output word pairs generated from tape 3 and 4. A symbol pair \u3008?, ?\u3009\n\u03b5(?, ,?,@,D) {1=3} /1\n(?,?,?,?,K) {1=2=3=4} /0\n\u03b5( ,?,@,?,I) {2=3} /1\nFig. 6. Initial form A (5) 1 of a word pair aligner\ninput word 1 s w u m input word 2 s w i m output word 1 s w u @ m output word 2 s w @ i m operation codes K K D I K\nweights 0 0 1 1 0\nFig. 7. Alignment of the word pair \u3008swum, swim\u3009\nread on tape 1 and 2 is identically mapped to \u3008?, ?\u3009 on tape 3 and 4, a \u3008\u03b5, ?\u3009 is mapped to \u3008@, ?\u3009, and a \u3008?, \u03b5\u3009 to \u3008?,@\u3009. A (5) 1 will introduce @\u2019s in s1 (resp. in s2) at positions where D (2) shall have \u3008\u03b5, \u03c3\u3009- (resp. a \u3008\u03c3, \u03b5\u3009-) transitions.6 Tape 5 generates a sequence of operation codes: K (keep), D (delete), I (insert). For example, A (5) 1 will map \u3008swum, swim\u3009, among others, to \u3008swu@m, sw@im\u3009 with KKDIK and to \u3008sw@um, swi@m\u3009 with KKIDK. To remove redundant (duplicated) alignments, we prohibit an insertion to be immediately followed by a deletion, via the constraint: C(1) = (K \u222a I \u222aD)\u2217 \u2212 (?\u2217 I D ?\u2217). The constraint is imposed through join and the operations tape is removed:\nAligner(4) = \u03c0{5}\n(\nA (5) 1 \u2736{5=1} C\n(1) )\n(16)\nThe Aligner(4) will map \u3008swum, swim\u3009 among other still to \u3008swu@m, sw@im\u3009 but no to \u3008sw@um, swi@m\u3009. The best alignment (with minimal weight) can be found through n-tape best-path search [16]."}, {"heading": "5.5 Acronym and Meaning Extraction", "text": "The automatic extraction of acronyms and their meaning from corpora is an important sub-task of text mining, and received much attention [37,32,35, e.g.].\nIt can be seen as a special case of string alignment between a text chunk and an acronym. For example, the chunk \u201cthey have many hidden Markov models\u201d can be aligned with the acronym \u201cHMMs\u201d in different ways, such as \u201cthey have many hidden Markov models\u201d or \u201cthey have many hidden Markov models\u201d. Alternative alignments have different cost, and ideally the least costly one should give the correct meaning.\nAn alignment-based approach can be implemented by means of a 3-WFSM that reads a text chunk on tape 1 and an acronym on tape 2, and generates all possible alignments on tape 3, inserting dots to mark letters used in the acronym. For the above example this would give \u201cthey have many .hidden .Markov .model.s\u201d, among others.\n6 Later, we simply replace in D(2) all @ by \u03b5.\nThe 3-WFSM can be generated from n-ary regular expressions that define the task in as much detail as required (cf. Sec. 5.3 and 5.4). For a detailed description see [15]. The best alignment, i.e., the most likely meaning of an acronym is found through n-tape best-path search [16].\nThe advantage of aligning via a n-WFSM rather than a classical alignment matrix [36,30] is that the n-WFSM can be built from regular expressions that define very subtle criteria, such as disallowing certain alignments or favoring others based on weights that depend on long-distance context."}, {"heading": "5.6 Cognate Search", "text": "Extracting cognates with equal meaning from an English-German dictionary EG(3) that encodes triples \u3008English word,German word, part of speech\u3009, means to identify all paths of EG(3) that have similar strings on tapes 1 and 2. We create a similarity automaton S(2) that describes through weights the degree of similarity between English and German words. This can either be expressed through edit distance (cf. Sec. 5.3, 5.4, and 5.5) or through weighted synchronic grapheme correspondences (e.g.: d-t, ght-cht, th-d, th-ss, . . .) : S(2) = ( \u3008\u3008?, ?\u3009{1=2}, w0\u3009 \u222a \u3008\u3008d , t\u3009, w1\u3009 \u222a \u3008\u3008ght , cht\u3009, w2\u3009 \u222a . . . )\u2217 When recognizing an English-German word pair, S(2) accepts either any two equal symbols in the two words (via \u3008?, ?\u3009{1=2}) or some English sequence and its German correspondence (e.g. ght and cht) with some weight.\nThe set of cognates EG(3)cog is obtained by joining the dictionary with the\nsimilarity automaton: EG(3)cog = EG (3) \u2736{1=1,2=2} S (2) EG(3)cog contains all (and only) the cognates with equal meaning in EG (3) such as \u3008daughter, tochter, noun\u3009, \u3008eight, acht, num\u3009, or \u3008light, leicht, adj\u3009. Weighs of triples express similarity of words.\nNote that this result cannot be achieved through ordinary transducer composition. For example, composing S(2) with the English and the German words separately: \u03c0\u30081\u3009(EG (3)) \u22c4 S(2) \u22c4 \u03c0\u30082\u3009(EG (3)), also yields false cognates such as \u3008become, bekommen\u3009 ([to] obtain)."}, {"heading": "6 Conclusion", "text": "The paper recalled basic definitions about n-ary weighted relations and their nWFSMs, central operations on these relations and machines, and an algorithm for the important auto-intersection operation.\nIt investigated the potential of n-WFSMs, w.r.t. classical 1- and 2-WFSMs (acceptors and transducers), in practical tasks. Through a series of applications, it exposed their augmented descriptive power and the importance of the join operation. Some of the applications are not feasible with 1- or 2-WFSMs.\nIn the morphological analysis of Semitic languages, n-WFSMs have been used to synchronize the vowels, consonants, and templatic pattern into a surface form. In transduction cascades consisting of n-WFSMs, intermediate result can\nbe preserved and used by subsequent transductions. n-WFSMs permit not only to map strings to strings or string m-tuples to k-tuples, but m-ary to k-ary string relations, such as an non-aligned word pair to its aligned form, or to a rewrite rule suitable for mapping one word to the other. In string alignment tasks, an n-WFSM provides better control over the alignment process than a classical alignment matrix, since it can be compiled from regular expressions defining very subtle criteria, such as long-distance dependencies for weights."}], "references": [{"title": "Incremental finite-state parsing", "author": ["S. A\u0131\u0308t-Mokhtar", "J.-P. Chanod"], "venue": "In Proc. 5th Int. Conf. ANLP,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1997}, {"title": "Finite State Morphology", "author": ["K.R. Beesley", "L. Karttunen"], "venue": "CSLI Publications, Palo Alto, CA,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2003}, {"title": "An efficient, probabilistically sound algorithm for segmentation and word discovery", "author": ["M. Brent"], "venue": "Machine Learning, 34:71\u2013106,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1999}, {"title": "Algorithms for the join and auto-intersection of multi-tape weighted finite-state machines", "author": ["J.-M. Champarnaud", "F. Guingne", "A. Kempe", "F. Nicart"], "venue": "Int. Journal of Foundations of Computer Science, 19(2):453\u2013476,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "Unsupervised models for morpheme segmentation and morfology learning", "author": ["M. Creutz", "K. Lagus"], "venue": "ACM Transactions on Speech and Language Processing, 4(1),", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2007}, {"title": "Automata, Languages, and Machines, volume A", "author": ["S. Eilenberg"], "venue": "Academic Press, San Diego,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1974}, {"title": "On relations defined by generalized finite automata", "author": ["C.C. Elgot", "J.E. Mezei"], "venue": "IBM Journal of Research and Development, 9(1):47\u201368,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1965}, {"title": "Synchronized rational relations of finite and infinite words", "author": ["C. Frougny", "J. Sakarovitch"], "venue": "Theoretical Computer Science, 108(1):45\u201382,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1993}, {"title": "Unsupervised learning of the morphology of a natural language", "author": ["J. Goldsmith"], "venue": "Computational Linguistics, 27:153\u2013198,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2001}, {"title": "The equivalence problem of multitape finite automata", "author": ["T. Harju", "J. Karhum\u00e4ki"], "venue": "Theoretical Computer Science, 78(2):347\u2013355,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1991}, {"title": "Automatic string alignment for finite-state transducers", "author": ["P. Isabelle", "A. Kempe"], "venue": "Unpublished work,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2004}, {"title": "Regular models of phonological rule systems", "author": ["R.M. Kaplan", "M. Kay"], "venue": "Computational Linguistics, 20(3):331\u2013378,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1994}, {"title": "Xerox finite state complier", "author": ["L. Karttunen", "T. Ga\u00e1l", "A. Kempe"], "venue": "Online demo and documentation,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1998}, {"title": "Nonconcatenative finite-state morphology", "author": ["M. Kay"], "venue": "In Proc. 3rd Int. Conf. EACL, pages 2\u201310, Copenhagen, Denmark,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1987}, {"title": "Acronym-meaning extraction from corpora using multitape weighted finite-state machines", "author": ["A. Kempe"], "venue": "Research report 2006/019, Xerox Research Centre Europe, Meylan, France,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2006}, {"title": "Viterbi algorithm generalized for n-tape best-path search", "author": ["A. Kempe"], "venue": "In Proc. 8th Int. Workshop FSMNLP, Pretoria, South Africa,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "WFSC \u2013 A new weighted finite state compiler", "author": ["A. Kempe", "C. Baeijs", "T. Ga\u00e1l", "F. Guingne", "F. Nicart"], "venue": "In O.H. Ibarra and Z. Dang, editors, Proc. 8th Int. Conf. CIAA, volume 2759 of LNCS, pages 108\u2013119, Santa Barbara, CA, USA,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}, {"title": "A note on join and auto-intersection of n-ary rational relations", "author": ["A. Kempe", "J.-M. Champarnaud", "J. Eisner"], "venue": "In B. Watson and L. Cleophas, editors, Proc. Eindhoven FASTAR Days, number 04\u201340 in TU/e CS TR, pages 64\u201378, Eindhoven, Netherlands,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "A class of rational n-wfsm auto-intersections", "author": ["A. Kempe", "J.-M. Champarnaud", "J. Eisner", "F. Guingne", "F. Nicart"], "venue": "In J. Farr\u00e9, I. Litovski, and S. Schmitz, editors, Proc. 10th Int. Conf. CIAA, pages 266\u2013274, Sophia Antipolis, France,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "Wfsm autointersection and join algorithms", "author": ["A. Kempe", "J.-M. Champarnaud", "F. Guingne", "F. Nicart"], "venue": "In Proc. 5th Int. Workshop FSMNLP, Helsinki, Finland,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "Algorithms for weighted multi-tape automata", "author": ["A. Kempe", "F. Guingne", "F. Nicart"], "venue": "Research report 2004/031, Xerox Research Centre Europe, Meylan, France,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2004}, {"title": "Linearization of nonlinear lexical representations", "author": ["G.A. Kiraz"], "venue": "In J. Coleman, editor, Proc. 3rd ACL SIG Computational Phonology, Madrid, Spain,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1997}, {"title": "Multitiered nonlinear morphology using multitape finite automata: a case study on Syriac and Arabic", "author": ["G.A. Kiraz"], "venue": "Computational Lingistics, 26(1):77\u2013105, March", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2000}, {"title": "Semirings, Automata, Languages", "author": ["W. Kuich", "A. Salomaa"], "venue": "Number 5 in EATCS Monographs on Theoretical Computer Science. Springer Verlag, Berlin, Germany,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1986}, {"title": "A weighted finite state transducer implementation of the alignment template model for statistical machine translation", "author": ["S. Kumar", "W. Byrne"], "venue": "In Proc. Int. Conf. HLT-NAACL, pages 63\u201370, Edmonton, Canada,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2003}, {"title": "Edit-distance of weighted automata", "author": ["M. Mohri"], "venue": "In Proc. 7th Int. Conf. CIAA, volume 2608 of LNCS, pages 1\u201323, Tours, France,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2003}, {"title": "A rational design for a weighted finitestate transducer library", "author": ["M. Mohri", "F.C.N. Pereira", "M. Riley"], "venue": "LNCS, 1436:144\u2013158,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1998}, {"title": "Multi-tape automata with symbol classes", "author": ["F. Nicart", "J.-M. Champarnaud", "T. Cs\u00e1ki", "T. Ga\u00e1l", "A. Kempe"], "venue": "In O.H. Ibarra and H.-C. Yen, editors, Proc. 11th Int. Conf. CIAA, volume 4094 of LNCS, pages 126\u2013136, Taipei, Taiwan,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2006}, {"title": "Speech recognition by composition of weighted finite automata", "author": ["F.C.N. Pereira", "M.D. Riley"], "venue": "In E. Roche and Y. Schabes, editors, Finite-State Language Processing, pages 431\u2013453. MIT Press, Cambridge, MA, USA,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1997}, {"title": "Fuzzy translation of cross-lingual spelling variants", "author": ["A. Pirkola", "J. Toivonen", "H. Keskustalo", "K. Visala", "K. J\u00e4rvelin"], "venue": "In Proc. 26th Annual Int. ACM SIGIR, pages 345\u2013352, Toronto, Canada,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2003}, {"title": "A variant of a recursively unsolvable problem", "author": ["E. Post"], "venue": "Bulletin of the American Mathematical Society, 52:264\u2013268,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1946}, {"title": "no, B", "author": ["J. Pustejovsky", "J. Cast"], "venue": "Cochran, M. Kotecki, M. Morrell, and A. Rumshisky. Linguistic knowledge extraction from medline: Automatic construction of an acronym database. In Proc. 10th World Congress on Health and Medical Informatics (Medinfo 2001),", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2001}, {"title": "Finite automata and their decision problems", "author": ["M.O. Rabin", "D. Scott"], "venue": "IBM Journal of Research and Development, 3(2):114\u2013125,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 1959}, {"title": "On n-tape finite state acceptors", "author": ["A.L. Rosenberg"], "venue": "In IEEE Symposium on Foundations of Computer Science (FOCS), pages 76\u201381,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1964}, {"title": "A simple algorithm for identifying abbreviation definitions in biomedical texts", "author": ["A. Schwartz", "M. Hearst"], "venue": "In Proc. Pacific Symposium on Biocomputing (PSB2003),", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2003}, {"title": "The string-to-string correction problem", "author": ["R.A. Wagner", "M.J. Fischer"], "venue": "Journal of the Association for Computing Machinery, 21(1):168\u2013173,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 1974}, {"title": "Using compression to identify acronyms in text", "author": ["S. Yeates", "D. Bainbridge", "I.H. Witten"], "venue": "In Proc. Data Compression Conf. (DCC-2000), Snowbird, Utah, USA,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 32, "context": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings.", "startOffset": 54, "endOffset": 69}, {"referenceID": 6, "context": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings.", "startOffset": 54, "endOffset": 69}, {"referenceID": 13, "context": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings.", "startOffset": 54, "endOffset": 69}, {"referenceID": 9, "context": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings.", "startOffset": 54, "endOffset": 69}, {"referenceID": 11, "context": "A weighted finite-state machine with n tapes (n-WFSM) [33,7,14,10,12] defines a rational relation on n strings.", "startOffset": 54, "endOffset": 69}, {"referenceID": 16, "context": "All described operations and applications have been implemented with Xerox\u2019s WFSC tool [17].", "startOffset": 87, "endOffset": 91}, {"referenceID": 17, "context": "\u22c6 Sections 2\u20134 are based on published results [18,19,20,4], obtained at Xerox Research Centre Europe (XRCE), Meylan, France, through joint work between Jean-Marc Champarnaud (Rouen Univ.", "startOffset": 46, "endOffset": 58}, {"referenceID": 18, "context": "\u22c6 Sections 2\u20134 are based on published results [18,19,20,4], obtained at Xerox Research Centre Europe (XRCE), Meylan, France, through joint work between Jean-Marc Champarnaud (Rouen Univ.", "startOffset": 46, "endOffset": 58}, {"referenceID": 19, "context": "\u22c6 Sections 2\u20134 are based on published results [18,19,20,4], obtained at Xerox Research Centre Europe (XRCE), Meylan, France, through joint work between Jean-Marc Champarnaud (Rouen Univ.", "startOffset": 46, "endOffset": 58}, {"referenceID": 3, "context": "\u22c6 Sections 2\u20134 are based on published results [18,19,20,4], obtained at Xerox Research Centre Europe (XRCE), Meylan, France, through joint work between Jean-Marc Champarnaud (Rouen Univ.", "startOffset": 46, "endOffset": 58}, {"referenceID": 6, "context": "We recall some definitions about n-ary weighted relations and their machines, following the usual definitions for multi-tape automata [7,6], with semiring weights added just as for acceptors and transducers [24,27].", "startOffset": 134, "endOffset": 139}, {"referenceID": 5, "context": "We recall some definitions about n-ary weighted relations and their machines, following the usual definitions for multi-tape automata [7,6], with semiring weights added just as for acceptors and transducers [24,27].", "startOffset": 134, "endOffset": 139}, {"referenceID": 23, "context": "We recall some definitions about n-ary weighted relations and their machines, following the usual definitions for multi-tape automata [7,6], with semiring weights added just as for acceptors and transducers [24,27].", "startOffset": 207, "endOffset": 214}, {"referenceID": 26, "context": "We recall some definitions about n-ary weighted relations and their machines, following the usual definitions for multi-tape automata [7,6], with semiring weights added just as for acceptors and transducers [24,27].", "startOffset": 207, "endOffset": 214}, {"referenceID": 17, "context": "For more details see [18].", "startOffset": 21, "endOffset": 25}, {"referenceID": 20, "context": "We now recall some central operations on n-ary weighted relations and n-WFSMs [21].", "startOffset": 78, "endOffset": 82}, {"referenceID": 17, "context": "For mathematical details of simple operations see [18].", "startOffset": 50, "endOffset": 54}, {"referenceID": 33, "context": "be implemented by simple constructions on the corresponding non-deterministic n-tape WFSMs [34].", "startOffset": 91, "endOffset": 95}, {"referenceID": 17, "context": "Unfortunately, rational relations are not closed under arbitrary joins [18].", "startOffset": 71, "endOffset": 75}, {"referenceID": 17, "context": "Thus, for any class of difficult join instances whose results are non-rational or have undecidable properties [18], there is a corresponding class of difficult auto-intersection instances, and vice-versa.", "startOffset": 110, "endOffset": 114}, {"referenceID": 18, "context": "For a detailed exposure see [19].", "startOffset": 28, "endOffset": 32}, {"referenceID": 30, "context": "Unfortunately, auto-intersection (and hence join) can be reduced to Post\u2019s Correspondence Problem (PCP) [31].", "startOffset": 104, "endOffset": 108}, {"referenceID": 17, "context": "Actually, any PCP instance can be represented as an unweighted 2-FSM, and the set of all solutions to the instance equals the auto-intersection of the 2-FSM [18].", "startOffset": 157, "endOffset": 161}, {"referenceID": 7, "context": "Although there cannot exist a fully general algorithm, A=\u03c3{i=j}(A (n) 1 ) can be compiled for a class of triples \u3008A (n) 1 , i, j\u3009 whose definition is based on the notion of delay [8,26].", "startOffset": 179, "endOffset": 185}, {"referenceID": 25, "context": "Although there cannot exist a fully general algorithm, A=\u03c3{i=j}(A (n) 1 ) can be compiled for a class of triples \u3008A (n) 1 , i, j\u3009 whose definition is based on the notion of delay [8,26].", "startOffset": 179, "endOffset": 185}, {"referenceID": 18, "context": "As earlier reported [19], if an n-WFSM A (n) 1 does not contain a path traversing both a cycle with positive and a cycle with negative delay w.", "startOffset": 20, "endOffset": 24}, {"referenceID": 18, "context": "Our algorithm for the above mentioned class of rational auto-intersections proceeds in three steps [19,20] :", "startOffset": 99, "endOffset": 106}, {"referenceID": 19, "context": "Our algorithm for the above mentioned class of rational auto-intersections proceeds in three steps [19,20] :", "startOffset": 99, "endOffset": 106}, {"referenceID": 18, "context": "The construction is proven to be correct and to terminate [19,20].", "startOffset": 58, "endOffset": 65}, {"referenceID": 19, "context": "The construction is proven to be correct and to terminate [19,20].", "startOffset": 58, "endOffset": 65}, {"referenceID": 21, "context": "Table 1 by Kiraz [22] shows the \u201csynchronization\u201d of the quadruple s = \u3008aa, ktb,waCVCVC,wakatab\u3009 in a 4-WFSM representing an Arabic morphological lexicon.", "startOffset": 17, "endOffset": 21}, {"referenceID": 21, "context": "Multi-tape-based morphological anaysis of Arabic; table adapted from Kiraz [22]", "startOffset": 75, "endOffset": 79}, {"referenceID": 27, "context": "where ? can be instantiated by any symbol, \u03b5 is the empty string, {i=j} a constraint requiring the ?\u2019s on tapes i and j to be instantiated by the same symbol [28], and 0 a weight over the tropical semiring.", "startOffset": 158, "endOffset": 162}, {"referenceID": 27, "context": "5 Deviating from [28], we denote symbol constraints similarly to join and autointersection constraints.", "startOffset": 17, "endOffset": 21}, {"referenceID": 12, "context": "C (1) 1 , B (2) 1 , and B (2) 2 can be compiled as unweighted automata with a tool such as Xfst [13,2] and then be enhanced with neutral weights.", "startOffset": 96, "endOffset": 102}, {"referenceID": 1, "context": "C (1) 1 , B (2) 1 , and B (2) 2 can be compiled as unweighted automata with a tool such as Xfst [13,2] and then be enhanced with neutral weights.", "startOffset": 96, "endOffset": 102}, {"referenceID": 15, "context": "The optimal rule (with minimal weight) can be found through n-tape best-path search [16].", "startOffset": 84, "endOffset": 88}, {"referenceID": 10, "context": "We start with a 5-WFSM over the real tropical semiring [11] :", "startOffset": 55, "endOffset": 59}, {"referenceID": 27, "context": "where @ is a special symbol representing \u03b5 in an alignment, {1=2=3=4} a constraint requiring the ?\u2019s on tapes 1 to 4 to be instantiated by the same symbol [28], and 0 and 1 are weights.", "startOffset": 155, "endOffset": 159}, {"referenceID": 15, "context": "The best alignment (with minimal weight) can be found through n-tape best-path search [16].", "startOffset": 86, "endOffset": 90}, {"referenceID": 14, "context": "For a detailed description see [15].", "startOffset": 31, "endOffset": 35}, {"referenceID": 15, "context": ", the most likely meaning of an acronym is found through n-tape best-path search [16].", "startOffset": 81, "endOffset": 85}, {"referenceID": 35, "context": "The advantage of aligning via a n-WFSM rather than a classical alignment matrix [36,30] is that the n-WFSM can be built from regular expressions that define very subtle criteria, such as disallowing certain alignments or favoring others based on weights that depend on long-distance context.", "startOffset": 80, "endOffset": 87}, {"referenceID": 29, "context": "The advantage of aligning via a n-WFSM rather than a classical alignment matrix [36,30] is that the n-WFSM can be built from regular expressions that define very subtle criteria, such as disallowing certain alignments or favoring others based on weights that depend on long-distance context.", "startOffset": 80, "endOffset": 87}], "year": 2017, "abstractText": "A weighted finite-state machine with n tapes (n-WFSM) defines a rational relation on n strings. The paper recalls important operations on these relations, and an algorithm for their auto-intersection. Through a series of practical applications, it investigates the augmented descriptive power of n-WFSMs, w.r.t. classical 1and 2-WFSMs (acceptors and transducers). Some applications are not feasible with the latter.", "creator": "LaTeX with hyperref package"}}}