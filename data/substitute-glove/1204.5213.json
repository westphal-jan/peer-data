{"id": "1204.5213", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Apr-2012", "title": "Solving Weighted Voting Game Design Problems Optimally: Representations, Synthesis, and Enumeration", "abstract": "We study instead formula_3 over ordinaries comes for barrel referendum games: the possible of beyond way weighted voting game been addition called power of the players is as key that not to as certain target advertising. Our fifth is also them measurement that things this whether necessarily. Thereto, anyone review well subclasses well context games, and coming widely representation therapeutic. We reuters templates and subjectivity comparison for it synthesis reasons, i. e. , converting with constituencies common kind make game off taken representation.", "histories": [["v1", "Mon, 23 Apr 2012 21:35:00 GMT  (127kb,D)", "https://arxiv.org/abs/1204.5213v1", null], ["v2", "Tue, 5 Jun 2012 14:57:18 GMT  (127kb,D)", "http://arxiv.org/abs/1204.5213v2", null], ["v3", "Mon, 1 Jul 2013 11:58:03 GMT  (132kb,D)", "http://arxiv.org/abs/1204.5213v3", null]], "reviews": [], "SUBJECTS": "cs.GT cs.AI cs.MA", "authors": ["bart de keijzer", "tomas b klos", "yingqian zhang"], "accepted": false, "id": "1204.5213"}, "pdf": {"name": "1204.5213.pdf", "metadata": {"source": "CRF", "title": "Solving Weighted Voting Game Design Problems Optimally: Representations, Synthesis, and Enumeration", "authors": ["Bart de Keijzer", "Tomas B. Klos", "Yingqian Zhang"], "emails": ["keijzer@cwi.nl.", "T.B.Klos@tudelft.nl.", "yqzhang@ese.eur.nl"], "sections": [{"heading": null, "text": "We contribute to the synthesis problem by showing that it is impossible to compute in polynomial time the list of ceiling coalitions (also known as shift-maximal losing coalitions) of a game from its list of roof coalitions (also known as shift-minimal winning coalitions), and vice versa.\nThen, we proceed by studying the problem of enumerating the set of weighted voting games. We present first a naive algorithm for this, running in doubly exponential time. Using our knowledge of the synthesis problem, we then improve on this naive algorithm, and we obtain an enumeration algorithm that runs in quadratic exponential time (that is, O(2n 2\n\u00b7 p(n)) for a polynomial p). Moreover, we show that this algorithm runs in output-polynomial time, making it the best possible enumeration algorithm up to a polynomial factor.\nFinally, we propose an exact anytime algorithm for the power index voting game design problem that runs in exponential time. This algorithm is straightforward and general: it computes the error for each game enumerated, and outputs the game that minimizes this error. By the genericity of our approach, our algorithm can be used to find a weighted voting game that optimizes any exponential time computable function. We implement our algorithm for the case of the normalized Banzhaf in-\n\u2217Algorithms, Combinatorics and Optimization; Centrum Wiskunde & Informatica; The Netherlands; Email: keijzer@cwi.nl. \u2020Algorithmics; Delft University of Technology; The Netherlands; Email: T.B.Klos@tudelft.nl. \u2021Department of Econometrics; Erasmus University Rotterdam; The Netherlands; Email: yqzhang@ese.eur.nl\nar X\niv :1\n20 4.\n52 13\nv3 [\ncs .G\nT ]\n1 J\ndex, and we perform experiments in order to study performance and error convergence."}, {"heading": "1 Introduction", "text": "In many real-world problems that involve multiple agents, for instance elections, there is a need for fair decision making protocols in which different agents have different amounts of influence in the outcome of a decision. Weighted voting games are often used in these decision making protocols. In a weighted voting game, a quota is given, and each agent (or also: player) in the game has a certain weight. If the total weight of a coalition of agents exceeds the quota, then that coalition is said to be winning, and losing otherwise.\nWeighted voting games arise in various settings, such as political decision making (decision making among larger and smaller political parties), stockholder companies (where people with different numbers of shares are supposed to have a different amount of influence), and elections (e.g., in the US Presidential Election, where each state can be regarded as a player who has a weight equal to its number of electors).\nThe weight that a player has in a weighted voting game turns out not to be equal to his actual influence on the outcome of the decisions that are made using the weighted voting game. Consider for example a weighted voting game in which the quota is equal to the sum of the weights of all players. In such a game, a player\u2019s influence is equal to the influence of any other player, no matter what weight he has. Throughout the literature, various power indices have been proposed: ways to measure a player\u2019s influence (or (a priori) power) in a voting game. However, computing a power index turns out to be a challenge in many cases.\nIn this paper, instead of analyzing the power of each agent in a voting game, we investigate the problem that has been referred to as the \u201cinverse problem\u201d and the \u201cgeneralized apportionment problem\u201d. We will call this problem the power index voting game design problem. In the power index voting game design problem we are given a target power index for each of the agents, and we study how to design a weighted voting game for which the power of each agent is as close as possible to the given target power index. The power index voting game design problem is an instantiation of a larger class of problems that we will call voting game design problems, in which the goal is to find a game G in a class of voting games such that G has a given set of target properties. citeazizinverse, who propose an algorithm to find a WVG for the Banzhaf index.\nThe practical motivation behind our work is obvious: It is desirable to have an algorithm that can quickly compute a fair voting protocol, given that we want each agent to have some specified amount of influence in the outcome. When new decision making bodies must be formed, or when changes occur in the formation of these bodies, such an algorithm may be used to design a voting method that is as fair as possible. Only little work is known that tries to solve this problem. Two of the proposed algorithms (see [20, 5]) are local search\nmethods that do not guarantee an optimal answer. There is one other paper by Kurz [39] that proposes a method for finding an exact algorithm. Such an algorithm to solve the inverse problem exactly is also the topic of this paper: We are interested in finding a game for which the power index of that game is the closest possible to a certain target power index. The work we present here is independent from [39], and differs from it in the sense that we put more emphasis on run-time analysis and giving proofs of various desirable properties of our algorithm. Moreover, our approach is vastly different from the approach of [39], and the theory behind our algorithm is of independent interest.\nIt seems that the most straightforward approach to solve the inverse problem would be to simply enumerate all possible weighted voting games of n players, and to compute for each of these weighted voting games its power index. We can then output the game of which the power index is the closest to the given target power index. This is precisely what we will do in this paper. Unfortunately, it turns out that enumerating all weighted voting games efficiently is not so straightforward.\nThe enumeration method that we present in this paper leads to a generic exponential time exact anytime algorithm for solving voting game design problems. We implemented our algorithm for the power index voting game design problem where our power index of choice is the (normalized) Banzhaf index : one of the two most widely used power indices. Using this implementation, we experimentally study the runtime and error convergence of this algorithm."}, {"heading": "1.1 Contributions", "text": "This paper is based on the master\u2019s thesis of De Keijzer [13]; one of the authors of this manuscript. A shorter discussion of this work has also appeared [14]. We present and discuss the results of [13], and remove various redundancies, imprecisions, typos, and mistakes that were present in [13]. The results we present are thus as follows:\n\u2022 We provide a general definition of voting game design problems, and show how the power index voting game design problem is one of these problems.\n\u2022 We present lower and upper bounds on the cardinalities of various classes of games. As it turns out, for many of these classes there is a very strong connection with certain classes of boolean functions; allowing us to borrow many bounds directly from boolean function theory.\n\u2022 We investigate thoroughly the problem of transforming various representations for simple games into each other. We give an overview of known results, and we present a new result: We prove that it is not possible to transform within polynomial time the roof-representation of a game into a ceiling-representation, and vice versa.1\n1The roof-representation is also known as the shift-minimal winning coalition representation [66]. Likewise, the ceiling representation is also known as the shift-minimal losing coalition representation.\n\u2022 We present exact algorithms for solving power index voting game design problems: first, a doubly exponential one for the large class of monotonic simple games; and subsequently we show that it is possible to obtain a (singly) exponential algorithm for the important special case of weighted voting games. This can be regarded as the main result of this paper.\n\u2013 At the core of these algorithms lie methods for enumerating classes of games. Therefore, it actually follows that the same approach can be used for solving practically any voting game design problem.\n\u2013 The method that we use for enumerating weighted voting games is based on a new partial order on the class of weighted voting games, that has some specific interesting properties. This result is of independent interest from a mathematical point of view.\n\u2022 The algorithm for solving the power index voting game design problem for the case of weighted voting games (mentioned in the previous point) is based on working with families of minimal winning coalitions. We show how it is possible to improve the runtime of this algorithm by showing that it suffices to only work with a subset of these minimal winning coalitions: The roof coalitions. Using this idea, we provide various techniques to improve our algorithm. Among these improvements is an output-polynomial time algorithm for outputting the list of ceiling coalitions of a linear game, given the list of roof coalitions.\n\u2022 Finally, we implement the aforementioned enumeration algorithm for weighted voting games, in order to measure its performance, obtain some interesting data about the class of weighted voting games, and validate some theoretical results related to weighted voting games."}, {"heading": "1.2 Related work", "text": "Although some specific variants of voting game design problems are mentioned sporadically in the literature, not many serious attempts to solve these problems are known to us. The voting game design problem that is usually studied is that of finding a weighted voting game, represented as a weight vector, for which the power index lies as close as possible to a given target power index. This specific version of the voting game design problem is sometimes referred to as the inverse problem, and is also the focus of this paper.\nWe know of only a few papers where the authors propose algorithms for the inverse problem. One of them is by Fatima et al. [20], where the authors present an algorithm for the inverse problem with the Shapley-Shubik index [60] as the power index of choice. This algorithm works essentially as follows: It first receives as input a target Shapley-Shubik index and a vector of initial weights. After that, the algorithm enters an infinite loop where repeatedly the Shapley-Shubik index is computed, and the weight vector is updated according to some rule. The Shapley-Shubik index is computed using a linear time randomized approximation algorithm, proposed in [19, 21] by the same authors.\nFor updating the weights, the authors propose two different rules of which they prove that by applying them, the Shapley-Shubik index of each player cannot get worse. Hence, the proposed algorithm is an anytime algorithm: it can be terminated at any time, but gets closer to the optimal answer the longer the algorithm runs. No analysis on the approximation error is done, although the authors mention in a footnote that analysis will be done in future work. The runtime of one iteration of the algorithm is shown to be O(n2) (where n denotes the number of players).\nAnother algorithm is by Aziz et al. [5] for the inverse problem with the Banzhaf index as the power index of choice. The algorithm the authors present here resembles that of [20], in that the algorithm repeatedly updates the weight vector in order to get closer to the target power index. The algorithm gets as input a target Banzhaf index. As an initial step, an integer weight vector is estimated according to a normal distribution approximation. Subsequently, the algorithm enters an infinite loop, and consecutively computes the Banzhaf index and updates the weight. For computing the Banzhaf index, the generating function method is used [9, 47, 10]. This is an exact pseudopolynomial time method that works only when the weights in the weighted representation of a game are integers. Therefore, the output of the algorithm is always an integer weighted representation (contrary to the method in [20] for which the output may have rational weights). The updating is done by interpolating a best fit curve. This results in a rational weight vector. To obtain integer weights, the weight vector is rounded to integers, but prior to that it is multiplied by a suitable constant that reduces the error when rounding to integers.\nFor Aziz\u2019s approach, there is no approximation guarantee and the convergence rate is unknown, so it is not certain whether this method is anytime just like Fatima\u2019s algorithm. Moreover, not much is known about the time complexity and practical performance of this algorithm (one example is presented of this algorithm working on a specific input).\nLeech proposes in [41, 45] an approach that largely resembles the method of Aziz et al.: it is the same, with the exception that a different updating rule is used. The method that Leech uses for computing the Banzhaf index is not mentioned. The focus in this paper is on the results that are obtained after applying the method to the 15-member EU council (also see [42]), and to the board of governors of the International Monetary Fund.\nThere are two more recent interesting works on the voting game design problem. One is by Kurz [39]. Kurz proposes an exact method using integer linear programming, for solving the weighted voting game design problem for both the Shapley-Shubik index and the Banzhaf index. The set of linear games is taken as the search space, and branch-and-bound techniques (along with various insights about the set of weighted voting games) are used in order to find in this set a weighted voting game with a power index closest to the target. Kurz does not provide a runtime analysis. The experiments performed show that the algorithm works well for small numbers of players. As mentioned in Section 1, our work is independent and differs from [39] because we are interested in devising an algorithm with a provably good runtime. Moreover, the approach\nwe take is different from that of [39], and the theory necessary to develop our algorithm can be considered interesting in itself.\nKurz moreover correctly points out that in the master\u2019s thesis of De Keijzer [13] (on which the present paper is based) the numbers of canonical weighted voting games for 6, 7, and 8 players are wrongly stated. After investigation on our part, it turned out that this is due to a bug in the first implementation of the algorithm. In this paper, we correct this mistake and report the numbers of canonical weighted voting games correctly, although these numbers are already known by now due to the recent paper [38], also by Kurz (see below).\nThe other recent work is [12], by De et al. This paper gives provides as a main result an algorithm for the inverse power index problem for the case of the Shapley-Shubik index, and has a certain approximation guarantee: in addition to a target power index, the algorithm takes a precision parameter and guarantees to output a weighted voting game of which the power index is -close to it, on the precondition that there exists an -close weighted voting game with the property that the quota is not too skewed, in a particular sense. This is, to our knowledge, the only polynomial time algorithm for a power index voting game design problem that provides an approximation guarantee in any sense.\nClosely related to our work are two papers that deal with the Chow parameters problem [54, 11]. The results in their paper are stated in terms of boolean function theory and learning theory, but when translated to our setting, these papers can be seen to deal with approximation algorithms for a type of value that can be considered a power index: The Chow parameters of a given player in a given game is defined to be the total number of winning coalitions that the players is in. The authors present in these papers, as a main result, a polynomial time approximation scheme for computing the Chow parameters of a weighted voting game.\nThe problem of enumerating the set of weighted voting games on a fixed number of players is, as we will see, closely related to the approach that we take for solving the weighted voting game design problem. This enumeration problem has been studied before in a paper by Kurz [38], where the author uses integer programming techniques in order to enumerate all canonical weighted voting games on up to nine players. The author generates integer weighted representations for all of these games and classifies the games that do not have a unique minimum-sum integer weighted representation.\nIn [37], Krohn and Sudho\u0308lter study the enumeration of canonical linear games and a subclass thereof, using various order theoretic concepts. It does not directly address the problem of enumerating weighted voting games, although it discusses a correspondence between the n-player proper weighted voting games and the (n + 1)-player decisive weighted canonical linear games.2 Because the class of canonical linear games is much bigger than the class of weighted voting games, their algorithms do not imply an efficient enumeration procedure for\n2A game is called proper if the complement of any winning coalition is losing. A game is called decisive if it is proper and the complement of any losing coalition is winning.\nweighted voting games, as is one of our main contributions in the present work. However, there are some connections between our work and [37]: their enumeration procedures work by exploiting graded posets, just like ours; although the posets in question there are the subsets winning coalitions together with the set inclusion relation (for the case of decisive canonical linear games, they use a variant of this poset), and not on the subsets of minimal winning coalitions. Although their idea of using a graded poset corresponds with ours, it seems to us that our results cannot be connected to theirs in a stronger sense. Moreover, the proofs of the properties that we establish for the partially ordered set we propose here, use vastly different ideas, and crucially exploit weightedness.\nThreshold functions [30, 50] are of fundamental research interest in voting games, circuit complexity and neural networks. The problem of realizing Boolean threshold functions by neural networks has been extensively studied [55, 61, 29], where upper and lower bounds are derived on the synaptic weights for such realization. The enumeration of threshold functions is closely related to the enumeration of weighted voting games (as threshold functions are essentially weighted voting games where negative weights are allowed.). The enumeration of threshold functions up to six variables has been done in [51]. Subsequently, in [68, 52], all threshold functions of respectively seven and eight variables were enumerated. Krohn and Sudho\u0308lter [37] enumerated the canonical weighted voting games up to eight players, as well as the class of canonical linear games. Kurz [38] was the first to enumerate all nine player canonical weighted voting games, and Freixas and Molinero [26] were the first to enumerate all nine player canonical linear games.\nThere exists some litature on enumeration of special subclasses of voting games as well: see [28] for linear games with two desirability classes; [24] for weighted voting games with one roof; and [25] for linear games with certain special types of voters and few desirability classes.\nAlon and Edelman observe that we need to know a priori estimates of what power indices are achievable in simple games, in order to analyze the accuracy of these kinds of iterative algorithms, i.e., there is a need for information about the distribution of power indices in [0, 1]n. As a first step into solving this problem, they prove in [2] a specific result for the case of the Banzhaf index for monotonic simple games.\nAlso, some applied work has been done on the design of voting games. In two papers, one by Laruelle and Widgre\u0301n [40] and one by Sutter [65], the distribution of voting power in the European Union is analyzed and designed using iterative methods that resemble the algorithm of Aziz [5]. Similar work was done by Leech for the EU [42], and for the IMF [43].\nFinally, a research direction that is related to our problem is that of studying minimal integer representation for a weighted voting game: Bounds on the maximum weight in such a representation provide us with a finite set of weighted representations to search through, as a means of solving our design problem. We explain this in greater detail in the next section. Some classical relevant bounds can be found in [50], Section 9.3. See [23, 26] for some recent work in this direction."}, {"heading": "1.3 Outline", "text": "The paper is divided into seven sections. Section 2 introduces the required preliminary knowledge and defines some novel concepts. In particular it introduces cooperative games, with an emphasis on simple games (since our paper deals exclusively with simple games). We will also explain the notion of a power index, because a great part of what motivates the results of this paper has to do with a problem related to power indices. We give a definition of one of the most popular power indices (the Banzhaf index), and we briefly discuss algorithms for computing them, as well as the computational complexity of this problem.\nWe define in Section 3 the main problem of interest that we attempt to solve in this paper: the problem where we are given a target power index, and where we must find a game such that its power index is as close as possible to the given target power index. We explain that this specific problem is part of a more general family of problems that we call voting game design problems.\nBefore directly trying to solve the problem introduced in Section 3, we first discuss in Section 4 the problem of transforming various representations of games into each other. We give polynomial time algorithms for some of these problems, and also in some cases impossibility results regarding the existence of polynomial time algorithms. Also, in this section, we make some statements about the cardinality of certain classes of simple games.\nSome of the results given in Section 4 are necessary for Section 5, where we devise exact algorithms for the power index voting game design problem (our main problem of interest). We first explain a naive approach for the class of monotonic simple games, and after that, improve on this exponentially for the subclass of weighted voting games. We show how this improvement is possible by the existence of a certain partial order with some specific desirable properties. Next, we give various improvements to this algorithm by making use of the concepts of roof and ceiling coalitions.\nAfter that, in Section 6 we will show various experimental results of a simple implementation of this exact algorithm. Because we can also use these algorithms as enumeration algorithms, we are able to provide some exact information about voting games, such as how many weighted voting games with a fixed number of minimal winning coalitions exist.\nWe conclude this paper in Section 7, with a discussion and some ideas for future work."}, {"heading": "2 Preliminaries", "text": "In this section, we will discuss some required preliminary definitions and results. Throughout this paper, we assume familiarity with big-O notation and analysis of algorithms. In some parts of this paper, some basic knowledge of computational complexity theory is assumed as well, although these parts are not crucial for understanding the main results presented. We will not cover these topics in\nthis section. We use some order-theoretic notions throughout various sections of the paper. These are given in the following definition.\nDefinition 1 (Partial order, (graded) poset, cover, rank function, least element). For a set S, a partial order is a relation on S that is reflexive, so \u2200x \u2208 S : x x; antisymmetric, so \u2200x, y \u2208 S : ((x y \u2227 y x) \u2192 x = y); and transitive, so \u2200x, y, z \u2208 S : ((x y \u2227 y z) \u2192 x z). A partially ordered set or poset is a set S equipped with a partial order , i.e., a pair (S, ). A least element of a poset (S, ) is an element x \u2208 S such that x y for all y \u2208 S. A minimal element of (S, ) is an element x \u2208 S such that y x implies y = x for all y \u2208 S. We say that y \u2208 S covers x \u2208 S in (S, ) when x y and there is no z \u2208 S such that x z y. A poset (S, ) is graded when there exists a rank function \u03c1 : S \u2192 N such that: i.) \u03c1 is constant on all minimal elements of (S, ). ii.) \u03c1(x) \u2264 \u03c1(y) for all x, y \u2208 S such that x y. iii.) for any pair x, y \u2208 S it holds that if y covers x in (S, ), then \u03c1(y) = \u03c1(x) + 1.\nThe remainder of this section on preliminaries will be devoted to the theory of cooperative simple games. A lot of the information in this section can be looked up in an introductory text on cooperative game theory, for example [57] or in Taylor and Zwicker\u2019s book on simple games [66]. We start with defining some essential terminology.\nDefinition 2 (Cooperative (simple) games, grand coalition, characteristic function, monotonicity).\n\u2022 A cooperative game is a pair (N, v), where N is a finite set of players; subsets of N are called coalitions and v : 2N \u2192 R\u22650 is a function mapping coalitions to non-negative real numbers. Intuitively, v describes how much collective payoff a coalition of players can gain when they cooperate.\n\u2022 N is called the grand coalition. v is called the characteristic function or gain function.\n\u2022 A simple game is a cooperative game (N, v) where the codomain of v is restricted to {0, 1}. In this context, subsets of N are referred to as winning coalitions if v(S) = 1, and losing coalitions otherwise (i.e., if v(S) = 0). (We purposefully do not exclude the game with only losing coalitions, as is customary. The reason is that including this game will make it more convenient later to show that a particular structure exists in a subclass of the simple games.)\n\u2022 A cooperative game (N, v) is monotonic if and only if v(S) \u2264 v(T ) for all pairs of coalitions S, T \u2208 2N that satisfy S \u2286 T .\nNote that in a large body of literature, the additional assumption is made that v(\u2205) in a cooperative game. For the sake of stating the results of our paper elegantly, we do not make this assumption.\nWe will often use simply the word game to refer to a cooperative game. A cooperative game (N, v) will often be denoted by just v when it is clear what the set of players is. Later, we define various important additional classes of simple games. Since we will be working with these classes extensively, it is convenient to introduce the following notation in order to denote classes of games that are restricted to a fixed number of players n:\nDefinition 3. Let G be a class of games. Then we use G(n) to denote the class of games restricted to the set of players {1, . . . , n}. In more formal language:\nG(n) = {G : G \u2208 G \u2227G = ({1, . . . , n}, v)}.\nThroughout this paper, n will always be the symbol we use to denote the number of players in a cooperative game.\nThe monotonic simple games are the games that we are concerned with in this paper.\nDefinition 4 (The class of monotonic simple games). We define Gmon to be the class of all monotonic simple games.\nSome of the definitions in the remainder of this section are taken or adapted from [4] and [66]. Next, we turn to some syntactic definitions of certain classes of simple games. There are various important ways to represent simple games:\nDefinition 5 (Representations of simple games). Suppose that (N, v) is a simple game. Let W = {S : S \u2208 2N \u2227 v(S) = 1} and L = {S : S \u2208 2N \u2227 v(S) = 0} be its sets of respectively losing coalitions and winning coalitions. Define Wmin = {S \u2208 W : (\u2200i \u2208 S)v(S \\ {i}) = 0} and Lmax = {S \u2208 L : (\u2200i \u2208 N \\ S)v(S \u222a {i}) = 1} as their respective sets of minimal winning coalitions and maximal losing coalitions. We can describe a simple game in the following forms:\nWinning coalition form (N,W ) is called the winning coalition form of (N, v).\nLosing coalition form (N,L) is called the losing coalition form of (N, v).\nMinimal winning coalition form If (N, v) is monotonic, then (N,Wmin) is the minimal winning coalition form of (N, v). Observe that Wmin fully describes v if and only if (N, v) is monotonic.\nMaximal losing coalition form If (N, v) is monotonic, then (N,Lmax) is the maximal losing coalition form of (N, v). Observe that Lmax fully describes v if and only if (N, v) is monotonic.\nWeighted form If there exists a quota q \u2208 R\u22650 and a weight wi \u2208 R\u22650 for each player i \u2208 N , such that for each coalition S \u2208 2N it holds that v(S) = 1 \u21d4 \u2211 i\u2208S wi \u2265 q, then the vector w = (q, w1, . . . , wn), also\nwritten as [q;w1, . . . , wn], is called a weighted form of (N, v). Observe that every game that has a weighted form is also monotonic.\nGames that have a weighted form are of our main interest and have a special name:\nDefinition 6 (Weighted voting games). If a monotonic simple game has a weighted form, then it is called a weighted voting game. The class of all weighted voting games is denoted by Gwvg.\nIt is well known that the class of weighted voting games is strictly contained in the class of monotonic simple games: examples of monotonic simple games that are not weighted are numerous and easily constructed. Later, in Section 4.1, we discuss the cardinalities of these classes with respect to n.\nA weighted voting game is an important type of simple game because it has a compact representation. Also, weighted voting games are important because they are used in a lot of practical situations, i.e., in a lot of real-life decision making protocols, for example: elections, politics and stockholder companies. An important property of weighted voting games that we will use, is that a weighted representation of such a game is invariant to scaling:\nProposition 1. Let G \u2208 Gwvg(n) be a weighted voting game, and let ` = [q;w1, . . . , wn] be a weighted representation for G. For every \u03bb \u2208 R+, we have that `\u2032 = [\u03bbq;\u03bbw1, . . . , \u03bbwn] is a weighted representation for G.\nProof. For any coalition C \u2286 N such that w`(C) < q:\nw`\u2032(C) = \u2211 i\u2208C \u03bbwi = \u03bb \u2211 i\u2208C wi = \u03bbw`(C) < \u03bbq,\nand for any coalition C \u2286 N such that w`(C) \u2265 q:\nw`\u2032(C) = \u2211 i\u2208C \u03bbwi = \u03bb \u2211 i\u2208C wi = \u03bbw`(C) \u2265 \u03bbq.\nWe will be using the following notational abuse in the remainder of this paper: Whenever we are discussing a weighted voting game G with players N = {1, . . . , n} and weighted form [q;w1, . . . , wn], we use w(S) as a shorthand for \u2211 i\u2208S wi for any subset S of N .\nWe next turn our attention to the topic of influence and power in monotonic simple games. For a monotonic simple game, it is possible to define a relation called the desirability relation on the players (see [31]):\nDefinition 7 (Desirability relation). For a monotonic simple game (N, v), the desirability relation v is defined by:\n\u2022 For any i, j \u2208 N : if \u2200S \u2286 N \\ {i, j} : v(S \u222a{i}) \u2265 v(S \u222a{j}), then i v j. In this case we say that i is more desirable than j.\n\u2022 For any i, j \u2208 N : if \u2200S \u2286 N \\ {i, j} : v(S \u222a{i}) = v(S \u222a{j}), then i \u223cv j. In this case we say that i and j are equally desirable.\n\u2022 For any i, j \u2208 N : if \u2200S \u2286 N \\ {i, j} : v(S \u222a{i}) \u2264 v(S \u222a{j}), then i v j. In this case we say that i is less desirable than j.\n\u2022 For any i, j \u2208 N : if i v j and not i \u223cv j, then i v j. In this case we say that i is strictly more desirable than j.\n\u2022 For any i, j \u2208 N : if i v j and not i \u223cv j, then i \u227av j. In this case we say that i is strictly less desirable than j.\nMoreover, if neither i v j nor j v i holds for some i, j \u2208 N , then we say that i and j are incomparable.\nIn cases that it is clear which game is meant, we drop the subscript and write ,\u227a, , ,\u223c instead of v,\u227av, v, v,\u223cv.\nThere exist other notions of desirability, for which different properties hold [17]. In the context of other desirability relations, the desirability relation that we have defined here is refered to as the individual desirability relation. Since this is the only desirability relation that we will use in this paper, we will refer to it as simply the desirability relation.\nUsing the notion of this desirability relation, it is now possible to define the class of linear games.\nDefinition 8 (Linear game). A simple game (N, v) is a linear game if and only if it is monotonic, and in (N, v) no pair of players in N is incomparable with respect to . Thus, for a linear game (N, v), is a total preorder on N . We denote the class of linear games by Glin.\nIt is straightforward to see that all weighted voting games are linear: let (N, v) be a weighted voting game where N = {1, . . . , n}, and let [q;w1, . . . , wn] be a weighted form of (N, v). Then it holds that i j when wi \u2264 wj . Hence, every pair of players is comparable with respect to .\nIn fact, the following sequence of strict containments holds: Gwvg \u2282 Glin \u2282 Gmon. This brings us to the definition of two special classes of games that will be convenient for use in subsequent sections.\nDefinition 9 (Canonical weighted voting games & canonical linear games). A linear game (N, v) is a canonical linear game whenever N = {1, . . . , n} for some n \u2208 N>0, and the desirability relation satisfies 1 2 \u00b7 \u00b7 \u00b7 n. When G is also weighted, then G is a canonical weighted voting game. The class of canonical linear games is denoted by Gclin, and the class of canonical weighted voting games is denoted by Gcwvg.\nNote that a canonical weighted voting game always has a weighted representation that is non-increasing.\nIt is now time to introduce two special ways of representing canonical linear games.\nDefinition 10 (Left-shift & right-shift). Let N be the set of players {1, . . . , n} and let S be any subset of N . A coalition S\u2032 \u2286 N is a direct left-shift of\nS whenever there exists an i \u2208 S and i \u2212 1 6\u2208 S with 2 \u2264 i \u2264 n such that S\u2032 = (S \\ {i}) \u222a {i \u2212 1}. A coalition S\u2032 \u2286 N is a left-shift of S whenever for some k \u2265 1 there exists a sequence (S1, . . . , Sk) \u2208 (2n)k, such that\n\u2022 S1 = S,\n\u2022 Sk = S\u2032,\n\u2022 for all i with 1 \u2264 i < k, we have that Si+1 is a direct left-shift of Si.\nThe definitions of direct right-shift and right-shift are obtained when we replace in the above definition i\u2212 1 with i+ 1 and i+ 1 with i\u2212 1.\nFor example, coalition {1, 3, 5} is a direct left-shift of coalition {1, 4, 5}, and coalition {1, 2, 5} is a left-shift of {1, 4, 5}.\nThe notions of left-shift and right-shift make sense for canonical linear games and canonical weighted voting games: Because of the specific desirability order that holds in canonical linear games, a left-shift of a winning coalition is always winning in such a game, and a right-shift of a losing coalition is always losing in such a game. This allows us to represent a canonical linear game in one of the following two forms.\nDefinition 11 (Roof/ceiling coalition/form). Let (N = {1, . . . , n}, v) be a canonical linear game. Also, let Wmin be (N, v)\u2019s list of minimal winning coalitions and let Lmax be (N, v)\u2019s list of maximal losing coalitions. A minimal winning coalition S \u2208Wmin is a roof coalition whenever every right-shift of S is losing. Let Wroof denote the set of all roof coalitions of G. The pair (N,Wroof) is called the roof form of G. A maximal losing coalition S \u2208 Lmax is a ceiling coalition whenever every left-shift of S is winning. Let Wceil denote the set of all ceiling coalitions of G. The pair (N,Wceil) is called the ceiling form of G.\nThe terminology (\u201croof\u201d and \u201cceiling\u201d) is taken from [56], although they have also been called shift-minimal winning coalitions and shift-maximal losing coalitions [66].\nBecause we will be discussing simple games from a computational perspective, we next introduce the concept of representation languages for simple games."}, {"heading": "2.1 Representation languages", "text": "We have introduced several ways of representing simple games: by the sets of winning and losing coalitions; by the sets of minimal winning coalitions and maximal losing coalitions; by the sets of roof coalitions and ceiling coalitions; and by their weighted representation.\nWe now make precise the notion of representing a simple game by turning these methods representing simple games into languages: sets of strings, such that the strings are a description of a game according to one of the methods in the list above.\nPrior to defining these languages, we need a way of describing coalitions. Coalitions can be described using their characteristic vector.\nDefinition 12. Let N = {1, . . . , n} be a set of n players. The characteristic vector ~\u03c7(S) of a coalition S \u2286 N is the vector (\u03c7(1, S), . . . , \u03c7(n, S)) where\n\u03c7(i, S) = { 1 if i \u2208 S 0 otherwise.\nA characteristic vector of a coalition in a game of n players is described by n bits.\nDefinition 13 (Representation Languages). We define the following representation languages to represent simple games.\n\u2022 LW . Strings ` \u2208 LW are lists of characteristic vectors of coalitions. The string ` represents a simple game G if and only if the set of coalitions that ` describes is precisely the set of coalitions that are winning in G.\n\u2022 The languages LW,min, LL, LL,max, Lroof , and Lceil are defined in the obvious analogous fashion.\n\u2022 Lweights. Strings ` \u2208 Lweights are lists of numbers \u3008q, w1, . . . , wn\u3009. The string ` represents the simple game G if and only if G is a weighted voting game with weighted form [q;w1, . . . , wn].\nWe will use the following convention: For a representation language L, we denote with L(n) the set of strings in the language L that represent games of n players. Also, let ` be a string from a representation language L(n). Then we write G` to denote the simple game on players {1, . . . , n} that is represented by `.\nDefinition 14. We say that a class of games G is defined by a language L if and only if \u2200` \u2208 L : \u2203G \u2208 G : G` = G and vice versa \u2200G \u2208 G : \u2203` \u2208 L : G` = G.\nUsing the above definition, we see that\n\u2022 Gsim is defined by both LW and LL;\n\u2022 Gmon is defined by both LW,min and LL,max;\n\u2022 Glin is defined by both Lroof and Lceil;\n\u2022 Gwvg is defined by Lweights."}, {"heading": "2.2 Power indices", "text": "Power indices can be used to measure the amount of influence that a player has in a monotonic simple game. Power indices were originally introduced because it was observed that in weighted voting games, the weight of a player is not directly proportional to the influence he has in the game. This is easy to see through the following trivial example weighted voting game:\n[1000; 997, 1, 1, 1].\nHere, each player is in only one winning coalition: the grand coalition. All players are required to be present in this coalition for it to be winning, and can therefore be said to have the same influence, despite the fact that there is a huge difference between the weights of the first vs. the other three players.\nMany proposals have been put forward to answer the question of what constitutes a good definition of power in a voting game. These answers are in the form of power indices, which are mathematical formulations for values that try to describe the \u2018true\u2019 influence a player has in a weighted voting game. We refer the reader to [3] for an excellent WWW information resource on power indices.\nPower indices try to measure a player\u2019s a priori power in a voting game. That is, they attempt to objectively measure the influence a player has on the outcome of a voting game, without having any statistical information on which coalitions are likely to form due to the preferences of the players. To do this, we cannot avoid making certain assumptions, but we let these assumptions be as neutral as possible. For example, in the Banzhaf index we describe below, the assumption is that each coalition will form with equal probability.\nWhile the need for power indices originally arose from studying weighted voting games, all of the power indices that have been devised up till now also make sense for (and are also well-defined for) simple games. So, for any simple coalitional game, we can use a power index as a measure of a player\u2019s a priori power in it.\nIn this paper we use the normalized Banzhaf index as our power index of choice. This power index is used in the experiments discussed in Section 6. However, we will see that for the theoretical part of our work, the particular choice of power index is irrelevant.\nDefinition 15 (normalized Banzhaf index & raw Banzhaf index). For a monotonic simple game (N = {1, . . . , n}, v), the normalized Banzhaf index of (N, v) is defined as \u03b2 = (\u03b21, . . . , \u03b2n), where for 1 \u2264 i \u2264 n,\n\u03b2i = \u03b2\u2032i\u2211n j=1 \u03b2 \u2032 j ,\nand \u03b2\u2032i = |{S \u2286 N \\ {i} : v(S) = 0 \u2227 v(S \u222a {i}) = 1}|. (1) Here, \u03b2\u2032i is called the raw Banzhaf index of player i.\nNote that the Banzhaf index of an n-player simple game is always a member of the unit simplex of Rn, i.e., the set {x \u2208 Rn : \u2211n i=1 xi = 1}.\nThe problem of computing power indices, and its associated computational complexity, has been widely studied (e.g., in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]). For a survey of complexity results, exact algorithms and approximation algorithms for computing power indices, see [33]. In general, computing power indices is a hard task, and the case of the normalized Banzhaf index is no exception: Computation of the raw Banzhaf index is known to be #Pcomplete [59], and the fastest known exponential time algorihm for computing the Banzhaf index is due to Klinz and Woeginger [35]. It achieves a runtime in O(( \u221a 2)n \u00b7 n2)."}, {"heading": "3 The problem statement", "text": "In this section, we will introduce the problem that we call the voting game design problem: the problem of finding a simple game that satisfies a given requirement (or set of requirements) as well as possible. We will focus on the problem of finding games in which the power index of the game is as close as possible to a given target power index.\nWe define a voting game design problem as an optimization problem where we are given three parameters f , G, and L. In such a voting game design problem we must minimize some function f : G \u2192 R\u22650, with G being some class of simple games. L is a representation language for G. We require the game that we output to be in the language L.\nDefinition 16 ((f,G,L)-voting game design ((f,G,L)-VGD)). Let G be a class of simple games, let L be a representation language for G, and let f : G \u2192 R+ \u222a {0} be a function. The (f,G,L)-voting game design problem (or (f,G,L)VGD) is the problem of finding an ` \u2208 L such that G` \u2208 G and f(G`) is minimized.\nHence, f can be seen as a function indicating the error, or the distance from the game that we are ideally looking for. By imposing restrictions on the choice of f , and by fixing G and L, we can obtain various interesting optimization problems. The cases that we will focus on will be those where f is a function that returns the distance of a game\u2019s power index from a certain target power index.\nDefinition 17 ((g,G,L)-power index voting game design ((g,G,L)-PVGD)). Suppose G is a class of games, and L is a representation language for a class of games. Furthermore, suppose g : G \u2192 Rn is a function that returns a type of power index (e.g., the normalized Banzhaf index) for games in G. Then, the (g,G,L)-power index voting game design problem (or (g,G,L)-PVGD) is the (f,G,L)-VGD problem with f restricted to those functions for which there exists a vector (p1, . . . , pn) such that for each G \u2208 G,\nf(G) = \u221a\u221a\u221a\u221a n\u2211 i=1 (g(G)i \u2212 pi)2.\nIn words, in a (g,G,L)-PVGD problem we must find a voting game in the class G that is as close as possible to a given target power index (p1, . . . , pn) according to power index function g and error function f . In this paper we measure the error by means of the Euclidean distance in Rn between the power index of the game and the target power index. We made this particular choice of f because from intuition it seems like a reasonable error function. In principle, we could also choose f differently. For example, we could take for f any other norm on Rn. For our purpose, the precise choice of f does not really matter, as long as the error function is not hard to compute, given g.\nWe can analyze this problem for various power index functions, classes of games, and representation languages. So, an instance of such a problem is then represented by only a vector (p1, . . . , pn), representing a target power index.\nWe will focus in this paper on the problem (\u03b2,Gwvg,Lweights)-PVGD, i.e., the problems of finding a weighted voting game in weighted representation, that is as close as possible to a certain target (normalized) Banzhaf index."}, {"heading": "4 Voting game synthesis", "text": "The method that we will propose for solving the power index voting game design problem involves transforming between different representations for classes of simple games. In this section we will give an overview of transforming representations of simple games into each other. We call these problems voting game synthesis problems, inspired by the term threshold synthesis used in [56] for finding a weight vector for a so-called threshold function, to be defined later in this section.\nIn Section 4.1, we first find out what we can say about the cardinalities of various classes of voting games. We state the synthesis problem formally in Section 4.2. In Section 4.3 we will look at how to solve it."}, {"heading": "4.1 On cardinalities of classes of simple games", "text": "In some variants of the voting game synthesis problem, we want to transform a simple game into a specific representation language that defines only a subclass of the class of games that is defined by the input-language.\nIt is interesting to know what fraction of a class of games is synthesizable in which language, i.e., we are interested in the cardinalities of all of these classes of simple games. This is an interesting question in its own right, but we also require it in order to analyze the algorithms for the voting game design problems that we will present in the next sections.\nFirst we will discuss the number of monotonic simple games and linear games on n players. After that, we will also look at the number of weighted voting games on n players."}, {"heading": "4.1.1 The number of monotonic simple games and linear games", "text": "Let us start off with the cardinality of the class of monotonic simple games of n players: Gmon(n). This class is defined by language LW,min, i.e., each game in this class can be described by a set of minimal winning coalitions (MWCs), and for each possible set of MWCs Wmin there is a monotonic simple game G such that the MWCs of G are precisely Wmin. We see therefore that the number of monotonic simple games on n players is equal to the number of families of MWCs on n players. In a family of MWCs, there are no two coalitions S and S\u2032 such that S\u2032 is a superset of S. In other words: all elements in a family of MWCs are pairwise incomparable with respect to \u2286, or: A family of MWCs on\nthe set of players N = {1, . . . , n} is an antichain in the poset (2N ,\u2286). Hence, the number of antichains in this poset is equal to |Gmon(n)|. Counting the number of antichains in this poset is a famous open problem in combinatorics, known as Dedekind\u2019s problem and |Gmon(n)| is therefore also referred to as the nth Dedekind number Dn. Dedekind\u2019s problem was first stated in [15]. To the best of our knowledge, exact values for Dn are known only up to n = 8. We will return to the discussion of the Dedekind number in Section 5.1, where we will also mention some known upper and lower bounds for it. For now, let us simply say that Dn grows rather quickly in n: as n gets larger, Dn increases exponentially.\nFor linear games, we know only of the following lower bound on the number of canonical linear games. The prove that we give here is from [56]:\nTheorem 1. For large enough n,\n|Gclin(n)| \u2265 2( \u221a 2 3\u03c02 n)/(n \u221a n).\nProof. First observe that |Gclin(n)| is equal to the number of antichains in the poset (2N , ssrs), where ssrs is defined as follows: for two coalitions S \u2286 N and S\u2032 \u2286 N , we have S ssrs S\u2032 if and only if S is a superset of a right-shift of S\u2032. It can be seen that (2N , ssrs) is a graded poset, with the following rank function r:\nr : 2N \u2192 N S 7\u2192 \u2211 i\u2208S n\u2212 i+ 1.\nA set of points of the same rank is an antichain in (2N , ssrs). Let Ak denote the set of points of rank k. k is at most n(n+1)2 . For each coalition S in Ak, its complement N \\ S is in An(n+1)/2\u2212k; therefore |Ak| = |An(n+1)/2\u2212k|. It is shown in [64] that the sequence (|A1|, . . . , |An(n+1)/2|) is unimodal, i.e., first non-increasing, then non-decreasing. By this fact and the fact that |Ak| = |An(n+1)/2\u2212k|, it must be the case that the largest antichain is |An(n+1)/4|. |An(n+1)/4| is equal to the number of points (x1, . . . , xn) satisfying x1 + 2x2 + \u00b7 \u00b7 \u00b7+ nxn = n(n+1)4 , and this number of points is equal to the middle coefficient of the polynomial (1 + q)(1 + q2) \u00b7 \u00b7 \u00b7 (1 + qn). It is shown in [53] that this middle coefficient is asymptotically equal to\u221a\n2 3\u03c02 n\nn \u221a n\nSince every subset of an antichain is also an antichain, there must be more than\n2( \u221a 2 3\u03c02 n)/(n \u221a n)\nantichains in (2N , ssrs)."}, {"heading": "4.1.2 The number of weighted voting games", "text": "To our knowledge, the existing game theory literature does not provide us with any general insights in the number of weighted voting games on n players. Fortunately there is a closely related field of research, called threshold logic (see for example [50]), that has some relevant results.\nDefinition 18 (Boolean threshold function, realization, LT). Let f be a boolean function on n boolean variables. f is a (boolean) threshold function when there exists a weight vector of real numbers r = (r0, r1, . . . rn) \u2208 Rn+1 such that r1x1 + \u00b7 \u00b7 \u00b7+ rnxn \u2265 r0 if and only if f(x1, . . . , xn) = 1. We say that r realizes f . We denote the set of threshold functions of n variables {x1, . . . , xn} by LT(n).3\nThreshold functions resemble weighted voting games, except for that we talk about boolean variables instead of players now. Also, an important difference between threshold functions and weighted voting games is that r0, r1, . . . , rn are allowed to be negative for threshold functions, whereas q, w1, . . . , wn, must be non-negative in weighted voting games.\n[70] gives an upper bound on the number of threshold functions of n variables |LT(n)|:\n|LT(n)| \u2264 2n 2\u2212n+1.\nAlso, the following asymptotic lower bound is known, as shown in [69]: For large enough n, we have\n|LT(n)| \u2265 2n 2(1\u2212 10log n ). (2)\nFrom these bounds, we can deduce some easy upper and lower bounds for |Gwvg|.\nFirst we observe the following property of the set of threshold functions on n variables. Let LT+(n) be the set of non-negative threshold functions of variables {x1, . . . , xn}: threshold functions f \u2208 LT(n) for which there exists a non-negative weight vector r that realizes f It is then not hard to see that there is an obvious one-to-one correspondence between the games in Gwvg(n) and the threshold functions in LT+(n), so |Gwvg(n)| = |LT+(n)|. An easy upper bound then follows:\nCorollary 1. For all n, |Gwvg(n)| \u2264 2n 2\u2212n+1.\nWe will proceed by obtaining a lower bound on the number of weighted voting games.\nCorollary 2. For large enough n, it holds that\n|Gwvg(n)| \u2264 2n 2(1\u2212 10log n )\u2212n\u22121\n3\u201cLT\u201d stands for \u201cLinear Threshold function\u201d.\nProof. Let f be a non-negative threshold function and let r be a non-negative weight vector that realizes f . There are 2n+1 possible ways to negate the elements of r, so there are at most 2n+1\u22121 threshold functions f \u2032 \u2208 LT(n)\\LT+(n) such that f \u2032 has a realization that is obtained by negating some of the elements of r. From this, it follows that |LT+(n)| \u2265 |LT(n)|2n+1 , and thus also |Gwvg(n)| \u2265 |LT(n)2n+1 |. Now by using (2) we get |Gwvg(n)| \u2265 2 n2(1\u2212 10 log n ) 2n+1 = 2 n2(1\u2212 10log n )\u2212n\u22121.\nWe have obtained this lower bound on the number of weighted voting games by upper-bounding the factor, say k, by which the number of threshold functions is larger than the number of non-negative threshold functions. If we could find the value of k exactly, or at least lower-bound k, then we would also be able to sharpen the upper bound on the number of weighted voting games.\nOur next question is: what about the canonical case, Gcwvg(n)? Gcwvg(n) is a subset of Gwvg(n), and for each non-canonical weighted voting game there exists a permutation of the players that makes it a canonical one. Since there are n! possible permutations, it must be that |Gcwvg(n)| \u2265 |Gwvg(n)|n! , and thus we obtain that\n|Gcwvg(n)| \u2265 2n\n2(1\u2212 10log n )\u2212n\u22121\nn! (3)\nfor large enough n."}, {"heading": "4.2 The synthesis problem for simple games", "text": "In a voting game synthesis problem, we are interested in transforming a given simple game from one representation language into another representation language.\nDefinition 19 (Voting game synthesis (VGS) problem). Let L1 and L2 be two representation languages for (possibly) distinct classes of simple games. Let fL1\u2192L2 : L1 \u2192 L2 \u222a {no} be the function that, on input `,\n\u2022 outputs no when G` is not in the class of games defined by L2,\n\u2022 otherwise maps a string ` \u2208 L1 to a string `\u2032 \u2208 L2 such that G` = G`\u2032 .\nIn the (L1,L2)-voting game synthesis problem, or (L1,L2)-VGS problem, we are given a string ` \u2208 L1 and we must compute fL1\u2192L2(`)."}, {"heading": "4.3 Algorithms for voting game synthesis", "text": "In this section we will discuss algorithms and hardness results for various VGS problems. In Sections 4.3.1, 4.3.2 and 4.3.3 we will consider respectively the problems of\n\u2022 transforming games into weighted representation (Lweights);\n\u2022 transforming games into roof- or ceiling-representation (Lroof ,Lceil);\n\u2022 transforming games into the languages LW ,LW,min,LL,LL,max."}, {"heading": "4.3.1 Synthesizing weighted representations", "text": "For our approach to solving the power index voting game design problem for weighted voting games, which we will present in Section 5, it is of central importance that the problem (LW,min,Lweights)-VGS has a polynomial time algorithm. This is a non-trivial result and was first stated in [56] by Peled and Simeone. In [56], the problem is stated in terms of set-covering problems. Because this algorithm is central to our approach for solving the PVGD-problem, we will here restate the algorithm in terms of simple games, and we will give a proof of its correctness and polynomial time complexity.\nIn order to state the algorithm, we first introduce a new total order on the set of coalitions 2N of a set of players N = {1, . . . , n}.\nDefinition 20 (Positional representation). Let S \u2286 N = {1, . . . , n} be a coalition. The ith position p(i, S) of S is defined to be the player a in S such that |{1, . . . , a} \u2229N | = i. The positional representation of S, pr(S), is defined as the n-dimensional vector (p\u2032(1, S), . . . , p\u2032(n, S)) where\np\u2032(i, S) = { 0 if |S| < i, p(i, S) otherwise.\nfor all i with 1 \u2264 i \u2264 n.\nAs an example: if we have N = {1, . . . , 5} and S = {1, 4, 5}, then pr(S) = (1, 4, 5, 0, 0).\nDefinition 21 (PR-lexi-order). The PR-lexi-order is the total order (2N , pr), where for two coalitions S \u2286 N and S\u2032 \u2286 N : S pr S\u2032 if and only if pr(S) lexicographically precedes pr(S\u2032). A vector ~v lexicographically precedes another vector ~v\u2032 when there exists a i such that vi < v \u2032 i and for all j < i it holds that vi = vj .\nFor example, we see that for N = {1, . . . , 5}, we have {1, 2, 3} pr {1, 3, 5}. The least element of (2N , pr) is \u2205 and the greatest element of (2N , pr) is N .\nNext, we introduce some operations that we can apply to coalitions. For this, the reader should recall definitions 10 and 12.\nDefinition 22 (fill-up, bottom right-shift, truncation, immediate successor). Let N be the set of players {1, . . . , n} and let S \u2286 N be a coalition. The functions a and b are defined as follows.\n\u2022 b(S) is the largest index j such that \u03c7(j, S) = 1.\n\u2022 a(S) is the largest index j such that \u03c7(j, S) = 0 and \u03c7(j + 1, S) = 1 (if such a j does not exist, then a(S) = 0).\nNow we can define the following operations on S:\n\u2022 The fill-up of S: fill(S) = S \u222a {b(S) + 1} (undefined if S = N).\n\u2022 The bottom right-shift of S: brs(S) = S \u222a {b(S) + 1} \\ {b(S)} (undefined if b(S) = n).\n\u2022 The truncation of S: trunc(S) = S \\ {a(S) + 1, . . . , n}.\n\u2022 The immediate successor of S:\nsucc(S) = { fill(S) if n 6\u2208 S , brs(S \\ {n}) if n \u2208 S .\nThe immediate successor operation is named as such because it denotes the successor of S in the total order (2N , pr).\nOne last concept we need is that of a shelter coalition.\nDefinition 23 (Shelter). A shelter is a minimal winning coalition S such that brs(S) is losing or undefined.\nNote that the set of roof coalitions of a canonical linear game is a subset of the set of shelter coalitions of that game.\nThe Hop-Skip-and-Jump algorithm We are now ready to state the algorithm. The input to the algorithm is a string ` in LW,min, i.e., the list of characteristic vectors describing the set of minimal winning coalitions Wmin. The four main steps of the algorithm are:\n1. Check whether G` is a linear game. If not, then stop. When it turns out that the game is linear, find a permutation of the players that turns the game into a canonical linear game. In the remaining steps, we assume that G` is a canonical linear game.\n2. Generate a list of shelters S, sorted according to the PR-lexi-order.\n3. Use S as input for the Hop-Skip-and-Jump algorithm. The Hop-Skip-andJump algorithm will give as output the set of all maximal losing coalitions Lmax. This step, is the most non-trivial part, and we will explain it in detail below.\n4. Use Wmin and Lmax to generate the following system of linear inequalities, and solve it for any choice of q in order to find the weights w1, . . . , wn:\nw1\u03c7(1, S) + \u00b7 \u00b7 \u00b7+ wn\u03c7(n, S) \u2265 q,\u2200S \u2208Wmin w1\u03c7(1, S) + \u00b7 \u00b7 \u00b7+ wn\u03c7(n, S) < q,\u2200S \u2208 Lmax\n(4)\nIf this system of linear inequalities has no solutions, then G` is not weighted; and otherwise the weights that have been found are the weights of the players, and q is the quota: [q;w1, . . . , wn] is a weighted form of the weighted voting game.\nThe first step of the algorithm is easy if we use an algorithm by Aziz, given in [4]. This algorithm decides whether a monotonic simple game represented as a listing of minimal winning coalitions is a linear game, and if so it outputs a strict desirability order4. From the strict desirability order, the required permutation directly follows.\nThe generation of the sorted list of shelters can be done in polynomial-time: We can easily check for each minimal winning coalition whether its bottom right-shift is losing.\nLinear programs are solvable in a time that is polynomial in the size of the linear program, by Karmarkar\u2019s algorithm [32] for example. For the linear program of the fourth part of the algorithm we will have to show that its size is bounded by a polynomial in n and the number of minimal winning coalitions, i.e., we will have to show that there are only polynomially many more maximal losing coalitions than that there are minimal winning coalitions. This follows from the fact that the Hop-Skip-and-Jump algorithm (see below) runs in polynomial time and hence can output only a polynomial number of coalitions. Lastly, the fact that we can choose any q \u2208 R>0 follows from Theorem 1.\nThe hard part that now remains is part three of the algorithm: outputting the list of maximal losing coalitions, given a sorted list of shelter coalitions. This is what the Hop-Skip-and-Jump-algorithm does. We will now state this algorithm, prove it correct and show that the runtime is bounded by a polynomial in the number of players n and the number of shelter coalitions t. From this polynomial runtime it then also follows that |Lmax| is polynomially bounded in |Wmin|.\nThe pseudocode for the Hop-Skip-and-Jump algorithm is given in Algorithm 1. The basic idea is to consider all coalitions in the order induced by the PR-lexiorder, and output those coalitions that are maximal losing coalitions. During this process, we will be able to skip huge intervals of coalitions in order to achieve a polynomial run-time.\nWe will now proceed by giving a correctness-proof of this algorithm.\nTheorem 2. Algorithm 1 outputs only maximal losing coalitions.\nProof. There are three places at which Algorithm 1 outputs coalitions: line 1, 8 and line 15.\nAt line 1, a coalition is only output when the list of shelters is empty. When this list is empty, it means there are no winning coalitions, so N is the only maximal losing coalition.\nAt line 15 we see that currentcoalition \u2282 nextshelter, and nextshelter is a minimal winning coalition, so currentcoalition must be losing. Also, at line 15, n \u2208 nextshelter. This means that any superset of currentcoalition is a superset of a leftshift of nextshelter, and therefore winning. So we conclude that\n4With this, we mean that the algorithm outputs a list ~P = (P1, . . . , Pj) such that {P1, . . . , Pj} is a partition of N , where the players of a set in this partition are all equally desirable, and for all i and j with i > j we have that any player in Pi is strictly more desirable than any player in Pj .\nAlgorithm 1 The Hop-Skip-and-Jump algorithm. A polynomial-time algorithm that outputs the set of maximal losing coalitions of a monotonic simple game G on players N = {1, . . . , n}, given the sorted list of shelters of G as input. An assumption we make in this algorithm is that the empty coalition does not occur in the list of shelters. If it does, it becomes a trivial task to output the list of maximal losing coalitions, so this is a safe assumption.\n1: nextshelter := first shelter on the list. {Output the coalition N and stop if the list is empty.} 2: currentcoalition := \u2205 {Start with the least coalition, according to the PRlexi-order.} 3: loop 4: while currentcoalition 6= nextshelter \\ {b(nextshelter)} do 5: if n 6\u2208 currentcoalition then 6: currentcoalition := fill(currentcoalition) 7: else 8: output currentcoalition 9: currentcoalition := brs(trunc(currentcoalition)) {Stop if undefined.}\n10: end if 11: end while 12: if n 6\u2208 nextshelter then 13: currentcoalition := brs(nextshelter) 14: else 15: output currentcoalition 16: currentcoalition := succ(nextshelter) {Stop if nextshelter = {n}.} 17: end if 18: nextshelter := next shelter on the list. 19: end loop\ncurrentcoalition is a maximal losing coalition. This establishes that at line 15, all coalitions output are maximal losing coalitions.\nNow we need to show the same for line 8. For this, we first need to prove the following invariant.\nLemma 1. When running Algorithm 1, directly after executing line 2, line 18, and each iteration of the while-loop of line 4, currentcoalition is a losing coalition.\nProof. We prove all three cases separately.\n\u2022 Directly after executing line 2, currentcoalition is the empty coalition and thus losing by assumption.\n\u2022 Directly after executing line 18, we have two subcases:\nCase 1: After the last time the execution of the algorithm passed line 11, lines 12 and 13 were executed while lines 14\u201316 were skipped. In this case, currentcoalition is a bottom right-shift of a shelter, so currentcoalition is losing by the definition of a shelter.\nCase 2: After the last time the execution of the algorithm passed line 11, lines 14\u201316 were executed while lines 12 and 13 were skipped. In this case, currentcoalition is a direct successor of a shelter s containing player n, by definition of the direct successor function, currentcoalition is a subset of s and hence losing.\n\u2022 Directly after each iteration of the while-loop of line 4. We can use induction for this final case. By the preceding two cases in this list, that we proved, we can assume that currentcoalition is losing when the while-loop is entered. It suffices now to show that currentcoalition is losing after a single repetition of the while-loop. We divide the proof up again, in two cases:\nCase 1: During the execution of the while-loop, lines 5 and 6 were executed while lines 7\u20139 were skipped. Then currentcoalition is a fill-up of a losing coalition, say l. Let i be the agent that was added by the fill-up, i.e., currentcoalition = l \u222a {i}. Suppose for contradiction that currentcoalition is winning; then i \u2208 nextshelter and i\u22121 \u2208 nextshelter. It must also be true that l \u2286 nextshelter because otherwise l is a rightshift of nextshelter and therefore winning (the induction hypothesis states that l is losing). Therefore l = nextshelter \\ {b(nextshelter)}. But then execution would have left the loop because of line 4. Contradiction.\nCase 2: In the execution of the while-loop, lines 7\u20139 were executed while lines 5 and 6 were skipped. currentcoalition is a bottom right-shift of a truncation of a losing coalition. A truncation of a losing coalition is losing, and a bottom right-shift of a losing coalition is losing, so currentcoalition is losing.\nFrom the lemma above, it follows that at line 8, currentcoalition is losing. To show that it is also maximal, we divide the proof up in three cases:\nCase 1: The execution of the algorithm has never passed line 11. In this case currentcoalition at line 8 is obtained by a series of successive fill-ups starting from the empty coalition, and n \u2208 currentcoalition. This means that currentcoalition = N , so currentcoalition is maximal.\nCase 2: The execution of the algorithm did pass line 11 at least once, and the last time that execution has done so lines 12 and 13 were executed while lines 14\u201316 were skipped. In this case we have that at line 8, currentcoalition is obtained by a series of fill-ups of a bottom right-shift of a shelter-coalition s. It follows that adding any player to currentcoalition will turn currentcoalition into a winning coalition, because currentcoalition would then become a superset of a left-shift of s. So currentcoalition is maximal.\nCase 3: The execution of the algorithm did pass line 11 at least once, and the last time that execution has done so, lines 14\u201316 were executed while lines 12 and 13 were skipped. In this case we have at line 8 that currentcoalition is the successor of a shelter s that has player n in it. By the definition of the successor function we get that adding any player to currentcoalition would make it a superset of a left-shift of s, and thus winning. So currentcoalition is maximal.\nTheorem 3. Algorithm 1 outputs all maximal losing coalitions.\nProof. By Theorem 2 we have that Algorithm 1 outputs only maximal losing coalitions, so what suffices is to show that the intervals of coalitions that Algorithm 1 does not output, do not contain any losing coalitions.\nLet s be a coalition that is not output by Algorithm 1. There are several cases possible.\nCase 1: There is a point when the execution of the algorithm has just passed line 6, such that currentcoalition = s. In that case s is losing, following from Lemma 1.\nCase 2: There is a point when the execution of the algorithm has just passed line 8, such that currentcoalition pr s pr brs(trunc(currentcoalition)). Now s is a direct right-shift of a point s\u2032 that the algorithm has output. s\u2032 is maximal losing so s is not maximal losing.\nCase 3: There is a point when the execution of the algorithm has just passed line 12, such that currentcoalition pr s pr brs(nextshelter). Here we have that s is either a right-shift of currentcoalition or a left-shift of a superset of\nnextshelter. In the former case, s is not a maximal losing coalition because it is a right-shift of currentcoalition, and currentcoalition is not a maximal losing coalition because it is a strict subset of the bottom right-shift of nextshelter, which is also losing. In the latter case, s is winning, so s can not be maximal losing.\nBy the two theorems above, we have established that the Hop-Skip-andJump algorithm works correctly. Now we will also show that it runs in polynomial time.\nTheorem 4. Algorithm 1 runs in time O(n3t) (where t is the number of shelter coalitions).\nProof. When repeatedly executing the while-loop of line 4, lines 5 and 6 can be executed only n consecutive times, before lines 7\u20139 are executed. Line 9 can be executed at most n times in total, given that the execution does not leave the while-loop (after n times, the operation done at line 9 is undefined, and execution stops). It follows that the while-loop is executed at most n2 consecutive times before execution leaves the while-loop. Each time lines 12\u201318 are executed, one shelter is taken from the list, so lines 12\u201318 are executed only t times. The fill-up operation, bottom right-shift operation, successor operation and truncation operation can all be implemented in O(n) time. So, bringing everything together, we arrive at a total runtime of O(n3t)."}, {"heading": "4.3.2 Synthesizing roof- and ceiling-representations", "text": "Next, we consider the problem of synthesizing various representations of games into the roof- and ceiling-representation of a canonical linear game.\nLet us start with the problem (LW,Lroof)-VGS. This problem boils down to solving the (LW,min,Lroof)-VGS problem, since (LW,LW,min)-VGS is easy (just check for each coalition in W whether it is minimal, and if so, it is in Wmin). The same holds for the problems (LL,Lceil)-VGS and (LL,max,Lceil)-VGS.\nSolving (LW,min,Lroof)-VGS is also not very difficult. As pointed out before, there is a polynomial-time algorithm that checks whether a monotonic simple game given as a list of minimal winning coalitions is linear, and we can obtain the strict desirability order if this is the case. It could be that it turns out the game is linear, but not canonical. If we wish, we are then also able to permute the players so that we end up with a canonical linear game. After that, all that we have to do is check for each minimal winning coalition C whether each of its direct right-shifts (no more than n direct right-shifts are possible) are losing coalitions. If that is the case, then C must be a roof. For the problem (LL,max,Lceil)-VGS, the situation is completely symmetric.\nWhat also follows now, is that the problems (LW,min,Lceil)-VGS can be solved in polynomial time: we first check if the input list of minimal winning coalitions describes a linear game. If so, then the Hop-Skip-and-Jump algorithm of Section 4.3.1 is able to generate in polynomial time a list of maximal\nlosing coalitions from the list of minimal winning coalitions. After that, we filter from this output list the coalitions that are not ceiling coalitions. The problem (LL,max,Lroof)-VGS is also solvable in polynomial time by running a \u201csymmetric\u201d version of the Hop-Skip-and-Jump algorithm where we\n\u2022 permute the players according to the permutation \u03c0 where the players are ordered in ascending desirability, i.e., the least desirable player is now player 1, and the most desirable player is player n;\n\u2022 run a version of the Hop-Skip-and-Jump algorithm where losing coalitions are treated as winning coalitions and vice versa.\nonce the Hop-Skip-and-Jump algorithm is done, we have a list of coalitions. For each C in this list, the coalition {\u03c0\u22121(i) : i \u2208 C} is a minimal winning coalition.\nAs a consequence, by polynomial time solvability of (LW,LW,min)-VGS and (LL,LL,max)-VGS we also have that (LL,Lroof)-VGS and (LW,Lroof)-VGS admit a polynomial time algorithm.\nIs the problem (Lceil,Lroof)-VGS solvable in polynomial time? This turns out to not be the case. We will now give a family of examples of canonical linear games in which the number of roof coalitions is exponential in n, while the number of ceiling coalitions is only polynomial in n. As a consequence, any algorithm that generates the list of roofs from the list of ceilings will run in exponential time in the worst case. By symmetry it also follows that (Lroof ,Lceil)-VGS is not solvable in polynomial time.\nLet us first define the following specific type of coalition.\nDefinition 24 ((k, i)-encoding coalition). Let N = {1, . . . , n} be a set of players such that n = 4i for some i \u2208 N. For any k satisfying 0 \u2264 k < 2i \u2212 1, the (k, i)encoding coalition Sk,i \u2286 N is then defined as\n{4(j \u2212 1) + 2, 4(j \u2212 1) + 3 : The jth bit in the binary representation of k equals 0.} \u222a {4(j \u2212 1) + 1, 4(j \u2212 1) + 4 : The jth bit in the binary representation of k equals 1.}\nFor example, S2,2 = {1, 4, 6, 7}, and S5,3 = {1, 4, 6, 7, 9, 12}. We can then define canonical linear games in which the roof coalitions are (k, i)-encoding coalitions.\nDefinition 25 (i-bit roof game). Let N = {1, . . . , n} be a set of players such that n = 4i for some i \u2208 N. The i-bit roof game on N , denoted Gi\u2212bit, is the canonical linear game such that the set of roof coalitions of G is {S0,i, . . . , S2i\u22121,i}.\nFor example, the 2-bit roof game, G2\u2212bit, consists of the roofs {{2, 3, 6, 7}, {2, 3, 5, 8}, {1, 4, 6, 7}, {1, 4, 5, 8}}. Gi\u2212bit is well-defined for all i because the binary representations of two arbitrary i-bit numbers k and k\u2032 differ in at least one bit. Therefore, Si,k is not a superset of a left-shift of Si,k\u2032 and hence the set of roofs that we have defined for Gi\u2212bit is indeed a valid set of roofs (i.e., there are no two roofs such that one is a left-shift of another).\nGi\u2212bit has 2 i = 2 n 4 roofs, i.e., an exponential number in n. We will show that the number of ceilings in Gi\u2212bit is only polynomially bounded. First let us use the following definitions for convenience.\nDefinition 26 (Accepting roof set). Let G \u2208 Gclin(n) be a canonical linear game on players N = {1, . . . , n}. Let C \u2286 N be a coalition, let x be a natural number such that 1 \u2264 x \u2264 |C|, and let D(C, x) be the x-th most desirable player in C. The accepting set of roofs of the x-th most desirable player in C, denoted A(C, x), is the set consisting of those roof coalitions R for which either the xth most desirable player in R is greater than or equal to D(c, x), or |R| < x.\nIt is important to now observe that the following fact holds.\nProposition 2. In a canonical linear game, a coalition C is winning if and only if \u22c2|C| a=1A(C, a) 6= \u2205.\nProof. This lemma is in fact an equivalent statement of the fact that C is winning in a canonical linear game if and only if it is a superset of a left-shift of\na roof: if R \u2208 \u22c2|C| a=1A(C, a) then it means that replacing the a-th most desirable player in R by the a-th most desirable player in C for all a,1 \u2264 a \u2264 R would result in a left-shift of R that is a subset of C, so C must be winning.\nConversely, suppose C is winning. Then there must be a roof R that is a right-shift of a subset of C. By removing from C the players with a higher number than D(C, |R|), we obtain a subset C \u2032 of C with |R| players. By replacing the a-th most desirable player of C by the a-th most desirable player of R for 1 \u2264 a \u2264 R, we obtain a right-shift of C that is R. Because in this last step we replaced each player in C \u2032 by a higher-numbered player, we get that\nR \u2208 \u22c2|R| a=1A(C, a). R is also in \u22c2|C| a=|R|+1A(C, a) by definition.\nUsing the notion of an accepting roof set, we can prove the following technical lemma. The reader should recall the definition of a direct left-shift (Definition 10).\nLemma 2. Let C be a ceiling of Gi\u2212bit with two or more distinct coalitions that are direct left-shifts of C, and let p be an arbitrary player that we can apply the direct left-shift operation on, i.e., let p be a player such that C1 = C\u222a{p\u22121}\\{p} is a direct left-shift of C. Also, let a be the number such that p = D(C, a). Then p = 2a.\nProof. Observe that for all b it holds that every roof R of Gi\u2212bit has either D(R, b) = 2b \u2212 1 or D(R, b) = 2b. By construction of Gi\u2212bit, the number of roofs of Gi\u2212bit that contain player 2b \u2212 1 is 2 i\n2 , and the number of roofs that\ncontain player 2b is also 2 i\n2 . C has at least two distinct direct left-shifts, so there must be another player p\u2032, p\u2032 6= p, such that C2 = C \u222a {p\u2032 \u2212 1} \\ {p\u2032} is a direct left-shift of C. First we will show that p \u2264 2a. Assume therefore that p > 2a. Now we have\nthat |A(C, a)| = 0, so then |A(C2, a)| = 0 and hence \u22c2 aA(C2, a) = \u2205. We see\nthat C2 is losing, but C2 is a direct left-shift of C, which is a ceiling, so C2 is winning. This is a contradiction, so p \u2264 2a.\nNow we will show that p \u2265 2a. Assume therefore that p < 2a. Now we have that |A(C, a)| = 2i, so then A(C1, a) = 2i. Now it must be that\u22c2 aA(C1, a) = \u22c2 aA(C, a). But \u22c2 aA(C, a) = \u2205 because C is losing, and there-\nfore \u22c2 aA(C1, a) = \u2205 so C1 is losing. C1 is also winning, because it is a left-shift of ceiling C. This is a contradiction, so p \u2265 2a. p \u2265 2a and p \u2264 2a, so p = 2a.\nLemma 3. In Gi\u2212bit, a ceiling does not have more than two direct left-shifts.\nProof. For contradiction, let C be a ceiling with more than two direct left-shifts. Let k be the number of direct left-shifts of C, and let P = {p1, . . . , pk} be the set containing the players of C that we can apply the direct left-shift operation on (we say that we can apply the direct left-shift operation on a player q when C \u222a{q\u2212 1} \\ {q} is a left-shift of C). Let A = {a1, . . . , ak} then be the numbers such that pj is the aj-th most desirable player in C, for all i with 1 \u2264 j \u2264 k. For any j \u2208 {1, . . . , i} and any b \u2208 {0, 1}, let R(j, b) denote the following set of roofs of Gi\u2212bit:\nR(j, b) = {Sk,i : The j-th bit of the binary representation of k is b. }\nObserve that by the previous lemma, there is a k-tuple of bits (b1, . . . , bk) \u2208 {0, 1}k such that for all j with 1 \u2264 j \u2264 k:\nA(C, aj) = R(dpj/4e, kj).\nThere are now two cases:\nCase 1: All of the players {p1, . . . , pk} are in different multiples of 4, i.e., dp1/4e 6= dp2/4e 6= \u00b7 \u00b7 \u00b7 6= dpk/4e. Then by the properties of the binary numbers, the intersection \u22c2 a\u2208AA(C, a) = \u22c2 p\u2208P R(dp/4e, b) is not empty,\ntherefore C must be winning, which is in contradiction with C being a ceiling. So this case is impossible.\nCase 2: There are two distinct players p and p\u2032, both in P , that are in the same multiple of 4, i.e., dp/4e = dp\u2032/4e. Assume without loss of generality that p < p\u2032. Then A(C, a) \u2229 A(C, a\u2032) = \u2205. But then we would be able to apply a direct left-shift on player p\u2032\u2032 without turning C into a winning coalition, i.e., C \u222a {p\u2032\u2032 \u2212 1} \\ {p\u2032\u2032} is winning. But C is a ceiling, so that is a contradiction.\nFrom the previous lemma it follows that there can not be more than two players that are the same multiple of 4, so the above two cases are indeed exhaustive. Both cases are impossible, so we must reject the assumption that there exists a ceiling C with more than two left-shifts.\nIt is easy to see that there exist no more than O(n5) coalitions with exactly two left-shifts, there are no more than O(n3) coalitions with one left-shift, and there are no more than O(n) coalitions with no left-shifts. so we get the following corollary.\nCorollary 3. The game Gi\u2212bit (on n = 4i players) has O(n 5) ceilings.\nWe can now conclude that {Gi\u2212bit : i \u2208 N} is an infinite family of examples in which there are exponentially many more roofs than ceilings. Hence, finally we obtain:\nCorollary 4. there is no polynomial time algorithm for (Lceil,Lroof)-VGS and (Lceil,Lroof)-VGS."}, {"heading": "4.3.3 Other voting game synthesis problems & summary of complexity results for voting game synthesis", "text": "In this section we will discuss some of the remaining variants of the voting game synthesis problem that we did not discuss in the other sections. At the end of this section, Table 1 summarizes all of the results that we have discussed up to now.\nFirst of all, Freixas et al. investigate in [27] the (L1,L2)-VGS problem for L1 and L2 \u2208 {LW ,LW,min,LL,LL,max}. Most of their results follow from the discussion above. One of their results that does not, is that (LW ,LL)-VGS and (LL,LW )-VGS do not have a polynomial time algorithm. This holds because there are instances where there are exponentially many more losing coalitions than that there are winning coalitions. Consider for instance the game in which only the grand coalition is winning. In this game there are 2n \u2212 1 losing coalitions, so it takes exponential time to list them all. This game is also a canonical linear game and a weighted voting game, so even if we restrict games to be weighted, or canonical linear, it still holds that (LW ,LL)-VGS and (LL,LW )- VGS do not have polynomial time algorithms.\nIn [27], it is also shown that (LW,max,LL,min)-VGS is in general not polynomial time solvable. The authors show this by giving a family of examples of monotonic simple games that have exponentially many more maximal losing coalitions than minimal winning coalitions. The Hop-Skip-and-Jump algorithm that we described above does actually solve (LW,max,LL,min)-VGS in polynomial time, but only for the restriction to linear games.\nAnother set of voting game synthesis problems that we have not yet discussed is the (Lweights,L2)-VGS case, for any choice of L2. In this case it always holds that there is no polynomial time algorithm for the problem:\n\u2022 When L2 = LW , consider the weighted voting game in which the quota is 0. Now there are 2n minimal winning coalitions, so the output is exponentially larger than the input. The case L2 = LL is analogous, but now we take a weighted voting game in which the quota is larger than the sum of all weights, so that there are no winning coalitions.\n\u2022 When L2 = LW,min or L2 = LL,max, we see that the weighted voting game in which every player\u2019s weight is 1 and the quota is bn2 c has an exponential number of minimal winning coalitions and maximal losing coalitions: any coalition of size bn2 c is minimal winning, and any coalition of size b n 2 c \u2212\n1 is maximal losing. There are respectively (\nn bn/2c\n) and ( n bn/2c\u22121 ) such\ncoalitions (by Sperner\u2019s theorem, see Theorem 5). By using Stirling\u2019s approximation, we can see that both these expressions are exponential in n.\n\u2022 When L2 = Lroof it follows directly from the proof of Theorem 1 that the weighted voting game in which player i gets weight n\u2212 i+1 and the quota is equal to n(n + 1)/4, has an exponential number of roofs. We do not know whether there is also a weighted voting game with an exponential number of ceilings.\nThat completes our study of the voting game synthesis problem. As said before, table 1 summarizes all of the results that we have discussed and obtained. It indicates for each variant of the voting game synthesis problem whether it is solvable in polynomial time (P), or does not have a polynomial time algorithm (EXP). We see that the complexities of three problems remain open:\n\u2022 transforming roof-representations of canonical linear games into weighted representations,\n\u2022 transforming ceiling-representations of canonical linear games into weighted representations,\n\u2022 transforming weighted-representations of weighted voting games into ceiling representations."}, {"heading": "5 Solving the power index voting game design", "text": "From the existing literature on the power index voting game design problem, we see that researchers have only considered heuristic methods for the case where\na weighted representation must be output. Even stronger: the weighted representation is the only representation that current voting game design algorithms internally work with. No other methods of representing a game have even been considered.\nThere exists an infinite number of weighted representations for each weighted voting game (this follows from Proposition 1). This makes it hard to derive an exact algorithm that is based on working with weighted representations alone, since there is no clear finite set of weight vectors that an algorithm can search through.5\nNevertheless, it turns out that we can fortunately answer this question positively: there do exist exact algorithms for voting game design problems. What follows in this section, is a study of exact algorithms for some power index voting game design problems. Of course, the most important among these problems is the variant in which we must find a weighted voting game, and output it in a weighted representation.\nWe approach the voting game design problem by devising an enumeration method that generates every voting game relatively efficiently. First, we devise a \u201cnaive\u201d method that enumerates all monotonic simple games in doubly exponential time (Section 5.1). Subsequently, in Section 5.2, for the case of weighted voting games, we improve on this runtime exponentially by showing how to enumerate all weighted voting games within exponential time. Although the runtime of this enumeration method is still exponential, we will see that it is efficient in the sense that it is polynomial in the number of games output. Moreover, the algorithm for the power index weighted voting game problem that results from this has the anytime property: the longer we run it, the better the result becomes, and eventually the optimum solution is output. The enumeration method is based on exploiting a new specific partial order on the class of weighted voting games.\nBecause we will be dealing with exponential algorithms, we make use of the O\u2217-notation: A function f : R\u2192 R is in O\u2217(g) for some g : R\u2192 R if and only if there is a polynomial p : R\u2192 R such that f \u2208 O(g \u00b7p). This essentially means that we make light of polynomial factors."}, {"heading": "5.1 Monotonic simple game design", "text": "In this section we will consider the power index voting game design problem for the class of monotonic simple games Gmon. There are four representation languages that can be used for monotonic simple games:\n\u2022 LW , the winning coalition listing;\n\u2022 LL, the losing coalition listing; 5However, the literature does provide us with bounds on the maximum weight necessary in an integer representation of a weighted voting game, and we could utilize this in order to come up with an enumeration algorithm based on generating a finite set of integer weighted representations. We elaborate on this in 5.2.\n\u2022 LW,min, the minimal winning coalition listing;\n\u2022 LL,max, the maximal losing coalition listing.\nFrom these languages, we obtain the following four different power index voting game design problems: (g,Gmon,LW )-PVGD, (g,Gmon,LL)-PVGD, (g,Gmon,LW,min)-PVGD and (g,Gmon,LL,max)-PVGD. For g we can then choose any power index. Of these problems, the cases of LW,min and LL,max are the most interesting, because these languages both define the class of monotonic simple games.\nWe do not know of any practical situations in which this problem occurs. Therefore, we will only address this problem briefly and show for theoretical purposes that the optimal answer is computable. We do this by providing an exact algorithm.\nAn exact algorithm that solves (g,Gmon,LW,min)-PVGD or (g,Gmon,LL,max)PVGD must search for the antichain of coalitions that represents the game that has a power index closest to the target power index. This antichain of coalitions could either be a set of minimal winning coalitions, or a set of maximal losing coalitions. In either way, a simple exact algorithm for this problem would be one that considers every possible antichain, and computes for each antichain the power index for the game that the antichain represents.\nAlgorithm 2 describes the process more precisely for the case that the representation language is LW,min. We will focus on LW,min from now on, because the case for LL,max is symmetric. An algorithm for the languages LW and LL can be obtained by applying the transformation algorithm discussed in the last section.\nAlgorithm 2 A straightforward algorithm for solving (g,Gmon,LW,min)-PVGD. The input is a target power index ~p = (p1, . . . , pn). The output is an ` \u2208 LW,min such that g(G`) is as close as possible to ~p.\n1: bestgame := 0 {bestgame keeps track of the best game that we have found, represented as a string in LW,min.} 2: besterror := \u221e {besterror is the error of g(Gbestgame) from ~p, according to the sum-of-squared-errors measure.} 3: for all ` \u2208 LW,min do 4: Compute g(G`) = (g(G`, 1), . . . , g(G`, n)). 5: error := \u2211n i=1(g(G`, i)\u2212 pi)2. 6: if error < besterror then 7: bestgame := ` 8: besterror := error 9: end if\n10: end for 11: return bestgame\nFrom line 3, we see that we need to enumerate all antichains on the grand coalition. As we already said in Section 4.1, the number of antichains we need to\nenumerate is Dn, the nth Dedekind number. Because the sequence of Dedekind numbers (Dn) quickly grows very large, line 3 is what gives the algorithm a very high time complexity. The following bounds are known [34]:\n2(1+c \u2032 log n n )En \u2265 Dn \u2265 2(1+c2 \u2212n/2)En , (5)\nwhere c\u2032 and c are constants and En is the size of the largest antichain on an n-set.6 Sperner\u2019s theorem [63] tells us the following about En:\nTheorem 5 (Sperner\u2019s theorem).\nEn =\n( n\nbn/2c\n) .\nFrom Sperner\u2019s theorem and Stirling\u2019s approximation, we get En \u2208 \u0398 (\n2n\u221a n\n) . (6)\nWe conclude that Dn is doubly exponential in n. Algorithm 2 therefore achieves a running time in \u0398\u2217(22\nn \u00b7 h(n)), where h(n) is the time it takes to execute one iteration of the for-loop in Algorithm 2. The function h is an exponential function for all popular power indices (e.g., the Shapley-Shubik index and the Banzhaf index) ([4, 16, 59]).\nRemark 1. The following is an interesting related problem: Apart from the fact that Dn is very large, we do not even know of an output-polynomial time procedure to enumerate all antichains on a set of n elements: The simplest way to enumerate antichains would be to enumerate each possible family of coalitions, and check if that family is an antichain. Unfortunately, this method does not run in output-polynomial time. In total, there are 22 n\nfamilies of coalitions. Substituting the tight bound of (6) into the upper bound of (5), we get\nDn \u2264 2(1+c \u2032 log n n )k 2n\u221a n (7)\nfor some constants k and c\u2032.\nExponentiating both sides of the above inequality by \u221a n\n(1+c\u2032 log nn )k , we see that\nD\n\u221a n\n(1+c\u2032 log n n )k n \u2264 22 n .\nThis means that the number of families of subsets on an n-set (i.e., the right hand side of the above inequality) is super-polynomial in n relative to the Dedekind number. This enumeration algorithm does thus not run in outputpolynomial time, even though the nth Dedekind number and the number of families of coalitions on a set of n elements, are both doubly-exponential. We leave this as an open problem.\n6Korshunov devised an asymptotically equal expression [36]:\nDn \u223c 2C(n)ec(n)2 \u2212n/2+n22\u2212n\u22125\u2212n2\u2212n\u22124 with C(n) = ( n bn/2c ) and c(n) = ( n bn/2c\u22121 ) . In [36], this expression is described as the number of monotonic boolean functions, which is equal to the nth Dedekind number."}, {"heading": "5.2 Weighted voting game design", "text": "Having given a simple but very slow algorithm for the PVGD-problem for the very general class of monotonic simple games, we will now see that we can do much better if we restrict the problem to smaller classes of simple games. More precisely, we will restrict ourselves to the class of weighted voting games: Gwvg. This class is contained in the class of linear games Glin, and therefore also contained in the class of monotonic simple games Gmon. For this reason, we can represent a game in Gwvg using any representation language that we have introduced.\nAs has been said in Section 1.2, the known literature on voting game design problems has focused on this specific variant, (g,Gvwg,Lweights)-PVGD, with f being either the Banzhaf index or the Shapley-Shubik index. Here, we will give an exact algorithm for this problem that runs in exponential time. What will turn out to make this algorithm interesting for practical purposes, is that it can be used as an anytime algorithm: we can stop execution of this algorithm at any time, but the longer we run it, the closer the answer will be to the optimum. The advantage of this algorithm over the current local search methods is obviously that we will not get stuck in local optima, and it is guaranteed that we eventually find the optimal answer."}, {"heading": "5.2.1 Preliminary considerations", "text": "Before proceeding with formally stating the algorithm, let us first address the question of which approach to take in order to find an exact algorithm for designing weighted voting games.\nA possible approach to solve the (g,Gvwg,Lweights)-PVGD problem is to use Algorithm 2 as our basis, and check for each monotonic simple game that we find whether it is a weighted voting game. We do the latter by making use of the Hop-Skip-and-Jump algorithm that we described in Section 4.3.1. This indeed results in an algorithm that solves the problem, but this algorithm would be highly unsatisfactory: firstly, we noted in the previous section that it is not known how to enumerate antichains efficiently. Secondly, the class of weighted voting games is a subclass of the class of monotonic simple games: in fact, we will see that there are far less weighted voting games than monotonic simple games.\nThe main problem we face for the (g,Gvwg,Lweights)-PVGD problem is the fact that every weighted voting game G \u2208 Gwvg has an infinite number of weighted representations, i.e., strings in Lweights that represent G. This is easily seen from Proposition 1: we can multiply the weight vector and the quota with any constant in order to obtain a new weight vector that represents the same game. On top of that, it is also possible to increase or decrease a player\u2019s weight by some amount without \u201cchanging the game.\u201d\nTheorem 9.3.2.1 of [50] provides us with a solution to this problem, as it tells us that for every weighted voting game there exists an integer weighted representation where none of the weights nor the quota exceeds 2n logn. This\nmeans that a possible enumeration algorithm could work by iterating over all of the 2(n+1)n logn integer weight vectors that have weights that fall within these bounds, and output a weight vector in case it corresponds to a weighted voting game that has not been output before. This yields an improvement over the enumeration algorithm outlined in Section 5.1 for the special case of weighted voting games. But we still do not consider this a satisfactory enumeration procedure because the runtime of this algorithm is still significantly larger than the known upper bounds on the number of weighted voting games. The enumeration algorithm that we propose below has a better runtime, and indeed has the property that it is also efficient in the sense runs in time polynomial in the number of weighted voting games it outputs. Our algorithm does not rely on weighted representations of weighted voting games; instead it works by representing weighted voting games by their sets of minimal winning coalitions."}, {"heading": "5.2.2 A new structural property for the class of weighted voting games", "text": "Let us now develop the necessary theory behind the algorithm that we will propose. We will focus only on the class of canonical weighted voting games, since for each non-canonical weighted voting game there is a canonical one that can be obtained by merely permuting the players.\nThe algorithm we will propose is based on a new structural property that allows us to enumerate the class of canonical weighted voting games efficiently: We will define a new relation MWC and we will prove that for any number of players n the class Gcwvg(n) forms a graded poset with a least element under this relation.\nDefinition 27 ( MWC). Let G,G\u2032 \u2208 Gcwvg(n) be any two canonical weighted voting games. We define G MWC G\u2032 to hold if and only if there exists for some k \u2208 N\u22651 a sequence G1, . . . , Gk of canonical weighted voting games of n players, such that G = G1, G\n\u2032 = Gk, and for 1 \u2264 i < k it holds that Wmin,i \u2282 Wmin,i+1 and |Wmin,i| = |Wmin,i+1| \u2212 1, where Wmin,i denotes the set of minimal winning coalitions of Gi.\nThe following theorem provides the foundation for our enumeration algorithm.\nTheorem 6. For each n, (Gcwvg(n), MWC) is a graded poset with rank function\n\u03c1 : Gcwvg(n) \u2192 N G 7\u2192 |Wmin,G|,\nwhere Wmin,G is the set of minimal winning coalitions of G. Moreover, the poset (Gcwvg(n), MWC) has a least element of rank 0.\nProof of Theorem 6. By the properties of the MWC-relation, (Gcwvg(n), MWC) is a valid poset. In order to show that the poset is also graded under the rank function \u03c1 specified in the theorem, we will prove the following lemma constructively.\nLemma 4. For every game G \u2208 Gcwvg(n) with a nonempty set Wmin,G as its set of minimal winning coalitions, there is a coalition C \u2208 Wmin,G and a game G\u2032 \u2208 Gcwvg(n) so that Wmin,G \\ {C} is the set of minimal winning coalitions of G\u2032.\nFrom Lemma 4, the claim follows: It implies that there is a unique minimal element, which is the game with no minimal winning coalitions. This implies that the poset has a least element, and it implies that condition (i.) in Definition 1 holds. Condition (ii.) and (iii.) follow immediately from the definitions of MWC and \u03c1.\nTo prove Lemma 4, we first prove the following two preliminary lemmas (5 and 6).\nLemma 5. Let G = (N = {1, . . . , n}, v) be a weighted voting game, and let ` = [q;w1, . . . , wn] be a weighted representation for G. For each player i there exists an > 0 such that for all \u2032 < , the vector `\u2032 = [q;w1, . . . , wi +\n\u2032, wi+1, . . . , wn] is also a weighted representation for G.\nInformally, this lemma states that it is always possible to increase the weight of a player by some amount without changing the game.\nProof. Let wmax = max{C \u2286 N : v(C) = 0} and wmin = min{C \u2286 N : v(C) = 1}. Take = wmin \u2212 wmax and note that > 0. Increasing any player\u2019s weight by any positive amount \u2032 that is less than does not turn any losing coalition in a winning coalition. Obviously, as \u2032 > 0, this change of weight also does not turn any winning coalition into a losing coalition.\nLemma 6. Let G = (N = {1, . . . , n}, v) be a weighted voting game. There exists a weighted representation ` for G such that for all C,C \u2032 \u2208 2N , C 6= C \u2032, for which v(C) = v(C \u2032) = 1, it holds that w`(C) 6= w`(C \u2032).\nOr, informally stated: for every weighted voting game, there exists a weighted representation such that all winning coalitions have a different weight.\nProof. Let `\u2032 = [q;w1, . . . , wn] be a weighted representation for G. Fix an arbitrary player i. By Lemma 5, there is an > 0 such that increasing wi by any value \u2032 \u2208 (0, ) will result in another weighted representation for G. Let E be the set of choices for \u2032 such that increasing wi by \u2032 yields a weighted representation ` where there are two coalitions C,C \u2032 \u2208 2N , i \u2208 C, i 6\u2208 C \u2032, that have the same weight under `. There are finitely many such pairs (C,C \u2032) so E is finite and therefore (0, )\\E is non-empty. By picking for \u2032 any value in (0, )\\E , and increasing the weight of player i by \u2032, we thus end up with a weighting ` in which there is no coalition C containing i such that w`(C) is equal to any coalition not containing i. Furthermore, if C,C \u2032 are two arbitrary coalitions that have distinct weight under `\u2032, then certainly they will have distinct weight under `.\nTherefore, by sequentially applying the above operation for all i \u2208 N , we end up with a weighting ` for which it holds for every player i that there is no coalition C containing i such that w`(C) is equal to the weight of any coalition\nnot containing i. This implies that all coalitions have a different weight under `, and completes the proof.\nUsing Lemma 6, we can prove Lemma 4, which establishes Theorem 6.\nProof of Lemma 4. Let G = ({1, . . . , n}, v) be a canonical weighted voting game. Let Wmin,G be its set of minimal winning coalitions and let ` = [q;w1, . . . , wn] be a weighted representation for which it holds that all winning coalitions have a different weight. By Lemma 6, such a representation exists. We will construct an `\u2032\u2032 from ` for which it holds that it is a weighted representation of a canonical weighted voting game with Wmin,G \\{C} as its list of minimal winning coalitions, for some C \u2208Wmin,G.\nLet i be the highest-numbered player that is in a coalition in Wmin,G, i.e., i is a least desirable nondummy player. We may assume without loss of generality that wj = 0 for all j > i. Let C \u2208 Wmin,G be the minimal winning coalition containing i with the lowest weight among all MWCs in Wmin,G that contain i.\nNext, define `\u2032 as [q;w1, . . . , wi \u2212 (w`(C) \u2212 q), . . . , wn]. Note that under `\u2032 the weights of the players are still decreasing and nonnegative: we have that w`(C\\{i}) < q (due to C\\{i} being a losing coalition, because C is a MWC). This implies w`(C\\{i}) + wi = w`(C) < q + wi, and is equivalent to wi > w`(C) \u2212 q (i.e., the new weight of player i is indeed nonnegative under `\u2032. Player i\u2019s weight is decreased in `\u2032, but not by enough to make losing even the lightest of all MWCs that contain i, so now G`\u2032 = G` = G and w`\u2032(C) = q. Moreover, the weights of the coalitions in Wmin,G that contain player i are still mutually distinct under `\u2032.\nWe now decrease player i\u2019s weight by an amount that is so small that the only minimal winning coalition that turns into a losing coalition is C. Note that under `\u2032, minimal winning coalition C is still the lightest minimal winning coalition containing i. Let C \u2032 \u2208 Wmin be the second-lightest minimal winning coalition containing i. Obtain `\u2032\u2032 by decreasing i\u2019s weight (according to `\u2032) by a positive amount smaller than w`\u2032(C\n\u2032)\u2212w`\u2032(C). Coalition C will become a losing coalition and all other minimal winning coalitions will stay winning. No new minimal winning coalition is introduced in this process: Suppose there would be such a new minimal winning coalition S, then S contains only players that are at least as desirable as i (the other players have weight 0). In case i 6\u2208 S, we have that S would also be a minimal winning coalition in the original game G because w`\u2032\u2032(S) = w`(S) \u2265 q, which is a contradiction. In case i \u2208 S, it must be that S\\{i} is winning in the original game G (as i was picked to be a least desirable nondummy player). Thus, w`\u2032\u2032(S\\{i} = w`(S\\{i}) \u2265 q, and this is in contradiction with S being an MWC in G`\u2032\u2032 .\nG`\u2032\u2032 is therefore an n-player canonical weighted voting game whose set of MWCs form a subset of the MWCs of G, and the cardinalities of these two sets differ by 1. This proves the claim.\nIn Figure 1, (Gcwvg(4), MWC) is depicted graphically. Note that this is not precisely the Hasse diagram of the poset (Gcwvg(4), MWC) (see the explanation in the caption of this figure; the reason that we do not give the Hasse diagram is because the Hasse diagram is not a very convenient way of representing (Gcwvg(4), MWC)).\nNext, we show that (Gcwvg(n), MWC) is not a tree for n \u2265 4. When we will state our algorithm in the next section, it will turn out that this fact makes things significantly more complicated.\nProposition 3. For n \u2265 4, (Gcwvg(n), MWC) is not a tree.\nProof. We will give an example of a game in (Gcwvg(4), MWC) that covers multiple games.7 A similar example for n > 4 is obtained by adding dummy players to the example that we give here.\nConsider the following weighted representation of a canonical weighted voting game over players {1, 2, 3, 4}:\n` = [4; 3, 2, 2, 1].\n7In fact, from inspecting Figure 1 and the explanation given in its caption, it may already be rather obvious to the reader which example game we intend.\nThe set of characteristic vectors Cmin,` of minimal winning coalitions of G` is as follows:\nCmin,` = {1100, 1010, 0110, 1001}.\nNext, consider the weighted voting games `\u2032 and `\u2032\u2032:\n`\u2032 = [4; 3, 1, 1, 1]\n`\u2032\u2032 = [2; 1, 1, 1, 0],\nwith respectively the following sets of characteristic vectors of minimal winning coalitions:\nCmin,`\u2032 = {1100, 1010, 1001}, Cmin,`\u2032\u2032 = {1100, 1010, 0110}.\nIt can be seen that Cmin,`\u2032 = Cmin,` \\ {0110} and Cmin,`\u2032\u2032 = Cmin,` \\ {1001}."}, {"heading": "5.2.3 The algorithm", "text": "We will use the results from the previous section to develop an exponential-time exact algorithm for (f,Gcwvg,LW,min)-PVGD, and also for (f,Gcwvg,Lweights)PVGD. The way this algorithm works is very straightforward: Just as in algorithm 2, we enumerate the complete class of games (weighted voting games in this case), and we compute for each game (that is output by the enumeration algorithm) the distance from the target power index.\nRecall that the problem with Algorithm 2 was that the enumeration procedure is not efficient. For the restriction to weighted voting games, we are able to make the enumeration procedure more efficient. We will use Theorem 6 for this: The key is that it is possible to generate the minimal winning coalition listing of canonical weighted games of rank i fairly efficiently from the minimal winning coalition listing of canonical weighted voting games of rank i\u2212 1.\nThe following theorem shows us how to do this. To state this theorem, we will first generalize the truncation-operation from Definition 22.\nDefinition 28 (Right-truncation). Let S \u2286 N be a coalition on players N = {1, . . . , n}. The ith right-truncation of S, denoted rtrunc(S, i), is defined as\nrtrunc(S, i) =  S \\ {P (S, i), . . . , n} if 0 < i \u2264 |S|, S if i = 0,\nundefined otherwise,\nwhere P (S, i) is the ith highest-numbered player among the players in S.\nIn effect, the ith right-truncation of a coalition S (for i \u2264 |S|) is the coalition that remains when the i highest-numbered players are removed from S.\nTheorem 7. For any n, let G,G\u2032 \u2208 Gclin(n) be a pair of canonical linear games with respective sets of minimal winning coalitions Wmin and W \u2032 min, such that Wmin \u2286 W \u2032min. Let Lmax and L\u2032max be the sets of maximal losing coalitions of G and G\u2032 respectively. There is a C \u2208 Lmax and an i \u2208 N with 0 \u2264 i \u2264 n such that W \u2032min = Wmin \u222a {rtrunc(C, i)}.\nProof. Because G is covered by G\u2032, by definition there is a coalition C \u2032 6\u2208Wmin such that W \u2032min = Wmin \u222a {C \u2032}. Coalition C \u2032 cannot be a superset of a coalition in Wmin because then it would not be a minimal winning coalition in G\n\u2032. Therefore, C \u2032 is a losing coalition in G, so it must be a subset of a coalition in Lmax. Suppose for contradiction that C\n\u2032 is not a right-truncation of a maximal losing coalition C \u2208 Lmax. So there is a C \u2208 Lmax such that C \u2032 is a subset of C, but not a right-truncation of C. This means that in C \u2032, some player j from C is not present, while at least one less desirable player k > j from C is in C \u2032. This implies that there is a left-shift C \u2032\u2032 of C \u2032 such that C \u2032\u2032 is a subset of a coalition in Lmax: C\n\u2032\u2032 is obtained from C \u2032 by replacing j by k. C \u2032\u2032 is a subset of C, so C \u2032\u2032 is still a losing coalition in G. C \u2032\u2032 is thus not a superset of any coalition in Wmin, and hence C \u2032\u2032 is also not a superset of any coalition in W \u2032min. So C \u2032\u2032 is a losing coalition in G\u2032. But G\u2032 is a canonical linear game, so by the desirability relation 1 D \u00b7 \u00b7 \u00b7 D n, C \u2032\u2032 is a winning coalition in G\u2032 because it is a left-shift of the winning coalition C \u2032. This is a contradiction.\nFrom Theorem 7, it becomes apparent how to use (Gcwvg(n), MWC) for enumerating the class of n-player canonical weighted voting games. We start by outputting the n-player weighted voting game with zero minimal winning coalitions. After that, we repeat the following process: generate the LW,minrepresentation of all canonical weighted voting games with i minimal winning coalitions, using the set of canonical weighted voting games games with i \u2212 1 minimal winning coalitions (also represented in LW,min). Once generated, we have the choice to output the games in their LW,min-representation or in their Lweights-representation, by using the Hop-Skip-and-Jump algorithm presented in Section 4.3.1.\nGenerating the set of games of i minimal winning coalitions works as follows: For each game of i\u22121 minimal winning coalitions, we obtain the set of maximal losing coalitions by using the Hop-Skip-and-Jump algorithm. Next, we check for each maximal losing coalition C whether there is a right-truncation of C that we can add to the set of minimal winning coalitions, such that the resulting set represents a weighted voting game. Again, testing whether a game is a weighted voting game is done by using the Hop-Skip-and-Jump algorithm. If a game turns out to be weighted, we can store it and output it.\nThere is one remaining problem with this approach: It outputs duplicate games. If (Gcwvg(n), MWC) were a tree, then this would not be the case, but by Proposition 3 it is not a tree for any n \u2265 4. Therefore, we have to do a duplicates-check for each weighted voting game that we find. In principle, this seems not to be so difficult: For each game that we find, sort its list of minimal winning coalitions, and check if this list of coalitions already occurs\nin the array of listings of minimal winning coalitions that correspond to games that we already found. The problem with this is that the list can grow very large, so these checks are then very time- and space-consuming operations.\nWe will therefore use a different method for doing this \u201cduplicates-check\u201d. Suppose that we have found an n-player canonical weighted voting game G of i minimal winning coalitions by adding a coalition C to a minimal winning coalition listing of a canonical weighted voting game that we have already found. We first sort G\u2019s list of minimal winning coalitions. After that, we check for each coalition C \u2032 that occurs before C in this sorted list, whether C \u2032\u2019s removal from the list results in a list of minimal winning coalitions of a canonical weighted voting game. If there is such a C \u2032, then we discard G, and otherwise we keep it. This way, it is certain that each canonical weighted voting game will be generated only once.\nAlgorithm 3 gives the pseudocode for this enumeration method. The array element games[i] will be the list of canonical weighted voting games that have i minimal winning coalitions. The value of i can not exceed ( n bn/2c ) by Theorem 5. The games are represented in language LW,min. The algorithm iterates from every new game found, starting from the game in games[0], which is the nplayer canonical weighted voting game with zero minimal winning coalitions. Correctness of the algorithm follows from our discussion above. We will now\nAlgorithm 3 An enumeration algorithm for the class of n player canonical weighted voting games. hopskipjump refers to the Hop-Skip-and-Jump algorithm.\n1: Output [1; 0, . . . , 0] 2: games[0] := {\u2205} 3: for i := 1 to ( n bn/2c ) do 4: for all Wmin \u2208 games[i\u2212 1] do 5: {Obtain the maximal losing coalitions:} 6: Lmax := hopskipjump(Wmin) 7: for all C \u2208 Lmax do 8: for j := 0 to n do 9: if isweighted(Wmin \u222a rtrunc(C, j)) then\n10: if Wmin\u222a rtrunc(C, j) passes the duplicates check (see discussion above) then 11: Output a weighted representation of the voting game with minimal winning coalitions Wmin \u222a rtrunc(C, j)). 12: Append Wmin \u222a rtrunc(C, j)) to games[i]. 13: end if 14: end if 15: end for 16: end for 17: end for 18: end for\nanalyze the time-complexity of the algorithm.\nTheorem 8. Algorithm 3 runs in O\u2217(2n 2+2n) time.\nProof. Lines 5 to 16 are executed at most once for every canonical weighted voting game. From Sperner\u2019s theorem, we know that any list of minimal winning coalitions has fewer than ( n bn/2c ) elements. So by the runtime of the\nHop-Skip-and-Jump algorithm, line 6 runs in time O ( n (\nn bn/2c\n)2 + n3 ( n bn/2c )) =\nO(n2 \u221a n22n). Within an iteration of the outer loop (line 4), lines 9 to 14 are executed at most n (\nn bn/2c\n) = O( \u221a n2n) times (because Lmax is also an an-\ntichain, Sperner\u2019s theorem also applies for maximal losing coalitions). The time-complexity of one execution of lines 9 to 14 is as follows.\n\u2022 At line 9, we must solve a linear program, taking time O ( n4.5 ( n bn/2c )) =\nO(n42n) using Karmarkar\u2019s interior point algorithm [32].\n\u2022 At line 10, we must execute the duplicates check. This consists of checking for at most ( n bn/2c ) sets of minimal winning coalitions whether they\nare weighted. This involves running the Hop-Skip-and-Jump algorithm, followed by solving a linear program. In total, this takes O(n3 \u221a n22n) time.\n\u2022 Lines 11 and 12 take linear time.\nBringing everything together, we see that a single pass from lines 5 to 16 costs us O(n423n) time. As mentioned earlier, these lines are executed at most |Gcwvg(n)| times. We know that |Gwvg(n)| \u2208 O(2n\n2\u2212n) (from Corollary 2 in the previous section), and of course |Gcwvg(n)| < |Gwvg(n)|, hence lines 5 to 16 are executed at most O(2n 2\u2212n) times, and therefore the runtime of the algorithm is O(2n 2+2nn4) = O\u2217(2n 2+2n).\nAlthough the runtime analysis of this algorithm that we gave is not very precise, the main point of interest that we want to emphasize is that this method runs in exponential time, instead of doubly exponential time. We can also show that this algorithm runs in an amount of time that is only polynomially greater than the amount of data output. This implies that Algorithm 3 is essentially the fastest possible enumeration algorithm for canonical weighted voting games, up to a polynomial factor.\nTheorem 9. Algorithm 3 runs in output-polynomial time, i.e., a polynomial in the number of bits that Algorithm 3 outputs.\nProof. Lines 5 to 16 are executed less than |Gcwvg(n)| times. From (3), we have as a lower bound that |Gcwvg(n)| \u2208 \u2126(2n\n2(1\u2212 10log n )/n!2n). One execution of lines 5 to 16 costs O(n423n) time, and thus one iteration runs in\nO(n423n) \u2286 O ( 2n 2(1\u2212 10log n )/n!2n ) \u2286 O(|Gcwvg(n)|)\ntime. We conclude that the algorithm runs in O(|Gcwvg(n)|2) time.\nRemark 2. We can not give a very sharp bound on the space complexity of Algorithm 3, because we do not know anything about the maximum cardinality of an antichain in (Gcwvg(n), MWC). However, it can be seen that it is also possible to generate the games in this poset in a depth-first manner, instead of a breadth-first manner like we do now. In that case, the amount of space that needs to be used is bounded by the maximum length of a chain in (Gcwvg(n), MWC). This is a total amount of O( 2\nn \u221a n ) space.\nNow that we have this enumeration algorithm for weighted voting games, we can use the same approach as in algorithm 2 in order to solve the (f,Gcwvg,Lweights)-PVGD problem: for each game that is output, we simply compute the power index of that game and check if it is closer to the optimum than the best game we have found up until that point."}, {"heading": "5.3 Improvements and optimizations", "text": "Algorithm 3 is in its current state not that suitable for solving the (f,Gcwvg,Lweights)-PVGD problem in practice. In this section we will make several improvements to the algorithm. This results in a version of the enumeration algorithm of which we expect that it outputs canonical weighted voting games at a steady rate. We will see that this gives us a practically applicable anytime-algorithm for the (\u03b2,Gcwvg,Lweights)-PVGD problem for small numbers of players.\nSection 5.3.1 shows how we can make the system of linear inequalities (4) smaller. In Section 5.3.2, we will improve Theorem 7 in order to more quickly find new potential minimal winning coalitions to extend our weighted voting games with. Lastly, in Section 5.3.3 we give an output-polynomial time algorithm for enumerating all ceiling coalitions, given a set of roof coalitions.\nIt is important to note that these three improvements combined eliminate the need to generate the complete list of maximal losing coalitions of the weighted voting games that we enumerate. Instead, it suffices to only keep track of the sets of minimal winning coalitions and ceiling coalitions."}, {"heading": "5.3.1 An improved linear program for finding the weight vector of a weighted voting game", "text": "When finding a weight vector for a weighted voting game of which we obtained the minimal winning coalitions and maximal losing coalitions, we proposed in the previous section to do this by solving the system of inequalities (4). In [56] it is noted that we can make this system much more compact, as follows.\nFirst of all we can reduce the number of inequalities in our system by observing that a minimal winning coalition C which is not a roof, always has a higher total weight than at least one roof, in a canonical weighted voting game. This is because C is a superset of a left-shift of some roof. In the same way, a maximal losing coalition which is not a ceiling, always has a lower total weight than at least one ceiling. Therefore, adding the inequalities w1 \u2265 \u00b7 \u00b7 \u00b7 \u2265 wn to\nour system of inequalities (4) allows us to remove a lot of other inequalities from (4), because it now suffices to only make sure that out of all minimal winning coalitions, only the roofs have a higher weight than q; and out of all maximal losing coalitions, only the ceilings have a lower total weight than q.\nSecondly, we can reduce the number of variables (weights) in (4) by noting that if two players i and i+ 1 are equally desirable, then wi = wi+1. Therefore, we need only one representative variable from each set D of players for which it holds that that\n1. the players in D are pairwise equally desirable, and\n2. any player in N \\D is strictly less or strictly more desirable than a player in D.\nBy reducing the number of inequalities and variables in this way, we can in most cases drastically decrease the time it takes to find a solution to (4)."}, {"heading": "5.3.2 A better way of finding new minimal winning coalitions", "text": "Theorem 7 allows us to find potential minimal winning coalitions that we can extend our weighted voting games with. We will now see that we do not really need to consider every right-truncation of every maximal losing coalition: In fact, we only need to look at ceiling coalitions.\nTheorem 10. For any n, let G,G\u2032 \u2208 Gwvg(n) be a pair of weighted voting games such that G is covered by G\u2032 in (Gcwvg(n), MWC). Let Wmin,G and Wmin,G\u2032 be the sets of minimal winning coalitions of G and G\u2032 respectively, and let Lceil,G and Lceil,G\u2032 be the sets of ceiling coalitions of G and G\n\u2032 respectively. There is a C \u2208 Lceil,G and an i \u2208 N with 0 \u2264 i \u2264 n such that Wmin,G\u2032 = Wmin,G \u222a rtrunc(C, i).\nProof. Let Wmin,G and Wmin,G\u2032 be the sets of minimal winning coalitions of games G and G\u2032 respectively. Because G is covered by G\u2032, by definition there is a coalition C 6\u2208 Wmin,G such that Wmin,G\u2032 = Wmin,G \u222a C. By Theorem 7, C is a right-truncation of a coalition in Lmax,G. Suppose for contradiction that C is not a right-truncation of a ceiling in Lceil,G. Then there is a ceiling C\n\u2032 \u2208 Lceil,G such that C is a subset of a right-shift of C \u2032, and there is a left-shift C \u2032\u2032 of C, C \u2032\u2032 6= C, such that C \u2032\u2032 is also a subset of a right-shift of C \u2032. Coalition C \u2032\u2032 is not a superset of Wmin,G because C\n\u2032 is losing in G, and C \u2032\u2032 is not a superset of C either, because C \u2032\u2032 is a left-shift of C and is unequal to C. So it follows that C \u2032\u2032 is a losing coalition in G\u2032.\nBut G\u2032 is a canonical weighted voting game, so the desirability relation 1 D \u00b7 \u00b7 \u00b7 D n is satisfied. Because C \u2032\u2032 is a left-shift of C, and C is winning in G\u2032, it follows that C \u2032\u2032 is a winning coalition in G\u2032. This is a contradiction."}, {"heading": "5.3.3 An algorithm for obtaining the ceiling-list of a canonical weighted voting game", "text": "In Section 4.3.2, we derived that the (Lroof ,Lceil)-VGS problem does not have a polynomial time algorithm because the output may be exponentially sized in\nthe input. Moreover, as proved by Polyme\u0301ris and Riquelme [58], an outputpolynomial time algorithm for this problem would have sensational consequences, as it would imply a polynomial time algorithm for the monotone boolean duality problem [22]: a well-known problem that can be solved in subexponential time, of which it is not known whether it admits a polynomial time algorithm.\nFinding an output-polynomial algorithm for (Lroof ,Lceil)-VGS is thus a very interesting open problem, but due to its alleged difficulty8 we instead resort to studying the (LW,min,Lceil)-VGS problem.\nOf course, one could simply solve the latter problem by using the Hop-Skipand-Jump algorithm, described in Section 4.3.1. This would provide us with a list of MLCs of the input game, after which we could filter out the ceilings. This algorithm (i.e., filtering the shelters from the MWCs and running the Hop-Skipand-Jump algorithm on those shelters) would run in O(nm2+n3m) time, where m is the number of MWCs. Below, we will provide an alternative algorithm for the special case where we only need to output the ceilings of a given game. We will use in the remainder of this section some notions from Definition 22.\nTheorem 11. Let G \u2208 Gclin(n) be a canonical linear game on players N = {1, . . . , n}, let Wmin be the set of MWCs of G, let C be the set of ceilings of G, and let C \u2208 C such that a(C) > 0. Then there exists i \u2208 N\u22650, 1 < i \u2264 |C| \u2212 |trunc(C)|, such that trunc(C) \u222a {a(C)} \u222a {a(C) + j : 2 \u2264 j \u2264 i} is a minimal winning coalition.\nProof. C is losing, so trunc(C) is losing, and trunc(C)\u222a{b(C)}\u222a{b(C) + j : 2 \u2264 j \u2264 |C| \u2212 |trunc(C)|} is a left-shift of C, and hence winning. Therefore there exists i \u2208 N\u22650, 2 \u2264 i \u2264 |C| \u2212 |trunc(C)| such that\n\u2022 C \u2032 := trunc(C) \u222a {a(C)} \u222a {a(C) + j : 0 \u2264 j \u2264 i} is winning, and\n\u2022 (C \u2032\u2032 := trunc(C)\u222a{a(C)}\u222a{a(C)+j : 2 \u2264 j \u2264 i\u22121} is losing or C \u2032\u2032 = C \u2032).\nBy canonicity, this means that C \u2032 is a minimal winning coalition.\nFrom the above theorem it becomes clear how to generate efficiently the set of ceilings from the set of minimal winning coalitions: For each MWC S, it suffices to check for all k \u2208 N\u22650, k \u2264 n\u2212 b(S) whether:\n\u2022 (S\\{a(S) \u2212 1}) \u222a {a(S)} \u222a {b(S) + j : 1 \u2264 j \u2264 k} is a ceiling (in case a(S)\u2212 1 \u2208 S),\n\u2022 (S\\{b(S)}) \u222a {b(S) + j : 1 \u2264 j \u2264 k} is a ceiling.\nThis would generate all ceilings C with the property that b(C) > 0. There are furthermore at most n ceilings C for which it holds that b(C) = 0, and it is clear that such coalitions can be generated and checked straightforwardly.\n8We thank Andreas Polyme\u0301ris and Fabia\u0301n Riquelme for pointing out to us the connection to the monotone boolean duality problem, as well as for pointing out an error in a preliminary version of this papers.\nThe runtime of this implied algorithm is theoretically no better than the HopSkip-and-Jump algorithm. However, due to the simplicity of this algorithm, and due to the fact that this algorithm only finds the ceilings (of which there are in general much less than that there are MWCs), we expect this algorithm to run much faster in practice, in most cases."}, {"heading": "6 Experiments", "text": "Before we turn to the results of some relatively large scale experiments, let us visualize the results for just n = 3 players, because we can easily depict these in two dimensions. Figure 2 shows the 3-player simplex, with the vertices labeled by the player numbers. Because we focus on canonical weighted voting games, only the shaded part of the simplex contains games. These games are represented as dark dots. There are four dots, but, as we shall see, there are ten 3-player games. Two of these are degenerate, namely the game with no winning coalitions, and the game in which the empty set is the minimal winning coalition, so all coalitions are winning. Weighted representations for the other eight games are given on the right in the figure. There are only four distinct power indices corresponding to these games, they are indicated on the left.\nIn the remainder of this section, we will discuss the results obtained from some experiments that we have performed by implementing Algorithm 3, and the algorithm for (\u03b2,Gwvg,Lweights)-PVGD that directly follows from it (where \u03b2 denotes the normalized Banzhaf index). There are various reasons for performing these experiments: First of all, we are interested in running our algorithm for some small choices of n to see at what point our algorithm becomes intractable. A second goal of these experiments is to obtain some interesting statistics about the class of canonical weighted voting games (e.g., the number of weighted voting games on n players). Thirdly, it we are interested in obtaining some statistics on the average optimal attainable error on a random instance, when we let the\nalgorithm run to completion for small n. Lastly, we want to know about the error convergence rate of the algorithm for larger values of n, when solving the problem to optimality is intractable. More precisely, we want to gain insight in the following:\n\u2022 the practical time-performance of the algorithm (for small n);\n\u2022 the average optimal attainable error on random instances (for small n);\n\u2022 the error-convergence behaviour of the algorithm (for larger n, when it becomes intractable to run the algorithm to completion);\n\u2022 obtaining the exact number of weighted voting games of n players, in order to compare this to the theoretical bounds;\n\u2022 obtaining the number of weighted voting games for fixed numbers of players, as a function of the number of minimal winning coalitions.\nIn Section 6.1 we give some important information about the implementation of our algorithm. Section 6.2 describes our experiments. Lastly, in Section 6.3 we present the results of the experiments."}, {"heading": "6.1 Implementation details", "text": "We have implemented Algorithm 3 together with all of the optimization tricks described in Section 5.3. The programming language that we used is C.\nExecution of the algorithm encompasses solving a large number of linear programs. For doing this, we make use of the GNU Linear Programming Toolkit [46]. This is an open-source C library.\nAs said in the introduction of this section, our implementation solves the (\u03b2,Gwvg,Lweights)-PVGD problem, where \u03b2 is the normalized Banzhaf index. This means that for each weighted voting game that is output by our enumeration algorithm, we must invoke a procedure for computing the normalized Banzhaf index. The algorithm we use for this is simply the naive brute-force approach.\nTwo variants of the enumeration algorithm have been implemented: The first one uses the standard breadth-first approach, that sequentially generates all weighted voting games of i minimal winning coalitions, for increasing i. The second one uses the depth-first method mentioned in Remark 2 (in Section 5.2.3)."}, {"heading": "6.2 Experiments", "text": "We perform our experiments on a computer with an Intel Core2 Quad Q9300 2.50GHz CPU with 2GB SDRAM Memory. The operating system is Windows Vista. We compiled our source code using gcc 3.4.4, included in the DJGPP C/C++ Development System. We compiled our code with the \u2013O3 compiler flag.\nFor doing the experiments, we need input data: instances that we use as input for the algorithm. An instance is a target banzhaf index for a canonical weighted voting game, i.e., a point p in the unit simplex such that pi \u2265 pj if i < j, for all i, j between 1 and n. Our instances therefore consist of samples of such vectors that were taken uniformly at random. These samples are generated according to the procedure described in [62].\nThe experiments are as follows:\nExperiment 1: For up to 8 players, we measured the CPU time it takes for the enumeration algorithm to output all games, for both the breadth-first and the depth-first method. From these experiments we obtain the exact number of canonical weighted voting games of n players for all n between 1 and 8. We also measure the additional runtime that is necessary when we include the computation of the Banzhaf index in the algorithm.\nExperiment 2: We use the enumeration algorithm to compute for all n with 1 \u2264 n \u2264 8 and all m with 0 \u2264 m \u2264 ( n bn/2c ) , the exact number of canonical\nweighted voting games on n players with m minimal winning coalitions.\nExperiment 3: For n between 1 and 7, we compute for 1000 random instances the average optimal error. That is, the average error that is attained out of 1000 random instances (i.e., uniform random vectors in the (n \u2212 1)- dimensional unit-simplex), when the algorithm is allowed to run to completion on these instances. We also report the worst error that is attained among these 1000 instances. The error function we use is the square root of the sum of squared errors, as stated in Definition 17. The reason for using this specific error measure is because it has a nice geometric interpretation: it is the Euclidean distance between the target (input) vector and the closest point in the unit simplex that is a normalized Banzhaf index of a weighted voting game.\nExperiment 4: For n \u2208 {10, 15, 20}, we measure the error-convergence behaviour of the algorithm: the Euclidean error as a function of the amount of time that the algorithm runs. We again do this experiment for both the breadth-first and the depth-first version of the algorithm. For each of these three choices of n, we perform this experiment for 10 random instances, and for each instance we allow the algorithm to run for one minute."}, {"heading": "6.3 Results", "text": "For Experiment 1, the runtimes are given in Figure 3. From the graph we see that for all four versions of the algorithm, there is relatively not much difference in the runtimes. This means that the inclusion of the Banzhaf index computation procedure does not add a significant amount of additional runtime. Nonetheless, one should not forget that these results are displayed on a logarithmic scale. When we compare the runtimes for 8 players with each\nother for example, we see that the runtime of the depth-first search version without Banzhaf index computation is 21 minutes, while it is 26 minutes when we include the computation of the Banzhaf index into the algorithm. When we use the breadth-first search approach instead, the runtime is only 16 minutes. In general, the breadth-first search method is a lot faster than the depth-first search method.\nThe number of canonical weighted voting games on n players, for 1 \u2264 n \u2264 8, is displayed in Figure 4. Even for these small values of n, we can already clearly see the quadratic curve of the graph on this log-scale, just as the theoretical bounds from Section 4.1 predict. In Table 2, we state the exact numbers of canonical weighted voting games on n players as numbers, for 1 \u2264 n \u2264 8.\nFor Experiment 2, the results are displayed in Figure 5. Note that on the vertical axis we have again a log-scale. We see that for each of these choices of n, most of the canonical weighted voting games have a relatively low number of minimal winning coaltions relative to the maximum number of winning coalitions ( n bn/2c ) .\nThe Euclidean errors computed in Experiment 3 are displayed in Figure 6. We see that the errors decrease as n gets larger. We also see that the worst case optimal error can be much worse than the average case. We want to emphasize that these are results computed over only 1000 random instances. Therefore, these worst case optimal errors serve only as a lower bound for the worst case optimal error over all possible instances.\nFor Experiment 4, we see no possibility for a meaningful or interesting visualisation of its results. Experiment 4 confirms to us that this enumerationapproach of solving PVGD problems quickly becomes impractical as n gets larger. Our hopes were that the anytime-property of the algorithm would account for a quick convergence to a low (but not necessarily optimal) error; even for large values of n. It turns out that this is not the case. In all cases (i.e., for n = 10, n = 15 and n = 20, for all of the 10 random instances), the errorconvergence is high during approximately the first second that the algorithm runs. After that, the frequency by which improvements in the error occur, seems to decrease exponentially. Moreover, it holds without exception that after the first second, the improvements are only tiny. The average euclidean errors obtained after letting the algorithm run for one minute are as follows:\n\u2022 For n = 10, after one minute, the average euclidean error over the 10 instances was 0.055234 for the breadth-first variant, and 0.1705204 for the depth-first variant.\n\u2022 For n = 15, after one minute, the average euclidean error over the 10 instances was 0.0983193 for the breadth-first variant, and 0.2018266 for the depth-first variant.\n\u2022 For n = 20, after one minute, the average euclidean error over the 10 instances was 0.1475115 for the breadth-first variant, and 0.2399217 for the depth-first variant.\nFrom this, we see that for n = 10, the breadth-first search method still gives us reasonably nice results within a minute, but when we increase the number of players to 15 and 20, we see that the results quickly get worse. Especially when we compare the results to the expected average optimal error (that we obtain by extrapolation of the results of Experiment 3).\nAnother interesting observation is that these errors for the depth-first variant are much worse than the errors for the breadth-first variant. An explanation for this is that the Banzhaf indices of the generated games are scattered more evenly across the unit simplex in the case of the breadth-first variant: We expect the depth-first variant to enumerate a lot of games for which the Banzhaf indices are close to each other, due to the cover relation of (Gcwvg(n), MWC).\nA final comment we would like to make is that when n gets larger, the output rate of the enumeration algorithm goes down. Of course, this is explained by the fact that many of the operations in the algorithm must now be performed on games with more players. Especially this slowdown is caused by the computation of the Banzhaf index that is done for every game. In our current implementation, computing the Banzhaf index takes time exponential in n.\nIn general, our current implementation is crude: many procedures in this implementation are still far from optimal. We expect that it is possible to attain a significant improvement in the performance of this algorithm by optimizing the code."}, {"heading": "7 Conclusions & future work", "text": "In this paper, we have derived an exact algorithm for solving power index weighted voting game design problems. We have shown that such a problem is always solvable for any class of games, but the guarantee on the worst-case runtime that we can give is unfortunately only doubly exponential. For the important case of weighted voting games, we have derived an anytime method that runs in exponential time, and we have developed various additional techniques that we can use to speed this algorithm up.\nThis algorithm is based on an enumeration procedure for the class of weighted voting games: it works by simply enumerating every game, and verifying for each game whether it lies closer to the target power index than the games that we encountered up until that point. For this reason, the algorithm has the anytime-property: as we run this algorithm for a longer period of time, the algorithm enumerates more games, and the quality of the solution will improve.\nAlso, due to the genericity of enumeration, we can use our algorithm not only to solve power index voting game design problems: we can use it to solve any other voting game design problem as well. The only thing we have to adapt is the error-function of the algorithm (i.e., the part of the algorithm that checks the property in question for each of the games that the enumeration procedure outputs); the enumeration procedure does not need to be changed.\nFinally, we implemented a simple, non-optimized version of the algorithm in order to do some experiments and obtain some statistical information about the class of weighted voting games. We have computed some exact values for the number of canonical weighted voting games on n players with m minimal winning coalitions, for small choices of n, and every m. We have seen that even for small n, it is already obvious from the experimental results that the number of weighted voting games grows quadratically on an exponential scale, precisely according to the known asymptotic bounds.\nWe measured the runtime of the algorithm, and observed that running the algorithm to completion becomes intractable at approximately n = 10 (on the computer that we performed the experiments with, we estimate that it takes a month to run the algorithm to completion for n = 9). Lastly, for larger values of n, our algorithm (or at least our current implementation) is of little use for practical purposes because the error does not converge as quickly as we would want to. We think that we can attain a significant speedup by optimizing the code, and by using better linear programming software.\nNote that in most real-life examples, the number of players in a weighted voting game is rather small: usually 10 to 50 players are involved. For future work, the goal is to get this algorithm to yield good results within a reasonable amount of time when the number of players is somewhere in this range. It would already be interesting to be able to solve the problem for ten players, as we are not aware of any enumerations of ten player canonical weighted voting games. However, we concluded that the current implementation of the algorithm is not yet fast enough to be able to handle ten players. Optimistic extrapolation tells us that this would take tens of years; pessimistic extrapolation gives us\nthousands of years. However, the current implementation is not really efficient, and we have hope that with some future insights, together with careful computer programming, enumerating weighted voting games for ten players or more will be within scope.\nWe think that it will be interesting to study in more depth the partial order we introduced in this paper, both from a from a computational perspective and from a purely mathematical perspective. One possible prospect is the following. With regard to weighted voting game design problems, we suspect that it is possible to prune a lot of \u201careas\u201d in this partial order: Careful analysis of the partial order and its properties might lead to results that allow us to construct an enumeration algorithm that a priori discards certain (hopefully large) subsets of weighted voting games.\nWe are moreover interested to see how an algorithm performs that searches through the partial order in a greedy manner, or what will happen if we use some other (possibly heuristic) more intelligent methods to search through the partial order. We wonder if it is possible to use such a search method while still having an optimality guarantee or approximation guarantee on the quality of the solution. Lastly, we can also consider the ideas presented here as a postprocessing step to existing algorithms. In other words, it might be a good idea to first run the algorithm of [20] or [5] in order to obtain a good initial game. Subsequently, we can try to search through the \u201cneighborhood\u201d of the game to find improvements, according to the partial order introduced in this paper, .\nLastly, some related questions for which it would be interesting to obtain an answer are about the computational complexity of the power index voting game design problem, and also about the polynomial-time-approximability of the problem. It is quite straightforward to see that the decision version of this problem is in most cases in NP#P (and therefore in PSPACE), as one could nondeterministically guess a weight vector, and subsequently use a #P-oracle to obtain the particular power index of interest.9 On the other hand, at the moment we do not have any ideas on how to prove hardness for this problem for any complexity class whatsoever. It seems a challenge to come up with a polynomial-time reduction from any known computational problem that is hard for any nontrivial complexity class. Also, on questions related to approximability of PVGD problems we currently do not have an answer.\nAcknowledgements We thank Fabia\u0301n Riquelme and Andreas Polyme\u0301ris for pointing out a problem in a preliminary version of this paper (See Section 5.3.3)."}], "references": [{"title": "Computing power indices in weighted multiple majority games", "author": ["E. Algaba", "J.M. Bilbao", "J.R. Fern\u00e1ndez Gar\u0107\u0131a", "J.J. L\u00f3pez"], "venue": "Mathematical 9All power indices that have been proposed and that we have encountered are known to be in #P 56  Social Sciences, 46:63\u201380,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2003}, {"title": "The inverse Banzhaf problem", "author": ["N. Alon", "P.H. Edelman"], "venue": "Social Choice and Welfare, June", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "Voting power and power index website: a voting power WWWresource including powerslave voting body analyser", "author": ["P. Antti"], "venue": "WWW, april", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2002}, {"title": "Complexity of comparison of influence of players in simple games", "author": ["H. Aziz"], "venue": "Proceedings of the 2nd International Workshop on Computational Social Choice (COMSOC-2008), pages 61\u201372,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "Efficient algorithm for designing weighted voting games", "author": ["H. Aziz", "M. Paterson", "D. Leech"], "venue": "Proceedings IEEE International Multitopic Conference,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2007}, {"title": "Approximating power indices", "author": ["Y. Bachrach", "V. Markakis", "A.D. Procaccia", "J.S. Rosenschein", "A. Saberi"], "venue": "Proceedings of The Seventh International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2008), pages 943\u2013950,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2008}, {"title": "Computing the Banzhaf power index in network flow games", "author": ["Y. Bachrach", "J.S. Rosenschein"], "venue": "AAMAS \u201907: Proceedings of the 6th international joint conference on Autonomous agents and multiagent systems, pages 1\u20137, New York, NY, USA,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Power and stability in connectivity games", "author": ["Y. Bachrach", "J.S. Rosenschein"], "venue": "Proceedings AAMAS 2008,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2008}, {"title": "Generating functions for computing power indices efficiently", "author": ["J. Bilbao", "J. Fern\u00e1ndez", "A. Losada", "J. L\u00f3pez"], "venue": "TOP: An Official Journal of the Spanish Society of Statistics and Operations Research, 8(2):191\u2013213, December", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2000}, {"title": "Power and size: a new paradox", "author": ["S.F. Brams", "P.J. Affuso"], "venue": "Theory and Decision, 7:29\u201356,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1976}, {"title": "Nearly optimal solutions for the chow parameters problem and low-weight approximation of halfspaces", "author": ["A. De", "I. Diakonikolas", "V. Feldman", "R.A. Servedio"], "venue": "Proceedings of the 44th symposium on Theory of Computing, pages 729\u2013746. ACM,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "The inverse shapley value problem", "author": ["A. De", "I. Diakonikolasand", "R. Servedio"], "venue": "A. Czumaj, K. Mehlhorn, A. Pitts, and R. Wattenhofer, editors, Automata, Languages, and Programming, volume 7391 of Lecture Notes in Computer Science, pages 266\u2013277. Springer Berlin Heidelberg,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "On the design and synthesis of voting games : exact solutions for the inverse problem", "author": ["B. de Keijzer"], "venue": "Master\u2019s thesis, Delft University of Technology,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "Enumeration and exact design of weighted voting games", "author": ["B. de Keijzer", "T. Klos", "Y. Zhang"], "venue": "In Proceedings of the 9th International Conference on Autonomous Agents and Multiagent Systems,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "\u00dcber Zerlegungen von Zahlen durch ihre gr\u00f6ssten gemeinsammen Teiler", "author": ["R. Dedekind"], "venue": "Gesammelte Werke, 1:103\u2013148,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1897}, {"title": "On the complexity of cooperative solution concepts", "author": ["X. Deng", "C.H. Papadimitriou"], "venue": "Math. Oper. Res., 19(2):257\u2013266,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1994}, {"title": "The desirability relation of simple games", "author": ["E. Einy"], "venue": "Mathematical Social Sciences, 10(2):155\u2013168,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1985}, {"title": "The complexity of power-index comparison", "author": ["P. Faliszewski", "L. Hemaspaandra"], "venue": "In Proceedings of the 4th International Conference on Algorithmic Aspects in Information and Management, pages 177\u2013187. Springer- Verlag Lecture Notes in Computer Science, june", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "A randomized method for the Shapley value for the voting game", "author": ["S.S. Fatima", "M. Wooldridge", "N.R. Jennings"], "venue": "Proceedings of the Sixth International Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS 2007), pages 955\u2013962, Honolulu, Hawaii, May", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2007}, {"title": "An anytime approximation method for the inverse Shapley value problem", "author": ["S.S. Fatima", "M. Wooldridge", "N.R. Jennings"], "venue": "Proceedings of the Seventh International Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS 2008), pages 935\u2013942, Estoril, Portugal, May", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2008}, {"title": "A linear approximation method for the Shapley value", "author": ["S.S. Fatima", "M. Wooldridge", "N.R. Jennings"], "venue": "Artificial Intelligence, 172(14):1673\u20131699,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2008}, {"title": "On the complexity of dualization of monotone disjunctive normal forms", "author": ["M.L. Fredman", "L. Khachiyan"], "venue": "Journal of Algorithms, 21(3):618\u2013628,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1996}, {"title": "On minimal integer representations of weighted games", "author": ["J. Freixas", "S. Kurz"], "venue": "CoRR, abs/1303.0868,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "Enumeration of weighted games with minimum and an analysis of voting power for bipartite complete games with minimum", "author": ["J. Freixas", "S. Kurz"], "venue": "Annals of Operations Research, pages 1\u201323,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2013}, {"title": "The golden number and fibonacci sequences in the design of voting structures", "author": ["J. Freixas", "S. Kurz"], "venue": "European Journal of Operational Research, 226(2):246\u2013257,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Weighted games without a unique minimal representation in integers", "author": ["J. Freixas", "X. Molinero"], "venue": "Optimization Methods and Software, 25(2):203\u2013 215,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2010}, {"title": "The complexity of testing properties of simple games", "author": ["J. Freixas", "X. Molinero", "M. Olsen", "M.J. Serna"], "venue": "CoRR, abs/0803.0404,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "Complete voting systems with two classes of voters: weightedness and counting", "author": ["J. Freixas", "X. Molinero", "S. Roura"], "venue": "Annals OR, 193(1):273\u2013289,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2012}, {"title": "The greatest allowed relative error in weights and threshold of strict separating systems", "author": ["Josep Freixas", "Xavier Molinero"], "venue": "IEEE Transactions on Neural Networks,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "Threshold logic", "author": ["S.T. Hu"], "venue": "University of California Press,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1965}, {"title": "A class of simple games", "author": ["J.R. Isbell"], "venue": "Duke Mathematical Journal, 25(3):423\u2013439,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1958}, {"title": "A new polynomial-time algorithm for linear programming", "author": ["N. Karmarkar"], "venue": "STOC \u201984: Proceedings of the sixteenth annual ACM symposium on Theory of computing, pages 302\u2013311, New York, NY, USA,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1984}, {"title": "A survey on the computation of power indices", "author": ["B. de Keijzer"], "venue": "Technical report, Delft University of Technology,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2009}, {"title": "On Dedekind\u2019s problem: The number of isotone boolean functions II", "author": ["D. Kleitman", "M. Markowski"], "venue": "Transactions of the American Mathematical Society, volume 213, pages 373\u2013390,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1975}, {"title": "Faster algorithms for computing power indices in weighted voting games", "author": ["B. Klinz", "G.J. Woeginger"], "venue": "Mathematical Social Sciences, 49:111\u2013 116,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2005}, {"title": "Monotone boolean functions", "author": ["A.D. Korshunov"], "venue": "Russian Mathematical Surveys, 58(5(353)):198\u2013162,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2003}, {"title": "Directed and weighted majority games", "author": ["I. Krohn", "P. Sudh\u00f6lter"], "venue": "Mathematical Methods of Operations Research, 42(2):189\u2013216,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 1995}, {"title": "On minimum sum representations for weighted voting games", "author": ["S. Kurz"], "venue": "CoRR, abs/1103.1445,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2011}, {"title": "On the inverse power index problem", "author": ["S. Kurz"], "venue": "Optimization,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2012}, {"title": "Is the allocation of voting power among EU states fair", "author": ["A. Laruelle", "M. Widgr\u00e9n"], "venue": "Public Choice,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1998}, {"title": "Computation of power indices", "author": ["D. Leech"], "venue": "Technical Report 664, Warwick Economic Research Papers, July", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2002}, {"title": "Designing the voting system for the EU council of ministers", "author": ["D. Leech"], "venue": "Public Choice, 113(3\u20134):437\u2013464, December", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2002}, {"title": "Voting power in the governance of the international monetary fund", "author": ["D. Leech"], "venue": "Annals of Operations Research, vol.109, Special Issue on Game Practice:373\u2013395,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2002}, {"title": "Computing power indices for large voting games", "author": ["D. Leech"], "venue": "Management Science, 49(6):831\u2013838, June", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2003}, {"title": "Power indices as an aid to institutional design: the generalised apportionment problem", "author": ["D. Leech"], "venue": "M. Holler, H. Kliemt, D. Schmidtchen, and M. Streit, editors, Yearbook on New Political Economy. Warwick Economic Research Papers,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2003}, {"title": "Values of large games, VI: Evaluating the electoral college exactly", "author": ["I. Mann", "L.S. Shapley"], "venue": "Technical Report RM-3158-PR, The RAND Corporation,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 1962}, {"title": "A survey of algorithms for calculating power indices of weighted majority games", "author": ["Y. Matsui", "T. Matsui"], "venue": "J. Oper. Res. Soc. Japan, 43:71\u201386,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2000}, {"title": "NP-completeness for calculating power indices of weighted majority games", "author": ["Y. Matsui", "T. Matsui"], "venue": "Theoretical Computer Science, 263(1\u20132):305\u2013 310,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2001}, {"title": "Threshold logic and its applications", "author": ["S. Muroga"], "venue": "Wiley-Interscience,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 1971}, {"title": "Majority functions of up to six variables", "author": ["S. Muroga", "I. Toda", "M. Kondo"], "venue": "Mathematics of Computation, 60(80):459\u2013472, October", "citeRegEx": "51", "shortCiteRegEx": null, "year": 1962}, {"title": "Enumeration of threshold functions of eight variables", "author": ["S. Muroga", "T. Tsuboi", "C.R. Baugh"], "venue": "IEEE Transactions on Computers, C-19(9):818\u2013 825, September", "citeRegEx": "52", "shortCiteRegEx": null, "year": 1970}, {"title": "On the unimodularity of some partition polynomials", "author": ["A.M. Odlyzko", "L.B. Richmond"], "venue": "European Journal of Combinatorics, 3:69\u201384,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 1982}, {"title": "The chow parameters problem", "author": ["R. O\u2019Donnel", "R.A. Servedio"], "venue": "SIAM Journal on Computing,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2011}, {"title": "Circuit complexity and neural networks", "author": ["I. Parberry"], "venue": "Foundations of Computing Series. Mit Press,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 1994}, {"title": "Polynomial-time algorithms for regular setcovering and threshold synthesis", "author": ["U.M. Peled", "B. Simeone"], "venue": "Discrete Applied Mathematics, 12:57\u201369,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 1985}, {"title": "Introduction to the Theory of Cooperative Games", "author": ["B. Peleg", "P. Sudh\u00f6lter"], "venue": "Springer,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2003}, {"title": "On the complexity of the decisive problem in simple, regular and weighted games", "author": ["A. Polym\u00e9ris", "F. Riquelme"], "venue": "CoRR, abs/1303.7122,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2013}, {"title": "NP-completeness of some problems concerning voting games", "author": ["K. Prasad", "J.S. Kelly"], "venue": "International Journal of Game Theory, 19(1):1\u20139,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 1990}, {"title": "A method for evaluating the distribution of power in a committee system", "author": ["L.S. Shapley", "M. Shubik"], "venue": "American Political Science Review, 48(3):787\u2013792,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 1954}, {"title": "Discrete Neural Computation: A Theoretical Foundation", "author": ["K.Y. Siu", "V.P. Roychowdhury", "T. Kailath"], "venue": "Prentice Hall Information & System Sciences Series. Prentice Hall,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 1995}, {"title": "Sampling uniformly from the unit simplex", "author": ["N.A. Smith", "N.W. Tromble"], "venue": "Technical report, John Hopkins University,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2004}, {"title": "Ein Satz \u00fcber Untermengen einer endlichen Menge", "author": ["E. Sperner"], "venue": "Mathematische Zeitschrift, 27(1):544\u2013548, December", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1928}, {"title": "Weyl groups, the hard Lefschetz theorem, and the Sperner property", "author": ["R.P. Stanley"], "venue": "SIAM J. Algebraic Discrete Methods, 1:168\u2013184,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 1980}, {"title": "Fair allocation and re-weighting of votes and voting power in the EU before and after the next enlargement", "author": ["M. Sutter"], "venue": "Journal of Theoretical Politics, 12:433\u2013449,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2000}, {"title": "Simple Games: Desirability Relations, Trading, Pseudoweightings", "author": ["A.D. Taylor", "W.S. Zwicker"], "venue": "Princeton University Press,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 1999}, {"title": "Efficient computation of power indices for weighted majority games", "author": ["T. Uno"], "venue": "Technical Report NII-2003-006E, National Institute of Informatics,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2003}, {"title": "Enumeration of seven-argument threshold functions", "author": ["R.O. Winder"], "venue": "IEEE Transactions on Electronic Computers, EC-14(3):315\u2013325, June", "citeRegEx": "68", "shortCiteRegEx": null, "year": 1965}, {"title": "Asymptotics of the logarithm of the number of threshold functions of the algebra of logic", "author": ["Y.A. Zuev"], "venue": "Soviet Math. Dokl., 39:512\u2013513,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 1989}, {"title": "On encoding and enumerating threshold functions", "author": ["J. \u017duni\u0107"], "venue": "IEEE Transactions on Neural Networks, 15(2):261\u2013267, march", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2004}], "referenceMentions": [{"referenceID": 19, "context": "Two of the proposed algorithms (see [20, 5]) are local search", "startOffset": 36, "endOffset": 43}, {"referenceID": 4, "context": "Two of the proposed algorithms (see [20, 5]) are local search", "startOffset": 36, "endOffset": 43}, {"referenceID": 38, "context": "There is one other paper by Kurz [39] that proposes a method for finding an exact algorithm.", "startOffset": 33, "endOffset": 37}, {"referenceID": 38, "context": "The work we present here is independent from [39], and differs from it in the sense that we put more emphasis on run-time analysis and giving proofs of various desirable properties of our algorithm.", "startOffset": 45, "endOffset": 49}, {"referenceID": 38, "context": "Moreover, our approach is vastly different from the approach of [39], and the theory behind our algorithm is of independent interest.", "startOffset": 64, "endOffset": 68}, {"referenceID": 12, "context": "This paper is based on the master\u2019s thesis of De Keijzer [13]; one of the authors of this manuscript.", "startOffset": 57, "endOffset": 61}, {"referenceID": 13, "context": "A shorter discussion of this work has also appeared [14].", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "We present and discuss the results of [13], and remove various redundancies, imprecisions, typos, and mistakes that were present in [13].", "startOffset": 38, "endOffset": 42}, {"referenceID": 12, "context": "We present and discuss the results of [13], and remove various redundancies, imprecisions, typos, and mistakes that were present in [13].", "startOffset": 132, "endOffset": 136}, {"referenceID": 64, "context": "1The roof-representation is also known as the shift-minimal winning coalition representation [66].", "startOffset": 93, "endOffset": 97}, {"referenceID": 19, "context": "[20], where the authors present an algorithm for the inverse problem with the Shapley-Shubik index [60] as the power index of choice.", "startOffset": 0, "endOffset": 4}, {"referenceID": 58, "context": "[20], where the authors present an algorithm for the inverse problem with the Shapley-Shubik index [60] as the power index of choice.", "startOffset": 99, "endOffset": 103}, {"referenceID": 18, "context": "The Shapley-Shubik index is computed using a linear time randomized approximation algorithm, proposed in [19, 21] by the same authors.", "startOffset": 105, "endOffset": 113}, {"referenceID": 20, "context": "The Shapley-Shubik index is computed using a linear time randomized approximation algorithm, proposed in [19, 21] by the same authors.", "startOffset": 105, "endOffset": 113}, {"referenceID": 4, "context": "[5] for the inverse problem with the Banzhaf index as the power index of choice.", "startOffset": 0, "endOffset": 3}, {"referenceID": 19, "context": "The algorithm the authors present here resembles that of [20], in that the algorithm repeatedly updates the weight vector in order to get closer to the target power index.", "startOffset": 57, "endOffset": 61}, {"referenceID": 8, "context": "For computing the Banzhaf index, the generating function method is used [9, 47, 10].", "startOffset": 72, "endOffset": 83}, {"referenceID": 45, "context": "For computing the Banzhaf index, the generating function method is used [9, 47, 10].", "startOffset": 72, "endOffset": 83}, {"referenceID": 9, "context": "For computing the Banzhaf index, the generating function method is used [9, 47, 10].", "startOffset": 72, "endOffset": 83}, {"referenceID": 19, "context": "Therefore, the output of the algorithm is always an integer weighted representation (contrary to the method in [20] for which the output may have rational weights).", "startOffset": 111, "endOffset": 115}, {"referenceID": 40, "context": "Leech proposes in [41, 45] an approach that largely resembles the method of Aziz et al.", "startOffset": 18, "endOffset": 26}, {"referenceID": 44, "context": "Leech proposes in [41, 45] an approach that largely resembles the method of Aziz et al.", "startOffset": 18, "endOffset": 26}, {"referenceID": 41, "context": "The focus in this paper is on the results that are obtained after applying the method to the 15-member EU council (also see [42]), and to the board of governors of the International Monetary Fund.", "startOffset": 124, "endOffset": 128}, {"referenceID": 38, "context": "One is by Kurz [39].", "startOffset": 15, "endOffset": 19}, {"referenceID": 38, "context": "As mentioned in Section 1, our work is independent and differs from [39] because we are interested in devising an algorithm with a provably good runtime.", "startOffset": 68, "endOffset": 72}, {"referenceID": 38, "context": "we take is different from that of [39], and the theory necessary to develop our algorithm can be considered interesting in itself.", "startOffset": 34, "endOffset": 38}, {"referenceID": 12, "context": "Kurz moreover correctly points out that in the master\u2019s thesis of De Keijzer [13] (on which the present paper is based) the numbers of canonical weighted voting games for 6, 7, and 8 players are wrongly stated.", "startOffset": 77, "endOffset": 81}, {"referenceID": 37, "context": "In this paper, we correct this mistake and report the numbers of canonical weighted voting games correctly, although these numbers are already known by now due to the recent paper [38], also by Kurz (see below).", "startOffset": 180, "endOffset": 184}, {"referenceID": 11, "context": "The other recent work is [12], by De et al.", "startOffset": 25, "endOffset": 29}, {"referenceID": 52, "context": "Closely related to our work are two papers that deal with the Chow parameters problem [54, 11].", "startOffset": 86, "endOffset": 94}, {"referenceID": 10, "context": "Closely related to our work are two papers that deal with the Chow parameters problem [54, 11].", "startOffset": 86, "endOffset": 94}, {"referenceID": 37, "context": "This enumeration problem has been studied before in a paper by Kurz [38], where the author uses integer programming techniques in order to enumerate all canonical weighted voting games on up to nine players.", "startOffset": 68, "endOffset": 72}, {"referenceID": 36, "context": "In [37], Krohn and Sudh\u00f6lter study the enumeration of canonical linear games and a subclass thereof, using various order theoretic concepts.", "startOffset": 3, "endOffset": 7}, {"referenceID": 36, "context": "However, there are some connections between our work and [37]: their enumeration procedures work by exploiting graded posets, just like ours; although the posets in question there are the subsets winning coalitions together with the set inclusion relation (for the case of decisive canonical linear games, they use a variant of this poset), and not on the subsets of minimal winning coalitions.", "startOffset": 57, "endOffset": 61}, {"referenceID": 29, "context": "Threshold functions [30, 50] are of fundamental research interest in voting games, circuit complexity and neural networks.", "startOffset": 20, "endOffset": 28}, {"referenceID": 48, "context": "Threshold functions [30, 50] are of fundamental research interest in voting games, circuit complexity and neural networks.", "startOffset": 20, "endOffset": 28}, {"referenceID": 53, "context": "The problem of realizing Boolean threshold functions by neural networks has been extensively studied [55, 61, 29], where upper and lower bounds are derived on the synaptic weights for such realization.", "startOffset": 101, "endOffset": 113}, {"referenceID": 59, "context": "The problem of realizing Boolean threshold functions by neural networks has been extensively studied [55, 61, 29], where upper and lower bounds are derived on the synaptic weights for such realization.", "startOffset": 101, "endOffset": 113}, {"referenceID": 28, "context": "The problem of realizing Boolean threshold functions by neural networks has been extensively studied [55, 61, 29], where upper and lower bounds are derived on the synaptic weights for such realization.", "startOffset": 101, "endOffset": 113}, {"referenceID": 49, "context": "The enumeration of threshold functions up to six variables has been done in [51].", "startOffset": 76, "endOffset": 80}, {"referenceID": 66, "context": "Subsequently, in [68, 52], all threshold functions of respectively seven and eight variables were enumerated.", "startOffset": 17, "endOffset": 25}, {"referenceID": 50, "context": "Subsequently, in [68, 52], all threshold functions of respectively seven and eight variables were enumerated.", "startOffset": 17, "endOffset": 25}, {"referenceID": 36, "context": "Krohn and Sudh\u00f6lter [37] enumerated the canonical weighted voting games up to eight players, as well as the class of canonical linear games.", "startOffset": 20, "endOffset": 24}, {"referenceID": 37, "context": "Kurz [38] was the first to enumerate all nine player canonical weighted voting games, and Freixas and Molinero [26] were the first to enumerate all nine player canonical linear games.", "startOffset": 5, "endOffset": 9}, {"referenceID": 25, "context": "Kurz [38] was the first to enumerate all nine player canonical weighted voting games, and Freixas and Molinero [26] were the first to enumerate all nine player canonical linear games.", "startOffset": 111, "endOffset": 115}, {"referenceID": 27, "context": "There exists some litature on enumeration of special subclasses of voting games as well: see [28] for linear games with two desirability classes; [24] for weighted voting games with one roof; and [25] for linear games with certain special types of voters and few desirability classes.", "startOffset": 93, "endOffset": 97}, {"referenceID": 23, "context": "There exists some litature on enumeration of special subclasses of voting games as well: see [28] for linear games with two desirability classes; [24] for weighted voting games with one roof; and [25] for linear games with certain special types of voters and few desirability classes.", "startOffset": 146, "endOffset": 150}, {"referenceID": 24, "context": "There exists some litature on enumeration of special subclasses of voting games as well: see [28] for linear games with two desirability classes; [24] for weighted voting games with one roof; and [25] for linear games with certain special types of voters and few desirability classes.", "startOffset": 196, "endOffset": 200}, {"referenceID": 0, "context": ", there is a need for information about the distribution of power indices in [0, 1].", "startOffset": 77, "endOffset": 83}, {"referenceID": 1, "context": "As a first step into solving this problem, they prove in [2] a specific result for the case of the Banzhaf index for monotonic simple games.", "startOffset": 57, "endOffset": 60}, {"referenceID": 39, "context": "In two papers, one by Laruelle and Widgr\u00e9n [40] and one by Sutter [65], the distribution of voting power in the European Union is analyzed and designed using iterative methods that resemble the algorithm of Aziz [5].", "startOffset": 43, "endOffset": 47}, {"referenceID": 63, "context": "In two papers, one by Laruelle and Widgr\u00e9n [40] and one by Sutter [65], the distribution of voting power in the European Union is analyzed and designed using iterative methods that resemble the algorithm of Aziz [5].", "startOffset": 66, "endOffset": 70}, {"referenceID": 4, "context": "In two papers, one by Laruelle and Widgr\u00e9n [40] and one by Sutter [65], the distribution of voting power in the European Union is analyzed and designed using iterative methods that resemble the algorithm of Aziz [5].", "startOffset": 212, "endOffset": 215}, {"referenceID": 41, "context": "Similar work was done by Leech for the EU [42], and for the IMF [43].", "startOffset": 42, "endOffset": 46}, {"referenceID": 42, "context": "Similar work was done by Leech for the EU [42], and for the IMF [43].", "startOffset": 64, "endOffset": 68}, {"referenceID": 48, "context": "Some classical relevant bounds can be found in [50], Section 9.", "startOffset": 47, "endOffset": 51}, {"referenceID": 22, "context": "See [23, 26] for some recent work in this direction.", "startOffset": 4, "endOffset": 12}, {"referenceID": 25, "context": "See [23, 26] for some recent work in this direction.", "startOffset": 4, "endOffset": 12}, {"referenceID": 55, "context": "A lot of the information in this section can be looked up in an introductory text on cooperative game theory, for example [57] or in Taylor and Zwicker\u2019s book on simple games [66].", "startOffset": 122, "endOffset": 126}, {"referenceID": 64, "context": "A lot of the information in this section can be looked up in an introductory text on cooperative game theory, for example [57] or in Taylor and Zwicker\u2019s book on simple games [66].", "startOffset": 175, "endOffset": 179}, {"referenceID": 3, "context": "Some of the definitions in the remainder of this section are taken or adapted from [4] and [66].", "startOffset": 83, "endOffset": 86}, {"referenceID": 64, "context": "Some of the definitions in the remainder of this section are taken or adapted from [4] and [66].", "startOffset": 91, "endOffset": 95}, {"referenceID": 30, "context": "For a monotonic simple game, it is possible to define a relation called the desirability relation on the players (see [31]):", "startOffset": 118, "endOffset": 122}, {"referenceID": 16, "context": "There exist other notions of desirability, for which different properties hold [17].", "startOffset": 79, "endOffset": 83}, {"referenceID": 54, "context": "The terminology (\u201croof\u201d and \u201cceiling\u201d) is taken from [56], although they have also been called shift-minimal winning coalitions and shift-maximal losing coalitions [66].", "startOffset": 53, "endOffset": 57}, {"referenceID": 64, "context": "The terminology (\u201croof\u201d and \u201cceiling\u201d) is taken from [56], although they have also been called shift-minimal winning coalitions and shift-maximal losing coalitions [66].", "startOffset": 164, "endOffset": 168}, {"referenceID": 2, "context": "We refer the reader to [3] for an excellent WWW information resource on power indices.", "startOffset": 23, "endOffset": 26}, {"referenceID": 47, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 46, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 17, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 6, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 7, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 0, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 34, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 8, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 65, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 5, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 43, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 40, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 32, "context": ", in [49, 48, 18, 7, 8, 1, 35, 9, 67, 6, 44, 41, 33]).", "startOffset": 5, "endOffset": 52}, {"referenceID": 32, "context": "For a survey of complexity results, exact algorithms and approximation algorithms for computing power indices, see [33].", "startOffset": 115, "endOffset": 119}, {"referenceID": 57, "context": "In general, computing power indices is a hard task, and the case of the normalized Banzhaf index is no exception: Computation of the raw Banzhaf index is known to be #Pcomplete [59], and the fastest known exponential time algorihm for computing the Banzhaf index is due to Klinz and Woeginger [35].", "startOffset": 177, "endOffset": 181}, {"referenceID": 34, "context": "In general, computing power indices is a hard task, and the case of the normalized Banzhaf index is no exception: Computation of the raw Banzhaf index is known to be #Pcomplete [59], and the fastest known exponential time algorihm for computing the Banzhaf index is due to Klinz and Woeginger [35].", "startOffset": 293, "endOffset": 297}, {"referenceID": 54, "context": "We call these problems voting game synthesis problems, inspired by the term threshold synthesis used in [56] for finding a weight vector for a so-called threshold function, to be defined later in this section.", "startOffset": 104, "endOffset": 108}, {"referenceID": 14, "context": "Dedekind\u2019s problem was first stated in [15].", "startOffset": 39, "endOffset": 43}, {"referenceID": 54, "context": "The prove that we give here is from [56]:", "startOffset": 36, "endOffset": 40}, {"referenceID": 62, "context": "It is shown in [64] that the sequence (|A1|, .", "startOffset": 15, "endOffset": 19}, {"referenceID": 51, "context": "It is shown in [53] that this middle coefficient is asymptotically equal to\u221a 2 3\u03c02 n", "startOffset": 15, "endOffset": 19}, {"referenceID": 48, "context": "Fortunately there is a closely related field of research, called threshold logic (see for example [50]), that has some relevant results.", "startOffset": 98, "endOffset": 102}, {"referenceID": 68, "context": "[70] gives an upper bound on the number of threshold functions of n variables |LT(n)|: |LT(n)| \u2264 2 2\u2212n+1.", "startOffset": 0, "endOffset": 4}, {"referenceID": 67, "context": "Also, the following asymptotic lower bound is known, as shown in [69]: For large enough n, we have |LT(n)| \u2265 2 (1\u2212 10 log n .", "startOffset": 65, "endOffset": 69}, {"referenceID": 54, "context": "This is a non-trivial result and was first stated in [56] by Peled and Simeone.", "startOffset": 53, "endOffset": 57}, {"referenceID": 54, "context": "In [56], the problem is stated in terms of set-covering problems.", "startOffset": 3, "endOffset": 7}, {"referenceID": 3, "context": "The first step of the algorithm is easy if we use an algorithm by Aziz, given in [4].", "startOffset": 81, "endOffset": 84}, {"referenceID": 31, "context": "Linear programs are solvable in a time that is polynomial in the size of the linear program, by Karmarkar\u2019s algorithm [32] for example.", "startOffset": 118, "endOffset": 122}, {"referenceID": 26, "context": "investigate in [27] the (L1,L2)-VGS problem for L1 and L2 \u2208 {LW ,LW,min,LL,LL,max}.", "startOffset": 15, "endOffset": 19}, {"referenceID": 26, "context": "In [27], it is also shown that (LW,max,LL,min)-VGS is in general not polynomial time solvable.", "startOffset": 3, "endOffset": 7}, {"referenceID": 33, "context": "The following bounds are known [34]:", "startOffset": 31, "endOffset": 35}, {"referenceID": 61, "context": "Sperner\u2019s theorem [63] tells us the following about En:", "startOffset": 18, "endOffset": 22}, {"referenceID": 3, "context": ", the Shapley-Shubik index and the Banzhaf index) ([4, 16, 59]).", "startOffset": 51, "endOffset": 62}, {"referenceID": 15, "context": ", the Shapley-Shubik index and the Banzhaf index) ([4, 16, 59]).", "startOffset": 51, "endOffset": 62}, {"referenceID": 57, "context": ", the Shapley-Shubik index and the Banzhaf index) ([4, 16, 59]).", "startOffset": 51, "endOffset": 62}, {"referenceID": 35, "context": "6Korshunov devised an asymptotically equal expression [36]:", "startOffset": 54, "endOffset": 58}, {"referenceID": 35, "context": "In [36], this expression is described as the number", "startOffset": 3, "endOffset": 7}, {"referenceID": 48, "context": "1 of [50] provides us with a solution to this problem, as it tells us that for every weighted voting game there exists an integer weighted representation where none of the weights nor the quota exceeds 2 .", "startOffset": 5, "endOffset": 9}, {"referenceID": 31, "context": "O(n2) using Karmarkar\u2019s interior point algorithm [32].", "startOffset": 49, "endOffset": 53}, {"referenceID": 54, "context": "In [56] it is noted that we can make this system much more compact, as follows.", "startOffset": 3, "endOffset": 7}, {"referenceID": 56, "context": "Moreover, as proved by Polym\u00e9ris and Riquelme [58], an outputpolynomial time algorithm for this problem would have sensational consequences, as it would imply a polynomial time algorithm for the monotone boolean duality problem [22]: a well-known problem that can be solved in subexponential time, of which it is not known whether it admits a polynomial time algorithm.", "startOffset": 46, "endOffset": 50}, {"referenceID": 21, "context": "Moreover, as proved by Polym\u00e9ris and Riquelme [58], an outputpolynomial time algorithm for this problem would have sensational consequences, as it would imply a polynomial time algorithm for the monotone boolean duality problem [22]: a well-known problem that can be solved in subexponential time, of which it is not known whether it admits a polynomial time algorithm.", "startOffset": 228, "endOffset": 232}, {"referenceID": 60, "context": "These samples are generated according to the procedure described in [62].", "startOffset": 68, "endOffset": 72}, {"referenceID": 19, "context": "In other words, it might be a good idea to first run the algorithm of [20] or [5] in order to obtain a good initial game.", "startOffset": 70, "endOffset": 74}, {"referenceID": 4, "context": "In other words, it might be a good idea to first run the algorithm of [20] or [5] in order to obtain a good initial game.", "startOffset": 78, "endOffset": 81}], "year": 2013, "abstractText": "We study the power index voting game design problem for weighted voting games: the problem of finding a weighted voting game in which the power of the players is as close as possible to a certain target distribution. Our goal is to find algorithms that solve this problem exactly. Thereto, we consider various subclasses of simple games, and their associated representation methods. We survey algorithms and impossibility results for the synthesis problem, i.e., converting a representation of a simple game into another representation. We contribute to the synthesis problem by showing that it is impossible to compute in polynomial time the list of ceiling coalitions (also known as shift-maximal losing coalitions) of a game from its list of roof coalitions (also known as shift-minimal winning coalitions), and vice versa. Then, we proceed by studying the problem of enumerating the set of weighted voting games. We present first a naive algorithm for this, running in doubly exponential time. Using our knowledge of the synthesis problem, we then improve on this naive algorithm, and we obtain an enumeration algorithm that runs in quadratic exponential time (that is, O(2 2 \u00b7 p(n)) for a polynomial p). Moreover, we show that this algorithm runs in output-polynomial time, making it the best possible enumeration algorithm up to a polynomial factor. Finally, we propose an exact anytime algorithm for the power index voting game design problem that runs in exponential time. This algorithm is straightforward and general: it computes the error for each game enumerated, and outputs the game that minimizes this error. By the genericity of our approach, our algorithm can be used to find a weighted voting game that optimizes any exponential time computable function. We implement our algorithm for the case of the normalized Banzhaf in\u2217Algorithms, Combinatorics and Optimization; Centrum Wiskunde & Informatica; The Netherlands; Email: keijzer@cwi.nl. \u2020Algorithmics; Delft University of Technology; The Netherlands; Email: T.B.Klos@tudelft.nl. \u2021Department of Econometrics; Erasmus University Rotterdam; The Netherlands; Email:", "creator": "LaTeX with hyperref package"}}}