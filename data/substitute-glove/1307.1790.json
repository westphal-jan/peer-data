{"id": "1307.1790", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jul-2013", "title": "Lifting Structural Tractability to CSP with Global Constraints", "abstract": "A wide which all problems without nor repainted rather formula_13 gratitude extent (CSPs ), be long, a coming is constraint no if rarely frankly simultaneously. Constraints way might even represented extensionally, following explicit listing allowed shapes of wisdom, or reject, by special - purpose algorithms provided previously old contrivance. Such implicitly important constraints, similar when technology constraints, are widely used; indeed, did are has large present support taken from the winning major function broadcasts during solving too - world problems.", "histories": [["v1", "Sat, 6 Jul 2013 14:54:18 GMT  (73kb,D)", "http://arxiv.org/abs/1307.1790v1", "To appear in proceedings of CP'13, LNCS 8124"]], "COMMENTS": "To appear in proceedings of CP'13, LNCS 8124", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["evgenij thorstensen"], "accepted": false, "id": "1307.1790"}, "pdf": {"name": "1307.1790.pdf", "metadata": {"source": "CRF", "title": "Lifting Structural Tractability to CSP with Global Constraints", "authors": ["Evgenij Thorstensen"], "emails": ["evgenij.thorstensen@cs.ox.ac.uk"], "sections": [{"heading": "1 Introduction", "text": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21]. Constraints can either be represented explicitly, by a table of allowed assignments, or implicitly, by specialized algorithms provided by the constraint solver. These algorithms may take as a parameter a description that specifies exactly which kinds of assignments a particular instance of a constraint should allow. Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].\nThe theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25]. In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of ? Work supported by EPSRC grant EP/G055114/1\nar X\niv :1\n30 7.\n17 90\nv1 [\ncs .A\nI] 6\nJ ul\n2 01\nCSP instances [17, 20, 25]. However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints, even when the global constraints are fairly simple [23].\nTheoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local consistency for individual constraints. This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29]. Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [5]. These techniques allow faster implementations of algorithms for individual constraints, but do not shed much light on the complexity of problems with multiple overlapping global constraints, which is something that practical problems frequently require.\nAs such, in this paper we investigate what properties of explicitly represented constraints structural restrictions rely on to guarantee tractability. Identifying such properties will allow us to find global constraints that also possess them, and lift well-known structural restrictions to instances with such constraints.\nAs discussed in [7], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity. Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation. In contrast, we will use a definition of global constraints that allows us to discuss different representations in a uniform manner. Furthermore, as the results we obtain will rely on a relationship between the size of a global constraint and the number of its satisfying assignments, we do not need to reference any specific representation.\nAs a running example, we will use the connected graph partition problem (CGP) [13, p. 209], defined below. The CGP is the problem of partitioning the vertices of a graph into bags of a given size while minimizing the number of edges that span bags. The vertices of the graph could represent components to be placed on circuit boards while minimizing the number of inter-board connections.\nProblem 1 (Connected graph partition (CGP)). We are given an undirected and connected graph \u3008V,E\u3009, as well as \u03b1, \u03b2 \u2208 N. Can V be partitioned into disjoint sets V1, . . . , Vm with |Vi| \u2264 \u03b1 such that the set of broken edges E\u2032 = {{u, v} \u2208 E | u \u2208 Vi, v \u2208 Vj , i 6= j} has cardinality \u03b2 or less?\nThis problem is NP-complete [13, p. 209], even for fixed \u03b1 \u2265 3. We are going to use the results in this paper to show a new result, namely that the CGP is tractable for every fixed \u03b2."}, {"heading": "2 Global Constraints", "text": "In this section, we define the basic concepts that we will use throughout the paper. In particular, we give a precise definition of global constraints, and illustrate it with a few examples.\nDefinition 1 (Variables and assignments). Let V be a set of variables, each with an associated set of domain elements. We denote the set of domain elements (the domain) of a variable v by D(v). We extend this notation to arbitrary subsets of variables, W , by setting D(W ) =\n\u22c3 v\u2208W D(v).\nAn assignment of a set of variables V is a function \u03b8 : V \u2192 D(V ) that maps every v \u2208 V to an element \u03b8(v) \u2208 D(v). We denote the restriction of \u03b8 to a set of variables W \u2286 V by \u03b8|W . We also allow the special assignment \u22a5 of the empty set of variables. In particular, for every assignment \u03b8, we have \u03b8|\u2205 = \u22a5.\nDefinition 2 (Projection). Let \u0398 be a set of assignments of a set of variables V . The projection of \u0398 onto a set of variables X \u2286 V is the set of assignments \u03c0X(\u0398) = {\u03b8|X | \u03b8 \u2208 \u0398}.\nNote that when \u0398 = \u2205 we have \u03c0X(\u0398) = \u2205, but when X = \u2205 and \u0398 6= \u2205, we have \u03c0X(\u0398) = {\u22a5}.\nDefinition 3 (Disjoint union of assignments). Let \u03b81 and \u03b82 be two assignments of disjoint sets of variables V1 and V2, respectively. The disjoint union of \u03b81 and \u03b82, denoted \u03b81\u2295\u03b82, is the assignment of V1\u222aV2 such that (\u03b81\u2295\u03b82)(v) = \u03b81(v) for all v \u2208 V1, and (\u03b81 \u2295 \u03b82)(v) = \u03b82(v) for all v \u2208 V2.\nGlobal constraints have traditionally been defined, somewhat vaguely, as constraints without a fixed arity, possibly also with a compact representation of the constraint relation. For example, in [22] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.\nBelow, we offer a precise definition similar to the one in [4], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time. Our definition differs from this one in that we separate the general algorithm of a global constraint (which we call its type) from the specific description. This separation allows us a better way of measuring the size of a global constraint, which in turn helps us to establish new complexity results.\nDefinition 4 (Global constraints). A global constraint type is a parameterized polynomial-time algorithm that determines the acceptability of an assignment of a given set of variables.\nEach global constraint type, e, has an associated set of descriptions, \u2206(e). Each description \u03b4 \u2208 \u2206(e) specifies appropriate parameter values for the algorithm e. In particular, each \u03b4 \u2208 \u2206(e) specifies a set of variables, denoted by V(\u03b4).\nA global constraint e[\u03b4], where \u03b4 \u2208 \u2206(e), is a function that maps assignments of V(\u03b4) to the set {0, 1}. Each assignment that is allowed by e[\u03b4] is mapped to 1, and each disallowed assignment is mapped to 0. The extension or constraint relation of e[\u03b4] is the set of assignments, \u03b8, of V(\u03b4) such that e[\u03b4](\u03b8) = 1. We also say that such assignments satisfy the constraint, while all other assignments falsify it.\nWhen we are only interested in describing the set of assignments that satisfy a constraint, and not in the complexity of determining membership in this set, we will sometimes abuse notation by writing \u03b8 \u2208 e[\u03b4] to mean e[\u03b4](\u03b8) = 1.\nAs can be seen from the definition above, a global constraint is not usually explicitly represented by listing all the assignments that satisfy it. Instead, it is represented by some description \u03b4 and some algorithm e that allows us to check whether the constraint relation of e[\u03b4] includes a given assignment. To stay within the complexity class NP, this algorithm is required to run in polynomial time. As the algorithms for many common global constraints are built into modern constraint solvers, we measure the size of a global constraint\u2019s representation by the size of its description.\nExample 1 (EGC). A very general global constraint type is the extended global cardinality constraint type [29]. This form of global constraint is defined by specifying for every domain element a a finite set of natural numbersK(a), called the cardinality set of a. The constraint requires that the number of variables which are assigned the value a is in the set K(a), for each possible domain element a.\nUsing our notation, the description \u03b4 of an EGC global constraint specifies a function K\u03b4 : D(V(\u03b4)) \u2192 P(N) that maps each domain element to a set of natural numbers. The algorithm for the EGC constraint then maps an assignment \u03b8 to 1 if and only if, for every domain element a \u2208 D(V(\u03b4)), we have that |{v \u2208 V(\u03b4) | \u03b8(v) = a}| \u2208 K\u03b4(a).\nExample 2 (Table and negative constraints). A rather degenerate example of a a global constraint type is the table constraint.\nIn this case the description \u03b4 is simply a list of assignments of some fixed set of variables, V(\u03b4). The algorithm for a table constraint then decides, for any assignment of V(\u03b4), whether it is included in \u03b4. This can be done in a time which is linear in the size of \u03b4 and so meets the polynomial time requirement.\nNegative constraints are complementary to table constraints, in that they are described by listing forbidden assignments. The algorithm for a negative constraint e[\u03b4] decides, for any assignment of V(\u03b4), whether whether it is not included in \u03b4. Observe that disjunctive clauses, used to define propositional satisfiability problems, are a special case of the negative constraint type, as they have exactly one forbidden assignment.\nWe observe that any global constraint can be rewritten as a table or negative constraint. However, this rewriting will, in general, incur an exponential increase in the size of the description.\nAs can be seen from the definition above, a table global constraint is explicitly represented, and thus equivalent to the usual notion of an explicitly represented constraint.\nDefinition 5 (CSP instance). An instance of the constraint satisfaction problem (CSP) is a pair \u3008V,C\u3009 where V is a finite set of variables, and C is a set of\nglobal constraints such that for every e[\u03b4] \u2208 C, V(\u03b4) \u2286 V . In a CSP instance, we call V(\u03b4) the scope of the constraint e[\u03b4].\nA classic CSP instance is one where every constraint is a table constraint. A solution to a CSP instance P = \u3008V,C\u3009 is an assignment \u03b8 of V which satisfies every global constraint, i.e., for every e[\u03b4] \u2208 C we have \u03b8|V(\u03b4) \u2208 e[\u03b4]. We denote the set of solutions to P by sol(P ).\nThe size of a CSP instance P = \u3008V,C\u3009 is |P | = |V |+ \u2211 v\u2208V |D(v)|+ \u2211 e[\u03b4]\u2208C |\u03b4|.\nExample 3 (The CGP encoded with global constraints). Given a connected graph G = \u3008V,E\u3009, \u03b1, and \u03b2, we build a CSP instance \u3008A\u222aB,C\u3009 as follows. The set A will have a variable v for every v \u2208 V with domain D(v) = {1, . . . , |V |}, while the set B will have a boolean variable e for every edge in E.\nThe set of constraints C will have an EGC constraint C\u03b1 on A with K(i) = {0, . . . , \u03b1} for every 1 \u2264 i \u2264 |V |. Likewise, C will have an EGC constraint C\u03b2 on B with K(0) = {0, . . . , |E|} and K(1) = {1, . . . , \u03b2}.\nFinally, to connect A and B, the set C will have for every edge {u, v} \u2208 E, with corresponding variable e \u2208 B, a table constraint on {u, v, e} requiring u 6= v \u2192 e = 1.\nAs an example, Figure 1 shows this encoding for the CGP on the graph C5, that is, a simple cycle on five vertices.\nThis encoding follows the definition of Problem 1 quite closely, and can be done in polynomial time."}, {"heading": "3 Structural Restrictions", "text": "In recent years, there has been a flurry of research into identifying tractable classes of classic CSP instances based on restrictions on the hypergraphs of CSP instances, known as structural restrictions. Below, we present and discuss a few representative examples. To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].\nDefinition 6 (Hypergraph). A hypergraph \u3008V,H\u3009 is a set of vertices V together with a set of hyperedges H \u2286 P(V ).\nGiven a CSP instance P = \u3008V,C\u3009, the hypergraph of P , denoted hyp(P ), has vertex set V together with a hyperedge V(\u03b4) for every e[\u03b4] \u2208 C.\nDefinition 7 (Tree decomposition). A tree decomposition of a hypergraph \u3008V,H\u3009 is a pair \u3008T, \u03bb\u3009 where T is a tree and \u03bb is a labelling function from nodes of T to subsets of V , such that\n1. for every v \u2208 V , there exists a node t of T such that v \u2208 \u03bb(t), 2. for every hyperedge h \u2208 H, there exists a node t of T such that h \u2286 \u03bb(t),\nand 3. for every v \u2208 V , the set of nodes {t | v \u2208 \u03bb(t)} induces a connected subtree\nof T .\nDefinition 8 (Width function). Let G = \u3008V,H\u3009 be a hypergraph. A width function on G is a function f : P(V )\u2192 R+ that assigns a positive real number to every nonempty subset of vertices of G. A width function f is monotone if f(X) \u2264 f(Y ) whenever X \u2286 Y .\nLet \u3008T, \u03bb\u3009 be a tree decomposition of G, and f a width function on G. The f - width of \u3008T, \u03bb\u3009 is max({f(\u03bb(t)) | t node of T}). The f -width of G is the minimal f -width over all its tree decompositions.\nIn other words, a width function on a hypergraph G tells us how to assign weights to nodes of tree decompositions of G.\nDefinition 9 (Treewidth). Let f(X) = |X| \u2212 1. The treewidth tw(G) of a hypergraph G is the f -width of G.\nLet G = \u3008V,H\u3009 be a hypergraph, and X \u2286 V . An edge cover for X is any set of hyperedges H \u2032 \u2286 H that satisfies X \u2286 \u22c3 H \u2032. The edge cover number \u03c1(X) of X is the size of the smallest edge cover for X. It is clear that \u03c1 is a width function.\nDefinition 10 ( [1, Chapter 2]). The generalized hypertree width hw(G) of a hypergraph G is the \u03c1-width of G.\nNext, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [20].\nDefinition 11 (Fractional edge cover). Let G = \u3008V,H\u3009 be a hypergraph, and X \u2286 V . A fractional edge cover for X is a function \u03b3 : H \u2192 [0, 1] such that\u2211 v\u2208h\u2208H \u03b3(h) \u2265 1 for every v \u2208 X. We call \u2211 h\u2208H \u03b3(h) the weight of \u03b3. The fractional edge cover number \u03c1\u2217(X) of X is the minimum weight over all fractional edge covers for X. It is known that this minimum is always rational [20].\nDefinition 12. The fractional hypertree width fhw(G) of a hypergraph G is the \u03c1\u2217-width of G.\nFor a class of hypergraphs H and a notion of width \u03b1, we write \u03b1(H) for the maximal \u03b1-width over the hypergraphs in H. If this is unbounded we write \u03b1(H) =\u221e; otherwise \u03b1(H) <\u221e.\nAll the above restrictions can be used to guarantee tractability for classes of CSP instances where all constraints are table constraints.\nTheorem 1 ( [10, 17, 20]). Let H be a class of hypergraphs. For every \u03b1 \u2208 {hw, fhw}, any class of classic CSP instances whose hypergraphs are in H is tractable if \u03b1(H) <\u221e.\nTo go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width. This concept uses a set of width functions satisfying a condition (submodularity), and considers the f -width of a hypergraph for every such function f .\nDefinition 13 (Submodular width function). Let G = \u3008V,H\u3009 be a hypergraph. A width function f on G is submodular if for every set X,Y \u2286 V , we have f(X) + f(Y ) \u2265 f(X \u2229 Y ) + f(X \u222a Y ).\nDefinition 14 (Submodular width). Let G be a hypergraph. The submodular width subw(G) of G is the maximum f -width of G taken over all monotone submodular width functions f on G.\nFor a class of hypergraphs H, we write subw(H) for the maximal submodular width over the hypergraphs in H. If this is unbounded we write subw(H) = \u221e; otherwise subw(H) <\u221e.\nUnlike for fractional hypertree width and every other structural restriction discussed so far, the running time of the algorithm given by Marx for classic CSP instances with bounded submodular width has an exponential dependence on the number of vertices in the hypergraph of the instance. The class of classic CSP instances with bounded submodular width is therefore not tractable. However, this class is what is called fixed-parameter tractable [11,12].\nDefinition 15 (Fixed-parameter tractable). A parameterized problem instance is a pair \u3008k, P \u3009, where P is a problem instance, such as a CSP instance, and k \u2208 N a parameter.\nLet S be a class of parameterized problem instances. We say that S is fixedparameter tractable (in FPT) if there is a function f of one argument, as well as a constant c, such that every problem \u3008k, P \u3009 \u2208 S can be solved in time O(f(k)\u00d7 |P |c).\nThe function f can be arbitrary, but must only depend on the parameter k. For CSP instances, a natural parameterization is by the size of the hypergraph of an instance, measured by the number of vertices. Since the hypergraph of an instance has a vertex for every variable, for every CSP instance P = \u3008V,C\u3009 we consider the parameterized instance \u3008|V |, P \u3009.\nTheorem 2 ( [24]). Let H be a class of hypergraphs. If subw(H) <\u221e, then a class of classic CSP instances whose hypergraphs are in H is in FPT.\nThe three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 hw(G).\nAs the example below demonstrates, Theorem 1 does not hold for CSP instances with arbitrary global constraints, even if we have a fixed, finite domain.\nExample 4. The NP-complete problem of 3-colourability [13] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.\nWe may reduce this problem to a CSP with EGC constraints (cf. Example 1) as follows: Let V be the set of variables for our CSP instance, each with domain {r, g, b}. For every edge \u3008v, w\u3009 \u2208 E, we post an EGC constraint with scope {v, w}, parameterized by the function K such that K(r) = K(g) = K(b) = {0, 1}. Finally, we make the hypergraph of this CSP instance have low width by adding an EGC constraint with scope V parameterized by the function K \u2032 such that K \u2032(r) = K \u2032(g) = K \u2032(b) = {0, . . . , |V |}. This reduction clearly takes polynomial time, and the hypergraph G of the resulting instance has hw(G) = fhw(G) = subw(G) = 1.\nAs the constraint with scope V allows all possible assignments, any solution to this CSP is also a solution to the 3-colourability problem, and vice versa.\nLikewise, Theorem 2 does not hold for CSP instances with arbitrary global constraints if we allow the variables unbounded domain size, that is, change the above example to k-colourability. With that in mind, in the rest of the paper we will identify properties of extensionally represented constraints that these structural restrictions exploit to guarantee tractability. Then, we are going to look for restricted classes of global constraints that possess these properties. To do so, we will use the following definitions.\nDefinition 16 (Constraint catalogue). A constraint catalogue is a set of global constraints. A CSP instance \u3008V,C\u3009 is said to be over a constraint catalogue \u0393 if for every e[\u03b4] \u2208 C we have e[\u03b4] \u2208 \u0393 .\nDefinition 17 (Restricted CSP class). Let \u0393 be a constraint catalogue, and let H be a class of hypergraphs. We define CSP(H, \u0393 ) to be the class of CSP instances over \u0393 whose hypergraphs are in H.\nDefinition 17 allows us to discuss classic CSP instances alongside instances with global constraints. Let Ext be the constraint catalogue containing all table global constraints. The classic CSP instances are then precisely those that are over Ext. In particular, we can now restate Theorems 1 and 2 as follows.\nTheorem 3. Let H be a class of hypergraphs. For every \u03b1 \u2208 {hw, fhw}, the class of CSP instances CSP(H,Ext) is tractable if \u03b1(H) < \u221e. Furthermore, if subw(H) <\u221e then CSP(H,Ext) is in FPT."}, {"heading": "4 Properties of Extensional Representation", "text": "We are going to start our investigation by considering fractional hypertree width in more detail. To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [20] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance. The following definition formalizes what we mean by \u201cparts\u201d, and is required to state the algorithm that Grohe and Marx use in their paper.\nDefinition 18 (Constraint projection). Let e[\u03b4] be a constraint. The projection of e[\u03b4] onto a set of variables X \u2286 V(\u03b4) is the constraint pjX(e[\u03b4]) such that \u00b5 \u2208 pjX(e[\u03b4]) if and only if there exists \u03b8 \u2208 e[\u03b4] with \u03b8|X = \u00b5.\nFor a CSP instance P = \u3008V,C\u3009 and X \u2286 V we define pjX(P ) = \u3008X,C \u2032\u3009, where C \u2032 is the least set containing for every e[\u03b4] \u2208 C such that X \u2229 V(\u03b4) 6= \u2205 the constraint pjX\u2229V(\u03b4)(e[\u03b4]).\nTheir algorithm is given as Algorithm 1, and is essentially the usual recursive search algorithm for finding all solutions to a CSP instance by considering smaller and smaller sub-instances using constraint projections.\nAlgorithm 1 Enumerate all solutions of a CSP instance procedure EnumSolutions(CSP instance P = \u3008V,C\u3009) . Returns sol(P )\nSolutions\u2190 \u2205 if V = \u2205 then\nreturn {\u22a5} . The empty assignment else\nw \u2190 chooseVar(V ) . Pick a variable from V \u0398 = EnumSolutions(pjV\u2212{w}(P )) for \u03b8 \u2208 \u0398 do\nfor a \u2208 D(w) do if \u03b8 \u222a \u3008w, a\u3009 is a solution to P then\nSolutions.add(\u03b8 \u222a \u3008w, a\u3009) end if\nend for end for\nend if return Solutions\nend procedure\nTo show that Algorithm 1 does indeed find all solutions, we will use the following property of constraint projections.\nLemma 1. Let P = \u3008V,C\u3009 be a CSP instance. For every X \u2286 V , we have sol(pjX(P )) \u2287 \u03c0X(sol(P )).\nProof. Given P = \u3008V,C\u3009, let X \u2286 V be arbitrary, and let C \u2032 = {e[\u03b4] \u2208 C | X \u2229 V(\u03b4) 6= \u2205}. For every \u03b8 \u2208 sol(P ) and constraint e[\u03b4] \u2208 C \u2032 we have that \u03b8|V(\u03b4) \u2208 e[\u03b4] since \u03b8 is a solution to P . By Definition 18, it follows that for every e[\u03b4] \u2208 C \u2032, \u03b8|X\u2229V(\u03b4) \u2208 pjX\u2229V(\u03b4)(e[\u03b4]). Since the set of constraints of pjX(P ) is the least set containing for each e[\u03b4] \u2208 C \u2032 the constraint pjX\u2229V(\u03b4)(e[\u03b4]), we have \u03b8|X \u2208 sol(pjX(P )), and hence sol(pjX(P )) \u2287 \u03c0X(sol(P )). Since X was arbitrary, the claim follows.\nTheorem 4 (Correctness of Algorithm 1). Let P be a CSP instance. We have that EnumSolutions(P ) = sol(P ).\nProof. The proof is by induction on the set of variables V in P . For the base case, if V = \u2205, the empty assignment is the only solution.\nOtherwise, choose a variable w \u2208 V , and let X = V \u2212 {w}. By induction, we can assume that EnumSolutions(pjX(P )) = sol(pjX(P )). Since for every \u03b8 \u2208 sol(P ) there exists a \u2208 D(w) such that \u03b8 = \u03b8|X \u222a \u3008w, a\u3009, and furthermore \u03b8|X \u2208 \u03c0X(sol(P )), it follows by Lemma 1 that \u03b8|X \u2208 sol(pjX(P )). Since Algorithm 1 checks every assignment of the form \u00b5 \u222a \u3008w, a\u3009 for every \u00b5 \u2208 sol(pjX(P )) and a \u2208 D(w), it follows that EnumSolutions(P ) = sol(P ).\nThe time required for this algorithm depends on three key factors, which we are going to enumerate and discuss below. Let\n1. s(P ) be the maximum of the number of solutions to each of the instances pjV\u2212{w}(P ), 2. c(P ) be the maximum time required to check whether an assignment is a solution to P , and 3. b(P ) be the maximum time required to construct any instance pjV\u2212{w}(P ).\nThere are |V | calls to EnumSolutions. For each call, we need b(P ) time to construct the projection, while the double loop takes at most s(P ) \u00d7 |D(w)| \u00d7 c(P ) time. Therefore, letting d = max({|D(w)| | w \u2208 V }), the running time of Algorithm 1 is bounded by O ( |V | \u00d7 (s(P )\u00d7 d\u00d7 c(P ) + b(P )) ) .\nSince constructing the projection of a classic CSP instance can be done in polynomial time, and likewise checking that an assignment is a solution, the whole algorithm runs in polynomial time if s(P ) is a polynomial in the size of P . For fractional hypertree width, Grohe and Marx show the following.\nLemma 2 ( [20]). A classic CSP instance P has at most |P |fhw(hyp(P )) solutions.\nSince fractional hypertree width is a monotone width function, it follows that for any instance P = \u3008V,C\u3009 and X \u2286 V , fhw(hyp(pjX(P ))) \u2264 fhw(hyp(P )). Therefore, for classic CSP instances of bounded fractional hypertree width s(P ) is indeed polynomial in |P |."}, {"heading": "5 CSP Instances with Few Solutions in Key Places", "text": "Having few solutions for every projection of a CSP instance is thus a property that makes fractional hypertree width yield tractable classes of classic CSP instances. More importantly, we have shown that this property allows us to find all solutions to a CSP instance P , even with global constraints, if we can build arbitrary projections of P in polynomial time. In other words, with these two conditions we should be able to reduce instances with global constraints to classic instances in polynomial time.\nHowever, on reflection there is no reason why we should need few solutions for every projection. Instead, consider the following reduction.\nDefinition 19 (Partial assignment checking). A global constraint catalogue \u0393 allows partial assignment checking if for any constraint e[\u03b4] \u2208 \u0393 we can decide in polynomial time whether a given assignment \u03b8 to a set of variables W \u2286 V(\u03b4) is contained in an assignment that satisfies e[\u03b4], i.e. whether there exists \u00b5 \u2208 e[\u03b4] such that \u03b8 = \u00b5|W .\nAs an example, a catalogue that contains arbitrary EGC constraints (cf. Example 1) does not satisfy Definition 19, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [26]. On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 19 [27].\nIf a catalogue \u0393 satisfies Definition 19, we can for any constraint e[\u03b4] \u2208 \u0393 build arbitrary projections of it, that is, construct the global constraint pjX(e[\u03b4]) for any X \u2286 V(\u03b4), in polynomial time.\nDefinition 20 (Intersection variables). Let \u3008V,C\u3009 be a CSP instance. The set of intersection variables of any constraint e[\u03b4] \u2208 P is iv(\u03b4) = \u22c3 {V(\u03b4)\u2229V(\u03b4\u2032) | e\u2032[\u03b4\u2032] \u2208 C \u2212 {e[\u03b4]}}.\nDefinition 21 (Table constraint induced by a global constraint). Let P = \u3008V,C\u3009 be a CSP instance. For every e[\u03b4] \u2208 C, let \u00b5\u2217 be the assignment to V(\u03b4)\u2212 iv(\u03b4) that assigns a special value \u2217 to every variable. The table constraint induced by e[\u03b4] is ic(e[\u03b4]) = e\u2032[\u03b4\u2032], where V(\u03b4\u2032) = V(\u03b4), and \u03b4\u2032 contains for every assignment \u03b8 \u2208 sol(pjiv(\u03b4)(P )) the assignment \u03b8 \u2295 \u00b5\u2217.\nIf every constraint in a CSP instance P = \u3008V,C\u3009 allows partial assignment checking, then building ic(e[\u03b4]) for any e[\u03b4] \u2208 C can be done in polynomial time when |sol(pjX(P ))| is itself polynomial in the size of P for every subsetX of iv(\u03b4). To do so, we can invoke Algorithm 1 on the instance pjiv(\u03b4)(P ). The definition below expresses this idea.\nDefinition 22 (Sparse intersections). A class of CSP instances P has sparse intersections if there exists a constant c such that for every constraint e[\u03b4] in any instance P \u2208 P, we have that for every X \u2286 iv(\u03b4), |sol(pjX(P ))| \u2264 |P |c.\nIf a class of instances P has sparse intersections, and the instances are all over a constraint catalogue that allows partial assignment checking, then we can for every constraint e[\u03b4] of any instance from P construct ic(e[\u03b4]) in polynomial time. While this definition considers the instance as a whole, one special case of it is the case where every constraint has few solutions in the size of its description, that is, there is a constant c and the constraints are drawn from a catalogue \u0393 such that for every e[\u03b4] \u2208 \u0393 , we have that |{\u00b5 | \u00b5 \u2208 e[\u03b4]}| \u2264 |\u03b4|c.\nTheorem 5. Let P be a class of CSP instances over a catalogue that allows partial assignment checking. If P has sparse intersections, then we can in polynomial time reduce any instance P \u2208 P to a classic CSP instance PCL with hyp(P ) = hyp(PCL), such that PCL has a solution if and only if P does.\nProof. Let P = \u3008V,C\u3009 be an instance from such a class P. For each e[\u03b4] \u2208 C, PCL will contain the table constraint ic(e[\u03b4]) from Definition 21. Since P is over a catalogue that allows partial assignment checking, and P has sparse intersections, computing ic(e[\u03b4]) can be done in polynomial time by invoking Algorithm 1 on pjiv(\u03b4)(P ).\nIt is clear that hyp(P ) = hyp(PCL). All that is left to show is that PCL has a solution if and only if P does. Let \u03b8 be a solution to P = \u3008V,C\u3009. For every e[\u03b4] \u2208 C, we have that \u03b8|iv(\u03b4) \u2208 pjiv(\u03b4)(P ) by Definitions 18 and 20, and the assignment \u00b5 that assigns the value \u03b8(v) to each v \u2208\n\u22c3 e[\u03b4]\u2208C iv(\u03b4), and \u2217 to every\nother variable is therefore a solution to PCL. In the other direction, if \u03b8 is a solution to PCL, then \u03b8 satisfies ic(e[\u03b4]) for every e[\u03b4] \u2208 C. By Definition 21, this means that \u03b8|iv(\u03b4) \u2208 sol(pjiv(\u03b4)(P )), and by Definition 18, there exists an assignment \u00b5e[\u03b4] with \u00b5e[\u03b4]|iv(\u03b4) = \u03b8|iv(\u03b4) that satisfies e[\u03b4]. By Definition 20, the variables not in iv(\u03b4) do not occur in any other constraint in P , so we can combine all the assignments \u00b5e[\u03b4] to form a solution \u00b5 to P such that for e[\u03b4] \u2208 C and v \u2208 V(\u03b4) we have \u00b5(v) = \u00b5e[\u03b4](v).\nFrom Theorem 5, we get tractable and fixed-parameter tractable classes of CSP instances with global constraints.\nCorollary 1. Let H be a class of hypergraphs, and \u0393 a catalogue that allows partial assignment checking. If CSP(H, \u0393 ) has sparse intersections, then CSP(H, \u0393 ) is tractable or in FPT if CSP(H,Ext) is.\nProof. Let H and \u0393 be given. By Theorem 5, we can reduce any P \u2208 CSP(H, \u0393 ) to an instance PCL \u2208 CSP(H,Ext) in polynomial time. Since PCL has a solution if and only if P does, tractability or fixed-parameter tractability of CSP(H,Ext) implies the same for CSP(H, \u0393 )."}, {"heading": "5.1 Applying Corollary 1 to the CGP", "text": "Recall the connected graph partition problem (Problem 1): Given a connected graph G, as well as natural numbers \u03b1 and \u03b2, can the vertices of G be partitioned\ninto bags of size at most \u03b1, such that no more than \u03b2 edges are broken. Using the CSP encoding we gave in Example 3, as well as Corollary 1, we will show a new result, that this problem is tractable if \u03b2 is fixed. To simplify the analysis, we assume without loss of generality that \u03b1 < |V |, which means that any solution has at least one broken edge.\nWe claim that if \u03b2 is fixed, then the constraint C\u03b2 = e\u03b2 [\u03b4\u03b2 ] allows partial assignment checking, and has only a polynomial number of satisfying assignments. The latter implies that for any instance P of the CGP, |sol(pjiv(\u03b4\u03b2)(P ))| is polynomial in the size of P for every subset of iv(\u03b4\u03b2). Furthermore, we will show that for the constraint C\u03b1 = e\u03b1[\u03b4\u03b1], we also have that |sol(pjiv(\u03b4\u03b1)(P ))| is polynomial in the size of P . That C\u03b1 allows partial assignment checking follows from a result by R\u00e9gin [27], since the cardinality sets of C\u03b1 are intervals.\nFirst, we show that the number of satisfying assignments to C\u03b2 is limited. Since C\u03b2 limits the number of ones in any solution to \u03b2 or fewer, the number of satisfying assignments to this constraint is the number of ways to choose up to\n\u03b2 variables to be assigned one. This is bounded by \u03b2\u2211 i=1 ( |E| i ) \u2264 (|E|+ 1)\u03b2 , and so we can generate them all in polynomial time.\nNow, let \u03b8 be such a solution. How many solutions to P contain \u03b8? Well, every constraint on {u, v, e} with e = 1 allows at most |V |2 assignments, and there are at most \u03b2 such constraints. So far we therefore have at most (|E|+ 1)\u03b2 \u00d7 |V |2\u03b2 assignments.\nOn the other hand, a ternary constraint with e = 0 requires u = v. Consider the graph G0 containing for every constraint on {u, v, e} with e = 0 the vertices u and v as well as the edge {u, v}. Since the original graph was connected, every connected component of G0 contains at least one vertex which is in the scope of some constraint with e = 1. Therefore, since equality is transitive, each connected component of G0 allows at most one assignment for each of the (|E| + 1)\u03b2 \u00d7 |V |2\u03b2 assignments to the other variables of P . We therefore get a total bound of (|E| + 1)\u03b2 \u00d7 |V |2\u03b2 on the total number of solutions to P , and hence to pjiv(\u03b4\u03b1)(P ).\nThe hypergraph of any CSP instance P encoding the CGP has two hyperedges covering the whole problem, so the hypertree width of this hypergraph is two. Therefore, we may apply Corollary 1 and Theorem 1 to obtain tractability when \u03b2 is fixed. As this problem is NP-complete for fixed \u03b1 \u2265 3 [13, p. 209], \u03b2 is a natural parameter to try and use.\nAs it happens, in this problem we can drop the requirement of partial assignment checking for the constraint C\u03b1. All its variables are intersection variables, and the instance has few solutions even if we disregard C\u03b1. Thus, we need only check whether any of those solutions satisfy C\u03b1, and checking whether an assignment to the whole scope of a constraint satisfies it can always be done in polynomial time by Definition 4. In the next section, we turn this observation into a general result."}, {"heading": "6 Back Doors", "text": "If a class of CSP instances includes constraints from a catalogue that is not known to allow partial assignment checking, we may still obtain tractability in some cases by applying the notion of a back door set. A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve. Below, we are going to adapt this notion to individual constraints.\nDefinition 23 (Back door). Let \u0393 be a global constraint catalogue. A back door for a constraint e[\u03b4] \u2208 \u0393 is any set of variables W \u2286 V(\u03b4) (called a back door set) such that we can decide in polynomial time whether a given assignment \u03b8 to a set of variables V(\u03b8) \u2287W is contained in an assignment that satisfies e[\u03b4], i.e. whether there exists \u00b5 \u2208 e[\u03b4] such that \u00b5|V(\u03b8) = \u03b8.\nTrivially, for every constraint e[\u03b4] the set of variables V(\u03b4) is a back door set, since by Definition 4 we can always check in polynomial time if an assignment to V(\u03b4) satisfies the constraint e[\u03b4].\nThe key point about back doors is that given a catalogue \u0393 , adding to each e[\u03b4] \u2208 \u0393 with back door set W an arbitrary set of assignments to W produces a catalogue \u0393 \u2032 that allows partial assignment checking. Adding a set of assignments \u0398 means to add \u0398 to the description, and modify the algorithm e to only accept an assignment if it contains a member of \u0398 in addition to previous requirements. Furthermore, given a CSP instance P containing e[\u03b4], as long as \u0398 \u2287 \u03c0W (sol(P )), adding \u0398 to e[\u03b4] produces an instance that has exactly the same solutions. This point leads to the following definition.\nDefinition 24 (Sparse back door cover). Let \u0393PAC be a catalogue that allows partial assignment checking and \u0393BD a catalogue. For every instance P = \u3008V,C\u3009 over \u0393PAC \u222a \u0393BD, let P \u2229 \u0393PAC be the instance with constraint set C \u2032 = C \u2229 \u0393PAC and set of variables \u22c3 {V \u2229 V(\u03b4) | e[\u03b4] \u2208 C \u2032}.\nA class of CSP instances P over \u0393PAC \u222a \u0393BD has sparse back door cover if there exists a constant c such that for every instance P = \u3008V,C\u3009 \u2208 P and constraint e[\u03b4] \u2208 C, if e[\u03b4] 6\u2208 \u0393PAC , then there exists a back door set W for e[\u03b4] with |sol(pjX(P \u2229 \u0393PAC))| \u2264 |P |c for every X \u2286W .\nSparse back door cover means that for each constraint that is not from a catalogue that allows partial assignment checking, we can in polynomial time get a set of assignments \u0398 for its back door set using Algorithm 1, and so turn this constraint into one that does allow partial assignment checking. This operation preserves the solutions of the instance that contains this constraint.\nTheorem 6. If a class of CSP instance P has sparse back door cover, then we can in polynomial time reduce any instance P \u2208 P to an instance P \u2032 such that hyp(P ) = hyp(P \u2032) and sol(P ) = sol(P \u2032). Furthermore, the class of instances {P \u2032 | P \u2208 P} is over a catalogue that allows partial assignment checking.\nProof. Let P = \u3008V,C\u3009 \u2208 P. We construct P \u2032 by adding to every e[\u03b4] \u2208 C such that e[\u03b4] 6\u2208 \u0393PAC , with back door set W , the set of assignments sol(pjW (P \u2229 \u0393PAC)), which we can obtain using Algorithm 1. By Definition 24, we have for everyX \u2286W that |sol(pjW (P\u2229\u0393PAC))| \u2264 |P |c, so Algorithm 1 takes polynomial time since \u0393PAC does allow partial assignment checking.\nIt is clear that hyp(P \u2032) = hyp(P ), and since sol(pjW (P\u2229\u0393PAC)) \u2287 \u03c0W (sol(P )), the set of solutions stays the same, i.e. sol(P \u2032) = sol(P ). Finally, since we have replaced each constraint e[\u03b4] in P that was not in \u0393PAC by a constraint that does allow partial assignment checking, it follows that P \u2032 is over a catalogue that allows partial assignment checking.\nOne consequence of Theorem 6 is that we can sometimes apply Theorem 5 to a CSP instance that contains a constraint for which checking if a partial assignment can be extended to a satisfying one is hard. We can do so when the variables of that constraint are covered by the variables of other constraints that do allow partial assignment checking \u2014 but only if the instance given by those constraints has few solutions.\nAs a concrete example of this, consider again the encoding of the CGP that we gave in Example 3. The variables of constraint C\u03b1 are entirely covered by the instance P \u2032 obtained by removing C\u03b1. As the entire set of variables of a constraint is a back door set for it, and the instance P \u2032 has few solutions (cf. Section 5.1), this class of instances has sparse back door cover. As such, the constraint C\u03b1 could, in fact, be arbitrary without affecting the tractability of this problem. In particular, the requirement that C\u03b1 allows partial assignment checking can be dropped."}, {"heading": "7 Summary and Future Work", "text": "In this paper, we have investigated properties that many structural restrictions rely on to yield tractable classes of CSP instances with explicitly represented constraints. In particular, we identify a relationship between the number of solutions and the size of a CSP instance as being one such property. Using this insight, we show that known structural restrictions yield tractability for any class of CSP instances with global constraints that satisfies this property. In particular, the above implies that the structural restrictions we consider yield tractability for classes of instances where every global constraint has few satisfying assignments relative to its size.\nTo illustrate our result, we apply it to a known problem, the connected graph partition problem, and use it to identify a new tractable case of this problem. We also demonstrate how the concept of back doors, subsets of variables that make a problem easy to solve once assigned, can be used to relax the conditions of our result in some cases.\nAs for future work, one obvious research direction to pursue is to find a complete characterization of tractable classes of CSP instances with sparse intersections. Another avenue of research would be to apply the results in this paper to various kinds of valued CSP."}], "references": [{"title": "Width Functions for Hypertree Decompositions", "author": ["I. Adler"], "venue": "Doctoral dissertation, Albert-Ludwigs-Universit\u00e4t Freiburg", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2006}, {"title": "Optimization methods for the partner units problem", "author": ["M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen"], "venue": "Proc. CPAIOR\u201911. LNCS, vol. 6697, pp. 4\u201319. Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Structural decomposition methods and what they are good for", "author": ["M. Aschinger", "C. Drescher", "G. Gottlob", "P. Jeavons", "E. Thorstensen"], "venue": "Schwentick, T., D\u00fcrr, C. (eds.) Proc. STACS\u201911. LIPIcs, vol. 9, pp. 12\u201328", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "The complexity of reasoning with global constraints", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "T. Walsh"], "venue": "Constraints 12(2), 239\u2013259", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "Decomposition of the NValue constraint", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "C.G. Quimper", "T. Walsh"], "venue": "Proc. CP\u201910. LNCS, vol. 6308, pp. 114\u2013128. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Classifying the complexity of constraints using finite algebras", "author": ["A. Bulatov", "P. Jeavons", "A. Krokhin"], "venue": "SIAM Journal on Computing 34(3), 720\u2013742", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2005}, {"title": "Constraint satisfaction with succinctly specified relations", "author": ["H. Chen", "M. Grohe"], "venue": "Journal of Computer and System Sciences 76(8), 847\u2013860", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2010}, {"title": "A unified theory of structural tractability for constraint satisfaction problems", "author": ["D. Cohen", "P. Jeavons", "M. Gyssens"], "venue": "Journal of Computer and System Sciences 74(5), 721\u2013743", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2008}, {"title": "Constraint representations and structural tractability", "author": ["D.A. Cohen", "M.J. Green", "C. Houghton"], "venue": "Proc. CP\u201909. LNCS, vol. 5732, pp. 289\u2013303. Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Constraint satisfaction, bounded treewidth, and finite-variable logics", "author": ["V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi"], "venue": "Proc. CP\u201902. LNCS, vol. 2470, pp. 223\u2013254. Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2002}, {"title": "Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Monographs in Computer Science, Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1999}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Texts in Theoretical Computer Science, Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": "W. H. Freeman", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1979}, {"title": "Backdoors to satisfaction", "author": ["S. Gaspers", "S. Szeider"], "venue": "Bodlaender, H.L., Downey, R., Fomin, F.V., Marx, D. (eds.) The Multivariate Algorithmic Revolution and Beyond, LNCS, vol. 7370, pp. 287\u2013317. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "MINION: A fast, scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "Proc. ECAI\u201906, pp. 98\u2013102. IOS Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2006}, {"title": "A comparison of structural CSP decomposition methods", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Artificial Intelligence 124(2), 243\u2013282", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2000}, {"title": "Hypertree decompositions and tractable queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences 64(3), 579\u2013627", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2002}, {"title": "Structural tractability of propagated constraints", "author": ["M.J. Green", "C. Jefferson"], "venue": "Proc. CP\u201908. LNCS, vol. 5202, pp. 372\u2013386. Springer", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM 54(1), 1\u201324", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2007}, {"title": "Constraint solving via fractional edge covers", "author": ["M. Grohe", "D. Marx"], "venue": "Proc. SODA\u201906, pp. 289\u2013298. ACM", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "Bin repacking scheduling in virtualized datacenters", "author": ["F. Hermenier", "S. Demassey", "X. Lorca"], "venue": "Lee, J. (ed.) Proc. CP\u201911. LNCS, vol. 6876, pp. 27\u201341. Springer", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Global constraints", "author": ["W.J. van Hoeve", "I. Katriel"], "venue": "Rossi, F., van Beek, P., Walsh, T. (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 169\u2013208. Elsevier", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2006}, {"title": "Simultaneous matchings: Hardness and approximation", "author": ["M. Kutz", "K. Elbassioni", "I. Katriel", "M. Mahajan"], "venue": "Journal of Computer and System Sciences 74(5), 884\u2013897", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2008}, {"title": "Tractable hypergraph properties for constraint satisfaction and conjunctive queries", "author": ["D. Marx"], "venue": "CoRR abs/0911.0801", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2009}, {"title": "Tractable hypergraph properties for constraint satisfaction and conjunctive queries", "author": ["D. Marx"], "venue": "Proc. STOC\u201910, pp. 735\u2013744. ACM", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "Improved algorithms for the global cardinality constraint", "author": ["C.G. Quimper", "A. L\u00f3pez-Ortiz", "P. van Beek", "A. Golynski"], "venue": "Proc. CP\u201904. LNCS, vol. 3258, pp. 542\u2013556. Springer", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2004}, {"title": "Generalized Arc Consistency for Global Cardinality Constraint", "author": ["J.C. R\u00e9gin"], "venue": "Proc. AAAI\u201996, pp. 209\u2013215. AAAI Press", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1996}, {"title": "The Handbook of Constraint Programming", "author": ["F. Rossi", "P. van Beek", "Walsh", "T. (eds."], "venue": "Elsevier", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2006}, {"title": "Tractable cases of the extended global cardinality constraint", "author": ["M. Samer", "S. Szeider"], "venue": "Constraints 16(1), 1\u201324", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "Practical applications of constraint programming", "author": ["M. Wallace"], "venue": "Constraints 1, 139\u2013 168", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1996}, {"title": "ECLiPSe: A platform for constraint logic programming", "author": ["M. Wallace", "S. Novello", "J. Schimpf"], "venue": "ICL Systems Journal 12(1), 137\u2013158", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1997}, {"title": "Backdoors to typical case complexity", "author": ["R. Williams", "C.P. Gomes", "B. Selman"], "venue": "Proc. IJCAI\u201903, pp. 1173\u20131178", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 21, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].", "startOffset": 116, "endOffset": 123}, {"referenceID": 29, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].", "startOffset": 116, "endOffset": 123}, {"referenceID": 1, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].", "startOffset": 154, "endOffset": 160}, {"referenceID": 20, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].", "startOffset": 154, "endOffset": 160}, {"referenceID": 14, "context": "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].", "startOffset": 162, "endOffset": 172}, {"referenceID": 27, "context": "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].", "startOffset": 162, "endOffset": 172}, {"referenceID": 30, "context": "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].", "startOffset": 162, "endOffset": 172}, {"referenceID": 2, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 5, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 7, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 15, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 18, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 24, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].", "startOffset": 287, "endOffset": 308}, {"referenceID": 16, "context": "CSP instances [17, 20, 25].", "startOffset": 14, "endOffset": 26}, {"referenceID": 19, "context": "CSP instances [17, 20, 25].", "startOffset": 14, "endOffset": 26}, {"referenceID": 24, "context": "CSP instances [17, 20, 25].", "startOffset": 14, "endOffset": 26}, {"referenceID": 22, "context": "However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints, even when the global constraints are fairly simple [23].", "startOffset": 272, "endOffset": 276}, {"referenceID": 3, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29].", "startOffset": 121, "endOffset": 127}, {"referenceID": 28, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29].", "startOffset": 121, "endOffset": 127}, {"referenceID": 4, "context": "Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [5].", "startOffset": 149, "endOffset": 152}, {"referenceID": 6, "context": "As discussed in [7], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity.", "startOffset": 16, "endOffset": 19}, {"referenceID": 17, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.", "startOffset": 118, "endOffset": 122}, {"referenceID": 8, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.", "startOffset": 145, "endOffset": 148}, {"referenceID": 6, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.", "startOffset": 176, "endOffset": 179}, {"referenceID": 21, "context": "For example, in [22] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.", "startOffset": 16, "endOffset": 20}, {"referenceID": 3, "context": "Below, we offer a precise definition similar to the one in [4], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time.", "startOffset": 59, "endOffset": 62}, {"referenceID": 28, "context": "A very general global constraint type is the extended global cardinality constraint type [29].", "startOffset": 89, "endOffset": 93}, {"referenceID": 0, "context": "To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].", "startOffset": 114, "endOffset": 117}, {"referenceID": 19, "context": "Next, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [20].", "startOffset": 114, "endOffset": 118}, {"referenceID": 0, "context": "A fractional edge cover for X is a function \u03b3 : H \u2192 [0, 1] such that \u2211", "startOffset": 52, "endOffset": 58}, {"referenceID": 19, "context": "It is known that this minimum is always rational [20].", "startOffset": 49, "endOffset": 53}, {"referenceID": 9, "context": "Theorem 1 ( [10, 17, 20]).", "startOffset": 12, "endOffset": 24}, {"referenceID": 16, "context": "Theorem 1 ( [10, 17, 20]).", "startOffset": 12, "endOffset": 24}, {"referenceID": 19, "context": "Theorem 1 ( [10, 17, 20]).", "startOffset": 12, "endOffset": 24}, {"referenceID": 23, "context": "To go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width.", "startOffset": 46, "endOffset": 54}, {"referenceID": 24, "context": "To go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width.", "startOffset": 46, "endOffset": 54}, {"referenceID": 10, "context": "However, this class is what is called fixed-parameter tractable [11,12].", "startOffset": 64, "endOffset": 71}, {"referenceID": 11, "context": "However, this class is what is called fixed-parameter tractable [11,12].", "startOffset": 64, "endOffset": 71}, {"referenceID": 23, "context": "Theorem 2 ( [24]).", "startOffset": 12, "endOffset": 16}, {"referenceID": 19, "context": "The three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 hw(G).", "startOffset": 79, "endOffset": 86}, {"referenceID": 23, "context": "The three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) \u2264 fhw(G) \u2264 hw(G).", "startOffset": 79, "endOffset": 86}, {"referenceID": 12, "context": "The NP-complete problem of 3-colourability [13] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.", "startOffset": 43, "endOffset": 47}, {"referenceID": 19, "context": "To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [20] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance.", "startOffset": 103, "endOffset": 107}, {"referenceID": 19, "context": "Lemma 2 ( [20]).", "startOffset": 10, "endOffset": 14}, {"referenceID": 25, "context": "Example 1) does not satisfy Definition 19, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [26].", "startOffset": 133, "endOffset": 137}, {"referenceID": 26, "context": "On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 19 [27].", "startOffset": 130, "endOffset": 134}, {"referenceID": 26, "context": "That C allows partial assignment checking follows from a result by R\u00e9gin [27], since the cardinality sets of C are intervals.", "startOffset": 73, "endOffset": 77}, {"referenceID": 13, "context": "A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.", "startOffset": 25, "endOffset": 32}, {"referenceID": 31, "context": "A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.", "startOffset": 25, "endOffset": 32}], "year": 2013, "abstractText": "A wide range of problems can be modelled as constraint satisfaction problems (CSPs), that is, a set of constraints that must be satisfied simultaneously. Constraints can either be represented extensionally, by explicitly listing allowed combinations of values, or implicitly, by special-purpose algorithms provided by a solver. Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances that yield tractable classes have been identified. However, many such restrictions fail to guarantee tractability for CSPs with global constraints. In this paper, we investigate the properties of extensionally represented constraints that these restrictions exploit to achieve tractability, and show that there are large classes of global constraints that also possess these properties. This allows us to lift these restrictions to the global case, and identify new tractable classes of CSPs with global constraints.", "creator": "LaTeX with hyperref package"}}}