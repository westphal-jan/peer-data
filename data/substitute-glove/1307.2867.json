{"id": "1307.2867", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jul-2013", "title": "Tractable Combinations of Global Constraints", "abstract": "We environmental following complexity part finite meaningful concerns involving trend constraints, everyone. e. , shows - purpose regulatory provides. a rule-based and 2004 asserts seen instead parametrised generalization. Such specified are widely used; find, rest them most of the end reasons for their success of complexity broadcasters central understanding real - nations problems.", "histories": [["v1", "Wed, 10 Jul 2013 18:01:30 GMT  (455kb,D)", "http://arxiv.org/abs/1307.2867v1", "To appear in proceedings of CP'13, LNCS 8124. arXiv admin note: text overlap witharXiv:1307.1790"]], "COMMENTS": "To appear in proceedings of CP'13, LNCS 8124. arXiv admin note: text overlap witharXiv:1307.1790", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["david a cohen", "peter g jeavons", "evgenij thorstensen", "stanislav \\v{z}ivn\\'y"], "accepted": false, "id": "1307.2867"}, "pdf": {"name": "1307.2867.pdf", "metadata": {"source": "CRF", "title": "Tractable Combinations of Global Constraints", "authors": ["David A. Cohen", "Peter G. Jeavons"], "emails": ["d.cohen@rhul.ac.uk", "firstname.lastname@cs.ox.ac.uk", "s.zivny@warwick.ac.uk"], "sections": [{"heading": "1 Introduction", "text": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [23,30], and industrial configuration [1,22]. The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].\nHowever, much of this theoretical work has focused on problems where each constraint is represented explicitly, by a table of allowed assignments.\nIn practice, however, a lot of the success of CP is due to the use of specialpurpose constraint types for which the software tools provide dedicated algorithms [16,28,31]. Such constraints are known as global constraints and are usually represented implicitly by an algorithm in the solver. This algorithm may take as a parameter a description that specifies exactly which kinds of assignments a particular instance of this constraint should allow.\nTheoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local consistency for ? Supported by EPSRC grant EP/G055114/1 ?? Supported by a Senior Research Fellowship from Warwick\u2019s DIMAP.\nar X\niv :1\n30 7.\n28 67\nv1 [\ncs .A\nI] 1\n0 Ju\nindividual constraints. This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [5,29]. Another strand of research has explored when it is possible to replace global constraints by collections of explicitly represented constraints [6]. These techniques allow faster implementations of algorithms for individual constraints, but do not shed much light on the complexity of problems with multiple overlapping global constraints, which is something that practical problems frequently require.\nAs an example, consider the following family of constraint problems involving clauses and cardinality constraints of unbounded arity.\nExample 1. Consider a family of constraint problems on a set of Boolean variables {x1, x2, . . . , x3n} (where n = 2, 3, 4, . . .), with the following five constraints:\n\u2013 C1 is the binary clause x1 \u2228 x2n+1; \u2013 C2 is a cardinality constraint on {x1, x2, . . . , xn} specifying that exactly one\nof these variables takes the value 1; \u2013 C3 is a cardinality constraint on {x2n+1, x2n+2, . . . , x3n} specifying that ex-\nactly one of these variables takes the value 1; \u2013 C4 is a cardinality constraint on {x2, x3, . . . , x3n}\u2212 {x2n+1} specifying that\nexactly n+ 1 of these variables takes the value 1; \u2013 C5 is the clause \u00acxn+1 \u2228 \u00acxn+2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00acx2n.\nThis problem is illustrated in Figure 1.\nThis family of problems is not included in any previously known tractable class, but will be shown to be tractable using the results of this paper.\nAs discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity. Previous work in this area has assumed that the global constraints have specific representations, such as propagators [19], negative constraints [10], or GDNF/decision diagrams [9], and exploited properties particular to that representation. In contrast, here we investigate the conditions that yield efficiently solvable classes of constraint problems with global constraints, without requiring any specific representation. Many global constraints have succinct representations, so even problems with very simple structures are known to be hard in some cases [24, 29]. We will therefore need to impose some restrictions on the properties of the individual global constraints, as well as on the problem structure.\nTo obtain our results, we define a notion of equivalence on assignments and a new width measure that identifies variables that are constrained in exactly the same way. We then show that we can replace variables that are equated under our width measure with a single new variable whose domain represents the possible equivalence classes of assignments. Both of these simplification steps, merging variables and equating assignments, can be seen as techniques for eliminating symmetries in the original problem formulation. We describe some sufficient conditions under which these techniques provide a polynomial-time reduction to a known tractable case, and hence identify new tractable classes of constraint problems involving global constraints."}, {"heading": "2 Global Constraints and Constraint Problems", "text": "In order to be more precise about the way in which global constraints are represented, we will extend the standard definition of a constraint problem.\nDefinition 1 (Variables and assignments). Let V be a set of variables, each with an associated set of domain elements. We denote the set of domain elements (the domain) of a variable v by D(v). We extend this notation to arbitrary subsets of variables, W , by setting D(W ) =\n\u22c3 v\u2208W D(v).\nAn assignment of a set of variables V is a function \u03b8 : V \u2192 D(V ) that maps every v \u2208 V to an element \u03b8(v) \u2208 D(v). We denote the restriction of \u03b8 to a set of variables W \u2286 V by \u03b8|W . We also allow the special assignment \u22a5 of the empty set of variables. In particular, for every assignment \u03b8, we have \u03b8|\u2205 = \u22a5.\nGlobal constraints have traditionally been defined, somewhat vaguely, as constraints without a fixed arity, possibly also with a compact representation of the constraint relation. For example, in [23] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.\nBelow, we offer a precise definition similar to the one in [5], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time. Our definition differs from this one in that we separate the general algorithm of a\nglobal constraint (which we call its type) from the specific description. This separation allows us a better way of measuring the size of a global constraint, which in turn helps us to establish new complexity results.\nDefinition 2 (Global constraints). A global constraint type is a parametrised polynomial-time algorithm that determines the acceptability of an assignment of a given set of variables.\nEach global constraint type, e, has an associated set of descriptions, \u2206(e). Each description \u03b4 \u2208 \u2206(e) specifies appropriate parameter values for the algorithm e. In particular, each \u03b4 \u2208 \u2206(e) specifies a set of variables, denoted by vars(\u03b4).\nA global constraint e[\u03b4], where \u03b4 \u2208 \u2206(e), is a function that maps assignments of vars(\u03b4) to the set {0, 1}. Each assignment that is allowed by e[\u03b4] is mapped to 1, and each disallowed assignment is mapped to 0. The extension or constraint relation of e[\u03b4] is the set of assignments, \u03b8, of vars(\u03b4) such that e[\u03b4](\u03b8) = 1. We also say that such assignments satisfy the constraint, while all other assignments falsify it.\nWhen we are only interested in describing the set of assignments that satisfy a constraint, and not in the complexity of determining membership in this set, we will sometimes abuse notation by writing \u03b8 \u2208 e[\u03b4] to mean e[\u03b4](\u03b8) = 1.\nAs can be seen from the definition above, a global constraint is not usually explicitly represented by listing all the assignments that satisfy it. Instead, it is represented by some description \u03b4 and some algorithm e that allows us to check whether the constraint relation of e[\u03b4] includes a given assignment. To stay within the complexity class NP, this algorithm is required to run in polynomial time. As the algorithms for many common global constraints are built into modern constraint solvers, we measure the size of a global constraint\u2019s representation by the size of its description.\nExample 2 (EGC). A very general global constraint type is the extended global cardinality constraint type [26, 29]. This form of global constraint is defined by specifying for every domain element a a finite set of natural numbersK(a), called the cardinality set of a. The constraint requires that the number of variables which are assigned the value a is in the set K(a), for each possible domain element a.\nUsing our notation, the description \u03b4 of an EGC global constraint specifies a function K\u03b4 : D(vars(\u03b4)) \u2192 P(N) that maps each domain element to a set of natural numbers. The algorithm for the EGC constraint then maps an assignment \u03b8 to 1 if and only if, for every domain element a \u2208 D(vars(\u03b4)), we have that |{v \u2208 vars(\u03b4) | \u03b8(v) = a}| \u2208 K\u03b4(a).\nThe cardinality constraint C2 from Example 1 can be expressed as an EGC global constraint with description \u03b4 such that K\u03b4(1) = {1}, and K\u03b4(0) = {n\u22121}.\nExample 3 (Clauses). We can view the disjunctive clauses used to define propositional satisfiability problems as a global constraint type in the following way.\nThe description \u03b4 of a clause is simply a list of the literals that it contains, and vars(\u03b4) is the corresponding set of variables. The algorithm for the clause then maps any Boolean assignment \u03b8 of vars(\u03b4) that satisfies the disjunction of the literals specified by \u03b4 to 1, and all other assignments to 0.\nNote that a clause forbids precisely one assignment to vars(\u03b4) (the one that falsifies all of the literals in the clause). Hence the extension of a clause contains 2|vars(\u03b4)|\u22121 assignments, so the size of the constraint relation grows exponentially with the number of variables, but the size of the constraint description grows only linearly.\nExample 4 (Table and negative constraints). A rather degenerate example of a a global constraint type is the table constraint.\nIn this case the description \u03b4 is simply a list of assignments of some fixed set of variables, vars(\u03b4). The algorithm for a table constraint then decides, for any assignment of vars(\u03b4), whether it is included in \u03b4. This can be done in a time which is linear in the size of \u03b4 and so meets the polynomial time requirement.\nNegative constraints are complementary to table constraints, in that they are described by listing forbidden assignments. The algorithm for a negative constraint e[\u03b4] decides, for any assignment of vars(\u03b4), whether it is not included in \u03b4. Observe that the clauses described in Example 3 are a special case of the negative constraint type, as they have exactly one forbidden assignment.\nWe observe that any global constraint can be rewritten as a table or negative constraint. However, this rewriting will, in general, incur an exponential increase in the size of the description.\nDefinition 3 (CSP instance). An instance of the constraint satisfaction problem (CSP) is a pair \u3008V,C\u3009 where V is a finite set of variables, and C is a set of global constraints such that for every e[\u03b4] \u2208 C, vars(\u03b4) \u2286 V . In a CSP instance, we call vars(\u03b4) the scope of the constraint e[\u03b4].\nA solution to a CSP instance \u3008V,C\u3009 is an assignment \u03b8 of V which satisfies every global constraint, i.e., for every e[\u03b4] \u2208 C we have \u03b8|vars(\u03b4) \u2208 e[\u03b4].\nThe general constraint satisfaction problem is clearly NP-complete, so in the remainder of the paper we shall look for more restricted versions of the problem that are tractable, that is, solvable in polynomial time."}, {"heading": "3 Restricted Classes of Constraint Problems", "text": "First, we are going to consider restrictions on the way that the constraints in a given instance interact with each other, or, in other words, the way that the constraint scopes overlap; such restrictions are known as structural restrictions [11,17,20].\nDefinition 4 (Hypergraph). A hypergraph \u3008V,H\u3009 is a set of vertices V together with a set of hyperedges H \u2286 P(V ).\nGiven a CSP instance P = \u3008V,C\u3009, the hypergraph of P , denoted hyp(P ), has vertex set V together with a hyperedge vars(\u03b4) for every e[\u03b4] \u2208 C.\nOne special class of hypergraphs that has received a great deal of attention is the class of acyclic hypergraphs [3]. This notion is a generalisation of the idea of tree-structure in a graph, and has been very important in the analysis of relational databases. A hypergraph is said to be acyclic if repeatedly removing all hyperedges contained in other hyperedges, and all vertices contained in only a single hyperedge, eventually deletes all vertices [3].\nSolving a CSP instance P whose constraints are represented extensionally (i.e., as table constraints) is known to be tractable if the hypergraph of P , hyp(P ), is acyclic [21]. Indeed, this has formed the basis for more general notions of \u201cbounded cyclicity\u201d [21] or \u201cbounded hypertree width\u201d [18], which have also been shown to imply tractability for problems with explicitly represented constraint relations. However, this is no longer true if the constraints are global, not even when we have a fixed, finite domain, as the following examples show.\nExample 5. Any hypergraph containing only a single edge is clearly acyclic (and therefore has hypertree width one [18]), but the class of CSP instances consisting of a single EGC constraint over an unbounded domain is NP-complete [26].\nExample 6. The NP-complete problem of 3-colourability [15] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.\nWe may reduce this problem to a CSP with EGC constraints (cf. Example 2) as follows: Let V be the set of variables for our CSP instance, each with domain {r, g, b}. For every edge \u3008v, w\u3009 \u2208 E, we post an EGC constraint with scope {v, w}, parametrised by the function K such that K(r) = K(g) = K(b) = {0, 1}. Finally, we make the hypergraph of this CSP instance acyclic by adding an EGC constraint with scope V parametrised by the function K \u2032 such that K \u2032(r) = K \u2032(g) = K \u2032(b) = {0, . . . , |V |}. This reduction clearly takes polynomial time, and the hypergraph of the resulting instance is acyclic.\nThese examples indicate that when dealing with implicitly represented constraints we cannot hope for tractability using structural restrictions alone. We are therefore led to consider hybrid restrictions, which restrict both the nature of the constraints and the structure at the same time.\nDefinition 5 (Constraint catalogue). A constraint catalogue is a set of global constraints. A CSP instance \u3008V,C\u3009 is said to be over a constraint catalogue C if for every e[\u03b4] \u2208 C we have e[\u03b4] \u2208 C.\nPrevious work on the complexity of constraint problems has restricted the extensions of the constraints to a specified set of relations, known as a constraint language [7]. This is an appropriate form of restriction when all constraints are given explicitly, as table constraints. However, here we work with global constraints where the relations are often implicit, and this can significantly alter the complexity of the corresponding problem classes, as we will illustrate below. Hence we allow a more general form of restriction on the constraints by specifying a constraint catalogue containing all allowed constraints.\nDefinition 6 (Restricted CSP class). Let C be a constraint catalogue, and let H be a class of hypergraphs. We define CSP(H, C) to be the class of CSP instances over C whose hypergraphs are in H.\nUsing Definition 6, we will restate an earlier structural tractability result, which will form the basis for our results in Section 5.\nDefinition 7 (Treewidth). A tree decomposition of a hypergraph \u3008V,H\u3009 is a pair \u3008T, \u03bb\u3009 where T is a tree and \u03bb is a labelling function from nodes of T to subsets of V , such that\n1. for every v \u2208 V , there exists a node t of T such that v \u2208 \u03bb(t), 2. for every hyperedge h \u2208 E, there exists a node t of T such that h \u2286 \u03bb(t), and 3. for every v \u2208 V , the set of nodes {t | v \u2208 \u03bb(t)} induces a connected subtree\nof T .\nThe width of a tree decomposition is max({|\u03bb(t)| \u2212 1 | t node of T}). The treewidth tw(G) of a hypergraph G is the minimum width over all its tree decompositions.\nLet H be a class of hypergraphs, and define tw(H) to be the maximum treewidth over the hypergraphs in H. If tw(H) is unbounded we write tw(H) = \u221e; otherwise tw(H) <\u221e.\nWe can now restate using the language of global constraints the following result, from Dalmau et al. [12], which builds on several earlier results [13,14].\nTheorem 1 ( [12]). Let C be a constraint catalogue and H a class of hypergraphs. CSP(H, C) is tractable if tw(H) <\u221e.\nObserve that the family of constraint problems described in Example 1 is not covered by the above result, because the treewidth of the associated hypergraphs is unbounded."}, {"heading": "4 Cooperating Constraint Catalogues", "text": "Whenever constraint scopes overlap, we may ask whether the possible assignments to the variables in the overlap are essentially different. It may be that some assignments extend to precisely the same satisfying assignments in each of the overlapping constraints. If so, we may as well identify such assignments.\nDefinition 8 (Disjoint union of assignments). Let \u03b81 and \u03b82 be two assignments of disjoint sets of variables V1 and V2, respectively. The disjoint union of \u03b81 and \u03b82, denoted \u03b81 \u2295 \u03b82, is the assignment of V1 \u222a V2 such that (\u03b81 \u2295 \u03b82)(v) = \u03b81(v) for all v \u2208 V1, and (\u03b81 \u2295 \u03b82)(v) = \u03b82(v) for all v \u2208 V2.\nDefinition 9 (Projection). Let \u0398 be a set of assignments of a set of variables V . The projection of \u0398 onto a set of variables X \u2286 V is the set of assignments \u03c0X(\u0398) = {\u03b8|X | \u03b8 \u2208 \u0398}.\nNote that when \u0398 = \u2205 we have \u03c0X(\u0398) = \u2205 for any set X, but when X = \u2205 and \u0398 6= \u2205, we have \u03c0X(\u0398) = {\u22a5}.\nDefinition 10 (Assignment extension). Let e[\u03b4] be a global constraint, and X \u2286 vars(\u03b4). For every assignment \u00b5 of X, let ext(\u00b5, e[\u03b4]) = \u03c0vars(\u03b4)\u2212X({\u03b8 \u2208 e[\u03b4] | \u03b8|X = \u00b5}).\nIn other words, for any assignment \u00b5 of X, the set ext(\u00b5, e[\u03b4]) is the set of assignments of vars(\u03b4) \u2212 X that extend \u00b5 to a satisfying assignment for e[\u03b4]; i.e., those assignments \u03b8 for which \u00b5\u2295 \u03b8 \u2208 e[\u03b4].\nDefinition 11 (Extension equivalence). Let e[\u03b4] be a global constraint, and X \u2286 vars(\u03b4). We say that two assignments \u03b81, \u03b82 to X are extension equivalent on X with respect to e[\u03b4] if ext(\u03b81, e[\u03b4]) = ext(\u03b82, e[\u03b4]). We denote this equivalence relation by equiv[e[\u03b4], X]; that is, equiv[e[\u03b4], X](\u03b81, \u03b82) holds if and only if \u03b81 and \u03b82 are extension equivalent on X with respect to e[\u03b4].\nIn other words, two assignments to some subset of the variables of a constraint e[\u03b4] are extension equivalent if every assignment to the rest of the variables combines with both of them to give either two assignments that satisfy e[\u03b4], or two that falsify it.\nExample 7. Consider the special case of extension equivalence with respect to a clause (cf. Example 3).\nGiven any clause e[\u03b4], and any non-empty set of variables X \u2286 vars(\u03b4), any assignment toX will either satisfy one of the corresponding literals specified by \u03b4, or else falsify all of them. If it satisfies at least one of them, then any extension will satisfy the clause, so all such assignments are extension equivalent. If it falsifies all of them, then an extension will satisfy the clauses if and only if it satifies one of the other literals. Hence the equivalence relation equiv[e[\u03b4], X] has precisely 2 equivalence classes, one containing the single assignment that falsifies all the literals corresponding to X, and one containing all other assignments.\nDefinition 12 (Intersecting variables). Let S be a set of global constraints. We write iv(S) for the set of variables common to all of their scopes, that is, iv(S) = \u22c2 e[\u03b4]\u2208S vars(\u03b4).\nDefinition 13 (Join). For any set S of global constraints, we define the join of S, denoted join(S), to be a global constraint e\u2032[\u03b4\u2032] with vars(\u03b4\u2032) = \u22c3 e[\u03b4]\u2208S vars(\u03b4) such that for any assignment \u03b8 to vars(\u03b4\u2032), we have \u03b8 \u2208 e\u2032[\u03b4\u2032] if and only if for every e[\u03b4] \u2208 S we have \u03b8|vars(\u03b4) \u2208 e[\u03b4].\nThe join of a set of global constraints may have no simple compact description, and computing its extension may be computationally expensive. However, we introduce this construct simply in order to describe the combined effect of a set of global constraints in terms of a single constraint.\nExample 8. Let V = {v1, . . . , vn}, for some n \u2265 3, be a set of variables with D(vi) = {a, b, c}, and let S = {e1[\u03b41], e2[\u03b42]} be a set of two global constraints as defined below:\n\u2013 e1[\u03b41] is a table constraint with vars(\u03b41) = {v1, . . . , vn\u22121} which enforces equality, i.e., \u03b41 = {\u03b8a, \u03b8b, \u03b8c}, where for each x \u2208 D(V ) and v \u2208 vars(\u03b41), \u03b8x(v) = x. \u2013 e2[\u03b42] is a negative constraint with vars(\u03b42) = {v2, . . . , vn} which enforces a not-all-equal condition, i.e., \u03b42 = {\u03b8a, \u03b8b, \u03b8c}, where for each x \u2208 D(V ) and v \u2208 vars(\u03b42), \u03b8x(v) = x.\nWe will use substitution notation to write assignments explicitly; thus, an assignment of {v, w} that assigns a to both variables is written {v/a, w/a}.\nWe have that iv(S) = {v2, . . . , vn\u22121}. The equivalence classes of assignments to iv(S) under equiv[join(S), iv(S)] are {{v2/a, . . . , vn\u22121/a}}, {{v2/b, . . . , vn\u22121/b}}, and {{v2/c, . . . , vn\u22121/c}}, each containing the single assignment shown, as well as (for n > 3) a final class containing all other assignments, for which we can choose an arbitrary representative assignment, \u03b80, such as {v2/a, v3/b, . . . , vn\u22121/b}.\nEach assignment in the first 3 classes has just 2 possible extensions that satisfy join(S), since the value assigned to v1 must equal the value assigned to v2, . . . , vn\u22121, and the value assigned to vn must be different. The assignment \u03b80 has no extensions, since ext(\u03b80, e1[\u03b41]) = \u2205.\nHence the number of equivalence classes in equiv[join(S), iv(S)] is at most 4, even though the total number of possible assignments of iv(S) is 3n\u22122\nDefinition 14 (Cooperating constraint catalogue). We say that a constraint catalogue C is a cooperating catalogue if for any finite set of global constraints S \u2286 C, we can compute a set of assignments of the variables iv(S) containing at least one representative of each equivalence class of equiv[join(S), iv(S)] in polynomial time in the size of iv(S) and the total size of the constraints in S.\nNote that this definition requires two things. First, that the number of equivalence classes in the equivalence relation equiv[join(S), iv(S)] is bounded by some fixed polynomial in the size of iv(S) and the size of the constraints in S. Secondly, that a suitable set of representatives for these equivalence classes can be computed efficiently from the constraints.\nExample 9. Consider a constraint catalogue consisting entirely of clauses (of arbitrary arity). It was shown in Example 7 that for any clause e[\u03b4] and any non-empty X \u2286 vars(\u03b4) the equivalence relation equiv[e[\u03b4], X] has precisely 2 equivalence classes.\nIf we consider some finite set, S, of clauses, then a similar argument shows that the equivalence relation equiv[join(S), iv(S)] has at most |S| + 1 classes. These are given by the single assignments of the variables in iv(S) that falsify the literals corresponding to the variables of iv(S) in each clause (there are at most |S| of these \u2014 they may not all be distinct) together with at most one further equivalence class containing all other assignments (which must satisfy at least one literal in each clause of S).\nHence the total number of equivalence classes in the equivalence relation equiv[join(S), iv(S)] increases at most linearly with the number of clauses in S, and a representative for each class can be easily obtained from the descriptions of these clauses, by projecting the falsifying assignments down to the set of common variables, iv(S), and adding at most one more, arbitrary, assignment.\nBy same argument, if we consider some finite set, S, of table constraints, then the equivalence relation equiv[join(S), iv(S)] has at most one class for each assignment allowed by each table constraint in S, together with at most one further class containing all other assignments.\nIn general, arbitrary EGC constraints (cf. Example 2) do not form a cooperating catalogue. However, we will show that if we bound the size of the variable domains, then the resulting EGC constraints do form a cooperating catalogue.\nDefinition 15 (Counting function). Let X be a set of variables with domain D = \u22c3 x\u2208X D(x). A counting function for X is any function K : D \u2192 N such\nthat \u2211 a\u2208DK(a) = |X|.\nEvery assignment \u03b8 to X defines a corresponding counting function K\u03b8 given by K\u03b8(a) = |{x \u2208 X | \u03b8(x) = a}| for every a \u2208 D.\nIt is easy to verify that no EGC constraint can distinguish two assignments with the same counting function; for any EGC constraint, either both assignments satisfy it, or they both falsify it. It follows that two assignments with the same counting function are extension equivalent with respect to EGC constraints.\nDefinition 16 (Counting constraints). A global constraint e[\u03b4] is called a counting constraint if, for any two assignments \u03b81, \u03b82 of vars(\u03b4) which have the same counting function, either \u03b81, \u03b82 \u2208 e[\u03b4] or \u03b81, \u03b82 6\u2208 e[\u03b4].\nEGC constraints are not the only constraint type with this property. Constraints that require the sum (or the product) of the values of all variables in their scope to take a particular value, and constraints that require the minimum (or maximum) value of the variables in their scope to take a certain value, are also counting constraints.\nAnother example is given by the NValue constraint type, which requires that the number of distinct domain values taken by an assignment is a member of a specified set of acceptable numbers.\nExample 10 (NValue constraint type [4, 6]). In an NValue constraint, e[\u03b4], the description \u03b4 specifies a finite set of natural numbers L\u03b4 \u2282 N. The algorithm e maps an assignment \u03b8 to 1 if |{\u03b8(v) | v \u2208 vars(\u03b4)}| \u2208 L\u03b4.\nThe reason for introducing counting functions is the following key property, previously noted by Bulatov and Marx [8].\nProperty 1. The number of possible counting functions for a set of variables X is at most (|X|+|D|\u22121 |D|\u22121 ) = O(|X||D|), where D = \u22c3 x\u2208X D(x).\nProof. If every variable x \u2208 X has D as its set of domain elements, that is, D(x) = D, then every counting function corresponds to a distinct way of partitioning |X| variables into at most |D| boxes. There are (|X|+|D|\u22121 |D|\u22121 ) ways of doing so [27, Section 2.3.3]. On the other hand, if there are variables x \u2208 X such that D(x) \u2282 D, then that disallows some counting functions.\nTheorem 2. Any constraint catalogue that contains only counting constraints with bounded domain size, table constraints, and negative constraints, is a cooperating catalogue.\nProof. Let C be a constraint catalogue containing only global constraints of the specified types, and let S \u2286 C be a finite subset of C. Partition S into two subsets: SC , containing only counting constraints and S\u00b1 containing only table and negative constraints.\nLet K be a set containing assignments of iv(S), such that for every counting function K for iv(S), there is some assignment \u03b8K \u2208 K with K\u03b8 = K. By Property 1, the number of counting functions for iv(S) is bounded by O(|iv(S)|d), where d is the bound on the domain size for the counting constraints in C. Hence such a set K can be computed in polynomial time in the size of iv(S).\nFor each constraint in S\u00b1 we have that the description is a list of assignments (these are the allowed assignments for the table constraints and the forbidden assignments for the negative constraints, see Example 4).\nAs we described in Example 9, for each table constraint e[\u03b4] \u2208 S, we can obtain a representative for each equivalence class of equiv[e[\u03b4], iv(S)] by taking the projection onto iv(S) of each allowed assignment, which we can denote by \u03c0iv(S)(\u03b4), together with at most one further, arbitrary, assignment, \u03b80, that is not in this set. This set of assignments contains at least one representative for each equivalence class of equiv[e[\u03b4], iv(S)] (and possibly more than one representative for some of these classes).\nSimilarly, for each negative constraint e[\u03b4] \u2208 S, we can obtain a representative for each equivalence class of equiv[e[\u03b4], iv(S)], by taking the projection onto iv(S) of each forbidden assignment, which we can again denote by \u03c0iv(S)(\u03b4), together with at most one further, arbitrary, assignment, \u03b80, that is not in this set.\nNow consider the set of assignments A = K\u222a{\u03b80}\u222a \u22c3\ne[\u03b4]\u2208S\u00b1 \u03c0iv(S)(\u03b4), where \u03b80\nis an arbitrary assignment of iv(S) which does not occur in \u03c0iv(S)(\u03b4) for any e[\u03b4] \u2208 S (if such an assignment exists). We claim that this set of assignments contains at least one representative for each equivalence class of equiv[join(S), iv(S)] (and possibly more than one for some classes).\nTo establish this claim we will show that any assignment \u03b8 of iv(S) that is not in A must be extension equivalent to some member of A. Let \u03b8 be an assignment of iv(S) that is not in A (if such an assignment exists). If S\u00b1 contains any positive constraints, then \u03b8 has an empty set of extensions to these constraints, and hence is extension equivalent to \u03b80. Otherwise, any extension of \u03b8 will satisfy all negative constraints in S\u00b1, so the extensions of \u03b8 that satisfy join(S)\nare completely determined by the counting function K\u03b8. In this case \u03b8 will be extension equivalent to some element of K.\nMoreover, the set of assignments A can be computed from S in polynomial time in the the size of iv(S) and the total size of the descriptions of the constraints in S\u00b1. Therefore, C is a cooperating catalogue as described in Definition 14.\nExample 11. By Theorem 2, the constraints in Example 1 form a cooperating catalogue."}, {"heading": "5 Polynomial-time Reductions", "text": "In this section, we will show that, for any constraint problem over a cooperating catalogue, a set of variables that all occur in exactly the same set of constraint scopes can be replaced by a single new variable with an appropriate domain, to give a polynomial-time reduction to a smaller problem.\nDefinition 17 (Dual of a hypergraph). Let G = \u3008V,H\u3009 be a hypergraph. The dual G\u2217 of G is a hypergraph with vertex set H and a hyperedge {h \u2208 H | v \u2208 h} for every v \u2208 V . For a class H of hypergraphs, let H\u2217 = {G\u2217 | G \u2208 H}.\nExample 12. Consider the hypergraphG in Figure 1. The dual,G\u2217, of this hypergraph has vertex set {C1, C2, C3, C4, C5} and five hyperedges {C1, C2}, {C1, C3}, {C2, C4}, {C3, C4} and {C4, C5}. This transformation is illustrated in Figure 2.\nG G*\nNote that the dual of the dual of a hypergraph is not necessarily the original hypergraph, since we do not allow multiple identical hyperedges.\nExample 13. Consider the dual hypergraph G\u2217 defined in Example 12. Taking the dual of this hypergraph yields G\u2217\u2217, with vertex set {h1, . . . , h5} (corresponding to the 5 hyperedges in G\u2217) and 5 distinct hyperedges, as shown in Figure 3.\nG* G**\nIn the example above, taking the dual of a hypergraph twice had the effect of merging precisely those sets of variables that occur in the same set of hyperedges. It is easy to verify that this is true in general: Taking the dual twice equates precisely those variables that occur in the same set of hyperedges.\nLemma 1. For any hypergraph G, the hypergraph G\u2217\u2217 has precisely one vertex corresponding to each maximal subset of vertices of G that occur in the same set of hyperedges.\nNext, we combine the idea of the dual with the usual notion of treewidth to create a new measure of width.\nDefinition 18 (twDD). Let G be a hypergraph. The treewidth of the dual of the dual (twDD) of G is twDD(G) = tw(G\u2217\u2217).\nFor a class of hypergraphs H, we define twDD(H) = tw(H\u2217\u2217).\nExample 14. Consider the class H of hypergraphs of the family of problems described in Example 1. Whatever the value of n, the dual hypergraph, G\u2217 is the same, as shown in Figure 2. Hence for all problems in this family the hypergraph G\u2217\u2217 is as shown in Figure 3, and can be shown to have treewidth 3. Hence twDD(H) = 3.\nWhen replacing a set of variables in a CSP instance with a single variable, we will use the following definition.\nDefinition 19 (Quotient of a CSP instance). Let P = \u3008V,C\u3009 be a CSP instance and X \u2286 V be a non-empty subset of variables that all occur in the scopes of the same set S of constraints. The quotient of P with respect to X, denoted PX , is defined as follows.\n\u2013 The variables of PX are given by V X = (V \u2212 X) \u222a {vX}, where vX is a fresh variable, and the domain of vX is the set of equivalence classes of equiv[join(S), X].\n\u2013 The constraints of PX are unchanged, except that each constraint e[\u03b4] \u2208 S is replaced by a new constraint eX [\u03b4X ], where vars(\u03b4X) = (vars(\u03b4)\u2212X)\u222a{vX}. For any assignment \u03b8 of vars(\u03b4X), we define eX [\u03b4X ](\u03b8) to be 1 if and only if \u03b8|vars(\u03b4)\u2212X \u2295 \u00b5 \u2208 e[\u03b4], where \u00b5 is a representative of the equivalence class \u03b8(vX).\nWe note that, by Definition 11, the value of eX [\u03b4X ] specified in Definition 19 is well-defined, that is, it does not depend on the specific representative chosen for the equivalence class \u03b8(vX), since each representative has the same set of possible extensions.\nLemma 2. Let P = \u3008V,C\u3009 be a CSP instance and X \u2286 V be a non-empty subset of variables that all occur in the scopes of the same set of constraints. The instance PX has a solution if and only if P has a solution.\nProof (Sketch). Let P = \u3008V,C\u3009 and X be given, and let S \u2286 C be the set of constraints e[\u03b4] such that X \u2286 vars(\u03b4).\nConstruct the instance PX as specified in Definition 19. Any solution to P can be converted into a corresponding solution for PX , and vice versa. This conversion process just involves replacing the part of the solution assignment that gives values to the variables in the set X with an assignment that gives a suitable value to the new variable vX .\nTheorem 3. Any CSP instance P can be converted to an instance P \u2032 with hyp(P \u2032) = hyp(P )\u2217\u2217, such that P \u2032 has a solution if and only if P does. Moreover, if P is over a cooperating catalogue, this conversion can be done in polynomial time.\nProof. Let P = \u3008V,C\u3009 be a CSP instance. For each variable v \u2208 V we define S(v) = {e[\u03b4] \u2208 C | v \u2208 vars(\u03b4)} We then partition the vertices of P into subsets X1, . . . , Xk, where each Xi is a maximal subset of variables v that share the same value for S(v).\nWe initially set P0 = P . Then, for each Xi in turn, we set Pi = (Pi\u22121)X . Finally we set P \u2032 = Pk. By Lemma 1, hyp(P \u2032) = hyp(P )\u2217\u2217, and by Lemma 2, P \u2032 has a solution if and only if P has a solution.\nFinally, if P is over a cooperating catalogue, then by Definition 14, we can compute the domains of each new variable introduced in polynomial time in the size of each Xi and the total size of the constraints. Hence we can compute P \u2032 in polynomial time.\nUsing Theorem 3, we can immediately get a new tractable CSP class by extending Theorem 1.\nTheorem 4. Let C be a constraint catalogue and H a class of hypergraphs. CSP(H, C) is tractable if C is a cooperating catalogue and twDD(H) <\u221e.\nProof. Let C be a cooperating catalogue, H a class of hypergraphs such that twDD(H) < \u221e, and P \u2208 CSP(H, C). Reduce P to a CSP instance P \u2032 using\nTheorem 3. By Definition 18, since hyp(P \u2032) = hyp(P )\u2217\u2217, tw(hyp(P \u2032)) < \u221e, which means that P \u2032 satisfies the conditions of Theorem 1, and hence can be solved in polynomial time.\nRecall the family of constraint problems described in Example 1 at the start of this paper. Since the constraints in this problem form a cooperating catalogue (Example 11), and all instances have bounded twDD (Example 14), this family of problems is tractable by Theorem 4."}, {"heading": "6 Summary and Future Work", "text": "We have identified a novel tractable class of constraint problems with global constraints. In fact, our results generalize several previously studied classes of problems [12]. Moreover, this is the first representation-independent tractability result for constraint problems with global constraints.\nOur new class is defined by restricting both the nature of the constraints and the way that they interact. As demonstrated in Example 5, instances with a single global constraint may already be NP-complete [26], so we cannot hope to achieve tractability by structural restrictions alone. In other words, notions such as bounded degree of cyclicity [21] or bounded hypertree width [18] are not sufficient to ensure tractability in the framework of global constraints, where the arity of individual constraints is unbounded. This led us to introduce the notion of a cooperating constraint catalogue, which is sufficiently restricted to ensure that an individual constraint is always tractable.\nHowever, this restriction on the nature of the constraints is still not enough to ensure tractability on any structure: Example 6 demonstrates that not all structures are tractable even with a cooperating constraint catalogue. In fact, a family of problems with acyclic structure (hypertree width one) over a cooperating constraint catalogue can still be NP-complete. This led us to investigate restrictions on the structure that are sufficient to ensure tractability for all instances over a cooperating catalogue. In particular, we have shown that it is sufficient to ensure that the dual of the dual of the hypergraph of the instance has bounded treewidth.\nAn intriguing open question is whether there are other restrictions on the nature of the constraints or the structure of the instances that are sufficient to ensure tractability in the framework of global constraints. Very little work has been done on this question, apart from the pioneering work of Bulatov and Marx [8], which considered only a single global cardinality constraint, along with arbitrary table constraints, and of Chen and Dalmau [9] on two specific succinct representations. Almost all other previous work on tractable classes has considered only table constraints. This may be one reason why such work has had little practical impact on the design of constraint solvers, which rely heavily on the use of in-built special-purpose global constraints.\nWe see this paper as a first step in the development of a more robust and applicable theory of tractability for global constraints."}], "references": [{"title": "Optimization methods for the partner units problem", "author": ["M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen"], "venue": "Proc. CPAIOR\u201911. LNCS, vol. 6697, pp. 4\u201319. Springer", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "Structural decomposition methods and what they are good for", "author": ["M. Aschinger", "C. Drescher", "G. Gottlob", "P. Jeavons", "E. Thorstensen"], "venue": "Schwentick, T., D\u00fcrr, C. (eds.) Proc. STACS\u201911. LIPIcs, vol. 9, pp. 12\u201328", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "On the desirability of acyclic database schemes", "author": ["C. Beeri", "R. Fagin", "D. Maier", "M. Yannakakis"], "venue": "Journal of the ACM 30, 479\u2013513", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1983}, {"title": "Pruning for the minimum constraint family and for the number of distinct values constraint family", "author": ["N. Beldiceanu"], "venue": "Proc. CP\u201901. LNCS, vol. 2239, pp. 211\u2013224. Springer", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "The complexity of reasoning with global constraints", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "T. Walsh"], "venue": "Constraints 12(2), 239\u2013259", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2007}, {"title": "Decomposition of the NValue constraint", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "C.G. Quimper", "T. Walsh"], "venue": "Proc. CP\u201910. LNCS, vol. 6308, pp. 114\u2013128. Springer", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "Classifying the complexity of constraints using finite algebras", "author": ["A. Bulatov", "P. Jeavons", "A. Krokhin"], "venue": "SIAM Journal on Computing 34(3), 720\u2013742", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2005}, {"title": "The complexity of global cardinality constraints", "author": ["A.A. Bulatov", "D. Marx"], "venue": "Logical Methods in Computer Science 6(4:4), 1\u201327", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Constraint satisfaction with succinctly specified relations", "author": ["H. Chen", "M. Grohe"], "venue": "Journal of Computer and System Sciences 76(8), 847\u2013860", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Constraint representations and structural tractability", "author": ["D.A. Cohen", "M.J. Green", "C. Houghton"], "venue": "Proc. CP\u201909. LNCS, vol. 5732, pp. 289\u2013303. Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "A unified theory of structural tractability for constraint satisfaction problems", "author": ["D.A. Cohen", "P. Jeavons", "M. Gyssens"], "venue": "Journal of Computer and System Sciences 74(5), 721\u2013743", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2008}, {"title": "Constraint satisfaction, bounded treewidth, and finite-variable logics", "author": ["V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi"], "venue": "Proc. CP\u201902. LNCS, vol. 2470, pp. 223\u2013254. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2002}, {"title": "Tree clustering for constraint networks", "author": ["R. Dechter", "J. Pearl"], "venue": "Artificial Intelligence 38(3), 353\u2013366", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1989}, {"title": "Complexity of k-tree structured constraint satisfaction problems", "author": ["E.C. Freuder"], "venue": "Proc. AAAI, pp. 4\u20139. AAAI Press / The MIT Press", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1990}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": "W. H. Freeman", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1979}, {"title": "MINION: A fast, scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "Proc. ECAI\u201906, pp. 98\u2013102. IOS Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2006}, {"title": "A comparison of structural CSP decomposition methods", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Artificial Intelligence 124(2), 243\u2013282", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2000}, {"title": "Hypertree decompositions and tractable queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences 64(3), 579\u2013627", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2002}, {"title": "Structural tractability of propagated constraints", "author": ["M.J. Green", "C. Jefferson"], "venue": "Proc. CP\u201908. LNCS, vol. 5202, pp. 372\u2013386. Springer", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2008}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM 54(1), 1\u201324", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "Decomposing constraint satisfaction problems using database techniques", "author": ["M. Gyssens", "P.G. Jeavons", "D.A. Cohen"], "venue": "Artificial Intelligence 66(1), 57\u201389", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1994}, {"title": "Bin repacking scheduling in virtualized datacenters", "author": ["F. Hermenier", "S. Demassey", "X. Lorca"], "venue": "Proc. CP\u201911. LNCS, vol. 6876, pp. 27\u201341. Springer", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Global constraints", "author": ["W.J. van Hoeve", "I. Katriel"], "venue": "Rossi, F., van Beek, P., Walsh, T. (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, chap. 6, pp. 169\u2013208. Elsevier", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2006}, {"title": "Simultaneous matchings: Hardness and approximation", "author": ["M. Kutz", "K. Elbassioni", "I. Katriel", "M. Mahajan"], "venue": "Journal of Computer and System Sciences 74(5), 884\u2013897", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "Tractable hypergraph properties for constraint satisfaction and conjunctive queries", "author": ["D. Marx"], "venue": "Proc. STOC\u201910, pp. 735\u2013744. ACM", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "Improved algorithms for the global cardinality constraint", "author": ["C.G. Quimper", "A. L\u00f3pez-Ortiz", "P. van Beek", "A. Golynski"], "venue": "Proc. CP\u201904. LNCS, vol. 3258, pp. 542\u2013556. Springer", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2004}, {"title": "Handbook of Discrete and Combinatorial Mathematics", "author": ["K.H. Rosen", "J.G. Michaels", "J.L. Gross", "J.W. Grossman", "Shier", "D.R. (eds."], "venue": "Discrete Mathematics and Its Applications, CRC Press", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2000}, {"title": "The Handbook of Constraint Programming", "author": ["F. Rossi", "P. van Beek", "Walsh", "T. (eds."], "venue": "Elsevier", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2006}, {"title": "Tractable cases of the extended global cardinality constraint", "author": ["M. Samer", "S. Szeider"], "venue": "Constraints 16(1), 1\u201324", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "Practical applications of constraint programming", "author": ["M. Wallace"], "venue": "Constraints 1, 139\u2013 168", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1996}, {"title": "ECLiPSe: A platform for constraint logic programming", "author": ["M. Wallace", "S. Novello", "J. Schimpf"], "venue": "ICL Systems Journal 12(1), 137\u2013158", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1997}], "referenceMentions": [{"referenceID": 22, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [23,30], and industrial configuration [1,22].", "startOffset": 116, "endOffset": 123}, {"referenceID": 29, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [23,30], and industrial configuration [1,22].", "startOffset": 116, "endOffset": 123}, {"referenceID": 0, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [23,30], and industrial configuration [1,22].", "startOffset": 154, "endOffset": 160}, {"referenceID": 21, "context": "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [23,30], and industrial configuration [1,22].", "startOffset": 154, "endOffset": 160}, {"referenceID": 1, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 6, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 10, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 16, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 19, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 24, "context": "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [2, 7, 11,17,20,25].", "startOffset": 287, "endOffset": 306}, {"referenceID": 15, "context": "In practice, however, a lot of the success of CP is due to the use of specialpurpose constraint types for which the software tools provide dedicated algorithms [16,28,31].", "startOffset": 160, "endOffset": 170}, {"referenceID": 27, "context": "In practice, however, a lot of the success of CP is due to the use of specialpurpose constraint types for which the software tools provide dedicated algorithms [16,28,31].", "startOffset": 160, "endOffset": 170}, {"referenceID": 30, "context": "In practice, however, a lot of the success of CP is due to the use of specialpurpose constraint types for which the software tools provide dedicated algorithms [16,28,31].", "startOffset": 160, "endOffset": 170}, {"referenceID": 4, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [5,29].", "startOffset": 121, "endOffset": 127}, {"referenceID": 28, "context": "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [5,29].", "startOffset": 121, "endOffset": 127}, {"referenceID": 5, "context": "Another strand of research has explored when it is possible to replace global constraints by collections of explicitly represented constraints [6].", "startOffset": 143, "endOffset": 146}, {"referenceID": 8, "context": "As discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity.", "startOffset": 16, "endOffset": 19}, {"referenceID": 18, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [19], negative constraints [10], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 118, "endOffset": 122}, {"referenceID": 9, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [19], negative constraints [10], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 145, "endOffset": 149}, {"referenceID": 8, "context": "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [19], negative constraints [10], or GDNF/decision diagrams [9], and exploited properties particular to that representation.", "startOffset": 177, "endOffset": 180}, {"referenceID": 23, "context": "Many global constraints have succinct representations, so even problems with very simple structures are known to be hard in some cases [24, 29].", "startOffset": 135, "endOffset": 143}, {"referenceID": 28, "context": "Many global constraints have succinct representations, so even problems with very simple structures are known to be hard in some cases [24, 29].", "startOffset": 135, "endOffset": 143}, {"referenceID": 22, "context": "For example, in [23] a global constraint is defined as \u201ca constraint that captures a relation between a non-fixed number of variables\u201d.", "startOffset": 16, "endOffset": 20}, {"referenceID": 4, "context": "Below, we offer a precise definition similar to the one in [5], where the authors define global constraints for a domain D over a list of variables \u03c3 as being given intensionally by a function D|\u03c3| \u2192 {0, 1} computable in polynomial time.", "startOffset": 59, "endOffset": 62}, {"referenceID": 25, "context": "A very general global constraint type is the extended global cardinality constraint type [26, 29].", "startOffset": 89, "endOffset": 97}, {"referenceID": 28, "context": "A very general global constraint type is the extended global cardinality constraint type [26, 29].", "startOffset": 89, "endOffset": 97}, {"referenceID": 10, "context": "First, we are going to consider restrictions on the way that the constraints in a given instance interact with each other, or, in other words, the way that the constraint scopes overlap; such restrictions are known as structural restrictions [11,17,20].", "startOffset": 242, "endOffset": 252}, {"referenceID": 16, "context": "First, we are going to consider restrictions on the way that the constraints in a given instance interact with each other, or, in other words, the way that the constraint scopes overlap; such restrictions are known as structural restrictions [11,17,20].", "startOffset": 242, "endOffset": 252}, {"referenceID": 19, "context": "First, we are going to consider restrictions on the way that the constraints in a given instance interact with each other, or, in other words, the way that the constraint scopes overlap; such restrictions are known as structural restrictions [11,17,20].", "startOffset": 242, "endOffset": 252}, {"referenceID": 2, "context": "One special class of hypergraphs that has received a great deal of attention is the class of acyclic hypergraphs [3].", "startOffset": 113, "endOffset": 116}, {"referenceID": 2, "context": "A hypergraph is said to be acyclic if repeatedly removing all hyperedges contained in other hyperedges, and all vertices contained in only a single hyperedge, eventually deletes all vertices [3].", "startOffset": 191, "endOffset": 194}, {"referenceID": 20, "context": ", as table constraints) is known to be tractable if the hypergraph of P , hyp(P ), is acyclic [21].", "startOffset": 94, "endOffset": 98}, {"referenceID": 20, "context": "Indeed, this has formed the basis for more general notions of \u201cbounded cyclicity\u201d [21] or \u201cbounded hypertree width\u201d [18], which have also been shown to imply tractability for problems with explicitly represented constraint relations.", "startOffset": 82, "endOffset": 86}, {"referenceID": 17, "context": "Indeed, this has formed the basis for more general notions of \u201cbounded cyclicity\u201d [21] or \u201cbounded hypertree width\u201d [18], which have also been shown to imply tractability for problems with explicitly represented constraint relations.", "startOffset": 116, "endOffset": 120}, {"referenceID": 17, "context": "Any hypergraph containing only a single edge is clearly acyclic (and therefore has hypertree width one [18]), but the class of CSP instances consisting of a single EGC constraint over an unbounded domain is NP-complete [26].", "startOffset": 103, "endOffset": 107}, {"referenceID": 25, "context": "Any hypergraph containing only a single edge is clearly acyclic (and therefore has hypertree width one [18]), but the class of CSP instances consisting of a single EGC constraint over an unbounded domain is NP-complete [26].", "startOffset": 219, "endOffset": 223}, {"referenceID": 14, "context": "The NP-complete problem of 3-colourability [15] is to decide, given a graph \u3008V,E\u3009, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.", "startOffset": 43, "endOffset": 47}, {"referenceID": 6, "context": "Previous work on the complexity of constraint problems has restricted the extensions of the constraints to a specified set of relations, known as a constraint language [7].", "startOffset": 168, "endOffset": 171}, {"referenceID": 11, "context": "[12], which builds on several earlier results [13,14].", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[12], which builds on several earlier results [13,14].", "startOffset": 46, "endOffset": 53}, {"referenceID": 13, "context": "[12], which builds on several earlier results [13,14].", "startOffset": 46, "endOffset": 53}, {"referenceID": 11, "context": "Theorem 1 ( [12]).", "startOffset": 12, "endOffset": 16}, {"referenceID": 3, "context": "Example 10 (NValue constraint type [4, 6]).", "startOffset": 35, "endOffset": 41}, {"referenceID": 5, "context": "Example 10 (NValue constraint type [4, 6]).", "startOffset": 35, "endOffset": 41}, {"referenceID": 7, "context": "The reason for introducing counting functions is the following key property, previously noted by Bulatov and Marx [8].", "startOffset": 114, "endOffset": 117}, {"referenceID": 11, "context": "In fact, our results generalize several previously studied classes of problems [12].", "startOffset": 79, "endOffset": 83}, {"referenceID": 25, "context": "As demonstrated in Example 5, instances with a single global constraint may already be NP-complete [26], so we cannot hope to achieve tractability by structural restrictions alone.", "startOffset": 99, "endOffset": 103}, {"referenceID": 20, "context": "In other words, notions such as bounded degree of cyclicity [21] or bounded hypertree width [18] are not sufficient to ensure tractability in the framework of global constraints, where the arity of individual constraints is unbounded.", "startOffset": 60, "endOffset": 64}, {"referenceID": 17, "context": "In other words, notions such as bounded degree of cyclicity [21] or bounded hypertree width [18] are not sufficient to ensure tractability in the framework of global constraints, where the arity of individual constraints is unbounded.", "startOffset": 92, "endOffset": 96}, {"referenceID": 7, "context": "Very little work has been done on this question, apart from the pioneering work of Bulatov and Marx [8], which considered only a single global cardinality constraint, along with arbitrary table constraints, and of Chen and Dalmau [9] on two specific succinct representations.", "startOffset": 100, "endOffset": 103}, {"referenceID": 8, "context": "Very little work has been done on this question, apart from the pioneering work of Bulatov and Marx [8], which considered only a single global cardinality constraint, along with arbitrary table constraints, and of Chen and Dalmau [9] on two specific succinct representations.", "startOffset": 230, "endOffset": 233}], "year": 2013, "abstractText": "We study the complexity of constraint satisfaction problems involving global constraints, i.e., special-purpose constraints provided by a solver and represented implicitly by a parametrised algorithm. Such constraints are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. Previous work has focused on the development of efficient propagators for individual constraints. In this paper, we identify a new tractable class of constraint problems involving global constraints of unbounded arity. To do so, we combine structural restrictions with the observation that some important types of global constraint do not distinguish between large classes of equivalent solutions.", "creator": "LaTeX with hyperref package"}}}