{"id": "1309.6297", "review": {"conference": "aaai", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Sep-2013", "title": "Generating Explanations for Biomedical Queries", "abstract": "We re protagonist computation models have randomized to output (outing directly \u03c0 though) nuances any labs queries, make anybody through segment. We improve themselves arithmetic although integrating going in BIOQUERY - ASP. We explores second usefulness latter these use before taking adjacent analyzes requesting related, counter initial, over the institute concerning offshore PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY though ORPHADATA. To reveal place Theory where Practice which Logic Programming (TPLP ).", "histories": [["v1", "Tue, 24 Sep 2013 19:28:44 GMT  (617kb,D)", "http://arxiv.org/abs/1309.6297v1", "42 pages, 14 figures, 4 tables, online appendix (proofs, 24 pages)"]], "COMMENTS": "42 pages, 14 figures, 4 tables, online appendix (proofs, 24 pages)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["esra erdem", "umut oztok"], "accepted": true, "id": "1309.6297"}, "pdf": {"name": "1309.6297.pdf", "metadata": {"source": "CRF", "title": "Generating Explanations for Biomedical Queries", "authors": ["ESRA ERDEM", "UMUT OZTOK", "Esra Erdem", "Umut Oztok"], "emails": ["esraerdem@sabanciuniv.edu)", "uoztok@sabanciuniv.edu)"], "sections": [{"heading": null, "text": "KEYWORDS: answer set programming, explanation generation, query answering, biomedical queries\n1 Introduction\nRecent advances in health and life sciences have led to generation of a large amount of biomedical data, represented in various biomedical databases or ontologies. That these databases and ontologies are represented in different formats and constructed/maintained independently from each other at different locations, have brought about many challenges for answering complex biomedical queries that require integration of knowledge represented in these ontologies and databases. One of the challenges for the users is to be able to represent such a biomedical query in a natural language, and get its answers in an understandable form. Another challenge is to extract relevant knowledge from different knowledge resources, and integrate them appropriately using also definitions, such as, chains of gene-gene interactions, cliques of genes based on gene-gene relations, or similarity/diversity of genes/drugs. Furthermore, once an answer is found for a complex query, the experts may need further explanations about the answer.\nTable 1 displays a list of complex biomedical queries that are important from the point of view of drug discovery. In the queries, drug-drug interactions present negative interactions among drugs, and gene-gene interactions present both negative and positive interactions among genes. Consider, for instance the query Q6. New molecule synthesis by changing substitutes of parent compound may lead to different biochemical and physiological effects; and each trial may lead to different indications. Such studies are important for fast inventions of new molecules. For example, while developing the drug Lovastatin (a member of the drug class of Hmg-coa reductase inhibitors, used for lowering cholesterol) from Aspergillus terreus (a sort of fungus) in 1979, scientists at Merck derived a new molecule named Simvastatin that also belongs to the same drug category (a hypolipidemic drug used\nar X\niv :1\n30 9.\n62 97\nv1 [\ncs .A\nI] 2\n4 Se"}, {"heading": "2 Esra Erdem, Umut Oztok", "text": "to control elevated cholesterol) targeting the same gene. Therefore, identifying genes targeted by a group of drugs automatically by means of queries like Q6 may be useful for experts.\nOnce an answer to a query is found, the experts may ask for an explanation to have a better understanding. For instance, an answer for the query Q3 in Table 1 is \u201cADRB1\u201d. A shortest explanation for this answer is as follows:\nThe drug Epinephrine targets the gene ADRB1 according to CTD. The gene DLG4 interacts with the gene ADRB1 according to BIOGRID.\nAn answer for the query Q8 is \u201cCASK\u201d. A shortest explanation for this answer is as follows:\nThe distance of the gene CASK from the start gene is 2. The gene CASK interacts with the gene DLG4 according to BIOGRID. The distance of the gene DLG4 from the start gene is 1.\nThe gene DLG4 interacts with the gene ADRB1 according to BIOGRID. ADRB1 is the start gene.\n(Statements with more indentations provide explanations for statements with less indentations.)\nTo address the first two challenges described above (i.e., representing complex queries in natural language and finding answers to queries efficiently), novel methods and a software system, called BIOQUERY-ASP (Erdem et al. 2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyn\u0301ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):\nGenerating Explanations for Biomedical Queries 3\n\u2022 Erdem and Yeniterzi (Erdem and Yeniterzi 2009) developed a controlled natural language, BIOQUERY-CNL, for expressing biomedical queries related to drug discovery. For instance, queries Q1\u2013Q10 in Table 1 are in this language. Recently, this language has been extended (called BIOQUERY-CNL*) to cover queries Q11\u2013 Q13 (Oztok 2012). Some algorithms have been introduced to translate a given query in BIOQUERY-CNL (resp. BIOQUERY-CNL*) to a program in ASP as well. \u2022 Bodenreider et al. (Bodenreider et al. 2008) introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer. This rule layer not only integrates those knowledge resources but also provides definitions of auxiliary concepts. \u2022 Erdem et al. (Erdem et al. 2011) have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query.\nThe details of representing biomedical queries in natural language and answering them using ASP are explained in a companion article. The focus of this article is the last challenge: generating explanations for biomedical queries.\nMost of the existing biomedical querying systems (e.g., web services built over the available knowledge resources) support keyword search but not complex queries like the queries in Table 1. None of the existing systems can provide informative explanations about the answers, but point to related web pages of the knowledge resources available online.\nThe contributions of this article can be summarized as follows.\n\u2022 We have formally defined \u201cexplanations\u201d in ASP, utilizing properties of programs and graphs. We have also defined variations of explanations, such as \u201cshortest explanations\u201d and \u201ck different explanations\u201d. \u2022 We have introduced novel generic algorithms to generate explanations for biomedical queries. These algorithms can compute shortest or k different explanations. We have analyzed the termination, soundness, and complexity of those algorithms. \u2022 We have developed a computational tool, called EXPGEN-ASP, that implements these explanation generation algorithms. \u2022 We have showed the applicability of our methods to generate explanations for answers of complex biomedical queries related to drug discovery. \u2022 We have embedded EXPGEN-ASP into BIOQUERY-ASP so that the experts can obtain explanations regarding the answers of biomedical queries, in a natural language.\nThe rest of the article is organized as follows. In Section 2, we provide a summary of Answer Set Programming. Next, in Section 3, we give an overview of BIOQUERYASP, in particular, the earlier work done on answering biomedical queries in ASP. Then, in Sections 4\u20136, we provide some definitions and algorithms related to generating shortest or k different explanations for an answer, also in ASP. Next, Section 7 illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources PHARMGKB (McDonagh et al. 2011),1 DRUGBANK (Knox et al. 2010),2\n1 http://www.pharmgkb.org/ 2 http://www.drugbank.ca/"}, {"heading": "4 Esra Erdem, Umut Oztok", "text": "BIOGRID (Stark et al. 2006),3 CTD (Davis et al. 2011),4 SIDER (Kuhn et al. 2010),5 DISEASE ONTOLOGY (Schriml et al. 2012)6 and ORPHADATA.7 In Sections 8 and 9, we discuss how to present explanations to the user in a natural language, and embedding of these algorithms in BIOQUERY-ASP. In Section 10, we provide a detailed analysis of the related work on \u201cjustifications\u201d (Pontelli et al. 2009) in comparison to explanations; and in Section 11, we briefly discuss other related work. We conclude in Section 12 by summarizing our contributions and pointing out some possible future work. Proofs are provided in the online appendix of the paper.\n3 http://thebiogrid.org/ 4 http://ctd.mdibl.org/ 5 http://sideeffects.embl.de/ 6 http://disease-ontology.org 7 http://www.orphadata.org\nGenerating Explanations for Biomedical Queries 5\n2 Answer Set Programming\nAnswer Set Programming (ASP) (Marek and Truszczyn\u0301ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems. The idea is to represent a problem as a \u201cprogram\u201d whose models (called \u201canswer sets\u201d (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions. The answer sets for the given program can then be computed by special implemented systems called answer set solvers. ASP has a high-level representation language that allows recursive definitions, aggregates, weight constraints, optimization statements, and default negation.\nASP also provides efficient solvers, such as CLASP (Gebser et al. 2007). Due to the continuous improvement of the ASP solvers and highly expressive representation language of ASP which is supported by a strong theoretical background that results from a years of intensive research, ASP has been applied fruitfully to a wide range of areas. Here are, for instance, three applications of ASP used in industry:\n\u2022 Decision Support Systems: An ASP-based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks (Nogueira et al. 2001) (used by United Space Alliance). \u2022 Automated Product Configuration: A web-based commercial system uses an ASPbased product configuration technology (Tiihonen et al. 2003) (used by Variantum Oy). \u2022 Workforce Management: An ASP-based system is developed to build teams of employees to handle incoming ships by taking into account a variety of requirements, e.g., skills, fairness, regulations (Ricca et al. 2012) (used by Gioia Tauro seaport).\nLet us briefly explain the syntax and semantics of ASP programs and describe how a computational problem can be solved in ASP.\n2.1 Programs\nSyntax The input language of ASP programs are composed of three sets namely constant symbols, predicate symbols, and variable symbols where intersection of constant symbols and variable symbols is empty. The basic elements of the ASP programs are atoms. An atom p(~t) is composed of a predicate symbol p and terms ~t = t1, . . . , tk where each ti (1 \u2264 i \u2264 k) is either a constant or a variable. A literal is either an atom p(~t) or its negated form not p(~t).\nAn ASP program is a finite set of rules of the form:\nA\u2190 A1, . . . , Ak, not Ak+1, . . . , not Am (1) where m \u2265 k \u2265 0 and each Ai is an atom; whereas, A is an atom or \u22a5.\nFor a rule r of the form (1), A is called the head of the rule and denoted by H(r). The conjunction of the literals A1, . . . , Ak, not Ak+1, . . . , not Am is called the body of r. The set {A1, ..., Ak} of atoms (called the positive part of the body) is denoted by B+(r), and the set {Ak+1, ..., Am} of atoms (called the negative part of the body) is denoted by B\u2212(r), and all the atoms in the body are denoted by B(r) = B+(r) \u222aB\u2212(r)."}, {"heading": "6 Esra Erdem, Umut Oztok", "text": "We say that a rule r is a fact if B(r) = \u2205, and we usually omit the\u2190 sign. Furthermore, we say that a rule r is a constraint if the head of r is \u22a5, and we usually omit the \u22a5 sign.\nSemantics (Answer Sets) Answer sets of a program are defined over ground programs. We call an atom, rule, or program ground, if it does not contain any variables. Given a program \u03a0, the set U\u03a0 represents all the constants in \u03a0, and the set B\u03a0 represents all the ground atoms that can be constructed from atoms in \u03a0 with constants in U\u03a0. Also, Ground(\u03a0) denotes the set of all the ground rules which are obtained by substituting all variables in rules with the set of all possible constants in U\u03a0.\nA subset I of B\u03a0 is called an interpretation for \u03a0. A ground atom p is true with respect to an interpretation I if p \u2208 I; otherwise, it is false. Similarly, a set S of atoms is true (resp., false) with respect to I if each atom p \u2208 S is true (resp., false) with respect to I . An interpretation I satisfies a ground rule r, if H(r) is true with respect to I whenever B+(r) is true and B\u2212(r) is false with respect to I . An interpretation I is called a model of a program \u03a0 if it satisfies all the rules in \u03a0.\nThe reduct \u03a0I of a program \u03a0 with respect to an interpretation I is defined as follows:\n\u03a0I = {H(r)\u2190 B+(r) | r \u2208 Ground(\u03a0) s.t. I \u2229B\u2212(r) = \u2205} An interpretation I is an answer set for a program \u03a0, if it is a subset-minimal model\nfor \u03a0I , and AS(\u03a0) denotes the set of all the answer sets of a program \u03a0. For example, consider the following program \u03a01:\np\u2190 not q (2) and take an interpretation I = {p}. The reduct \u03a0I1 is as follows:\np (3)\nThe interpretation I is a model of the reduct (3). Let us take a strict subset I \u2032 of I which is \u2205. Then, the reduct \u03a0I\u20321 is again equal to (3); however, I \u2032 does not satisfy (3). Therefore, I = {p} is a subset-minimal model; hence an answer set of \u03a01. Note also that {p} is the only answer set of \u03a0.\n2.2 Generate-And-Test Representation Methodology with Special ASP Constructs\nThe idea of ASP (Lifschitz 2008) is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem, and to find the answer sets for that program using an answer set solver.\nWhen we represent a problem in ASP, two kinds of rules play an important role: those that \u201cgenerate\u201d many answer sets corresponding to \u201cpossible solutions\u201d, and those that can be used to \u201celiminate\u201d the answer sets that do not correspond to solutions. The rules\np\u2190 not q q \u2190 not p (4)\nare of the former kind: they generate the answer sets {p} and {q}. Constraints are of the latter kind. For instance, adding the constraint\n\u2190 p\nGenerating Explanations for Biomedical Queries 7\nto program (4) eliminates the answer sets for the program that contain p. In ASP, we use special constructs of the form\n{A1, . . . , An}c (5)\n(called choice expressions), and of the form\nl \u2264 {A1, . . . , Am} \u2264 u (6)\n(called cardinality expressions) where each Ai is an atom and l and u are nonnegative integers denoting the \u201clower bound\u201d and the \u201cupper bound\u201d (Simons et al. 2002). Programs using these constructs can be viewed as abbreviations for normal nested programs defined in (Ferraris and Lifschitz 2005). Expression (5) describes subsets of {A1, . . . , An}. Such expressions can be used in heads of rules to generate many answer sets. For instance, the answer sets for the program\n{p, q, r}c \u2190 (7) are arbitrary subsets of {p, q, r}. Expression (6) describes the subsets of the set {A1, . . . , Am} whose cardinalities are at least l and at most u. Such expressions can be used in constraints to eliminate some answer sets. For instance, adding the constraint\n\u2190 2 \u2264 {p, q, r} to program (7) eliminates the answer sets for (7) whose cardinalities are at least 2. We abbreviate the rules\n{A1, . . . , Am}c \u2190 Body \u2190 not (l \u2264 {A1, . . . , Am}) \u2190 not ({A1, . . . , Am} \u2264 u)\nby the rule\nl \u2264 {A1, . . . , Am}c \u2264 u\u2190 Body. In ASP, there are also special constructs that are useful for optimization problems. For instance, to compute answer sets that contain the maximum number of elements from the set {A1, . . . , Am}, we can use the following optimization statement.\nmaximize\u3008{A1, . . . , Am}\u3009\n2.3 Presenting Programs to Answer Set Solvers\nOnce we represent a computational problem as a program whose answer sets correspond to the solutions of the problem, we can use an answer set solver to compute the solutions of the problem. To present a program to an answer set solver, like CLASP, we need to make some syntactic modifications.\nRecall that answer sets for a program are defined over ground programs. Thus, the input of ASP solvers should be ground instantiations of the programs. For that, programs go through a \u201cgrounding\u201d phase in which variables in the program (if exists) are substituted by constants. For CLASP, we use the \u201cgrounder\u201d GRINGO (Gebser et al. 2011).\nAlthough the syntax of the input language of GRINGO is somewhat more restricted than the class of programs defined above, it provides a number of useful special constructs. For"}, {"heading": "8 Esra Erdem, Umut Oztok", "text": "instance, the head of a rule can be an expression of one of the forms\n{A1, . . . , An}c l \u2264 {A1, . . . , An}c {A1, . . . , An}c \u2264 u l \u2264 {A1, . . . , An}c \u2264 u\nbut the superscript c and the sign \u2264 are dropped. The body can also contain cardinality expressions but the sign \u2264 is dropped. In the input language of GRINGO, :- stands for\u2190, and each rule is followed by a period. For facts\u2190 is dropped. For instance, the rule\n1 \u2264 {p, q, r}c \u2264 1\u2190\ncan be presented to GRINGO as follow:\n1{p,q,r}1.\nVariables in a program are represented by strings whose initial letters are capitalized. The constants and predicate symbols, on the other hand, start with a lowercase letter. For instance, the program \u03a0n\npi \u2190 not pi+1 (1 \u2264 i \u2264 n)\ncan be presented to GRINGO as follows:\nindex(1..n). p(I) :- not p(I+1), index(I).\nHere, the auxiliary predicate index is a \u201cdomain predicate\u201d used to describe the ranges of variables. Variables can be also used \u201clocally\u201d to describe the list of formulas. For instance, the rule\n1 \u2264 {p1, . . . , pn} \u2264 1 can be expressed in GRINGO as follows\nindex(1..n). 1{p(I) : index(I)}1.\n3 Answering Biomedical Queries\nWe have earlier developed the software system BIOQUERY-ASP (Erdem et al. 2011) (see Figure 1) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drugdrug interactions, cliques of genes based on gene-gene relations, or similar/diverse genes. As depicted in Figure 1, BIOQUERY-ASP takes a query in a controlled natural language and transforms it into ASP. Meanwhile, it extracts knowledge from biomedical databases and ontologies, and integrates them in ASP. Afterwards, it computes an answer to the given query using an ASP solver.\nLet us give an example to illustrate these stages; the details of representing biomedical queries in natural language and answering them using ASP are explained in a companion article though.\nGenerating Explanations for Biomedical Queries 9\nFirst of all, let us mention that knowledge related to drug discovery is extracted from the biomedical databases/ontologies and represented in ASP. If the biomedical ontology is in RDF(S)/OWL then we can extract such knowledge using the ASP solver DLVHEX (Eiter et al. 2006) by making use of external predicates. For instance, consider as an external theory a Drug Ontology described in RDF. All triples from this theory can be exported using the external predicate &rdf:\ntriple_drug(X,Y,Z) :- &rdf[\"URI for Drug Ontology\"](X,Y,Z).\nThen the names of drugs can be extracted by DLVHEX using the rule:\ndrug_name(A) :- triple_drug(_,\"drugproperties:name\",A).\nSome knowledge resources are provided as relational databases, or more often as a set of triples (probably extracted from ontologies in RDF). In such cases, we use short scripts to transform the relations into ASP.\nTo relate the knowledge extracted from the biomedical databases or ontologies and also provide auxiliary definitions, a rule layer is constructed in ASP. For instance, drugs targeting genes are described by the relation drug_gene defined in the rule layer as follows:\ndrug_gene(D,G) :- drug_gene_pharmgkb(D,G). drug_gene(D,G) :- drug_gene_ctd(D,G).\nwhere drug_gene_pharmgkb and drug_gene_ctd are relations for extracting knowledge from relevant knowledge resources. The auxiliary concept of reachability of a gene from another gene by means of a chain of gene-gene interactions is defined in the rule layer as well:\ngene_reachable_from(X,1) :- gene_gene(X,Y), start_gene(Y). gene_reachable_from(X,N+1) :- gene_gene(X,Z),\ngene_reachable_from(Z,N), 0 < N, N < L, max_chain_length(L).\nNow, consider, for instance, the query Q11 from Table 1.\nQ11 What are the drugs that treat the disease Depression and that do not target the gene ACYP1?\nThis type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer\u2019s Viagra (Gower 2009).\nThis query is then translated into the following program in the language of GRINGO:\nwhat_be_drugs(DRG) :- cond1(DRG), cond2(DRG). cond1(DRG) :- drug_disease(DRG,\"Depression\"). cond2(DRG) :- drug_name(DRG), not drug_gene(DRG,\"ACYP1\"). answer_exists :- what_be_drugs(DRG). :- not answer_exists."}, {"heading": "10 Esra Erdem, Umut Oztok", "text": "where cond1 and cond2 are invented relations, drug_name, drug_disease and drug_gene are defined in the rule layer.\nOnce the query and the rule layer are in ASP, the parts of the rule layer that are relevant to the given query are identified by an algorithm (Erdem et al. 2011). For some queries, the relevant part of the program is almost 100 times smaller than the whole program (considering the number of ground rules).\nThen, given the query as an ASP program and the relevant knowledge as an ASP program, we can find answers to the query by computing an answer set for the union of these two programs using CLASP. For the query above an answer computed in this way is \u201cFluoxetine\u201d.\n4 Explaining an Answer for a Query\nOnce an answer is found for a complex biomedical query, the experts may need informative explanations about the answer, as discussed in the introduction. With this motivation, we study generating explanations for complex biomedical queries. Since the queries, knowledge extracted from databases and ontologies, and the rule layer are in ASP, our studies focus on explanation generation within the context of ASP.\nBefore we introduce our methods to generate explanations for a given query, let us introduce some definitions regarding explanations in ASP.\nLet \u03a0 be the relevant part of a ground ASP program with respect to a given biomedical query Q (also a ground ASP program), that contains rules describing the knowledge extracted from biomedical ontologies and databases, the knowledge integrating them, and the background knowledge. Rules in \u03a0 \u222a Q generally do not contain cardinality/choice expressions in the head; therefore, we assume that in \u03a0 \u222a Q only bodies of rules contain cardinality expressions. Let X be an answer set for \u03a0\u222aQ. Let p be an atom that characterizes an answer to the query Q. The goal is to find an \u201cexplanation\u201d as to why p is computed as an answer to the query Q, i.e., why is p in X? Before we introduce a definition of an explanation, we need the following notations and definitions.\nWe say that a set X of atoms satisfies a cardinality expression C of the form\nl \u2264 {A1, . . . , Am} \u2264 u\nif the cardinality of X \u2229 {A1, . . . , Am} is within the lower bound l and upper bound u. Also X satisfies a set SC of cardinality expressions (denoted by X |= SC), if X satisfies every element of SC.\nLet \u03a0 be a ground ASP program, r be a rule in \u03a0, p be an atom in \u03a0, and Y and Z be two sets of atoms. Let Bcard(r) denote the set of cardinality expressions that appear in the body of r. We say that r supports an atom p using atoms in Y but not in Z (or with respect to Y but Z), if the following hold:\nH(r) = p, B+(r) \u2286 Y \\Z, B\u2212(r) \u2229 Y = \u2205, Y |= Bcard(r)\n(8)\nWe denote the set of rules in \u03a0 that support p with respect to Y but Z, by \u03a0Y,Z(p).\nGenerating Explanations for Biomedical Queries 11\nWe now introduce definitions about explanations in ASP. We first define a generic tree whose vertices are labeled by either atoms or rules.\nDefinition 1 (Vertex-labeled tree) A vertex-labeled tree \u3008V,E, l,\u03a0, X\u3009 for a program \u03a0 and a set X of atoms is a tree \u3008V,E\u3009 whose vertices are labeled by a function l that maps V to \u03a0 \u222aX . In this tree, the vertices labeled by an atom (resp., a rule) are called atom vertices (resp., rule vertices).\nFor a vertex-labeled tree T = \u3008V,E, l,\u03a0, X\u3009 and a vertex v in V , we introduce the following notations:\n\u2022 ancT (v) denotes the set of atoms which are labels of ancestors of v. \u2022 desT (v) denotes the set of rule vertices which are descendants of v. \u2022 childE(v) denotes the set of children of v. \u2022 siblingE(v) denotes the set of siblings of v. \u2022 outE(v) denotes the set of out-going edges of v. \u2022 degE(v) denotes the degree of v and equals to |outE(v)|. \u2022 If degE(v) = 0, then v is a leaf vertex. \u2022 leaf (T ) denotes the set of leaves of T . \u2022 The root of T is the root of \u3008V,E\u3009. \u2022 T is empty if \u3008V,E\u3009 = \u3008\u2205, \u2205\u3009.\nWe now define a specific class of vertex-labeled trees which contains all possible \u201cexplanations\u201d for an atom.\nDefinition 2 (And-or explanation tree) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X . The and-or explanation tree for p with respect to \u03a0 and X is a vertex-labeled tree T = \u3008V,E, l,\u03a0, X\u3009 that satisfies the following:\n(i) for the root v \u2208 V of the tree, l(v) = p; (ii) for every atom vertex v \u2208 V ,\noutE(v) = {(v, v\u2032) | (v, v\u2032) \u2208 E, l(v\u2032) \u2208 \u03a0X,ancT (v\u2032)(l(v))};\n(iii) for every rule vertex v \u2208 V ,\noutE(v) = {(v, v\u2032) | (v, v\u2032) \u2208 E, l(v\u2032) \u2208 B+(l(v))};\n(iv) each leaf vertex is a rule vertex.\nLet us explain conditions (i)\u2212 (iv) in Definition 2 in detail.\n(i) The root of the and-or explanation tree T is labeled by the atom p. Intuitively, T contains all possible explanations for p.\n(ii) For every atom vertex v \u2208 V , there is an out-going edge (v, v\u2032) to a rule vertex v\u2032 \u2208 V under the following conditions: the rule that labels v\u2032 supports the atom that labels v, using atoms in X but not any atom that labels an ancestor of v\u2032. We want to exclude the atoms labeling ancestors of v\u2032 to ensure that the height of the and-or explanation tree is finite (e.g., otherwise, due to cyclic dependencies the tree may be infinite)."}, {"heading": "12 Esra Erdem, Umut Oztok", "text": "(iii) For every rule vertex v \u2208 V , there is an out-going edge (v, v\u2032) to an atom vertex if the atom that labels v\u2032 is in the positive body of the rule that labels v. In this way, we make sure that every atom in the positive body of the rule that labels v takes part in explaining the head of the rule that labels v. (iv) Together with Conditions (ii) and (iii) above, this condition guarantees that the leaves of the and-or explanation tree are rule vertices that are labeled by facts in the reduct of the given ASP program \u03a0 with respect to the given answer set X . Intuitively, this condition expresses that the leaves are self-explanatory.\nExample 1 Let \u03a0 be the program\na\u2190 b, c a\u2190 d d\u2190 b\u2190 c c\u2190\nand X = {a, b, c, d}. The and-or explanation tree for a with respect to \u03a0 and X is shown in Figure 2. Intuitively, the and-or explanation tree includes all possible \u201cexplanations\u201d for an atom. For instance, according to Figure 2, the atom a has two explanations:\n\u2022 One explanation is characterized by the rules that label the vertices in the left subtree of the root: a is in X because the rule\na\u2190 b, c\nsupport a. Moreover, this rule can be \u201capplied to generate a\u201d because b and c, the atoms in its positive body, are in X . Further, b is in X because the rule\nb\u2190 c\nsupports b. Further, c is in X because c is supported by the rule\nc\u2190\nwhich is self-explanatory. \u2022 The other explanation is characterized by the rules that label the vertices in the right\nsubtree of the root: a is in X because the rule\na\u2190 d\nsupports a. Further, this rule can be \u201capplied to generate a\u201d because d is in X . In addition, d is in X because d is supported by the rule\nd\u2190\nwhich is self-explanatory.\nProposition 1 Let \u03a0 be a ground ASP program and X be an answer set for \u03a0. For every p in X , the and-or explanation tree for p with respect to \u03a0 and X is not empty.\nNote that in the and-or explanation tree, atom vertices are the \u201cor\u201d vertices, and rule vertices are the \u201cand\u201d vertices. Then, we can obtain a subtree of the and-or explanation tree that contains an explanation, by visiting only one child of every atom vertex and every child of every rule vertex, starting from the root of the and-or explanation tree. Here is precise definition of such a subtree, called an explanation tree.\nDefinition 3 (Explanation tree) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X . An explanation tree in T is a vertex-labeled tree T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 such that\n(i) \u3008V \u2032, E\u2032\u3009 is a subtree of \u3008V,E\u3009; (ii) the root of \u3008V \u2032, E\u2032\u3009 is the root of \u3008V,E\u3009;\n(iii) for every atom vertex v\u2032 \u2208 V \u2032, degE\u2032(v\u2032) = 1; (iv) for every rule vertex v\u2032 \u2208 V \u2032, outE(v\u2032) \u2286 E\u2032.\nExample 2 Let T be the and-or explanation tree in Figure 2. Then, Figure 3 illustrates the explanation trees in T . These explanation trees characterize the two explanations for a explained in Example 1.\nAfter having defined the and-or explanation tree and an explanation tree for an atom, let us now define an explanation for an atom.\nDefinition 4 (Explanation) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, and p be an atom in X . A vertex-labeled tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 is an explanation for p with respect to \u03a0 and X if there exists an explanation tree \u3008V,E, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X such that\n(i) V \u2032 = {v | v is a rule vertex inV }; (ii) E\u2032 = {(v1, v2) | (v1, v), (v, v2) \u2208 E, for some atom vertex v \u2208 V }. Intuitively, an explanation can be obtained from an explanation tree by \u201cignoring\u201d its\natom vertices.\nExample 3 Let \u03a0 and X be defined as in Example 1. Then, Figure 4 depicts two explanations for a with respect to \u03a0 and X , described in Example 1.\nSo far, we have considered only positive programs in the examples. Our definitions can also be used in programs that contain negation and aggregates in the bodies of rules.\nExample 4 Let \u03a0 be the program\na\u2190 b, c, not e a\u2190 d, not b a\u2190 d, 1 \u2264 {b, c} \u2264 2 d\u2190 b\u2190 c c\u2190\nand X = {a, b, c, d}. The and-or explanation tree for a with respect to \u03a0 and X is shown in Figure 5(a). Here, the rule a\u2190 d, not b is not included in the tree as b is in X , whereas the rule a \u2190 b, c, not e is in the tree as e is not in X and, b and c are in X . Also, the rule a \u2190 d, 1 \u2264 {b, c} \u2264 2 is in the tree as d is in X and the cardinality expression 1 \u2264 {b, c} \u2264 2 is satisfied by X . An explanation for a with respect to \u03a0 and X is shown in Figure 5(b).\nNote that our definition of an and-or explanation tree considers positive body parts of the rules only to provide explanations. Therefore, explanation trees do not provide further explanations for negated literals (e.g., why an atom is not included in the answer set), or aggregates (e.g., why a cardinality constraint is satisfied) as seen in the example above.\n5 Generating Shortest Explanations\nAs can be seen in Figure 4, there might be more than one explanation for a given atom. Hence, it is not surprising that one may prefer some explanations to others. Consider biomedical queries about chains of gene-gene interactions like the query Q8 in Table 1. Answers of such queries may contain chains of gene-gene interactions with different lengths. For instance, an answer for this query is \u201cCASK\u201d. Figure 6 shows an explanation for this answer. Here, \u201cCASK\u201d is related to \u201cADRB1\u201d via a gene-gene chain interaction of length 2 (the chain \u201cCASK\u201d\u2013\u201cDLG4\u201d\u2013\u201cADRB1\u201d). Another explanation is partly shown in Figure 7. Now, \u201cCASK\u201d is related to \u201cADRB1\u201d via a gene-gene chain interaction of length 3 (the chain \u201cCASK\u201d\u2013\u201c DLG1\u201d\u2013\u201cDLG4\u201d\u2013\u201cADRB1\u201d). Since gene-gene interactions are important for drug discovery, it may be more desirable for the experts to reason about chains with shortest lengths.\nWith this motivation, we consider generating shortest explanations. Intuitively, an explanation S is shorter than another explanation S\u2032 if the number of rule vertices involved in S is less than the number of rule vertices involved in S\u2032. Then we can define shortest explanations as follows.\nDefinition 5 (Shortest explanation) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and S be an explanation (with vertices V ) for p with respect to \u03a0 and X . Then, S is a shortest explanation for p with respect to \u03a0 and X if there exists no explanation S\u2032 (with vertices V \u2032) for p with respect to \u03a0 and X such that |V \u2032| < |V |.\nExample 5 Let \u03a0 and X be defined as in Example 1. Then, Figure 4(b) is the shortest explanation for a with respect to \u03a0 and X .\nTo compute shortest explanations, we define a weight function that assigns weights to the vertices of the and-or explanation tree. Basically, the weight of an atom vertex (\u201cor\u201d\nGenerating Explanations for Biomedical Queries 17\nvertex) is equal to the minimum weight among weights of its children and the weight of a rule vertex (\u201cand\u201d vertex) is equal to sum of weights of its children plus 1. Then the idea is to extract a shortest explanation by propagating the weights of the leaves up and then traversing the vertices that contribute to the weight of the root. Let us define the weight of vertices in the and-or explanation tree.\nDefinition 6 (Weight function) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X . The weight function WT for T maps vertices in V to a positive integer and it is defined as follows.\nWT (v) = { min{WT (c) | c \u2208 childE(v)} if v is an atom vertex in V ; 1 +\n\u2211 c \u2208 childE(v) WT (c) otherwise.\nAlgorithm 1: Generating Shortest Explanations Input: \u03a0 : ground ASP program, X : answer set for \u03a0, p : atom in X . Output: a shortest explanation for p w.r.t \u03a0 and X , or an empty vertex-labeled tree.\n1 \u3008V,E, l,\u03a0, X\u3009 := createTree(\u03a0, X, p, {}); 2 if \u3008V,E\u3009 is not empty then 3 v \u2190 root of \u3008V,E\u3009; 4 calculateWeight(\u03a0, X, V, l, v, E,WT ); 5 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := extractExp(\u03a0, X, V, l, v, E,WT , \u2205,min); 6 return \u3008V \u2032, E\u2032, l,\u03a0, X\u3009; 7 else 8 return \u3008\u2205, \u2205, l,\u03a0, X\u3009;\nUsing this weight function, we develop Algorithm 1 to generate shortest explanations. Let us describe this algorithm. Algorithm 1 starts by creating the and-or explanation tree T for p with respect to \u03a0 and X (Line 1); for that it uses Algorithm 2. If T is not empty, then Algorithm 1 assigns weights to the vertices of T (Line 4), using Algorithm 3. As the final step, Algorithm 1 extracts a shortest explanation from T (Line 5), using Algorithm 4. The idea is to traverse an explanation tree of T , by the help of the weight function, and construct an explanation, which would be a shortest one, by contemplating only the rule vertices in the traversed explanation tree. If T is empty, Algorithm 1 returns an empty vertex-labeled tree.\nAlgorithm 2 (with the call createTree(\u03a0, X, p, {})) creates the and-or explanation tree for p with respect to \u03a0 and X recursively. With a call createTree(\u03a0, X, d, L), where L intuitively denotes the atoms labeling the atom vertices created so far, the algorithm considers two cases: d being an atom or a rule. In the former case, 1) the algorithm creates an atom vertex v for d, 2) it identifies the rules that support d, 3) for each such rule, it creates a vertex labeled tree (i.e., a subtree of the resulting and-or explanation tree), and 4) it connects these trees to the atom vertex v. In the latter case, if d is a rule in \u03a0, 1) the algorithm creates a rule vertex v for d, 2) it identifies the atoms in the positive part of the"}, {"heading": "18 Esra Erdem, Umut Oztok", "text": "Algorithm 2: createTree Input: \u03a0 : ground ASP program, X : answer set for \u03a0, d : an atom in X or a rule in\n\u03a0, L : set of atoms in X . Output: A vertex-labeled tree.\n1 V := \u2205, E := \u2205 ; 2 if d \u2208 X\\L then 3 v \u2190 Create an atom vertex s.t. l(v) = d ; 4 L := L \u222a {d}, V := V \u222a {v} ; 5 foreach r \u2208 \u03a0X,L(d) do 6 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := createTree(\u03a0, X, r, L); 7 if \u3008V \u2032, E\u2032\u3009 6= \u3008\u2205, \u2205\u3009 then 8 v\u2032 \u2190 root of \u3008V \u2032, E\u2032\u3009 s.t. l(v\u2032) = r; 9 V := V \u222a V \u2032, E := E \u222a {(v, v\u2032)} \u222a E\u2032 ;\n10 if E = \u2205 then return \u3008\u2205, \u2205, l,\u03a0, X\u3009; 11 else if d \u2208 \u03a0 then 12 v \u2190 Create a rule vertex s.t. l(v) = d ; 13 foreach a \u2208 B+(d) do 14 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := createTree(\u03a0, X, a, L); 15 if \u3008V \u2032, E\u2032\u3009 = \u3008\u2205, \u2205\u3009 then return \u3008\u2205, \u2205, l,\u03a0, X\u3009; 16 v\u2032 \u2190 root of \u3008V \u2032, E\u2032\u3009 s.t. l(v\u2032) = a; 17 V := V \u222a V \u2032, E := E \u222a {(v, v\u2032)} \u222a E\u2032;\n18 return \u3008V,E, l,\u03a0, X\u3009;\nrule, 3) it creates the and-or explanation tree for each such atom, and 4) it connects these trees to the rule vertex v.\nOnce the and-or explanation tree is created, Algorithm 3 assigns weights to all vertices in the tree by propagating the weights of the leaves (i.e., 1) up to the root in a bottom-up fashion using the weight function definition (i.e., Definition 6).\nAfter that, Algorithm 1 (with the call extractExp(\u03a0, X, V, l, v, E,WT , \u2205,min)) extracts a shortest explanation in a top-down fashion starting from the root by examining the weights of the vertices. In particular, if a visited vertex v is an atom vertex then the algorithm proceeds with the child of v with the minimum weight; otherwise, it considers all the children of v.\nThe execution of Algorithm 1 is also illustrated in Figure 8. First, the and-or explanation tree is generated, which has a generic structure as in Figure 8(a). Here, yellow vertices denote atom vertices and blue vertices denote rule vertices. Then, this tree is weighted as in Figure 8(b). Then, starting from the root, a subtree of the and-or explanation tree is traversed by visiting minimum weighted child of every atom vertex and every child of every rule vertex. This process is shown in Figure 8(c), where red vertices form the traversed subtree. From this subtree, an explanation is extracted by ignoring atom vertices and keeping the parent-child relationship of the tree as it is. The resulting explanation is depicted in Figure 8(d).\nGenerating Explanations for Biomedical Queries 19\nAlgorithm 3: calculateWeight Input: \u03a0 : ground ASP program, X : answer set for \u03a0, V : set of vertices,\nl : V \u2192 \u03a0 \u222aX , v : vertex in V , E : set of edges, WT : candidate weight function.\nOutput: Weight of v. 1 if l(v) \u2208 X then 2 foreach c \u2208 childE(v) do WT (c) := calculateWeight(\u03a0, X, V, l, c, E,WT ); 3 WT (v) := min{WT (c) | c \u2208 childE(v)}; 4 else if l(v) \u2208 \u03a0 then 5 WT (v) := 1; 6 foreach c \u2208 childE(v) do\nWT (v) := WT (v) + calculateWeight(\u03a0, X, V, l, c, E,WT );\n7 return WT (v);\nAlgorithm 4: extractExp Input: \u03a0 : ground ASP program, X : answer set for \u03a0, Vt : set of vertices,\nl : Vt \u2192 \u03a0 \u222aX , v : vertex in Vt, Et : set of edges, WT : weight function of T , r : rule vertex in Vt or \u2205, op: string min or max.\nOutput: A vertex-labeled tree \u3008V,E, l,\u03a0, X\u3009. 1 V := \u2205, E := \u2205; 2 if l(v) \u2208 X then 3 c\u2190 Pick op weighted child of v ; 4 if r 6= \u2205 then E := E \u222a {(r, c)}; 5 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := extractExp(\u03a0, X, Vt, l, c, Et,WT , r, op); 6 V := V \u222a V \u2032, E := E \u222a E\u2032; 7 else if l(v) \u2208 \u03a0 then 8 V := V \u222a {v}; 9 foreach c \u2208 childEt(v) do\n10 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := extractExp(\u03a0, X, Vt, l, c, Et,WT , v, op); 11 V := V \u222a V \u2032, E := E \u222a E\u2032;\n12 return \u3008V,E, l,\u03a0, X\u3009;\nProposition 2 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , Algorithm 1 terminates.\nProposition 3 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , Algorithm 1 either finds a shortest explanation for p with respect to \u03a0 and X or returns an empty vertexlabeled tree.\n20 Esra Erdem, Umut Oztok\nProposition 4 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , the time complexity of Algorithm 1 is O(|\u03a0||X| \u00d7 |B\u03a0|).\nWe generate the complete and-or explanation tree while finding a shortest explanation. In fact, we can find a shortest explanation by creating a partial and-or explanation tree using a branch-and-bound idea. In particular, the idea is to compute the weights of vertices during the creation of the and-or explanation tree and, in case there exists a branch of the and-or explanation tree that exceeds the weight of a vertex computed so far, to stop branching on unnecessary parts of the and-or explanation tree. Then, a shortest explanation can be extracted by the same method used previously, i.e., by traversing a subtree of the andor explanation tree and ignoring the atom vertices in this subtree. For instance, consider Figure 8(b). Assume that we first create the right branch of the root. Since the weight of an atom vertex is equal to the minimum weight among its children weights, we know that\nGenerating Explanations for Biomedical Queries 21\nAlgorithm 5: Generating k Different Explanations Input: \u03a0: ground ASP program, X: answer set for \u03a0, p: atom in X , k : a positive\ninteger. Assume there are n different explanations for p w.r.t \u03a0 and X . Output: min{n, k} different explanations for p with respect to \u03a0 and X .\n1 K := \u2205, R0 := \u2205; 2 \u3008V,E, l,\u03a0, X\u3009 := createTree(\u03a0, X, p, {}); 3 v \u2190 root of \u3008V,E\u3009; 4 for i = 1, 2, . . . k do 5 calculateDifference(\u03a0, X, V, l, v, E,Ri\u22121,WT,Ri\u22121); 6 if WT,Ri\u22121(v) = 0 then return K; 7 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 := extractExp(\u03a0, X, V, l, v, E,WT,Ri\u22121 , \u2205,max); 8 Ki \u2190 \u3008V \u2032, E\u2032, l,\u03a0, X\u3009; 9 K := K \u222a {Ki};\n10 Ri := Ri\u22121 \u222a {v | rule vertex v \u2208 V \u2032}; 11 return K;\nthe weight of the root is at most 2. Now, we check whether it is necessary to branch on the left child of the root. Note that the weight of a rule vertex is equal to 1 plus the sum of its children weights. As R1 has two children, its weight is at least 3. Therefore, it is redundant to branch on the left child of the root. This improvement is not implemented and is a future work.\n6 Generating k Different Explanations\nWhen there is more than one explanation for an answer of a query, it might be useful to provide the experts with several more explanations that are different from each other. For instance, consider the query Q5 in Table 1.\nQ5 What are the drugs that treat the disease Asthma or that react with the drug Epinephrine?\nAn answer for this query is \u201cDoxepin\u201d. According to one explanation, \u201cDoxepin\u201d reacts with \u201cEpinephrine\u201d with respect to DRUGBANK. At this point, the expert may not be convinced and ask for a different explanation. Another explanation for this answer is that \u201cDoxepin\u201d treats \u201cAsthma\u201d according to CTD. Motivated by this example, we study generating different explanations.\nWe introduce an algorithm (Algorithm 5) to compute k different explanations for an atom p in X with respect to \u03a0 and X . For that, we define a distance measure \u2206D between a set Z of (previously computed) explanations, and an (to be computed) explanation S. We consider the rule vertices RZ and RS contained in Z and S, respectively. Then, we define the function \u2206D that measures the distance between Z and S as follows:\n\u2206D(Z, S) = |RS\\RZ |.\nIn the following, we sometimes use RZ and RS instead of Z and S in \u2206D. Also, we denote by RVertices(S) the set of rule vertices of a vertex-labeled tree S."}, {"heading": "22 Esra Erdem, Umut Oztok", "text": "Algorithm 6: calculateDifference Input: \u03a0 : ground ASP program, X : answer set for \u03a0, V : set of vertices,\nl : V \u2192 \u03a0 \u222aX , v : vertex in V , E : set of edges, R : set of rule vertices in V , DR : candidate distance function.\nOutput: distance of v. 1 if l(v) \u2208 X then 2 foreach c \u2208 childE(v) do 3 DR(c) := calculateDifference(\u03a0, X, V, l, c, E,R,DR);\n4 DR(v) := max{DR(c) | c \u2208 childE(v)}; 5 else if l(v) \u2208 \u03a0 then 6 if v /\u2208 R then DR(v) := 1; 7 else DR(v) := 0; 8 foreach c \u2208 childE(v) do 9 DR(v) := DR(v) + calculateDifference(\u03a0, X, V, l, c, E,R,DR);\n10 return DR(v);\nLet us now explain Algorithm 5. It computes a set K of k different explanations iteratively. Initially, K = \u2205. First, we compute the and-or explanation tree T (Line 2). Then, we enter into a loop that iterates at most k times (Line 4). At each iteration i, an explanation Ki that is most distant from the previously computed i \u2212 1 explanations is extracted from T . Let us denote the rule vertices included in the previously computed i \u2212 1 explanations by Ri\u22121. Then, essentially, at each iteration we pick an explanation Ki such that \u2206D(Ri\u22121,RVertices(Ki)) is maximum. To be able to find such a Ki, we need to define the \u201ccontribution\u201d of each vertex v in T to the distance measure \u2206D(Ri\u22121,RVertices(Ki)) if v is included in explanation Ki:\nWT,Ri\u22121(v) =    max{WT,Ri\u22121(v\u2032) | v\u2032 \u2208 childE(v)} if v is an atom vertex;\u2211 v\u2032\u2208childE(v) WT,Ri\u22121(v \u2032) if v is a rule vertex and v \u2208 Ri\u22121;\n1 + \u2211\nv\u2032\u2208childE(v) WT,Ri\u22121(v \u2032) otherwise.\nNote that this function is different from WT . Intuitively, v contributes to the distance measure if it is not included in Ri\u22121. The contributions of vertices in T are computed by Algorithm 6 (Line 5) by propagating the contributions up in the spirit of Algorithm 3. Then, Ki is extracted from weighted-T by using Algorithm 4 (Line 7).\nThe execution of Algorithm 5 is also illustrated in Figure 9. Similar to Algorithm 1, which generates shortest explanations, first the and-or explanation tree is created, which has a generic structure as shown in Figure 9(a). Recall that yellow vertices denote atom vertices and blue vertices denote rule vertices. For the sake of example, assume that R = {R2, R6}. Then, the goal is to generate an explanation that contains different rule vertices from the rule vertices in R as much as possible. For that, the weights of vertices are assigned according to the weight function WT,R as depicted in Figure 9(b). Here, the weight of the root implies that there exists an explanation which contains 4 different rule vertices from the rule vertices in R and this explanation is the most different one. Then, starting\nGenerating Explanations for Biomedical Queries 23\nfrom the root, a subtree of the and-or explanation tree is traversed by visiting maximum weighted child of every atom vertex, and every child of every rule vertex. This subtree is shown in Figure 9(c) by red vertices. Finally, an explanation is extracted by ignoring the atom vertices and keeping the parent-child relationship as it is, from this subtree. This explanation is illustrated in Figure 9(d).\nProposition 5 Given a ground ASP program \u03a0, an answer set X for \u03a0, an atom p in X , and a positive integer k, Algorithm 5 terminates.\nProposition 6 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to \u03a0 and X . Then, Algorithm 5 returns min{n, k} different explanations for p with respect to \u03a0 and X .\nFurthermore, at each iteration i of the loop in Algorithm 5 the distance \u2206D(Ri\u22121,Ki) is maximized."}, {"heading": "24 Esra Erdem, Umut Oztok", "text": "Proposition 7 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to \u03a0 and X . Then, at the end of each iteration i (1 \u2264 i \u2264 min{n, k}) of the loop in Algorithm 5, \u2206D(Ri\u22121,RVertices(Ki)) is maximized, i.e., there is no other explanation K \u2032 such that \u2206D(Ri\u22121,RVertices(Ki)) < \u2206D(Ri\u22121,RVertices(K \u2032)).\nThis result leads us to some useful consequences. First, Algorithm 5 computes \u201clongest\u201d explanations if k = 1. The following corollary shows how to compute longest explanations.\nCorollary 1 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k = 1. Then, Algorithm 5 computes a longest explanation for p with respect to \u03a0 and X .\nNext, we show that Algorithm 5 computes k different explanations such that for every i (1 \u2264 i \u2264 k) the ith explanation is the most distant explanation from the previously computed i\u2212 1 explanations. Corollary 2 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to \u03a0 and X . Then, Algorithm 5 computes min{n, k} different explanations K1, . . . ,Kmin{n,k} for p with respect to \u03a0 and X such that for every j (2 \u2264 j \u2264 min{n, k}) \u2206D( \u22c3j\u22121 z=1 RVertices(Kz),Kj) is maximized.\nThe following proposition shows that the time complexity of Algorithm 5 is exponential in the size of the given answer set.\nProposition 8 Given a ground ASP program \u03a0, an answer set X for \u03a0, an atom p in X and a positive integer k, the time complexity of Algorithm 5 is O(k \u00d7 |\u03a0||X|+1 \u00d7 |B\u03a0|).\n7 Experiments with Biomedical Queries\nOur algorithms for generating explanations are applicable to the queries Q1, Q2, Q3, Q4, Q5, Q8, Q10, Q11 and Q12 in Table 1. The ASP programs for the other queries involve choice expressions. For instance, the query Q7 asks for cliques of 5 genes. We use the following rule to generate a possible set of 5 genes that might form a clique.\n5{clique(GEN):gene_name(GEN)}5.\nOur algorithms apply to ASP programs that contain a single atom in the heads of the rules, and negation and cardinality expressions in the bodies of the rules. Therefore, our methods are not applicable to the queries which are presented by ASP programs that include choice expressions.\nIn Table 2, we present the results for generating shortest explanations for the queries Q1, Q2, Q3, Q4, Q5, Q8, Q10, Q11 and Q12. In this table, the second column denotes the CPU timings to generate shortest explanations in seconds. The third column consists of the sizes\nGenerating Explanations for Biomedical Queries 25\nof explanations, i.e., the number of rule vertices in an explanation. In the fourth column, the sizes of answer sets, i.e., the number of atoms in an answer set, are given. The fifth column presents the sizes of the and-or explanation trees, i.e., the number of vertices in the tree.\nBefore telling what the last column presents, let us clarify an issue regarding the computation of explanations. Since answer sets contain millions of atoms, the relevant ground programs are also huge. Thus, first grounding the programs and then generating explanations over those grounded programs is an overkill in terms of computational efficiency. To this end, we apply another method and do grounding when it is necessary. To better explain the idea, let us present our method by an example. At the beginning, we have a ground atom for which we are looking for shortest explanations. Assume that this atom is what_be_genes(\"ADRB1\"). Then, we find the rules whose heads are of the form what_be_genes(GN), and instantiate GN with \u201cADRB1\u201d. For instance, assume that the following rule exists in the program:\nwhat_be_genes(GN)\u2190 drug_gene(DRG,GN)\nThen, by such an instantiation, we obtain the following instance of this rule:\nwhat_be_genes(\"ADRB1\")\u2190 drug_gene(DRG,\"ADRB1\")\nNext, if the rules that we obtain by instantiating their heads are not ground, we ground them using the grounder GRINGO considering the answer set. We apply the same method for the atoms that are now ground, to find the relevant rules and ground them if necessary. This allows us to deal with a relevant subset of the rules while generating explanations."}, {"heading": "26 Esra Erdem, Umut Oztok", "text": "The last column of Table 2 presents the number of times GRINGO is called for such incremental grounding. For instance, for the queries Q1, Q3 and Q5, GRINGO is never called. However, GRINGO is called 193 times during the computation of a shortest explanation for the query Q10.\nAs seen from the results presented in Table 2, the computation time is not very much related to the size of the explanation. As also suggested by the complexity results of Algorithm 1 (i.e., O(|\u03a0||X|\u00d7 |B\u03a0)|), the computation time for generating shortest explanations greatly depends on the sizes of the answer set and the and-or explanation tree. For instance, for the query Q4, the answer set contains approximately 19 million atoms, the size of the and-or explanation tree is 6690, and it takes 1245 CPU seconds to compute a shortest explanation, whereas for the query Q8, the answer set approximately contains 1 million atoms, the and-or explanation tree has 28 vertices, and it takes 40 CPU seconds to compute a shortest explanation. Also, the number of times GRINGO is called during the computation affects the computation time. For instance, for the query Q10 the answer set approximately contains 1.6 million atoms, the and-or explanation tree has 3419 vertices, and it takes 1600 CPU seconds to compute a shortest explanation.\nTable 3 shows the computation times for generating different explanations for the answers of the same queries, if exists. As seen from these results, the time for computing 2 and 4 different explanations is slightly different than the time for computing shortest explanations.\nGenerating Explanations for Biomedical Queries 27\n8 Presenting Explanations in a Natural Language\nAn explanation for an answer of a biomedical query may not be easy to understand, since the user may not know the syntax of ASP rules neither the meanings of predicates. To this end, it is better to present explanations to the experts in a natural language.\nObserve that leaves of an explanation denote facts extracted from the biomedical resources. Also some internal vertices contain informative explanations such as the position of a drug in a chain of drug-drug interactions. Therefore, there is a corresponding natural language explanation for some vertices in the tree. Such a correspondence can be stored in a predicate look-up table, like Table 4. Given such a look-up table, a pre-order depth-first traversal of an explanation and generating natural language expressions corresponding to vertices of the explanation lead to an explanation in natural language (Oztok 2012).\nFor instance, the explanation in Figure 6 is expressed in natural language as illustrated in the introduction.\n9 Implementation of Explanation Generation Algorithms\nBased on the algorithms introduced above, we have developed a computational tool called EXPGEN-ASP (Oztok 2012), using the programming language C++. Given an ASP program and its answer set, EXPGEN-ASP generates shortest explanations as well as k different explanations.\nThe input of EXPGEN-ASP are\n\u2022 an ASP program \u03a0, \u2022 an answer set X for \u03a0, \u2022 an atom p in X , \u2022 an option that is used to generate either a shortest explanation or k different expla-\nnations,"}, {"heading": "28 Esra Erdem, Umut Oztok", "text": "\u2022 a predicate look-up table, and the output are\n\u2022 a shortest explanation for p with respect to \u03a0 and X in a natural language (if shortest explanation option is chosen), \u2022 k different explanations for p with respect to \u03a0 and X in a natural language (if k different explanations option is chosen).\nFor generating shortest explanations (resp., k different explanations), EXPGEN-ASP utilizes Algorithm 1 (resp., Algorithm 5).\nTo provide experts with further informative explanations about the answers of biomedical queries, we have embedded EXPGEN-ASP into BIOQUERY-ASP by utilizing Table 4 as the predicate look-up table of the system. Figure 10 shows a snapshot of the explanation generation mechanism of BIOQUERY-ASP.\nGenerating Explanations for Biomedical Queries 29\n10 Relating Explanations to Justifications\nThe most similar work to ours is (Pontelli et al. 2009) that study the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d. As an answer to this question, the authors of (Pontelli et al. 2009) finds a \u201cjustification\u201d, which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set.\nExample 6 Let \u03a0 be the program presented in Example 1:\na\u2190 b, c a\u2190 d d\u2190 b\u2190 c c\u2190\nand X = {a, b, c, d}. Figure 11 is an offline justification of a+ with respect to X and \u2205. Intuitively, a is in X since b and c are also in X and there is a rule in \u03a0 that supports a using the atoms b and c. Furthermore, b is in X since c is in X and there is a rule in \u03a0 that supports b using the atom c. Finally, c is in X as it is a fact in \u03a0.\nTo relate offline justifications and explanations, we need to introduce the following definitions and notations about justifications defined in (Pontelli et al. 2009).\n10.1 Offline Justifications\nFirst, let us introduce notations related to ASP programs used in (Pontelli et al. 2009). The class of ASP programs studied is normal programs, i.e., programs that consist of the rules of the form\nA\u2190 A1, . . . , Ak, not Ak+1, . . . , not Am where m \u2265 k \u2265 0 and A and each Ai is an atom. Therefore, the programs we consider are more general. Let \u03a0 be a normal ASP program. Then, A\u03a0 is the Herbrand base of \u03a0. An interpretation I for a program \u03a0 is defined as a pair \u3008I+, I\u2212\u3009, where I+ \u222a I\u2212 \u2286 A\u03a0 and I+ \u2229 I\u2212 = \u2205. Intuitively, I+ denotes the set of atoms that are true, while I\u2212 denotes the"}, {"heading": "30 Esra Erdem, Umut Oztok", "text": "set of atoms that are false. I is a complete interpretation if I+ \u222a I\u2212 = A\u03a0. The reduct \u03a0I of \u03a0 with respect to I is defined as\n\u03a0I = {H(r)\u2190 B+(r) | r \u2208 \u03a0, B\u2212(r) \u2229 I+ = \u2205}\nA complete interpretation M for a program \u03a0 is an answer set for \u03a0 if M+ is an answer set for \u03a0M . Also, a literal is either an atom or a formula of the form not a where a is an atom. The set of atoms which appear as negated literals in \u03a0 is denoted by NANT (\u03a0). For an atom a, a+ denotes that the atom a is true and a\u2212 denotes that a\u2212 is false. Then, a+ and a\u2212 are called the annotated versions of a. Moreover, it is defined that atom(a+) = a and atom(a\u2212) = a. For a set S of atoms, the following sets of annotated atoms are defined.\n\u2022 Sp = {a+ | a \u2208 S} \u2022 Sn = {a\u2212 | a \u2208 S}\nFinally, the set not S is defined as not S = {not a | a \u2208 S}. Apart from the answer set semantics, there is another important semantics of logic programs, called the well-founded semantics (Gelder et al. 1991). Since this semantics is important to build the notion of a justification, we now briefly describe the well-founded semantics. We consider the definition proposed in (Apt and Bol 1994), instead of the original definition proposed in (Gelder et al. 1991), as the authors of (Pontelli et al. 2009) considered.\nDefinition 7 (Immediate consequence) Let \u03a0 be a normal ASP program, and S and V be two sets of atoms from A\u03a0. Then, the immediate consequence of S with respect to \u03a0 and V , denoted by T\u03a0,V (S) is the set defined as follows:\nT\u03a0,V (S) = {a | \u2203 r \u2208 \u03a0, H(r) = a, B+(r) \u2286 S, B\u2212(r) \u2229 V = \u2205}.\nWe denote by lfp(T\u03a0,V ) the least fixpoint of T\u03a0,V when V is fixed.\nDefinition 8 (The well-founded model) Let \u03a0 be a normal ASP program, \u03a0+ = {r | r \u2208 \u03a0, B\u2212(r) = \u2205}. The sequence \u3008Ki, Ui\u3009i\u22650 is defined as follows:\nK0 = lfp(T\u03a0+), U0 = lfp(T\u03a0,K0), Ki = lfp(T\u03a0,Ui\u22121), Ui = lfp(T\u03a0,Ki).\nLet j be the first index of the computation such that \u3008Kj , Uj\u3009 = \u3008Kj+1, Uj+1\u3009. Then, the well-founded model of \u03a0 is WF\u03a0 = \u3008W+,W\u2212\u3009 where W+ = Kj and W\u2212 = A\u03a0\\Uj .\nExample 7 Let \u03a0 be the program\na\u2190 b, not d d\u2190 b, not a b\u2190 c c\u2190\nGenerating Explanations for Biomedical Queries 31\nThen, the well-founded model of \u03a0 is computed as follows:\nK0 = {b, c}, U0 = {a, b, c, d}, K1 = {b, c}, U0 = {a, b, c, d}.\nThus, WF\u03a0 = \u3008{b, c}, \u2205\u3009.\nWe now provide definitions regarding the notion of an offline justification. First, we introduce the basic building of an offline justification, a labeled graph called as e-graph.\nDefinition 9 (e-graph) Let \u03a0 be a normal ASP program. An e-graph for \u03a0 is a labeled, directed graph (N,E), where N \u2286 Ap\u03a0 \u222a An\u03a0 \u222a {assume,>,\u22a5} and E \u2286 N \u00d7 N \u00d7 {+,\u2212}, which satisfies following properties:\n(i) the only sinks (i.e., nodes without out-going edges) in the graph are assume,>,\u22a5; (ii) for every b \u2208 N \u2229 Ap\u03a0, (b, assume,\u2212) /\u2208 E and (b,\u22a5,\u2212) /\u2208 E;\n(iii) for every b \u2208 N \u2229 An\u03a0, (b, assume,+) /\u2208 E and (b,>,+) /\u2208 E; (iv) for every b \u2208 N , if for some l \u2208 {assume,>,\u22a5} and s \u2208 {+,\u2212}, (b, l, s) \u2208 E,\nthen (b, l, s) is the only out-going edge originating from b.\nAccording to this definition, an edge of an e-graph connects two annotated atoms or an annotated atom with one of the nodes in {assume,>,\u22a5} and is marked by a label from {+,\u2212}. An edge is called as positive (resp., negative) if it is labeled by + (resp.,\u2212). Also, a path in an e-graph is called as positive if it has only positive edges, whereas it is called as negative if it has at least one negative edge. The existence of a positive path between two nodes v1 and v2 is denoted by (v1, v2) \u2208 E\u2217,+. In the offline justification, > is used to explain facts, \u22a5 to explain atoms which do not have defining rules, and assume is for atoms for which explanations are not needed, i.e., they are assumed to be true or false.\nExample 8 Let \u03a0 be the program presented in Example 1, and X = {a, b, c, d}. Then, Figure 12 is an e-graph for \u03a0. Intuitively, the true state of a depends on the true state of b and the false state of c, where b is assumed to be true and c is assumed to be false."}, {"heading": "32 Esra Erdem, Umut Oztok", "text": "In an e-graph, a set of elements that directly contributes to the truth value of an atom can be obtained through the out-going edges of a corresponding node. This set is defined as follows.\nDefinition 10 (support(b,G)) Let \u03a0 be a normal ASP program, G = (N,E) be an e-graph for \u03a0 and b \u2208 N \u2229(Ap\u03a0\u222aAn\u03a0) be a node in G. Then, support(b,G) is defined as follows.\n\u2022 support(b,G) = {l}, if for some l \u2208 {assume,>,\u22a5} and s \u2208 {+,\u2212}, (b, l, s) is in E; \u2022 support(b,G) = {atom(c) | (b, c,+) \u2208 E} \u222a {not atom(c) | (b, c,\u2212) \u2208 E}, otherwise.\nExample 9 Let G be the e-graph in Figure 12. Then, support(a,G) = {b, not c}, support(b,G) = {assume} and support(c,G) = {assume}.\nTo define the notion of a justification, an e-graph should be enriched with explanations of truth values of atoms that are derived from the rules of the program. For that, the concept of one step justification of a literal is defined as follows.\nDefinition 11 (Local Consistent Explanation (LCE)) Let \u03a0 be a normal ASP program, b be an atom, J be a possible interpretation for \u03a0, U \u2286 A\u03a0 be a set of atoms, and S \u2286 A\u03a0 \u222a notA\u03a0 \u222a {assume,>,\u22a5} be a set of literals. We say that\n\u2022 S is an LCE of b+ with respect to (J, U), if b \u2208 J+ and\n- S = {assume} or - S \u2229 A\u03a0 \u2286 J+, {c | not c \u2208 S} \u2286 J\u2212 \u222a U , and there is a rule r \u2208 \u03a0 such that H(r) = b and B(r) = S. In case, B(r) = \u2205, S is denoted by the set {>}.\n\u2022 S is an LCE of b\u2212 with respect to (J, U), if b \u2208 J\u2212 \u222a U and\n- S = {assume} or - S \u2229 A \u2286 J\u2212 \u222a U , {c |not c \u2208 S} \u2286 J+, and S is a minimal set of literals\nsuch that for every rule r \u2208 \u03a0 if H(r) = b, then B+(r) \u2229 S 6= \u2205 or B\u2212(r) \u2229 {c | not c \u2208 S} 6= \u2205. In case, S = \u2205, S is denoted by the set {\u22a5}.\nThe set of all the LCEs of b+ with respect to (J, U) is denoted by LCEp\u03a0(b, J, U) and the set of all the LCEs of b\u2212 with respect to (J, U) is denoted by LCEn\u03a0(b, J, U).\nHere, a possible interpretation J denotes an answer set. The set U consists of atoms that are assumed to be false (which will be called as Assumptions in the notion of justification later on). The need for U comes from the fact that the truth value of some atoms is first guessed while computing answer sets. Intuitively, if an atom a is true, an LCE consists of the body of a rule which is satisfied by J and has a in its head; if a is false, an LCE consists of a set of literals that are false in J and falsify all rules whose head are a.\nGenerating Explanations for Biomedical Queries 33\nExample 10 Let \u03a0 and X be defined as in Example 8. Then, the LCEs of the atoms with respect to (X, \u2205) is as follows.\nLCEp\u03a0(a,X, \u2205) = {{b, c}, {d}, {assume}} LCEp\u03a0(b,X, \u2205) = {{c}, {assume}} LCEp\u03a0(c,X, \u2205) = {{>}, {assume}} LCEp\u03a0(d,X, \u2205) = {{>}, {assume}}\nAccordingly, a class of e-graphs where edges represent LCEs of the corresponding nodes are defined as follows.\nDefinition 12 ((J, U)-based e-graph) Let \u03a0 be a normal ASP program, J be a possible interpretation for \u03a0, U \u2286 A\u03a0 be a set of atoms and b be an element in Ap\u03a0 \u222a An\u03a0. A (J, U)-based e-graph G = (N,E) of b is an e-graph such that\n(i) every node c \u2208 N is reachable from b, (ii) for every c \u2208 N\\{assume,>,\u22a5}, support(c,G) is an LCE of c with respect to\n(J, U);\nA (J, U)-based e-graph (N,E) is safe if for all b+ \u2208 N, (b+, b+) /\u2208 E\u2217,+, i.e., there is no positive cycle in the graph.\nWe now introduce a special class of (J, U)-based e-graphs where only false elements can be assumed.\nDefinition 13 (Offline e-graph) Let \u03a0 be a normal ASP program, J be a partial interpretation for \u03a0, U \u2286 A\u03a0 be a set of atoms and b be an element in Ap \u222a An. An offline e-graph G = (N,E) of b with respect to J and U is a (J, U)-based e-graph of b that satisfies following properties:\n(i) there exists no p+ \u2208 N such that (p+, assume,+) \u2208 E; (ii) (p\u2212, assume,\u2212) \u2208 E if and only if p \u2208 U .\nE(b, J, U) is the set of all offline e-graphs of b with respect to J and U .\nHere, the roles of J and U are the same as their roles in Definition 11. Observe that true atoms cannot be assumed due to the first condition and only elements in the set U are assumed due to the second condition.\nWe said earlier that in a (J, U)-based e-graph J represents an answer set and U consists of atoms that are assumed to be false. Here, U is chosen based on some characteristics of J . In particular, we want U to be a set of atoms such that when its elements are assumed to be false, the truth value of other atoms in the program can be uniquely determined and leads to J . We now introduce regarding definitions formally."}, {"heading": "34 Esra Erdem, Umut Oztok", "text": "Definition 14 (Tentative Assumptions) Let \u03a0 be a normal ASP program, M be an answer set for \u03a0 and WF\u03a0 =< WF+\u03a0 ,WF \u2212 \u03a0 > be the well-founded model of \u03a0. The tentative assumptions T A\u03a0(M) of \u03a0 with respect to M are defined as\nT A\u03a0(M) = {a | a \u2208 NANT (\u03a0) \u2227 a \u2208M\u2212, a /\u2208 (WF+\u03a0 \u222aWF\u2212\u03a0 )} (9)\nExample 11 Let \u03a0 be the program:\nc\u2190 a, not d d\u2190 a, not c a\u2190 b b\u2190\nThen, X = {a, b, c} is an answer set for \u03a0 and \u3008{a, b}, \u2205\u3009 is the well-founded model of \u03a0. Given that, T A\u03a0(X) = {d} as d \u2208 NANT (\u03a0), d /\u2208 X and d /\u2208 (WF+\u03a0 \u222aWF\u2212\u03a0 ). In fact, tentative assumptions is a set of atoms whose subsets might \u201cpotentially\u201d form U .\nWe provide a definition that would allow one to obtain a program from a given program \u03a0 and a set V of atoms by assuming all the atoms in V as false.\nDefinition 15 (Negative Reduct) Let \u03a0 be a normal ASP program, M be an answer set for \u03a0, and U \u2286 T A\u03a0(M) be a set of tentative assumption atoms. The negative reduct NR(\u03a0, U) of \u03a0 with respect to U is the set of rules defined as\nNR(\u03a0, U) = \u03a0\\{r |H(r) \u2208 U} (10) Finally, the concept of assumptions can be introduced formally.\nDefinition 16 (Assumption) Let \u03a0 be a normal ASP program, M be an answer set for \u03a0. An assumption of \u03a0 with respect to M is a set U of atoms that satisfies the following properties:\n(i) U \u2286 T A\u03a0(M); (ii) the well-founded model of NR(\u03a0, U) is equal to M .\nAssumptions(\u03a0,M) is the set of all assumptions of \u03a0 with respect to M .\nExample 12 Let \u03a0 and X be defined as in Example 11. Let U = {d}. Then, NR(\u03a0, U) is:\nc\u2190 a, not d a\u2190 b b\u2190\nand \u3008{a, b, c}, \u2205\u3009 is the well-founded model of NR(\u03a0, U). Thus, U is an assumption of \u03a0 with respect to X .\nNote that assumptions are nothing but subsets of tentative assumptions that would allow to obtain the answer set J .\nAt last, we are ready to define the notion of offline justification.\nGenerating Explanations for Biomedical Queries 35\nDefinition 17 (Offline Justification) Let \u03a0 be a normal ASP program, M be an answer set for \u03a0, U be an assumption in Assumptions(\u03a0,M) and b be an annotated atom inAp \u222aAn. An offline justification of b with respect to M and U is an element (N,E) of E(b,M,U) which is safe.\nAccording to the definition, a justification is a (J, U)-based e-graph where J is an answer set and U is an assumption. Also, justifications do not allow the creation of positive cycles in the justification of true atoms. For instance, for \u03a0 and X defined as in Example 1, Figure 11 illustrates an offline justification of a+ with respect to X and \u2205.\nIn (Pontelli et al. 2009), the authors prove the following proposition which shows that for every atom in the program, there exists an offline justification.\nProposition 9 Let \u03a0 be a ground normal ASP program, X be an answer for \u03a0. Then, for each atom a in \u03a0, there is an offline justification of with respect to X and X\u2212\\WF\u2212\u03a0 which does not contain negative cycles.\n10.2 From Justifications to Explanations\nWe relate a justification to an explanation. In particular, given an offline justification, we show that one can obtain an explanation tree whose atom vertices are formed by utilizing the \u201cannotated atoms\u201d of the justification and rule vertices are formed by utilizing the \u201csupport\u201d of annotated atoms. To compute such explanation trees, we develop Algorithm 7.\nLet us now explain the algorithm in detail. Algorithm 7 takes as input a ground normal ASP program \u03a0 , an answer set X for \u03a0, an atom p in X , and a justification (V,E) of p+ with respect to X and some U \u2208 Assumptions(\u03a0, X). Our goal is to obtain an explanation tree in the and-or explanation tree for p with respect to \u03a0 and X from the justification (V,E). The algorithm starts by creating two sets V \u2032 and E\u2032 (Line 1). Here, V \u2032 and E\u2032 corresponds to the set of vertices and the set of edges of the explanation tree, respectively. By Condition (ii) in Definition 3 and Condition (i) in Definition 2, we know that the label of the root of an explanation tree for p with respect to \u03a0 and X is p. Thus, a vertex v with label p is defined (Line 2), and added into the queue Q (Line 3). Then, the algorithm enters into a \u201cwhile\u201d loop which executes until Q becomes empty. At every iteration of the loop, an element v from Q is first extracted (Line 5) and added into V \u2032 (Line 6). This implies that every element added into Q is also added into V \u2032. For instance, the vertex defined at Line 2 is the first vertex extracted from Q and also added into V \u2032, which makes sense since we know that the root of an explanation tree is an atom vertex with label v. Then, according to the type of the extracted vertex, its out-going edges are defined. Let v\u2032 be a vertex extracted from Q at Line 5 in some iteration of the loop. Consider the following two cases.\nCase 1 Assume that v\u2032 is an atom vertex. Then, the algorithm directly goes to Line 13. By Condition (i) in Definition 3, we know that an explanation tree is a subtree of the and-or explanation tree. Hence, we need to define out-going edges of v\u2032 by taking into account Condition (ii) in Definition 2, which implies that a child of v\u2032 must"}, {"heading": "36 Esra Erdem, Umut Oztok", "text": "Algorithm 7: Justification to Explanation Input: \u03a0 : ground normal ASP program, X : answer set for \u03a0, p : atom in X , (V,E) :\njustification of p+ w.r.t X and some U \u2208 Assumptions(\u03a0, X). Output: A vertex-labeled tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009.\n1 V \u2032 := \u2205, E\u2032 := \u2205; 2 v \u2190 Create a vertex v s.t. l(v) = p; 3 Q\u2190 v; 4 while Q 6= \u2205 do 5 v\u2032 \u2190 Dequeue an element from Q; 6 V \u2032 := V \u2032 \u222a {v\u2032}; 7 if l(v\u2032) \u2208 \u03a0 then // v\u2032 is a rule vertex 8 foreach a \u2208 B+(l(v\u2032)) do 9 v\u2032\u2032 \u2190 Create a vertex v\u2032\u2032 s.t. l(v\u2032\u2032) = a;\n10 E\u2032 := E\u2032 \u222a {(v\u2032, v\u2032\u2032)} // edge from rule vertex to atom vertex; 11 Enqueue v\u2032\u2032 to Q;\n12 else if l(v\u2032) \u2208 X then // v\u2032 is an atom vertex 13 r \u2190 Create a rule r s.t. H(r) = l(v\u2032) and B(r) = support(l(v\u2032)+, G); 14 v\u2032\u2032 \u2190 Create a vertex v\u2032\u2032 s.t. l(v\u2032\u2032) = r; 15 E\u2032 := E\u2032 \u222a {(v\u2032, v\u2032\u2032)} // edge from atom vertex to rule vertex; 16 Enqueue v\u2032\u2032 to Q;\n17 return \u3008V \u2032, E\u2032, l,\u03a0, X\u3009;\nbe a rule vertex v\u2032\u2032 such that the rule that labels v\u2032\u2032 \u201csupports\u201d the atom that labels v\u2032. Thus, a rule r that supports the atom that labels v\u2032 is created (Line 13). We ensure \u201csupportedness\u201d property by utilizing the annotated atoms in the given offline justification which supports the annotated version of the atom that labels v\u2032. Then, a vertex v\u2032\u2032 with label r is created (Line 14), and a corresponding child of v\u2032 is added into E\u2032 (Line 15). By Condition (iii) in Definition 3, we know that every atom vertex of an explanation tree has a single child. Therefore, another child of v\u2032 is not created. Then, before finishing the iteration of the loop, the child v\u2032\u2032 of v\u2032 is added into Q so that its children can be formed in the next iterations of the loop.\nCase 2 Assume that v\u2032 is a rule vertex. Then, the condition at Line 7 is satisfied and the algorithm goes to Line 8. In this case, while forming the children of v\u2032, we should consider Condition (iii) in Definition 2, which implies that a child v\u2032\u2032 of v\u2032 must be an atom vertex such that the atom that labels v\u2032\u2032 is in the positive body of the rule that labels v\u2032. Also, by Condition (iv) in Definition 3, we should ensure that for every atom a in the positive body of the rule that labels v\u2032, there exists a child va of v\u2032 such that the atom that labels va is equal to a. Thus, the loop between Lines 8\u201311 iterates for every atom a in the positive body of the label of v\u2032 and a vertex v\u2032\u2032 with label a is created (Line 9). Then, v\u2032\u2032 becomes a child of v\u2032 (Line 10). To form the children of v\u2032\u2032 in the next iterations of the \u201cwhile\u201d loop, the child v\u2032\u2032 of v\u2032 is added into Q (Line 11).\nWhen the algorithm finishes processing the elements of Q, i.e., Q becomes empty, the \u201cwhile\u201d loop terminates. Then, the algorithm returns a vertex-labeled tree (Line 17). We now provide the proposition about the soundness of Algorithm 7.\nProposition 10 Given a ground normal ASP program \u03a0, an answer set X for \u03a0, an atom p in X , an assumption U in Assumption(\u03a0, X), and an offline justification G = (V,E) of p+ with respect to X and U , Algorithm 7 returns an explanation tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X .\nExample 13 Let \u03a0 and X be defined as in Example 8. Figure 13(a) is an offline justification of a+ with respect to X and \u2205. Figure 13(b) shows a corresponding explanation tree in the and-or explanation tree for a with respect to \u03a0 and X that is obtained by using Algorithm 7.\n10.3 From Explanations to Justifications\nWe relate an explanation to a justification. In particular, given an explanation tree whose labels of vertices are unique, we show that one can obtain an offline justification by utilizing the labels of atom vertices of the explanation tree. For that, we design Algorithm 8.\nLet us now describe the algorithm in detail. Algorithm 8 takes as input a ground normal ASP program \u03a0, an answer set X for \u03a0, an atom p in X , and an explanation tree T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X . Our goal is to obtain an offline justification (V,E) of p+ in \u03a0X with respect to X and \u2205. The reason to obtain the offline justification in the reduct of \u03a0 with respect to X is that our definition of explanation is not defined for the atoms that are not in the answer set. Algorithm 8 starts by creating two sets V and E which will correspond to the set of nodes and the set of edges"}, {"heading": "38 Esra Erdem, Umut Oztok", "text": "Algorithm 8: Explanation to Justification Input: \u03a0 : ground normal ASP program, X : answer set for \u03a0, p : atom in X ,\n\u3008V \u2032, E\u2032, l,\u03a0, X\u3009 : an explanation tree in the and-or explanation tree for p w.r.t \u03a0 and X .\nOutput: (V,E) : justification of p+ w.r.t X and \u2205. 1 V := \u2205, E := \u2205; 2 Q\u2190 root of \u3008V \u2032, E\u2032\u3009; 3 while Q 6= \u2205 do 4 v \u2190 Dequeue an element from Q; 5 V := V \u222a {l(v)+}; 6 v\u2032 \u2190 child of v in \u3008V \u2032, E\u2032\u3009; 7 if l(v\u2032) is a fact in \u03a0X then 8 E := E \u222a {(l(v)+,>,+)}; 9 foreach v\u2032\u2032 \u2208 childE\u2032(v\u2032) do\n10 E := E \u222a {(l(v)+, l(v\u2032\u2032)+,+)}; 11 Enqueue v\u2032\u2032 to Q;\n12 V := V \u222a {>}; 13 return (V,E);\nof the offline justification, respectively (Line 1). Then, the root of \u3008V \u2032, E\u2032\u3009 is added into the queue Q (Line 2) and we enter into a \u201cwhile\u201d loop that iterates until Q becomes empty. At every iteration of the loop, first an element v is extracted from Q (Line 4) and l(v)+ is added into V (Line 5). Then, we form the out-going edges of l(v)+. Due to Condition (iii) in Definition 3, every atom vertex in an explanation tree has a single child, which is a rule vertex due to Condition (i) in Definition 3 and Condition (ii) in Definition 2. Then, we extract the child v\u2032 of v at Line 6 and consider two cases. Note that v\u2032 is a rule vertex.\nCase 1 Assume that l(v\u2032) is a fact in \u03a0X . Then, l(v\u2032) satisfies the condition at Line 7 and we add (l(v)+,>,+) into E at Line 8. The key insight behind that is as follows. Due to Condition (ii) in Definition 12, support(l(v)+, (V,E)) must be an LCE of l(v)+. Due to Condition (i) in Definition 3 and Condition (ii) in Definition 2, the head of l(v\u2032) is l(v). As l(v\u2032) is a fact in \u03a0X , i.e., its body is empty in \u03a0X , {>} becomes an LCE of l(v)+ with respect to (X, \u2205), due to Definition 11. Thus, by adding (l(v)+,>,+) to E, support(l(v)+, (V,E)) becomes {>}. Case 2 Assume that l(v\u2032) is not a fact in \u03a0X . Then, for every child v\u2032\u2032 of v\u2032, we add (l(v)+, l(v\u2032\u2032)+,+) into E at Line 10. The intuition behind this is to make sure that support(l(v)+, (V,E)) is an LCE of l(v)+. Due to Condition (i) in Definition 3, an explanation tree is a subtree of the corresponding and-or explanation tree. Then, due to Condition (ii) in Definition 2, for every atom vertex v in an explanation tree, the atoms in the positive body of the rule that labels the child v\u2032 of v are in the given answer set X . Thus, due to Definition 11, adding (l(v)+, l(v\u2032\u2032)+,+) into E for every child v\u2032\u2032 of v\u2032 ensures that support(l(v)+, (V,E)) is an LCE of l(v)+ with respect\nGenerating Explanations for Biomedical Queries 39\nto (X, \u2205). Also, we add v\u2032\u2032 into V so that its children in V are formed in the next iterations of the \u201cwhile\u201d loop.\nDue to Line 8, there are incoming edges of >. But, > is not added into V inside the \u201cwhile\u201d loop. Thus, when the \u201cwhile\u201d loop terminates, before returning (V,E) at Line 13, we add > into V .\nAlgorithm 8 creates an offline justification of the given atom in the reduct of the given ASP program with respect to the given answer set, provided that labels of the vertices of the given explanation tree are unique.\nProposition 11 Given a ground normal ASP program \u03a0 , an answer set X for \u03a0, an atom p in X , and an explanation tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X such that for every v, v\u2032 \u2208 V \u2032, l(v) = l(v\u2032) if and only if v = v\u2032, Algorithm 8 returns an offline justification of p+ in \u03a0X with respect to X and \u2205.\nExample 14 Let \u03a0 be the program:\na\u2190 b, c, not d b\u2190 not e c\u2190\nand X = {a, b, c}. Figure 14(a) is an explanation tree T in the and-or explanation tree for a with respect to \u03a0 and X . Then, given \u03a0, X, a and T , Algorithm 8 creates an offline justification of a+ in \u03a0X with respect to \u03a0 and \u2205 as in Figure 14(b).\n11 Other Related Work\nThe most recent work related to explanation generation in ASP are (Brain and Vos 2005; Syrjanen 2006; Gebser et al. 2008; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al."}, {"heading": "40 Esra Erdem, Umut Oztok", "text": "2011), in the context of debugging ASP programs. Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set. As we study the problem of explaining the reasons why atoms are in the answer set, our work differs from those two work.\nIn (Brain and Vos 2005), similar to our work, the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d is studied. As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in \u03a0 that supports X with respect to \u03a0; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules).\nPontelli et al. (2009) also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set. In (Oetsch et al. 2011), a framework where the users can construct interpretations through an interactive stepping process is introduced. As a result, (Pontelli et al. 2009) and (Oetsch et al. 2011) can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping.\n12 Conclusion\nWe have formally defined explanations in the context of ASP. We have also introduced variations of explanations, such as \u201cshortest explanations\u201d and \u201ck different explanations\u201d.\nWe have proposed generic algorithms to generate explanations for biomedical queries. In particular, we have presented algorithms to compute shortest or k different explanations. We have analyzed termination, soundness and complexity of these algorithms. In particular, the complexity of generating a shortest explanation for an answer (in an answer set X) is O(|\u03a0||X| \u00d7 |B\u03a0|) where |\u03a0| is the number of ASP rules representing the query, the knowledge extracted from biomedical resources and the rule layer, and |B\u03a0| is the number of atoms in \u03a0. The complexity of generating k different explanations is O(k\u00d7 |\u03a0||X|+1\u00d7 |B\u03a0|). For k different explanations, we have defined a distance measure based on the number of different ASP rules between explanations.\nWe have developed a computational tool EXPGEN-ASP which implements these algorithms. We have embedded EXPGEN-ASP into BIOQUERY-ASP to generate explanations regarding the answers of complex biomedical queries. We have proposed a method to present explanations in a natural language. No existing biomedical query answering system is capable of generating explanations; our methods have fulfilled this need in biomedical query answering.\nWe have illustrated the applicability of our methods to answer complex biomedical queries over large biomedical knowledge resources about drugs, genes, and diseases, such as PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA. The total number of the facts extracted from these resources to answer queries is approximately 10.3 million.\nIt is important to emphasize here that our definitions and methods for explanation generation are general, so they can be applied to other applications (e.g., debugging, query answering in other domains).\nOne line of future work is to generalize the notion of an explanation to queries (like Q7) that contain choice expressions.\nGenerating Explanations for Biomedical Queries 41\n13 Acknowledgments\nWe would like to thank Yelda Erdem (Sanovel Pharmaceutical Inc.) for her help in identifying biomedical queries relevant to drug discovery, and Halit Erdogan (Sabanci University) for his help with an earlier version of BIOQUERY-ASP which he implemented as part of his MS thesis studies. We would like to thank Hans Tompits (Vienna University of Technology) for his useful comments about the work presented in the paper, and pointing out relevant references in the context of debugging ASP programs. We also would like to thank anonymous reviewers for their useful comments and suggestions on an earlier draft. This work was partially supported by TUBITAK Grant 108E229.\nReferences\nAPT, K. R. AND BOL, R. N. 1994. Logic programming and negation: A survey. J. Log. Program. 19/20, 9\u201371.\nBARAL, C. 2003. Knowledge Representation, Reasoning and Declarative Problem Solving. Cambridge University Press."}, {"heading": "BODENREIDER, O., COBAN, Z. H., DOGANAY, M. C., ERDEM, E., AND KOSUCU, H. 2008. A", "text": "preliminary report on answering complex queries related to drug discovery using answer set programming. In Proc. of ALPSWS.\nBRAIN, M. AND VOS, M. D. 2005. Debugging logic programs under the answer set semantics. In Proc. of ASP.\nBREWKA, G., EITER, T., AND TRUSZCZYNSKI, M. 2011. Answer set programming at a glance. Commun. ACM 54, 12, 92\u2013103.\nCHONG, C. R. AND SULLIVAN, D. J. 2007. New uses for old drugs. Nature 448, 645\u2013646. DAVIS, A. P., KING, B. L., MOCKUS, S., MURPHY, C. G., SARACENI-RICHARDS, C., ROSEN-\nSTEIN, M., WIEGERS, T., AND MATTINGLY, C. J. 2011. The Comparative Toxicogenomics Database: update 2011. Nucleic Acids Research 39, Database issue, D1067\u2013D1072.\nEITER, T., G.IANNI, R.SCHINDLAUER, AND H.TOMPITS. 2006. Effective integration of declarative rules with external evaluations for Semantic-Web reasoning. In Proc. of ESWC.\nERDEM, E., ERDEM, Y., ERDOGAN, H., AND OZTOK, U. 2011. Finding answers and generating explanations for complex biomedical queries. In Proc. of AAAI.\nERDEM, E., ERDOGAN, H., AND OZTOK, U. 2011. BIOQUERY-ASP: Querying biomedical ontologies using answer set programming. In Proc. of RuleML2011@BRF Challenge.\nERDEM, E. AND YENITERZI, R. 2009. Transforming controlled natural language biomedical queries into answer set programs. In Proc. of the Workshop on BioNLP. 117\u2013124.\nFERRARIS, P. AND LIFSCHITZ, V. 2005. Weight constraints as nested expressions. Theory and Practice of Logic Programming 5, 45\u201374.\nGEBSER, M., KAMINSKI, R., KOENIG, A., AND SCHAUB, T. 2011. Advances in gringo series 3. In Proc of. LPNMR. Vol. 6645. 345\u2013351.\nGEBSER, M., KAUFMANN, B., NEUMANN, A., AND SCHAUB, T. 2007. clasp: A conflict-driven answer set solver. In Proc. of LPNMR. 260\u2013265.\nGEBSER, M., PUEHRER, J., SCHAUB, T., AND TOMPITS, H. 2008. A meta-programming technique for debugging answer-set programs. In Proc. of AAAI.\nGELDER, A. V., ROSS, K. A., AND SCHLIPF, J. S. 1991. The well-founded semantics for general logic programs. J. ACM 38, 3, 620\u2013650.\nGELFOND, M. AND LIFSCHITZ, V. 1988. The stable model semantics for logic programming. In Proc. of ICLP. MIT Press, 1070\u20131080."}, {"heading": "42 Esra Erdem, Umut Oztok", "text": "GELFOND, M. AND LIFSCHITZ, V. 1991. Classical negation in logic programs and disjunctive databases. New Generation Computing 9, 365\u2013385.\nGOWER, T. 2009. Born again. Proto Magazine Summer, 14\u201319."}, {"heading": "KNOX, C., LAW, V., JEWISON, T., LIU, P., LY, S., FROLKIS, A., PON, A., BANCO, K., MAK, C.,", "text": "NEVEU, V., DJOUMBOU, Y., EISNER, R., GUO, A. C., AND WISHART, D. S. 2010. Drugbank 3.0: a comprehensive resource for \u2018omics\u2019 research on drugs. Nucleic Acids Research 39, Database issue, D1035\u2013D1041.\nKUHN, M., CAMPILLOS, M., LETUNIC, I., JENSEN, L. J., AND BORK, P. 2010. A side effect resource to capture phenotypic effects of drugs. Molecular Systems Biology 6, 343.\nLIFSCHITZ, V. 2002. Answer set programming and plan generation. Artificial Intelligence 138, 39\u201354.\nLIFSCHITZ, V. 2008. What is answer set programming? In Proc. of AAAI. MIT Press, 1594\u20131597. MAREK, V. AND TRUSZCZYN\u0301SKI, M. 1999. Stable models and an alternative logic programming\nparadigm. In The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013 398."}, {"heading": "MCDONAGH, E. M., WHIRL-CARRILLO, M., GARTEN, Y., ALTMAN, R. B., AND KLEIN, T. E.", "text": "2011. From pharmacogenomic knowledge acquisition to clinical applications: the PharmGKB as a clinical pharmacogenomic biomarker resource. Biomarkers in Medicine 5, 6, 795\u2013806.\nNIEMEL\u00c4, I. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence 25, 241\u2013273.\nNOGUEIRA, M., BALDUCCINI, M., GELFOND, M., WATSON, R., AND BARRY, M. 2001. An A-Prolog decision support system for the space shuttle. In Proc. of PADL. Springer, 169\u2013183.\nOETSCH, J., PUEHRER, J., AND TOMPITS, H. 2010. Catching the ouroboros: On debugging nonground answer-set programs. TPLP 10, 4-6, 513\u2013529.\nOETSCH, J., PUEHRER, J., AND TOMPITS, H. 2011. Stepping through an answer-set program. In LPNMR. 134\u2013147.\nOZTOK, U. 2012. Generating explanations for complex biomedical queries. PONTELLI, E., SON, T. C., AND EL-KHATIB, O. 2009. Justifications for logic programs under\nanswer set semantics. Theory and Practice of Logic Programming, 1\u201356."}, {"heading": "RICCA, F., GRASSO, G., ALVIANO, M., MANNA, M., LIO, V., IIRITANO, S., AND LEONE, N.", "text": "2012. Team-building with answer set programming in the Gioia-Tauro seaport. Theory and Practice of Logic Programming 12."}, {"heading": "SCHRIML, L. M., ARZE, C., NADENDLA, S., CHANG, Y.-W. W., MAZAITIS, M., FELIX, V.,", "text": "FENG, G., AND KIBBE, W. A. 2012. Disease Ontology: a backbone for disease semantic integration. Nucleic Acids Research 40, Database issue, D940\u2013D946.\nSIMONS, P., NIEMEL\u00c4, I., AND SOININEN, T. 2002. Extending and implementing the stable model semantics. Artificial Intelligence 138, 181\u2013234.\nSTARK, C., BREITKREUTZ, B.-J., REGULY, T., BOUCHER, L., BREITKREUTZ, A., AND TYERS, M. 2006. BioGRID: a general repository for interaction datasets. Nucleic Acids Research 34, Database issue, D535\u2013D539.\nSYRJANEN, T. 2006. Debugging inconsistent answer set programs. In Proc. of NMR. TIIHONEN, J., SOININEN, T., AND SULONEN, R. 2003. A practical tool for mass-customising\nconfigurable products. In Proc. of the International Conference on Engineering Design. 1290\u2013 1299.\n1 Online appendix for the paper\nGenerating Explanations for Biomedical Queries published in Theory and Practice of Logic Programming\nESRA ERDEM, UMUT OZTOK Sabanc\u0131 University, Orhanl\u0131, Tuzla, I\u0307stanbul 34956, Turkey\n(e-mail: {esraerdem,uoztok}@sabanciuniv.edu)\nsubmitted 25 October 2012; revised 17 July 2013; accepted 19 August 2013\nAppendix A Proofs\nWe provide proofs of the theoretical results presented in the paper: the algorithmic analysis for generating shortest explanations (Propositions 2, 3, and 4), the algorithmic analysis for generating k different explanations (Propositions 5, 6, and 8), and the analysis for the relationship between an explanation and a justification. (Propositions 10 and 11).\nA.1 Generating Shortest Explanations\nIn Section 5 of the paper, we have analyzed three properties of Algorithm 1, namely termination, soundness and complexity, resulting in Propositions 2, 3, and 4. In the following, we show the proofs of these results.\nA.1.1 Proof of Proposition 2 \u2013 Termination of Algorithm 1\nTo prove that Algorithm 1 terminates we need the following lemma.\nLemma 1 Given a ground ASP program \u03a0, an answer set X for \u03a0, an atom p in X , and a set L of atoms in X , Algorithm 2 terminates."}, {"heading": "Proof of Lemma 1", "text": "It is sufficient to show that the recursion tree generated by Algorithm 2 is finite. That is, the branching factor of the recursion tree and the height of the recursion tree are finite. Note that each node of the recursion tree denotes a call to createTree(\u03a0, X, d, L) for some atom or rule d and a set L of atoms.\nPart (1) We show that the branching factor of the tree is finite. Branches in the tree are created in loops at Lines 5 and 13. The loop at Line 5 iterates at most the number of rules in \u03a0 and the loop at Line 13 iterates at most the number of atoms in X . As \u03a0 and X are finite, the branching factor of the tree is finite.\n2 Part (2) We show that the height of the recursion tree is finite. Let us first make the following observation. Consider a path \u3008v1, . . .\u3009 in the recursion tree. For every node vi that denotes a call to createTree(\u03a0, X, di, Li) where di is an atom in X , the following holds for vi+2 (if exists): Li \u2282 Li+2. This follows from the two consecutive calls to createTree: Li increases at every other call, due to Line 4. Now, assume that the height of the recursion tree is infinite. Then, there exists an infinite path \u3008v1, . . .\u3009 in the recursion tree. Thus, L1 \u2282 L3 \u2282 . . . \u2282 L(2\u00d7|X|)+1 \u2282 L(2\u00d7|X|)+3 \u2282 . . .. Recall that we add elements into Lis only from X (Line 4). Thus, L(2\u00d7|X|)+1 = X . Then, it is not possible to have L(2\u00d7|X|)+1 \u2282 L(2\u00d7|X|)+3. As we reach a contradiction, the height of the recursion tree is finite.\nNow, we show that Algorithm 1 terminates.\nProposition 2 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , Algorithm 1 terminates."}, {"heading": "Proof of Proposition 2", "text": "Algorithm 1 terminates only if Algorithms 2, 3, and 4 terminate. By Lemma 1, we know that Algorithm 2 terminates and that the vertex-labeled tree T returned by Algorithm 2 is finite. Since Algorithm 3 and Algorithm 4 simply traverse T (cf. Lines 2 and 6 in Algorithm 3, and Lines 5 and 10 in Algorithm 4), they also terminate. Thus, Algorithm 1 terminates.\nA.1.2 Proof of Proposition 3 \u2013 Soundness of Algorithm 1\nTo show the proof of Proposition 3, we need the following necessary lemmas.\nLemma 2 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X or a rule in \u03a0 and L be a subset of X . If the vertex-labeled tree \u3008V,E, l,\u03a0, X\u3009 returned by createTree(\u03a0, X, d, L) is not empty, then the following hold:\n(i) the root of \u3008V,E\u3009 is created in createTree(\u03a0, X, d, L) and is mapped to d by l; (ii) for every rule vertex v \u2208 V ,\noutE(v) = {(v, v\u2032) | (v, v\u2032) \u2208 E, l(v\u2032) \u2208 B+(l(v))};\n(iii) each leaf vertex is a rule vertex."}, {"heading": "Proof of Lemma 2", "text": "Let \u3008V,E, l,\u03a0, X\u3009 be the non-empty vertex-labeled tree returned by createTree(\u03a0, X, d, L). We show one by one that each condition in the lemma holds.\n3 (i) Assume that d is an atom in X . Note that d /\u2208 L because otherwise \u3008V,E\u3009 = \u3008\u2205, \u2205\u3009. Due to the call createTree(\u03a0, X, d, L), the algorithm, at Line 3, creates a vertex v such that l(v) = d. We know that E 6= \u2205. Then, there exists some out-going edges of v. At Line 9, the out-going edges of v are formed. Due to Line 8, each vertex v\u2032 in (v, v\u2032) is the root of a vertex-labeled tree. Moreover, there is no part of the algorithm that adds a \u201cparent\u201d to a vertex. Therefore, v is the root of \u3008V,E\u3009.\nSimilar reasoning can be applied for the case where d is a rule in \u03a0.\n(ii) Let v \u2208 V be a rule vertex. Let Sv = {(v, v\u2032) | (v, v\u2032) \u2208 E, l(v\u2032) \u2208 B+(l(v))} denoting the set of out-going edges of v to atom vertices whose labels are in the positive body of the rule that labels v. We show that outE(v) = Sv .\nLet (v, v\u2032) \u2208 outE(v). Then, (v, v\u2032) \u2208 E. Edges are created at Lines 9 and 17. As v is a rule vertex, (v, v\u2032) must be created at Line 17. Then, by Line 16 and the condition at Line 13, l(v\u2032) \u2208 B+(l(v)). So, (v, v\u2032) \u2208 Sv (i.e., outE(v) \u2286 Sv).\nLet (v, v\u2032) \u2208 Sv . Then, by the definition of Sv , (v, v\u2032) \u2208 E. Thus, (v, v\u2032) \u2208 outE(v) (i.e., Sv \u2286 outE(v)).\n(iii) Assume otherwise. Then, there exists an atom vertex v \u2208 V such that it is a leaf vertex. Vertices are created at Lines 3 and 12. As v is an atom vertex, it must be created at Line 3. Since it is a leaf vertex, condition at Line 7 never holds. But, then condition at Line 10 holds. Then, the call where v is created returns an empty set of vertices. That is, v cannot be in V .\nLemma 3 Let \u03a0 be a ground ASP program and X be an answer set for \u03a0. For the two subsequent calls createTree(\u03a0, X, d, L) and createTree(\u03a0, X, d\u2032, L\u2032) (i.e., createTree(\u03a0, X, d\u2032, L\u2032) being called right after createTree(\u03a0, X, d, L)) on a path in the recursion tree for some execution of Algorithm 2, the following hold\n(i) If d is an atom, then L\u2032 = L \u222a {d}; (ii) If d is a rule, then L\u2032 = L."}, {"heading": "Proof of Lemma 3", "text": "Let createTree(\u03a0, X, d, L) and createTree(\u03a0, X, d\u2032, L\u2032) be two subsequent calls on a path in the recursion tree for some execution of Algorithm 2. We show one by one that the conditions in the lemma hold.\n(i) Assume that d is an atom. Then, createTree(\u03a0, X, d\u2032, L\u2032) is called at Line 6. Due to Line 4, L\u2032 = L \u222a {d}.\n(ii) Assume that d is a rule. Then, createTree(\u03a0, X, d\u2032, L\u2032) is called at Line 13. As L is not modified prior to this call, L\u2032 = L.\n4 Lemma 4 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0 and \u3008V,E, l,\u03a0, X\u3009 be the vertex-labeled tree returned by execution Exc of Algorithm 2. Let createTree(\u03a0, X, d, L) and createTree(\u03a0, X, d\u2032, L\u2032) be the two subsequent calls (i.e., createTree(\u03a0, X, d\u2032, L\u2032) being called right after createTree(\u03a0, X, d, L)) on a path in the recursion tree for Exc, where each call on the path returns a nonempty vertex-labeled tree. Let v and v\u2032 be two vertices created by createTree(\u03a0, X, d, L) and createTree(\u03a0, X, d\u2032, L\u2032), respectively, such that l(v) = d and l(v\u2032) = d\u2032. Then, (v, v\u2032) \u2208 E."}, {"heading": "Proof of Lemma 4", "text": "Notice that either d is an atom and d\u2032 is a rule or vice versa. We show that the lemma holds for the former case. The latter case can be shown similarly. Assume that d is an atom and d\u2032 is a rule. Then, createTree(\u03a0, X, d\u2032, L\u2032) must be called at Line 6 within createTree(\u03a0, X, d, L). As none of the calls on the path returns empty vertex-labeled tree, the condition at Line 7 holds in createTree(\u03a0, X, d, L). Then, an edge (v, v\u2032) is added to E at Line 9. Note that v is created in createTree(\u03a0, X, d, L) at Line 3 and l(v) = d. Also, due to Line 8, v\u2032 is the root of the vertex-labeled tree returned by createTree(\u03a0, X, d\u2032, L\u2032). Then, by Lemma 2, v\u2032 is a vertex created in createTree(\u03a0, X, d\u2032, L\u2032) and l(v\u2032) = d\u2032.\nLemma 5 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X and T = \u3008V,E, l,\u03a0, X\u3009 be the vertex-labeled tree returned by createTree(\u03a0, X, d, \u2205). If T is not empty, then for every node createTree(\u03a0, X, d\u2032, L\u2032) in the recursion tree for createTree(\u03a0, X, d, \u2205), where createTree(\u03a0, X, d\u2032, L\u2032) and its ancestors return nonempty vertex-labeled trees, L\u2032 = ancT (v) where l(v) = d\u2032."}, {"heading": "Proof of Lemma 5", "text": "Assume that T is not empty. Then, we prove the lemma by induction on the depth of a node in the recursion tree for createTree(\u03a0, X, d, \u2205).\nBase case: Note that the node at depth 0 in the recursion tree for createTree(\u03a0, X, d, \u2205) returns a nonempty vertex-labeled tree and it has no ancestors. By Lemma 2, the root v of \u3008V,E\u3009 is mapped to d by l, i.e., l(v) = d = d\u2032. As the root of a tree does not have any ancestors, ancT (v) = \u2205 = L\u2032.\nInduction step: As an induction hypothesis, assume that for every node createTree(\u03a0, X, d\u2032, L\u2032) at depth less than n in the recursion tree for createTree(\u03a0, X, d, \u2205), where createTree(\u03a0, X, d\u2032, L\u2032) and its ancestors return nonempty vertex-labeled trees, L\u2032 = ancT (v) where l(v) = d\u2032. Let createTree(\u03a0, X, d\u2032, L\u2032) be a node at depth n in the recursion tree for createTree(\u03a0, X, d, \u2205), where createTree(\u03a0, X, d\u2032, L\u2032) and its ancestors return nonempty vertex-labeled trees. We show that L\u2032 = ancT (v) where l(v) = d\u2032. For that, we need to consider two cases: d\u2032 is an atom and d\u2032 is a rule. Let createTree(\u03a0, X, p, Lp) be the parent of createTree(\u03a0, X, d\u2032, L\u2032), as illustrated in Figure A 1.\n5 Depth\ncreateTree(\u03a0, X, d, \u2205)\n...\n...\ncreateTree(\u03a0, X, p, Lp)\ncreateTree(\u03a0, X, d\u2032, L\u2032)\n...\n...\n...\n... ...\n0\nn\u2212 1\nn\nFig. A 1: Part of the recursion tree for createTree(\u03a0, X, d, \u2205).\nCase 1. Assume that d is an atom. Then, p must be a rule. By Lemma 3, L\u2032 = Lp. Notice that the depth of the parent node is n \u2212 1. Then, by the induction hypothesis, Lp = ancT (v) where l(v) = p. Also, by Lemma 4, (v, v\u2032) \u2208 E where l(v\u2032) = d\u2032. Since v is a rule vertex, ancT (v) = ancT (v\u2032). Thus, L\u2032 = ancT (v\u2032) where l(v\u2032) = d\u2032.\nCase 2. Assume that d is a rule. Then, p must be an atom. By Lemma 3, L\u2032 = Lp\u222a{p}. Notice that the depth of the parent node is n \u2212 1. Then, by the induction hypothesis, Lp = ancT (v) where l(v) = p. Also, by Lemma 4, (v, v\u2032) \u2208 E where l(v\u2032) = d\u2032. Since v is an atom vertex, ancT (v) \u222a {l(v)} = ancT (v\u2032). Thus, L\u2032 = ancT (v\u2032) where l(v\u2032) = d\u2032.\nProposition 12 (Soundness of Algorithm 2) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X and T = \u3008V,E, l,\u03a0, X\u3009 be the vertex-labeled tree returned by createTree(\u03a0, X, d, \u2205). If T is not empty, then T is the and-or explanation tree for d with respect to \u03a0 and X ."}, {"heading": "Proof of Proposition 12", "text": "Suppose that T is not empty. We want to show that T is the and-or explanation tree for d with respect to \u03a0 and X . For that, T must satisfy conditions (i)\u2212 (iv) in Definition 2. As T is not empty, conditions (i), (iii) and (iv) hold due to Lemma 2. To complete the proof, we show condition (ii) also holds in the sequel.\nLet Sv = {(v, v\u2032) | (v, v\u2032) \u2208 E, l(v\u2032) \u2208 \u03a0X,ancT (v\u2032)(l(v))}. Our goal is to show that for every atom vertex v \u2208 V , outE(v) = Sv . To do so, we show that outE(v) \u2286 Sv and that Sv \u2286 outE(v).\n6 Let v be an atom vertex in V . Now, we show that outE(v) \u2286 S. Take an arbitrary element (v, v\u2032) \u2208 outE(v). Then, (v, v\u2032) \u2208 E. Throughout the algorithm edges are created at Lines 9 and 17. Since v is an atom vertex, (v, v\u2032) must be created at Line 9. Then, due to the condition at Line 5 and Lemma 5, l(v\u2032) \u2208 \u03a0X,ancE(v\u2032)(l(v)). Thus, (v, v\u2032) \u2208 Sv . As the last step, we show that Sv \u2286 outE(v). Let (v, v\u2032) \u2208 Sv be an arbitrary element. Then, by the definition of Sv , (v, v\u2032) \u2208 E. Thus, trivially, (v, v\u2032) \u2208 outE(v).\nLemma 6 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X , T = \u3008VT , ET , l,\u03a0, X\u3009 be the and-or explanation tree for d with respect to \u03a0 and X , v be the root of T and \u3008V,E, l,\u03a0, X\u3009 be the vertex-labeled tree returned by\nextractExp(\u03a0, X, VT , l, v, ET ,WT , \u2205,min).\nThen, for each v\u2032 \u2208 V , we have\nWT (v \u2032) \u2264 min{WT (s) | s \u2208 siblingET (v\u2032)}."}, {"heading": "Proof of Lemma 6", "text": "Let v\u2032 \u2208 V . Vertices are added to V at Line 8. Then, due to Line 7, v\u2032 is a rule vertex. Also, each vertex added to V corresponds to the 5th parameter of the algorithm. Note that recursive calls are made at Lines 5 and 10. Since the 5th parameter is a rule vertex only in the call at Line 5, the call where v\u2032 is added to V must be initiated at Line 5. Then, due to Line 3, WT (v\u2032) = min{WT (s) | s \u2208 siblingET (v\u2032)}.\nLemma 7 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X , T = \u3008VT , ET , l,\u03a0, X\u3009 be the and-or explanation tree for d with respect to \u03a0 and X , v be the root of T , and \u3008V,E, l,\u03a0, X\u3009 be the vertex-labeled tree returned by\nextractExp(\u03a0, X, VT , l, v, ET ,WT , \u2205,min).\nLet v1, v2 \u2208 V . If (v1, v), (v, v2) \u2208 ET for some v \u2208 VT , then (v1, v2) \u2208 E."}, {"heading": "Proof of Lemma 7", "text": "Since v1 \u2208 V , it is added to V at Line 8. Then, for each child of v1, the algorithm is recursively called at Line 10. As (v1, v) \u2208 ET , we make a call\nextractExp(\u03a0, X, VT , l, v, ET ,WT , v1,min).\nInside that call, we add (v1, c) to E (at Line 4) where c is a minimum weighted child of v (due to Line 3). As (v, v2) \u2208 ET and v2 is a minimum weighted child of v due to Lemma 6, c is equal to v2. Thus, (v1, v2) \u2208 E.\n7 Lemma 8 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, d be an atom in X , T = \u3008VT , ET , l,\u03a0, X\u3009 be the and-or explanation tree for d with respect to \u03a0 and X , and op be a string min. Then, Algorithm 4 returns an explanation \u3008V,E, l,\u03a0, X\u3009 for d with respect to \u03a0 and X ."}, {"heading": "Proof of Lemma 8", "text": "Let v be the root of T and S = \u3008V,E, l,\u03a0, X\u3009 be the output of\nextractExp(\u03a0, X, VT , l, v, ET ,WT , \u2205,min).\nTo prove that S is an explanation for d with respect to \u03a0 and X , we need to show that there exists an explanation tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in T which satisfies Conditions (i) and (ii) in Definition 4 of the paper. That is, the following hold.\n(i) V = {v | v is a rule vertex inV \u2032}; (ii) E = {(v1, v2) | (v1, v), (v, v2) \u2208 E\u2032 for some atom vertex v \u2208 V \u2032}.\nTo do so, we construct a vertex-labeled tree and show that it is an explanation tree in T which satisfies above conditions. Thus, let us define a vertex-labeled tree T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 where\nV \u2032 = V \u222a {v | v \u2208 VT s.t. (v, v\u2032) \u2208 ET for some v\u2032 \u2208 V } (A1) E\u2032 = {(v, v\u2032) | v, v\u2032 \u2208 V \u2032 s.t. (v, v\u2032) \u2208 ET } (A2)\nWe now show that T \u2032 is an explanation tree in T , i.e., T \u2032 satisfies Conditions (i)\u2013(iv) in Definition 3.\n(i) Due to Line 8 and that v \u2208 VT , V \u2286 VT . So, by (A1), V \u2032 \u2286 VT . Also, by (A2), E\u2032 \u2286 ET .\n(ii) In the first call of Algorithm 4, v is the root of T . Then, at Line 5, the algorithm is called with a child c of v. Note that c is a rule vertex. Due to Line 8, for some v\u2032 \u2208 V , (v, v\u2032) \u2208 ET .\n(iii) Let v\u2032 be an atom vertex in V \u2032. Then, by (A1) and (A2), (v\u2032, v\u2032\u2032) \u2208 E\u2032 for some v\u2032\u2032 \u2208 V . This ensures that deg\u2032E(v\u2032) \u2265 1. Assume that deg\u2032E(v\u2032) > 1. Then, for some v\u2032\u2032\u2032 \u2208 V \u2032 (v\u2032\u2032 6= v\u2032\u2032\u2032), (v\u2032, v\u2032\u2032\u2032) \u2208 E\u2032. Then, v\u2032\u2032\u2032 \u2208 V . This is not possible due to Line 3. Thus, degE(v \u2032) = 1.\n(iv) Let v\u2032 be a rule vertex in V \u2032. Then, by (A1) v\u2032 \u2208 V and v is added into V at Line 8. Due to Line 9 and (A1), every child c of v is in V \u2032. Then, by (A2), (v, c) \u2208 E\u2032. That is, outET (v) \u2286 E\u2032.\nAs a last step, we show that T \u2032 satisfies Conditions (i) and (ii) in Definition 4.\n(i) Note that every element in the set {v | v \u2208 VT s.t. (v, v\u2032) \u2208 ET for some v\u2032 \u2208 V } is an atom vertex. Then, by (A1), V = {v | v is a rule vertex inV \u2032};\n8 (ii) Let S = {(v1, v2) | (v1, v), (v, v2) \u2208 E\u2032 for some atom vertex v \u2208 V \u2032}. We show that E = S.\nLet (v1, v2) \u2208 E. Then, (v1, v2) is added into E at Line 4. So, due to Lines 2 and 3, we know that there exists an atom vertex v \u2208 VT such that (v, v2) \u2208 ET . Then, by (A1), v \u2208 V \u2032 and, by (A2), (v, v2) \u2208 E\u2032. Also, by Line 9, we know that (v1, v) \u2208 ET . Then, by (A2), (v1, v) \u2208 E\u2032. Thus, (v1, v2) \u2208 S. That is, E \u2286 S.\nLet (v1, v2) \u2208 S. Then, for some atom vertex v \u2208 V \u2032, (v1, v), (v, v2) \u2208 E\u2032. By (A2), v1, v2 \u2208 V and (v1, v), (v, v2) \u2208 ET . Then, due to Lemma 7, (v1, v2) \u2208 E. That is, S \u2286 E.\nLemma 9 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, and p be an atom in X . Let T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X , T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation tree in T and v be a rule vertex in V \u2032. Then, the following inequality holds for the weight of v\nWT (v) \u2264 1 + |{u\u2032 |u\u2032 \u2208 desT \u2032(v)}|. (A3)"}, {"heading": "Proof of Lemma 9", "text": "We prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let u be a rule vertex in V \u2032 at height 0. Then, u is a leaf vertex. By the definition of the weight function, WT (u) = 1. Then, (A3) holds.\nInduction step: As an induction hypothesis, assume that for every rule vertex i \u2208 V \u2032 at height less than n, (A3) holds. We show that (A3) holds for every rule vertex w \u2208 V \u2032 at height n + 1. Let w be a rule vertex at height n + 1. Then, by the definition of the weight function, WT (w) = 1+ \u2211 w\u2032\u2208childE(w) WT (w\n\u2032). Let w\u2032 be a child of w. Note that w\u2032 is an atom vertex. By the definition of an explanation tree, w\u2032 \u2208 V \u2032 and w\u2032 has exactly one child w\u2032\u2032 \u2208 V \u2032 which is a rule vertex. Then, by the definition of the weight function, WT (w\u2032) = min{WT (c) | c \u2208 childE(w\u2032)} and thus WT (w\u2032) \u2264 WT (w\u2032\u2032). On the other hand, as the height of w\u2032\u2032 is n\u2212 1, by the induction hypothesis, WT (w\u2032\u2032) \u2264 1 + |{d | d \u2208 desT \u2032(w\u2032\u2032)}|. Since w\u2032 has exactly one child w\u2032\u2032 \u2208 V \u2032, we have\n1 + |{d | d \u2208 desT \u2032(w\u2032\u2032)}| = |{u |u \u2208 desT \u2032(w\u2032)}|.\nThat is, WT (w\u2032) \u2264 |{u |u \u2208 desT \u2032(w\u2032)}|. Then, we have\nWT (w) = 1 + \u2211\nw\u2032\u2208childE(w) WT (w \u2032)\n\u2264 1 +\u2211w\u2032\u2208childE(w) |{u |u \u2208 desT \u2032(w \u2032)}| = 1 + |{u\u2032 |u\u2032 \u2208 desT \u2032(w)}|.\n9 Lemma 10 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T be the and-or explanation tree (with edges E) for p with respect to \u03a0 and X , v be the root of T , and T \u2032 be an explanation tree (with vertices V \u2032) in T . Then,\nWT (v) \u2264 |{u |u is a rule vertex inV \u2032}|."}, {"heading": "Proof of Lemma 10", "text": "We want to show that the weight of v, WT (v), is at most the number of rule vertices in V \u2032. Note that v is the root of T \u2032 and there exists exactly one vertex v\u2032 \u2208 V \u2032 such that v\u2032 \u2208 childE(v) (due to Definition 3). Then, we have\nWT (v) = min{WT (c) | c \u2208 childE(v)} (by Definition 6) \u2264 WT (v\u2032) (as v\u2032 \u2208 childE(v)) \u2264 1 + |{v\u2032\u2032 | v\u2032\u2032 \u2208 desT \u2032(v\u2032)}| (by Lemma 9) = |{u |u is a rule vertex inV \u2032}|. (as v\u2032 is the only child of v in T \u2032)\nLemma 11 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T be the and-or explanation tree for p with respect to \u03a0 and X , v be the root of T , and \u3008V,E, l,\u03a0, X\u3009 be an explanation for p with respect to \u03a0 and X . Then, WT (v) \u2264 |V |."}, {"heading": "Proof of Lemma 11", "text": "We show that the weight of v, WT (v), is at most |V |. By the definition of an explanation, there exists an explanation tree T \u2032 (with vertices V \u2032) of T such that |V | = |{v\u2032 | v\u2032 is a rule vertex inV \u2032}|. By Lemma 10, WT (v) \u2264 |{v\u2032 | v\u2032 is a rule vertex inV \u2032}|. Thus, WT (v) \u2264 |V |.\nLemma 12 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X , and T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation tree in T . If we have\nWT (v) \u2264 min{WT (s) | s \u2208 siblingE(v)}. (A4) for every rule vertex v \u2208 V \u2032, then the following holds for every rule vertex v \u2208 V \u2032.\nWT (v) = 1 + |{u\u2032 |u\u2032 \u2208 desT \u2032(v)}|. (A5)"}, {"heading": "Proof of Lemma 12", "text": "Assume that (A4) holds for every rule vertex v \u2208 V \u2032. Then, we prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let u be a rule vertex in V \u2032 at height 0. Then, u is a leaf vertex. By the definition of the weight function, WT (u) = 1. As u has no descendants, (A5) holds.\n10\nInduction step: As an induction hypothesis, assume that for every rule vertex i \u2208 V \u2032 at height less than n, (A5) holds. We show that (A5) holds for every rule vertex w \u2208 V \u2032 at height n + 1. Let w \u2208 V \u2032 be a rule vertex at height n + 1. Then, by the definition of the weight function, WT (w) = 1 + \u2211 w\u2032\u2208childE(w) WT (w\n\u2032). Let w\u2032 be a child of w. Note that w\u2032 is an atom vertex. By the definition of an explanation tree, w\u2032 \u2208 V \u2032 and w\u2032 has exactly one child w\u2032\u2032 \u2208 V \u2032, which is a rule vertex. Then, by the definition of the weight function, WT (w\u2032) = min{WT (c) | c \u2208 childE(w\u2032)}. Also, by (A4), WT (w\u2032\u2032) \u2264 min{WT (s) | s \u2208 siblingE(w\u2032\u2032)}. Then, WT (w\u2032\u2032) = min{WT (c) | c \u2208 childE(w\u2032)}. Thus, WT (w\n\u2032) = WT (w\u2032\u2032). As the height of w\u2032\u2032 is n\u22121, by the induction hypothesis, WT (w\u2032\u2032) = 1+|{u |u \u2208 desT \u2032(w\u2032\u2032)}|. As w\u2032\u2032 is the only child of w\u2032, WT (w\u2032) = |{u |u \u2208 desT \u2032(w\u2032)}|. Then, we have\nWT (w) = 1 + \u2211\nw\u2032\u2208childE(w) WT (w \u2032)\n= 1 + \u2211\nw\u2032\u2208childE(w) |{u |u \u2208 desT \u2032(w \u2032)}|\n= 1 + |{u\u2032 |u\u2032 \u2208 desT \u2032(w)}|.\nLemma 13 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T be the and-or explanation tree (with edges E) for p with respect to \u03a0 and X , v be the root of T , and T \u2032 be an explanation tree (with vertices V \u2032) in T . If we have\nWT (v \u2032) \u2264 min{WT (s) | s \u2208 siblingE(v\u2032)} (A6)\nfor every rule vertex v\u2032 \u2208 V \u2032, then, the following holds\nWT (v) = |{u |u is a rule vertex inV \u2032}|."}, {"heading": "Proof of Lemma 13", "text": "Assume that (A4) holds for every rule vertex v\u2032 \u2208 V \u2032. Then, we want to show that the weight of v, WT (v), is equal to the number of rule vertices in V \u2032. Note that v is the root of T \u2032 and there exists exactly one vertex v\u2032 \u2208 V \u2032 such that v\u2032 \u2208 childE(v) (due to Definition 3). Then, we have\nWT (v) = min{WT (c) | c \u2208 childE(v)} (by Definition 6) = WT (v \u2032) (by (A6))\n= 1 + |{u\u2032 |u\u2032 \u2208 desT \u2032(v\u2032)}| (by Lemma 12) = |{u |u is a rule vertex inV \u2032}|. (as v\u2032 is the only child of v in T \u2032)\nWe are now ready to prove Proposition 3.\nProposition 3 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , Algorithm 1 either finds a shortest explanation for p with respect to \u03a0 and X or returns an empty vertexlabeled tree.\n11"}, {"heading": "Proof of Proposition 3", "text": "Algorithm 1 has two return statements; Lines 6 and 8. At Line 8, it returns an empty vertexlabeled tree. We show that what Algorithm 1 returns at Line 6, S = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009, is an explanation for p with respect to \u03a0 and X and that there is no other explanation for p with respect to \u03a0 and X , with vertices V \u2032\u2032, such that |V \u2032\u2032| < |V \u2032|.\nDue to the condition at Line 2, the vertex-labeled tree found at Line 1 is not empty. Then, by Proposition 12, we know that T is the and-or explanation tree for p with respect to \u03a0 and X . Then, by Lemma 8, we know that \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 found at Line 5 is an explanation for p with respect to \u03a0 and X .\nNow, suppose that there exists another explanation for p with respect to \u03a0 and X , with vertices V \u2032\u2032, such that |V \u2032\u2032| < |V \u2032|. Let v be the root of T . Then, by Lemma 11, WT (v) \u2264 |V \u2032\u2032|. Also, since S is an explanation for p with respect to \u03a0 and X , there exists an explanation tree with vertices V \u2032\u2032\u2032 in T such that V \u2032 = {u |u is a rule vertex inV \u2032\u2032\u2032}. Due to Lemma 6, WT (v\u2032) \u2264 min{WT (s) | s \u2208 siblingE(v\u2032)} for each v\u2032 \u2208 V \u2032. Then, by Lemma 13, WT (v) = |{u |u is a rule vertex inV \u2032\u2032\u2032}|. This implies that |V \u2032| \u2264 |V \u2032\u2032|. Since this is a contradiction, S is a shortest explanation for p with respect to \u03a0 and X .\nA.1.3 Proof of Proposition 4 \u2013 Complexity of Algorithm 1\nWe prove Proposition 4 which shows that the time complexity of Algorithm 1 is exponential in the size of the given answer set.\nProposition 4 Given a ground ASP program \u03a0, an answer set X for \u03a0, and an atom p in X , the time complexity of Algorithm 1 is O(|\u03a0||X| \u00d7 |B\u03a0|)."}, {"heading": "Proof of Proposition 4", "text": "In Algorithm 1, all the lines, expect 1, 4 and 5, take constant amount of time. At Lines 1, 4 and 5, three different algorithms are called. At Line 1, Algorithm 2 is called. This algorithm creates the and-or explanation tree recursively. As shown in Proof of Lemma 1, the branching factor of a vertex in the recursion tree is O(max{|X|, |\u03a0|}) and the height of the tree is O(|X|). Also, at Line 5, for an atom d \u2208 X , we check whether a rule in \u03a0 supports d in O(|B\u03a0|). Thus, the time complexity of Algorithm 2, in the worst case, is O(max{|X|, |\u03a0|}|X| \u00d7 |B\u03a0|). As |X| \u2264 |\u03a0|, it is O(|\u03a0||X| \u00d7 |B\u03a0|). At Lines 4 and 5, Algorithm 3 and Algorithm 4 are called, respectively. Algorithm 3 and Algorithm 4 simply traverse the tree T created by Algorithm 2 (cf. Lines 2 and 6 in Algorithm 3, and Lines 5 and 10 in Algorithm 4. By Proposition 12, we know that T is the and-or explanation tree for p with respect to \u03a0 and X . Since the height of T is O(|X|) and the branching factor of a vertex in T is max{|X|, |\u03a0|}, the time complexity of Algorithm 2 dominates the time complexities of others. Thus, the time complexity of Algorithm 1, in the worst case, is O(|\u03a0||X| \u00d7 |B\u03a0|).\n12\nA.2 Generating k Different Explanations\nIn Section 6 of the paper, we have first analyzed three properties of Algorithm 5, namely termination, soundness and complexity, resulting in Propositions 5, 6, and 8. Then, we show some characteristics of its output, resulting in Proposition 7, Corollary 1 and Corollary 2. In the following, we show the proofs of these results.\nA.2.1 Proof of Proposition 5 \u2013 Termination of Algorithm 5\nWe now prove Proposition 5 which shows that Algorithm 5 terminates.\nProposition 5 Given a ground ASP program \u03a0, an answer set X for \u03a0, an atom p in X , and a positive integer k, Algorithm 5 terminates."}, {"heading": "Proof of Proposition 5", "text": "Algorithm 5 calls Algorithm 2 at Line 2. By Lemma 1, we know that Algorithm 2 terminates. Then, to show that Algorithm 5 terminates, we need to show that the loop between Lines 4\u201310 terminates. Due to Line 4, the loop iterates at most k times. If it iterates less than k times, it means that it is terminated at Line 6. Thus, assume that it iterates k times. Then, it is enough to show that every iteration of the loop terminates. Consider the ith (1 \u2264 i \u2264 k) iteration of the loop. First, at Line 5, Algorithm 6 is called. Observe that this algorithm simply traverses the and-or explanation tree T created at Line 2 (cf. Lines 2, 3, 8 and 9 in Algorithm 6). Since T is finite, Algorithm 6 terminates. Next, Algorithm 4 is called at Line 7. Similar to Algorithm 6, this algorithm also simply traverses a portion of T (cf. Lines 3, 5, 9 and 10 in Algorithm 4). Hence, Algorithm 4 also terminates. As the rest of the loop consists of some assignment statements, the ith (1 \u2264 i \u2264 k) iteration of the loop terminates. Since every iteration of the loop terminates, Algorithm 5 terminates.\nA.2.2 Proof of Proposition 6 \u2013 Soundness of Algorithm 5\nBefore showing the soundness property of Algorithm 5, we provide some necessary lemmas.\nProposition 13 (Completeness of Algorithm 2) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X . Let T be the and-or explanation tree p with respect to \u03a0 and X . Then, createTree(\u03a0, X, p, {}) returns T ."}, {"heading": "Proof of Proposition 13", "text": "Let \u3008V,E, l,\u03a0, X\u3009 be the output of Algorithm 2. By Condition (i) in Definition 2, the root of T is an atom vertex with label p. Since p is in X and L = \u2205 at the beginning of Algorithm 2, a vertex v with label p is created at Line 3 and added into V at Line 4.\nTake an atom vertex v \u2208 V . Then, there should be an out-going edge (v, v\u2032) of v such that l(v\u2032) \u2208 \u03a0X,ancT (v\u2032)(l(v)) (due to Condition (ii) in Definition 2). Note that, the set L in Algorithm 2 is essentially ancT (v\u2032), and l(v\u2032) \u2208 \u03a0X,L(l(v)) is checked at Line 5.\n13\nMoreover, we need to ensure that v\u2032 is a rule vertex. This condition is checked at Line 6 by recursive calls.\nTake a rule vertex v \u2208 V . Then, for every atom a in B+(l(v)), there should be an outgoing edge (v, v\u2032) of v such that l(v\u2032) = a (due to Condition (iii) in Definition 2). This is satisfied by the condition at Line 13. Moreover, we need to make sure that v\u2032 is atom vertex. For that, there is a recursive call at Line 14.\nTake a leaf vertex v \u2208 V . Then, v must be a rule vertex (due to Condition (iv) in Definition 2). Assume that v is an atom vertex. Thus, no out-going edge is defined for v at Line 9. Then, when the loop at Line 5 terminates, the condition at Line 10 is satisfied. This implies that v is not in V . As it is a contradiction, v must be a rule vertex.\nBy this proposition and Proposition 1, we know that Algorithm 2 returns the and-or explanation tree. Thus, at Line 1 of Algorithm 5, the and-or explanation tree for p with respect to \u03a0 and X is created. We prove our statements by keeping this in mind.\nLemma 14 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to \u03a0 and X . Then, for the root vr of T , at each iteration i (1 \u2264 i \u2264 min{n, k}) of the loop in Algorithm 5, WT,Ri\u22121(vr) = |RVertices(Ki)\\Ri\u22121|."}, {"heading": "Proof of Lemma 14", "text": "Consider the ith (1 \u2264 i \u2264 min{n, k}) iteration of the loop. At Line 5, we call Algorithm 6 and calculate WT,Ri\u22121 for every vertex v in V . According to Algorithm 6, for an atom vertex v \u2208 V , due to Line 4, WT,Ri\u22121(v) = max{WT,Ri\u22121(v\u2032) | v\u2032 \u2208 childE(v)} and for a rule vertex u, due to Lines 6\u20139, WT,Ri\u22121(u) = xu + \u2211 u\u2032\u2208childE(u) WT,Ri\u22121(u\n\u2032) where xu = 1 if u /\u2208 Ri\u22121, xu = 0 otherwise. Let v be an atom vertex in V . Let {v\u20321, . . . , v\u2032vz} be a set of rule vertices that \u201ccontribute\u201d to WT,Ri\u22121(v), i.e., rule vertices that appear in the expanded formula of WT,Ri\u22121(v). This implies that WT,Ri\u22121 = xv\u20321 + . . . + xv\u2032vz where xv\u2032j = 1 if v \u2032 j /\u2208 Ri\u22121, xv\u2032j = 0 otherwise, for 1 \u2264 j \u2264 vz . Also, at Line 7 in Algorithm 5, we extract an explanation using Algorithm 4. Then, at Line 8, we assign the output \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 of Algorithm 4 to Ki. Let RVertices(Ki) = {v1, . . . , vz}. Observe in Algorithm 4 that for every atom vertex, we process its maximum weighted child recursively (Line 3), and for every rule vertex we choose every child of it recursively (Line 9). Then, due to the observation and the calculation of WT,Ri\u22121 , RVertices(Ki) is a set of rule vertices that contribute to WT,Ri\u22121(vr). Then, WT,Ri\u22121(vr) = x1 + . . . + xz where xj = 1 if vj /\u2208 Ri\u22121, xj = 0 otherwise, for 1 \u2264 j \u2264 z. That is, WT,Ri\u22121(vr) = |RVertices(Ki)\\Ri\u22121|.\nNow, we prove Proposition 6.\nProposition 6 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to \u03a0 and X . Then, Algorithm 5 returns min{n, k} different explanations for p with respect to \u03a0 and X .\n14"}, {"heading": "Proof of Proposition 6", "text": "First, assume that n \u2265 k. Then, we show that Algorithm 5 returns at Line 11 a set K of k different explanations for p with respect to \u03a0 and X . Note that an element is added into K at each iteration of the loop between Lines 4\u201310. Since that loop iterates k times, we need to show that two properties hold: (i) for every iteration i (1 \u2264 i \u2264 k), Ki (the element added into K at the ith iteration) is an explanation for p with respect to \u03a0 and X . (ii) for all iterations i, j (1 \u2264 i < j \u2264 k), Ki and Kj are different. In the following, we consider those two properties.\n(i) For every iteration i (1 \u2264 i \u2264 k), Ki is formed at Line 8. According to Line 7, Ki is an output of Algorithm 4. Then, due to Lemma 8, we conclude that Ki is an explanation for p with respect to \u03a0 and X .\n(ii) Assume otherwise. Then, there exists i, j (1 \u2264 i < j \u2264 k) such that Ki = Kj . Consider the jth iteration of the loop. At Line 5, we call Algorithm 6 and calculate WT,Rj\u22121 for every vertex v in V . Then, at Line 7, we extract an explanation using Algorithm 4. Let Kj = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009, vr be the root of \u3008V \u2032, E\u2032\u3009 and RVertices(Kj) = {v1, . . . , vl}. Then, by Lemma 14, WT,Rj\u22121(vr) = x1 + . . . + xl where xz = 1 if vz /\u2208 Rj\u22121, xz = 0 otherwise, for 1 \u2264 z \u2264 l. Since Ki = Kj , {v1, . . . , vl} = RVertices(Ki). Due to Line 10, we know that RV ertices(Ki) \u2286 Rj\u22121. Then, for 1 \u2264 z \u2264 l, vz \u2208 Rj\u22121. Thus, WT,Rj\u22121(vr) = 0. This implies that for every vertex v \u2208 V , WT,Rj\u22121(v) = 0. That is, every rule vertex in V is also in Rj\u22121. However, as we are at the jth iteration and at each iteration one explanation is computed, Rj\u22121 might contain rule vertices for at most j \u2212 1 explanations. We know that n \u2265 k. Thus, for some v\u2032 \u2208 V , the following should hold: v\u2032 /\u2208 Rj\u22121. As we reach a contradiction, Ki 6= Kj .\nNow, assume that n < k. Then, we show that Algorithm 5 returns at Line 6 a set K of n different explanations for p with respect to \u03a0 and X . Note that at the end of nth iteration of the loop, K contains n different explanations (due to the same reasoning above). Then, in the next iteration, WT,Rn+1(v) = 0. This is because Rn contains the rule vertices of n different explanations and the total number of explanations for p with respect to \u03a0 and X is n. Thus, the condition at Line 6 is satisfied and n different explanations are returned.\nA.2.3 Some Properties of Algorithm 5\nBefore presenting some characteristics of the output of Algorithm 5, we provide some necessary definitions and lemmas.\nDefinition 18 (WT,R) Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X , and R be a set of rule vertices in V . Then, WT,R is a function that maps vertices in V to nonnegative\n15\nintegers as follows.\nWT,R(v) =    max{WT,R(v\u2032) | v\u2032 \u2208 childE(v)} if v is an atom vertex;\u2211 v\u2032\u2208childE(v) WT,R(v \u2032) if v is a rule vertex and v \u2208 R; 1 +\n\u2211 v\u2032\u2208childE(v) WT,R(v \u2032) otherwise.\nLemma 15 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, and p be an atom in X . Let T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X , T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation tree in T and R be a set of rule vertices in V . Then, for every rule vertex v in V \u2032, the following holds\nWT,R(v) \u2265 {\n1 + |{u\u2032 |u\u2032 \u2208 (desT \u2032(v)\\R)}| if v /\u2208 R; |{u\u2032 |u\u2032 \u2208 (desT \u2032(v)\\R)}| otherwise.\n(A7)"}, {"heading": "Proof of Lemma 15", "text": "We prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let v be a rule vertex in V \u2032 at height 0. Then, v is a leaf vertex. By Definition 18, WT,R(v) = xv where xv = 1 if v /\u2208 R, xv = 0 otherwise. Then, (A7) holds.\nInduction step: As an induction hypothesis, assume that for every rule vertex i \u2208 V \u2032 at height less than n+ 1, (A7) holds. We show that (A7) holds for every rule vertex v \u2208 V \u2032 at height n+1. Let v be a rule vertex in V \u2032 at height n+1. Then, by Definition 18, WT,R(v) = xv + \u2211 v\u2032\u2208childE(v) WT,R(v\n\u2032) where xv = 1 if v /\u2208 R, xv = 0 otherwise. Let v\u2032 be a child of v. Note that v\u2032 is an atom vertex. By Conditions (iii) and (iv) in Definition 3, v\u2032 \u2208 V \u2032 and v\u2032 has exactly one child v\u2032\u2032 \u2208 V \u2032 which is a rule vertex. Then, by Definition 18, WT,R(v\n\u2032) = max{WT,R(c) | c \u2208 childE(v\u2032)} and thus WT,R(v\u2032) \u2265 WT,R(v\u2032\u2032). On the other hand, as the height of v\u2032\u2032 is n \u2212 1, by the induction hypothesis, (A7) holds for v\u2032\u2032. Thus, we obtain the following.\nWT,R(v \u2032) \u2265 { 1 + |{u\u2032 |u\u2032 \u2208 (desT \u2032(v\u2032\u2032)\\R)}| if v\u2032\u2032 /\u2208 R; |{u\u2032 |u\u2032 \u2208 (desT \u2032(v\u2032\u2032)\\R)}| otherwise.\n(A8)\nSince v\u2032 has exactly one child v\u2032\u2032 \u2208 V \u2032, we derive\n{v\u2032\u2032} \u222a {d | d \u2208 desT \u2032(v\u2032\u2032)} = |{u |u \u2208 desT \u2032(v\u2032)}|. (A9)\nThen, due to (A8) and (A9),\nWT,R(v \u2032) \u2265 |{u |u \u2208 (desT \u2032(v\u2032)\\R)}|. (A10)\nThen, to conclude the proof, we consider two cases. Case 1. Suppose that v /\u2208 R. Then, we can derive the following.\nWT,R(v) = 1 + \u2211\nv\u2032\u2208childE(v) WT,R(v \u2032) (by Definition 18)\n\u2265 1 +\u2211v\u2032\u2208childE(v) |{u |u \u2208 (desT \u2032(v \u2032)\\R)}| (by (A10)) = 1 + |{u\u2032 |u\u2032 \u2208 (desT \u2032(v)\\R)}|. (as every child of v is an atom vertex)\n16\nCase 2. Suppose that v \u2208 R. Then, we can derive the following.\nWT,R(v) = \u2211\nv\u2032\u2208childE(v) WT,R(v \u2032) (by Definition 18)\n\u2265 \u2211v\u2032\u2208childE(v) |{u |u \u2208 (desT \u2032(v \u2032)\\R)}| (by (A10)) = |{u\u2032 |u\u2032 \u2208 (desT \u2032(v)\\R}|. (as every child of v is an atom vertex)\nLemma 16 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T = \u3008V,E, l,\u03a0, X\u3009 be the and-or explanation tree for p with respect to \u03a0 and X , v be the root of T , T \u2032 be an explanation tree (with vertices V \u2032) in T , and R be a set of rule vertices in V . Then,\nWT,R(v) \u2265 |{u |u \u2208 (RVertices(T \u2032)\\R)}|."}, {"heading": "Proof of Lemma 16", "text": "We want to show that WT,R(v) is equal to at least the number of rule vertices in V \u2032 but R. Recall that v is the root of T \u2032 and there exists exactly one vertex v\u2032 \u2208 V \u2032 such that v\u2032 \u2208 childE(v) (due to Condition (iii) in Definition 3). Then, we consider two cases.\nCase 1. Assume that v\u2032 /\u2208 R. Then, we can derive the following.\nWT,R(v) = max{WT,R(c) | c \u2208 childE(v)} (by Definition 18) \u2265 WT,R(v\u2032) (as v\u2032 \u2208 childE(v)) \u2265 1 + |{v\u2032\u2032 | v\u2032\u2032 \u2208 (desT \u2032(v\u2032)\\R)}| (by Lemma 15) = |{u |u \u2208 (RVertices(T \u2032)\\R)}|. (as v\u2032 is the only child of v in T \u2032)\nCase 2. Assume that v\u2032 \u2208 R. Then, we can derive the following.\nWT,R(v) = max{WT,R(c) | c \u2208 childE(v)} (by Definition 18) \u2265 WT,R(v\u2032) (as v\u2032 \u2208 childE(v)) \u2265 |{v\u2032\u2032 | v\u2032\u2032 \u2208 (desT \u2032(v\u2032)\\R)}| (by Lemma 15) = |{u |u \u2208 (RVertices(T \u2032)\\R)}|. (as v\u2032 is the only child of v in T \u2032)\nLemma 17 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , T be the and-or explanation tree (with vertices V ) for p with respect to \u03a0 and X , v be the root of T , T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation for p with respect to \u03a0 and X , and R be a set of rule vertices in V . Then, WT,R(v) \u2265 |RVertices(T \u2032)\\R|.\n17"}, {"heading": "Proof of Lemma 17", "text": "We show that WT,R(v) is equal to at least |RVertices(T \u2032)\\R|. By Definition 4, there exists an explanation tree T \u2032\u2032 (with vertices V \u2032\u2032) in T such that V \u2032 = {v\u2032 | v\u2032 is a rule vertex inV \u2032\u2032}. That is, RVertices(T \u2032) = RVertices(T \u2032\u2032). By Lemma 16, we know that WT,R(v) \u2265 |{u |u \u2208 (RVertices(T \u2032\u2032)\\R)}|. Thus, we conclude that WT,R(v) \u2265 |RVertices(T \u2032)\\R|.\nWe can now prove our main result which simply indicates that at each iteration i of the loop in Algorithm 5 the distance \u2206D(Ri\u22121,Ki) is maximized.\nProposition 7 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to \u03a0 and X . Then, at the end of each iteration i (1 \u2264 i \u2264 min{n, k}) of the loop in Algorithm 5, \u2206D(Ri\u22121,RVertices(Ki)) is maximized, i.e., there is no other explanation K \u2032 such that \u2206D(Ri\u22121,RVertices(Ki)) < \u2206D(Ri\u22121,RVertices(K \u2032))."}, {"heading": "Proof of Proposition 7", "text": "The proof is by contradiction. Assume that there exists an explanation K \u2032 such that \u2206D(Ri\u22121,RVertices(Ki)) < \u2206D(Ri\u22121,RVertices(K \u2032)). That is, |RVertices(K \u2032)\\Ri\u22121| > |RVertices(Ki)\\Ri\u22121|. Let vr be the root of T . Then, by Lemma 17, WT,Ri\u22121(vr) \u2265 |RVertices(K \u2032)\\Ri\u22121|. Also, by Lemma 14, we know that WT,Ri\u22121(vr) = |RVertices(Ki)\\Ri\u22121|. Therefore, we obtain that |RVertices(Ki)\\Ri\u22121| \u2265 |RVertices(K \u2032)\\Ri\u22121|. But, that contradicts the assumption |RVertices(K \u2032)\\Ri\u22121| > |RVertices(Ki)\\Ri\u22121|. Thus, there is no K \u2032 such that \u2206D(Ri\u22121,RVertices(Ki)) < \u2206D(Ri\u22121,RVertices(K \u2032)), i.e., \u2206D(Ri\u22121,RVertices(Ki)) is maximized.\nNow, we provide the proof of the corollary that shows how to compute longest explanations.\nCorollary 1 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k = 1. Then, Algorithm 5 computes a longest explanation for p with respect to \u03a0 and X ."}, {"heading": "Proof of Corollary 1", "text": "Since k = 1, the loop in Algorithm 5 iterates once. At that iteration, by Proposition 6, we know that an explanation K1 for p with respect to \u03a0 and X is computed. By Proposition 7, we also know that \u2206D(R0,RVertices(K1)) is maximized. That is, there exists no explanation K \u2032 for p with respect to \u03a0 and X such that |RVertices(K \u2032)\\R0| > |RVertices(K1)\\R0|. Note that R0 is an empty set. Therefore, there exists no explanation K \u2032 for p with respect to \u03a0 and X such that |RVertices(K \u2032)| > |RVertices(K1)|. As every vertex of an explanation is a rule vertex, we conclude that K1 is a longest explanation for p with respect to \u03a0 and X .\n18\nNext, we indicate the proof of the corollary that shows Algorithm 5 computes min{n, k} different explanations such that for every i (1 \u2264 i \u2264 min{n, k}) the ith explanation is the most distant explanation from the previously computed i\u2212 1 explanations. Corollary 2 Let \u03a0 be a ground ASP program, X be an answer set for \u03a0, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to \u03a0 and X . Then, Algorithm 5 computes min{n, k} different explanations K1, . . . ,Kmin{n,k} for p with respect to \u03a0 and X such that for every j (2 \u2264 j \u2264 min{n, k}) \u2206D( \u22c3j\u22121 z=1 RVertices(Kz),Kj) is maximized."}, {"heading": "Proof of Corollary 2", "text": "By Proposition 6, we know that K1, . . . ,Kmin{n,k} are min{n, k} different explanations for p with respect to \u03a0 and X . Also, by Proposition 7, for every i (2 \u2264 i \u2264 min{n, k}), we obtain that \u2206D(Ri\u22121,Ki) is maximized. Due to Lines 1 and 10 of Algorithm 5, Ri\u22121 = \u22c3i\u22121 j=0 RVertices(Kj). Since R0 is an empty set, we conclude that \u2206D( \u22c3i\u22121 j=1 RVertices(Kj),Ki) is maximized.\nA.2.4 Proof of Proposition 8 \u2013 Complexity of Algorithm 5\nWe prove Proposition 8 which shows that the time complexity of Algorithm 5 is exponential in the size of the given answer set.\nProposition 8 Given a ground ASP program \u03a0, an answer set X for \u03a0, an atom p in X and a positive integer k, the time complexity of Algorithm 5 is O(k \u00d7 |\u03a0||X|+1 \u00d7 |B\u03a0|)."}, {"heading": "Proof of Proposition 8", "text": "Algorithm 5 calls Algorithm 2 at Line 2. In the proof of Proposition 4, it is shown that the worst case time complexity of Algorithm 2 is O(|\u03a0||X|\u00d7B\u03a0). Moreover, Algorithm 5 has a loop between Lines 4\u201310, which iterates at most k times. In every iteration of the loop, Algorithm 6 and Algorithm 4 are called at Lines 5 and 7. Algorithm 6 simply traverses the and-or explanation tree T recursively (cf. Lines 2, 3, 8 and 9 in Algorithm 6). The height of T is O(|X|) and the branching factor of a vertex in T is O(|\u03a0|). Also, at Line 8 in Algorithm 6, we check whether a rule vertex in V is in R. As R is a subset of the rule vertices in V , this check can be done in O(|\u03a0| \u00d7 |B\u03a0|) time. Thus, the time complexity of Algorithm 6, in the worst case, is O(|\u03a0||X| \u00d7 |\u03a0| \u00d7 |B\u03a0|). Similar to Algorithm 6, Algorithm 4 just traverses a portion of T (cf. Lines 3, 5, 9 and 10 in Algorithm 4). Thus, the time complexity of every iteration of the loop in Algorithm 5 is O(|\u03a0||X|+1 \u00d7 |B\u03a0|). As the loop iterates at most k times, the time complexity of Algorithm 5, in the worst case, is O(k \u00d7 |\u03a0||X|+1 \u00d7 |B\u03a0|).\nA.3 Relations between Explanations and Justifications\nIn Section 10 of the paper, we have related explanations to justifications, resulting in Propositions 10 and 11. In the following, we show the proofs of these results.\n19\nA.3.1 Proof of Proposition 10 \u2013 Soundness of Algorithm 7\nIn the proof of Proposition 10, the idea is to show that Algorithm 7 returns at Line 17 an explanation tree T \u2032 in the and-or explanation tree for p with respect to \u03a0 and X . That is, T \u2032 satisfies Conditions (i)\u2013(iv) in Definition 3. Before providing the proof of Proposition 10, we consider some useful lemmas and corollaries.\nLemma 18 Let \u03a0 be a ground normal ASP program, X be an answer set for \u03a0, p be an atom in X , U be an assumption in Assumptions(\u03a0, X), G = (V,E) be an offline justification of p+ with respect to X and U , T = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an output of Algorithm 7 and P = \u3008v1, . . . , vn\u3009 be a path in T . Take any three consecutive elements vi, vi+1 and vi+2 in P such that vi and vi+2 are atom vertices and vi+1 is a rule vertex. Then, (l(vi) +, l(vi+2) +,+) \u2208 E holds."}, {"heading": "Proof of Lemma 18", "text": "As vi is an atom vertex, its out-going edges are formed at Line 15 of Algorithm 7. Then, due to Lines 13 and 14, vi+1 is a rule vertex such that B(l(vi+1)) = support(l(vi)+, G). As vi+1 is a rule vertex, its out-going edges are formed at Line 10. Then, due to Lines 8 and 9, vi+2 is an atom vertex where l(vi+2) \u2208 B+(l(vi+1)). Since B(l(vi+1)) = support(l(vi)\n+, G) and l(vi+2) \u2208 B+(l(vi+1)), by Definition 10, (l(vi)+, l(vi+2)+,+) \u2208 E holds.\nCorollary 3 Let \u03a0 be a ground normal ASP program, X be an answer set for \u03a0, p be an atom in X , U be an assumption in Assumptions(\u03a0, X), G = (N,E) be an offline justification of p+ with respect to X and U , T = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an output of Algorithm 7 and P = \u3008v1, . . . , vn\u3009 be a path in T where v1 and vn are atom vertices. Then, l(vn)+ is reachable from l(v1)+ by a positive path in G."}, {"heading": "Proof of Corollary 3", "text": "Note that an edge in E\u2032 is either defined from an atom vertex to a rule vertex or vice versa due to Lines 10 and 15 of Algorithm 7. By this observation, in P , as v1 is an atom vertex, vi is an atom vertex (resp., rule vertex) if i is an odd number (resp., a even number). Then, by Lemma 18, for 1 \u2264 i \u2264 n \u2212 2 and i mod 2 6= 0 (i.e., i is an odd number), (l(vi)+, l(vi+2)+,+) \u2208 E. Thus, there exists a positive path\u2329 l(v1) +, l(v3) +, l(v5) +, . . . , l(v+n\u22122), l(vn) + \u232a\nin G. That is, l(vn)+ is reachable from l(v1) + by a positive path in G.\nLemma 19 Let \u03a0 be a ground normal ASP program, X be an answer set for \u03a0, p be an atom in X , U be an assumption in Assumptions(\u03a0, X), G = (N,E) be an offline justification of p+ with respect to X and U , T = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an output of Algorithm 7 and v be an atom vertex in V \u2032 such that v is the first element added into the queue Q in Algorithm 7. Consider a sequence S = \u3008v1 = v, v2, . . . , vn\u3009 of n elements where vi \u2208 V \u2032 for 1 \u2264 i \u2264 n\n20\nsuch that vj+1 is added into Q right after vj for 1 \u2264 j < n. Then, every vertex vi \u2208 V \u2032 (1 < i \u2264 n) is reachable from v by a path in T ."}, {"heading": "Proof of Lemma 19", "text": "The proof is by induction on the length of S.\nBase case: Assume that S has two elements, i.e., S = \u3008v1 = v, v2\u3009. Since v is the first vertex added into Q by definition, it is the first vertex dequeued from Q at Line 5. Then, since v is an atom vertex by definition, the second vertex is added into Q at Line 16. By definition of S, v2 is the second vertex added into Q. Thus, by Line 15, (v, v2) \u2208 E\u2032, i.e., v2 is reachable from v by a path in T .\nInduction step: As an induction hypothesis, assume that for a sequence S\u2032 = \u3008v1 = v, v2, . . . , vk\u3009 of k elements, where vi \u2208 V \u2032 for 1 \u2264 i \u2264 k such that vj+1 is added into Q right after vj for 1 \u2264 j < k, every vertex vl \u2208 V (1 < l \u2264 k) is reachable from v by a path in T . Let S\u2032\u2032 = \u3008v1 = v, v2, . . . , vk+1\u3009 be a sequence of k + 1 elements, where vi \u2208 V \u2032 for 1 \u2264 i \u2264 k + 1 such that vj+1 is added into Q right after vj for 1 \u2264 j < k + 1. We show that v reaches every vertex in S\u2032\u2032 by using edges in E\u2032. Consider the subsequence S\u2032\u2032sub of S\n\u2032\u2032 that consists of the first k elements of S\u2032\u2032, i.e., a prefix of S\u2032\u2032 with length k. By the induction hypothesis, every vertex vi \u2208 S\u2032\u2032sub is reachable from v by a path in T . Now, we show that vk+1 is reachable from v by a path in T . We consider two cases. Case 1. Assume that vk+1 is an atom vertex. Then, vk+1 is added into V \u2032 at Line 11. So, by Line 10, there exists a vertex v\u2032 such that (v\u2032, vk+1) \u2208 E\u2032. But, due to Line 5, v\u2032 must be added into Q prior to vk+1. That is, v\u2032 \u2208 S\u2032\u2032sub. So, by the induction hypothesis, v reaches v\u2032 by a path P in T . Thus, by P and (v\u2032, vk+1), vk+1 is reachable from v by a path in T . Case 2. Assume that vk+1 is a rule vertex. Then, vk+1 is added into V \u2032 at Line 16. So, by Line 15, there exists a vertex v\u2032 such that (v\u2032, vk+1) \u2208 E\u2032. But, due to Line 5, v\u2032 must be added into Q prior to vk+1. That is, v\u2032 \u2208 S\u2032\u2032sub. So, by the induction hypothesis, v reaches v\u2032 by a path P in T . Thus, by P and (v\u2032, vk+1), vk+1 is reachable from v by a path in T .\nWe now prove Proposition 10 that shows the soundness of Algorithm 7.\nProposition 10 Given a ground normal ASP program \u03a0, an answer set X for \u03a0, an atom p in X , an assumption U in Assumption(\u03a0, X), and an offline justification G = (V,E) of p+ with respect to X and U , Algorithm 7 returns an explanation tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X ."}, {"heading": "Proof of Proposition 10", "text": "We show what Algorithm 7 returns at Line 17, T \u2032 = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009, is an explanation tree in the and-or explanation tree T = \u3008VT , ET , l,\u03a0, X\u3009 for p with respect to \u03a0 and X . That is, T \u2032 satisfies Conditions (i)\u2013(iv) in Definition 3. In the following, we study each condition separately.\n21\n(ii) To show that the root of \u3008V \u2032, E\u2032\u3009 is a vertex whose label is p, we need to show three cases hold; (1) there exists a vertex v in V \u2032 with label p, (2) every vertex v\u2032 \u2208 V \u2032 is reachable from v by a path in T \u2032. (3) v has no in-going edge. In the following, we show that each case holds. Case 1. Observe that a vertex is in V \u2032 if and only if it is added into the queue Q. Then, due to Lines 2 and 3, there exists a vertex v \u2208 V \u2032 such that l(v) = p. Case 2. The first element added into Q is an atom vertex v with l(v) = p, due to Lines 2 and 3. Note that a vertex is in V \u2032 if and only if it is added into Q. Then, as v is added into Q, by the observation, v \u2208 V \u2032. Now, pick a vertex v\u2032 \u2208 V \u2032. By the same observation, v\u2032 is also added into Q. Since v is the first element queued in Q, v\u2032 is queued in V \u2032 later on. Thus, by Lemma 19, v\u2032 is reachable from v by a path in T \u2032. Case 3. Assume otherwise. That is, (v\u2032, v) \u2208 E\u2032 for some vertex v\u2032 \u2208 V \u2032. The edges in E\u2032 are constructed at Lines 10 and 15. Then, as v is an atom vertex, v\u2032 is a rule vertex. Observe that a vertex is in V \u2032 if and only if it is added into Q. Then, since v\u2032 is a rule vertex in V \u2032, it is added into Q at Line 16. So, due to Line 15, there exists an atom vertex v\u2032\u2032 \u2208 V \u2032 such that (v\u2032\u2032, v\u2032) \u2208 E\u2032. Thus, as (v\u2032\u2032, v\u2032), (v\u2032, v) \u2208 E\u2032, there exists a path \u3008v\u2032\u2032, v\u2032, v\u3009 in T \u2032. Then, by Corollary 3, l(v)+ is reachable from l(v\u2032\u2032)+ by a positive path P in G. Moreover, as shown in Case 2 above, v\u2032\u2032 is reachable from v by a path \u3008v1 = v, v2, . . . , vn = v\u2032\u2032\u3009 in T \u2032. So, by Corollary 3, l(v\u2032\u2032)+ is reachable from l(v)+ by a positive path P \u2032 in G. Then, by P and P \u2032, a positive cycle exists in G. As every offline justification is a safe offline e-graph due to Definition 17, we reach a contradiction.\n(i) By Condition (ii) in Definition 3, we know that the root of \u3008V \u2032, E\u2032\u3009 is a vertex v with l(v) = p. Then, if we show that for every vertex v\u2032 \u2208 V \u2032, outE\u2032(v\u2032) is a subset of ET , then we can conclude that \u3008V \u2032, E\u2032\u3009 is a subtree of \u3008VT , ET \u3009. Now, pick a vertex v\u2032 \u2208 V \u2032. We consider two cases: Case 1. Assume that v\u2032 is an atom vertex. Take an out-going edge (v\u2032, v\u2032\u2032) of v\u2032 in E\u2032. To show that (v\u2032, v\u2032\u2032) \u2208 ET , we need to show that l(v\u2032\u2032) \u2208 \u03a0X,ancT \u2032 (v\u2032\u2032)(l(v\u2032)), due to Condition (ii) in Definition 2. For that, we should show that H(l(v\u2032\u2032)) = l(v\u2032), B+(l(v\u2032\u2032)) \u2286 X\\ancT \u2032(v\u2032\u2032), B\u2212(l(v\u2032\u2032)) \u2229 X = \u2205 and X |= Bcard(l(v\u2032\u2032)), due to (8) in Section 4. As \u03a0 is a ground normal ASP program, it does not contain cardinality expressions in its body. Thus, X |= Bcard(l(v\u2032\u2032)) trivially. In Algorithm 7, outgoing edges of atom vertices are formed at Line 15. Then, due to Lines 13 and 14, H(l(v\u2032\u2032)) = l(v\u2032) and B(l(v\u2032\u2032)) = support(l(v\u2032)+, G). Since G is an offline justification, G is an offline e-graph by Definition 17. Then, by Definition 13, G is an (X,U)based e-graph. So, by Definition 12, support(l(v\u2032)+, G) is an LCE of l(v\u2032)+ with respect to (X,U), so does B(l(v\u2032\u2032)). According to Definition 11, as B(l(v\u2032\u2032)) 6= {assume}, B+(l(v\u2032\u2032)) \u2286 X and B\u2212(l(v\u2032\u2032)) \u2229 X = \u2205. To complete this part, it remains to show that B+(l(v\u2032\u2032)) \u2286 X\\ancT \u2032(v\u2032\u2032). Since B+(l(v\u2032\u2032)) \u2286 X , it is enough to show that B+(l(v\u2032\u2032)) \u2229 ancT \u2032(v\u2032\u2032) = \u2205. For that, assume B+(l(v\u2032\u2032)) \u2229 ancT \u2032(v\u2032\u2032) 6= \u2205. Let a \u2208 B+(l(v\u2032\u2032)) \u2229 ancT \u2032(v\u2032\u2032). Since a \u2208 B+(l(v\u2032\u2032)) and B(l(v\u2032\u2032)) = support(l(v\u2032)+, G), (l(v\u2032)+, a+,+) \u2208 E holds. As a \u2208 ancT \u2032(v\u2032\u2032), there exists a vertex u \u2208 V \u2032 where l(u) = a such that a path P = \u3008v1 = u, . . . , vn = v\u2032\u3009 in T \u2032 exists. Then, due to Corollary 3, l(v\u2032)+ is reachable from a+ by a positive path in G. But, as (l(v\u2032)+, a+,+) \u2208 E, (a+, a+) \u2208 E\u2217,+\n22\nholds, i.e., there is a positive cycle in the offline justification, which is a contradiction, due to Definition 17. Case 2. Assume that v\u2032 is a rule vertex. Take an out-going edge (v\u2032, v\u2032\u2032) of v\u2032 in E\u2032. To show that (v\u2032, v\u2032\u2032) \u2208 ET , we need to show that l(v\u2032\u2032) \u2208 B+(l(v\u2032)), due to Condition (iii) in Definition 2. Out-going edges of v\u2032 are formed at Line 10 which is reached only by satisfying the condition at Line 8. Then, due to Line 9, l(v\u2032\u2032) \u2208 B+(l(v\u2032)).\n(iii) Observe that an element is added into Q once. Thus, we dequeue each atom vertex only once. Then, due to Lines 12\u201316, every atom vertex v\u2032 \u2208 V \u2032 has exactly one out-going edge, i.e., degE\u2032(v \u2032) = 1.\n(iv) Take a rule vertex v\u2032 \u2208 V \u2032. Its edges are formed at Line 10. Then, due to the condition at Line 8 and the statement at Line 9, for every a \u2208 B+(l(v\u2032)), there exists a vertex v\u2032\u2032 such that l(v\u2032\u2032) = a. Then, the condition holds.\nAlso, we can show that the and-or explanation tree exists for every atom in an answer set.\nProposition 1 Let \u03a0 be a ground ASP program and X be an answer set for \u03a0. For every p be in X , the and-or explanation tree for p with respect to \u03a0 and X is not empty."}, {"heading": "Proof of Proposition 1", "text": "By Proposition 9, we know that there exists an offline justification of p+ with respect to X and X\u2212\\WF\u2212\u03a0 . Then, by Proposition 10, there is an explanation tree in the and-or explanation tree for p with respect to \u03a0 and X . That is, the and-or explanation tree for p with respect to \u03a0 and X is not empty.\nA.3.2 Proof of Proposition 11 \u2013 Soundness of Algorithm 8\nBefore proving Proposition 11, we provide the necessary lemmas.\nLemma 20 Let \u03a0 be a ground normal ASP program, X be an answer set for \u03a0, p be an atom in X , T = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation tree in the and-or explanation tree for p with respect to \u03a0 and X such that for every v, v\u2032 \u2208 V \u2032, l(v) = l(v\u2032) if and only if v = v\u2032, (V,E) be the output of Algorithm 8 called with inputs \u03a0, X, p and T , and \u3008v1, v2, v3\u3009 be a path in T such that l(v1)+ \u2208 V . Then, (l(v1)+, l(v3)+,+) \u2208 E and l(v3)+ \u2208 V ."}, {"heading": "Proof of Lemma 20", "text": "All of the nodes, except the one with label >, are added to V at Line 5 of Algorithm 8. As l(v1)\n+ \u2208 V , v1 is extracted from the queue Q at Line 4. Then, since \u3008v1, v2, v3\u3009 is a path in T and every atom vertex in V \u2032 has exactly one child due to Condition (iii) in Definition 3, v2 is obtained at Line 6. By the condition at Line 9, every child of v2 is considered in the loop. Accordingly, at Line 10, the edge (l(v1)+, l(v3)+,+) is added into E. Also, v3 is\n23\nadded into Q at Line 11. Then, due to the condition at Line 3 and the statements at Lines 4 and 5, l(v3)+ \u2208 V .\nCorollary 4 Let \u03a0 be a ground normal ASP program, X be an answer set for \u03a0, p be an atom in X , T = \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 be an explanation tree in the and-or explanation tree for p with respect to \u03a0 and X such that for every v, v\u2032 \u2208 V \u2032, l(v) = l(v\u2032) if and only if v = v\u2032, (V,E) be the output of Algorithm 8 called with inputs \u03a0, X, p and T , and \u3008v1, v2, . . . , vn\u3009 be a path in T such that l(v1)+ \u2208 V . Then, \u3008l(v1)+, l(v3)+, l(v5)+, . . . , l(vn)+\u3009 is a path in (V,E)."}, {"heading": "Proof of Corollary 4", "text": "Since \u3008v1, v2, v3\u3009 is a path in T and l(v1)+ \u2208 V , by Lemma 20, (l(v1)+, l(v3)+,+) \u2208 E and l(v3)+ \u2208 V . Similarly, (l(v3)+, l(v5)+,+) \u2208 E and l(v5)+ \u2208 V . Then, this incremental application of Lemma 20 leads that \u3008l(v1)+, l(v3)+, l(v5)+, . . . , l(vn)+\u3009 is a path in (V,E).\nWe now prove Proposition 11 which shows that Algorithm 8 creates an offline justification of the given atom in the reduct of the given ASP program with respect to the given answer set, provided that labels of the vertices of the given explanation tree are unique labels, i.e., no two different vertices labels the same entity.\nProposition 11 Given a ground normal ASP program \u03a0 , an answer set X for \u03a0, an atom p in X , and an explanation tree \u3008V \u2032, E\u2032, l,\u03a0, X\u3009 in the and-or explanation tree for p with respect to \u03a0 and X such that for every v, v\u2032 \u2208 V \u2032, l(v) = l(v\u2032) if and only if v = v\u2032, Algorithm 8 returns an offline justification of p+ in \u03a0X with respect to X and \u2205."}, {"heading": "Proof of Proposition 11", "text": "To show that the output (V,E) of Algorithm 8 at Line 13 is an offline justification of p+ in \u03a0X with respect to X and \u2205, one needs to show that the following conditions hold.\n(1) \u2205 \u2208 Assumptions(\u03a0X , X); (2) (V,E) is an e-graph for \u03a0X ; (3) (V,E) is a (X, \u2205)-based e-graph of p+; (4) (V,E) is an offline e-graph of p+ with respect to X and \u2205.\nCondition (1) We show that \u2205 \u2208 Assumptions(\u03a0X , X). As \u03a0X is a positive program, i.e., it does not contain any negative atoms, by Definition 14, T A\u03a0X (X) = \u2205. Also, due to Definition 15, NR(\u03a0X , X) = \u03a0X . Then, by Definition 16, \u2205 \u2208 Assumptions(\u03a0X , X).\nCondition (2) We show that (V,E) is an e-graph for \u03a0X . For that, (V,E) should satisfy Conditions (i)\u2212 (iv) in Definition 9.\n(i) Consider two cases.\n24\nCase 1. Take a node b+ \u2208 V \\{>}. It is added to V at Line 5. Then, there exists an atom vertex v \u2208 V \u2032 such that l(v) = b. By Condition (iii) in Definition 3, v has exactly one child v\u2032 in \u3008V \u2032, E\u2032\u3009, which is a rule vertex. Then, depending on whether l(v\u2032) is a fact or not, an out-going edge of b+ in E is formed at Line 8 or 10. So, b+ is not a sink. Case 2. Let l be >. Then, it is added to V at Line 12. The edges in E are formed at Lines 8 and 10. Accordingly, l has no out-going edge, i.e., it is a sink. Therefore, (V,E) is an e-graph for \u03a0X . (ii) Due to Lines 8 and 10, clearly, for every b \u2208 V there is no edges in the form of (b, assume,\u2212) and (b,\u22a5,\u2212) in E.\n(iii) Similar to (ii), for every b \u2208 V there is no edges in the form of (b, assume,+) and (b,>,+) in E. (iv) Let b+ \u2208 V such that (b+,>,+) \u2208 E. As out-going edges are created at Lines 8 and 10, (b,>,+) must be formed at Line 8. Then, there exists an atom vertex v \u2208 V \u2032 such that l(v) = b and the label of the child v\u2032 of v is a fact (Line 7). Then, since the condition at Line 9 is not satisfied, it is not possible that b+ has another out-going edge.\nCondition (3) We show that (V,E) is an (X, \u2205)-based e-graph of p+. By Condition (1) above, we know that (V,E) is an e-graph. To show that (V,E) is an (X, \u2205)-based e-graph of p+, we need to show that Conditions (i) and (ii) in Definition 12 hold.\n(i) Take a node c+ \u2208 V . It is added to V at Line 5. Then, there exists an atom vertex v\u2032 \u2208 V \u2032 such that l(v\u2032) = c. By Condition (ii) in Definition 3, we know that the root of \u3008V \u2032, E\u2032\u3009 is a vertex v where l(v) = p. So, v\u2032 is reachable from v by a path \u3008v1 = v, v2, v3, . . . , vn = v\u2032\u3009 in \u3008V \u2032, E\u2032\u3009. Also, as v is added into Q at Line 2, we know that l(v)+ \u2208 V by Line 5. Then, by Corollary 4, \u3008l(v)+, l(v3)+, . . . , l(v\u2032)+\u3009 is a path in (V,E). That is, c+ is reachable from p+.\n(ii) Let G = (V,E). Take a node c+ \u2208 V \\{>}. Then, support(c+, G) = {a | (c+, a+,+) \u2208 E} or support(c+, G) = {>}. Assume that support(c+, G) = {a | (c+, a+,+) \u2208 E}. As c+ \u2208 V \\{>}, there exists an atom vertex v \u2208 V \u2032 such that l(v) = c. By Condition (iii) in Definition 3, there exists exactly one child v\u2032 of v in \u3008V \u2032, E\u2032\u3009. Then, due to the condition at Line 9, for each a \u2208 support(c+, G), (v\u2032, v\u2032\u2032) \u2208 E\u2032 where v\u2032\u2032 \u2208 V \u2032 with l(v\u2032\u2032) = a. Thus, B+(l(v\u2032)) = support(c+, G). By Condition (ii) in Definition 2, H(l(v\u2032)) = c and B+(l(v\u2032)) \u2286 X . Hence, support(c+G) is an LCE of (X, \u2205).\nCondition (4) We show that (V,E) is an offline e-graph of p+ with respect to X and \u2205. By Condition (3) above, we know that (V,E) is an (X, \u2205)-based e-graph of p+. Then, to show that (V,E) is an offline e-graph of p+ with respect to X and \u2205, we need to show that (V,E) satisfies Conditions (i) and (ii) in Definition 13. As edges in E are formed at Lines 8 and 10, for every b \u2208 V there are no edges in the form of (b, assume,+) and (b, assume,\u2212) in E. Then, conditions are trivially satisfied."}], "references": [{"title": "Logic programming and negation: A survey", "author": ["APT K.R.", "BOL R.N."], "venue": "J. Log. Program. 19/20, 9\u201371.", "citeRegEx": "R. and N.,? 1994", "shortCiteRegEx": "R. and N.", "year": 1994}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. BARAL"], "venue": "Cambridge University Press.", "citeRegEx": "BARAL,? 2003", "shortCiteRegEx": "BARAL", "year": 2003}, {"title": "A preliminary report on answering complex queries related to drug discovery using answer set programming", "author": ["O. BODENREIDER", "Z.H. COBAN", "M.C. DOGANAY", "E. ERDEM", "H. KOSUCU"], "venue": "Proc. of ALPSWS.", "citeRegEx": "BODENREIDER et al\\.,? 2008", "shortCiteRegEx": "BODENREIDER et al\\.", "year": 2008}, {"title": "Debugging logic programs under the answer set semantics", "author": ["M. BRAIN", "M.D. VOS"], "venue": "Proc. of ASP.", "citeRegEx": "BRAIN and VOS,? 2005", "shortCiteRegEx": "BRAIN and VOS", "year": 2005}, {"title": "Answer set programming at a glance", "author": ["G. BREWKA", "T. EITER", "M. TRUSZCZYNSKI"], "venue": "Commun. ACM 54, 12, 92\u2013103.", "citeRegEx": "BREWKA et al\\.,? 2011", "shortCiteRegEx": "BREWKA et al\\.", "year": 2011}, {"title": "New uses for old drugs", "author": ["C.R. CHONG", "D.J. SULLIVAN"], "venue": "Nature 448, 645\u2013646.", "citeRegEx": "CHONG and SULLIVAN,? 2007", "shortCiteRegEx": "CHONG and SULLIVAN", "year": 2007}, {"title": "The Comparative Toxicogenomics Database: update 2011", "author": ["A.P. DAVIS", "B.L. KING", "S. MOCKUS", "C.G. MURPHY", "C. SARACENI-RICHARDS", "M. ROSENSTEIN", "T. WIEGERS", "C.J. MATTINGLY"], "venue": "Nucleic Acids Research 39, Database issue, D1067\u2013D1072.", "citeRegEx": "DAVIS et al\\.,? 2011", "shortCiteRegEx": "DAVIS et al\\.", "year": 2011}, {"title": "Effective integration of declarative rules with external evaluations for Semantic-Web reasoning", "author": ["T. EITER", "G.IANNI", "R.SCHINDLAUER", "H.TOMPITS."], "venue": "Proc. of ESWC.", "citeRegEx": "EITER et al\\.,? 2006", "shortCiteRegEx": "EITER et al\\.", "year": 2006}, {"title": "Finding answers and generating explanations for complex biomedical queries", "author": ["E. ERDEM", "Y. ERDEM", "H. ERDOGAN", "U. OZTOK"], "venue": "Proc. of AAAI.", "citeRegEx": "ERDEM et al\\.,? 2011", "shortCiteRegEx": "ERDEM et al\\.", "year": 2011}, {"title": "BIOQUERY-ASP: Querying biomedical ontologies using answer set programming", "author": ["E. ERDEM", "H. ERDOGAN", "U. OZTOK"], "venue": "Proc. of RuleML2011@BRF Challenge.", "citeRegEx": "ERDEM et al\\.,? 2011", "shortCiteRegEx": "ERDEM et al\\.", "year": 2011}, {"title": "Transforming controlled natural language biomedical queries into answer set programs", "author": ["E. ERDEM", "R. YENITERZI"], "venue": "Proc. of the Workshop on BioNLP. 117\u2013124.", "citeRegEx": "ERDEM and YENITERZI,? 2009", "shortCiteRegEx": "ERDEM and YENITERZI", "year": 2009}, {"title": "Weight constraints as nested expressions", "author": ["P. FERRARIS", "V. LIFSCHITZ"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374.", "citeRegEx": "FERRARIS and LIFSCHITZ,? 2005", "shortCiteRegEx": "FERRARIS and LIFSCHITZ", "year": 2005}, {"title": "Advances in gringo series 3", "author": ["M. GEBSER", "R. KAMINSKI", "A. KOENIG", "T. SCHAUB"], "venue": "Proc of. LPNMR. Vol. 6645. 345\u2013351.", "citeRegEx": "GEBSER et al\\.,? 2011", "shortCiteRegEx": "GEBSER et al\\.", "year": 2011}, {"title": "clasp: A conflict-driven answer set solver", "author": ["M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB"], "venue": "Proc. of LPNMR. 260\u2013265.", "citeRegEx": "GEBSER et al\\.,? 2007", "shortCiteRegEx": "GEBSER et al\\.", "year": 2007}, {"title": "A meta-programming technique for debugging answer-set programs", "author": ["M. GEBSER", "J. PUEHRER", "T. SCHAUB", "H. TOMPITS"], "venue": "Proc. of AAAI.", "citeRegEx": "GEBSER et al\\.,? 2008", "shortCiteRegEx": "GEBSER et al\\.", "year": 2008}, {"title": "The well-founded semantics for general logic programs", "author": ["A.V. GELDER", "K.A. ROSS", "J.S. SCHLIPF"], "venue": "J. ACM 38, 3, 620\u2013650.", "citeRegEx": "GELDER et al\\.,? 1991", "shortCiteRegEx": "GELDER et al\\.", "year": 1991}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proc. of ICLP. MIT Press, 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1991", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1991}, {"title": "Born again", "author": ["T. GOWER"], "venue": "Proto Magazine Summer, 14\u201319.", "citeRegEx": "GOWER,? 2009", "shortCiteRegEx": "GOWER", "year": 2009}, {"title": "A side effect resource to capture phenotypic effects of drugs", "author": ["M. KUHN", "M. CAMPILLOS", "I. LETUNIC", "L.J. JENSEN", "P. BORK"], "venue": "Molecular Systems Biology 6, 343.", "citeRegEx": "KUHN et al\\.,? 2010", "shortCiteRegEx": "KUHN et al\\.", "year": 2010}, {"title": "Answer set programming and plan generation", "author": ["V. LIFSCHITZ"], "venue": "Artificial Intelligence 138, 39\u201354.", "citeRegEx": "LIFSCHITZ,? 2002", "shortCiteRegEx": "LIFSCHITZ", "year": 2002}, {"title": "What is answer set programming? In Proc", "author": ["V. LIFSCHITZ"], "venue": "of AAAI. MIT Press, 1594\u20131597.", "citeRegEx": "LIFSCHITZ,? 2008", "shortCiteRegEx": "LIFSCHITZ", "year": 2008}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. MAREK", "M. TRUSZCZY\u0143SKI"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013 398.", "citeRegEx": "MAREK and TRUSZCZY\u0143SKI,? 1999", "shortCiteRegEx": "MAREK and TRUSZCZY\u0143SKI", "year": 1999}, {"title": "From pharmacogenomic knowledge acquisition to clinical applications: the PharmGKB as a clinical pharmacogenomic biomarker resource", "author": ["E.M. MCDONAGH", "M. WHIRL-CARRILLO", "Y. GARTEN", "R.B. ALTMAN", "T.E. KLEIN"], "venue": "Biomarkers in Medicine 5, 6, 795\u2013806.", "citeRegEx": "MCDONAGH et al\\.,? 2011", "shortCiteRegEx": "MCDONAGH et al\\.", "year": 2011}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. NIEMEL\u00c4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273.", "citeRegEx": "NIEMEL\u00c4,? 1999", "shortCiteRegEx": "NIEMEL\u00c4", "year": 1999}, {"title": "An A-Prolog decision support system for the space shuttle", "author": ["M. NOGUEIRA", "M. BALDUCCINI", "M. GELFOND", "R. WATSON", "M. BARRY"], "venue": "Proc. of PADL. Springer, 169\u2013183.", "citeRegEx": "NOGUEIRA et al\\.,? 2001", "shortCiteRegEx": "NOGUEIRA et al\\.", "year": 2001}, {"title": "Catching the ouroboros: On debugging nonground answer-set programs", "author": ["J. OETSCH", "J. PUEHRER", "H. TOMPITS"], "venue": "TPLP 10, 4-6, 513\u2013529.", "citeRegEx": "OETSCH et al\\.,? 2010", "shortCiteRegEx": "OETSCH et al\\.", "year": 2010}, {"title": "Stepping through an answer-set program", "author": ["J. OETSCH", "J. PUEHRER", "H. TOMPITS"], "venue": "LPNMR. 134\u2013147.", "citeRegEx": "OETSCH et al\\.,? 2011", "shortCiteRegEx": "OETSCH et al\\.", "year": 2011}, {"title": "Generating explanations for complex biomedical queries", "author": ["U. OZTOK"], "venue": null, "citeRegEx": "OZTOK,? \\Q2012\\E", "shortCiteRegEx": "OZTOK", "year": 2012}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. PONTELLI", "T.C. SON", "O. EL-KHATIB"], "venue": "Theory and Practice of Logic Programming, 1\u201356.", "citeRegEx": "PONTELLI et al\\.,? 2009", "shortCiteRegEx": "PONTELLI et al\\.", "year": 2009}, {"title": "Team-building with answer set programming in the Gioia-Tauro seaport", "author": ["F. RICCA", "G. GRASSO", "M. ALVIANO", "M. MANNA", "V. LIO", "S. IIRITANO", "N. LEONE"], "venue": "Theory and Practice of Logic Programming 12.", "citeRegEx": "RICCA et al\\.,? 2012", "shortCiteRegEx": "RICCA et al\\.", "year": 2012}, {"title": "Disease Ontology: a backbone for disease semantic integration", "author": ["L.M. SCHRIML", "C. ARZE", "S. NADENDLA", "CHANG", "Y.-W.W.", "M. MAZAITIS", "V. FELIX", "G. FENG", "W.A. KIBBE"], "venue": "Nucleic Acids Research 40, Database issue, D940\u2013D946.", "citeRegEx": "SCHRIML et al\\.,? 2012", "shortCiteRegEx": "SCHRIML et al\\.", "year": 2012}, {"title": "Extending and implementing the stable model semantics", "author": ["P. SIMONS", "I. NIEMEL\u00c4", "T. SOININEN"], "venue": "Artificial Intelligence 138, 181\u2013234.", "citeRegEx": "SIMONS et al\\.,? 2002", "shortCiteRegEx": "SIMONS et al\\.", "year": 2002}, {"title": "BioGRID: a general repository for interaction datasets", "author": ["C. STARK", "BREITKREUTZ", "B.-J.", "T. REGULY", "L. BOUCHER", "A. BREITKREUTZ", "M. TYERS"], "venue": "Nucleic Acids Research 34, Database issue, D535\u2013D539.", "citeRegEx": "STARK et al\\.,? 2006", "shortCiteRegEx": "STARK et al\\.", "year": 2006}, {"title": "Debugging inconsistent answer set programs", "author": ["T. SYRJANEN"], "venue": "Proc. of NMR.", "citeRegEx": "SYRJANEN,? 2006", "shortCiteRegEx": "SYRJANEN", "year": 2006}, {"title": "A practical tool for mass-customising configurable products", "author": ["J. TIIHONEN", "T. SOININEN", "R. SULONEN"], "venue": "Proc. of the International Conference on Engineering Design. 1290\u2013 1299.", "citeRegEx": "TIIHONEN et al\\.,? 2003", "shortCiteRegEx": "TIIHONEN et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 8, "context": ", representing complex queries in natural language and finding answers to queries efficiently), novel methods and a software system, called BIOQUERY-ASP (Erdem et al. 2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al.", "startOffset": 153, "endOffset": 172}, {"referenceID": 20, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 1, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 21, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 4, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 10, "context": "\u2022 Erdem and Yeniterzi (Erdem and Yeniterzi 2009) developed a controlled natural language, BIOQUERY-CNL, for expressing biomedical queries related to drug discovery.", "startOffset": 22, "endOffset": 48}, {"referenceID": 2, "context": "(Bodenreider et al. 2008) introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer.", "startOffset": 0, "endOffset": 25}, {"referenceID": 8, "context": "(Erdem et al. 2011) have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query.", "startOffset": 0, "endOffset": 19}, {"referenceID": 23, "context": "Next, Section 7 illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources PHARMGKB (McDonagh et al. 2011), DRUGBANK (Knox et al.", "startOffset": 136, "endOffset": 158}, {"referenceID": 33, "context": "BIOGRID (Stark et al. 2006), CTD (Davis et al.", "startOffset": 8, "endOffset": 27}, {"referenceID": 6, "context": "2006), CTD (Davis et al. 2011), SIDER (Kuhn et al.", "startOffset": 11, "endOffset": 30}, {"referenceID": 19, "context": "2011), SIDER (Kuhn et al. 2010), DISEASE ONTOLOGY (Schriml et al.", "startOffset": 13, "endOffset": 31}, {"referenceID": 31, "context": "2010), DISEASE ONTOLOGY (Schriml et al. 2012) and ORPHADATA.", "startOffset": 24, "endOffset": 45}, {"referenceID": 29, "context": "In Section 10, we provide a detailed analysis of the related work on \u201cjustifications\u201d (Pontelli et al. 2009) in comparison to explanations; and in Section 11, we briefly discuss other related work.", "startOffset": 86, "endOffset": 108}, {"referenceID": 20, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 1, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 21, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 4, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 16, "context": "The idea is to represent a problem as a \u201cprogram\u201d whose models (called \u201canswer sets\u201d (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.", "startOffset": 85, "endOffset": 141}, {"referenceID": 17, "context": "The idea is to represent a problem as a \u201cprogram\u201d whose models (called \u201canswer sets\u201d (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.", "startOffset": 85, "endOffset": 141}, {"referenceID": 13, "context": "ASP also provides efficient solvers, such as CLASP (Gebser et al. 2007).", "startOffset": 51, "endOffset": 71}, {"referenceID": 25, "context": "Here are, for instance, three applications of ASP used in industry: \u2022 Decision Support Systems: An ASP-based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks (Nogueira et al. 2001) (used by United Space Alliance).", "startOffset": 215, "endOffset": 237}, {"referenceID": 35, "context": "\u2022 Automated Product Configuration: A web-based commercial system uses an ASPbased product configuration technology (Tiihonen et al. 2003) (used by Variantum Oy).", "startOffset": 115, "endOffset": 137}, {"referenceID": 30, "context": ", skills, fairness, regulations (Ricca et al. 2012) (used by Gioia Tauro seaport).", "startOffset": 32, "endOffset": 51}, {"referenceID": 21, "context": "The idea of ASP (Lifschitz 2008) is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem, and to find the answer sets for that program using an answer set solver.", "startOffset": 16, "endOffset": 32}, {"referenceID": 32, "context": "(called cardinality expressions) where each Ai is an atom and l and u are nonnegative integers denoting the \u201clower bound\u201d and the \u201cupper bound\u201d (Simons et al. 2002).", "startOffset": 144, "endOffset": 164}, {"referenceID": 11, "context": "Programs using these constructs can be viewed as abbreviations for normal nested programs defined in (Ferraris and Lifschitz 2005).", "startOffset": 101, "endOffset": 130}, {"referenceID": 12, "context": "For CLASP, we use the \u201cgrounder\u201d GRINGO (Gebser et al. 2011).", "startOffset": 40, "endOffset": 60}, {"referenceID": 8, "context": "We have earlier developed the software system BIOQUERY-ASP (Erdem et al. 2011) (see Figure 1) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drugdrug interactions, cliques of genes based on gene-gene relations, or similar/diverse genes.", "startOffset": 59, "endOffset": 78}, {"referenceID": 7, "context": "If the biomedical ontology is in RDF(S)/OWL then we can extract such knowledge using the ASP solver DLVHEX (Eiter et al. 2006) by making use of external predicates.", "startOffset": 107, "endOffset": 126}, {"referenceID": 5, "context": "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer\u2019s Viagra (Gower 2009).", "startOffset": 69, "endOffset": 94}, {"referenceID": 18, "context": "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer\u2019s Viagra (Gower 2009).", "startOffset": 205, "endOffset": 217}, {"referenceID": 8, "context": "Once the query and the rule layer are in ASP, the parts of the rule layer that are relevant to the given query are identified by an algorithm (Erdem et al. 2011).", "startOffset": 142, "endOffset": 161}, {"referenceID": 29, "context": "The most similar work to ours is (Pontelli et al. 2009) that study the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d.", "startOffset": 33, "endOffset": 55}, {"referenceID": 29, "context": "As an answer to this question, the authors of (Pontelli et al. 2009) finds a \u201cjustification\u201d, which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set.", "startOffset": 46, "endOffset": 68}, {"referenceID": 29, "context": "To relate offline justifications and explanations, we need to introduce the following definitions and notations about justifications defined in (Pontelli et al. 2009).", "startOffset": 144, "endOffset": 166}, {"referenceID": 29, "context": "First, let us introduce notations related to ASP programs used in (Pontelli et al. 2009).", "startOffset": 66, "endOffset": 88}, {"referenceID": 15, "context": "Apart from the answer set semantics, there is another important semantics of logic programs, called the well-founded semantics (Gelder et al. 1991).", "startOffset": 127, "endOffset": 147}, {"referenceID": 15, "context": "We consider the definition proposed in (Apt and Bol 1994), instead of the original definition proposed in (Gelder et al. 1991), as the authors of (Pontelli et al.", "startOffset": 106, "endOffset": 126}, {"referenceID": 29, "context": "1991), as the authors of (Pontelli et al. 2009) considered.", "startOffset": 25, "endOffset": 47}, {"referenceID": 29, "context": "In (Pontelli et al. 2009), the authors prove the following proposition which shows that for every atom in the program, there exists an offline justification.", "startOffset": 3, "endOffset": 25}, {"referenceID": 34, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al.", "startOffset": 13, "endOffset": 28}, {"referenceID": 14, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.", "startOffset": 84, "endOffset": 124}, {"referenceID": 26, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.", "startOffset": 84, "endOffset": 124}, {"referenceID": 3, "context": "In (Brain and Vos 2005), similar to our work, the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d is studied.", "startOffset": 3, "endOffset": 23}, {"referenceID": 3, "context": "As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in \u03a0 that supports X with respect to \u03a0; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules).", "startOffset": 46, "endOffset": 66}, {"referenceID": 27, "context": "In (Oetsch et al. 2011), a framework where the users can construct interpretations through an interactive stepping process is introduced.", "startOffset": 3, "endOffset": 23}, {"referenceID": 29, "context": "As a result, (Pontelli et al. 2009) and (Oetsch et al.", "startOffset": 13, "endOffset": 35}, {"referenceID": 27, "context": "2009) and (Oetsch et al. 2011) can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping.", "startOffset": 10, "endOffset": 30}, {"referenceID": 3, "context": "In (Brain and Vos 2005), similar to our work, the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d is studied. As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in \u03a0 that supports X with respect to \u03a0; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules). Pontelli et al. (2009) also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set.", "startOffset": 4, "endOffset": 382}], "year": 2013, "abstractText": "We introduce novel mathematical models and algorithms to generate (shortest or k different) explanations for biomedical queries, using answer set programming. We implement these algorithms and integrate them in BIOQUERY-ASP. We illustrate the usefulness of these methods with some complex biomedical queries related to drug discovery, over the biomedical knowledge resources PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA.", "creator": "LaTeX with hyperref package"}}}