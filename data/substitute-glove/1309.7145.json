{"id": "1309.7145", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Sep-2013", "title": "Propagating Regular Counting Constraints", "abstract": "Constraints in finite sequences of denote fact casual city microarray and timetabling. Moreover, set wide quality known more constraints in involves utilizing led to general analyzing techniques and simplified propagation algorithms, often companies on linear finite one-dimensional (DFA) and come modification. We whether attempt - DFAs (cDFA ), of agencies annotated compact for start counting constraints, that takes constraints bringing given number of turned means following - meaning example spawning leaving a correspond. We show say coming guidelines hierarchy consistency next formula_5 since for atmost making summoners spot counting constraints based up put frequent found most while cDFA with although accepting trade others a placed effective that not be incremented by transitions. We been prove although was spite more exact regular exactly uncertainties is NP - hard then indicate that he partial iteration for exact nine counting dictated means switch well its more freshet much an limited codice_29 from [18 ]. Regular run matters them closely have to brought CostRegular constraint but contributes yet piece less descriptive and some computational combination.", "histories": [["v1", "Fri, 27 Sep 2013 08:23:52 GMT  (26kb)", "http://arxiv.org/abs/1309.7145v1", "Includes a SICStus Prolog source file with the propagator"]], "COMMENTS": "Includes a SICStus Prolog source file with the propagator", "reviews": [], "SUBJECTS": "cs.AI cs.FL", "authors": ["nicolas beldiceanu", "pierre flener", "justin pearson", "pascal van hentenryck"], "accepted": true, "id": "1309.7145"}, "pdf": {"name": "1309.7145.pdf", "metadata": {"source": "CRF", "title": "Propagating Regular Counting Constraints", "authors": ["Nicolas Beldiceanu", "Pierre Flener", "Justin Pearson", "Pascal Van Hentenryck"], "emails": ["Nicolas.Beldiceanu@mines-nantes.fr", "pvh@nicta.com.au"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 9.\n71 45\nv1 [\ncs .A\nI] 2\n7 Se"}, {"heading": "1 Introduction", "text": "Constraints over finite sequences of variables arise in many sequencing and timetabling applications, and the last decade has witnessed significant research on how to model and propagate, in a generic way, idiosyncratic constraints that are often featured in these applications. The resulting modelling techniques are often based on formal languages and, in particular, deterministic finite automata (DFA). Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].\nThis paper is concerned with the concept of counter-DFA (cDFA), an extension of DFAs proposed in [3], and uses it to model regular counting constraints, that is constraints on the number of regular-language patterns occurring in a sequence of variables. cDFAs typically result in more concise and natural encodings of regular counting constraints compared to DFAs, but it is unknown if\nthey admit efficient propagators enforcing domain consistency. This paper originated as an attempt to settle this question. We consider the subset of cDFAs satisfying two conditions: (1) all their states are accepting, and (2) they manipulate a single counter that can be incremented by transitions. These conditions are satisfied for many regular counting constraints and offer a good compromise between expressiveness and efficiency.\nOur main contribution is to show that, for such a counter automaton A, it is possible to enforce domain consistency efficiently on atmost and atleast regular counting constraints. Constraint cAutomatonAtMost(N,X,A) holds if the counter of A is at most N after A has consumed sequence X . Constraint cAutomatonAtLeast(N,X,A) is defined similarly. We also prove the NPhardness of satisfiability testing for constraint cAutomaton(N,X,A), which holds if the counter of A is exactly N after A has consumed X . Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X . Furthermore, our propagators for atmost and atleast regular counting achieve domain consistency on the counter variable N (and X) in the same asymptotic time as the CostRegular propagator achieves only bounds consistency on N (but also domain consistency on X).\nThe rest of the paper is organised as follows. Section 2 defines cDFAs, regular counting constraints, and the class of cDFAs considered. Section 3 gives the propagator, its complexity, and its evaluation. Section 4 concludes the paper and discusses related work."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 Deterministic Finite Counter Automata", "text": "Recall that a deterministic finite automaton (DFA) is a tuple \u3008Q,\u03a3, \u03b4, q0, F \u3009, where Q is the set of states, \u03a3 is the alphabet, \u03b4 : Q \u00d7\u03a3 \u2192 Q is the transition function, q0 \u2208 Q is the start state, and F \u2286 Q is the set of accepting states.\nThis paper considers a subclass of counter-DFAs in which all states are accepting and only one counter is used. The counter is initialised to 0 and increases by a given natural number at every transition. Such an automaton accepts every string and assigns a value to its counter. More formally, a counter-DFA (cDFA) is here specified as a tuple \u3008Q,\u03a3, \u03b4, q0, F \u3009, where Q, \u03a3, q0, and F are as in a DFA except that F = Q and the DFA transition function \u03b4 is extended to the signature Q \u00d7 \u03a3 \u2192 Q \u00d7 N, so that \u03b4(q, \u2113) = \u3008r, inc\u3009 indicates that r is the successor state of state q upon reading alphabet symbol \u2113 and the counter must be incremented by inc. We also define two projections of this extended transition function: if \u03b4(q, \u2113) = \u3008r, inc\u3009, then \u03b4Q(q, \u2113) = r and \u03b4N(q, \u2113) = inc. Given \u03b4(q, \u2113) = \u3008r, inc\u3009, we denote by C(q \u2113 \u2192 r) the counter increase inc of transition q \u2113 \u2192 r from state q to state r upon consuming symbol \u2113. Similarly, we denote by C(q \u03c3 r) the counter increase of a path q \u03c3 r from state q to state r upon consuming a (possibly empty) string \u03c3.\nExample 1. Consider the automatonAAB in Figure 1. It represents a cDFA with state set Q = {\u01eb, a, aa} and alphabet \u03a3 = {a, b}. The transition function \u03b4 is given by the labelled arcs between states, and the start state is q0 = \u01eb (indicated by an arc coming from no state; we often denote the start state by \u01eb, because it can be reached by consuming the empty string \u01eb). Since the final states F are all the states in Q, this automaton recognises every string over {a, b} and is thus by itself not very interesting. However, the cDFA features a counter k that is initialised to 0 at the start state, incremented by 1 on the transition from state aa to state \u01eb upon reading symbol \u2018b\u2019, and incremented by 0 on all other transitions. As a result, the final value of k is the number of occurrences of the word \u201caab\u201d within the string."}, {"heading": "2.2 Regular Counting Constraints", "text": "A regular counting constraint is defined as a constraint that can be modelled by a cDFA. The cAutomaton(N,X,A) constraint holds if the value of variable N , called the counter variable, is equal to the final value of the counter after cDFA A has consumed the values of the entire sequence X of variables. Consider the constraint NumberWord(N,X,w), which holds if N is the number of occurrences of the non-empty word w in the sequence X of variables. Constraint NumberWord(N,X, \u201caab\u201d) can be modelled by the cAutomaton(N,X,AAB) constraint with the automaton AAB specified in Figure 1."}, {"heading": "2.3 Signature Constraints", "text": "A constraint on a sequence X of variables can sometimes be modelled with the help of a DFA or cDFA that operates not on X , but on a sequence of signature variables that functionally depend via signature constraints on a sliding window of variables within X [3].\nFor example, the Among(N,X,V) constraint [4] requires N to be the number of variables in the sequence X that are assigned a value from the given set V . With signature constraints xi \u2208 V \u21d4 si = 1 and xi /\u2208 V \u21d4 si = 0 (with xi \u2208 X), we obtain a sequence of |X | signature variables si that can be used in a cDFA that counts the number of occurrences of value 1 in that sequence. Rather than labelling the transitions of such a cDFA with values of the domain of the signature variables (the set {0, 1} here), we label them with the corresponding\nconditions of the signature constraints, as in the cDFA AMONG given in Figure 2. Note that the choice of Among is purely pedagogical: we do not argue that this is the best way to model and propagate this constraint.\nIf each signature variable depends on a sliding window of size 1 within X (as for Among), then the signature constraints are unary. Our results also apply to cDFAs with unary signature constraints because a network of a cAutomatonAtMost constraint and unary signature constraints is Berge-acyclic."}, {"heading": "3 The Propagator", "text": ""}, {"heading": "3.1 Feasibility Test and Domain Consistency Filtering", "text": "Our propagator is defined in terms of the following concepts, which assume a sequence x1, . . . , xn of variables:\n\u2013 Define QCF(i) (respectively QCF(i)) to be the set of pairs \u3008q, c\u3009 where c is the minimum (respectively maximum) counter increase (or value) after the automaton consumes string \u03c3 from state q0 to reach state q, for all strings \u03c3 = \u03c31 \u00b7 \u00b7 \u00b7\u03c3i where i \u2208 [0, n] and \u03c3j \u2208 dom(xj) for each j \u2208 [1, i].\n\u2013 Define QCB(i) (respectively QCB(i)) to be the set of pairs \u3008q, c\u3009 where c is the minimum (respectively maximum) counter increase after the automaton consumes string \u03c3 from state q to reach a state appearing in QCF(n)\n(respectively QCF(n)), for all strings \u03c3 = \u03c3i \u00b7 \u00b7 \u00b7\u03c3n where i \u2208 [1, n+ 1] and \u03c3j \u2208 dom(xj) for each j \u2208 [i, n].\nExample 2. By illustrating one representative of these four quantities, we show that we have to maintain the maximum counter value for every state reachable from q0 in i steps, rather than just maintaining the overall maximum counter value and the set of states reachable from q0 in i steps. Consider the automaton RST in Figure 3, where q0 is \u01eb. In a sequence of n = 6 variables x1, . . . , x6 that\nmust be assigned value \u2018r\u2019 or \u2018t\u2019, we have:\nQCF(0) = {\u3008\u01eb, 0\u3009}\nQCF(1) = {\u3008\u01eb, 0\u3009, \u3008r, 1\u3009}\nQCF(2) = {\u3008\u01eb, 1\u3009, \u3008r, 1\u3009, \u3008rr , 1\u3009}\nQCF(3) = {\u3008\u01eb, 1\u3009, \u3008r, 2\u3009, \u3008rr , 1\u3009, \u3008rrt , 1\u3009}\nQCF(4) = {\u3008\u01eb, 2\u3009, \u3008r, 2\u3009, \u3008rr , 2\u3009, \u3008rrt , 1\u3009, \u3008rrtr , 3\u3009}\nQCF(5) = {\u3008\u01eb, 2\u3009, \u3008r, 3\u3009, \u3008rr , 3\u3009, \u3008rrt , 2\u3009, \u3008rrtr , 3\u3009}\nQCF(6) = {\u3008\u01eb, 3\u3009, \u3008r, 3\u3009, \u3008rr , 3\u3009, \u3008rrt , 3\u3009, \u3008rrtr , 4\u3009}\nIndeed, \u3008rrtr , 4\u3009 \u2208 QCF(6) because \u3008rrt , 2\u3009 \u2208 QCF(5) and there is a transition in A from rrt to rrtr on symbol \u2018r\u2019 with a counter increase of 2, even though three states have a higher counter value (namely 3) than rrt in QCF(5).\nTo compute QCF(i) and QCB(i), we need an operation that takes a set of state-and-integer pairs and keeps only the pairs \u3008q, c\u3009 where there is no pair \u3008q, c\u2032\u3009 with c\u2032 < c. Formally, trimMin(S) = {\u3008q, c\u3009 \u2208 S | \u2204\u3008q, c\u2032\u3009 \u2208 S : c\u2032 < c}.\nFor brevity, we use trimMin \u03c6(q,c) (\u3008q, c\u3009) to denote trimMin({\u3008q, c\u3009 | \u03c6(q, c)}), for any condition \u03c6. We inductively define QCF(i) and QCB(i) as follows:\nQCF(i) =\n\n \n \n{\u3008q0, 0\u3009} if i = 0\ntrimMin \u3008q,c\u3009\u2208QCF(i\u22121)\n\u2113\u2208dom(xi)\n(\u3008\u03b4Q(q, \u2113), c+ \u03b4N(q, \u2113)\u3009) if i \u2208 [1, n]\nQCB(i) =\n\n  \n  \n{\u3008q, 0\u3009 | \u2203c \u2208 N : \u3008q, c\u3009 \u2208 QCF(n)} if i = n+ 1\ntrimMin \u3008q\u2032,c\u2032\u3009\u2208QCB(i+1)\n\u2113\u2208dom(xi) \u03b4(q,\u2113)=\u3008q\u2032,inc\u3009\n(\u3008q, c\u2032 + inc\u3009) if i \u2208 [1, n]\nWe prove that the inductively computed quantities correspond to the definitions of QCF(i) and QCB(i). First consider QCF(i). The base case QCF(0) follows from the initialisation to zero of the counter. By induction, suppose the set QCF(i\u22121) is correct. Before applying trimMin, the set contains all pairs obtained upon reading the symbol \u2113 starting from some pair \u3008q, c\u3009 in QCF(i\u2212 1), where c is the minimum counter value for q over sequences of length i\u2212 1. The trimMin operation then filters out all the pairs \u3008q\u2032, c\u2032\u3009 with non-minimum counter value for q\u2032. The correctness proof for QCB(i) is similar.\nWe define the cAutomatonAtMost(N,X,A) propagator. The propagator for cAutomatonAtLeast is similar. The following theorem gives a feasibility test.\nTheorem 1. A cAutomatonAtMost(N, [x1, . . . , xn],A) constraint has a solution iff the minimum value of the counter of A after consuming the entire sequence is at most the maximum of the domain of N :\nmin \u3008q,c\u3009\u2208QCF(n) c \u2264 max(dom(N))\nProof. Suppose c is the minimum counter value such that \u3008q, c\u3009 \u2208 QCF(n) for some state q. By the definition of QCF(n), there is some sequence \u03c3 = \u03c31 \u00b7 \u00b7 \u00b7\u03c3n where for all 1 \u2264 j \u2264 n the symbol \u03c3j belongs to dom(xj) such that C(q0 \u03c3 q) = c. Because each \u03c3j belongs to the domain of the corresponding variable, we have that \u03c3 is a solution to cAutomatonAtMost iff c \u2264 max(dom(N)).\nWe now show how to achieve domain consistency on cAutomatonAtMost.\nTheorem 2. For a cAutomatonAtMost(N, [x1, . . . , xn],A) constraint, define the minimum value of the counter of A for variable xi to take value \u2113:\nm(i, \u2113) = min \u3008q,c\u3009\u2208QCF(i\u22121)\nq\u2032=\u03b4Q(q,\u2113)\n\u3008q\u2032,c\u2032\u3009\u2208QCB(i+1)\n(c+ \u03b4N(q, \u2113) + c \u2032)\n1. A value \u2113 in dom(xi) (with i \u2208 [1, n]) appears in a solution iff the minimum value of the counter is at most the maximum of the domain of N :\nm(i, \u2113) \u2264 max(dom(N))\n2. A value in dom(N) appears in a solution iff it is at least the minimum counter value given in Theorem 1.\nProof. We start with the first claim. (If) We show that any \u2113 \u2208 dom(xi) with m(i, \u2113) \u2264 max(dom(N)) participates in a solution. Suppose m(i, \u2113) equals c + \u03b4N(q, \u2113) + c\n\u2032 for some \u3008q, c\u3009 \u2208 QCF(i \u2212 1) and some \u3008q\u2032, c\u2032\u3009 \u2208 QCB(i + 1), with q\u2032 = \u03b4Q(q, \u2113). Then there exist two strings \u03c3 = \u03c31 \u00b7 \u00b7 \u00b7\u03c3i\u22121 and \u03c4 = \u03c3i+1 \u00b7 \u00b7 \u00b7\u03c3n and some state qn such that\nC(q0 \u03c3 q) = c\nand\nC(q\u2032 \u03c4 qn) = c \u2032\nwith \u03c3j \u2208 dom(xj) for all j \u2208 [1, n]. Note that the length of \u03c3\u2113\u03c4 is n. We have:\nC(q0 \u03c3\u2113\u03c4 qn) = C(q0 \u03c3 q) + \u03b4N(q, \u2113) + C(q \u2032 \u03c4 qn)\n= c+ \u03b4N(q, \u2113) + c \u2032\n= m(i, \u2113) \u2264 max(dom(N)).\nHence the assignment corresponding to \u03c3\u2113\u03c4 satisfies the domains and the constraint, so \u2113 \u2208 dom(xi) participates in a solution. (Only if) If \u2113 \u2208 dom(xi) participates in a solution, then the counter of that solution is at least m(i, \u2113) and at most max(dom(N)), hence m(i, \u2113) \u2264 max(dom(N)).\nThe second claim follows from Theorem 1. Indeed, let c = min\u3008q,c\u3009\u2208QCF(n) c So there exists a sequence \u03c3 = \u03c31 \u00b7 \u00b7 \u00b7\u03c3n with each \u03c3j \u2208 dom(xj) such that C(q0 \u03c3 q) = c. Further, for any \u03c3\u2032 = \u03c3\u20321 \u00b7 \u00b7 \u00b7\u03c3 \u2032 n with each \u03c3 \u2032 j \u2208 dom(xj) for all j \u2208 [1, n], we have c \u2264 C(q0 \u03c3\u2032 q\u2032n) for some state q \u2032 n. So, by Theorem 1, we need to prove that v \u2208 dom(N) participates in a solution iff c \u2264 v. (Only if) If v \u2208 dom(N) participates in a solution, then there exists a sequence \u03c3\u2032 = \u03c3\u20321 \u00b7 \u00b7 \u00b7\u03c3 \u2032 n such that each \u03c3\u2032j \u2208 dom(xj) and C(q0 \u03c3\u2032 q\u2032n) \u2264 v. Since c \u2264 C(q0 \u03c3\u2032\nq\u2032n), we have c \u2264 v. (If) If c \u2264 v, then the sequence \u03c3 above necessarily also forms a solution with N = v.\nA propagator is obtained by directly implementing the expressions and conditions of Theorems 1 and 2. It is idempotent."}, {"heading": "3.2 Complexity", "text": "The complexity of a non-incremental implementation of the propagator is established as follows. Recall that we consider sequences of n variables xi, each with at most the automaton alphabet \u03a3 as domain. Let the automaton have |Q| states. Each set QCF(i) has O(|Q|) elements and takes O(|\u03a3| \u00b7 |Q|) time to construct and trim (assuming it is implemented as a counter-value array indexed by Q, with all cells initialised to +\u221e). There are n+1 such sets, hence the entire QCF(\u00b7) vector takes O(n \u00b7 |\u03a3| \u00b7 |Q|) time and \u0398(n \u00b7 |Q|) space. Similarly, the entire QCB(\u00b7) vector takes O(n \u00b7 |\u03a3| \u00b7 |Q|) time and \u0398(n \u00b7 |Q|) space. Each value m(i, \u2113) takes O(|Q|) time to construct, since at most |Q| pairs \u3008q, c\u3009 of QCF(i \u2212 1) are iterated over and the corresponding pair \u3008q\u2032, c\u2032\u3009 is unique and can be retrieved in constant time (under the assumed data structure). There are n \u00b7 |\u03a3| such values, hence the entire m(\u00b7, \u00b7) matrix takes O(n \u00b7 |\u03a3| \u00b7 |Q|) time and \u0398(n \u00b7 |\u03a3|) space. Each test of a domain value takes constant time, hence \u0398(n+1) time in total for the n variables xi and the counter variable N . In total, such an implementation takes O(n \u00b7 |\u03a3| \u00b7 |Q|) time, and \u0398(n \u00b7 (|Q|+ |\u03a3|)) space."}, {"heading": "3.3 The Exact Regular Counting Constraint", "text": "Not surprisingly, decomposing cAutomaton(N,X,A) into the conjunction of cAutomatonAtMost(N,X,A) and cAutomatonAtLeast(N,X,A) does not yield domain consistency at the fixpoint of their propagators: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, x, 2],B), with N \u2208 {0, 1, 2} and x \u2208 {1, 2}, it misses the inference of N 6= 1. Worse, achieving domain consistency on exact regular counting is actually NP-hard:\nTheorem 3. The feasibility of cAutomaton constraints is NP-hard.\nProof. By reduction from Subset-Sum. Consider an instance \u3008{a1, . . . , ak}, s\u3009 of Subset-Sum, which holds if there is a subset A \u2286 {a1, . . . , ak} such that \u2211\nv\u2208A v = s. Construct a cDFAA with one state and alphabet\u03a3 = {a1, . . . , ak, 0}. A transition labelled by ai increases the counter by ai, and the transition labelled by 0 does not increase the counter. Build a sequence of variables X = \u3008x1, . . . , xk\u3009 such that dom(xi) = {0, ai} and a variable N such that dom(N) = {s}. Such a reduction can be done in polynomial time. Subset-Sum holds iff cAutomaton(N,X,A) holds.\nThe propagator for cAutomatonAtMost can be generalised into an incomplete propagator for cAutomaton. A value \u2113 is removed from the domain of variable xi if the following condition holds:\n\u2200\u3008q, c\u3009 \u2208 QCF(i\u2212 1) : \u2227\n\u3008q,c\u3009\u2208QCF(i\u22121) q\u2032=\u03b4Q(q,\u2113)\n\u3008q\u2032,c\u2032\u3009\u2208QCB(i+1) \u3008q\u2032,c\u2032\u3009\u2208QCB(i+1)\n[\nc+ \u03b4N(q, \u2113) + c \u2032, c+ \u03b4N(q, \u2113) + c\u2032\n]\n\u2229 dom(N) = \u2205\nThis propagator has the same space complexity as cAutomatonAtMost, but it may need more than one run to achieve idempotency. Indeed, it differs from the previous propagator in that lower and upper bounds have to be calculated for each state in QCF(i \u2212 1), and it is possible that some states will give different bounds. Hence the first run of the propagator might not reach idempotency. The propagator is strictly stronger than computing the fixpoint of cAutomatonAtMost and cAutomatonAtLeast, because the intersection test with respect to dom(N) is strictly stronger than the conjunction of the\ntwo comparisons on the atmost and atleast sides: for the cDFA in Figure 4 and the cAutomaton(1, [2, x, 1, y, z],B) constraint, with x, y, z \u2208 {1, 2}, the cAutomaton propagator infers z 6= 2, whereas the decomposition misses this inference. The cAutomaton propagator is also incomplete: the counter-example before Theorem 3 for the decomposition also applies to it."}, {"heading": "3.4 Evaluation", "text": "We implemented in SICStus Prolog version 4.2.1 [5] the described propagators for cAutomatonAtMost, cAutomatonAtLeast, and cAutomaton. As a sanity check, we tested them extensively as follows.\nWe generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.9.6) and doing a counter increment by 1 on each arc with a probability of 20%. For each random cDFA, we generated random instances, with random lengths (up to n = 10) of X = [x1, . . . , xn] and random initial domains of the counter variable N (one value, two values, and intervals of length 2 or 3) and the signature variables si (intervals of any length, and sets with holes).\nThe results, upon many millions of random instances, are that no counterexample to the domain consistency of cAutomatonAtMost has been generated (giving credence to Theorems 1 and 2), and that no pruning by the three propagators of actually supported values was observed. Also, our propagator for cAutomaton never propagates less but often more, to the point of detecting more failures, than the built-in Automaton [3] of SICStus Prolog, and that it is already often up to twice faster than the latter, even though it is currently na\u0308\u0131vely implemented in Prolog while the built-in works by decomposition into a conjunction of other global constraints, all of which are very carefully implemented in C.\nTable 1 gives the cumulative runtimes (under Mac OS X 10.7.5 on a 2.8 GHz Intel Core 2 Duo with a 4 GB RAM), the numbers of detected failures, and (when both propagators succeed) the numbers of pruned values for random instances of some constraints, the four-state cDFA for the NumberWord(N,X, \u201ctoto\u201d) constraint being unnecessary here.\nTo demonstrate the power of our propagators, we have also tested them on constraints whose counter-DFAs have binary signature constraints, so that our atleast and atmost regular counting propagators may not achieve domain consistency, because they were designed for unary signature constraints. For example, the Inflexion(N,X) constraint holds if there are N inflexions (local optima) in the integer sequence X ; a cDFA is given in [2], with signature constraints using the predicates xi {<,=, >} xi+1 on the sliding window [xi, xi+1] of size 2. Our exact regular counting propagator outperforms the built-in Automaton [3] of SICStus Prolog, as shown in the last line of Table 1. Further, our instance generator has not yet constructed any counter-example to domain consistency on atmost regular counting."}, {"heading": "4 Conclusion", "text": "This paper considers regular counting constraints over finite sequences of variables, which are ubiquitous and very diverse in sequencing and timetabling (e.g., restricting the number of monthly working weekends, or two-day-periods where a nurse works during a night followed by an afternoon). It studies a class of counter deterministic finite automata (cDFA) that provides much more concise models for regular counting constraints than representations using standard DFAs."}, {"heading": "4.1 Summary and Extensions", "text": "Our main contribution is to show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints, based on the frequent case of a counter-DFA with only accepting states and a single counter that can be incremented by transitions. We have also proved that determining the feasibility of exact regular counting constraints is NP-hard.\nIt is possible to lift our restriction to counter automata where all states are accepting, even though we are then technically outside the realm of regular counting. For instance, this would allow us to constrain the number N of occurrences of some pattern, recognised by cDFA A1, in a sequence X of variables, while X is not allowed to contain any occurrence of another pattern, recognised by cDFA A2. Rather than decomposing this constraint into the conjunction of cAutomaton(N,X,A1) and cAutomaton(0, X,A2), with poor propagation through the shared variables, we can design a cDFA A12 that counts the number of occurrences of the first pattern and fails at any occurrence of the second pattern (instead of counting them) and post the unique constraint cAutomaton(N,X,A12), after using the following recipe. Add an accepting state, say q, and an alphabet symbol, say $, whose meaning is end-ofstring. Add transitions on $ from all existing accepting states to q, with counter increase by zero. Add transitions on $ from all non-accepting states to q, with counter increase by a suitably large number, such as max(dom(N))+1. Make the non-accepting states accepting. Append the symbol $ to the sequence X when posting the constraint, so that the extended automaton never actually stops in\na state different from q, thereby making it irrelevant whether the original states are accepting or not."}, {"heading": "4.2 Related Work", "text": "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by \u03a3 and X , gives the costs of assigning each value of the alphabet \u03a3 of A to each variable of the sequence X . Indeed, both the abstractions and the underlying algorithms of regular counting constraints and CostRegular are closely related. However, we now argue that regular counting constraints sometimes provide both a more natural abstraction and some computational benefits, namely more propagation and asymptotically less space, within the same asymptotic time.\nAt the conceptual level, the regular counting and CostRegular constraints differ in how costs are expressed. In the CostRegular constraint the costs are associated with variable-value assignments, while in regular counting constraints the costs (seen as counter increments) are associated with the transitions of the counter automaton. This is an important conceptual distinction, as counter automata provide a more natural and compact abstraction for a variety of constraints, where the focus is on counting rather than costing. Footnote 1 of [6, page 318] points out that the cost matrix C can be made three-dimensional, indexed also by the states Q of A, but this is not discussed further in [6]. This allows the expression of costs on transitions, and it seems that this has no impact on the time complexity of their propagator. This generalisation is implemented in the Choco solver [8]. It is only with such a three-dimensional cost matrix that it is possible for the modeller to post a regular counting constraint by using the CostRegular constraint: first unroll the counter automaton for the length |X | into a directed acyclic weighted graph G (as described in [9], and the counter increments become the weights) and then post CostRegular(X,N,G); the Choco implementation [8, page 95] of CostRegular features this option. The alternative is to read the three-dimensional cost matrix C off A only (since X is not needed) and to post CostRegular(X,A\u2032, N, C), where DFA A\u2032 is counter-DFA A stripped of its counter increments. Either way, this encoding is not particularly convenient and it seems natural to adopt counter automata as an abstraction. Also note that the cost matrix C has to be computed for every different value of |X | that occurs in the problem model, while this is not the case with counter automata. Essentially, regular counting is a specialisation of the generalised CostRegular constraint (with a three-dimensional cost matrix), obtained by projecting the generalised cost matrix onto two different dimensions than in the original CostRegular constraint, namely Q and \u03a3, and using it to extend the transition function of the DFA to the signature Q \u00d7 \u03a3 \u2192 Q \u00d7 N and calling the extended DFA a counter-DFA.\nAt the efficiency level, regular counting constraints are propagated using dynamic programming, like CostRegular. This is not surprising. The time\ncomplexity is the same as for the encoding using CostRegular, namely O(n \u00b7 |\u03a3| \u00b7 |Q|), where n = |X |, as the unrolling of the cDFA takes the same time as the propagator itself. It is interesting however to note that the structure of regular counting constraints enables a better space complexity thanks to the compactness of a counter automaton as the input datastructure, as well as fundamentally different internal datastructures: we do not store the unrolled automaton. Indeed, we have shown that regular counting constraints have a space complexity of \u0398(n \u00b7 (|Q| + |\u03a3|)), while the encoding by CostRegular constraint takes \u0398(n \u00b7 |\u03a3| \u00b7 |Q|) space, to store either the three-dimensional cost matrix C or the unrolled graph G (Choco allows both ways of parametrising CostRegular). Note that adding a counter to a DFA bears no asymptotic space overhead on the representation of the DFA.\nAt the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N . As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N \u2208 {1, 3} and x, y \u2208 {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting. Our datastructures are more compact (see above), and yet enable more propagation on X for exact regular counting.\nTo summarise, although regular counting constraints and the CostRegular constraint are closely related, we believe that the results of this paper contribute both to our understanding of these constraints and to the practice in the field.\nThe SeqBin constraint [10,7] can be represented by a regular counting constraint, but it would require non-unary signature constraints."}, {"heading": "4.3 Future Work", "text": "There are many issues that remain open. They include the following questions. Can we implement our propagator to run in O(n\u00b7|\u03a3|) time? Which counter-DFAs admit a propagator achieving domain consistency for exact regular counting? Can we generalise our domain-consistency result to non-unary signature constraints? Can we generalise our results to non-deterministic counter automata (since all our notation depends on the transition function \u03b4 being total)?"}, {"heading": "Acknowledgements", "text": "The second and third authors are supported by grants 2011-6133 and 2012-4908 of the Swedish Research Council (VR). NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program. We wish to thank Mats Carlsson for help with\nSICStus Prolog, Joseph Scott for help with FAdo, and Arnaud Letord for help with performing the test with CostRegular in Choco."}, {"heading": "Appendix: SICStus Prolog Implementation", "text": ":\u2212 use module ( l i b r a r y ( l i s t s ) ) . :\u2212 use module ( l i b r a r y ( av l ) ) . :\u2212 use module ( l i b r a r y ( c l p f d ) ) .\ncautomatonAtmost(A, N, Vars ) :\u2212 dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomatonAtmost(A,N, Vars ) , atmost , [max(N) | Susp ] ) .\ncautomatonAtleast (A, N, Vars ) :\u2212 dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomatonAtleast (A,N, Vars ) , a t l e a s t , [ min (N) | Susp ] ) .\ncautomaton (A, N, Vars ) :\u2212 dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomaton (A,N, Vars ) , among , [ dom(N) | Susp ] ,\n[ idempotent ( f a l s e ) ] ) .\ndom suspensions (Vs , Ss ) :\u2212 ( f o r e ach (V, Vs) ,\nf o r e ach (dom(V) , Ss ) do true ) .\n:\u2212 mu l t i f i l e c l p f d : d i s p a t c h g l o b a l /4 . c l p f d : d i s p a t c h g l o b a l ( cautomatonAtmost(A,N, Vars ) , atmost , atmost ,\nActions ) :\u2212 A = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB, MinN, ) , fd max (N, MaxN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , prune vars (Vars , Doms , , QCF, RQCB, atmost , TransAVL , , MaxN, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nc l p f d : d i s p a t c h g l o b a l ( cautomatonAtleast (A,N, Vars ) , a t l e a s t , a t l e a s t , Actions ) :\u2212\nA = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB, , MaxN) , fd min (N, MinN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , prune vars (Vars , Doms , , QCF, RQCB, a t l e a s t , TransAVL , MinN,\n, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nc l p f d : d i s p a t c h g l o b a l ( cautomaton (A,N, Vars ) , among , among , Actions ) :\u2212 A = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB,\nMinN, MaxN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , convert dvars to doms ( [N] , [DomN] ) , prune vars (Vars , Doms , DomN, QCF, RQCB, among , TransAVL , MinN, MaxN, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nt r a n s a v l ( Trans i t ions , TransAVL) :\u2212 ( f o r e ach (Arc , Tran s i t i on s ) ,\nfromto (KL1 , [ key (Q,V, 0 )\u2212va lue (Q0, I ) , key (Q0,V, 1 )\u2212va lue (Q, I ) |KL2] ,KL2 , [ ] ) do ( Arc = arc (Q0,V,Q) \u2212> I = 0\n; Arc = arc (Q0,V,Q, [ +Inc ] ) \u2212> I = Inc )\n) , keysort (KL1, KL3) , keyclumped (KL3, KL4) , o r d l i s t t o a v l (KL4, TransAVL) .\np rune ac t i on s (ValuesToRemove , Actions ) :\u2212 ( f o r e ach (X\u2212Delete , ValuesToRemove ) ,\nf o r e ach (X i n s e t KeepSet , Actions ) do f d s e t (X, Set ) ,\nl i s t t o f d s e t ( Delete , DelSet ) , f d s e t s u b t r a c t ( Set , DelSet , KeepSet )\n) .\nprune vars (RV, RD, DomN, RF, RB, Flag , TransAVL , MinN, MaxN, Remove) :\u2212 ( f o r e ach (Var ,RV) ,\nf o r e ach (Dom,RD) , fromto (RF, [ QCF prev |RF1] ,RF1 , [ ] ) , f o r e ach (QCB next ,RB) , f o r e ach (Var\u2212ValuesToRemove , Remove) , param(DomN, Flag , TransAVL ,MinN,MaxN)\ndo prune var (Dom, DomN, Flag , TransAVL , QCF prev , QCB next , MinN, MaxN, ValuesToRemove )\n) .\nprune var (R, DomN, Flag , TransAVL , QCF prev , QCB next , MinN , MaxN, S0 ) :\u2212\n( f o r e ach (Val ,R) , fromto (S0 , S1 , S2 , [ ] ) , param(DomN, Flag , TransAVL , QCF prev , QCB next , MinN, MaxN)\ndo ( check va lue (QCF prev , Val , DomN, Flag , TransAVL , QCB next , MinN , MaxN)\n\u2212> S1 = [ Val | S2 ] ; S1 = S2 )\n) .\ncheck va lue (R, Val , DomN, Flag , TransAVL , QCB next , MinN, MaxN) :\u2212 ( f o r e ach ( t (Q,MinQ,MaxQ) ,R) ,\nparam(Val , DomN, Flag , TransAVL , QCB next , MinN , MaxN) do check va lue ( Flag , Q, MinQ, MaxQ, Val , DomN, TransAVL ,\nQCB next , MinN , MaxN) ) .\ncheck va lue ( atmost , Q, MinQ, , Val , , TransAVL , QCB next , , MaxN) :\u2212 ( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) ,\nmember( t (NextQ ,MinNextQ , ) , QCB next ) \u2212> MinQ + Inc + MinNextQ > MaxN ; true ) .\ncheck va lue ( a t l e a s t , Q, , MaxQ, Val , , TransAVL , QCB next , MinN, ) :\u2212 ( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) ,\nmember( t (NextQ , ,MaxNextQ) , QCB next ) \u2212> MaxQ + Inc + MaxNextQ < MinN ; true ) .\ncheck va lue (among , Q, MinQ, MaxQ, Val , DomN, TransAVL , QCB next , MinN , MaxN) :\u2212\n( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) , member( t (NextQ ,MinNextQ ,MaxNextQ) , QCB next )\n\u2212> In f i s min (MaxN+1, MinQ + Inc + MinNextQ) , Sup i s max(MinN\u22121, MaxQ + Inc + MaxNextQ)\n; In f = MaxN+1, Sup = MinN\u22121\n) , ( In f =< Sup \u2212> \\+i n t e r s e c t (DomN, In f , Sup ) ; true ) .\ncompute qcf qcb ( State s , TransAVL , N, Vars , Doms , [ F i r s t |RQCF] , QCB, MinN, MaxN) :\u2212\nconvert dvars to doms (Vars , Doms) , once (member( source ( I n i t i a l S t a t e ) , S ta t e s ) ) , F i r s t = [ t ( I n i t i a l S t a t e , 0 , 0 ) ] , comple te qc f qcb (Doms , 1 , TransAVL , Fi r st , RQCF) , l a s t ( [ F i r s t |RQCF] , LastState s ) , fd min (N, InitMinN ) , fd max (N, InitMaxN) , InitMin i s InitMaxN + 1 , InitMax i s InitMinN \u2212 1 , s e t c ou n t e r s t o z e r o ( LastState s , Last , InitMin , InitMax , MinN,\nMaxN) , r e v e r s e (Doms , RDoms) ,\ncomple te qc f qcb (RDoms, 0 , TransAVL , Last , RQCB) , r e v e r s e ( [ Last |RQCB] , QCB) .\ncomple te qc f qcb (R, Flag , TransAVL , States0 , S) :\u2212 ( f o r e ach (Dom,R) ,\nf o r e ach ( States2 , S) , fromto ( States0 , States1 , States2 , ) , param( Flag , TransAVL)\ndo compute nexts ( States1 , Flag , Dom, TransAVL , State s2 ) ) .\ncompute nexts ( PrevStates , Flag , Dom, TransAVL , NextStates ) :\u2212 compute next state s ( PrevStates , Flag , Dom, TransAVL , KL1, [ ] ) , keysort (KL1, KL2) , keyclumped (KL2, KL3) , ( f o r e ach (Tag\u2212Pairs ,KL3) ,\nf o r e ach ( t (Tag ,Min ,Max) , NextStates ) do transpose ( Pairs , [ MinOf ,MaxOf ] ) ,\nmin member(Min , MinOf) , max member(Max, MaxOf)\n) .\ncompute next state s (R, Flag , Dom, TransAVL) \u2212\u2212> ( f o r e ach ( t (Q,Min ,Max) ,R) ,\nparam( Flag , Dom, TransAVL) do ( f o r e ach (Val ,Dom) ,\nparam( Flag , TransAVL ,Q,Min ,Max) do ( { g e t n e x t p r ev s t a t e s ( Flag , Q, Val , TransAVL ,\nValues ) } , ( f o r e ach ( va lue (NextPrevQ , Inc ) , Values ) ,\nparam(Min ,Max) do {NextPrevMin i s Min + Inc } ,\n{NextPrevMax i s Max + Inc } , [ NextPrevQ\u2212[NextPrevMin , NextPrevMax ] ]\n) )\n) ) .\ng e t n ex t p r ev s t a t e ( Flag , Q0, Val , TransAVL , Q, Inc ) :\u2212 g e t n ex t p r e v s t a t e s ( Flag , Q0, Val , TransAVL , Values ) , member( va lue (Q, Inc ) , Values ) .\ng e t n e x t p r ev s t a t e s ( Flag , Q0, Val , TransAVL , Values ) :\u2212 a v l f e t c h ( key (Q0, Val , Flag ) , TransAVL , Values ) , ! . g e t n e x t p r ev s t a t e s ( , , , , [ ] ) .\ns e t c o un t e r s t o z e r o (R, S , Min0 , Max0 , Min , Max) :\u2212 ( f o r e ach ( t (Q,MinT,MaxT) ,R) ,\nf o r e ach ( t (Q, 0 , 0 ) ,S ) , fromto (Min0 ,Min1 ,Min2 ,Min) , fromto (Max0 ,Max1,Max2 ,Max)\ndo Min2 i s min(MinT, Min1) , Max2 i s max(MaxT, Max1) ) .\nconvert dvars to doms (R, S) :\u2212 ( f o r e ach (V,R) ,\nf o r e ach (D, S) do f d s e t (V, SV) , f d s e t t o l i s t (SV, D) ) .\ni n t e r s e c t ( [V | ] , In f , Sup ) :\u2212 In f =< V, V =< Sup , ! . i n t e r s e c t ( [ |R] , In f , Sup ) :\u2212 i n t e r s e c t (R, In f , Sup ) ."}], "references": [{"title": "Enumeration and generation with a string automata representation", "author": ["M. Almeida", "N. Moreira", "R. Reis"], "venue": "Theoretical Computer Science 387(2),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Global constraint catalogue: Past, present, and future", "author": ["N. Beldiceanu", "M. Carlsson", "S. Demassey", "T. Petit"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Deriving filtering algorithms from constraint checkers", "author": ["N. Beldiceanu", "M. Carlsson", "T. Petit"], "venue": "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 107\u2013122. Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2004}, {"title": "Introducing global constraints in CHIP", "author": ["N. Beldiceanu", "E. Contejean"], "venue": "Journal of Mathematical and Computer Modelling 20(12), 97\u2013123", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1994}, {"title": "An open-ended finite domain constraint solver", "author": ["M. Carlsson", "G. Ottosson", "B. Carlson"], "venue": "Glaser, H., Hartel, P., Kuchen, H. (eds.) PLILP 1997. LNCS, vol. 1292, pp. 191\u2013206. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1997}, {"title": "A Cost-Regular based hybrid column generation approach", "author": ["S. Demassey", "G. Pesant", "L.M. Rousseau"], "venue": "Constraints 11(4), 315\u2013333", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2006}, {"title": "The SEQBIN constraint revisited", "author": ["G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "Milano, M. (ed.) CP 2012. LNCS, vol. 7514, pp. 332\u2013347. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Choco solver: Documentation, version", "author": ["F. Laburthe", "N. Jussien"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "A regular language membership constraint for finite sequences of variables", "author": ["G. Pesant"], "venue": "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 482\u2013495. Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2004}], "referenceMentions": [{"referenceID": 2, "context": "We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3].", "startOffset": 236, "endOffset": 239}, {"referenceID": 2, "context": "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].", "startOffset": 169, "endOffset": 174}, {"referenceID": 8, "context": "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].", "startOffset": 169, "endOffset": 174}, {"referenceID": 2, "context": "This paper is concerned with the concept of counter-DFA (cDFA), an extension of DFAs proposed in [3], and uses it to model regular counting constraints, that is constraints on the number of regular-language patterns occurring in a sequence of variables.", "startOffset": 97, "endOffset": 100}, {"referenceID": 5, "context": "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .", "startOffset": 39, "endOffset": 42}, {"referenceID": 7, "context": "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "A constraint on a sequence X of variables can sometimes be modelled with the help of a DFA or cDFA that operates not on X , but on a sequence of signature variables that functionally depend via signature constraints on a sliding window of variables within X [3].", "startOffset": 258, "endOffset": 261}, {"referenceID": 3, "context": "For example, the Among(N,X,V) constraint [4] requires N to be the number of variables in the sequence X that are assigned a value from the given set V .", "startOffset": 41, "endOffset": 44}, {"referenceID": 2, "context": "Comparison between cAutomaton and Automaton [3] of SICStus Prolog", "startOffset": 44, "endOffset": 47}, {"referenceID": 4, "context": "1 [5] the described propagators for cAutomatonAtMost, cAutomatonAtLeast, and cAutomaton.", "startOffset": 2, "endOffset": 5}, {"referenceID": 1, "context": "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.", "startOffset": 117, "endOffset": 120}, {"referenceID": 0, "context": "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.", "startOffset": 178, "endOffset": 181}, {"referenceID": 2, "context": "Also, our propagator for cAutomaton never propagates less but often more, to the point of detecting more failures, than the built-in Automaton [3] of SICStus Prolog, and that it is already often up to twice faster than the latter, even though it is currently n\u00e4\u0131vely implemented in Prolog while the built-in works by decomposition into a conjunction of other global constraints, all of which are very carefully implemented in C.", "startOffset": 143, "endOffset": 146}, {"referenceID": 1, "context": "For example, the Inflexion(N,X) constraint holds if there are N inflexions (local optima) in the integer sequence X ; a cDFA is given in [2], with signature constraints using the predicates xi {<,=, >} xi+1 on the sliding window [xi, xi+1] of size 2.", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "Our exact regular counting propagator outperforms the built-in Automaton [3] of SICStus Prolog, as shown in the last line of Table 1.", "startOffset": 73, "endOffset": 76}, {"referenceID": 5, "context": "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by \u03a3 and X , gives the costs of assigning each value of the alphabet \u03a3 of A to each variable of the sequence X .", "startOffset": 86, "endOffset": 89}, {"referenceID": 8, "context": "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by \u03a3 and X , gives the costs of assigning each value of the alphabet \u03a3 of A to each variable of the sequence X .", "startOffset": 135, "endOffset": 138}, {"referenceID": 5, "context": "Footnote 1 of [6, page 318] points out that the cost matrix C can be made three-dimensional, indexed also by the states Q of A, but this is not discussed further in [6].", "startOffset": 165, "endOffset": 168}, {"referenceID": 7, "context": "This generalisation is implemented in the Choco solver [8].", "startOffset": 55, "endOffset": 58}, {"referenceID": 8, "context": "It is only with such a three-dimensional cost matrix that it is possible for the modeller to post a regular counting constraint by using the CostRegular constraint: first unroll the counter automaton for the length |X | into a directed acyclic weighted graph G (as described in [9], and the counter increments become the weights) and then post CostRegular(X,N,G); the Choco implementation [8, page 95] of CostRegular features this option.", "startOffset": 278, "endOffset": 281}, {"referenceID": 5, "context": "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .", "startOffset": 218, "endOffset": 223}, {"referenceID": 7, "context": "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .", "startOffset": 218, "endOffset": 223}, {"referenceID": 5, "context": "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N \u2208 {1, 3} and x, y \u2208 {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.", "startOffset": 26, "endOffset": 31}, {"referenceID": 7, "context": "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N \u2208 {1, 3} and x, y \u2208 {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.", "startOffset": 26, "endOffset": 31}, {"referenceID": 6, "context": "The SeqBin constraint [10,7] can be represented by a regular counting constraint, but it would require non-unary signature constraints.", "startOffset": 22, "endOffset": 28}], "year": 2013, "abstractText": "Constraints over finite sequences of variables are ubiquitous in sequencing and timetabling. Moreover, the wide variety of such constraints in practical applications led to general modelling techniques and generic propagation algorithms, often based on deterministic finite automata (DFA) and their extensions. We consider counter-DFAs (cDFA), which provide concise models for regular counting constraints, that is constraints over the number of times a regular-language pattern occurs in a sequence. We show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints based on the frequent case of a cDFA with only accepting states and a single counter that can be incremented by transitions. We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3]. Regular counting constraints are closely related to the CostRegular constraint but contribute both a natural abstraction and some computational advantages.", "creator": "LaTeX with hyperref package"}}}