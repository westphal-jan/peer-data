{"id": "1312.6149", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "On the Semantics of Gringo", "abstract": "Input languages both answer taken paradigms are new this well grammatically shape conceptual of own stable formula. But many easier constructs cover in although archaic, involved local polynomial, implied peptides, under aggregates, cannot it similarly explained and value of stable typically in after own both the original interpretation both mean emphasis and its hilarious vagueness. Manuals illustrated noted works include answer place solvers having answer examples constructs forms examples and informal note did neither to however user ' s intuition, without lyrics from none descriptions semantics. We reconsider to approach the problem of defining although semantics form raghead programs under translating them into the language significant kyudo propositional template. This mathematical allows us to knowledge above quantum of gringo guidelines certain natural rent in infinitary syllogistic theories.", "histories": [["v1", "Fri, 20 Dec 2013 21:33:55 GMT  (12kb,D)", "http://arxiv.org/abs/1312.6149v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["amelia harrison", "vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1312.6149"}, "pdf": {"name": "1312.6149.pdf", "metadata": {"source": "CRF", "title": "On the Semantics of Gringo", "authors": ["Amelia Harrison", "Vladimir Lifschitz", "Fangkai Yang"], "emails": ["fkyang}@cs.utexas.edu"], "sections": [{"heading": "1 Introduction", "text": "In this note, Gringo is the name of the input language of the grounder gringo,1 which is used as the front end in many answer set programming (ASP) systems. Several releases of gringo have been made public, and more may be coming in the future; accordingly, we can distinguish between several \u201cdialects\u201d of the language Gringo. We concentrate here on Version 4, released in March of 2013. (It differs from Version 3, described in the User\u2019s Guide dated October 4, 2010,2 in several ways, including the approach to aggregates\u2014it is modified as proposed by the ASP Standardization Working Group.3)\nThe basis of Gringo is the language of logic programs with negation as failure, with the syntax and semantics defined in [6]. Our goal here is to extend that semantics to a larger subset of Gringo. Specifically, we would like to cover arithmetical functions and comparisons, conditions, and aggregates.4\n1 http://potassco.sourceforge.net/. 2 The User\u2019s Guide can be downloaded from the Potassco website (Footnote 1).\nIt is posted also at http://www.cs.utexas.edu/users/vl/teaching/lbai/clingo guide.pdf.\n3 https://www.mat.unical.it/aspcomp2013/ASPStandardization. 4 The subset of Gringo discussed in this note includes also constraints, disjunctive\nrules, and choice rules, treated along the lines of [7] and [3]. The first of these papers introduces also \u201cclassical\u201d (or \u201cstrong\u201d) negation\u2014a useful feature that we do not include. (Extending our semantics of Gringo to programs with classical negation\nar X\niv :1\n31 2.\n61 49\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nOur proposal is based on the informal and sometimes incomplete description of the language in the User\u2019s Guide, on the discussion of ASP programming constructs in [4], on experiments with gringo, and on the clarifications provided in response to our questions by its designers.\nThe proposed semantics uses a translation from Gringo into the language of infinitary propositional formulas\u2014propositional formulas with infinitely long conjunctions and disjunctions. Including infinitary formulas is essential, as we will see, when conditions or aggregates use variables ranging over infinite sets (for instance, over integers).\nAlternatively, the semantics of Gringo can be approached using quantified equilibrium logic [12] or its syntactic counterpart defined in [2]. This method involves translating rules into the language of first-order logic. For instance, the rule\np(Y )\u2190 \u0131count{X,Y : q(X,Y )} \u2265 1 (1)\ncan be represented by the sentence\n\u2200y(\u2203xQ(x, y)\u2192 P (y)).\nHowever, this translation is not sufficiently general. For instance, it is not clear how to represent the rule\n\u0131total hours(N)\u2190 \u0131sum{H,C : \u0131enroll(C), hours(H,C)} = N (2)\nfrom Section 3.1.10 of the Gringo 3 User\u2019s Guide with a first-order formula. One reason is that the aggregate \u0131sum is used here instead of \u0131count. The second difficulty is that the variable N is used rather than a constant.\nGeneral aggregate expressions, as used in Gringo, can be represented by first-order formulas with generalized quantifiers.5 The advantage of infinitary propositional formulas as the target language is that properties of these formulas, and of their stable models, are better understood. We may be able to prove, for instance, that two Gringo programs have the same stable models by observing that the corresponding infinitary formulas are equivalent in one of the natural deduction systems discussed in [8]. We give here several examples of reasoning about Gringo programs based on this idea.\nThe process of converting Gringo programs into infinitary propositional formulas defined in this note uses substitutions to eliminate variables. This form of grounding is quite different, of course, from the process of intelligent instantiation implemented in gringo and other grounders. Mathematically, it is much simpler than intelligent instantiation; as a computational procedure, it is much less efficient, not to mention the fact that sometimes it produces infinite objects. Like grounding in the original definition of a stable model [6], it is modular, in the sense that it applies to the program rule by rule, and it is applicable even if\nis straightforward, using the process of eliminating classical negation in favor of additional atoms described in [7, Section 4].) 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].\nthe program is not safe. From this perspective, gringo\u2019s safety requirement is an implementation restriction.\nOur description of the syntax of Gringo disregards some of the features related to representing programs as strings of ASCII characters, such as using :- to separate the head from the body, using semicolons, rather than parentheses, to indicate the boundaries of a conditional literal, and representing falsity (which we denote here by \u22a5) as #false. Since the subset of Gringo discussed in this note does not include assignments, we can disregard also the requirement that equality be represented by two characters ==."}, {"heading": "2 Syntax", "text": "We begin with a signature \u03c3 in the sense of first-order logic that includes, among others,\n(i) numerals\u2014object constants representing all integers, (ii) arithmetical functions\u2014binary function constants +, \u2212, \u00d7, (iii) comparisons\u2014binary predicate constants <, >, \u2264, \u2265.\nWe will identify numerals with the corresponding elements of the set Z of integers. Object, function, and predicate symbols not listed under (i)\u2013(iii) will be called symbolic. A term over \u03c3 is arithmetical if it does not contain symbolic object or function constants. A ground term is precomputed if it does not contain arithmetical functions.\nWe assume that in addition to the signature, a set of symbols called aggregate names is specified, and that for each aggregate name \u03b1, the function denoted by \u03b1, \u03b1\u0302, maps every tuple of precomputed terms to an element of Z \u222a {\u221e,\u2212\u221e}.\nExamples. The functions denoted by the aggregate names \u0131count, \u0131max, and \u0131sum are defined as follows. For any set T of tuples of precomputed terms,\n\u2013 \u0131\u0302count(T ) is the cardinality of T if T is finite, and \u221e otherwise; \u2013 \u0131\u0302max(T ) is the least upper bound of the set of the integers t1 over all tuples\n(t1, . . . , tm) from T in which t1 is an integer; \u2013 \u0131\u0302sum(T ) is the sum of the integers t1 over all tuples (t1, . . . , tm) from T in\nwhich t1 is a positive integer; it is\u221e if there are infinitely many such tuples.6\nA literal is an expression of one of the forms\np(t1, . . . , tk), t1 = t2, \u0131not p(t1, . . . , tk), \u0131not (t1 = t2)\nwhere p is a symbolic predicate constant of arity k, and each ti is a term over \u03c3, or\nt1 \u227a t2, \u0131not (t1 \u227a t2) 6 To allow negative numbers in this example, we would have to define summation for a\nset that contains both infinitely many positive numbers and infinitely many negative numbers. It is unclear how to do this in a natural way.\nwhere \u227a is a comparison, and t1, t2 are arithmetical terms. A conditional literal is an expression of the form H : L, where H is a literal or the symbol \u22a5, and L is a list of literals, possibly empty. The members of L will be called conditions. If L is empty then we will drop the colon after H, so that every literal can be viewed as a conditional literal.\nExample. If \u0131available and \u0131person are unary predicate symbols then\n\u0131available(X) : \u0131person(X)\nand\n\u22a5 : (\u0131person(X), \u0131not \u0131available(X))\nare conditional literals.\nAn aggregate expression is an expression of the form\n\u03b1{t : L} \u227a s\nwhere \u03b1 is an aggregate name, t is a list of terms, L is a list of literals, \u227a is a comparison or the symbol =, and s is an arithmetical term.\nExample. If \u0131enroll is a unary predicate symbol and \u0131hours is a binary predicate symbol then\n\u0131sum{H,C : \u0131enroll(C), \u0131hours(H,C)} = N\nis an aggregate expression.\nA rule is an expression of the form\nH1 | \u00b7 \u00b7 \u00b7 |Hm \u2190 B1, . . . , Bn (3)\n(m,n \u2265 0), where each Hi is a conditional literal, and each Bi is a conditional literal or an aggregate expression. A program is a set of rules.\nIf p is a symbolic predicate constant of arity k, and t is a k-tuple of terms, then\n{p(t)} \u2190 B1, . . . , Bn\nis shorthand for\np(t) | \u0131not p(t)\u2190 B1, . . . , Bn.\nExample. For any positive integer n,\n{p(i)}\u2190 (i = 1, . . . , n), \u2190 p(X), p(Y ), p(X+Y ) (4)\nis a program."}, {"heading": "3 Semantics", "text": "We will define the semantics of Gringo using a syntactic transformation \u03c4 . It converts Gringo rules into infinitary propositional combinations of atoms of the form p(t), where p is a symbolic predicate constant, and t is a tuple of precomputed terms. Then the stable models of a program will be defined as stable models, in the sense of [13], of the set consisting of the translations of all rules of the program. Truszczynski\u2019s definition of stable models for infinitary propositional formulas is reviewed below.\nPrior to defining the translation \u03c4 for rules, we will define it for ground literals, conditional literals, and aggregate expressions."}, {"heading": "3.1 Review: Stable Models of Infinitary Formulas", "text": "Let \u03c3 be a propositional signature, that is, a set of propositional atoms. The sets F\u03c30 , F\u03c31 , . . . are defined as follows:\n\u2013 F\u03c30 = \u03c3 \u222a {\u22a5}, \u2013 F\u03c3i+1 is obtained from F\u03c3i by adding expressions H\u2227 and H\u2228 for all subsets H of F\u03c3i , and expressions F \u2192 G for all F,G \u2208 F\u03c3i .\nThe elements of \u22c3\u221e i=0 F\u03c3i are called (infinitary) formulas over \u03c3. Negation and equivalence are abbreviations. Subsets of a signature \u03c3 will be also called its interpretations. The satisfaction relation between an interpretation and a formula is defined in a natural way. The reduct F I of a formula F w.r.t. an interpretation I is defined as follows:\n\u2013 \u22a5I = \u22a5. \u2013 For p \u2208 \u03c3, pI = \u22a5 if I 6|= p; otherwise pI = p. \u2013 (H\u2227)I = {GI | G \u2208 H}\u2227. \u2013 (H\u2228)I = {GI | G \u2208 H}\u2228. \u2013 (G\u2192 H)I = \u22a5 if I 6|= G\u2192 H; otherwise (G\u2192 H)I = GI \u2192 HI .\nAn interpretation I is a stable model of a set H of formulas if it is minimal w.r.t. set inclusion among the interpretations satisfying the reducts of all formulas from H."}, {"heading": "3.2 Semantics of Well-Formed Ground Literals", "text": "A term t is well-formed if it contains neither symbolic object constants nor symbolic function constants in the scope of arithmetical functions. For instance, all arithmetical terms and all precomputed terms are well-formed; c+2 is not well-formed. The definition of \u201cwell-formed\u201d for literals, aggregate expressions, and so forth is the same.\nFor every well-formed ground term t, by [t] we denote the precomputed term obtained from t by evaluating all arithmetical functions, and similarly for tuples of terms. For instance, [f(2+2)] is f(4).\nThe translation \u03c4L of a well-formed ground literal L is defined as follows:\n\u2013 \u03c4(p(t)) is p([t]); \u2013 \u03c4(t1 \u227a t2), where \u227a is the symbol = or a comparison, is > if the relation \u227a\nholds between [t1] and [t2], and \u22a5 otherwise; \u2013 \u03c4(\u0131not A) is \u00ac\u03c4A.\nFor instance, \u03c4(\u0131not p(f(2+2))) is \u00acp(f(4)), and \u03c4(2+2= 4) is >. Furthermore, \u03c4\u22a5 stands for \u22a5, and, for any list L of ground literals, \u03c4L is the conjunction of the formulas \u03c4L for all members L of L."}, {"heading": "3.3 Global Variables", "text": "About a variable we say that it is global\n\u2013 in a conditional literal H : L, if it occurs in H but does not occur in L; \u2013 in an aggregate expression \u03b1{t : L} \u227a s, if it occurs in the term s; \u2013 in a rule (3), if it is global in at least one of the expressions Hi, Bi.\nFor instance, the head of the rule (2) is a literal with the global variable N , and its body is an aggregate expression with the global variable N . Consequently N is global in the rule as well.\nA conditional literal, an aggregate expression, or a rule is closed if it has no global variables. An instance of a rule R is any well-formed closed rule that can be obtained from R by substituting precomputed terms for global variables. For instance,\n\u0131total hours(6)\u2190 \u0131sum{H,C : \u0131enroll(C), hours(H,C)} = 6\nis an instance of rule (2). It is clear that if a rule is not well-formed then it has no instances."}, {"heading": "3.4 Semantics of Closed Conditional Literals", "text": "If t is a term, x is a tuple of distinct variables, and r is a tuple of terms of the same length as x, then the term obtained from t by substituting r for x will be denoted by txr . Similar notation will be used for the result of substituting r for x in expressions of other kinds, such as literals and lists of literals.\nThe result of applying \u03c4 to a closed conditional literalH : L is the conjunction of the formulas\n\u03c4(Lxr )\u2192 \u03c4(Hxr )\nwhere x is the list of variables occurring inH : L, over all tuples r of precomputed terms of the same length as x such that both Lxr and H x r are well-formed. For instance, \u03c4(\u0131available(X) : \u0131person(X))\nis the conjunction of the formulas \u0131person(r) \u2192 \u0131available(r) over all precomputed terms r;\n\u03c4(\u22a5 : p(2\u00d7X))\nis the conjunction of the formulas \u00acp(2\u00d7 i) over all numerals i. When a conditional literal occurs in the head of a rule, we will translate it in a different way. By \u03c4h(H : L) we denote the disjunction of the formulas\n\u03c4(Lxr ) \u2227 \u03c4(Hxr )\nwhere x and r are as above. For instance,\n\u03c4h(\u0131available(X) : \u0131person(X))\nis the disjunction of the formulas \u0131person(r)\u2227 \u0131available(r) over all precomputed terms r."}, {"heading": "3.5 Semantics of Closed Aggregate Expressions", "text": "In this section, the semantics of ground aggregates proposed in [1, Section 4.1] is adapted to closed aggregate expressions. Let E be a closed aggregate expression \u03b1{t : L} \u227a s, and let x be the list of variables occurring in E. A tuple r of precomputed terms of the same length as x is admissible (w.r.t. E) if both txr and L x r are well-formed. About a set \u2206 of admissible tuples we say that it justifies E if the relation \u227a holds between \u03b1\u0302({[txr ] : r \u2208 \u2206}) and [s]. For instance, consider the aggregate expression\n\u0131sum{H,C : \u0131enroll(C), hours(H,C)} = 6. (5)\nIn this case, admissible tuples are arbitrary pairs of precomputed terms. The set {(3, \u0131cs101), (3, \u0131cs102)} justifies (5), because\n\u0131\u0302sum({(H,C)H,C3,cs101 , (H,C) H,C 3,cs102}) = \u0131\u0302sum({(3, \u0131cs101), (3, \u0131cs102)}) = 3+3 = 6.\nMore generally, a set \u2206 of pairs of precomputed terms justifies (5) whenever \u2206 contains finitely many pairs (h, c) in which h is a positive integer, and the sum of the integers h over all these pairs is 6.\nWe define \u03c4E as the conjunction of the implications\u2227 r\u2208\u2206 \u03c4(Lxr )\u2192 \u2228 r\u2208A\\\u2206 \u03c4(Lxr ) (6)\nover all sets \u2206 of admissible tuples that do not justify E, where A is the set of all admissible tuples. For instance, if E is (5) then the conjunctive terms of \u03c4E are the formulas\u2227\n(h,c)\u2208\u2206\n(\u0131enroll(c) \u2227 \u0131hours(h, c))\u2192 \u2228\n(h,c)6\u2208\u2206\n(\u0131enroll(c) \u2227 \u0131hours(h, c)).\nThe conjunctive term corresponding to {(3, \u0131cs101)} as \u2206 says: if I am enrolled in CS101 for 3 hours then I am enrolled in at least one other course."}, {"heading": "3.6 Semantics of Rules and Programs", "text": "For any rule R, \u03c4R stands for the conjunction of the formulas\n\u03c4B1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c4Bn \u2192 \u03c4hH1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c4hHm\nfor all instances (3) of R. A stable model of a program \u03a0 is a stable model, in the sense of [13], of the set consisting of the formulas \u03c4R for all rules R of \u03a0.\nConsider, for instance, the rules of program (4). If R is the rule {p(i)} then \u03c4R is p(i) \u2228 \u00acp(i) (7) (i = 1, . . . , n). If R is the rule\n\u2190 p(X), p(Y ), p(X+Y )\nthen the instances of R are rules of the form\n\u2190 p(i), p(j), p(i+j)\nfor all numerals i, j. (Substituting precomputed ground terms other than numerals would produce a rule that is not well-formed.) Consequently \u03c4R is in this case the infinite conjunction\u2227\ni,j,k\u2208Z i+j=k\n\u00ac(p(i) \u2227 p(j) \u2227 p(k)). (8)\nThe stable models of program (4) are the stable models of formulas (7), (8), that is, sets of the form {p(i) : i \u2208 S} for all sum-free subsets S of {1, . . . , n}."}, {"heading": "4 Reasoning about Gringo Programs", "text": "In this section we give examples of reasoning about Gringo programs on the basis of the semantics defined above. These examples use the results of [8], and we assume here that the reader is familiar with that paper."}, {"heading": "4.1 Simplifying a Rule from Example 3.7 of User\u2019s Guide", "text": "Consider the rule7\n\u0131weekdays\u2190 \u0131day(X) : (\u0131day(X), \u0131not \u0131weekend(X)). (9)\nReplacing this rule with the fact \u0131weekdays within any program will not affect the set of stable models. Indeed, the result of applying translation \u03c4 to (9) is the formula \u2227\nr\n(\u0131day(r) \u2227 \u00ac\u0131weekend(r)\u2192 \u0131day(r)) \u2192 \u0131weekdays, (10)\n7 This rule is similar to a rule from Example 3.7 of the Gringo 3 User\u2019s Guide (see Footnote 2).\nwhere the conjunction extends over all precomputed terms r. The formula\n\u0131day(r) \u2227 \u00ac\u0131weekend(r)\u2192 \u0131day(r)\nis intuitionistically provable. By the replacement property of the basic system of natural deduction from [8], it follows that (10) is equivalent to \u0131weekdays in the basic system. By the main theorem of [8], it follows that replacing (10) with the atom \u0131weekdays within any set of formulas does not affect the set of stable models."}, {"heading": "4.2 Simplifying the Sorting Rule", "text": "The rule\n\u0131order(X,Y )\u2190 p(X), p(Y ), X < Y, \u0131not p(Z) : (p(Z), X < Z,Z < Y ) (11)\ncan be used for sorting.8 It can be replaced by either of the following two shorter rules within any program without changing that program\u2019s stable models.\n\u0131order(X,Y )\u2190 p(X), p(Y ), X < Y, \u22a5 : (p(Z), X < Z,Z < Y ) (12)\n\u0131order(X,Y )\u2190 p(X), p(Y ), X < Y, \u0131not p(Z) : (X < Z,Z < Y ) (13) Let\u2019s prove this claim for rule (12). By the main theorem of [8] it is sufficient to show that the result of applying \u03c4 to (11) is equivalent in the basic system to the result of applying \u03c4 to (12). The instances of (11) are the rules\n\u0131order(i, j)\u2190 p(i), p(j), i < j, \u0131not p(Z) : (p(Z), i < Z,Z < j),\nand the instances of (12) are the rules\n\u0131order(i, j)\u2190 p(i), p(j), i < j, \u22a5 : (p(Z), i < Z,Z < j)\nwhere i and j are arbitrary numerals. The result of applying \u03c4 to (11) is the conjunction of the formulas\np(i) \u2227 p(j) \u2227 i < j \u2227 \u2227 k (\u00acp(k) \u2227 i < k \u2227 k < j \u2192 p(k))\u2192 \u0131order(i, j) (14)\nfor all numerals i, j. The result of applying \u03c4 to (12) is the conjunction of the formulas\np(i) \u2227 p(j) \u2227 i < j \u2227 \u2227 k (\u00acp(k) \u2227 i < k \u2227 k < j \u2192 \u22a5)\u2192 \u0131order(i, j). (15)\nBy the replacement property of the basic system, it is sufficient to observe that\np(k) \u2227 i < k \u2227 k < j \u2192 \u00acp(k)\nis intuitionistically equivalent to\np(k) \u2227 i < k \u2227 k < j \u2192 \u22a5.\nThe proof for rule (13) is similar. Rule (12), like rule (11), is safe; rule (13) is not. 8 This rule was communicated to us by Roland Kaminski on October 21, 2012."}, {"heading": "4.3 Eliminating Choice in Favor of a Conditional Literal", "text": "Replacing the rule\n{p(X)} \u2190 q(X) (16)\nwith\np(X)\u2190 q(X),\u22a5 : \u0131not p(X) (17)\nwithin any program will not affect the set of stable models. Indeed, the result of applying translation \u03c4 to (16) is\u2227\nr\n(q(r)\u2192 p(r) \u2228 \u00acp(r)) (18)\nwhere the conjunction extends over all precomputed terms r, and the result of applying \u03c4 to (17) is \u2227\nr\n(q(r) \u2227 \u00ac\u00acp(r)\u2192 p(r)). (19)\nThe implication from (18) is equivalent to the implication from (19) in the extension of intuitionistic logic obtained by adding the axiom schema\n\u00acF \u2228 \u00ac\u00acF,\nand consequently in the extended system presented in [8, Section 7]. By the replacement property of the extended system, it follows that (18) is equivalent to (19) in the extended system as well."}, {"heading": "4.4 Eliminating a Trivial Aggregate Expression", "text": "The rule (1) says, informally speaking, that we can conclude p(Y ) once we established that there exists at least one X such that q(X,Y ). Replacing this rule with\np(Y )\u2190 q(X,Y ) (20)\nwithin any program will not affect the set of stable models. To prove this claim, we need to calculate the result of applying \u03c4 to rule (1). The instances of (1) are the rules\np(t)\u2190 \u0131count{X, t : q(X, t)} \u2265 1 (21)\nfor all precomputed terms t. Consider the aggregate expression E in the body of (21). Any precomputed term r is admissible w.r.t. E. A set \u2206 of precomputed terms justifies E if\n\u0131\u0302count({(r, t) : r \u2208 \u2206}) \u2265 1,\nthat is to say, if \u2206 is non-empty. Consequently \u03c4E consists of only one implication (6), with the empty \u2206. The antecedent of this implication is the empty\nconjunction >, and its consequent is the disjunction \u2228 u q(u, t) over all precomputed terms u. Then the result of applying \u03c4 to (1) is\n\u2227 t (\u2228 u q(u, t) \u2192 p(t) ) . (22)\nOn the other hand, the result of applying \u03c4 to (20) is\u2227 t,u (q(u, t)\u2192 p(t)).\nThis formula is equivalent to (22) in the basic system [8, Example 2]."}, {"heading": "4.5 Replacing an Aggregate Expression with a Conditional Literal", "text": "Informally speaking, the rule\nq \u2190 \u0131count{X : p(X)} = 0 (23)\nsays that we can conclude q once we have established that the cardinality of the set {X : p(X)} is 0; the rule q \u2190 \u22a5 : p(X) (24) says that we can conclude q once we have established that p(X) does not hold for any X. We\u2019ll prove that replacing (23) with (24) within any program will not affect the set of stable models. To this end, we\u2019ll show that the results of applying \u03c4 to (23) and (24) are equivalent to each other in the extended system from [8, Section 7].\nFirst, we\u2019ll need to calculate the result of applying \u03c4 to rule (23). Consider the aggregate expression E in the body of (23). Any precomputed term r is admissible w.r.t. E. A set \u2206 of precomputed terms justifies E if\n\u0131\u0302count({r : r \u2208 \u2206}) = 0,\nthat is to say, if \u2206 is empty. Consequently \u03c4E is the conjunction of the implications \u2227\nr\u2208\u2206 p(r)\u2192 \u2228 r\u2208A\\\u2206 p(r) (25)\nfor all non-empty subsets \u2206 of the set A of precomputed terms. The result of applying \u03c4 to (23) is \u2227\n\u2206\u2286A \u2206 6=\u2205\n\u2227 r\u2208\u2206 p(r)\u2192 \u2228 r\u2208A\\\u2206 p(r)  \u2192 q. (26)\nThe result of applying \u03c4 to (24), on the other hand, is(\u2227 r\u2208A \u00acp(r) ) \u2192 q. (27)\nThe fact that the antecedents of (26) and (27) are equivalent to each other in the extended system can be established by essentially the same argument as in [8, Example 7]. By the replacement property of the extended system, it follows that (26) is equivalent to (27) in the extended system as well."}, {"heading": "4.6 Eliminating Summation over the Empty Set", "text": "Informally speaking, the rule\nq \u2190 \u0131sum{X : p(X)} = 0 (28)\nsays that we can conclude q once we have established that the sum of the elements of the set {X : p(X)} is 0. In the presence of the constraint\n\u2190 p(X), (29)\nreplacing (28) with the fact q will not affect the stable models.\nTo see this, first we calculate the result of applying \u03c4 to rule (28). Consider the aggregate expression E in the body of (28). Any precomputed term r is admissible w.r.t. E. A set \u2206 of precomputed terms justifies E if\n\u0131\u0302sum({r : r \u2208 \u2206}) = 0,\nthat is to say, if \u2206 contains no positive integers. Consequently \u03c4E is the conjunction of the implications \u2227\nr\u2208\u2206 p(r)\u2192 \u2228 r\u2208A\\\u2206 p(r) (30)\nfor subsets \u2206 of the set A of precomputed terms that contain at least one positive integer. The result of applying \u03c4 to (28) is \u2227\n\u2206\u2286A \u2206\u2229Z 6=\u2205\n\u2227 r\u2208\u2206 p(r)\u2192 \u2228 r\u2208A\\\u2206 p(r)  \u2192 q. (31)\nThe result of applying \u03c4 to (29), on the other hand, is\u2227 r\u2208A \u00acp(r). (32)\nFor every nonempty \u2206, the antecedent of (30) contradicts (32). Consequently, the antecedent of (31) can be derived from (32) in the basic system. It follows that the equivalence between (31) and the atom q can be derived in the basic system under assumption (32)."}, {"heading": "5 Conclusion", "text": "In this note we approached the problem of defining the semantics of Gringo by reducing Gringo programs to infinitary propositional formulas. We argued that this approach to semantics may allow us to study equivalent transformations of programs using natural deduction in infinitary propositional logic.\nIn the absence of a precise semantics, it is impossible to put the study of some important issues on a firm foundation. This includes the correctness of ASP programs, grounders, solvers, and optimization methods, and also the relationship between input languages of different solvers (for instance, the equivalence of the semantics of aggregate expressions in Gringo to their semantics in the ASP Core language and in the language proposed in [5] under the assumption that aggregates are used nonrecursively). As future work, we are interested in addressing some of these tasks on the basis of the semantics proposed in this note. Proving the correctness of the intelligent instantiation algorithms implemented in gringo will provide justification for our informal claim that for a safe program, the semantics proposed here correctly describes the output produced by gringo."}, {"heading": "Acknowledgements", "text": "Many thanks to Roland Kaminski and Torsten Schaub for helping us understand the input language of gringo. Roland, Michael Gelfond, Yuliya Lierler, Joohyung Lee, and anonymous referees provided valuable comments on drafts of this note."}], "references": [{"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). pp. 119\u2013131", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175, 236\u2013263", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Weight constraints as nested expressions", "author": ["P. Ferraris", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2005}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan and Claypool Publishers", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Representing knowledge in A-Prolog", "author": ["M. Gelfond"], "venue": "Lecture Notes in Computer Science 2408, 413\u2013451", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Kowalski, R., Bowen, K. (eds.) Proceedings of International Logic Programming Conference and Symposium. pp. 1070\u20131080. MIT Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1991}, {"title": "On equivalent transformations of infinitary formulas under the stable model semantics (preliminary report)", "author": ["A. Harrison", "V. Lifschitz", "M. Truszczynski"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR)", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Stable models of formulas with generalized quantifiers", "author": ["J. Lee", "Y. Meng"], "venue": "Working Notes of the 14th International Workshop on Non-Monotonic Reasoning (NMR)", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Stable models of formulas with generalized quantifiers (preliminary report)", "author": ["J. Lee", "Y. Meng"], "venue": "Technical Communications of the 28th International Conference on Logic Programming (ICLP). pp. 61\u201371", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Two new definitions of stable models of logic programs with generalized quantifiers", "author": ["J. Lee", "Y. Meng"], "venue": "Working Notes of the 5th Workshop of Answer Set Programming and Other Computing Paradigms (ASPOCP)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Towards a first order equilibrium logic for nonmonotonic reasoning", "author": ["D. Pearce", "A. Valverde"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA). pp. 147\u2013160", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Connecting first-order ASP and the logic FO(ID) through reducts", "author": ["M. Truszczynski"], "venue": "Correct Reasoning: Essays on Logic-Based AI in Honor of Vladimir Lifschitz. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 5, "context": ") The basis of Gringo is the language of logic programs with negation as failure, with the syntax and semantics defined in [6].", "startOffset": 123, "endOffset": 126}, {"referenceID": 6, "context": "4 The subset of Gringo discussed in this note includes also constraints, disjunctive rules, and choice rules, treated along the lines of [7] and [3].", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "4 The subset of Gringo discussed in this note includes also constraints, disjunctive rules, and choice rules, treated along the lines of [7] and [3].", "startOffset": 145, "endOffset": 148}, {"referenceID": 3, "context": "Our proposal is based on the informal and sometimes incomplete description of the language in the User\u2019s Guide, on the discussion of ASP programming constructs in [4], on experiments with gringo, and on the clarifications provided in response to our questions by its designers.", "startOffset": 163, "endOffset": 166}, {"referenceID": 11, "context": "Alternatively, the semantics of Gringo can be approached using quantified equilibrium logic [12] or its syntactic counterpart defined in [2].", "startOffset": 92, "endOffset": 96}, {"referenceID": 1, "context": "Alternatively, the semantics of Gringo can be approached using quantified equilibrium logic [12] or its syntactic counterpart defined in [2].", "startOffset": 137, "endOffset": 140}, {"referenceID": 7, "context": "We may be able to prove, for instance, that two Gringo programs have the same stable models by observing that the corresponding infinitary formulas are equivalent in one of the natural deduction systems discussed in [8].", "startOffset": 216, "endOffset": 219}, {"referenceID": 5, "context": "Like grounding in the original definition of a stable model [6], it is modular, in the sense that it applies to the program rule by rule, and it is applicable even if", "startOffset": 60, "endOffset": 63}, {"referenceID": 8, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 87, "endOffset": 90}, {"referenceID": 9, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 90, "endOffset": 94}, {"referenceID": 10, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 94, "endOffset": 98}, {"referenceID": 12, "context": "Then the stable models of a program will be defined as stable models, in the sense of [13], of the set consisting of the translations of all rules of the program.", "startOffset": 86, "endOffset": 90}, {"referenceID": 12, "context": "A stable model of a program \u03a0 is a stable model, in the sense of [13], of the set consisting of the formulas \u03c4R for all rules R of \u03a0.", "startOffset": 65, "endOffset": 69}, {"referenceID": 7, "context": "These examples use the results of [8], and we assume here that the reader is familiar with that paper.", "startOffset": 34, "endOffset": 37}, {"referenceID": 7, "context": "By the replacement property of the basic system of natural deduction from [8], it follows that (10) is equivalent to \u0131weekdays in the basic system.", "startOffset": 74, "endOffset": 77}, {"referenceID": 7, "context": "By the main theorem of [8], it follows that replacing (10) with the atom \u0131weekdays within any set of formulas does not affect the set of stable models.", "startOffset": 23, "endOffset": 26}, {"referenceID": 7, "context": "By the main theorem of [8] it is sufficient to show that the result of applying \u03c4 to (11) is equivalent in the basic system to the result of applying \u03c4 to (12).", "startOffset": 23, "endOffset": 26}, {"referenceID": 4, "context": "This includes the correctness of ASP programs, grounders, solvers, and optimization methods, and also the relationship between input languages of different solvers (for instance, the equivalence of the semantics of aggregate expressions in Gringo to their semantics in the ASP Core language and in the language proposed in [5] under the assumption that aggregates are used nonrecursively).", "startOffset": 323, "endOffset": 326}], "year": 2013, "abstractText": "Input languages of answer set solvers are based on the mathematically simple concept of a stable model. But many useful constructs available in these languages, including local variables, conditional literals, and aggregates, cannot be easily explained in terms of stable models in the sense of the original definition of this concept and its straightforward generalizations. Manuals written by designers of answer set solvers usually explain such constructs using examples and informal comments that appeal to the user\u2019s intuition, without references to any precise semantics. We propose to approach the problem of defining the semantics of gringo programs by translating them into the language of infinitary propositional formulas. This semantics allows us to study equivalent transformations of gringo programs using natural deduction in infinitary propositional logic.", "creator": "LaTeX with hyperref package"}}}