{"id": "1402.0575", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Reasoning about Explanations for Negative Query Answers in DL-Lite", "abstract": "In order leave could end-user allows, largely logic - has third-party provide unclear facilities five reasoning working. This holds also for Description Logics, where studying with focused earlier rest suggest of both TBox understood and, fewer emerged, backend answering. Besides explaining brought presence far a enum today called sequential nothing, clear is important go unfortunately also why for given graph indeed missing. We messages the latter ways there many without pluralization retrieval answering to DL - Lite ontologies but proposals abductive reasoning; did this, we exactly the earliest both been ABox the force, given pronoun to also early seen result. As argument tasks should consider historical and recognizes it an explanation, often reflect and overriding its a means contradict over both arguments. We alter also computational complexity called themselves conflicts six unjust, subset minimal, and cardinality minimal anecdotal.", "histories": [["v1", "Tue, 4 Feb 2014 01:39:28 GMT  (437kb)", "http://arxiv.org/abs/1402.0575v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["diego calvanese", "magdalena ortiz", "mantas simkus", "giorgio stefanoni"], "accepted": false, "id": "1402.0575"}, "pdf": {"name": "1402.0575.pdf", "metadata": {"source": "CRF", "title": "Reasoning about Explanations for Negative Query Answers in DL-Lite", "authors": ["Diego Calvanese", "Magdalena Ortiz", "Giorgio Stefanoni"], "emails": ["calvanese@inf.unibz.it", "ortiz@kr.tuwien.ac.at", "simkus@dbai.tuwien.ac.at", "Giorgio.Stefanoni@cs.ox.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Ontology-based data access (OBDA) systems are a new form of information systems that use an ontology, a set of logical constraints, to mediate the access to data. The role of the ontology in an OBDA system is twofold. On the one hand, it is an intermediate layer between the domain user and the physical data providing a unified view of the information held in the various data sources. In many cases, the ontology extends the data vocabulary by introducing new intensional predicates that can be used to query information in a more succinct and declarative way. On the other hand, the ontology provides constraints, which are taken into account while answering queries and which may contribute to enrich the obtained answers. Hence, potentially relevant implicit knowledge that can be derived from the data, plus the ontology, can be made explicit by using specifically tailored reasoning algorithms. Most existing OBDA systems are based on the DL-Lite family of lightweight Description Logics (DLs), introduced by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2007), which is also the basis for the QL profile of the OWL 2 ontology language (Motik, Fokoue, Horrocks, Wu, Lutz, & Grau, 2009).\nAs argued by McGuinness and Patel-Schneider (1998), in order to meet usability requirements set by domain users, knowledge-based systems should be equipped with explanation algorithms for reasoning services. This holds also for Description Logics, where\nc\u00a92013 AI Access Foundation. All rights reserved.\nresearch has focused on the explanation of TBox reasoning (cf., McGuinness & Borgida, 1995; Borgida, Franconi, & Horrocks, 2000; Penaloza & Sertkaya, 2010; Horridge, Parsia, & Sattler, 2008). Additionally, Borgida, Calvanese, and Rodriguez-Muro (2008) studied the problem of explaining positive query answers to conjunctive queries over DL-Lite ontologies. In particular, they outlined a procedure for computing the reasons for a tuple to be in the answer to a query, and for minimizing the corresponding explanation shown to the user. In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there. As OBDA systems answer queries under ontological constraints, explaining negative query answers is not trivial: these constraints need to be taken into account to understand why a required tuple is missing from the answers. A procedure for explaining negative query answers would then improve the usability of OBDA systems.\nFor this reason, we formalize this explanation problem in the context of query answering over DL ontologies. Following Eiter and Gottlob (1995), we adopt abductive reasoning ; that is, explanations are set of facts that need to be asserted in the ABox to force the required tuple to be in the result. Such explanations help users in debugging a negative answer by giving an effective way of repairing the OBDA system in terms of updates to the data layer. Since ontologies can be used to enrich the data vocabulary, we consider also restrictions to the vocabulary over which the additional assertions can be constructed. More precisely, given a DL TBox T , an ABox A, a query q, and a set \u03a3 of predicates, an explanation for a given tuple ~c is a new ABox E , all whose predicates occur in \u03a3, such that the answer to q over the ontology \u3008T ,A \u222a E\u3009 contains ~c. According to the Occam\u2019s razor principle, an important aspect in explanations is to provide users with solutions that are simple to understand and free of redundancy, hence as small as possible. To address this requirement, we study various restrictions on explanations, in particular, we focus on subset minimal and cardinality minimal ones. We consider standard decision problems associated to logic-based abduction: (i) existence of an explanation, (ii) recognition of a given ABox as being an explanation, and (iii) relevance and (iv) necessity of an ABox assertion\u2014that is, whether it occurs in some or all explanations. At first, the latter two problems may appear rather artificial, however, they provide valuable information to the user when debugging negative answers. Relevance can be used to test whether an assertion the user deems related to the negative answer is indeed so; whereas, necessity can be used to test whether an assertion is intrinsically related to the negative answer.\nThe idea of restricting the vocabulary of explanations is an adaptation of a concept introduced by Baader, Bienvenu, Lutz, and Wolter (2010), who study among others the query emptiness problem. That is, given a query q over a TBox T decide whether for all ABoxes A over a given signature \u03a3, we have that evaluating q over \u3008T ,A\u3009 leads to an empty result. In Section 3, we shall see that in our framework deciding the existence of an explanation relates to the query non-emptiness problem. In fact, for many DLs, deciding whether a query is non-empty w.r.t. a TBox reduces to checking whether there exists an explanation for a missing answer.\nThe purpose of this paper is to shed light on the computational complexity of explaining missing answers to queries over ontologies formulated in DL-LiteA\u2014an expressive member of the DL-Lite family of DLs. To this end, we consider two important classes of queries\u2014\nthat is, instance queries and unions of conjunctive queries (UCQs)\u2014and we provide computational complexity results for the four decision problems defined above. Moreover, we perform our complexity analysis under two different explanation settings. We consider the case in which the explanation vocabulary is a strict subset of the vocabulary of the ontology and the data, as well as the case in which explanations can be constructed over arbitrary predicates. In Section 4, we show that when we consider instance queries as input, the relevant decision problems are NL-complete, irrespective of the chosen explanation setting and of the particular minimality criterion applied over explanations. In Section 5, we analyze the complexity of the problem when we admit UCQs as input, and we show that the complexity varies with respect to both the chosen explanation setting and the minimality criterion. Our complexity results for UCQs are summarized in Table 5.1."}, {"heading": "2. Preliminaries", "text": "In this section, we first introduce ontologies formulated in DLs, with a particular focus on the DL DL-LiteA. We then introduce the languages for querying ontologies that we consider, and we recall some important properties of DL-LiteA that will be used throughout the paper. Finally, we briefly present some of the less known complexity classes that will be mentioned later."}, {"heading": "2.1 Description Logic Ontologies", "text": "As usual in DLs, we consider countably infinite sets NC , NR, and NI of atomic concepts, atomic roles, and individuals, respectively. Whenever the distinction between atomic concepts and roles is immaterial, we call an element of NC \u222aNR a predicate.\nA DL TBox T is a finite set of axioms, whose form depends on the specific DL being considered; for DL-LiteA, the DL adopted in this paper, the definition is given below. A DL ABox A is a finite set of ABox assertions, which are expressions of the form A(c) or P (c, d), where A is an atomic concept, P is an atomic role, and c and d are individuals. A DL ontology is a pair O = \u3008T ,A\u3009, where T is a DL TBox and A is a DL ABox.\nThe semantics of DL ontologies is based on first-order interpretations I = \u3008\u2206I , \u00b7I\u3009, where \u2206I is a non-empty set called the domain and \u00b7I is the interpretation function mapping each individual c \u2208 NI to an object cI \u2208 \u2206I , each atomic concept A \u2208 NC to a set AI \u2286 \u2206I , and each atomic role P \u2208 NR to a binary relation P I \u2286 \u2206I \u00d7\u2206I .\nAn interpretation I satisfies an ABox assertion A(c) if cI \u2208 AI , and it satisfies an assertion P (c, d) if \u3008cI , dI\u3009 \u2208 P I . Satisfaction of TBox axioms is also defined according to their form in each specific DL; we define it below for DL-LiteA. An interpretation I is a model of \u3008T ,A\u3009, if it satisfies all the axioms in T and all the assertions in A. We call \u3008T ,A\u3009 consistent if it admits at least one model, and inconsistent otherwise. Also, an ABox A is consistent with a TBox T if the ontology \u3008T ,A\u3009 is consistent.\n2.1.1 DL-LiteA\nDL-LiteA is a member of the DL-Lite family of DLs (Calvanese et al., 2007; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, & Rosati, 2009), which has been designed for dealing efficiently with large amounts of extensional information. In DL-LiteA,\nconcept expressions (or, concepts) C, denoting sets of objects, and role expressions (or, roles) R, denoting binary relations between objects, are formed according to the following syntax, where A denotes an atomic concept and P an atomic role.1\nC \u2212\u2192 A | \u2203R R \u2212\u2192 P | P\u2212\nA DL-LiteA TBox consists of axioms of the following form.\nC1 v C2 R1 v R2\nC1 v \u00acC2 R1 v \u00acR2 (funct R)\nAxioms in the first column are called positive inclusions (among concepts and roles, respectively), those in the second column disjointness axioms, and those in the third column functionality assertions on roles. In order to retain tractability of reasoning, DL-LiteA TBoxes must satisfy the additional restriction that roles that are functional or inverse functional cannot be specialized. Formally, if a DL-LiteA TBox contains (funct P ) or (funct P\n\u2212), then for each role R it does not contain Rv P or Rv P\u2212 (Calvanese et al., 2007).\nThe semantics of concept expressions is specified as follows.\n(\u2203R)I = {o \u2208 \u2206I | \u2203o\u2032 \u2208 \u2206I : \u3008o, o\u2032\u3009 \u2208 RI}\n(P\u2212)I = {\u3008o, o\u2032\u3009 \u2208 \u2206I \u00d7\u2206I | \u3008o\u2032, o\u3009 \u2208 P I}\nAn interpretation I satisfies axiom \u03b11 v \u03b12 if \u03b1I1 \u2286 \u03b1I2 , it satisfies axiom \u03b11 v \u00ac\u03b12 if \u03b1I1 \u2229 \u03b1I2 = \u2205, and it satisfies axiom (funct R) if RI is a partial function\u2014that is, for each set of objects {o, o1, o2} \u2286 \u2206I , if \u3008o, o1\u3009 \u2208 RI and \u3008o, o2\u3009 \u2208 RI , then o1 = o2.\nFollowing the common practice for the DLs of the DL-Lite family (Calvanese et al., 2007), we usually adopt the unique name assumption (UNA)\u2014that is, for each interpretation I and individual pair c 6= d, we require that cI 6= dI . Whenever we drop this assumption, we will explicitly say so. Under the UNA, the problem of checking whether a DL-LiteA ontology is consistent is NL-complete, whereas without the UNA, the problem becomes PTime-complete (Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009)."}, {"heading": "2.2 Instance Queries and Conjunctive Queries", "text": "Let NV be a countably infinite set of variables. Together NI and NV form the set of terms. Expressions of the form A(t) or P (t, t\u2032), where A is an atomic concept, P is an atomic role, and t, t\u2032 are terms, are called atoms.\nA conjunctive query (CQ) q of arity n \u2265 0 is an expression q(x1, . . . , xn)\u2190 a1, . . . , am, where, for each i \u2208 {1, . . . ,m}, we have that ai is an atom. The tuple \u3008x1, . . . , xn\u3009 is the tuple of answer variables of q. Let NV (q) be the set of variables occurring in q, let NI(q) be the set of individuals in q, let at(q) = {a1, . . . , am}, and let |q| be the number of terms occurring in q. We consider safe CQs\u2014that is, each answer variable xi of q occurs in at least one of the atoms of q. A Boolean conjunctive query is a CQ with arity 0, and we shall write it simply as a set of atoms. An instance query q(x) is a conjunctive query whose body consists of a single unary atom A(x). A union of conjunctive queries (UCQ) is a set of CQs\n1. We ignore here the distinction between data values and objects present in DL-LiteA and OWL 2 QL, since it is immaterial for our results. That is, we do not consider value domains and attributes.\nof the same arity, and we assume w.l.o.g. that all CQs in a UCQ have the same tuple of answer variables. In the following, we denote with IQ the set of all instance queries and with CQ the set of all UCQs.\nA match for an n-ary CQ q in an interpretation I is a mapping \u03c0 : NV (q)\u222aNI(q)\u2192 \u2206I such that\n(i) \u03c0(c) = cI , for each c \u2208 NI(q),\n(ii) \u03c0(t) \u2208 AI , for each A(t) \u2208 at(q), and\n(iii) \u3008\u03c0(t), \u03c0(t\u2032)\u3009 \u2208 P I , for each P (t, t\u2032) \u2208 at(q).\nAn n-tuple of individuals \u3008c1, . . . , cn\u3009 is an answer to q in I, if there exists a match \u03c0 for q in I such that \u3008cI1 , . . . , cIn\u3009 = \u3008\u03c0(x1), . . . , \u03c0(xn)\u3009. We let ans(q, I) denote the set of all answers to q in I. A Boolean CQ returns as answer either \u2205, representing the value \u2018false\u2019, or the empty tuple \u3008\u3009, representing the value \u2018true\u2019. For a UCQ q, we let ans(q, I) = \u22c3 q\u2032\u2208q ans(q\n\u2032, I). The certain answer to a UCQ q of arity n over ontology \u3008T ,A\u3009 is defined as\ncert(q, T ,A) = {~c \u2208 (NI)n | ~c \u2208 ans(q, I), for each model I of \u3008T ,A\u3009}.\n2.3 Query Answering in DL-LiteA\nThe problem of query answering in DLs is the problem of computing the certain answer to a given query over a given DL ontology. Formulated in this way, query answering is a computation problem and not a decision problem. Since in this paper we are interested in establishing computational complexity results, we identify query answering with its decision problem, sometimes called the recognition problem, in which the input is constituted by a DL ontology \u3008T ,A\u3009, a query q(~x), and a tuple ~c of arity |~x|, and the task is to determine whether ~c \u2208 cert(q, T ,A). In the special case of instance queries, this problem is also known as instance checking. Notice that, since we consider both the ontology and the query as part of the input, we are considering so-called combined complexity (Vardi, 1982).\nIn many DLs, instance checking can be reduced to the problem of deciding ontology consistency. This holds also for DL-LiteA and, thus, answering an instance query can be done in nondeterministic logarithmic space. In contrast, the problem of answering a UCQ (and hence a CQ) q over a DL-LiteA ontology \u3008T ,A\u3009 can be solved in nondeterministic polynomial time by adopting a pure query rewriting approach (Calvanese et al., 2007, 2009). This technique works in two steps. In the first step, we compute the perfect reformulation Rq,T of q w.r.t. T\u2014that is, we rewrite the input query q with respect to the TBox T into a UCQ Rq,T . In this rewriting step, the portion of the TBox relevant for answering q is compiled into Rq,T . In the second step, we simply evaluate the computed rewriting Rq,T over the ABox A\u2014seen as a first order interpretation. This is captured by the proposition below, which makes use of the notion of interpretation associated to an ABox, formalized in the following definition.\nDefinition 2.1. Given an ABox A, let DBA be the interpretation whose domain \u2206DBA is the set of individuals occurring in A, and\n(i) cDBA = c, for all individuals c occurring in A;\n(ii) ADBA = {c | A(c) \u2208 A}, for all A \u2208 NC ; (iii) PDBA = {\u3008c, d\u3009 | P (c, d) \u2208 A}, for all P \u2208 NR.\nThe following proposition summarizes the results about query answering based on rewriting that have been shown for the logics of the DL-Lite family (and for DL-LiteA in particular) and that we will exploit in the following.\nProposition 2.1. (Calvanese et al., 2007, 2009) Let \u3008T ,A\u3009 be a DL-LiteA ontology, let q be a UCQ, and let max(q) = maxqi\u2208q |at(qi)|. It is possible to construct a UCQ Rq,T , called the perfect reformulation of q w.r.t. T , such that\ncert(q, T ,A) = ans(Rq,T ,DBA).\nMoreover, Rq,T satisfies the following properties.\n\u2022 All predicates occurring in Rq,T occur in T or in q. \u2022 Each qr \u2208 Rq,T has at most max(q) atoms and at most 2 \u00b7max(q) terms. \u2022 If q consists of a single instance query, then each qr \u2208 Rq,T has only one atom. \u2022 Each qr \u2208 Rq,T can be obtained in nondeterministic polynomial time in the combined\nsize of T and q. \u2022 Deciding whether a given tuple of individuals is in ans(Rq,T ,DBA) can also be achieved\nin nondeterministic polynomial time in the combined size of T and q."}, {"heading": "2.4 Complexity Theory", "text": "We briefly outline the definition of some non-canonical complexity classes used in the paper; for more details, we refer the reader to standard textbooks on computational complexity (e.g., Papadimitriou, 1994). The class \u03a3P2 is a member of the Polynomial Hierarchy: it is the class of all decision problems solvable in nondeterministic polynomial time using an NP oracle. The class PNP\u2016 contains all decision problems that can be solved in polynomial time with an NP oracle, where all oracle calls must be first prepared and then issued in parallel. The class DP contains all problems that, considered as languages, can be characterized as the intersection of a language in NP and a language in coNP. Additionally, the class NL contains all decision problems that can be solved by a nondeterministic Turing machine using a logarithmic amount of space. It is believed that NL \u2286 PTime \u2286 NP \u2286 DP \u2286 PNP\u2016 \u2286 \u03a3P2 is a strict hierarchy of inclusions. Here we make such an assumption.\nAs usual, we use reductions between problems to infer complexity bounds throughout the paper. Unless stated otherwise, these are all many-one logarithmic space reductions."}, {"heading": "3. Explaining Negative Query Answers", "text": "In this section, we formalize as an abductive task the problem of finding explanations for negative answers to queries over DL ontologies.\nFor a DL TBox T , a DL ABox A, and a query q from IQ\u222aCQ, we let \u03a3(T ,A, q) denote the set of all those predicates that occur in T , A, or q. A signature \u03a3 is a non-empty finite subset of NC \u222a NR. Furthermore, an ABox A is a \u03a3-ABox if all the assertions in A use only predicates from \u03a3; that is, if \u03a3(\u2205,A, \u2205) \u2286 \u03a3.\nDefinition 3.1. Let \u3008T ,A\u3009 be a DL ontology, q(~x) a query from IQ \u222a CQ, ~c a tuple of individuals of arity |~x|, and \u03a3 a signature. We call P = \u3008T ,A, q,~c,\u03a3\u3009 a Query Abduction Problem (QAP). An explanation for (or, a solution to) P is a \u03a3-ABox E such that\n(i) the ontology \u3008T ,A \u222a E\u3009 is consistent, and\n(ii) ~c \u2208 cert(q, T ,A \u222a E).\nThe set of all explanations for P is denoted by expl(P). The predicates in \u03a3 are the ones allowed in explanations, hence we call them abducible predicates. If \u03a3(T ,A, q) \u2286 \u03a3, we say that P has unrestricted explanation signature; otherwise, if \u03a3 does not contain all symbols in \u03a3(T ,A, q), we say that P has restricted explanation signature.\nFor such a QAP, we call tuple ~c a negative answer to q over \u3008T ,A\u3009, if ~c /\u2208 cert(q, T ,A). Clearly, query q over ontology \u3008T ,A\u3009 admits a negative answer only if \u3008T ,A\u3009 is consistent. Also, by condition (i), if the ontology is inconsistent, then P does not admit explanations.\nOntology languages, such as DL-LiteA, which allow for the specification of existential restrictions and negative constraints (e.g., disjointness axioms), sometimes require explanations to introduce fresh individuals that do not occur within the QAP. We next precisely characterize these individuals.\nDefinition 3.2. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP and let E be a solution to P. An arbitrary individual u occurring in E is anonymous if it does not occur in T , A, q, and in ~c.\nNow, we use an example to highlight how query abduction problems can be useful in debugging negative query answers.\nExample 3.1. Let Au be the following set of assertions about a particular university.\nDPhil(Anna) DPhil(Beppe) enroll(Anna,KR) teach(Marco,KR) enroll(Luca, IDB) teach(Carlo, IDB)\nThat is, Anna and Beppe are doctoral students, Anna is enrolled in the KR course, which is taught by Marco, and Luca is enrolled in the introductory DB course (IDB), which is taught by Carlo. Now, consider the following DL-LiteA TBox Tu formalizing the university domain, of which Au is a (partial) instance.\n\u2203enroll v Student \u2203enroll\u2212 v Course\nDPhil v Student\n\u2203teach v Lecturer \u2203teach\u2212 v Course Course v \u2203teach\u2212\nTu models that objects in the domain of enroll are Students, and objects in the domain of teach are Lecturers, whereas objects in the range of enroll or of teach are Courses. Among the students we have DPhil students. Finally, every Course must be taught by someone.\nNow, assume that the university administration is interested in finding all those who are teaching a course in which at least one of the enrolled students is a doctoral student, which is captured by the following query.\nqu(x)\u2190 teach(x, y), enroll(z, y),DPhil(z)\nAssume that Carlo is expected to be part of the result. This is not the case, as Luca is the only student of Carlo and he is not known to be a DPhil student. Hence Carlo /\u2208 cert(q, T ,A) and Carlo is a negative answer. Suppose that we have complete information on all the predicates but enroll and teach\u2014that is, only the latter predicates are abducible. It is easy to see that\nEu = {teach(Carlo, c), enroll(Beppe, c), enroll(Luca, c)}\nis an explanation for the QAP Pu = \u3008Tu,Au, qu,Carlo, {enroll, teach}\u3009, which suggests the existence of a course, represented by the anonymous individual c, that does not occur in the ABox Au.\nThe above example shows that certain explanations may be too assumptive in that they include assertions that are not required to solve the problem. Indeed, in the example\u2019s explanation there is no reason to assume that Luca is enrolled in the anonymous course c. In the following, we will examine various restrictions to expl(P) to reduce redundancy in explanations, achieved by introducing a preference relation among explanations. This relation is reflexive and transitive\u2014that is, we have a pre-order among explanations. For such a pre-order on expl(P), we write E \u227a E \u2032 if E E \u2032 and E \u2032 E .\nDefinition 3.3. The preferred explanations expl (P) of a QAP P under the pre-order , called -explanations or ( -solutions), are defined as follows.\nexpl (P) = { E \u2208 expl(P) | there is no E \u2032 \u2208 expl(P) such that E \u2032 \u227a E }\nWe consider two preference orders that are commonly adopted when comparing abductive solutions: the subset-minimality order, denoted by \u2286, and the minimum explanation size order, denoted by \u2264. The latter order is defined by E \u2264 E \u2032 iff |E| \u2264 |E \u2032|. Considering that, by the definition, explanations are finite, for an arbitrary QAP P, we have that each \u2264-solution to P is also a \u2286-solution to P; that is, expl\u2264(P) \u2286 expl\u2286(P).\nExample 3.2. As we already argued, the ABox Eu is a redundant solution to the QAP Pu introduced in Example 3.1. Next, we introduce two minimal solutions. First, we consider the solution asserting Carlo to teach an anonymous course c and Beppe to be enrolled in that course. This ABox E \u2032u = {teach(Carlo, c), enroll(Beppe, c)} is a \u2286-explanation. Second, we consider the solution asserting Beppe to be enrolled in the IDB course. This ABox E \u2032\u2032u = {enroll(Beppe, IDB)} is a \u2264-explanation (and hence also a \u2286-explanation).\nIn the context of logic-based abduction, four main decision problems have been considered of interest (Eiter & Gottlob, 1995), and they are parametrized according to the chosen preference order .\nDefinition 3.4. Given a QAP P, an ABox assertion \u03d5(~d) over abducible predicate \u03d5, and an ABox E, we define the following decision problems.\n\u2022 -exist(ence): Does there exist a -explanation for P?\n\u2022 -nec(essity): Does assertion \u03d5(~d) occur in all -explanations for P?\n\u2022 -rel(evance): Does assertion \u03d5(~d) occur in some -explanation for P?\n\u2022 -rec(ognition): Is ABox E a -explanation for P?\nWhenever no preference is applied (i.e., when is the identity), we omit to write in front of the problems\u2019 names.\nIn this paper, we study the complexity of the above reasoning problems for query abduction. We start by highlighting, in the remaining part of this section, interesting properties of query abduction problems and important connections between reasoning tasks."}, {"heading": "3.1 Reductions between Reasoning Problems", "text": "We now show that some of the introduced problems can be reduced to each other. Unless otherwise stated, the reductions we present work for all DLs, for both instance queries and UCQs, and for both restricted and unrestricted explanation signatures.\nWe start by showing that nec is at least as hard as non-exist (i.e., the complement of the exist problem).\nProposition 3.1. For every DL, non-exist is reducible to nec.\nProof. Assume a QAP P = \u3008T ,A, q,~c,\u03a3\u3009 and let \u03d5(~d) be an arbitrary ABox assertion, such that \u03d5 and ~d do not occur in P. The following holds: P has no explanation iff \u03d5(~d) is necessary for P \u2032 = \u3008T ,A, q,~c,\u03a3 \u222a {\u03d5}\u3009. By the construction, it follows that each solution to P is also a solution to P \u2032; furthermore, for each solution E \u2032 to P \u2032, \u03d5 6\u2208 \u03a3(\u2205, E \u2032, \u2205) implies that E \u2032 is a solution to P. By the definition of P \u2032 and since \u03d5 and ~d are globally fresh, for each ABox E , we have that E is an explanation for P \u2032 if and only if E \\ {\u03d5(~d)} is an explanation for P \u2032. The correctness of the reduction immediately follows.\nFor QAPs with restricted explanation signatures, we next show that nec reduces to non-exist. The reduction works for every DL that allows for disjointness axioms.\nProposition 3.2. For every DL that allows for concept and role disjointness axioms, and under restricted explanation signatures, nec is reducible to non-exist.\nProof. Consider an instance of nec given by a QAP P = \u3008T ,A, q,~c,\u03a3\u3009 where \u03a3 might be restricted, and by an ABox assertion \u03d5(~d). Next, we show how to construct a QAP P \u2032 such that \u03d5(~d) is necessary for P iff P \u2032 does not admit solutions. To this end, let \u03d5\u2032 and \u03d5\u0304 be two globally fresh predicates of the same arity as \u03d5; furthermore, let TBox T \u2032, ABox A\u2032, and signature \u03a3\u2032 be as follows.\nT \u2032 := T \u222a {\u03d5\u2032 v \u03d5} \u222a {\u03d5\u0304v \u00ac\u03d5\u2032} A\u2032 := A \u222a {\u03d5\u0304(~d)} \u03a3\u2032 := {\u03c8 \u2208 \u03a3 | \u03c8 6= \u03d5} \u222a {\u03d5\u2032}\nFinally, let P \u2032 := \u3008T \u2032,A\u2032, q,~c,\u03a3\u2032\u3009. Now, we show the correctness of the reduction; that is, \u03d5(~d) is necessary for P iff P \u2032 does not admit solutions.\n(\u21d2) We prove the contrapositive. Suppose that P \u2032 has a solution E \u2032. By the definition of \u3008T \u2032,A\u2032\u3009 and of \u03a3\u2032, we have that \u03d5\u2032(~d) 6\u2208 E \u2032 and that predicate \u03d5 does not occur in E \u2032. Let ABox E be defined as follows.\nE := {\u03c8(~t) \u2208 E \u2032 | \u03c8 6= \u03d5\u2032} \u222a {\u03d5(~t) | \u03d5\u2032(~t) \u2208 E \u2032}\nBy the construction, E is a \u03a3-ABox that does not contain \u03d5(~d). It remains to show that E is a solution to P. To this end, please observe that each model J of \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 is a model of \u3008T ,A \u222a E\u3009, since \u03d5\u2032 v \u03d5 \u2208 T \u2032. In addition, each model I of \u3008T ,A \u222a E\u3009 can be extended to a model J of \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 by setting \u03d5\u2032J := {(~t)J | \u03d5\u2032(~t) \u2208 E \u2032} and \u03d5\u0304J := {(~d)J }. It follows that \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 is a conservative extension of \u3008T ,A \u222a E\u3009. Given that ~c \u2208 cert(q, T \u2032,A\u2032 \u222a E \u2032) and that q is over \u3008T ,A\u3009, we obtain that ~c \u2208 cert(q, T ,A \u222a E). Furthermore, since \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 is consistent, we also have that \u3008T ,A \u222a E\u3009 is consistent; so E is a solution to P that does not contain assertion \u03d5(~d), as required.\n(\u21d0) We prove the contrapositive. Suppose that a solution E to P exists such that \u03d5(~d) 6\u2208 E . Let ABox E \u2032 be defined as follows.\nE \u2032 := {\u03c8(~t) \u2208 E | \u03c8 6= \u03d5} \u222a {\u03d5\u2032(~t) | \u03d5(~t) \u2208 E}\nBy the construction, E \u2032 is a \u03a3\u2032-ABox which does not contain \u03d5\u2032(~d). It remains to show that E \u2032 is a solution to P \u2032. As we have seen before, \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 is a conservative extension of \u3008T ,A \u222a E\u3009. Given that ~c \u2208 cert(q, T ,A \u222a E), we obtain that ~c \u2208 cert(q, T \u2032,A\u2032 \u222a E \u2032). Furthermore, since \u3008T ,A \u222a E\u3009 is consistent and \u03d5\u2032(~d) 6\u2208 E \u2032, we also have that \u3008T \u2032,A\u2032 \u222a E \u2032\u3009 is consistent; so E \u2032 is a solution to P \u2032, as required.\nA simple modification of Proposition 3.2 shows that this result applies also to DLs that allow for negative ABox assertions of the form \u00acA(c) and \u00acP (c, c\u2032) instead of disjointness axioms. We next show that rel and exist are mutually reducible.\nProposition 3.3. For every DL, rel and exist are mutually reducible.\nProof. First, we show that we can reduce rel to exist. Let P be an arbitrary QAP of the form \u3008T ,A, q,~c,\u03a3\u3009 and let \u03d5(~d) be an arbitrary ABox assertion such that \u03d5 \u2208 \u03a3. We construct a QAP P \u2032 such that \u03d5(~d) is relevant to P if and only if P \u2032 admits a solution. To this end, let A\u2032 be the ABox defined as A\u2032 = A \u222a {\u03d5(~d)}. Then, we define QAP P \u2032 as P \u2032 = \u3008T ,A\u2032, q,~c,\u03a3\u3009. Next, we prove the correctness of the reduction. The only-if direction is immediate. For the if direction, suppose that P \u2032 admits a solution E \u2032. It follows, by the definition of P \u2032, that \u03a3-ABox E \u2032 \u222a {\u03d5(~d)} is consistent with TBox T . Moreover, this latter ABox is also a solution to P and, therefore, the given assertion is relevant.\nSecond, we prove that exist is reducible to rel. Let P be an arbitrary QAP of the form \u3008T ,A, q,~c,\u03a3\u3009, let \u03d5 be an arbitrary predicate from \u03a3, and let ~d be an arbitrary tuple of individuals not occurring in P such that ~d is of the same arity as predicate \u03d5. We prove that P admits a solution iff \u03d5(~d) is relevant for P. The if direction follows by the definition of relevance. To show the only-if direction, suppose that P admits a solution E . If \u03d5(~d) occurs in E , it is relevant for P. Otherwise, since individuals ~d do not occur in P and \u03d5 \u2208 \u03a3, ABox E \u222a {\u03d5(~d)} is also a solution to P, and hence \u03d5(~d) is relevant for P.\nMoreover, \u2286-nec and nec are also mutually reducible.\nProposition 3.4. For every DL, \u2286-nec and nec are mutually reducible.\nProof. For an arbitrary QAP P and an arbitrary ABox assertion \u03d5(~d), we have that \u03d5(~d) occurs in all \u2286-minimal explanations for P iff \u03d5(~d) occurs in all explanations for P. Thus, nec and \u2286-nec are equivalent problems.\nFinally, since our preference orders prefer \u2018smaller\u2019 explanations and, by the definition, explanations are finite, our orders are well-founded. It immediately follows that there exists an explanation for an arbitrary QAP P if and only if P admits a minimal explanation under both our preference orders.\nProposition 3.5. For every DL, \u2286-exist, \u2264-exist, and exist are mutually reducible."}, {"heading": "3.2 QAPs and the Query Emptiness Problem", "text": "As mentioned in the introduction, deciding the existence of an explanation is related to the query emptiness problem studied by Baader et al. (2010). Since we will rely on that problem to infer some complexity bounds throughout the paper, we briefly introduce it here.\nDefinition 3.5. Let T be a DL TBox, Q \u2208 {IQ, CQ} a query language, and \u03a3 a signature. We say that a Q-query q is empty for \u03a3 given T if for every \u03a3-ABox A that is consistent with T we have that cert(q, T ,A) = \u2205. Otherwise, we say that q is non-empty for \u03a3 given T . The Q non-emptiness problem consists in deciding, for input T , q, and \u03a3, whether q is non-empty for \u03a3 given T .\nNext, we first show that, for every DL, and for both instance queries and Boolean UCQs, query non-emptiness reduces to exist. Then, we show that for the DL-LiteA case this holds even for arbitrary UCQs.\nProposition 3.6. For every DL and both instance queries and Boolean UCQs, Q nonemptiness is reducible to exist.\nProof. Let T be an arbitrary DL TBox, let q \u2208 IQ \u222a CQ be an arbitrary query such that q \u2208 CQ implies that q is a Boolean UCQ, and let \u03a3 be an arbitrary signature. We show how to construct a QAP P such that q is non-empty for \u03a3 given T iff P admits a solution. To this end, let ~c be an arbitrary tuple such that q \u2208 CQ implies that ~c = \u3008\u3009, and q \u2208 IQ implies that ~c = \u3008a\u3009 where a is a globally fresh individual. Clearly, we have that q is non-empty for \u03a3 given T iff P = \u3008T , \u2205, q,~c,\u03a3\u3009 admits a solution.\nThe relationship between CQ non-emptiness and exist can tightened, when we restrict our attention to DL-LiteA TBoxes.\nProposition 3.7. For DL-LiteA, CQ non-emptiness is reducible to exist.\nProof. Consider a DL-LiteA TBox T , a signature \u03a3, and this time an n-ary query q \u2208 CQ. W.l.o.g., we assume that q is a CQ. Then, we cannot immediately extend the proof given for Boolean CQs by introducing n (distinct) individuals since we might be forced to match distinct answer variables of q to the same individual in an ABox witnessing non-emptiness of q. However, we can adapt the proof to this case as follows. We let N be a fresh atomic concept not occurring in \u03a3(T , \u2205, q)\u222a\u03a3. We define \u03a3\u2032 = \u03a3\u222a{N} and we let q\u2032 be the Boolean CQ such that at(q\u2032) = at(q)\u222a {N(x1), . . . , N(xn)}. Finally, we let P = \u3008T , \u2205, q\u2032, \u3008\u3009,\u03a3\u2032\u3009 be a QAP. In the following, we show that q is non-empty for \u03a3 given T iff P admits a solution.\n(\u21d2) Suppose that q is non-empty for \u03a3 given T . That is, there exists a \u03a3-ABox A such that \u3008T ,A\u3009 is consistent and there exists some n-ary tuple ~a = \u3008a1, . . . , an\u3009 of individuals\nsuch that ~a \u2208 cert(q, T ,A). Now, consider the \u03a3\u2032-ABox E = A \u222a {N(ai) | 1 \u2264 i \u2264 n}. Since N is a fresh predicate, we have that \u3008T , E\u3009 is a conservative extension of \u3008T ,A\u3009. That is, each model of \u3008T ,A\u3009 can be extended to be a model of \u3008T , E\u3009, and every model of \u3008T , E\u3009 is also a model of \u3008T ,A\u3009. By the assumption that \u3008T ,A\u3009 is consistent and that ~a \u2208 cert(q, T ,A), we conclude that E is a solution to P.\n(\u21d0) Suppose that P admits a solution E . It follows that \u3008T , E\u3009 is consistent and that for each model I of \u3008T , E\u3009, there exists a match \u03c0 for q\u2032 such that I |=\u03c0 q\u2032. Since N is a fresh predicate not occurring in T and for each answer variable xi of q the atom N(xi) is contained in q\u2032, we have that \u03c0(xi) = a I i for some ai \u2208 NI such that N(ai) \u2208 E . It follows that ~a \u2208 cert(q, T , E). Consider the \u03a3-ABox A obtained from E by removing all the assertions over N ; it immediately follows that \u3008T , E\u3009 is a conservative extension of \u3008T ,A\u3009. Therefore, also ~a \u2208 cert(q, T ,A) and, thus, q is non-empty for \u03a3 given T .\nProposition 3.7 can be generalized to Horn DLs\u2014that is, to all those DLs for which answering instance and conjunctive queries reduces to evaluating the input query over a single, canonical model of the ontology. It follows that for DL-LiteA and, more in general, for all Horn-DLs, deciding exist generalizes the query non-emptiness problem. Hence, all the hardness results for non-emptiness obtained by Baader et al. (2010) that hold for instance queries and UCQs apply also to the exist problem under restricted explanation signatures. However, since we also consider ABoxes and we require a specific tuple to be in the query answer, the converse does not hold and we can not always transfer their upper bounds to our setting."}, {"heading": "3.3 Canonical Explanations", "text": "Before studying the complexity of reasoning over query abduction problems, we first show that we can restrict the search for explanations. In order to do so, we define the notion of instantiation of a conjunctive query.\nDefinition 3.6. Let q be an n-ary CQ with answer variables \u3008x1, . . . , xn\u3009; furthermore, let ~c = \u3008c1, . . . , cn\u3009 be a tuple of individuals. Let \u03be be a mapping from the terms of q to NI such that \u03be is identity over NI and for each answer variable xj of q we have that \u03be(xj) = cj. Then, we call the ABox\nE\u03be = {A(\u03be(t)) | A(t) \u2208 at(q)} \u222a {R(\u03be(s), \u03be(t)) | R(s, t) \u2208 at(q)}\na ~c-instantiation of q. Given a DL ontology O, if we additionally have that, for each quantified variable y, \u03be(y) is a distinct anonymous individual uy not occurring in q and O, then we say that E\u03be is direct for O.\nNote that in the following we do not distinguish between instantiations that differ only in the assignment of anonymous individuals to variables. Hence, a CQ has only a finite number of distinct instantiations, and a unique direct one."}, {"heading": "3.3.1 Unrestricted Explanation Signature", "text": "To obtain an explanation for a QAP P with unrestricted explanation signature, we can iterate over the set of all possible instantiations to the input query, searching for one such\ninstantiation that is consistent with the input ontology. In the absence of the UNA, we can even consider one single instantiation of each CQ: the direct instantiation, where all existentially quantified variables are mapped to distinct anonymous individuals. In the presence of the UNA, if our underlying DL is expressive enough to enforce inequalities over the individuals occurring in P (e.g., by means of disjointness axioms), we can again reduce the problem to searching for a CQ whose direct instantiation is consistent with the input ontology, when the UNA is dropped.\nProposition 3.8. Let O = \u3008T ,A\u3009 be an arbitrary DL ontology and let P = \u3008T ,A, q,~c,\u03a3\u3009 be an arbitrary QAP with unrestricted explanation signature. Furthermore, for each qi \u2208 q, let Eqi be the direct ~c-instantiation of qi for O. The following hold:\n1. Under the UNA, a solution to P exists iff a ~c-instantiation E\u03be of some qi \u2208 q exists such that \u3008T ,A \u222a E\u03be\u3009 is consistent.\n2. Without the UNA, a solution to P exists iff a query qi \u2208 q exists such that \u3008T ,A \u222a Eqi\u3009 is consistent.\n3. Furthermore, suppose that the DL supports concept disjointness axioms. Under the UNA, a solution to P exists iff a query qi \u2208 q exists such that \u3008T \u2032,A\u2032 \u222a Eqi\u3009 is consistent without the UNA, where A\u2032 and T \u2032 extend A and T with a quadratic number of assertions and axioms, respectively.\nProof. Consider an arbitrary qi \u2208 q and let E\u03be be an arbitrary ~c-instantiation of qi. We first prove that consistency of \u3008T ,A \u222a E\u03be\u3009 (with or without the UNA) implies that E\u03be is a solution to P (with or without the UNA, resp.). This shows the if direction of 1 and 2. Let \u03be be the mapping generating E\u03be and suppose that \u3008T ,A \u222a E\u03be\u3009 is consistent. Let I be an arbitrary model of \u3008T ,A \u222a E\u03be\u3009. Then we build a match \u03c0 for qi in I by setting \u03c0(t) = \u03be(t)I for each term t in qi. As \u03c0(xj) = \u03be(xj)\nI = cIj for each answer variable xj , the match \u03c0 witnesses ~c \u2208 ans(q, I). Hence ~c \u2208 cert(q, T ,A \u222a E\u03be) and E\u03be is a solution to P, as desired.\nFor the only-if direction of 1, we assume an arbitrary solution E to P, and use it to show that there exists a ~c-instantiation E\u03be of some qi \u2208 q such that \u3008T ,A \u222a E\u03be\u3009 is consistent. Since E is a solution to P, by definition, there exists a model I of \u3008T ,A \u222a E\u3009 under the UNA. Without loss of generality, we assume that \u2206I = NI and that for each c \u2208 NI we have that cI = c. Moreover, the interpretation I admits a match \u03c0 for some qi \u2208 q witnessing ~c \u2208 ans(qi, I). To define the mapping \u03be, we let \u03be(t) = \u03c0(t) for each term t occurring in qi. Then I is a model of E\u03be. Since it is also a model of \u3008T ,A\u3009, it is a model of \u3008T ,A \u222a E\u03be\u3009 and shows that the latter is consistent, as desired.\nThe only-if direction of 2 is shown similarly. Suppose that P admits a solution E . Then there exists a model I of \u3008T ,A \u222a E\u3009 (without the UNA) that admits a match \u03c0 for some qi \u2208 q witnessing ~c \u2208 ans(qi, I). To obtain an interpretation J that is a model of \u3008T ,A \u222a Eqi\u3009, we extend I as follows. For every anonymous individual uy that was introduced in Eqi due to an existentially quantified variable y, we let uyJ = \u03c0(y). The resulting interpretation is a model of Eqi , and since these individuals uy do not occur in the ontology, modelhood for \u3008T ,A\u3009 is preserved.\nFor 3, we use the extended ABox A\u2032 and TBox T \u2032 to enforce the UNA over the individuals occurring in P. The ABox A\u2032 extends A with an assertion Ac(c) for each individual\nc occurring in P, where each Ac is a fresh concept name. The TBox T \u2032 consists of axioms Ac v \u00acAc\u2032 for all pairs c 6= c\u2032 of individuals occurring in P. Since the interpretations of \u3008T ,A\u3009 under the UNA and of \u3008T \u2032,A\u2032\u3009 without the UNA coincide, the claim easily follows from statement 2 above.\nA direct consequence of this proposition is that, for all DLs, we can restrict our search to explanations that result from instantiating the input query.\nCorollary 3.9. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP with unrestricted explanation signature, let max(q) = maxqi\u2208q |at(qi)|, and let max-terms(q) = maxqi\u2208q |qi|. If P has an explanation, then P has an explanation with concepts and roles only from q, at most max(q) atoms, and at most max-terms(q) individuals."}, {"heading": "3.3.2 Restricted Explanation Signature", "text": "If we allow for restricted explanation signatures, then Proposition 3.8 does not hold anymore, and the search space for possible explanations becomes significantly larger. As we will see in the following sections, this has a notable effect on the complexity of the different decision problems. However, in the case of DL-LiteA, we can still show a weaker version of the proposition that allows us to restrict our search to the instantiations of the queries in the perfect reformulation of the input query q. Moreover, every \u2286-minimal explanation can be obtained this way.\nProposition 3.10. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP where \u3008T ,A\u3009 is a DL-LiteA ontology, and let Rq,T be the perfect reformulation of q w.r.t. T . A solution to P exists if and only if a ~c-instantiation E\u03be of some qr \u2208 Rq,T exists such that (i) \u3008T ,A \u222a E\u03be\u3009 is consistent, and (ii) E\u03be \\ A is a \u03a3-ABox. Moreover, E \u2032 is a \u2286-minimal explanation implies that query qr \u2208 Rq,T and ABox E\u03be exist such that E\u03be is a ~c-instantiation of qr and E \u2032 = E\u03be \\ A.\nProof. The first part of the claim is shown analogously to item 1 of Proposition 3.8 (recall that in DL-LiteA we make the UNA). For the if direction, consider an arbitrary qr \u2208 Rq,T and let E\u03be be a ~c-instantiation of qr generated from a mapping \u03be. We assume that \u3008T ,A \u222a E\u03be\u3009 is consistent and that E\u03be \\ A is a \u03a3-ABox. Then, to show that E\u03be \\ A is a solution to P, it suffices to show the existence of a match \u03c0 for qr in DBA\u222aE\u03be witnessing ~c \u2208 cert(q, T ,A\u222aE\u03be). This \u03c0 is easily obtained by setting \u03c0(t) = \u03be(t)I for each term t in qr. For the only-if direction, we assume an arbitrary solution E to P and use it to show that there exists a ~cinstantiation E\u03be of some qr \u2208 Rq,T that satisfies conditions (i) and (ii). Since E is a solution to P, by definition, E is a \u03a3-ABox, \u3008T ,A \u222a E\u3009 is consistent, and ~c \u2208 cert(q, T ,A \u222a E). By Proposition 2.1, it follows that there exists a query qr \u2208 Rq,T and a match \u03c0 for qr in DBA\u222aE that witness ~c \u2208 ans(qr,DBA\u222aE). We define a mapping \u03be by setting \u03be(t) = \u03c0(t) for each term t in qr. Then, for the resulting ~c-instantiation E\u03be we have that E\u03be \u2286 E \u222aA, which implies the consistency of \u3008T ,A \u222a E\u03be\u3009 and that E\u03be \\ A is also a \u03a3-ABox as desired.\nTo show the second part of the claim, suppose E is a \u2286-minimal solution to P. By Proposition 2.1, we have that there exists some qr \u2208 Rq,T for which there exists a match \u03c0 witnessing ~c \u2208 ans(qr,DBA\u222aE). We construct a ~c-instantiation E\u03be of qr as follows:\nE\u03be = {A(\u03c0(t)) \u2208 A \u222a E | A(t) \u2208 at(qr)} \u222a {R(\u03c0(t), \u03c0(t\u2032)) \u2208 A \u222a E | R(t, t\u2032) \u2208 at(qr)}\nBy the minimality of E , we have that E = E\u03be \\ A.\nSimilarly as above, this implies that we can consider only small explanations whose size is linear in the size of the input query q, but now their signature depends not only on q, but also on the signature of the input TBox T .\nCorollary 3.11. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP where \u3008T ,A\u3009 is a DL-LiteA ontology. Furthermore, let max(q) = maxqi\u2208q |at(qi)|. If P = \u3008T ,A, q,~c,\u03a3\u3009 has an explanation, then P has an explanation with concepts and roles only from T and q, at most max(q) atoms, and at most 2 \u00b7max(q) individuals."}, {"heading": "4. Complexity for Instance Queries", "text": "We now study the complexity of reasoning over query abduction problems. We consider the complexity under both unrestricted and restricted explanation signatures, and we consider the different minimality criteria over abductive solutions. We measure the complexity of a QAP P = \u3008T ,A, q,~c,\u03a3\u3009 in terms of the combined size of T , A, q, and \u03a3\u2014that is, we consider combined complexity. In this section, we investigate the complexity of reasoning over QAPs when the body of the input query consists of a single unary atom\u2014that is, we consider instance queries. In the following section, we shall turn our attention to UCQs."}, {"heading": "4.1 Existence of Explanations", "text": "Before giving the first complexity results, we show that, for instance queries, \u2286-minimal and \u2264-minimal explanations coincide. To see this, consider an arbitrary QAP P = \u3008T ,A, q, c,\u03a3\u3009 such that q \u2208 IQ and let qr be an arbitrary CQ in the perfect reformulation Rq,T . By Propositions 2.1 and 3.10, it follows that each ~c-instantiation of qr that is consistent with \u3008T ,A\u3009 contains an explanation for P; moreover, each \u2286-minimal explanation for P can be obtained in this way. As these explanations contain at most one assertion (cf. Proposition 2.1), \u2264- and \u2286-minimal explanations are both of size at most one, and we obtain the following result.\nProposition 4.1. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP such that \u3008T ,A\u3009 is a DL-LiteA ontology and q \u2208 IQ, and let E be an arbitrary \u03a3-ABox. Then, E is a solution to P implies that a solution E \u2032 \u2286 E to P exists such that |E \u2032| \u2264 1. Hence, expl\u2264(P) = expl\u2286(P).\nNow we consider the complexity of deciding existence of an explanation.\nTheorem 4.2. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, exist, \u2286-exist, and \u2264-exist are NL-complete.\nProof. By Proposition 3.5, it suffices to show the result for exist. We first provide an algorithm that yields the desired upper bound, even with restricted explanation signatures. Then we show that the problem is NL-hard already for the case of unrestricted signatures.\n(membership) Let P = \u3008T ,A, q, c,\u03a3\u3009 be a QAP such that q \u2208 IQ. To decide exist in non-deterministic logarithmic space, we can exploit Proposition 4.1 and test all candidate singleton explanations by iterating over \u03a3, the individuals occurring in P, and at most two anonymous individuals. This results in at most polynomially many candidate solutions E of constant size. For each of them we test whether \u3008T ,A \u222a E\u3009 is consistent and c \u2208 cert(q, T ,A \u222a E). Since for DL-LiteA both ontology consistency and instance checking can be solved in non-deterministic logarithmic space, exist is in NL.\nAlgorithm 1 isNEC\nInput: QAP P = \u3008T ,A, q,~c,\u03a3\u3009 and assertion \u03d5(~d) such that \u3008T ,A\u3009 is a DL-LiteA ontology, q \u2208 IQ \u222a CQ, \u03a3 is unrestricted, and \u03d5 \u2208 \u03a3. Output: \u201cyes\u201d iff \u03d5(~d) is necessary for P. 1: Let \u03d5\u0304 be a globally fresh predicate of the same arity as \u03d5. 2: Let T \u2032 := T \u222a {\u03d5\u0304v \u00ac\u03d5} and let A\u2032 := A \u222a {\u03d5\u0304(~d)}. 3: If \u3008T \u2032,A\u2032, q,~c,\u03a3\u3009 admits a solution, then return \u201cno\u201d. 4: Let I be the set of all individuals occurring in P and ~d. 5: Let u be a globally fresh anonymous individual. 6: for all \u03a3-ABoxes E\u2217 over the individuals in I \u222a {u} s.t. |E\u2217| \u2264 1 and \u03d5(~d) 6\u2208 E\u2217 do 7: If \u3008T ,A \u222a E\u2217\u3009 |= \u03d5(~d) and \u3008T ,A \u222a E\u2217, q,~c,\u03a3\u3009 admits a solution, then return \u201cno\u201d. 8: end for 9: Return \u201cyes\u201d.\n(hardness) We reduce the DL-LiteA ontology consistency problem (under the UNA) to exist. Consider an arbitrary DL-LiteA ontology \u3008T ,A\u3009. Furthermore, consider an arbitrary atomic concept A not occurring in \u3008T ,A\u3009, let q = A(x), let c \u2208 NI be an arbitrary individual, and let P = \u3008T ,A, q, c,\u03a3\u3009 be a QAP with unrestricted \u03a3. We show that \u3008T ,A\u3009 is consistent if and only if P admits a solution. The if direction is trivial. For the onlyif direction, suppose that \u3008T ,A\u3009 is consistent, and consider E = {A(c)}. Since \u3008T ,A\u3009 is consistent and A is fresh, \u3008T ,A \u222a E\u3009 is also consistent. As each model I of \u3008T ,A \u222a E\u3009 satisfies the assertion A(c), E is a solution to P."}, {"heading": "4.2 Deciding Necessity", "text": "In Section 3.1, we have seen that for QAPs with restricted explanation signatures and DLs that allow for disjointness axioms, nec reduces to non-exist. For the case of QAPs with unrestricted explanation signatures but ontologies restricted to DL-LiteA, we provide in Algorithm 1 a Turing reduction to (non-)exist; that is, a procedure that solves nec by employing a subroutine for solving exist. The following proposition proves its correctness.\nProposition 4.3. For DL-LiteA, instance queries and UCQs, and under unrestricted explanation signatures, algorithm isNEC decides nec.\nProof. Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP such that \u3008T ,A\u3009 is a DL-LiteA ontology, query q \u2208 IQ \u222a CQ, and signature \u03a3 is unrestricted; furthermore, let \u03d5(~d) be an assertion over abducible predicate \u03d5 \u2208 \u03a3. We prove that \u03d5(~d) is necessary for P iff isNEC returns \u201cyes\u201d.\nFor the only-if direction, we prove the contrapositive. Suppose that isNEC returns \u201cno\u201d on the given instance; we show that a solution E to P exists such that \u03d5(~d) 6\u2208 E . According to the construction of isNEC, we consider two alternative cases.\n\u2022 QAP \u3008T \u2032,A\u2032, q,~c,\u03a3\u3009 admits a solution E . For DL-LiteA, Calvanese et al. (2009) showed that negative inclusion axioms affect only the consistency of the given ontology, but do not contribute towards computing the certain answer; that is, ~c \u2208 cert(q, T \u2032,A\u2032) iff \u3008T \u2032,A\u2032\u3009 is consistent and ~c \u2208 cert(q, T ,A\u2032). Then, since assertion \u03d5\u0304(~d) is over a predicate not occurring in P and \u3008T \u2032,A\u2032\u3009 is consistent, we have that E is also a solution\nto P = \u3008T ,A, q,~c,\u03a3\u3009. By the definition, such solution does not contain \u03d5(~d), since \u3008T \u2032,A\u2032\u3009 |= \u03d5\u0304(~d) and \u03d5\u0304v \u00ac\u03d5 \u2208 T \u2032.\n\u2022 QAP \u3008T \u2032,A\u2032, q,~c,\u03a3\u3009 has no solution. Since isNEC returns \u201cno\u201d, a \u03a3-ABox E\u2217 exists such that |E\u2217| \u2264 1, \u03d5(~d) 6\u2208 E\u2217, \u3008T ,A \u222a E\u2217\u3009 |= \u03d5(~d), and QAP \u3008T ,A \u222a E\u2217, q,~c,\u03a3\u3009 has a solution E . Given that assertion \u03d5(~d) is entailed by \u3008T ,A \u222a E\u2217\u3009 we have that E \u2032 := E \\ {\u03d5(~d)} is also a solution to \u3008T ,A \u222a E\u2217, q,~c,\u03a3\u3009. We conclude that E \u2032 \u222a E\u2217 is a solution to \u3008T ,A, q,~c,\u03a3\u3009 that does not contain \u03d5(~d), as required.\nFor the if direction, we prove the contrapositive. Suppose that a \u03a3-ABox E exists such that E is a solution to P and \u03d5(~d) 6\u2208 E ; we show that isNEC returns \u201cno\u201d. W.l.o.g., the individual u of Algorithm 1 does not occur in E . Now, if \u3008T ,A \u222a E\u3009 6|= \u03d5(~d), we have that E is a solution to QAP \u3008T \u2032,A\u2032, q,~c,\u03a3\u3009, so isNEC returns \u201cno\u201d, as required. Otherwise, consider the case in which \u3008T ,A \u222a E\u3009 |= \u03d5(~d) and take the conjunctive query q\u2032(~x)\u2190 \u03d5(~x). By the assumption, we have that ~d \u2208 cert(q\u2032, T ,A \u222a E). By Proposition 2.1, a query r \u2208 Rq\u2032,T and a match \u03c0 for r exist such that r contains a single atom and ~d \u2208 ans(r,DBA\u222aE) is witnessed by \u03c0. Let \u03c8(~y) be the unique atom occurring in r such that ~x \u2286 ~y and let \u03c8(~t) be the assertion obtained from \u03c8(~y) by replacing each variable y \u2208 ~y with \u03c0(y). Clearly, we have that \u03c8(~t) \u2208 A \u222a E . Next, we distinguish among two cases.\n\u2022 For each variable y \u2208 ~y we have that \u03c0(y) \u2208 I. Then, let E\u2217 := \u2205, if \u03c8(~t) \u2208 A, and let E\u2217 := {\u03c8(~t)}, if \u03c8(~t) \u2208 E . In either case, we have that \u03d5(~d) 6\u2208 E\u2217, that \u3008T ,A \u222a E\u2217\u3009 |= \u03d5(~d), and that E\u2217 \u2286 E . Hence, E is a solution to QAP \u3008T ,A \u222a E\u2217, q,~c,\u03a3\u3009; so isNEC returns \u201cno\u201d, as required.\n\u2022 Variable y \u2208 ~y exists such that \u03c0(y) 6\u2208 I. Given that ~d \u2286 I, ~d \u2208 ans(r,DBA\u222aE), and predicates have arity at most 2, we have that ~d is of the form ~d := \u3008d\u3009, \u03d5 \u2208 NC , and \u03c8 \u2208 NR. It follows that CQ r is of the form r(x)\u2190 \u03c8(x, y) or r(x)\u2190 \u03c8(y, x). Next, we consider the former case only, as the other case is symmetrical. Then, assertion \u03c8(~t) is of the form \u03c8(d, \u03c0(y)). Since \u03c0(y) 6\u2208 I, we have that \u03c8(d, \u03c0(y)) \u2208 E . Now, let E \u2032 be the ABox obtained from E by replacing each occurrence of individual \u03c0(y) with the individual u of Algorithm 1. Since E \u2032 is obtained from solution E by uniformly replacing an anonymous individual with an individual that does not occur in E and P, we have that E \u2032 is also a solution to P. By the definition, \u03d5(d) 6\u2208 E \u2032 and \u03c8(d, u) \u2208 E \u2032. Now, let E\u2217 := {\u03c8(d, u)}. Since d \u2208 ans(r,DBA\u222aE) is witnessed by \u03c0 and by the definition of E\u2217, we have that \u3008T ,A \u222a E\u2217\u3009 |= \u03d5(d). At last, since E\u2217 \u2286 E \u2032 and E \u2032 is a solution to P, we conclude that ABox E \u2032 is a solution to \u3008T ,A \u222a E\u2217, q,~c,\u03a3\u3009. Hence, isNEC returns \u201cno\u201d, as required.\nNext, we use Algorithm 1 and Propositions 3.1 and 3.2 to characterize the complexity of nec in the presence of instance queries.\nTheorem 4.4. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, nec, \u2264-nec, and \u2286-nec are NL-complete.\nProof. For the NL upper bound for nec and under restricted signatures, observe that, by Proposition 3.2, nec reduces to non-exist. In Theorem 4.2, we proved that exist is in NL.\nGiven that NL = coNL, we have that nec is in NL as well. The NL upper bound in the case of unrestricted signature can be established using algorithm isNEC and Proposition 4.3. Indeed, given that NL = coNL, that non-exist is in coNL, and that checking whether an assertion is entailed by a DL-LiteA ontology is in coNL as well, we immediately obtain that isNEC runs in nondeterministic logarithmic space. The coNL-hardness and thus also NLhardness of nec follows from Proposition 3.1 and Theorem 4.2. In addition, Proposition 3.4 states that nec and \u2286-nec are equivalent and, thus, also \u2286-nec is NL-complete. Finally, by Proposition 4.1, we conclude that \u2264-nec is NL-complete."}, {"heading": "4.3 Deciding Relevance", "text": "By Proposition 3.3, deciding the relevance of an assertion to a QAP is equivalent to assessing whether a QAP admits a solution. We already showed this latter problem to be NL-complete (see Theorem 4.2). Therefore, the following result easily follows.\nTheorem 4.5. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, rel is NL-complete.\nIn the next theorem, we show that the complexity of the problem does not change even when we apply a minimality criterion over solutions.\nTheorem 4.6. For DL-LiteA, instance queries, and under both restricted and unrestricted explanation signatures, \u2264-rel and \u2286-rel are NL-complete.\nProof. By Proposition 4.1, it suffices to show that \u2264-rel is NL-complete. (membership) Let P = \u3008T ,A, q, c,\u03a3\u3009 be a QAP such that q \u2208 IQ and let \u03d5(~d) be an ABox assertion over abducible predicate \u03d5. We argue that \u03d5(~d) is\u2264-relevant to P if and only if (i) c 6\u2208 cert(q, T ,A), (ii) \u3008T ,A \u222a {\u03d5(~d)}\u3009 is consistent, and (iii) c \u2208 cert(q, T ,A\u222a{\u03d5(~d)}). We show the only-if direction, since the if direction directly follows by Proposition 4.1 and by the definition of solution. Suppose that \u03d5(~d) is \u2264-relevant to P. By the definition of minimal solution, it follows that c 6\u2208 cert(q, T ,A). Also, by Proposition 4.1, it follows that {\u03d5(~d)} is a \u2264-solution to P. But then, we have that c \u2208 cert(q, T ,A \u222a {\u03d5(~d)}) and that the ontology \u3008T ,A \u222a {\u03d5(~d)}\u3009 is consistent. Since conditions (i-iii) can be decided in non-deterministic logarithmic space for DL-LiteA ontologies, we conclude that, for instance queries and (un)restricted explanation signatures, \u2264-rel is in NL.\n(hardness) Hardness can be proved by employing the same reduction as in Theorem 4.2 and by taking A(c) to be the assertion to be shown relevant. By Proposition 4.1, we have that \u3008T ,A\u3009 is consistent if and only if A(c) is \u2264-relevant for P."}, {"heading": "4.4 Deciding Recognition", "text": "Finally, we consider the problem of deciding whether a given ABox is a solution to a QAP.\nTheorem 4.7. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, rec is NL-complete.\nProof. (membership) Let P = \u3008T ,A, q, c,\u03a3\u3009 be a QAP (where \u03a3 may be restricted) such that q \u2208 IQ and let E be an ABox. By the definition of solution to a QAP, we can decide\nwhether E \u2208 expl(P) in three steps: (i) check that E is a \u03a3-ABox, (ii) check that \u3008T ,A \u222a E\u3009 is consistent, and (iii) check that c \u2208 cert(q, T ,A \u222a E). For DL-LiteA ontologies, we can perform these three steps in non-deterministic logarithmic space. Thus, for instance queries and under both restricted and unrestricted signatures, rec is in NL.\n(hardness) We provide a reduction from the consistency problem of DL-LiteA ontologies. Consider an arbitrary ontology \u3008T ,A\u3009. Then, we let A be a fresh concept name not occurring in the ontology and we let c be a fresh individual. Furthermore, let q(x)\u2190 A(x) be our instance query. Finally, we let P = \u3008T ,A, q, c,\u03a3\u3009 be our query abduction problem with unrestricted explanation signature and we let E = {A(c)} be our target ABox. It is not too difficult to see that \u3008T ,A\u3009 is consistent iff E is a solution to P.\nUnsurprisingly, the complexity does not change when we consider a minimality criterion over solutions.\nTheorem 4.8. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, \u2264-rec and \u2286-rec are NL-complete\nProof. By Proposition 4.1, we focus only on \u2264-rec. (membership) In order to decide whether E \u2208 expl\u2264(P) we first check that E is indeed a solution to P, which we can do in non-deterministic logarithmic space (see Theorem 4.7). Then, by Proposition 4.1, we need to check that |E| \u2264 1 and that E is the empty ABox whenever c \u2208 cert(q, T ,A). Since instance checking in DL-LiteA is in NL, we conclude that \u2264-rec is in NL as well.\n(hardness) We can reuse the reduction to consistency in DL-LiteA provided in Theorem 4.7 to show that, for instance queries and under unrestricted explanation signatures, \u2264-nec is NL-hard. We conclude that, under both restricted and unrestricted explanation signature, \u2264-nec and \u2286-nec are NL-complete."}, {"heading": "5. Complexity for Unions of Conjunctive Queries", "text": "In this section, we consider the more general problem of reasoning over query abduction problems that admit UCQs in the input. We establish the complexity of the various rea-\nAlgorithm 2 someExplanation\nInput: QAP P = \u3008T ,A, q,~c,\u03a3\u3009. Output: \u201cyes\u201d iff P has an explanation.\n1: Guess a CQ qr in the perfect reformulation Rq,T of q w.r.t. T . 2: Guess a ~c-instantiation E\u03be of qr. 3: If E\u03be \\ A is a \u03a3-ABox and \u3008T ,A \u222a E\u03be\u3009 is consistent, then return \u201cyes\u201d. 4: Return \u201cno\u201d.\nsoning tasks for these problems in DL-LiteA, under both unrestricted and restricted explanation signatures, and under the different minimality criteria. The results in this section are summarized in Table 5.1."}, {"heading": "5.1 Existence of Explanations", "text": "We first focus on the problem of deciding whether a query abduction problem with unrestricted signature admits at least one explanation.\nIt follows from Proposition 3.8 that the complexity of this problem coincides with the complexity of deciding consistency without the UNA in the underlying DL. By Proposition 3.5, this extends to \u2286-exist, and \u2264-exist. Since reasoning without the UNA is PTime-complete for DL-LiteA (Artale et al., 2009), we obtain the following result.\nTheorem 5.1. For every DL L, UCQs, and under unrestricted explanation signatures, exist, \u2286-exist, and \u2264-exist have the same complexity as consistency checking without the UNA in L. Hence for DL-LiteA, the mentioned problems are PTime-complete.\nIf we allow for restricted explanation signatures, then deciding exist becomes harder. For DL-LiteA, the complexity increases from PTime to NP.\nTheorem 5.2. For DL-LiteA, UCQs, and under restricted explanation signatures, exist, \u2286-exist, and \u2264-exist are NP-complete. NP-hardness holds already in the following restricted settings:\n1. QAPs where the TBox contains only concept inclusions of the forms A1 v A2 and A1v\u00acA2 for concept names A1 and A2, the ABox is empty, and the query is a Boolean CQ consisting of a conjunction of unary atoms over a single quantified variable.\n2. QAPs with an empty TBox.\nProof. By Proposition 3.5, it is sufficient to show that exist is NP-complete.\n(membership) The upper bound follows from guess-and-check Algorithm 2, which is immediate by Proposition 3.10. It guesses non-deterministically a CQ qr in the perfect reformulation Rq,T of q w.r.t. T , and a ~c-instantiation E\u03be of qr. The algorithm then checks in polynomial time that E\u03be \\A is a \u03a3-ABox and that the ontology \u3008T ,A \u222a E\u03be\u3009 is consistent; it was shown by Calvanese et al. (2009) that the latter check is polynomial.\n(hardness) Next, we provide the two hardness results. The first one follows directly from Proposition 3.7 and the hardness proof for CQ query emptiness for the sublogic of\nDL-LiteA known as DL-Litecore given in Theorem 17 by Baader et al. (2010). For showing hardness in the second setting, we reduce the following NP-complete problem: given a pair of directed graphs G = (V,E) and G\u2032 = (V \u2032, E\u2032), decide whether there exists an homomorphism from G to G\u2032. To this end, let A = {e(ca, cb) | (a, b) \u2208 E\u2032} be an ABox. Furthermore, for B an arbitrary atomic concept and c a globally fresh individual, let q = {e(xa, xb) | (a, b) \u2208 E} \u222a {B(c)} be a Boolean CQ and \u03a3 = {B} be a signature. Finally, let PG,G\u2032 = \u3008\u2205,A, q,\u03a3\u3009 be a QAP; we show that there exists a homomorphism from G to G\u2032 iff there is a solution to PG,G\u2032 . Indeed, if there is a homomorphism from G to G\u2032, then {B(c)} is a solution to P. For the other direction, assume there is an explanation E for P. Since binary atoms are prohibited from occurring in E by the selection of \u03a3, there must exist a match \u03c0 from q to DBA. Such a mapping \u03c0 also witnesses the existence a homomorphism from G to G\u2032."}, {"heading": "5.2 Deciding Necessity", "text": "Now, we consider the problem of checking whether an assertion occurs in all the solutions to a QAP P; that is, whether an assertion is necessary for P. For the case of restricted explanation signatures, we use the reductions from Section 3.1 and Theorem 5.2 to derive that nec and \u2286-nec are coNP-complete. For the case of unrestricted explanation signatures, we use the procedure for solving nec described in Algorithm 1 to show that nec and \u2286-nec are PTime-complete.\nTheorem 5.3. For DL-LiteA, UCQs, and under unrestricted explanation signatures, nec and \u2286-nec are PTime-complete. Furthermore, under restricted explanation signatures, nec and \u2286-nec are coNP-complete.\nProof. In Theorem 5.1 and Theorem 5.2, we proved that the problems of deciding the existence of a solution to a QAP with unrestricted and with restricted explanation signatures are PTime-complete and NP-complete, respectively. By applying the reduction in Proposition 3.1, we have that nec is PTime-hard under unrestricted and coNP-hard under restricted explanation signatures.\nFor the upper bound, we first consider the case of restricted explanation signatures. By Proposition 3.2, nec reduces to non-exist. By Theorem 5.2, this latter problem can be solved in nondeterministic polynomial time. We readily obtain that nec is in coNP. For the case of unrestricted signatures, Proposition 4.3 states that algorithm isNEC solves nec, even when we consider UCQs in input. By the definition, isNEC requires checking whether polynomially many QAPs do not admit a solution, and whether polynomially many DLLiteA ontologies entail a given assertion. Since for DL-LiteA, instance checking is in PTime and, by Theorem 5.1, non-exist is in PTime, we conclude that isNEC runs in polynomial time. Thus, nec under unrestricted signatures is in PTime.\nWe conclude that nec is PTime-complete under unrestricted and coNP-complete under restricted explanation signatures.\nFinally, Proposition 3.4 states that nec and \u2286-nec are equivalent and, thus, also \u2286-nec is PTime-complete under unrestricted and coNP-complete under restricted explanation signatures.\nNow, we consider the complexity of \u2264-nec and we show that, under common assumptions, the problem is harder than nec. Intuitively, this is because one has to first compute the minimal size of an explanation, and then inspect all the explanations of that size. In the following, we will use [i..j] to denote the integer interval {i, . . . , j}. Theorem 5.4. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, \u2264-nec is PNP\u2016 -complete. The hardness holds already for QAPs with an empty TBox and a CQ.\nProof. We structure the proof as follows. First, we show that \u2264-nec is in PNP\u2016 . Then, we prove that the problem is PNP\u2016 -hard under restricted signatures. Finally, we argue that the same reduction can also be used in the particular case of unrestricted signatures.\n(membership) Consider an arbitrary QAP P = \u3008T ,A, q,~c,\u03a3\u3009 (where the signature may be restricted) and let \u03b1 be an arbitrary ABox assertion. From Corollary 3.9, we know that if P has an explanation, then there exists an explanation whose size m is bounded by max(q) = maxqi\u2208q |at(qi)|. Observe that \u3008P, \u03b1\u3009 is a negative instance of \u2264-nec iff there is an i \u2208 [0..m] such that (a) P has an explanation E with |E| = i and \u03b1 6\u2208 E , and (b) E is \u2264-minimal. Thus, we use an auxiliary problem size-out, which is to decide given a tuple \u3008P \u2032, \u03b1\u2032, n\u2032\u3009, where P \u2032 is a QAP, \u03b1\u2032 is an assertion, and n\u2032 is an integer, whether there exists an explanation E \u2032 for P \u2032 such that |E \u2032| = n\u2032 and \u03b1\u2032 6\u2208 E \u2032. Furthermore, the problem no-smaller is to decide, given a tuple \u3008P \u2032, n\u2032\u3009 of a QAP and an integer, whether there is no explanation E \u2032 for P \u2032 such that |E \u2032| < n\u2032. Observe that size-out is in NP, while no-smaller is in coNP. Take the tuple S = \u3008A0, B0, . . . , Am, Bm\u3009, where Ai = \u3008P, \u03b1, i\u3009 and Bi = \u3008P, i\u3009, for all i \u2208 [0..m]. Due to the above observation, \u03b1 occurs in all \u2264-minimal explanations E for P iff for all i \u2208 [0..m], one of the following holds: (i) Ai is a negative instance of size-out, or (ii) Bi is a negative instance of no-smaller. S can be built in polynomial time in the size of the input, and whether all instances instances in S satisfy (i) and (ii) above can be decided by making 2m parallel calls to an NP oracle. Thus we obtain membership in PNP\u2016 .\n(hardness) We give a reduction from OddMinVertexCover, which is PNP\u2016 -complete (Wagner, 1987). An instance of this problem is given by a graph G = (V,E), and we are asked whether the least cardinality over all vertex covers in G is odd. That is, is there an odd integer k \u2208 [1..|V |] such that G has a vertex cover C with |C| = k, and there is no vertex cover C \u2032 in G with |C \u2032| < k?\nIn the reduction we exploit the following property. Given an integer k and a directed graph G = (V,E) with m vertices, construct a new graph G\u2032 = ([1..m], E\u2032) such that there exist two symmetric edges between each i \u2208 [1..k] and j \u2208 [1..m]. The following holds: if there is an injective homomorphism h from G to G\u2032, then G has a vertex cover of size k. Indeed, take C = {v \u2208 V | h(v) \u2264 k}. Due to injectivity, |C| = k. Assume an arbitrary edge {v1, v2} \u2208 E. Since h is a homomorphism, due to the selection of edges we must have h(v1) \u2264 k or h(v2) \u2264 k. Then {v1, v2} \u2229 C 6= \u2205 by the selection of C.\nAssume an arbitrary graph G = (V,E) with vertices V = {v1, . . . , vm}. W.l.o.g., G is connected, directed, and has at least 2 nodes. We construct next a QAP PG = \u3008\u2205,A|V |, qG, \u3008\u3009,\u03a3G\u3009 and an assertion \u03b1G such that G is a positive instance of OddMinVertexCover iff \u03b1G is \u2264-necessary for PG. In the reduction we use individuals odd , even, cij , where i, j \u2208 [0..m], concept names M , L, and roles P , 6=, Edge.\nLet qG be the Boolean query consisting of atoms\n(i) Edge(xi1 , xi2), for each edge (vi1 , vi2) \u2208 E,\n(ii) 6=(xi1 , xi2), for each i1, i2 \u2208 [1..m], i1 6= i2, and\n(iii) L(x1), . . . , L(xm) and P (x1, y), M(y).\nIntuitively, in (i) we represent the graph G in the query. We will use atoms in (ii) to ensure that different variables are mapped to distinct elements. The atoms L(xi) will be used to measure the size of vertex covers, while the atoms P (x1, y) and M(y) will be used to determine their parity. We allow explanations only over concept names, and thus set \u03a3G = {M,L}.\nTo define A|V |, we first construct a collection A0, . . . ,Am of ABoxes, where each Aj consists of the assertions\n(a) L(cji ), for each i \u2208 [j..m],\n(b) Edge(cji1 , c j i2 ), for all i1, i2 \u2208 [1..m] with i1 \u2264 j or i2 \u2264 j, and\n(c) 6=(cji1 , c j i2 ), for all i1, i2 \u2208 [1..m] with i1 6= i2.\nFor an integer k, let par(k) = odd if k is odd, and par(k) = even, otherwise. Let A\u2032 = {P (cji , par(j)) | i, j \u2208 [0..m]}. Then A|V | = A0\u222a\u00b7 \u00b7 \u00b7\u222aAm\u222aA\u2032. See Figure 1 for an example.\nFinally, we let \u03b1G = M(odd). To prove the correctness of the reduction, we define up(k) = {L(ck1), . . . , L(ckk),M(par(k))}, and claim the following:\nclaim 1: If C is a vertex cover in G of size k, then up(k) is an explanation for PG. Let A\u2217 = A|V | \u222aup(k). It suffices to show the existence of a match \u03c0 for qG in DBA\u2217 . Take an enumeration z1, . . . , zm of variables x1, . . . , xm such that {z1, . . . , zk} = {xi | vi \u2208 C}. Take the mapping \u03c0 such that \u03c0(zi) = c k i for all i \u2208 [1..m], and \u03c0(y) = par(k). Assume an atom Edge(xi1 , xi2) in qG. Due to (b) in the definition of Aj , it suffices to show that \u03c0(xi1) = c k ` or \u03c0(xi2) = c k ` for some ` \u2264 k. Indeed, since C is a vertex cover, vi1 \u2208 C or vi2 \u2208 C. Then due to the enumeration of variables, xi1 = z` or xi2 = z` for some ` \u2264 k. Due to the definition of \u03c0, \u03c0(xi1) = c k ` or \u03c0(xi2) = c k ` for ` \u2264 k. The atoms 6=(xi1 , xi2) in qG are properly mapped due to (c) in the construction of Aj and the fact that \u03c0 is injective\nby construction. For an atom L(xi) in qG we have two options. If \u03c0(xi) = c k ` with ` \u2264 k, then L(ck` ) \u2208 up(k) by the definition of up(k). Otherwise, if ` > k, then L(ck` ) \u2208 Ak by the definition of Ak. The atom P (\u03c0(x1), \u03c0(y)) belongs to A\u2217 due to the definition of A\u2032, while M(\u03c0(y)) \u2208 up(k) by construction of up(k).\nclaim 2: Assume up(k) is an explanation for PG. Then G has a vertex cover of size k. Let A\u2217 = A|V |\u222aup(k) and let \u03c0 be a match for qG in DBA\u2217 . Observe that due irreflexivity of the role 6= and the atoms (ii) in qG, \u03c0 must be injective. Observe also that for all ` \u2208 [1..m], where ` 6= k, we have |{c`i | L(c`i) \u2208 A`}| < m. Due to the connectedness of G and atoms L(x1), . . . , L(xm) in qG, \u03c0 must use only the atoms in Ak \u222aA\u2032 \u222a up(k). That is, \u03c0 is also a match for qG in DBAk\u222aA\u2032\u222aup(k). Let C = {vi \u2208 V | \u03c0(xi) = ckn, n \u2208 [1..k]}. Then |C| = k due to the injectivity of \u03c0. To see that C is a vertex cover, assume an edge (vi1 , vi2) \u2208 E. By construction, qG has the atom Edge(xi1 , xi2). Since \u03c0 is a match in DBAk\u222aA\u2032\u222aup(k), Edge(\u03c0(xi1), \u03c0(xi2)) \u2208 Ak. Then, by construction of Ak, we have \u03c0(xi1) = ckn or \u03c0(xi2) = ckn with n \u2264 k. Then by the selection of C, {\u03c0(xi1), \u03c0(xi2)} \u2229 C 6= \u2205.\nclaim 3: Assume E is a \u2264-minimal explanation for PG with size k. Then E = up(k \u2212 1). Since G is connected and E is \u2264-minimal, there exist an index ` \u2208 [1..m] such that E \u2286 {L(c`1), . . . , L(c`m),M(par(`))} and there is a match for qG in A` \u222a A\u2032 \u222a E . Since L(c`i) \u2208 A` for i \u2208 [`+1..m] by the definition of A`, we have by cardinality minimality that E \u2286 {L(c`1), . . . , L(c``),M(par(`))}. By the definition of A`, |{c`i | L(c`i) \u2208 A`}| = m \u2212 `. Thus, due to the injectivity of any match \u03c0 for qG, we must have |{c`i | L(c`i) \u2208 E}| \u2265 `. Hence, E = {L(c`1), . . . , L(c``),M(par(`))} = up(`). Since |E| = k, we have ` = k \u2212 1.\nWe can now finalize the correctness proof:\n(\u21d2) Suppose there exists an odd integer k \u2208 [1..|V |] such that G has a vertex cover C with |C| = k, and there is no vertex cover C \u2032 in G with |C \u2032| < k. By claim 1, up(k) is an explanation for PG. We make sure that up(k) is \u2264-minimal. Suppose there exists an explanation E \u2032 with size |E \u2032| < |up(k)|, i.e., |E \u2032| = ` for some ` \u2264 k. We can assume that E \u2032 is \u2264-minimal. Then by claim 3, E \u2032 = up(` \u2212 1). It follows from claim 2 that G has a vertex cover of size ` \u2212 1. Since ` \u2212 1 < k, we arrive at a contradiction to the assumption that G has no vertex cover of size < k. Thus up(k) is \u2264-minimal. Since k is odd, we have M(odd) \u2208 up(k). By claim 3, apart from up(k) there is no other \u2264-minimal explanation for PG. That is, M(odd) occurs in all \u2264-minimal explanations for PG.\n(\u21d0) Assume M(odd) occurs in all \u2264-minimal explanations for PG. By claim 3, we know that up(k) is the unique \u2264-minimal explanation, for some integer k. Since M(odd) \u2208 up(k), we get that k is odd. Then, by claim 2, there is a vertex cover C with size k. It remains to ensure that there is no vertex cover C \u2032 of size ` < k. Assume the opposite. Then by claim 1 we have that up(`) is an explanation with size |up(`)| < |up(k)|, which contradicts the assumption that up(k) is \u2264-minimal. Thus G is a positive instance of OddMinVertexCover.\nThe definition of \u03a3G prohibits binary atoms from occurring in \u2264-minimal explanations. The same effect can be achieved by using \u03a3G = \u03a3(\u2205,A|V |, qG) and by modifying A|V | and qG to make it prohibitively expensive to have binary atoms in \u2264-minimal explanations. Simply replace each binary assertion r(c, d) in A|V | by fresh assertions r1(c, d), . . . , rm+2(c, d), and each binary r(x, y) in qG by r1(x, y), . . . , rm+2(x, y). In this way the lower-bound can be shown for unrestricted explanation signatures."}, {"heading": "5.3 Deciding Relevance", "text": "Using Theorems 5.1 and 5.2, and the reductions in Section 3, we obtain the following results.\nTheorem 5.5. For DL-LiteA, UCQs, and under unrestricted explanation signatures, rel is PTime-complete. Under restricted explanation signatures, rel is NP-complete.\nUnsurprisingly, for UCQs, \u2264-rel has the same complexity as \u2264-nec. Indeed, the two problems share the same source of complexity, namely the need to inspect all explanations up to a computed size, which allows us to reduce the OddMinVertexCover problem. In fact, PNP\u2016 -hardness can be shown using the same reduction as in the proof of Theorem 5.4, and a matching upper bound can be obtained by slightly modifying the algorithm for \u2264-nec.\nTheorem 5.6. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, \u2264-rel is PNP\u2016 -complete. P NP \u2016 -hardness holds already for QAPs with an empty TBox and a CQ.\nProof. First, we show that, under restricted explanation signatures, the problem \u2264-rel is in PNP\u2016 . Second, we argue that, under unrestricted explanation signatures, \u2264-rel is P NP \u2016 -hard.\n(membership) \u2264-rel can be tackled in a way similar to \u2264-nec. In fact, the algorithm described in Theorem 5.4 can be modified in order to solve this problem. Let size-in solve the following problem: given a tuple \u3008P, \u03b1, n\u3009, where P is a QAP, \u03b1 an assertion, and n an integer, decide whether there exists an explanation E , with |E| = n and \u03b1 \u2208 E . Then, we change the positivity condition of the \u2264-nec algorithm as follows: \u03b1 occurs in some \u2264-minimal explanation E for P iff for some i \u2208 [0..m] it holds that: (i) Ai is a positive instance of size-in, and (ii) Bi is a positive instance of no-smaller. It is easy to see that size-in is solvable in NP, hence the whole problem is again in PNP\u2016 .\n(hardness) Recall the reduction from OddMinVertexCover to \u2264-nec in the proof of Theorem 5.4. We argue that exactly the same reduction also shows PNP\u2016 -hardness of \u2264-rel. Assume a directed graph G and let PG and \u03b1G be the QAP and the assertion resulting in the reduction. To prove the claim it suffices to show the following equivalence: \u03b1G is \u2264-necessary for PG iff \u03b1G is \u2264-relevant for PG. This equivalence follows directly from claim 3, which states that PG has a unique \u2264-minimal explanation.\nWe now turn our attention to \u2286-rel. For this problem we obtain a precise complexity characterization for the case of restricted explanation signatures, but we leave it open whether for unrestricted signatures the \u03a3P2 upper bound shown below is tight.\n2 We note that for the latter case, a coNP lower bound can be easily shown, for instance, by a reduction from the non-existence of a homomorphism between two graphs.\nTheorem 5.7. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, \u2286-rel is in \u03a3P2 . Under restricted explanation signatures, \u2286-rel is \u03a3P2 -hard, and the hardness holds already for QAPs with an empty TBox and a CQ.\nProof. (membership) Let P = \u3008T ,A, q,~c,\u03a3\u3009 be a QAP and let \u03b1 be an ABox assertion. We now provide an extended version of the algorithm solving existence, which decides whether \u03b1\n2. The proof of the \u03a3P2 lower bound under unrestricted signatures in Theorem 2 by Calvanese, Ortiz, Simkus, and Stefanoni (2011) is incorrect.\nis \u2286-relevant for P. Let has-subexpl solve the problem of deciding whether a given explanation E has a subset which is itself an explanation. In our modified algorithm, similarly to Algorithm 2, first we non-deterministically guess a CQ qr in the perfect reformulation Rq,T of q w.r.t. T and a ~c-instantiation E\u03be of qr such that \u03b1 \u2208 E\u03be. Additionally to the consistency test and to checking that E\u03be is a \u03a3-ABox, we also check the complement of has-subexpl for E , in order to assure that E is \u2286-minimal. It follows that \u03b1 is \u2286-relevant. Since checking the complement of has-subexpl can be done in coNP, the problem is solvable in \u03a3P2 .\n(hardness) We reduce the \u03a3P2 -complete problem non-cert3col (Stewart, 1991, see also Bonatti, Lutz, & Wolter, 2009). An instance of non-cert3col is given by a graph G = (V,E) with vertices V = {1, . . . , n} such that every edge is labelled with a disjunction of two literals over the Boolean propositions {p(i,j) | 1 \u2264 i, j \u2264 n}. We say that edge e \u2208 E evaluates to true under truth assignment \u03c4 if \u03c4 satisfies the disjunction labelling e. Then, graph G is a positive instance to non-cert3col iff a truth assignment \u03c4 exists such that graph \u03c4(G)\u2014obtained from G by including only those edges that evalute to true under \u03c4\u2014is not 3-colorable. Assume an instance G of non-cert3col. We show how to build in polynomial time a QAP PG = \u3008TG,AG, qG,~cG,\u03a3G\u3009 and an ABox assertion \u03b1G. We first present all relevant definitions, after which we discuss the intuition behind the reduction and prove its correctness.\nIn the construction, we use an empty TBox and a Boolean CQ, thus TG = \u2205 and ~cG = \u3008\u3009. In order to define the ABox AG, let L be a function that assigns to each edge e \u2208 E the set {l1, l2} of literals occurring in its label. Moreover, we let T(e) (resp., F(e)) be the set containing each truth assignment \u03c4 to the literals in L(e) such that edge e evaluates to true (resp., false) under \u03c4 . Finally, for each truth assignment \u03c4 and each literal l occurring in G, we define the image of l w.r.t. \u03c4 , written img\u03c4 (l), as follows.\nimg\u03c4 (l) :=\n{ l if \u03c4(l) = t\nl\u0304 otherwise\nWe are now ready to define the ABox AG. In the definition, we use individuals a1, . . . , a4; moreover, for each literal l in G, we use individuals l and l\u0304 to denote l\u2019s truth value. Also, for all 1 \u2264 k \u2264 ` \u2264 4, each edge e \u2208 E, and each truth assignment \u03c4 \u2208 T(e) \u222a F(e), we let \u03c3e,\u03c4k,` be a fresh individual. ABox AG consists of four distinct components A\n\u2217, AtT , AfT , and AC which we introduce next.\nA\u2217 ={d(l, l\u0304), d(l\u0304, l) | literal l occurs in G} \u222a {B(ak) | 1 \u2264 k \u2264 3}\nAtT ={Re(ak, \u03c3 e,\u03c4 k,` ), Re(\u03c3 e,\u03c4 k,` , a`) | e \u2208 E, \u03c4 \u2208 T(e), 1 \u2264 k < ` \u2264 3} \u222a\n{P (\u03c3e,\u03c4k,` , img\u03c4 (l)) | e \u2208 E, \u03c4 \u2208 T(e), l \u2208 L(e), 1 \u2264 k < ` \u2264 3}\nAfT ={Re(ak, \u03c3 e,\u03c4 k,` ), Re(\u03c3 e,\u03c4 k,` , a`) | e \u2208 E, \u03c4 \u2208 F(e), 1 \u2264 k \u2264 ` \u2264 3} \u222a\n{P (\u03c3e,\u03c4k,` , img\u03c4 (l)) | e \u2208 E, \u03c4 \u2208 F(e), l \u2208 L(e), 1 \u2264 k \u2264 ` \u2264 3}\nAC ={Re(a4, \u03c3e,\u03c44,4), Re(\u03c3 e,\u03c4 4,4 , a4) | e \u2208 E, \u03c4 \u2208 T(e) \u222a F(e)} \u222a\n{P (\u03c3e,\u03c44,4 , img\u03c4 (l)) | e \u2208 E, \u03c4 \u2208 T(e) \u222a F(e), l \u2208 L(e)}\nNext, we define the Boolean query qG. To this end, for each vertex i \u2208 V , let xi be a distinct variable; for each edge \u3008i, j\u3009 \u2208 E, let yi,j be a distinct variable; and, for each literal l occurring in G, let zl and z\u0304l be two distinct variables. Then, for each edge \u3008i, j\u3009 \u2208 E, let qG contain the following atoms.\n{B(xi), Re(xi, yi,j), Re(yi,j , xj), B(xj)} \u222a {P (yi,j , zl), Al(zl), d(zl, z\u0304l) | l \u2208 L(e)}\nFinally, we let \u03b1G = B(a4) be the assertion we want to show to be relevant and let \u03a3G = {Al | literal l occurs in G} \u222a {B} be the signature.\nNow, we outline the main idea behind this construction. ABox AG encodes two structures: a triangular structure AtT \u222a AfT and a cyclic structure AC . The former structure over individuals a1, a2, and a3 is such that edges in G that evaluate to true according to an arbitrary truth assignment \u03c4 can be mapped only to non-reflexive edges (cf. AtT ). In contrast, edges of G that evaluate to false according to \u03c4 can be mapped to an arbitrary edge (cf. AfT ). The latter, cyclic, structure AC over individual a4 (which is not asserted to be member of B) is such that G can be mapped over AC under all possible truth assignments.\nQuery qG is obtained from graph G by requiring that each vertex of the graph is a member of concept B, by reifying edges of the graph, and by incorporating the disjunction over literals. In particular, for each literal l in G, variables zl and z\u0304l represent the truth values of l and atom Al(zl) is used to enforce a particular truth assignment. Since ABox AG does not contain assertions over concept Al, each minimal explanation E\u03c4 for PG corresponds to a truth assignment \u03c4 for G. That is, such E\u03c4 contains, for each literal l in G, either Al(l) or Al(l\u0304). Also, by the definition of the ABox, query qG can be mapped over AtT \u222a AfT under minimal explanation E\u03c4 implies that \u03c4(G) is 3-colorable. In contrast, for every truth assignment \u03c4 , we can map query qG over the cyclic structure AC , provided that explanation E\u03c4 asserts the individual a4 to be a member of B. We are now ready to formally prove the correctness of our reduction.\n(\u21d2) Suppose there is a truth assignment \u03c4 such that \u03c4(G) is not 3-colorable; we show that assertion B(a4) is \u2286-relevant for PG. Consider the \u03a3-ABox E = {B(a4)} \u222a E\u03c4 , where E\u03c4 = {Al(l) | \u03c4(l) = t} \u222a {Al(l\u0304) | \u03c4(l) = f}. Clearly, E is an explanation. Indeed, we can match the query qG over the cyclic structure AC by mapping all variables xi of qG to (interpretation of) a4. Suppose there is a smaller explanation E \u2032 \u2282 E . Observe that E\u03c4 \u2286 E \u2032. This is because, for each literal l, concept Al does not occur in AG but does occur in qG. Then, E \\ {B(a4)} must be an explanation. Then qG can be matched over the triangular structure encoded in AG. Thus, \u03c4(G) is 3-colorable which contradicts the assumption.\n(\u21d0) Let E be a \u2286-minimal explanation for PG containing B(a4); we show that there exists a truth assignment \u03c4 such that \u03c4(G) is not 3-colorable. We first argue that for each literal l we have that either Al(l) \u2208 E or Al(l\u0304) \u2208 E . This follows from three considerations. First, due to the signature restriction, predicate d cannot occur in E . Second, for each literal l, query qG contains atoms Al(zl) and d(zl, z\u0304l), whereas ABox AG contains assertions d(l, l\u0304) and d(l\u0304, l). Third, for each literal l, concept Al occurs in qG with one and only variable zl. Therefore, since E is a minimal solution, we know that exactly one of Al(l) \u2208 E and Al(l\u0304) \u2208 E holds. Next, we define the truth assignment \u03c4 to the literals occurring in G. For each literal l in G, let \u03c4(l) = t if Al(l) \u2208 E , and \u03c4(l) = f if Al(l\u0304) \u2208 E . It is not difficult to argue that t(G) is not 3-colorable and thus G is a positive instance of non-cert3col.\nIndeed, if \u03c4(G) was 3-colorable, qG could be mapped over the triangle structure of AG making E \\ {B(a4)} a smaller explanation, which is a contradiction."}, {"heading": "5.4 Recognizing Explanations", "text": "Unsurprisingly, for UCQs and under both unrestricted and restricted explanation signatures, rec is in NP. Indeed, in order to solve the problem, we need to check consistency of the explanation with the ontology, and check whether the given tuple is in the certain answer to the query. The former is polynomial and the latter in NP.\nTheorem 5.8. For DL-LiteA, UCQs, and under both restricted and unrestricted explanation signatures, we have that rec is NP-complete. NP-hardness holds already for QAPs with an empty TBox and a CQ.\nProof. As usual, we first show that, under (un)restricted explanation signatures, rec is in NP. Then, we argue that, under unrestricted explanation signatures, the problem is NP-hard.\n(membership) Given a QAP P = \u3008T ,A, q,~c,\u03a3\u3009 and an ABox E , we devise an algorithm deciding rec as follows. Firstly, the procedure checks that E is indeed a \u03a3-ABox; this check is linear in E . Then it makes sure that extending the ontology with ABox E does not lead to an inconsistent theory; this can be checked in polynomial time (Artale et al., 2009). At last, it decides whether ~c occurs in cert(q, T ,A \u222a E); by Proposition 2.1 this is feasible in NP. Hence overall the algorithm runs in non-deterministic polynomial time.\n(hardness) We use essentially the same reduction from the existence of a homomorphism between directed graphs G and G\u2032 as in the proof of Theorem 5.2, the only difference being that instead of reducing it to the existence of an explanation over the signature \u03a3 = {B}, we leave the signature unrestricted (that is, \u03a3 = \u03a3(T ,A, q)), and reduce the problem to deciding whether E = {B(c)} is an explanation.\nIn case a preference order is in place, to recognize an explanation one has to check minimality as well. This check is coNP-hard for \u2286- and \u2264-minimality, leading to completeness for DP.\nTheorem 5.9. For DL-LiteA, UCQs, and under both restricted and unrestricted explanation signatures, we have that \u2264-rec and \u2286-rec are DP-complete. DP-hardness holds already for QAPs with an empty TBox and a CQ.\nProof. We first argue that, under (un)restricted explanation signatures, the two problems are in DP. Then, under unrestricted explanation signatures, we prove that \u2264-rec and \u2286-rec are DP-hard.\n(membership) Membership of a problem \u03a0 in DP can be shown by providing two languages L1 \u2208 NP and L2 \u2208 coNP, such that the set of all yes-instances of \u03a0 is L1 \u2229 L2. For \u2264-rec, simply let\nL1 = {(P, E) | E \u2208 expl(P)} L2 = {(P, E) | P has no explanation E \u2032 s.t. |E \u2032| < |E|}\nFor \u2286-rec, we take L1 as above and L2 = {(P, E) | P has no explanation E \u2032 s.t. E \u2032 ( E}.\n(hardness) DP-hardness is shown by a reduction from the problem HP-noHP. An instance of HP-noHP is given by two directed graphs G = (V,E) and G\u2032 = (V \u2032, E\u2032), where \u3008G,G\u2032\u3009 is a positive instance iff G has an Hamilton path and G\u2032 does not have one. For such a pair \u3008G,G\u2032\u3009, we define a QAP P = \u3008\u2205,A, q, \u3008\u3009,\u03a3\u3009 and a \u03a3-ABox E such that: (a) \u3008G,G\u2032\u3009 is a positive instance of HP-noHP iff E is a \u2264-minimal explanation for P, and (b) \u3008G,G\u2032\u3009 is a positive instance of HP-noHP iff E is a \u2286-minimal explanation for P. W.l.o.g., nodes in G and G\u2032 are disjoint and are ordinary individuals. Construct an ABox AG = {e(vi, vj) | (vi, vj) \u2208 E} \u222a {d(vi, vj) | vi, vj \u2208 V, vi 6= vi}. Intuitively, an assertion e(vi, vj) encodes an edge (vi, vj) in the graph G, whereas an assertion d(vi, vj) encodes that nodes vi and vj are distinct. The ABox AG\u2032 encodes G\u2032 in a similar way as before, using roles e\u2032 instead of e, and in addition it has an assertion A(v\u2032i) for each v \u2032 i \u2208 V \u2032. Take a set of fresh individuals O = {o1, . . . , o|V \u2032|} and an ABox AC = {e\u2032(oi, oj), d(oi, oj) | 1 \u2264 i 6= j \u2264 |V \u2032|}. Then the ABox A in P is defined as A = AG \u222a AG\u2032 \u222a AC .\nLet q = q1 \u2227 q\u20321 \u2227 q2 \u2227 q\u20322 \u2227 q3 be a Boolean CQ with\nq1 = {e(x1, x2), e(x2, x3), . . . , e(x|V |\u22121, x|V |))}, q\u20321 = {d(xi, xj) | vi, vj \u2208 V, vi 6= vj}, q2 = {e\u2032(y1, y2), e\u2032(y2, y3), . . . , e\u2032(y|V \u2032|\u22121, y|V \u2032|)}, q\u20322 = {d(yi, yj) | v\u2032i, v\u2032j \u2208 V \u2032, v\u2032i 6= v\u2032j}, q3 = {A(y1), . . . , A(y|V \u2032|)}.\nIntuitively, q1\u2227q\u20321 asks for a simple path with |V | vertices related via the role e. Analogously, q2 \u2227 q\u20322 asks for a simple path with |V \u2032| vertices related via the role e\u2032. Additionally, q3 asks that each node on the latter path satisfies A.\nFinally, we let E = {A(oi) | oi \u2208 O} and we let \u03a3 = \u03a3(T ,A, q). (\u21d2) Assume that \u3008G,G\u2032\u3009 is a positive instance of HP-noHP, and let a1, . . . a|V | be a Hamilton path in G. We show that E is a \u2264-minimal and a \u2286-minimal explanation for P. To this end, first take a mapping \u03c0 for variables in q such that \u03c0(x1) = a1, . . . , \u03c0(x|V |) = a|V | and \u03c0(y1) = o1, . . . , \u03c0(y|V \u2032|) = o|V \u2032|. Then clearly \u03c0 is a match for q in DBA\u222aE , and hence E is an explanation to P. Indeed, the subquery q1 \u2227 q\u20321 of q is fulfilled because a1, . . . a|V | is a Hamilton path in G, q2 \u2227 q\u20322 is fulfilled because AC has a clique of size |V \u2032|, while q3 is fulfilled by E . To assure minimality, assume towards a contradiction that there is an explanation E \u2032 with |E \u2032| < |E| or |E \u2032| \u2282 |E|. In any case, |E \u2032| < |V \u2032|. Assume \u03c0\u2032 is a match for q in DBA\u222aE \u2032 . Note that AG and AG\u2032 do not share individuals. Since q3 \u2227 q\u20322 asks for |V \u2032| elements satisfying A and |E \u2032| < |V \u2032|, \u03c0\u2032 must map the variables y1, . . . , y|V \u2032| to the |V \u2032| distinct individuals of AG\u2032 . Then the presence of q2 in q implies the existence of a Hamilton path in G\u2032. Contradiction.\n(\u21d0) Assume that E \u2208 expl\u2264(P) (resp., E \u2208 expl\u2286(P)) and \u03c0 is a match for q in DBA\u222aE . Note that e\u2032 does not occur in AG and e does not occur in AG\u2032 \u222aAC . Then by construction of q1 \u2227 q\u20321 and AG, \u03c0 maps the variables x1, . . . , x|V | to the |V | distinct constants of AG and G must have a Hamilton path. Towards a contradiction suppose G\u2032 also has a Hamilton path. Then by construction of AG\u2032 , q2 \u2227 q\u20322 \u2227 q3 has a match in DBAG\u2032 . This means we can build a match \u03c0\u2032 for q in DBAG\u2032 , which in turn means that \u2205 is an explanation to P. This contradicts the assumption that E is \u2264-minimal (resp., \u2286-minimal)."}, {"heading": "6. Discussion", "text": "In this section, we discuss some issues that remain for further investigation."}, {"heading": "6.1 Computing Explanations", "text": "In our complexity analysis for DL-LiteA, we have not considered the problem of computing solutions to query abduction problems. Nevertheless, we can infer upper bounds on the complexity of computing solutions to a QAP P from the presented results. If the input query in P is an instance query, then both computing an arbitrary solution and computing all minimal3 solutions is easy, since by Proposition 3.10, we only need to consider singleton candidate explanations, and their number is polynomially bounded. The problem of computing an arbitrary solution E remains polynomial for UCQs if the signature of P is unrestricted, since we can always obtain E by creating a suitable direct instantiation of one of the CQs in input (see Section 3.3). Instead, under restricted signatures, the total number of (minimal) solutions is in general exponential in the size of the signature \u03a3 and in the maximal size of each query occurring in the input UCQ; so computing all of them requires in general exponential time. It remains to be investigated whether these solutions can be enumerated with a polynomial delay (cf., Penaloza & Sertkaya, 2010). In the case of a restricted signature, however, the NP-harness result established in Theorem 5.2 implies that to compute a solution E one essentially essentially cannot do better than guessing the ABox E and deciding whether E \u2208 expl (P)."}, {"heading": "6.2 Data Complexity", "text": "In this work we have focused on combined complexity. With respect to data complexity (i.e., when the complexity is measured with respect to the size of the ABox only, while both the query and the TBox are considered fixed) and ontology complexity (i.e., when only the query is considered fixed), we observe that those inference tasks that we have shown to be NP-complete essentially rely on checking ontology consistency, and hence are in AC0 in data complexity (Calvanese et al., 2009). Moreover, by Corollaries 3.9 and 3.11, one can restrict the attention to explanations that are bounded by the size of the query, it follows that for a fixed query, there are only polynomially many explanations to be considered. Hence all our reasoning tasks are polynomial both in data complexity and in ontology complexity."}, {"heading": "6.3 Other Description Logics.", "text": "All the lower bounds proved in the paper do not rely on properties that are exclusive to DL-LiteA, hence they hold for other DLs as well. In fact, as we have mentioned, many lower bounds hold even in the absence of a TBox. As for the upper bounds, we have relied on DL-LiteA and on the existence of the perfect reformulation of a given query (see Proposition 2.1) only to argue that canonical explanations are small and have a restricted signature (more specifically, that they can be obtained by instantiating CQs in the perfect reformulation of the input query) and that query answering can be done in NP. For this reason, we expect our results to carry over to other DLs that admit \u201csmall\u201d explanations\n3. Since every ABox that is a superset of a solution is itself a solution, if we don\u2019t impose any minimality condition, there will always be an exponential number of solutions, provided that one exists.\nand for which query answering is in NP. For instance, both the lower and the upper bounds we have established hold for OWL 2 QL, which is obtained from DL-LiteA by forbidding functionality assertions and dropping the unique name assumption (as our results do not rely on functionality axioms, the unique name assumption is irrelevant).\nFor more expressive DLs, some bounds on the complexity of our reasoning tasks can also be inferred. In Corollary 5.1, we showed that for QAPs under unrestricted explanation signatures, deciding the existence of an explanation has the same complexity as ontology consistency without the UNA. Hence, the problem is ExpTime-complete for all the extensions of ALC in which standard reasoning (with or without the UNA) is also ExpTime-complete, like the well known SHIQ. If we consider restricted explanation signatures, the problem becomes significantly harder. This is witnessed by the lower bounds by Baader et al. (2010) stemming from CQ-emptiness (see Proposition 3.6): exist is already 2ExpTime hard for ALCI (Theorem 28 of Baader et al., 2010), and undecidable for ALCF (Theorem 29). For ALC, the authors have recently improved the lower bound of CQ-emptiness from ExpTime to NExpTime (personal communication). As mentioned in Section 3, their upper bounds do not apply directly to our setting (although we expect some of them to extend), and the precise characterization of the reasoning problems considered in this paper for expressive DLs remains open."}, {"heading": "7. Related Work", "text": "The problem of explaining missing query answers was first considered by the database community (Jagadish, Chapman, Elkiss, Jayapandian, Li, Nandi, & Yu, 2007). In the literature, we found three different models of explanation for missing answers, which differ on the notion of solution. First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer. Herschel and Herna\u0301ndez (2010) have generalized this latter model by considering UCQs with aggregation and grouping. Although this explanation model is closely related to ours, both the work by Huang et al. and by Herschel and Herna\u0301ndez tackle the problem from the point of view of computing solutions, whereas we are interested in outlining the computational complexity of the problem. Moreover, in the spirit of abductive reasoning, our solutions are of a declarative rather than operational nature\u2014that is, solutions are databases rather than a sequence of database operations.\nIn classical logic, abductive reasoning is a form of non sequitur argument, in which a conclusion B is not a logical consequence of the premises \u0393 (\u0393 6|= B), even though B is assumed to follow from the theory (Eiter & Gottlob, 1995). The aim is to find a set of formulas A such that \u0393 \u222a A |= B. Abductive reasoning is important also in the context of Description Logics (Elsenbroich, Kutz, & Sattler, 2006), where three orthogonal abductive problems have been studied. First, abduction has been studied to explain concepts\u2014that is, given two concepts C and D and a TBox T , concept abduction amounts to finding a\nconcept H such that T |= C uH v D and C uH is satisfiable w.r.t. T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T \u222a A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies. This problem consists in finding which additions need to be made to the ABox in order to force a set of ABox assertions to be logically entailed by the ontology. Along the same line, Du, Qi, Shen, and Pan (2011a) have considered this problem from a more practical perspective.\nMore recently, Du, Wang, Qi, Pan, and Hu (2011b) have defined the problem of abductive conjunctive query answering, which they use as the basis for a new approach to semantic matchmaking. Given a satisfiable DL ontologyO and a CQ q, a tuple ~c is called an abductive answer to q w.r.t. O if there exists a set E of ABox assertions such that O \u222a E |= q(~c). Similarly to our approach, the authors allow to restrict the signature over which abductive solutions can be constructed. In addition, one can limit the impact of E on O by specifying a set of closed predicates; for each assertion \u03b1 over a closed predicate we require that O \u222a E |= \u03b1 if and only if O |= \u03b1. The main contribution of the paper is a procedure for computing abductive answers to CQs over ontologies formulated in the DLP fragment of OWL 2, which is a fragment orthogonal to DL-LiteA in terms of expressiveness. Considering closed predicates in the context of DL-LiteA and QAPs is an interesting research direction."}, {"heading": "8. Conclusions", "text": "In this paper we have studied the problem of explaining negative answers to user queries over DL-LiteA ontologies. We have formalized the problem as an abductive task: given a (U)CQ q, a consistent ontology O and a tuple of constants ~c such that ~c is not in the certain answers of q over O, an explanation is defined as a set of ABox assertions that, when added to O, preserve its consistency and result in ~c being in the certain answers. We considered the special cases of allowing only a restricted signature for the assertions in the explanation, and having only an instance query rather than a full (U)CQ in the input. We have also considered preference orders between explanations, and studied two such orders: subset minimal and cardinality minimal explanations. For all these cases, we have obtained complexity bounds for four decision problems inspired in knowledge base abduction: deciding existence of an explanation (exist), deciding whether a given assertion occurs in all (nec) or some (rel) explanations, and recognizing explanations (rec). All our complexity bounds are tight, with the exception of rel for subset minimal explanations under unrestricted signatures, for which we leave open a gap between coNP-hardness and membership in \u03a3P2 .\nSpecifically, we have shown that in the case of instance queries all these decision problems are tractable, and in fact NL-complete, even when restricted explanations signatures and preference orders are simultaneously considered. The picture is significantly different for (U)CQs, as the results in Table 5.1 show. Indeed, tractability is always lost as soon as one considers restricted explanations signatures. If the signatures are not restricted, considering a preference order also results in intractability for most cases, the only exceptions being exist, which is always tractable, and nec, which is polynomial for subset minimal\nexplanations but PNP\u2016 for cardinality minimal ones. In contrast to nec, rel is harder, under common assumptions, for subset minimal than for cardinality minimal explanations. rec is hard even when the explanations signature is not restricted and no preference order is considered.\nIt would be interesting to apply this framework to other lightweight description logics, starting with those of the EL-family. Also, we would like to investigate other minimality criteria. For instance, semantic criteria allow one to reward explanations that are less/more constraining in terms of the models of an ontology."}, {"heading": "Acknowledgments", "text": "The authors would like to thank the anonymous referees for their careful reading of the submitted manuscript and their valuable comments. This work was partially supported by the Austrian Science Fund (FWF) grants P20840 and T515, the EU FP7 projects ACSI (Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, and Optique (Scalable End-user Access to Big Data), grant agreement n. FP7-318338, and by AlcatelLucent and EPSRC."}], "references": [{"title": "The DL-Lite family and relations", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Artale et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Artale et al\\.", "year": 2009}, {"title": "Query and predicate emptiness in description logics", "author": ["F. Baader", "M. Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In Proc. of the 12th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Baader et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2010}, {"title": "Complexity of abduction in the EL family of lightweight description logics", "author": ["M. Bienvenu"], "venue": "Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2008), pp. 220\u2013230. AAAI Press.", "citeRegEx": "Bienvenu,? 2008", "shortCiteRegEx": "Bienvenu", "year": 2008}, {"title": "The complexity of circumscription in description logics", "author": ["P.A. Bonatti", "C. Lutz", "F. Wolter"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Bonatti et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bonatti et al\\.", "year": 2009}, {"title": "Explanation in the DL-Lite family of description logics", "author": ["A. Borgida", "D. Calvanese", "M. Rodriguez-Muro"], "venue": "In Proc. of the 7th Int. Conf. on Ontologies, DataBases, and Applications of Semantics (ODBASE 2008),", "citeRegEx": "Borgida et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Borgida et al\\.", "year": 2008}, {"title": "Ontologies and databases: The DL-Lite approach", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodriguez-Muro", "R. Rosati"], "venue": "Semantic Technologies for Informations Systems \u2013 5th Int. Reasoning Web Summer School (RW 2009),", "citeRegEx": "Calvanese et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2009}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "The complexity of conjunctive query abduction in DL-Lite", "author": ["D. Calvanese", "M. Ortiz", "M. Simkus", "G. Stefanoni"], "venue": "In Proc. of the 24th Int. Workshop on Description Logic (DL 2011),", "citeRegEx": "Calvanese et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2011}, {"title": "Why not", "author": ["A. Chapman", "H.V. Jagadish"], "venue": "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,", "citeRegEx": "Chapman and Jagadish,? \\Q2009\\E", "shortCiteRegEx": "Chapman and Jagadish", "year": 2009}, {"title": "Towards practical ABox abduction in large OWL DL ontologies", "author": ["J. Du", "G. Qi", "Shen", "Y.-D", "J.Z. Pan"], "venue": "In Proc. of the 25th AAAI Conf. on Artificial Intelligence (AAAI", "citeRegEx": "Du et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Du et al\\.", "year": 2011}, {"title": "A new matchmaking approach based on abductive conjunctive query answering", "author": ["J. Du", "S. Wang", "G. Qi", "J.Z. Pan", "Y. Hu"], "venue": "In Proc. of the Joint Int. Semantic Tech. Conf. (JIST", "citeRegEx": "Du et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Du et al\\.", "year": 2011}, {"title": "The complexity of logic-based abduction", "author": ["T. Eiter", "G. Gottlob"], "venue": "J. of the ACM,", "citeRegEx": "Eiter and Gottlob,? \\Q1995\\E", "shortCiteRegEx": "Eiter and Gottlob", "year": 1995}, {"title": "A case for abductive reasoning over ontologies", "author": ["C. Elsenbroich", "O. Kutz", "U. Sattler"], "venue": "In Proc. of the 2nd Int. Workshop on OWL: Experiences and Directions (OWLED 2006),", "citeRegEx": "Elsenbroich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Elsenbroich et al\\.", "year": 2006}, {"title": "Explaining missing answers to SPJUA queries", "author": ["M. Herschel", "M.A. Hern\u00e1ndez"], "venue": "Proc. of the VLDB Endowment,", "citeRegEx": "Herschel and Hern\u00e1ndez,? \\Q2010\\E", "shortCiteRegEx": "Herschel and Hern\u00e1ndez", "year": 2010}, {"title": "Laconic and precise justifications in OWL", "author": ["M. Horridge", "B. Parsia", "U. Sattler"], "venue": "In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008),", "citeRegEx": "Horridge et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Horridge et al\\.", "year": 2008}, {"title": "On the provenance of non-answers to queries over extracted data", "author": ["J. Huang", "T. Chen", "A. Doan", "J. Naughton"], "venue": "Proc. of the VLDB Endowment,", "citeRegEx": "Huang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2008}, {"title": "A diagnostics framework based on abductive description logic reasoning", "author": ["T. Hubauer", "S. Grimm", "S. Lamparter", "M. Roshchin"], "venue": "In Proc. of the IEEE Int. Conf. on Industrial Technology,", "citeRegEx": "Hubauer et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hubauer et al\\.", "year": 2012}, {"title": "Making database systems usable", "author": ["H.V. Jagadish", "A. Chapman", "A. Elkiss", "M. Jayapandian", "Y. Li", "A. Nandi", "C. Yu"], "venue": "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,", "citeRegEx": "Jagadish et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Jagadish et al\\.", "year": 2007}, {"title": "ABox abduction in the description logic ALC", "author": ["S. Klarman", "U. Endriss", "S. Schlobach"], "venue": "J. of Automated Reasoning,", "citeRegEx": "Klarman et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Klarman et al\\.", "year": 2011}, {"title": "Explaining subsumption in description logics", "author": ["D.L. McGuinness", "A. Borgida"], "venue": "In Proc. of the 14th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "McGuinness and Borgida,? \\Q1995\\E", "shortCiteRegEx": "McGuinness and Borgida", "year": 1995}, {"title": "Usability issues in knowledge representation systems", "author": ["D.L. McGuinness", "P.F. Patel-Schneider"], "venue": "In Proc. of the 15th Nat. Conf. on Artificial Intelligence (AAAI", "citeRegEx": "McGuinness and Patel.Schneider,? \\Q1998\\E", "shortCiteRegEx": "McGuinness and Patel.Schneider", "year": 1998}, {"title": "OWL 2 Web Ontology Language Profiles", "author": ["B. Motik", "A. Fokoue", "I. Horrocks", "Z. Wu", "C. Lutz", "B.C. Grau"], "venue": "W3C Recommendation,", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "A tableaux-based calculus for abduction in expressive description logics: Preliminary results", "author": ["T.D. Noia", "E.D. Sciascio", "F.M. Donini"], "venue": "In Proc. of the 22rd Int. Workshop on Description Logic (DL 2009),", "citeRegEx": "Noia et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Noia et al\\.", "year": 2009}, {"title": "Computational Complexity", "author": ["C.H. Papadimitriou"], "venue": "Addison Wesley Publ. Co.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "Complexity of axiom pinpointing in the DL-Lite family of description logics", "author": ["R. Penaloza", "B. Sertkaya"], "venue": "In Proc. of the 19th Eur. Conf. on Artificial Intelligence (ECAI", "citeRegEx": "Penaloza and Sertkaya,? \\Q2010\\E", "shortCiteRegEx": "Penaloza and Sertkaya", "year": 2010}, {"title": "Complete problems involving boolean labelled structures and projection transactions", "author": ["I.A. Stewart"], "venue": "J. of Logic and Computation, 1 (6), 861\u2013882.", "citeRegEx": "Stewart,? 1991", "shortCiteRegEx": "Stewart", "year": 1991}, {"title": "How to ConQueR why-not questions", "author": ["Q.T. Tran", "Chan", "C.-Y"], "venue": "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,", "citeRegEx": "Tran et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Tran et al\\.", "year": 2010}, {"title": "The complexity of relational query languages", "author": ["M.Y. Vardi"], "venue": "Proc. of the 14th Symp. on Theory of computing (STOC 1982), pp. 137\u2013146.", "citeRegEx": "Vardi,? 1982", "shortCiteRegEx": "Vardi", "year": 1982}, {"title": "More complicated questions about maxima and minima, and some closures of NP", "author": ["K.W. Wagner"], "venue": "Theoretical Computer Science, 51 (1\u20132), 53\u201380.", "citeRegEx": "Wagner,? 1987", "shortCiteRegEx": "Wagner", "year": 1987}], "referenceMentions": [{"referenceID": 20, "context": "As argued by McGuinness and Patel-Schneider (1998), in order to meet usability requirements set by domain users, knowledge-based systems should be equipped with explanation algorithms for reasoning services.", "startOffset": 13, "endOffset": 51}, {"referenceID": 3, "context": "In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there.", "startOffset": 13, "endOffset": 35}, {"referenceID": 3, "context": "In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there. As OBDA systems answer queries under ontological constraints, explaining negative query answers is not trivial: these constraints need to be taken into account to understand why a required tuple is missing from the answers. A procedure for explaining negative query answers would then improve the usability of OBDA systems. For this reason, we formalize this explanation problem in the context of query answering over DL ontologies. Following Eiter and Gottlob (1995), we adopt abductive reasoning ; that is, explanations are set of facts that need to be asserted in the ABox to force the required tuple to be in the result.", "startOffset": 13, "endOffset": 714}, {"referenceID": 2, "context": "The idea of restricting the vocabulary of explanations is an adaptation of a concept introduced by Baader, Bienvenu, Lutz, and Wolter (2010), who study among others the query emptiness problem.", "startOffset": 107, "endOffset": 141}, {"referenceID": 6, "context": "DL-LiteA is a member of the DL-Lite family of DLs (Calvanese et al., 2007; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, & Rosati, 2009), which has been designed for dealing efficiently with large amounts of extensional information.", "startOffset": 50, "endOffset": 154}, {"referenceID": 6, "context": "Formally, if a DL-LiteA TBox contains (funct P ) or (funct P \u2212), then for each role R it does not contain Rv P or Rv P\u2212 (Calvanese et al., 2007).", "startOffset": 120, "endOffset": 144}, {"referenceID": 6, "context": "Following the common practice for the DLs of the DL-Lite family (Calvanese et al., 2007), we usually adopt the unique name assumption (UNA)\u2014that is, for each interpretation I and individual pair c 6= d, we require that cI 6= dI .", "startOffset": 64, "endOffset": 88}, {"referenceID": 27, "context": "Notice that, since we consider both the ontology and the query as part of the input, we are considering so-called combined complexity (Vardi, 1982).", "startOffset": 134, "endOffset": 147}, {"referenceID": 1, "context": "As mentioned in the introduction, deciding the existence of an explanation is related to the query emptiness problem studied by Baader et al. (2010). Since we will rely on that problem to infer some complexity bounds throughout the paper, we briefly introduce it here.", "startOffset": 128, "endOffset": 149}, {"referenceID": 1, "context": "Hence, all the hardness results for non-emptiness obtained by Baader et al. (2010) that hold for instance queries and UCQs apply also to the exist problem under restricted explanation signatures.", "startOffset": 62, "endOffset": 83}, {"referenceID": 5, "context": "For DL-LiteA, Calvanese et al. (2009) showed that negative inclusion axioms affect only the consistency of the given ontology, but do not contribute towards computing the certain answer; that is, ~c \u2208 cert(q, T \u2032,A\u2032) iff \u3008T \u2032,A\u2032\u3009 is consistent and ~c \u2208 cert(q, T ,A\u2032).", "startOffset": 14, "endOffset": 38}, {"referenceID": 0, "context": "Since reasoning without the UNA is PTime-complete for DL-LiteA (Artale et al., 2009), we obtain the following result.", "startOffset": 63, "endOffset": 84}, {"referenceID": 5, "context": "The algorithm then checks in polynomial time that E\u03be \\A is a \u03a3-ABox and that the ontology \u3008T ,A \u222a E\u03be\u3009 is consistent; it was shown by Calvanese et al. (2009) that the latter check is polynomial.", "startOffset": 133, "endOffset": 157}, {"referenceID": 1, "context": "DL-LiteA known as DL-Litecore given in Theorem 17 by Baader et al. (2010). For showing hardness in the second setting, we reduce the following NP-complete problem: given a pair of directed graphs G = (V,E) and G\u2032 = (V \u2032, E\u2032), decide whether there exists an homomorphism from G to G\u2032.", "startOffset": 53, "endOffset": 74}, {"referenceID": 28, "context": "(hardness) We give a reduction from OddMinVertexCover, which is P \u2016 -complete (Wagner, 1987).", "startOffset": 78, "endOffset": 92}, {"referenceID": 0, "context": "Then it makes sure that extending the ontology with ABox E does not lead to an inconsistent theory; this can be checked in polynomial time (Artale et al., 2009).", "startOffset": 139, "endOffset": 160}, {"referenceID": 5, "context": ", when only the query is considered fixed), we observe that those inference tasks that we have shown to be NP-complete essentially rely on checking ontology consistency, and hence are in AC0 in data complexity (Calvanese et al., 2009).", "startOffset": 210, "endOffset": 234}, {"referenceID": 1, "context": "This is witnessed by the lower bounds by Baader et al. (2010) stemming from CQ-emptiness (see Proposition 3.", "startOffset": 41, "endOffset": 62}, {"referenceID": 8, "context": "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.", "startOffset": 7, "endOffset": 35}, {"referenceID": 8, "context": "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database.", "startOffset": 7, "endOffset": 259}, {"referenceID": 8, "context": "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer.", "startOffset": 7, "endOffset": 444}, {"referenceID": 8, "context": "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer. Herschel and Hern\u00e1ndez (2010) have generalized this latter model by considering UCQs with aggregation and grouping.", "startOffset": 7, "endOffset": 671}, {"referenceID": 2, "context": "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008).", "startOffset": 2, "endOffset": 50}, {"referenceID": 2, "context": "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems.", "startOffset": 35, "endOffset": 107}, {"referenceID": 2, "context": "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T \u222a A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies.", "startOffset": 35, "endOffset": 383}, {"referenceID": 2, "context": "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T \u222a A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies. This problem consists in finding which additions need to be made to the ABox in order to force a set of ABox assertions to be logically entailed by the ontology. Along the same line, Du, Qi, Shen, and Pan (2011a) have considered this problem from a more practical perspective.", "startOffset": 35, "endOffset": 660}], "year": 2013, "abstractText": "In order to meet usability requirements, most logic-based applications provide explanation facilities for reasoning services. This holds also for Description Logics, where research has focused on the explanation of both TBox reasoning and, more recently, query answering. Besides explaining the presence of a tuple in a query answer, it is important to explain also why a given tuple is missing. We address the latter problem for instance and conjunctive query answering over DL-Lite ontologies by adopting abductive reasoning; that is, we look for additions to the ABox that force a given tuple to be in the result. As reasoning tasks we consider existence and recognition of an explanation, and relevance and necessity of a given assertion for an explanation. We characterize the computational complexity of these problems for arbitrary, subset minimal, and cardinality minimal explanations.", "creator": "TeX"}}}