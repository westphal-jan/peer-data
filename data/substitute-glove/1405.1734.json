{"id": "1405.1734", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-May-2014", "title": "Logic and Constraint Logic Programming for Distributed Constraint Optimization", "abstract": "The runs of Distributed Constraint Optimization Problems (DCOPs) having dropping closer, promising one still rigorous prior capturing parts problems (twitter. \u03b1. , platform - agent integration and resource allocation health) what because something produces and cannot although tempting acknowledged between came centralized tone. The carolina - of - the - painters in creates DCOPs creating from beginning providing as magazine - structuring vulnerabilities and blog - hoc formula_9 solving necessary. This text malfeasance made building four approaches DCOPs given is completely railroad and equations programming capabilities. In unlike, the paper chronicles saw use as a commerce constraint quadratic (end computable logic programming unlike in beyond fact) to 're held chicago - level function solving. The estimate lab show clearly arguments marketing provides contribute. takes governors - part - where - modernist DCOP system, on value of performer and system-level, opening the lobby to the that of more capabilities marketing ((800). protein. , data strategies, complex budgetary) any motivation DCOPs.", "histories": [["v1", "Wed, 7 May 2014 20:02:09 GMT  (329kb,D)", "https://arxiv.org/abs/1405.1734v1", "To appear in Theory and Practice of Logic Programming (TPLP)"], ["v2", "Wed, 14 May 2014 22:55:33 GMT  (343kb,D)", "http://arxiv.org/abs/1405.1734v2", "To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.MA cs.AI", "authors": ["tiep le", "enrico pontelli", "tran cao son", "william yeoh"], "accepted": false, "id": "1405.1734"}, "pdf": {"name": "1405.1734.pdf", "metadata": {"source": "CRF", "title": "Logic and Constraint Logic Programming for Distributed Constraint Optimization", "authors": ["Tiep Le", "Enrico Pontelli", "Tran Cao Son", "William Yeoh"], "emails": ["tile@cs.nmsu.edu)", "epontell@cs.nmsu.edu)", "tson@cs.nmsu.edu)", "wyeoh@cs.nmsu.edu)"], "sections": [{"heading": null, "text": "KEYWORDS: DCOP, CLP, Implementation"}, {"heading": "1 Introduction", "text": "Distributed Constraint Optimization Problems (DCOPs) are descriptions of constraint optimization problems where variables and constraints are distributed among a group of agents, and where each agent can only interact with agents that share a common constraint (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012). Researchers have realized the importance of DCOPs, as they naturally capture real-world scenarios, where a collective tries to achieve optimal decisions, but without the ability to collect all information about resources and limitations into a central solver. For example, DCOPs have been successfully used to model domains like resource management and scheduling (Maheswaran et al. 2004; Farinelli et al. 2008; Le\u0301aute\u0301 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al. 2005; Zivan et al. 2009; Stranders et al. 2009), and smart grids (Kumar et al. 2009; Gupta et al. 2013).\nThe DCOP field has grown at a fast pace in recent years. Several popular implementations of DCOP solvers have been created (Le\u0301aute\u0301 et al. 2009; Sultanik et al. 2007; Ezzahir et al. 2007). The majority of the existing DCOP algorithms can be placed in one of three classes. Search-based algorithms perform a distributed search over the space of solutions to determine the optimum (Modi et al. 2005; Gershman et al. 2009; Zhang et al. 2005; Yeoh et al. 2010). Inference-based algorithms, on the other hand, make use of techniques\nar X\niv :1\n40 5.\n17 34\nv2 [\ncs .M\nA ]\n1 4\nfrom dynamic programming to propagate aggregate information among agents (Petcu and Faltings 2005; Farinelli et al. 2008; Vinyals et al. 2009); these two classes provide a different balance between memory requirements and number of messages exchanged. Another class of methods includes approximated algorithms that rely on sampling (Ottens et al. 2012; Nguyen et al. 2013) applied to the overall search space.\nThe driving objective of the investigation discussed in this paper is to understand the role that logic programming can play in solving DCOPs. In particular, existing popular DCOP solvers (e.g., the frequently used FRODO platform (Le\u0301aute\u0301 et al. 2009)) are ad-hoc systems, with a relatively closed structure, and making use of ad-hoc dedicated solvers for constraint handling within each agent. Thus, a question we intend to address with this paper is whether the use of a general infrastructure for constraint solving within each agent of a DCOP would bring benefits compared to the ad-hoc solutions of the existing implementations. We propose a general infrastructure (based on distributed dynamic programming) for the communication among agents, guaranteeing completeness of the system. The platform enables the use of a generic logic programming solver (e.g., a Constraint Logic Programming system) to handle the local constraints within each agent; the generality of the platform will also allow the use of distinct logic programming paradigms within each agent (e.g., Answer Set Programming).\nThe paper discusses the overall logic programming infrastructure, along with the details of the modeling of each agent using constraint logic programming. We provide some preliminary experimental results, validating the viability and effectiveness of this research direction for DCOPs. The results also highlight the potential offered by logic programming to provide an implicit representation of hard constraints in DCOPs, enabling a more effective pruning of the search space and reducing memory requirements."}, {"heading": "2 Background", "text": "In this section, we provide a brief review of basic concepts from DCOPs. We assume that the readers have familiarity with logic and constraint logic programming; in particular, we will refer to the syntax of the clpfd library of SICStus Prolog (Carlsson et al. 2012)."}, {"heading": "2.1 Distributed Constraint Optimization Problems (DCOPs)", "text": "A DCOP (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012) is described by a tuple P = (X,D,F,A, \u03b1) where: (i) X = {x1, . . . , xn} is a set of variables; (ii) D = {Dx1 , . . . , Dxn} is a set of finite domains, where each Dxi is the domain of variable xi; (iii) F = {f1, . . . , fm} is a set of utility functions (a.k.a. constraints), where each fj : Dxj1 \u00d7Dxj2 \u00d7 . . .\u00d7Dxjk 7\u2192 N\u222a {\u2212\u221e, 0} specifies the utility of each combination of values of variables in its scope scp(fj) = {xj1, . . . , xjk} \u2286 X; (iv) A = {a1, . . . , ap} is a set of agents; and (v) \u03b1 : X \u2192 A maps each variable to an agent.\nWe assume the domains Dx to be finite intervals of integer numbers. A substitution \u03b8 of a DCOP P is a value assignment for the variables in X s.t. \u03b8(x) \u2208 Dx for each x \u2208 X. Its utility is utP(\u03b8) = \u2211m i=1 fi(scp(fi)\u03b8), i.e., the evaluation of all utility functions on it. A solution \u03b8 is a substitution such that utP(\u03b8) is maximal, i.e., there is no other substitution \u03c3 such that utP(\u03b8) < utP(\u03c3). SolnP denotes the set of solutions of P. Each DCOP P is associated with a constraint graph, denoted with GP = (X,EP),\nwhere X is a set of nodes which correspond to DCOP variables, and EP is a set of edges which connect pairs of variables in the scope of the same utility function."}, {"heading": "2.2 Distributed Pseudo-tree Optimization Procedure (DPOP)", "text": "DPOP (Petcu and Faltings 2005) is one of the most popular complete algorithms for the distribution resolution of DCOPs; as discussed in several works, it has several nice properties (e.g., it requires only a linear number of messages), and it has been used as the foundations for several more advanced algorithms (Petcu et al. 2006; Petcu and Faltings 2007; Petcu et al. 2007).\nThe premise of DPOP is the generation of a DFS-Pseudo-tree\u2014composed of a subgraph of the constraint graph of a DCOP. The pseudo-tree has a node for each agent in the DCOP; edges meet the following conditions: (a) If an edge (a1, a2) is present in the pseudo-tree, then there are two variables x1, x2 s.t. \u03b1(x1) = a1, \u03b1(x2) = a2, and (x1, x2) \u2208 EP ; (b) The set of edges describes a rooted tree; (c) For each pair of variables xi, xj s.t. \u03b1(xi) 6= \u03b1(xj) and (xi, xj) \u2208 EP , we have that \u03b1(xi) and \u03b1(xj) appear in the same branch of the pseudo-tree. \u03b1(xi) and \u03b1(xj) are also called the pseudo-parent and pseudo-child of each other.\nAlgorithms exist (e.g., (Hamadi et al. 1998)) to support the distributed construction of a DFS-Pseudo-tree. Given a DCOP P, we will refer to a DFS-Pseudo-tree of P by TP = (A,ETP). We will also denote with a 7\u2192P b if there exists a sequence of edges (a1, a2), (a2, a3), . . . , (ar\u22121, ar) in ETP such that a = a1 and b = ar; in this case, we say that b is reachable from a in TP . Given an agent a, we denote with SP(a) the set of agents in TP in the subtree rooted at a (including a itself). The DPOP algorithm operates in two phases:\n\u2022 UTIL Propagation: During this phase, messages flow bottom-up in the tree, from the leaves towards the root. Given a node N , the UTIL message sent by N\nsummarizes the maximum utility achievable within the subtree rooted at N for each combination of values of variables belonging to the separator set (Dechter 2003) of N . The agent does so by summing the utilities in the UTIL messages received from its children agents, and then projecting out its own variables by optimizing over them. \u2022 VALUE Propagation: During this phase, messages flow top-down in the tree. Node N determines an assignment to its own variables that produces the maximum\nutility based on the assignments given by the ancestor nodes; this assignment is then propagated as VALUE messages to the children. Let us consider a DCOP with X = {x1, x2, x3, x4}, each with Dxi = {0, 1} and with binary constraints described by the graph (and pseudo-tree) and utility table (assuming\ni > j) in Fig. 1 (left and middle). For simplicity, we assume a single variable per agent. Node x2 will receive two UTIL messages from its children; for example, the message from x3 will indicate that the best utilities are 20 (for x2 = 0) and 8 (for x2 = 1). In turn, x2 will compose the UTIL messages with its own constraint, to generate a new utility table, shown in Fig. 1 (right). This will lead to a UTIL meassage sent to x1 indicating utilities of 45 for x1 = 0 and 48 for x1 = 1. In the VALUE phase, node x1 will generate an assignment of x1 = 1, which will be sent as a VALUE message to x2; in turn, x2 will trigger the assignment x2 = 0 as a VALUE message to its children."}, {"heading": "3 Logic-Programing-based DPOP (LP-DPOP)", "text": "In this section, we illustrate the LP-DPOP framework, designed to map DCOPs into logic programs that can be solved in a distributed manner using the DPOP algorithm.\nAgent a\nAgent b\nDFS-Pseudo-tree Parent\nDFS-Pseudo-tree Children\ntable_max_b table_info_b\ntable_max_a table_info_a solution_c\nsolution_a\nAgent c\nFig. 2. Overall Communication Needs\nAgent Description (FRODO)\nvariables domains\nutilities\n!a\nLP variables/domains\nUtility Facts\nPseudo-tree\nAlgorithm\nDFS Pseudo\nTree Computation\nFig. 3. Components of an Agent in LPDPOPfacts"}, {"heading": "3.1 Overall Structure", "text": "The overall structure of LP-DPOP is summarized in Fig. 2. Intuitively, each agent a of a DCOP P is mapped to a logic program \u03a0a. Agents exchange information according to the communication protocol of DPOP. These exchanges are represented by collections of facts that are communicated between agents. In particular,\n\u2022 UTIL messages from agent b to agent a are encoded as facts table max b(L), where L is a list of [u, v1, . . . , vk]. Each one is a row of the UTIL message, where u\nis the maximum utility for the combination of values v1, . . . , vk. It is also necessary to transmit an additional message describing the variables being communicated: table info b([v(x1, low1, high1), . . . , v(xk, lowk, highk)]). This message identifies the names of the variables being communicated and their respective domains. It should be mentioned that the UTIL message from b to a can contain variables belonging to some ancestors of a. \u2022 VALUE messages from agent c to agent a are encoded as facts solution c(Var ,Val), where Var is the name of a variable and Val is the value assigned to it."}, {"heading": "3.2 LP-DPOP Execution Model", "text": "Computing DFS-PseudoTree: One can use existing off-the-shelf distributed algorithms to construct pseudo-trees. A commonly used algorithm is the distributed DFS\nprotocol (Hamadi et al. 1998), that creates a DFS tree with the max-degree heuristic as the variable-ordering heuristic. The max-degree heuristic favors variables with larger numbers of constraints to be higher up in the pseudo-tree.\nSolving a DCOP: The actual agent a is implemented by a logic program \u03a0a. In the context of this paper, the logic program is a CLP program, whose entry point is a predicate called agent:\nagent :- agent(ID),\n(\\+is_leaf(ID) -> get_utils; true), (\\+is_root(ID) -> compute_utils, send_utils, get_value; true), (\\+is_leaf(ID) -> compute_value, send_value; compute_value).\nThe logic program implements the compute utils and the compute value predicates. They are described in the next section."}, {"heading": "3.3 Modeling LP-DPOP as CLP", "text": "In this section, we illustrate the structure of the logic program that encodes each individual agent. We propose two alternative models. The first one follows the model illustrated in Fig 3: the input DCOP is described using the standardized format introduced by the FRODO DCOP platform (Le\u0301aute\u0301 et al. 2009).\nIn the first model, referred to as LP-DPOPfacts, the FRODO model is literally translated into collections of logic programming facts. The second model, referred to as LPDPOPrules, follows the more \u201crealistic\u201d option of capturing the hard constraints present in the DCOP model explicitly as logical constraints, instead of forcing their mapping to explicit utility tables (as automatically done by FRODO).\n3.3.1 LP-DPOPfacts\nThe logic program \u03a0a modeling an agent is composed of four primary modules, as illustrated in Fig. 3:\n1. Agent, Variables and Domains: the core components of the agent variables and\ndomains are encoded in \u03a0a by facts of the form:\n\u25e6 A single fact agent(a) describing the identity of the agent; \u25e6 For each variable xi with domain Dxi , such that \u03b1(xi) = a or \u03b1(xj) = a for some variable xj such that (xi, xj) \u2208 EP : a fact variable(xi,min(Dxi),max(Dxi)) and a fact owner(\u03b1(xi), xi).\n2. DFS-Pseudo-Tree: the local position of a in the DFS-Pseudo-tree is described by:\n\u2212 facts of the form child(b) where b is agent s.t. (a, b) \u2208 ETP ; \u2212 a fact parent(c) where c is the (only) agent s.t. (c, a) \u2208 ETP ; and \u2212 a fact ancestor(c) where c is any non-parent ancestor of a in the pseudo-tree,\ni.e., any agent c s.t. (c, a) 6\u2208 ETP and c 7\u2192P a. 3. Utilities/Constraints: the constraints are obtained as direct translation of the utility\ntables in the FRODO representation: for each constraint fj , there is a fact of the form constraint fj(L), where L is a list containing lists [fj(v1, . . . vr), v1, . . . , vr] for each assignement {x1/v1, . . . , xr/vr} to the variables of scp(fj) = {x1, . . . , xr} where fj(v1, . . . , vr) 6= \u2212\u221e. Each constraint is further described by the facts: (i) a fact constraint(fj), identifying the name of each constraint, (ii) a fact scope(fj , xi)\nfor each xi \u2208 scp(fj), identifying the variables contributing to the scope of the constraint, and (iii) facts of the form constraint agent(fj , ar), identifying agents that has variables in the scope of the constraint.\n4. Resolution Engine: a collection of rules that implement the compute utils and\ncompute value\u2014these are described below. The core of the computation of the UTIL message is implemented within the compute utils predicate. Intuitively, the construction of the UTIL message is mapped to a CLP problem. Its construction and resolution can be summarized as follows:\n... define_variables(L,Low,High),\ndefine_constraints(L,Util), generate_utils(Low,High,UTILITIES), ...\nThe steps can be summarized as follows:\n\u2022 The define variables predicate is used to collect the variables that belong to the agent and its ancestors (returned in the list Low and High, respectively), and\nfor each variable generates a corresponding CLP domain variable. The collecting variables phase is based on the variable facts (describing all variables owned by the agent) and the variables indicated in the table info b messages received from the children; these may contain variables that belong to pseudo-parents in the tree and unknown to the agent a. To enable interpretation of the CLP variables, two facts low vars(Low) and high vars(High) are created in this phase. In the latter phase, for each Xi in the collection of variables collected from the former phase calls Xi in `..m where ` and m are the minimum and maximum value of Xi\u2019s domain which are either known to the agent or given in received the table info b message. \u2022 The predicate define constraints creates CLP constraints capturing the utilities the agent has to deal with\u2014these include the utilities described by each\ntable max b message received from a child b and the utilities fj of the agent a s.t. scp(fj) does not contain any variables in \u22c3\n(a,b)\u2208ETP{x \u2208 X | \u03b1(x) = b}. For each utility fi of these utilities (described by a list of lists), the predicate define constraints introduces a constraint of the form:\ntable([[Ui, X1, .., Xr]] , L, [order(id3), consistency(domain)])\nwhere:\n\u25e6 X1, . . . , Xr are the CLP variables which were created by define variables and correspond to the scope of this utility. \u25e6 L is the list of lists given in constraint fi(L); \u25e6 Ui is a new variable introduced for each utility fi. The final step of the define constraints is to introduce the additional CLP constraint Util#= U1+U2+. . . +Us where Ui are the variables introduced in the table constraints and Util is a brand new variable.\n\u2022 The generate utils predicate has the following general structure: generate_utils(Lo, Hi, UTILITIES) :-\nfindall([Util|Hi], (labeling([],Hi),find_max_util(Lo,Hi,Util)),UTILITIES).\nfind_max_util(Lo, Hi, Util) :-\nmaximize(labeling([ff],Lo), Util), assert(agent_a_table_max(Lo,Hi)).\nThe core of the computation of the VALUE message takes advantage of the fact that the combination of variables producing the maximum values are asserted as\nagent a table max facts during the UTILs phase, enabling a simple lookup to compute the solution. This can be summarized as follows:\n... high_vars(H), findall(Value,(member(Name,H),solution(Name,Value)), Sols), agent_a_table_max(Low,Sols), low_vars(Lo), length(Lo,Len), I in 1..Len, findall(solution(Name,Value),\n(indomain(I), nth1(I,Lo,Name), nth1(I,Low,Value)), VALUES), ...\n3.3.2 LP-DPOPrules\nAn alternative encoding takes advantage of the fact that the utilities provided in the utility table of a FRODO encoding are the results of enumerating the solutions of hard constraints. A hard constraint captures a relation fj(x1, . . . , xr)\u2295u where \u2295 is a relational operator, and u is an integer. This is typically captured in FRODO as a table, containing all tuples of values from Dx1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7Dxr that satisfy the relation (with a utility value of 0), and the default utility value of \u2212\u221e assigned to the remaining tuples.\nThis utility can be directly captured in CLP, thus avoiding the transition through the\ncreation of an explicit table of solutions:\nhard constraint fj(X1, . . . , Xr) : \u2212f\u0302j(X1, . . . , Xr)\u2295\u0302u\nwhere f\u0302j and \u2295\u0302 are the CLP operators corresponding to fj and \u2295. For example, the smart grid problems used in the experimental section uses hard constraints encoded as hard constraint eq0(X1,2, X2,1) :\u2212 X1,2 + X2,1# = 0 The resulting encoding of the UTIL value computation will modify the encoding of LPDPOPfacts as shown below\nconstraint_f(L), table([[U,X_1,...,X_r]],L,_) \u21d2 hard_constraint_f(X_1,...,X_r)"}, {"heading": "3.4 Some Implementation Details", "text": "The current implementation of LP-DPOP makes use of the Linda (Carriero et al. 1994) infrastructure of SICStus Prolog (Carlsson et al. 2012) to handle all the communication.\nIndependent agents can be launched on different machines and connect to a Linda\nserver started on a dedicated host. Each agent has a main clause of the type\nrun agent :- prolog flag(argv, [Host,Port]),linda client(Host:Port),agent.\nThe operations of sending a UTIL message from b to the parent a is simply realized\nby a code fragment of the type\nsend util(Vars,Utils,To):- out(msg to(To),[table info b(Vars),table max b(Utils)]).\nThe corresponding reception of UTIL message by a will use a predicate of the form\nget util(Vars,Utils,Me):- in(msg to(Me), [table info b(Vars),table max b(Utils)]).\nThe communication of VALUE messages is analogous. get value and send value are\nsimple wrappers of the predicates discussed above."}, {"heading": "3.5 Some Theoretical Considerations", "text": "The soundness and completeness of the LP-DPOP system is a natural consequence of the soundness and completeness properties of the DPOP algorithm, along with the soundness\nand completeness of the CLP(FD) solver of SICStus Prolog. Since LP-DPOP emulates the computation and communication operations of DPOP, each \u03a0a program is a correct and complete implementation of the corresponding agent a.\nIn the worst case, each agent in LP-DPOP, like DPOP, needs to compute, store, and send a utility for each combination of values of the variables in the separator set of the agent. Therefore, like DPOP, LP-DPOP also suffers from an exponential memory requirement, i.e., the memory requirement per agent isO(maxDomw), wheremaxDom = argmaxi |Di| and w is the induced width of the pseudo-tree."}, {"heading": "4 Experimental Results", "text": "We compare two implementations of the LP-DPOP framework, LP-DPOPfacts and LPDPOPrules with a publicly-available implementation of DPOP, which is available on the FRODO framework (Le\u0301aute\u0301 et al. 2009). All experiments are conducted on a Quadcore 3.4GHz machine with 16GB of memory. The runtime of the algorithms are measured using the simulated runtime metric (Sultanik et al. 2007). The timeout is set to 10 minutes. Two domains, randomized graphs and smart grids, were used in the experiments.\nRandomized Graphs: A randomized graph generated using the model in (Erdo\u0308s and Re\u0301nyi 1959) with the input parameters n (number of nodes) and M (number of binary edges) will be used as the constraint graph of a DCOP instance P. Each instance P = (X,D,F,A, \u03b1) is generated using five parameters: |X|, |A|, the domain size d of all variables, the constraint density p1 (defined as the ratio between the number of binary edges M and the maximum number of binary edges among |X| nodes), and the constraint tightness p2 (defined as the ratio between the number of infeasible value combinations, that is, their utility equals \u2212\u221e, and the total number of value combinations).\nWe conduct experiments, where we vary one parameter in each experiment. The \u201cdefault\u201d value for each experiment is |A| = 5, |X| = 15, d = 6, p1 = 0.6, and p2 = 0.6. As the utility tables of instances of this domain are randomly generated, the programs for LP-DPOPrules and LP-DPOPfacts are very similar. Thus, we only compare FRODO with LP-DPOPfacts. Table 1 shows the percentage of instances solved and the average simulated runtime (in ms) for the solved instances; each data point is an average over 50 randomly generated instances. If an algorithm fails to solve more than 85% of instances in a specific configuration, then we consider that it fails to solve problems with that configuration.\nThe results show that LP-DPOPfacts is able to solve more problems and is faster than DPOP when the problem becomes more complex (i.e., increasing |X|, d, p1, or p2). The reason is that at a specific percentage of hard constraints (i.e., p2 = 0.6), LP-DPOP facts is able to prune a significant portion of the search space. Unlike DPOP, LP-DPOPfacts does not need to explicitly represent the rows in the UTIL table that are infeasible, resulting in lower memory usage and runtime needed to search through search space. The size of the search space pruned increases as the complexity of the instance grows, making the difference between the runtimes of LP-DPOPfacts and DPOP significant.\nSmart Grids: A customer-driven microgrid (CDMG), one possible instantiation of the smart grid problem, has recently been shown to subsume several classical power system sub-problems (e.g., load shedding, demand response, restoration) (Jain et al. 2012). In this domain, each agent represents a node with consumption, generation, and transmis-\nsion preference, and a global cost function. Constraints include the power balance and no power loss principles, the generation and consumption limits, and the capacity of the power line between nodes. The objective is to minimize a global cost function. CDMG optimization problems are well-suited to be modeled with DCOPs due to their distributed nature. Moreover, as some of the constraints in CDMGs (e.g., the power balance principle) can be described in functional form, they can be exploited by LP-DPOPrules. For this reason, both LP-DPOPfacts and LP-DPOPrules were used in this domain.\nWe conduct experiments on a range of CDMG problem instances generated using the four network topologies following the IEEE standards and varying the domain of the variables.1 Fig. 4(a) displays the topology of the IEEE 13 Bus network, where rectangles represent nodes/agents, filled circles represent variables, and links between variables represent constraints. The initial configuration of the CDMG and the precise equations used in the generation of the problems can be found in (Jain et al. 2012). The experimental results for the four largest standards, the 13, 34, 37, and 123 Bus Topology,2 are shown in Fig. 4(b), 4(c), 4(d), and 4(e), respectively. We make the following observations:\n\u2022 LP-DPOPrules is the best among the three systems both in terms of runtime and scalability in all experiments. LP-DPOPrules\u2019s memory requirement during its exe-\ncution is significant smaller and increases at a much slower pace than other systems. This indicates that the rules used in expressing the constraints help the constraint solver to more effectively prune the search space resulting in a better performance. \u2022 LP-DPOPfacts is slower than DPOP in all experiments in this domain. It is because LP-DPOPfacts often needs to backtrack while computing the UTIL message, and\neach backtracking step requires the look up of several related utility tables\u2014some\n1 www.ewh.ieee.org/soc/pes/dsacom/ 2 In 123 Bus Topology\u2019s experiments, a multi-server version of LP-DPOPfacts and LP-DPOPrules was used because of the limit on the number of concurrent streams supported by Linda and SICStus. FRODO cannot be run on multiple machines.\ntables can contain many tuples (e.g., one agent in the 13 Bus problem with domain size of 23 could have 3, 543, 173 facts). We believe that this is the source of the weak performance of LP-DPOPfacts."}, {"heading": "5 Conclusion and Future Work", "text": "In this paper, we presented a generic infrastructure built on logic programming to address problems in the area of DCOP. The use of a generic CLP solver to implement the individual agents proved to be a winning option, largely outperforming existing DCOP technology in terms of speed and scalability. The paper also makes the preliminary case for a different encoding of DCOPs w.r.t. existing technologies; the ability to explicitly model hard constraints provides agents with additional knowledge that can be used to prune the search space, further enhancing performance.\nThis is, in many regards, a preliminary effort that will be expanded in several directions. First, we believe that different types of DCOP problems may benefit from different types of local solvers within each agent; we currently explore the use of ASP as an alternative for the encoding the agents. The preliminary results are competitive and superior to those produced by DPOP. Classifying DCOP problems in such a way to enable the automated selection of what type of LP-based solver to use is an open research question to be addressed. The strong results observed in the use of implicit encodings of hard constraints also suggest the need of developing DCOP description languages that separate hard and soft constraints and do not require the explicit representation for all constraints.\nOn the other direction, we view this work as a feasibility study towards the development of distributed LP models (e.g., Distributed ASP). Paradigms like ASP are highly suitable to capture the description of individual agents operating in multi-agent environments; yet, ASP does not inherently provide the capability of handling a distributed ASP computation with properties analogous to those found in DCOP. We believe the models and infrastructure described in this paper could represent the first step in the direction of creating the foundations of DASP and other distributed logic programming models."}], "references": [{"title": "SICStus Prolog User\u2019s Manual", "author": ["M. Carlsson et al."], "venue": "Tech. rep., Swedish Institute of Computer Science.", "citeRegEx": "al.,? 2012", "shortCiteRegEx": "al.", "year": 2012}, {"title": "The Linda Alternative to Message Passing Systems", "author": ["N. Carriero", "D. Gelernter", "T. Mattson", "A. Sherman"], "venue": "Parallel Computing 20, 4, 633\u2013655.", "citeRegEx": "Carriero et al\\.,? 1994", "shortCiteRegEx": "Carriero et al\\.", "year": 1994}, {"title": "Constraint processing", "author": ["R. Dechter"], "venue": "Elsevier Morgan Kaufmann.", "citeRegEx": "Dechter,? 2003", "shortCiteRegEx": "Dechter", "year": 2003}, {"title": "On random graphs I", "author": ["P. Erd\u00f6s", "A. R\u00e9nyi"], "venue": "Publicationes Mathematicae Debrecen 6, 290.", "citeRegEx": "Erd\u00f6s and R\u00e9nyi,? 1959", "shortCiteRegEx": "Erd\u00f6s and R\u00e9nyi", "year": 1959}, {"title": "DisChoco: A platform for distributed constraint programming", "author": ["R. Ezzahir", "C. Bessiere", "M. Belaissaoui", "E.H. Bouyakhf"], "venue": "Proceedings of the Distributed Constraint Reasoning Workshop. 16\u201327.", "citeRegEx": "Ezzahir et al\\.,? 2007", "shortCiteRegEx": "Ezzahir et al\\.", "year": 2007}, {"title": "Decentralised coordination of low-power embedded devices using the Max-Sum algorithm", "author": ["A. Farinelli", "A. Rogers", "A. Petcu", "N. Jennings"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 639\u2013646.", "citeRegEx": "Farinelli et al\\.,? 2008", "shortCiteRegEx": "Farinelli et al\\.", "year": 2008}, {"title": "Distributed coordination through anarchic optimization", "author": ["S. Fitzpatrick", "L. Meertens"], "venue": "Distributed Sensor Networks: A Multiagent Perspective, V. Lesser, C. Ortiz, and M. Tambe, Eds. Kluwer, 257\u2013295.", "citeRegEx": "Fitzpatrick and Meertens,? 2003", "shortCiteRegEx": "Fitzpatrick and Meertens", "year": 2003}, {"title": "Asynchronous Forward-Bounding for distributed COPs", "author": ["A. Gershman", "A. Meisels", "R. Zivan"], "venue": "Journal of Artificial Intelligence Research 34, 61\u201388.", "citeRegEx": "Gershman et al\\.,? 2009", "shortCiteRegEx": "Gershman et al\\.", "year": 2009}, {"title": "Solving customer-driven microgrid optimization problems as DCOPs", "author": ["S. Gupta", "P. Jain", "W. Yeoh", "S. Ranade", "E. Pontelli"], "venue": "Proceedings of the Distributed Constraint Reasoning Workshop. 45\u201359.", "citeRegEx": "Gupta et al\\.,? 2013", "shortCiteRegEx": "Gupta et al\\.", "year": 2013}, {"title": "Distributed intelligent backtracking", "author": ["Y. Hamadi", "C. Bessi\u00e8re", "J. Quinqueton"], "venue": "Proceedings of the European Conference on Artificial Intelligence (ECAI). 219\u2013223.", "citeRegEx": "Hamadi et al\\.,? 1998", "shortCiteRegEx": "Hamadi et al\\.", "year": 1998}, {"title": "Capacity discovery in customer-driven micro-grids", "author": ["P. Jain", "S. Ranade"], "venue": "Proceedings of the North American Power Symposium (NAPS). 1\u20136.", "citeRegEx": "Jain and Ranade,? 2009", "shortCiteRegEx": "Jain and Ranade", "year": 2009}, {"title": "Optimum operation of a customerdriven microgrid: A comprehensive approach", "author": ["P. Jain", "S. Ranade", "S. Gupta", "E. Pontelli"], "venue": "Proceedings of International Conference on Power Electronics, Drives and Energy Systems (PEDES). 2012. 1\u20136.", "citeRegEx": "Jain et al\\.,? 2012", "shortCiteRegEx": "Jain et al\\.", "year": 2012}, {"title": "Asynchronous algorithms for approximate distributed constraint optimization with quality bounds", "author": ["C. Kiekintveld", "Z. Yin", "A. Kumar", "M. Tambe"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 133\u2013140.", "citeRegEx": "Kiekintveld et al\\.,? 2010", "shortCiteRegEx": "Kiekintveld et al\\.", "year": 2010}, {"title": "Distributed constraint optimization with structured resource constraints", "author": ["A. Kumar", "B. Faltings", "A. Petcu"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 923\u2013930.", "citeRegEx": "Kumar et al\\.,? 2009", "shortCiteRegEx": "Kumar et al\\.", "year": 2009}, {"title": "Coordinating logistics operations with privacy guarantees", "author": ["T. L\u00e9aut\u00e9", "B. Faltings"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI). 2482\u2013 2487.", "citeRegEx": "L\u00e9aut\u00e9 and Faltings,? 2011", "shortCiteRegEx": "L\u00e9aut\u00e9 and Faltings", "year": 2011}, {"title": "FRODO 2.0: An open-source framework for distributed constraint optimization", "author": ["T. L\u00e9aut\u00e9", "B. Ottens", "R. Szymanek"], "venue": "In Proceedings of the Distributed Constraint Reasoning Workshop", "citeRegEx": "L\u00e9aut\u00e9 et al\\.,? \\Q2009\\E", "shortCiteRegEx": "L\u00e9aut\u00e9 et al\\.", "year": 2009}, {"title": "Taking DCOP to the real world: Efficient complete solutions for distributed event scheduling", "author": ["R. Maheswaran", "M. Tambe", "E. Bowring", "J. Pearce", "P. Varakantham"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 310\u2013317.", "citeRegEx": "Maheswaran et al\\.,? 2004", "shortCiteRegEx": "Maheswaran et al\\.", "year": 2004}, {"title": "ADOPT: Asynchronous distributed constraint optimization with quality guarantees", "author": ["P. Modi", "Shen", "W.-M.", "M. Tambe", "M. Yokoo"], "venue": "Artificial Intelligence 161, 1\u20132, 149\u2013180.", "citeRegEx": "Modi et al\\.,? 2005", "shortCiteRegEx": "Modi et al\\.", "year": 2005}, {"title": "Distributed Gibbs: A memory-bounded", "author": ["D.T. Nguyen", "W. Yeoh", "H.C. Lau"], "venue": null, "citeRegEx": "Nguyen et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Nguyen et al\\.", "year": 2013}, {"title": "DUCT: An upper confidence bound approach to distributed constraint optimization problems", "author": ["B. Ottens", "C. Dimitrakakis", "B. Faltings"], "venue": "Proceedings of the AAAI Conference on Artificial Intelligence (AAAI). 528\u2013534.", "citeRegEx": "Ottens et al\\.,? 2012", "shortCiteRegEx": "Ottens et al\\.", "year": 2012}, {"title": "A scalable method for multiagent constraint optimization", "author": ["A. Petcu", "B. Faltings"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI). 1413\u2013 1420.", "citeRegEx": "Petcu and Faltings,? 2005", "shortCiteRegEx": "Petcu and Faltings", "year": 2005}, {"title": "MB-DPOP: A new memory-bounded algorithm for distributed optimization", "author": ["A. Petcu", "B. Faltings"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI). 1452\u20131457.", "citeRegEx": "Petcu and Faltings,? 2007", "shortCiteRegEx": "Petcu and Faltings", "year": 2007}, {"title": "PC-DPOP: A new partial centralization algorithm for distributed optimization", "author": ["A. Petcu", "B. Faltings", "R. Mailler"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI). 167\u2013172.", "citeRegEx": "Petcu et al\\.,? 2007", "shortCiteRegEx": "Petcu et al\\.", "year": 2007}, {"title": "MDPOP: Faithful distributed implementation of efficient social choice problems", "author": ["A. Petcu", "B. Faltings", "D.C. Parkes"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 1397\u20131404.", "citeRegEx": "Petcu et al\\.,? 2006", "shortCiteRegEx": "Petcu et al\\.", "year": 2006}, {"title": "An empirical study of phase transitions in binary constraint satisfaction problems", "author": ["P. Prosser"], "venue": "Artificial Intelligence 81, 1-2, 81\u2013109.", "citeRegEx": "Prosser,? 1996", "shortCiteRegEx": "Prosser", "year": 1996}, {"title": "Decentralised coordination of mobile sensors using the Max-Sum algorithm", "author": ["R. Stranders", "A. Farinelli", "A. Rogers", "N. Jennings"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI). 299\u2013304.", "citeRegEx": "Stranders et al\\.,? 2009", "shortCiteRegEx": "Stranders et al\\.", "year": 2009}, {"title": "DCOPolis: a framework for simulating and deploying distributed constraint reasoning algorithms", "author": ["E. Sultanik", "R. Lass", "W. Regli"], "venue": "Proceedings of the Distributed Constraint Reasoning Workshop.", "citeRegEx": "Sultanik et al\\.,? 2007", "shortCiteRegEx": "Sultanik et al\\.", "year": 2007}, {"title": "Generalizing DPOP: Action-GDL, a new complete algorithm for DCOPs", "author": ["M. Vinyals", "J.A. Rodrguez-Aguilar", "J. Cerquides"], "venue": "Proceedings of the International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS). 1239\u20131240.", "citeRegEx": "Vinyals et al\\.,? 2009", "shortCiteRegEx": "Vinyals et al\\.", "year": 2009}, {"title": "BnB-ADOPT: An asynchronous branch-andbound DCOP algorithm", "author": ["W. Yeoh", "A. Felner", "S. Koenig"], "venue": "Journal of Artificial Intelligence Research 38, 85\u2013133.", "citeRegEx": "Yeoh et al\\.,? 2010", "shortCiteRegEx": "Yeoh et al\\.", "year": 2010}, {"title": "Distributed problem solving", "author": ["W. Yeoh", "M. Yokoo"], "venue": "AI Magazine 33, 3, 53\u201365.", "citeRegEx": "Yeoh and Yokoo,? 2012", "shortCiteRegEx": "Yeoh and Yokoo", "year": 2012}, {"title": "Distributed stochastic search and distributed breakout: Properties, comparison and applications to constraint optimization problems in sensor networks", "author": ["W. Zhang", "G. Wang", "Z. Xing", "L. Wittenberg"], "venue": "Artificial Intelligence 161, 1\u20132, 55\u201387.", "citeRegEx": "Zhang et al\\.,? 2005", "shortCiteRegEx": "Zhang et al\\.", "year": 2005}, {"title": "Distributed constraint optimization for teams of mobile sensing agents", "author": ["R. Zivan", "H. Yedidsion", "S. Okamoto", "R. Glinton", "K. Sycara"], "venue": "Autonomous Agents and MultiAgent Systems, 1\u201342.", "citeRegEx": "Zivan et al\\.,? 2014", "shortCiteRegEx": "Zivan et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 17, "context": "Distributed Constraint Optimization Problems (DCOPs) are descriptions of constraint optimization problems where variables and constraints are distributed among a group of agents, and where each agent can only interact with agents that share a common constraint (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012).", "startOffset": 261, "endOffset": 325}, {"referenceID": 20, "context": "Distributed Constraint Optimization Problems (DCOPs) are descriptions of constraint optimization problems where variables and constraints are distributed among a group of agents, and where each agent can only interact with agents that share a common constraint (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012).", "startOffset": 261, "endOffset": 325}, {"referenceID": 29, "context": "Distributed Constraint Optimization Problems (DCOPs) are descriptions of constraint optimization problems where variables and constraints are distributed among a group of agents, and where each agent can only interact with agents that share a common constraint (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012).", "startOffset": 261, "endOffset": 325}, {"referenceID": 16, "context": "For example, DCOPs have been successfully used to model domains like resource management and scheduling (Maheswaran et al. 2004; Farinelli et al. 2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al.", "startOffset": 104, "endOffset": 177}, {"referenceID": 5, "context": "For example, DCOPs have been successfully used to model domains like resource management and scheduling (Maheswaran et al. 2004; Farinelli et al. 2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al.", "startOffset": 104, "endOffset": 177}, {"referenceID": 14, "context": "For example, DCOPs have been successfully used to model domains like resource management and scheduling (Maheswaran et al. 2004; Farinelli et al. 2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al.", "startOffset": 104, "endOffset": 177}, {"referenceID": 6, "context": "2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al. 2005; Zivan et al. 2009; Stranders et al. 2009), and smart grids (Kumar et al.", "startOffset": 49, "endOffset": 163}, {"referenceID": 10, "context": "2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al. 2005; Zivan et al. 2009; Stranders et al. 2009), and smart grids (Kumar et al.", "startOffset": 49, "endOffset": 163}, {"referenceID": 30, "context": "2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al. 2005; Zivan et al. 2009; Stranders et al. 2009), and smart grids (Kumar et al.", "startOffset": 49, "endOffset": 163}, {"referenceID": 25, "context": "2008; L\u00e9aut\u00e9 and Faltings 2011), sensor networks (Fitzpatrick and Meertens 2003; Jain and Ranade 2009; Zhang et al. 2005; Zivan et al. 2009; Stranders et al. 2009), and smart grids (Kumar et al.", "startOffset": 49, "endOffset": 163}, {"referenceID": 13, "context": "2009), and smart grids (Kumar et al. 2009; Gupta et al. 2013).", "startOffset": 23, "endOffset": 61}, {"referenceID": 8, "context": "2009), and smart grids (Kumar et al. 2009; Gupta et al. 2013).", "startOffset": 23, "endOffset": 61}, {"referenceID": 15, "context": "Several popular implementations of DCOP solvers have been created (L\u00e9aut\u00e9 et al. 2009; Sultanik et al. 2007; Ezzahir et al. 2007).", "startOffset": 66, "endOffset": 129}, {"referenceID": 26, "context": "Several popular implementations of DCOP solvers have been created (L\u00e9aut\u00e9 et al. 2009; Sultanik et al. 2007; Ezzahir et al. 2007).", "startOffset": 66, "endOffset": 129}, {"referenceID": 4, "context": "Several popular implementations of DCOP solvers have been created (L\u00e9aut\u00e9 et al. 2009; Sultanik et al. 2007; Ezzahir et al. 2007).", "startOffset": 66, "endOffset": 129}, {"referenceID": 17, "context": "Search-based algorithms perform a distributed search over the space of solutions to determine the optimum (Modi et al. 2005; Gershman et al. 2009; Zhang et al. 2005; Yeoh et al. 2010).", "startOffset": 106, "endOffset": 183}, {"referenceID": 7, "context": "Search-based algorithms perform a distributed search over the space of solutions to determine the optimum (Modi et al. 2005; Gershman et al. 2009; Zhang et al. 2005; Yeoh et al. 2010).", "startOffset": 106, "endOffset": 183}, {"referenceID": 30, "context": "Search-based algorithms perform a distributed search over the space of solutions to determine the optimum (Modi et al. 2005; Gershman et al. 2009; Zhang et al. 2005; Yeoh et al. 2010).", "startOffset": 106, "endOffset": 183}, {"referenceID": 28, "context": "Search-based algorithms perform a distributed search over the space of solutions to determine the optimum (Modi et al. 2005; Gershman et al. 2009; Zhang et al. 2005; Yeoh et al. 2010).", "startOffset": 106, "endOffset": 183}, {"referenceID": 20, "context": "from dynamic programming to propagate aggregate information among agents (Petcu and Faltings 2005; Farinelli et al. 2008; Vinyals et al. 2009); these two classes provide a different balance between memory requirements and number of messages exchanged.", "startOffset": 73, "endOffset": 142}, {"referenceID": 5, "context": "from dynamic programming to propagate aggregate information among agents (Petcu and Faltings 2005; Farinelli et al. 2008; Vinyals et al. 2009); these two classes provide a different balance between memory requirements and number of messages exchanged.", "startOffset": 73, "endOffset": 142}, {"referenceID": 27, "context": "from dynamic programming to propagate aggregate information among agents (Petcu and Faltings 2005; Farinelli et al. 2008; Vinyals et al. 2009); these two classes provide a different balance between memory requirements and number of messages exchanged.", "startOffset": 73, "endOffset": 142}, {"referenceID": 19, "context": "Another class of methods includes approximated algorithms that rely on sampling (Ottens et al. 2012; Nguyen et al. 2013) applied to the overall search space.", "startOffset": 80, "endOffset": 120}, {"referenceID": 18, "context": "Another class of methods includes approximated algorithms that rely on sampling (Ottens et al. 2012; Nguyen et al. 2013) applied to the overall search space.", "startOffset": 80, "endOffset": 120}, {"referenceID": 15, "context": ", the frequently used FRODO platform (L\u00e9aut\u00e9 et al. 2009)) are ad-hoc systems, with a relatively closed structure, and making use of ad-hoc dedicated solvers for constraint handling within each agent.", "startOffset": 37, "endOffset": 57}, {"referenceID": 17, "context": "A DCOP (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012) is described by a tuple P = (X,D,F,A, \u03b1) where: (i) X = {x1, .", "startOffset": 7, "endOffset": 71}, {"referenceID": 20, "context": "A DCOP (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012) is described by a tuple P = (X,D,F,A, \u03b1) where: (i) X = {x1, .", "startOffset": 7, "endOffset": 71}, {"referenceID": 29, "context": "A DCOP (Modi et al. 2005; Petcu and Faltings 2005; Yeoh and Yokoo 2012) is described by a tuple P = (X,D,F,A, \u03b1) where: (i) X = {x1, .", "startOffset": 7, "endOffset": 71}, {"referenceID": 20, "context": "DPOP (Petcu and Faltings 2005) is one of the most popular complete algorithms for the distribution resolution of DCOPs; as discussed in several works, it has several nice properties (e.", "startOffset": 5, "endOffset": 30}, {"referenceID": 23, "context": ", it requires only a linear number of messages), and it has been used as the foundations for several more advanced algorithms (Petcu et al. 2006; Petcu and Faltings 2007; Petcu et al. 2007).", "startOffset": 126, "endOffset": 189}, {"referenceID": 21, "context": ", it requires only a linear number of messages), and it has been used as the foundations for several more advanced algorithms (Petcu et al. 2006; Petcu and Faltings 2007; Petcu et al. 2007).", "startOffset": 126, "endOffset": 189}, {"referenceID": 22, "context": ", it requires only a linear number of messages), and it has been used as the foundations for several more advanced algorithms (Petcu et al. 2006; Petcu and Faltings 2007; Petcu et al. 2007).", "startOffset": 126, "endOffset": 189}, {"referenceID": 9, "context": ", (Hamadi et al. 1998)) to support the distributed construction of a DFS-Pseudo-tree.", "startOffset": 2, "endOffset": 22}, {"referenceID": 2, "context": "Given a node N , the UTIL message sent by N summarizes the maximum utility achievable within the subtree rooted at N for each combination of values of variables belonging to the separator set (Dechter 2003) of N .", "startOffset": 192, "endOffset": 206}, {"referenceID": 9, "context": "protocol (Hamadi et al. 1998), that creates a DFS tree with the max-degree heuristic as the variable-ordering heuristic.", "startOffset": 9, "endOffset": 29}, {"referenceID": 15, "context": "The first one follows the model illustrated in Fig 3: the input DCOP is described using the standardized format introduced by the FRODO DCOP platform (L\u00e9aut\u00e9 et al. 2009).", "startOffset": 150, "endOffset": 170}, {"referenceID": 1, "context": "The current implementation of LP-DPOP makes use of the Linda (Carriero et al. 1994) infrastructure of SICStus Prolog (Carlsson et al.", "startOffset": 61, "endOffset": 83}, {"referenceID": 15, "context": "We compare two implementations of the LP-DPOP framework, LP-DPOP and LPDPOP with a publicly-available implementation of DPOP, which is available on the FRODO framework (L\u00e9aut\u00e9 et al. 2009).", "startOffset": 168, "endOffset": 188}, {"referenceID": 26, "context": "The runtime of the algorithms are measured using the simulated runtime metric (Sultanik et al. 2007).", "startOffset": 78, "endOffset": 100}, {"referenceID": 3, "context": "Randomized Graphs: A randomized graph generated using the model in (Erd\u00f6s and R\u00e9nyi 1959) with the input parameters n (number of nodes) and M (number of binary edges) will be used as the constraint graph of a DCOP instance P.", "startOffset": 67, "endOffset": 89}, {"referenceID": 11, "context": ", load shedding, demand response, restoration) (Jain et al. 2012).", "startOffset": 47, "endOffset": 65}, {"referenceID": 11, "context": "The initial configuration of the CDMG and the precise equations used in the generation of the problems can be found in (Jain et al. 2012).", "startOffset": 119, "endOffset": 137}], "year": 2014, "abstractText": "The field of Distributed Constraint Optimization Problems (DCOPs) has gained momentum, thanks to its suitability in capturing complex problems (e.g., multi-agent coordination and resource allocation problems) that are naturally distributed and cannot be realistically addressed in a centralized manner. The state of the art in solving DCOPs relies on the use of ad-hoc infrastructures and ad-hoc constraint solving procedures. This paper investigates an infrastructure for solving DCOPs that is completely built on logic programming technologies. In particular, the paper explores the use of a general constraint solver (a constraint logic programming system in this context) to handle the agent-level constraint solving. The preliminary experiments show that logic programming provides benefits over a state-of-the-art DCOP system, in terms of performance and scalability, opening the doors to the use of more advanced technology (e.g., search strategies and complex constraints) for solving DCOPs.", "creator": "LaTeX with hyperref package"}}}