{"id": "1405.3272", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2014", "title": "Fast and Fuzzy Private Set Intersection", "abstract": "Private Set Intersection (PSI) instance being mandate from turned multiple of interface duel between use, older the present it cryptographic PSI started a convenient fashion: time ends only needs came be accessing once, from which time pair of programmers go few came round of ordinary allowing surprising. This turn be orders mainly earthquake dramatically although all PSI at created increased addition with \" bespeaks \" in with pair, is fall indicated be nonexistent directly even comparatively. This is considerable in taken this alone the sets consist instance English words raw with WordNet.", "histories": [["v1", "Tue, 13 May 2014 19:38:58 GMT  (117kb)", "https://arxiv.org/abs/1405.3272v1", "20 pages, 6 figures, plus source code"], ["v2", "Wed, 21 May 2014 02:51:41 GMT  (117kb)", "http://arxiv.org/abs/1405.3272v2", "20 pages, 6 figures, plus source code"]], "COMMENTS": "20 pages, 6 figures, plus source code", "reviews": [], "SUBJECTS": "cs.CR cs.CL", "authors": ["nicholas kersting"], "accepted": false, "id": "1405.3272"}, "pdf": {"name": "1405.3272.pdf", "metadata": {"source": "CRF", "title": "Fast and Fuzzy Private Set Intersection", "authors": ["Nicholas Kersting"], "emails": ["1054h34@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n32 72\nv2 [\ncs .C\nR ]\n2 1\nM ay\n2 01\n1Email: 1054h34@gmail.com"}, {"heading": "1 Introduction", "text": "Private Set Intersection (PSI) is a process wherein two or more parties compare sets to mutually discover their intersection without revealing anything else about the sets [1, 2, 3, 4]. Though important potential applications abound in e.g. medicine, finance, and networking, a convincingly practical realization of PSI has yet to surface. State-of-the-art techniques employ a series of interaction rounds between users with compound encryptions of their sets [5, 6], typically taking O(102) milliseconds to compare small sets consisting of a few hundred elements. This situation is particularly acute in the context of smartphone apps, where we have probably the most exciting and relevant use cases of PSI [7, 8], but the severe CPU and memory constraints there slow the performance of existing PSI algorithms to seconds or minutes.\nThis paper introduces an algorithm to implement PSI in a different way: sets are first encrypted and then compared in one round as ordinary sets. This promises to be orders of magnitude faster than ordinary PSI in situations where set content is unvarying over many comparisons, e.g. as would occur in social matchmaking applications, for then the cost of encryption is amortized over the many comparison operations. Since the encryption only needs to be done once on the input set after which it can be compared any number of times to other sets, these encryptions enjoy the ability to be stored, ported, or subjected to additional layers of security as desired. Moreover, the technique is naturally suited to sets of extended elements, for example English words, where intersection is not best expressed as a binary \u201cyes/no\u201d but rather as a continuous score between 0 and 1.\nIn this algorithm speed is attained at the cost of an inherent uncertainty or \u201cfuzziness\u201d in the comparison process: the resultant intersection between the sets will generally contain false positives (but no false negatives), however these can be reduced to a tolerable level by methods privy to the particular application at hand. At the same time, this fuzziness actually assists as a guard against bruteforce decryption, which in addition to being NP-hard thus also produces too many irreducible false positives to be informational. Fuzziness is therefore more of a feature than a liability of the algorithm.\nThe following exposition will define the encryption technique, apply it to an intuitive geometrical toy example, and then show relevant metrics for a more serious application to the comparison of English messages parsed with WordNet [9]. Finally, there will be a brief discussion of potential use cases and future outlook."}, {"heading": "2 Proposed Algorithm", "text": ""}, {"heading": "2.1 Encryption", "text": "The algorithm begins by encrypting each of the two sets to be compared. Since the encryption procedure is the same for each set, let us focus on one of them, denoted W .\nThough W may in general consist of elements of any type (e.g. strings, integers,\nfloats, etc.) we will assume they are drawn from members of a particular master set X , i.e. W \u2261 {w1, w2, ..., wN} with W \u2286 X \u2261 {x1, x2, ..., xP}, P \u2265 N .\nWe will also need a map M defined which takes any x in X to a set of integers \u2126x, valued in R \u2261 [0, Imax], for some large positive integer Imax, i.e. M : x \u2192 \u2126x. In particular,\nM : wi \u2212\u2192 \u2126i\n\u2261 {\u2126i1, \u2126i2, ...,\u2126ipi}\nwith \u2126ip being the p-th element of \u2126i. Then the encryption Sn of W , for a configurable parameter n that controls the strength of the encryption, is defined as the set\nSn \u2261 {\u2126i1p1 + \u2126i2p2 + ...+ \u2126inpn}1\u2264i1<i2<...<in\u2264N ; p1, p2,...pn (1)\nwith duplicate elements removed (this turns out to be important for storage and security purposes later). This is hereafter known as \u201cn-Sum Encryption\u201d. Note that for Sn to be defined we require W to have at least n elements, i.e. N \u2265 n.\nThe simplest variant, n = 1, gives a set S1 consisting of the union of all the \u2126i:\nS1 \u2261 {\u2126i}i\u2264N (2)\nFor n = 2 the encryption set is the set of all sums of pairs of integers, each originating from a different \u2126i:\nS2 \u2261 {\u2126ip + \u2126jq}i<j\u2264N ; p, q (3)\nFor n = 3 all triplet combinations must be computed:\nS3 \u2261 {\u2126ip + \u2126jq + \u2126kr}i<j<k\u2264N ; p, q, r (4)\nThis pattern extends to higher values of n where one computes quartets, quintets and so on. For n > 1 we have a legitimate encryption procedure because it is much easier to sum several numbers than to uniquely reconstruct them from that sum, this being essentially the NP-hard \u201csubset sum problem\u201d (Appendix A contains an explicit Python script to perform the encryption which we will make use of later in Section 4).\nBreaking the encryption, i.e. inferring W from Sn given knowledge of M , requires brute-force search2 and depends strongly on n and \u2126.3 For S2, for example, brute force decryption requires iterating over all pairs (x, y) in R and testing for inclusion of {\u2126xp+\u2126yq}p,q in S2, which has quadratic O(I 2 max) time complexity. In addition, a certain combinatorial uncertainty arises in this procedure, for {\u2126xp +\u2126yq}p,q may be included in S2 without either \u2126xp or \u2126yq being included in any of the \u2126i mapped from\n2As noted, S1 is not very secure as it suffices to walk through each integer x in R and test \u2126x for inclusion in S1. This can be done in linear O(Imax) time.\n3For example, in the degenerate case where \u2126i \u2261 \u2126 \u2200i, we always have S1 = \u2126 for any input set W , thus we can infer nothing about it. The other extreme is where \u2126i \u22c2 \u2126j = 0 \u2200i, j, and the information of Sn is maximized. Indeed here we can uniquely reconstruct W from S1.\nW , i.e. one can expect false positives which are in general irreducible by the subset sum problem, for knowing a sum of two or more integers does not in general uniquely identify those integers, even if one knows the set from which they are drawn.\nIn general, brute force decryption of Sn would require both searching the space of all n-tuplets in R, taking O(Inmax) time\n4, as well as dealing with worsening combinatorial uncertainty; already for n \u2265 3 and Imax > 10\n8 commodity hardware would really struggle to search n-tuple space (which here is the size of Avogadro\u2019s number!), and then only to be swamped with false positives."}, {"heading": "2.2 Finding the Intersection", "text": "The goal of PSI is for the two users to discover the intersection of their respective private sets W and W \u2032. To do this they simply measure the intersection of their encrypted sets Sn and S \u2032 n: by construction if both private sets share at least n elements in common, even partially, this intersection will be non-empty and each user can easily find which n-tuple(s) are responsible for that intersection, and to what extent. In the process of computing Sn, for example, the user can build an inverted dictionary mapping elements of Sn to lists of elements from the {\u2126i}. Then knowing Sn \u22c2 S \u2032n identifies a subset of Sn which the dictionary then maps to a set of elements Y , and we can assign a \u2018matching score\u2019 to each of the original elements wi given by the ratio |Y \u22c2 \u2126i|\n|\u2126i| ."}, {"heading": "3 A Geometrical Application", "text": "As a toy example, consider the problem of privately determining the geometric intersection of two groups of shapes (see Figure 1, and Appendix B for generating code), assumed rectangular for simplicity though the discussion below will apply just as well to any shape. This might represent two countries (\u2018Blue\u2019 and \u2018Orange\u2019) which each want to secretly establish a certain number colonies of various sizes in a given territory without overlapping with each other, as such overlapping is presumed to be mutually disadvantageous. It\u2019s in the best interest of each country to know what the potential conflict areas are, but neither is willing to disclose any other information about the locations and sizes of their colonies. Here the private sets are the respective colonies (wi, 1 \u2264 i \u2264 N), each of which is mapped to a collection of grid points (\u2126i), suitably hashed\n5, that compose the rectangular areas. For example, a colony centrally located at (10, 10) with a width and height of 3 might be mapped\n4the number of terms contributing to Sn increases like N n C \u2248\nNn\nn! .\n5There are several choices here: the trivial hash, i.e. simply numbering coordinate points from 1 to M (= number of grid points in the territory), a flat random hash assigning each coordinate to a random number between 1 and Imax, or a custom hash taking coordinates to some values with a given distribution. The trivial hash gives poor results because of a low Imax, e.g. for S2 all bi-sums are between 0 and 2M and most are degenerate at the peak of a pyramid-shaped distribution; one does better for a flat random hash with a much larger choice of Imax, or a custom hash designed such that the distribution of hash values results in a flat distribution of bi-sums.\nto 9 numbers representing the enclosed coordinate points:\n\u2126{(10,10),3,3} = {a1, a2, a3, a4, a5, a6, a7, a8, a9}\nwhile another located at (12, 12) with the same width and height would be\n\u2126{(12,12),3,3} = {a9, a10, a11, a12, a13, a14, a15, a16, a17}\noverlapping at exactly one point (a9) as expected. With each country agreeing to the same standard map M : colony \u2192 \u2126, they can proceed to compute their respective Sn and compare these sets to discover their planned colonies\u2019 intersection.\nFor definiteness let the countries compare S2 computed over their respective colonies. It is now a straightforward procedure for each to map the intersection\nback to the original points (encoded in the \u2126i) to determine which of these led to the intersection: the upper plots of Figure 2 show these candidate points in black. There are false positives in this procedure forming a certain combinatorial background, or \u2018fuzziness\u2019, but no false negatives: if a point is not black, it definitely is not in the actual intersection of the colonies. This stage of the comparison may already be useful if Orange and Blue simply want to know which parts of their planned colonies would definitely not be overlapping. But we can do better, for in this case we have a geometrical way of filtering out most of the false positives: since we know the colonies are rectangular (and say of a given minimum size, here taken as 5 grid units), candidate points must compose rectangular regions of at least that minimum size. After this filtering, each country obtains a much cleaner representation of the overlap without learning anything else about the other country\u2019s colonies (lower plots of Figure 2), which by comparison to Figure 1 the reader can verify is quite accurate. If we wanted to report a matching score for each shape, that would simply be given by the ratio of black to non-black area.\nEach country\u2019s S2 is safe against brute-force decryption, which would involve not only generating a look-up table of encrypted values to points6, but then trying\n6In this toy example this is actually easy, as there are only M = 50\u00d7 50 = 2500 possible hashed grid points, thus in principle M2 C = 3 million possible sums (rows in the table).\nto back-solve to find all the candidate points responsible for the observed S2. As long as the maximum hash value Imax is sufficiently small the vast majority of the sample space will be candidate points and very little information is gleaned (see Figure 3). Note that if Imax is too small then the matching procedure between the countries likewise becomes uninformative (by the Central Limit Theorem sums between random integers tend to cluster about a central value7), so for a given setup there is an optimal value that provides good discrimination for matching but poor discrimination for brute-force decryption; for the parameters of the present toy model that balance is struck at roughly Imax = 10 8."}, {"heading": "4 Application to Message Comparison", "text": "The motivating application is the comparison of text messages. Like the colonies of the toy example above, words are intrinsically extended objects that can overlap with each other, but in semantic space instead of geometric space, e.g. the word\n7But see a prior footnote about choice of distribution.\n\u201cfast\u201d shares some semantic overlap with \u201cquick\u201d, \u201chasty\u201d, and \u201cinstant\u201d, all in differing amounts, and WordNet provides the map from a word wi to its \u201csemantic territory\u201d \u2126i that allows us to compute that overlap. Specifically, each \u2126i is a collection of synonym sets (\u201csynsets\u201d for short) that are represented by a particular positive integer (\u201coffset\u201d in WordNet parlance)8; they are the result of extensive linguistic research and generally \u201cmake sense\u201d, i.e. given any three words x, y, and z, if x is semantically closer to y than to z, then typically |\u2126x \u2229\u2126y| > |\u2126x \u2229\u2126z|. It is useful to keep the analogy to the geometrical application of the last section in mind with the correspondences of country \u2192 message, colony \u2192 word, and coordinate \u2192 synset integer, for we really have the same problem in a different guise, i.e. we are considering the problem of how two users can compare messages in order to discover their words\u2019 semantic intersection only.\nGiven an English message then, we map the words to the appropriate numerical identifiers and apply the cryptographic hash Sn. Note that applying this encryption to messages is implicitly using the \u201cBag of Words\u201d NLP model wherein word order, grammar, and punctuation are ignored. Despite the crudeness of that model, one can reliably match large classes of messages, in particular those whose meaning is invariant upon permutation of their words, e.g. \u201cwithdraw money tomorrow noon\u201d, \u201cagriculture thesis topic\u201d, etc. In fact the set Sn applied to the whole message is equivalent to Sn applied to all possible n-grams constructed from words in the message.\nLet us consider a simple, if somewhat contrived example that we can compute by hand:\nMessage 1: \u201cLaser reheat cappuccino\u201d\nMessage 2: \u201cLaser reheat espresso\u201d\nEach word belongs to a particular synset,\n\u201claser\u201d = w1 \u2261 3643253\n\u201creheat\u201d = w2 \u2261 544280\n\u201ccappuccino\u201d = w3 \u2261 7920349\n\u201cespresso\u201d = w4 \u2261 7920052\n8The actual \u2126i we use here are computed from the WordNet database as follows: for a given word wi, we first find all the synsets that contain that word, and for each of these we look up all of their associated synsets, excepting those of type \u201cantonynm\u201d. Thus \u2126i includes all synsets up to two links removed from wi.\nand we look up the mapping to other synsets in WordNet:\n\u21261 = {3643253,3851341,3924532}\n\u21262 = {371264,544280}\n\u21263 = {7920349,7929519}\n\u21264 = {7920052, 7920222, 7929519}\nthe bold-faced synsets being common to both messages. Following (3), we have what we need to compute S2 for each message:\nS2 = {4014517, 4187533, 4222605, 4295796, 4395621, 4468812, 8291613, 8300783,\n8464629, 8473799, 11563602, 11572772, 11771690, 11780860, 11844881, 11854051}\nS\u20322 = {4014517, 4187533, 4222605, 4295796, 4395621, 4468812, 8291316, 8291486,\n8300783, 8464332, 8464502, 8473799, 11563305, 11563475, 11572772, 11771393,\n11771563, 11780860, 11844584, 11844754, 11854051}\nS2 \u22c2 S\u20322 = {4014517, 4187533, 4222605, 4295796, 4395621, 4468812, 8300783, 8473799,\n11572772, 11780860, 11854051}\nHere S2 has 16 keys, S \u2032 2 has 21, and S2 \u22c2 S \u20322 has 11, giving each message an \u201coverlap\u201d percentage of 11/16 \u2248 69% and 11/21 \u2248 52%, respectively. In this simple example each user can easily determine exactly which synsets in their respective \u2126i contributed to that overlap (the bold values) by keeping track with an inverted dictionary; in this case there is no uncertainty, and thus we say the \u201cconfidence\u201d of matching is 100%.\nBrute-force decryption of S2 would again require not only the costly construction of a look-up table9 but also some way to deal with the inherent combinatorial uncertainty of this process. For example, supposing we wished to brute-force decrypt the more embellished message \u201cUS car production blue sapphire laser millisecond pulse reheat\u201d, which has 62461 keys: in addition to the message\u2019s actual words, it turns out the brute-force decryption also returns hundreds of red herring match results for words like \u201cno-go\u201d, \u201ckeyless\u201d, \u201cbrainwashed\u201d, and \u201cbaptised\u201d. This is analogous to what brute-force decryption did for us in the geometrical example of the last section, i.e return the almost non-informational Figure 3 which basically says that most points are possibly in the intersection.\nIn the toy geometrical example we learned that the matching procedure produces many false positives in addition to real positives, and that there was a simple way to\n9In this case for S2 this is still doable, barely: there are M \u2248 1.5 \u00b7 10 5 words in WordNet3.1, thus in principle M2 C = 10 billion possible sums to tabulate; this might fit in the memory of a commodity server. Doing the same for S3 and beyond would quickly become impractical, however.\nfilter out the false positives based on geometrical constraints on the way the rectangular shapes can overlap. Unfortunately in the present case there is no such obvious filter we can apply: the synsets that represent a word are not localized into any special \u201cshapes\u201d in a way that we can leverage, so we\u2019re stuck with false positives in this procedure10. However, it does turn out that the number of positives (both real and false) is inversely correlated with the number of false positives. For example, measurement of hundreds of randomly-generated pairs of 10-word messages encrypted with S2 (see Figure 4) indicates that an overlap between messages above 1% essentially guarantees an absence of false positives, hence a high degree of confidence in the synsets extracted from this procedure. This is in tune with our expectations for a system with inherent uncertainty: the larger signal (overlap) available, the higher one\u2019s confidence in conclusions based on that signal."}, {"heading": "4.1 Encryption Storage", "text": "The space required to store an encryption Sn is not entirely negligible. For averagelength messages encrypted with S2 one typically produces a list of thousands of keys (i.e 10-100 KB), and this increases exponentially at higher encryption levels (see Figure 5). The \u201cUS car production blue sapphire laser millisecond pulse reheat\u201d example as a text file is over 500K, though with bit packing the 62461 keys (each a 32-bit int) it really only needs half that space. Standard compression tools can further reduce that by a factor of several [10]; in this way most encrypted messages typically take the space of a thumbnail image."}, {"heading": "4.2 Encryption Speed", "text": "Encryption of a set only has to occur once in this algorithm, and this constitutes the bulk of the overall time spent. Comparison to other sets then follows intersection algorithms on sorted sets, which are fast: sub-ms for small (< 104 elements) to 10 ms for large sets with millions of elements [11]. Figure 6 below shows upper-bound timing metrics for encryption \u2013 note these are non-optimized single-threaded speeds, whereas the algorithm is in fact highly parallelizable (e.g. each n-tuple combination in (1) can run on its own thread), so these times could easily be an order of magnitude smaller in a production environment.11 For all but the highest levels of encryption (S4 and higher) this initial runtime overhead is comparable to what current PSI techniques use in every set comparison. For situations where one set will be compared multiple times to other sets, this overhead is amortized over the number of comparisons performed\n10Note we could redefine the synset numbers to give a more even sum distribution, e.g. to optimize for S2 we choose the distribution of synset numbers such that the distribution of bi-sums is approximately flat. As the distribution of synset numbers in WordNet is approximately flat, i.e. \u03c1(x) \u223c 1, there is potential for improvement if we redistributed according to something like \u03c1(x) \u223c 1\u221a\nx + 1\u221a Imax\u2212x .\n11Encryption metrics are reported here with non-optimized Python code, show in Appendix A, not only for both human readability and portability, but also to deliberately produce pessimistic results.\nand we thus quickly attain a speed limited only by ordinary set comparison, which as mentioned is at least two orders of magnitude faster than current PSI techniques."}, {"heading": "5 Use Cases for Fast PSI", "text": "Private Set Intersection techniques promise to enjoy a large number of potential applications, but these are made more feasible by a fast protocol such as the one proposed. In the social domain, i.e. interest matchmaking, it is quite likely that users will offer a much more liberal set of interests than they currently do with public protocols owing to the reassurance that non-matching interests will not be revealed to anyone. The fact that their private lists can be persistently stored in encrypted form removes the need for a simultaneous transfer protocol: one-sided matching is a very fast and practical option. A few examples:\n\u2022 Privacy-Preserving Social Networking: users compare lists of private profile descriptors to make relevant new connections.\n\u2022 Advertising: marketers compare a list of potential features of the ad with consumers\u2019 private lists of interests in order to predict the ad\u2019s success.\n\u2022 Scientific Collaboration: researchers compare lists of key words to find potential collaborators on a topic without announcing their idea or intentions to the public and risk being scooped.\n\u2022 Employee Complaint Forum: employees compare lists of concerns to determine whether a threshold commonality of complaints is reached, prompting management for reform with minimal danger of incrimination.\n\u2022 Social Organizing: individuals compare lists of place+time+topic in order to effect a spontaneous social gathering.\n\u2022 Meeting Agendas: participants submit private lists of desired topics, and the overlap is used to draw up an agenda.\n\u2022 Corporate Benchmarking: companies compare confidential lists of assets to determine ranking (a sort of generalization of Yao\u2019s \u201cMillionaire Problem\u201d [12]).\nOn larger organizational or governmental scales there are many more promising applications, e.g.\n\u2022 Medicine: patients\u2019 medical records are compared to a specific \u2018filter list\u2019 in order to identify and process records without accessing them in entirety.\n\u2022 Law Enforcement: a federal agency needs to compare its confidential list of suspects with some other institution\u2019s likewise confidential list of registrants.\n\u2022 Personalization: multi-component systems can compare lists of users\u2019 attributes to certain criteria in order to identify recurrent users and provide a personalized experience.\n\u2022 Routing Optimization: network nodes compare lists of private attributes such as capacity and flow constraints in order to determine a globally optimal routing.\n\u2022 Central Command Processing: a central unit can publicly broadcast a single command (encrypted list of goal keywords) which worker-units compare with their own private list of qualifications in order to effect the appropriate action, maximizing communication efficiency and security."}, {"heading": "6 Conclusions and Remarks", "text": "This paper introduces a new Private Set Intersection technique using n-Sum encryption that should be many times faster than current techniques when any given set is likely to undergo multiple comparisons in its lifetime. The speed increase is due to the fact that, after an initial one-time encryption of each set, all subsequent comparisons proceed by ordinary comparison of ordered sets, and many well-studied fast algorithms exist for this.\nThe technique is mathematically simple and flexible in that one has a choice of which mapping of set elements M : x \u2192 \u2126 to use. Specifying the technique in terms of an abstract map M has the advantage of decoupling: different choices of M , be they versions of WordNet or customized hashes, can be tailored to the application in hand. In general M is chosen to make reporting of partial intersection between set elements feasible and meaningful, with the traditional binary \u2018yes/no\u2019 reporting a result of choosing a trivial \u2126, i.e. M : x \u2192 x. As this is mostly a proof-of-concept paper, the technique is likely to be highly optimizable, leveraging especially the highly-parallelizable nature of the algorithm, and adaptable to different technologies.\nSecurity in n-Sum encryption is configurable: while S1 uncovers the bare content of the sets, S2 and S3 offer security at a level which is probably sufficient for casual PSI, while S4 and S5 may be suitable for more sensitive (e.g. financial and governmental) applications of PSI. Malicious brute-force decryption, or equivalently submitting a huge set of every possible element to troll for matches, doesn\u2019t pay: not only does the computational burden become formidable for S3 and above, but a huge set intersected with a small one has a very low percentage-wise overlap, so (e.g. Figure 4) the intersection will contain mostly false positives. The most effective matching is expected to be a small submission against another small submission, so this technique is ideal for finding rare matches between users in a large pool that otherwise wouldn\u2019t easily find each other.\nUncertainty or \u2018fuzzy matching\u2019 is a side effect which may actually be advantageous. Oftentimes communication does not require exact clarity, but rather approximate accuracy on the first pass.12 Furthermore, as we saw above fuzziness makes brute-force decryption much harder to interpret.\nFinally, one can imagine various usage scenarios: in one scenario there is a public file server where one can freely upload and download (encrypted) sets [14]; the server\n12\u2018Hearsay\u2019 is also a fuzzy mode of communication which enjoys the features of being certain enough to be highly useful in daily life, but too uncertain to be used in court to reap punishment. It is safe, cheap talk. Such modes of communication probably naturally evolve in systems to optimize collective results [13].\nthus might maintain a directory of all submissions, a mix of sets encrypted with different security levels and different M , perhaps, and anyone can intersect with their own set and initiate an exchange. At the opposite extreme, a closed boardroom-type scenario would utilize a small private server to collect and compare submissions from invited participants. Also, in the scenario of a location-based smartphone app, one might initiate a Bluetooth exchange with other nearby devices subject to certain constraints, e.g. set size, security level, user identity/trustworthiness, and of course proximity."}, {"heading": "Appendix A: n-Sum Encryption", "text": "The following runs in Python 2.6.7\n# N-Sum encryption for any N # BEFORE RUNNING: put this script and \"omegaO2.txt\" # (https://github.com/nkersting/WordNet) in the same directory. # USAGE: Simply run this script and, when prompted, enter the message # you wish to encrypt. # OUTPUT: Sorted list of encryption keys written to \"keys.txt\", one per line ################################################################## # This script produces usable sum-encrypted messages, but there are still some # additional needed improvements. For example, # 1. tokenization, e.g. handle punctuation (note convert \"read.\" to \"read\" # but not \"U.S.\" to \"U.S\") # 2. lemmatization, e.g. convert plural nouns to singular (WordNet has no plurals) # 3. hash words not in the dictionary to unused unique integers # (WordNet uses integers between 0 and roughly 1.6*10^7) # 4. compound words (connected with \"_\") # 5. Part of Speech differentiation\nimport csv import shlex\n################################################################### def MapEntry(entryword, syndict, stopwords):\nif (syndict.has_key(entryword) and entryword not in stopwords):\nreturn syndict[entryword]\nelse:\nreturn []\n################################################################### def SumWordsDFSRecursive(currwords, index, syndict, stopwords, sublist, sumdict):\nif index == len(currwords):\ntotal = sum(sublist) # key computed here if (sumdict.has_key(total) == False):\nsumdict[total] = []\nfor item in sublist:\nsumdict[total].append(item) # build the inverted dictionary\nreturn\nfor entry in MapEntry(currwords[index], syndict, stopwords):\ntemplist = sublist[:] templist.append(entry) SumWordsDFSRecursive(currwords, index+1, syndict, stopwords, templist,\nsumdict)\nreturn\n################################################################### def SumNEncrypt(userwords, currwords, syndict, stopwords, N, sumdict):\nif len(currwords) == N:\nsublist = [] SumWordsDFSRecursive(currwords, 0, syndict, stopwords, sublist, sumdict) return\nfor i in range(0, len(userwords)): # iterate over all n-element combinations\nnewwords = currwords[:] newwords.append(userwords[i]) SumNEncrypt(userwords[i+1:], newwords, syndict, stopwords, N, sumdict)\nreturn\n################################################################### def main():\nN = 2 # change this for the desired security level sN stopwords = [] # append words to ignore, such as \"a\", \"the\", \"it\", etc. synfile = \"omegaO2.txt\" # map file defines M: x -> Omega_x outfile = open(\"keys.txt\", \"w\") # output as a text file, one key per line\nsynReader = csv.reader(open(synfile,\u2019rb\u2019), delimiter=\u2019 \u2019) # read map file syns = [] for synline in synReader:\nsyns.append(synline)\nsyndict = {} # convert to a dictionary for faster access for entryline in syns:\nsyndict[entryline[0]] = [int(x) for x in entryline[1:]]\nusertext = raw_input(\u2019Message to encrypt: \u2019) # user input userwords = shlex.split(usertext)\nsumdict = {} SumNEncrypt(userwords, [], syndict, stopwords, N, sumdict) # encryption here\nfor key in sorted(sumdict.keys()): # write output with one sum per line\noutfile.write(str(key) + \u2019\\n\u2019)"}, {"heading": "Appendix B: Overlapping Shapes Code", "text": "This was used for the toy example in Section 3\ndef RandRect(collection, worldDim):\nmaxDim = 10 minDim = 5 passed = False while (not passed):\npassed = True x = random.randint(1, worldDim - maxDim) # ensure colonies inside borders y = random.randint(1, worldDim - maxDim) width = random.randint(minDim, maxDim) height = random.randint(minDim, maxDim) for member in collection:\nx2 = member[0] y2 = member[1] width2 = member[2] height2 = member[3] if (x + width >= x2 and # ensure each country\u2019s colonies\ny <= y2 + height2 and # non-self-intersecting y + height >= y2 and x <= x2 + width2):\npassed = False\ncollection.append((x,y,width,height)) return\n#################################### def MakeHash(worldDim): # hash sequence to large unused integers\nmaxHash = 100000000 # store the reverse hash as well topInt = worldDim * worldDim # maxHash must be chosen large enough used = set() # to make the encryption give useful results, posHash = {} # but not so large that decryption easily revHash = {} # betrays the input set\nfor i in range(1, topInt + 1):\npassed = False while (not passed):\nkey = random.randint(1,maxHash) if (key not in used):\nused.add(key) posHash[i] = key revHash[key] = i passed = True\nreturn posHash, revHash\n################################### def MakeSumDict(posHash): # constructs look-up dictionary\nsumToPoints = {} # for brute-force decryption allkeys = posHash.keys()\nfor i in range (0, len(allkeys)):\nfor j in range (i, len(allkeys)):\ns = posHash[allkeys[i]] + posHash[allkeys[j]] if (sumToPoints.has_key(s) == False):\nsumToPoints[s] = []\nsumToPoints[s].append(allkeys[i]) sumToPoints[s].append(allkeys[j])\nreturn sumToPoints\n#################################### def MapSumsToPoints(sumlist, sumToPoints):\ncandidates = set() for s in sumlist:\nfor v in sumToPoints[s]:\ncandidates.add(v)\nreturn candidates\n############################### def FillColonyOmega(colonies, positionHash, worldDim):\nomega = {} count = 0 for colony in colonies:\ncount += 1 vals = [] for i in range(0,colony[2]):\nfor j in range(0,colony[3]):\nvals.append(positionHash[colony[0] + i + worldDim*(colony[1] + j)])\nomega[str(count)] = vals\nreturn omega\n########################################## def PointToCoords(point, worldDim):\nx = point % worldDim y = point / worldDim return x, y\n################################## def main():\nN = 10 # number of colonies in each collection worldDim = 50 # number of grid units on each side of the world\nrandom.seed()\nusertext = \"\" for i in range (1, N+1): # fake \u2019message\u2019\nusertext += (str(i) + \u2019 \u2019) # describing the colonies 1 .. N\nuserwords = shlex.split(usertext)\n# hash from coordinate position to particular random int positionHash, reverseHash = MakeHash(worldDim)\ncolonies1 = [] for i in range(0,N):\nRandRect(colonies1, worldDim)\ncolonies2 = [] for i in range(0,N):\nRandRect(colonies2, worldDim)\nomega1 = FillColonyOmega(colonies1, positionHash, worldDim) omega2 = FillColonyOmega(colonies2, positionHash, worldDim)\nsumdict1 = {} stopwords = [] SumNEncrypt(userwords, [], omega1, stopwords, 2, sumdict1)\nsumdict2 = {} stopwords = [] SumNEncrypt(userwords, [], omega2, stopwords, 2, sumdict2)\nsumlist1 = set(sumdict1.keys()) sumlist2 = set(sumdict2.keys()) overlap = sumlist1.intersection(sumlist2) # keys in the intersection\nencryptedPoints1 = set() # true and false positives here encryptedPoints2 = set() for commCrypt in overlap:\nfor comm in sumdict1[commCrypt]:\nencryptedPoints1.add(comm)\nfor comm in sumdict2[commCrypt]:\nencryptedPoints2.add(comm)\ntrue1 = set() # S_1 for one colony for key in omega1.keys():\nfor val in omega1[key]:\ntrue1.add(val)\ntrue2 = set() for key in omega2.keys():\nfor val in omega2[key]:\ntrue2.add(val)\ntrueoverlap = true1.intersection(true2) # these is the actual intersection\nfirstCollection = [] # coordinates of apparent intersection for point in encryptedPoints1:\nx, y = PointToCoords(reverseHash[point], worldDim) firstCollection.append([x,y,1,1])\nsecCollection = [] for point in encryptedPoints2:\nx, y = PointToCoords(reverseHash[point], worldDim) secCollection.append([x,y,1,1])\ndecryptCollection = [] # coordinates of brute-force decrypted intersection sumDict = MakeSumDict(positionHash) candidates = MapSumsToPoints(sumlist1, sumDict) for c in candidates:\nx, y = PointToCoords(c, worldDim) decryptCollection.append([x,y,1,1])"}], "references": [], "referenceMentions": [], "year": 2014, "abstractText": "Private Set Intersection (PSI) is usually implemented as a sequence of encryption rounds between pairs of users, whereas the present work implements PSI in a simpler fashion: each set only needs to be encrypted once, after which each pair of users need only one ordinary set comparison. This is typically orders of magnitude faster than ordinary PSI at the cost of some \u201cfuzziness\u201d in the matching, which may nonetheless be tolerable or even desirable. This is demonstrated in the case where the sets consist of English words processed with WordNet. Email: 1054h34@gmail.com", "creator": "LaTeX with hyperref package"}}}